{"sha": "bed6869865ccfc6e72be26cb2041d83ab5cdbe3c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlZDY4Njk4NjVjY2ZjNmU3MmJlMjZjYjIwNDFkODNhYjVjZGJlM2M=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-11-26T19:56:07Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-11-26T19:56:07Z"}, "message": "Cleanup", "tree": {"sha": "94929e320d14ae8829f807ff83824fb94f44c375", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/94929e320d14ae8829f807ff83824fb94f44c375"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bed6869865ccfc6e72be26cb2041d83ab5cdbe3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bed6869865ccfc6e72be26cb2041d83ab5cdbe3c", "html_url": "https://github.com/rust-lang/rust/commit/bed6869865ccfc6e72be26cb2041d83ab5cdbe3c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bed6869865ccfc6e72be26cb2041d83ab5cdbe3c/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cace49e9a79a5fe44cda63964412c5bdce7ee90d", "url": "https://api.github.com/repos/rust-lang/rust/commits/cace49e9a79a5fe44cda63964412c5bdce7ee90d", "html_url": "https://github.com/rust-lang/rust/commit/cace49e9a79a5fe44cda63964412c5bdce7ee90d"}], "stats": {"total": 162, "additions": 85, "deletions": 77}, "files": [{"sha": "54da937eaae53eb57c60c51375597b2f9f176ad1", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 40, "deletions": 9, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/bed6869865ccfc6e72be26cb2041d83ab5cdbe3c/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed6869865ccfc6e72be26cb2041d83ab5cdbe3c/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=bed6869865ccfc6e72be26cb2041d83ab5cdbe3c", "patch": "@@ -28,7 +28,8 @@ use crate::{\n     expr::{BindingAnnotation, Body, BodySourceMap, ExprValidator, Pat, PatId},\n     ty::display::HirFormatter,\n     ty::{\n-        self, InEnvironment, InferenceResult, TraitEnvironment, TraitRef, Ty, TypeCtor, TypeWalk,\n+        self, InEnvironment, InferenceResult, TraitEnvironment, TraitRef, Ty, TyDefId, TypeCtor,\n+        TypeWalk,\n     },\n     CallableDef, Either, HirDisplay, Name, Source,\n };\n@@ -498,12 +499,9 @@ impl Adt {\n         let subst = db.generic_defaults(self.into());\n         subst.iter().any(|ty| ty == &Ty::Unknown)\n     }\n-    pub fn ty(self, db: &impl HirDatabase) -> Ty {\n-        match self {\n-            Adt::Struct(it) => it.ty(db),\n-            Adt::Union(it) => it.ty(db),\n-            Adt::Enum(it) => it.ty(db),\n-        }\n+    pub fn ty(self, db: &impl HirDatabase) -> Type {\n+        let id = AdtId::from(self);\n+        Type::from_def(db, id.module(db).krate, id)\n     }\n \n     pub fn module(self, db: &impl DefDatabase) -> Module {\n@@ -795,8 +793,8 @@ impl TypeAlias {\n         db.type_alias_data(self.id).type_ref.clone()\n     }\n \n-    pub fn ty(self, db: &impl HirDatabase) -> Ty {\n-        db.ty(self.id.into())\n+    pub fn ty(self, db: &impl HirDatabase) -> Type {\n+        Type::from_def(db, self.id.lookup(db).module(db).krate, self.id)\n     }\n \n     pub fn name(self, db: &impl DefDatabase) -> Name {\n@@ -989,6 +987,17 @@ pub struct Type {\n }\n \n impl Type {\n+    fn from_def(\n+        db: &impl HirDatabase,\n+        krate: CrateId,\n+        def: impl HasResolver + Into<TyDefId>,\n+    ) -> Type {\n+        let resolver = def.resolver(db);\n+        let environment = TraitEnvironment::lower(db, &resolver);\n+        let ty = db.ty(def.into());\n+        Type { krate, ty: InEnvironment { value: ty, environment } }\n+    }\n+\n     pub fn is_bool(&self) -> bool {\n         match &self.ty.value {\n             Ty::Apply(a_ty) => match a_ty.ctor {\n@@ -1097,6 +1106,28 @@ impl Type {\n             .map(move |ty| self.derived(ty))\n     }\n \n+    // This would be nicer if it just returned an iterator, but that runs into\n+    // lifetime problems, because we need to borrow temp `CrateImplBlocks`.\n+    pub fn iterate_impl_items<T>(\n+        self,\n+        db: &impl HirDatabase,\n+        krate: Crate,\n+        mut callback: impl FnMut(AssocItem) -> Option<T>,\n+    ) -> Option<T> {\n+        for krate in self.ty.value.def_crates(db, krate.crate_id)? {\n+            let impls = db.impls_in_crate(krate);\n+\n+            for impl_block in impls.lookup_impl_blocks(&self.ty.value) {\n+                for &item in db.impl_data(impl_block).items.iter() {\n+                    if let Some(result) = callback(item.into()) {\n+                        return Some(result);\n+                    }\n+                }\n+            }\n+        }\n+        None\n+    }\n+\n     // FIXME: remove\n     pub fn into_ty(self) -> Ty {\n         self.ty.value"}, {"sha": "9f3e6c43f213c5ff2a1389bea7d01d45425a0f01", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bed6869865ccfc6e72be26cb2041d83ab5cdbe3c/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed6869865ccfc6e72be26cb2041d83ab5cdbe3c/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=bed6869865ccfc6e72be26cb2041d83ab5cdbe3c", "patch": "@@ -389,14 +389,14 @@ impl SourceAnalyzer {\n     pub fn iterate_path_candidates<T>(\n         &self,\n         db: &impl HirDatabase,\n-        ty: Ty,\n+        ty: &Type,\n         name: Option<&Name>,\n         callback: impl FnMut(&Ty, AssocItem) -> Option<T>,\n     ) -> Option<T> {\n         // There should be no inference vars in types passed here\n         // FIXME check that?\n         // FIXME replace Unknown by bound vars here\n-        let canonical = crate::ty::Canonical { value: ty, num_vars: 0 };\n+        let canonical = crate::ty::Canonical { value: ty.ty.value.clone(), num_vars: 0 };\n         method_resolution::iterate_method_candidates(\n             &canonical,\n             db,"}, {"sha": "1c0f71adc2c20f5b967350ede42205a47d6abce2", "filename": "crates/ra_hir/src/ty/lower.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bed6869865ccfc6e72be26cb2041d83ab5cdbe3c/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed6869865ccfc6e72be26cb2041d83ab5cdbe3c/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs?ref=bed6869865ccfc6e72be26cb2041d83ab5cdbe3c", "patch": "@@ -189,7 +189,7 @@ impl Ty {\n                 Ty::Param { idx, name }\n             }\n             TypeNs::SelfType(impl_block) => ImplBlock::from(impl_block).target_ty(db),\n-            TypeNs::AdtSelfType(adt) => Adt::from(adt).ty(db),\n+            TypeNs::AdtSelfType(adt) => db.ty(adt.into()),\n \n             TypeNs::AdtId(it) => Ty::from_hir_path_inner(db, resolver, resolved_segment, it.into()),\n             TypeNs::BuiltinType(it) => {"}, {"sha": "92645e2a523e2bbc763d41594e9bb37ad6215d5e", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 39, "deletions": 62, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/bed6869865ccfc6e72be26cb2041d83ab5cdbe3c/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed6869865ccfc6e72be26cb2041d83ab5cdbe3c/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=bed6869865ccfc6e72be26cb2041d83ab5cdbe3c", "patch": "@@ -97,14 +97,15 @@ impl CrateImplBlocks {\n     }\n }\n \n-fn def_crates(\n-    db: &impl HirDatabase,\n-    cur_crate: CrateId,\n-    ty: &Ty,\n-) -> Option<ArrayVec<[CrateId; 2]>> {\n-    // Types like slice can have inherent impls in several crates, (core and alloc).\n-    // The corresponding impls are marked with lang items, so we can use them to find the required crates.\n-    macro_rules! lang_item_crate {\n+impl Ty {\n+    pub(crate) fn def_crates(\n+        &self,\n+        db: &impl HirDatabase,\n+        cur_crate: CrateId,\n+    ) -> Option<ArrayVec<[CrateId; 2]>> {\n+        // Types like slice can have inherent impls in several crates, (core and alloc).\n+        // The corresponding impls are marked with lang items, so we can use them to find the required crates.\n+        macro_rules! lang_item_crate {\n         ($($name:expr),+ $(,)?) => {{\n             let mut v = ArrayVec::<[LangItemTarget; 2]>::new();\n             $(\n@@ -114,38 +115,38 @@ fn def_crates(\n         }};\n     }\n \n-    let lang_item_targets = match ty {\n-        Ty::Apply(a_ty) => match a_ty.ctor {\n-            TypeCtor::Adt(def_id) => {\n-                return Some(std::iter::once(def_id.module(db).krate).collect())\n-            }\n-            TypeCtor::Bool => lang_item_crate!(\"bool\"),\n-            TypeCtor::Char => lang_item_crate!(\"char\"),\n-            TypeCtor::Float(Uncertain::Known(f)) => match f.bitness {\n-                // There are two lang items: one in libcore (fXX) and one in libstd (fXX_runtime)\n-                FloatBitness::X32 => lang_item_crate!(\"f32\", \"f32_runtime\"),\n-                FloatBitness::X64 => lang_item_crate!(\"f64\", \"f64_runtime\"),\n+        let lang_item_targets = match self {\n+            Ty::Apply(a_ty) => match a_ty.ctor {\n+                TypeCtor::Adt(def_id) => {\n+                    return Some(std::iter::once(def_id.module(db).krate).collect())\n+                }\n+                TypeCtor::Bool => lang_item_crate!(\"bool\"),\n+                TypeCtor::Char => lang_item_crate!(\"char\"),\n+                TypeCtor::Float(Uncertain::Known(f)) => match f.bitness {\n+                    // There are two lang items: one in libcore (fXX) and one in libstd (fXX_runtime)\n+                    FloatBitness::X32 => lang_item_crate!(\"f32\", \"f32_runtime\"),\n+                    FloatBitness::X64 => lang_item_crate!(\"f64\", \"f64_runtime\"),\n+                },\n+                TypeCtor::Int(Uncertain::Known(i)) => lang_item_crate!(i.ty_to_string()),\n+                TypeCtor::Str => lang_item_crate!(\"str_alloc\", \"str\"),\n+                TypeCtor::Slice => lang_item_crate!(\"slice_alloc\", \"slice\"),\n+                TypeCtor::RawPtr(Mutability::Shared) => lang_item_crate!(\"const_ptr\"),\n+                TypeCtor::RawPtr(Mutability::Mut) => lang_item_crate!(\"mut_ptr\"),\n+                _ => return None,\n             },\n-            TypeCtor::Int(Uncertain::Known(i)) => lang_item_crate!(i.ty_to_string()),\n-            TypeCtor::Str => lang_item_crate!(\"str_alloc\", \"str\"),\n-            TypeCtor::Slice => lang_item_crate!(\"slice_alloc\", \"slice\"),\n-            TypeCtor::RawPtr(Mutability::Shared) => lang_item_crate!(\"const_ptr\"),\n-            TypeCtor::RawPtr(Mutability::Mut) => lang_item_crate!(\"mut_ptr\"),\n             _ => return None,\n-        },\n-        _ => return None,\n-    };\n-    let res = lang_item_targets\n-        .into_iter()\n-        .filter_map(|it| match it {\n-            LangItemTarget::ImplBlockId(it) => Some(it),\n-            _ => None,\n-        })\n-        .map(|it| it.module(db).krate)\n-        .collect();\n-    Some(res)\n+        };\n+        let res = lang_item_targets\n+            .into_iter()\n+            .filter_map(|it| match it {\n+                LangItemTarget::ImplBlockId(it) => Some(it),\n+                _ => None,\n+            })\n+            .map(|it| it.module(db).krate)\n+            .collect();\n+        Some(res)\n+    }\n }\n-\n /// Look up the method with the given name, returning the actual autoderefed\n /// receiver type (but without autoref applied yet).\n pub(crate) fn lookup_method(\n@@ -286,7 +287,7 @@ fn iterate_inherent_methods<T>(\n     krate: CrateId,\n     mut callback: impl FnMut(&Ty, AssocItem) -> Option<T>,\n ) -> Option<T> {\n-    for krate in def_crates(db, krate, &ty.value)? {\n+    for krate in ty.value.def_crates(db, krate)? {\n         let impls = db.impls_in_crate(krate);\n \n         for impl_block in impls.lookup_impl_blocks(&ty.value) {\n@@ -342,30 +343,6 @@ pub(crate) fn implements_trait(\n     solution.is_some()\n }\n \n-impl Ty {\n-    // This would be nicer if it just returned an iterator, but that runs into\n-    // lifetime problems, because we need to borrow temp `CrateImplBlocks`.\n-    pub fn iterate_impl_items<T>(\n-        self,\n-        db: &impl HirDatabase,\n-        krate: CrateId,\n-        mut callback: impl FnMut(AssocItem) -> Option<T>,\n-    ) -> Option<T> {\n-        for krate in def_crates(db, krate, &self)? {\n-            let impls = db.impls_in_crate(krate);\n-\n-            for impl_block in impls.lookup_impl_blocks(&self) {\n-                for &item in db.impl_data(impl_block).items.iter() {\n-                    if let Some(result) = callback(item.into()) {\n-                        return Some(result);\n-                    }\n-                }\n-            }\n-        }\n-        None\n-    }\n-}\n-\n /// This creates Substs for a trait with the given Self type and type variables\n /// for all other parameters, to query Chalk with it.\n fn generic_implements_goal("}, {"sha": "5155365ccbb34bd2c785c0dcefd6d91ab29cb768", "filename": "crates/ra_hir_def/src/resolver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bed6869865ccfc6e72be26cb2041d83ab5cdbe3c/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed6869865ccfc6e72be26cb2041d83ab5cdbe3c/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs?ref=bed6869865ccfc6e72be26cb2041d83ab5cdbe3c", "patch": "@@ -484,7 +484,7 @@ impl Resolver {\n     }\n }\n \n-pub trait HasResolver {\n+pub trait HasResolver: Copy {\n     /// Builds a resolver for type references inside this def.\n     fn resolver(self, db: &impl DefDatabase) -> Resolver;\n }\n@@ -502,7 +502,7 @@ impl HasResolver for TraitId {\n     }\n }\n \n-impl<T: Into<AdtId>> HasResolver for T {\n+impl<T: Into<AdtId> + Copy> HasResolver for T {\n     fn resolver(self, db: &impl DefDatabase) -> Resolver {\n         let def = self.into();\n         def.module(db)"}, {"sha": "89e0009a17a6ec918b55ec495d293707790c53ab", "filename": "crates/ra_ide_api/src/completion/complete_path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bed6869865ccfc6e72be26cb2041d83ab5cdbe3c/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed6869865ccfc6e72be26cb2041d83ab5cdbe3c/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs?ref=bed6869865ccfc6e72be26cb2041d83ab5cdbe3c", "patch": "@@ -50,7 +50,7 @@ pub(super) fn complete_path(acc: &mut Completions, ctx: &CompletionContext) {\n                 hir::ModuleDef::TypeAlias(a) => a.ty(ctx.db),\n                 _ => unreachable!(),\n             };\n-            ctx.analyzer.iterate_path_candidates(ctx.db, ty.clone(), None, |_ty, item| {\n+            ctx.analyzer.iterate_path_candidates(ctx.db, &ty, None, |_ty, item| {\n                 match item {\n                     hir::AssocItem::Function(func) => {\n                         if !func.has_self_param(ctx.db) {"}]}