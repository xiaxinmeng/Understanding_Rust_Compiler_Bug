{"sha": "14e18bfa38dc445a07109cd8fbd98d6ff804f076", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0ZTE4YmZhMzhkYzQ0NWEwNzEwOWNkOGZiZDk4ZDZmZjgwNGYwNzY=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-07-03T15:13:56Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-07-03T16:07:03Z"}, "message": "Merge the inline function/method assists into `inline_call`", "tree": {"sha": "d6d7ebd3c2bb30673049a2350d40242689f4a129", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d6d7ebd3c2bb30673049a2350d40242689f4a129"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/14e18bfa38dc445a07109cd8fbd98d6ff804f076", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/14e18bfa38dc445a07109cd8fbd98d6ff804f076", "html_url": "https://github.com/rust-lang/rust/commit/14e18bfa38dc445a07109cd8fbd98d6ff804f076", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/14e18bfa38dc445a07109cd8fbd98d6ff804f076/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "688398febce6d76bb01a13f99ed607e9371a5c6a", "url": "https://api.github.com/repos/rust-lang/rust/commits/688398febce6d76bb01a13f99ed607e9371a5c6a", "html_url": "https://github.com/rust-lang/rust/commit/688398febce6d76bb01a13f99ed607e9371a5c6a"}], "stats": {"total": 139, "additions": 48, "deletions": 91}, "files": [{"sha": "93f8edb1a8299f40c4e146df8a40a4c91decc66f", "filename": "crates/ide_assists/src/handlers/inline_call.rs", "status": "renamed", "additions": 43, "deletions": 84, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/14e18bfa38dc445a07109cd8fbd98d6ff804f076/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14e18bfa38dc445a07109cd8fbd98d6ff804f076/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_call.rs?ref=14e18bfa38dc445a07109cd8fbd98d6ff804f076", "patch": "@@ -10,59 +10,9 @@ use crate::{\n     AssistId, AssistKind,\n };\n \n-// Assist: inline_method\n+// Assist: inline_call\n //\n-// Inlines a method body.\n-//\n-// ```\n-// struct Foo(u32);\n-// impl Foo {\n-//     fn add(self, a: u32) -> Self {\n-//         Foo(self.0 + a)\n-//     }\n-// }\n-// fn main() {\n-//     let x = Foo(3).add$0(2);\n-// }\n-// ```\n-// ->\n-// ```\n-// struct Foo(u32);\n-// impl Foo {\n-//     fn add(self, a: u32) -> Self {\n-//         Foo(self.0 + a)\n-//     }\n-// }\n-// fn main() {\n-//     let x = {\n-//         let this = Foo(3);\n-//         let a = 2;\n-//         Foo(this.0 + a)\n-//     };\n-// }\n-// ```\n-pub(crate) fn inline_method(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n-    let name_ref: ast::NameRef = ctx.find_node_at_offset()?;\n-    let call = name_ref.syntax().parent().and_then(ast::MethodCallExpr::cast)?;\n-    let receiver = call.receiver()?;\n-    let function = ctx.sema.resolve_method_call(&call)?;\n-    let mut arguments = vec![receiver];\n-    arguments.extend(call.arg_list()?.args());\n-\n-    inline_(\n-        acc,\n-        ctx,\n-        \"inline_method\",\n-        &format!(\"Inline `{}`\", name_ref),\n-        function,\n-        arguments,\n-        ast::Expr::MethodCallExpr(call),\n-    )\n-}\n-\n-// Assist: inline_function\n-//\n-// Inlines a function body.\n+// Inlines a function or method body.\n //\n // ```\n // fn add(a: u32, b: u32) -> u32 { a + b }\n@@ -81,32 +31,40 @@ pub(crate) fn inline_method(acc: &mut Assists, ctx: &AssistContext) -> Option<()\n //     };\n // }\n // ```\n-pub(crate) fn inline_function(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n-    let path_expr: ast::PathExpr = ctx.find_node_at_offset()?;\n-    let call = path_expr.syntax().parent().and_then(ast::CallExpr::cast)?;\n-    let path = path_expr.path()?;\n-\n-    let function = match dbg!(ctx.sema.resolve_path(&path)?) {\n-        PathResolution::Def(hir::ModuleDef::Function(f))\n-        | PathResolution::AssocItem(hir::AssocItem::Function(f)) => f,\n-        _ => return None,\n-    };\n-    inline_(\n-        acc,\n-        ctx,\n-        \"inline_function\",\n-        &format!(\"Inline `{}`\", path),\n-        function,\n-        call.arg_list()?.args().collect(),\n-        ast::Expr::CallExpr(call),\n-    )\n+pub(crate) fn inline_call(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    let (label, function, arguments, expr) =\n+        if let Some(path_expr) = ctx.find_node_at_offset::<ast::PathExpr>() {\n+            let call = path_expr.syntax().parent().and_then(ast::CallExpr::cast)?;\n+            let path = path_expr.path()?;\n+\n+            let function = match ctx.sema.resolve_path(&path)? {\n+                PathResolution::Def(hir::ModuleDef::Function(f))\n+                | PathResolution::AssocItem(hir::AssocItem::Function(f)) => f,\n+                _ => return None,\n+            };\n+            (\n+                format!(\"Inline `{}`\", path),\n+                function,\n+                call.arg_list()?.args().collect(),\n+                ast::Expr::CallExpr(call),\n+            )\n+        } else {\n+            let name_ref: ast::NameRef = ctx.find_node_at_offset()?;\n+            let call = name_ref.syntax().parent().and_then(ast::MethodCallExpr::cast)?;\n+            let receiver = call.receiver()?;\n+            let function = ctx.sema.resolve_method_call(&call)?;\n+            let mut arguments = vec![receiver];\n+            arguments.extend(call.arg_list()?.args());\n+            (format!(\"Inline `{}`\", name_ref), function, arguments, ast::Expr::MethodCallExpr(call))\n+        };\n+\n+    inline_(acc, ctx, label, function, arguments, expr)\n }\n \n pub(crate) fn inline_(\n     acc: &mut Assists,\n     ctx: &AssistContext,\n-    assist_id: &'static str,\n-    label: &str,\n+    label: String,\n     function: hir::Function,\n     arg_list: Vec<ast::Expr>,\n     expr: ast::Expr,\n@@ -133,7 +91,7 @@ pub(crate) fn inline_(\n     if arg_list.len() != params.len() {\n         // Can't inline the function because they've passed the wrong number of\n         // arguments to this function\n-        cov_mark::hit!(inline_function_incorrect_number_of_arguments);\n+        cov_mark::hit!(inline_call_incorrect_number_of_arguments);\n         return None;\n     }\n \n@@ -142,11 +100,12 @@ pub(crate) fn inline_(\n     let body = function_source.body()?;\n \n     acc.add(\n-        AssistId(assist_id, AssistKind::RefactorInline),\n+        AssistId(\"inline_call\", AssistKind::RefactorInline),\n         label,\n         expr.syntax().text_range(),\n         |builder| {\n             // FIXME: emit type ascriptions when a coercion happens?\n+            // FIXME: dont create locals when its not required\n             let statements = new_bindings\n                 .map(|(pattern, value)| make::let_stmt(pattern, Some(value)).into())\n                 .chain(body.statements());\n@@ -184,7 +143,7 @@ mod tests {\n     #[test]\n     fn no_args_or_return_value_gets_inlined_without_block() {\n         check_assist(\n-            inline_function,\n+            inline_call,\n             r#\"\n fn foo() { println!(\"Hello, World!\"); }\n fn main() {\n@@ -205,7 +164,7 @@ fn main() {\n     #[test]\n     fn args_with_side_effects() {\n         check_assist(\n-            inline_function,\n+            inline_call,\n             r#\"\n fn foo(name: String) { println!(\"Hello, {}!\", name); }\n fn main() {\n@@ -226,9 +185,9 @@ fn main() {\n \n     #[test]\n     fn not_applicable_when_incorrect_number_of_parameters_are_provided() {\n-        cov_mark::check!(inline_function_incorrect_number_of_arguments);\n+        cov_mark::check!(inline_call_incorrect_number_of_arguments);\n         check_assist_not_applicable(\n-            inline_function,\n+            inline_call,\n             r#\"\n fn add(a: u32, b: u32) -> u32 { a + b }\n fn main() { let x = add$0(42); }\n@@ -239,7 +198,7 @@ fn main() { let x = add$0(42); }\n     #[test]\n     fn function_with_multiple_statements() {\n         check_assist(\n-            inline_function,\n+            inline_call,\n             r#\"\n fn foo(a: u32, b: u32) -> u32 {\n     let x = a + b;\n@@ -274,7 +233,7 @@ fn main() {\n     #[test]\n     fn function_with_self_param() {\n         check_assist(\n-            inline_function,\n+            inline_call,\n             r#\"\n struct Foo(u32);\n \n@@ -311,7 +270,7 @@ fn main() {\n     #[test]\n     fn method_by_val() {\n         check_assist(\n-            inline_method,\n+            inline_call,\n             r#\"\n struct Foo(u32);\n \n@@ -348,7 +307,7 @@ fn main() {\n     #[test]\n     fn method_by_ref() {\n         check_assist(\n-            inline_method,\n+            inline_call,\n             r#\"\n struct Foo(u32);\n \n@@ -385,7 +344,7 @@ fn main() {\n     #[test]\n     fn method_by_ref_mut() {\n         check_assist(\n-            inline_method,\n+            inline_call,\n             r#\"\n struct Foo(u32);\n ", "previous_filename": "crates/ide_assists/src/handlers/inline_function.rs"}, {"sha": "bc30020f1f9566389f16f7b9dccc73fedc423893", "filename": "crates/ide_assists/src/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/14e18bfa38dc445a07109cd8fbd98d6ff804f076/crates%2Fide_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14e18bfa38dc445a07109cd8fbd98d6ff804f076/crates%2Fide_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Flib.rs?ref=14e18bfa38dc445a07109cd8fbd98d6ff804f076", "patch": "@@ -85,7 +85,7 @@ mod handlers {\n     mod generate_new;\n     mod generate_setter;\n     mod infer_function_return_type;\n-    mod inline_function;\n+    mod inline_call;\n     mod inline_local_variable;\n     mod introduce_named_lifetime;\n     mod invert_if;\n@@ -155,8 +155,7 @@ mod handlers {\n             generate_new::generate_new,\n             generate_setter::generate_setter,\n             infer_function_return_type::infer_function_return_type,\n-            inline_function::inline_function,\n-            inline_function::inline_method,\n+            inline_call::inline_call,\n             inline_local_variable::inline_local_variable,\n             introduce_named_lifetime::introduce_named_lifetime,\n             invert_if::invert_if,"}, {"sha": "cae2ad57eb5d62eed29187581f5e419ad732993b", "filename": "crates/ide_assists/src/tests/generated.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/14e18bfa38dc445a07109cd8fbd98d6ff804f076/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14e18bfa38dc445a07109cd8fbd98d6ff804f076/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=14e18bfa38dc445a07109cd8fbd98d6ff804f076", "patch": "@@ -919,9 +919,9 @@ fn foo() -> i32 { 42i32 }\n }\n \n #[test]\n-fn doctest_inline_function() {\n+fn doctest_inline_call() {\n     check_doc_test(\n-        \"inline_function\",\n+        \"inline_call\",\n         r#####\"\n fn add(a: u32, b: u32) -> u32 { a + b }\n fn main() {"}, {"sha": "e00ec7f1963c3fde158bf095a82d4c9319eebd14", "filename": "crates/syntax/src/ast/make.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/14e18bfa38dc445a07109cd8fbd98d6ff804f076/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14e18bfa38dc445a07109cd8fbd98d6ff804f076/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs?ref=14e18bfa38dc445a07109cd8fbd98d6ff804f076", "patch": "@@ -338,15 +338,14 @@ pub fn arg_list(args: impl IntoIterator<Item = ast::Expr>) -> ast::ArgList {\n }\n \n pub fn ident_pat(ref_: bool, mut_: bool, name: ast::Name) -> ast::IdentPat {\n-    use std::fmt::Write as _;\n     let mut s = String::from(\"fn f(\");\n     if ref_ {\n         s.push_str(\"ref \");\n     }\n     if mut_ {\n         s.push_str(\"mut \");\n     }\n-    let _ = write!(s, \"{}\", name);\n+    format_to!(s, \"{}\", name);\n     s.push_str(\": ())\");\n     ast_from_text(&s)\n }"}]}