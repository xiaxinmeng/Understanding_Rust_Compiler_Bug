{"sha": "972b93b20e2d21307622eacb812d8a552ecf0f81", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3MmI5M2IyMGUyZDIxMzA3NjIyZWFjYjgxMmQ4YTU1MmVjZjBmODE=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-04-13T22:36:08Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-10-15T15:23:51Z"}, "message": "rustc_metadata: use decoder::Metadata instead of &[u8] for Lazy<Table<T>>::get.", "tree": {"sha": "5b705cdf04065e3132b4d95bca84ffdc9ce2c919", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b705cdf04065e3132b4d95bca84ffdc9ce2c919"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/972b93b20e2d21307622eacb812d8a552ecf0f81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/972b93b20e2d21307622eacb812d8a552ecf0f81", "html_url": "https://github.com/rust-lang/rust/commit/972b93b20e2d21307622eacb812d8a552ecf0f81", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/972b93b20e2d21307622eacb812d8a552ecf0f81/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cef495028019b5bbb380bfa1d7a10e9e06dbf166", "url": "https://api.github.com/repos/rust-lang/rust/commits/cef495028019b5bbb380bfa1d7a10e9e06dbf166", "html_url": "https://github.com/rust-lang/rust/commit/cef495028019b5bbb380bfa1d7a10e9e06dbf166"}], "stats": {"total": 28, "additions": 19, "deletions": 9}, "files": [{"sha": "6da936374c7891baea16da30b8ac7de450cee3ca", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/972b93b20e2d21307622eacb812d8a552ecf0f81/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/972b93b20e2d21307622eacb812d8a552ecf0f81/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=972b93b20e2d21307622eacb812d8a552ecf0f81", "patch": "@@ -132,8 +132,8 @@ impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a CrateMetadata, TyCtxt<'tcx>) {\n }\n \n impl<'a, 'tcx, T: Encodable + Decodable> Lazy<T> {\n-    crate fn decode<M: Metadata<'a, 'tcx>>(self, meta: M) -> T {\n-        let mut dcx = meta.decoder(self.position.get());\n+    crate fn decode<M: Metadata<'a, 'tcx>>(self, metadata: M) -> T {\n+        let mut dcx = metadata.decoder(self.position.get());\n         dcx.lazy_state = LazyState::NodeStart(self.position);\n         T::decode(&mut dcx).unwrap()\n     }\n@@ -142,9 +142,9 @@ impl<'a, 'tcx, T: Encodable + Decodable> Lazy<T> {\n impl<'a: 'x, 'tcx: 'x, 'x, T: Encodable + Decodable> Lazy<[T]> {\n     crate fn decode<M: Metadata<'a, 'tcx>>(\n         self,\n-        meta: M,\n+        metadata: M,\n     ) -> impl ExactSizeIterator<Item = T> + Captures<'a> + Captures<'tcx> + 'x {\n-        let mut dcx = meta.decoder(self.position.get());\n+        let mut dcx = metadata.decoder(self.position.get());\n         dcx.lazy_state = LazyState::NodeStart(self.position);\n         (0..self.meta).map(move |_| T::decode(&mut dcx).unwrap())\n     }\n@@ -481,7 +481,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     fn maybe_entry(&self, item_id: DefIndex) -> Option<Lazy<Entry<'tcx>>> {\n-        self.root.per_def.entry.get(self.blob.raw_bytes(), item_id)\n+        self.root.per_def.entry.get(self, item_id)\n     }\n \n     fn entry(&self, item_id: DefIndex) -> Entry<'tcx> {"}, {"sha": "0585aa1d3884ef3d4c2d17f3f47005313aa3368b", "filename": "src/librustc_metadata/table.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/972b93b20e2d21307622eacb812d8a552ecf0f81/src%2Flibrustc_metadata%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/972b93b20e2d21307622eacb812d8a552ecf0f81/src%2Flibrustc_metadata%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftable.rs?ref=972b93b20e2d21307622eacb812d8a552ecf0f81", "patch": "@@ -1,3 +1,4 @@\n+use crate::decoder::Metadata;\n use crate::schema::*;\n \n use rustc::hir::def_id::{DefId, DefIndex};\n@@ -158,10 +159,15 @@ impl<T> LazyMeta for Table<T> where Option<T>: FixedSizeEncoding {\n impl<T> Lazy<Table<T>> where Option<T>: FixedSizeEncoding {\n     /// Given the metadata, extract out the value at a particular index (if any).\n     #[inline(never)]\n-    crate fn get(&self, bytes: &[u8], i: usize) -> Option<T> {\n+    crate fn get<'a, 'tcx, M: Metadata<'a, 'tcx>>(\n+        &self,\n+        metadata: M,\n+        i: usize,\n+    ) -> Option<T> {\n         debug!(\"Table::lookup: index={:?} len={:?}\", i, self.meta);\n \n-        <Option<T>>::read_from_bytes_at(&bytes[self.position.get()..][..self.meta], i)\n+        let bytes = &metadata.raw_bytes()[self.position.get()..][..self.meta];\n+        <Option<T>>::read_from_bytes_at(bytes, i)\n     }\n }\n \n@@ -201,7 +207,11 @@ impl<T> Lazy<PerDefTable<T>> where Option<T>: FixedSizeEncoding {\n \n     /// Given the metadata, extract out the value at a particular DefIndex (if any).\n     #[inline(never)]\n-    crate fn get(&self, bytes: &[u8], def_index: DefIndex) -> Option<T> {\n-        self.as_table().get(bytes, def_index.index())\n+    crate fn get<'a, 'tcx, M: Metadata<'a, 'tcx>>(\n+        &self,\n+        metadata: M,\n+        def_index: DefIndex,\n+    ) -> Option<T> {\n+        self.as_table().get(metadata, def_index.index())\n     }\n }"}]}