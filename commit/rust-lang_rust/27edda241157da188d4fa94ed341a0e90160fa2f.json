{"sha": "27edda241157da188d4fa94ed341a0e90160fa2f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3ZWRkYTI0MTE1N2RhMTg4ZDRmYTk0ZWQzNDFhMGU5MDE2MGZhMmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-09T00:58:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-09T00:58:54Z"}, "message": "Auto merge of #33360 - alexcrichton:rustbuild-dox, r=brson\n\nrustbuild: Document many more parts of the build\n\nThis commit expands the bootstrap build system's `README.md` as well as ensuring\nthat all API documentation is present and up-to-date. Additionally a new\n`config.toml.example` file is checked in with commented out versions of all\npossible configuration values.", "tree": {"sha": "a0f2c98ac15ff7ede2be8326b055e22a219c4f6e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a0f2c98ac15ff7ede2be8326b055e22a219c4f6e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/27edda241157da188d4fa94ed341a0e90160fa2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/27edda241157da188d4fa94ed341a0e90160fa2f", "html_url": "https://github.com/rust-lang/rust/commit/27edda241157da188d4fa94ed341a0e90160fa2f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/27edda241157da188d4fa94ed341a0e90160fa2f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6974800c6b3733beb3aea31a0994d0c47c7a76c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/6974800c6b3733beb3aea31a0994d0c47c7a76c9", "html_url": "https://github.com/rust-lang/rust/commit/6974800c6b3733beb3aea31a0994d0c47c7a76c9"}, {"sha": "f72bfe6661b35fd012fee100c673dafd1aec15f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/f72bfe6661b35fd012fee100c673dafd1aec15f7", "html_url": "https://github.com/rust-lang/rust/commit/f72bfe6661b35fd012fee100c673dafd1aec15f7"}], "stats": {"total": 773, "additions": 726, "deletions": 47}, "files": [{"sha": "942f070c82fd8b8e5a928d1ef2aa0c13e98c27b2", "filename": "src/bootstrap/README.md", "status": "modified", "additions": 136, "deletions": 6, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/27edda241157da188d4fa94ed341a0e90160fa2f/src%2Fbootstrap%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/27edda241157da188d4fa94ed341a0e90160fa2f/src%2Fbootstrap%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FREADME.md?ref=27edda241157da188d4fa94ed341a0e90160fa2f", "patch": "@@ -1,4 +1,4 @@\n-# Bootstrapping Rust\n+# rustbuild - Bootstrapping Rust\n \n This is an in-progress README which is targeted at helping to explain how Rust\n is bootstrapped and in general some of the technical details of the build\n@@ -8,20 +8,64 @@ system.\n > intended to be the primarily used one just yet. The makefiles are currently\n > the ones that are still \"guaranteed to work\" as much as possible at least.\n \n-## Using the new build system\n+## Using rustbuild\n \n When configuring Rust via `./configure`, pass the following to enable building\n via this build system:\n \n ```\n ./configure --enable-rustbuild\n+make\n ```\n \n-## ...\n+Afterwards the `Makefile` which is generated will have a few commands like\n+`make check`, `make tidy`, etc. For finer-grained control, the\n+`bootstrap.py` entry point can be used:\n+\n+```\n+python src/bootstrap/bootstrap.py\n+```\n+\n+This accepts a number of options like `--stage` and `--step` which can configure\n+what's actually being done.\n+\n+## Configuring rustbuild\n+\n+There are currently two primary methods for configuring the rustbuild build\n+system. First, the `./configure` options serialized in `config.mk` will be\n+parsed and read. That is, if any `./configure` options are passed, they'll be\n+handled naturally.\n+\n+Next, rustbuild offers a TOML-based configuration system with a `config.toml`\n+file in the same location as `config.mk`. An example of this configuration can\n+be found at `src/bootstrap/config.toml.example`, and the configuration file\n+can also be passed as `--config path/to/config.toml` if the build system is\n+being invoked manually (via the python script).\n+\n+## Build stages\n+\n+The rustbuild build system goes through a few phases to actually build the\n+compiler. What actually happens when you invoke rustbuild is:\n+\n+1. The entry point script, `src/bootstrap/bootstrap.py` is run. This script is\n+   responsible for downloading the stage0 compiler/Cargo binaries, and it then\n+   compiles the build system itself (this folder). Finally, it then invokes the\n+   actual `boostrap` binary build system.\n+2. In Rust, `bootstrap` will slurp up all configuration, perform a number of\n+   sanity checks (compilers exist for example), and then start building the\n+   stage0 artifacts.\n+3. The stage0 `cargo` downloaded earlier is used to build the standard library\n+   and the compiler, and then these binaries are then copied to the `stage1`\n+   directory. That compiler is then used to generate the stage1 artifacts which\n+   are then copied to the stage2 directory, and then finally the stage2\n+   artifacts are generated using that compiler.\n+\n+The goal of each stage is to (a) leverage Cargo as much as possible and failing\n+that (b) leverage Rust as much as possible!\n \n ## Directory Layout\n \n-This build system houses all output under the `target` directory, which looks\n+This build system houses all output under the `build` directory, which looks\n like this:\n \n ```\n@@ -42,6 +86,12 @@ build/\n     debug/\n     release/\n \n+  # Output of the dist-related steps like dist-std, dist-rustc, and dist-docs\n+  dist/\n+\n+  # Temporary directory used for various input/output as part of various stages\n+  tmp/\n+\n   # Each remaining directory is scoped by the \"host\" triple of compilation at\n   # hand.\n   x86_64-unknown-linux-gnu/\n@@ -50,7 +100,8 @@ build/\n     # folder is under. The exact layout here will likely depend on the platform,\n     # and this is also built with CMake so the build system is also likely\n     # different.\n-    compiler-rt/build/\n+    compiler-rt/\n+      build/\n \n     # Output folder for LLVM if it is compiled for this target\n     llvm/\n@@ -67,6 +118,17 @@ build/\n       share/\n       ...\n \n+    # Output folder for all documentation of this target. This is what's filled\n+    # in whenever the `doc` step is run.\n+    doc/\n+\n+    # Output for all compiletest-based test suites\n+    test/\n+      run-pass/\n+      compile-fail/\n+      debuginfo/\n+      ...\n+\n     # Location where the stage0 Cargo and Rust compiler are unpacked. This\n     # directory is purely an extracted and overlaid tarball of these two (done\n     # by the bootstrapy python script). In theory the build system does not\n@@ -82,7 +144,9 @@ build/\n     # invocation. The build system instruments calling Cargo in the right order\n     # with the right variables to ensure these are filled in correctly.\n     stageN-std/\n+    stageN-test/\n     stageN-rustc/\n+    stageN-tools/\n \n     # This is a special case of the above directories, **not** filled in via\n     # Cargo but rather the build system itself. The stage0 compiler already has\n@@ -96,7 +160,7 @@ build/\n     # Basically this directory is just a temporary artifact use to configure the\n     # stage0 compiler to ensure that the libstd we just built is used to\n     # compile the stage1 compiler.\n-    stage0-rustc/lib/\n+    stage0-sysroot/lib/\n \n     # These output directories are intended to be standalone working\n     # implementations of the compiler (corresponding to each stage). The build\n@@ -108,3 +172,69 @@ build/\n     stage2/\n     stage3/\n ```\n+\n+## Cargo projects\n+\n+The current build is unfortunately not quite as simple as `cargo build` in a\n+directory, but rather the compiler is split into three different Cargo projects:\n+\n+* `src/rustc/std_shim` - a project which builds and compiles libstd\n+* `src/rustc/test_shim` - a project which builds and compiles libtest\n+* `src/rustc` - the actual compiler itself\n+\n+Each \"project\" has a corresponding Cargo.lock file with all dependencies, and\n+this means that building the compiler involves running Cargo three times. The\n+structure here serves two goals:\n+\n+1. Facilitating dependencies coming from crates.io. These dependencies don't\n+   depend on `std`, so libstd is a separate project compiled ahead of time\n+   before the actual compiler builds.\n+2. Splitting \"host artifacts\" from \"target artifacts\". That is, when building\n+   code for an arbitrary target you don't need the entire compiler, but you'll\n+   end up needing libraries like libtest that depend on std but also want to use\n+   crates.io dependencies. Hence, libtest is split out as its own project that\n+   is sequenced after `std` but before `rustc`. This project is built for all\n+   targets.\n+\n+There is some loss in build parallelism here because libtest can be compiled in\n+parallel with a number of rustc artifacts, but in theory the loss isn't too bad!\n+\n+## Build tools\n+\n+We've actually got quite a few tools that we use in the compiler's build system\n+and for testing. To organize these, each tool is a project in `src/tools` with a\n+corresponding `Cargo.toml`. All tools are compiled with Cargo (currently having\n+independent `Cargo.lock` files) and do not currently explicitly depend on the\n+compiler or standard library. Compiling each tool is sequenced after the\n+appropriate libstd/libtest/librustc compile above.\n+\n+## Extending rustbuild\n+\n+So you'd like to add a feature to the rustbuild build system or just fix a bug.\n+Great! One of the major motivational factors for moving away from `make` is that\n+Rust is in theory much easier to read, modify, and write. If you find anything\n+excessively confusing, please open an issue on this and we'll try to get it\n+documented or simplified pronto.\n+\n+First up, you'll probably want to read over the documentation above as that'll\n+give you a high level overview of what rustbuild is doing. You also probably\n+want to play around a bit yourself by just getting it up and running before you\n+dive too much into the actual build system itself.\n+\n+After that, each module in rustbuild should have enough documentation to keep\n+you up and running. Some general areas that you may be interested in modifying\n+are:\n+\n+* Adding a new build tool? Take a look at `build/step.rs` for examples of other\n+  tools, as well as `build/mod.rs`.\n+* Adding a new compiler crate? Look no further! Adding crates can be done by\n+  adding a new directory with `Cargo.toml` followed by configuring all\n+  `Cargo.toml` files accordingly.\n+* Adding a new dependency from crates.io? We're still working on that, so hold\n+  off on that for now.\n+* Adding a new configuration option? Take a look at `build/config.rs` or perhaps\n+  `build/flags.rs` and then modify the build elsewhere to read that option.\n+* Adding a sanity check? Take a look at `build/sanity.rs`.\n+\n+If you have any questions feel free to reach out on `#rust-internals` on IRC or\n+open an issue in the bug tracker!"}, {"sha": "d0b0f1007c6a0d5c62a10becf4f140168f9aa40f", "filename": "src/bootstrap/build/cc.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/27edda241157da188d4fa94ed341a0e90160fa2f/src%2Fbootstrap%2Fbuild%2Fcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27edda241157da188d4fa94ed341a0e90160fa2f/src%2Fbootstrap%2Fbuild%2Fcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fcc.rs?ref=27edda241157da188d4fa94ed341a0e90160fa2f", "patch": "@@ -8,6 +8,29 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! C-compiler probing and detection.\n+//!\n+//! This module will fill out the `cc` and `cxx` maps of `Build` by looking for\n+//! C and C++ compilers for each target configured. A compiler is found through\n+//! a number of vectors (in order of precedence)\n+//!\n+//! 1. Configuration via `target.$target.cc` in `config.toml`.\n+//! 2. Configuration via `target.$target.android-ndk` in `config.toml`, if\n+//!    applicable\n+//! 3. Special logic to probe on OpenBSD\n+//! 4. The `CC_$target` environment variable.\n+//! 5. The `CC` environment variable.\n+//! 6. \"cc\"\n+//!\n+//! Some of this logic is implemented here, but much of it is farmed out to the\n+//! `gcc` crate itself, so we end up having the same fallbacks as there.\n+//! Similar logic is then used to find a C++ compiler, just some s/cc/c++/ is\n+//! used.\n+//!\n+//! It is intended that after this module has run no C/C++ compiler will\n+//! ever be probed for. Instead the compilers found here will be used for\n+//! everything.\n+\n use std::process::Command;\n \n use build_helper::{cc2ar, output};"}, {"sha": "76d061eb43e0ca4707c21a64e2ce3a677deafa7b", "filename": "src/bootstrap/build/channel.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/27edda241157da188d4fa94ed341a0e90160fa2f/src%2Fbootstrap%2Fbuild%2Fchannel.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27edda241157da188d4fa94ed341a0e90160fa2f/src%2Fbootstrap%2Fbuild%2Fchannel.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fchannel.rs?ref=27edda241157da188d4fa94ed341a0e90160fa2f", "patch": "@@ -8,7 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::env;\n+//! Build configuration for Rust's release channels.\n+//!\n+//! Implements the stable/beta/nightly channel distinctions by setting various\n+//! flags like the `unstable_features`, calculating variables like `release` and\n+//! `package_vers`, and otherwise indicating to the compiler what it should\n+//! print out as part of its version information.\n+\n use std::fs::{self, File};\n use std::io::prelude::*;\n use std::process::Command;\n@@ -19,6 +25,9 @@ use md5;\n use build::Build;\n \n pub fn collect(build: &mut Build) {\n+    // Currently the canonical source for the release number (e.g. 1.10.0) and\n+    // the prerelease version (e.g. `.1`) is in `mk/main.mk`. We \"parse\" that\n+    // here to learn about those numbers.\n     let mut main_mk = String::new();\n     t!(t!(File::open(build.src.join(\"mk/main.mk\"))).read_to_string(&mut main_mk));\n     let mut release_num = \"\";\n@@ -32,7 +41,8 @@ pub fn collect(build: &mut Build) {\n         }\n     }\n \n-    // FIXME: this is duplicating makefile logic\n+    // Depending on the channel, passed in `./configure --release-channel`,\n+    // determine various properties of the build.\n     match &build.config.channel[..] {\n         \"stable\" => {\n             build.release = release_num.to_string();\n@@ -58,6 +68,8 @@ pub fn collect(build: &mut Build) {\n     }\n     build.version = build.release.clone();\n \n+    // If we have a git directory, add in some various SHA information of what\n+    // commit this compiler was compiled from.\n     if fs::metadata(build.src.join(\".git\")).is_ok() {\n         let ver_date = output(Command::new(\"git\").current_dir(&build.src)\n                                       .arg(\"log\").arg(\"-1\")\n@@ -80,11 +92,14 @@ pub fn collect(build: &mut Build) {\n         build.short_ver_hash = Some(short_ver_hash);\n     }\n \n+    // Calculate this compiler's bootstrap key, which is currently defined as\n+    // the first 8 characters of the md5 of the release string.\n     let key = md5::compute(build.release.as_bytes());\n     build.bootstrap_key = format!(\"{:02x}{:02x}{:02x}{:02x}\",\n                                   key[0], key[1], key[2], key[3]);\n-    env::set_var(\"RUSTC_BOOTSTRAP_KEY\", &build.bootstrap_key);\n \n+    // Slurp up the stage0 bootstrap key as we're bootstrapping from an\n+    // otherwise stable compiler.\n     let mut s = String::new();\n     t!(t!(File::open(build.src.join(\"src/stage0.txt\"))).read_to_string(&mut s));\n     if let Some(line) = s.lines().find(|l| l.starts_with(\"rustc_key\")) {"}, {"sha": "0cd96881b58743ad7bbaee5fa8c6408633f4b595", "filename": "src/bootstrap/build/check.rs", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/27edda241157da188d4fa94ed341a0e90160fa2f/src%2Fbootstrap%2Fbuild%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27edda241157da188d4fa94ed341a0e90160fa2f/src%2Fbootstrap%2Fbuild%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fcheck.rs?ref=27edda241157da188d4fa94ed341a0e90160fa2f", "patch": "@@ -8,6 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! Implementation of the various `check-*` targets of the build system.\n+//!\n+//! This file implements the various regression test suites that we execute on\n+//! our CI.\n+\n use std::fs;\n use std::path::{PathBuf, Path};\n use std::process::Command;\n@@ -16,15 +21,22 @@ use build_helper::output;\n \n use build::{Build, Compiler};\n \n+/// Runs the `linkchecker` tool as compiled in `stage` by the `host` compiler.\n+///\n+/// This tool in `src/tools` will verify the validity of all our links in the\n+/// documentation to ensure we don't have a bunch of dead ones.\n pub fn linkcheck(build: &Build, stage: u32, host: &str) {\n     println!(\"Linkcheck stage{} ({})\", stage, host);\n     let compiler = Compiler::new(stage, host);\n     build.run(build.tool_cmd(&compiler, \"linkchecker\")\n                    .arg(build.out.join(host).join(\"doc\")));\n }\n \n+/// Runs the `cargotest` tool as compiled in `stage` by the `host` compiler.\n+///\n+/// This tool in `src/tools` will check out a few Rust projects and run `cargo\n+/// test` to ensure that we don't regress the test suites there.\n pub fn cargotest(build: &Build, stage: u32, host: &str) {\n-\n     let ref compiler = Compiler::new(stage, host);\n \n     // Configure PATH to find the right rustc. NB. we have to use PATH\n@@ -47,6 +59,11 @@ pub fn cargotest(build: &Build, stage: u32, host: &str) {\n                    .arg(&out_dir));\n }\n \n+/// Runs the `tidy` tool as compiled in `stage` by the `host` compiler.\n+///\n+/// This tool in `src/tools` checks up on various bits and pieces of style and\n+/// otherwise just implements a few lint-like checks that are specific to the\n+/// compiler itself.\n pub fn tidy(build: &Build, stage: u32, host: &str) {\n     println!(\"tidy check stage{} ({})\", stage, host);\n     let compiler = Compiler::new(stage, host);\n@@ -58,13 +75,21 @@ fn testdir(build: &Build, host: &str) -> PathBuf {\n     build.out.join(host).join(\"test\")\n }\n \n+/// Executes the `compiletest` tool to run a suite of tests.\n+///\n+/// Compiles all tests with `compiler` for `target` with the specified\n+/// compiletest `mode` and `suite` arguments. For example `mode` can be\n+/// \"run-pass\" or `suite` can be something like `debuginfo`.\n pub fn compiletest(build: &Build,\n                    compiler: &Compiler,\n                    target: &str,\n                    mode: &str,\n                    suite: &str) {\n     let mut cmd = build.tool_cmd(compiler, \"compiletest\");\n \n+    // compiletest currently has... a lot of arguments, so let's just pass all\n+    // of them!\n+\n     cmd.arg(\"--compile-lib-path\").arg(build.rustc_libdir(compiler));\n     cmd.arg(\"--run-lib-path\").arg(build.sysroot_libdir(compiler, target));\n     cmd.arg(\"--rustc-path\").arg(build.compiler_path(compiler));\n@@ -113,6 +138,8 @@ pub fn compiletest(build: &Build,\n         cmd.arg(\"--verbose\");\n     }\n \n+    // Only pass correct values for these flags for the `run-make` suite as it\n+    // requires that a C++ compiler was configured which isn't always the case.\n     if suite == \"run-make\" {\n         let llvm_config = build.llvm_config(target);\n         let llvm_components = output(Command::new(&llvm_config).arg(\"--components\"));\n@@ -139,11 +166,19 @@ pub fn compiletest(build: &Build,\n             }\n         }\n     }\n+    build.add_bootstrap_key(compiler, &mut cmd);\n \n     build.run(&mut cmd);\n }\n \n+/// Run `rustdoc --test` for all documentation in `src/doc`.\n+///\n+/// This will run all tests in our markdown documentation (e.g. the book)\n+/// located in `src/doc`. The `rustdoc` that's run is the one that sits next to\n+/// `compiler`.\n pub fn docs(build: &Build, compiler: &Compiler) {\n+    // Do a breadth-first traversal of the `src/doc` directory and just run\n+    // tests for all files that end in `*.md`\n     let mut stack = vec![build.src.join(\"src/doc\")];\n \n     while let Some(p) = stack.pop() {\n@@ -161,6 +196,12 @@ pub fn docs(build: &Build, compiler: &Compiler) {\n     }\n }\n \n+/// Run the error index generator tool to execute the tests located in the error\n+/// index.\n+///\n+/// The `error_index_generator` tool lives in `src/tools` and is used to\n+/// generate a markdown file from the error indexes of the code base which is\n+/// then passed to `rustdoc --test`.\n pub fn error_index(build: &Build, compiler: &Compiler) {\n     println!(\"Testing error-index stage{}\", compiler.stage);\n "}, {"sha": "1d407c941323545a9745c5e794de5ff5478536de", "filename": "src/bootstrap/build/clean.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/27edda241157da188d4fa94ed341a0e90160fa2f/src%2Fbootstrap%2Fbuild%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27edda241157da188d4fa94ed341a0e90160fa2f/src%2Fbootstrap%2Fbuild%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fclean.rs?ref=27edda241157da188d4fa94ed341a0e90160fa2f", "patch": "@@ -8,6 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! Implementation of `make clean` in rustbuild.\n+//!\n+//! Responsible for cleaning out a build directory of all old and stale\n+//! artifacts to prepare for a fresh build. Currently doesn't remove the\n+//! `build/cache` directory (download cache) or the `build/$target/llvm`\n+//! directory as we want that cached between builds.\n+\n use std::fs;\n use std::path::Path;\n "}, {"sha": "5ed9c1c18c2184bb538a1d30fbfed455e7013e5c", "filename": "src/bootstrap/build/compile.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/27edda241157da188d4fa94ed341a0e90160fa2f/src%2Fbootstrap%2Fbuild%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27edda241157da188d4fa94ed341a0e90160fa2f/src%2Fbootstrap%2Fbuild%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fcompile.rs?ref=27edda241157da188d4fa94ed341a0e90160fa2f", "patch": "@@ -8,6 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! Implementation of compiling various phases of the compiler and standard\n+//! library.\n+//!\n+//! This module contains some of the real meat in the rustbuild build system\n+//! which is where Cargo is used to compiler the standard library, libtest, and\n+//! compiler. This module is also responsible for assembling the sysroot as it\n+//! goes along from the output of the previous stage.\n+\n use std::collections::HashMap;\n use std::fs;\n use std::path::{Path, PathBuf};\n@@ -35,6 +43,8 @@ pub fn std<'a>(build: &'a Build, target: &str, compiler: &Compiler<'a>) {\n     copy(&build.compiler_rt_built.borrow()[target],\n          &libdir.join(staticlib(\"compiler-rt\", target)));\n \n+    // Some platforms have startup objects that may be required to produce the\n+    // libstd dynamic library, for example.\n     build_startup_objects(build, target, &libdir);\n \n     let out_dir = build.cargo_out(compiler, Mode::Libstd, target);\n@@ -154,7 +164,6 @@ pub fn test_link(build: &Build,\n     add_to_sysroot(&out_dir, &libdir);\n }\n \n-\n /// Build the compiler.\n ///\n /// This will build the compiler for a particular stage of the build using"}, {"sha": "533c1c93d5bc47772f2243ec6a9c5fb91bd44b08", "filename": "src/bootstrap/build/config.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/27edda241157da188d4fa94ed341a0e90160fa2f/src%2Fbootstrap%2Fbuild%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27edda241157da188d4fa94ed341a0e90160fa2f/src%2Fbootstrap%2Fbuild%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fconfig.rs?ref=27edda241157da188d4fa94ed341a0e90160fa2f", "patch": "@@ -8,6 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! Serialized configuration of a build.\n+//!\n+//! This module implements parsing `config.mk` and `config.toml` configuration\n+//! files to tweak how the build runs.\n+\n use std::collections::HashMap;\n use std::env;\n use std::fs::File;\n@@ -27,7 +32,9 @@ use toml::{Parser, Decoder, Value};\n /// is generated from `./configure`.\n ///\n /// Note that this structure is not decoded directly into, but rather it is\n-/// filled out from the decoded forms of the structs below.\n+/// filled out from the decoded forms of the structs below. For documentation\n+/// each field, see the corresponding fields in\n+/// `src/bootstrap/config.toml.example`.\n #[derive(Default)]\n pub struct Config {\n     pub ccache: bool,\n@@ -250,6 +257,11 @@ impl Config {\n         return config\n     }\n \n+    /// \"Temporary\" routine to parse `config.mk` into this configuration.\n+    ///\n+    /// While we still have `./configure` this implements the ability to decode\n+    /// that configuration into this. This isn't exactly a full-blown makefile\n+    /// parser, but hey it gets the job done!\n     pub fn update_with_config_mk(&mut self) {\n         let mut config = String::new();\n         File::open(\"config.mk\").unwrap().read_to_string(&mut config).unwrap();"}, {"sha": "088e89b658d46699d0d6ff920852b66c44f5043b", "filename": "src/bootstrap/build/dist.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/27edda241157da188d4fa94ed341a0e90160fa2f/src%2Fbootstrap%2Fbuild%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27edda241157da188d4fa94ed341a0e90160fa2f/src%2Fbootstrap%2Fbuild%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fdist.rs?ref=27edda241157da188d4fa94ed341a0e90160fa2f", "patch": "@@ -8,6 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! Implementation of the various distribution aspects of the compiler.\n+//!\n+//! This module is responsible for creating tarballs of the standard library,\n+//! compiler, and documentation. This ends up being what we distribute to\n+//! everyone as well.\n+//!\n+//! No tarball is actually created literally in this file, but rather we shell\n+//! out to `rust-installer` still. This may one day be replaced with bits and\n+//! pieces of `rustup.rs`!\n+\n use std::fs::{self, File};\n use std::io::Write;\n use std::path::{PathBuf, Path};\n@@ -33,6 +43,9 @@ fn tmpdir(build: &Build) -> PathBuf {\n     build.out.join(\"tmp/dist\")\n }\n \n+/// Builds the `rust-docs` installer component.\n+///\n+/// Slurps up documentation from the `stage`'s `host`.\n pub fn docs(build: &Build, stage: u32, host: &str) {\n     println!(\"Dist docs stage{} ({})\", stage, host);\n     let name = format!(\"rust-docs-{}\", package_vers(build));\n@@ -68,6 +81,12 @@ pub fn docs(build: &Build, stage: u32, host: &str) {\n     }\n }\n \n+/// Build the `rust-mingw` installer component.\n+///\n+/// This contains all the bits and pieces to run the MinGW Windows targets\n+/// without any extra installed software (e.g. we bundle gcc, libraries, etc).\n+/// Currently just shells out to a python script, but that should be rewritten\n+/// in Rust.\n pub fn mingw(build: &Build, host: &str) {\n     println!(\"Dist mingw ({})\", host);\n     let name = format!(\"rust-mingw-{}\", package_vers(build));\n@@ -102,6 +121,7 @@ pub fn mingw(build: &Build, host: &str) {\n     t!(fs::remove_dir_all(&image));\n }\n \n+/// Creates the `rustc` installer component.\n pub fn rustc(build: &Build, stage: u32, host: &str) {\n     println!(\"Dist rustc stage{} ({})\", stage, host);\n     let name = format!(\"rustc-{}\", package_vers(build));\n@@ -209,6 +229,7 @@ pub fn rustc(build: &Build, stage: u32, host: &str) {\n     }\n }\n \n+/// Copies debugger scripts for `host` into the `sysroot` specified.\n pub fn debugger_scripts(build: &Build,\n                         sysroot: &Path,\n                         host: &str) {\n@@ -237,7 +258,8 @@ pub fn debugger_scripts(build: &Build,\n     }\n }\n \n-\n+/// Creates the `rust-std` installer component as compiled by `compiler` for the\n+/// target `target`.\n pub fn std(build: &Build, compiler: &Compiler, target: &str) {\n     println!(\"Dist std stage{} ({} -> {})\", compiler.stage, compiler.host,\n              target);"}, {"sha": "f7cc742277a63086bed52acb09aa046d1c52e439", "filename": "src/bootstrap/build/doc.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/27edda241157da188d4fa94ed341a0e90160fa2f/src%2Fbootstrap%2Fbuild%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27edda241157da188d4fa94ed341a0e90160fa2f/src%2Fbootstrap%2Fbuild%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fdoc.rs?ref=27edda241157da188d4fa94ed341a0e90160fa2f", "patch": "@@ -8,6 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! Documentation generation for rustbuild.\n+//!\n+//! This module implements generation for all bits and pieces of documentation\n+//! for the Rust project. This notably includes suites like the rust book, the\n+//! nomicon, standalone documentation, etc.\n+//!\n+//! Everything here is basically just a shim around calling either `rustbook` or\n+//! `rustdoc`.\n+\n use std::fs::{self, File};\n use std::io::prelude::*;\n use std::path::Path;\n@@ -16,6 +25,11 @@ use std::process::Command;\n use build::{Build, Compiler, Mode};\n use build::util::{up_to_date, cp_r};\n \n+/// Invoke `rustbook` as compiled in `stage` for `target` for the doc book\n+/// `name` into the `out` path.\n+///\n+/// This will not actually generate any documentation if the documentation has\n+/// already been generated.\n pub fn rustbook(build: &Build, stage: u32, target: &str, name: &str, out: &Path) {\n     t!(fs::create_dir_all(out));\n \n@@ -35,6 +49,14 @@ pub fn rustbook(build: &Build, stage: u32, target: &str, name: &str, out: &Path)\n                    .arg(out));\n }\n \n+/// Generates all standalone documentation as compiled by the rustdoc in `stage`\n+/// for the `target` into `out`.\n+///\n+/// This will list all of `src/doc` looking for markdown files and appropriately\n+/// perform transformations like substituting `VERSION`, `SHORT_HASH`, and\n+/// `STAMP` alongw ith providing the various header/footer HTML we've cutomized.\n+///\n+/// In the end, this is just a glorified wrapper around rustdoc!\n pub fn standalone(build: &Build, stage: u32, target: &str, out: &Path) {\n     println!(\"Documenting stage{} standalone ({})\", stage, target);\n     t!(fs::create_dir_all(out));\n@@ -105,6 +127,10 @@ pub fn standalone(build: &Build, stage: u32, target: &str, out: &Path) {\n     }\n }\n \n+/// Compile all standard library documentation.\n+///\n+/// This will generate all documentation for the standard library and its\n+/// dependencies. This is largely just a wrapper around `cargo doc`.\n pub fn std(build: &Build, stage: u32, target: &str, out: &Path) {\n     println!(\"Documenting stage{} std ({})\", stage, target);\n     t!(fs::create_dir_all(out));\n@@ -123,6 +149,10 @@ pub fn std(build: &Build, stage: u32, target: &str, out: &Path) {\n     cp_r(&out_dir, out)\n }\n \n+/// Compile all libtest documentation.\n+///\n+/// This will generate all documentation for libtest and its dependencies. This\n+/// is largely just a wrapper around `cargo doc`.\n pub fn test(build: &Build, stage: u32, target: &str, out: &Path) {\n     println!(\"Documenting stage{} test ({})\", stage, target);\n     let compiler = Compiler::new(stage, &build.config.build);\n@@ -139,6 +169,10 @@ pub fn test(build: &Build, stage: u32, target: &str, out: &Path) {\n     cp_r(&out_dir, out)\n }\n \n+/// Generate all compiler documentation.\n+///\n+/// This will generate all documentation for the compiler libraries and their\n+/// dependencies. This is largely just a wrapper around `cargo doc`.\n pub fn rustc(build: &Build, stage: u32, target: &str, out: &Path) {\n     println!(\"Documenting stage{} compiler ({})\", stage, target);\n     let compiler = Compiler::new(stage, &build.config.build);\n@@ -156,6 +190,8 @@ pub fn rustc(build: &Build, stage: u32, target: &str, out: &Path) {\n     cp_r(&out_dir, out)\n }\n \n+/// Generates the HTML rendered error-index by running the\n+/// `error_index_generator` tool.\n pub fn error_index(build: &Build, stage: u32, target: &str, out: &Path) {\n     println!(\"Documenting stage{} error index ({})\", stage, target);\n     t!(fs::create_dir_all(out));"}, {"sha": "d925997f36c214ae09c078b04ec31537da7e4b02", "filename": "src/bootstrap/build/flags.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/27edda241157da188d4fa94ed341a0e90160fa2f/src%2Fbootstrap%2Fbuild%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27edda241157da188d4fa94ed341a0e90160fa2f/src%2Fbootstrap%2Fbuild%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fflags.rs?ref=27edda241157da188d4fa94ed341a0e90160fa2f", "patch": "@@ -8,13 +8,19 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! Command-line interface of the rustbuild build system.\n+//!\n+//! This module implements the command-line parsing of the build system which\n+//! has various flags to configure how it's run.\n+\n use std::fs;\n use std::path::PathBuf;\n use std::process;\n use std::slice;\n \n use getopts::Options;\n \n+/// Deserialized version of all flags for this compile.\n pub struct Flags {\n     pub verbose: bool,\n     pub stage: Option<u32>,"}, {"sha": "b38532fb3dfa7192ad328159acaa115a76341c2e", "filename": "src/bootstrap/build/mod.rs", "status": "modified", "additions": 143, "deletions": 18, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/27edda241157da188d4fa94ed341a0e90160fa2f/src%2Fbootstrap%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27edda241157da188d4fa94ed341a0e90160fa2f/src%2Fbootstrap%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fmod.rs?ref=27edda241157da188d4fa94ed341a0e90160fa2f", "patch": "@@ -8,6 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! Implementation of rustbuild, the Rust build system.\n+//!\n+//! This module, and its descendants, are the implementation of the Rust build\n+//! system. Most of this build system is backed by Cargo but the outer layer\n+//! here serves as the ability to orchestrate calling Cargo, sequencing Cargo\n+//! builds, building artifacts like LLVM, etc.\n+//!\n+//! More documentation can be found in each respective module below.\n+\n use std::cell::RefCell;\n use std::collections::HashMap;\n use std::env;\n@@ -21,6 +30,14 @@ use num_cpus;\n \n use build::util::{exe, mtime, libdir, add_lib_path};\n \n+/// A helper macro to `unwrap` a result except also print out details like:\n+///\n+/// * The file/line of the panic\n+/// * The expression that failed\n+/// * The error itself\n+///\n+/// This is currently used judiciously throughout the build system rather than\n+/// using a `Result` with `try!`, but this may change on day...\n macro_rules! t {\n     ($e:expr) => (match $e {\n         Ok(e) => e,\n@@ -53,12 +70,27 @@ mod job {\n pub use build::config::Config;\n pub use build::flags::Flags;\n \n+/// A structure representing a Rust compiler.\n+///\n+/// Each compiler has a `stage` that it is associated with and a `host` that\n+/// corresponds to the platform the compiler runs on. This structure is used as\n+/// a parameter to many methods below.\n #[derive(Eq, PartialEq, Clone, Copy, Hash, Debug)]\n pub struct Compiler<'a> {\n     stage: u32,\n     host: &'a str,\n }\n \n+/// Global configuration for the build system.\n+///\n+/// This structure transitively contains all configuration for the build system.\n+/// All filesystem-encoded configuration is in `config`, all flags are in\n+/// `flags`, and then parsed or probed information is listed in the keys below.\n+///\n+/// This structure is a parameter of almost all methods in the build system,\n+/// although most functions are implemented as free functions rather than\n+/// methods specifically on this structure itself (to make it easier to\n+/// organize).\n pub struct Build {\n     // User-specified configuration via config.toml\n     config: Config,\n@@ -92,14 +124,33 @@ pub struct Build {\n     compiler_rt_built: RefCell<HashMap<String, PathBuf>>,\n }\n \n+/// The various \"modes\" of invoking Cargo.\n+///\n+/// These entries currently correspond to the various output directories of the\n+/// build system, with each mod generating output in a different directory.\n pub enum Mode {\n+    /// This cargo is going to build the standard library, placing output in the\n+    /// \"stageN-std\" directory.\n     Libstd,\n+\n+    /// This cargo is going to build libtest, placing output in the\n+    /// \"stageN-test\" directory.\n     Libtest,\n+\n+    /// This cargo is going to build librustc and compiler libraries, placing\n+    /// output in the \"stageN-rustc\" directory.\n     Librustc,\n+\n+    /// This cargo is going to some build tool, placing output in the\n+    /// \"stageN-tools\" directory.\n     Tool,\n }\n \n impl Build {\n+    /// Creates a new set of build configuration from the `flags` on the command\n+    /// line and the filesystem `config`.\n+    ///\n+    /// By default all build output will be placed in the current directory.\n     pub fn new(flags: Flags, config: Config) -> Build {\n         let cwd = t!(env::current_dir());\n         let src = flags.src.clone().unwrap_or(cwd.clone());\n@@ -141,6 +192,7 @@ impl Build {\n         }\n     }\n \n+    /// Executes the entire build, as configured by the flags and configuration.\n     pub fn build(&mut self) {\n         use build::step::Source::*;\n \n@@ -161,6 +213,16 @@ impl Build {\n         self.verbose(\"updating submodules\");\n         self.update_submodules();\n \n+        // The main loop of the build system.\n+        //\n+        // The `step::all` function returns a topographically sorted list of all\n+        // steps that need to be executed as part of this build. Each step has a\n+        // corresponding entry in `step.rs` and indicates some unit of work that\n+        // needs to be done as part of the build.\n+        //\n+        // Almost all of these are simple one-liners that shell out to the\n+        // corresponding functionality in the extra modules, where more\n+        // documentation can be found.\n         for target in step::all(self) {\n             let doc_out = self.out.join(&target.target).join(\"doc\");\n             match target.src {\n@@ -338,6 +400,10 @@ impl Build {\n         }\n     }\n \n+    /// Updates all git submodules that we have.\n+    ///\n+    /// This will detect if any submodules are out of date an run the necessary\n+    /// commands to sync them all with upstream.\n     fn update_submodules(&self) {\n         if !self.config.submodules {\n             return\n@@ -350,6 +416,11 @@ impl Build {\n             cmd.current_dir(&self.src).arg(\"submodule\");\n             return cmd\n         };\n+\n+        // FIXME: this takes a seriously long time to execute on Windows and a\n+        //        nontrivial amount of time on Unix, we should have a better way\n+        //        of detecting whether we need to run all the submodule commands\n+        //        below.\n         let out = output(git_submodule().arg(\"status\"));\n         if !out.lines().any(|l| l.starts_with(\"+\") || l.starts_with(\"-\")) {\n             return\n@@ -366,8 +437,9 @@ impl Build {\n                                 .arg(\"git\").arg(\"checkout\").arg(\".\"));\n     }\n \n-    /// Clear out `dir` if our build has been flagged as dirty, and also set\n-    /// ourselves as dirty if `file` changes when `f` is executed.\n+    /// Clear out `dir` if `input` is newer.\n+    ///\n+    /// After this executes, it will also ensure that `dir` exists.\n     fn clear_if_dirty(&self, dir: &Path, input: &Path) {\n         let stamp = dir.join(\".stamp\");\n         if mtime(&stamp) < mtime(input) {\n@@ -381,8 +453,10 @@ impl Build {\n     /// Prepares an invocation of `cargo` to be run.\n     ///\n     /// This will create a `Command` that represents a pending execution of\n-    /// Cargo for the specified stage, whether or not the standard library is\n-    /// being built, and using the specified compiler targeting `target`.\n+    /// Cargo. This cargo will be configured to use `compiler` as the actual\n+    /// rustc compiler, its output will be scoped by `mode`'s output directory,\n+    /// it will pass the `--target` flag for the specified `target`, and will be\n+    /// executing the Cargo command `cmd`.\n     fn cargo(&self,\n              compiler: &Compiler,\n              mode: Mode,\n@@ -398,6 +472,9 @@ impl Build {\n         // Customize the compiler we're running. Specify the compiler to cargo\n         // as our shim and then pass it some various options used to configure\n         // how the actual compiler itself is called.\n+        //\n+        // These variables are primarily all read by\n+        // src/bootstrap/{rustc,rustdoc.rs}\n         cargo.env(\"RUSTC\", self.out.join(\"bootstrap/debug/rustc\"))\n              .env(\"RUSTC_REAL\", self.compiler_path(compiler))\n              .env(\"RUSTC_STAGE\", compiler.stage.to_string())\n@@ -414,16 +491,7 @@ impl Build {\n              .env(\"RUSTDOC_REAL\", self.rustdoc(compiler))\n              .env(\"RUSTC_FLAGS\", self.rustc_flags(target).join(\" \"));\n \n-        // Set the bootstrap key depending on which stage compiler we're using.\n-        // In stage0 we're using a previously released stable compiler, so we\n-        // use the stage0 bootstrap key. Otherwise we use our own build's\n-        // bootstrap key.\n-        let bootstrap_key = if compiler.is_snapshot(self) {\n-            &self.bootstrap_key_stage0\n-        } else {\n-            &self.bootstrap_key\n-        };\n-        cargo.env(\"RUSTC_BOOTSTRAP_KEY\", bootstrap_key);\n+        self.add_bootstrap_key(compiler, &mut cargo);\n \n         // Specify some various options for build scripts used throughout\n         // the build.\n@@ -443,7 +511,7 @@ impl Build {\n \n         // Environment variables *required* needed throughout the build\n         //\n-        // FIXME: should update code to not require this env vars\n+        // FIXME: should update code to not require this env var\n         cargo.env(\"CFG_COMPILER_HOST_TRIPLE\", target);\n \n         if self.config.verbose || self.flags.verbose {\n@@ -522,6 +590,12 @@ impl Build {\n         if self.config.rust_optimize {\"release\"} else {\"debug\"}\n     }\n \n+    /// Returns the sysroot for the `compiler` specified that *this build system\n+    /// generates*.\n+    ///\n+    /// That is, the sysroot for the stage0 compiler is not what the compiler\n+    /// thinks it is by default, but it's the same as the default for stages\n+    /// 1-3.\n     fn sysroot(&self, compiler: &Compiler) -> PathBuf {\n         if compiler.stage == 0 {\n             self.out.join(compiler.host).join(\"stage0-sysroot\")\n@@ -530,6 +604,8 @@ impl Build {\n         }\n     }\n \n+    /// Returns the libdir where the standard library and other artifacts are\n+    /// found for a compiler's sysroot.\n     fn sysroot_libdir(&self, compiler: &Compiler, target: &str) -> PathBuf {\n         self.sysroot(compiler).join(\"lib\").join(\"rustlib\")\n             .join(target).join(\"lib\")\n@@ -561,11 +637,17 @@ impl Build {\n     }\n \n     /// Root output directory for LLVM compiled for `target`\n+    ///\n+    /// Note that if LLVM is configured externally then the directory returned\n+    /// will likely be empty.\n     fn llvm_out(&self, target: &str) -> PathBuf {\n         self.out.join(target).join(\"llvm\")\n     }\n \n-    /// Returns the path to `llvm-config` for the specified target\n+    /// Returns the path to `llvm-config` for the specified target.\n+    ///\n+    /// If a custom `llvm-config` was specified for target then that's returned\n+    /// instead.\n     fn llvm_config(&self, target: &str) -> PathBuf {\n         let target_config = self.config.target_config.get(target);\n         if let Some(s) = target_config.and_then(|c| c.llvm_config.as_ref()) {\n@@ -576,7 +658,7 @@ impl Build {\n         }\n     }\n \n-    /// Returns the path to `llvm-config` for the specified target\n+    /// Returns the path to `FileCheck` binary for the specified target\n     fn llvm_filecheck(&self, target: &str) -> PathBuf {\n         let target_config = self.config.target_config.get(target);\n         if let Some(s) = target_config.and_then(|c| c.llvm_config.as_ref()) {\n@@ -603,15 +685,37 @@ impl Build {\n         self.out.join(target).join(\"rust-test-helpers\")\n     }\n \n+    /// Adds the compiler's directory of dynamic libraries to `cmd`'s dynamic\n+    /// library lookup path.\n     fn add_rustc_lib_path(&self, compiler: &Compiler, cmd: &mut Command) {\n         // Windows doesn't need dylib path munging because the dlls for the\n         // compiler live next to the compiler and the system will find them\n         // automatically.\n-        if cfg!(windows) { return }\n+        if cfg!(windows) {\n+            return\n+        }\n \n         add_lib_path(vec![self.rustc_libdir(compiler)], cmd);\n     }\n \n+    /// Adds the compiler's bootstrap key to the environment of `cmd`.\n+    fn add_bootstrap_key(&self, compiler: &Compiler, cmd: &mut Command) {\n+        // In stage0 we're using a previously released stable compiler, so we\n+        // use the stage0 bootstrap key. Otherwise we use our own build's\n+        // bootstrap key.\n+        let bootstrap_key = if compiler.is_snapshot(self) {\n+            &self.bootstrap_key_stage0\n+        } else {\n+            &self.bootstrap_key\n+        };\n+        cmd.env(\"RUSTC_BOOTSTRAP_KEY\", bootstrap_key);\n+    }\n+\n+    /// Returns the compiler's libdir where it stores the dynamic libraries that\n+    /// it itself links against.\n+    ///\n+    /// For example this returns `<sysroot>/lib` on Unix and `<sysroot>/bin` on\n+    /// Windows.\n     fn rustc_libdir(&self, compiler: &Compiler) -> PathBuf {\n         if compiler.is_snapshot(self) {\n             self.rustc_snapshot_libdir()\n@@ -620,30 +724,38 @@ impl Build {\n         }\n     }\n \n+    /// Returns the libdir of the snapshot compiler.\n     fn rustc_snapshot_libdir(&self) -> PathBuf {\n         self.rustc.parent().unwrap().parent().unwrap()\n             .join(libdir(&self.config.build))\n     }\n \n+    /// Runs a command, printing out nice contextual information if it fails.\n     fn run(&self, cmd: &mut Command) {\n         self.verbose(&format!(\"running: {:?}\", cmd));\n         run_silent(cmd)\n     }\n \n+    /// Prints a message if this build is configured in verbose mode.\n     fn verbose(&self, msg: &str) {\n         if self.flags.verbose || self.config.verbose {\n             println!(\"{}\", msg);\n         }\n     }\n \n+    /// Returns the number of parallel jobs that have been configured for this\n+    /// build.\n     fn jobs(&self) -> u32 {\n         self.flags.jobs.unwrap_or(num_cpus::get() as u32)\n     }\n \n+    /// Returns the path to the C compiler for the target specified.\n     fn cc(&self, target: &str) -> &Path {\n         self.cc[target].0.path()\n     }\n \n+    /// Returns a list of flags to pass to the C compiler for the target\n+    /// specified.\n     fn cflags(&self, target: &str) -> Vec<String> {\n         // Filter out -O and /O (the optimization flags) that we picked up from\n         // gcc-rs because the build scripts will determine that for themselves.\n@@ -663,15 +775,26 @@ impl Build {\n         return base\n     }\n \n+    /// Returns the path to the `ar` archive utility for the target specified.\n     fn ar(&self, target: &str) -> &Path {\n         &self.cc[target].1\n     }\n \n+    /// Returns the path to the C++ compiler for the target specified, may panic\n+    /// if no C++ compiler was configured for the target.\n     fn cxx(&self, target: &str) -> &Path {\n         self.cxx[target].path()\n     }\n \n+    /// Returns flags to pass to the compiler to generate code for `target`.\n     fn rustc_flags(&self, target: &str) -> Vec<String> {\n+        // New flags should be added here with great caution!\n+        //\n+        // It's quite unfortunate to **require** flags to generate code for a\n+        // target, so it should only be passed here if absolutely necessary!\n+        // Most default configuration should be done through target specs rather\n+        // than an entry here.\n+\n         let mut base = Vec::new();\n         if target != self.config.build && !target.contains(\"msvc\") {\n             base.push(format!(\"-Clinker={}\", self.cc(target).display()));\n@@ -681,10 +804,12 @@ impl Build {\n }\n \n impl<'a> Compiler<'a> {\n+    /// Creates a new complier for the specified stage/host\n     fn new(stage: u32, host: &'a str) -> Compiler<'a> {\n         Compiler { stage: stage, host: host }\n     }\n \n+    /// Returns whether this is a snapshot compiler for `build`'s configuration\n     fn is_snapshot(&self, build: &Build) -> bool {\n         self.stage == 0 && self.host == build.config.build\n     }"}, {"sha": "5691b2da6a448856b76443106c817bfd606ea1d0", "filename": "src/bootstrap/build/native.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/27edda241157da188d4fa94ed341a0e90160fa2f/src%2Fbootstrap%2Fbuild%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27edda241157da188d4fa94ed341a0e90160fa2f/src%2Fbootstrap%2Fbuild%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fnative.rs?ref=27edda241157da188d4fa94ed341a0e90160fa2f", "patch": "@@ -8,6 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! Compilation of native dependencies like LLVM.\n+//!\n+//! Native projects like LLVM unfortunately aren't suited just yet for\n+//! compilation in build scripts that Cargo has. This is because thie\n+//! compilation takes a *very* long time but also because we don't want to\n+//! compile LLVM 3 times as part of a normal bootstrap (we want it cached).\n+//!\n+//! LLVM and compiler-rt are essentially just wired up to everything else to\n+//! ensure that they're always in place if needed.\n+\n use std::path::Path;\n use std::process::Command;\n use std::fs;\n@@ -19,6 +29,7 @@ use gcc;\n use build::Build;\n use build::util::{exe, staticlib, up_to_date};\n \n+/// Compile LLVM for `target`.\n pub fn llvm(build: &Build, target: &str) {\n     // If we're using a custom LLVM bail out here, but we can only use a\n     // custom LLVM for the build triple.\n@@ -116,6 +127,10 @@ fn check_llvm_version(build: &Build, llvm_config: &Path) {\n     panic!(\"\\n\\nbad LLVM version: {}, need >=3.5\\n\\n\", version)\n }\n \n+/// Compiles the `compiler-rt` library, or at least the builtins part of it.\n+///\n+/// This uses the CMake build system and an existing LLVM build directory to\n+/// compile the project.\n pub fn compiler_rt(build: &Build, target: &str) {\n     let dst = build.compiler_rt_out(target);\n     let arch = target.split('-').next().unwrap();\n@@ -171,6 +186,8 @@ pub fn compiler_rt(build: &Build, target: &str) {\n     cfg.build();\n }\n \n+/// Compiles the `rust_test_helpers.c` library which we used in various\n+/// `run-pass` test suites for ABI testing.\n pub fn test_helpers(build: &Build, target: &str) {\n     let dst = build.test_helpers_out(target);\n     let src = build.src.join(\"src/rt/rust_test_helpers.c\");"}, {"sha": "a290527742982421e067f85001d1b7e8199a6a96", "filename": "src/bootstrap/build/sanity.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/27edda241157da188d4fa94ed341a0e90160fa2f/src%2Fbootstrap%2Fbuild%2Fsanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27edda241157da188d4fa94ed341a0e90160fa2f/src%2Fbootstrap%2Fbuild%2Fsanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fsanity.rs?ref=27edda241157da188d4fa94ed341a0e90160fa2f", "patch": "@@ -8,6 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! Sanity checking performed by rustbuild before actually executing anything.\n+//!\n+//! This module contains the implementation of ensuring that the build\n+//! environment looks reasonable before progressing. This will verify that\n+//! various programs like git and python exist, along with ensuring that all C\n+//! compilers for cross-compiling are found.\n+//!\n+//! In theory if we get past this phase it's a bug if a build fails, but in\n+//! practice that's likely not true!\n+\n use std::collections::HashSet;\n use std::env;\n use std::ffi::{OsStr, OsString};"}, {"sha": "4a336589b44c53e0ebec066d79877f6e80909efa", "filename": "src/bootstrap/build/step.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/27edda241157da188d4fa94ed341a0e90160fa2f/src%2Fbootstrap%2Fbuild%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27edda241157da188d4fa94ed341a0e90160fa2f/src%2Fbootstrap%2Fbuild%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fstep.rs?ref=27edda241157da188d4fa94ed341a0e90160fa2f", "patch": "@@ -8,6 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! Major workhorse of rustbuild, definition and dependencies between stages of\n+//! the copmile.\n+//!\n+//! The primary purpose of this module is to define the various `Step`s of\n+//! execution of the build. Each `Step` has a corresponding `Source` indicating\n+//! what it's actually doing along with a number of dependencies which must be\n+//! executed first.\n+//!\n+//! This module will take the CLI as input and calculate the steps required for\n+//! the build requested, ensuring that all intermediate pieces are in place.\n+//! Essentially this module is a `make`-replacement, but not as good.\n+\n use std::collections::HashSet;\n \n use build::{Build, Compiler};\n@@ -18,6 +30,15 @@ pub struct Step<'a> {\n     pub target: &'a str,\n }\n \n+/// Macro used to iterate over all targets that are recognized by the build\n+/// system.\n+///\n+/// Whenever a new step is added it will involve adding an entry here, updating\n+/// the dependencies section below, and then adding an implementation of the\n+/// step in `build/mod.rs`.\n+///\n+/// This macro takes another macro as an argument and then calls that macro with\n+/// all steps that the build system knows about.\n macro_rules! targets {\n     ($m:ident) => {\n         $m! {\n@@ -110,6 +131,9 @@ macro_rules! targets {\n     }\n }\n \n+// Define the `Source` enum by iterating over all the steps and peeling out just\n+// the types that we want to define.\n+\n macro_rules! item { ($a:item) => ($a) }\n \n macro_rules! define_source {\n@@ -125,6 +149,12 @@ macro_rules! define_source {\n \n targets!(define_source);\n \n+/// Calculate a list of all steps described by `build`.\n+///\n+/// This will inspect the flags passed in on the command line and use that to\n+/// build up a list of steps to execute. These steps will then be transformed\n+/// into a topologically sorted list which when executed left-to-right will\n+/// correctly sequence the entire build.\n pub fn all(build: &Build) -> Vec<Step> {\n     let mut ret = Vec::new();\n     let mut all = HashSet::new();\n@@ -146,6 +176,8 @@ pub fn all(build: &Build) -> Vec<Step> {\n     }\n }\n \n+/// Determines what top-level targets are requested as part of this build,\n+/// returning them as a list.\n fn top_level(build: &Build) -> Vec<Step> {\n     let mut targets = Vec::new();\n     let stage = build.flags.stage.unwrap_or(2);\n@@ -161,8 +193,10 @@ fn top_level(build: &Build) -> Vec<Step> {\n                      .unwrap_or(host.target)\n     };\n \n+    // First, try to find steps on the command line.\n     add_steps(build, stage, &host, &target, &mut targets);\n \n+    // If none are specified, then build everything.\n     if targets.len() == 0 {\n         let t = Step {\n             src: Source::Llvm { _dummy: () },\n@@ -260,8 +294,14 @@ impl<'a> Step<'a> {\n         Step { target: target, src: self.src.clone() }\n     }\n \n+    // Define ergonomic constructors for each step defined above so they can be\n+    // easily constructed.\n     targets!(constructors);\n \n+    /// Mapping of all dependencies for rustbuild.\n+    ///\n+    /// This function receives a step, the build that we're building for, and\n+    /// then returns a list of all the dependencies of that step.\n     pub fn deps(&self, build: &'a Build) -> Vec<Step<'a>> {\n         match self.src {\n             Source::Rustc { stage: 0 } => {"}, {"sha": "36ce064914227598cdf170ff007d574947c575e5", "filename": "src/bootstrap/build/util.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/27edda241157da188d4fa94ed341a0e90160fa2f/src%2Fbootstrap%2Fbuild%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27edda241157da188d4fa94ed341a0e90160fa2f/src%2Fbootstrap%2Fbuild%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Futil.rs?ref=27edda241157da188d4fa94ed341a0e90160fa2f", "patch": "@@ -8,6 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! Various utility functions used throughout rustbuild.\n+//!\n+//! Simple things like testing the various filesystem operations here and there,\n+//! not a lot of interesting happenings here unfortunately.\n+\n use std::env;\n use std::path::{Path, PathBuf};\n use std::fs;\n@@ -16,6 +21,7 @@ use std::process::Command;\n use bootstrap::{dylib_path, dylib_path_var};\n use filetime::FileTime;\n \n+/// Returns the `name` as the filename of a static library for `target`.\n pub fn staticlib(name: &str, target: &str) -> String {\n     if target.contains(\"windows-msvc\") {\n         format!(\"{}.lib\", name)\n@@ -24,12 +30,15 @@ pub fn staticlib(name: &str, target: &str) -> String {\n     }\n }\n \n+/// Returns the last-modified time for `path`, or zero if it doesn't exist.\n pub fn mtime(path: &Path) -> FileTime {\n     fs::metadata(path).map(|f| {\n         FileTime::from_last_modification_time(&f)\n     }).unwrap_or(FileTime::zero())\n }\n \n+/// Copies a file from `src` to `dst`, attempting to use hard links and then\n+/// falling back to an actually filesystem copy if necessary.\n pub fn copy(src: &Path, dst: &Path) {\n     let res = fs::hard_link(src, dst);\n     let res = res.or_else(|_| fs::copy(src, dst).map(|_| ()));\n@@ -39,6 +48,8 @@ pub fn copy(src: &Path, dst: &Path) {\n     }\n }\n \n+/// Copies the `src` directory recursively to `dst`. Both are assumed to exist\n+/// when this function is called.\n pub fn cp_r(src: &Path, dst: &Path) {\n     for f in t!(fs::read_dir(src)) {\n         let f = t!(f);\n@@ -66,14 +77,18 @@ pub fn exe(name: &str, target: &str) -> String {\n     }\n }\n \n+/// Returns whether the file name given looks like a dynamic library.\n pub fn is_dylib(name: &str) -> bool {\n     name.ends_with(\".dylib\") || name.ends_with(\".so\") || name.ends_with(\".dll\")\n }\n \n+/// Returns the corresponding relative library directory that the compiler's\n+/// dylibs will be found in.\n pub fn libdir(target: &str) -> &'static str {\n     if target.contains(\"windows\") {\"bin\"} else {\"lib\"}\n }\n \n+/// Adds a list of lookup paths to `cmd`'s dynamic library lookup path.\n pub fn add_lib_path(path: Vec<PathBuf>, cmd: &mut Command) {\n     let mut list = dylib_path();\n     for path in path {\n@@ -82,7 +97,10 @@ pub fn add_lib_path(path: Vec<PathBuf>, cmd: &mut Command) {\n     cmd.env(dylib_path_var(), t!(env::join_paths(list)));\n }\n \n-#[allow(dead_code)] // this will be used soon\n+/// Returns whether `dst` is up to date given that the file or files in `src`\n+/// are used to generate it.\n+///\n+/// Uses last-modified time checks to verify this.\n pub fn up_to_date(src: &Path, dst: &Path) -> bool {\n     let threshold = mtime(dst);\n     let meta = t!(fs::metadata(src));"}, {"sha": "a0e6ab1a2d2d01d8f873aef7d817a7dd117c28f6", "filename": "src/bootstrap/config.toml.example", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/27edda241157da188d4fa94ed341a0e90160fa2f/src%2Fbootstrap%2Fconfig.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/27edda241157da188d4fa94ed341a0e90160fa2f/src%2Fbootstrap%2Fconfig.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.toml.example?ref=27edda241157da188d4fa94ed341a0e90160fa2f", "patch": "@@ -0,0 +1,154 @@\n+# Sample TOML configuration file for building Rust.\n+#\n+# All options are commented out by default in this file, and they're commented\n+# out with their default values. The build system by default looks for\n+# `config.toml` in the current directory of a build for build configuration, but\n+# a custom configuration file can also be specified with `--config` to the build\n+# system.\n+\n+# =============================================================================\n+# Tweaking how LLVM is compiled\n+# =============================================================================\n+[llvm]\n+\n+# Indicates whether the LLVM build is a Release or Debug build\n+#optimize = true\n+\n+# Indicates whether the LLVM assertions are enabled or not\n+#assertions = false\n+\n+# Indicates whether ccache is used when building LLVM\n+#ccache = false\n+\n+# If an external LLVM root is specified, we automatically check the version by\n+# default to make sure it's within the range that we're expecting, but setting\n+# this flag will indicate that this version check should not be done.\n+#version-check = false\n+\n+# Link libstdc++ statically into the librustc_llvm instead of relying on a\n+# dynamic version to be available.\n+#static-libstdcpp = false\n+\n+# Tell the LLVM build system to use Ninja instead of the platform default for\n+# the generated build system. This can sometimes be faster than make, for\n+# example.\n+#ninja = false\n+\n+# =============================================================================\n+# General build configuration options\n+# =============================================================================\n+[build]\n+\n+# Build triple for the original snapshot compiler. This must be a compiler that\n+# nightlies are already produced for. The current platform must be able to run\n+# binaries of this build triple and the nightly will be used to bootstrap the\n+# first compiler.\n+#build = \"x86_64-unknown-linux-gnu\"    # defaults to your host platform\n+\n+# In addition to the build triple, other triples to produce full compiler\n+# toolchains for. Each of these triples will be bootstrapped from the build\n+# triple and then will continue to bootstrap themselves. This platform must\n+# currently be able to run all of the triples provided here.\n+#host = [\"x86_64-unknown-linux-gnu\"]   # defaults to just the build triple\n+\n+# In addition to all host triples, other triples to produce the standard library\n+# for. Each host triple will be used to produce a copy of the standard library\n+# for each target triple.\n+#target = [\"x86_64-unknown-linux-gnu\"] # defaults to just the build triple\n+\n+# Instead of downloading the src/nightlies.txt version of Cargo specified, use\n+# this Cargo binary instead to build all Rust code\n+#cargo = \"/path/to/bin/cargo\"\n+\n+# Instead of downloading the src/nightlies.txt version of the compiler\n+# specified, use this rustc binary instead as the stage0 snapshot compiler.\n+#rustc = \"/path/to/bin/rustc\"\n+\n+# Flag to specify whether any documentation is built. If false, rustdoc and\n+# friends will still be compiled but they will not be used to generate any\n+# documentation.\n+#docs = true\n+\n+# Indicate whether the compiler should be documented in addition to the standard\n+# library and facade crates.\n+#compiler-docs = false\n+\n+# =============================================================================\n+# Options for compiling Rust code itself\n+# =============================================================================\n+[rust]\n+\n+# Whether or not to optimize the compiler and standard library\n+#optimize = true\n+\n+# Number of codegen units to use for each compiler invocation. A value of 0\n+# means \"the number of cores on this machine\", and 1+ is passed through to the\n+# compiler.\n+#codegen-units = 1\n+\n+# Whether or not debug assertions are enabled for the compiler and standard\n+# library\n+#debug-assertions = false\n+\n+# Whether or not debuginfo is emitted\n+#debuginfo = false\n+\n+# Whether or not jemalloc is built and enabled\n+#use-jemalloc = true\n+\n+# Whether or not jemalloc is built with its debug option set\n+#debug-jemalloc = false\n+\n+# The default linker that will be used by the generated compiler. Note that this\n+# is not the linker used to link said compiler.\n+#default-linker = \"cc\"\n+\n+# The default ar utility that will be used by the generated compiler if LLVM\n+# cannot be used. Note that this is not used to assemble said compiler.\n+#default-ar = \"ar\"\n+\n+# The \"channel\" for the Rust build to produce. The stable/beta channels only\n+# allow using stable features, whereas the nightly and dev channels allow using\n+# nightly features\n+#channel = \"dev\"\n+\n+# The root location of the MUSL installation directory. The library directory\n+# will also need to contain libunwind.a for an unwinding implementation.\n+#musl-root = \"...\"\n+\n+# By default the `rustc` executable is built with `-Wl,-rpath` flags on Unix\n+# platforms to ensure that the compiler is usable by default from the build\n+# directory (as it links to a number of dynamic libraries). This may not be\n+# desired in distributions, for example.\n+#rpath = true\n+\n+# =============================================================================\n+# Options for specific targets\n+#\n+# Each of the following options is scoped to the specific target triple in\n+# question and is used for determining how to compile each target.\n+# =============================================================================\n+[target.x86_64-unknown-linux-gnu]\n+\n+# C compiler to be used to compiler C code and link Rust code. Note that the\n+# default value is platform specific, and if not specified it may also depend on\n+# what platform is crossing to what platform.\n+#cc = \"cc\"\n+\n+# C++ compiler to be used to compiler C++ code (e.g. LLVM and our LLVM shims).\n+# This is only used for host targets.\n+#cxx = \"c++\"\n+\n+# Path to the `llvm-config` binary of the installation of a custom LLVM to link\n+# against. Note that if this is specifed we don't compile LLVM at all for this\n+# target.\n+#llvm-config = \"../path/to/llvm/root/bin/llvm-config\"\n+\n+# Path to the custom jemalloc static library to link into the standard library\n+# by default. This is only used if jemalloc is still enabled above\n+#jemalloc = \"/path/to/jemalloc/libjemalloc_pic.a\"\n+\n+# If this target is for Android, this option will be required to specify where\n+# the NDK for the target lives. This is used to find the C compiler to link and\n+# build native code.\n+#android-ndk = \"/path/to/ndk\""}, {"sha": "ef6184d6ca76cf8fc3dbbb6b40e6dd0452a75098", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/27edda241157da188d4fa94ed341a0e90160fa2f/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27edda241157da188d4fa94ed341a0e90160fa2f/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=27edda241157da188d4fa94ed341a0e90160fa2f", "patch": "@@ -8,10 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! A small helper library shared between the build system's executables\n+//!\n+//! Currently this just has some simple utilities for modifying the dynamic\n+//! library lookup path.\n+\n use std::env;\n use std::ffi::OsString;\n use std::path::PathBuf;\n \n+/// Returns the environment variable which the dynamic library lookup path\n+/// resides in for this platform.\n pub fn dylib_path_var() -> &'static str {\n     if cfg!(target_os = \"windows\") {\n         \"PATH\"\n@@ -22,6 +29,8 @@ pub fn dylib_path_var() -> &'static str {\n     }\n }\n \n+/// Parses the `dylib_path_var()` environment variable, returning a list of\n+/// paths that are members of this lookup path.\n pub fn dylib_path() -> Vec<PathBuf> {\n     env::split_paths(&env::var_os(dylib_path_var()).unwrap_or(OsString::new()))\n         .collect()"}, {"sha": "18d03b5d59c29864ec9266c7de1b57da725ac10b", "filename": "src/bootstrap/main.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/27edda241157da188d4fa94ed341a0e90160fa2f/src%2Fbootstrap%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27edda241157da188d4fa94ed341a0e90160fa2f/src%2Fbootstrap%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmain.rs?ref=27edda241157da188d4fa94ed341a0e90160fa2f", "patch": "@@ -8,6 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! rustbuild, the Rust build system\n+//!\n+//! This is the entry point for the build system used to compile the `rustc`\n+//! compiler. Lots of documentation can be found in the `README.md` file next to\n+//! this file, and otherwise documentation can be found throughout the `build`\n+//! directory in each respective module.\n+\n #![deny(warnings)]\n \n extern crate bootstrap;\n@@ -32,8 +39,11 @@ fn main() {\n     let args = env::args().skip(1).collect::<Vec<_>>();\n     let flags = Flags::parse(&args);\n     let mut config = Config::parse(&flags.build, flags.config.clone());\n+\n+    // compat with `./configure` while we're still using that\n     if std::fs::metadata(\"config.mk\").is_ok() {\n         config.update_with_config_mk();\n     }\n+\n     Build::new(flags, config).build();\n }"}, {"sha": "99e16035d1d4f0ba5f46d18719c565dd87cf0dcb", "filename": "src/bootstrap/rustc.rs", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/27edda241157da188d4fa94ed341a0e90160fa2f/src%2Fbootstrap%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27edda241157da188d4fa94ed341a0e90160fa2f/src%2Fbootstrap%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Frustc.rs?ref=27edda241157da188d4fa94ed341a0e90160fa2f", "patch": "@@ -29,7 +29,6 @@ extern crate bootstrap;\n \n use std::env;\n use std::ffi::OsString;\n-use std::path::PathBuf;\n use std::process::Command;\n \n fn main() {\n@@ -54,37 +53,33 @@ fn main() {\n     cmd.args(&args)\n        .arg(\"--cfg\").arg(format!(\"stage{}\", env::var(\"RUSTC_STAGE\").unwrap()));\n \n-    if target.is_none() {\n-        // Build scripts are always built with the snapshot compiler, so we need\n-        // to be sure to set up the right path information for the OS dynamic\n-        // linker to find the libraries in question.\n-        if let Some(p) = env::var_os(\"RUSTC_SNAPSHOT_LIBDIR\") {\n-            let mut path = bootstrap::dylib_path();\n-            path.insert(0, PathBuf::from(p));\n-            cmd.env(bootstrap::dylib_path_var(), env::join_paths(path).unwrap());\n-        }\n-    } else {\n+    if let Some(target) = target {\n+        // The stage0 compiler has a special sysroot distinct from what we\n+        // actually downloaded, so we just always pass the `--sysroot` option.\n         cmd.arg(\"--sysroot\").arg(env::var_os(\"RUSTC_SYSROOT\").unwrap());\n \n         // When we build Rust dylibs they're all intended for intermediate\n         // usage, so make sure we pass the -Cprefer-dynamic flag instead of\n         // linking all deps statically into the dylib.\n         cmd.arg(\"-Cprefer-dynamic\");\n \n+        // Help the libc crate compile by assisting it in finding the MUSL\n+        // native libraries.\n         if let Some(s) = env::var_os(\"MUSL_ROOT\") {\n             let mut root = OsString::from(\"native=\");\n             root.push(&s);\n             root.push(\"/lib\");\n             cmd.arg(\"-L\").arg(&root);\n         }\n+\n+        // Pass down extra flags, commonly used to configure `-Clinker` when\n+        // cross compiling.\n         if let Ok(s) = env::var(\"RUSTC_FLAGS\") {\n             cmd.args(&s.split(\" \").filter(|s| !s.is_empty()).collect::<Vec<_>>());\n         }\n-    }\n \n-    // Set various options from config.toml to configure how we're building\n-    // code.\n-    if let Some(target) = target {\n+        // Set various options from config.toml to configure how we're building\n+        // code.\n         if env::var(\"RUSTC_DEBUGINFO\") == Ok(\"true\".to_string()) {\n             cmd.arg(\"-g\");\n         }"}]}