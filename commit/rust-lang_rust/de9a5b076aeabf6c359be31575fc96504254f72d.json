{"sha": "de9a5b076aeabf6c359be31575fc96504254f72d", "node_id": "C_kwDOAAsO6NoAKGRlOWE1YjA3NmFlYWJmNmMzNTliZTMxNTc1ZmM5NjUwNDI1NGY3MmQ", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-01-14T12:01:27Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-01-14T12:09:06Z"}, "message": "Make the inlining destination a `Local`.", "tree": {"sha": "46f13f400ba4558529c1d14e3aa3d2344627fdbd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/46f13f400ba4558529c1d14e3aa3d2344627fdbd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de9a5b076aeabf6c359be31575fc96504254f72d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de9a5b076aeabf6c359be31575fc96504254f72d", "html_url": "https://github.com/rust-lang/rust/commit/de9a5b076aeabf6c359be31575fc96504254f72d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de9a5b076aeabf6c359be31575fc96504254f72d/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c327e1133579fc2657ea68c5ed883e3dd848443", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c327e1133579fc2657ea68c5ed883e3dd848443", "html_url": "https://github.com/rust-lang/rust/commit/1c327e1133579fc2657ea68c5ed883e3dd848443"}], "stats": {"total": 121, "additions": 96, "deletions": 25}, "files": [{"sha": "f652e07915405241fbc6964fdfa798866c557b13", "filename": "compiler/rustc_mir_transform/src/inline.rs", "status": "modified", "additions": 28, "deletions": 18, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/de9a5b076aeabf6c359be31575fc96504254f72d/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de9a5b076aeabf6c359be31575fc96504254f72d/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs?ref=de9a5b076aeabf6c359be31575fc96504254f72d", "patch": "@@ -542,6 +542,21 @@ impl<'tcx> Inliner<'tcx> {\n                     destination\n                 };\n \n+                // Always create a local to hold the destination, as `RETURN_PLACE` may appear\n+                // where a full `Place` is not allowed.\n+                let (remap_destination, destination_local) = if let Some(d) = dest.as_local() {\n+                    (false, d)\n+                } else {\n+                    (\n+                        true,\n+                        self.new_call_temp(\n+                            caller_body,\n+                            &callsite,\n+                            destination.ty(caller_body, self.tcx).ty,\n+                        ),\n+                    )\n+                };\n+\n                 // Copy the arguments if needed.\n                 let args: Vec<_> = self.make_call_args(args, &callsite, caller_body, &callee_body);\n \n@@ -560,7 +575,7 @@ impl<'tcx> Inliner<'tcx> {\n                     new_locals: Local::new(caller_body.local_decls.len())..,\n                     new_scopes: SourceScope::new(caller_body.source_scopes.len())..,\n                     new_blocks: BasicBlock::new(caller_body.basic_blocks.len())..,\n-                    destination: dest,\n+                    destination: destination_local,\n                     callsite_scope: caller_body.source_scopes[callsite.source_info.scope].clone(),\n                     callsite,\n                     cleanup_block: cleanup,\n@@ -591,6 +606,16 @@ impl<'tcx> Inliner<'tcx> {\n                     // To avoid repeated O(n) insert, push any new statements to the end and rotate\n                     // the slice once.\n                     let mut n = 0;\n+                    if remap_destination {\n+                        caller_body[block].statements.push(Statement {\n+                            source_info: callsite.source_info,\n+                            kind: StatementKind::Assign(Box::new((\n+                                dest,\n+                                Rvalue::Use(Operand::Move(destination_local.into())),\n+                            ))),\n+                        });\n+                        n += 1;\n+                    }\n                     for local in callee_body.vars_and_temps_iter().rev() {\n                         if !callee_body.local_decls[local].internal\n                             && integrator.always_live_locals.contains(local)\n@@ -959,7 +984,7 @@ struct Integrator<'a, 'tcx> {\n     new_locals: RangeFrom<Local>,\n     new_scopes: RangeFrom<SourceScope>,\n     new_blocks: RangeFrom<BasicBlock>,\n-    destination: Place<'tcx>,\n+    destination: Local,\n     callsite_scope: SourceScopeData<'tcx>,\n     callsite: &'a CallSite<'tcx>,\n     cleanup_block: Option<BasicBlock>,\n@@ -972,7 +997,7 @@ struct Integrator<'a, 'tcx> {\n impl Integrator<'_, '_> {\n     fn map_local(&self, local: Local) -> Local {\n         let new = if local == RETURN_PLACE {\n-            self.destination.local\n+            self.destination\n         } else {\n             let idx = local.index() - 1;\n             if idx < self.args.len() {\n@@ -1054,21 +1079,6 @@ impl<'tcx> MutVisitor<'tcx> for Integrator<'_, 'tcx> {\n     }\n \n     fn visit_place(&mut self, place: &mut Place<'tcx>, context: PlaceContext, location: Location) {\n-        for elem in place.projection {\n-            // FIXME: Make sure that return place is not used in an indexing projection, since it\n-            // won't be rebased as it is supposed to be.\n-            assert_ne!(ProjectionElem::Index(RETURN_PLACE), elem);\n-        }\n-\n-        // If this is the `RETURN_PLACE`, we need to rebase any projections onto it.\n-        let dest_proj_len = self.destination.projection.len();\n-        if place.local == RETURN_PLACE && dest_proj_len > 0 {\n-            let mut projs = Vec::with_capacity(dest_proj_len + place.projection.len());\n-            projs.extend(self.destination.projection);\n-            projs.extend(place.projection);\n-\n-            place.projection = self.tcx.intern_place_elems(&*projs);\n-        }\n         // Handles integrating any locals that occur in the base\n         // or projections\n         self.super_place(place, context, location)"}, {"sha": "a28da146e378659e68193505aeba97c8cb3d0d08", "filename": "tests/mir-opt/inline/inline_into_box_place.main.Inline.diff", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/de9a5b076aeabf6c359be31575fc96504254f72d/tests%2Fmir-opt%2Finline%2Finline_into_box_place.main.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/de9a5b076aeabf6c359be31575fc96504254f72d/tests%2Fmir-opt%2Finline%2Finline_into_box_place.main.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Finline%2Finline_into_box_place.main.Inline.diff?ref=de9a5b076aeabf6c359be31575fc96504254f72d", "patch": "@@ -11,13 +11,14 @@\n       let mut _6: ();                      // in scope 0 at $DIR/inline_into_box_place.rs:+1:42: +1:43\n       let mut _7: *const std::vec::Vec<u32>; // in scope 0 at $DIR/inline_into_box_place.rs:+1:29: +1:43\n +     let mut _8: &mut std::vec::Vec<u32>; // in scope 0 at $DIR/inline_into_box_place.rs:+1:33: +1:43\n++     let mut _9: std::vec::Vec<u32>;      // in scope 0 at $DIR/inline_into_box_place.rs:+1:33: +1:43\n       scope 1 {\n           debug _x => _1;                  // in scope 1 at $DIR/inline_into_box_place.rs:+1:9: +1:11\n       }\n       scope 2 {\n       }\n +     scope 3 (inlined Vec::<u32>::new) {  // at $DIR/inline_into_box_place.rs:8:33: 8:43\n-+         let mut _9: alloc::raw_vec::RawVec<u32>; // in scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n++         let mut _10: alloc::raw_vec::RawVec<u32>; // in scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n +     }\n   \n       bb0: {\n@@ -37,8 +38,9 @@\n -         (*_7) = Vec::<u32>::new() -> [return: bb2, unwind: bb5]; // scope 0 at $DIR/inline_into_box_place.rs:+1:33: +1:43\n +         StorageLive(_8);                 // scope 0 at $DIR/inline_into_box_place.rs:+1:33: +1:43\n +         _8 = &mut (*_7);                 // scope 0 at $DIR/inline_into_box_place.rs:+1:33: +1:43\n-+         StorageLive(_9);                 // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n-+         _9 = const _;                    // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n++         StorageLive(_9);                 // scope 0 at $DIR/inline_into_box_place.rs:+1:33: +1:43\n++         StorageLive(_10);                // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n++         _10 = const _;                   // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n                                            // mir::Constant\n -                                          // + span: $DIR/inline_into_box_place.rs:8:33: 8:41\n -                                          // + user_ty: UserType(1)\n@@ -49,10 +51,12 @@\n +                                          // + span: $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n +                                          // + user_ty: UserType(0)\n +                                          // + literal: Const { ty: alloc::raw_vec::RawVec<u32>, val: Unevaluated(alloc::raw_vec::RawVec::<T>::NEW, [u32], None) }\n-+         Deinit((*_8));                   // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n-+         ((*_8).0: alloc::raw_vec::RawVec<u32>) = move _9; // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n-+         ((*_8).1: usize) = const 0_usize; // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n-+         StorageDead(_9);                 // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n++         Deinit(_9);                      // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n++         (_9.0: alloc::raw_vec::RawVec<u32>) = move _10; // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n++         (_9.1: usize) = const 0_usize;   // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n++         StorageDead(_10);                // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n++         (*_8) = move _9;                 // scope 0 at $DIR/inline_into_box_place.rs:+1:33: +1:43\n++         StorageDead(_9);                 // scope 0 at $DIR/inline_into_box_place.rs:+1:33: +1:43\n +         StorageDead(_8);                 // scope 0 at $DIR/inline_into_box_place.rs:+1:33: +1:43\n           _1 = move _5;                    // scope 0 at $DIR/inline_into_box_place.rs:+1:29: +1:43\n           StorageDead(_5);                 // scope 0 at $DIR/inline_into_box_place.rs:+1:42: +1:43"}, {"sha": "97361fa5f4c3b8197bac2466fb9c0a8b33bebc87", "filename": "tests/mir-opt/inline/issue_106141.outer.Inline.diff", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/de9a5b076aeabf6c359be31575fc96504254f72d/tests%2Fmir-opt%2Finline%2Fissue_106141.outer.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/de9a5b076aeabf6c359be31575fc96504254f72d/tests%2Fmir-opt%2Finline%2Fissue_106141.outer.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Finline%2Fissue_106141.outer.Inline.diff?ref=de9a5b076aeabf6c359be31575fc96504254f72d", "patch": "@@ -0,0 +1,55 @@\n+- // MIR for `outer` before Inline\n++ // MIR for `outer` after Inline\n+  \n+  fn outer() -> usize {\n+      let mut _0: usize;                   // return place in scope 0 at $DIR/issue_106141.rs:+0:19: +0:24\n++     scope 1 (inlined inner) {            // at $DIR/issue_106141.rs:2:5: 2:12\n++         let mut _1: bool;                // in scope 1 at $DIR/issue_106141.rs:13:8: 13:21\n++         let mut _2: bool;                // in scope 1 at $DIR/issue_106141.rs:13:8: 13:21\n++         let mut _3: &[bool; 1];          // in scope 1 at $DIR/issue_106141.rs:11:18: 11:25\n++         scope 2 {\n++             debug buffer => _3;          // in scope 2 at $DIR/issue_106141.rs:11:9: 11:15\n++             scope 3 {\n++                 debug index => _0;       // in scope 3 at $DIR/issue_106141.rs:12:9: 12:14\n++             }\n++         }\n++     }\n+  \n+      bb0: {\n+-         _0 = inner() -> bb1;             // scope 0 at $DIR/issue_106141.rs:+1:5: +1:12\n++         StorageLive(_3);                 // scope 0 at $DIR/issue_106141.rs:+1:5: +1:12\n++         _3 = const _;                    // scope 1 at $DIR/issue_106141.rs:11:18: 11:25\n+                                           // mir::Constant\n+-                                          // + span: $DIR/issue_106141.rs:2:5: 2:10\n+-                                          // + literal: Const { ty: fn() -> usize {inner}, val: Value(<ZST>) }\n++                                          // + span: $DIR/issue_106141.rs:11:18: 11:25\n++                                          // + literal: Const { ty: &[bool; 1], val: Unevaluated(inner, [], Some(promoted[0])) }\n++         _0 = index() -> bb1;             // scope 2 at $DIR/issue_106141.rs:12:17: 12:24\n++                                          // mir::Constant\n++                                          // + span: $DIR/issue_106141.rs:12:17: 12:22\n++                                          // + literal: Const { ty: fn() -> usize {index}, val: Value(<ZST>) }\n+      }\n+  \n+      bb1: {\n++         StorageLive(_1);                 // scope 3 at $DIR/issue_106141.rs:13:8: 13:21\n++         _2 = Lt(_0, const 1_usize);      // scope 3 at $DIR/issue_106141.rs:13:8: 13:21\n++         assert(move _2, \"index out of bounds: the length is {} but the index is {}\", const 1_usize, _0) -> bb2; // scope 3 at $DIR/issue_106141.rs:13:8: 13:21\n++     }\n++ \n++     bb2: {\n++         _1 = (*_3)[_0];                  // scope 3 at $DIR/issue_106141.rs:13:8: 13:21\n++         switchInt(move _1) -> [0: bb3, otherwise: bb4]; // scope 3 at $DIR/issue_106141.rs:13:8: 13:21\n++     }\n++ \n++     bb3: {\n++         _0 = const 0_usize;              // scope 3 at $DIR/issue_106141.rs:16:9: 16:10\n++         goto -> bb4;                     // scope 3 at $DIR/issue_106141.rs:13:5: 17:6\n++     }\n++ \n++     bb4: {\n++         StorageDead(_1);                 // scope 3 at $DIR/issue_106141.rs:17:5: 17:6\n++         StorageDead(_3);                 // scope 0 at $DIR/issue_106141.rs:+1:5: +1:12\n+          return;                          // scope 0 at $DIR/issue_106141.rs:+2:2: +2:2\n+      }\n+  }\n+  "}, {"sha": "c8288b7f3419df1b9b87fb3e5760dcb2a0d0633c", "filename": "tests/mir-opt/inline/issue_106141.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de9a5b076aeabf6c359be31575fc96504254f72d/tests%2Fmir-opt%2Finline%2Fissue_106141.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de9a5b076aeabf6c359be31575fc96504254f72d/tests%2Fmir-opt%2Finline%2Fissue_106141.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Finline%2Fissue_106141.rs?ref=de9a5b076aeabf6c359be31575fc96504254f72d", "patch": "@@ -20,3 +20,5 @@ fn inner() -> usize {\n fn main() {\n     outer();\n }\n+\n+// EMIT_MIR issue_106141.outer.Inline.diff"}]}