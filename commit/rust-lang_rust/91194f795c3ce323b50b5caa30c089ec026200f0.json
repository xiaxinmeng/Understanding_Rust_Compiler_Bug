{"sha": "91194f795c3ce323b50b5caa30c089ec026200f0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxMTk0Zjc5NWMzY2UzMjNiNTBiNWNhYTMwYzA4OWVjMDI2MjAwZjA=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-03-22T03:40:05Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-03-27T06:39:14Z"}, "message": "parse: move constraint/arg restriction to ast_validation.", "tree": {"sha": "0280be8415580c403d75a51697d2573d499e8939", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0280be8415580c403d75a51697d2573d499e8939"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/91194f795c3ce323b50b5caa30c089ec026200f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/91194f795c3ce323b50b5caa30c089ec026200f0", "html_url": "https://github.com/rust-lang/rust/commit/91194f795c3ce323b50b5caa30c089ec026200f0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/91194f795c3ce323b50b5caa30c089ec026200f0/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c19a10e24af157b96687ca8dc1b48ebac4b9489", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c19a10e24af157b96687ca8dc1b48ebac4b9489", "html_url": "https://github.com/rust-lang/rust/commit/6c19a10e24af157b96687ca8dc1b48ebac4b9489"}], "stats": {"total": 447, "additions": 247, "deletions": 200}, "files": [{"sha": "6586280d21454aa63aa5e2a8fcbfdc46cf5235d5", "filename": "src/librustc_ast/ast.rs", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/91194f795c3ce323b50b5caa30c089ec026200f0/src%2Flibrustc_ast%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91194f795c3ce323b50b5caa30c089ec026200f0/src%2Flibrustc_ast%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fast.rs?ref=91194f795c3ce323b50b5caa30c089ec026200f0", "patch": "@@ -214,11 +214,18 @@ impl GenericArg {\n pub struct AngleBracketedArgs {\n     /// The overall span.\n     pub span: Span,\n-    /// The arguments for this path segment.\n-    pub args: Vec<GenericArg>,\n-    /// Constraints on associated types, if any.\n-    /// E.g., `Foo<A = Bar, B: Baz>`.\n-    pub constraints: Vec<AssocTyConstraint>,\n+    /// The comma separated parts in the `<...>`.\n+    pub args: Vec<AngleBracketedArg>,\n+}\n+\n+/// Either an argument for a parameter e.g., `'a`, `Vec<u8>`, `0`,\n+/// or a constraint on an associated item, e.g., `Item = String` or `Item: Bound`.\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+pub enum AngleBracketedArg {\n+    /// Argument for a generic parameter.\n+    Arg(GenericArg),\n+    /// Constraint for an associated item.\n+    Constraint(AssocTyConstraint),\n }\n \n impl Into<Option<P<GenericArgs>>> for AngleBracketedArgs {\n@@ -248,11 +255,13 @@ pub struct ParenthesizedArgs {\n \n impl ParenthesizedArgs {\n     pub fn as_angle_bracketed_args(&self) -> AngleBracketedArgs {\n-        AngleBracketedArgs {\n-            span: self.span,\n-            args: self.inputs.iter().cloned().map(GenericArg::Type).collect(),\n-            constraints: vec![],\n-        }\n+        let args = self\n+            .inputs\n+            .iter()\n+            .cloned()\n+            .map(|input| AngleBracketedArg::Arg(GenericArg::Type(input)))\n+            .collect();\n+        AngleBracketedArgs { span: self.span, args }\n     }\n }\n "}, {"sha": "a72a60c30b28a049dec4f28b47cb42368534cecd", "filename": "src/librustc_ast/mut_visit.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/91194f795c3ce323b50b5caa30c089ec026200f0/src%2Flibrustc_ast%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91194f795c3ce323b50b5caa30c089ec026200f0/src%2Flibrustc_ast%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fmut_visit.rs?ref=91194f795c3ce323b50b5caa30c089ec026200f0", "patch": "@@ -546,9 +546,11 @@ pub fn noop_visit_angle_bracketed_parameter_data<T: MutVisitor>(\n     data: &mut AngleBracketedArgs,\n     vis: &mut T,\n ) {\n-    let AngleBracketedArgs { args, constraints, span } = data;\n-    visit_vec(args, |arg| vis.visit_generic_arg(arg));\n-    visit_vec(constraints, |constraint| vis.visit_ty_constraint(constraint));\n+    let AngleBracketedArgs { args, span } = data;\n+    visit_vec(args, |arg| match arg {\n+        AngleBracketedArg::Arg(arg) => vis.visit_generic_arg(arg),\n+        AngleBracketedArg::Constraint(constraint) => vis.visit_ty_constraint(constraint),\n+    });\n     vis.visit_span(span);\n }\n "}, {"sha": "51863350a8cf38f3508a1ede7e9616741a41d3f7", "filename": "src/librustc_ast/visit.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/91194f795c3ce323b50b5caa30c089ec026200f0/src%2Flibrustc_ast%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91194f795c3ce323b50b5caa30c089ec026200f0/src%2Flibrustc_ast%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fvisit.rs?ref=91194f795c3ce323b50b5caa30c089ec026200f0", "patch": "@@ -464,8 +464,12 @@ where\n {\n     match *generic_args {\n         GenericArgs::AngleBracketed(ref data) => {\n-            walk_list!(visitor, visit_generic_arg, &data.args);\n-            walk_list!(visitor, visit_assoc_ty_constraint, &data.constraints);\n+            for arg in &data.args {\n+                match arg {\n+                    AngleBracketedArg::Arg(a) => visitor.visit_generic_arg(a),\n+                    AngleBracketedArg::Constraint(c) => visitor.visit_assoc_ty_constraint(c),\n+                }\n+            }\n         }\n         GenericArgs::Parenthesized(ref data) => {\n             walk_list!(visitor, visit_ty, &data.inputs);"}, {"sha": "45ee7265c15fcb2b6124bb21dad05fb7ee0391db", "filename": "src/librustc_ast_lowering/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/91194f795c3ce323b50b5caa30c089ec026200f0/src%2Flibrustc_ast_lowering%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91194f795c3ce323b50b5caa30c089ec026200f0/src%2Flibrustc_ast_lowering%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Flib.rs?ref=91194f795c3ce323b50b5caa30c089ec026200f0", "patch": "@@ -34,6 +34,7 @@\n #![feature(crate_visibility_modifier)]\n #![feature(marker_trait_attr)]\n #![feature(specialization)]\n+#![feature(or_patterns)]\n #![recursion_limit = \"256\"]\n \n use rustc_ast::ast;"}, {"sha": "f15a4555e5f133e4d10a72486de491f4dca70e17", "filename": "src/librustc_ast_lowering/path.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/91194f795c3ce323b50b5caa30c089ec026200f0/src%2Flibrustc_ast_lowering%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91194f795c3ce323b50b5caa30c089ec026200f0/src%2Flibrustc_ast_lowering%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fpath.rs?ref=91194f795c3ce323b50b5caa30c089ec026200f0", "patch": "@@ -366,22 +366,27 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         param_mode: ParamMode,\n         mut itctx: ImplTraitContext<'_, 'hir>,\n     ) -> (GenericArgsCtor<'hir>, bool) {\n-        let &AngleBracketedArgs { ref args, ref constraints, .. } = data;\n-        let has_non_lt_args = args.iter().any(|arg| match arg {\n-            ast::GenericArg::Lifetime(_) => false,\n-            ast::GenericArg::Type(_) => true,\n-            ast::GenericArg::Const(_) => true,\n+        let has_non_lt_args = data.args.iter().any(|arg| match arg {\n+            AngleBracketedArg::Arg(ast::GenericArg::Lifetime(_)) => false,\n+            AngleBracketedArg::Arg(ast::GenericArg::Type(_) | ast::GenericArg::Const(_))\n+            | AngleBracketedArg::Constraint(_) => true,\n         });\n-        (\n-            GenericArgsCtor {\n-                args: args.iter().map(|a| self.lower_generic_arg(a, itctx.reborrow())).collect(),\n-                bindings: self.arena.alloc_from_iter(\n-                    constraints.iter().map(|b| self.lower_assoc_ty_constraint(b, itctx.reborrow())),\n-                ),\n-                parenthesized: false,\n-            },\n-            !has_non_lt_args && param_mode == ParamMode::Optional,\n-        )\n+        let args = data\n+            .args\n+            .iter()\n+            .filter_map(|arg| match arg {\n+                AngleBracketedArg::Arg(arg) => Some(self.lower_generic_arg(arg, itctx.reborrow())),\n+                AngleBracketedArg::Constraint(_) => None,\n+            })\n+            .collect();\n+        let bindings = self.arena.alloc_from_iter(data.args.iter().filter_map(|arg| match arg {\n+            AngleBracketedArg::Constraint(c) => {\n+                Some(self.lower_assoc_ty_constraint(c, itctx.reborrow()))\n+            }\n+            AngleBracketedArg::Arg(_) => None,\n+        }));\n+        let ctor = GenericArgsCtor { args, bindings, parenthesized: false };\n+        (ctor, !has_non_lt_args && param_mode == ParamMode::Optional)\n     }\n \n     fn lower_parenthesized_parameter_data("}, {"sha": "e6f09a3a6cba55bb0d3373264170fa5112ac4b79", "filename": "src/librustc_ast_passes/ast_validation.rs", "status": "modified", "additions": 45, "deletions": 11, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/91194f795c3ce323b50b5caa30c089ec026200f0/src%2Flibrustc_ast_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91194f795c3ce323b50b5caa30c089ec026200f0/src%2Flibrustc_ast_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_passes%2Fast_validation.rs?ref=91194f795c3ce323b50b5caa30c089ec026200f0", "patch": "@@ -639,6 +639,37 @@ impl<'a> AstValidator<'a> {\n             .emit();\n         }\n     }\n+\n+    /// Enforce generic args coming before constraints in `<...>` of a path segment.\n+    fn check_generic_args_before_constraints(&self, data: &AngleBracketedArgs) {\n+        // Early exit in case it's partitioned as it should be.\n+        if data.args.iter().is_partitioned(|arg| matches!(arg, AngleBracketedArg::Arg(_))) {\n+            return;\n+        }\n+        // Find all generic argument coming after the first constraint...\n+        let mut misplaced_args = Vec::new();\n+        let mut first = None;\n+        for arg in &data.args {\n+            match (arg, first) {\n+                (AngleBracketedArg::Arg(a), Some(_)) => misplaced_args.push(a.span()),\n+                (AngleBracketedArg::Constraint(c), None) => first = Some(c.span),\n+                (AngleBracketedArg::Arg(_), None) | (AngleBracketedArg::Constraint(_), Some(_)) => {\n+                }\n+            }\n+        }\n+        // ...and then error:\n+        self.err_handler()\n+            .struct_span_err(\n+                data.span,\n+                \"constraints in a path segment must come after generic arguments\",\n+            )\n+            .span_labels(\n+                misplaced_args,\n+                \"this generic argument must come before the first constraint\",\n+            )\n+            .span_label(first.unwrap(), \"the first constraint is provided here\")\n+            .emit();\n+    }\n }\n \n /// Checks that generic parameters are in the correct order,\n@@ -1008,17 +1039,20 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n     fn visit_generic_args(&mut self, _: Span, generic_args: &'a GenericArgs) {\n         match *generic_args {\n             GenericArgs::AngleBracketed(ref data) => {\n-                walk_list!(self, visit_generic_arg, &data.args);\n-\n-                // Type bindings such as `Item = impl Debug` in `Iterator<Item = Debug>`\n-                // are allowed to contain nested `impl Trait`.\n-                self.with_impl_trait(None, |this| {\n-                    walk_list!(\n-                        this,\n-                        visit_assoc_ty_constraint_from_generic_args,\n-                        &data.constraints\n-                    );\n-                });\n+                self.check_generic_args_before_constraints(data);\n+\n+                for arg in &data.args {\n+                    match arg {\n+                        AngleBracketedArg::Arg(arg) => self.visit_generic_arg(arg),\n+                        // Type bindings such as `Item = impl Debug` in `Iterator<Item = Debug>`\n+                        // are allowed to contain nested `impl Trait`.\n+                        AngleBracketedArg::Constraint(constraint) => {\n+                            self.with_impl_trait(None, |this| {\n+                                this.visit_assoc_ty_constraint_from_generic_args(constraint);\n+                            });\n+                        }\n+                    }\n+                }\n             }\n             GenericArgs::Parenthesized(ref data) => {\n                 walk_list!(self, visit_ty, &data.inputs);"}, {"sha": "bfe304419801d5f2c7833170ceb6eaa5012ce23b", "filename": "src/librustc_ast_passes/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/91194f795c3ce323b50b5caa30c089ec026200f0/src%2Flibrustc_ast_passes%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91194f795c3ce323b50b5caa30c089ec026200f0/src%2Flibrustc_ast_passes%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_passes%2Flib.rs?ref=91194f795c3ce323b50b5caa30c089ec026200f0", "patch": "@@ -1,10 +1,12 @@\n-#![feature(bindings_after_at)]\n //! The `rustc_ast_passes` crate contains passes which validate the AST in `syntax`\n //! parsed by `rustc_parse` and then lowered, after the passes in this crate,\n //! by `rustc_ast_lowering`.\n //!\n //! The crate also contains other misc AST visitors, e.g. `node_count` and `show_span`.\n \n+#![feature(bindings_after_at)]\n+#![feature(iter_is_partitioned)]\n+\n pub mod ast_validation;\n pub mod feature_gate;\n pub mod node_count;"}, {"sha": "4aabbe7efbef456866710ed954d93109d96d219d", "filename": "src/librustc_ast_pretty/pprust.rs", "status": "modified", "additions": 17, "deletions": 24, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/91194f795c3ce323b50b5caa30c089ec026200f0/src%2Flibrustc_ast_pretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91194f795c3ce323b50b5caa30c089ec026200f0/src%2Flibrustc_ast_pretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_pretty%2Fpprust.rs?ref=91194f795c3ce323b50b5caa30c089ec026200f0", "patch": "@@ -796,31 +796,10 @@ impl<'a> PrintState<'a> for State<'a> {\n         match *args {\n             ast::GenericArgs::AngleBracketed(ref data) => {\n                 self.s.word(\"<\");\n-\n-                self.commasep(Inconsistent, &data.args, |s, generic_arg| {\n-                    s.print_generic_arg(generic_arg)\n+                self.commasep(Inconsistent, &data.args, |s, arg| match arg {\n+                    ast::AngleBracketedArg::Arg(a) => s.print_generic_arg(a),\n+                    ast::AngleBracketedArg::Constraint(c) => s.print_assoc_constraint(c),\n                 });\n-\n-                let mut comma = !data.args.is_empty();\n-\n-                for constraint in data.constraints.iter() {\n-                    if comma {\n-                        self.word_space(\",\")\n-                    }\n-                    self.print_ident(constraint.ident);\n-                    self.s.space();\n-                    match constraint.kind {\n-                        ast::AssocTyConstraintKind::Equality { ref ty } => {\n-                            self.word_space(\"=\");\n-                            self.print_type(ty);\n-                        }\n-                        ast::AssocTyConstraintKind::Bound { ref bounds } => {\n-                            self.print_type_bounds(\":\", &*bounds);\n-                        }\n-                    }\n-                    comma = true;\n-                }\n-\n                 self.s.word(\">\")\n             }\n \n@@ -891,6 +870,20 @@ impl<'a> State<'a> {\n         }\n     }\n \n+    fn print_assoc_constraint(&mut self, constraint: &ast::AssocTyConstraint) {\n+        self.print_ident(constraint.ident);\n+        self.s.space();\n+        match &constraint.kind {\n+            ast::AssocTyConstraintKind::Equality { ty } => {\n+                self.word_space(\"=\");\n+                self.print_type(ty);\n+            }\n+            ast::AssocTyConstraintKind::Bound { bounds } => {\n+                self.print_type_bounds(\":\", &*bounds);\n+            }\n+        }\n+    }\n+\n     crate fn print_generic_arg(&mut self, generic_arg: &GenericArg) {\n         match generic_arg {\n             GenericArg::Lifetime(lt) => self.print_lifetime(*lt),"}, {"sha": "4d89bf79e7c67e16d2171ee3796cda2e3f31a707", "filename": "src/librustc_expand/build.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/91194f795c3ce323b50b5caa30c089ec026200f0/src%2Flibrustc_expand%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91194f795c3ce323b50b5caa30c089ec026200f0/src%2Flibrustc_expand%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fbuild.rs?ref=91194f795c3ce323b50b5caa30c089ec026200f0", "patch": "@@ -36,7 +36,8 @@ impl<'a> ExtCtxt<'a> {\n             idents.into_iter().map(|ident| ast::PathSegment::from_ident(ident.with_span_pos(span))),\n         );\n         let args = if !args.is_empty() {\n-            ast::AngleBracketedArgs { args, constraints: Vec::new(), span }.into()\n+            let args = args.into_iter().map(ast::AngleBracketedArg::Arg).collect();\n+            ast::AngleBracketedArgs { args, span }.into()\n         } else {\n             None\n         };"}, {"sha": "eff7dacef7953f21b0ae753d51d8990b27f51985", "filename": "src/librustc_interface/util.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/91194f795c3ce323b50b5caa30c089ec026200f0/src%2Flibrustc_interface%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91194f795c3ce323b50b5caa30c089ec026200f0/src%2Flibrustc_interface%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Futil.rs?ref=91194f795c3ce323b50b5caa30c089ec026200f0", "patch": "@@ -634,17 +634,19 @@ impl<'a, 'b> ReplaceBodyWithLoop<'a, 'b> {\n                         match seg.args.as_ref().map(|generic_arg| &**generic_arg) {\n                             None => false,\n                             Some(&ast::GenericArgs::AngleBracketed(ref data)) => {\n-                                let types = data.args.iter().filter_map(|arg| match arg {\n-                                    ast::GenericArg::Type(ty) => Some(ty),\n-                                    _ => None,\n-                                });\n-                                any_involves_impl_trait(types)\n-                                    || data.constraints.iter().any(|c| match c.kind {\n+                                data.args.iter().any(|arg| match arg {\n+                                    ast::AngleBracketedArg::Arg(arg) => match arg {\n+                                        ast::GenericArg::Type(ty) => involves_impl_trait(ty),\n+                                        ast::GenericArg::Lifetime(_)\n+                                        | ast::GenericArg::Const(_) => false,\n+                                    },\n+                                    ast::AngleBracketedArg::Constraint(c) => match c.kind {\n                                         ast::AssocTyConstraintKind::Bound { .. } => true,\n                                         ast::AssocTyConstraintKind::Equality { ref ty } => {\n                                             involves_impl_trait(ty)\n                                         }\n-                                    })\n+                                    },\n+                                })\n                             }\n                             Some(&ast::GenericArgs::Parenthesized(ref data)) => {\n                                 any_involves_impl_trait(data.inputs.iter())"}, {"sha": "2320dcba33c97a2f4b02ef5dc3dfee851b8be1f0", "filename": "src/librustc_parse/parser/path.rs", "status": "modified", "additions": 23, "deletions": 53, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/91194f795c3ce323b50b5caa30c089ec026200f0/src%2Flibrustc_parse%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91194f795c3ce323b50b5caa30c089ec026200f0/src%2Flibrustc_parse%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fpath.rs?ref=91194f795c3ce323b50b5caa30c089ec026200f0", "patch": "@@ -1,12 +1,9 @@\n use super::ty::{AllowPlus, RecoverQPath};\n use super::{Parser, TokenType};\n use crate::maybe_whole;\n-use rustc_ast::ast::{\n-    self, AngleBracketedArgs, Ident, ParenthesizedArgs, Path, PathSegment, QSelf,\n-};\n-use rustc_ast::ast::{\n-    AnonConst, AssocTyConstraint, AssocTyConstraintKind, BlockCheckMode, GenericArg,\n-};\n+use rustc_ast::ast::{self, AngleBracketedArg, AngleBracketedArgs, GenericArg, ParenthesizedArgs};\n+use rustc_ast::ast::{AnonConst, AssocTyConstraint, AssocTyConstraintKind, BlockCheckMode};\n+use rustc_ast::ast::{Ident, Path, PathSegment, QSelf};\n use rustc_ast::token::{self, Token};\n use rustc_errors::{pluralize, Applicability, PResult};\n use rustc_span::source_map::{BytePos, Span};\n@@ -218,11 +215,11 @@ impl<'a> Parser<'a> {\n                 let lo = self.token.span;\n                 let args = if self.eat_lt() {\n                     // `<'a, T, A = U>`\n-                    let (args, constraints) =\n-                        self.parse_generic_args_with_leading_angle_bracket_recovery(style, lo)?;\n+                    let args =\n+                        self.parse_angle_args_with_leading_angle_bracket_recovery(style, lo)?;\n                     self.expect_gt()?;\n                     let span = lo.to(self.prev_token.span);\n-                    AngleBracketedArgs { args, constraints, span }.into()\n+                    AngleBracketedArgs { args, span }.into()\n                 } else {\n                     // `(T, U) -> R`\n                     let (inputs, _) = self.parse_paren_comma_seq(|p| p.parse_ty())?;\n@@ -251,18 +248,18 @@ impl<'a> Parser<'a> {\n \n     /// Parses generic args (within a path segment) with recovery for extra leading angle brackets.\n     /// For the purposes of understanding the parsing logic of generic arguments, this function\n-    /// can be thought of being the same as just calling `self.parse_generic_args()` if the source\n+    /// can be thought of being the same as just calling `self.parse_angle_args()` if the source\n     /// had the correct amount of leading angle brackets.\n     ///\n     /// ```ignore (diagnostics)\n     /// bar::<<<<T as Foo>::Output>();\n     ///      ^^ help: remove extra angle brackets\n     /// ```\n-    fn parse_generic_args_with_leading_angle_bracket_recovery(\n+    fn parse_angle_args_with_leading_angle_bracket_recovery(\n         &mut self,\n         style: PathStyle,\n         lo: Span,\n-    ) -> PResult<'a, (Vec<GenericArg>, Vec<AssocTyConstraint>)> {\n+    ) -> PResult<'a, Vec<AngleBracketedArg>> {\n         // We need to detect whether there are extra leading left angle brackets and produce an\n         // appropriate error and suggestion. This cannot be implemented by looking ahead at\n         // upcoming tokens for a matching `>` character - if there are unmatched `<` tokens\n@@ -337,8 +334,8 @@ impl<'a> Parser<'a> {\n         let snapshot = if is_first_invocation { Some(self.clone()) } else { None };\n \n         debug!(\"parse_generic_args_with_leading_angle_bracket_recovery: (snapshotting)\");\n-        match self.parse_generic_args() {\n-            Ok(value) => Ok(value),\n+        match self.parse_angle_args() {\n+            Ok(args) => Ok(args),\n             Err(ref mut e) if is_first_invocation && self.unmatched_angle_bracket_count > 0 => {\n                 // Cancel error from being unable to find `>`. We know the error\n                 // must have been this due to a non-zero unmatched angle bracket\n@@ -381,39 +378,31 @@ impl<'a> Parser<'a> {\n                 .emit();\n \n                 // Try again without unmatched angle bracket characters.\n-                self.parse_generic_args()\n+                self.parse_angle_args()\n             }\n             Err(e) => Err(e),\n         }\n     }\n \n-    /// Parses (possibly empty) list of lifetime and type arguments and associated type bindings,\n+    /// Parses (possibly empty) list of generic arguments / associated item constraints,\n     /// possibly including trailing comma.\n-    fn parse_generic_args(&mut self) -> PResult<'a, (Vec<GenericArg>, Vec<AssocTyConstraint>)> {\n+    fn parse_angle_args(&mut self) -> PResult<'a, Vec<AngleBracketedArg>> {\n         let mut args = Vec::new();\n-        let mut constraints = Vec::new();\n-        let mut misplaced_assoc_ty_constraints: Vec<Span> = Vec::new();\n-        let mut assoc_ty_constraints: Vec<Span> = Vec::new();\n-\n-        let args_lo = self.token.span;\n-\n         loop {\n             if self.check_lifetime() && self.look_ahead(1, |t| !t.is_like_plus()) {\n                 // Parse lifetime argument.\n-                args.push(GenericArg::Lifetime(self.expect_lifetime()));\n-                misplaced_assoc_ty_constraints.append(&mut assoc_ty_constraints);\n+                args.push(AngleBracketedArg::Arg(GenericArg::Lifetime(self.expect_lifetime())));\n             } else if self.check_ident()\n-                && self.look_ahead(1, |t| t == &token::Eq || t == &token::Colon)\n+                && self.look_ahead(1, |t| matches!(t.kind, token::Eq | token::Colon))\n             {\n                 // Parse associated type constraint.\n                 let lo = self.token.span;\n                 let ident = self.parse_ident()?;\n                 let kind = if self.eat(&token::Eq) {\n                     AssocTyConstraintKind::Equality { ty: self.parse_ty()? }\n                 } else if self.eat(&token::Colon) {\n-                    AssocTyConstraintKind::Bound {\n-                        bounds: self.parse_generic_bounds(Some(self.prev_token.span))?,\n-                    }\n+                    let bounds = self.parse_generic_bounds(Some(self.prev_token.span))?;\n+                    AssocTyConstraintKind::Bound { bounds }\n                 } else {\n                     unreachable!();\n                 };\n@@ -425,8 +414,8 @@ impl<'a> Parser<'a> {\n                     self.sess.gated_spans.gate(sym::associated_type_bounds, span);\n                 }\n \n-                constraints.push(AssocTyConstraint { id: ast::DUMMY_NODE_ID, ident, kind, span });\n-                assoc_ty_constraints.push(span);\n+                let constraint = AssocTyConstraint { id: ast::DUMMY_NODE_ID, ident, kind, span };\n+                args.push(AngleBracketedArg::Constraint(constraint));\n             } else if self.check_const_arg() {\n                 // Parse const argument.\n                 let expr = if let token::OpenDelim(token::Brace) = self.token.kind {\n@@ -453,12 +442,10 @@ impl<'a> Parser<'a> {\n                     self.parse_literal_maybe_minus()?\n                 };\n                 let value = AnonConst { id: ast::DUMMY_NODE_ID, value: expr };\n-                args.push(GenericArg::Const(value));\n-                misplaced_assoc_ty_constraints.append(&mut assoc_ty_constraints);\n+                args.push(AngleBracketedArg::Arg(GenericArg::Const(value)));\n             } else if self.check_type() {\n                 // Parse type argument.\n-                args.push(GenericArg::Type(self.parse_ty()?));\n-                misplaced_assoc_ty_constraints.append(&mut assoc_ty_constraints);\n+                args.push(AngleBracketedArg::Arg(GenericArg::Type(self.parse_ty()?)));\n             } else {\n                 break;\n             }\n@@ -468,23 +455,6 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n-        // FIXME: we would like to report this in ast_validation instead, but we currently do not\n-        // preserve ordering of generic parameters with respect to associated type binding, so we\n-        // lose that information after parsing.\n-        if !misplaced_assoc_ty_constraints.is_empty() {\n-            let mut err = self.struct_span_err(\n-                args_lo.to(self.prev_token.span),\n-                \"associated type bindings must be declared after generic parameters\",\n-            );\n-            for span in misplaced_assoc_ty_constraints {\n-                err.span_label(\n-                    span,\n-                    \"this associated type binding should be moved after the generic parameters\",\n-                );\n-            }\n-            err.emit();\n-        }\n-\n-        Ok((args, constraints))\n+        Ok(args)\n     }\n }"}, {"sha": "0829a82b932c377af7a06480143d1f1cd8f0be75", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/91194f795c3ce323b50b5caa30c089ec026200f0/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91194f795c3ce323b50b5caa30c089ec026200f0/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=91194f795c3ce323b50b5caa30c089ec026200f0", "patch": "@@ -783,7 +783,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n                 match **generic_args {\n                     ast::GenericArgs::AngleBracketed(ref data) => {\n                         for arg in &data.args {\n-                            if let ast::GenericArg::Type(ty) = arg {\n+                            if let ast::AngleBracketedArg::Arg(ast::GenericArg::Type(ty)) = arg {\n                                 self.visit_ty(ty);\n                             }\n                         }\n@@ -849,7 +849,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n             if let ast::GenericArgs::AngleBracketed(ref data) = **generic_args {\n                 for arg in &data.args {\n                     match arg {\n-                        ast::GenericArg::Type(ty) => self.visit_ty(ty),\n+                        ast::AngleBracketedArg::Arg(ast::GenericArg::Type(ty)) => self.visit_ty(ty),\n                         _ => {}\n                     }\n                 }"}, {"sha": "afbd13e6fd9a8103bbf27b13a9eb372303b4120b", "filename": "src/test/ui/parser/constraints-before-generic-args-syntactic-pass.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/91194f795c3ce323b50b5caa30c089ec026200f0/src%2Ftest%2Fui%2Fparser%2Fconstraints-before-generic-args-syntactic-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91194f795c3ce323b50b5caa30c089ec026200f0/src%2Ftest%2Fui%2Fparser%2Fconstraints-before-generic-args-syntactic-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fconstraints-before-generic-args-syntactic-pass.rs?ref=91194f795c3ce323b50b5caa30c089ec026200f0", "patch": "@@ -0,0 +1,9 @@\n+// check-pass\n+\n+#[cfg(FALSE)]\n+fn syntax() {\n+    foo::<T = u8, T: Ord, String>();\n+    foo::<T = u8, 'a, T: Ord>();\n+}\n+\n+fn main() {}"}, {"sha": "ca30f5f1329d878670a6c63d6ad8035e001bbc15", "filename": "src/test/ui/parser/issue-32214.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91194f795c3ce323b50b5caa30c089ec026200f0/src%2Ftest%2Fui%2Fparser%2Fissue-32214.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91194f795c3ce323b50b5caa30c089ec026200f0/src%2Ftest%2Fui%2Fparser%2Fissue-32214.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-32214.rs?ref=91194f795c3ce323b50b5caa30c089ec026200f0", "patch": "@@ -1,6 +1,6 @@\n trait Trait<T> { type Item; }\n \n pub fn test<W, I: Trait<Item=(), W> >() {}\n-//~^ ERROR associated type bindings must be declared after generic parameters\n+//~^ ERROR constraints in a path segment must come after generic arguments\n \n fn main() { }"}, {"sha": "ee99fe70811dec3d5c61a065a6e903c524cc17f9", "filename": "src/test/ui/parser/issue-32214.stderr", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/91194f795c3ce323b50b5caa30c089ec026200f0/src%2Ftest%2Fui%2Fparser%2Fissue-32214.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/91194f795c3ce323b50b5caa30c089ec026200f0/src%2Ftest%2Fui%2Fparser%2Fissue-32214.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-32214.stderr?ref=91194f795c3ce323b50b5caa30c089ec026200f0", "patch": "@@ -1,10 +1,11 @@\n-error: associated type bindings must be declared after generic parameters\n-  --> $DIR/issue-32214.rs:3:25\n+error: constraints in a path segment must come after generic arguments\n+  --> $DIR/issue-32214.rs:3:24\n    |\n LL | pub fn test<W, I: Trait<Item=(), W> >() {}\n-   |                         -------^^^\n-   |                         |\n-   |                         this associated type binding should be moved after the generic parameters\n+   |                        ^-------^^-^\n+   |                         |        |\n+   |                         |        this generic argument must come before the first constraint\n+   |                         the first constraint is provided here\n \n error: aborting due to previous error\n "}, {"sha": "d9d5351b5c2d401f47b09391b74be06e299d2f8c", "filename": "src/test/ui/suggestions/suggest-move-types.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/91194f795c3ce323b50b5caa30c089ec026200f0/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-move-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91194f795c3ce323b50b5caa30c089ec026200f0/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-move-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-move-types.rs?ref=91194f795c3ce323b50b5caa30c089ec026200f0", "patch": "@@ -1,5 +1,3 @@\n-// ignore-tidy-linelength\n-\n #![allow(warnings)]\n \n // This test verifies that the suggestion to move types before associated type bindings\n@@ -25,60 +23,64 @@ trait ThreeWithLifetime<'a, 'b, 'c, T, U, V> {\n   type C;\n }\n \n-struct A<T, M: One<A=(), T>> { //~ ERROR associated type bindings must be declared after generic parameters\n+struct A<T, M: One<A=(), T>> {\n+//~^ ERROR constraints in a path segment must come after generic arguments\n     m: M,\n     t: T,\n }\n \n \n struct Al<'a, T, M: OneWithLifetime<A=(), T, 'a>> {\n-//~^ ERROR associated type bindings must be declared after generic parameters\n+//~^ ERROR constraints in a path segment must come after generic arguments\n //~^^ ERROR type provided when a lifetime was expected\n     m: M,\n     t: &'a T,\n }\n \n-struct B<T, U, V, M: Three<A=(), B=(), C=(), T, U, V>> { //~ ERROR associated type bindings must be declared after generic parameters\n+struct B<T, U, V, M: Three<A=(), B=(), C=(), T, U, V>> {\n+//~^ ERROR constraints in a path segment must come after generic arguments\n     m: M,\n     t: T,\n     u: U,\n     v: V,\n }\n \n struct Bl<'a, 'b, 'c, T, U, V, M: ThreeWithLifetime<A=(), B=(), C=(), T, U, V, 'a, 'b, 'c>> {\n-//~^ ERROR associated type bindings must be declared after generic parameters\n+//~^ ERROR constraints in a path segment must come after generic arguments\n //~^^ ERROR type provided when a lifetime was expected\n     m: M,\n     t: &'a T,\n     u: &'b U,\n     v: &'c V,\n }\n \n-struct C<T, U, V, M: Three<T, A=(), B=(), C=(), U, V>> { //~ ERROR associated type bindings must be declared after generic parameters\n+struct C<T, U, V, M: Three<T, A=(), B=(), C=(), U, V>> {\n+//~^ ERROR constraints in a path segment must come after generic arguments\n     m: M,\n     t: T,\n     u: U,\n     v: V,\n }\n \n struct Cl<'a, 'b, 'c, T, U, V, M: ThreeWithLifetime<T, 'a, A=(), B=(), C=(), U, 'b, V, 'c>> {\n-//~^ ERROR associated type bindings must be declared after generic parameters\n+//~^ ERROR constraints in a path segment must come after generic arguments\n //~^^ ERROR lifetime provided when a type was expected\n     m: M,\n     t: &'a T,\n     u: &'b U,\n     v: &'c V,\n }\n \n-struct D<T, U, V, M: Three<T, A=(), B=(), U, C=(), V>> { //~ ERROR associated type bindings must be declared after generic parameters\n+struct D<T, U, V, M: Three<T, A=(), B=(), U, C=(), V>> {\n+//~^ ERROR constraints in a path segment must come after generic arguments\n     m: M,\n     t: T,\n     u: U,\n     v: V,\n }\n \n struct Dl<'a, 'b, 'c, T, U, V, M: ThreeWithLifetime<T, 'a, A=(), B=(), U, 'b, C=(), V, 'c>> {\n-//~^ ERROR associated type bindings must be declared after generic parameters\n+//~^ ERROR constraints in a path segment must come after generic arguments\n //~^^ ERROR lifetime provided when a type was expected\n     m: M,\n     t: &'a T,"}, {"sha": "0225546b9e37b58afdc49345e91901836390b0fa", "filename": "src/test/ui/suggestions/suggest-move-types.stderr", "status": "modified", "additions": 67, "deletions": 55, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/91194f795c3ce323b50b5caa30c089ec026200f0/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-move-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/91194f795c3ce323b50b5caa30c089ec026200f0/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-move-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-move-types.stderr?ref=91194f795c3ce323b50b5caa30c089ec026200f0", "patch": "@@ -1,81 +1,93 @@\n-error: associated type bindings must be declared after generic parameters\n-  --> $DIR/suggest-move-types.rs:28:20\n+error: constraints in a path segment must come after generic arguments\n+  --> $DIR/suggest-move-types.rs:26:19\n    |\n LL | struct A<T, M: One<A=(), T>> {\n-   |                    ----^^^\n-   |                    |\n-   |                    this associated type binding should be moved after the generic parameters\n+   |                   ^----^^-^\n+   |                    |     |\n+   |                    |     this generic argument must come before the first constraint\n+   |                    the first constraint is provided here\n \n-error: associated type bindings must be declared after generic parameters\n-  --> $DIR/suggest-move-types.rs:34:37\n+error: constraints in a path segment must come after generic arguments\n+  --> $DIR/suggest-move-types.rs:33:36\n    |\n LL | struct Al<'a, T, M: OneWithLifetime<A=(), T, 'a>> {\n-   |                                     ----^^^^^^^\n-   |                                     |\n-   |                                     this associated type binding should be moved after the generic parameters\n+   |                                    ^----^^-^^--^\n+   |                                     |     |  |\n+   |                                     |     |  this generic argument must come before the first constraint\n+   |                                     |     this generic argument must come before the first constraint\n+   |                                     the first constraint is provided here\n \n-error: associated type bindings must be declared after generic parameters\n-  --> $DIR/suggest-move-types.rs:41:28\n+error: constraints in a path segment must come after generic arguments\n+  --> $DIR/suggest-move-types.rs:40:27\n    |\n LL | struct B<T, U, V, M: Three<A=(), B=(), C=(), T, U, V>> {\n-   |                            ----^^----^^----^^^^^^^^^\n-   |                            |     |     |\n-   |                            |     |     this associated type binding should be moved after the generic parameters\n-   |                            |     this associated type binding should be moved after the generic parameters\n-   |                            this associated type binding should be moved after the generic parameters\n+   |                           ^----^^^^^^^^^^^^^^-^^-^^-^\n+   |                            |                 |  |  |\n+   |                            |                 |  |  this generic argument must come before the first constraint\n+   |                            |                 |  this generic argument must come before the first constraint\n+   |                            |                 this generic argument must come before the first constraint\n+   |                            the first constraint is provided here\n \n-error: associated type bindings must be declared after generic parameters\n-  --> $DIR/suggest-move-types.rs:48:53\n+error: constraints in a path segment must come after generic arguments\n+  --> $DIR/suggest-move-types.rs:48:52\n    |\n LL | struct Bl<'a, 'b, 'c, T, U, V, M: ThreeWithLifetime<A=(), B=(), C=(), T, U, V, 'a, 'b, 'c>> {\n-   |                                                     ----^^----^^----^^^^^^^^^^^^^^^^^^^^^\n-   |                                                     |     |     |\n-   |                                                     |     |     this associated type binding should be moved after the generic parameters\n-   |                                                     |     this associated type binding should be moved after the generic parameters\n-   |                                                     this associated type binding should be moved after the generic parameters\n+   |                                                    ^----^^^^^^^^^^^^^^-^^-^^-^^--^^--^^--^\n+   |                                                     |                 |  |  |  |   |   |\n+   |                                                     |                 |  |  |  |   |   this generic argument must come before the first constraint\n+   |                                                     |                 |  |  |  |   this generic argument must come before the first constraint\n+   |                                                     |                 |  |  |  this generic argument must come before the first constraint\n+   |                                                     |                 |  |  this generic argument must come before the first constraint\n+   |                                                     |                 |  this generic argument must come before the first constraint\n+   |                                                     |                 this generic argument must come before the first constraint\n+   |                                                     the first constraint is provided here\n \n-error: associated type bindings must be declared after generic parameters\n-  --> $DIR/suggest-move-types.rs:57:28\n+error: constraints in a path segment must come after generic arguments\n+  --> $DIR/suggest-move-types.rs:57:27\n    |\n LL | struct C<T, U, V, M: Three<T, A=(), B=(), C=(), U, V>> {\n-   |                            ^^^----^^----^^----^^^^^^\n-   |                               |     |     |\n-   |                               |     |     this associated type binding should be moved after the generic parameters\n-   |                               |     this associated type binding should be moved after the generic parameters\n-   |                               this associated type binding should be moved after the generic parameters\n+   |                           ^^^^----^^^^^^^^^^^^^^-^^-^\n+   |                               |                 |  |\n+   |                               |                 |  this generic argument must come before the first constraint\n+   |                               |                 this generic argument must come before the first constraint\n+   |                               the first constraint is provided here\n \n-error: associated type bindings must be declared after generic parameters\n-  --> $DIR/suggest-move-types.rs:64:53\n+error: constraints in a path segment must come after generic arguments\n+  --> $DIR/suggest-move-types.rs:65:52\n    |\n LL | struct Cl<'a, 'b, 'c, T, U, V, M: ThreeWithLifetime<T, 'a, A=(), B=(), C=(), U, 'b, V, 'c>> {\n-   |                                                     ^^^^^^^----^^----^^----^^^^^^^^^^^^^^\n-   |                                                            |     |     |\n-   |                                                            |     |     this associated type binding should be moved after the generic parameters\n-   |                                                            |     this associated type binding should be moved after the generic parameters\n-   |                                                            this associated type binding should be moved after the generic parameters\n+   |                                                    ^^^^^^^^----^^^^^^^^^^^^^^-^^--^^-^^--^\n+   |                                                            |                 |  |   |  |\n+   |                                                            |                 |  |   |  this generic argument must come before the first constraint\n+   |                                                            |                 |  |   this generic argument must come before the first constraint\n+   |                                                            |                 |  this generic argument must come before the first constraint\n+   |                                                            |                 this generic argument must come before the first constraint\n+   |                                                            the first constraint is provided here\n \n-error: associated type bindings must be declared after generic parameters\n-  --> $DIR/suggest-move-types.rs:73:28\n+error: constraints in a path segment must come after generic arguments\n+  --> $DIR/suggest-move-types.rs:74:27\n    |\n LL | struct D<T, U, V, M: Three<T, A=(), B=(), U, C=(), V>> {\n-   |                            ^^^----^^----^^^^^----^^^\n-   |                               |     |        |\n-   |                               |     |        this associated type binding should be moved after the generic parameters\n-   |                               |     this associated type binding should be moved after the generic parameters\n-   |                               this associated type binding should be moved after the generic parameters\n+   |                           ^^^^----^^^^^^^^-^^^^^^^^-^\n+   |                               |           |        |\n+   |                               |           |        this generic argument must come before the first constraint\n+   |                               |           this generic argument must come before the first constraint\n+   |                               the first constraint is provided here\n \n-error: associated type bindings must be declared after generic parameters\n-  --> $DIR/suggest-move-types.rs:80:53\n+error: constraints in a path segment must come after generic arguments\n+  --> $DIR/suggest-move-types.rs:82:52\n    |\n LL | struct Dl<'a, 'b, 'c, T, U, V, M: ThreeWithLifetime<T, 'a, A=(), B=(), U, 'b, C=(), V, 'c>> {\n-   |                                                     ^^^^^^^----^^----^^^^^^^^^----^^^^^^^\n-   |                                                            |     |            |\n-   |                                                            |     |            this associated type binding should be moved after the generic parameters\n-   |                                                            |     this associated type binding should be moved after the generic parameters\n-   |                                                            this associated type binding should be moved after the generic parameters\n+   |                                                    ^^^^^^^^----^^^^^^^^-^^--^^^^^^^^-^^--^\n+   |                                                            |           |  |         |  |\n+   |                                                            |           |  |         |  this generic argument must come before the first constraint\n+   |                                                            |           |  |         this generic argument must come before the first constraint\n+   |                                                            |           |  this generic argument must come before the first constraint\n+   |                                                            |           this generic argument must come before the first constraint\n+   |                                                            the first constraint is provided here\n \n error[E0747]: type provided when a lifetime was expected\n-  --> $DIR/suggest-move-types.rs:34:43\n+  --> $DIR/suggest-move-types.rs:33:43\n    |\n LL | struct Al<'a, T, M: OneWithLifetime<A=(), T, 'a>> {\n    |                                           ^\n@@ -91,15 +103,15 @@ LL | struct Bl<'a, 'b, 'c, T, U, V, M: ThreeWithLifetime<A=(), B=(), C=(), T, U,\n    = note: lifetime arguments must be provided before type arguments\n \n error[E0747]: lifetime provided when a type was expected\n-  --> $DIR/suggest-move-types.rs:64:56\n+  --> $DIR/suggest-move-types.rs:65:56\n    |\n LL | struct Cl<'a, 'b, 'c, T, U, V, M: ThreeWithLifetime<T, 'a, A=(), B=(), C=(), U, 'b, V, 'c>> {\n    |                                                        ^^\n    |\n    = note: type arguments must be provided before lifetime arguments\n \n error[E0747]: lifetime provided when a type was expected\n-  --> $DIR/suggest-move-types.rs:80:56\n+  --> $DIR/suggest-move-types.rs:82:56\n    |\n LL | struct Dl<'a, 'b, 'c, T, U, V, M: ThreeWithLifetime<T, 'a, A=(), B=(), U, 'b, C=(), V, 'c>> {\n    |                                                        ^^"}]}