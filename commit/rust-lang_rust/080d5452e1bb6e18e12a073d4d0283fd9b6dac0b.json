{"sha": "080d5452e1bb6e18e12a073d4d0283fd9b6dac0b", "node_id": "C_kwDOAAsO6NoAKDA4MGQ1NDUyZTFiYjZlMThlMTJhMDczZDRkMDI4M2ZkOWI2ZGFjMGI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-16T04:46:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-16T04:46:01Z"}, "message": "Auto merge of #94468 - Amanieu:global_asm_sym, r=nagisa\n\nImplement sym operands for global_asm!\n\nTracking issue: #93333\n\nThis PR is pretty much a complete rewrite of `sym` operand support for inline assembly so that the same implementation can be shared by `asm!` and `global_asm!`. The main changes are:\n- At the AST level, `sym` is represented as a special `InlineAsmSym` AST node containing a path instead of an `Expr`.\n- At the HIR level, `sym` is split into `SymStatic` and `SymFn` depending on whether the path resolves to a static during AST lowering (defaults to `SynFn` if `get_early_res` fails).\n  - `SymFn` is just an `AnonConst`. It runs through typeck and we just collect the resulting type at the end. An error is emitted if the type is not a `FnDef`.\n  - `SymStatic` directly holds a path and the `DefId` of the `static` that it is pointing to.\n- The representation at the MIR level is mostly unchanged. There is a minor change to THIR where `SymFn` is a constant instead of an expression.\n- At the codegen level we need to apply the target's symbol mangling to the result of `tcx.symbol_name()` depending on the target. This is done by calling the LLVM name mangler, which handles all of the details.\n  - On Mach-O, all symbols have a leading underscore.\n  - On x86 Windows, different mangling is used for cdecl, stdcall, fastcall and vectorcall.\n  - No mangling is needed on other platforms.\n\nr? `@nagisa`\ncc `@eddyb`", "tree": {"sha": "b7cd51a92bf8665a809ae013ba1d0c0aee2b902f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b7cd51a92bf8665a809ae013ba1d0c0aee2b902f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b", "html_url": "https://github.com/rust-lang/rust/commit/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "27490eb4232ceebc4f5e1e11b529b55994cf0333", "url": "https://api.github.com/repos/rust-lang/rust/commits/27490eb4232ceebc4f5e1e11b529b55994cf0333", "html_url": "https://github.com/rust-lang/rust/commit/27490eb4232ceebc4f5e1e11b529b55994cf0333"}, {"sha": "bdba89733e719e12b8fdd362d4c1e397f7c51436", "url": "https://api.github.com/repos/rust-lang/rust/commits/bdba89733e719e12b8fdd362d4c1e397f7c51436", "html_url": "https://github.com/rust-lang/rust/commit/bdba89733e719e12b8fdd362d4c1e397f7c51436"}], "stats": {"total": 899, "additions": 654, "deletions": 245}, "files": [{"sha": "714f9383bb2100fee13f16ce64a0957f3300e29c", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=080d5452e1bb6e18e12a073d4d0283fd9b6dac0b", "patch": "@@ -2061,6 +2061,20 @@ impl InlineAsmTemplatePiece {\n     }\n }\n \n+/// Inline assembly symbol operands get their own AST node that is somewhat\n+/// similar to `AnonConst`.\n+///\n+/// The main difference is that we specifically don't assign it `DefId` in\n+/// `DefCollector`. Instead this is deferred until AST lowering where we\n+/// lower it to an `AnonConst` (for functions) or a `Path` (for statics)\n+/// depending on what the path resolves to.\n+#[derive(Clone, Encodable, Decodable, Debug)]\n+pub struct InlineAsmSym {\n+    pub id: NodeId,\n+    pub qself: Option<QSelf>,\n+    pub path: Path,\n+}\n+\n /// Inline assembly operand.\n ///\n /// E.g., `out(\"eax\") result` as in `asm!(\"mov eax, 2\", out(\"eax\") result)`.\n@@ -2090,7 +2104,7 @@ pub enum InlineAsmOperand {\n         anon_const: AnonConst,\n     },\n     Sym {\n-        expr: P<Expr>,\n+        sym: InlineAsmSym,\n     },\n }\n "}, {"sha": "cba49835f69cb45efc0a6be4011ca764790f1b74", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=080d5452e1bb6e18e12a073d4d0283fd9b6dac0b", "patch": "@@ -280,6 +280,14 @@ pub trait MutVisitor: Sized {\n     fn flat_map_pat_field(&mut self, fp: PatField) -> SmallVec<[PatField; 1]> {\n         noop_flat_map_pat_field(fp, self)\n     }\n+\n+    fn visit_inline_asm(&mut self, asm: &mut InlineAsm) {\n+        noop_visit_inline_asm(asm, self)\n+    }\n+\n+    fn visit_inline_asm_sym(&mut self, sym: &mut InlineAsmSym) {\n+        noop_visit_inline_asm_sym(sym, self)\n+    }\n }\n \n /// Use a map-style function (`FnOnce(T) -> T`) to overwrite a `&mut T`. Useful\n@@ -1019,7 +1027,7 @@ pub fn noop_visit_item_kind<T: MutVisitor>(kind: &mut ItemKind, vis: &mut T) {\n             }\n         }\n         ItemKind::ForeignMod(nm) => vis.visit_foreign_mod(nm),\n-        ItemKind::GlobalAsm(asm) => noop_visit_inline_asm(asm, vis),\n+        ItemKind::GlobalAsm(asm) => vis.visit_inline_asm(asm),\n         ItemKind::TyAlias(box TyAlias {\n             defaultness, generics, where_clauses, bounds, ty, ..\n         }) => {\n@@ -1237,25 +1245,34 @@ pub fn noop_visit_anon_const<T: MutVisitor>(AnonConst { id, value }: &mut AnonCo\n     vis.visit_expr(value);\n }\n \n-fn noop_visit_inline_asm<T: MutVisitor>(asm: &mut InlineAsm, vis: &mut T) {\n+pub fn noop_visit_inline_asm<T: MutVisitor>(asm: &mut InlineAsm, vis: &mut T) {\n     for (op, _) in &mut asm.operands {\n         match op {\n             InlineAsmOperand::In { expr, .. }\n             | InlineAsmOperand::Out { expr: Some(expr), .. }\n-            | InlineAsmOperand::InOut { expr, .. }\n-            | InlineAsmOperand::Sym { expr, .. } => vis.visit_expr(expr),\n+            | InlineAsmOperand::InOut { expr, .. } => vis.visit_expr(expr),\n             InlineAsmOperand::Out { expr: None, .. } => {}\n             InlineAsmOperand::SplitInOut { in_expr, out_expr, .. } => {\n                 vis.visit_expr(in_expr);\n                 if let Some(out_expr) = out_expr {\n                     vis.visit_expr(out_expr);\n                 }\n             }\n-            InlineAsmOperand::Const { anon_const, .. } => vis.visit_anon_const(anon_const),\n+            InlineAsmOperand::Const { anon_const } => vis.visit_anon_const(anon_const),\n+            InlineAsmOperand::Sym { sym } => vis.visit_inline_asm_sym(sym),\n         }\n     }\n }\n \n+pub fn noop_visit_inline_asm_sym<T: MutVisitor>(\n+    InlineAsmSym { id, qself, path }: &mut InlineAsmSym,\n+    vis: &mut T,\n+) {\n+    vis.visit_id(id);\n+    vis.visit_qself(qself);\n+    vis.visit_path(path);\n+}\n+\n pub fn noop_visit_expr<T: MutVisitor>(\n     Expr { kind, id, span, attrs, tokens }: &mut Expr,\n     vis: &mut T,\n@@ -1374,7 +1391,7 @@ pub fn noop_visit_expr<T: MutVisitor>(\n         ExprKind::Ret(expr) => {\n             visit_opt(expr, |expr| vis.visit_expr(expr));\n         }\n-        ExprKind::InlineAsm(asm) => noop_visit_inline_asm(asm, vis),\n+        ExprKind::InlineAsm(asm) => vis.visit_inline_asm(asm),\n         ExprKind::MacCall(mac) => vis.visit_mac_call(mac),\n         ExprKind::Struct(se) => {\n             let StructExpr { qself, path, fields, rest } = se.deref_mut();"}, {"sha": "3183612597d137e68d7faee5730fc3db274cf04b", "filename": "compiler/rustc_ast/src/visit.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs?ref=080d5452e1bb6e18e12a073d4d0283fd9b6dac0b", "patch": "@@ -214,6 +214,12 @@ pub trait Visitor<'ast>: Sized {\n     fn visit_crate(&mut self, krate: &'ast Crate) {\n         walk_crate(self, krate)\n     }\n+    fn visit_inline_asm(&mut self, asm: &'ast InlineAsm) {\n+        walk_inline_asm(self, asm)\n+    }\n+    fn visit_inline_asm_sym(&mut self, sym: &'ast InlineAsmSym) {\n+        walk_inline_asm_sym(self, sym)\n+    }\n }\n \n #[macro_export]\n@@ -717,13 +723,12 @@ pub fn walk_anon_const<'a, V: Visitor<'a>>(visitor: &mut V, constant: &'a AnonCo\n     visitor.visit_expr(&constant.value);\n }\n \n-fn walk_inline_asm<'a, V: Visitor<'a>>(visitor: &mut V, asm: &'a InlineAsm) {\n+pub fn walk_inline_asm<'a, V: Visitor<'a>>(visitor: &mut V, asm: &'a InlineAsm) {\n     for (op, _) in &asm.operands {\n         match op {\n             InlineAsmOperand::In { expr, .. }\n             | InlineAsmOperand::Out { expr: Some(expr), .. }\n-            | InlineAsmOperand::InOut { expr, .. }\n-            | InlineAsmOperand::Sym { expr, .. } => visitor.visit_expr(expr),\n+            | InlineAsmOperand::InOut { expr, .. } => visitor.visit_expr(expr),\n             InlineAsmOperand::Out { expr: None, .. } => {}\n             InlineAsmOperand::SplitInOut { in_expr, out_expr, .. } => {\n                 visitor.visit_expr(in_expr);\n@@ -732,10 +737,18 @@ fn walk_inline_asm<'a, V: Visitor<'a>>(visitor: &mut V, asm: &'a InlineAsm) {\n                 }\n             }\n             InlineAsmOperand::Const { anon_const, .. } => visitor.visit_anon_const(anon_const),\n+            InlineAsmOperand::Sym { sym } => visitor.visit_inline_asm_sym(sym),\n         }\n     }\n }\n \n+pub fn walk_inline_asm_sym<'a, V: Visitor<'a>>(visitor: &mut V, sym: &'a InlineAsmSym) {\n+    if let Some(ref qself) = sym.qself {\n+        visitor.visit_ty(&qself.ty);\n+    }\n+    visitor.visit_path(&sym.path, sym.id);\n+}\n+\n pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n     walk_list!(visitor, visit_attribute, expression.attrs.iter());\n "}, {"sha": "ae3e367596258b16a37d4c66fd086fe2f2492f74", "filename": "compiler/rustc_ast_lowering/src/asm.rs", "status": "modified", "additions": 60, "deletions": 5, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs?ref=080d5452e1bb6e18e12a073d4d0283fd9b6dac0b", "patch": "@@ -1,12 +1,17 @@\n+use crate::{ImplTraitContext, ImplTraitPosition, ParamMode};\n+\n use super::LoweringContext;\n \n+use rustc_ast::ptr::P;\n use rustc_ast::*;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_set::FxHashSet;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n+use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::definitions::DefPathData;\n use rustc_session::parse::feature_err;\n-use rustc_span::{sym, Span};\n+use rustc_span::{sym, ExpnId, Span};\n use rustc_target::asm;\n use std::collections::hash_map::Entry;\n use std::fmt::Write;\n@@ -188,7 +193,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             anon_const: self.lower_anon_const(anon_const),\n                         }\n                     }\n-                    InlineAsmOperand::Sym { ref expr } => {\n+                    InlineAsmOperand::Sym { ref sym } => {\n                         if !self.sess.features_untracked().asm_sym {\n                             feature_err(\n                                 &self.sess.parse_sess,\n@@ -198,7 +203,54 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             )\n                             .emit();\n                         }\n-                        hir::InlineAsmOperand::Sym { expr: self.lower_expr_mut(expr) }\n+\n+                        let static_def_id = self\n+                            .resolver\n+                            .get_partial_res(sym.id)\n+                            .filter(|res| res.unresolved_segments() == 0)\n+                            .and_then(|res| {\n+                                if let Res::Def(DefKind::Static(_), def_id) = res.base_res() {\n+                                    Some(def_id)\n+                                } else {\n+                                    None\n+                                }\n+                            });\n+\n+                        if let Some(def_id) = static_def_id {\n+                            let path = self.lower_qpath(\n+                                sym.id,\n+                                &sym.qself,\n+                                &sym.path,\n+                                ParamMode::Optional,\n+                                ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n+                            );\n+                            hir::InlineAsmOperand::SymStatic { path, def_id }\n+                        } else {\n+                            // Replace the InlineAsmSym AST node with an\n+                            // Expr using the name node id.\n+                            let expr = Expr {\n+                                id: sym.id,\n+                                kind: ExprKind::Path(sym.qself.clone(), sym.path.clone()),\n+                                span: *op_sp,\n+                                attrs: AttrVec::new(),\n+                                tokens: None,\n+                            };\n+\n+                            // Wrap the expression in an AnonConst.\n+                            let parent_def_id = self.current_hir_id_owner;\n+                            let node_id = self.resolver.next_node_id();\n+                            self.resolver.create_def(\n+                                parent_def_id,\n+                                node_id,\n+                                DefPathData::AnonConst,\n+                                ExpnId::root(),\n+                                *op_sp,\n+                            );\n+                            let anon_const = AnonConst { id: node_id, value: P(expr) };\n+                            hir::InlineAsmOperand::SymFn {\n+                                anon_const: self.lower_anon_const(&anon_const),\n+                            }\n+                        }\n                     }\n                 };\n                 (op, self.lower_span(*op_sp))\n@@ -260,7 +312,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         err.span_label(op_sp, \"argument\");\n                         err.emit();\n                     }\n-                    hir::InlineAsmOperand::Sym { .. } => {\n+                    hir::InlineAsmOperand::SymFn { .. }\n+                    | hir::InlineAsmOperand::SymStatic { .. } => {\n                         let mut err = sess.struct_span_err(\n                             placeholder_span,\n                             \"asm template modifiers are not allowed for `sym` arguments\",\n@@ -308,7 +361,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         hir::InlineAsmOperand::InOut { .. }\n                         | hir::InlineAsmOperand::SplitInOut { .. } => (true, true),\n \n-                        hir::InlineAsmOperand::Const { .. } | hir::InlineAsmOperand::Sym { .. } => {\n+                        hir::InlineAsmOperand::Const { .. }\n+                        | hir::InlineAsmOperand::SymFn { .. }\n+                        | hir::InlineAsmOperand::SymStatic { .. } => {\n                             unreachable!()\n                         }\n                     };"}, {"sha": "c2247150d09c2580a1bf1302a2d9b5a0daa726be", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=080d5452e1bb6e18e12a073d4d0283fd9b6dac0b", "patch": "@@ -1266,10 +1266,14 @@ impl<'a> State<'a> {\n                         s.space();\n                         s.print_expr(&anon_const.value);\n                     }\n-                    InlineAsmOperand::Sym { expr } => {\n+                    InlineAsmOperand::Sym { sym } => {\n                         s.word(\"sym\");\n                         s.space();\n-                        s.print_expr(expr);\n+                        if let Some(qself) = &sym.qself {\n+                            s.print_qpath(&sym.path, qself, true);\n+                        } else {\n+                            s.print_path(&sym.path, true, 0);\n+                        }\n                     }\n                 }\n             }"}, {"sha": "030295d3d8dc382e296c1b01dc7f7ecfeeb35c2e", "filename": "compiler/rustc_builtin_macros/src/asm.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs?ref=080d5452e1bb6e18e12a073d4d0283fd9b6dac0b", "patch": "@@ -154,17 +154,19 @@ pub fn parse_asm_args<'a>(\n         } else if p.eat_keyword(kw::Const) {\n             let anon_const = p.parse_anon_const_expr()?;\n             ast::InlineAsmOperand::Const { anon_const }\n-        } else if !is_global_asm && p.eat_keyword(sym::sym) {\n+        } else if p.eat_keyword(sym::sym) {\n             let expr = p.parse_expr()?;\n-            match expr.kind {\n-                ast::ExprKind::Path(..) => {}\n-                _ => {\n-                    let err = diag\n-                        .struct_span_err(expr.span, \"argument to `sym` must be a path expression\");\n-                    return Err(err);\n-                }\n-            }\n-            ast::InlineAsmOperand::Sym { expr }\n+            let ast::ExprKind::Path(qself, path) = &expr.kind else {\n+                let err = diag\n+                    .struct_span_err(expr.span, \"expected a path for argument to `sym`\");\n+                return Err(err);\n+            };\n+            let sym = ast::InlineAsmSym {\n+                id: ast::DUMMY_NODE_ID,\n+                qself: qself.clone(),\n+                path: path.clone(),\n+            };\n+            ast::InlineAsmOperand::Sym { sym }\n         } else if allow_templates {\n             let template = p.parse_expr()?;\n             // If it can't possibly expand to a string, provide diagnostics here to include other"}, {"sha": "2af050f0c7533282bd965bf3628936e1a9e682f4", "filename": "compiler/rustc_codegen_gcc/src/asm.rs", "status": "modified", "additions": 28, "deletions": 4, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs?ref=080d5452e1bb6e18e12a073d4d0283fd9b6dac0b", "patch": "@@ -258,9 +258,14 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                 }\n \n                 InlineAsmOperandRef::SymFn { instance } => {\n+                    // TODO(@Amanieu): Additional mangling is needed on\n+                    // some targets to add a leading underscore (Mach-O)\n+                    // or byte count suffixes (x86 Windows).\n                     constants_len += self.tcx.symbol_name(instance).name.len();\n                 }\n                 InlineAsmOperandRef::SymStatic { def_id } => {\n+                    // TODO(@Amanieu): Additional mangling is needed on\n+                    // some targets to add a leading underscore (Mach-O).\n                     constants_len += self.tcx.symbol_name(Instance::mono(self.tcx, def_id)).name.len();\n                 }\n             }\n@@ -412,13 +417,16 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                         }\n \n                         InlineAsmOperandRef::SymFn { instance } => {\n+                            // TODO(@Amanieu): Additional mangling is needed on\n+                            // some targets to add a leading underscore (Mach-O)\n+                            // or byte count suffixes (x86 Windows).\n                             let name = self.tcx.symbol_name(instance).name;\n                             template_str.push_str(name);\n                         }\n \n                         InlineAsmOperandRef::SymStatic { def_id } => {\n-                            // TODO(@Commeownist): This may not be sufficient for all kinds of statics.\n-                            // Some statics may need the `@plt` suffix, like thread-local vars.\n+                            // TODO(@Amanieu): Additional mangling is needed on\n+                            // some targets to add a leading underscore (Mach-O).\n                             let instance = Instance::mono(self.tcx, def_id);\n                             let name = self.tcx.symbol_name(instance).name;\n                             template_str.push_str(name);\n@@ -656,8 +664,8 @@ fn dummy_output_type<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, reg: InlineAsmRegCl\n     }\n }\n \n-impl<'gcc, 'tcx> AsmMethods for CodegenCx<'gcc, 'tcx> {\n-    fn codegen_global_asm(&self, template: &[InlineAsmTemplatePiece], operands: &[GlobalAsmOperandRef], options: InlineAsmOptions, _line_spans: &[Span]) {\n+impl<'gcc, 'tcx> AsmMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n+    fn codegen_global_asm(&self, template: &[InlineAsmTemplatePiece], operands: &[GlobalAsmOperandRef<'tcx>], options: InlineAsmOptions, _line_spans: &[Span]) {\n         let asm_arch = self.tcx.sess.asm_arch.unwrap();\n \n         // Default to Intel syntax on x86\n@@ -690,6 +698,22 @@ impl<'gcc, 'tcx> AsmMethods for CodegenCx<'gcc, 'tcx> {\n                             // here unlike normal inline assembly.\n                             template_str.push_str(string);\n                         }\n+\n+                        GlobalAsmOperandRef::SymFn { instance } => {\n+                            // TODO(@Amanieu): Additional mangling is needed on\n+                            // some targets to add a leading underscore (Mach-O)\n+                            // or byte count suffixes (x86 Windows).\n+                            let name = self.tcx.symbol_name(instance).name;\n+                            template_str.push_str(name);\n+                        }\n+\n+                        GlobalAsmOperandRef::SymStatic { def_id } => {\n+                            // TODO(@Amanieu): Additional mangling is needed on\n+                            // some targets to add a leading underscore (Mach-O).\n+                            let instance = Instance::mono(self.tcx, def_id);\n+                            let name = self.tcx.symbol_name(instance).name;\n+                            template_str.push_str(name);\n+                        }\n                     }\n                 }\n             }"}, {"sha": "dff3200791825adac4ad57ce0ebf272891d0affd", "filename": "compiler/rustc_codegen_llvm/src/asm.rs", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs?ref=080d5452e1bb6e18e12a073d4d0283fd9b6dac0b", "patch": "@@ -312,11 +312,11 @@ impl<'ll, 'tcx> AsmBuilderMethods<'tcx> for Builder<'_, 'll, 'tcx> {\n     }\n }\n \n-impl AsmMethods for CodegenCx<'_, '_> {\n+impl<'tcx> AsmMethods<'tcx> for CodegenCx<'_, 'tcx> {\n     fn codegen_global_asm(\n         &self,\n         template: &[InlineAsmTemplatePiece],\n-        operands: &[GlobalAsmOperandRef],\n+        operands: &[GlobalAsmOperandRef<'tcx>],\n         options: InlineAsmOptions,\n         _line_spans: &[Span],\n     ) {\n@@ -342,6 +342,29 @@ impl AsmMethods for CodegenCx<'_, '_> {\n                             // here unlike normal inline assembly.\n                             template_str.push_str(string);\n                         }\n+                        GlobalAsmOperandRef::SymFn { instance } => {\n+                            let llval = self.get_fn(instance);\n+                            self.add_compiler_used_global(llval);\n+                            let symbol = llvm::build_string(|s| unsafe {\n+                                llvm::LLVMRustGetMangledName(llval, s);\n+                            })\n+                            .expect(\"symbol is not valid UTF-8\");\n+                            template_str.push_str(&symbol);\n+                        }\n+                        GlobalAsmOperandRef::SymStatic { def_id } => {\n+                            let llval = self\n+                                .renamed_statics\n+                                .borrow()\n+                                .get(&def_id)\n+                                .copied()\n+                                .unwrap_or_else(|| self.get_static(def_id));\n+                            self.add_compiler_used_global(llval);\n+                            let symbol = llvm::build_string(|s| unsafe {\n+                                llvm::LLVMRustGetMangledName(llval, s);\n+                            })\n+                            .expect(\"symbol is not valid UTF-8\");\n+                            template_str.push_str(&symbol);\n+                        }\n                     }\n                 }\n             }"}, {"sha": "c163c7d869269374aa9fc85a50c3f5484ef4ae96", "filename": "compiler/rustc_codegen_llvm/src/base.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs?ref=080d5452e1bb6e18e12a073d4d0283fd9b6dac0b", "patch": "@@ -99,15 +99,6 @@ pub fn compile_codegen_unit(tcx: TyCtxt<'_>, cgu_name: Symbol) -> (ModuleCodegen\n                 attributes::apply_to_llfn(entry, llvm::AttributePlace::Function, &attrs);\n             }\n \n-            // Run replace-all-uses-with for statics that need it\n-            for &(old_g, new_g) in cx.statics_to_rauw().borrow().iter() {\n-                unsafe {\n-                    let bitcast = llvm::LLVMConstPointerCast(new_g, cx.val_ty(old_g));\n-                    llvm::LLVMReplaceAllUsesWith(old_g, bitcast);\n-                    llvm::LLVMDeleteGlobal(old_g);\n-                }\n-            }\n-\n             // Finalize code coverage by injecting the coverage map. Note, the coverage map will\n             // also be added to the `llvm.compiler.used` variable, created next.\n             if cx.sess().instrument_coverage() {\n@@ -122,6 +113,16 @@ pub fn compile_codegen_unit(tcx: TyCtxt<'_>, cgu_name: Symbol) -> (ModuleCodegen\n                 cx.create_compiler_used_variable()\n             }\n \n+            // Run replace-all-uses-with for statics that need it. This must\n+            // happen after the llvm.used variables are created.\n+            for &(old_g, new_g) in cx.statics_to_rauw().borrow().iter() {\n+                unsafe {\n+                    let bitcast = llvm::LLVMConstPointerCast(new_g, cx.val_ty(old_g));\n+                    llvm::LLVMReplaceAllUsesWith(old_g, bitcast);\n+                    llvm::LLVMDeleteGlobal(old_g);\n+                }\n+            }\n+\n             // Finalize debuginfo\n             if cx.sess().opts.debuginfo != DebugInfo::None {\n                 cx.debuginfo_finalize();"}, {"sha": "4d3f3f318b80c7aa8d884ec9b93e1a686f9eb02e", "filename": "compiler/rustc_codegen_llvm/src/consts.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs?ref=080d5452e1bb6e18e12a073d4d0283fd9b6dac0b", "patch": "@@ -412,6 +412,13 @@ impl<'ll> StaticMethods for CodegenCx<'ll, '_> {\n                 llvm::LLVMRustSetLinkage(new_g, linkage);\n                 llvm::LLVMRustSetVisibility(new_g, visibility);\n \n+                // The old global has had its name removed but is returned by\n+                // get_static since it is in the instance cache. Provide an\n+                // alternative lookup that points to the new global so that\n+                // global_asm! can compute the correct mangled symbol name\n+                // for the global.\n+                self.renamed_statics.borrow_mut().insert(def_id, new_g);\n+\n                 // To avoid breaking any invariants, we leave around the old\n                 // global for the moment; we'll replace all references to it\n                 // with the new global later. (See base::codegen_backend.)"}, {"sha": "d296ee3b42ce1cfe4f5c738a87c325dca1ade669", "filename": "compiler/rustc_codegen_llvm/src/context.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs?ref=080d5452e1bb6e18e12a073d4d0283fd9b6dac0b", "patch": "@@ -14,6 +14,7 @@ use rustc_codegen_ssa::traits::*;\n use rustc_data_structures::base_n;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::small_c_str::SmallCStr;\n+use rustc_hir::def_id::DefId;\n use rustc_middle::mir::mono::CodegenUnit;\n use rustc_middle::ty::layout::{\n     FnAbiError, FnAbiOfHelpers, FnAbiRequest, HasParamEnv, LayoutError, LayoutOfHelpers,\n@@ -105,6 +106,12 @@ pub struct CodegenCx<'ll, 'tcx> {\n \n     /// A counter that is used for generating local symbol names\n     local_gen_sym_counter: Cell<usize>,\n+\n+    /// `codegen_static` will sometimes create a second global variable with a\n+    /// different type and clear the symbol name of the original global.\n+    /// `global_asm!` needs to be able to find this new global so that it can\n+    /// compute the correct mangled symbol name to insert into the asm.\n+    pub renamed_statics: RefCell<FxHashMap<DefId, &'ll Value>>,\n }\n \n pub struct TypeLowering<'ll> {\n@@ -436,6 +443,7 @@ impl<'ll, 'tcx> CodegenCx<'ll, 'tcx> {\n             rust_try_fn: Cell::new(None),\n             intrinsics: Default::default(),\n             local_gen_sym_counter: Cell::new(0),\n+            renamed_statics: Default::default(),\n         }\n     }\n "}, {"sha": "7f533b0552a5de2d884be0b1a312a66faca174f5", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=080d5452e1bb6e18e12a073d4d0283fd9b6dac0b", "patch": "@@ -2537,4 +2537,6 @@ extern \"C\" {\n         remark_passes_len: usize,\n     );\n \n+    #[allow(improper_ctypes)]\n+    pub fn LLVMRustGetMangledName(V: &Value, out: &RustString);\n }"}, {"sha": "5006a2157fcae6e801dcf763bfcbd84415fad9eb", "filename": "compiler/rustc_codegen_ssa/src/mono_item.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmono_item.rs?ref=080d5452e1bb6e18e12a073d4d0283fd9b6dac0b", "patch": "@@ -4,7 +4,9 @@ use crate::traits::*;\n use rustc_hir as hir;\n use rustc_middle::mir::mono::MonoItem;\n use rustc_middle::mir::mono::{Linkage, Visibility};\n+use rustc_middle::ty;\n use rustc_middle::ty::layout::{HasTyCtxt, LayoutOf};\n+use rustc_middle::ty::Instance;\n \n pub trait MonoItemExt<'a, 'tcx> {\n     fn define<Bx: BuilderMethods<'a, 'tcx>>(&self, cx: &'a Bx::CodegenCx);\n@@ -56,7 +58,27 @@ impl<'a, 'tcx: 'a> MonoItemExt<'a, 'tcx> for MonoItem<'tcx> {\n                                 );\n                                 GlobalAsmOperandRef::Const { string }\n                             }\n-                            _ => span_bug!(*op_sp, \"invalid operand type for global_asm!\"),\n+                            hir::InlineAsmOperand::SymFn { ref anon_const } => {\n+                                let ty = cx\n+                                    .tcx()\n+                                    .typeck_body(anon_const.body)\n+                                    .node_type(anon_const.hir_id);\n+                                let instance = match ty.kind() {\n+                                    &ty::FnDef(def_id, substs) => Instance::new(def_id, substs),\n+                                    _ => span_bug!(*op_sp, \"asm sym is not a function\"),\n+                                };\n+\n+                                GlobalAsmOperandRef::SymFn { instance }\n+                            }\n+                            hir::InlineAsmOperand::SymStatic { path: _, def_id } => {\n+                                GlobalAsmOperandRef::SymStatic { def_id }\n+                            }\n+                            hir::InlineAsmOperand::In { .. }\n+                            | hir::InlineAsmOperand::Out { .. }\n+                            | hir::InlineAsmOperand::InOut { .. }\n+                            | hir::InlineAsmOperand::SplitInOut { .. } => {\n+                                span_bug!(*op_sp, \"invalid operand type for global_asm!\")\n+                            }\n                         })\n                         .collect();\n "}, {"sha": "c2ae74b18d81ee17473dc3cfc68c792561fc09ba", "filename": "compiler/rustc_codegen_ssa/src/traits/asm.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fasm.rs?ref=080d5452e1bb6e18e12a073d4d0283fd9b6dac0b", "patch": "@@ -36,8 +36,10 @@ pub enum InlineAsmOperandRef<'tcx, B: BackendTypes + ?Sized> {\n }\n \n #[derive(Debug)]\n-pub enum GlobalAsmOperandRef {\n+pub enum GlobalAsmOperandRef<'tcx> {\n     Const { string: String },\n+    SymFn { instance: Instance<'tcx> },\n+    SymStatic { def_id: DefId },\n }\n \n pub trait AsmBuilderMethods<'tcx>: BackendTypes {\n@@ -53,11 +55,11 @@ pub trait AsmBuilderMethods<'tcx>: BackendTypes {\n     );\n }\n \n-pub trait AsmMethods {\n+pub trait AsmMethods<'tcx> {\n     fn codegen_global_asm(\n         &self,\n         template: &[InlineAsmTemplatePiece],\n-        operands: &[GlobalAsmOperandRef],\n+        operands: &[GlobalAsmOperandRef<'tcx>],\n         options: InlineAsmOptions,\n         line_spans: &[Span],\n     );"}, {"sha": "396768e0a42d0a2e17203ebfe01c7b1475a6eaaf", "filename": "compiler/rustc_codegen_ssa/src/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fmod.rs?ref=080d5452e1bb6e18e12a073d4d0283fd9b6dac0b", "patch": "@@ -60,7 +60,7 @@ pub trait CodegenMethods<'tcx>:\n     + StaticMethods\n     + CoverageInfoMethods<'tcx>\n     + DebugInfoMethods<'tcx>\n-    + AsmMethods\n+    + AsmMethods<'tcx>\n     + PreDefineMethods<'tcx>\n     + HasParamEnv<'tcx>\n     + HasTyCtxt<'tcx>\n@@ -76,7 +76,7 @@ impl<'tcx, T> CodegenMethods<'tcx> for T where\n         + StaticMethods\n         + CoverageInfoMethods<'tcx>\n         + DebugInfoMethods<'tcx>\n-        + AsmMethods\n+        + AsmMethods<'tcx>\n         + PreDefineMethods<'tcx>\n         + HasParamEnv<'tcx>\n         + HasTyCtxt<'tcx>"}, {"sha": "83193746432e9678105bb3380401880d3bc59c5a", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=080d5452e1bb6e18e12a073d4d0283fd9b6dac0b", "patch": "@@ -2425,8 +2425,12 @@ pub enum InlineAsmOperand<'hir> {\n     Const {\n         anon_const: AnonConst,\n     },\n-    Sym {\n-        expr: Expr<'hir>,\n+    SymFn {\n+        anon_const: AnonConst,\n+    },\n+    SymStatic {\n+        path: QPath<'hir>,\n+        def_id: DefId,\n     },\n }\n \n@@ -2437,7 +2441,7 @@ impl<'hir> InlineAsmOperand<'hir> {\n             | Self::Out { reg, .. }\n             | Self::InOut { reg, .. }\n             | Self::SplitInOut { reg, .. } => Some(reg),\n-            Self::Const { .. } | Self::Sym { .. } => None,\n+            Self::Const { .. } | Self::SymFn { .. } | Self::SymStatic { .. } => None,\n         }\n     }\n "}, {"sha": "445b856e513dc4a78f8e4feb4e91378e7d84eb32", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=080d5452e1bb6e18e12a073d4d0283fd9b6dac0b", "patch": "@@ -484,6 +484,9 @@ pub trait Visitor<'v>: Sized {\n     fn visit_defaultness(&mut self, defaultness: &'v Defaultness) {\n         walk_defaultness(self, defaultness);\n     }\n+    fn visit_inline_asm(&mut self, asm: &'v InlineAsm<'v>, id: HirId) {\n+        walk_inline_asm(self, asm, id);\n+    }\n }\n \n pub fn walk_mod<'v, V: Visitor<'v>>(visitor: &mut V, module: &'v Mod<'v>, mod_hir_id: HirId) {\n@@ -588,7 +591,7 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item<'v>) {\n         }\n         ItemKind::GlobalAsm(asm) => {\n             visitor.visit_id(item.hir_id());\n-            walk_inline_asm(visitor, asm);\n+            visitor.visit_inline_asm(asm, item.hir_id());\n         }\n         ItemKind::TyAlias(ref ty, ref generics) => {\n             visitor.visit_id(item.hir_id());\n@@ -648,12 +651,12 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item<'v>) {\n     }\n }\n \n-fn walk_inline_asm<'v, V: Visitor<'v>>(visitor: &mut V, asm: &'v InlineAsm<'v>) {\n-    for (op, _op_sp) in asm.operands {\n+pub fn walk_inline_asm<'v, V: Visitor<'v>>(visitor: &mut V, asm: &'v InlineAsm<'v>, id: HirId) {\n+    for (op, op_sp) in asm.operands {\n         match op {\n-            InlineAsmOperand::In { expr, .. }\n-            | InlineAsmOperand::InOut { expr, .. }\n-            | InlineAsmOperand::Sym { expr, .. } => visitor.visit_expr(expr),\n+            InlineAsmOperand::In { expr, .. } | InlineAsmOperand::InOut { expr, .. } => {\n+                visitor.visit_expr(expr)\n+            }\n             InlineAsmOperand::Out { expr, .. } => {\n                 if let Some(expr) = expr {\n                     visitor.visit_expr(expr);\n@@ -665,7 +668,9 @@ fn walk_inline_asm<'v, V: Visitor<'v>>(visitor: &mut V, asm: &'v InlineAsm<'v>)\n                     visitor.visit_expr(out_expr);\n                 }\n             }\n-            InlineAsmOperand::Const { anon_const } => visitor.visit_anon_const(anon_const),\n+            InlineAsmOperand::Const { anon_const, .. }\n+            | InlineAsmOperand::SymFn { anon_const, .. } => visitor.visit_anon_const(anon_const),\n+            InlineAsmOperand::SymStatic { path, .. } => visitor.visit_qpath(path, id, *op_sp),\n         }\n     }\n }\n@@ -1221,7 +1226,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr<'v>)\n             walk_list!(visitor, visit_expr, optional_expression);\n         }\n         ExprKind::InlineAsm(ref asm) => {\n-            walk_inline_asm(visitor, asm);\n+            visitor.visit_inline_asm(asm, expression.hir_id);\n         }\n         ExprKind::Yield(ref subexpression, _) => {\n             visitor.visit_expr(subexpression);"}, {"sha": "27f07a479b1b0ea0d8f14f6b3cdd010fa614aa53", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=080d5452e1bb6e18e12a073d4d0283fd9b6dac0b", "patch": "@@ -1352,10 +1352,15 @@ impl<'a> State<'a> {\n                     s.space();\n                     s.print_anon_const(anon_const);\n                 }\n-                hir::InlineAsmOperand::Sym { expr } => {\n-                    s.word(\"sym\");\n+                hir::InlineAsmOperand::SymFn { anon_const } => {\n+                    s.word(\"sym_fn\");\n                     s.space();\n-                    s.print_expr(expr);\n+                    s.print_anon_const(anon_const);\n+                }\n+                hir::InlineAsmOperand::SymStatic { path, def_id: _ } => {\n+                    s.word(\"sym_static\");\n+                    s.space();\n+                    s.print_qpath(path, true);\n                 }\n             },\n             AsmArg::Options(opts) => {"}, {"sha": "3ed4396d1e955c2bc531f69d323a1a6deb7e0e18", "filename": "compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp?ref=080d5452e1bb6e18e12a073d4d0283fd9b6dac0b", "patch": "@@ -1835,3 +1835,9 @@ extern \"C\" void LLVMRustContextConfigureDiagnosticHandler(\n   unwrap(C)->setDiagnosticHandler(std::make_unique<RustDiagnosticHandler>(\n       DiagnosticHandlerCallback, DiagnosticHandlerContext, RemarkAllPasses, Passes));\n }\n+\n+extern \"C\" void LLVMRustGetMangledName(LLVMValueRef V, RustStringRef Str) {\n+  RawRustStringOstream OS(Str);\n+  GlobalValue *GV = unwrap<GlobalValue>(V);\n+  Mangler().getNameWithPrefix(OS, GV, true);\n+}"}, {"sha": "e56efb8d497269439f00cd4611aae5654ae26500", "filename": "compiler/rustc_middle/src/thir.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir.rs?ref=080d5452e1bb6e18e12a073d4d0283fd9b6dac0b", "patch": "@@ -526,7 +526,8 @@ pub enum InlineAsmOperand<'tcx> {\n         span: Span,\n     },\n     SymFn {\n-        expr: ExprId,\n+        value: mir::ConstantKind<'tcx>,\n+        span: Span,\n     },\n     SymStatic {\n         def_id: DefId,"}, {"sha": "f57569522d58d3c65e1e0bd9522c0cff0d4d67fa", "filename": "compiler/rustc_middle/src/thir/visit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fvisit.rs?ref=080d5452e1bb6e18e12a073d4d0283fd9b6dac0b", "patch": "@@ -138,8 +138,7 @@ pub fn walk_expr<'a, 'tcx: 'a, V: Visitor<'a, 'tcx>>(visitor: &mut V, expr: &Exp\n                 match op {\n                     In { expr, reg: _ }\n                     | Out { expr: Some(expr), reg: _, late: _ }\n-                    | InOut { expr, reg: _, late: _ }\n-                    | SymFn { expr } => visitor.visit_expr(&visitor.thir()[*expr]),\n+                    | InOut { expr, reg: _, late: _ } => visitor.visit_expr(&visitor.thir()[*expr]),\n                     SplitInOut { in_expr, out_expr, reg: _, late: _ } => {\n                         visitor.visit_expr(&visitor.thir()[*in_expr]);\n                         if let Some(out_expr) = out_expr {\n@@ -148,6 +147,7 @@ pub fn walk_expr<'a, 'tcx: 'a, V: Visitor<'a, 'tcx>>(visitor: &mut V, expr: &Exp\n                     }\n                     Out { expr: None, reg: _, late: _ }\n                     | Const { value: _, span: _ }\n+                    | SymFn { value: _, span: _ }\n                     | SymStatic { def_id: _ } => {}\n                 }\n             }"}, {"sha": "a04ac33827424ab35fa1562077e3518c18103672", "filename": "compiler/rustc_mir_build/src/build/expr/into.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs?ref=080d5452e1bb6e18e12a073d4d0283fd9b6dac0b", "patch": "@@ -426,9 +426,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                                 value: Box::new(Constant { span, user_ty: None, literal: value }),\n                             }\n                         }\n-                        thir::InlineAsmOperand::SymFn { expr } => mir::InlineAsmOperand::SymFn {\n-                            value: Box::new(this.as_constant(&this.thir[expr])),\n-                        },\n+                        thir::InlineAsmOperand::SymFn { value, span } => {\n+                            mir::InlineAsmOperand::SymFn {\n+                                value: Box::new(Constant {\n+                                    span,\n+                                    user_ty: None,\n+                                    literal: value.into(),\n+                                }),\n+                            }\n+                        }\n                         thir::InlineAsmOperand::SymStatic { def_id } => {\n                             mir::InlineAsmOperand::SymStatic { def_id }\n                         }"}, {"sha": "f382f79af29dbf1291c3efe6a2678d3c7a7d1498", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 46, "deletions": 85, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=080d5452e1bb6e18e12a073d4d0283fd9b6dac0b", "patch": "@@ -462,95 +462,56 @@ impl<'tcx> Cx<'tcx> {\n                 operands: asm\n                     .operands\n                     .iter()\n-                    .map(|(op, _op_sp)| {\n-                        match *op {\n-                            hir::InlineAsmOperand::In { reg, ref expr } => {\n-                                InlineAsmOperand::In { reg, expr: self.mirror_expr(expr) }\n-                            }\n-                            hir::InlineAsmOperand::Out { reg, late, ref expr } => {\n-                                InlineAsmOperand::Out {\n-                                    reg,\n-                                    late,\n-                                    expr: expr.as_ref().map(|expr| self.mirror_expr(expr)),\n-                                }\n-                            }\n-                            hir::InlineAsmOperand::InOut { reg, late, ref expr } => {\n-                                InlineAsmOperand::InOut { reg, late, expr: self.mirror_expr(expr) }\n-                            }\n-                            hir::InlineAsmOperand::SplitInOut {\n-                                reg,\n-                                late,\n-                                ref in_expr,\n-                                ref out_expr,\n-                            } => InlineAsmOperand::SplitInOut {\n+                    .map(|(op, _op_sp)| match *op {\n+                        hir::InlineAsmOperand::In { reg, ref expr } => {\n+                            InlineAsmOperand::In { reg, expr: self.mirror_expr(expr) }\n+                        }\n+                        hir::InlineAsmOperand::Out { reg, late, ref expr } => {\n+                            InlineAsmOperand::Out {\n                                 reg,\n                                 late,\n-                                in_expr: self.mirror_expr(in_expr),\n-                                out_expr: out_expr.as_ref().map(|expr| self.mirror_expr(expr)),\n-                            },\n-                            hir::InlineAsmOperand::Const { ref anon_const } => {\n-                                let anon_const_def_id =\n-                                    self.tcx.hir().local_def_id(anon_const.hir_id);\n-                                let value = mir::ConstantKind::from_anon_const(\n-                                    self.tcx,\n-                                    anon_const_def_id,\n-                                    self.param_env,\n-                                );\n-                                let span = self.tcx.hir().span(anon_const.hir_id);\n-\n-                                InlineAsmOperand::Const { value, span }\n-                            }\n-                            hir::InlineAsmOperand::Sym { ref expr } => {\n-                                let hir::ExprKind::Path(ref qpath) = expr.kind else {\n-                                    span_bug!(\n-                                        expr.span,\n-                                        \"asm `sym` operand should be a path, found {:?}\",\n-                                        expr.kind\n-                                    );\n-                                };\n-                                let temp_lifetime =\n-                                    self.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n-                                let res = self.typeck_results().qpath_res(qpath, expr.hir_id);\n-                                let ty;\n-                                match res {\n-                                    Res::Def(DefKind::Fn, _) | Res::Def(DefKind::AssocFn, _) => {\n-                                        ty = self.typeck_results().node_type(expr.hir_id);\n-                                        let user_ty =\n-                                            self.user_substs_applied_to_res(expr.hir_id, res);\n-                                        InlineAsmOperand::SymFn {\n-                                            expr: self.thir.exprs.push(Expr {\n-                                                ty,\n-                                                temp_lifetime,\n-                                                span: expr.span,\n-                                                kind: ExprKind::zero_sized_literal(user_ty),\n-                                            }),\n-                                        }\n-                                    }\n-\n-                                    Res::Def(DefKind::Static(_), def_id) => {\n-                                        InlineAsmOperand::SymStatic { def_id }\n-                                    }\n-\n-                                    _ => {\n-                                        self.tcx.sess.span_err(\n-                                            expr.span,\n-                                            \"asm `sym` operand must point to a fn or static\",\n-                                        );\n-\n-                                        // Not a real fn, but we're not reaching codegen anyways...\n-                                        ty = self.tcx.ty_error();\n-                                        InlineAsmOperand::SymFn {\n-                                            expr: self.thir.exprs.push(Expr {\n-                                                ty,\n-                                                temp_lifetime,\n-                                                span: expr.span,\n-                                                kind: ExprKind::zero_sized_literal(None),\n-                                            }),\n-                                        }\n-                                    }\n-                                }\n+                                expr: expr.as_ref().map(|expr| self.mirror_expr(expr)),\n                             }\n                         }\n+                        hir::InlineAsmOperand::InOut { reg, late, ref expr } => {\n+                            InlineAsmOperand::InOut { reg, late, expr: self.mirror_expr(expr) }\n+                        }\n+                        hir::InlineAsmOperand::SplitInOut {\n+                            reg,\n+                            late,\n+                            ref in_expr,\n+                            ref out_expr,\n+                        } => InlineAsmOperand::SplitInOut {\n+                            reg,\n+                            late,\n+                            in_expr: self.mirror_expr(in_expr),\n+                            out_expr: out_expr.as_ref().map(|expr| self.mirror_expr(expr)),\n+                        },\n+                        hir::InlineAsmOperand::Const { ref anon_const } => {\n+                            let anon_const_def_id = self.tcx.hir().local_def_id(anon_const.hir_id);\n+                            let value = mir::ConstantKind::from_anon_const(\n+                                self.tcx,\n+                                anon_const_def_id,\n+                                self.param_env,\n+                            );\n+                            let span = self.tcx.hir().span(anon_const.hir_id);\n+\n+                            InlineAsmOperand::Const { value, span }\n+                        }\n+                        hir::InlineAsmOperand::SymFn { ref anon_const } => {\n+                            let anon_const_def_id = self.tcx.hir().local_def_id(anon_const.hir_id);\n+                            let value = mir::ConstantKind::from_anon_const(\n+                                self.tcx,\n+                                anon_const_def_id,\n+                                self.param_env,\n+                            );\n+                            let span = self.tcx.hir().span(anon_const.hir_id);\n+\n+                            InlineAsmOperand::SymFn { value, span }\n+                        }\n+                        hir::InlineAsmOperand::SymStatic { path: _, def_id } => {\n+                            InlineAsmOperand::SymStatic { def_id }\n+                        }\n                     })\n                     .collect(),\n                 options: asm.options,"}, {"sha": "fdb14e45d981a565cc13259df233107fccb60771", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=080d5452e1bb6e18e12a073d4d0283fd9b6dac0b", "patch": "@@ -435,7 +435,27 @@ fn collect_items_rec<'tcx>(\n                             // are supported. Therefore the value should not\n                             // depend on any other items.\n                         }\n-                        _ => span_bug!(*op_sp, \"invalid operand type for global_asm!\"),\n+                        hir::InlineAsmOperand::SymFn { anon_const } => {\n+                            let def_id = tcx.hir().body_owner_def_id(anon_const.body).to_def_id();\n+                            if let Ok(val) = tcx.const_eval_poly(def_id) {\n+                                rustc_data_structures::stack::ensure_sufficient_stack(|| {\n+                                    collect_const_value(tcx, val, &mut neighbors);\n+                                });\n+                            }\n+                        }\n+                        hir::InlineAsmOperand::SymStatic { path: _, def_id } => {\n+                            let instance = Instance::mono(tcx, *def_id);\n+                            if should_codegen_locally(tcx, &instance) {\n+                                trace!(\"collecting static {:?}\", def_id);\n+                                neighbors.push(dummy_spanned(MonoItem::Static(*def_id)));\n+                            }\n+                        }\n+                        hir::InlineAsmOperand::In { .. }\n+                        | hir::InlineAsmOperand::Out { .. }\n+                        | hir::InlineAsmOperand::InOut { .. }\n+                        | hir::InlineAsmOperand::SplitInOut { .. } => {\n+                            span_bug!(*op_sp, \"invalid operand type for global_asm!\")\n+                        }\n                     }\n                 }\n             } else {"}, {"sha": "261ea0b4deb4a18bb164838bfaee63e8110f1405", "filename": "compiler/rustc_passes/src/dead.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdead.rs?ref=080d5452e1bb6e18e12a073d4d0283fd9b6dac0b", "patch": "@@ -536,6 +536,10 @@ impl<'v, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'tcx> {\n                         .insert(self.tcx.hir().local_def_id(ctor_hir_id), item.def_id);\n                 }\n             }\n+            hir::ItemKind::GlobalAsm(_) => {\n+                // global_asm! is always live.\n+                self.worklist.push(item.def_id);\n+            }\n             _ => (),\n         }\n     }"}, {"sha": "7028fc4412648832b09dc57e90ae1aa1b8e35a29", "filename": "compiler/rustc_passes/src/intrinsicck.rs", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_passes%2Fsrc%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_passes%2Fsrc%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fintrinsicck.rs?ref=080d5452e1bb6e18e12a073d4d0283fd9b6dac0b", "patch": "@@ -1,3 +1,4 @@\n+use hir::intravisit::walk_inline_asm;\n use rustc_ast::InlineAsmTemplatePiece;\n use rustc_data_structures::stable_set::FxHashSet;\n use rustc_errors::struct_span_err;\n@@ -483,7 +484,10 @@ impl<'tcx> ExprVisitor<'tcx> {\n                         );\n                     }\n                 }\n-                hir::InlineAsmOperand::Const { .. } | hir::InlineAsmOperand::Sym { .. } => {}\n+                // These are checked in ItemVisitor.\n+                hir::InlineAsmOperand::Const { .. }\n+                | hir::InlineAsmOperand::SymFn { .. }\n+                | hir::InlineAsmOperand::SymStatic { .. } => {}\n             }\n         }\n     }\n@@ -498,6 +502,42 @@ impl<'tcx> Visitor<'tcx> for ItemVisitor<'tcx> {\n         ExprVisitor { tcx: self.tcx, param_env, typeck_results }.visit_body(body);\n         self.visit_body(body);\n     }\n+\n+    fn visit_inline_asm(&mut self, asm: &'tcx hir::InlineAsm<'tcx>, id: hir::HirId) {\n+        for (op, op_sp) in asm.operands.iter() {\n+            match *op {\n+                // These are checked in ExprVisitor.\n+                hir::InlineAsmOperand::In { .. }\n+                | hir::InlineAsmOperand::Out { .. }\n+                | hir::InlineAsmOperand::InOut { .. }\n+                | hir::InlineAsmOperand::SplitInOut { .. } => {}\n+                // No special checking is needed for these:\n+                // - Typeck has checked that Const operands are integers.\n+                // - AST lowering guarantees that SymStatic points to a static.\n+                hir::InlineAsmOperand::Const { .. } | hir::InlineAsmOperand::SymStatic { .. } => {}\n+                // Check that sym actually points to a function. Later passes\n+                // depend on this.\n+                hir::InlineAsmOperand::SymFn { anon_const } => {\n+                    let ty = self.tcx.typeck_body(anon_const.body).node_type(anon_const.hir_id);\n+                    match ty.kind() {\n+                        ty::Never | ty::Error(_) => {}\n+                        ty::FnDef(..) => {}\n+                        _ => {\n+                            let mut err =\n+                                self.tcx.sess.struct_span_err(*op_sp, \"invalid `sym` operand\");\n+                            err.span_label(\n+                                self.tcx.hir().span(anon_const.body.hir_id),\n+                                &format!(\"is {} `{}`\", ty.kind().article(), ty),\n+                            );\n+                            err.help(\"`sym` operands must refer to either a function or a static\");\n+                            err.emit();\n+                        }\n+                    };\n+                }\n+            }\n+        }\n+        walk_inline_asm(self, asm, id);\n+    }\n }\n \n impl<'tcx> Visitor<'tcx> for ExprVisitor<'tcx> {"}, {"sha": "99ea73fe2fe10bdb9304dbf8e2f60a13d8f8b464", "filename": "compiler/rustc_passes/src/liveness.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs?ref=080d5452e1bb6e18e12a073d4d0283fd9b6dac0b", "patch": "@@ -1043,7 +1043,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                     match op {\n                         hir::InlineAsmOperand::In { .. }\n                         | hir::InlineAsmOperand::Const { .. }\n-                        | hir::InlineAsmOperand::Sym { .. } => {}\n+                        | hir::InlineAsmOperand::SymFn { .. }\n+                        | hir::InlineAsmOperand::SymStatic { .. } => {}\n                         hir::InlineAsmOperand::Out { expr, .. } => {\n                             if let Some(expr) = expr {\n                                 succ = self.write_place(expr, succ, ACC_WRITE);\n@@ -1064,8 +1065,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 let mut succ = succ;\n                 for (op, _op_sp) in asm.operands.iter().rev() {\n                     match op {\n-                        hir::InlineAsmOperand::In { expr, .. }\n-                        | hir::InlineAsmOperand::Sym { expr, .. } => {\n+                        hir::InlineAsmOperand::In { expr, .. } => {\n                             succ = self.propagate_through_expr(expr, succ)\n                         }\n                         hir::InlineAsmOperand::Out { expr, .. } => {\n@@ -1082,7 +1082,9 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                             }\n                             succ = self.propagate_through_expr(in_expr, succ);\n                         }\n-                        hir::InlineAsmOperand::Const { .. } => {}\n+                        hir::InlineAsmOperand::Const { .. }\n+                        | hir::InlineAsmOperand::SymFn { .. }\n+                        | hir::InlineAsmOperand::SymStatic { .. } => {}\n                     }\n                 }\n                 succ"}, {"sha": "e85720952da7a4dc81616ff3b19de86995708da4", "filename": "compiler/rustc_passes/src/naked_functions.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_passes%2Fsrc%2Fnaked_functions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_passes%2Fsrc%2Fnaked_functions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fnaked_functions.rs?ref=080d5452e1bb6e18e12a073d4d0283fd9b6dac0b", "patch": "@@ -252,7 +252,9 @@ impl<'tcx> CheckInlineAssembly<'tcx> {\n             .operands\n             .iter()\n             .filter_map(|&(ref op, op_sp)| match op {\n-                InlineAsmOperand::Const { .. } | InlineAsmOperand::Sym { .. } => None,\n+                InlineAsmOperand::Const { .. }\n+                | InlineAsmOperand::SymFn { .. }\n+                | InlineAsmOperand::SymStatic { .. } => None,\n                 InlineAsmOperand::In { .. }\n                 | InlineAsmOperand::Out { .. }\n                 | InlineAsmOperand::InOut { .. }"}, {"sha": "f3b8c1e266c5871a2ca30a56c286f8ba0b64064d", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=080d5452e1bb6e18e12a073d4d0283fd9b6dac0b", "patch": "@@ -1012,6 +1012,12 @@ impl<'a> Resolver<'a> {\n                 err.span_label(trait_item_span, \"item in trait\");\n                 err\n             }\n+            ResolutionError::InvalidAsmSym => {\n+                let mut err = self.session.struct_span_err(span, \"invalid `sym` operand\");\n+                err.span_label(span, &format!(\"is a local variable\"));\n+                err.help(\"`sym` operands must refer to either a function or a static\");\n+                err\n+            }\n         }\n     }\n "}, {"sha": "24b6d6569810702522450851ae51700c7f4dd25d", "filename": "compiler/rustc_resolve/src/ident.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "raw_url": "https://github.com/rust-lang/rust/raw/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fident.rs?ref=080d5452e1bb6e18e12a073d4d0283fd9b6dac0b", "patch": "@@ -1182,6 +1182,12 @@ impl<'a> Resolver<'a> {\n                             }\n                             return Res::Err;\n                         }\n+                        InlineAsmSymRibKind => {\n+                            if let Some(span) = finalize {\n+                                self.report_error(span, InvalidAsmSym);\n+                            }\n+                            return Res::Err;\n+                        }\n                     }\n                 }\n                 if let Some((span, res_err)) = res_err {\n@@ -1242,6 +1248,22 @@ impl<'a> Resolver<'a> {\n                             }\n                             return Res::Err;\n                         }\n+                        InlineAsmSymRibKind => {\n+                            let features = self.session.features_untracked();\n+                            if !features.generic_const_exprs {\n+                                if let Some(span) = finalize {\n+                                    self.report_error(\n+                                        span,\n+                                        ResolutionError::ParamInNonTrivialAnonConst {\n+                                            name: rib_ident.name,\n+                                            is_type: true,\n+                                        },\n+                                    );\n+                                }\n+                                return Res::Err;\n+                            }\n+                            continue;\n+                        }\n                     };\n \n                     if let Some(span) = finalize {\n@@ -1306,6 +1328,22 @@ impl<'a> Resolver<'a> {\n                             }\n                             return Res::Err;\n                         }\n+                        InlineAsmSymRibKind => {\n+                            let features = self.session.features_untracked();\n+                            if !features.generic_const_exprs {\n+                                if let Some(span) = finalize {\n+                                    self.report_error(\n+                                        span,\n+                                        ResolutionError::ParamInNonTrivialAnonConst {\n+                                            name: rib_ident.name,\n+                                            is_type: false,\n+                                        },\n+                                    );\n+                                }\n+                                return Res::Err;\n+                            }\n+                            continue;\n+                        }\n                     };\n \n                     // This was an attempt to use a const parameter outside its scope."}, {"sha": "763f31622bc1f4ec18dcbff1156a25b28fc80318", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=080d5452e1bb6e18e12a073d4d0283fd9b6dac0b", "patch": "@@ -140,6 +140,10 @@ crate enum RibKind<'a> {\n     /// We are inside of the type of a const parameter. Can't refer to any\n     /// parameters.\n     ConstParamTyRibKind,\n+\n+    /// We are inside a `sym` inline assembly operand. Can only refer to\n+    /// globals.\n+    InlineAsmSymRibKind,\n }\n \n impl RibKind<'_> {\n@@ -153,7 +157,8 @@ impl RibKind<'_> {\n             | ConstantItemRibKind(..)\n             | ModuleRibKind(_)\n             | MacroDefinition(_)\n-            | ConstParamTyRibKind => false,\n+            | ConstParamTyRibKind\n+            | InlineAsmSymRibKind => false,\n             AssocItemRibKind | ItemRibKind(_) | ForwardGenericParamBanRibKind => true,\n         }\n     }\n@@ -722,6 +727,23 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n         visit::walk_where_predicate(self, p);\n         self.diagnostic_metadata.current_where_predicate = previous_value;\n     }\n+\n+    fn visit_inline_asm_sym(&mut self, sym: &'ast InlineAsmSym) {\n+        // This is similar to the code for AnonConst.\n+        self.with_rib(ValueNS, InlineAsmSymRibKind, |this| {\n+            this.with_rib(TypeNS, InlineAsmSymRibKind, |this| {\n+                this.with_label_rib(InlineAsmSymRibKind, |this| {\n+                    this.smart_resolve_path(\n+                        sym.id,\n+                        sym.qself.as_ref(),\n+                        &sym.path,\n+                        PathSource::Expr(None),\n+                    );\n+                    visit::walk_inline_asm_sym(this, sym);\n+                });\n+            })\n+        });\n+    }\n }\n \n impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n@@ -909,7 +931,8 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 | ConstantItemRibKind(..)\n                 | ModuleRibKind(..)\n                 | ForwardGenericParamBanRibKind\n-                | ConstParamTyRibKind => {\n+                | ConstParamTyRibKind\n+                | InlineAsmSymRibKind => {\n                     return false;\n                 }\n             }"}, {"sha": "0335c40d70d8c57eb899a245d754d4e31d867a4a", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=080d5452e1bb6e18e12a073d4d0283fd9b6dac0b", "patch": "@@ -260,6 +260,8 @@ enum ResolutionError<'a> {\n         trait_item_span: Span,\n         code: rustc_errors::DiagnosticId,\n     },\n+    /// Inline asm `sym` operand must refer to a `fn` or `static`.\n+    InvalidAsmSym,\n }\n \n enum VisResolutionError<'a> {"}, {"sha": "13a7dd7b70c09b055e05fbf69ac22c17215cf8a1", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=080d5452e1bb6e18e12a073d4d0283fd9b6dac0b", "patch": "@@ -2520,12 +2520,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         self.check_expr_asm_operand(out_expr, false);\n                     }\n                 }\n-                hir::InlineAsmOperand::Const { anon_const } => {\n+                hir::InlineAsmOperand::Const { anon_const }\n+                | hir::InlineAsmOperand::SymFn { anon_const } => {\n                     self.to_const(anon_const);\n                 }\n-                hir::InlineAsmOperand::Sym { expr } => {\n-                    self.check_expr(expr);\n-                }\n+                hir::InlineAsmOperand::SymStatic { .. } => {}\n             }\n         }\n         if asm.options.contains(ast::InlineAsmOptions::NORETURN) {"}, {"sha": "0d5e7b28a4e65e942c8e2c975f448a3b21a5e0d2", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=080d5452e1bb6e18e12a073d4d0283fd9b6dac0b", "patch": "@@ -427,16 +427,29 @@ fn typeck_with_fallback<'tcx>(\n                             span,\n                         }),\n                         Node::Expr(&hir::Expr { kind: hir::ExprKind::InlineAsm(asm), .. })\n-                        | Node::Item(&hir::Item { kind: hir::ItemKind::GlobalAsm(asm), .. })\n-                            if asm.operands.iter().any(|(op, _op_sp)| match op {\n-                                hir::InlineAsmOperand::Const { anon_const } => {\n-                                    anon_const.hir_id == id\n-                                }\n-                                _ => false,\n-                            }) =>\n-                        {\n-                            // Inline assembly constants must be integers.\n-                            fcx.next_int_var()\n+                        | Node::Item(&hir::Item { kind: hir::ItemKind::GlobalAsm(asm), .. }) => {\n+                            let operand_ty = asm\n+                                .operands\n+                                .iter()\n+                                .filter_map(|(op, _op_sp)| match op {\n+                                    hir::InlineAsmOperand::Const { anon_const }\n+                                        if anon_const.hir_id == id =>\n+                                    {\n+                                        // Inline assembly constants must be integers.\n+                                        Some(fcx.next_int_var())\n+                                    }\n+                                    hir::InlineAsmOperand::SymFn { anon_const }\n+                                        if anon_const.hir_id == id =>\n+                                    {\n+                                        Some(fcx.next_ty_var(TypeVariableOrigin {\n+                                            kind: TypeVariableOriginKind::MiscVariable,\n+                                            span,\n+                                        }))\n+                                    }\n+                                    _ => None,\n+                                })\n+                                .next();\n+                            operand_ty.unwrap_or_else(fallback)\n                         }\n                         _ => fallback(),\n                     },"}, {"sha": "fa06ec09fce22c6e7ed0960af0240f2752ff2275", "filename": "compiler/rustc_typeck/src/collect/type_of.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs?ref=080d5452e1bb6e18e12a073d4d0283fd9b6dac0b", "patch": "@@ -450,7 +450,8 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                 Node::Expr(&Expr { kind: ExprKind::InlineAsm(asm), .. })\n                 | Node::Item(&Item { kind: ItemKind::GlobalAsm(asm), .. })\n                     if asm.operands.iter().any(|(op, _op_sp)| match op {\n-                        hir::InlineAsmOperand::Const { anon_const } => anon_const.hir_id == hir_id,\n+                        hir::InlineAsmOperand::Const { anon_const }\n+                        | hir::InlineAsmOperand::SymFn { anon_const } => anon_const.hir_id == hir_id,\n                         _ => false,\n                     }) =>\n                 {"}, {"sha": "2bcf2d3b2ed71aabc5a68172464226e808ce06bc", "filename": "compiler/rustc_typeck/src/expr_use_visitor.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs?ref=080d5452e1bb6e18e12a073d4d0283fd9b6dac0b", "patch": "@@ -358,8 +358,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n             hir::ExprKind::InlineAsm(asm) => {\n                 for (op, _op_sp) in asm.operands {\n                     match op {\n-                        hir::InlineAsmOperand::In { expr, .. }\n-                        | hir::InlineAsmOperand::Sym { expr, .. } => self.consume_expr(expr),\n+                        hir::InlineAsmOperand::In { expr, .. } => self.consume_expr(expr),\n                         hir::InlineAsmOperand::Out { expr: Some(expr), .. }\n                         | hir::InlineAsmOperand::InOut { expr, .. } => {\n                             self.mutate_expr(expr);\n@@ -371,7 +370,9 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                             }\n                         }\n                         hir::InlineAsmOperand::Out { expr: None, .. }\n-                        | hir::InlineAsmOperand::Const { .. } => {}\n+                        | hir::InlineAsmOperand::Const { .. }\n+                        | hir::InlineAsmOperand::SymFn { .. }\n+                        | hir::InlineAsmOperand::SymStatic { .. } => {}\n                     }\n                 }\n             }"}, {"sha": "b76ce7ac387facd52e042e716c52f5589505e680", "filename": "src/test/assembly/asm/global_asm.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/src%2Ftest%2Fassembly%2Fasm%2Fglobal_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/src%2Ftest%2Fassembly%2Fasm%2Fglobal_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fassembly%2Fasm%2Fglobal_asm.rs?ref=080d5452e1bb6e18e12a073d4d0283fd9b6dac0b", "patch": "@@ -1,15 +1,26 @@\n // only-x86_64\n+// only-linux\n // assembly-output: emit-asm\n // compile-flags: -C llvm-args=--x86-asm-syntax=intel\n \n-#![feature(asm_const)]\n+#![feature(asm_const, asm_sym)]\n #![crate_type = \"rlib\"]\n \n use std::arch::global_asm;\n \n+#[no_mangle]\n+fn my_func() {}\n+\n+#[no_mangle]\n+static MY_STATIC: i32 = 0;\n+\n // CHECK: mov eax, eax\n global_asm!(\"mov eax, eax\");\n // CHECK: mov ebx, 5\n global_asm!(\"mov ebx, {}\", const 5);\n // CHECK: mov ecx, 5\n global_asm!(\"movl ${}, %ecx\", const 5, options(att_syntax));\n+// CHECK: call my_func\n+global_asm!(\"call {}\", sym my_func);\n+// CHECK: lea rax, [rip + MY_STATIC]\n+global_asm!(\"lea rax, [rip + {}]\", sym MY_STATIC);"}, {"sha": "cbc93cd3f7530c6bcbb93d8a6b6dc4acc956c493", "filename": "src/test/ui/asm/aarch64/parse-error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/src%2Ftest%2Fui%2Fasm%2Faarch64%2Fparse-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/src%2Ftest%2Fui%2Fasm%2Faarch64%2Fparse-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Faarch64%2Fparse-error.rs?ref=080d5452e1bb6e18e12a073d4d0283fd9b6dac0b", "patch": "@@ -29,7 +29,7 @@ fn main() {\n         asm!(\"{}\", in(reg) foo => bar);\n         //~^ ERROR expected one of `!`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n         asm!(\"{}\", sym foo + bar);\n-        //~^ ERROR argument to `sym` must be a path expression\n+        //~^ ERROR expected a path for argument to `sym`\n         asm!(\"\", options(foo));\n         //~^ ERROR expected one of\n         asm!(\"\", options(nomem foo));"}, {"sha": "f2013046cda4207043b3e2f6fd5146a170d39528", "filename": "src/test/ui/asm/aarch64/parse-error.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/src%2Ftest%2Fui%2Fasm%2Faarch64%2Fparse-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/src%2Ftest%2Fui%2Fasm%2Faarch64%2Fparse-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Faarch64%2Fparse-error.stderr?ref=080d5452e1bb6e18e12a073d4d0283fd9b6dac0b", "patch": "@@ -58,7 +58,7 @@ error: expected one of `!`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n LL |         asm!(\"{}\", in(reg) foo => bar);\n    |                                ^^ expected one of 7 possible tokens\n \n-error: argument to `sym` must be a path expression\n+error: expected a path for argument to `sym`\n   --> $DIR/parse-error.rs:31:24\n    |\n LL |         asm!(\"{}\", sym foo + bar);\n@@ -350,17 +350,17 @@ LL | global_asm!(\"{a}\", a = const FOO, a = const BAR);\n    |\n    = help: if this argument is intentionally unused, consider using it in an asm comment: `\"/* {1} */\"`\n \n-error: expected one of `clobber_abi`, `const`, or `options`, found `\"\"`\n+error: expected one of `clobber_abi`, `const`, `options`, or `sym`, found `\"\"`\n   --> $DIR/parse-error.rs:126:28\n    |\n LL | global_asm!(\"\", options(), \"\");\n-   |                            ^^ expected one of `clobber_abi`, `const`, or `options`\n+   |                            ^^ expected one of `clobber_abi`, `const`, `options`, or `sym`\n \n-error: expected one of `clobber_abi`, `const`, or `options`, found `\"{}\"`\n+error: expected one of `clobber_abi`, `const`, `options`, or `sym`, found `\"{}\"`\n   --> $DIR/parse-error.rs:128:30\n    |\n LL | global_asm!(\"{}\", const FOO, \"{}\", const FOO);\n-   |                              ^^^^ expected one of `clobber_abi`, `const`, or `options`\n+   |                              ^^^^ expected one of `clobber_abi`, `const`, `options`, or `sym`\n \n error: asm template must be a string literal\n   --> $DIR/parse-error.rs:130:13"}, {"sha": "9e53a2e0c5230cfd768b6506f14faf97317de89a", "filename": "src/test/ui/asm/aarch64/type-check-2.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/src%2Ftest%2Fui%2Fasm%2Faarch64%2Ftype-check-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/src%2Ftest%2Fui%2Fasm%2Faarch64%2Ftype-check-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Faarch64%2Ftype-check-2.rs?ref=080d5452e1bb6e18e12a073d4d0283fd9b6dac0b", "patch": "@@ -2,7 +2,7 @@\n \n #![feature(repr_simd, never_type, asm_sym)]\n \n-use std::arch::asm;\n+use std::arch::{asm, global_asm};\n \n #[repr(simd)]\n #[derive(Clone, Copy)]\n@@ -39,9 +39,7 @@ fn main() {\n         asm!(\"{}\", sym S);\n         asm!(\"{}\", sym main);\n         asm!(\"{}\", sym C);\n-        //~^ ERROR asm `sym` operand must point to a fn or static\n-        asm!(\"{}\", sym x);\n-        //~^ ERROR asm `sym` operand must point to a fn or static\n+        //~^ ERROR invalid `sym` operand\n \n         // Register operands must be Copy\n \n@@ -84,3 +82,12 @@ fn main() {\n         asm!(\"{}\", in(reg) u);\n     }\n }\n+\n+// Sym operands must point to a function or static\n+\n+const C: i32 = 0;\n+static S: i32 = 0;\n+global_asm!(\"{}\", sym S);\n+global_asm!(\"{}\", sym main);\n+global_asm!(\"{}\", sym C);\n+//~^ ERROR invalid `sym` operand"}, {"sha": "6047bed6e7802bb36b8f8fda8e2ad87caeecf347", "filename": "src/test/ui/asm/aarch64/type-check-2.stderr", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/src%2Ftest%2Fui%2Fasm%2Faarch64%2Ftype-check-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/src%2Ftest%2Fui%2Fasm%2Faarch64%2Ftype-check-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Faarch64%2Ftype-check-2.stderr?ref=080d5452e1bb6e18e12a073d4d0283fd9b6dac0b", "patch": "@@ -1,21 +1,21 @@\n error: arguments for inline assembly must be copyable\n-  --> $DIR/type-check-2.rs:48:31\n+  --> $DIR/type-check-2.rs:46:31\n    |\n LL |         asm!(\"{:v}\", in(vreg) SimdNonCopy(0.0, 0.0, 0.0, 0.0));\n    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `SimdNonCopy` does not implement the Copy trait\n \n-error: cannot use value of type `[closure@$DIR/type-check-2.rs:60:28: 60:38]` for inline assembly\n-  --> $DIR/type-check-2.rs:60:28\n+error: cannot use value of type `[closure@$DIR/type-check-2.rs:58:28: 58:38]` for inline assembly\n+  --> $DIR/type-check-2.rs:58:28\n    |\n LL |         asm!(\"{}\", in(reg) |x: i32| x);\n    |                            ^^^^^^^^^^\n    |\n    = note: only integers, floats, SIMD vectors, pointers and function pointers can be used as arguments for inline assembly\n \n error: cannot use value of type `Vec<i32>` for inline assembly\n-  --> $DIR/type-check-2.rs:62:28\n+  --> $DIR/type-check-2.rs:60:28\n    |\n LL |         asm!(\"{}\", in(reg) vec![0]);\n    |                            ^^^^^^^\n@@ -24,48 +24,52 @@ LL |         asm!(\"{}\", in(reg) vec![0]);\n    = note: this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: cannot use value of type `(i32, i32, i32)` for inline assembly\n-  --> $DIR/type-check-2.rs:64:28\n+  --> $DIR/type-check-2.rs:62:28\n    |\n LL |         asm!(\"{}\", in(reg) (1, 2, 3));\n    |                            ^^^^^^^^^\n    |\n    = note: only integers, floats, SIMD vectors, pointers and function pointers can be used as arguments for inline assembly\n \n error: cannot use value of type `[i32; 3]` for inline assembly\n-  --> $DIR/type-check-2.rs:66:28\n+  --> $DIR/type-check-2.rs:64:28\n    |\n LL |         asm!(\"{}\", in(reg) [1, 2, 3]);\n    |                            ^^^^^^^^^\n    |\n    = note: only integers, floats, SIMD vectors, pointers and function pointers can be used as arguments for inline assembly\n \n error: cannot use value of type `fn() {main}` for inline assembly\n-  --> $DIR/type-check-2.rs:74:31\n+  --> $DIR/type-check-2.rs:72:31\n    |\n LL |         asm!(\"{}\", inout(reg) f);\n    |                               ^\n    |\n    = note: only integers, floats, SIMD vectors, pointers and function pointers can be used as arguments for inline assembly\n \n error: cannot use value of type `&mut i32` for inline assembly\n-  --> $DIR/type-check-2.rs:77:31\n+  --> $DIR/type-check-2.rs:75:31\n    |\n LL |         asm!(\"{}\", inout(reg) r);\n    |                               ^\n    |\n    = note: only integers, floats, SIMD vectors, pointers and function pointers can be used as arguments for inline assembly\n \n-error: asm `sym` operand must point to a fn or static\n-  --> $DIR/type-check-2.rs:41:24\n+error: invalid `sym` operand\n+  --> $DIR/type-check-2.rs:41:20\n    |\n LL |         asm!(\"{}\", sym C);\n-   |                        ^\n+   |                    ^^^^^ is an `i32`\n+   |\n+   = help: `sym` operands must refer to either a function or a static\n \n-error: asm `sym` operand must point to a fn or static\n-  --> $DIR/type-check-2.rs:43:24\n+error: invalid `sym` operand\n+  --> $DIR/type-check-2.rs:92:19\n+   |\n+LL | global_asm!(\"{}\", sym C);\n+   |                   ^^^^^ is an `i32`\n    |\n-LL |         asm!(\"{}\", sym x);\n-   |                        ^\n+   = help: `sym` operands must refer to either a function or a static\n \n error[E0381]: use of possibly-uninitialized variable: `x`\n   --> $DIR/type-check-2.rs:19:28"}, {"sha": "9f0121e11b4470a001e1f2f7e1ae3a1aa07aefaa", "filename": "src/test/ui/asm/type-check-1.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/src%2Ftest%2Fui%2Fasm%2Ftype-check-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/src%2Ftest%2Fui%2Fasm%2Ftype-check-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Ftype-check-1.rs?ref=080d5452e1bb6e18e12a073d4d0283fd9b6dac0b", "patch": "@@ -3,7 +3,7 @@\n // ignore-spirv\n // ignore-wasm32\n \n-#![feature(asm_const)]\n+#![feature(asm_const, asm_sym)]\n \n use std::arch::{asm, global_asm};\n \n@@ -44,6 +44,8 @@ fn main() {\n         asm!(\"{}\", const const_bar(0));\n         asm!(\"{}\", const const_bar(x));\n         //~^ ERROR attempt to use a non-constant value in a constant\n+        asm!(\"{}\", sym x);\n+        //~^ ERROR invalid `sym` operand\n \n         // Const operands must be integers and must be constants.\n \n@@ -59,6 +61,11 @@ fn main() {\n     }\n }\n \n+unsafe fn generic<T>() {\n+    asm!(\"{}\", sym generic::<T>);\n+    //~^ generic parameters may not be used in const operations\n+}\n+\n // Const operands must be integers and must be constants.\n \n global_asm!(\"{}\", const 0);"}, {"sha": "7dba69fb7459276987dc7ac45bf996507fb44ab9", "filename": "src/test/ui/asm/type-check-1.stderr", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/src%2Ftest%2Fui%2Fasm%2Ftype-check-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/src%2Ftest%2Fui%2Fasm%2Ftype-check-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Ftype-check-1.stderr?ref=080d5452e1bb6e18e12a073d4d0283fd9b6dac0b", "patch": "@@ -25,14 +25,31 @@ LL |         let x = 0;\n LL |         asm!(\"{}\", const const_bar(x));\n    |                                    ^ non-constant value\n \n+error: invalid `sym` operand\n+  --> $DIR/type-check-1.rs:47:24\n+   |\n+LL |         asm!(\"{}\", sym x);\n+   |                        ^ is a local variable\n+   |\n+   = help: `sym` operands must refer to either a function or a static\n+\n+error: generic parameters may not be used in const operations\n+  --> $DIR/type-check-1.rs:65:30\n+   |\n+LL |     asm!(\"{}\", sym generic::<T>);\n+   |                              ^ cannot perform const operation using `T`\n+   |\n+   = note: type parameters may not be used in const expressions\n+   = help: use `#![feature(generic_const_exprs)]` to allow generic const expressions\n+\n error[E0308]: mismatched types\n-  --> $DIR/type-check-1.rs:53:26\n+  --> $DIR/type-check-1.rs:55:26\n    |\n LL |         asm!(\"{}\", const 0f32);\n    |                          ^^^^ expected integer, found `f32`\n \n error[E0308]: mismatched types\n-  --> $DIR/type-check-1.rs:55:26\n+  --> $DIR/type-check-1.rs:57:26\n    |\n LL |         asm!(\"{}\", const 0 as *mut u8);\n    |                          ^^^^^^^^^^^^ expected integer, found *-ptr\n@@ -41,7 +58,7 @@ LL |         asm!(\"{}\", const 0 as *mut u8);\n            found raw pointer `*mut u8`\n \n error[E0308]: mismatched types\n-  --> $DIR/type-check-1.rs:57:26\n+  --> $DIR/type-check-1.rs:59:26\n    |\n LL |         asm!(\"{}\", const &0);\n    |                          ^^ expected integer, found `&{integer}`\n@@ -92,21 +109,21 @@ LL |         asm!(\"{}\", inout(reg) v[..]);\n    = note: all inline asm arguments must have a statically known size\n \n error[E0308]: mismatched types\n-  --> $DIR/type-check-1.rs:67:25\n+  --> $DIR/type-check-1.rs:74:25\n    |\n LL | global_asm!(\"{}\", const 0f32);\n    |                         ^^^^ expected integer, found `f32`\n \n error[E0308]: mismatched types\n-  --> $DIR/type-check-1.rs:69:25\n+  --> $DIR/type-check-1.rs:76:25\n    |\n LL | global_asm!(\"{}\", const 0 as *mut u8);\n    |                         ^^^^^^^^^^^^ expected integer, found *-ptr\n    |\n    = note:     expected type `{integer}`\n            found raw pointer `*mut u8`\n \n-error: aborting due to 13 previous errors\n+error: aborting due to 15 previous errors\n \n Some errors have detailed explanations: E0277, E0308, E0435.\n For more information about an error, try `rustc --explain E0277`."}, {"sha": "9aeb6b2853fba8397aa322176a72af922ab1605f", "filename": "src/test/ui/asm/x86_64/parse-error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Fparse-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Fparse-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Fparse-error.rs?ref=080d5452e1bb6e18e12a073d4d0283fd9b6dac0b", "patch": "@@ -29,7 +29,7 @@ fn main() {\n         asm!(\"{}\", in(reg) foo => bar);\n         //~^ ERROR expected one of `!`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n         asm!(\"{}\", sym foo + bar);\n-        //~^ ERROR argument to `sym` must be a path expression\n+        //~^ ERROR expected a path for argument to `sym`\n         asm!(\"\", options(foo));\n         //~^ ERROR expected one of\n         asm!(\"\", options(nomem foo));"}, {"sha": "1fd317a96a8a6c09f5ab3c44e959f0ba4a497ba6", "filename": "src/test/ui/asm/x86_64/parse-error.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Fparse-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Fparse-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Fparse-error.stderr?ref=080d5452e1bb6e18e12a073d4d0283fd9b6dac0b", "patch": "@@ -58,7 +58,7 @@ error: expected one of `!`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n LL |         asm!(\"{}\", in(reg) foo => bar);\n    |                                ^^ expected one of 7 possible tokens\n \n-error: argument to `sym` must be a path expression\n+error: expected a path for argument to `sym`\n   --> $DIR/parse-error.rs:31:24\n    |\n LL |         asm!(\"{}\", sym foo + bar);\n@@ -362,17 +362,17 @@ LL | global_asm!(\"{a}\", a = const FOO, a = const BAR);\n    |\n    = help: if this argument is intentionally unused, consider using it in an asm comment: `\"/* {1} */\"`\n \n-error: expected one of `clobber_abi`, `const`, or `options`, found `\"\"`\n+error: expected one of `clobber_abi`, `const`, `options`, or `sym`, found `\"\"`\n   --> $DIR/parse-error.rs:130:28\n    |\n LL | global_asm!(\"\", options(), \"\");\n-   |                            ^^ expected one of `clobber_abi`, `const`, or `options`\n+   |                            ^^ expected one of `clobber_abi`, `const`, `options`, or `sym`\n \n-error: expected one of `clobber_abi`, `const`, or `options`, found `\"{}\"`\n+error: expected one of `clobber_abi`, `const`, `options`, or `sym`, found `\"{}\"`\n   --> $DIR/parse-error.rs:132:30\n    |\n LL | global_asm!(\"{}\", const FOO, \"{}\", const FOO);\n-   |                              ^^^^ expected one of `clobber_abi`, `const`, or `options`\n+   |                              ^^^^ expected one of `clobber_abi`, `const`, `options`, or `sym`\n \n error: asm template must be a string literal\n   --> $DIR/parse-error.rs:134:13"}, {"sha": "eb87ea91085f0ca5ab6f695f077622480f625d98", "filename": "src/test/ui/asm/x86_64/type-check-2.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Ftype-check-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Ftype-check-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Ftype-check-2.rs?ref=080d5452e1bb6e18e12a073d4d0283fd9b6dac0b", "patch": "@@ -2,7 +2,7 @@\n \n #![feature(repr_simd, never_type, asm_sym)]\n \n-use std::arch::asm;\n+use std::arch::{asm, global_asm};\n \n #[repr(simd)]\n struct SimdNonCopy(f32, f32, f32, f32);\n@@ -35,9 +35,7 @@ fn main() {\n         asm!(\"{}\", sym S);\n         asm!(\"{}\", sym main);\n         asm!(\"{}\", sym C);\n-        //~^ ERROR asm `sym` operand must point to a fn or static\n-        asm!(\"{}\", sym x);\n-        //~^ ERROR asm `sym` operand must point to a fn or static\n+        //~^ ERROR invalid `sym` operand\n \n         // Register operands must be Copy\n \n@@ -80,3 +78,12 @@ fn main() {\n         asm!(\"{}\", in(reg) u);\n     }\n }\n+\n+// Sym operands must point to a function or static\n+\n+const C: i32 = 0;\n+static S: i32 = 0;\n+global_asm!(\"{}\", sym S);\n+global_asm!(\"{}\", sym main);\n+global_asm!(\"{}\", sym C);\n+//~^ ERROR invalid `sym` operand"}, {"sha": "cb3960acdf9d317e0e0661e79c5d52463bd9c475", "filename": "src/test/ui/asm/x86_64/type-check-2.stderr", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Ftype-check-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Ftype-check-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Ftype-check-2.stderr?ref=080d5452e1bb6e18e12a073d4d0283fd9b6dac0b", "patch": "@@ -1,21 +1,21 @@\n error: arguments for inline assembly must be copyable\n-  --> $DIR/type-check-2.rs:44:32\n+  --> $DIR/type-check-2.rs:42:32\n    |\n LL |         asm!(\"{}\", in(xmm_reg) SimdNonCopy(0.0, 0.0, 0.0, 0.0));\n    |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `SimdNonCopy` does not implement the Copy trait\n \n-error: cannot use value of type `[closure@$DIR/type-check-2.rs:56:28: 56:38]` for inline assembly\n-  --> $DIR/type-check-2.rs:56:28\n+error: cannot use value of type `[closure@$DIR/type-check-2.rs:54:28: 54:38]` for inline assembly\n+  --> $DIR/type-check-2.rs:54:28\n    |\n LL |         asm!(\"{}\", in(reg) |x: i32| x);\n    |                            ^^^^^^^^^^\n    |\n    = note: only integers, floats, SIMD vectors, pointers and function pointers can be used as arguments for inline assembly\n \n error: cannot use value of type `Vec<i32>` for inline assembly\n-  --> $DIR/type-check-2.rs:58:28\n+  --> $DIR/type-check-2.rs:56:28\n    |\n LL |         asm!(\"{}\", in(reg) vec![0]);\n    |                            ^^^^^^^\n@@ -24,48 +24,52 @@ LL |         asm!(\"{}\", in(reg) vec![0]);\n    = note: this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: cannot use value of type `(i32, i32, i32)` for inline assembly\n-  --> $DIR/type-check-2.rs:60:28\n+  --> $DIR/type-check-2.rs:58:28\n    |\n LL |         asm!(\"{}\", in(reg) (1, 2, 3));\n    |                            ^^^^^^^^^\n    |\n    = note: only integers, floats, SIMD vectors, pointers and function pointers can be used as arguments for inline assembly\n \n error: cannot use value of type `[i32; 3]` for inline assembly\n-  --> $DIR/type-check-2.rs:62:28\n+  --> $DIR/type-check-2.rs:60:28\n    |\n LL |         asm!(\"{}\", in(reg) [1, 2, 3]);\n    |                            ^^^^^^^^^\n    |\n    = note: only integers, floats, SIMD vectors, pointers and function pointers can be used as arguments for inline assembly\n \n error: cannot use value of type `fn() {main}` for inline assembly\n-  --> $DIR/type-check-2.rs:70:31\n+  --> $DIR/type-check-2.rs:68:31\n    |\n LL |         asm!(\"{}\", inout(reg) f);\n    |                               ^\n    |\n    = note: only integers, floats, SIMD vectors, pointers and function pointers can be used as arguments for inline assembly\n \n error: cannot use value of type `&mut i32` for inline assembly\n-  --> $DIR/type-check-2.rs:73:31\n+  --> $DIR/type-check-2.rs:71:31\n    |\n LL |         asm!(\"{}\", inout(reg) r);\n    |                               ^\n    |\n    = note: only integers, floats, SIMD vectors, pointers and function pointers can be used as arguments for inline assembly\n \n-error: asm `sym` operand must point to a fn or static\n-  --> $DIR/type-check-2.rs:37:24\n+error: invalid `sym` operand\n+  --> $DIR/type-check-2.rs:37:20\n    |\n LL |         asm!(\"{}\", sym C);\n-   |                        ^\n+   |                    ^^^^^ is an `i32`\n+   |\n+   = help: `sym` operands must refer to either a function or a static\n \n-error: asm `sym` operand must point to a fn or static\n-  --> $DIR/type-check-2.rs:39:24\n+error: invalid `sym` operand\n+  --> $DIR/type-check-2.rs:88:19\n+   |\n+LL | global_asm!(\"{}\", sym C);\n+   |                   ^^^^^ is an `i32`\n    |\n-LL |         asm!(\"{}\", sym x);\n-   |                        ^\n+   = help: `sym` operands must refer to either a function or a static\n \n error[E0381]: use of possibly-uninitialized variable: `x`\n   --> $DIR/type-check-2.rs:15:28"}, {"sha": "9ba9642fcc833691fabcd4489b206e6ddb16a37a", "filename": "src/tools/clippy/clippy_lints/src/loops/never_loop.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fnever_loop.rs?ref=080d5452e1bb6e18e12a073d4d0283fd9b6dac0b", "patch": "@@ -169,13 +169,14 @@ fn never_loop_expr(expr: &Expr<'_>, main_loop_id: HirId) -> NeverLoopResult {\n             .iter()\n             .map(|(o, _)| match o {\n                 InlineAsmOperand::In { expr, .. }\n-                | InlineAsmOperand::InOut { expr, .. }\n-                | InlineAsmOperand::Sym { expr } => never_loop_expr(expr, main_loop_id),\n+                | InlineAsmOperand::InOut { expr, .. } => never_loop_expr(expr, main_loop_id),\n                 InlineAsmOperand::Out { expr, .. } => never_loop_expr_all(&mut expr.iter(), main_loop_id),\n                 InlineAsmOperand::SplitInOut { in_expr, out_expr, .. } => {\n                     never_loop_expr_all(&mut once(in_expr).chain(out_expr.iter()), main_loop_id)\n                 },\n-                InlineAsmOperand::Const { .. } => NeverLoopResult::Otherwise,\n+                InlineAsmOperand::Const { .. }\n+                | InlineAsmOperand::SymFn { .. }\n+                | InlineAsmOperand::SymStatic { .. } => NeverLoopResult::Otherwise,\n             })\n             .fold(NeverLoopResult::Otherwise, combine_both),\n         ExprKind::Struct(_, _, None)"}, {"sha": "a04288e0a413ecd8f6733eda276ba321d1b146d8", "filename": "src/tools/clippy/clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=080d5452e1bb6e18e12a073d4d0283fd9b6dac0b", "patch": "@@ -281,8 +281,9 @@ fn print_expr(cx: &LateContext<'_>, expr: &hir::Expr<'_>, indent: usize) {\n             for (op, _op_sp) in asm.operands {\n                 match op {\n                     hir::InlineAsmOperand::In { expr, .. }\n-                    | hir::InlineAsmOperand::InOut { expr, .. }\n-                    | hir::InlineAsmOperand::Sym { expr } => print_expr(cx, expr, indent + 1),\n+                    | hir::InlineAsmOperand::InOut { expr, .. } => {\n+                        print_expr(cx, expr, indent + 1);\n+                    }\n                     hir::InlineAsmOperand::Out { expr, .. } => {\n                         if let Some(expr) = expr {\n                             print_expr(cx, expr, indent + 1);\n@@ -294,10 +295,26 @@ fn print_expr(cx: &LateContext<'_>, expr: &hir::Expr<'_>, indent: usize) {\n                             print_expr(cx, out_expr, indent + 1);\n                         }\n                     },\n-                    hir::InlineAsmOperand::Const { anon_const } => {\n+                    hir::InlineAsmOperand::Const { anon_const }\n+                    | hir::InlineAsmOperand::SymFn { anon_const } => {\n                         println!(\"{}anon_const:\", ind);\n                         print_expr(cx, &cx.tcx.hir().body(anon_const.body).value, indent + 1);\n                     },\n+                    hir::InlineAsmOperand::SymStatic { path, .. } => {\n+                        match path {\n+                            hir::QPath::Resolved(ref ty, path) => {\n+                                println!(\"{}Resolved Path, {:?}\", ind, ty);\n+                                println!(\"{}path: {:?}\", ind, path);\n+                            },\n+                            hir::QPath::TypeRelative(ty, seg) => {\n+                                println!(\"{}Relative Path, {:?}\", ind, ty);\n+                                println!(\"{}seg: {:?}\", ind, seg);\n+                            },\n+                            hir::QPath::LangItem(lang_item, ..) => {\n+                                println!(\"{}Lang Item Path, {:?}\", ind, lang_item.name());\n+                            },\n+                        }\n+                    }\n                 }\n             }\n         },"}, {"sha": "c05317f59b716ad60f0fdd92689ee1167fbe914e", "filename": "src/tools/clippy/clippy_utils/src/hir_utils.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/080d5452e1bb6e18e12a073d4d0283fd9b6dac0b/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhir_utils.rs?ref=080d5452e1bb6e18e12a073d4d0283fd9b6dac0b", "patch": "@@ -675,7 +675,8 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n                             }\n                         },\n                         InlineAsmOperand::Const { anon_const } => self.hash_body(anon_const.body),\n-                        InlineAsmOperand::Sym { expr } => self.hash_expr(expr),\n+                        InlineAsmOperand::SymFn { anon_const } => self.hash_body(anon_const.body),\n+                        InlineAsmOperand::SymStatic { path, def_id: _ } => self.hash_qpath(path),\n                     }\n                 }\n             },"}]}