{"sha": "0961e688fda35a664b5869dcfe1295b00538c7ae", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5NjFlNjg4ZmRhMzVhNjY0YjU4NjlkY2ZlMTI5NWIwMDUzOGM3YWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-05T01:56:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-05T01:56:25Z"}, "message": "Auto merge of #88469 - patrick-gu:master, r=dtolnay\n\nAdd links in docs for some primitive types\n\nThis pull request adds additional links in existing documentation of some of the primitive types.\n\nWhere items are linked only once, I have used the `[link](destination)` format. For items in `std`, I have linked directly to the HTML, since although the primitives are in `core`, they are not displayed on `core` documentation. I was unsure of what length I should keep lines of documentation to, so I tried to keep them within reason.\n\nAdditionally, I have avoided excessively linking to keywords like `self` when they are not relevant to the documentation. I can add these links if it would be an improvement.\n\nI hope this can improve Rust. Please let me know if there's anything I did wrong!", "tree": {"sha": "f87403aad47587b526655e97500d342ea78e6250", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f87403aad47587b526655e97500d342ea78e6250"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0961e688fda35a664b5869dcfe1295b00538c7ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0961e688fda35a664b5869dcfe1295b00538c7ae", "html_url": "https://github.com/rust-lang/rust/commit/0961e688fda35a664b5869dcfe1295b00538c7ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0961e688fda35a664b5869dcfe1295b00538c7ae/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3baa466444fcaa7e25f0578431f4ddeba0dc4a1b", "url": "https://api.github.com/repos/rust-lang/rust/commits/3baa466444fcaa7e25f0578431f4ddeba0dc4a1b", "html_url": "https://github.com/rust-lang/rust/commit/3baa466444fcaa7e25f0578431f4ddeba0dc4a1b"}, {"sha": "7c32b58df24fe98dd3529d344fec6b1ad1631b63", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c32b58df24fe98dd3529d344fec6b1ad1631b63", "html_url": "https://github.com/rust-lang/rust/commit/7c32b58df24fe98dd3529d344fec6b1ad1631b63"}], "stats": {"total": 58, "additions": 33, "deletions": 25}, "files": [{"sha": "8c33a43ab330ebd4d847152d7e188cbb231afbb6", "filename": "library/core/src/array/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0961e688fda35a664b5869dcfe1295b00538c7ae/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0961e688fda35a664b5869dcfe1295b00538c7ae/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fmod.rs?ref=0961e688fda35a664b5869dcfe1295b00538c7ae", "patch": "@@ -396,7 +396,7 @@ impl<T, const N: usize> [T; N] {\n     ///\n     /// This method is particularly useful if combined with other methods, like\n     /// [`map`](#method.map). This way, you can avoid moving the original\n-    /// array if its elements are not `Copy`.\n+    /// array if its elements are not [`Copy`].\n     ///\n     /// ```\n     /// #![feature(array_methods)]"}, {"sha": "ca1c0ae759892466228d0f072e48a6da7da78df6", "filename": "library/core/src/bool.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0961e688fda35a664b5869dcfe1295b00538c7ae/library%2Fcore%2Fsrc%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0961e688fda35a664b5869dcfe1295b00538c7ae/library%2Fcore%2Fsrc%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fbool.rs?ref=0961e688fda35a664b5869dcfe1295b00538c7ae", "patch": "@@ -2,7 +2,7 @@\n \n #[lang = \"bool\"]\n impl bool {\n-    /// Returns `Some(t)` if the `bool` is `true`, or `None` otherwise.\n+    /// Returns `Some(t)` if the `bool` is [`true`](keyword.true.html), or `None` otherwise.\n     ///\n     /// # Examples\n     ///\n@@ -18,7 +18,7 @@ impl bool {\n         if self { Some(t) } else { None }\n     }\n \n-    /// Returns `Some(f())` if the `bool` is `true`, or `None` otherwise.\n+    /// Returns `Some(f())` if the `bool` is [`true`](keyword.true.html), or `None` otherwise.\n     ///\n     /// # Examples\n     ///"}, {"sha": "e6d3ac8f2d2c5d3637cb4fd144fc1572cedf691a", "filename": "library/core/src/char/methods.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0961e688fda35a664b5869dcfe1295b00538c7ae/library%2Fcore%2Fsrc%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0961e688fda35a664b5869dcfe1295b00538c7ae/library%2Fcore%2Fsrc%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fchar%2Fmethods.rs?ref=0961e688fda35a664b5869dcfe1295b00538c7ae", "patch": "@@ -96,7 +96,7 @@ impl char {\n     /// Converts a `u32` to a `char`.\n     ///\n     /// Note that all `char`s are valid [`u32`]s, and can be cast to one with\n-    /// `as`:\n+    /// [`as`](keyword.as.html):\n     ///\n     /// ```\n     /// let c = '\ud83d\udcaf';\n@@ -372,7 +372,7 @@ impl char {\n     /// println!(\"\\\\u{{2764}}\");\n     /// ```\n     ///\n-    /// Using `to_string`:\n+    /// Using [`to_string`](string/trait.ToString.html#tymethod.to_string):\n     ///\n     /// ```\n     /// assert_eq!('\u2764'.escape_unicode().to_string(), \"\\\\u{2764}\");\n@@ -422,7 +422,7 @@ impl char {\n     /// Returns an iterator that yields the literal escape code of a character\n     /// as `char`s.\n     ///\n-    /// This will escape the characters similar to the `Debug` implementations\n+    /// This will escape the characters similar to the [`Debug`](core::fmt::Debug) implementations\n     /// of `str` or `char`.\n     ///\n     /// # Examples\n@@ -448,7 +448,7 @@ impl char {\n     /// println!(\"\\\\n\");\n     /// ```\n     ///\n-    /// Using `to_string`:\n+    /// Using [`to_string`](string/trait.ToString.html#tymethod.to_string):\n     ///\n     /// ```\n     /// assert_eq!('\\n'.escape_debug().to_string(), \"\\\\n\");\n@@ -502,7 +502,7 @@ impl char {\n     /// println!(\"\\\\\\\"\");\n     /// ```\n     ///\n-    /// Using `to_string`:\n+    /// Using [`to_string`](string/trait.ToString.html#tymethod.to_string):\n     ///\n     /// ```\n     /// assert_eq!('\"'.escape_default().to_string(), \"\\\\\\\"\");\n@@ -937,7 +937,7 @@ impl char {\n     /// println!(\"i\\u{307}\");\n     /// ```\n     ///\n-    /// Using `to_string`:\n+    /// Using [`to_string`](string/trait.ToString.html#tymethod.to_string):\n     ///\n     /// ```\n     /// assert_eq!('C'.to_lowercase().to_string(), \"c\");\n@@ -1002,7 +1002,7 @@ impl char {\n     /// println!(\"SS\");\n     /// ```\n     ///\n-    /// Using `to_string`:\n+    /// Using [`to_string`](string/trait.ToString.html#tymethod.to_string):\n     ///\n     /// ```\n     /// assert_eq!('c'.to_uppercase().to_string(), \"C\");\n@@ -1131,7 +1131,7 @@ impl char {\n \n     /// Checks that two values are an ASCII case-insensitive match.\n     ///\n-    /// Equivalent to `to_ascii_lowercase(a) == to_ascii_lowercase(b)`.\n+    /// Equivalent to <code>[to_ascii_lowercase]\\(a) == [to_ascii_lowercase]\\(b)</code>.\n     ///\n     /// # Examples\n     ///\n@@ -1144,6 +1144,8 @@ impl char {\n     /// assert!(upper_a.eq_ignore_ascii_case(&upper_a));\n     /// assert!(!upper_a.eq_ignore_ascii_case(&lower_z));\n     /// ```\n+    ///\n+    /// [to_ascii_lowercase]: #method.to_ascii_lowercase\n     #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n     #[rustc_const_stable(feature = \"const_ascii_methods_on_intrinsics\", since = \"1.52.0\")]\n     #[inline]"}, {"sha": "b85489dabe94c716d47b336f3b2387ced963737b", "filename": "library/std/src/primitive_docs.rs", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0961e688fda35a664b5869dcfe1295b00538c7ae/library%2Fstd%2Fsrc%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0961e688fda35a664b5869dcfe1295b00538c7ae/library%2Fstd%2Fsrc%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprimitive_docs.rs?ref=0961e688fda35a664b5869dcfe1295b00538c7ae", "patch": "@@ -3,26 +3,29 @@\n #[doc(alias = \"false\")]\n /// The boolean type.\n ///\n-/// The `bool` represents a value, which could only be either `true` or `false`. If you cast\n-/// a `bool` into an integer, `true` will be 1 and `false` will be 0.\n+/// The `bool` represents a value, which could only be either [`true`] or [`false`]. If you cast\n+/// a `bool` into an integer, [`true`] will be 1 and [`false`] will be 0.\n ///\n /// # Basic usage\n ///\n /// `bool` implements various traits, such as [`BitAnd`], [`BitOr`], [`Not`], etc.,\n /// which allow us to perform boolean operations using `&`, `|` and `!`.\n ///\n-/// `if` requires a `bool` value as its conditional. [`assert!`], which is an\n-/// important macro in testing, checks whether an expression is `true` and panics\n+/// [`if`] requires a `bool` value as its conditional. [`assert!`], which is an\n+/// important macro in testing, checks whether an expression is [`true`] and panics\n /// if it isn't.\n ///\n /// ```\n /// let bool_val = true & false | false;\n /// assert!(!bool_val);\n /// ```\n ///\n+/// [`true`]: keyword.true.html\n+/// [`false`]: keyword.false.html\n /// [`BitAnd`]: ops::BitAnd\n /// [`BitOr`]: ops::BitOr\n /// [`Not`]: ops::Not\n+/// [`if`]: keyword.if.html\n ///\n /// # Examples\n ///\n@@ -574,8 +577,8 @@ mod prim_pointer {}\n ///\n /// # Editions\n ///\n-/// Prior to Rust 1.53, arrays did not implement `IntoIterator` by value, so the method call\n-/// `array.into_iter()` auto-referenced into a slice iterator. Right now, the old behavior\n+/// Prior to Rust 1.53, arrays did not implement [`IntoIterator`] by value, so the method call\n+/// `array.into_iter()` auto-referenced into a [slice iterator](slice::iter). Right now, the old behavior\n /// is preserved in the 2015 and 2018 editions of Rust for compatibility, ignoring\n /// `IntoIterator` by value. In the future, the behavior on the 2015 and 2018 edition\n /// might be made consistent to the behavior of later editions.\n@@ -833,7 +836,7 @@ mod prim_str {}\n /// ```\n ///\n /// The sequential nature of the tuple applies to its implementations of various\n-/// traits.  For example, in `PartialOrd` and `Ord`, the elements are compared\n+/// traits. For example, in [`PartialOrd`] and [`Ord`], the elements are compared\n /// sequentially until the first non-equal set is found.\n ///\n /// For more about tuples, see [the book](../book/ch03-02-data-types.html#the-tuple-type).\n@@ -1037,14 +1040,16 @@ mod prim_usize {}\n /// References, both shared and mutable.\n ///\n /// A reference represents a borrow of some owned value. You can get one by using the `&` or `&mut`\n-/// operators on a value, or by using a `ref` or `ref mut` pattern.\n+/// operators on a value, or by using a [`ref`](keyword.ref.html) or\n+/// <code>[ref](keyword.ref.html) [mut](keyword.mut.html)</code> pattern.\n ///\n /// For those familiar with pointers, a reference is just a pointer that is assumed to be\n /// aligned, not null, and pointing to memory containing a valid value of `T` - for example,\n-/// `&bool` can only point to an allocation containing the integer values `1` (`true`) or `0`\n-/// (`false`), but creating a `&bool` that points to an allocation containing\n-/// the value `3` causes undefined behaviour.\n-/// In fact, `Option<&T>` has the same memory representation as a\n+/// <code>&[bool]</code> can only point to an allocation containing the integer values `1`\n+/// ([`true`](keyword.true.html)) or `0` ([`false`](keyword.false.html)), but creating a\n+/// <code>&[bool]</code> that points to an allocation containing the value `3` causes\n+/// undefined behaviour.\n+/// In fact, <code>[Option]\\<&T></code> has the same memory representation as a\n /// nullable but aligned pointer, and can be passed across FFI boundaries as such.\n ///\n /// In most cases, references can be used much like the original value. Field access, method\n@@ -1140,7 +1145,7 @@ mod prim_usize {}\n /// * [`ExactSizeIterator`]\n /// * [`FusedIterator`]\n /// * [`TrustedLen`]\n-/// * [`Send`] \\(note that `&T` references only get `Send` if `T: Sync`)\n+/// * [`Send`] \\(note that `&T` references only get `Send` if <code>T: [Sync]</code>)\n /// * [`io::Write`]\n /// * [`Read`]\n /// * [`Seek`]\n@@ -1172,7 +1177,8 @@ mod prim_ref {}\n /// Function pointers are pointers that point to *code*, not data. They can be called\n /// just like functions. Like references, function pointers are, among other things, assumed to\n /// not be null, so if you want to pass a function pointer over FFI and be able to accommodate null\n-/// pointers, make your type `Option<fn()>` with your required signature.\n+/// pointers, make your type [`Option<fn()>`](core::option#options-and-pointers-nullable-pointers)\n+/// with your required signature.\n ///\n /// ### Safety\n ///"}]}