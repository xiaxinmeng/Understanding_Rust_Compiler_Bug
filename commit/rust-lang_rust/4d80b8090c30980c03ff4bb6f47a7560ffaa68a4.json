{"sha": "4d80b8090c30980c03ff4bb6f47a7560ffaa68a4", "node_id": "C_kwDOAAsO6NoAKDRkODBiODA5MGMzMDk4MGMwM2ZmNGJiNmY0N2E3NTYwZmZhYTY4YTQ", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-05-09T18:56:43Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-05-25T03:19:15Z"}, "message": "Pull out logic from #111131, plus some new logic in EvalCtxt::normalize_opaque_type\n\nCo-authored-by: lcnr <rust@lcnr.de>", "tree": {"sha": "d45cf4788222a3542ea503f8083f516ecbb04855", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d45cf4788222a3542ea503f8083f516ecbb04855"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4d80b8090c30980c03ff4bb6f47a7560ffaa68a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4d80b8090c30980c03ff4bb6f47a7560ffaa68a4", "html_url": "https://github.com/rust-lang/rust/commit/4d80b8090c30980c03ff4bb6f47a7560ffaa68a4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4d80b8090c30980c03ff4bb6f47a7560ffaa68a4/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7664dfe4331265d0b2b1ffb89c92d443886bec0b", "url": "https://api.github.com/repos/rust-lang/rust/commits/7664dfe4331265d0b2b1ffb89c92d443886bec0b", "html_url": "https://github.com/rust-lang/rust/commit/7664dfe4331265d0b2b1ffb89c92d443886bec0b"}], "stats": {"total": 165, "additions": 122, "deletions": 43}, "files": [{"sha": "b6b935de68c8424d73f48d21208f7943c7d7047a", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4d80b8090c30980c03ff4bb6f47a7560ffaa68a4/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d80b8090c30980c03ff4bb6f47a7560ffaa68a4/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=4d80b8090c30980c03ff4bb6f47a7560ffaa68a4", "patch": "@@ -113,10 +113,7 @@ impl<'tcx> InferCtxt<'tcx> {\n                 bug!()\n             }\n \n-            (_, ty::Alias(AliasKind::Projection | AliasKind::Inherent, _))\n-            | (ty::Alias(AliasKind::Projection | AliasKind::Inherent, _), _)\n-                if self.tcx.trait_solver_next() =>\n-            {\n+            (_, ty::Alias(..)) | (ty::Alias(..), _) if self.tcx.trait_solver_next() => {\n                 relation.register_type_relate_obligation(a, b);\n                 Ok(a)\n             }"}, {"sha": "42dfe4f6bb81258b638aa6fdbbf9fd55f435bc0a", "filename": "compiler/rustc_infer/src/infer/equate.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4d80b8090c30980c03ff4bb6f47a7560ffaa68a4/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d80b8090c30980c03ff4bb6f47a7560ffaa68a4/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs?ref=4d80b8090c30980c03ff4bb6f47a7560ffaa68a4", "patch": "@@ -104,7 +104,8 @@ impl<'tcx> TypeRelation<'tcx> for Equate<'_, '_, 'tcx> {\n             (&ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }), _)\n             | (_, &ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }))\n                 if self.fields.define_opaque_types == DefineOpaqueTypes::Yes\n-                    && def_id.is_local() =>\n+                    && def_id.is_local()\n+                    && !self.tcx().trait_solver_next() =>\n             {\n                 self.fields.obligations.extend(\n                     infcx"}, {"sha": "7190d33d299b762de93dd83f2694b3e41f82b96c", "filename": "compiler/rustc_infer/src/infer/lattice.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4d80b8090c30980c03ff4bb6f47a7560ffaa68a4/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d80b8090c30980c03ff4bb6f47a7560ffaa68a4/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flattice.rs?ref=4d80b8090c30980c03ff4bb6f47a7560ffaa68a4", "patch": "@@ -108,9 +108,12 @@ where\n             &ty::Alias(ty::Opaque, ty::AliasTy { def_id: a_def_id, .. }),\n             &ty::Alias(ty::Opaque, ty::AliasTy { def_id: b_def_id, .. }),\n         ) if a_def_id == b_def_id => infcx.super_combine_tys(this, a, b),\n+\n         (&ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }), _)\n         | (_, &ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }))\n-            if this.define_opaque_types() == DefineOpaqueTypes::Yes && def_id.is_local() =>\n+            if this.define_opaque_types() == DefineOpaqueTypes::Yes\n+                && def_id.is_local()\n+                && !this.tcx().trait_solver_next() =>\n         {\n             this.register_obligations(\n                 infcx"}, {"sha": "d3fd01b964255bb241f7100d8ac1f89baf87cef0", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4d80b8090c30980c03ff4bb6f47a7560ffaa68a4/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d80b8090c30980c03ff4bb6f47a7560ffaa68a4/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=4d80b8090c30980c03ff4bb6f47a7560ffaa68a4", "patch": "@@ -491,16 +491,22 @@ where\n             (\n                 &ty::Alias(ty::Opaque, ty::AliasTy { def_id: a_def_id, .. }),\n                 &ty::Alias(ty::Opaque, ty::AliasTy { def_id: b_def_id, .. }),\n-            ) if a_def_id == b_def_id => infcx.super_combine_tys(self, a, b).or_else(|err| {\n-                self.tcx().sess.delay_span_bug(\n-                    self.delegate.span(),\n-                    \"failure to relate an opaque to itself should result in an error later on\",\n-                );\n-                if a_def_id.is_local() { self.relate_opaques(a, b) } else { Err(err) }\n-            }),\n+            ) if a_def_id == b_def_id || infcx.tcx.trait_solver_next() => {\n+                infcx.super_combine_tys(self, a, b).or_else(|err| {\n+                    // This behavior is only there for the old solver, the new solver\n+                    // shouldn't ever fail. Instead, it unconditionally emits an\n+                    // alias-relate goal.\n+                    assert!(!self.tcx().trait_solver_next());\n+                    self.tcx().sess.delay_span_bug(\n+                        self.delegate.span(),\n+                        \"failure to relate an opaque to itself should result in an error later on\",\n+                    );\n+                    if a_def_id.is_local() { self.relate_opaques(a, b) } else { Err(err) }\n+                })\n+            }\n             (&ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }), _)\n             | (_, &ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }))\n-                if def_id.is_local() =>\n+                if def_id.is_local() && !self.tcx().trait_solver_next() =>\n             {\n                 self.relate_opaques(a, b)\n             }"}, {"sha": "21df3291f361df17697bc8466d25ba0054e8fda3", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 34, "deletions": 11, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/4d80b8090c30980c03ff4bb6f47a7560ffaa68a4/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d80b8090c30980c03ff4bb6f47a7560ffaa68a4/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=4d80b8090c30980c03ff4bb6f47a7560ffaa68a4", "patch": "@@ -2,7 +2,7 @@ use super::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use super::{DefineOpaqueTypes, InferResult};\n use crate::errors::OpaqueHiddenTypeDiag;\n use crate::infer::{DefiningAnchor, InferCtxt, InferOk};\n-use crate::traits;\n+use crate::traits::{self, PredicateObligation};\n use hir::def_id::{DefId, LocalDefId};\n use hir::OpaqueTyOrigin;\n use rustc_data_structures::fx::FxIndexMap;\n@@ -48,9 +48,15 @@ impl<'tcx> InferCtxt<'tcx> {\n         span: Span,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> InferOk<'tcx, T> {\n+        // We handle opaque types differently in the new solver.\n+        if self.tcx.trait_solver_next() {\n+            return InferOk { value, obligations: vec![] };\n+        }\n+\n         if !value.has_opaque_types() {\n             return InferOk { value, obligations: vec![] };\n         }\n+\n         let mut obligations = vec![];\n         let replace_opaque_type = |def_id: DefId| {\n             def_id.as_local().is_some_and(|def_id| self.opaque_type_origin(def_id).is_some())\n@@ -521,17 +527,14 @@ impl<'tcx> InferCtxt<'tcx> {\n         origin: hir::OpaqueTyOrigin,\n         a_is_expected: bool,\n     ) -> InferResult<'tcx, ()> {\n-        let tcx = self.tcx;\n-        let OpaqueTypeKey { def_id, substs } = opaque_type_key;\n-\n         // Ideally, we'd get the span where *this specific `ty` came\n         // from*, but right now we just use the span from the overall\n         // value being folded. In simple cases like `-> impl Foo`,\n         // these are the same span, but not in cases like `-> (impl\n         // Foo, impl Bar)`.\n         let span = cause.span;\n         let prev = self.inner.borrow_mut().opaque_types().register(\n-            OpaqueTypeKey { def_id, substs },\n+            opaque_type_key,\n             OpaqueHiddenType { ty: hidden_ty, span },\n             origin,\n         );\n@@ -543,6 +546,26 @@ impl<'tcx> InferCtxt<'tcx> {\n             Vec::new()\n         };\n \n+        self.add_item_bounds_for_hidden_type(\n+            opaque_type_key,\n+            cause,\n+            param_env,\n+            hidden_ty,\n+            &mut obligations,\n+        );\n+\n+        Ok(InferOk { value: (), obligations })\n+    }\n+\n+    pub fn add_item_bounds_for_hidden_type(\n+        &self,\n+        OpaqueTypeKey { def_id, substs }: OpaqueTypeKey<'tcx>,\n+        cause: ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        hidden_ty: Ty<'tcx>,\n+        obligations: &mut Vec<PredicateObligation<'tcx>>,\n+    ) {\n+        let tcx = self.tcx;\n         let item_bounds = tcx.explicit_item_bounds(def_id);\n \n         for (predicate, _) in item_bounds.subst_iter_copied(tcx, substs) {\n@@ -555,14 +578,15 @@ impl<'tcx> InferCtxt<'tcx> {\n                     // FIXME(inherent_associated_types): Extend this to support `ty::Inherent`, too.\n                     ty::Alias(ty::Projection, projection_ty)\n                         if !projection_ty.has_escaping_bound_vars()\n-                            && !tcx.is_impl_trait_in_trait(projection_ty.def_id) =>\n+                            && !tcx.is_impl_trait_in_trait(projection_ty.def_id)\n+                            && !tcx.trait_solver_next() =>\n                     {\n                         self.infer_projection(\n                             param_env,\n                             projection_ty,\n                             cause.clone(),\n                             0,\n-                            &mut obligations,\n+                            obligations,\n                         )\n                     }\n                     // Replace all other mentions of the same opaque type with the hidden type,\n@@ -588,10 +612,10 @@ impl<'tcx> InferCtxt<'tcx> {\n                 predicate.kind().skip_binder()\n             {\n                 if projection.term.references_error() {\n-                    // No point on adding these obligations since there's a type error involved.\n-                    return Ok(InferOk { value: (), obligations: vec![] });\n+                    // No point on adding any obligations since there's a type error involved.\n+                    obligations.clear();\n+                    return;\n                 }\n-                trace!(\"{:#?}\", projection.term);\n             }\n             // Require that the predicate holds for the concrete type.\n             debug!(?predicate);\n@@ -602,7 +626,6 @@ impl<'tcx> InferCtxt<'tcx> {\n                 predicate,\n             ));\n         }\n-        Ok(InferOk { value: (), obligations })\n     }\n }\n "}, {"sha": "ceafafb5582cd9d4ccadd13fdeb50fbc3058f023", "filename": "compiler/rustc_infer/src/infer/sub.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4d80b8090c30980c03ff4bb6f47a7560ffaa68a4/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d80b8090c30980c03ff4bb6f47a7560ffaa68a4/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs?ref=4d80b8090c30980c03ff4bb6f47a7560ffaa68a4", "patch": "@@ -131,7 +131,8 @@ impl<'tcx> TypeRelation<'tcx> for Sub<'_, '_, 'tcx> {\n             (&ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }), _)\n             | (_, &ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }))\n                 if self.fields.define_opaque_types == DefineOpaqueTypes::Yes\n-                    && def_id.is_local() =>\n+                    && def_id.is_local()\n+                    && !self.tcx().trait_solver_next() =>\n             {\n                 self.fields.obligations.extend(\n                     infcx"}, {"sha": "73f435d4840ace72406c462a24f62d9a8452aa8b", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4d80b8090c30980c03ff4bb6f47a7560ffaa68a4/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d80b8090c30980c03ff4bb6f47a7560ffaa68a4/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=4d80b8090c30980c03ff4bb6f47a7560ffaa68a4", "patch": "@@ -996,17 +996,11 @@ impl<'tcx> Term<'tcx> {\n         }\n     }\n \n-    /// This function returns the inner `AliasTy` if this term is a projection.\n-    ///\n-    /// FIXME: rename `AliasTy` to `AliasTerm` and make sure we correctly\n-    /// deal with constants.\n-    pub fn to_projection_term(&self, tcx: TyCtxt<'tcx>) -> Option<AliasTy<'tcx>> {\n+    /// This function returns the inner `AliasTy` for a `ty::Alias` or `ConstKind::Unevaluated`.\n+    pub fn to_alias_ty(&self, tcx: TyCtxt<'tcx>) -> Option<AliasTy<'tcx>> {\n         match self.unpack() {\n-            TermKind::Ty(ty) => match ty.kind() {\n-                ty::Alias(kind, alias_ty) => match kind {\n-                    AliasKind::Projection | AliasKind::Inherent => Some(*alias_ty),\n-                    AliasKind::Opaque => None,\n-                },\n+            TermKind::Ty(ty) => match *ty.kind() {\n+                ty::Alias(_kind, alias_ty) => Some(alias_ty),\n                 _ => None,\n             },\n             TermKind::Const(ct) => match ct.kind() {"}, {"sha": "4a403196c7e05d89abf8a49c67cf9900eb095484", "filename": "compiler/rustc_trait_selection/src/solve/fulfill.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4d80b8090c30980c03ff4bb6f47a7560ffaa68a4/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d80b8090c30980c03ff4bb6f47a7560ffaa68a4/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs?ref=4d80b8090c30980c03ff4bb6f47a7560ffaa68a4", "patch": "@@ -133,12 +133,14 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentCtxt<'tcx> {\n                                 | ty::PredicateKind::ObjectSafe(_)\n                                 | ty::PredicateKind::ClosureKind(_, _, _)\n                                 | ty::PredicateKind::ConstEvaluatable(_)\n-                                | ty::PredicateKind::TypeWellFormedFromEnv(_)\n                                 | ty::PredicateKind::Ambiguous => {\n                                     FulfillmentErrorCode::CodeSelectionError(\n                                         SelectionError::Unimplemented,\n                                     )\n                                 }\n+                                ty::PredicateKind::TypeWellFormedFromEnv(_) => {\n+                                    bug!(\"unexpected goal: {goal:?}\")\n+                                }\n                             },\n                             root_obligation: obligation,\n                         });"}, {"sha": "1427268f8291f4fd797c9daabc079f9750fa76b6", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4d80b8090c30980c03ff4bb6f47a7560ffaa68a4/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d80b8090c30980c03ff4bb6f47a7560ffaa68a4/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=4d80b8090c30980c03ff4bb6f47a7560ffaa68a4", "patch": "@@ -24,6 +24,7 @@ mod assembly;\n mod canonicalize;\n mod eval_ctxt;\n mod fulfill;\n+mod opaques;\n mod project_goals;\n mod search_graph;\n mod trait_goals;\n@@ -212,7 +213,7 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n             );\n         }\n \n-        match (lhs.to_projection_term(tcx), rhs.to_projection_term(tcx)) {\n+        match (lhs.to_alias_ty(tcx), rhs.to_alias_ty(tcx)) {\n             (None, None) => bug!(\"`AliasRelate` goal without an alias on either lhs or rhs\"),\n \n             // RHS is not a projection, only way this is true is if LHS normalizes-to RHS"}, {"sha": "1a7704593382d62649b3d9ebcfe40227d8436457", "filename": "compiler/rustc_trait_selection/src/solve/opaques.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/4d80b8090c30980c03ff4bb6f47a7560ffaa68a4/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fopaques.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d80b8090c30980c03ff4bb6f47a7560ffaa68a4/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fopaques.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fopaques.rs?ref=4d80b8090c30980c03ff4bb6f47a7560ffaa68a4", "patch": "@@ -0,0 +1,44 @@\n+use rustc_infer::infer::InferOk;\n+use rustc_middle::traits::solve::{Certainty, Goal, QueryResult};\n+use rustc_middle::traits::{ObligationCause, Reveal};\n+use rustc_middle::ty::ProjectionPredicate;\n+\n+use super::{EvalCtxt, SolverMode};\n+\n+impl<'tcx> EvalCtxt<'_, 'tcx> {\n+    pub(super) fn normalize_opaque_type(\n+        &mut self,\n+        goal: Goal<'tcx, ProjectionPredicate<'tcx>>,\n+    ) -> QueryResult<'tcx> {\n+        let tcx = self.tcx();\n+        let opaque_ty = goal.predicate.projection_ty;\n+        let expected = goal.predicate.term.ty().expect(\"no such thing as an opaque const\");\n+\n+        match goal.param_env.reveal() {\n+            Reveal::UserFacing => match self.solver_mode() {\n+                SolverMode::Normal => self.probe(|ecx| {\n+                    // FIXME: Check that the usage is \"defining\" (all free params), otherwise bail.\n+                    // FIXME: This should probably just check the anchor directly\n+                    let InferOk { value: (), obligations } = self.infcx.handle_opaque_type(\n+                        expected,\n+                        tcx.mk_opaque(opaque_ty.def_id, opaque_ty.substs),\n+                        true,\n+                        &ObligationCause::dummy(),\n+                        goal.param_env,\n+                    )?;\n+                    // FIXME: Need to fold these to replace the opaque ty with the expected ty.\n+                    ecx.add_goals(obligations.into_iter().map(Into::into));\n+                    ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+                }),\n+                SolverMode::Coherence => {\n+                    self.evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS)\n+                }\n+            },\n+            Reveal::All => self.probe(|ecx| {\n+                let actual = tcx.type_of(opaque_ty.def_id).subst(tcx, opaque_ty.substs);\n+                ecx.eq(goal.param_env, expected, actual)?;\n+                ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+            }),\n+        }\n+    }\n+}"}, {"sha": "248b750b3bdafe8bb95e1c1cb7151b14b01298d7", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4d80b8090c30980c03ff4bb6f47a7560ffaa68a4/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d80b8090c30980c03ff4bb6f47a7560ffaa68a4/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=4d80b8090c30980c03ff4bb6f47a7560ffaa68a4", "patch": "@@ -30,8 +30,13 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         // `U` and equate it with `u32`. This means that we don't need a separate\n         // projection cache in the solver.\n         if self.term_is_fully_unconstrained(goal) {\n-            let candidates = self.assemble_and_evaluate_candidates(goal);\n-            self.merge_candidates(candidates)\n+            match goal.predicate.projection_ty.kind(self.tcx()) {\n+                ty::AliasKind::Projection => {\n+                    let candidates = self.assemble_and_evaluate_candidates(goal);\n+                    self.merge_candidates(candidates)\n+                }\n+                ty::AliasKind::Opaque => self.normalize_opaque_type(goal),\n+            }\n         } else {\n             self.set_normalizes_to_hack_goal(goal);\n             self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)"}, {"sha": "62d2aad5277f6ba75d057303841efb34561fc2ad", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4d80b8090c30980c03ff4bb6f47a7560ffaa68a4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d80b8090c30980c03ff4bb6f47a7560ffaa68a4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=4d80b8090c30980c03ff4bb6f47a7560ffaa68a4", "patch": "@@ -834,8 +834,10 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n                 | ty::PredicateKind::Subtype(..)\n                 // FIXME(generic_const_exprs): you can absolutely add this as a where clauses\n                 | ty::PredicateKind::ConstEvaluatable(..)\n-                | ty::PredicateKind::Coerce(..)\n-                | ty::PredicateKind::TypeWellFormedFromEnv(..) => {}\n+                | ty::PredicateKind::Coerce(..) => {}\n+                ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n+                    bug!(\"predicate should only exist in the environment: {bound_predicate:?}\")\n+                }\n                 ty::PredicateKind::Ambiguous => return false,\n             };\n         }"}, {"sha": "e447ab94f6408def5d4ea261a26c29d33513f0d4", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4d80b8090c30980c03ff4bb6f47a7560ffaa68a4/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d80b8090c30980c03ff4bb6f47a7560ffaa68a4/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=4d80b8090c30980c03ff4bb6f47a7560ffaa68a4", "patch": "@@ -679,7 +679,7 @@ impl<'tcx> LowerInto<'tcx, Option<chalk_ir::QuantifiedWhereClause<RustInterner<'\n             | ty::PredicateKind::ConstEquate(..)\n             | ty::PredicateKind::Ambiguous\n             | ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n-                bug!(\"unexpected predicate {}\", &self)\n+                bug!(\"unexpected predicate {self}\")\n             }\n         };\n         value.map(|value| chalk_ir::Binders::new(binders, value))"}]}