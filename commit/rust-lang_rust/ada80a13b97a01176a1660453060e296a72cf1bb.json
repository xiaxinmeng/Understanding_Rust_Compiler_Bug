{"sha": "ada80a13b97a01176a1660453060e296a72cf1bb", "node_id": "C_kwDOAAsO6NoAKGFkYTgwYTEzYjk3YTAxMTc2YTE2NjA0NTMwNjBlMjk2YTcyY2YxYmI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-27T22:02:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-27T22:02:14Z"}, "message": "Auto merge of #99725 - lcnr:dedup-region_bound_pairs, r=compiler-errors\n\nuse `FxIndexSet` for `region_bound_pairs`\n\nshould help with #99217 and might generally be a perf improvement.\n\nr? types", "tree": {"sha": "ebc2c1ec769748be6dd4ab627979abc6b9468d82", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ebc2c1ec769748be6dd4ab627979abc6b9468d82"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ada80a13b97a01176a1660453060e296a72cf1bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ada80a13b97a01176a1660453060e296a72cf1bb", "html_url": "https://github.com/rust-lang/rust/commit/ada80a13b97a01176a1660453060e296a72cf1bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ada80a13b97a01176a1660453060e296a72cf1bb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2643b16468fda787470340890212591d8bc832b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/2643b16468fda787470340890212591d8bc832b7", "html_url": "https://github.com/rust-lang/rust/commit/2643b16468fda787470340890212591d8bc832b7"}, {"sha": "2e796acf33ba247acfb9327a398e15c1ea8710e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e796acf33ba247acfb9327a398e15c1ea8710e8", "html_url": "https://github.com/rust-lang/rust/commit/2e796acf33ba247acfb9327a398e15c1ea8710e8"}], "stats": {"total": 72, "additions": 37, "deletions": 35}, "files": [{"sha": "167960918308cd365c50894a3db07acc040415e4", "filename": "compiler/rustc_borrowck/src/type_check/constraint_conversion.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ada80a13b97a01176a1660453060e296a72cf1bb/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ada80a13b97a01176a1660453060e296a72cf1bb/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs?ref=ada80a13b97a01176a1660453060e296a72cf1bb", "patch": "@@ -22,6 +22,16 @@ pub(crate) struct ConstraintConversion<'a, 'tcx> {\n     infcx: &'a InferCtxt<'a, 'tcx>,\n     tcx: TyCtxt<'tcx>,\n     universal_regions: &'a UniversalRegions<'tcx>,\n+    /// Each RBP `GK: 'a` is assumed to be true. These encode\n+    /// relationships like `T: 'a` that are added via implicit bounds\n+    /// or the `param_env`.\n+    ///\n+    /// Each region here is guaranteed to be a key in the `indices`\n+    /// map. We use the \"original\" regions (i.e., the keys from the\n+    /// map, and not the values) because the code in\n+    /// `process_registered_region_obligations` has some special-cased\n+    /// logic expecting to see (e.g.) `ReStatic`, and if we supplied\n+    /// our special inference variable there, we would mess that up.\n     region_bound_pairs: &'a RegionBoundPairs<'tcx>,\n     implicit_region_bound: ty::Region<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,"}, {"sha": "cc0318ede54a0e98858df911cd48a6134d811656", "filename": "compiler/rustc_borrowck/src/type_check/free_region_relations.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ada80a13b97a01176a1660453060e296a72cf1bb/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ada80a13b97a01176a1660453060e296a72cf1bb/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs?ref=ada80a13b97a01176a1660453060e296a72cf1bb", "patch": "@@ -2,6 +2,7 @@ use rustc_data_structures::frozen::Frozen;\n use rustc_data_structures::transitive_relation::TransitiveRelation;\n use rustc_infer::infer::canonical::QueryRegionConstraints;\n use rustc_infer::infer::outlives;\n+use rustc_infer::infer::outlives::env::RegionBoundPairs;\n use rustc_infer::infer::region_constraints::GenericKind;\n use rustc_infer::infer::InferCtxt;\n use rustc_middle::mir::ConstraintCategory;\n@@ -34,18 +35,6 @@ pub(crate) struct UniversalRegionRelations<'tcx> {\n     inverse_outlives: TransitiveRelation<RegionVid>,\n }\n \n-/// Each RBP `('a, GK)` indicates that `GK: 'a` can be assumed to\n-/// be true. These encode relationships like `T: 'a` that are\n-/// added via implicit bounds.\n-///\n-/// Each region here is guaranteed to be a key in the `indices`\n-/// map. We use the \"original\" regions (i.e., the keys from the\n-/// map, and not the values) because the code in\n-/// `process_registered_region_obligations` has some special-cased\n-/// logic expecting to see (e.g.) `ReStatic`, and if we supplied\n-/// our special inference variable there, we would mess that up.\n-type RegionBoundPairs<'tcx> = Vec<(ty::Region<'tcx>, GenericKind<'tcx>)>;\n-\n /// As part of computing the free region relations, we also have to\n /// normalize the input-output types, which we then need later. So we\n /// return those. This vector consists of first the input types and\n@@ -71,7 +60,7 @@ pub(crate) fn create<'tcx>(\n         implicit_region_bound,\n         constraints,\n         universal_regions: universal_regions.clone(),\n-        region_bound_pairs: Vec::new(),\n+        region_bound_pairs: Default::default(),\n         relations: UniversalRegionRelations {\n             universal_regions: universal_regions.clone(),\n             outlives: Default::default(),\n@@ -371,11 +360,13 @@ impl<'tcx> UniversalRegionRelationsBuilder<'_, 'tcx> {\n                 }\n \n                 OutlivesBound::RegionSubParam(r_a, param_b) => {\n-                    self.region_bound_pairs.push((r_a, GenericKind::Param(param_b)));\n+                    self.region_bound_pairs\n+                        .insert(ty::OutlivesPredicate(GenericKind::Param(param_b), r_a));\n                 }\n \n                 OutlivesBound::RegionSubProjection(r_a, projection_b) => {\n-                    self.region_bound_pairs.push((r_a, GenericKind::Projection(projection_b)));\n+                    self.region_bound_pairs\n+                        .insert(ty::OutlivesPredicate(GenericKind::Projection(projection_b), r_a));\n                 }\n             }\n         }"}, {"sha": "b2decd64f0fd9690d1bab2db52559ccb48f05d89", "filename": "compiler/rustc_infer/src/infer/outlives/env.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ada80a13b97a01176a1660453060e296a72cf1bb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ada80a13b97a01176a1660453060e296a72cf1bb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs?ref=ada80a13b97a01176a1660453060e296a72cf1bb", "patch": "@@ -1,6 +1,7 @@\n use crate::infer::free_regions::FreeRegionMap;\n use crate::infer::{GenericKind, InferCtxt};\n use crate::traits::query::OutlivesBound;\n+use rustc_data_structures::fx::FxIndexSet;\n use rustc_middle::ty::{self, ReEarlyBound, ReFree, ReVar, Region};\n \n use super::explicit_outlives_bounds;\n@@ -53,7 +54,8 @@ pub struct OutlivesEnvironment<'tcx> {\n /// \"Region-bound pairs\" tracks outlives relations that are known to\n /// be true, either because of explicit where-clauses like `T: 'a` or\n /// because of implied bounds.\n-pub type RegionBoundPairs<'tcx> = Vec<(Region<'tcx>, GenericKind<'tcx>)>;\n+pub type RegionBoundPairs<'tcx> =\n+    FxIndexSet<ty::OutlivesPredicate<GenericKind<'tcx>, Region<'tcx>>>;\n \n impl<'a, 'tcx> OutlivesEnvironment<'tcx> {\n     pub fn new(param_env: ty::ParamEnv<'tcx>) -> Self {\n@@ -97,10 +99,12 @@ impl<'a, 'tcx> OutlivesEnvironment<'tcx> {\n             debug!(\"add_outlives_bounds: outlives_bound={:?}\", outlives_bound);\n             match outlives_bound {\n                 OutlivesBound::RegionSubParam(r_a, param_b) => {\n-                    self.region_bound_pairs.push((r_a, GenericKind::Param(param_b)));\n+                    self.region_bound_pairs\n+                        .insert(ty::OutlivesPredicate(GenericKind::Param(param_b), r_a));\n                 }\n                 OutlivesBound::RegionSubProjection(r_a, projection_b) => {\n-                    self.region_bound_pairs.push((r_a, GenericKind::Projection(projection_b)));\n+                    self.region_bound_pairs\n+                        .insert(ty::OutlivesPredicate(GenericKind::Projection(projection_b), r_a));\n                 }\n                 OutlivesBound::RegionSubRegion(r_a, r_b) => {\n                     if let (ReEarlyBound(_) | ReFree(_), ReVar(vid_b)) = (r_a.kind(), r_b.kind()) {"}, {"sha": "c7d7ef40d9d413ae64a541371e73a6f3154ca9de", "filename": "compiler/rustc_infer/src/infer/outlives/verify.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ada80a13b97a01176a1660453060e296a72cf1bb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ada80a13b97a01176a1660453060e296a72cf1bb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs?ref=ada80a13b97a01176a1660453060e296a72cf1bb", "patch": "@@ -6,7 +6,7 @@ use rustc_data_structures::captures::Captures;\n use rustc_data_structures::sso::SsoHashSet;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::subst::{GenericArg, Subst};\n-use rustc_middle::ty::{self, EarlyBinder, Ty, TyCtxt};\n+use rustc_middle::ty::{self, EarlyBinder, OutlivesPredicate, Ty, TyCtxt};\n \n use smallvec::smallvec;\n \n@@ -259,16 +259,17 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n         // The problem is that the type of `x` is `&'a A`. To be\n         // well-formed, then, A must outlive `'a`, but we don't know that\n         // this holds from first principles.\n-        let from_region_bound_pairs = self.region_bound_pairs.iter().filter_map(|&(r, p)| {\n-            debug!(\n-                \"declared_generic_bounds_from_env_for_erased_ty: region_bound_pair = {:?}\",\n-                (r, p)\n-            );\n-            let p_ty = p.to_ty(tcx);\n-            let erased_p_ty = self.tcx.erase_regions(p_ty);\n-            (erased_p_ty == erased_ty)\n-                .then_some(ty::Binder::dummy(ty::OutlivesPredicate(p.to_ty(tcx), r)))\n-        });\n+        let from_region_bound_pairs =\n+            self.region_bound_pairs.iter().filter_map(|&OutlivesPredicate(p, r)| {\n+                debug!(\n+                    \"declared_generic_bounds_from_env_for_erased_ty: region_bound_pair = {:?}\",\n+                    (r, p)\n+                );\n+                let p_ty = p.to_ty(tcx);\n+                let erased_p_ty = self.tcx.erase_regions(p_ty);\n+                (erased_p_ty == erased_ty)\n+                    .then_some(ty::Binder::dummy(ty::OutlivesPredicate(p.to_ty(tcx), r)))\n+            });\n \n         param_bounds\n             .chain(from_region_bound_pairs)"}, {"sha": "faab862cc3c3c2d6cc255342523795081389c297", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ada80a13b97a01176a1660453060e296a72cf1bb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ada80a13b97a01176a1660453060e296a72cf1bb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=ada80a13b97a01176a1660453060e296a72cf1bb", "patch": "@@ -7,9 +7,8 @@ use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::ItemKind;\n-use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n+use rustc_infer::infer::outlives::env::{OutlivesEnvironment, RegionBoundPairs};\n use rustc_infer::infer::outlives::obligations::TypeOutlives;\n-use rustc_infer::infer::region_constraints::GenericKind;\n use rustc_infer::infer::{self, InferCtxt, TyCtxtInferExt};\n use rustc_infer::traits::Normalized;\n use rustc_middle::ty::query::Providers;\n@@ -689,10 +688,7 @@ fn resolve_regions_with_wf_tys<'tcx>(\n     id: hir::HirId,\n     param_env: ty::ParamEnv<'tcx>,\n     wf_tys: &FxHashSet<Ty<'tcx>>,\n-    add_constraints: impl for<'a> FnOnce(\n-        &'a InferCtxt<'a, 'tcx>,\n-        &'a Vec<(ty::Region<'tcx>, GenericKind<'tcx>)>,\n-    ),\n+    add_constraints: impl for<'a> FnOnce(&'a InferCtxt<'a, 'tcx>, &'a RegionBoundPairs<'tcx>),\n ) -> bool {\n     // Unfortunately, we have to use a new `InferCtxt` each call, because\n     // region constraints get added and solved there and we need to test each"}]}