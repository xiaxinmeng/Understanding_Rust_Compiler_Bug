{"sha": "945d4cf69f7a2a63f17e82c5927bad75922a6005", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0NWQ0Y2Y2OWY3YTJhNjNmMTdlODJjNTkyN2JhZDc1OTIyYTYwMDU=", "commit": {"author": {"name": "BO41", "email": "botbob@disroot.org", "date": "2019-08-26T10:50:15Z"}, "committer": {"name": "flip1995", "email": "hello@philkrones.com", "date": "2019-08-29T15:34:02Z"}, "message": "Dereference one less on search_is_some and make it auto-fixable", "tree": {"sha": "122ae18cecee89a468e85eb2cff11c5bce84858f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/122ae18cecee89a468e85eb2cff11c5bce84858f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/945d4cf69f7a2a63f17e82c5927bad75922a6005", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEZxoS6lESXlRGMHWcaTCGhp1QZjcFAl1n8GoACgkQaTCGhp1Q\nZjcWbw/+OAtDxx0aF5JXpq/A8dxQWO+LeyWCgD33Pgh0aUhfX5htKk/tHQuqwkqI\nmWGiEcQm3/tPR01zTHBBIsprCk/n9soOdiYIKuXrvyewLH2RR0E74kbPEvD3tjeP\nuJbStAytKSnN1ZRVMbezKYQxE1vON7+kiHv8o1pvGrr3oblh0g/3lQ1fKzek4DoE\nS1ump6oAw3Jr/ZaVwjqJCTdp2uyvYaQMG+xxIRJd24zVpVtU60ao5RAvgwbRUIkF\nqZm7cpz+V2cBn6gm38QeO/PWA3djebFOapiLTqh0NYxxDSSpxcczVGlzz8urRIW5\n0GBHpw4adzVxfv7Cvn8e4ziddmtJDXXX7Fztvcj8lNy/oG33pW7DI+Z/VrCUY8wu\nJNFdtThIzagXjwh6vC5M/gfXTMpS4lxc9Klby1buCF4GwJi/+8GUV1ZaQUALoob0\n86SEp90ZEMPSwqUAW8FdAO1T/QqMidjKv9eLpKUPRLLmnnTa2O4h37Kl8XQ7POoY\nTNR2E7hY3WPW8U4Wr6179YtvTolVeYM9/N18kME5NnElYrqkiMuH+5wbpvKtK/LT\nQ17wnSrw77HjccA7YjzN0wDb+77RdTFadU+9dFLFdxmvSupfnEG/HC4iDrbxENYU\nzGg5QMSp8FwjbF0JSWlCtIq7m3Y9ifprQLdxKZ1ezatJcgg7QbQ=\n=fYqi\n-----END PGP SIGNATURE-----", "payload": "tree 122ae18cecee89a468e85eb2cff11c5bce84858f\nparent 888b736560755254e33593033c3d1248c8e56085\nauthor BO41 <botbob@disroot.org> 1566816615 +0200\ncommitter flip1995 <hello@philkrones.com> 1567092842 +0200\n\nDereference one less on search_is_some and make it auto-fixable\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/945d4cf69f7a2a63f17e82c5927bad75922a6005", "html_url": "https://github.com/rust-lang/rust/commit/945d4cf69f7a2a63f17e82c5927bad75922a6005", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/945d4cf69f7a2a63f17e82c5927bad75922a6005/comments", "author": null, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "888b736560755254e33593033c3d1248c8e56085", "url": "https://api.github.com/repos/rust-lang/rust/commits/888b736560755254e33593033c3d1248c8e56085", "html_url": "https://github.com/rust-lang/rust/commit/888b736560755254e33593033c3d1248c8e56085"}], "stats": {"total": 400, "additions": 363, "deletions": 37}, "files": [{"sha": "06126e02ed330c745ea9a2985085e2fb42987e71", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/945d4cf69f7a2a63f17e82c5927bad75922a6005/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/945d4cf69f7a2a63f17e82c5927bad75922a6005/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=945d4cf69f7a2a63f17e82c5927bad75922a6005", "patch": "@@ -2386,31 +2386,40 @@ fn lint_search_is_some<'a, 'tcx>(\n         let search_snippet = snippet(cx, search_args[1].span, \"..\");\n         if search_snippet.lines().count() <= 1 {\n             // suggest `any(|x| ..)` instead of `any(|&x| ..)` for `find(|&x| ..).is_some()`\n+            // suggest `any(|..| *..)` instead of `any(|..| **..)` for `find(|..| **..).is_some()`\n             let any_search_snippet = if_chain! {\n                 if search_method == \"find\";\n                 if let hir::ExprKind::Closure(_, _, body_id, ..) = search_args[1].node;\n                 let closure_body = cx.tcx.hir().body(body_id);\n                 if let Some(closure_arg) = closure_body.params.get(0);\n                 if let hir::PatKind::Ref(..) = closure_arg.pat.node;\n                 then {\n-                    Some(search_snippet.replacen('&', \"\", 1))\n+                    match &closure_arg.pat.node {\n+                        hir::PatKind::Ref(..) => Some(search_snippet.replacen('&', \"\", 1)),\n+                        hir::PatKind::Binding(_, _, expr, _) => {\n+                            let closure_arg_snip = snippet(cx, expr.span, \"..\");\n+                            Some(search_snippet.replace(&format!(\"*{}\", closure_arg_snip), &closure_arg_snip))\n+                        }\n+                        _ => None,\n+                    }\n                 } else {\n                     None\n                 }\n             };\n             // add note if not multi-line\n-            span_note_and_lint(\n+            span_lint_and_sugg(\n                 cx,\n                 SEARCH_IS_SOME,\n                 expr.span,\n                 &msg,\n-                expr.span,\n-                &format!(\n-                    \"replace `{0}({1}).is_some()` with `any({2})`\",\n-                    search_method,\n-                    search_snippet,\n-                    any_search_snippet.as_ref().map_or(&*search_snippet, String::as_str)\n+                \"try this\",\n+                format!(\n+                    \"any({})\",\n+                    any_search_snippet\n+                        .as_ref()\n+                        .map_or(&*search_snippet, String::as_str)\n                 ),\n+                Applicability::MachineApplicable,\n             );\n         } else {\n             span_lint(cx, SEARCH_IS_SOME, expr.span, &msg);"}, {"sha": "f86da92bae32003f0162799da3233803af053b37", "filename": "tests/ui/methods.fixed", "status": "added", "additions": 306, "deletions": 0, "changes": 306, "blob_url": "https://github.com/rust-lang/rust/blob/945d4cf69f7a2a63f17e82c5927bad75922a6005/tests%2Fui%2Fmethods.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/945d4cf69f7a2a63f17e82c5927bad75922a6005/tests%2Fui%2Fmethods.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods.fixed?ref=945d4cf69f7a2a63f17e82c5927bad75922a6005", "patch": "@@ -0,0 +1,306 @@\n+// aux-build:option_helpers.rs\n+// compile-flags: --edition 2018\n+// run-rustfix\n+\n+#![warn(clippy::all, clippy::pedantic, clippy::option_unwrap_used)]\n+#![allow(\n+    clippy::blacklisted_name,\n+    unused,\n+    clippy::print_stdout,\n+    clippy::non_ascii_literal,\n+    clippy::new_without_default,\n+    clippy::missing_docs_in_private_items,\n+    clippy::needless_pass_by_value,\n+    clippy::default_trait_access,\n+    clippy::use_self,\n+    clippy::useless_format,\n+    clippy::wrong_self_convention\n+)]\n+\n+#[macro_use]\n+extern crate option_helpers;\n+\n+use std::collections::BTreeMap;\n+use std::collections::HashMap;\n+use std::collections::HashSet;\n+use std::collections::VecDeque;\n+use std::iter::FromIterator;\n+use std::ops::Mul;\n+use std::rc::{self, Rc};\n+use std::sync::{self, Arc};\n+\n+use option_helpers::IteratorFalsePositives;\n+\n+pub struct T;\n+\n+impl T {\n+    pub fn add(self, other: T) -> T {\n+        self\n+    }\n+\n+    // no error, not public interface\n+    pub(crate) fn drop(&mut self) {}\n+\n+    // no error, private function\n+    fn neg(self) -> Self {\n+        self\n+    }\n+\n+    // no error, private function\n+    fn eq(&self, other: T) -> bool {\n+        true\n+    }\n+\n+    // No error; self is a ref.\n+    fn sub(&self, other: T) -> &T {\n+        self\n+    }\n+\n+    // No error; different number of arguments.\n+    fn div(self) -> T {\n+        self\n+    }\n+\n+    // No error; wrong return type.\n+    fn rem(self, other: T) {}\n+\n+    // Fine\n+    fn into_u32(self) -> u32 {\n+        0\n+    }\n+\n+    fn into_u16(&self) -> u16 {\n+        0\n+    }\n+\n+    fn to_something(self) -> u32 {\n+        0\n+    }\n+\n+    fn new(self) -> Self {\n+        unimplemented!();\n+    }\n+}\n+\n+struct Lt<'a> {\n+    foo: &'a u32,\n+}\n+\n+impl<'a> Lt<'a> {\n+    // The lifetime is different, but that\u2019s irrelevant; see issue #734.\n+    #[allow(clippy::needless_lifetimes)]\n+    pub fn new<'b>(s: &'b str) -> Lt<'b> {\n+        unimplemented!()\n+    }\n+}\n+\n+struct Lt2<'a> {\n+    foo: &'a u32,\n+}\n+\n+impl<'a> Lt2<'a> {\n+    // The lifetime is different, but that\u2019s irrelevant; see issue #734.\n+    pub fn new(s: &str) -> Lt2 {\n+        unimplemented!()\n+    }\n+}\n+\n+struct Lt3<'a> {\n+    foo: &'a u32,\n+}\n+\n+impl<'a> Lt3<'a> {\n+    // The lifetime is different, but that\u2019s irrelevant; see issue #734.\n+    pub fn new() -> Lt3<'static> {\n+        unimplemented!()\n+    }\n+}\n+\n+#[derive(Clone, Copy)]\n+struct U;\n+\n+impl U {\n+    fn new() -> Self {\n+        U\n+    }\n+    // Ok because `U` is `Copy`.\n+    fn to_something(self) -> u32 {\n+        0\n+    }\n+}\n+\n+struct V<T> {\n+    _dummy: T,\n+}\n+\n+impl<T> V<T> {\n+    fn new() -> Option<V<T>> {\n+        None\n+    }\n+}\n+\n+struct AsyncNew;\n+\n+impl AsyncNew {\n+    async fn new() -> Option<Self> {\n+        None\n+    }\n+}\n+\n+struct BadNew;\n+\n+impl BadNew {\n+    fn new() -> i32 {\n+        0\n+    }\n+}\n+\n+impl Mul<T> for T {\n+    type Output = T;\n+    // No error, obviously.\n+    fn mul(self, other: T) -> T {\n+        self\n+    }\n+}\n+\n+/// Checks implementation of the following lints:\n+/// * `OPTION_MAP_UNWRAP_OR`\n+/// * `OPTION_MAP_UNWRAP_OR_ELSE`\n+#[rustfmt::skip]\n+fn option_methods() {\n+    let opt = Some(1);\n+\n+    // Check `OPTION_MAP_UNWRAP_OR`.\n+    // Single line case.\n+    let _ = opt.map(|x| x + 1)\n+                // Should lint even though this call is on a separate line.\n+               .unwrap_or(0);\n+    // Multi-line cases.\n+    let _ = opt.map(|x| {\n+                        x + 1\n+                    }\n+              ).unwrap_or(0);\n+    let _ = opt.map(|x| x + 1)\n+               .unwrap_or({\n+                    0\n+                });\n+    // Single line `map(f).unwrap_or(None)` case.\n+    let _ = opt.map(|x| Some(x + 1)).unwrap_or(None);\n+    // Multi-line `map(f).unwrap_or(None)` cases.\n+    let _ = opt.map(|x| {\n+        Some(x + 1)\n+    }\n+    ).unwrap_or(None);\n+    let _ = opt\n+        .map(|x| Some(x + 1))\n+        .unwrap_or(None);\n+    // macro case\n+    let _ = opt_map!(opt, |x| x + 1).unwrap_or(0); // should not lint\n+\n+    // Should not lint if not copyable\n+    let id: String = \"identifier\".to_string();\n+    let _ = Some(\"prefix\").map(|p| format!(\"{}.{}\", p, id)).unwrap_or(id);\n+    // ...but DO lint if the `unwrap_or` argument is not used in the `map`\n+    let id: String = \"identifier\".to_string();\n+    let _ = Some(\"prefix\").map(|p| format!(\"{}.\", p)).unwrap_or(id);\n+\n+    // Check OPTION_MAP_UNWRAP_OR_ELSE\n+    // single line case\n+    let _ = opt.map(|x| x + 1)\n+                // Should lint even though this call is on a separate line.\n+               .unwrap_or_else(|| 0);\n+    // Multi-line cases.\n+    let _ = opt.map(|x| {\n+                        x + 1\n+                    }\n+              ).unwrap_or_else(|| 0);\n+    let _ = opt.map(|x| x + 1)\n+               .unwrap_or_else(||\n+                    0\n+                );\n+    // Macro case.\n+    // Should not lint.\n+    let _ = opt_map!(opt, |x| x + 1).unwrap_or_else(|| 0);\n+\n+    // Issue #4144\n+    {\n+        let mut frequencies = HashMap::new();\n+        let word = \"foo\";\n+\n+        frequencies\n+            .get_mut(word)\n+            .map(|count| {\n+                *count += 1;\n+            })\n+            .unwrap_or_else(|| {\n+                frequencies.insert(word.to_owned(), 1);\n+            });\n+    }\n+}\n+\n+/// Checks implementation of `FILTER_NEXT` lint.\n+#[rustfmt::skip]\n+fn filter_next() {\n+    let v = vec![3, 2, 1, 0, -1, -2, -3];\n+\n+    // Single-line case.\n+    let _ = v.iter().filter(|&x| *x < 0).next();\n+\n+    // Multi-line case.\n+    let _ = v.iter().filter(|&x| {\n+                                *x < 0\n+                            }\n+                   ).next();\n+\n+    // Check that hat we don't lint if the caller is not an `Iterator`.\n+    let foo = IteratorFalsePositives { foo: 0 };\n+    let _ = foo.filter().next();\n+}\n+\n+/// Checks implementation of `SEARCH_IS_SOME` lint.\n+#[rustfmt::skip]\n+fn search_is_some() {\n+    let v = vec![3, 2, 1, 0, -1, -2, -3];\n+    let y = &&42;\n+\n+    // Check `find().is_some()`, single-line case.\n+    let _ = any(|x| *x < 0);\n+    let _ = any(|x| **y == x); // one dereference less\n+    let _ = any(|x| x == 0);\n+\n+    // Check `find().is_some()`, multi-line case.\n+    let _ = v.iter().find(|&x| {\n+                              *x < 0\n+                          }\n+                   ).is_some();\n+\n+    // Check `position().is_some()`, single-line case.\n+    let _ = any(|&x| x < 0);\n+\n+    // Check `position().is_some()`, multi-line case.\n+    let _ = v.iter().position(|&x| {\n+                                  x < 0\n+                              }\n+                   ).is_some();\n+\n+    // Check `rposition().is_some()`, single-line case.\n+    let _ = any(|&x| x < 0);\n+\n+    // Check `rposition().is_some()`, multi-line case.\n+    let _ = v.iter().rposition(|&x| {\n+                                   x < 0\n+                               }\n+                   ).is_some();\n+\n+    // Check that we don't lint if the caller is not an `Iterator`.\n+    let foo = IteratorFalsePositives { foo: 0 };\n+    let _ = foo.find().is_some();\n+    let _ = foo.position().is_some();\n+    let _ = foo.rposition().is_some();\n+}\n+\n+#[allow(clippy::similar_names)]\n+fn main() {\n+    let opt = Some(0);\n+    let _ = opt.unwrap();\n+}"}, {"sha": "930b76a686773c46a17c0c5a9ff0354a449eb803", "filename": "tests/ui/methods.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/945d4cf69f7a2a63f17e82c5927bad75922a6005/tests%2Fui%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/945d4cf69f7a2a63f17e82c5927bad75922a6005/tests%2Fui%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods.rs?ref=945d4cf69f7a2a63f17e82c5927bad75922a6005", "patch": "@@ -1,5 +1,6 @@\n // aux-build:option_helpers.rs\n // compile-flags: --edition 2018\n+// run-rustfix\n \n #![warn(clippy::all, clippy::pedantic, clippy::option_unwrap_used)]\n #![allow(\n@@ -260,9 +261,12 @@ fn filter_next() {\n #[rustfmt::skip]\n fn search_is_some() {\n     let v = vec![3, 2, 1, 0, -1, -2, -3];\n+    let y = &&42;\n \n     // Check `find().is_some()`, single-line case.\n     let _ = v.iter().find(|&x| *x < 0).is_some();\n+    let _ = (0..1).find(|x| **y == *x).is_some(); // one dereference less\n+    let _ = (0..1).find(|x| *x == 0).is_some();\n \n     // Check `find().is_some()`, multi-line case.\n     let _ = v.iter().find(|&x| {"}, {"sha": "c35a74463ec88bf62718815acdea4469d63f5b2d", "filename": "tests/ui/methods.stderr", "status": "modified", "additions": 36, "deletions": 29, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/945d4cf69f7a2a63f17e82c5927bad75922a6005/tests%2Fui%2Fmethods.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/945d4cf69f7a2a63f17e82c5927bad75922a6005/tests%2Fui%2Fmethods.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods.stderr?ref=945d4cf69f7a2a63f17e82c5927bad75922a6005", "patch": "@@ -1,5 +1,5 @@\n error: defining a method called `add` on this type; consider implementing the `std::ops::Add` trait or choosing a less ambiguous name\n-  --> $DIR/methods.rs:36:5\n+  --> $DIR/methods.rs:37:5\n    |\n LL | /     pub fn add(self, other: T) -> T {\n LL | |         self\n@@ -9,7 +9,7 @@ LL | |     }\n    = note: `-D clippy::should-implement-trait` implied by `-D warnings`\n \n error: methods called `new` usually return `Self`\n-  --> $DIR/methods.rs:152:5\n+  --> $DIR/methods.rs:153:5\n    |\n LL | /     fn new() -> i32 {\n LL | |         0\n@@ -19,7 +19,7 @@ LL | |     }\n    = note: `-D clippy::new-ret-no-self` implied by `-D warnings`\n \n error: called `map(f).unwrap_or(a)` on an Option value. This can be done more directly by calling `map_or(a, f)` instead\n-  --> $DIR/methods.rs:174:13\n+  --> $DIR/methods.rs:175:13\n    |\n LL |       let _ = opt.map(|x| x + 1)\n    |  _____________^\n@@ -31,7 +31,7 @@ LL | |                .unwrap_or(0);\n    = note: replace `map(|x| x + 1).unwrap_or(0)` with `map_or(0, |x| x + 1)`\n \n error: called `map(f).unwrap_or(a)` on an Option value. This can be done more directly by calling `map_or(a, f)` instead\n-  --> $DIR/methods.rs:178:13\n+  --> $DIR/methods.rs:179:13\n    |\n LL |       let _ = opt.map(|x| {\n    |  _____________^\n@@ -41,7 +41,7 @@ LL | |               ).unwrap_or(0);\n    | |____________________________^\n \n error: called `map(f).unwrap_or(a)` on an Option value. This can be done more directly by calling `map_or(a, f)` instead\n-  --> $DIR/methods.rs:182:13\n+  --> $DIR/methods.rs:183:13\n    |\n LL |       let _ = opt.map(|x| x + 1)\n    |  _____________^\n@@ -51,15 +51,15 @@ LL | |                 });\n    | |__________________^\n \n error: called `map(f).unwrap_or(None)` on an Option value. This can be done more directly by calling `and_then(f)` instead\n-  --> $DIR/methods.rs:187:13\n+  --> $DIR/methods.rs:188:13\n    |\n LL |     let _ = opt.map(|x| Some(x + 1)).unwrap_or(None);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: replace `map(|x| Some(x + 1)).unwrap_or(None)` with `and_then(|x| Some(x + 1))`\n \n error: called `map(f).unwrap_or(None)` on an Option value. This can be done more directly by calling `and_then(f)` instead\n-  --> $DIR/methods.rs:189:13\n+  --> $DIR/methods.rs:190:13\n    |\n LL |       let _ = opt.map(|x| {\n    |  _____________^\n@@ -69,7 +69,7 @@ LL | |     ).unwrap_or(None);\n    | |_____________________^\n \n error: called `map(f).unwrap_or(None)` on an Option value. This can be done more directly by calling `and_then(f)` instead\n-  --> $DIR/methods.rs:193:13\n+  --> $DIR/methods.rs:194:13\n    |\n LL |       let _ = opt\n    |  _____________^\n@@ -80,15 +80,15 @@ LL | |         .unwrap_or(None);\n    = note: replace `map(|x| Some(x + 1)).unwrap_or(None)` with `and_then(|x| Some(x + 1))`\n \n error: called `map(f).unwrap_or(a)` on an Option value. This can be done more directly by calling `map_or(a, f)` instead\n-  --> $DIR/methods.rs:204:13\n+  --> $DIR/methods.rs:205:13\n    |\n LL |     let _ = Some(\"prefix\").map(|p| format!(\"{}.\", p)).unwrap_or(id);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: replace `map(|p| format!(\"{}.\", p)).unwrap_or(id)` with `map_or(id, |p| format!(\"{}.\", p))`\n \n error: called `map(f).unwrap_or_else(g)` on an Option value. This can be done more directly by calling `map_or_else(g, f)` instead\n-  --> $DIR/methods.rs:208:13\n+  --> $DIR/methods.rs:209:13\n    |\n LL |       let _ = opt.map(|x| x + 1)\n    |  _____________^\n@@ -100,7 +100,7 @@ LL | |                .unwrap_or_else(|| 0);\n    = note: replace `map(|x| x + 1).unwrap_or_else(|| 0)` with `map_or_else(|| 0, |x| x + 1)`\n \n error: called `map(f).unwrap_or_else(g)` on an Option value. This can be done more directly by calling `map_or_else(g, f)` instead\n-  --> $DIR/methods.rs:212:13\n+  --> $DIR/methods.rs:213:13\n    |\n LL |       let _ = opt.map(|x| {\n    |  _____________^\n@@ -110,7 +110,7 @@ LL | |               ).unwrap_or_else(|| 0);\n    | |____________________________________^\n \n error: called `map(f).unwrap_or_else(g)` on an Option value. This can be done more directly by calling `map_or_else(g, f)` instead\n-  --> $DIR/methods.rs:216:13\n+  --> $DIR/methods.rs:217:13\n    |\n LL |       let _ = opt.map(|x| x + 1)\n    |  _____________^\n@@ -120,7 +120,7 @@ LL | |                 );\n    | |_________________^\n \n error: called `filter(p).next()` on an `Iterator`. This is more succinctly expressed by calling `.find(p)` instead.\n-  --> $DIR/methods.rs:246:13\n+  --> $DIR/methods.rs:247:13\n    |\n LL |     let _ = v.iter().filter(|&x| *x < 0).next();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -129,7 +129,7 @@ LL |     let _ = v.iter().filter(|&x| *x < 0).next();\n    = note: replace `filter(|&x| *x < 0).next()` with `find(|&x| *x < 0)`\n \n error: called `filter(p).next()` on an `Iterator`. This is more succinctly expressed by calling `.find(p)` instead.\n-  --> $DIR/methods.rs:249:13\n+  --> $DIR/methods.rs:250:13\n    |\n LL |       let _ = v.iter().filter(|&x| {\n    |  _____________^\n@@ -139,17 +139,28 @@ LL | |                    ).next();\n    | |___________________________^\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:265:13\n+  --> $DIR/methods.rs:267:13\n    |\n LL |     let _ = v.iter().find(|&x| *x < 0).is_some();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|x| *x < 0)`\n    |\n    = note: `-D clippy::search-is-some` implied by `-D warnings`\n-   = note: replace `find(|&x| *x < 0).is_some()` with `any(|x| *x < 0)`\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n   --> $DIR/methods.rs:268:13\n    |\n+LL |     let _ = (0..1).find(|x| **y == *x).is_some(); // one dereference less\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|x| **y == x)`\n+\n+error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n+  --> $DIR/methods.rs:269:13\n+   |\n+LL |     let _ = (0..1).find(|x| *x == 0).is_some();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|x| x == 0)`\n+\n+error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n+  --> $DIR/methods.rs:272:13\n+   |\n LL |       let _ = v.iter().find(|&x| {\n    |  _____________^\n LL | |                               *x < 0\n@@ -158,15 +169,13 @@ LL | |                    ).is_some();\n    | |______________________________^\n \n error: called `is_some()` after searching an `Iterator` with position. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:274:13\n+  --> $DIR/methods.rs:278:13\n    |\n LL |     let _ = v.iter().position(|&x| x < 0).is_some();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: replace `position(|&x| x < 0).is_some()` with `any(|&x| x < 0)`\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|&x| x < 0)`\n \n error: called `is_some()` after searching an `Iterator` with position. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:277:13\n+  --> $DIR/methods.rs:281:13\n    |\n LL |       let _ = v.iter().position(|&x| {\n    |  _____________^\n@@ -176,15 +185,13 @@ LL | |                    ).is_some();\n    | |______________________________^\n \n error: called `is_some()` after searching an `Iterator` with rposition. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:283:13\n+  --> $DIR/methods.rs:287:13\n    |\n LL |     let _ = v.iter().rposition(|&x| x < 0).is_some();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: replace `rposition(|&x| x < 0).is_some()` with `any(|&x| x < 0)`\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|&x| x < 0)`\n \n error: called `is_some()` after searching an `Iterator` with rposition. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:286:13\n+  --> $DIR/methods.rs:290:13\n    |\n LL |       let _ = v.iter().rposition(|&x| {\n    |  _____________^\n@@ -194,12 +201,12 @@ LL | |                    ).is_some();\n    | |______________________________^\n \n error: used unwrap() on an Option value. If you don't want to handle the None case gracefully, consider using expect() to provide a better panic message\n-  --> $DIR/methods.rs:301:13\n+  --> $DIR/methods.rs:305:13\n    |\n LL |     let _ = opt.unwrap();\n    |             ^^^^^^^^^^^^\n    |\n    = note: `-D clippy::option-unwrap-used` implied by `-D warnings`\n \n-error: aborting due to 21 previous errors\n+error: aborting due to 23 previous errors\n "}]}