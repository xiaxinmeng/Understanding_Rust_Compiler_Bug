{"sha": "1bbb1e06f114b0a26cd9d9ca35fe1f248c56442a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiYmIxZTA2ZjExNGIwYTI2Y2Q5ZDljYTM1ZmUxZjI0OGM1NjQ0MmE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-08-22T00:26:33Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-08-28T01:47:58Z"}, "message": "librustc: Remove `each_path`.\n\nThis does not implement lazy symbol resolution yet.", "tree": {"sha": "d833a95a55f6199b4d4768405adbeb2526934ddb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d833a95a55f6199b4d4768405adbeb2526934ddb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1bbb1e06f114b0a26cd9d9ca35fe1f248c56442a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1bbb1e06f114b0a26cd9d9ca35fe1f248c56442a", "html_url": "https://github.com/rust-lang/rust/commit/1bbb1e06f114b0a26cd9d9ca35fe1f248c56442a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1bbb1e06f114b0a26cd9d9ca35fe1f248c56442a/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ad2239f62031aaf5d8d046f1648cd91f8507f44", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ad2239f62031aaf5d8d046f1648cd91f8507f44", "html_url": "https://github.com/rust-lang/rust/commit/1ad2239f62031aaf5d8d046f1648cd91f8507f44"}], "stats": {"total": 542, "additions": 285, "deletions": 257}, "files": [{"sha": "731dac5829459a666cc49439d05814e7b312a2ef", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1bbb1e06f114b0a26cd9d9ca35fe1f248c56442a/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bbb1e06f114b0a26cd9d9ca35fe1f248c56442a/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=1bbb1e06f114b0a26cd9d9ca35fe1f248c56442a", "patch": "@@ -49,16 +49,34 @@ pub fn each_lang_item(cstore: @mut cstore::CStore,\n     decoder::each_lang_item(crate_data, f)\n }\n \n-/// Iterates over all the paths in the given crate.\n-pub fn each_path(cstore: @mut cstore::CStore,\n-                 cnum: ast::CrateNum,\n-                 f: &fn(&str, decoder::def_like, ast::visibility) -> bool)\n-                 -> bool {\n+/// Iterates over each child of the given item.\n+pub fn each_child_of_item(cstore: @mut cstore::CStore,\n+                          def_id: ast::def_id,\n+                          callback: &fn(decoder::def_like, ast::ident)) {\n+    let crate_data = cstore::get_crate_data(cstore, def_id.crate);\n+    let get_crate_data: decoder::GetCrateDataCb = |cnum| {\n+        cstore::get_crate_data(cstore, cnum)\n+    };\n+    decoder::each_child_of_item(cstore.intr,\n+                                crate_data,\n+                                def_id.node,\n+                                get_crate_data,\n+                                callback)\n+}\n+\n+/// Iterates over each top-level crate item.\n+pub fn each_top_level_item_of_crate(cstore: @mut cstore::CStore,\n+                                    cnum: ast::CrateNum,\n+                                    callback: &fn(decoder::def_like,\n+                                                  ast::ident)) {\n     let crate_data = cstore::get_crate_data(cstore, cnum);\n     let get_crate_data: decoder::GetCrateDataCb = |cnum| {\n         cstore::get_crate_data(cstore, cnum)\n     };\n-    decoder::each_path(cstore.intr, crate_data, get_crate_data, f)\n+    decoder::each_top_level_item_of_crate(cstore.intr,\n+                                          crate_data,\n+                                          get_crate_data,\n+                                          callback)\n }\n \n pub fn get_item_path(tcx: ty::ctxt, def: ast::def_id) -> ast_map::path {"}, {"sha": "e2b12bc559903f5491147bd7675dcdf375f6e029", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 103, "deletions": 37, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/1bbb1e06f114b0a26cd9d9ca35fe1f248c56442a/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bbb1e06f114b0a26cd9d9ca35fe1f248c56442a/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=1bbb1e06f114b0a26cd9d9ca35fe1f248c56442a", "patch": "@@ -39,7 +39,7 @@ use syntax::ast_map;\n use syntax::attr;\n use syntax::parse::token::{ident_interner, special_idents};\n use syntax::print::pprust;\n-use syntax::{ast, ast_util};\n+use syntax::ast;\n use syntax::codemap;\n use syntax::parse::token;\n \n@@ -702,33 +702,114 @@ impl<'self> EachItemContext<'self> {\n     }\n }\n \n-/// Iterates over all the paths in the given crate.\n-pub fn each_path(intr: @ident_interner,\n-                 cdata: cmd,\n-                 get_crate_data: GetCrateDataCb,\n-                 f: &fn(&str, def_like, ast::visibility) -> bool)\n-                 -> bool {\n-    // FIXME #4572: This function needs to be nuked, as it's impossible to\n-    // make fast. It's the source of most of the performance problems when\n-    // compiling small crates.\n+fn each_child_of_item_or_crate(intr: @ident_interner,\n+                               cdata: cmd,\n+                               item_doc: ebml::Doc,\n+                               get_crate_data: GetCrateDataCb,\n+                               callback: &fn(def_like, ast::ident)) {\n+    // Iterate over all children.\n+    let _ = do reader::tagged_docs(item_doc, tag_mod_child) |child_info_doc| {\n+        let child_def_id = reader::with_doc_data(child_info_doc,\n+                                                 parse_def_id);\n+        let child_def_id = translate_def_id(cdata, child_def_id);\n+\n+        // This item may be in yet another crate if it was the child of a\n+        // reexport.\n+        let other_crates_items = if child_def_id.crate == cdata.cnum {\n+            reader::get_doc(reader::Doc(cdata.data), tag_items)\n+        } else {\n+            let crate_data = get_crate_data(child_def_id.crate);\n+            reader::get_doc(reader::Doc(crate_data.data), tag_items)\n+        };\n+\n+        // Get the item.\n+        match maybe_find_item(child_def_id.node, other_crates_items) {\n+            None => {}\n+            Some(child_item_doc) => {\n+                // Hand off the item to the callback.\n+                let child_name = item_name(intr, child_item_doc);\n+                let def_like = item_to_def_like(child_item_doc,\n+                                                child_def_id,\n+                                                cdata.cnum);\n+                callback(def_like, child_name);\n+            }\n+        }\n+\n+        true\n+    };\n+\n+    // Iterate over all reexports.\n+    let _ = do each_reexport(item_doc) |reexport_doc| {\n+        let def_id_doc = reader::get_doc(reexport_doc,\n+                                         tag_items_data_item_reexport_def_id);\n+        let child_def_id = reader::with_doc_data(def_id_doc,\n+                                                 parse_def_id);\n+        let child_def_id = translate_def_id(cdata, child_def_id);\n+\n+        let name_doc = reader::get_doc(reexport_doc,\n+                                       tag_items_data_item_reexport_name);\n+        let name = name_doc.as_str_slice();\n+\n+        // This reexport may be in yet another crate.\n+        let other_crates_items = if child_def_id.crate == cdata.cnum {\n+            reader::get_doc(reader::Doc(cdata.data), tag_items)\n+        } else {\n+            let crate_data = get_crate_data(child_def_id.crate);\n+            reader::get_doc(reader::Doc(crate_data.data), tag_items)\n+        };\n+\n+        // Get the item.\n+        match maybe_find_item(child_def_id.node, other_crates_items) {\n+            None => {}\n+            Some(child_item_doc) => {\n+                // Hand off the item to the callback.\n+                let def_like = item_to_def_like(child_item_doc,\n+                                                child_def_id,\n+                                                cdata.cnum);\n+                callback(def_like, token::str_to_ident(name));\n+            }\n+        }\n+\n+        true\n+    };\n+}\n \n+/// Iterates over each child of the given item.\n+pub fn each_child_of_item(intr: @ident_interner,\n+                          cdata: cmd,\n+                          id: ast::NodeId,\n+                          get_crate_data: GetCrateDataCb,\n+                          callback: &fn(def_like, ast::ident)) {\n+    // Find the item.\n+    let root_doc = reader::Doc(cdata.data);\n+    let items = reader::get_doc(root_doc, tag_items);\n+    let item_doc = match maybe_find_item(id, items) {\n+        None => return,\n+        Some(item_doc) => item_doc,\n+    };\n+\n+    each_child_of_item_or_crate(intr,\n+                                cdata,\n+                                item_doc,\n+                                get_crate_data,\n+                                callback)\n+}\n+\n+/// Iterates over all the top-level crate items.\n+pub fn each_top_level_item_of_crate(intr: @ident_interner,\n+                                    cdata: cmd,\n+                                    get_crate_data: GetCrateDataCb,\n+                                    callback: &fn(def_like, ast::ident)) {\n     let root_doc = reader::Doc(cdata.data);\n     let misc_info_doc = reader::get_doc(root_doc, tag_misc_info);\n     let crate_items_doc = reader::get_doc(misc_info_doc,\n                                           tag_misc_info_crate_items);\n \n-    let mut path_builder = ~\"\";\n-\n-    let mut context = EachItemContext {\n-        intr: intr,\n-        cdata: cdata,\n-        get_crate_data: get_crate_data,\n-        path_builder: &mut path_builder,\n-        callback: f,\n-    };\n-\n-    // Iterate over all top-level crate items.\n-    context.each_child_of_module_or_crate(crate_items_doc)\n+    each_child_of_item_or_crate(intr,\n+                                cdata,\n+                                crate_items_doc,\n+                                get_crate_data,\n+                                callback)\n }\n \n pub fn get_item_path(cdata: cmd, id: ast::NodeId) -> ast_map::path {\n@@ -1268,21 +1349,6 @@ pub fn get_crate_vers(data: @~[u8]) -> @str {\n     }\n }\n \n-fn iter_crate_items(intr: @ident_interner, cdata: cmd,\n-                    get_crate_data: GetCrateDataCb,\n-                    proc: &fn(path: &str, ast::def_id)) {\n-    do each_path(intr, cdata, get_crate_data) |path_string, def_like, _| {\n-        match def_like {\n-            dl_impl(*) | dl_field => {}\n-            dl_def(def) => {\n-                proc(path_string,\n-                     ast_util::def_id_of_def(def))\n-            }\n-        }\n-        true\n-    };\n-}\n-\n pub fn list_crate_metadata(intr: @ident_interner, bytes: @~[u8],\n                            out: @io::Writer) {\n     let hash = get_crate_hash(bytes);"}, {"sha": "646658986f72b4a378c3d2ba0f58b5ade69945bb", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 158, "deletions": 214, "changes": 372, "blob_url": "https://github.com/rust-lang/rust/blob/1bbb1e06f114b0a26cd9d9ca35fe1f248c56442a/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bbb1e06f114b0a26cd9d9ca35fe1f248c56442a/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=1bbb1e06f114b0a26cd9d9ca35fe1f248c56442a", "patch": "@@ -10,10 +10,11 @@\n \n \n use driver::session::Session;\n-use metadata::csearch::{each_path, get_trait_method_def_ids};\n+use metadata::csearch::get_trait_method_def_ids;\n use metadata::csearch::get_method_name_and_explicit_self;\n use metadata::csearch::get_static_methods_if_impl;\n use metadata::csearch::{get_type_name_if_impl, get_struct_fields};\n+use metadata::csearch;\n use metadata::cstore::find_extern_mod_stmt_cnum;\n use metadata::decoder::{def_like, dl_def, dl_field, dl_impl};\n use middle::lang_items::LanguageItems;\n@@ -486,7 +487,7 @@ pub fn Module(parent_link: ParentLink,\n         anonymous_children: @mut HashMap::new(),\n         import_resolutions: @mut HashMap::new(),\n         glob_count: 0,\n-        resolved_import_count: 0\n+        resolved_import_count: 0,\n     }\n }\n \n@@ -1629,14 +1630,13 @@ impl Resolver {\n         visit::walk_block(visitor, block, new_parent);\n     }\n \n-    pub fn handle_external_def(@mut self,\n-                               def: def,\n-                               visibility: ast::visibility,\n-                               modules: &mut HashMap<def_id, @mut Module>,\n-                               child_name_bindings: @mut NameBindings,\n-                               final_ident: &str,\n-                               ident: ident,\n-                               new_parent: ReducedGraphParent) {\n+    fn handle_external_def(@mut self,\n+                           def: def,\n+                           visibility: ast::visibility,\n+                           child_name_bindings: @mut NameBindings,\n+                           final_ident: &str,\n+                           ident: ident,\n+                           new_parent: ReducedGraphParent) {\n         let privacy = visibility_to_privacy(visibility);\n         match def {\n           def_mod(def_id) | def_foreign_mod(def_id) => {\n@@ -1645,50 +1645,18 @@ impl Resolver {\n                 debug!(\"(building reduced graph for external crate) \\\n                         already created module\");\n                 module_def.def_id = Some(def_id);\n-                modules.insert(def_id, module_def);\n               }\n               Some(_) | None => {\n                 debug!(\"(building reduced graph for \\\n                         external crate) building module \\\n                         %s\", final_ident);\n                 let parent_link = self.get_parent_link(new_parent, ident);\n \n-                // FIXME (#5074): this should be a match on find\n-                if !modules.contains_key(&def_id) {\n-                    child_name_bindings.define_module(privacy,\n-                                                      parent_link,\n-                                                      Some(def_id),\n-                                                      NormalModuleKind,\n-                                                      dummy_sp());\n-                    modules.insert(def_id,\n-                                   child_name_bindings.get_module());\n-                } else {\n-                    let existing_module = *modules.get(&def_id);\n-\n-                    // Create an import resolution to avoid creating cycles in\n-                    // the module graph.\n-\n-                    let resolution = @mut ImportResolution(Public, 0);\n-                    resolution.outstanding_references = 0;\n-\n-                    match existing_module.parent_link {\n-                      NoParentLink |\n-                      BlockParentLink(*) => {\n-                        fail!(\"can't happen\");\n-                      }\n-                      ModuleParentLink(parent_module, ident) => {\n-                        let name_bindings = parent_module.children.get(\n-                            &ident);\n-                        resolution.type_target =\n-                            Some(Target(parent_module, *name_bindings));\n-                      }\n-                    }\n-\n-                    debug!(\"(building reduced graph for external crate) \\\n-                            ... creating import resolution\");\n-\n-                    new_parent.import_resolutions.insert(ident, resolution);\n-                }\n+                child_name_bindings.define_module(privacy,\n+                                                  parent_link,\n+                                                  Some(def_id),\n+                                                  NormalModuleKind,\n+                                                  dummy_sp());\n               }\n             }\n           }\n@@ -1779,184 +1747,160 @@ impl Resolver {\n         }\n     }\n \n-    /**\n-     * Builds the reduced graph rooted at the 'use' directive for an external\n-     * crate.\n-     */\n-    pub fn build_reduced_graph_for_external_crate(@mut self,\n-                                                  root: @mut Module) {\n-        let mut modules = HashMap::new();\n-\n-        // Create all the items reachable by paths.\n-        do each_path(self.session.cstore, root.def_id.unwrap().crate)\n-                |path_string, def_like, visibility| {\n-\n-            debug!(\"(building reduced graph for external crate) found path \\\n-                        entry: %s (%?)\",\n-                    path_string, def_like);\n-\n-            let mut pieces: ~[&str] = path_string.split_str_iter(\"::\").collect();\n-            let final_ident_str = pieces.pop();\n-            let final_ident = self.session.ident_of(final_ident_str);\n-\n-            // Find the module we need, creating modules along the way if we\n-            // need to.\n-\n-            let mut current_module = root;\n-            for ident_str in pieces.iter() {\n-                let ident = self.session.ident_of(*ident_str);\n-                // Create or reuse a graph node for the child.\n-                let (child_name_bindings, new_parent) =\n-                    self.add_child(ident,\n-                                   ModuleReducedGraphParent(current_module),\n-                                   OverwriteDuplicates,\n-                                   dummy_sp());\n-\n-                // Define or reuse the module node.\n-                match child_name_bindings.type_def {\n-                    None => {\n-                        debug!(\"(building reduced graph for external crate) \\\n-                                autovivifying missing type def %s\",\n-                                *ident_str);\n-                        let parent_link = self.get_parent_link(new_parent,\n-                                                               ident);\n-                        child_name_bindings.define_module(Public,\n-                                                          parent_link,\n-                                                          None,\n-                                                          NormalModuleKind,\n-                                                          dummy_sp());\n-                    }\n-                    Some(type_ns_def)\n-                            if type_ns_def.module_def.is_none() => {\n-                        debug!(\"(building reduced graph for external crate) \\\n-                                autovivifying missing module def %s\",\n-                                *ident_str);\n-                        let parent_link = self.get_parent_link(new_parent,\n-                                                               ident);\n-                        child_name_bindings.define_module(Public,\n-                                                          parent_link,\n-                                                          None,\n-                                                          NormalModuleKind,\n-                                                          dummy_sp());\n+    /// Builds the reduced graph for a single item in an external crate.\n+    fn build_reduced_graph_for_external_crate_def(@mut self,\n+                                                  root: @mut Module,\n+                                                  def_like: def_like,\n+                                                  ident: ident) {\n+        match def_like {\n+            dl_def(def) => {\n+                // Add the new child item, if necessary.\n+                let optional_module = match def {\n+                    def_foreign_mod(*) => Some(root),\n+                    _ => {\n+                        let (child_name_bindings, new_parent) =\n+                            self.add_child(ident,\n+                                           ModuleReducedGraphParent(root),\n+                                           OverwriteDuplicates,\n+                                           dummy_sp());\n+\n+                        self.handle_external_def(def,\n+                                                 public,\n+                                                 child_name_bindings,\n+                                                 self.session.str_of(ident),\n+                                                 ident,\n+                                                 new_parent);\n+\n+                        /*println(fmt!(\">>> child item added: %s\",\n+                                     self.session.str_of(ident)));*/\n+\n+                        child_name_bindings.get_module_if_available()\n                     }\n-                    _ => {} // Fall through.\n-                }\n-\n-                current_module = child_name_bindings.get_module();\n-            }\n-\n-            match def_like {\n-                dl_def(def) => {\n-                    // Add the new child item.\n-                    let (child_name_bindings, new_parent) =\n-                        self.add_child(final_ident,\n-                                       ModuleReducedGraphParent(\n-                                            current_module),\n-                                       OverwriteDuplicates,\n-                                       dummy_sp());\n-\n-                    self.handle_external_def(def,\n-                                             visibility,\n-                                             &mut modules,\n-                                             child_name_bindings,\n-                                             self.session.str_of(\n-                                                 final_ident),\n-                                             final_ident,\n-                                             new_parent);\n-                }\n-                dl_impl(def) => {\n-                    // We only process static methods of impls here.\n-                    match get_type_name_if_impl(self.session.cstore, def) {\n-                        None => {}\n-                        Some(final_ident) => {\n-                            let static_methods_opt =\n-                                get_static_methods_if_impl(\n-                                    self.session.cstore, def);\n-                            match static_methods_opt {\n-                                Some(ref static_methods) if\n-                                    static_methods.len() >= 1 => {\n-                                    debug!(\"(building reduced graph for \\\n-                                            external crate) processing \\\n-                                            static methods for type name %s\",\n-                                            self.session.str_of(\n-                                                final_ident));\n-\n-                                    let (child_name_bindings, new_parent) =\n-                                        self.add_child(final_ident,\n-                                            ModuleReducedGraphParent(\n-                                                            current_module),\n-                                            OverwriteDuplicates,\n-                                            dummy_sp());\n+                };\n \n-                                    // Process the static methods. First,\n-                                    // create the module.\n-                                    let type_module;\n-                                    match child_name_bindings.type_def {\n-                                        Some(TypeNsDef {\n-                                            module_def: Some(module_def),\n-                                            _\n-                                        }) => {\n-                                            // We already have a module. This\n-                                            // is OK.\n-                                            type_module = module_def;\n-\n-                                            // Mark it as an impl module if\n-                                            // necessary.\n-                                            type_module.kind = ImplModuleKind;\n-                                        }\n-                                        Some(_) | None => {\n-                                            let parent_link =\n-                                                self.get_parent_link(\n-                                                    new_parent, final_ident);\n-                                            child_name_bindings.define_module(\n-                                                Public,\n-                                                parent_link,\n-                                                Some(def),\n-                                                ImplModuleKind,\n-                                                dummy_sp());\n-                                            type_module =\n-                                                child_name_bindings.\n-                                                    get_module();\n-                                        }\n+                match optional_module {\n+                    None => {}\n+                    Some(module) => {\n+                        do csearch::each_child_of_item(self.session.cstore,\n+                                                       def_id_of_def(def))\n+                                |def_like, child_ident| {\n+                            /*println(fmt!(\">>> each_child_of_item: %s %s\",\n+                                         self.session.str_of(ident),\n+                                         self.session.str_of(child_ident)));*/\n+                            self.build_reduced_graph_for_external_crate_def(\n+                                module,\n+                                def_like,\n+                                child_ident)\n+                        }\n+                    }\n+                }\n+            }\n+            dl_impl(def) => {\n+                // We only process static methods of impls here.\n+                match get_type_name_if_impl(self.session.cstore, def) {\n+                    None => {}\n+                    Some(final_ident) => {\n+                        let static_methods_opt =\n+                            get_static_methods_if_impl(self.session.cstore,\n+                                                       def);\n+                        match static_methods_opt {\n+                            Some(ref static_methods) if\n+                                static_methods.len() >= 1 => {\n+                                debug!(\"(building reduced graph for \\\n+                                        external crate) processing \\\n+                                        static methods for type name %s\",\n+                                        self.session.str_of(\n+                                            final_ident));\n+\n+                                let (child_name_bindings, new_parent) =\n+                                    self.add_child(\n+                                        final_ident,\n+                                        ModuleReducedGraphParent(root),\n+                                        OverwriteDuplicates,\n+                                        dummy_sp());\n+\n+                                // Process the static methods. First,\n+                                // create the module.\n+                                let type_module;\n+                                match child_name_bindings.type_def {\n+                                    Some(TypeNsDef {\n+                                        module_def: Some(module_def),\n+                                        _\n+                                    }) => {\n+                                        // We already have a module. This\n+                                        // is OK.\n+                                        type_module = module_def;\n+\n+                                        // Mark it as an impl module if\n+                                        // necessary.\n+                                        type_module.kind = ImplModuleKind;\n                                     }\n-\n-                                    // Add each static method to the module.\n-                                    let new_parent = ModuleReducedGraphParent(\n-                                        type_module);\n-                                    for static_method_info in static_methods.iter() {\n-                                        let ident = static_method_info.ident;\n-                                        debug!(\"(building reduced graph for \\\n-                                                 external crate) creating \\\n-                                                 static method '%s'\",\n-                                               self.session.str_of(ident));\n-\n-                                        let (method_name_bindings, _) =\n-                                            self.add_child(\n-                                                ident,\n-                                                new_parent,\n-                                                OverwriteDuplicates,\n-                                                dummy_sp());\n-                                        let def = def_fn(\n-                                            static_method_info.def_id,\n-                                            static_method_info.purity);\n-                                        method_name_bindings.define_value(\n-                                            Public, def, dummy_sp());\n+                                    Some(_) | None => {\n+                                        let parent_link =\n+                                            self.get_parent_link(new_parent,\n+                                                                 final_ident);\n+                                        child_name_bindings.define_module(\n+                                            Public,\n+                                            parent_link,\n+                                            Some(def),\n+                                            ImplModuleKind,\n+                                            dummy_sp());\n+                                        type_module =\n+                                            child_name_bindings.\n+                                                get_module();\n                                     }\n                                 }\n \n-                                // Otherwise, do nothing.\n-                                Some(_) | None => {}\n+                                // Add each static method to the module.\n+                                let new_parent =\n+                                    ModuleReducedGraphParent(type_module);\n+                                for static_method_info in\n+                                        static_methods.iter() {\n+                                    let ident = static_method_info.ident;\n+                                    debug!(\"(building reduced graph for \\\n+                                             external crate) creating \\\n+                                             static method '%s'\",\n+                                           self.session.str_of(ident));\n+\n+                                    let (method_name_bindings, _) =\n+                                        self.add_child(ident,\n+                                                       new_parent,\n+                                                       OverwriteDuplicates,\n+                                                       dummy_sp());\n+                                    let def = def_fn(\n+                                        static_method_info.def_id,\n+                                        static_method_info.purity);\n+                                    method_name_bindings.define_value(\n+                                        Public,\n+                                        def,\n+                                        dummy_sp());\n+                                }\n                             }\n+\n+                            // Otherwise, do nothing.\n+                            Some(_) | None => {}\n                         }\n                     }\n                 }\n-                dl_field => {\n-                    debug!(\"(building reduced graph for external crate) \\\n-                            ignoring field\");\n-                }\n             }\n-            true\n-        };\n+            dl_field => {\n+                debug!(\"(building reduced graph for external crate) \\\n+                        ignoring field\");\n+            }\n+        }\n+    }\n+\n+    /// Builds the reduced graph rooted at the 'use' directive for an external\n+    /// crate.\n+    pub fn build_reduced_graph_for_external_crate(@mut self,\n+                                                  root: @mut Module) {\n+        do csearch::each_top_level_item_of_crate(self.session.cstore,\n+                                                 root.def_id.unwrap().crate)\n+                |def_like, ident| {\n+            self.build_reduced_graph_for_external_crate_def(root,\n+                                                            def_like,\n+                                                            ident)\n+        }\n     }\n \n     /// Creates and adds an import directive to the given module."}]}