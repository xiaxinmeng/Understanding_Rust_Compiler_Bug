{"sha": "c5be0cedf3a9d56c17d988ce6354599b85198fb8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1YmUwY2VkZjNhOWQ1NmMxN2Q5ODhjZTYzNTQ1OTliODUxOThmYjg=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-12-03T12:58:44Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-12-03T12:58:44Z"}, "message": "Merge #2463\n\n2463: More correct method resolution r=flodiebold a=flodiebold\n\nThis should fix the order in which candidates for method resolution are considered, i.e. `(&Foo).clone()` should now be of type `Foo` instead of `&Foo`. It also checks for inherent candidates that the self type unifies properly with the self type in the impl (i.e. `impl Foo<u32>` methods will only be considered for `Foo<u32>`).\r\n\r\nTo be able to get the correct receiver type to check in the method resolution, I needed the unification logic, so I extracted it to the `unify.rs` module.\r\n\r\nShould fix #2435.\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "70e3d0e36efa9568fb7f510f44bd65ff675122a2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/70e3d0e36efa9568fb7f510f44bd65ff675122a2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c5be0cedf3a9d56c17d988ce6354599b85198fb8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd5lwECRBK7hj4Ov3rIwAAdHIIAJq555zlU3PCG4HCh1L5Ohvy\na0JJfuHwERkqhwr6RkyUDDUn9IWkeCmS200yg4XC+ojxuQFIRQ4b7/e/A11aiAlG\nwoHdX66yzFNgxXy4w19CzfkfQXeWJPipew8LjrMPLR8qBdtvovD4VMtawsPoD1GP\nyyE+qBls9Bqjo4EShHRR6GsdNPvntGLGz6tzkpX04RqLLuVu3JS+YLy1JHAwQD1n\nC8RiJjLpvDpPRxuaV5aSbCmtg1WmPoqkssqcUTX3GaUyevLPLeB/B7Jaxdl1p6Ud\nO4XAcI2qTBA9hbAPG8vxCbrHincX/CdwkIMxqinTv5vitrYUozo7KCrUk9DgIhA=\n=sUx2\n-----END PGP SIGNATURE-----\n", "payload": "tree 70e3d0e36efa9568fb7f510f44bd65ff675122a2\nparent 3376c08052a563a5d2db487c458972378edebf44\nparent 18f25acb89304b2eb0a822b7b49b5e66a439ada7\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1575377924 +0000\ncommitter GitHub <noreply@github.com> 1575377924 +0000\n\nMerge #2463\n\n2463: More correct method resolution r=flodiebold a=flodiebold\n\nThis should fix the order in which candidates for method resolution are considered, i.e. `(&Foo).clone()` should now be of type `Foo` instead of `&Foo`. It also checks for inherent candidates that the self type unifies properly with the self type in the impl (i.e. `impl Foo<u32>` methods will only be considered for `Foo<u32>`).\r\n\r\nTo be able to get the correct receiver type to check in the method resolution, I needed the unification logic, so I extracted it to the `unify.rs` module.\r\n\r\nShould fix #2435.\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c5be0cedf3a9d56c17d988ce6354599b85198fb8", "html_url": "https://github.com/rust-lang/rust/commit/c5be0cedf3a9d56c17d988ce6354599b85198fb8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c5be0cedf3a9d56c17d988ce6354599b85198fb8/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3376c08052a563a5d2db487c458972378edebf44", "url": "https://api.github.com/repos/rust-lang/rust/commits/3376c08052a563a5d2db487c458972378edebf44", "html_url": "https://github.com/rust-lang/rust/commit/3376c08052a563a5d2db487c458972378edebf44"}, {"sha": "18f25acb89304b2eb0a822b7b49b5e66a439ada7", "url": "https://api.github.com/repos/rust-lang/rust/commits/18f25acb89304b2eb0a822b7b49b5e66a439ada7", "html_url": "https://github.com/rust-lang/rust/commit/18f25acb89304b2eb0a822b7b49b5e66a439ada7"}], "stats": {"total": 910, "additions": 570, "deletions": 340}, "files": [{"sha": "d16f1eb46d6265afa6539491790a86d7c323fc45", "filename": "crates/ra_hir_ty/src/infer.rs", "status": "modified", "additions": 25, "deletions": 234, "changes": 259, "blob_url": "https://github.com/rust-lang/rust/blob/c5be0cedf3a9d56c17d988ce6354599b85198fb8/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5be0cedf3a9d56c17d988ce6354599b85198fb8/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs?ref=c5be0cedf3a9d56c17d988ce6354599b85198fb8", "patch": "@@ -18,7 +18,6 @@ use std::mem;\n use std::ops::Index;\n use std::sync::Arc;\n \n-use ena::unify::{InPlaceUnificationTable, NoError, UnifyKey, UnifyValue};\n use rustc_hash::FxHashMap;\n \n use hir_def::{\n@@ -33,16 +32,17 @@ use hir_def::{\n use hir_expand::{diagnostics::DiagnosticSink, name};\n use ra_arena::map::ArenaMap;\n use ra_prof::profile;\n-use test_utils::tested_by;\n \n use super::{\n     primitive::{FloatTy, IntTy},\n     traits::{Guidance, Obligation, ProjectionPredicate, Solution},\n-    ApplicationTy, InEnvironment, ProjectionTy, Substs, TraitEnvironment, TraitRef, Ty, TypeCtor,\n-    TypeWalk, Uncertain,\n+    ApplicationTy, InEnvironment, ProjectionTy, TraitEnvironment, TraitRef, Ty, TypeCtor, TypeWalk,\n+    Uncertain,\n };\n use crate::{db::HirDatabase, infer::diagnostics::InferenceDiagnostic};\n \n+pub(crate) use unify::unify;\n+\n macro_rules! ty_app {\n     ($ctor:pat, $param:pat) => {\n         crate::Ty::Apply(crate::ApplicationTy { ctor: $ctor, parameters: $param })\n@@ -191,7 +191,7 @@ struct InferenceContext<'a, D: HirDatabase> {\n     owner: DefWithBodyId,\n     body: Arc<Body>,\n     resolver: Resolver,\n-    var_unification_table: InPlaceUnificationTable<TypeVarId>,\n+    table: unify::InferenceTable,\n     trait_env: Arc<TraitEnvironment>,\n     obligations: Vec<Obligation>,\n     result: InferenceResult,\n@@ -209,7 +209,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     fn new(db: &'a D, owner: DefWithBodyId, resolver: Resolver) -> Self {\n         InferenceContext {\n             result: InferenceResult::default(),\n-            var_unification_table: InPlaceUnificationTable::new(),\n+            table: unify::InferenceTable::new(),\n             obligations: Vec::default(),\n             return_ty: Ty::Unknown, // set in collect_fn_signature\n             trait_env: TraitEnvironment::lower(db, &resolver),\n@@ -224,13 +224,12 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     fn resolve_all(mut self) -> InferenceResult {\n         // FIXME resolve obligations as well (use Guidance if necessary)\n         let mut result = mem::replace(&mut self.result, InferenceResult::default());\n-        let mut tv_stack = Vec::new();\n         for ty in result.type_of_expr.values_mut() {\n-            let resolved = self.resolve_ty_completely(&mut tv_stack, mem::replace(ty, Ty::Unknown));\n+            let resolved = self.table.resolve_ty_completely(mem::replace(ty, Ty::Unknown));\n             *ty = resolved;\n         }\n         for ty in result.type_of_pat.values_mut() {\n-            let resolved = self.resolve_ty_completely(&mut tv_stack, mem::replace(ty, Ty::Unknown));\n+            let resolved = self.table.resolve_ty_completely(mem::replace(ty, Ty::Unknown));\n             *ty = resolved;\n         }\n         result\n@@ -275,96 +274,15 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         self.normalize_associated_types_in(ty)\n     }\n \n-    fn unify_substs(&mut self, substs1: &Substs, substs2: &Substs, depth: usize) -> bool {\n-        substs1.0.iter().zip(substs2.0.iter()).all(|(t1, t2)| self.unify_inner(t1, t2, depth))\n-    }\n-\n-    fn unify(&mut self, ty1: &Ty, ty2: &Ty) -> bool {\n-        self.unify_inner(ty1, ty2, 0)\n-    }\n-\n-    fn unify_inner(&mut self, ty1: &Ty, ty2: &Ty, depth: usize) -> bool {\n-        if depth > 1000 {\n-            // prevent stackoverflows\n-            panic!(\"infinite recursion in unification\");\n-        }\n-        if ty1 == ty2 {\n-            return true;\n-        }\n-        // try to resolve type vars first\n-        let ty1 = self.resolve_ty_shallow(ty1);\n-        let ty2 = self.resolve_ty_shallow(ty2);\n-        match (&*ty1, &*ty2) {\n-            (Ty::Apply(a_ty1), Ty::Apply(a_ty2)) if a_ty1.ctor == a_ty2.ctor => {\n-                self.unify_substs(&a_ty1.parameters, &a_ty2.parameters, depth + 1)\n-            }\n-            _ => self.unify_inner_trivial(&ty1, &ty2),\n-        }\n-    }\n-\n-    fn unify_inner_trivial(&mut self, ty1: &Ty, ty2: &Ty) -> bool {\n-        match (ty1, ty2) {\n-            (Ty::Unknown, _) | (_, Ty::Unknown) => true,\n-\n-            (Ty::Infer(InferTy::TypeVar(tv1)), Ty::Infer(InferTy::TypeVar(tv2)))\n-            | (Ty::Infer(InferTy::IntVar(tv1)), Ty::Infer(InferTy::IntVar(tv2)))\n-            | (Ty::Infer(InferTy::FloatVar(tv1)), Ty::Infer(InferTy::FloatVar(tv2)))\n-            | (\n-                Ty::Infer(InferTy::MaybeNeverTypeVar(tv1)),\n-                Ty::Infer(InferTy::MaybeNeverTypeVar(tv2)),\n-            ) => {\n-                // both type vars are unknown since we tried to resolve them\n-                self.var_unification_table.union(*tv1, *tv2);\n-                true\n-            }\n-\n-            // The order of MaybeNeverTypeVar matters here.\n-            // Unifying MaybeNeverTypeVar and TypeVar will let the latter become MaybeNeverTypeVar.\n-            // Unifying MaybeNeverTypeVar and other concrete type will let the former become it.\n-            (Ty::Infer(InferTy::TypeVar(tv)), other)\n-            | (other, Ty::Infer(InferTy::TypeVar(tv)))\n-            | (Ty::Infer(InferTy::MaybeNeverTypeVar(tv)), other)\n-            | (other, Ty::Infer(InferTy::MaybeNeverTypeVar(tv)))\n-            | (Ty::Infer(InferTy::IntVar(tv)), other @ ty_app!(TypeCtor::Int(_)))\n-            | (other @ ty_app!(TypeCtor::Int(_)), Ty::Infer(InferTy::IntVar(tv)))\n-            | (Ty::Infer(InferTy::FloatVar(tv)), other @ ty_app!(TypeCtor::Float(_)))\n-            | (other @ ty_app!(TypeCtor::Float(_)), Ty::Infer(InferTy::FloatVar(tv))) => {\n-                // the type var is unknown since we tried to resolve it\n-                self.var_unification_table.union_value(*tv, TypeVarValue::Known(other.clone()));\n-                true\n-            }\n-\n-            _ => false,\n-        }\n-    }\n-\n-    fn new_type_var(&mut self) -> Ty {\n-        Ty::Infer(InferTy::TypeVar(self.var_unification_table.new_key(TypeVarValue::Unknown)))\n-    }\n-\n-    fn new_integer_var(&mut self) -> Ty {\n-        Ty::Infer(InferTy::IntVar(self.var_unification_table.new_key(TypeVarValue::Unknown)))\n-    }\n-\n-    fn new_float_var(&mut self) -> Ty {\n-        Ty::Infer(InferTy::FloatVar(self.var_unification_table.new_key(TypeVarValue::Unknown)))\n-    }\n-\n-    fn new_maybe_never_type_var(&mut self) -> Ty {\n-        Ty::Infer(InferTy::MaybeNeverTypeVar(\n-            self.var_unification_table.new_key(TypeVarValue::Unknown),\n-        ))\n-    }\n-\n     /// Replaces Ty::Unknown by a new type var, so we can maybe still infer it.\n     fn insert_type_vars_shallow(&mut self, ty: Ty) -> Ty {\n         match ty {\n-            Ty::Unknown => self.new_type_var(),\n+            Ty::Unknown => self.table.new_type_var(),\n             Ty::Apply(ApplicationTy { ctor: TypeCtor::Int(Uncertain::Unknown), .. }) => {\n-                self.new_integer_var()\n+                self.table.new_integer_var()\n             }\n             Ty::Apply(ApplicationTy { ctor: TypeCtor::Float(Uncertain::Unknown), .. }) => {\n-                self.new_float_var()\n+                self.table.new_float_var()\n             }\n             _ => ty,\n         }\n@@ -402,64 +320,22 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         }\n     }\n \n+    fn unify(&mut self, ty1: &Ty, ty2: &Ty) -> bool {\n+        self.table.unify(ty1, ty2)\n+    }\n+\n     /// Resolves the type as far as currently possible, replacing type variables\n     /// by their known types. All types returned by the infer_* functions should\n     /// be resolved as far as possible, i.e. contain no type variables with\n     /// known type.\n-    fn resolve_ty_as_possible(&mut self, tv_stack: &mut Vec<TypeVarId>, ty: Ty) -> Ty {\n+    fn resolve_ty_as_possible(&mut self, ty: Ty) -> Ty {\n         self.resolve_obligations_as_possible();\n \n-        ty.fold(&mut |ty| match ty {\n-            Ty::Infer(tv) => {\n-                let inner = tv.to_inner();\n-                if tv_stack.contains(&inner) {\n-                    tested_by!(type_var_cycles_resolve_as_possible);\n-                    // recursive type\n-                    return tv.fallback_value();\n-                }\n-                if let Some(known_ty) =\n-                    self.var_unification_table.inlined_probe_value(inner).known()\n-                {\n-                    // known_ty may contain other variables that are known by now\n-                    tv_stack.push(inner);\n-                    let result = self.resolve_ty_as_possible(tv_stack, known_ty.clone());\n-                    tv_stack.pop();\n-                    result\n-                } else {\n-                    ty\n-                }\n-            }\n-            _ => ty,\n-        })\n+        self.table.resolve_ty_as_possible(ty)\n     }\n \n-    /// If `ty` is a type variable with known type, returns that type;\n-    /// otherwise, return ty.\n     fn resolve_ty_shallow<'b>(&mut self, ty: &'b Ty) -> Cow<'b, Ty> {\n-        let mut ty = Cow::Borrowed(ty);\n-        // The type variable could resolve to a int/float variable. Hence try\n-        // resolving up to three times; each type of variable shouldn't occur\n-        // more than once\n-        for i in 0..3 {\n-            if i > 0 {\n-                tested_by!(type_var_resolves_to_int_var);\n-            }\n-            match &*ty {\n-                Ty::Infer(tv) => {\n-                    let inner = tv.to_inner();\n-                    match self.var_unification_table.inlined_probe_value(inner).known() {\n-                        Some(known_ty) => {\n-                            // The known_ty can't be a type var itself\n-                            ty = Cow::Owned(known_ty.clone());\n-                        }\n-                        _ => return ty,\n-                    }\n-                }\n-                _ => return ty,\n-            }\n-        }\n-        log::error!(\"Inference variable still not resolved: {:?}\", ty);\n-        ty\n+        self.table.resolve_ty_shallow(ty)\n     }\n \n     /// Recurses through the given type, normalizing associated types mentioned\n@@ -469,48 +345,21 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     /// call). `make_ty` handles this already, but e.g. for field types we need\n     /// to do it as well.\n     fn normalize_associated_types_in(&mut self, ty: Ty) -> Ty {\n-        let ty = self.resolve_ty_as_possible(&mut vec![], ty);\n+        let ty = self.resolve_ty_as_possible(ty);\n         ty.fold(&mut |ty| match ty {\n             Ty::Projection(proj_ty) => self.normalize_projection_ty(proj_ty),\n             _ => ty,\n         })\n     }\n \n     fn normalize_projection_ty(&mut self, proj_ty: ProjectionTy) -> Ty {\n-        let var = self.new_type_var();\n+        let var = self.table.new_type_var();\n         let predicate = ProjectionPredicate { projection_ty: proj_ty, ty: var.clone() };\n         let obligation = Obligation::Projection(predicate);\n         self.obligations.push(obligation);\n         var\n     }\n \n-    /// Resolves the type completely; type variables without known type are\n-    /// replaced by Ty::Unknown.\n-    fn resolve_ty_completely(&mut self, tv_stack: &mut Vec<TypeVarId>, ty: Ty) -> Ty {\n-        ty.fold(&mut |ty| match ty {\n-            Ty::Infer(tv) => {\n-                let inner = tv.to_inner();\n-                if tv_stack.contains(&inner) {\n-                    tested_by!(type_var_cycles_resolve_completely);\n-                    // recursive type\n-                    return tv.fallback_value();\n-                }\n-                if let Some(known_ty) =\n-                    self.var_unification_table.inlined_probe_value(inner).known()\n-                {\n-                    // known_ty may contain other variables that are known by now\n-                    tv_stack.push(inner);\n-                    let result = self.resolve_ty_completely(tv_stack, known_ty.clone());\n-                    tv_stack.pop();\n-                    result\n-                } else {\n-                    tv.fallback_value()\n-                }\n-            }\n-            _ => ty,\n-        })\n-    }\n-\n     fn resolve_variant(&mut self, path: Option<&Path>) -> (Ty, Option<VariantId>) {\n         let path = match path {\n             Some(path) => path,\n@@ -615,78 +464,20 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     }\n }\n \n-/// The ID of a type variable.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n-pub struct TypeVarId(pub(super) u32);\n-\n-impl UnifyKey for TypeVarId {\n-    type Value = TypeVarValue;\n-\n-    fn index(&self) -> u32 {\n-        self.0\n-    }\n-\n-    fn from_index(i: u32) -> Self {\n-        TypeVarId(i)\n-    }\n-\n-    fn tag() -> &'static str {\n-        \"TypeVarId\"\n-    }\n-}\n-\n-/// The value of a type variable: either we already know the type, or we don't\n-/// know it yet.\n-#[derive(Clone, PartialEq, Eq, Debug)]\n-pub enum TypeVarValue {\n-    Known(Ty),\n-    Unknown,\n-}\n-\n-impl TypeVarValue {\n-    fn known(&self) -> Option<&Ty> {\n-        match self {\n-            TypeVarValue::Known(ty) => Some(ty),\n-            TypeVarValue::Unknown => None,\n-        }\n-    }\n-}\n-\n-impl UnifyValue for TypeVarValue {\n-    type Error = NoError;\n-\n-    fn unify_values(value1: &Self, value2: &Self) -> Result<Self, NoError> {\n-        match (value1, value2) {\n-            // We should never equate two type variables, both of which have\n-            // known types. Instead, we recursively equate those types.\n-            (TypeVarValue::Known(t1), TypeVarValue::Known(t2)) => panic!(\n-                \"equating two type variables, both of which have known types: {:?} and {:?}\",\n-                t1, t2\n-            ),\n-\n-            // If one side is known, prefer that one.\n-            (TypeVarValue::Known(..), TypeVarValue::Unknown) => Ok(value1.clone()),\n-            (TypeVarValue::Unknown, TypeVarValue::Known(..)) => Ok(value2.clone()),\n-\n-            (TypeVarValue::Unknown, TypeVarValue::Unknown) => Ok(TypeVarValue::Unknown),\n-        }\n-    }\n-}\n-\n /// The kinds of placeholders we need during type inference. There's separate\n /// values for general types, and for integer and float variables. The latter\n /// two are used for inference of literal values (e.g. `100` could be one of\n /// several integer types).\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n pub enum InferTy {\n-    TypeVar(TypeVarId),\n-    IntVar(TypeVarId),\n-    FloatVar(TypeVarId),\n-    MaybeNeverTypeVar(TypeVarId),\n+    TypeVar(unify::TypeVarId),\n+    IntVar(unify::TypeVarId),\n+    FloatVar(unify::TypeVarId),\n+    MaybeNeverTypeVar(unify::TypeVarId),\n }\n \n impl InferTy {\n-    fn to_inner(self) -> TypeVarId {\n+    fn to_inner(self) -> unify::TypeVarId {\n         match self {\n             InferTy::TypeVar(ty)\n             | InferTy::IntVar(ty)"}, {"sha": "9daa77cfa92d9756a551f8d77676e1bebe5d34cc", "filename": "crates/ra_hir_ty/src/infer/coerce.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c5be0cedf3a9d56c17d988ce6354599b85198fb8/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5be0cedf3a9d56c17d988ce6354599b85198fb8/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=c5be0cedf3a9d56c17d988ce6354599b85198fb8", "patch": "@@ -10,7 +10,7 @@ use test_utils::tested_by;\n \n use crate::{autoderef, db::HirDatabase, Substs, Ty, TypeCtor, TypeWalk};\n \n-use super::{InEnvironment, InferTy, InferenceContext, TypeVarValue};\n+use super::{unify::TypeVarValue, InEnvironment, InferTy, InferenceContext};\n \n impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     /// Unify two types, but may coerce the first one to the second one\n@@ -85,16 +85,16 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         match (&from_ty, to_ty) {\n             // Never type will make type variable to fallback to Never Type instead of Unknown.\n             (ty_app!(TypeCtor::Never), Ty::Infer(InferTy::TypeVar(tv))) => {\n-                let var = self.new_maybe_never_type_var();\n-                self.var_unification_table.union_value(*tv, TypeVarValue::Known(var));\n+                let var = self.table.new_maybe_never_type_var();\n+                self.table.var_unification_table.union_value(*tv, TypeVarValue::Known(var));\n                 return true;\n             }\n             (ty_app!(TypeCtor::Never), _) => return true,\n \n             // Trivial cases, this should go after `never` check to\n             // avoid infer result type to be never\n             _ => {\n-                if self.unify_inner_trivial(&from_ty, &to_ty) {\n+                if self.table.unify_inner_trivial(&from_ty, &to_ty) {\n                     return true;\n                 }\n             }\n@@ -330,7 +330,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 // Stop when constructor matches.\n                 (ty_app!(from_ctor, st1), ty_app!(to_ctor, st2)) if from_ctor == to_ctor => {\n                     // It will not recurse to `coerce`.\n-                    return self.unify_substs(st1, st2, 0);\n+                    return self.table.unify_substs(st1, st2, 0);\n                 }\n                 _ => {}\n             }"}, {"sha": "1e78f6efd46f7da85329321f0ced3036a6ac3f1e", "filename": "crates/ra_hir_ty/src/infer/expr.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c5be0cedf3a9d56c17d988ce6354599b85198fb8/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5be0cedf3a9d56c17d988ce6354599b85198fb8/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=c5be0cedf3a9d56c17d988ce6354599b85198fb8", "patch": "@@ -32,7 +32,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 TypeMismatch { expected: expected.ty.clone(), actual: ty.clone() },\n             );\n         }\n-        let ty = self.resolve_ty_as_possible(&mut vec![], ty);\n+        let ty = self.resolve_ty_as_possible(ty);\n         ty\n     }\n \n@@ -53,7 +53,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             expected.ty.clone()\n         };\n \n-        self.resolve_ty_as_possible(&mut vec![], ty)\n+        self.resolve_ty_as_possible(ty)\n     }\n \n     fn infer_expr_inner(&mut self, tgt_expr: ExprId, expected: &Expectation) -> Ty {\n@@ -94,7 +94,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n                 let pat_ty = match self.resolve_into_iter_item() {\n                     Some(into_iter_item_alias) => {\n-                        let pat_ty = self.new_type_var();\n+                        let pat_ty = self.table.new_type_var();\n                         let projection = ProjectionPredicate {\n                             ty: pat_ty.clone(),\n                             projection_ty: ProjectionTy {\n@@ -103,7 +103,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                             },\n                         };\n                         self.obligations.push(Obligation::Projection(projection));\n-                        self.resolve_ty_as_possible(&mut vec![], pat_ty)\n+                        self.resolve_ty_as_possible(pat_ty)\n                     }\n                     None => Ty::Unknown,\n                 };\n@@ -128,7 +128,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 }\n \n                 // add return type\n-                let ret_ty = self.new_type_var();\n+                let ret_ty = self.table.new_type_var();\n                 sig_tys.push(ret_ty.clone());\n                 let sig_ty = Ty::apply(\n                     TypeCtor::FnPtr { num_args: sig_tys.len() as u16 - 1 },\n@@ -167,7 +167,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             Expr::Match { expr, arms } => {\n                 let input_ty = self.infer_expr(*expr, &Expectation::none());\n \n-                let mut result_ty = self.new_maybe_never_type_var();\n+                let mut result_ty = self.table.new_maybe_never_type_var();\n \n                 for arm in arms {\n                     for &pat in &arm.pats {\n@@ -283,7 +283,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 let inner_ty = self.infer_expr(*expr, &Expectation::none());\n                 let ty = match self.resolve_future_future_output() {\n                     Some(future_future_output_alias) => {\n-                        let ty = self.new_type_var();\n+                        let ty = self.table.new_type_var();\n                         let projection = ProjectionPredicate {\n                             ty: ty.clone(),\n                             projection_ty: ProjectionTy {\n@@ -292,7 +292,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                             },\n                         };\n                         self.obligations.push(Obligation::Projection(projection));\n-                        self.resolve_ty_as_possible(&mut vec![], ty)\n+                        self.resolve_ty_as_possible(ty)\n                     }\n                     None => Ty::Unknown,\n                 };\n@@ -302,7 +302,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 let inner_ty = self.infer_expr(*expr, &Expectation::none());\n                 let ty = match self.resolve_ops_try_ok() {\n                     Some(ops_try_ok_alias) => {\n-                        let ty = self.new_type_var();\n+                        let ty = self.table.new_type_var();\n                         let projection = ProjectionPredicate {\n                             ty: ty.clone(),\n                             projection_ty: ProjectionTy {\n@@ -311,7 +311,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                             },\n                         };\n                         self.obligations.push(Obligation::Projection(projection));\n-                        self.resolve_ty_as_possible(&mut vec![], ty)\n+                        self.resolve_ty_as_possible(ty)\n                     }\n                     None => Ty::Unknown,\n                 };\n@@ -465,10 +465,10 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     ty_app!(TypeCtor::Tuple { .. }, st) => st\n                         .iter()\n                         .cloned()\n-                        .chain(repeat_with(|| self.new_type_var()))\n+                        .chain(repeat_with(|| self.table.new_type_var()))\n                         .take(exprs.len())\n                         .collect::<Vec<_>>(),\n-                    _ => (0..exprs.len()).map(|_| self.new_type_var()).collect(),\n+                    _ => (0..exprs.len()).map(|_| self.table.new_type_var()).collect(),\n                 };\n \n                 for (expr, ty) in exprs.iter().zip(tys.iter_mut()) {\n@@ -482,7 +482,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     ty_app!(TypeCtor::Array, st) | ty_app!(TypeCtor::Slice, st) => {\n                         st.as_single().clone()\n                     }\n-                    _ => self.new_type_var(),\n+                    _ => self.table.new_type_var(),\n                 };\n \n                 match array {\n@@ -524,7 +524,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         };\n         // use a new type variable if we got Ty::Unknown here\n         let ty = self.insert_type_vars_shallow(ty);\n-        let ty = self.resolve_ty_as_possible(&mut vec![], ty);\n+        let ty = self.resolve_ty_as_possible(ty);\n         self.write_expr_ty(tgt_expr, ty.clone());\n         ty\n     }\n@@ -553,7 +553,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                         }\n                     }\n \n-                    let ty = self.resolve_ty_as_possible(&mut vec![], ty);\n+                    let ty = self.resolve_ty_as_possible(ty);\n                     self.infer_pat(*pat, &ty, BindingMode::default());\n                 }\n                 Statement::Expr(expr) => {"}, {"sha": "a14662884458c9fe05307b582f2200c06d863b0c", "filename": "crates/ra_hir_ty/src/infer/pat.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c5be0cedf3a9d56c17d988ce6354599b85198fb8/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5be0cedf3a9d56c17d988ce6354599b85198fb8/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpat.rs?ref=c5be0cedf3a9d56c17d988ce6354599b85198fb8", "patch": "@@ -170,7 +170,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     }\n                     BindingMode::Move => inner_ty.clone(),\n                 };\n-                let bound_ty = self.resolve_ty_as_possible(&mut vec![], bound_ty);\n+                let bound_ty = self.resolve_ty_as_possible(bound_ty);\n                 self.write_pat_ty(pat, bound_ty);\n                 return inner_ty;\n             }\n@@ -179,7 +179,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         // use a new type variable if we got Ty::Unknown here\n         let ty = self.insert_type_vars_shallow(ty);\n         self.unify(&ty, expected);\n-        let ty = self.resolve_ty_as_possible(&mut vec![], ty);\n+        let ty = self.resolve_ty_as_possible(ty);\n         self.write_pat_ty(pat, ty.clone());\n         ty\n     }"}, {"sha": "b0024c6e1c99b22b049af9cf42b2da6e2483a6d0", "filename": "crates/ra_hir_ty/src/infer/path.rs", "status": "modified", "additions": 5, "deletions": 37, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/c5be0cedf3a9d56c17d988ce6354599b85198fb8/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5be0cedf3a9d56c17d988ce6354599b85198fb8/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpath.rs?ref=c5be0cedf3a9d56c17d988ce6354599b85198fb8", "patch": "@@ -57,7 +57,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         let typable: ValueTyDefId = match value {\n             ValueNs::LocalBinding(pat) => {\n                 let ty = self.result.type_of_pat.get(pat)?.clone();\n-                let ty = self.resolve_ty_as_possible(&mut vec![], ty);\n+                let ty = self.resolve_ty_as_possible(ty);\n                 return Some(ty);\n             }\n             ValueNs::FunctionId(it) => it.into(),\n@@ -206,12 +206,14 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     AssocItemId::TypeAliasId(_) => unreachable!(),\n                 };\n                 let substs = match container {\n-                    ContainerId::ImplId(_) => self.find_self_types(&def, ty.clone()),\n+                    ContainerId::ImplId(impl_id) => {\n+                        method_resolution::inherent_impl_substs(self.db, impl_id, &ty)\n+                    }\n                     ContainerId::TraitId(trait_) => {\n                         // we're picking this method\n                         let trait_substs = Substs::build_for_def(self.db, trait_)\n                             .push(ty.clone())\n-                            .fill(std::iter::repeat_with(|| self.new_type_var()))\n+                            .fill(std::iter::repeat_with(|| self.table.new_type_var()))\n                             .build();\n                         let substs = Substs::build_for_def(self.db, item)\n                             .use_parent_substs(&trait_substs)\n@@ -231,38 +233,4 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             },\n         )\n     }\n-\n-    fn find_self_types(&self, def: &ValueNs, actual_def_ty: Ty) -> Option<Substs> {\n-        if let ValueNs::FunctionId(func) = *def {\n-            // We only do the infer if parent has generic params\n-            let gen = self.db.generic_params(func.into());\n-            if gen.count_parent_params() == 0 {\n-                return None;\n-            }\n-\n-            let impl_id = match func.lookup(self.db).container {\n-                ContainerId::ImplId(it) => it,\n-                _ => return None,\n-            };\n-            let self_ty = self.db.impl_self_ty(impl_id).clone();\n-            let self_ty_substs = self_ty.substs()?;\n-            let actual_substs = actual_def_ty.substs()?;\n-\n-            let mut new_substs = vec![Ty::Unknown; gen.count_parent_params()];\n-\n-            // The following code *link up* the function actual parma type\n-            // and impl_block type param index\n-            self_ty_substs.iter().zip(actual_substs.iter()).for_each(|(param, pty)| {\n-                if let Ty::Param { idx, .. } = param {\n-                    if let Some(s) = new_substs.get_mut(*idx as usize) {\n-                        *s = pty.clone();\n-                    }\n-                }\n-            });\n-\n-            Some(Substs(new_substs.into()))\n-        } else {\n-            None\n-        }\n-    }\n }"}, {"sha": "8ed2a6090a8df1728a3382dce58f6c9ad5d1ce8f", "filename": "crates/ra_hir_ty/src/infer/unify.rs", "status": "modified", "additions": 270, "deletions": 6, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/c5be0cedf3a9d56c17d988ce6354599b85198fb8/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5be0cedf3a9d56c17d988ce6354599b85198fb8/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Funify.rs?ref=c5be0cedf3a9d56c17d988ce6354599b85198fb8", "patch": "@@ -1,9 +1,15 @@\n //! Unification and canonicalization logic.\n \n+use std::borrow::Cow;\n+\n+use ena::unify::{InPlaceUnificationTable, NoError, UnifyKey, UnifyValue};\n+\n+use test_utils::tested_by;\n+\n use super::{InferenceContext, Obligation};\n use crate::{\n     db::HirDatabase, utils::make_mut_slice, Canonical, InEnvironment, InferTy, ProjectionPredicate,\n-    ProjectionTy, Substs, TraitRef, Ty, TypeWalk,\n+    ProjectionTy, Substs, TraitRef, Ty, TypeCtor, TypeWalk,\n };\n \n impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n@@ -24,7 +30,7 @@ where\n     /// A stack of type variables that is used to detect recursive types (which\n     /// are an error, but we need to protect against them to avoid stack\n     /// overflows).\n-    var_stack: Vec<super::TypeVarId>,\n+    var_stack: Vec<TypeVarId>,\n }\n \n pub(super) struct Canonicalized<T> {\n@@ -53,14 +59,14 @@ where\n                     return tv.fallback_value();\n                 }\n                 if let Some(known_ty) =\n-                    self.ctx.var_unification_table.inlined_probe_value(inner).known()\n+                    self.ctx.table.var_unification_table.inlined_probe_value(inner).known()\n                 {\n                     self.var_stack.push(inner);\n                     let result = self.do_canonicalize_ty(known_ty.clone());\n                     self.var_stack.pop();\n                     result\n                 } else {\n-                    let root = self.ctx.var_unification_table.find(inner);\n+                    let root = self.ctx.table.var_unification_table.find(inner);\n                     let free_var = match tv {\n                         InferTy::TypeVar(_) => InferTy::TypeVar(root),\n                         InferTy::IntVar(_) => InferTy::IntVar(root),\n@@ -153,10 +159,268 @@ impl<T> Canonicalized<T> {\n         solution: Canonical<Vec<Ty>>,\n     ) {\n         // the solution may contain new variables, which we need to convert to new inference vars\n-        let new_vars = Substs((0..solution.num_vars).map(|_| ctx.new_type_var()).collect());\n+        let new_vars = Substs((0..solution.num_vars).map(|_| ctx.table.new_type_var()).collect());\n         for (i, ty) in solution.value.into_iter().enumerate() {\n             let var = self.free_vars[i];\n-            ctx.unify(&Ty::Infer(var), &ty.subst_bound_vars(&new_vars));\n+            ctx.table.unify(&Ty::Infer(var), &ty.subst_bound_vars(&new_vars));\n+        }\n+    }\n+}\n+\n+pub fn unify(ty1: Canonical<&Ty>, ty2: &Ty) -> Option<Substs> {\n+    let mut table = InferenceTable::new();\n+    let vars =\n+        Substs::builder(ty1.num_vars).fill(std::iter::repeat_with(|| table.new_type_var())).build();\n+    let ty_with_vars = ty1.value.clone().subst_bound_vars(&vars);\n+    if !table.unify(&ty_with_vars, ty2) {\n+        return None;\n+    }\n+    Some(\n+        Substs::builder(ty1.num_vars)\n+            .fill(vars.iter().map(|v| table.resolve_ty_completely(v.clone())))\n+            .build(),\n+    )\n+}\n+\n+#[derive(Clone, Debug)]\n+pub(crate) struct InferenceTable {\n+    pub(super) var_unification_table: InPlaceUnificationTable<TypeVarId>,\n+}\n+\n+impl InferenceTable {\n+    pub fn new() -> Self {\n+        InferenceTable { var_unification_table: InPlaceUnificationTable::new() }\n+    }\n+\n+    pub fn new_type_var(&mut self) -> Ty {\n+        Ty::Infer(InferTy::TypeVar(self.var_unification_table.new_key(TypeVarValue::Unknown)))\n+    }\n+\n+    pub fn new_integer_var(&mut self) -> Ty {\n+        Ty::Infer(InferTy::IntVar(self.var_unification_table.new_key(TypeVarValue::Unknown)))\n+    }\n+\n+    pub fn new_float_var(&mut self) -> Ty {\n+        Ty::Infer(InferTy::FloatVar(self.var_unification_table.new_key(TypeVarValue::Unknown)))\n+    }\n+\n+    pub fn new_maybe_never_type_var(&mut self) -> Ty {\n+        Ty::Infer(InferTy::MaybeNeverTypeVar(\n+            self.var_unification_table.new_key(TypeVarValue::Unknown),\n+        ))\n+    }\n+\n+    pub fn resolve_ty_completely(&mut self, ty: Ty) -> Ty {\n+        self.resolve_ty_completely_inner(&mut Vec::new(), ty)\n+    }\n+\n+    pub fn resolve_ty_as_possible(&mut self, ty: Ty) -> Ty {\n+        self.resolve_ty_as_possible_inner(&mut Vec::new(), ty)\n+    }\n+\n+    pub fn unify(&mut self, ty1: &Ty, ty2: &Ty) -> bool {\n+        self.unify_inner(ty1, ty2, 0)\n+    }\n+\n+    pub fn unify_substs(&mut self, substs1: &Substs, substs2: &Substs, depth: usize) -> bool {\n+        substs1.0.iter().zip(substs2.0.iter()).all(|(t1, t2)| self.unify_inner(t1, t2, depth))\n+    }\n+\n+    fn unify_inner(&mut self, ty1: &Ty, ty2: &Ty, depth: usize) -> bool {\n+        if depth > 1000 {\n+            // prevent stackoverflows\n+            panic!(\"infinite recursion in unification\");\n+        }\n+        if ty1 == ty2 {\n+            return true;\n+        }\n+        // try to resolve type vars first\n+        let ty1 = self.resolve_ty_shallow(ty1);\n+        let ty2 = self.resolve_ty_shallow(ty2);\n+        match (&*ty1, &*ty2) {\n+            (Ty::Apply(a_ty1), Ty::Apply(a_ty2)) if a_ty1.ctor == a_ty2.ctor => {\n+                self.unify_substs(&a_ty1.parameters, &a_ty2.parameters, depth + 1)\n+            }\n+            _ => self.unify_inner_trivial(&ty1, &ty2),\n+        }\n+    }\n+\n+    pub(super) fn unify_inner_trivial(&mut self, ty1: &Ty, ty2: &Ty) -> bool {\n+        match (ty1, ty2) {\n+            (Ty::Unknown, _) | (_, Ty::Unknown) => true,\n+\n+            (Ty::Infer(InferTy::TypeVar(tv1)), Ty::Infer(InferTy::TypeVar(tv2)))\n+            | (Ty::Infer(InferTy::IntVar(tv1)), Ty::Infer(InferTy::IntVar(tv2)))\n+            | (Ty::Infer(InferTy::FloatVar(tv1)), Ty::Infer(InferTy::FloatVar(tv2)))\n+            | (\n+                Ty::Infer(InferTy::MaybeNeverTypeVar(tv1)),\n+                Ty::Infer(InferTy::MaybeNeverTypeVar(tv2)),\n+            ) => {\n+                // both type vars are unknown since we tried to resolve them\n+                self.var_unification_table.union(*tv1, *tv2);\n+                true\n+            }\n+\n+            // The order of MaybeNeverTypeVar matters here.\n+            // Unifying MaybeNeverTypeVar and TypeVar will let the latter become MaybeNeverTypeVar.\n+            // Unifying MaybeNeverTypeVar and other concrete type will let the former become it.\n+            (Ty::Infer(InferTy::TypeVar(tv)), other)\n+            | (other, Ty::Infer(InferTy::TypeVar(tv)))\n+            | (Ty::Infer(InferTy::MaybeNeverTypeVar(tv)), other)\n+            | (other, Ty::Infer(InferTy::MaybeNeverTypeVar(tv)))\n+            | (Ty::Infer(InferTy::IntVar(tv)), other @ ty_app!(TypeCtor::Int(_)))\n+            | (other @ ty_app!(TypeCtor::Int(_)), Ty::Infer(InferTy::IntVar(tv)))\n+            | (Ty::Infer(InferTy::FloatVar(tv)), other @ ty_app!(TypeCtor::Float(_)))\n+            | (other @ ty_app!(TypeCtor::Float(_)), Ty::Infer(InferTy::FloatVar(tv))) => {\n+                // the type var is unknown since we tried to resolve it\n+                self.var_unification_table.union_value(*tv, TypeVarValue::Known(other.clone()));\n+                true\n+            }\n+\n+            _ => false,\n+        }\n+    }\n+\n+    /// If `ty` is a type variable with known type, returns that type;\n+    /// otherwise, return ty.\n+    pub fn resolve_ty_shallow<'b>(&mut self, ty: &'b Ty) -> Cow<'b, Ty> {\n+        let mut ty = Cow::Borrowed(ty);\n+        // The type variable could resolve to a int/float variable. Hence try\n+        // resolving up to three times; each type of variable shouldn't occur\n+        // more than once\n+        for i in 0..3 {\n+            if i > 0 {\n+                tested_by!(type_var_resolves_to_int_var);\n+            }\n+            match &*ty {\n+                Ty::Infer(tv) => {\n+                    let inner = tv.to_inner();\n+                    match self.var_unification_table.inlined_probe_value(inner).known() {\n+                        Some(known_ty) => {\n+                            // The known_ty can't be a type var itself\n+                            ty = Cow::Owned(known_ty.clone());\n+                        }\n+                        _ => return ty,\n+                    }\n+                }\n+                _ => return ty,\n+            }\n+        }\n+        log::error!(\"Inference variable still not resolved: {:?}\", ty);\n+        ty\n+    }\n+\n+    /// Resolves the type as far as currently possible, replacing type variables\n+    /// by their known types. All types returned by the infer_* functions should\n+    /// be resolved as far as possible, i.e. contain no type variables with\n+    /// known type.\n+    fn resolve_ty_as_possible_inner(&mut self, tv_stack: &mut Vec<TypeVarId>, ty: Ty) -> Ty {\n+        ty.fold(&mut |ty| match ty {\n+            Ty::Infer(tv) => {\n+                let inner = tv.to_inner();\n+                if tv_stack.contains(&inner) {\n+                    tested_by!(type_var_cycles_resolve_as_possible);\n+                    // recursive type\n+                    return tv.fallback_value();\n+                }\n+                if let Some(known_ty) =\n+                    self.var_unification_table.inlined_probe_value(inner).known()\n+                {\n+                    // known_ty may contain other variables that are known by now\n+                    tv_stack.push(inner);\n+                    let result = self.resolve_ty_as_possible_inner(tv_stack, known_ty.clone());\n+                    tv_stack.pop();\n+                    result\n+                } else {\n+                    ty\n+                }\n+            }\n+            _ => ty,\n+        })\n+    }\n+\n+    /// Resolves the type completely; type variables without known type are\n+    /// replaced by Ty::Unknown.\n+    fn resolve_ty_completely_inner(&mut self, tv_stack: &mut Vec<TypeVarId>, ty: Ty) -> Ty {\n+        ty.fold(&mut |ty| match ty {\n+            Ty::Infer(tv) => {\n+                let inner = tv.to_inner();\n+                if tv_stack.contains(&inner) {\n+                    tested_by!(type_var_cycles_resolve_completely);\n+                    // recursive type\n+                    return tv.fallback_value();\n+                }\n+                if let Some(known_ty) =\n+                    self.var_unification_table.inlined_probe_value(inner).known()\n+                {\n+                    // known_ty may contain other variables that are known by now\n+                    tv_stack.push(inner);\n+                    let result = self.resolve_ty_completely_inner(tv_stack, known_ty.clone());\n+                    tv_stack.pop();\n+                    result\n+                } else {\n+                    tv.fallback_value()\n+                }\n+            }\n+            _ => ty,\n+        })\n+    }\n+}\n+\n+/// The ID of a type variable.\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+pub struct TypeVarId(pub(super) u32);\n+\n+impl UnifyKey for TypeVarId {\n+    type Value = TypeVarValue;\n+\n+    fn index(&self) -> u32 {\n+        self.0\n+    }\n+\n+    fn from_index(i: u32) -> Self {\n+        TypeVarId(i)\n+    }\n+\n+    fn tag() -> &'static str {\n+        \"TypeVarId\"\n+    }\n+}\n+\n+/// The value of a type variable: either we already know the type, or we don't\n+/// know it yet.\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub enum TypeVarValue {\n+    Known(Ty),\n+    Unknown,\n+}\n+\n+impl TypeVarValue {\n+    fn known(&self) -> Option<&Ty> {\n+        match self {\n+            TypeVarValue::Known(ty) => Some(ty),\n+            TypeVarValue::Unknown => None,\n+        }\n+    }\n+}\n+\n+impl UnifyValue for TypeVarValue {\n+    type Error = NoError;\n+\n+    fn unify_values(value1: &Self, value2: &Self) -> Result<Self, NoError> {\n+        match (value1, value2) {\n+            // We should never equate two type variables, both of which have\n+            // known types. Instead, we recursively equate those types.\n+            (TypeVarValue::Known(t1), TypeVarValue::Known(t2)) => panic!(\n+                \"equating two type variables, both of which have known types: {:?} and {:?}\",\n+                t1, t2\n+            ),\n+\n+            // If one side is known, prefer that one.\n+            (TypeVarValue::Known(..), TypeVarValue::Unknown) => Ok(value1.clone()),\n+            (TypeVarValue::Unknown, TypeVarValue::Known(..)) => Ok(value2.clone()),\n+\n+            (TypeVarValue::Unknown, TypeVarValue::Unknown) => Ok(TypeVarValue::Unknown),\n         }\n     }\n }"}, {"sha": "21efb196af19ac88072866ee99bc0cc73539a074", "filename": "crates/ra_hir_ty/src/method_resolution.rs", "status": "modified", "additions": 186, "deletions": 39, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/c5be0cedf3a9d56c17d988ce6354599b85198fb8/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5be0cedf3a9d56c17d988ce6354599b85198fb8/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs?ref=c5be0cedf3a9d56c17d988ce6354599b85198fb8", "patch": "@@ -7,19 +7,20 @@ use std::sync::Arc;\n use arrayvec::ArrayVec;\n use hir_def::{\n     lang_item::LangItemTarget, resolver::Resolver, type_ref::Mutability, AssocItemId, AstItemDef,\n-    FunctionId, HasModule, ImplId, TraitId,\n+    FunctionId, HasModule, ImplId, Lookup, TraitId,\n };\n use hir_expand::name::Name;\n use ra_db::CrateId;\n use ra_prof::profile;\n use rustc_hash::FxHashMap;\n \n+use super::Substs;\n use crate::{\n     autoderef,\n     db::HirDatabase,\n     primitive::{FloatBitness, Uncertain},\n     utils::all_super_traits,\n-    Canonical, InEnvironment, TraitEnvironment, TraitRef, Ty, TypeCtor,\n+    Canonical, InEnvironment, TraitEnvironment, TraitRef, Ty, TypeCtor, TypeWalk,\n };\n \n /// This is used as a key for indexing impls.\n@@ -176,7 +177,6 @@ pub fn iterate_method_candidates<T>(\n     mode: LookupMode,\n     mut callback: impl FnMut(&Ty, AssocItemId) -> Option<T>,\n ) -> Option<T> {\n-    let krate = resolver.krate()?;\n     match mode {\n         LookupMode::MethodCall => {\n             // For method calls, rust first does any number of autoderef, and then one\n@@ -189,57 +189,159 @@ pub fn iterate_method_candidates<T>(\n             // rustc does an autoderef and then autoref again).\n             let environment = TraitEnvironment::lower(db, resolver);\n             let ty = InEnvironment { value: ty.clone(), environment };\n-            for derefed_ty in autoderef::autoderef(db, resolver.krate(), ty) {\n-                if let Some(result) =\n-                    iterate_inherent_methods(&derefed_ty, db, name, mode, krate, &mut callback)\n-                {\n-                    return Some(result);\n-                }\n-                if let Some(result) = iterate_trait_method_candidates(\n-                    &derefed_ty,\n+            let krate = resolver.krate()?;\n+\n+            // We have to be careful about the order we're looking at candidates\n+            // in here. Consider the case where we're resolving `x.clone()`\n+            // where `x: &Vec<_>`. This resolves to the clone method with self\n+            // type `Vec<_>`, *not* `&_`. I.e. we need to consider methods where\n+            // the receiver type exactly matches before cases where we have to\n+            // do autoref. But in the autoderef steps, the `&_` self type comes\n+            // up *before* the `Vec<_>` self type.\n+            //\n+            // On the other hand, we don't want to just pick any by-value method\n+            // before any by-autoref method; it's just that we need to consider\n+            // the methods by autoderef order of *receiver types*, not *self\n+            // types*.\n+\n+            let deref_chain: Vec<_> = autoderef::autoderef(db, Some(krate), ty.clone()).collect();\n+            for i in 0..deref_chain.len() {\n+                if let Some(result) = iterate_method_candidates_with_autoref(\n+                    &deref_chain[i..],\n                     db,\n                     resolver,\n                     name,\n-                    mode,\n                     &mut callback,\n                 ) {\n                     return Some(result);\n                 }\n             }\n+            None\n         }\n         LookupMode::Path => {\n             // No autoderef for path lookups\n-            if let Some(result) =\n-                iterate_inherent_methods(&ty, db, name, mode, krate.into(), &mut callback)\n-            {\n-                return Some(result);\n-            }\n-            if let Some(result) =\n-                iterate_trait_method_candidates(&ty, db, resolver, name, mode, &mut callback)\n-            {\n-                return Some(result);\n-            }\n+            iterate_method_candidates_for_self_ty(&ty, db, resolver, name, &mut callback)\n+        }\n+    }\n+}\n+\n+fn iterate_method_candidates_with_autoref<T>(\n+    deref_chain: &[Canonical<Ty>],\n+    db: &impl HirDatabase,\n+    resolver: &Resolver,\n+    name: Option<&Name>,\n+    mut callback: impl FnMut(&Ty, AssocItemId) -> Option<T>,\n+) -> Option<T> {\n+    if let Some(result) = iterate_method_candidates_by_receiver(\n+        &deref_chain[0],\n+        &deref_chain[1..],\n+        db,\n+        resolver,\n+        name,\n+        &mut callback,\n+    ) {\n+        return Some(result);\n+    }\n+    let refed = Canonical {\n+        num_vars: deref_chain[0].num_vars,\n+        value: Ty::apply_one(TypeCtor::Ref(Mutability::Shared), deref_chain[0].value.clone()),\n+    };\n+    if let Some(result) = iterate_method_candidates_by_receiver(\n+        &refed,\n+        deref_chain,\n+        db,\n+        resolver,\n+        name,\n+        &mut callback,\n+    ) {\n+        return Some(result);\n+    }\n+    let ref_muted = Canonical {\n+        num_vars: deref_chain[0].num_vars,\n+        value: Ty::apply_one(TypeCtor::Ref(Mutability::Mut), deref_chain[0].value.clone()),\n+    };\n+    if let Some(result) = iterate_method_candidates_by_receiver(\n+        &ref_muted,\n+        deref_chain,\n+        db,\n+        resolver,\n+        name,\n+        &mut callback,\n+    ) {\n+        return Some(result);\n+    }\n+    None\n+}\n+\n+fn iterate_method_candidates_by_receiver<T>(\n+    receiver_ty: &Canonical<Ty>,\n+    rest_of_deref_chain: &[Canonical<Ty>],\n+    db: &impl HirDatabase,\n+    resolver: &Resolver,\n+    name: Option<&Name>,\n+    mut callback: impl FnMut(&Ty, AssocItemId) -> Option<T>,\n+) -> Option<T> {\n+    // We're looking for methods with *receiver* type receiver_ty. These could\n+    // be found in any of the derefs of receiver_ty, so we have to go through\n+    // that.\n+    let krate = resolver.krate()?;\n+    for self_ty in std::iter::once(receiver_ty).chain(rest_of_deref_chain) {\n+        if let Some(result) =\n+            iterate_inherent_methods(self_ty, db, name, Some(receiver_ty), krate, &mut callback)\n+        {\n+            return Some(result);\n+        }\n+    }\n+    for self_ty in std::iter::once(receiver_ty).chain(rest_of_deref_chain) {\n+        if let Some(result) = iterate_trait_method_candidates(\n+            self_ty,\n+            db,\n+            resolver,\n+            name,\n+            Some(receiver_ty),\n+            &mut callback,\n+        ) {\n+            return Some(result);\n         }\n     }\n     None\n }\n \n+fn iterate_method_candidates_for_self_ty<T>(\n+    self_ty: &Canonical<Ty>,\n+    db: &impl HirDatabase,\n+    resolver: &Resolver,\n+    name: Option<&Name>,\n+    mut callback: impl FnMut(&Ty, AssocItemId) -> Option<T>,\n+) -> Option<T> {\n+    let krate = resolver.krate()?;\n+    if let Some(result) = iterate_inherent_methods(self_ty, db, name, None, krate, &mut callback) {\n+        return Some(result);\n+    }\n+    if let Some(result) =\n+        iterate_trait_method_candidates(self_ty, db, resolver, name, None, &mut callback)\n+    {\n+        return Some(result);\n+    }\n+    None\n+}\n+\n fn iterate_trait_method_candidates<T>(\n-    ty: &Canonical<Ty>,\n+    self_ty: &Canonical<Ty>,\n     db: &impl HirDatabase,\n     resolver: &Resolver,\n     name: Option<&Name>,\n-    mode: LookupMode,\n+    receiver_ty: Option<&Canonical<Ty>>,\n     mut callback: impl FnMut(&Ty, AssocItemId) -> Option<T>,\n ) -> Option<T> {\n     let krate = resolver.krate()?;\n     // FIXME: maybe put the trait_env behind a query (need to figure out good input parameters for that)\n     let env = TraitEnvironment::lower(db, resolver);\n     // if ty is `impl Trait` or `dyn Trait`, the trait doesn't need to be in scope\n-    let inherent_trait = ty.value.inherent_trait().into_iter();\n+    let inherent_trait = self_ty.value.inherent_trait().into_iter();\n     // if we have `T: Trait` in the param env, the trait doesn't need to be in scope\n     let traits_from_env = env\n-        .trait_predicates_for_self_ty(&ty.value)\n+        .trait_predicates_for_self_ty(&self_ty.value)\n         .map(|tr| tr.trait_)\n         .flat_map(|t| all_super_traits(db, t));\n     let traits =\n@@ -252,17 +354,17 @@ fn iterate_trait_method_candidates<T>(\n         // iteration\n         let mut known_implemented = false;\n         for (_name, item) in data.items.iter() {\n-            if !is_valid_candidate(db, name, mode, (*item).into()) {\n+            if !is_valid_candidate(db, name, receiver_ty, (*item).into(), self_ty) {\n                 continue;\n             }\n             if !known_implemented {\n-                let goal = generic_implements_goal(db, env.clone(), t, ty.clone());\n+                let goal = generic_implements_goal(db, env.clone(), t, self_ty.clone());\n                 if db.trait_solve(krate.into(), goal).is_none() {\n                     continue 'traits;\n                 }\n             }\n             known_implemented = true;\n-            if let Some(result) = callback(&ty.value, (*item).into()) {\n+            if let Some(result) = callback(&self_ty.value, (*item).into()) {\n                 return Some(result);\n             }\n         }\n@@ -271,22 +373,22 @@ fn iterate_trait_method_candidates<T>(\n }\n \n fn iterate_inherent_methods<T>(\n-    ty: &Canonical<Ty>,\n+    self_ty: &Canonical<Ty>,\n     db: &impl HirDatabase,\n     name: Option<&Name>,\n-    mode: LookupMode,\n+    receiver_ty: Option<&Canonical<Ty>>,\n     krate: CrateId,\n     mut callback: impl FnMut(&Ty, AssocItemId) -> Option<T>,\n ) -> Option<T> {\n-    for krate in ty.value.def_crates(db, krate)? {\n+    for krate in self_ty.value.def_crates(db, krate)? {\n         let impls = db.impls_in_crate(krate);\n \n-        for impl_block in impls.lookup_impl_blocks(&ty.value) {\n+        for impl_block in impls.lookup_impl_blocks(&self_ty.value) {\n             for &item in db.impl_data(impl_block).items.iter() {\n-                if !is_valid_candidate(db, name, mode, item) {\n+                if !is_valid_candidate(db, name, receiver_ty, item, self_ty) {\n                     continue;\n                 }\n-                if let Some(result) = callback(&ty.value, item.into()) {\n+                if let Some(result) = callback(&self_ty.value, item) {\n                     return Some(result);\n                 }\n             }\n@@ -298,23 +400,68 @@ fn iterate_inherent_methods<T>(\n fn is_valid_candidate(\n     db: &impl HirDatabase,\n     name: Option<&Name>,\n-    mode: LookupMode,\n+    receiver_ty: Option<&Canonical<Ty>>,\n     item: AssocItemId,\n+    self_ty: &Canonical<Ty>,\n ) -> bool {\n     match item {\n         AssocItemId::FunctionId(m) => {\n             let data = db.function_data(m);\n-            name.map_or(true, |name| &data.name == name)\n-                && (data.has_self_param || mode == LookupMode::Path)\n+            if let Some(name) = name {\n+                if &data.name != name {\n+                    return false;\n+                }\n+            }\n+            if let Some(receiver_ty) = receiver_ty {\n+                if !data.has_self_param {\n+                    return false;\n+                }\n+                let transformed_receiver_ty = match transform_receiver_ty(db, m, self_ty) {\n+                    Some(ty) => ty,\n+                    None => return false,\n+                };\n+                if transformed_receiver_ty != receiver_ty.value {\n+                    return false;\n+                }\n+            }\n+            true\n         }\n         AssocItemId::ConstId(c) => {\n             let data = db.const_data(c);\n-            name.map_or(true, |name| data.name.as_ref() == Some(name)) && (mode == LookupMode::Path)\n+            name.map_or(true, |name| data.name.as_ref() == Some(name)) && receiver_ty.is_none()\n         }\n         _ => false,\n     }\n }\n \n+pub(crate) fn inherent_impl_substs(\n+    db: &impl HirDatabase,\n+    impl_id: ImplId,\n+    self_ty: &Ty,\n+) -> Option<Substs> {\n+    let vars = Substs::build_for_def(db, impl_id).fill_with_bound_vars(0).build();\n+    let self_ty_with_vars = db.impl_self_ty(impl_id).subst(&vars);\n+    let self_ty_with_vars = Canonical { num_vars: vars.len(), value: &self_ty_with_vars };\n+    super::infer::unify(self_ty_with_vars, self_ty)\n+}\n+\n+fn transform_receiver_ty(\n+    db: &impl HirDatabase,\n+    function_id: FunctionId,\n+    self_ty: &Canonical<Ty>,\n+) -> Option<Ty> {\n+    let substs = match function_id.lookup(db).container {\n+        hir_def::ContainerId::TraitId(_) => Substs::build_for_def(db, function_id)\n+            .push(self_ty.value.clone())\n+            .fill_with_unknown()\n+            .build(),\n+        hir_def::ContainerId::ImplId(impl_id) => inherent_impl_substs(db, impl_id, &self_ty.value)?,\n+        hir_def::ContainerId::ModuleId(_) => unreachable!(),\n+    };\n+    let sig = db.callable_item_signature(function_id.into());\n+    Some(sig.params()[0].clone().subst(&substs))\n+}\n+\n pub fn implements_trait(\n     ty: &Canonical<Ty>,\n     db: &impl HirDatabase,"}, {"sha": "d5b8d10e2a3ce601b185b9593b4026d8d3ede6c4", "filename": "crates/ra_hir_ty/src/tests.rs", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c5be0cedf3a9d56c17d988ce6354599b85198fb8/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5be0cedf3a9d56c17d988ce6354599b85198fb8/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs?ref=c5be0cedf3a9d56c17d988ce6354599b85198fb8", "patch": "@@ -3433,7 +3433,20 @@ pub fn baz() -> usize { 31usize }\n     assert_eq!(\"(i32, usize)\", type_at_pos(&db, pos));\n }\n \n-#[ignore]\n+#[test]\n+fn method_resolution_unify_impl_self_type() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+struct S<T>;\n+impl S<u32> { fn foo(&self) -> u8 {} }\n+impl S<i32> { fn foo(&self) -> i8 {} }\n+fn test() { (S::<u32>.foo(), S::<i32>.foo())<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"(u8, i8)\");\n+}\n+\n #[test]\n fn method_resolution_trait_before_autoref() {\n     let t = type_at(\n@@ -3449,7 +3462,6 @@ fn test() { S.foo()<|>; }\n     assert_eq!(t, \"u128\");\n }\n \n-#[ignore]\n #[test]\n fn method_resolution_by_value_before_autoref() {\n     let t = type_at(\n@@ -3495,6 +3507,21 @@ fn test() { S.foo()<|>; }\n     assert_eq!(t, \"i8\");\n }\n \n+#[test]\n+fn method_resolution_impl_ref_before_trait() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Trait { fn foo(self) -> u128; }\n+struct S;\n+impl S { fn foo(&self) -> i8 { 0 } }\n+impl Trait for &S { fn foo(self) -> u128 { 0 } }\n+fn test() { S.foo()<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"i8\");\n+}\n+\n #[test]\n fn method_resolution_trait_autoderef() {\n     let t = type_at("}, {"sha": "a52eb0ee4a6ea62165a650ae1086a7e8ea654a9d", "filename": "crates/ra_ide/src/completion/complete_dot.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/c5be0cedf3a9d56c17d988ce6354599b85198fb8/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5be0cedf3a9d56c17d988ce6354599b85198fb8/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs?ref=c5be0cedf3a9d56c17d988ce6354599b85198fb8", "patch": "@@ -216,6 +216,39 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn test_method_completion_only_fitting_impls() {\n+        assert_debug_snapshot!(\n+            do_ref_completion(\n+                r\"\n+            struct A<T> {}\n+            impl A<u32> {\n+                fn the_method(&self) {}\n+            }\n+            impl A<i32> {\n+                fn the_other_method(&self) {}\n+            }\n+            fn foo(a: A<u32>) {\n+               a.<|>\n+            }\n+            \",\n+            ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"the_method()\",\n+                source_range: [243; 243),\n+                delete: [243; 243),\n+                insert: \"the_method()$0\",\n+                kind: Method,\n+                lookup: \"the_method\",\n+                detail: \"fn the_method(&self)\",\n+            },\n+        ]\n+        \"###\n+        );\n+    }\n+\n     #[test]\n     fn test_trait_method_completion() {\n         assert_debug_snapshot!("}]}