{"sha": "d3c6119a7a68732ff95efdec356ac7abb0f6f6f4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzYzYxMTlhN2E2ODczMmZmOTVlZmRlYzM1NmFjN2FiYjBmNmY2ZjQ=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-06-27T20:14:04Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-06-27T20:30:49Z"}, "message": "More keyword paring and migration in runtime, docs, code modes.", "tree": {"sha": "07ade2378a2bdd2c704ddf2376dfe2c1ba24cd3b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/07ade2378a2bdd2c704ddf2376dfe2c1ba24cd3b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d3c6119a7a68732ff95efdec356ac7abb0f6f6f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d3c6119a7a68732ff95efdec356ac7abb0f6f6f4", "html_url": "https://github.com/rust-lang/rust/commit/d3c6119a7a68732ff95efdec356ac7abb0f6f6f4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d3c6119a7a68732ff95efdec356ac7abb0f6f6f4/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f0565be49a4263ca0582acc64102051da1434cff", "url": "https://api.github.com/repos/rust-lang/rust/commits/f0565be49a4263ca0582acc64102051da1434cff", "html_url": "https://github.com/rust-lang/rust/commit/f0565be49a4263ca0582acc64102051da1434cff"}], "stats": {"total": 226, "additions": 116, "deletions": 110}, "files": [{"sha": "303789f553642ba5947560729c34da328b447b88", "filename": "RELEASES.txt", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d3c6119a7a68732ff95efdec356ac7abb0f6f6f4/RELEASES.txt", "raw_url": "https://github.com/rust-lang/rust/raw/d3c6119a7a68732ff95efdec356ac7abb0f6f6f4/RELEASES.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.txt?ref=d3c6119a7a68732ff95efdec356ac7abb0f6f6f4", "patch": "@@ -23,8 +23,10 @@ Version 0.3  (June 2012) - not yet!\n     * Type reflection\n \n   * Removal of various obsolete features\n-    * Keywords: be, prove, syntax, note, mutable, do, bind\n-    * Constructs: do-while loops, fn binding, resources\n+    * Keywords: 'be', 'prove', 'syntax', 'note', 'mutable',\n+                'bind', 'crust', 'native' (now 'extern')\n+    * Constructs: do-while loops ('do' repurposed),\n+                  fn binding, resources\n \n   * Compiler reorganization\n     * Syntax-layer of compiler split into separate crate\n@@ -39,7 +41,7 @@ Version 0.3  (June 2012) - not yet!\n     * Extensive work on libuv interface\n     * Much vector code moved to libraries\n     * Syntax extensions: #line, #col, #file, #mod,\n-      #stringify, #include, #include_str, #include_bin.\n+      #stringify, #include, #include_str, #include_bin\n \n   * Tool improvements\n     * Cargo automatically resolves dependencies"}, {"sha": "6a1ec76645373c910bbf27b74f0d9b3ca032efc5", "filename": "doc/lib/codemirror-rust.js", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3c6119a7a68732ff95efdec356ac7abb0f6f6f4/doc%2Flib%2Fcodemirror-rust.js", "raw_url": "https://github.com/rust-lang/rust/raw/d3c6119a7a68732ff95efdec356ac7abb0f6f6f4/doc%2Flib%2Fcodemirror-rust.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Flib%2Fcodemirror-rust.js?ref=d3c6119a7a68732ff95efdec356ac7abb0f6f6f4", "patch": "@@ -7,12 +7,12 @@ CodeMirror.defineMode(\"rust\", function() {\n     \"let\": \"let\", \"fn\": \"fn\", \"for\": \"for\", \"alt\": \"alt\", \"iface\": \"iface\",\n     \"impl\": \"impl\", \"type\": \"type\", \"enum\": \"enum\", \"mod\": \"mod\",\n     \"as\": \"op\", \"true\": \"atom\", \"false\": \"atom\", \"assert\": \"op\", \"check\": \"op\",\n-    \"claim\": \"op\", \"native\": \"ignore\", \"unsafe\": \"ignore\", \"import\": \"else-style\",\n+    \"claim\": \"op\", \"extern\": \"ignore\", \"unsafe\": \"ignore\", \"import\": \"else-style\",\n     \"export\": \"else-style\", \"copy\": \"op\", \"log\": \"op\", \"log_err\": \"op\",\n     \"use\": \"op\", \"bind\": \"op\", \"self\": \"atom\"\n   };\n   var typeKeywords = function() {\n-    var keywords = {\"fn\": \"fn\", \"block\": \"fn\", \"obj\": \"obj\"};\n+    var keywords = {\"fn\": \"fn\"};\n     var atoms = \"bool uint int i8 i16 i32 i64 u8 u16 u32 u64 float f32 f64 str char\".split(\" \");\n     for (var i = 0, e = atoms.length; i < e; ++i) keywords[atoms[i]] = \"atom\";\n     return keywords;"}, {"sha": "697dd3cb48a498a7e2029c54dfb54126764fa045", "filename": "doc/rust.md", "status": "modified", "additions": 44, "deletions": 43, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/d3c6119a7a68732ff95efdec356ac7abb0f6f6f4/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/d3c6119a7a68732ff95efdec356ac7abb0f6f6f4/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=d3c6119a7a68732ff95efdec356ac7abb0f6f6f4", "patch": "@@ -210,17 +210,16 @@ The keywords in [source files](#source-files) are the following strings:\n \n ~~~~~~~~ {.keyword}\n alt assert\n-be break\n-check claim class const cont copy crust\n+break\n+check claim class const cont copy\n drop\n-else enum export\n+else enum export extern\n fail false fn for\n if iface impl import\n let log loop\n mod mut\n-native new\n pure\n-resource ret\n+ret\n true trait type\n unchecked unsafe\n while\n@@ -575,7 +574,7 @@ of [attributes](#attributes) attached to it.\n \n ~~~~~~~~ {.ebnf .gram}\n item : mod_item | fn_item | type_item | enum_item\n-     | res_item | iface_item | impl_item | native_mod_item ;\n+     | res_item | iface_item | impl_item | foreign_mod_item ;\n ~~~~~~~~\n \n An _item_ is a component of a crate; some module items can be defined in crate\n@@ -1039,29 +1038,29 @@ Similarly, [interface](#interfaces) bounds can be specified for type\n parameters to allow methods of that interface to be called on values\n of that type.\n \n-#### Crust functions\n+#### Extern functions\n \n-Crust functions are part of Rust's foreign function interface,\n-providing the opposite functionality to [native modules](#native-modules).\n-Whereas native modules allow Rust code to call foreign\n-code, crust functions allow foreign code to call Rust code. They are\n-defined the same as any other Rust function, except that they are\n-prepended with the `crust` keyword.\n+Extern functions are part of Rust's foreign function interface, providing\n+the opposite functionality to [foreign modules](#foreign-modules). Whereas\n+foreign modules allow Rust code to call foreign code, extern functions with\n+bodies defined in Rust code _can be called by foreign code_. They are defined the\n+same as any other Rust function, except that they are prepended with the\n+`extern` keyword.\n \n ~~~\n-crust fn new_vec() -> [int] { [] }\n+extern fn new_vec() -> [int] { [] }\n ~~~\n \n-Crust functions may not be called from Rust code, but their value\n+Extern functions may not be called from Rust code, but their value\n may be taken as an unsafe `u8` pointer.\n \n ~~~\n-# crust fn new_vec() -> [int] { [] }\n+# extern fn new_vec() -> [int] { [] }\n let fptr: *u8 = new_vec;\n ~~~\n \n-The primary motivation of crust functions is to create callbacks\n-for native functions that expect to receive function pointers.\n+The primary motivation of extern functions is to create callbacks\n+for foreign functions that expect to receive function pointers.\n \n ### Type definitions\n \n@@ -1298,63 +1297,65 @@ impl of seq<bool> for u32 {\n }\n ~~~~\n \n-### Native modules\n+### Foreign modules\n \n ~~~ {.ebnf .gram}\n-native_mod_item : \"native mod\" ident '{' native_mod '} ;\n-native_mod : [ native_fn ] * ;\n+foreign_mod_item : \"extern mod\" ident '{' foreign_mod '} ;\n+foreign_mod : [ foreign_fn ] * ;\n ~~~\n \n-Native modules form the basis for Rust's foreign function interface. A native\n-module describes functions in external, non-Rust libraries. Functions within\n-native modules are declared the same as other Rust functions, with the exception\n-that they may not have a body and are instead terminated by a semi-colon.\n+Foreign modules form the basis for Rust's foreign function interface. A\n+foreign module describes functions in external, non-Rust\n+libraries. Functions within foreign modules are declared the same as other\n+Rust functions, with the exception that they may not have a body and are\n+instead terminated by a semi-colon.\n \n ~~~\n # import libc::{c_char, FILE};\n # #[nolink]\n \n-native mod c {\n+extern mod c {\n     fn fopen(filename: *c_char, mode: *c_char) -> *FILE;\n }\n ~~~\n \n-Functions within native modules may be called by Rust code as it would any\n+Functions within foreign modules may be called by Rust code as it would any\n normal function and the Rust compiler will automatically translate between\n-the Rust ABI and the native ABI.\n+the Rust ABI and the foreign ABI.\n \n-The name of the native module has special meaning to the Rust compiler in\n+The name of the foreign module has special meaning to the Rust compiler in\n that it will treat the module name as the name of a library to link to,\n performing the linking as appropriate for the target platform. The name\n-given for the native module will be transformed in a platform-specific\n-way to determine the name of the library. For example, on Linux the name\n-of the native module is prefixed with 'lib' and suffixed with '.so', so\n-the native mod 'rustrt' would be linked to a library named 'librustrt.so'.\n+given for the foreign module will be transformed in a platform-specific way\n+to determine the name of the library. For example, on Linux the name of the\n+foreign module is prefixed with 'lib' and suffixed with '.so', so the\n+foreign mod 'rustrt' would be linked to a library named 'librustrt.so'.\n \n-A number of [attributes](#attributes) control the behavior of native mods.\n+A number of [attributes](#attributes) control the behavior of foreign\n+modules.\n \n-By default native mods assume that the library they are calling use\n-the standard C \"cdecl\" ABI. Other ABI's may be specified using the `abi`\n+By default foreign modules assume that the library they are calling use the\n+standard C \"cdecl\" ABI. Other ABI's may be specified using the `abi`\n attribute as in\n \n ~~~{.xfail-test}\n // Interface to the Windows API\n #[abi = \"stdcall\"]\n-native mod kernel32 { }\n+extern mod kernel32 { }\n ~~~\n \n The `link_name` attribute allows the default library naming behavior to\n be overriden by explicitly specifying the name of the library.\n \n ~~~{.xfail-test}\n #[link_name = \"crypto\"]\n-native mod mycrypto { }\n+extern mod mycrypto { }\n ~~~\n \n The `nolink` attribute tells the Rust compiler not to perform any linking\n-for the native module. This is particularly useful for creating native\n-mods for libc, which tends to not follow standard library naming conventions\n-and is linked to all Rust programs anyway.\n+for the foreign module. This is particularly useful for creating foreign\n+modules for libc, which tends to not follow standard library naming\n+conventions and is linked to all Rust programs anyway.\n \n ## Attributes\n \n@@ -1752,8 +1753,8 @@ A type cast expression is denoted with the binary operator `as`.\n Executing an `as` expression casts the value on the left-hand side to the type\n on the right-hand side.\n \n-A numeric value can be cast to any numeric type.  A native pointer value can\n-be cast to or from any integral type or native pointer type.  Any other cast\n+A numeric value can be cast to any numeric type.  An unsafe pointer value can\n+be cast to or from any integral type or unsafe pointer type.  Any other cast\n is unsupported and will fail to compile.\n \n An example of an `as` expression:"}, {"sha": "3aaa7f30c21f421c9c93282a71b42251724fc931", "filename": "doc/tutorial.md", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/d3c6119a7a68732ff95efdec356ac7abb0f6f6f4/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/d3c6119a7a68732ff95efdec356ac7abb0f6f6f4/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=d3c6119a7a68732ff95efdec356ac7abb0f6f6f4", "patch": "@@ -2106,7 +2106,7 @@ OpenSSL libraries installed, it should 'just work'.\n ~~~~ {.xfail-test}\n use std;\n \n-native mod crypto {\n+extern mod crypto {\n     fn SHA1(src: *u8, sz: uint, out: *u8) -> *u8;\n }\n \n@@ -2128,20 +2128,23 @@ fn main(args: [str]) {\n }\n ~~~~\n \n-## Native modules\n+## Foreign modules\n \n Before we can call `SHA1`, we have to declare it. That is what this\n part of the program is responsible for:\n \n ~~~~ {.xfail-test}\n-native mod crypto {\n+extern mod crypto {\n     fn SHA1(src: *u8, sz: uint, out: *u8) -> *u8;\n }\n ~~~~\n \n-A `native` module declaration tells the compiler that the program\n-should be linked with a library by that name, and that the given list\n-of functions are available in that library.\n+An `extern` module declaration containing function signatures introduces\n+the functions listed as _foreign functions_, that are implemented in some\n+other language (usually C) and accessed through Rust's foreign function\n+interface (FFI). An extern module like this is called a foreign module, and\n+implicitly tells the compiler to link with a library with the same name as\n+the module, and that it will find the foreign functions in that library.\n \n In this case, it'll change the name `crypto` to a shared library name\n in a platform-specific way (`libcrypto.so` on Linux, for example), and\n@@ -2150,38 +2153,38 @@ actual library, you can use the `\"link_name\"` attribute, like:\n \n ~~~~ {.xfail-test}\n #[link_name = \"crypto\"]\n-native mod something {\n+extern mod something {\n     fn SHA1(src: *u8, sz: uint, out: *u8) -> *u8;\n }\n ~~~~\n \n-## Native calling conventions\n+## Foreign calling conventions\n \n-Most native C code use the cdecl calling convention, so that is what\n-Rust uses by default when calling native functions. Some native functions,\n-most notably the Windows API, use other calling conventions, so Rust\n-provides a way to hint to the compiler which is expected by using\n-the `\"abi\"` attribute:\n+Most foreign code will be C code, which usually uses the `cdecl` calling\n+convention, so that is what Rust uses by default when calling foreign\n+functions. Some foreign functions, most notably the Windows API, use other\n+calling conventions, so Rust provides a way to hint to the compiler which\n+is expected by using the `\"abi\"` attribute:\n \n ~~~~\n #[cfg(target_os = \"win32\")]\n #[abi = \"stdcall\"]\n-native mod kernel32 {\n+extern mod kernel32 {\n     fn SetEnvironmentVariableA(n: *u8, v: *u8) -> int;\n }\n ~~~~\n \n-The `\"abi\"` attribute applies to a native mod (it can not be applied\n+The `\"abi\"` attribute applies to a foreign module (it can not be applied\n to a single function within a module), and must be either `\"cdecl\"`\n or `\"stdcall\"`. Other conventions may be defined in the future.\n \n ## Unsafe pointers\n \n-The native `SHA1` function is declared to take three arguments, and\n+The foreign `SHA1` function is declared to take three arguments, and\n return a pointer.\n \n ~~~~ {.xfail-test}\n-# native mod crypto {\n+# extern mod crypto {\n fn SHA1(src: *u8, sz: uint, out: *u8) -> *u8;\n # }\n ~~~~\n@@ -2295,7 +2298,7 @@ use std;\n type timeval = {mut tv_sec: uint,\n                 mut tv_usec: uint};\n #[nolink]\n-native mod libc {\n+extern mod libc {\n     fn gettimeofday(tv: *timeval, tz: *()) -> i32;\n }\n fn unix_time_in_microseconds() -> u64 unsafe {\n@@ -2307,8 +2310,8 @@ fn unix_time_in_microseconds() -> u64 unsafe {\n # fn main() { assert #fmt(\"%?\", unix_time_in_microseconds()) != \"\"; }\n ~~~~\n \n-The `#[nolink]` attribute indicates that there's no native library to link\n-in. The standard C library is already linked with Rust programs.\n+The `#[nolink]` attribute indicates that there's no foreign library to\n+link in. The standard C library is already linked with Rust programs.\n \n A `timeval`, in C, is a struct with two 32-bit integers. Thus, we\n define a record type with the same contents, and declare"}, {"sha": "e8240ae7fafcab447cb91959d0a779fb6f67329a", "filename": "src/etc/emacs/rust-mode.el", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d3c6119a7a68732ff95efdec356ac7abb0f6f6f4/src%2Fetc%2Femacs%2Frust-mode.el", "raw_url": "https://github.com/rust-lang/rust/raw/d3c6119a7a68732ff95efdec356ac7abb0f6f6f4/src%2Fetc%2Femacs%2Frust-mode.el", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Femacs%2Frust-mode.el?ref=d3c6119a7a68732ff95efdec356ac7abb0f6f6f4", "patch": "@@ -52,21 +52,21 @@\n (defvar rust-punc-chars \"()[].,{}:;\")\n (defvar rust-value-keywords\n   (let ((table (make-hash-table :test 'equal)))\n-    (dolist (word '(\"mod\" \"type\" \"resource\" \"fn\" \"enum\" \"iface\" \"impl\"))\n+    (dolist (word '(\"mod\" \"const\" \"class\" \"type\"\n+\t\t\t\t\t\"trait\" \"fn\" \"enum\" \"iface\"\n+\t\t\t\t\t\"impl\"))\n       (puthash word 'def table))\n     (dolist (word '(\"assert\"\n-                    \"be\" \"break\"\n-                    \"check\" \"claim\" \"class\" \"const\" \"cont\" \"copy\" \"crust\"\n+                    \"break\"\n+                    \"check\" \"claim\" \"cont\" \"copy\"\n                     \"drop\"\n-                    \"else\" \"export\"\n+                    \"else\" \"export\" \"extern\"\n                     \"fail\" \"for\"\n                     \"if\" \"import\"\n                     \"let\" \"log\" \"loop\"\n-                    \"mut\"\n-                    \"native\" \"new\"\n+                    \"new\"\n                     \"pure\"\n                     \"ret\"\n-                    \"trait\"\n                     \"unchecked\" \"unsafe\"\n                     \"while\"))\n       (puthash word t table))"}, {"sha": "7c339ed0856cd8629949148bbb8ae55c6ba2a55c", "filename": "src/etc/vim/syntax/rust.vim", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d3c6119a7a68732ff95efdec356ac7abb0f6f6f4/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim", "raw_url": "https://github.com/rust-lang/rust/raw/d3c6119a7a68732ff95efdec356ac7abb0f6f6f4/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim?ref=d3c6119a7a68732ff95efdec356ac7abb0f6f6f4", "patch": "@@ -14,21 +14,21 @@ if !exists(\"main_syntax\")\n   let main_syntax='rust'\n endif\n \n-syn keyword   rustKeyword     alt as assert be bind break\n-syn keyword   rustKeyword     check claim cont const copy else export fail\n-syn keyword   rustKeyword     for if impl import in inline lambda let log\n-syn keyword   rustKeyword     loop mod mut mutable native note of prove pure\n-syn keyword   rustKeyword     ret self syntax to unchecked\n+syn keyword   rustKeyword     alt as assert break\n+syn keyword   rustKeyword     check claim cont const copy else export extern fail\n+syn keyword   rustKeyword     for if impl import in let log\n+syn keyword   rustKeyword     loop mod mut of pure\n+syn keyword   rustKeyword     ret self to unchecked\n syn keyword   rustKeyword     unsafe use while with\n \" FIXME: Scoped impl's name is also fallen in this category\n-syn keyword   rustKeyword     mod iface resource class enum type nextgroup=rustIdentifier skipwhite\n+syn keyword   rustKeyword     mod iface trait class enum type nextgroup=rustIdentifier skipwhite\n syn keyword   rustKeyword     fn nextgroup=rustFuncName skipwhite\n \n syn match     rustIdentifier  \"\\%([^[:cntrl:][:space:][:punct:][:digit:]]\\|_\\)\\%([^[:cntrl:][:punct:][:space:]]\\|_\\)*\" display contained\n syn match     rustFuncName    \"\\%([^[:cntrl:][:space:][:punct:][:digit:]]\\|_\\)\\%([^[:cntrl:][:punct:][:space:]]\\|_\\)*\" display contained\n \n \" Reserved words\n-syn keyword   rustKeyword     m32 m64 m128 f80 f16 f128 class trait\n+syn keyword   rustKeyword     m32 m64 m128 f80 f16 f128\n \n syn keyword   rustType        any int uint float char bool u8 u16 u32 u64 f32\n syn keyword   rustType        f64 i8 i16 i32 i64 str"}, {"sha": "8ab37e95d21d0c87ceb3396a8f406dbaf816a8a7", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3c6119a7a68732ff95efdec356ac7abb0f6f6f4/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c6119a7a68732ff95efdec356ac7abb0f6f6f4/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=d3c6119a7a68732ff95efdec356ac7abb0f6f6f4", "patch": "@@ -285,7 +285,7 @@ fn restricted_keyword_table() -> hashmap<str, ()> {\n     let keys = [\n         \"alt\",\n         \"assert\",\n-        \"be\", \"break\",\n+        \"break\",\n         \"check\", \"claim\", \"class\", \"const\", \"cont\", \"copy\", \"crust\",\n         \"do\", \"drop\",\n         \"else\", \"enum\", \"export\", \"extern\","}, {"sha": "38e387735f977287aa27a561a2d9fd0e9ed0661d", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3c6119a7a68732ff95efdec356ac7abb0f6f6f4/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d3c6119a7a68732ff95efdec356ac7abb0f6f6f4/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=d3c6119a7a68732ff95efdec356ac7abb0f6f6f4", "patch": "@@ -1,4 +1,4 @@\n-/* Native builtins. */\n+/* Foreign builtins. */\n \n #include \"rust_sched_loop.h\"\n #include \"rust_task.h\""}, {"sha": "e46b624c936d735e105e073c931d2ca3b985333b", "filename": "src/rt/rust_task.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3c6119a7a68732ff95efdec356ac7abb0f6f6f4/src%2Frt%2Frust_task.h", "raw_url": "https://github.com/rust-lang/rust/raw/d3c6119a7a68732ff95efdec356ac7abb0f6f6f4/src%2Frt%2Frust_task.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.h?ref=d3c6119a7a68732ff95efdec356ac7abb0f6f6f4", "patch": "@@ -10,7 +10,7 @@\n    * Managing the dynamically resizing list of Rust stack segments\n \n    * Switching between running Rust code on the Rust segmented stack and\n-   native C code on large stacks owned by the scheduler\n+   foreign C code on large stacks owned by the scheduler\n \n    The lifetime of a rust_task object closely mirrors that of a running Rust\n    task object, but they are not identical. In particular, the rust_task is an"}, {"sha": "965d38fa70c93325aada61b9371144af4f1b68e3", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3c6119a7a68732ff95efdec356ac7abb0f6f6f4/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d3c6119a7a68732ff95efdec356ac7abb0f6f6f4/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=d3c6119a7a68732ff95efdec356ac7abb0f6f6f4", "patch": "@@ -40,7 +40,7 @@ extern \"C\" void record_sp_limit(void *limit);\n \n /**********************************************************************\n  * Switches to the C-stack and invokes |fn_ptr|, passing |args| as argument.\n- * This is used by the C compiler to call native functions and by other\n+ * This is used by the C compiler to call foreign functions and by other\n  * upcalls to switch to the C stack.  The return value is passed through a\n  * field in the args parameter. This upcall is specifically for switching\n  * to the shim functions generated by rustc.\n@@ -58,7 +58,7 @@ upcall_call_shim_on_c_stack(void *args, void *fn_ptr) {\n         task->call_on_c_stack(args, fn_ptr);\n     } catch (...) {\n         // Logging here is not reliable\n-        assert(false && \"Native code threw an exception\");\n+        assert(false && \"Foreign code threw an exception\");\n     }\n \n     task->record_stack_limit();"}, {"sha": "1873ae33e9c16f3d2bd0a06971efbc73ec7a9fb0", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/d3c6119a7a68732ff95efdec356ac7abb0f6f6f4/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d3c6119a7a68732ff95efdec356ac7abb0f6f6f4/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=d3c6119a7a68732ff95efdec356ac7abb0f6f6f4", "patch": "@@ -8,20 +8,20 @@\n #include \"rust_log.h\"\n #include \"uv.h\"\n \n-// crust fn pointers\n-typedef void (*crust_async_op_cb)(uv_loop_t* loop, void* data,\n+// extern fn pointers\n+typedef void (*extern_async_op_cb)(uv_loop_t* loop, void* data,\n         uv_async_t* op_handle);\n-typedef void (*crust_simple_cb)(uint8_t* id_buf, void* loop_data);\n-typedef void (*crust_close_cb)(uint8_t* id_buf, void* handle,\n+typedef void (*extern_simple_cb)(uint8_t* id_buf, void* loop_data);\n+typedef void (*extern_close_cb)(uint8_t* id_buf, void* handle,\n         void* data);\n \n // data types\n #define RUST_UV_HANDLE_LEN 16\n \n struct handle_data {\n     uint8_t id_buf[RUST_UV_HANDLE_LEN];\n-    crust_simple_cb cb;\n-    crust_close_cb close_cb;\n+    extern_simple_cb cb;\n+    extern_close_cb close_cb;\n };\n \n // helpers\n@@ -37,7 +37,7 @@ current_kernel_free(void* ptr) {\n }\n \n static handle_data*\n-new_handle_data_from(uint8_t* buf, crust_simple_cb cb) {\n+new_handle_data_from(uint8_t* buf, extern_simple_cb cb) {\n     handle_data* data = (handle_data*)current_kernel_malloc(\n             sizeof(handle_data),\n             \"handle_data\");\n@@ -48,39 +48,39 @@ new_handle_data_from(uint8_t* buf, crust_simple_cb cb) {\n \n // libuv callback impls\n static void\n-native_crust_async_op_cb(uv_async_t* handle, int status) {\n-    crust_async_op_cb cb = (crust_async_op_cb)handle->data;\n+foreign_extern_async_op_cb(uv_async_t* handle, int status) {\n+    extern_async_op_cb cb = (extern_async_op_cb)handle->data;\n     void* loop_data = handle->loop->data;\n     cb(handle->loop, loop_data, handle);\n }\n \n static void\n-native_async_cb(uv_async_t* handle, int status) {\n+foreign_async_cb(uv_async_t* handle, int status) {\n     handle_data* handle_d = (handle_data*)handle->data;\n     void* loop_data = handle->loop->data;\n     handle_d->cb(handle_d->id_buf, loop_data);\n }\n \n static void\n-native_timer_cb(uv_timer_t* handle, int status) {\n+foreign_timer_cb(uv_timer_t* handle, int status) {\n     handle_data* handle_d = (handle_data*)handle->data;\n     void* loop_data = handle->loop->data;\n     handle_d->cb(handle_d->id_buf, loop_data);\n }\n \n static void\n-native_close_cb(uv_handle_t* handle) {\n+foreign_close_cb(uv_handle_t* handle) {\n     handle_data* data = (handle_data*)handle->data;\n     data->close_cb(data->id_buf, handle, handle->loop->data);\n }\n \n static void\n-native_close_op_cb(uv_handle_t* op_handle) {\n+foreign_close_op_cb(uv_handle_t* op_handle) {\n     current_kernel_free(op_handle);\n     // uv_run() should return after this..\n }\n \n-// native fns bound in rust\n+// foreign fns bound in rust\n extern \"C\" void\n rust_uv_free(void* ptr) {\n     current_kernel_free(ptr);\n@@ -122,11 +122,11 @@ rust_uv_loop_set_data(uv_loop_t* loop, void* data) {\n }\n \n extern \"C\" void*\n-rust_uv_bind_op_cb(uv_loop_t* loop, crust_async_op_cb cb) {\n+rust_uv_bind_op_cb(uv_loop_t* loop, extern_async_op_cb cb) {\n     uv_async_t* async = (uv_async_t*)current_kernel_malloc(\n             sizeof(uv_async_t),\n             \"uv_async_t\");\n-    uv_async_init(loop, async, native_crust_async_op_cb);\n+    uv_async_init(loop, async, foreign_extern_async_op_cb);\n     async->data = (void*)cb;\n     // decrement the ref count, so that our async bind\n     // doesn't count towards keeping the loop alive\n@@ -136,7 +136,7 @@ rust_uv_bind_op_cb(uv_loop_t* loop, crust_async_op_cb cb) {\n \n extern \"C\" void\n rust_uv_stop_op_cb(uv_handle_t* op_handle) {\n-    uv_close(op_handle, native_close_op_cb);\n+    uv_close(op_handle, foreign_close_op_cb);\n }\n \n extern \"C\" void\n@@ -150,10 +150,10 @@ rust_uv_close(uv_handle_t* handle, uv_close_cb cb) {\n }\n \n extern \"C\" void\n-rust_uv_hilvl_close(uv_handle_t* handle, crust_close_cb cb) {\n+rust_uv_hilvl_close(uv_handle_t* handle, extern_close_cb cb) {\n     handle_data* data = (handle_data*)handle->data;\n     data->close_cb = cb;\n-    uv_close(handle, native_close_cb);\n+    uv_close(handle, foreign_close_cb);\n }\n \n extern \"C\" void\n@@ -181,20 +181,20 @@ rust_uv_async_init(uv_loop_t* loop_handle,\n }\n \n extern \"C\" void*\n-rust_uv_hilvl_async_init(uv_loop_t* loop, crust_simple_cb cb,\n+rust_uv_hilvl_async_init(uv_loop_t* loop, extern_simple_cb cb,\n         uint8_t* buf) {\n     uv_async_t* async = (uv_async_t*)current_kernel_malloc(\n             sizeof(uv_async_t),\n             \"uv_async_t\");\n-    uv_async_init(loop, async, native_async_cb);\n+    uv_async_init(loop, async, foreign_async_cb);\n     handle_data* data = new_handle_data_from(buf, cb);\n     async->data = data;\n \n     return async;\n }\n \n extern \"C\" void*\n-rust_uv_hilvl_timer_init(uv_loop_t* loop, crust_simple_cb cb,\n+rust_uv_hilvl_timer_init(uv_loop_t* loop, extern_simple_cb cb,\n         uint8_t* buf) {\n     uv_timer_t* new_timer = (uv_timer_t*)current_kernel_malloc(\n             sizeof(uv_timer_t),\n@@ -209,7 +209,7 @@ rust_uv_hilvl_timer_init(uv_loop_t* loop, crust_simple_cb cb,\n extern \"C\" void\n rust_uv_hilvl_timer_start(uv_timer_t* the_timer, uint32_t timeout,\n         uint32_t repeat) {\n-    uv_timer_start(the_timer, native_timer_cb, timeout, repeat);\n+    uv_timer_start(the_timer, foreign_timer_cb, timeout, repeat);\n }\n \n extern \"C\" int"}]}