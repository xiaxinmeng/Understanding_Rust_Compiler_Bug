{"sha": "f738423e6bec663e94fa16e5f9e5bec964678f83", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3Mzg0MjNlNmJlYzY2M2U5NGZhMTZlNWY5ZTViZWM5NjQ2NzhmODM=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-06-13T14:47:47Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-13T14:47:47Z"}, "message": "Rollup merge of #73194 - lzutao:INT-patterns, r=dtolnay\n\nPrefer the associated constants for pattern matching error\n\nResolved this comment: https://github.com/rust-lang/rust/issues/68490#issuecomment-641614383", "tree": {"sha": "8c1c3a8c793489179d1c81b51595609f0d607d47", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c1c3a8c793489179d1c81b51595609f0d607d47"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f738423e6bec663e94fa16e5f9e5bec964678f83", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe5OcUCRBK7hj4Ov3rIwAAdHIIAG178nTRJbRuckk6d9+3ACr/\nBegHZrQnel09AxD0XDScENI8JyBIlmW//CFnu6ns/Z+/f6+YjW6gwascBTipuVsg\nrN3tmYWCGSn4xYBqG84CwmlyPTsnFSR50bwKBxUd/ZBZsD7A/UH14rRBqZT3f2ht\ntWhYYyR8/AccD0VJJZsJ+eWEIuP2kia3z7rHmRMDRI4GPa6bLH6JRrud2vcuxnxU\ngZfLhOAR88zi9Dug1CbGdRP2VYUAljX9odROUAkcsTOM2d0/LJrhhURuE6gmBvW4\nLW0VKnyZai2WYRC4T2HmbeQEfWG+/Nd83wz6H/QlGTMvHqIN36+bUXBG8ktLQ4w=\n=aMyv\n-----END PGP SIGNATURE-----\n", "payload": "tree 8c1c3a8c793489179d1c81b51595609f0d607d47\nparent 6ad8cbdc7d3e8f3abf4dc002d441940e1e24efc3\nparent c755292859546105b06ffa2936c0def095763e03\nauthor Dylan DPC <dylan.dpc@gmail.com> 1592059667 +0200\ncommitter GitHub <noreply@github.com> 1592059667 +0200\n\nRollup merge of #73194 - lzutao:INT-patterns, r=dtolnay\n\nPrefer the associated constants for pattern matching error\n\nResolved this comment: https://github.com/rust-lang/rust/issues/68490#issuecomment-641614383\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f738423e6bec663e94fa16e5f9e5bec964678f83", "html_url": "https://github.com/rust-lang/rust/commit/f738423e6bec663e94fa16e5f9e5bec964678f83", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f738423e6bec663e94fa16e5f9e5bec964678f83/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6ad8cbdc7d3e8f3abf4dc002d441940e1e24efc3", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ad8cbdc7d3e8f3abf4dc002d441940e1e24efc3", "html_url": "https://github.com/rust-lang/rust/commit/6ad8cbdc7d3e8f3abf4dc002d441940e1e24efc3"}, {"sha": "c755292859546105b06ffa2936c0def095763e03", "url": "https://api.github.com/repos/rust-lang/rust/commits/c755292859546105b06ffa2936c0def095763e03", "html_url": "https://github.com/rust-lang/rust/commit/c755292859546105b06ffa2936c0def095763e03"}], "stats": {"total": 278, "additions": 139, "deletions": 139}, "files": [{"sha": "d782dd07a65889c4dbc4548e1d99a34b0e50ef00", "filename": "src/librustc_middle/ty/print/pretty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f738423e6bec663e94fa16e5f9e5bec964678f83/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f738423e6bec663e94fa16e5f9e5bec964678f83/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs?ref=f738423e6bec663e94fa16e5f9e5bec964678f83", "patch": "@@ -986,7 +986,7 @@ pub trait PrettyPrinter<'tcx>:\n \n                 let ui_str = ui.name_str();\n                 if data == max {\n-                    p!(write(\"std::{}::MAX\", ui_str))\n+                    p!(write(\"{}::MAX\", ui_str))\n                 } else {\n                     if print_ty { p!(write(\"{}{}\", data, ui_str)) } else { p!(write(\"{}\", data)) }\n                 };\n@@ -999,8 +999,8 @@ pub trait PrettyPrinter<'tcx>:\n \n                 let i_str = i.name_str();\n                 match data {\n-                    d if d == min => p!(write(\"std::{}::MIN\", i_str)),\n-                    d if d == max => p!(write(\"std::{}::MAX\", i_str)),\n+                    d if d == min => p!(write(\"{}::MIN\", i_str)),\n+                    d if d == max => p!(write(\"{}::MAX\", i_str)),\n                     _ => {\n                         let data = sign_extend(data, size) as i128;\n                         if print_ty {"}, {"sha": "de06e5334e0408adda32abc5a4925c9555eba157", "filename": "src/test/mir-opt/const_prop/bad_op_div_by_zero/rustc.main.ConstProp.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f738423e6bec663e94fa16e5f9e5bec964678f83/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fbad_op_div_by_zero%2Frustc.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f738423e6bec663e94fa16e5f9e5bec964678f83/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fbad_op_div_by_zero%2Frustc.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fbad_op_div_by_zero%2Frustc.main.ConstProp.diff?ref=f738423e6bec663e94fa16e5f9e5bec964678f83", "patch": "@@ -59,7 +59,7 @@\n                                            // mir::Constant\n                                            // + span: $DIR/bad_op_div_by_zero.rs:5:14: 5:19\n -                                          // + literal: Const { ty: i32, val: Value(Scalar(0xffffffff)) }\n--         _6 = Eq(const 1i32, const std::i32::MIN); // scope 1 at $DIR/bad_op_div_by_zero.rs:5:14: 5:19\n+-         _6 = Eq(const 1i32, const i32::MIN); // scope 1 at $DIR/bad_op_div_by_zero.rs:5:14: 5:19\n +                                          // + literal: Const { ty: bool, val: Value(Scalar(0x00)) }\n +         _6 = const false;                // scope 1 at $DIR/bad_op_div_by_zero.rs:5:14: 5:19\n                                            // ty::Const"}, {"sha": "7052c8387041b2d1772057268e918c5b7ea0ecb6", "filename": "src/test/mir-opt/const_prop/bad_op_mod_by_zero/rustc.main.ConstProp.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f738423e6bec663e94fa16e5f9e5bec964678f83/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fbad_op_mod_by_zero%2Frustc.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f738423e6bec663e94fa16e5f9e5bec964678f83/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fbad_op_mod_by_zero%2Frustc.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fbad_op_mod_by_zero%2Frustc.main.ConstProp.diff?ref=f738423e6bec663e94fa16e5f9e5bec964678f83", "patch": "@@ -59,7 +59,7 @@\n                                            // mir::Constant\n                                            // + span: $DIR/bad_op_mod_by_zero.rs:5:14: 5:19\n -                                          // + literal: Const { ty: i32, val: Value(Scalar(0xffffffff)) }\n--         _6 = Eq(const 1i32, const std::i32::MIN); // scope 1 at $DIR/bad_op_mod_by_zero.rs:5:14: 5:19\n+-         _6 = Eq(const 1i32, const i32::MIN); // scope 1 at $DIR/bad_op_mod_by_zero.rs:5:14: 5:19\n +                                          // + literal: Const { ty: bool, val: Value(Scalar(0x00)) }\n +         _6 = const false;                // scope 1 at $DIR/bad_op_mod_by_zero.rs:5:14: 5:19\n                                            // ty::Const"}, {"sha": "12ba9cacabf7c333bd5e184b754134cb326f9cda", "filename": "src/test/ui/consts/const-match-check.eval1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f738423e6bec663e94fa16e5f9e5bec964678f83/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.eval1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f738423e6bec663e94fa16e5f9e5bec964678f83/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.eval1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.eval1.stderr?ref=f738423e6bec663e94fa16e5f9e5bec964678f83", "patch": "@@ -1,8 +1,8 @@\n-error[E0005]: refutable pattern in local binding: `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n+error[E0005]: refutable pattern in local binding: `i32::MIN..=-1i32` and `1i32..=i32::MAX` not covered\n   --> $DIR/const-match-check.rs:25:15\n    |\n LL |     A = { let 0 = 0; 0 },\n-   |               ^ patterns `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n+   |               ^ patterns `i32::MIN..=-1i32` and `1i32..=i32::MAX` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html"}, {"sha": "2eed7abdc65701c99658a7c8aaf919e4eecd8b12", "filename": "src/test/ui/consts/const-match-check.eval2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f738423e6bec663e94fa16e5f9e5bec964678f83/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.eval2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f738423e6bec663e94fa16e5f9e5bec964678f83/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.eval2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.eval2.stderr?ref=f738423e6bec663e94fa16e5f9e5bec964678f83", "patch": "@@ -1,8 +1,8 @@\n-error[E0005]: refutable pattern in local binding: `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n+error[E0005]: refutable pattern in local binding: `i32::MIN..=-1i32` and `1i32..=i32::MAX` not covered\n   --> $DIR/const-match-check.rs:31:24\n    |\n LL |     let x: [i32; { let 0 = 0; 0 }] = [];\n-   |                        ^ patterns `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n+   |                        ^ patterns `i32::MIN..=-1i32` and `1i32..=i32::MAX` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html"}, {"sha": "1fa0cb17fe66e6a8b53a5e0e5e78e5f039620a4f", "filename": "src/test/ui/consts/const-match-check.matchck.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f738423e6bec663e94fa16e5f9e5bec964678f83/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.matchck.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f738423e6bec663e94fa16e5f9e5bec964678f83/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.matchck.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.matchck.stderr?ref=f738423e6bec663e94fa16e5f9e5bec964678f83", "patch": "@@ -1,8 +1,8 @@\n-error[E0005]: refutable pattern in local binding: `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n+error[E0005]: refutable pattern in local binding: `i32::MIN..=-1i32` and `1i32..=i32::MAX` not covered\n   --> $DIR/const-match-check.rs:4:22\n    |\n LL | const X: i32 = { let 0 = 0; 0 };\n-   |                      ^ patterns `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n+   |                      ^ patterns `i32::MIN..=-1i32` and `1i32..=i32::MAX` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n@@ -12,11 +12,11 @@ help: you might want to use `if let` to ignore the variant that isn't matched\n LL | const X: i32 = { if let 0 = 0 { /* */ } 0 };\n    |                  ^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0005]: refutable pattern in local binding: `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n+error[E0005]: refutable pattern in local binding: `i32::MIN..=-1i32` and `1i32..=i32::MAX` not covered\n   --> $DIR/const-match-check.rs:8:23\n    |\n LL | static Y: i32 = { let 0 = 0; 0 };\n-   |                       ^ patterns `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n+   |                       ^ patterns `i32::MIN..=-1i32` and `1i32..=i32::MAX` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n@@ -26,11 +26,11 @@ help: you might want to use `if let` to ignore the variant that isn't matched\n LL | static Y: i32 = { if let 0 = 0 { /* */ } 0 };\n    |                   ^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0005]: refutable pattern in local binding: `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n+error[E0005]: refutable pattern in local binding: `i32::MIN..=-1i32` and `1i32..=i32::MAX` not covered\n   --> $DIR/const-match-check.rs:13:26\n    |\n LL |     const X: i32 = { let 0 = 0; 0 };\n-   |                          ^ patterns `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n+   |                          ^ patterns `i32::MIN..=-1i32` and `1i32..=i32::MAX` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n@@ -40,11 +40,11 @@ help: you might want to use `if let` to ignore the variant that isn't matched\n LL |     const X: i32 = { if let 0 = 0 { /* */ } 0 };\n    |                      ^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0005]: refutable pattern in local binding: `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n+error[E0005]: refutable pattern in local binding: `i32::MIN..=-1i32` and `1i32..=i32::MAX` not covered\n   --> $DIR/const-match-check.rs:19:26\n    |\n LL |     const X: i32 = { let 0 = 0; 0 };\n-   |                          ^ patterns `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n+   |                          ^ patterns `i32::MIN..=-1i32` and `1i32..=i32::MAX` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html"}, {"sha": "65f09eb80098c73c260f53aa75026a6bf35af121", "filename": "src/test/ui/consts/const-pattern-irrefutable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f738423e6bec663e94fa16e5f9e5bec964678f83/src%2Ftest%2Fui%2Fconsts%2Fconst-pattern-irrefutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f738423e6bec663e94fa16e5f9e5bec964678f83/src%2Ftest%2Fui%2Fconsts%2Fconst-pattern-irrefutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-pattern-irrefutable.rs?ref=f738423e6bec663e94fa16e5f9e5bec964678f83", "patch": "@@ -9,8 +9,8 @@ use foo::d;\n const a: u8 = 2;\n \n fn main() {\n-    let a = 4; //~ ERROR refutable pattern in local binding: `0u8..=1u8` and `3u8..=std::u8::MAX\n-    let c = 4; //~ ERROR refutable pattern in local binding: `0u8..=1u8` and `3u8..=std::u8::MAX\n-    let d = 4; //~ ERROR refutable pattern in local binding: `0u8..=1u8` and `3u8..=std::u8::MAX\n+    let a = 4; //~ ERROR refutable pattern in local binding: `0u8..=1u8` and `3u8..=u8::MAX\n+    let c = 4; //~ ERROR refutable pattern in local binding: `0u8..=1u8` and `3u8..=u8::MAX\n+    let d = 4; //~ ERROR refutable pattern in local binding: `0u8..=1u8` and `3u8..=u8::MAX\n     fn f() {} // Check that the `NOTE`s still work with an item here (cf. issue #35115).\n }"}, {"sha": "bb2fdec72ba0dd6638b15ca2f9a92f39b2abe266", "filename": "src/test/ui/consts/const-pattern-irrefutable.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f738423e6bec663e94fa16e5f9e5bec964678f83/src%2Ftest%2Fui%2Fconsts%2Fconst-pattern-irrefutable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f738423e6bec663e94fa16e5f9e5bec964678f83/src%2Ftest%2Fui%2Fconsts%2Fconst-pattern-irrefutable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-pattern-irrefutable.stderr?ref=f738423e6bec663e94fa16e5f9e5bec964678f83", "patch": "@@ -1,4 +1,4 @@\n-error[E0005]: refutable pattern in local binding: `0u8..=1u8` and `3u8..=std::u8::MAX` not covered\n+error[E0005]: refutable pattern in local binding: `0u8..=1u8` and `3u8..=u8::MAX` not covered\n   --> $DIR/const-pattern-irrefutable.rs:12:9\n    |\n LL | const a: u8 = 2;\n@@ -12,7 +12,7 @@ LL |     let a = 4;\n    |\n    = note: the matched value is of type `u8`\n \n-error[E0005]: refutable pattern in local binding: `0u8..=1u8` and `3u8..=std::u8::MAX` not covered\n+error[E0005]: refutable pattern in local binding: `0u8..=1u8` and `3u8..=u8::MAX` not covered\n   --> $DIR/const-pattern-irrefutable.rs:13:9\n    |\n LL |     pub const b: u8 = 2;\n@@ -26,7 +26,7 @@ LL |     let c = 4;\n    |\n    = note: the matched value is of type `u8`\n \n-error[E0005]: refutable pattern in local binding: `0u8..=1u8` and `3u8..=std::u8::MAX` not covered\n+error[E0005]: refutable pattern in local binding: `0u8..=1u8` and `3u8..=u8::MAX` not covered\n   --> $DIR/const-pattern-irrefutable.rs:14:9\n    |\n LL |     pub const d: u8 = 2;"}, {"sha": "e32005e21a8e1b63df9ce58f44c08a209185bf51", "filename": "src/test/ui/for/for-loop-refutable-pattern-error-message.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f738423e6bec663e94fa16e5f9e5bec964678f83/src%2Ftest%2Fui%2Ffor%2Ffor-loop-refutable-pattern-error-message.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f738423e6bec663e94fa16e5f9e5bec964678f83/src%2Ftest%2Fui%2Ffor%2Ffor-loop-refutable-pattern-error-message.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffor%2Ffor-loop-refutable-pattern-error-message.stderr?ref=f738423e6bec663e94fa16e5f9e5bec964678f83", "patch": "@@ -1,8 +1,8 @@\n-error[E0005]: refutable pattern in `for` loop binding: `&std::i32::MIN..=0i32` and `&2i32..=std::i32::MAX` not covered\n+error[E0005]: refutable pattern in `for` loop binding: `&i32::MIN..=0i32` and `&2i32..=i32::MAX` not covered\n   --> $DIR/for-loop-refutable-pattern-error-message.rs:2:9\n    |\n LL |     for &1 in [1].iter() {}\n-   |         ^^ patterns `&std::i32::MIN..=0i32` and `&2i32..=std::i32::MAX` not covered\n+   |         ^^ patterns `&i32::MIN..=0i32` and `&2i32..=i32::MAX` not covered\n    |\n    = note: the matched value is of type `&i32`\n "}, {"sha": "028bfb89312fc7174760aa9925efc48e4200ec87", "filename": "src/test/ui/half-open-range-patterns/half-open-range-pats-exhaustive-fail.stderr", "status": "modified", "additions": 70, "deletions": 70, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/f738423e6bec663e94fa16e5f9e5bec964678f83/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-exhaustive-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f738423e6bec663e94fa16e5f9e5bec964678f83/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-exhaustive-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-exhaustive-fail.stderr?ref=f738423e6bec663e94fa16e5f9e5bec964678f83", "patch": "@@ -70,20 +70,20 @@ LL |     m!('a', ..VAL_1 | VAL_2..);\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `char`\n \n-error[E0004]: non-exhaustive patterns: `std::u8::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `u8::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:41:12\n    |\n LL |         m!(0, ..core::u8::MAX);\n-   |            ^ pattern `std::u8::MAX` not covered\n+   |            ^ pattern `u8::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u8`\n \n-error[E0004]: non-exhaustive patterns: `254u8..=std::u8::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `254u8..=u8::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:42:12\n    |\n LL |         m!(0, ..ALMOST_MAX);\n-   |            ^ pattern `254u8..=std::u8::MAX` not covered\n+   |            ^ pattern `254u8..=u8::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u8`\n@@ -97,11 +97,11 @@ LL |         m!(0, ALMOST_MIN..);\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u8`\n \n-error[E0004]: non-exhaustive patterns: `std::u8::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `u8::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:44:12\n    |\n LL |         m!(0, ..=ALMOST_MAX);\n-   |            ^ pattern `std::u8::MAX` not covered\n+   |            ^ pattern `u8::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u8`\n@@ -124,20 +124,20 @@ LL |         m!(0, ..VAL_1 | VAL_2..);\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u8`\n \n-error[E0004]: non-exhaustive patterns: `std::u16::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `u16::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:54:12\n    |\n LL |         m!(0, ..core::u16::MAX);\n-   |            ^ pattern `std::u16::MAX` not covered\n+   |            ^ pattern `u16::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u16`\n \n-error[E0004]: non-exhaustive patterns: `65534u16..=std::u16::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `65534u16..=u16::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:55:12\n    |\n LL |         m!(0, ..ALMOST_MAX);\n-   |            ^ pattern `65534u16..=std::u16::MAX` not covered\n+   |            ^ pattern `65534u16..=u16::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u16`\n@@ -151,11 +151,11 @@ LL |         m!(0, ALMOST_MIN..);\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u16`\n \n-error[E0004]: non-exhaustive patterns: `std::u16::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `u16::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:57:12\n    |\n LL |         m!(0, ..=ALMOST_MAX);\n-   |            ^ pattern `std::u16::MAX` not covered\n+   |            ^ pattern `u16::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u16`\n@@ -178,20 +178,20 @@ LL |         m!(0, ..VAL_1 | VAL_2..);\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u16`\n \n-error[E0004]: non-exhaustive patterns: `std::u32::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `u32::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:67:12\n    |\n LL |         m!(0, ..core::u32::MAX);\n-   |            ^ pattern `std::u32::MAX` not covered\n+   |            ^ pattern `u32::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u32`\n \n-error[E0004]: non-exhaustive patterns: `4294967294u32..=std::u32::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `4294967294u32..=u32::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:68:12\n    |\n LL |         m!(0, ..ALMOST_MAX);\n-   |            ^ pattern `4294967294u32..=std::u32::MAX` not covered\n+   |            ^ pattern `4294967294u32..=u32::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u32`\n@@ -205,11 +205,11 @@ LL |         m!(0, ALMOST_MIN..);\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u32`\n \n-error[E0004]: non-exhaustive patterns: `std::u32::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `u32::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:70:12\n    |\n LL |         m!(0, ..=ALMOST_MAX);\n-   |            ^ pattern `std::u32::MAX` not covered\n+   |            ^ pattern `u32::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u32`\n@@ -232,20 +232,20 @@ LL |         m!(0, ..VAL_1 | VAL_2..);\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u32`\n \n-error[E0004]: non-exhaustive patterns: `std::u64::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `u64::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:80:12\n    |\n LL |         m!(0, ..core::u64::MAX);\n-   |            ^ pattern `std::u64::MAX` not covered\n+   |            ^ pattern `u64::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u64`\n \n-error[E0004]: non-exhaustive patterns: `18446744073709551614u64..=std::u64::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `18446744073709551614u64..=u64::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:81:12\n    |\n LL |         m!(0, ..ALMOST_MAX);\n-   |            ^ pattern `18446744073709551614u64..=std::u64::MAX` not covered\n+   |            ^ pattern `18446744073709551614u64..=u64::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u64`\n@@ -259,11 +259,11 @@ LL |         m!(0, ALMOST_MIN..);\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u64`\n \n-error[E0004]: non-exhaustive patterns: `std::u64::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `u64::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:83:12\n    |\n LL |         m!(0, ..=ALMOST_MAX);\n-   |            ^ pattern `std::u64::MAX` not covered\n+   |            ^ pattern `u64::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u64`\n@@ -286,20 +286,20 @@ LL |         m!(0, ..VAL_1 | VAL_2..);\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u64`\n \n-error[E0004]: non-exhaustive patterns: `std::u128::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `u128::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:93:12\n    |\n LL |         m!(0, ..core::u128::MAX);\n-   |            ^ pattern `std::u128::MAX` not covered\n+   |            ^ pattern `u128::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u128`\n \n-error[E0004]: non-exhaustive patterns: `340282366920938463463374607431768211454u128..=std::u128::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `340282366920938463463374607431768211454u128..=u128::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:94:12\n    |\n LL |         m!(0, ..ALMOST_MAX);\n-   |            ^ pattern `340282366920938463463374607431768211454u128..=std::u128::MAX` not covered\n+   |            ^ pattern `340282366920938463463374607431768211454u128..=u128::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u128`\n@@ -313,11 +313,11 @@ LL |         m!(0, ALMOST_MIN..);\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u128`\n \n-error[E0004]: non-exhaustive patterns: `std::u128::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `u128::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:96:12\n    |\n LL |         m!(0, ..=ALMOST_MAX);\n-   |            ^ pattern `std::u128::MAX` not covered\n+   |            ^ pattern `u128::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u128`\n@@ -340,38 +340,38 @@ LL |         m!(0, ..VAL_1 | VAL_2..);\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u128`\n \n-error[E0004]: non-exhaustive patterns: `std::i8::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `i8::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:109:12\n    |\n LL |         m!(0, ..core::i8::MAX);\n-   |            ^ pattern `std::i8::MAX` not covered\n+   |            ^ pattern `i8::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i8`\n \n-error[E0004]: non-exhaustive patterns: `126i8..=std::i8::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `126i8..=i8::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:110:12\n    |\n LL |         m!(0, ..ALMOST_MAX);\n-   |            ^ pattern `126i8..=std::i8::MAX` not covered\n+   |            ^ pattern `126i8..=i8::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i8`\n \n-error[E0004]: non-exhaustive patterns: `std::i8::MIN` not covered\n+error[E0004]: non-exhaustive patterns: `i8::MIN` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:111:12\n    |\n LL |         m!(0, ALMOST_MIN..);\n-   |            ^ pattern `std::i8::MIN` not covered\n+   |            ^ pattern `i8::MIN` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i8`\n \n-error[E0004]: non-exhaustive patterns: `std::i8::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `i8::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:112:12\n    |\n LL |         m!(0, ..=ALMOST_MAX);\n-   |            ^ pattern `std::i8::MAX` not covered\n+   |            ^ pattern `i8::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i8`\n@@ -394,38 +394,38 @@ LL |         m!(0, ..VAL_1 | VAL_2..);\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i8`\n \n-error[E0004]: non-exhaustive patterns: `std::i16::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `i16::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:122:12\n    |\n LL |         m!(0, ..core::i16::MAX);\n-   |            ^ pattern `std::i16::MAX` not covered\n+   |            ^ pattern `i16::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i16`\n \n-error[E0004]: non-exhaustive patterns: `32766i16..=std::i16::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `32766i16..=i16::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:123:12\n    |\n LL |         m!(0, ..ALMOST_MAX);\n-   |            ^ pattern `32766i16..=std::i16::MAX` not covered\n+   |            ^ pattern `32766i16..=i16::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i16`\n \n-error[E0004]: non-exhaustive patterns: `std::i16::MIN` not covered\n+error[E0004]: non-exhaustive patterns: `i16::MIN` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:124:12\n    |\n LL |         m!(0, ALMOST_MIN..);\n-   |            ^ pattern `std::i16::MIN` not covered\n+   |            ^ pattern `i16::MIN` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i16`\n \n-error[E0004]: non-exhaustive patterns: `std::i16::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `i16::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:125:12\n    |\n LL |         m!(0, ..=ALMOST_MAX);\n-   |            ^ pattern `std::i16::MAX` not covered\n+   |            ^ pattern `i16::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i16`\n@@ -448,38 +448,38 @@ LL |         m!(0, ..VAL_1 | VAL_2..);\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i16`\n \n-error[E0004]: non-exhaustive patterns: `std::i32::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `i32::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:135:12\n    |\n LL |         m!(0, ..core::i32::MAX);\n-   |            ^ pattern `std::i32::MAX` not covered\n+   |            ^ pattern `i32::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i32`\n \n-error[E0004]: non-exhaustive patterns: `2147483646i32..=std::i32::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `2147483646i32..=i32::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:136:12\n    |\n LL |         m!(0, ..ALMOST_MAX);\n-   |            ^ pattern `2147483646i32..=std::i32::MAX` not covered\n+   |            ^ pattern `2147483646i32..=i32::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i32`\n \n-error[E0004]: non-exhaustive patterns: `std::i32::MIN` not covered\n+error[E0004]: non-exhaustive patterns: `i32::MIN` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:137:12\n    |\n LL |         m!(0, ALMOST_MIN..);\n-   |            ^ pattern `std::i32::MIN` not covered\n+   |            ^ pattern `i32::MIN` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i32`\n \n-error[E0004]: non-exhaustive patterns: `std::i32::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `i32::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:138:12\n    |\n LL |         m!(0, ..=ALMOST_MAX);\n-   |            ^ pattern `std::i32::MAX` not covered\n+   |            ^ pattern `i32::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i32`\n@@ -502,38 +502,38 @@ LL |         m!(0, ..VAL_1 | VAL_2..);\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i32`\n \n-error[E0004]: non-exhaustive patterns: `std::i64::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `i64::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:148:12\n    |\n LL |         m!(0, ..core::i64::MAX);\n-   |            ^ pattern `std::i64::MAX` not covered\n+   |            ^ pattern `i64::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i64`\n \n-error[E0004]: non-exhaustive patterns: `9223372036854775806i64..=std::i64::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `9223372036854775806i64..=i64::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:149:12\n    |\n LL |         m!(0, ..ALMOST_MAX);\n-   |            ^ pattern `9223372036854775806i64..=std::i64::MAX` not covered\n+   |            ^ pattern `9223372036854775806i64..=i64::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i64`\n \n-error[E0004]: non-exhaustive patterns: `std::i64::MIN` not covered\n+error[E0004]: non-exhaustive patterns: `i64::MIN` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:150:12\n    |\n LL |         m!(0, ALMOST_MIN..);\n-   |            ^ pattern `std::i64::MIN` not covered\n+   |            ^ pattern `i64::MIN` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i64`\n \n-error[E0004]: non-exhaustive patterns: `std::i64::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `i64::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:151:12\n    |\n LL |         m!(0, ..=ALMOST_MAX);\n-   |            ^ pattern `std::i64::MAX` not covered\n+   |            ^ pattern `i64::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i64`\n@@ -556,38 +556,38 @@ LL |         m!(0, ..VAL_1 | VAL_2..);\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i64`\n \n-error[E0004]: non-exhaustive patterns: `std::i128::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `i128::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:161:12\n    |\n LL |         m!(0, ..core::i128::MAX);\n-   |            ^ pattern `std::i128::MAX` not covered\n+   |            ^ pattern `i128::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i128`\n \n-error[E0004]: non-exhaustive patterns: `170141183460469231731687303715884105726i128..=std::i128::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `170141183460469231731687303715884105726i128..=i128::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:162:12\n    |\n LL |         m!(0, ..ALMOST_MAX);\n-   |            ^ pattern `170141183460469231731687303715884105726i128..=std::i128::MAX` not covered\n+   |            ^ pattern `170141183460469231731687303715884105726i128..=i128::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i128`\n \n-error[E0004]: non-exhaustive patterns: `std::i128::MIN` not covered\n+error[E0004]: non-exhaustive patterns: `i128::MIN` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:163:12\n    |\n LL |         m!(0, ALMOST_MIN..);\n-   |            ^ pattern `std::i128::MIN` not covered\n+   |            ^ pattern `i128::MIN` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i128`\n \n-error[E0004]: non-exhaustive patterns: `std::i128::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `i128::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:164:12\n    |\n LL |         m!(0, ..=ALMOST_MAX);\n-   |            ^ pattern `std::i128::MAX` not covered\n+   |            ^ pattern `i128::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i128`"}, {"sha": "31b3407a46e08f371e6b85657d6ef67b4bf92365", "filename": "src/test/ui/or-patterns/exhaustiveness-non-exhaustive.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f738423e6bec663e94fa16e5f9e5bec964678f83/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-non-exhaustive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f738423e6bec663e94fa16e5f9e5bec964678f83/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-non-exhaustive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-non-exhaustive.rs?ref=f738423e6bec663e94fa16e5f9e5bec964678f83", "patch": "@@ -4,15 +4,15 @@\n // We wrap patterns in a tuple because top-level or-patterns were special-cased.\n fn main() {\n     match (0u8, 0u8) {\n-        //~^ ERROR non-exhaustive patterns: `(2u8..=std::u8::MAX, _)`\n+        //~^ ERROR non-exhaustive patterns: `(2u8..=u8::MAX, _)`\n         (0 | 1, 2 | 3) => {}\n     }\n     match ((0u8,),) {\n-        //~^ ERROR non-exhaustive patterns: `((4u8..=std::u8::MAX))`\n+        //~^ ERROR non-exhaustive patterns: `((4u8..=u8::MAX))`\n         ((0 | 1,) | (2 | 3,),) => {}\n     }\n     match (Some(0u8),) {\n-        //~^ ERROR non-exhaustive patterns: `(Some(2u8..=std::u8::MAX))`\n+        //~^ ERROR non-exhaustive patterns: `(Some(2u8..=u8::MAX))`\n         (None | Some(0 | 1),) => {}\n     }\n }"}, {"sha": "653f4978ab350c2fb5abfe4a3cfaa3b22917602d", "filename": "src/test/ui/or-patterns/exhaustiveness-non-exhaustive.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f738423e6bec663e94fa16e5f9e5bec964678f83/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-non-exhaustive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f738423e6bec663e94fa16e5f9e5bec964678f83/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-non-exhaustive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-non-exhaustive.stderr?ref=f738423e6bec663e94fa16e5f9e5bec964678f83", "patch": "@@ -1,26 +1,26 @@\n-error[E0004]: non-exhaustive patterns: `(2u8..=std::u8::MAX, _)` not covered\n+error[E0004]: non-exhaustive patterns: `(2u8..=u8::MAX, _)` not covered\n   --> $DIR/exhaustiveness-non-exhaustive.rs:6:11\n    |\n LL |     match (0u8, 0u8) {\n-   |           ^^^^^^^^^^ pattern `(2u8..=std::u8::MAX, _)` not covered\n+   |           ^^^^^^^^^^ pattern `(2u8..=u8::MAX, _)` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `(u8, u8)`\n \n-error[E0004]: non-exhaustive patterns: `((4u8..=std::u8::MAX))` not covered\n+error[E0004]: non-exhaustive patterns: `((4u8..=u8::MAX))` not covered\n   --> $DIR/exhaustiveness-non-exhaustive.rs:10:11\n    |\n LL |     match ((0u8,),) {\n-   |           ^^^^^^^^^ pattern `((4u8..=std::u8::MAX))` not covered\n+   |           ^^^^^^^^^ pattern `((4u8..=u8::MAX))` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `((u8,),)`\n \n-error[E0004]: non-exhaustive patterns: `(Some(2u8..=std::u8::MAX))` not covered\n+error[E0004]: non-exhaustive patterns: `(Some(2u8..=u8::MAX))` not covered\n   --> $DIR/exhaustiveness-non-exhaustive.rs:14:11\n    |\n LL |     match (Some(0u8),) {\n-   |           ^^^^^^^^^^^^ pattern `(Some(2u8..=std::u8::MAX))` not covered\n+   |           ^^^^^^^^^^^^ pattern `(Some(2u8..=u8::MAX))` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `(std::option::Option<u8>,)`"}, {"sha": "2eadef9cb5c118b870aec2e41ddd36451d6efabd", "filename": "src/test/ui/or-patterns/issue-69875-should-have-been-expanded-earlier-non-exhaustive.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f738423e6bec663e94fa16e5f9e5bec964678f83/src%2Ftest%2Fui%2For-patterns%2Fissue-69875-should-have-been-expanded-earlier-non-exhaustive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f738423e6bec663e94fa16e5f9e5bec964678f83/src%2Ftest%2Fui%2For-patterns%2Fissue-69875-should-have-been-expanded-earlier-non-exhaustive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fissue-69875-should-have-been-expanded-earlier-non-exhaustive.stderr?ref=f738423e6bec663e94fa16e5f9e5bec964678f83", "patch": "@@ -1,8 +1,8 @@\n-error[E0005]: refutable pattern in local binding: `std::i32::MIN..=-1i32` and `3i32..=std::i32::MAX` not covered\n+error[E0005]: refutable pattern in local binding: `i32::MIN..=-1i32` and `3i32..=i32::MAX` not covered\n   --> $DIR/issue-69875-should-have-been-expanded-earlier-non-exhaustive.rs:4:9\n    |\n LL |     let 0 | (1 | 2) = 0;\n-   |         ^^^^^^^^^^^ patterns `std::i32::MIN..=-1i32` and `3i32..=std::i32::MAX` not covered\n+   |         ^^^^^^^^^^^ patterns `i32::MIN..=-1i32` and `3i32..=i32::MAX` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n@@ -12,11 +12,11 @@ help: you might want to use `if let` to ignore the variant that isn't matched\n LL |     if let 0 | (1 | 2) = 0 { /* */ }\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0004]: non-exhaustive patterns: `std::i32::MIN..=-1i32` and `3i32..=std::i32::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `i32::MIN..=-1i32` and `3i32..=i32::MAX` not covered\n   --> $DIR/issue-69875-should-have-been-expanded-earlier-non-exhaustive.rs:5:11\n    |\n LL |     match 0 {\n-   |           ^ patterns `std::i32::MIN..=-1i32` and `3i32..=std::i32::MAX` not covered\n+   |           ^ patterns `i32::MIN..=-1i32` and `3i32..=i32::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i32`"}, {"sha": "6427a30b8f2ed8354c91828924cd94c63534cb9e", "filename": "src/test/ui/pattern/usefulness/exhaustive_integer_patterns.stderr", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f738423e6bec663e94fa16e5f9e5bec964678f83/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fexhaustive_integer_patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f738423e6bec663e94fa16e5f9e5bec964678f83/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fexhaustive_integer_patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fexhaustive_integer_patterns.stderr?ref=f738423e6bec663e94fa16e5f9e5bec964678f83", "patch": "@@ -10,11 +10,11 @@ note: the lint level is defined here\n LL | #![deny(unreachable_patterns)]\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n-error[E0004]: non-exhaustive patterns: `128u8..=std::u8::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `128u8..=u8::MAX` not covered\n   --> $DIR/exhaustive_integer_patterns.rs:28:11\n    |\n LL |     match x {\n-   |           ^ pattern `128u8..=std::u8::MAX` not covered\n+   |           ^ pattern `128u8..=u8::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u8`\n@@ -34,20 +34,20 @@ error: unreachable pattern\n LL |         -2..=20 => {}\n    |         ^^^^^^^\n \n-error[E0004]: non-exhaustive patterns: `std::i8::MIN..=-8i8`, `-6i8`, `121i8..=124i8` and 1 more not covered\n+error[E0004]: non-exhaustive patterns: `i8::MIN..=-8i8`, `-6i8`, `121i8..=124i8` and 1 more not covered\n   --> $DIR/exhaustive_integer_patterns.rs:41:11\n    |\n LL |     match x {\n-   |           ^ patterns `std::i8::MIN..=-8i8`, `-6i8`, `121i8..=124i8` and 1 more not covered\n+   |           ^ patterns `i8::MIN..=-8i8`, `-6i8`, `121i8..=124i8` and 1 more not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i8`\n \n-error[E0004]: non-exhaustive patterns: `std::i8::MIN` not covered\n+error[E0004]: non-exhaustive patterns: `i8::MIN` not covered\n   --> $DIR/exhaustive_integer_patterns.rs:83:11\n    |\n LL |     match 0i8 {\n-   |           ^^^ pattern `std::i8::MIN` not covered\n+   |           ^^^ pattern `i8::MIN` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i8`\n@@ -61,20 +61,20 @@ LL |     match 0i16 {\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i16`\n \n-error[E0004]: non-exhaustive patterns: `128u8..=std::u8::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `128u8..=u8::MAX` not covered\n   --> $DIR/exhaustive_integer_patterns.rs:109:11\n    |\n LL |     match 0u8 {\n-   |           ^^^ pattern `128u8..=std::u8::MAX` not covered\n+   |           ^^^ pattern `128u8..=u8::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u8`\n \n-error[E0004]: non-exhaustive patterns: `(0u8, Some(_))` and `(2u8..=std::u8::MAX, Some(_))` not covered\n+error[E0004]: non-exhaustive patterns: `(0u8, Some(_))` and `(2u8..=u8::MAX, Some(_))` not covered\n   --> $DIR/exhaustive_integer_patterns.rs:121:11\n    |\n LL |     match (0u8, Some(())) {\n-   |           ^^^^^^^^^^^^^^^ patterns `(0u8, Some(_))` and `(2u8..=std::u8::MAX, Some(_))` not covered\n+   |           ^^^^^^^^^^^^^^^ patterns `(0u8, Some(_))` and `(2u8..=u8::MAX, Some(_))` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `(u8, std::option::Option<()>)`\n@@ -102,20 +102,20 @@ note: the lint level is defined here\n LL | #![deny(overlapping_patterns)]\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n-error[E0004]: non-exhaustive patterns: `std::u128::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `u128::MAX` not covered\n   --> $DIR/exhaustive_integer_patterns.rs:146:11\n    |\n LL |     match 0u128 {\n-   |           ^^^^^ pattern `std::u128::MAX` not covered\n+   |           ^^^^^ pattern `u128::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u128`\n \n-error[E0004]: non-exhaustive patterns: `5u128..=std::u128::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `5u128..=u128::MAX` not covered\n   --> $DIR/exhaustive_integer_patterns.rs:150:11\n    |\n LL |     match 0u128 {\n-   |           ^^^^^ pattern `5u128..=std::u128::MAX` not covered\n+   |           ^^^^^ pattern `5u128..=u128::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u128`"}, {"sha": "0e12b89de1b9104ca43eff20110ad0b51d2746af", "filename": "src/test/ui/pattern/usefulness/match-byte-array-patterns-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f738423e6bec663e94fa16e5f9e5bec964678f83/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-byte-array-patterns-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f738423e6bec663e94fa16e5f9e5bec964678f83/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-byte-array-patterns-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-byte-array-patterns-2.stderr?ref=f738423e6bec663e94fa16e5f9e5bec964678f83", "patch": "@@ -1,8 +1,8 @@\n-error[E0004]: non-exhaustive patterns: `&[0u8..=64u8, _, _, _]` and `&[66u8..=std::u8::MAX, _, _, _]` not covered\n+error[E0004]: non-exhaustive patterns: `&[0u8..=64u8, _, _, _]` and `&[66u8..=u8::MAX, _, _, _]` not covered\n   --> $DIR/match-byte-array-patterns-2.rs:4:11\n    |\n LL |     match buf {\n-   |           ^^^ patterns `&[0u8..=64u8, _, _, _]` and `&[66u8..=std::u8::MAX, _, _, _]` not covered\n+   |           ^^^ patterns `&[0u8..=64u8, _, _, _]` and `&[66u8..=u8::MAX, _, _, _]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `&[u8; 4]`"}, {"sha": "c6a9329f9e8e124ef31988d1823f8db06a9b132a", "filename": "src/test/ui/pattern/usefulness/match-non-exhaustive.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f738423e6bec663e94fa16e5f9e5bec964678f83/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-non-exhaustive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f738423e6bec663e94fa16e5f9e5bec964678f83/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-non-exhaustive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-non-exhaustive.stderr?ref=f738423e6bec663e94fa16e5f9e5bec964678f83", "patch": "@@ -1,8 +1,8 @@\n-error[E0004]: non-exhaustive patterns: `std::i32::MIN..=0i32` and `2i32..=std::i32::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `i32::MIN..=0i32` and `2i32..=i32::MAX` not covered\n   --> $DIR/match-non-exhaustive.rs:2:11\n    |\n LL |     match 0 { 1 => () }\n-   |           ^ patterns `std::i32::MIN..=0i32` and `2i32..=std::i32::MAX` not covered\n+   |           ^ patterns `i32::MIN..=0i32` and `2i32..=i32::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i32`"}, {"sha": "9177345bc6f50603d757d492cccfe8ec0adff9c4", "filename": "src/test/ui/pattern/usefulness/non-exhaustive-match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f738423e6bec663e94fa16e5f9e5bec964678f83/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f738423e6bec663e94fa16e5f9e5bec964678f83/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.rs?ref=f738423e6bec663e94fa16e5f9e5bec964678f83", "patch": "@@ -11,8 +11,8 @@ fn main() {\n     match Some(10) { //~ ERROR non-exhaustive patterns: `Some(_)` not covered\n       None => {}\n     }\n-    match (2, 3, 4) { //~ ERROR non-exhaustive patterns: `(_, _, std::i32::MIN..=3i32)`\n-                      //  and `(_, _, 5i32..=std::i32::MAX)` not covered\n+    match (2, 3, 4) { //~ ERROR non-exhaustive patterns: `(_, _, i32::MIN..=3i32)`\n+                      //  and `(_, _, 5i32..=i32::MAX)` not covered\n       (_, _, 4) => {}\n     }\n     match (T::A, T::A) { //~ ERROR non-exhaustive patterns: `(A, A)` not covered"}, {"sha": "3cdbd8a3433f4144ca590d654cb1608ef656f516", "filename": "src/test/ui/pattern/usefulness/non-exhaustive-match.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f738423e6bec663e94fa16e5f9e5bec964678f83/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f738423e6bec663e94fa16e5f9e5bec964678f83/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.stderr?ref=f738423e6bec663e94fa16e5f9e5bec964678f83", "patch": "@@ -36,11 +36,11 @@ LL |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `std::option::Option<i32>`\n \n-error[E0004]: non-exhaustive patterns: `(_, _, std::i32::MIN..=3i32)` and `(_, _, 5i32..=std::i32::MAX)` not covered\n+error[E0004]: non-exhaustive patterns: `(_, _, i32::MIN..=3i32)` and `(_, _, 5i32..=i32::MAX)` not covered\n   --> $DIR/non-exhaustive-match.rs:14:11\n    |\n LL |     match (2, 3, 4) {\n-   |           ^^^^^^^^^ patterns `(_, _, std::i32::MIN..=3i32)` and `(_, _, 5i32..=std::i32::MAX)` not covered\n+   |           ^^^^^^^^^ patterns `(_, _, i32::MIN..=3i32)` and `(_, _, 5i32..=i32::MAX)` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `(i32, i32, i32)`"}, {"sha": "3ef2ead32cb7ceedf069e125748e228c6ff17bbf", "filename": "src/test/ui/pattern/usefulness/refutable-pattern-errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f738423e6bec663e94fa16e5f9e5bec964678f83/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Frefutable-pattern-errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f738423e6bec663e94fa16e5f9e5bec964678f83/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Frefutable-pattern-errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Frefutable-pattern-errors.rs?ref=f738423e6bec663e94fa16e5f9e5bec964678f83", "patch": "@@ -5,5 +5,5 @@ fn func((1, (Some(1), 2..=3)): (isize, (Option<isize>, isize))) { }\n \n fn main() {\n     let (1, (Some(1), 2..=3)) = (1, (None, 2));\n-    //~^ ERROR refutable pattern in local binding: `(std::i32::MIN..=0i32, _)` and `(2i32..=std::i32::MAX, _)` not covered\n+    //~^ ERROR refutable pattern in local binding: `(i32::MIN..=0i32, _)` and `(2i32..=i32::MAX, _)` not covered\n }"}, {"sha": "ac729ae9f7cdff4c5230ed9c51c6b36283c3ed0d", "filename": "src/test/ui/pattern/usefulness/refutable-pattern-errors.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f738423e6bec663e94fa16e5f9e5bec964678f83/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Frefutable-pattern-errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f738423e6bec663e94fa16e5f9e5bec964678f83/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Frefutable-pattern-errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Frefutable-pattern-errors.stderr?ref=f738423e6bec663e94fa16e5f9e5bec964678f83", "patch": "@@ -6,11 +6,11 @@ LL | fn func((1, (Some(1), 2..=3)): (isize, (Option<isize>, isize))) { }\n    |\n    = note: the matched value is of type `(isize, (std::option::Option<isize>, isize))`\n \n-error[E0005]: refutable pattern in local binding: `(std::i32::MIN..=0i32, _)` and `(2i32..=std::i32::MAX, _)` not covered\n+error[E0005]: refutable pattern in local binding: `(i32::MIN..=0i32, _)` and `(2i32..=i32::MAX, _)` not covered\n   --> $DIR/refutable-pattern-errors.rs:7:9\n    |\n LL |     let (1, (Some(1), 2..=3)) = (1, (None, 2));\n-   |         ^^^^^^^^^^^^^^^^^^^^^ patterns `(std::i32::MIN..=0i32, _)` and `(2i32..=std::i32::MAX, _)` not covered\n+   |         ^^^^^^^^^^^^^^^^^^^^^ patterns `(i32::MIN..=0i32, _)` and `(2i32..=i32::MAX, _)` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html"}, {"sha": "7b9e30f40fbb3ca48e4b878b0fcb44c13e3df5d8", "filename": "src/test/ui/precise_pointer_size_matching.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f738423e6bec663e94fa16e5f9e5bec964678f83/src%2Ftest%2Fui%2Fprecise_pointer_size_matching.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f738423e6bec663e94fa16e5f9e5bec964678f83/src%2Ftest%2Fui%2Fprecise_pointer_size_matching.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprecise_pointer_size_matching.stderr?ref=f738423e6bec663e94fa16e5f9e5bec964678f83", "patch": "@@ -1,17 +1,17 @@\n-error[E0004]: non-exhaustive patterns: `std::isize::MIN..=-6isize` and `21isize..=std::isize::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `isize::MIN..=-6isize` and `21isize..=isize::MAX` not covered\n   --> $DIR/precise_pointer_size_matching.rs:24:11\n    |\n LL |     match 0isize {\n-   |           ^^^^^^ patterns `std::isize::MIN..=-6isize` and `21isize..=std::isize::MAX` not covered\n+   |           ^^^^^^ patterns `isize::MIN..=-6isize` and `21isize..=isize::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `isize`\n \n-error[E0004]: non-exhaustive patterns: `0usize` and `21usize..=std::usize::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `0usize` and `21usize..=usize::MAX` not covered\n   --> $DIR/precise_pointer_size_matching.rs:29:11\n    |\n LL |     match 0usize {\n-   |           ^^^^^^ patterns `0usize` and `21usize..=std::usize::MAX` not covered\n+   |           ^^^^^^ patterns `0usize` and `21usize..=usize::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `usize`"}, {"sha": "21fb8d4a2e68dc37d1b4276675c5a64f214362f6", "filename": "src/test/ui/suggestions/const-pat-non-exaustive-let-new-var.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f738423e6bec663e94fa16e5f9e5bec964678f83/src%2Ftest%2Fui%2Fsuggestions%2Fconst-pat-non-exaustive-let-new-var.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f738423e6bec663e94fa16e5f9e5bec964678f83/src%2Ftest%2Fui%2Fsuggestions%2Fconst-pat-non-exaustive-let-new-var.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fconst-pat-non-exaustive-let-new-var.rs?ref=f738423e6bec663e94fa16e5f9e5bec964678f83", "patch": "@@ -1,6 +1,6 @@\n fn main() {\n     let A = 3;\n-    //~^ ERROR refutable pattern in local binding: `std::i32::MIN..=1i32` and\n+    //~^ ERROR refutable pattern in local binding: `i32::MIN..=1i32` and\n     //~| interpreted as a constant pattern, not a new variable\n     //~| HELP introduce a variable instead\n     //~| SUGGESTION a_var"}, {"sha": "7a6269da07f3260658cf2c9eecdfd740bc291731", "filename": "src/test/ui/suggestions/const-pat-non-exaustive-let-new-var.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f738423e6bec663e94fa16e5f9e5bec964678f83/src%2Ftest%2Fui%2Fsuggestions%2Fconst-pat-non-exaustive-let-new-var.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f738423e6bec663e94fa16e5f9e5bec964678f83/src%2Ftest%2Fui%2Fsuggestions%2Fconst-pat-non-exaustive-let-new-var.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fconst-pat-non-exaustive-let-new-var.stderr?ref=f738423e6bec663e94fa16e5f9e5bec964678f83", "patch": "@@ -1,4 +1,4 @@\n-error[E0005]: refutable pattern in local binding: `std::i32::MIN..=1i32` and `3i32..=std::i32::MAX` not covered\n+error[E0005]: refutable pattern in local binding: `i32::MIN..=1i32` and `3i32..=i32::MAX` not covered\n   --> $DIR/const-pat-non-exaustive-let-new-var.rs:2:9\n    |\n LL |     let A = 3;"}]}