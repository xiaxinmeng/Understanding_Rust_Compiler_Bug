{"sha": "deddb009f0003734d3c73fa859826d57ec600270", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlZGRiMDA5ZjAwMDM3MzRkM2M3M2ZhODU5ODI2ZDU3ZWM2MDAyNzA=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-08-03T07:07:20Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-08-03T07:07:20Z"}, "message": "Merge pull request #8244 from thestinger/for\n\nmake `for` parse as `foreach` does\r\n\r\nr=huonw, bors is acting up and this has been run through the try bots", "tree": {"sha": "3646e0cc53c8b1203e8b16d6efc21e4b46c52be3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3646e0cc53c8b1203e8b16d6efc21e4b46c52be3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/deddb009f0003734d3c73fa859826d57ec600270", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/deddb009f0003734d3c73fa859826d57ec600270", "html_url": "https://github.com/rust-lang/rust/commit/deddb009f0003734d3c73fa859826d57ec600270", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/deddb009f0003734d3c73fa859826d57ec600270/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a7be1c9e4d5a50dab4f3f95c8f1d843a7d6f084", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a7be1c9e4d5a50dab4f3f95c8f1d843a7d6f084", "html_url": "https://github.com/rust-lang/rust/commit/2a7be1c9e4d5a50dab4f3f95c8f1d843a7d6f084"}, {"sha": "87cf2864b1e427753f3153ee31aafcff19e253ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/87cf2864b1e427753f3153ee31aafcff19e253ca", "html_url": "https://github.com/rust-lang/rust/commit/87cf2864b1e427753f3153ee31aafcff19e253ca"}], "stats": {"total": 1630, "additions": 787, "deletions": 843}, "files": [{"sha": "19cd58bd3b403e03bf8d7aa46b01f45636ca12cb", "filename": "doc/tutorial-container.md", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/deddb009f0003734d3c73fa859826d57ec600270/doc%2Ftutorial-container.md", "raw_url": "https://github.com/rust-lang/rust/raw/deddb009f0003734d3c73fa859826d57ec600270/doc%2Ftutorial-container.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-container.md?ref=deddb009f0003734d3c73fa859826d57ec600270", "patch": "@@ -164,19 +164,18 @@ dropped when they become unnecessary.\n \n ## For loops\n \n-The `foreach` keyword is transitional, and is going to replace the current\n-obsolete `for` loop.\n+The `for` keyword can be used as sugar for iterating through any iterator:\n \n ~~~\n let xs = [2, 3, 5, 7, 11, 13, 17];\n \n // print out all the elements in the vector\n-foreach x in xs.iter() {\n+for x in xs.iter() {\n     println(x.to_str())\n }\n \n // print out all but the first 3 elements in the vector\n-foreach x in xs.iter().skip(3) {\n+for x in xs.iter().skip(3) {\n     println(x.to_str())\n }\n ~~~\n@@ -192,7 +191,7 @@ let ys = [\"foo\", \"bar\", \"baz\", \"foobar\"];\n let mut it = xs.iter().zip(ys.iter());\n \n // print out the pairs of elements up to (&3, &\"baz\")\n-foreach (x, y) in it {\n+for (x, y) in it {\n     printfln!(\"%d %s\", *x, *y);\n \n     if *x == 3 {\n@@ -229,7 +228,7 @@ impl<A, T: Iterator<A>> FromIterator<A, T> for ~[A] {\n     pub fn from_iterator(iterator: &mut T) -> ~[A] {\n         let (lower, _) = iterator.size_hint();\n         let mut xs = with_capacity(lower);\n-        foreach x in iterator {\n+        for x in iterator {\n             xs.push(x);\n         }\n         xs\n@@ -300,7 +299,7 @@ printfln!(\"%?\", it.next()); // prints `Some(&2)`\n printfln!(\"%?\", it.next_back()); // prints `Some(&6)`\n \n // prints `5`, `4` and `3`\n-foreach &x in it.invert() {\n+for &x in it.invert() {\n     printfln!(\"%?\", x)\n }\n ~~~\n@@ -319,7 +318,7 @@ let mut it = xs.iter().chain_(ys.iter()).transform(|&x| x * 2);\n printfln!(\"%?\", it.next()); // prints `Some(2)`\n \n // prints `16`, `14`, `12`, `10`, `8`, `6`, `4`\n-foreach x in it.invert() {\n+for x in it.invert() {\n     printfln!(\"%?\", x);\n }\n ~~~"}, {"sha": "a5f2001eaf515b2f624d101c8860f60f0f0f9f39", "filename": "doc/tutorial.md", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/deddb009f0003734d3c73fa859826d57ec600270/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/deddb009f0003734d3c73fa859826d57ec600270/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=deddb009f0003734d3c73fa859826d57ec600270", "patch": "@@ -567,11 +567,6 @@ loop {\n This code prints out a weird sequence of numbers and stops as soon as\n it finds one that can be divided by five.\n \n-Rust also has a `for` construct. It's different from C's `for` and it works\n-best when iterating over collections. See the section on [closures](#closures)\n-to find out how to use `for` and higher-order functions for enumerating\n-elements of a collection.\n-\n # Data structures\n \n ## Structs\n@@ -1397,8 +1392,8 @@ assert!(crayons.len() == 3);\n assert!(!crayons.is_empty());\n \n // Iterate over a vector, obtaining a pointer to each element\n-// (`for` is explained in the next section)\n-foreach crayon in crayons.iter() {\n+// (`for` is explained in the container/iterator tutorial)\n+for crayon in crayons.iter() {\n     let delicious_crayon_wax = unwrap_crayon(*crayon);\n     eat_crayon_wax(delicious_crayon_wax);\n }\n@@ -1749,7 +1744,7 @@ of `vector`:\n ~~~~\n fn map<T, U>(vector: &[T], function: &fn(v: &T) -> U) -> ~[U] {\n     let mut accumulator = ~[];\n-    foreach element in vector.iter() {\n+    for element in vector.iter() {\n         accumulator.push(function(element));\n     }\n     return accumulator;\n@@ -2027,7 +2022,7 @@ generic types.\n ~~~~\n # trait Printable { fn print(&self); }\n fn print_all<T: Printable>(printable_things: ~[T]) {\n-    foreach thing in printable_things.iter() {\n+    for thing in printable_things.iter() {\n         thing.print();\n     }\n }\n@@ -2073,7 +2068,7 @@ However, consider this function:\n trait Drawable { fn draw(&self); }\n \n fn draw_all<T: Drawable>(shapes: ~[T]) {\n-    foreach shape in shapes.iter() { shape.draw(); }\n+    for shape in shapes.iter() { shape.draw(); }\n }\n # let c: Circle = new_circle();\n # draw_all(~[c]);\n@@ -2088,7 +2083,7 @@ an _object_.\n ~~~~\n # trait Drawable { fn draw(&self); }\n fn draw_all(shapes: &[@Drawable]) {\n-    foreach shape in shapes.iter() { shape.draw(); }\n+    for shape in shapes.iter() { shape.draw(); }\n }\n ~~~~\n "}, {"sha": "a07da151afc3b8d244a4b1f710b69787f82d8f2c", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/deddb009f0003734d3c73fa859826d57ec600270/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deddb009f0003734d3c73fa859826d57ec600270/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=deddb009f0003734d3c73fa859826d57ec600270", "patch": "@@ -41,7 +41,7 @@ pub fn load_props(testfile: &Path) -> TestProps {\n     let mut pp_exact = None;\n     let mut debugger_cmds = ~[];\n     let mut check_lines = ~[];\n-    for iter_header(testfile) |ln| {\n+    do iter_header(testfile) |ln| {\n         match parse_error_pattern(ln) {\n           Some(ep) => error_patterns.push(ep),\n           None => ()\n@@ -74,6 +74,8 @@ pub fn load_props(testfile: &Path) -> TestProps {\n             Some(cl) => check_lines.push(cl),\n             None => ()\n         };\n+\n+        true\n     };\n     return TestProps {\n         error_patterns: error_patterns,\n@@ -87,17 +89,19 @@ pub fn load_props(testfile: &Path) -> TestProps {\n }\n \n pub fn is_test_ignored(config: &config, testfile: &Path) -> bool {\n-    for iter_header(testfile) |ln| {\n-        if parse_name_directive(ln, \"xfail-test\") { return true; }\n-        if parse_name_directive(ln, xfail_target()) { return true; }\n-        if config.mode == common::mode_pretty &&\n-           parse_name_directive(ln, \"xfail-pretty\") { return true; }\n-    };\n-    return false;\n-\n     fn xfail_target() -> ~str {\n         ~\"xfail-\" + os::SYSNAME\n     }\n+\n+    let val = do iter_header(testfile) |ln| {\n+        if parse_name_directive(ln, \"xfail-test\") { false }\n+        else if parse_name_directive(ln, xfail_target()) { false }\n+        else if config.mode == common::mode_pretty &&\n+            parse_name_directive(ln, \"xfail-pretty\") { false }\n+        else { true }\n+    };\n+\n+    !val\n }\n \n fn iter_header(testfile: &Path, it: &fn(~str) -> bool) -> bool {\n@@ -109,7 +113,7 @@ fn iter_header(testfile: &Path, it: &fn(~str) -> bool) -> bool {\n         // module or function. This doesn't seem to be an optimization\n         // with a warm page cache. Maybe with a cold one.\n         if ln.starts_with(\"fn\") || ln.starts_with(\"mod\") {\n-            return false;\n+            return true;\n         } else { if !(it(ln)) { return false; } }\n     }\n     return true;"}, {"sha": "7a71d3f667f787018836469719f2b23011b3352d", "filename": "src/libextra/bitv.rs", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibextra%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibextra%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbitv.rs?ref=deddb009f0003734d3c73fa859826d57ec600270", "patch": "@@ -206,13 +206,14 @@ impl BigBitv {\n     #[inline]\n     pub fn equals(&self, b: &BigBitv, nbits: uint) -> bool {\n         let len = b.storage.len();\n-        for uint::iterate(0, len) |i| {\n+        do uint::iterate(0, len) |i| {\n             let mask = big_mask(nbits, i);\n             if mask & self.storage[i] != mask & b.storage[i] {\n-                return false;\n+                false\n+            } else {\n+                true\n             }\n         }\n-        return true;\n     }\n }\n \n@@ -358,7 +359,7 @@ impl Bitv {\n     pub fn clear(&mut self) {\n         match self.rep {\n           Small(ref mut b) => b.clear(),\n-          Big(ref mut s) => for s.each_storage() |w| { *w = 0u }\n+          Big(ref mut s) => { do s.each_storage() |w| { *w = 0u; true }; }\n         }\n     }\n \n@@ -367,15 +368,17 @@ impl Bitv {\n     pub fn set_all(&mut self) {\n       match self.rep {\n         Small(ref mut b) => b.set_all(),\n-        Big(ref mut s) => for s.each_storage() |w| { *w = !0u } }\n+        Big(ref mut s) => { do s.each_storage() |w| { *w = !0u; true }; }\n+      }\n     }\n \n     /// Invert all bits\n     #[inline]\n     pub fn negate(&mut self) {\n       match self.rep {\n         Small(ref mut b) => b.negate(),\n-        Big(ref mut s) => for s.each_storage() |w| { *w = !*w } }\n+        Big(ref mut s) => { do s.each_storage() |w| { *w = !*w; true }; }\n+      }\n     }\n \n     /**\n@@ -718,11 +721,11 @@ impl BitvSet {\n     }\n \n     pub fn difference(&self, other: &BitvSet, f: &fn(&uint) -> bool) -> bool {\n-        for self.common_iter(other).advance |(i, w1, w2)| {\n+        foreach (i, w1, w2) in self.common_iter(other) {\n             if !iterate_bits(i, w1 & !w2, |b| f(&b)) {\n-                return false;\n+                return false\n             }\n-        }\n+        };\n         /* everything we have that they don't also shows up */\n         self.outlier_iter(other).advance(|(mine, i, w)|\n             !mine || iterate_bits(i, w, |b| f(&b))\n@@ -731,11 +734,11 @@ impl BitvSet {\n \n     pub fn symmetric_difference(&self, other: &BitvSet,\n                             f: &fn(&uint) -> bool) -> bool {\n-        for self.common_iter(other).advance |(i, w1, w2)| {\n+        foreach (i, w1, w2) in self.common_iter(other) {\n             if !iterate_bits(i, w1 ^ w2, |b| f(&b)) {\n-                return false;\n+                return false\n             }\n-        }\n+        };\n         self.outlier_iter(other).advance(|(_, i, w)| iterate_bits(i, w, |b| f(&b)))\n     }\n \n@@ -744,11 +747,11 @@ impl BitvSet {\n     }\n \n     pub fn union(&self, other: &BitvSet, f: &fn(&uint) -> bool) -> bool {\n-        for self.common_iter(other).advance |(i, w1, w2)| {\n+        foreach (i, w1, w2) in self.common_iter(other) {\n             if !iterate_bits(i, w1 | w2, |b| f(&b)) {\n-                return false;\n+                return false\n             }\n-        }\n+        };\n         self.outlier_iter(other).advance(|(_, i, w)| iterate_bits(i, w, |b| f(&b)))\n     }\n }\n@@ -758,12 +761,12 @@ impl cmp::Eq for BitvSet {\n         if self.size != other.size {\n             return false;\n         }\n-        for self.common_iter(other).advance |(_, w1, w2)| {\n+        foreach (_, w1, w2) in self.common_iter(other) {\n             if w1 != w2 {\n                 return false;\n             }\n         }\n-        for self.outlier_iter(other).advance |(_, _, w)| {\n+        foreach (_, _, w) in self.outlier_iter(other) {\n             if w != 0 {\n                 return false;\n             }\n@@ -798,15 +801,15 @@ impl Set<uint> for BitvSet {\n     }\n \n     fn is_subset(&self, other: &BitvSet) -> bool {\n-        for self.common_iter(other).advance |(_, w1, w2)| {\n+        foreach (_, w1, w2) in self.common_iter(other) {\n             if w1 & w2 != w1 {\n                 return false;\n             }\n         }\n         /* If anything is not ours, then everything is not ours so we're\n            definitely a subset in that case. Otherwise if there's any stray\n            ones that 'other' doesn't have, we're not a subset. */\n-        for self.outlier_iter(other).advance |(mine, _, w)| {\n+        foreach (mine, _, w) in self.outlier_iter(other) {\n             if !mine {\n                 return true;\n             } else if w != 0 {"}, {"sha": "06e96d99bca95f03eff9c625b45f3465ac1d7713", "filename": "src/libextra/crypto/sha2.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibextra%2Fcrypto%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibextra%2Fcrypto%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fsha2.rs?ref=deddb009f0003734d3c73fa859826d57ec600270", "patch": "@@ -112,7 +112,7 @@ impl Engine512State {\n \n         // Putting the message schedule inside the same loop as the round calculations allows for\n         // the compiler to generate better code.\n-        for uint::range_step(0, 64, 8) |t| {\n+        do uint::range_step(0, 64, 8) |t| {\n             schedule_round!(t + 16);\n             schedule_round!(t + 17);\n             schedule_round!(t + 18);\n@@ -130,9 +130,10 @@ impl Engine512State {\n             sha2_round!(d, e, f, g, h, a, b, c, K64, t + 5);\n             sha2_round!(c, d, e, f, g, h, a, b, K64, t + 6);\n             sha2_round!(b, c, d, e, f, g, h, a, K64, t + 7);\n-        }\n+            true\n+        };\n \n-        for uint::range_step(64, 80, 8) |t| {\n+        do uint::range_step(64, 80, 8) |t| {\n             sha2_round!(a, b, c, d, e, f, g, h, K64, t);\n             sha2_round!(h, a, b, c, d, e, f, g, K64, t + 1);\n             sha2_round!(g, h, a, b, c, d, e, f, K64, t + 2);\n@@ -141,7 +142,8 @@ impl Engine512State {\n             sha2_round!(d, e, f, g, h, a, b, c, K64, t + 5);\n             sha2_round!(c, d, e, f, g, h, a, b, K64, t + 6);\n             sha2_round!(b, c, d, e, f, g, h, a, K64, t + 7);\n-        }\n+            true\n+        };\n \n         self.H0 += a;\n         self.H1 += b;\n@@ -507,7 +509,7 @@ impl Engine256State {\n \n         // Putting the message schedule inside the same loop as the round calculations allows for\n         // the compiler to generate better code.\n-        for uint::range_step(0, 48, 8) |t| {\n+        do uint::range_step(0, 48, 8) |t| {\n             schedule_round!(t + 16);\n             schedule_round!(t + 17);\n             schedule_round!(t + 18);\n@@ -525,9 +527,10 @@ impl Engine256State {\n             sha2_round!(d, e, f, g, h, a, b, c, K32, t + 5);\n             sha2_round!(c, d, e, f, g, h, a, b, K32, t + 6);\n             sha2_round!(b, c, d, e, f, g, h, a, K32, t + 7);\n-        }\n+            true\n+        };\n \n-        for uint::range_step(48, 64, 8) |t| {\n+        do uint::range_step(48, 64, 8) |t| {\n             sha2_round!(a, b, c, d, e, f, g, h, K32, t);\n             sha2_round!(h, a, b, c, d, e, f, g, K32, t + 1);\n             sha2_round!(g, h, a, b, c, d, e, f, K32, t + 2);\n@@ -536,7 +539,8 @@ impl Engine256State {\n             sha2_round!(d, e, f, g, h, a, b, c, K32, t + 5);\n             sha2_round!(c, d, e, f, g, h, a, b, K32, t + 6);\n             sha2_round!(b, c, d, e, f, g, h, a, K32, t + 7);\n-        }\n+            true\n+        };\n \n         self.H0 += a;\n         self.H1 += b;"}, {"sha": "2094259664cf9092290a90f1b9799be503795f22", "filename": "src/libextra/fileinput.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibextra%2Ffileinput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibextra%2Ffileinput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffileinput.rs?ref=deddb009f0003734d3c73fa859826d57ec600270", "patch": "@@ -505,9 +505,10 @@ mod test {\n         }\n \n         let mut read_lines = ~[];\n-        for input_vec(filenames) |line| {\n+        do input_vec(filenames) |line| {\n             read_lines.push(line.to_owned());\n-        }\n+            true\n+        };\n         assert_eq!(read_lines, all_lines);\n     }\n \n@@ -523,13 +524,14 @@ mod test {\n             make_file(filename.get_ref(), contents);\n         }\n \n-        for input_vec_state(filenames) |line, state| {\n+        do input_vec_state(filenames) |line, state| {\n             let nums: ~[&str] = line.split_iter(' ').collect();\n             let file_num = uint::from_str(nums[0]).get();\n             let line_num = uint::from_str(nums[1]).get();\n             assert_eq!(line_num, state.line_num_file);\n             assert_eq!(file_num * 3 + line_num, state.line_num);\n-        }\n+            true\n+        };\n     }\n \n     #[test]\n@@ -543,15 +545,16 @@ mod test {\n         make_file(filenames[2].get_ref(), [~\"3\", ~\"4\"]);\n \n         let mut count = 0;\n-        for input_vec_state(filenames.clone()) |line, state| {\n+        do input_vec_state(filenames.clone()) |line, state| {\n             let expected_path = match line {\n                 \"1\" | \"2\" => filenames[0].clone(),\n                 \"3\" | \"4\" => filenames[2].clone(),\n                 _ => fail!(\"unexpected line\")\n             };\n             assert_eq!(state.current_path.clone(), expected_path);\n             count += 1;\n-        }\n+            true\n+        };\n         assert_eq!(count, 4);\n     }\n \n@@ -570,9 +573,10 @@ mod test {\n         wr.write_str(\"3\\n4\");\n \n         let mut lines = ~[];\n-        for input_vec(~[f1, f2]) |line| {\n+        do input_vec(~[f1, f2]) |line| {\n             lines.push(line.to_owned());\n-        }\n+            true\n+        };\n         assert_eq!(lines, ~[~\"1\", ~\"2\", ~\"3\", ~\"4\"]);\n     }\n \n@@ -610,8 +614,9 @@ mod test {\n     #[test]\n     #[should_fail]\n     fn test_input_vec_missing_file() {\n-        for input_vec(pathify([~\"this/file/doesnt/exist\"], true)) |line| {\n+        do input_vec(pathify([~\"this/file/doesnt/exist\"], true)) |line| {\n             println(line);\n-        }\n+            true\n+        };\n     }\n }"}, {"sha": "8b8e3faaf9a24da4c140990e92cc0a5aa6f2faae", "filename": "src/libextra/smallintmap.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibextra%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibextra%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsmallintmap.rs?ref=deddb009f0003734d3c73fa859826d57ec600270", "patch": "@@ -155,13 +155,12 @@ impl<V> SmallIntMap<V> {\n \n     /// Visit all key-value pairs in reverse order\n     pub fn each_reverse<'a>(&'a self, it: &fn(uint, &'a V) -> bool) -> bool {\n-        for uint::range_rev(self.v.len(), 0) |i| {\n+        do uint::range_rev(self.v.len(), 0) |i| {\n             match self.v[i] {\n-              Some(ref elt) => if !it(i, elt) { return false; },\n-              None => ()\n+              Some(ref elt) => it(i, elt),\n+              None => true\n             }\n         }\n-        return true;\n     }\n \n     pub fn get<'a>(&'a self, key: &uint) -> &'a V {"}, {"sha": "9a681bf6a0771bacf0f237e59c138deb8407c23d", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=deddb009f0003734d3c73fa859826d57ec600270", "patch": "@@ -148,7 +148,7 @@ struct crate_hash {\n pub fn get_dep_hashes(cstore: &CStore) -> ~[@str] {\n     let mut result = ~[];\n \n-    for cstore.extern_mod_crate_map.each_value |&cnum| {\n+    foreach (_, &cnum) in cstore.extern_mod_crate_map.iter() {\n         let cdata = cstore::get_crate_data(cstore, cnum);\n         let hash = decoder::get_crate_hash(cdata.data);\n         let vers = decoder::get_crate_vers(cdata.data);"}, {"sha": "4824fe55f1d1707dc52bdb53392a1dcaf6d92432", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 100, "deletions": 81, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=deddb009f0003734d3c73fa859826d57ec600270", "patch": "@@ -60,13 +60,18 @@ fn lookup_hash(d: ebml::Doc, eq_fn: &fn(x:&[u8]) -> bool, hash: uint) ->\n     let tagged_doc = reader::doc_at(d.data, pos);\n \n     let belt = tag_index_buckets_bucket_elt;\n-    for reader::tagged_docs(tagged_doc.doc, belt) |elt| {\n+\n+    let mut ret = None;\n+    do reader::tagged_docs(tagged_doc.doc, belt) |elt| {\n         let pos = io::u64_from_be_bytes(*elt.data, elt.start, 4u) as uint;\n         if eq_fn(elt.data.slice(elt.start + 4u, elt.end)) {\n-            return Some(reader::doc_at(d.data, pos).doc);\n+            ret = Some(reader::doc_at(d.data, pos).doc);\n+            false\n+        } else {\n+            true\n         }\n     };\n-    None\n+    ret\n }\n \n pub type GetCrateDataCb<'self> = &'self fn(ast::CrateNum) -> cmd;\n@@ -160,21 +165,25 @@ fn item_visibility(item: ebml::Doc) -> ast::visibility {\n }\n \n fn item_method_sort(item: ebml::Doc) -> char {\n-    for reader::tagged_docs(item, tag_item_trait_method_sort) |doc| {\n-        return doc.as_str_slice()[0] as char;\n-    }\n-    return 'r';\n+    let mut ret = 'r';\n+    do reader::tagged_docs(item, tag_item_trait_method_sort) |doc| {\n+        ret = doc.as_str_slice()[0] as char;\n+        false\n+    };\n+    ret\n }\n \n fn item_symbol(item: ebml::Doc) -> ~str {\n     reader::get_doc(item, tag_items_data_item_symbol).as_str()\n }\n \n fn item_parent_item(d: ebml::Doc) -> Option<ast::def_id> {\n-    for reader::tagged_docs(d, tag_items_data_parent_item) |did| {\n-        return Some(reader::with_doc_data(did, parse_def_id));\n-    }\n-    None\n+    let mut ret = None;\n+    do reader::tagged_docs(d, tag_items_data_parent_item) |did| {\n+        ret = Some(reader::with_doc_data(did, parse_def_id));\n+        false\n+    };\n+    ret\n }\n \n fn item_reqd_and_translated_parent_item(cnum: ast::CrateNum,\n@@ -195,12 +204,7 @@ fn get_provided_source(d: ebml::Doc, cdata: cmd) -> Option<ast::def_id> {\n }\n \n fn each_reexport(d: ebml::Doc, f: &fn(ebml::Doc) -> bool) -> bool {\n-    for reader::tagged_docs(d, tag_items_data_item_reexport) |reexport_doc| {\n-        if !f(reexport_doc) {\n-            return false;\n-        }\n-    }\n-    return true;\n+    reader::tagged_docs(d, tag_items_data_item_reexport, f)\n }\n \n fn variant_disr_val(d: ebml::Doc) -> Option<uint> {\n@@ -250,12 +254,13 @@ fn item_ty_param_defs(item: ebml::Doc, tcx: ty::ctxt, cdata: cmd,\n                       tag: uint)\n     -> @~[ty::TypeParameterDef] {\n     let mut bounds = ~[];\n-    for reader::tagged_docs(item, tag) |p| {\n+    do reader::tagged_docs(item, tag) |p| {\n         let bd = parse_type_param_def_data(\n             *p.data, p.start, cdata.cnum, tcx,\n             |_, did| translate_def_id(cdata, did));\n         bounds.push(bd);\n-    }\n+        true\n+    };\n     @bounds\n }\n \n@@ -276,9 +281,10 @@ fn item_ty_param_count(item: ebml::Doc) -> uint {\n fn enum_variant_ids(item: ebml::Doc, cdata: cmd) -> ~[ast::def_id] {\n     let mut ids: ~[ast::def_id] = ~[];\n     let v = tag_items_data_item_variant;\n-    for reader::tagged_docs(item, v) |p| {\n+    do reader::tagged_docs(item, v) |p| {\n         let ext = reader::with_doc_data(p, parse_def_id);\n         ids.push(ast::def_id { crate: cdata.cnum, node: ext.node });\n+        true\n     };\n     return ids;\n }\n@@ -290,7 +296,7 @@ fn item_path(item_doc: ebml::Doc) -> ast_map::path {\n     let len = reader::doc_as_u32(len_doc) as uint;\n \n     let mut result = vec::with_capacity(len);\n-    for reader::docs(path_doc) |tag, elt_doc| {\n+    do reader::docs(path_doc) |tag, elt_doc| {\n         if tag == tag_path_elt_mod {\n             let str = elt_doc.as_str_slice();\n             result.push(ast_map::path_mod(token::str_to_ident(str)));\n@@ -300,7 +306,8 @@ fn item_path(item_doc: ebml::Doc) -> ast_map::path {\n         } else {\n             // ignore tag_path_len element\n         }\n-    }\n+        true\n+    };\n \n     return result;\n }\n@@ -432,13 +439,13 @@ pub fn get_impl_method(intr: @ident_interner, cdata: cmd, id: ast::NodeId,\n                        name: ast::ident) -> Option<ast::def_id> {\n     let items = reader::get_doc(reader::Doc(cdata.data), tag_items);\n     let mut found = None;\n-    for reader::tagged_docs(find_item(id, items), tag_item_impl_method)\n-        |mid| {\n-            let m_did = reader::with_doc_data(mid, parse_def_id);\n-            if item_name(intr, find_item(m_did.node, items)) == name {\n-                found = Some(translate_def_id(cdata, m_did));\n-            }\n+    do reader::tagged_docs(find_item(id, items), tag_item_impl_method) |mid| {\n+        let m_did = reader::with_doc_data(mid, parse_def_id);\n+        if item_name(intr, find_item(m_did.node, items)) == name {\n+            found = Some(translate_def_id(cdata, m_did));\n         }\n+        true\n+    };\n     found\n }\n \n@@ -465,18 +472,15 @@ fn def_like_to_def(def_like: def_like) -> ast::def {\n pub fn each_lang_item(cdata: cmd, f: &fn(ast::NodeId, uint) -> bool) -> bool {\n     let root = reader::Doc(cdata.data);\n     let lang_items = reader::get_doc(root, tag_lang_items);\n-    for reader::tagged_docs(lang_items, tag_lang_items_item) |item_doc| {\n+    do reader::tagged_docs(lang_items, tag_lang_items_item) |item_doc| {\n         let id_doc = reader::get_doc(item_doc, tag_lang_items_item_id);\n         let id = reader::doc_as_u32(id_doc) as uint;\n         let node_id_doc = reader::get_doc(item_doc,\n                                           tag_lang_items_item_node_id);\n         let node_id = reader::doc_as_u32(node_id_doc) as ast::NodeId;\n \n-        if !f(node_id, id) {\n-            return false;\n-        }\n+        f(node_id, id)\n     }\n-    return true;\n }\n \n struct EachItemContext<'self> {\n@@ -581,7 +585,7 @@ impl<'self> EachItemContext<'self> {\n         let mut continue = true;\n \n         // Iterate over all children.\n-        for reader::tagged_docs(item_doc, tag_mod_child) |child_info_doc| {\n+        do reader::tagged_docs(item_doc, tag_mod_child) |child_info_doc| {\n             let child_def_id = reader::with_doc_data(child_info_doc,\n                                                      parse_def_id);\n             let child_def_id = translate_def_id(self.cdata, child_def_id);\n@@ -621,20 +625,17 @@ impl<'self> EachItemContext<'self> {\n                     continue = self.process_item_and_pop_name(child_item_doc,\n                                                               child_def_id,\n                                                               old_len);\n-\n-                    if !continue {\n-                        break\n-                    }\n                 }\n             }\n-        }\n+            continue\n+        };\n \n         if !continue {\n             return false\n         }\n \n         // Iterate over reexports.\n-        for each_reexport(item_doc) |reexport_doc| {\n+        do each_reexport(item_doc) |reexport_doc| {\n             let def_id_doc = reader::get_doc(\n                 reexport_doc,\n                 tag_items_data_item_reexport_def_id);\n@@ -678,10 +679,8 @@ impl<'self> EachItemContext<'self> {\n                 }\n             }\n \n-            if !continue {\n-                break\n-            }\n-        }\n+            continue\n+        };\n \n         continue\n     }\n@@ -824,10 +823,11 @@ fn get_explicit_self(item: ebml::Doc) -> ast::explicit_self_ {\n fn item_impl_methods(intr: @ident_interner, cdata: cmd, item: ebml::Doc,\n                      tcx: ty::ctxt) -> ~[@ty::Method] {\n     let mut rslt = ~[];\n-    for reader::tagged_docs(item, tag_item_impl_method) |doc| {\n+    do reader::tagged_docs(item, tag_item_impl_method) |doc| {\n         let m_did = reader::with_doc_data(doc, parse_def_id);\n         rslt.push(@get_method(intr, cdata, m_did.node, tcx));\n-    }\n+        true\n+    };\n \n     rslt\n }\n@@ -896,9 +896,10 @@ pub fn get_trait_method_def_ids(cdata: cmd,\n     let data = cdata.data;\n     let item = lookup_item(id, data);\n     let mut result = ~[];\n-    for reader::tagged_docs(item, tag_item_trait_method) |mth| {\n+    do reader::tagged_docs(item, tag_item_trait_method) |mth| {\n         result.push(item_def_id(mth, cdata));\n-    }\n+        true\n+    };\n     result\n }\n \n@@ -909,14 +910,15 @@ pub fn get_provided_trait_methods(intr: @ident_interner, cdata: cmd,\n     let item = lookup_item(id, data);\n     let mut result = ~[];\n \n-    for reader::tagged_docs(item, tag_item_trait_method) |mth_id| {\n+    do reader::tagged_docs(item, tag_item_trait_method) |mth_id| {\n         let did = item_def_id(mth_id, cdata);\n         let mth = lookup_item(did.node, data);\n \n-        if item_method_sort(mth) != 'p' { loop; }\n-\n-        result.push(@get_method(intr, cdata, did.node, tcx));\n-    }\n+        if item_method_sort(mth) == 'p' {\n+            result.push(@get_method(intr, cdata, did.node, tcx));\n+        }\n+        true\n+    };\n \n     return result;\n }\n@@ -926,9 +928,10 @@ pub fn get_supertraits(cdata: cmd, id: ast::NodeId, tcx: ty::ctxt)\n                     -> ~[@ty::TraitRef] {\n     let mut results = ~[];\n     let item_doc = lookup_item(id, cdata.data);\n-    for reader::tagged_docs(item_doc, tag_item_super_trait_ref) |trait_doc| {\n+    do reader::tagged_docs(item_doc, tag_item_super_trait_ref) |trait_doc| {\n         results.push(@doc_trait_ref(trait_doc, tcx, cdata));\n-    }\n+        true\n+    };\n     return results;\n }\n \n@@ -939,11 +942,13 @@ pub fn get_type_name_if_impl(cdata: cmd,\n         return None;\n     }\n \n-    for reader::tagged_docs(item, tag_item_impl_type_basename) |doc| {\n-        return Some(token::str_to_ident(doc.as_str_slice()));\n-    }\n+    let mut ret = None;\n+    do reader::tagged_docs(item, tag_item_impl_type_basename) |doc| {\n+        ret = Some(token::str_to_ident(doc.as_str_slice()));\n+        false\n+    };\n \n-    return None;\n+    ret\n }\n \n pub fn get_static_methods_if_impl(intr: @ident_interner,\n@@ -956,14 +961,17 @@ pub fn get_static_methods_if_impl(intr: @ident_interner,\n     }\n \n     // If this impl implements a trait, don't consider it.\n-    for reader::tagged_docs(item, tag_item_trait_ref) |_doc| {\n-        return None;\n-    }\n+    let ret = do reader::tagged_docs(item, tag_item_trait_ref) |_doc| {\n+        false\n+    };\n+\n+    if !ret { return None }\n \n     let mut impl_method_ids = ~[];\n-    for reader::tagged_docs(item, tag_item_impl_method) |impl_method_doc| {\n+    do reader::tagged_docs(item, tag_item_impl_method) |impl_method_doc| {\n         impl_method_ids.push(reader::with_doc_data(impl_method_doc, parse_def_id));\n-    }\n+        true\n+    };\n \n     let mut static_impl_methods = ~[];\n     foreach impl_method_id in impl_method_ids.iter() {\n@@ -996,11 +1004,13 @@ pub fn get_item_attrs(cdata: cmd,\n                       f: &fn(~[@ast::MetaItem])) {\n \n     let item = lookup_item(node_id, cdata.data);\n-    for reader::tagged_docs(item, tag_attributes) |attributes| {\n-        for reader::tagged_docs(attributes, tag_attribute) |attribute| {\n+    do reader::tagged_docs(item, tag_attributes) |attributes| {\n+        do reader::tagged_docs(attributes, tag_attribute) |attribute| {\n             f(get_meta_items(attribute));\n-        }\n-    }\n+            true\n+        };\n+        true\n+    };\n }\n \n fn struct_field_family_to_visibility(family: Family) -> ast::visibility {\n@@ -1017,7 +1027,7 @@ pub fn get_struct_fields(intr: @ident_interner, cdata: cmd, id: ast::NodeId)\n     let data = cdata.data;\n     let item = lookup_item(id, data);\n     let mut result = ~[];\n-    for reader::tagged_docs(item, tag_item_field) |an_item| {\n+    do reader::tagged_docs(item, tag_item_field) |an_item| {\n         let f = item_family(an_item);\n         if f == PublicField || f == PrivateField || f == InheritedField {\n             let name = item_name(intr, an_item);\n@@ -1028,15 +1038,17 @@ pub fn get_struct_fields(intr: @ident_interner, cdata: cmd, id: ast::NodeId)\n                 struct_field_family_to_visibility(f),\n             });\n         }\n-    }\n-    for reader::tagged_docs(item, tag_item_unnamed_field) |an_item| {\n+        true\n+    };\n+    do reader::tagged_docs(item, tag_item_unnamed_field) |an_item| {\n         let did = item_def_id(an_item, cdata);\n         result.push(ty::field_ty {\n             ident: special_idents::unnamed_field,\n             id: did,\n             vis: ast::inherited,\n         });\n-    }\n+        true\n+    };\n     result\n }\n \n@@ -1102,25 +1114,28 @@ fn item_family_to_str(fam: Family) -> ~str {\n \n fn get_meta_items(md: ebml::Doc) -> ~[@ast::MetaItem] {\n     let mut items: ~[@ast::MetaItem] = ~[];\n-    for reader::tagged_docs(md, tag_meta_item_word) |meta_item_doc| {\n+    do reader::tagged_docs(md, tag_meta_item_word) |meta_item_doc| {\n         let nd = reader::get_doc(meta_item_doc, tag_meta_item_name);\n         let n = nd.as_str_slice().to_managed();\n         items.push(attr::mk_word_item(n));\n+        true\n     };\n-    for reader::tagged_docs(md, tag_meta_item_name_value) |meta_item_doc| {\n+    do reader::tagged_docs(md, tag_meta_item_name_value) |meta_item_doc| {\n         let nd = reader::get_doc(meta_item_doc, tag_meta_item_name);\n         let vd = reader::get_doc(meta_item_doc, tag_meta_item_value);\n         let n = nd.as_str_slice().to_managed();\n         let v = vd.as_str_slice().to_managed();\n         // FIXME (#623): Should be able to decode MetaNameValue variants,\n         // but currently the encoder just drops them\n         items.push(attr::mk_name_value_item_str(n, v));\n+        true\n     };\n-    for reader::tagged_docs(md, tag_meta_item_list) |meta_item_doc| {\n+    do reader::tagged_docs(md, tag_meta_item_list) |meta_item_doc| {\n         let nd = reader::get_doc(meta_item_doc, tag_meta_item_name);\n         let n = nd.as_str_slice().to_managed();\n         let subitems = get_meta_items(meta_item_doc);\n         items.push(attr::mk_list_item(n, subitems));\n+        true\n     };\n     return items;\n }\n@@ -1129,7 +1144,7 @@ fn get_attributes(md: ebml::Doc) -> ~[ast::Attribute] {\n     let mut attrs: ~[ast::Attribute] = ~[];\n     match reader::maybe_get_doc(md, tag_attributes) {\n       option::Some(attrs_d) => {\n-        for reader::tagged_docs(attrs_d, tag_attribute) |attr_doc| {\n+        do reader::tagged_docs(attrs_d, tag_attribute) |attr_doc| {\n             let meta_items = get_meta_items(attr_doc);\n             // Currently it's only possible to have a single meta item on\n             // an attribute\n@@ -1144,6 +1159,7 @@ fn get_attributes(md: ebml::Doc) -> ~[ast::Attribute] {\n                     },\n                     span: codemap::dummy_sp()\n                 });\n+            true\n         };\n       }\n       option::None => ()\n@@ -1193,12 +1209,13 @@ pub fn get_crate_deps(data: @~[u8]) -> ~[crate_dep] {\n         let d = reader::get_doc(doc, tag_);\n         d.as_str_slice().to_managed()\n     }\n-    for reader::tagged_docs(depsdoc, tag_crate_dep) |depdoc| {\n+    do reader::tagged_docs(depsdoc, tag_crate_dep) |depdoc| {\n         deps.push(crate_dep {cnum: crate_num,\n                   name: token::str_to_ident(docstr(depdoc, tag_crate_dep_name)),\n                   vers: docstr(depdoc, tag_crate_dep_vers),\n                   hash: docstr(depdoc, tag_crate_dep_hash)});\n         crate_num += 1;\n+        true\n     };\n     return deps;\n }\n@@ -1235,15 +1252,16 @@ pub fn get_crate_vers(data: @~[u8]) -> @str {\n fn iter_crate_items(intr: @ident_interner, cdata: cmd,\n                     get_crate_data: GetCrateDataCb,\n                     proc: &fn(path: &str, ast::def_id)) {\n-    for each_path(intr, cdata, get_crate_data) |path_string, def_like, _| {\n+    do each_path(intr, cdata, get_crate_data) |path_string, def_like, _| {\n         match def_like {\n             dl_impl(*) | dl_field => {}\n             dl_def(def) => {\n                 proc(path_string,\n                      ast_util::def_id_of_def(def))\n             }\n         }\n-    }\n+        true\n+    };\n }\n \n pub fn list_crate_metadata(intr: @ident_interner, bytes: @~[u8],\n@@ -1273,8 +1291,9 @@ pub fn translate_def_id(cdata: cmd, did: ast::def_id) -> ast::def_id {\n pub fn get_link_args_for_crate(cdata: cmd) -> ~[~str] {\n     let link_args = reader::get_doc(reader::Doc(cdata.data), tag_link_args);\n     let mut result = ~[];\n-    for reader::tagged_docs(link_args, tag_link_args_arg) |arg_doc| {\n+    do reader::tagged_docs(link_args, tag_link_args_arg) |arg_doc| {\n         result.push(arg_doc.as_str());\n-    }\n+        true\n+    };\n     result\n }"}, {"sha": "74a3ba57543a5fc0f54e07893ac68bc7e9ed314e", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=deddb009f0003734d3c73fa859826d57ec600270", "patch": "@@ -558,11 +558,12 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n         ebml_w.wr_str(def_to_str(local_def(item.id)));\n         ebml_w.end_tag();\n \n-        for each_auxiliary_node_id(*item) |auxiliary_node_id| {\n+        do each_auxiliary_node_id(*item) |auxiliary_node_id| {\n             ebml_w.start_tag(tag_mod_child);\n             ebml_w.wr_str(def_to_str(local_def(auxiliary_node_id)));\n             ebml_w.end_tag();\n-        }\n+            true\n+        };\n \n         match item.node {\n             item_impl(*) => {\n@@ -1377,9 +1378,7 @@ fn synthesize_crate_attrs(ecx: &EncodeContext,\n \n         let mut meta_items = ~[name_item, vers_item];\n \n-        for items.iter()\n-            .filter(|mi| \"name\" != mi.name() && \"vers\" != mi.name())\n-            .advance |&mi| {\n+        foreach &mi in items.iter().filter(|mi| \"name\" != mi.name() && \"vers\" != mi.name()) {\n             meta_items.push(mi);\n         }\n         let link_item = attr::mk_list_item(@\"link\", meta_items);\n@@ -1454,26 +1453,24 @@ fn encode_crate_deps(ecx: &EncodeContext,\n fn encode_lang_items(ecx: &EncodeContext, ebml_w: &mut writer::Encoder) {\n     ebml_w.start_tag(tag_lang_items);\n \n-    for ecx.tcx.lang_items.each_item |def_id, i| {\n-        let def_id = match def_id {\n-            Some(id) => id, None => { loop }\n-        };\n-        if def_id.crate != LOCAL_CRATE {\n-            loop;\n-        }\n-\n-        ebml_w.start_tag(tag_lang_items_item);\n+    do ecx.tcx.lang_items.each_item |def_id, i| {\n+        foreach id in def_id.iter() {\n+            if id.crate == LOCAL_CRATE {\n+                ebml_w.start_tag(tag_lang_items_item);\n \n-        ebml_w.start_tag(tag_lang_items_item_id);\n-        ebml_w.writer.write_be_u32(i as u32);\n-        ebml_w.end_tag();   // tag_lang_items_item_id\n+                ebml_w.start_tag(tag_lang_items_item_id);\n+                ebml_w.writer.write_be_u32(i as u32);\n+                ebml_w.end_tag();   // tag_lang_items_item_id\n \n-        ebml_w.start_tag(tag_lang_items_item_node_id);\n-        ebml_w.writer.write_be_u32(def_id.node as u32);\n-        ebml_w.end_tag();   // tag_lang_items_item_node_id\n+                ebml_w.start_tag(tag_lang_items_item_node_id);\n+                ebml_w.writer.write_be_u32(id.node as u32);\n+                ebml_w.end_tag();   // tag_lang_items_item_node_id\n \n-        ebml_w.end_tag();   // tag_lang_items_item\n-    }\n+                ebml_w.end_tag();   // tag_lang_items_item\n+            }\n+        }\n+        true\n+    };\n \n     ebml_w.end_tag();   // tag_lang_items\n }\n@@ -1501,11 +1498,12 @@ fn encode_misc_info(ecx: &EncodeContext,\n         ebml_w.wr_str(def_to_str(local_def(item.id)));\n         ebml_w.end_tag();\n \n-        for each_auxiliary_node_id(item) |auxiliary_node_id| {\n+        do each_auxiliary_node_id(item) |auxiliary_node_id| {\n             ebml_w.start_tag(tag_mod_child);\n             ebml_w.wr_str(def_to_str(local_def(auxiliary_node_id)));\n             ebml_w.end_tag();\n-        }\n+            true\n+        };\n     }\n \n     // Encode reexports for the root module."}, {"sha": "765bf35b2b7a6b86e39092527226f7de0d387378", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=deddb009f0003734d3c73fa859826d57ec600270", "patch": "@@ -88,7 +88,7 @@ pub fn mk_filesearch(maybe_sysroot: &Option<@Path>,\n \n pub fn search<T>(filesearch: @FileSearch, pick: pick<T>) -> Option<T> {\n     let mut rslt = None;\n-    for filesearch.for_each_lib_search_path() |lib_search_path| {\n+    do filesearch.for_each_lib_search_path() |lib_search_path| {\n         debug!(\"searching %s\", lib_search_path.to_str());\n         let r = os::list_dir_path(lib_search_path);\n         foreach path in r.iter() {\n@@ -102,8 +102,8 @@ pub fn search<T>(filesearch: @FileSearch, pick: pick<T>) -> Option<T> {\n                 debug!(\"rejected %s\", path.to_str());\n             }\n         }\n-        if rslt.is_some() { break; }\n-    }\n+        rslt.is_none()\n+    };\n     return rslt;\n }\n "}, {"sha": "f8fae5ce26b5076f8def6fc00ef8a97220fe1aed", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=deddb009f0003734d3c73fa859826d57ec600270", "patch": "@@ -371,10 +371,11 @@ fn enc_purity(w: @io::Writer, p: purity) {\n \n fn enc_abi_set(w: @io::Writer, abis: AbiSet) {\n     w.write_char('[');\n-    for abis.each |abi| {\n+    do abis.each |abi| {\n         w.write_str(abi.name());\n         w.write_char(',');\n-    }\n+        true\n+    };\n     w.write_char(']')\n }\n \n@@ -412,14 +413,15 @@ fn enc_fn_sig(w: @io::Writer, cx: @ctxt, fsig: &ty::FnSig) {\n }\n \n fn enc_bounds(w: @io::Writer, cx: @ctxt, bs: &ty::ParamBounds) {\n-    for bs.builtin_bounds.each |bound| {\n+    do bs.builtin_bounds.each |bound| {\n         match bound {\n             ty::BoundSend => w.write_char('S'),\n             ty::BoundFreeze => w.write_char('K'),\n             ty::BoundStatic => w.write_char('O'),\n             ty::BoundSized => w.write_char('Z'),\n         }\n-    }\n+        true\n+    };\n \n     foreach &tp in bs.trait_bounds.iter() {\n         w.write_char('I');"}, {"sha": "902ff02e5d3b760afbbe5869be77ce5d2701f090", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=deddb009f0003734d3c73fa859826d57ec600270", "patch": "@@ -1139,7 +1139,7 @@ fn decode_side_tables(xcx: @ExtendedDecodeContext,\n                       ast_doc: ebml::Doc) {\n     let dcx = xcx.dcx;\n     let tbl_doc = ast_doc.get(c::tag_table as uint);\n-    for reader::docs(tbl_doc) |tag, entry_doc| {\n+    do reader::docs(tbl_doc) |tag, entry_doc| {\n         let id0 = entry_doc.get(c::tag_table_id as uint).as_int();\n         let id = xcx.tr_id(id0);\n \n@@ -1218,7 +1218,8 @@ fn decode_side_tables(xcx: @ExtendedDecodeContext,\n         }\n \n         debug!(\">< Side table doc loaded\");\n-    }\n+        true\n+    };\n }\n \n // ______________________________________________________________________"}, {"sha": "f6cc102938aaa59f8cc1a2e19e91d97f46a7e227", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 47, "deletions": 35, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=deddb009f0003734d3c73fa859826d57ec600270", "patch": "@@ -83,13 +83,10 @@ impl<'self> CheckLoanCtxt<'self> {\n         //! are issued for future scopes and thus they may have been\n         //! *issued* but not yet be in effect.\n \n-        for self.dfcx_loans.each_bit_on_entry_frozen(scope_id) |loan_index| {\n+        do self.dfcx_loans.each_bit_on_entry_frozen(scope_id) |loan_index| {\n             let loan = &self.all_loans[loan_index];\n-            if !op(loan) {\n-                return false;\n-            }\n+            op(loan)\n         }\n-        return true;\n     }\n \n     pub fn each_in_scope_loan(&self,\n@@ -100,14 +97,13 @@ impl<'self> CheckLoanCtxt<'self> {\n         //! currently in scope.\n \n         let region_maps = self.tcx().region_maps;\n-        for self.each_issued_loan(scope_id) |loan| {\n+        do self.each_issued_loan(scope_id) |loan| {\n             if region_maps.is_subscope_of(scope_id, loan.kill_scope) {\n-                if !op(loan) {\n-                    return false;\n-                }\n+                op(loan)\n+            } else {\n+                true\n             }\n         }\n-        return true;\n     }\n \n     pub fn each_in_scope_restriction(&self,\n@@ -118,26 +114,29 @@ impl<'self> CheckLoanCtxt<'self> {\n         //! Iterates through all the in-scope restrictions for the\n         //! given `loan_path`\n \n-        for self.each_in_scope_loan(scope_id) |loan| {\n+        do self.each_in_scope_loan(scope_id) |loan| {\n+            let mut ret = true;\n             foreach restr in loan.restrictions.iter() {\n                 if restr.loan_path == loan_path {\n                     if !op(loan, restr) {\n-                        return false;\n+                        ret = false;\n+                        break;\n                     }\n                 }\n             }\n+            ret\n         }\n-        return true;\n     }\n \n     pub fn loans_generated_by(&self, scope_id: ast::NodeId) -> ~[uint] {\n         //! Returns a vector of the loans that are generated as\n         //! we encounter `scope_id`.\n \n         let mut result = ~[];\n-        for self.dfcx_loans.each_gen_bit_frozen(scope_id) |loan_index| {\n+        do self.dfcx_loans.each_gen_bit_frozen(scope_id) |loan_index| {\n             result.push(loan_index);\n-        }\n+            true\n+        };\n         return result;\n     }\n \n@@ -152,12 +151,13 @@ impl<'self> CheckLoanCtxt<'self> {\n         let new_loan_indices = self.loans_generated_by(scope_id);\n         debug!(\"new_loan_indices = %?\", new_loan_indices);\n \n-        for self.each_issued_loan(scope_id) |issued_loan| {\n+        do self.each_issued_loan(scope_id) |issued_loan| {\n             foreach &new_loan_index in new_loan_indices.iter() {\n                 let new_loan = &self.all_loans[new_loan_index];\n                 self.report_error_if_loans_conflict(issued_loan, new_loan);\n             }\n-        }\n+            true\n+        };\n \n         foreach i in range(0u, new_loan_indices.len()) {\n             let old_loan = &self.all_loans[new_loan_indices[i]];\n@@ -268,15 +268,15 @@ impl<'self> CheckLoanCtxt<'self> {\n \n         debug!(\"check_if_path_is_moved(id=%?, use_kind=%?, lp=%s)\",\n                id, use_kind, lp.repr(self.bccx.tcx));\n-        for self.move_data.each_move_of(id, lp) |move, moved_lp| {\n+        do self.move_data.each_move_of(id, lp) |move, moved_lp| {\n             self.bccx.report_use_of_moved_value(\n                 span,\n                 use_kind,\n                 lp,\n                 move,\n                 moved_lp);\n-            return;\n-        }\n+            false\n+        };\n     }\n \n     pub fn check_assignment(&self, expr: @ast::expr) {\n@@ -308,13 +308,13 @@ impl<'self> CheckLoanCtxt<'self> {\n         if self.is_local_variable(cmt) {\n             assert!(cmt.mutbl.is_immutable()); // no \"const\" locals\n             let lp = opt_loan_path(cmt).get();\n-            for self.move_data.each_assignment_of(expr.id, lp) |assign| {\n+            do self.move_data.each_assignment_of(expr.id, lp) |assign| {\n                 self.bccx.report_reassigned_immutable_variable(\n                     expr.span,\n                     lp,\n                     assign);\n-                return;\n-            }\n+                false\n+            };\n             return;\n         }\n \n@@ -462,14 +462,18 @@ impl<'self> CheckLoanCtxt<'self> {\n             // `RESTR_MUTATE` restriction whenever the contents of an\n             // owned pointer are borrowed, and hence while `v[*]` is not\n             // restricted from being written, `v` is.\n-            for this.each_in_scope_restriction(expr.id, loan_path)\n+            let cont = do this.each_in_scope_restriction(expr.id, loan_path)\n                 |loan, restr|\n             {\n                 if restr.set.intersects(RESTR_MUTATE) {\n                     this.report_illegal_mutation(expr, loan_path, loan);\n-                    return false;\n+                    false\n+                } else {\n+                    true\n                 }\n-            }\n+            };\n+\n+            if !cont { return false }\n \n             // The previous code handled assignments to paths that\n             // have been restricted. This covers paths that have been\n@@ -525,12 +529,16 @@ impl<'self> CheckLoanCtxt<'self> {\n                 }\n \n                 // Check for a non-const loan of `loan_path`\n-                for this.each_in_scope_loan(expr.id) |loan| {\n+                let cont = do this.each_in_scope_loan(expr.id) |loan| {\n                     if loan.loan_path == loan_path && loan.mutbl != m_const {\n                         this.report_illegal_mutation(expr, full_loan_path, loan);\n-                        return false;\n+                        false\n+                    } else {\n+                        true\n                     }\n-                }\n+                };\n+\n+                if !cont { return false }\n             }\n         }\n     }\n@@ -563,7 +571,7 @@ impl<'self> CheckLoanCtxt<'self> {\n     }\n \n     fn check_move_out_from_id(&self, id: ast::NodeId, span: span) {\n-        for self.move_data.each_path_moved_by(id) |_, move_path| {\n+        do self.move_data.each_path_moved_by(id) |_, move_path| {\n             match self.analyze_move_out_from(id, move_path) {\n                 MoveOk => {}\n                 MoveWhileBorrowed(loan_path, loan_span) => {\n@@ -578,7 +586,8 @@ impl<'self> CheckLoanCtxt<'self> {\n                              self.bccx.loan_path_to_str(loan_path)));\n                 }\n             }\n-        }\n+            true\n+        };\n     }\n \n     pub fn analyze_move_out_from(&self,\n@@ -589,13 +598,16 @@ impl<'self> CheckLoanCtxt<'self> {\n \n         // FIXME(#4384) inadequare if/when we permit `move a.b`\n \n+        let mut ret = MoveOk;\n+\n         // check for a conflicting loan:\n-        for self.each_in_scope_restriction(expr_id, move_path) |loan, _| {\n+        do self.each_in_scope_restriction(expr_id, move_path) |loan, _| {\n             // Any restriction prevents moves.\n-            return MoveWhileBorrowed(loan.loan_path, loan.span);\n-        }\n+            ret = MoveWhileBorrowed(loan.loan_path, loan.span);\n+            false\n+        };\n \n-        MoveOk\n+        ret\n     }\n \n     pub fn check_call(&self,"}, {"sha": "9285c1e1f64e401304811f1d78a6bd32b4220e62", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 35, "deletions": 30, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=deddb009f0003734d3c73fa859826d57ec600270", "patch": "@@ -277,9 +277,10 @@ impl MoveData {\n \n         match self.path_map.find_copy(&lp) {\n             Some(index) => {\n-                for self.each_base_path(index) |p| {\n+                do self.each_base_path(index) |p| {\n                     result.push(p);\n-                }\n+                    true\n+                };\n             }\n             None => {\n                 match *lp {\n@@ -446,25 +447,29 @@ impl MoveData {\n     fn each_applicable_move(&self,\n                             index0: MovePathIndex,\n                             f: &fn(MoveIndex) -> bool) -> bool {\n-        for self.each_extending_path(index0) |index| {\n+        let mut ret = true;\n+        do self.each_extending_path(index0) |index| {\n             let mut p = self.path(index).first_move;\n             while p != InvalidMoveIndex {\n                 if !f(p) {\n-                    return false;\n+                    ret = false;\n+                    break;\n                 }\n                 p = self.move(p).next_move;\n             }\n-        }\n-        return true;\n+            ret\n+        };\n+        ret\n     }\n \n     fn kill_moves(&self,\n                   path: MovePathIndex,\n                   kill_id: ast::NodeId,\n                   dfcx_moves: &mut MoveDataFlow) {\n-        for self.each_applicable_move(path) |move_index| {\n+        do self.each_applicable_move(path) |move_index| {\n             dfcx_moves.add_kill(kill_id, *move_index);\n-        }\n+            true\n+        };\n     }\n }\n \n@@ -506,14 +511,11 @@ impl FlowedMoveData {\n          * Iterates through each path moved by `id`\n          */\n \n-        for self.dfcx_moves.each_gen_bit_frozen(id) |index| {\n+        do self.dfcx_moves.each_gen_bit_frozen(id) |index| {\n             let move = &self.move_data.moves[index];\n             let moved_path = move.path;\n-            if !f(move, self.move_data.path(moved_path).loan_path) {\n-                return false;\n-            }\n+            f(move, self.move_data.path(moved_path).loan_path)\n         }\n-        return true;\n     }\n \n     pub fn each_move_of(&self,\n@@ -545,31 +547,33 @@ impl FlowedMoveData {\n \n         let opt_loan_path_index = self.move_data.existing_move_path(loan_path);\n \n-        for self.dfcx_moves.each_bit_on_entry_frozen(id) |index| {\n+        let mut ret = true;\n+\n+        do self.dfcx_moves.each_bit_on_entry_frozen(id) |index| {\n             let move = &self.move_data.moves[index];\n             let moved_path = move.path;\n             if base_indices.iter().any(|x| x == &moved_path) {\n                 // Scenario 1 or 2: `loan_path` or some base path of\n                 // `loan_path` was moved.\n                 if !f(move, self.move_data.path(moved_path).loan_path) {\n-                    return false;\n+                    ret = false;\n                 }\n-                loop;\n-            }\n-\n-            foreach &loan_path_index in opt_loan_path_index.iter() {\n-                for self.move_data.each_base_path(moved_path) |p| {\n-                    if p == loan_path_index {\n-                        // Scenario 3: some extension of `loan_path`\n-                        // was moved\n-                        if !f(move, self.move_data.path(moved_path).loan_path) {\n-                            return false;\n+            } else {\n+                foreach &loan_path_index in opt_loan_path_index.iter() {\n+                    let cont = do self.move_data.each_base_path(moved_path) |p| {\n+                        if p == loan_path_index {\n+                            // Scenario 3: some extension of `loan_path`\n+                            // was moved\n+                            f(move, self.move_data.path(moved_path).loan_path)\n+                        } else {\n+                            true\n                         }\n-                    }\n+                    };\n+                    if !cont { ret = false; break }\n                 }\n             }\n+            ret\n         }\n-        return true;\n     }\n \n     pub fn is_assignee(&self,\n@@ -601,13 +605,14 @@ impl FlowedMoveData {\n             }\n         };\n \n-        for self.dfcx_assign.each_bit_on_entry_frozen(id) |index| {\n+        do self.dfcx_assign.each_bit_on_entry_frozen(id) |index| {\n             let assignment = &self.move_data.var_assignments[index];\n             if assignment.path == loan_path_index && !f(assignment) {\n-                return false;\n+                false\n+            } else {\n+                true\n             }\n         }\n-        return true;\n     }\n }\n "}, {"sha": "5cacbd2ec3fd43726754248352637b8afde0c0d4", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=deddb009f0003734d3c73fa859826d57ec600270", "patch": "@@ -118,12 +118,13 @@ pub fn check_arms(cx: &MatchCheckCtxt, arms: &[arm]) {\n                     _ => false\n                 }\n             };\n-            for walk_pat(*pat) |p| {\n+            do walk_pat(*pat) |p| {\n                 if pat_matches_nan(p) {\n                     cx.tcx.sess.span_warn(p.span, \"unmatchable NaN in pattern, \\\n                                                    use the is_NaN method in a guard instead\");\n                 }\n-            }\n+                true\n+            };\n \n             let v = ~[*pat];\n             match is_useful(cx, &seen, v) {\n@@ -873,7 +874,7 @@ pub fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n \n     if !any_by_move { return; } // pointless micro-optimization\n     foreach pat in pats.iter() {\n-        for walk_pat(*pat) |p| {\n+        do walk_pat(*pat) |p| {\n             if pat_is_binding(def_map, p) {\n                 match p.node {\n                     pat_ident(_, _, sub) => {\n@@ -890,6 +891,7 @@ pub fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n                     }\n                 }\n             }\n-        }\n+            true\n+        };\n     }\n }"}, {"sha": "634fa73f6aaba396dd120c0927cf0bf807f425de", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=deddb009f0003734d3c73fa859826d57ec600270", "patch": "@@ -880,11 +880,12 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n         debug!(\"DataFlowContext::walk_pat(pat=%s, in_out=%s)\",\n                pat.repr(self.dfcx.tcx), bits_to_str(reslice(in_out)));\n \n-        for ast_util::walk_pat(pat) |p| {\n+        do ast_util::walk_pat(pat) |p| {\n             debug!(\"  p.id=%? in_out=%s\", p.id, bits_to_str(reslice(in_out)));\n             self.merge_with_entry_set(p.id, in_out);\n             self.dfcx.apply_gen_kill(p.id, in_out);\n-        }\n+            true\n+        };\n     }\n \n     fn walk_pat_alternatives(&mut self,"}, {"sha": "ae4bf596eb4e2bc7a65ea7ee53d9fbd0f9567164", "filename": "src/librustc/middle/graph.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fgraph.rs?ref=deddb009f0003734d3c73fa859826d57ec600270", "patch": "@@ -314,20 +314,22 @@ mod test {\n     fn each_node() {\n         let graph = create_graph();\n         let expected = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"];\n-        for graph.each_node |idx, node| {\n+        do graph.each_node |idx, node| {\n             assert_eq!(&expected[*idx], graph.node_data(idx));\n             assert_eq!(expected[*idx], node.data);\n-        }\n+            true\n+        };\n     }\n \n     #[test]\n     fn each_edge() {\n         let graph = create_graph();\n         let expected = [\"AB\", \"BC\", \"BD\", \"DE\", \"EC\", \"FB\"];\n-        for graph.each_edge |idx, edge| {\n+        do graph.each_edge |idx, edge| {\n             assert_eq!(&expected[*idx], graph.edge_data(idx));\n             assert_eq!(expected[*idx], edge.data);\n-        }\n+            true\n+        };\n     }\n \n     fn test_adjacent_edges<N:Eq,E:Eq>(graph: &Graph<N,E>,\n@@ -338,7 +340,7 @@ mod test {\n         assert_eq!(graph.node_data(start_index), &start_data);\n \n         let mut counter = 0;\n-        for graph.each_incoming_edge(start_index) |edge_index, edge| {\n+        do graph.each_incoming_edge(start_index) |edge_index, edge| {\n             assert_eq!(graph.edge_data(edge_index), &edge.data);\n             assert!(counter < expected_incoming.len());\n             debug!(\"counter=%? expected=%? edge_index=%? edge=%?\",\n@@ -351,11 +353,12 @@ mod test {\n                 }\n             }\n             counter += 1;\n-        }\n+            true\n+        };\n         assert_eq!(counter, expected_incoming.len());\n \n         let mut counter = 0;\n-        for graph.each_outgoing_edge(start_index) |edge_index, edge| {\n+        do graph.each_outgoing_edge(start_index) |edge_index, edge| {\n             assert_eq!(graph.edge_data(edge_index), &edge.data);\n             assert!(counter < expected_outgoing.len());\n             debug!(\"counter=%? expected=%? edge_index=%? edge=%?\",\n@@ -368,7 +371,8 @@ mod test {\n                 }\n             }\n             counter += 1;\n-        }\n+            true\n+        };\n         assert_eq!(counter, expected_outgoing.len());\n     }\n "}, {"sha": "c604c3835bfe105d1e89eac2875ffd80eadfae4a", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=deddb009f0003734d3c73fa859826d57ec600270", "patch": "@@ -338,11 +338,12 @@ pub fn check_builtin_bounds(cx: Context, ty: ty::t, bounds: ty::BuiltinBounds,\n {\n     let kind = ty::type_contents(cx.tcx, ty);\n     let mut missing = ty::EmptyBuiltinBounds();\n-    for bounds.each |bound| {\n+    do bounds.each |bound| {\n         if !kind.meets_bound(cx.tcx, bound) {\n             missing.add(bound);\n         }\n-    }\n+        true\n+    };\n     if !missing.is_empty() {\n         any_missing(missing);\n     }"}, {"sha": "e9c9bcf37de67bbdf12dfe4c7466d0a6bdc9ac24", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=deddb009f0003734d3c73fa859826d57ec600270", "patch": "@@ -428,11 +428,12 @@ impl<'self> LanguageItemCollector<'self> {\n     pub fn collect_external_language_items(&mut self) {\n         let crate_store = self.session.cstore;\n         do iter_crate_data(crate_store) |crate_number, _crate_metadata| {\n-            for each_lang_item(crate_store, crate_number)\n+            do each_lang_item(crate_store, crate_number)\n                     |node_id, item_index| {\n                 let def_id = def_id { crate: crate_number, node: node_id };\n                 self.collect_item(item_index, def_id);\n-            }\n+                true\n+            };\n         }\n     }\n "}, {"sha": "f867790ca13d9b0f3088a451bcb82a2fb7541054", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 28, "deletions": 57, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=deddb009f0003734d3c73fa859826d57ec600270", "patch": "@@ -76,7 +76,6 @@ pub enum lint {\n     unused_imports,\n     unnecessary_qualification,\n     while_true,\n-    deprecated_for_loop,\n     path_statement,\n     unrecognized_lint,\n     non_camel_case_types,\n@@ -168,13 +167,6 @@ static lint_table: &'static [(&'static str, LintSpec)] = &[\n         default: warn\n      }),\n \n-    (\"deprecated_for_loop\",\n-     LintSpec {\n-         lint: deprecated_for_loop,\n-         desc: \"recommend using `foreach` or `do` instead of `for`\",\n-         default: allow\n-     }),\n-\n     (\"path_statement\",\n      LintSpec {\n         lint: path_statement,\n@@ -414,35 +406,33 @@ impl Context {\n         // of what we changed so we can roll everything back after invoking the\n         // specified closure\n         let mut pushed = 0u;\n-        for each_lint(self.tcx.sess, attrs) |meta, level, lintname| {\n-            let lint = match self.dict.find_equiv(&lintname) {\n-              None => {\n-                self.span_lint(\n-                    unrecognized_lint,\n-                    meta.span,\n-                    fmt!(\"unknown `%s` attribute: `%s`\",\n-                         level_to_str(level), lintname));\n-                loop\n-              }\n-              Some(lint) => { lint.lint }\n-            };\n-\n-            let now = self.get_level(lint);\n-            if now == forbid && level != forbid {\n-                self.tcx.sess.span_err(meta.span,\n-                    fmt!(\"%s(%s) overruled by outer forbid(%s)\",\n-                         level_to_str(level),\n-                         lintname, lintname));\n-                loop;\n-            }\n-\n-            if now != level {\n-                let src = self.get_source(lint);\n-                self.lint_stack.push((lint, now, src));\n-                pushed += 1;\n-                self.set_level(lint, level, Node(meta.span));\n+        do each_lint(self.tcx.sess, attrs) |meta, level, lintname| {\n+            match self.dict.find_equiv(&lintname) {\n+                None => {\n+                    self.span_lint(\n+                        unrecognized_lint,\n+                        meta.span,\n+                        fmt!(\"unknown `%s` attribute: `%s`\",\n+                        level_to_str(level), lintname));\n+                }\n+                Some(lint) => {\n+                    let lint = lint.lint;\n+                    let now = self.get_level(lint);\n+                    if now == forbid && level != forbid {\n+                        self.tcx.sess.span_err(meta.span,\n+                        fmt!(\"%s(%s) overruled by outer forbid(%s)\",\n+                        level_to_str(level),\n+                        lintname, lintname));\n+                    } else if now != level {\n+                        let src = self.get_source(lint);\n+                        self.lint_stack.push((lint, now, src));\n+                        pushed += 1;\n+                        self.set_level(lint, level, Node(meta.span));\n+                    }\n+                }\n             }\n-        }\n+            true\n+        };\n \n         // detect doc(hidden)\n         let mut doc_hidden = do attrs.iter().any |attr| {\n@@ -496,7 +486,7 @@ impl Context {\n                 }\n             }\n             Crate(c) => {\n-                for self.visitors.iter().advance |visitor| {\n+                foreach visitor in self.visitors.iter() {\n                     match *visitor {\n                         OldVisitor(_, stopping) => {\n                             oldvisit::visit_crate(c, (self, stopping))\n@@ -615,24 +605,6 @@ fn lint_while_true() -> oldvisit::vt<@mut Context> {\n     })\n }\n \n-fn lint_deprecated_for_loop() -> oldvisit::vt<@mut Context> {\n-    oldvisit::mk_vt(@oldvisit::Visitor {\n-        visit_expr: |e, (cx, vt): (@mut Context, oldvisit::vt<@mut Context>)| {\n-            match e.node {\n-                ast::expr_call(_, _, ast::ForSugar) |\n-                ast::expr_method_call(_, _, _, _, _, ast::ForSugar) => {\n-                    cx.span_lint(deprecated_for_loop, e.span,\n-                                \"`for` is deprecated; use `foreach <pat> in \\\n-                                 <iterator>` or `do`\")\n-                }\n-                _ => {}\n-            }\n-            oldvisit::visit_expr(e, (cx, vt));\n-        },\n-        .. *oldvisit::default_visitor()\n-    })\n-}\n-\n fn lint_type_limits() -> oldvisit::vt<@mut Context> {\n     fn is_valid<T:cmp::Ord>(binop: ast::binop, v: T,\n             min: T, max: T) -> bool {\n@@ -1165,7 +1137,7 @@ pub fn check_crate(tcx: ty::ctxt, crate: @ast::Crate) {\n     };\n \n     // Install defaults.\n-    for cx.dict.each_value |spec| {\n+    foreach (_, spec) in cx.dict.iter() {\n         cx.set_level(spec.lint, spec.default, Default);\n     }\n \n@@ -1176,7 +1148,6 @@ pub fn check_crate(tcx: ty::ctxt, crate: @ast::Crate) {\n \n     // Register each of the lint passes with the context\n     cx.add_oldvisit_lint(lint_while_true());\n-    cx.add_oldvisit_lint(lint_deprecated_for_loop());\n     cx.add_oldvisit_lint(lint_path_statement());\n     cx.add_oldvisit_lint(lint_heap());\n     cx.add_oldvisit_lint(lint_type_limits());"}, {"sha": "06588f228556734ff5d73e715b4b750dcdc839ab", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=deddb009f0003734d3c73fa859826d57ec600270", "patch": "@@ -654,16 +654,21 @@ impl VisitContext {\n                                       moves_map: MovesMap,\n                                       arms: &[arm])\n                                       -> Option<@pat> {\n+        let mut ret = None;\n         foreach arm in arms.iter() {\n             foreach &pat in arm.pats.iter() {\n-                for ast_util::walk_pat(pat) |p| {\n+                let cont = do ast_util::walk_pat(pat) |p| {\n                     if moves_map.contains(&p.id) {\n-                        return Some(p);\n+                        ret = Some(p);\n+                        false\n+                    } else {\n+                        true\n                     }\n-                }\n+                };\n+                if !cont { return ret }\n             }\n         }\n-        return None;\n+        ret\n     }\n \n     pub fn compute_captures(&self, fn_expr_id: NodeId) -> @[CaptureVar] {"}, {"sha": "9bf14697d9ad764b9b9c1d245ed3b98114652eda", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=deddb009f0003734d3c73fa859826d57ec600270", "patch": "@@ -72,14 +72,15 @@ pub fn pat_is_binding_or_wild(dm: resolve::DefMap, pat: @pat) -> bool {\n \n pub fn pat_bindings(dm: resolve::DefMap, pat: @pat,\n                     it: &fn(binding_mode, NodeId, span, &Path)) {\n-    for walk_pat(pat) |p| {\n+    do walk_pat(pat) |p| {\n         match p.node {\n           pat_ident(binding_mode, ref pth, _) if pat_is_binding(dm, p) => {\n             it(binding_mode, p.id, p.span, pth);\n           }\n           _ => {}\n         }\n-    }\n+        true\n+    };\n }\n \n pub fn pat_binding_ids(dm: resolve::DefMap, pat: @pat) -> ~[NodeId] {"}, {"sha": "761a34b72e534ab40bf0b573cc676ef6db95d9b0", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=deddb009f0003734d3c73fa859826d57ec600270", "patch": "@@ -15,8 +15,6 @@\n // makes all other generics or inline functions that it references\n // reachable as well.\n \n-use std::iterator::IteratorUtil;\n-\n use middle::ty;\n use middle::typeck;\n \n@@ -392,8 +390,7 @@ impl ReachableContext {\n     // this properly would result in the necessity of computing *type*\n     // reachability, which might result in a compile time loss.\n     fn mark_destructors_reachable(&self) {\n-        for self.tcx.destructor_for_type.iter().advance\n-                |(_, destructor_def_id)| {\n+        foreach (_, destructor_def_id) in self.tcx.destructor_for_type.iter() {\n             if destructor_def_id.crate == LOCAL_CRATE {\n                 self.reachable_symbols.insert(destructor_def_id.node);\n             }"}, {"sha": "5a70f251aca461aa8726fac7193ab9463cf92ef8", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 19, "deletions": 22, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=deddb009f0003734d3c73fa859826d57ec600270", "patch": "@@ -1726,7 +1726,7 @@ impl Resolver {\n         let mut modules = HashMap::new();\n \n         // Create all the items reachable by paths.\n-        for each_path(self.session.cstore, root.def_id.get().crate)\n+        do each_path(self.session.cstore, root.def_id.get().crate)\n                 |path_string, def_like, visibility| {\n \n             debug!(\"(building reduced graph for external crate) found path \\\n@@ -1893,7 +1893,8 @@ impl Resolver {\n                             ignoring field\");\n                 }\n             }\n-        }\n+            true\n+        };\n     }\n \n     /// Creates and adds an import directive to the given module.\n@@ -1992,7 +1993,7 @@ impl Resolver {\n                self.module_to_str(module_));\n         self.resolve_imports_for_module(module_);\n \n-        for module_.children.each_value |&child_node| {\n+        foreach (_, &child_node) in module_.children.iter() {\n             match child_node.get_module_if_available() {\n                 None => {\n                     // Nothing to do.\n@@ -2003,7 +2004,7 @@ impl Resolver {\n             }\n         }\n \n-        for module_.anonymous_children.each_value |&child_module| {\n+        foreach (_, &child_module) in module_.anonymous_children.iter() {\n             self.resolve_imports_for_module_subtree(child_module);\n         }\n     }\n@@ -2446,8 +2447,7 @@ impl Resolver {\n         assert_eq!(containing_module.glob_count, 0);\n \n         // Add all resolved imports from the containing module.\n-        for containing_module.import_resolutions.iter().advance\n-                |(ident, target_import_resolution)| {\n+        foreach (ident, target_import_resolution) in containing_module.import_resolutions.iter() {\n \n             debug!(\"(resolving glob import) writing module resolution \\\n                     %? into `%s`\",\n@@ -2536,8 +2536,7 @@ impl Resolver {\n         }\n \n         // Add external module children from the containing module.\n-        for containing_module.external_module_children.iter().advance\n-                |(&ident, module)| {\n+        foreach (&ident, module) in containing_module.external_module_children.iter() {\n             let name_bindings =\n                 @mut Resolver::create_name_bindings_from_module(*module);\n             merge_import_resolution(ident, name_bindings);\n@@ -3109,7 +3108,7 @@ impl Resolver {\n         }\n \n         // Descend into children and anonymous children.\n-        for module_.children.each_value |&child_node| {\n+        foreach (_, &child_node) in module_.children.iter() {\n             match child_node.get_module_if_available() {\n                 None => {\n                     // Continue.\n@@ -3120,7 +3119,7 @@ impl Resolver {\n             }\n         }\n \n-        for module_.anonymous_children.each_value |&module_| {\n+        foreach (_, &module_) in module_.anonymous_children.iter() {\n             self.report_unresolved_imports(module_);\n         }\n     }\n@@ -3168,7 +3167,7 @@ impl Resolver {\n \n         self.record_exports_for_module(module_);\n \n-        for module_.children.each_value |&child_name_bindings| {\n+        foreach (_, &child_name_bindings) in module_.children.iter() {\n             match child_name_bindings.get_module_if_available() {\n                 None => {\n                     // Nothing to do.\n@@ -3179,7 +3178,7 @@ impl Resolver {\n             }\n         }\n \n-        for module_.anonymous_children.each_value |&child_module| {\n+        foreach (_, &child_module) in module_.anonymous_children.iter() {\n             self.record_exports_for_module_subtree(child_module);\n         }\n     }\n@@ -3229,8 +3228,7 @@ impl Resolver {\n     pub fn add_exports_for_module(@mut self,\n                                   exports2: &mut ~[Export2],\n                                   module_: @mut Module) {\n-        for module_.import_resolutions.iter().advance |(ident,\n-                                                        importresolution)| {\n+        foreach (ident, importresolution) in module_.import_resolutions.iter() {\n             if importresolution.privacy != Public {\n                 debug!(\"(computing exports) not reexporting private `%s`\",\n                        self.session.str_of(*ident));\n@@ -4195,7 +4193,7 @@ impl Resolver {\n                            bindings_list: Option<@mut HashMap<ident,NodeId>>,\n                            visitor: ResolveVisitor) {\n         let pat_id = pattern.id;\n-        for walk_pat(pattern) |pattern| {\n+        do walk_pat(pattern) |pattern| {\n             match pattern.node {\n                 pat_ident(binding_mode, ref path, _)\n                         if !path.global && path.idents.len() == 1 => {\n@@ -4425,7 +4423,8 @@ impl Resolver {\n                     // Nothing to do.\n                 }\n             }\n-        }\n+            true\n+        };\n     }\n \n     pub fn resolve_bare_identifier_pattern(@mut self, name: ident)\n@@ -4838,7 +4837,7 @@ impl Resolver {\n         let mut j = this.value_ribs.len();\n         while j != 0 {\n             j -= 1;\n-            for this.value_ribs[j].bindings.each_key |&k| {\n+            foreach (&k, _) in this.value_ribs[j].bindings.iter() {\n                 maybes.push(this.session.str_of(k));\n                 values.push(uint::max_value);\n             }\n@@ -5166,7 +5165,7 @@ impl Resolver {\n                 }\n \n                 // Look for trait children.\n-                for search_module.children.each_value |&child_name_bindings| {\n+                foreach (_, &child_name_bindings) in search_module.children.iter() {\n                     match child_name_bindings.def_for_namespace(TypeNS) {\n                         Some(def) => {\n                             match def {\n@@ -5189,9 +5188,7 @@ impl Resolver {\n                 }\n \n                 // Look for imports.\n-                for search_module.import_resolutions.each_value\n-                        |&import_resolution| {\n-\n+                foreach (_, &import_resolution) in search_module.import_resolutions.iter() {\n                     match import_resolution.target_for_namespace(TypeNS) {\n                         None => {\n                             // Continue.\n@@ -5370,7 +5367,7 @@ impl Resolver {\n         debug!(\"Dump of module `%s`:\", self.module_to_str(module_));\n \n         debug!(\"Children:\");\n-        for module_.children.each_key |&name| {\n+        foreach (&name, _) in module_.children.iter() {\n             debug!(\"* %s\", self.session.str_of(name));\n         }\n "}, {"sha": "5f9351e4e12e79c66a89ee2ae01d22bb1bba57cf", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=deddb009f0003734d3c73fa859826d57ec600270", "patch": "@@ -1148,7 +1148,7 @@ fn store_non_ref_bindings(bcx: @mut Block,\n      */\n \n     let mut bcx = bcx;\n-    for bindings_map.each_value |&binding_info| {\n+    foreach (_, &binding_info) in bindings_map.iter() {\n         match binding_info.trmode {\n             TrByValue(lldest) => {\n                 let llval = Load(bcx, binding_info.llmatch); // get a T*\n@@ -1182,7 +1182,7 @@ fn insert_lllocals(bcx: @mut Block,\n         BindArgument => bcx.fcx.llargs\n     };\n \n-    for bindings_map.each_value |&binding_info| {\n+    foreach (_, &binding_info) in bindings_map.iter() {\n         let llval = match binding_info.trmode {\n             // By value bindings: use the stack slot that we\n             // copied/moved the value into\n@@ -1250,7 +1250,7 @@ pub fn compile_guard(bcx: @mut Block,\n \n     fn drop_bindings(bcx: @mut Block, data: &ArmData) -> @mut Block {\n         let mut bcx = bcx;\n-        for data.bindings_map.each_value |&binding_info| {\n+        foreach (_, &binding_info) in data.bindings_map.iter() {\n             match binding_info.trmode {\n                 TrByValue(llval) => {\n                     bcx = glue::drop_ty(bcx, llval, binding_info.ty);"}, {"sha": "e0a7cd8cc0b57871fbe707ca1b5203162bde68bf", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=deddb009f0003734d3c73fa859826d57ec600270", "patch": "@@ -2801,7 +2801,7 @@ pub fn create_module_map(ccx: &mut CrateContext) -> ValueRef {\n     // like the multiple borrows. At least, it doesn't\n     // like them on the current snapshot. (2013-06-14)\n     let mut keys = ~[];\n-    for ccx.module_data.each_key |k| {\n+    foreach (k, _) in ccx.module_data.iter() {\n         keys.push(k.to_managed());\n     }\n "}, {"sha": "bbf07e369750f94ee17e9a7515429778bd9b2216", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=deddb009f0003734d3c73fa859826d57ec600270", "patch": "@@ -736,7 +736,7 @@ pub fn emit_tydescs(ccx: &mut CrateContext) {\n     ccx.finished_tydescs = true;\n     let glue_fn_ty = Type::generic_glue_fn(ccx).ptr_to();\n     let tyds = &mut ccx.tydescs;\n-    for tyds.each_value |&val| {\n+    foreach (_, &val) in tyds.iter() {\n         let ti = val;\n \n         // Each of the glue functions needs to be cast to a generic type"}, {"sha": "bfab8e26132e7ce689134efaf74aa1579d1e1593", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=deddb009f0003734d3c73fa859826d57ec600270", "patch": "@@ -2277,7 +2277,7 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n         // This is like with typarams below, but less \"pessimistic\" and also\n         // dependent on the trait store.\n         let mut bt = TC_NONE;\n-        for (AllBuiltinBounds() - bounds).each |bound| {\n+        do (AllBuiltinBounds() - bounds).each |bound| {\n             bt = bt + match bound {\n                 BoundStatic if bounds.contains_elem(BoundSend)\n                             => TC_NONE, // Send bound implies static bound.\n@@ -2286,7 +2286,8 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n                 BoundFreeze => TC_MUTABLE,\n                 BoundSized  => TC_NONE, // don't care if interior is sized\n             };\n-        }\n+            true\n+        };\n         st + mt + bt\n     }\n \n@@ -2297,7 +2298,7 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n         let _i = indenter();\n \n         let mut tc = TC_ALL;\n-        for type_param_def.bounds.builtin_bounds.each |bound| {\n+        do type_param_def.bounds.builtin_bounds.each |bound| {\n             debug!(\"tc = %s, bound = %?\", tc.to_str(), bound);\n             tc = tc - match bound {\n                 BoundStatic => TypeContents::nonstatic(cx),\n@@ -2306,7 +2307,8 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n                 // The dynamic-size bit can be removed at pointer-level, etc.\n                 BoundSized => TypeContents::dynamically_sized(cx),\n             };\n-        }\n+            true\n+        };\n \n         debug!(\"result = %s\", tc.to_str());\n         return tc;\n@@ -4424,10 +4426,11 @@ pub fn count_traits_and_supertraits(tcx: ctxt,\n                                     type_param_defs: &[TypeParameterDef]) -> uint {\n     let mut total = 0;\n     foreach type_param_def in type_param_defs.iter() {\n-        for each_bound_trait_and_supertraits(\n+        do each_bound_trait_and_supertraits(\n             tcx, type_param_def.bounds.trait_bounds) |_| {\n             total += 1;\n-        }\n+            true\n+        };\n     }\n     return total;\n }"}, {"sha": "2d7840423c5e57820d3846c7e129de28d6b7d1c7", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 31, "deletions": 33, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=deddb009f0003734d3c73fa859826d57ec600270", "patch": "@@ -420,44 +420,42 @@ impl<'self> LookupContext<'self> {\n         let tcx = self.tcx();\n         let mut next_bound_idx = 0; // count only trait bounds\n \n-        for ty::each_bound_trait_and_supertraits(tcx, bounds)\n-            |bound_trait_ref|\n-        {\n+        do ty::each_bound_trait_and_supertraits(tcx, bounds) |bound_trait_ref| {\n             let this_bound_idx = next_bound_idx;\n             next_bound_idx += 1;\n \n             let trait_methods = ty::trait_methods(tcx, bound_trait_ref.def_id);\n-            let pos = {\n-                match trait_methods.iter().position(|m| {\n-                    m.explicit_self != ast::sty_static &&\n-                        m.ident == self.m_name })\n-                {\n-                    Some(pos) => pos,\n-                    None => {\n-                        debug!(\"trait doesn't contain method: %?\",\n-                               bound_trait_ref.def_id);\n-                        loop; // check next trait or bound\n-                    }\n+            match trait_methods.iter().position(|m| {\n+                m.explicit_self != ast::sty_static &&\n+                m.ident == self.m_name })\n+            {\n+                Some(pos) => {\n+                    let method = trait_methods[pos];\n+\n+                    let cand = Candidate {\n+                        rcvr_ty: self_ty,\n+                        rcvr_substs: bound_trait_ref.substs.clone(),\n+                        method_ty: method,\n+                        origin: method_param(\n+                            method_param {\n+                                trait_id: bound_trait_ref.def_id,\n+                                method_num: pos,\n+                                param_num: param,\n+                                bound_num: this_bound_idx,\n+                            })\n+                    };\n+\n+                    debug!(\"pushing inherent candidate for param: %?\", cand);\n+                    self.inherent_candidates.push(cand);\n                 }\n-            };\n-            let method = trait_methods[pos];\n-\n-            let cand = Candidate {\n-                rcvr_ty: self_ty,\n-                rcvr_substs: bound_trait_ref.substs.clone(),\n-                method_ty: method,\n-                origin: method_param(\n-                    method_param {\n-                        trait_id: bound_trait_ref.def_id,\n-                        method_num: pos,\n-                        param_num: param,\n-                        bound_num: this_bound_idx,\n-                    })\n-            };\n-\n-            debug!(\"pushing inherent candidate for param: %?\", cand);\n-            self.inherent_candidates.push(cand);\n-        }\n+                None => {\n+                    debug!(\"trait doesn't contain method: %?\",\n+                    bound_trait_ref.def_id);\n+                    // check next trait or bound\n+                }\n+            }\n+            true\n+        };\n     }\n \n "}, {"sha": "0e50021c82c0bf5c06953c7d6fbc0f714bcd1139", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=deddb009f0003734d3c73fa859826d57ec600270", "patch": "@@ -131,7 +131,7 @@ fn lookup_vtables_for_param(vcx: &VtableContext,\n     // ty is the value supplied for the type parameter A...\n     let mut param_result = ~[];\n \n-    for ty::each_bound_trait_and_supertraits(\n+    do ty::each_bound_trait_and_supertraits(\n         tcx, type_param_bounds.trait_bounds) |trait_ref|\n     {\n         // ...and here trait_ref is each bound that was declared on A,\n@@ -158,7 +158,8 @@ fn lookup_vtables_for_param(vcx: &VtableContext,\n                          vcx.infcx.ty_to_str(ty)));\n             }\n         }\n-    }\n+        true\n+    };\n \n     debug!(\"lookup_vtables_for_param result(\\\n             location_info=%?, \\\n@@ -286,7 +287,8 @@ fn lookup_vtable_from_bounds(vcx: &VtableContext,\n     let tcx = vcx.tcx();\n \n     let mut n_bound = 0;\n-    for ty::each_bound_trait_and_supertraits(tcx, bounds) |bound_trait_ref| {\n+    let mut ret = None;\n+    do ty::each_bound_trait_and_supertraits(tcx, bounds) |bound_trait_ref| {\n         debug!(\"checking bounds trait %s\",\n                bound_trait_ref.repr(vcx.tcx()));\n \n@@ -298,13 +300,14 @@ fn lookup_vtable_from_bounds(vcx: &VtableContext,\n             let vtable = vtable_param(param, n_bound);\n             debug!(\"found param vtable: %?\",\n                    vtable);\n-            return Some(vtable);\n+            ret = Some(vtable);\n+            false\n+        } else {\n+            n_bound += 1;\n+            true\n         }\n-\n-        n_bound += 1;\n-    }\n-\n-    return None;\n+    };\n+    ret\n }\n \n fn search_for_vtable(vcx: &VtableContext,\n@@ -552,7 +555,7 @@ pub fn early_resolve_expr(ex: @ast::expr,\n     let cx = fcx.ccx;\n     match ex.node {\n       ast::expr_path(*) => {\n-        for fcx.opt_node_ty_substs(ex.id) |substs| {\n+        do fcx.opt_node_ty_substs(ex.id) |substs| {\n             debug!(\"vtable resolution on parameter bounds for expr %s\",\n                    ex.repr(fcx.tcx()));\n             let def = cx.tcx.def_map.get_copy(&ex.id);\n@@ -571,7 +574,8 @@ pub fn early_resolve_expr(ex: @ast::expr,\n                     insert_vtables(fcx, ex.id, vtbls);\n                 }\n             }\n-        }\n+            true\n+        };\n       }\n \n       ast::expr_paren(e) => {"}, {"sha": "b30eb67916d3577cfa87549ad22fad816df5a91c", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=deddb009f0003734d3c73fa859826d57ec600270", "patch": "@@ -178,17 +178,19 @@ fn resolve_type_vars_for_node(wbcx: @mut WbCtxt, sp: span, id: ast::NodeId)\n         debug!(\"resolve_type_vars_for_node(id=%d, n_ty=%s, t=%s)\",\n                id, ppaux::ty_to_str(tcx, n_ty), ppaux::ty_to_str(tcx, t));\n         write_ty_to_tcx(tcx, id, t);\n-        for fcx.opt_node_ty_substs(id) |substs| {\n+        let mut ret = Some(t);\n+        do fcx.opt_node_ty_substs(id) |substs| {\n           let mut new_tps = ~[];\n           foreach subst in substs.tps.iter() {\n               match resolve_type_vars_in_type(fcx, sp, *subst) {\n                 Some(t) => new_tps.push(t),\n-                None => { wbcx.success = false; return None; }\n+                None => { wbcx.success = false; ret = None; break }\n               }\n           }\n           write_substs_to_tcx(tcx, id, new_tps);\n-        }\n-        return Some(t);\n+          ret.is_some()\n+        };\n+        ret\n       }\n     }\n }"}, {"sha": "4af54cef71632fcaab8c85a71423860d0977b59a", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=deddb009f0003734d3c73fa859826d57ec600270", "patch": "@@ -371,9 +371,10 @@ impl CoherenceChecker {\n     }\n \n     pub fn check_implementation_coherence(&self) {\n-        for self.crate_context.tcx.trait_impls.each_key |&trait_id| {\n+        do self.crate_context.tcx.trait_impls.each_key |&trait_id| {\n             self.check_implementation_coherence_of(trait_id);\n-        }\n+            true\n+        };\n     }\n \n     pub fn check_implementation_coherence_of(&self, trait_def_id: def_id) {\n@@ -738,14 +739,15 @@ impl CoherenceChecker {\n \n         let crate_store = self.crate_context.tcx.sess.cstore;\n         do iter_crate_data(crate_store) |crate_number, _crate_metadata| {\n-            for each_path(crate_store, crate_number) |_, def_like, _| {\n+            do each_path(crate_store, crate_number) |_, def_like, _| {\n                 match def_like {\n                     dl_impl(def_id) => {\n                         self.add_external_impl(&mut impls_seen, def_id)\n                     }\n-                    dl_def(_) | dl_field => loop,   // Skip this.\n+                    dl_def(_) | dl_field => (),   // Skip this.\n                 }\n-            }\n+                true\n+            };\n         }\n     }\n "}, {"sha": "9a4a8ca11dcd120d1eabe0195351f11331c4aa03", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=deddb009f0003734d3c73fa859826d57ec600270", "patch": "@@ -267,16 +267,23 @@ impl Combine for Glb {\n                       a_isr: isr_alist,\n                       r: ty::Region) -> ty::Region\n         {\n-            for list::each(a_isr) |pair| {\n+            let mut ret = None;\n+            do list::each(a_isr) |pair| {\n                 let (a_br, a_r) = *pair;\n                 if a_r == r {\n-                    return ty::re_bound(a_br);\n+                    ret = Some(ty::re_bound(a_br));\n+                    false\n+                } else {\n+                    true\n                 }\n-            }\n+            };\n \n-            this.infcx.tcx.sess.span_bug(\n-                this.trace.origin.span(),\n-                fmt!(\"could not find original bound region for %?\", r));\n+            match ret {\n+                Some(x) => x,\n+                None => this.infcx.tcx.sess.span_bug(\n+                            this.trace.origin.span(),\n+                            fmt!(\"could not find original bound region for %?\", r))\n+            }\n         }\n \n         fn fresh_bound_variable(this: &Glb) -> ty::Region {"}, {"sha": "0ed30bb61b9f364050315ece1603a85b27251ec8", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=deddb009f0003734d3c73fa859826d57ec600270", "patch": "@@ -526,7 +526,7 @@ pub fn lattice_var_and_t<L:LatticeDir + Combine,\n \n pub fn var_ids<T:Combine>(this: &T, isr: isr_alist) -> ~[RegionVid] {\n     let mut result = ~[];\n-    for list::each(isr) |pair| {\n+    do list::each(isr) |pair| {\n         match pair.second() {\n             ty::re_infer(ty::ReVar(r)) => { result.push(r); }\n             r => {\n@@ -535,8 +535,9 @@ pub fn var_ids<T:Combine>(this: &T, isr: isr_alist) -> ~[RegionVid] {\n                     fmt!(\"Found non-region-vid: %?\", r));\n             }\n         }\n-    }\n-    return result;\n+        true\n+    };\n+    result\n }\n \n pub fn is_var_in_set(new_vars: &[RegionVid], r: ty::Region) -> bool {"}, {"sha": "8afb5a18d4f6feb0e72af5a37756d005169dbc8c", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=deddb009f0003734d3c73fa859826d57ec600270", "patch": "@@ -182,20 +182,27 @@ impl Combine for Lub {\n             // in both A and B.  Replace the variable with the \"first\"\n             // bound region from A that we find it to be associated\n             // with.\n-            for list::each(a_isr) |pair| {\n+            let mut ret = None;\n+            do list::each(a_isr) |pair| {\n                 let (a_br, a_r) = *pair;\n                 if tainted.iter().any(|x| x == &a_r) {\n                     debug!(\"generalize_region(r0=%?): \\\n                             replacing with %?, tainted=%?\",\n                            r0, a_br, tainted);\n-                    return ty::re_bound(a_br);\n+                    ret = Some(ty::re_bound(a_br));\n+                    false\n+                } else {\n+                    true\n                 }\n+            };\n+\n+            match ret {\n+                Some(x) => x,\n+                None => this.infcx.tcx.sess.span_bug(\n+                            this.trace.origin.span(),\n+                            fmt!(\"Region %? is not associated with \\\n+                                  any bound region from A!\", r0))\n             }\n-\n-            this.infcx.tcx.sess.span_bug(\n-                this.trace.origin.span(),\n-                fmt!(\"Region %? is not associated with \\\n-                      any bound region from A!\", r0));\n         }\n     }\n "}, {"sha": "07fd66640b5cb790b196967e5e3238b86df6dc1c", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=deddb009f0003734d3c73fa859826d57ec600270", "patch": "@@ -1209,7 +1209,7 @@ impl RegionVarBindings {\n             debug!(\"process_edges(source_vid=%?, dir=%?)\", source_vid, dir);\n \n             let source_node_index = NodeIndex(source_vid.to_uint());\n-            for graph.each_adjacent_edge(source_node_index, dir) |_, edge| {\n+            do graph.each_adjacent_edge(source_node_index, dir) |_, edge| {\n                 match edge.data {\n                     ConstrainVarSubVar(from_vid, to_vid) => {\n                         let opp_vid =\n@@ -1229,7 +1229,8 @@ impl RegionVarBindings {\n \n                     ConstrainRegSubReg(*) => {}\n                 }\n-            }\n+                true\n+            };\n         }\n     }\n "}, {"sha": "975dbfb07e0c2c4f0c8033576c85c86596543670", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=deddb009f0003734d3c73fa859826d57ec600270", "patch": "@@ -191,7 +191,9 @@ impl Combine for Sub {\n         // that the skolemized regions do not \"leak\".\n         let new_vars =\n             self.infcx.region_vars.vars_created_since_snapshot(snapshot);\n-        for list::each(skol_isr) |pair| {\n+\n+        let mut ret = Ok(sig);\n+        do list::each(skol_isr) |pair| {\n             let (skol_br, skol) = *pair;\n             let tainted = self.infcx.region_vars.tainted(snapshot, skol);\n             foreach tainted_region in tainted.iter() {\n@@ -208,16 +210,19 @@ impl Combine for Sub {\n \n                 // A is not as polymorphic as B:\n                 if self.a_is_expected {\n-                    return Err(ty::terr_regions_insufficiently_polymorphic(\n+                    ret = Err(ty::terr_regions_insufficiently_polymorphic(\n                         skol_br, *tainted_region));\n+                    break\n                 } else {\n-                    return Err(ty::terr_regions_overly_polymorphic(\n+                    ret = Err(ty::terr_regions_overly_polymorphic(\n                         skol_br, *tainted_region));\n+                    break\n                 }\n             }\n-        }\n+            ret.is_ok()\n+        };\n \n-        return Ok(sig);\n+        ret\n     }\n \n     // Traits please (FIXME: #2794):"}, {"sha": "6128c16996742a4152a9b17594dbbbe3b8920311", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=deddb009f0003734d3c73fa859826d57ec600270", "patch": "@@ -299,11 +299,12 @@ impl get_and_find_region for isr_alist {\n     }\n \n     pub fn find(&self, br: ty::bound_region) -> Option<ty::Region> {\n-        for list::each(*self) |isr| {\n+        let mut ret = None;\n+        do list::each(*self) |isr| {\n             let (isr_br, isr_r) = *isr;\n-            if isr_br == br { return Some(isr_r); }\n-        }\n-        return None;\n+            if isr_br == br { ret = Some(isr_r); false } else { true }\n+        };\n+        ret\n     }\n }\n "}, {"sha": "beb762c74892bc2136f3ff51d138a7176c6b5fe8", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=deddb009f0003734d3c73fa859826d57ec600270", "patch": "@@ -589,14 +589,15 @@ impl Repr for ty::RegionSubsts {\n impl Repr for ty::ParamBounds {\n     fn repr(&self, tcx: ctxt) -> ~str {\n         let mut res = ~[];\n-        for self.builtin_bounds.each |b| {\n+        do self.builtin_bounds.each |b| {\n             res.push(match b {\n                 ty::BoundStatic => ~\"'static\",\n                 ty::BoundSend => ~\"Send\",\n                 ty::BoundFreeze => ~\"Freeze\",\n                 ty::BoundSized => ~\"Sized\",\n             });\n-        }\n+            true\n+        };\n         foreach t in self.trait_bounds.iter() {\n             res.push(t.repr(tcx));\n         }\n@@ -832,9 +833,10 @@ impl UserString for ty::BuiltinBounds {\n     fn user_string(&self, tcx: ctxt) -> ~str {\n         if self.is_empty() { ~\"<no-bounds>\" } else {\n             let mut result = ~[];\n-            for self.each |bb| {\n+            do self.each |bb| {\n                 result.push(bb.user_string(tcx));\n-            }\n+                true\n+            };\n             result.connect(\"+\")\n         }\n     }"}, {"sha": "316dd09ef0aa8f8fd2f93b35dce88a2242301fa9", "filename": "src/librusti/program.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrusti%2Fprogram.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrusti%2Fprogram.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Fprogram.rs?ref=deddb009f0003734d3c73fa859826d57ec600270", "patch": "@@ -202,13 +202,13 @@ impl Program {\n             use extra::serialize::*;\n             %s // view items\n         \", self.externs, self.view_items);\n-        for self.structs.each_value |s| {\n+        foreach (_, s) in self.structs.iter() {\n             // The structs aren't really useful unless they're encodable\n             code.push_str(\"#[deriving(Encodable, Decodable)]\");\n             code.push_str(*s);\n             code.push_str(\"\\n\");\n         }\n-        for self.items.each_value |s| {\n+        foreach (_, s) in self.items.iter() {\n             code.push_str(*s);\n             code.push_str(\"\\n\");\n         }"}, {"sha": "7c12645b2b2a354de495075e2139089ffed518ff", "filename": "src/librustpkg/package_source.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustpkg%2Fpackage_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustpkg%2Fpackage_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_source.rs?ref=deddb009f0003734d3c73fa859826d57ec600270", "patch": "@@ -165,7 +165,7 @@ impl PkgSrc {\n         debug!(\"Called check_dir, I'm in %s\", dir.to_str());\n         let prefix = dir.components.len();\n         debug!(\"Matching against %?\", self.id.local_path.filestem());\n-        for os::walk_dir(&dir) |pth| {\n+        do os::walk_dir(&dir) |pth| {\n             match pth.filename() {\n                 Some(~\"lib.rs\") => PkgSrc::push_crate(&mut self.libs,\n                                                       prefix,\n@@ -181,7 +181,8 @@ impl PkgSrc {\n                                                         pth),\n                 _ => ()\n             }\n-        }\n+            true\n+        };\n \n         if self.libs.is_empty() && self.mains.is_empty()\n             && self.tests.is_empty() && self.benchs.is_empty() {"}, {"sha": "c86d10bc3e7339cad254f7067310edb8d075989d", "filename": "src/librustpkg/rustpkg.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustpkg%2Frustpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustpkg%2Frustpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rs?ref=deddb009f0003734d3c73fa859826d57ec600270", "patch": "@@ -206,11 +206,12 @@ impl CtxMethods for Ctx {\n                     // The package id is presumed to be the first command-line\n                     // argument\n                     let pkgid = PkgId::new(args[0].clone(), &os::getcwd());\n-                    for each_pkg_parent_workspace(&pkgid) |workspace| {\n+                    do each_pkg_parent_workspace(&pkgid) |workspace| {\n                         debug!(\"found pkg %s in workspace %s, trying to build\",\n                                pkgid.to_str(), workspace.to_str());\n                         self.build(workspace, &pkgid);\n-                    }\n+                        true\n+                    };\n                 }\n             }\n             \"clean\" => {\n@@ -264,17 +265,19 @@ impl CtxMethods for Ctx {\n                         self.install(&rp[0], &pkgid);\n                     }\n                     else {\n-                        for each_pkg_parent_workspace(&pkgid) |workspace| {\n+                        do each_pkg_parent_workspace(&pkgid) |workspace| {\n                             self.install(workspace, &pkgid);\n-                        }\n+                            true\n+                        };\n                     }\n                 }\n             }\n             \"list\" => {\n                 io::println(\"Installed packages:\");\n-                for installed_packages::list_installed_packages |pkg_id| {\n-                    io::println(pkg_id.local_path.to_str());\n-                }\n+                do installed_packages::list_installed_packages |pkg_id| {\n+                    println(pkg_id.local_path.to_str());\n+                    true\n+                };\n             }\n             \"prefer\" => {\n                 if args.len() < 1 {\n@@ -299,11 +302,12 @@ impl CtxMethods for Ctx {\n                 else {\n                     let rp = rust_path();\n                     assert!(!rp.is_empty());\n-                    for each_pkg_parent_workspace(&pkgid) |workspace| {\n+                    do each_pkg_parent_workspace(&pkgid) |workspace| {\n                         path_util::uninstall_package_from(workspace, &pkgid);\n                         note(fmt!(\"Uninstalled package %s (was installed in %s)\",\n                                   pkgid.to_str(), workspace.to_str()));\n-                    }\n+                        true\n+                    };\n                 }\n             }\n             \"unprefer\" => {"}, {"sha": "2010e1d4b793f5f0dc69610a6730825e96c34a78", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=deddb009f0003734d3c73fa859826d57ec600270", "patch": "@@ -323,7 +323,7 @@ pub fn find_and_install_dependencies(ctxt: &Ctx,\n     debug!(\"In find_and_install_dependencies...\");\n     let my_workspace = (*workspace).clone();\n     let my_ctxt      = *ctxt;\n-    for c.each_view_item() |vi: &ast::view_item| {\n+    do c.each_view_item() |vi: &ast::view_item| {\n         debug!(\"A view item!\");\n         match vi.node {\n             // ignore metadata, I guess\n@@ -354,7 +354,8 @@ pub fn find_and_install_dependencies(ctxt: &Ctx,\n             // Ignore `use`s\n             _ => ()\n         }\n-    }\n+        true\n+    };\n }\n \n #[cfg(windows)]"}, {"sha": "8505385543213720901ea1fcae0b0b46da83329d", "filename": "src/libstd/char.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibstd%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibstd%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fchar.rs?ref=deddb009f0003734d3c73fa859826d57ec600270", "patch": "@@ -211,12 +211,13 @@ pub fn escape_unicode(c: char, f: &fn(char)) {\n         (c <= '\\uffff') { f('u'); 4 }\n         _               { f('U'); 8 }\n     );\n-    for int::range_step(4 * (pad - 1), -1, -4) |offset| {\n+    do int::range_step(4 * (pad - 1), -1, -4) |offset| {\n         match ((c as u32) >> offset) & 0xf {\n             i @ 0 .. 9 => { f('0' + i as char); }\n             i => { f('a' + (i - 10) as char); }\n         }\n-    }\n+        true\n+    };\n }\n \n ///"}, {"sha": "abb04e637ca9de99088fbb56d8bbce9fb82974f2", "filename": "src/libstd/cmp.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibstd%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibstd%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcmp.rs?ref=deddb009f0003734d3c73fa859826d57ec600270", "patch": "@@ -236,7 +236,9 @@ mod test {\n         fn t(o1: Ordering, o2: Ordering, e: Ordering) {\n             assert_eq!(lexical_ordering(o1, o2), e);\n         }\n-        for [Less, Equal, Greater].each |&o| {\n+\n+        let xs = [Less, Equal, Greater];\n+        foreach &o in xs.iter() {\n             t(Less, o, Less);\n             t(Equal, o, o);\n             t(Greater, o, Greater);"}, {"sha": "9842a570d7ea7e3c405245d5af9f9e4a17857bf7", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 28, "deletions": 21, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=deddb009f0003734d3c73fa859826d57ec600270", "patch": "@@ -889,27 +889,34 @@ mod tests {\n     fn test_ranges() {\n         let mut l = ~[];\n \n-        for range_rev(14,11) |i| {\n+        do range_rev(14,11) |i| {\n             l.push(i);\n-        }\n-        for range_step(20,26,2) |i| {\n+            true\n+        };\n+        do range_step(20,26,2) |i| {\n             l.push(i);\n-        }\n-        for range_step(36,30,-2) |i| {\n+            true\n+        };\n+        do range_step(36,30,-2) |i| {\n             l.push(i);\n-        }\n-        for range_step(max_value - 2, max_value, 2) |i| {\n+            true\n+        };\n+        do range_step(max_value - 2, max_value, 2) |i| {\n             l.push(i);\n-        }\n-        for range_step(max_value - 3, max_value, 2) |i| {\n+            true\n+        };\n+        do range_step(max_value - 3, max_value, 2) |i| {\n             l.push(i);\n-        }\n-        for range_step(min_value + 2, min_value, -2) |i| {\n+            true\n+        };\n+        do range_step(min_value + 2, min_value, -2) |i| {\n             l.push(i);\n-        }\n-        for range_step(min_value + 3, min_value, -2) |i| {\n+            true\n+        };\n+        do range_step(min_value + 3, min_value, -2) |i| {\n             l.push(i);\n-        }\n+            true\n+        };\n         assert_eq!(l, ~[13,12,11,\n                         20,22,24,\n                         36,34,32,\n@@ -919,22 +926,22 @@ mod tests {\n                         min_value+3,min_value+1]);\n \n         // None of the `fail`s should execute.\n-        for range_rev(0,10) |_i| {\n+        do range_rev(0,10) |_i| {\n             fail!(~\"unreachable\");\n-        }\n-        for range_step(10,0,1) |_i| {\n+        };\n+        do range_step(10,0,1) |_i| {\n             fail!(~\"unreachable\");\n-        }\n-        for range_step(0,10,-1) |_i| {\n+        };\n+        do range_step(0,10,-1) |_i| {\n             fail!(~\"unreachable\");\n-        }\n+        };\n     }\n \n     #[test]\n     #[should_fail]\n     #[ignore(cfg(windows))]\n     fn test_range_step_zero_step() {\n-        for range_step(0,10,0) |_i| {}\n+        do range_step(0,10,0) |_i| { true };\n     }\n }\n "}, {"sha": "a2874c9670390816c034777c231aa4d0179b048a", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 29, "deletions": 22, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=deddb009f0003734d3c73fa859826d57ec600270", "patch": "@@ -654,27 +654,34 @@ mod tests {\n     pub fn test_ranges() {\n         let mut l = ~[];\n \n-        for range_rev(14,11) |i| {\n+        do range_rev(14,11) |i| {\n             l.push(i);\n-        }\n-        for range_step(20,26,2) |i| {\n+            true\n+        };\n+        do range_step(20,26,2) |i| {\n             l.push(i);\n-        }\n-        for range_step(36,30,-2) |i| {\n+            true\n+        };\n+        do range_step(36,30,-2) |i| {\n             l.push(i);\n-        }\n-        for range_step(max_value - 2, max_value, 2) |i| {\n+            true\n+        };\n+        do range_step(max_value - 2, max_value, 2) |i| {\n             l.push(i);\n-        }\n-        for range_step(max_value - 3, max_value, 2) |i| {\n+            true\n+        };\n+        do range_step(max_value - 3, max_value, 2) |i| {\n             l.push(i);\n-        }\n-        for range_step(min_value + 2, min_value, -2) |i| {\n+            true\n+        };\n+        do range_step(min_value + 2, min_value, -2) |i| {\n             l.push(i);\n-        }\n-        for range_step(min_value + 3, min_value, -2) |i| {\n+            true\n+        };\n+        do range_step(min_value + 3, min_value, -2) |i| {\n             l.push(i);\n-        }\n+            true\n+        };\n \n         assert_eq!(l, ~[13,12,11,\n                         20,22,24,\n@@ -685,28 +692,28 @@ mod tests {\n                         min_value+3,min_value+1]);\n \n         // None of the `fail`s should execute.\n-        for range_rev(0,0) |_i| {\n+        do range_rev(0,0) |_i| {\n             fail!(\"unreachable\");\n-        }\n-        for range_step(10,0,1) |_i| {\n+        };\n+        do range_step(10,0,1) |_i| {\n             fail!(\"unreachable\");\n-        }\n-        for range_step(0,1,-10) |_i| {\n+        };\n+        do range_step(0,1,-10) |_i| {\n             fail!(\"unreachable\");\n-        }\n+        };\n     }\n \n     #[test]\n     #[should_fail]\n     #[ignore(cfg(windows))]\n     fn test_range_step_zero_step_up() {\n-        for range_step(0,10,0) |_i| {}\n+        do range_step(0,10,0) |_i| { true };\n     }\n     #[test]\n     #[should_fail]\n     #[ignore(cfg(windows))]\n     fn test_range_step_zero_step_down() {\n-        for range_step(0,-10,0) |_i| {}\n+        do range_step(0,-10,0) |_i| { true };\n     }\n }\n "}, {"sha": "69e1852e662227ebd912a59baa5af978dd4332fb", "filename": "src/libstd/rand.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibstd%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibstd%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand.rs?ref=deddb009f0003734d3c73fa859826d57ec600270", "patch": "@@ -701,7 +701,7 @@ impl IsaacRng {\n         if use_rsl {\n             macro_rules! memloop (\n                 ($arr:expr) => {{\n-                    for u32::range_step(0, RAND_SIZE, 8) |i| {\n+                    do u32::range_step(0, RAND_SIZE, 8) |i| {\n                         a+=$arr[i  ]; b+=$arr[i+1];\n                         c+=$arr[i+2]; d+=$arr[i+3];\n                         e+=$arr[i+4]; f+=$arr[i+5];\n@@ -711,20 +711,22 @@ impl IsaacRng {\n                         self.mem[i+2]=c; self.mem[i+3]=d;\n                         self.mem[i+4]=e; self.mem[i+5]=f;\n                         self.mem[i+6]=g; self.mem[i+7]=h;\n-                    }\n+                        true\n+                    };\n                 }}\n             );\n \n             memloop!(self.rsl);\n             memloop!(self.mem);\n         } else {\n-            for u32::range_step(0, RAND_SIZE, 8) |i| {\n+            do u32::range_step(0, RAND_SIZE, 8) |i| {\n                 mix!();\n                 self.mem[i  ]=a; self.mem[i+1]=b;\n                 self.mem[i+2]=c; self.mem[i+3]=d;\n                 self.mem[i+4]=e; self.mem[i+5]=f;\n                 self.mem[i+6]=g; self.mem[i+7]=h;\n-            }\n+                true\n+            };\n         }\n \n         self.isaac();\n@@ -764,12 +766,13 @@ impl IsaacRng {\n \n         let r = [(0, MIDPOINT), (MIDPOINT, 0)];\n         foreach &(mr_offset, m2_offset) in r.iter() {\n-            for uint::range_step(0, MIDPOINT, 4) |base| {\n+            do uint::range_step(0, MIDPOINT, 4) |base| {\n                 rngstep!(0, 13);\n                 rngstep!(1, -6);\n                 rngstep!(2, 2);\n                 rngstep!(3, -16);\n-            }\n+                true\n+            };\n         }\n \n         self.a = a;"}, {"sha": "4c67d844c7e814ac9f440bfc33d650ab99137cc7", "filename": "src/libstd/run.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=deddb009f0003734d3c73fa859826d57ec600270", "patch": "@@ -665,9 +665,10 @@ fn spawn_process_os(prog: &str, args: &[~str],\n             fail!(\"failure in dup3(err_fd, 2): %s\", os::last_os_error());\n         }\n         // close all other fds\n-        for int::range_rev(getdtablesize() as int, 3) |fd| {\n+        do int::range_rev(getdtablesize() as int, 3) |fd| {\n             close(fd as c_int);\n-        }\n+            true\n+        };\n \n         do with_dirp(dir) |dirp| {\n             if !dirp.is_null() && chdir(dirp) == -1 {"}, {"sha": "9bcf430ff906d7ee90b0c28ff1fbd710d75b0776", "filename": "src/libstd/trie.rs", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibstd%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibstd%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftrie.rs?ref=deddb009f0003734d3c73fa859826d57ec600270", "patch": "@@ -272,14 +272,13 @@ impl<T> TrieNode<T> {\n     }\n \n     fn each_reverse<'a>(&'a self, f: &fn(&uint, &'a T) -> bool) -> bool {\n-        for uint::range_rev(self.children.len(), 0) |idx| {\n+        do uint::range_rev(self.children.len(), 0) |idx| {\n             match self.children[idx] {\n-                Internal(ref x) => if !x.each_reverse(|i,t| f(i,t)) { return false },\n-                External(k, ref v) => if !f(&k, v) { return false },\n-                Nothing => ()\n+                Internal(ref x) => x.each_reverse(|i,t| f(i,t)),\n+                External(k, ref v) => f(&k, v),\n+                Nothing => true\n             }\n         }\n-        true\n     }\n \n     fn mutate_values<'a>(&'a mut self, f: &fn(&uint, &mut T) -> bool) -> bool {\n@@ -417,35 +416,39 @@ mod test_map {\n         let mut trie = TrieMap::new();\n         let n = 300;\n \n-        for uint::range_step(1, n, 2) |x| {\n+        do uint::range_step(1, n, 2) |x| {\n             assert!(trie.insert(x, x + 1));\n             assert!(trie.contains_key(&x));\n             check_integrity(&trie.root);\n-        }\n+            true\n+        };\n \n-        for uint::range_step(0, n, 2) |x| {\n+        do uint::range_step(0, n, 2) |x| {\n             assert!(!trie.contains_key(&x));\n             assert!(trie.insert(x, x + 1));\n             check_integrity(&trie.root);\n-        }\n+            true\n+        };\n \n         foreach x in range(0u, n) {\n             assert!(trie.contains_key(&x));\n             assert!(!trie.insert(x, x + 1));\n             check_integrity(&trie.root);\n         }\n \n-        for uint::range_step(1, n, 2) |x| {\n+        do uint::range_step(1, n, 2) |x| {\n             assert!(trie.remove(&x));\n             assert!(!trie.contains_key(&x));\n             check_integrity(&trie.root);\n-        }\n+            true\n+        };\n \n-        for uint::range_step(0, n, 2) |x| {\n+        do uint::range_step(0, n, 2) |x| {\n             assert!(trie.contains_key(&x));\n             assert!(!trie.insert(x, x + 1));\n             check_integrity(&trie.root);\n-        }\n+            true\n+        };\n     }\n \n     #[test]\n@@ -471,9 +474,10 @@ mod test_map {\n     fn test_each_break() {\n         let mut m = TrieMap::new();\n \n-        for uint::range_rev(uint::max_value, uint::max_value - 10000) |x| {\n+        do uint::range_rev(uint::max_value, uint::max_value - 10000) |x| {\n             m.insert(x, x / 2);\n-        }\n+            true\n+        };\n \n         let mut n = uint::max_value - 10000;\n         do m.each |k, v| {\n@@ -511,9 +515,10 @@ mod test_map {\n     fn test_each_reverse_break() {\n         let mut m = TrieMap::new();\n \n-        for uint::range_rev(uint::max_value, uint::max_value - 10000) |x| {\n+        do uint::range_rev(uint::max_value, uint::max_value - 10000) |x| {\n             m.insert(x, x / 2);\n-        }\n+            true\n+        };\n \n         let mut n = uint::max_value - 1;\n         do m.each_reverse |k, v| {"}, {"sha": "dc6919efcf9009576885ade19c0d229aaa5886b3", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=deddb009f0003734d3c73fa859826d57ec600270", "patch": "@@ -94,12 +94,17 @@ pub fn lookup(name: &str) -> Option<Abi> {\n      * Returns the ABI with the given name (if any).\n      */\n \n-    for each_abi |abi| {\n+    let mut res = None;\n+\n+    do each_abi |abi| {\n         if name == abi.data().name {\n-            return Some(abi);\n+            res = Some(abi);\n+            false\n+        } else {\n+            true\n         }\n-    }\n-    return None;\n+    };\n+    res\n }\n \n pub fn all_names() -> ~[&'static str] {\n@@ -193,21 +198,24 @@ impl AbiSet {\n \n     pub fn for_arch(&self, arch: Architecture) -> Option<Abi> {\n         // NB---Single platform ABIs come first\n-        for self.each |abi| {\n+\n+        let mut res = None;\n+\n+        do self.each |abi| {\n             let data = abi.data();\n             match data.abi_arch {\n-                Archs(a) if (a & arch.bit()) != 0 => { return Some(abi); }\n-                Archs(_) => { }\n-                RustArch | AllArch => { return Some(abi); }\n+                Archs(a) if (a & arch.bit()) != 0 => { res = Some(abi); false }\n+                Archs(_) => { true }\n+                RustArch | AllArch => { res = Some(abi); false }\n             }\n-        }\n+        };\n \n-        None\n+        res\n     }\n \n     pub fn check_valid(&self) -> Option<(Abi, Abi)> {\n         let mut abis = ~[];\n-        for self.each |abi| { abis.push(abi); }\n+        do self.each |abi| { abis.push(abi); true };\n \n         foreach (i, abi) in abis.iter().enumerate() {\n             let data = abi.data();\n@@ -261,9 +269,10 @@ impl ToStr for Abi {\n impl ToStr for AbiSet {\n     fn to_str(&self) -> ~str {\n         let mut strs = ~[];\n-        for self.each |abi| {\n+        do self.each |abi| {\n             strs.push(abi.data().name);\n-        }\n+            true\n+        };\n         fmt!(\"\\\"%s\\\"\", strs.connect(\" \"))\n     }\n }"}, {"sha": "2de4aa474e51e059cfe1cdfb4754146dacab0aa5", "filename": "src/libsyntax/oldvisit.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibsyntax%2Foldvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibsyntax%2Foldvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Foldvisit.rs?ref=deddb009f0003734d3c73fa859826d57ec600270", "patch": "@@ -126,10 +126,10 @@ pub fn visit_mod<E:Clone>(m: &_mod,\n                           _sp: span,\n                           _id: NodeId,\n                           (e, v): (E, vt<E>)) {\n-    for m.view_items.iter().advance |vi| {\n+    foreach vi in m.view_items.iter() {\n         (v.visit_view_item)(vi, (e.clone(), v));\n     }\n-    for m.items.iter().advance |i| {\n+    foreach i in m.items.iter() {\n         (v.visit_item)(*i, (e.clone(), v));\n     }\n }\n@@ -173,10 +173,10 @@ pub fn visit_item<E:Clone>(i: &item, (e, v): (E, vt<E>)) {\n         }\n         item_mod(ref m) => (v.visit_mod)(m, i.span, i.id, (e, v)),\n         item_foreign_mod(ref nm) => {\n-            for nm.view_items.iter().advance |vi| {\n+            foreach vi in nm.view_items.iter() {\n                 (v.visit_view_item)(vi, (e.clone(), v));\n             }\n-            for nm.items.iter().advance |ni| {\n+            foreach ni in nm.items.iter() {\n                 (v.visit_foreign_item)(*ni, (e.clone(), v));\n             }\n         }\n@@ -194,11 +194,11 @@ pub fn visit_item<E:Clone>(i: &item, (e, v): (E, vt<E>)) {\n         }\n         item_impl(ref tps, ref traits, ref ty, ref methods) => {\n             (v.visit_generics)(tps, (e.clone(), v));\n-            for traits.iter().advance |p| {\n+            foreach p in traits.iter() {\n                 visit_trait_ref(p, (e.clone(), v));\n             }\n             (v.visit_ty)(ty, (e.clone(), v));\n-            for methods.iter().advance |m| {\n+            foreach m in methods.iter() {\n                 visit_method_helper(*m, (e.clone(), v))\n             }\n         }\n@@ -208,10 +208,10 @@ pub fn visit_item<E:Clone>(i: &item, (e, v): (E, vt<E>)) {\n         }\n         item_trait(ref generics, ref traits, ref methods) => {\n             (v.visit_generics)(generics, (e.clone(), v));\n-            for traits.iter().advance |p| {\n+            foreach p in traits.iter() {\n                 visit_path(&p.path, (e.clone(), v));\n             }\n-            for methods.iter().advance |m| {\n+            foreach m in methods.iter() {\n                 (v.visit_trait_method)(m, (e.clone(), v));\n             }\n         }\n@@ -222,10 +222,10 @@ pub fn visit_item<E:Clone>(i: &item, (e, v): (E, vt<E>)) {\n pub fn visit_enum_def<E:Clone>(enum_definition: &ast::enum_def,\n                                tps: &Generics,\n                                (e, v): (E, vt<E>)) {\n-    for enum_definition.variants.iter().advance |vr| {\n+    foreach vr in enum_definition.variants.iter() {\n         match vr.node.kind {\n             tuple_variant_kind(ref variant_args) => {\n-                for variant_args.iter().advance |va| {\n+                foreach va in variant_args.iter() {\n                     (v.visit_ty)(&va.ty, (e.clone(), v));\n                 }\n             }\n@@ -235,7 +235,7 @@ pub fn visit_enum_def<E:Clone>(enum_definition: &ast::enum_def,\n             }\n         }\n         // Visit the disr expr if it exists\n-        for vr.node.disr_expr.iter().advance |ex| {\n+        foreach ex in vr.node.disr_expr.iter() {\n             (v.visit_expr)(*ex, (e.clone(), v))\n         }\n     }\n@@ -250,12 +250,12 @@ pub fn visit_ty<E:Clone>(t: &Ty, (e, v): (E, vt<E>)) {\n             (v.visit_ty)(mt.ty, (e, v));\n         },\n         ty_tup(ref ts) => {\n-            for ts.iter().advance |tt| {\n+            foreach tt in ts.iter() {\n                 (v.visit_ty)(tt, (e.clone(), v));\n             }\n         },\n         ty_closure(ref f) => {\n-            for f.decl.inputs.iter().advance |a| {\n+            foreach a in f.decl.inputs.iter() {\n                 (v.visit_ty)(&a.ty, (e.clone(), v));\n             }\n             (v.visit_ty)(&f.decl.output, (e.clone(), v));\n@@ -264,7 +264,7 @@ pub fn visit_ty<E:Clone>(t: &Ty, (e, v): (E, vt<E>)) {\n             };\n         },\n         ty_bare_fn(ref f) => {\n-            for f.decl.inputs.iter().advance |a| {\n+            foreach a in f.decl.inputs.iter() {\n                 (v.visit_ty)(&a.ty, (e.clone(), v));\n             }\n             (v.visit_ty)(&f.decl.output, (e, v));\n@@ -284,27 +284,27 @@ pub fn visit_ty<E:Clone>(t: &Ty, (e, v): (E, vt<E>)) {\n }\n \n pub fn visit_path<E:Clone>(p: &Path, (e, v): (E, vt<E>)) {\n-    for p.types.iter().advance |tp| { (v.visit_ty)(tp, (e.clone(), v)); }\n+    foreach tp in p.types.iter() { (v.visit_ty)(tp, (e.clone(), v)); }\n }\n \n pub fn visit_pat<E:Clone>(p: &pat, (e, v): (E, vt<E>)) {\n     match p.node {\n         pat_enum(ref path, ref children) => {\n             visit_path(path, (e.clone(), v));\n-            for children.iter().advance |children| {\n-                for children.iter().advance |child| {\n+            foreach children in children.iter() {\n+                foreach child in children.iter() {\n                     (v.visit_pat)(*child, (e.clone(), v));\n                 }\n             }\n         }\n         pat_struct(ref path, ref fields, _) => {\n             visit_path(path, (e.clone(), v));\n-            for fields.iter().advance |f| {\n+            foreach f in fields.iter() {\n                 (v.visit_pat)(f.pat, (e.clone(), v));\n             }\n         }\n         pat_tup(ref elts) => {\n-            for elts.iter().advance |elt| {\n+            foreach elt in elts.iter() {\n                 (v.visit_pat)(*elt, (e.clone(), v))\n             }\n         },\n@@ -313,7 +313,7 @@ pub fn visit_pat<E:Clone>(p: &pat, (e, v): (E, vt<E>)) {\n         },\n         pat_ident(_, ref path, ref inner) => {\n             visit_path(path, (e.clone(), v));\n-            for inner.iter().advance |subpat| {\n+            foreach subpat in inner.iter() {\n                 (v.visit_pat)(*subpat, (e.clone(), v))\n             }\n         }\n@@ -324,13 +324,13 @@ pub fn visit_pat<E:Clone>(p: &pat, (e, v): (E, vt<E>)) {\n         }\n         pat_wild => (),\n         pat_vec(ref before, ref slice, ref after) => {\n-            for before.iter().advance |elt| {\n+            foreach elt in before.iter() {\n                 (v.visit_pat)(*elt, (e.clone(), v));\n             }\n-            for slice.iter().advance |elt| {\n+            foreach elt in slice.iter() {\n                 (v.visit_pat)(*elt, (e.clone(), v));\n             }\n-            for after.iter().advance |tail| {\n+            foreach tail in after.iter() {\n                 (v.visit_pat)(*tail, (e.clone(), v));\n             }\n         }\n@@ -351,7 +351,7 @@ pub fn visit_foreign_item<E:Clone>(ni: &foreign_item, (e, v): (E, vt<E>)) {\n \n pub fn visit_ty_param_bounds<E:Clone>(bounds: &OptVec<TyParamBound>,\n                                       (e, v): (E, vt<E>)) {\n-    for bounds.iter().advance |bound| {\n+    foreach bound in bounds.iter() {\n         match *bound {\n             TraitTyParamBound(ref ty) => visit_trait_ref(ty, (e.clone(), v)),\n             RegionTyParamBound => {}\n@@ -360,13 +360,13 @@ pub fn visit_ty_param_bounds<E:Clone>(bounds: &OptVec<TyParamBound>,\n }\n \n pub fn visit_generics<E:Clone>(generics: &Generics, (e, v): (E, vt<E>)) {\n-    for generics.ty_params.iter().advance |tp| {\n+    foreach tp in generics.ty_params.iter() {\n         visit_ty_param_bounds(&tp.bounds, (e.clone(), v));\n     }\n }\n \n pub fn visit_fn_decl<E:Clone>(fd: &fn_decl, (e, v): (E, vt<E>)) {\n-    for fd.inputs.iter().advance |a| {\n+    foreach a in fd.inputs.iter() {\n         (v.visit_pat)(a.pat, (e.clone(), v));\n         (v.visit_ty)(&a.ty, (e.clone(), v));\n     }\n@@ -399,7 +399,7 @@ pub fn visit_fn<E:Clone>(fk: &fn_kind,\n }\n \n pub fn visit_ty_method<E:Clone>(m: &TypeMethod, (e, v): (E, vt<E>)) {\n-    for m.decl.inputs.iter().advance |a| {\n+    foreach a in m.decl.inputs.iter() {\n         (v.visit_ty)(&a.ty, (e.clone(), v));\n     }\n     (v.visit_generics)(&m.generics, (e.clone(), v));\n@@ -420,7 +420,7 @@ pub fn visit_struct_def<E:Clone>(\n     _id: NodeId,\n     (e, v): (E, vt<E>)\n ) {\n-    for sd.fields.iter().advance |f| {\n+    foreach f in sd.fields.iter() {\n         (v.visit_struct_field)(*f, (e.clone(), v));\n     }\n }\n@@ -430,10 +430,10 @@ pub fn visit_struct_field<E:Clone>(sf: &struct_field, (e, v): (E, vt<E>)) {\n }\n \n pub fn visit_block<E:Clone>(b: &Block, (e, v): (E, vt<E>)) {\n-    for b.view_items.iter().advance |vi| {\n+    foreach vi in b.view_items.iter() {\n         (v.visit_view_item)(vi, (e.clone(), v));\n     }\n-    for b.stmts.iter().advance |s| {\n+    foreach s in b.stmts.iter() {\n         (v.visit_stmt)(*s, (e.clone(), v));\n     }\n     visit_expr_opt(b.expr, (e, v));\n@@ -460,7 +460,7 @@ pub fn visit_expr_opt<E>(eo: Option<@expr>, (e, v): (E, vt<E>)) {\n }\n \n pub fn visit_exprs<E:Clone>(exprs: &[@expr], (e, v): (E, vt<E>)) {\n-    for exprs.iter().advance |ex| { (v.visit_expr)(*ex, (e.clone(), v)); }\n+    foreach ex in exprs.iter() { (v.visit_expr)(*ex, (e.clone(), v)); }\n }\n \n pub fn visit_mac<E>(_m: &mac, (_e, _v): (E, vt<E>)) {\n@@ -477,21 +477,21 @@ pub fn visit_expr<E:Clone>(ex: @expr, (e, v): (E, vt<E>)) {\n         }\n         expr_struct(ref p, ref flds, base) => {\n             visit_path(p, (e.clone(), v));\n-            for flds.iter().advance |f| {\n+            foreach f in flds.iter() {\n                 (v.visit_expr)(f.expr, (e.clone(), v));\n             }\n             visit_expr_opt(base, (e.clone(), v));\n         }\n         expr_tup(ref elts) => {\n-            for elts.iter().advance |el| { (v.visit_expr)(*el, (e.clone(), v)) }\n+            foreach el in elts.iter() { (v.visit_expr)(*el, (e.clone(), v)) }\n         }\n         expr_call(callee, ref args, _) => {\n             visit_exprs(*args, (e.clone(), v));\n             (v.visit_expr)(callee, (e.clone(), v));\n         }\n         expr_method_call(_, callee, _, ref tys, ref args, _) => {\n             visit_exprs(*args, (e.clone(), v));\n-            for tys.iter().advance |tp| {\n+            foreach tp in tys.iter() {\n                 (v.visit_ty)(tp, (e.clone(), v));\n             }\n             (v.visit_expr)(callee, (e.clone(), v));\n@@ -524,7 +524,7 @@ pub fn visit_expr<E:Clone>(ex: @expr, (e, v): (E, vt<E>)) {\n         expr_loop(ref b, _) => (v.visit_block)(b, (e.clone(), v)),\n         expr_match(x, ref arms) => {\n             (v.visit_expr)(x, (e.clone(), v));\n-            for arms.iter().advance |a| { (v.visit_arm)(a, (e.clone(), v)); }\n+            foreach a in arms.iter() { (v.visit_arm)(a, (e.clone(), v)); }\n         }\n         expr_fn_block(ref decl, ref body) => {\n             (v.visit_fn)(\n@@ -547,7 +547,7 @@ pub fn visit_expr<E:Clone>(ex: @expr, (e, v): (E, vt<E>)) {\n         }\n         expr_field(x, _, ref tys) => {\n             (v.visit_expr)(x, (e.clone(), v));\n-            for tys.iter().advance |tp| {\n+            foreach tp in tys.iter() {\n                 (v.visit_ty)(tp, (e.clone(), v));\n             }\n         }\n@@ -567,10 +567,10 @@ pub fn visit_expr<E:Clone>(ex: @expr, (e, v): (E, vt<E>)) {\n         expr_mac(ref mac) => visit_mac(mac, (e.clone(), v)),\n         expr_paren(x) => (v.visit_expr)(x, (e.clone(), v)),\n         expr_inline_asm(ref a) => {\n-            for a.inputs.iter().advance |&(_, input)| {\n+            foreach &(_, input) in a.inputs.iter() {\n                 (v.visit_expr)(input, (e.clone(), v));\n             }\n-            for a.outputs.iter().advance |&(_, out)| {\n+            foreach &(_, out) in a.outputs.iter() {\n                 (v.visit_expr)(out, (e.clone(), v));\n             }\n         }\n@@ -579,7 +579,7 @@ pub fn visit_expr<E:Clone>(ex: @expr, (e, v): (E, vt<E>)) {\n }\n \n pub fn visit_arm<E:Clone>(a: &arm, (e, v): (E, vt<E>)) {\n-    for a.pats.iter().advance |p| { (v.visit_pat)(*p, (e.clone(), v)); }\n+    foreach p in a.pats.iter() { (v.visit_pat)(*p, (e.clone(), v)); }\n     visit_expr_opt(a.guard, (e.clone(), v));\n     (v.visit_block)(&a.body, (e.clone(), v));\n }"}, {"sha": "ac3c50a53defb230491ed8c1d7f22022f9173cd3", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deddb009f0003734d3c73fa859826d57ec600270/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=deddb009f0003734d3c73fa859826d57ec600270", "patch": "@@ -11,7 +11,7 @@\n use abi;\n use abi::AbiSet;\n use ast::{Sigil, BorrowedSigil, ManagedSigil, OwnedSigil};\n-use ast::{CallSugar, NoSugar, DoSugar, ForSugar};\n+use ast::{CallSugar, NoSugar, DoSugar};\n use ast::{TyBareFn, TyClosure};\n use ast::{RegionTyParamBound, TraitTyParamBound};\n use ast::{provided, public, purity};\n@@ -24,7 +24,7 @@ use ast::{expr, expr_, expr_addr_of, expr_match, expr_again};\n use ast::{expr_assign, expr_assign_op, expr_binary, expr_block};\n use ast::{expr_break, expr_call, expr_cast, expr_do_body};\n use ast::{expr_field, expr_fn_block, expr_if, expr_index};\n-use ast::{expr_lit, expr_log, expr_loop, expr_loop_body, expr_mac};\n+use ast::{expr_lit, expr_log, expr_loop, expr_mac};\n use ast::{expr_method_call, expr_paren, expr_path, expr_repeat};\n use ast::{expr_ret, expr_self, expr_struct, expr_tup, expr_unary};\n use ast::{expr_vec, expr_vstore, expr_vstore_mut_box};\n@@ -1626,8 +1626,7 @@ impl Parser {\n         } else if self.eat_keyword(keywords::ForEach) {\n             return self.parse_for_expr();\n         } else if self.eat_keyword(keywords::For) {\n-            return self.parse_sugary_call_expr(lo, ~\"for\", ForSugar,\n-                                               expr_loop_body);\n+            return self.parse_for_expr();\n         } else if self.eat_keyword(keywords::Do) {\n             return self.parse_sugary_call_expr(lo, ~\"do\", DoSugar,\n                                                expr_do_body);\n@@ -2326,9 +2325,9 @@ impl Parser {\n         }\n     }\n \n-    // parse a 'foreach' .. 'in' expression ('foreach' token already eaten)\n+    // parse a 'for' .. 'in' expression ('for' token already eaten)\n     pub fn parse_for_expr(&self) -> @expr {\n-        // Parse: `foreach <src_pat> in <src_expr> <src_loop_block>`\n+        // Parse: `for <src_pat> in <src_expr> <src_loop_block>`\n \n         let lo = self.last_span.lo;\n         let pat = self.parse_pat();"}, {"sha": "10d9c1a6b9b4671fe53da0ad29e3fb7229cb17e1", "filename": "src/test/bench/core-map.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/deddb009f0003734d3c73fa859826d57ec600270/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deddb009f0003734d3c73fa859826d57ec600270/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=deddb009f0003734d3c73fa859826d57ec600270", "patch": "@@ -53,21 +53,24 @@ fn descending<M: MutableMap<uint, uint>>(map: &mut M, n_keys: uint) {\n     io::println(\" Descending integers:\");\n \n     do timed(\"insert\") {\n-        for uint::range_rev(n_keys, 0) |i| {\n+        do uint::range_rev(n_keys, 0) |i| {\n             map.insert(i, i + 1);\n-        }\n+            true\n+        };\n     }\n \n     do timed(\"search\") {\n-        for uint::range_rev(n_keys, 0) |i| {\n+        do uint::range_rev(n_keys, 0) |i| {\n             assert_eq!(map.find(&i).unwrap(), &(i + 1));\n-        }\n+            true\n+        };\n     }\n \n     do timed(\"remove\") {\n-        for uint::range_rev(n_keys, 0) |i| {\n+        do uint::range_rev(n_keys, 0) |i| {\n             assert!(map.remove(&i));\n-        }\n+            true\n+        };\n     }\n }\n "}, {"sha": "4f90ff5802d7c6d37b2706c7189dccc5ba33353b", "filename": "src/test/compile-fail/bad-for-loop-2.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2a7be1c9e4d5a50dab4f3f95c8f1d843a7d6f084/src%2Ftest%2Fcompile-fail%2Fbad-for-loop-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a7be1c9e4d5a50dab4f3f95c8f1d843a7d6f084/src%2Ftest%2Fcompile-fail%2Fbad-for-loop-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-for-loop-2.rs?ref=2a7be1c9e4d5a50dab4f3f95c8f1d843a7d6f084", "patch": "@@ -1,15 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn main() {\n-    fn quux(_: &fn(&int) -> bool) -> () { }\n-    for quux |_| { } //~ ERROR expected `for` closure to return\n-                     // `bool`, but found `()`\n-}"}, {"sha": "83616b708f2aaf13386e0d4f51ec31dcfff093b3", "filename": "src/test/compile-fail/bad-for-loop.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2a7be1c9e4d5a50dab4f3f95c8f1d843a7d6f084/src%2Ftest%2Fcompile-fail%2Fbad-for-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a7be1c9e4d5a50dab4f3f95c8f1d843a7d6f084/src%2Ftest%2Fcompile-fail%2Fbad-for-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-for-loop.rs?ref=2a7be1c9e4d5a50dab4f3f95c8f1d843a7d6f084", "patch": "@@ -1,16 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn main() {\n-    fn quux(_: &fn(&int) -> int) -> bool { true }\n-    for quux |_| { } //~ ERROR A `for` loop iterator should expect a\n-                     // closure that returns `bool`.  This iterator\n-                     // expects a closure that returns `int`.\n-}"}, {"sha": "869ef0591e4bee2a69540ac7256fa5513489e1dc", "filename": "src/test/compile-fail/borrowck-lend-flow-loop.rs", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/deddb009f0003734d3c73fa859826d57ec600270/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deddb009f0003734d3c73fa859826d57ec600270/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-loop.rs?ref=deddb009f0003734d3c73fa859826d57ec600270", "patch": "@@ -17,7 +17,6 @@\n fn borrow(_v: &int) {}\n fn borrow_mut(_v: &mut int) {}\n fn cond() -> bool { fail!() }\n-fn for_func(_f: &fn() -> bool) -> bool { fail!() }\n fn produce<T>() -> T { fail!(); }\n \n fn inc(v: &mut ~int) {\n@@ -70,17 +69,6 @@ fn while_aliased_mut() {\n     }\n }\n \n-fn for_loop_aliased_mut() {\n-    // In this instance, the borrow is carried through the loop.\n-\n-    let mut v = ~3;\n-    let mut w = ~4;\n-    let mut _x = &w;\n-    for for_func {\n-        borrow_mut(v); //~ ERROR cannot borrow\n-        _x = &v;\n-    }\n-}\n \n fn loop_aliased_mut_break() {\n     // In this instance, the borrow is carried through the loop.\n@@ -110,21 +98,6 @@ fn while_aliased_mut_break() {\n     borrow_mut(v); //~ ERROR cannot borrow\n }\n \n-fn for_aliased_mut_break() {\n-    // In this instance, the borrow is carried through the loop.\n-\n-    let mut v = ~3;\n-    let mut w = ~4;\n-    let mut _x = &w;\n-    for for_func {\n-        // here we cannot be sure that `for_func` respects the break below\n-        borrow_mut(v); //~ ERROR cannot borrow\n-        _x = &v;\n-        break;\n-    }\n-    borrow_mut(v); //~ ERROR cannot borrow\n-}\n-\n fn while_aliased_mut_cond(cond: bool, cond2: bool) {\n     let mut v = ~3;\n     let mut w = ~4;"}, {"sha": "7e65d8ab82d9b4dbb0f3b26474d31198c5ad0921", "filename": "src/test/compile-fail/issue-3651.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2a7be1c9e4d5a50dab4f3f95c8f1d843a7d6f084/src%2Ftest%2Fcompile-fail%2Fissue-3651.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a7be1c9e4d5a50dab4f3f95c8f1d843a7d6f084/src%2Ftest%2Fcompile-fail%2Fissue-3651.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3651.rs?ref=2a7be1c9e4d5a50dab4f3f95c8f1d843a7d6f084", "patch": "@@ -1,16 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::task;\n-\n-fn main() {\n-    for task::spawn { return true; } //~ ERROR A `for` loop iterator should expect a closure that\n-                                     //~^ ERROR expected `for` closure to return `bool`\n-}"}, {"sha": "5570562cf8b0040be00377f5277bf7294a652fe2", "filename": "src/test/compile-fail/lint-deprecated-for-loop.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2a7be1c9e4d5a50dab4f3f95c8f1d843a7d6f084/src%2Ftest%2Fcompile-fail%2Flint-deprecated-for-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a7be1c9e4d5a50dab4f3f95c8f1d843a7d6f084/src%2Ftest%2Fcompile-fail%2Flint-deprecated-for-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-deprecated-for-loop.rs?ref=2a7be1c9e4d5a50dab4f3f95c8f1d843a7d6f084", "patch": "@@ -1,20 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-#[forbid(deprecated_for_loop)];\n-\n-fn f(_: &fn() -> bool) -> bool {\n-    true\n-}\n-\n-fn main() {\n-    for f {} //~ ERROR `for` is deprecated\n-}"}, {"sha": "c9a3e044d9c4783ed2722401dddfc57957b6b029", "filename": "src/test/compile-fail/regionck-closure-lifetimes.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/deddb009f0003734d3c73fa859826d57ec600270/src%2Ftest%2Fcompile-fail%2Fregionck-closure-lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deddb009f0003734d3c73fa859826d57ec600270/src%2Ftest%2Fcompile-fail%2Fregionck-closure-lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregionck-closure-lifetimes.rs?ref=deddb009f0003734d3c73fa859826d57ec600270", "patch": "@@ -31,16 +31,6 @@ fn no_env_no_for<'a>(_: &'a uint, blk: &fn(p: &'a fn())) {\n     blk(|| ())\n }\n \n-fn no_env_but_for<'a>(_: &'a uint, blk: &fn(p: &'a fn() -> bool) -> bool) {\n-    // Test that a `for` loop is considered to hvae\n-    // implicit free variables.\n-    //\n-    // FIXME(#4846): The `&'a uint` parameter is needed to ensure that `'a`\n-    // is a free and not bound region name.\n-\n-    for blk { } //~ ERROR cannot infer an appropriate lifetime\n-}\n-\n fn repeating_loop() {\n     // Test that the closure cannot be created within `loop` loop and\n     // called without, even though the state that it closes over is"}, {"sha": "5269f7dab5aad92570635f8608b7adf0924674b5", "filename": "src/test/run-pass/assignability-trait.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/deddb009f0003734d3c73fa859826d57ec600270/src%2Ftest%2Frun-pass%2Fassignability-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deddb009f0003734d3c73fa859826d57ec600270/src%2Ftest%2Frun-pass%2Fassignability-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassignability-trait.rs?ref=deddb009f0003734d3c73fa859826d57ec600270", "patch": "@@ -30,14 +30,14 @@ impl<A> iterable<A> for ~[A] {\n \n fn length<A, T: iterable<A>>(x: T) -> uint {\n     let mut len = 0;\n-    for x.iterate() |_y| { len += 1 }\n+    do x.iterate() |_y| { len += 1; true };\n     return len;\n }\n \n pub fn main() {\n     let x = ~[0,1,2,3];\n     // Call a method\n-    for x.iterate() |y| { assert!(x[*y] == *y); }\n+    do x.iterate() |y| { assert!(x[*y] == *y); true };\n     // Call a parameterized function\n     assert_eq!(length(x.clone()), x.len());\n     // Call a parameterized function, with type arguments that require\n@@ -47,7 +47,7 @@ pub fn main() {\n     // Now try it with a type that *needs* to be borrowed\n     let z = [0,1,2,3];\n     // Call a method\n-    for z.iterate() |y| { assert!(z[*y] == *y); }\n+    do z.iterate() |y| { assert!(z[*y] == *y); true };\n     // Call a parameterized function\n     assert_eq!(length::<int, &[int]>(z), z.len());\n }"}, {"sha": "20c9032fbd294a0757dd301881a49eb0bf881823", "filename": "src/test/run-pass/borrowck-mut-uniq.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/deddb009f0003734d3c73fa859826d57ec600270/src%2Ftest%2Frun-pass%2Fborrowck-mut-uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deddb009f0003734d3c73fa859826d57ec600270/src%2Ftest%2Frun-pass%2Fborrowck-mut-uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-mut-uniq.rs?ref=deddb009f0003734d3c73fa859826d57ec600270", "patch": "@@ -31,9 +31,10 @@ pub fn main() {\n     add_int(ints, 22);\n     add_int(ints, 44);\n \n-    for iter_ints(ints) |i| {\n+    do iter_ints(ints) |i| {\n         error!(\"int = %d\", *i);\n-    }\n+        true\n+    };\n \n     error!(\"ints=%?\", ints);\n }"}, {"sha": "b7c97392ec156e5917d62f3856d7c60a6c631d62", "filename": "src/test/run-pass/do-empty-args.rs", "status": "renamed", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/deddb009f0003734d3c73fa859826d57ec600270/src%2Ftest%2Frun-pass%2Fdo-empty-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deddb009f0003734d3c73fa859826d57ec600270/src%2Ftest%2Frun-pass%2Fdo-empty-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdo-empty-args.rs?ref=deddb009f0003734d3c73fa859826d57ec600270", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // no-reformat\n-// Testing various forms of `do` and `for` with empty arg lists\n+// Testing various forms of `do` with empty arg lists\n \n fn f(f: &fn() -> bool) -> bool {\n     true\n@@ -20,8 +20,4 @@ pub fn main() {\n     do f() { true };\n     do f || { true };\n     do f { true };\n-    for f() || { }\n-    for f() { }\n-    for f || { }\n-    for f { }\n }", "previous_filename": "src/test/run-pass/do-for-empty-args.rs"}, {"sha": "2af441993225bcc5fc54a3159f94b32848d27a8b", "filename": "src/test/run-pass/do-no-args.rs", "status": "renamed", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/deddb009f0003734d3c73fa859826d57ec600270/src%2Ftest%2Frun-pass%2Fdo-no-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deddb009f0003734d3c73fa859826d57ec600270/src%2Ftest%2Frun-pass%2Fdo-no-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdo-no-args.rs?ref=deddb009f0003734d3c73fa859826d57ec600270", "patch": "@@ -8,13 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Testing that we can drop the || in for/do exprs\n+// Testing that we can drop the || in do exprs\n \n fn f(f: @fn() -> bool) -> bool { true }\n \n fn d(f: @fn()) { }\n \n pub fn main() {\n-    for f { }\n     do d { }\n }", "previous_filename": "src/test/run-pass/do-for-no-args.rs"}, {"sha": "5eecbe7e03afb207cec9f44a5a9a8cae76b33284", "filename": "src/test/run-pass/num-range-rev.rs", "status": "modified", "additions": 36, "deletions": 24, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/deddb009f0003734d3c73fa859826d57ec600270/src%2Ftest%2Frun-pass%2Fnum-range-rev.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deddb009f0003734d3c73fa859826d57ec600270/src%2Ftest%2Frun-pass%2Fnum-range-rev.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnum-range-rev.rs?ref=deddb009f0003734d3c73fa859826d57ec600270", "patch": "@@ -40,75 +40,87 @@ pub fn main() {\n     // int and uint have same result for\n     //   Sum{100 > i >= 2} == (Sum{1 <= i <= 99} - 1) == n*(n+1)/2 - 1 for n=99\n     let mut sum = 0u;\n-    for uint_range_rev(100, 2) |i| {\n+    do uint_range_rev(100, 2) |i| {\n         sum += i;\n-    }\n+        true\n+    };\n     assert_eq!(sum, 4949);\n \n     let mut sum = 0i;\n-    for int_range_rev(100, 2) |i| {\n+    do int_range_rev(100, 2) |i| {\n         sum += i;\n-    }\n+        true\n+    };\n     assert_eq!(sum, 4949);\n \n \n     // elements are visited in correct order\n     let primes = [2,3,5,7,11];\n     let mut prod = 1i;\n-    for uint_range_rev(5, 0) |i| {\n+    do uint_range_rev(5, 0) |i| {\n         printfln!(\"uint 4 downto 0: %u\", i);\n         prod *= int::pow(primes[i], i);\n-    }\n+        true\n+    };\n     assert_eq!(prod, 11*11*11*11*7*7*7*5*5*3*1);\n     let mut prod = 1i;\n-    for int_range_rev(5, 0) |i| {\n+    do int_range_rev(5, 0) |i| {\n         printfln!(\"int 4 downto 0: %d\", i);\n         prod *= int::pow(primes[i], i as uint);\n-    }\n+        true\n+    };\n     assert_eq!(prod, 11*11*11*11*7*7*7*5*5*3*1);\n \n \n     // range and range_rev are symmetric.\n     let mut sum_up = 0u;\n-    for uint_range(10, 30) |i| {\n+    do uint_range(10, 30) |i| {\n         sum_up += i;\n-    }\n+        true\n+    };\n     let mut sum_down = 0u;\n-    for uint_range_rev(30, 10) |i| {\n+    do uint_range_rev(30, 10) |i| {\n         sum_down += i;\n-    }\n+        true\n+    };\n     assert_eq!(sum_up, sum_down);\n \n     let mut sum_up = 0;\n-    for int_range(-20, 10) |i| {\n+    do int_range(-20, 10) |i| {\n         sum_up += i;\n-    }\n+        true\n+    };\n     let mut sum_down = 0;\n-    for int_range_rev(10, -20) |i| {\n+    do int_range_rev(10, -20) |i| {\n         sum_down += i;\n-    }\n+        true\n+    };\n     assert_eq!(sum_up, sum_down);\n \n \n     // empty ranges\n-    for int_range_rev(10, 10) |_| {\n+    do int_range_rev(10, 10) |_| {\n         fail!(\"range should be empty when start == stop\");\n-    }\n+        true\n+    };\n \n-    for uint_range_rev(0, 1) |_| {\n+    do uint_range_rev(0, 1) |_| {\n         fail!(\"range should be empty when start-1 underflows\");\n-    }\n+        true\n+    };\n \n     // range iterations do not wrap/underflow\n     let mut uflo_loop_visited = ~[];\n-    for int_range_step(int::min_value+15, int::min_value, -4) |x| {\n+    do int_range_step(int::min_value+15, int::min_value, -4) |x| {\n         uflo_loop_visited.push(x - int::min_value);\n-    }\n+        true\n+    };\n     assert_eq!(uflo_loop_visited, ~[15, 11, 7, 3]);\n \n     let mut uflo_loop_visited = ~[];\n-    for uint_range_step(uint::min_value+15, uint::min_value, -4) |x| {\n+    do uint_range_step(uint::min_value+15, uint::min_value, -4) |x| {\n         uflo_loop_visited.push(x - uint::min_value);\n-    }\n+        true\n+    };\n     assert_eq!(uflo_loop_visited, ~[15, 11, 7, 3]);\n }"}, {"sha": "7376edef8a8f6c9c2f5637519cf3a016c6971e7b", "filename": "src/test/run-pass/num-range.rs", "status": "modified", "additions": 39, "deletions": 26, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/deddb009f0003734d3c73fa859826d57ec600270/src%2Ftest%2Frun-pass%2Fnum-range.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deddb009f0003734d3c73fa859826d57ec600270/src%2Ftest%2Frun-pass%2Fnum-range.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnum-range.rs?ref=deddb009f0003734d3c73fa859826d57ec600270", "patch": "@@ -32,88 +32,101 @@ pub fn main() {\n     // int and uint have same result for\n     //   Sum{2 <= i < 100} == (Sum{1 <= i <= 99} - 1) == n*(n+1)/2 - 1 for n=99\n     let mut sum = 0u;\n-    for uint_range(2, 100) |i| {\n+    do uint_range(2, 100) |i| {\n         sum += i;\n-    }\n+        true\n+    };\n     assert_eq!(sum, 4949);\n \n     let mut sum = 0i;\n-    for int_range(2, 100) |i| {\n+    do int_range(2, 100) |i| {\n         sum += i;\n-    }\n+        true\n+    };\n     assert_eq!(sum, 4949);\n \n \n     // elements are visited in correct order\n     let primes = [2,3,5,7];\n     let mut prod = 1i;\n-    for uint_range(0, 4) |i| {\n+    do uint_range(0, 4) |i| {\n         prod *= int::pow(primes[i], i);\n-    }\n+        true\n+    };\n     assert_eq!(prod, 1*3*5*5*7*7*7);\n     let mut prod = 1i;\n-    for int_range(0, 4) |i| {\n+    do int_range(0, 4) |i| {\n         prod *= int::pow(primes[i], i as uint);\n-    }\n+        true\n+    };\n     assert_eq!(prod, 1*3*5*5*7*7*7);\n \n \n     // empty ranges\n-    for int_range(10, 10) |_| {\n+    do int_range(10, 10) |_| {\n         fail!(\"range should be empty when start == stop\");\n-    }\n+        true\n+    };\n \n-    for uint_range(10, 10) |_| {\n+    do uint_range(10, 10) |_| {\n         fail!(\"range should be empty when start == stop\");\n-    }\n+        true\n+    };\n \n \n     // range iterations do not wrap/overflow\n     let mut oflo_loop_visited = ~[];\n-    for uint_range_step(uint::max_value-15, uint::max_value, 4) |x| {\n+    do uint_range_step(uint::max_value-15, uint::max_value, 4) |x| {\n         oflo_loop_visited.push(uint::max_value - x);\n-    }\n+        true\n+    };\n     assert_eq!(oflo_loop_visited, ~[15, 11, 7, 3]);\n \n     let mut oflo_loop_visited = ~[];\n-    for int_range_step(int::max_value-15, int::max_value, 4) |x| {\n+    do int_range_step(int::max_value-15, int::max_value, 4) |x| {\n         oflo_loop_visited.push(int::max_value - x);\n-    }\n+        true\n+    };\n     assert_eq!(oflo_loop_visited, ~[15, 11, 7, 3]);\n \n \n     // range_step never passes nor visits the stop element\n-    for int_range_step(0, 21, 3) |x| {\n+    do int_range_step(0, 21, 3) |x| {\n         assert!(x < 21);\n-    }\n+        true\n+    };\n \n     // range_step_inclusive will never pass stop element, and may skip it.\n     let mut saw21 = false;\n-    for uint::range_step_inclusive(0, 21, 4) |x| {\n+    do uint::range_step_inclusive(0, 21, 4) |x| {\n         assert!(x <= 21);\n         if x == 21 { saw21 = true; }\n-    }\n+        true\n+    };\n     assert!(!saw21);\n     let mut saw21 = false;\n-    for int::range_step_inclusive(0, 21, 4) |x| {\n+    do int::range_step_inclusive(0, 21, 4) |x| {\n         assert!(x <= 21);\n         if x == 21 { saw21 = true; }\n-    }\n+        true\n+    };\n     assert!(!saw21);\n \n     // range_step_inclusive will never pass stop element, but may visit it.\n     let mut saw21 = false;\n-    for uint::range_step_inclusive(0, 21, 3) |x| {\n+    do uint::range_step_inclusive(0, 21, 3) |x| {\n         assert!(x <= 21);\n         printfln!(\"saw: %u\", x);\n         if x == 21 { saw21 = true; }\n-    }\n+        true\n+    };\n     assert!(saw21);\n     let mut saw21 = false;\n-    for int::range_step_inclusive(0, 21, 3) |x| {\n+    do int::range_step_inclusive(0, 21, 3) |x| {\n         assert!(x <= 21);\n         if x == 21 { saw21 = true; }\n-    }\n+        true\n+    };\n     assert!(saw21);\n \n }"}, {"sha": "341c1b96e36dd6f577533a2d284282d2079bd681", "filename": "src/test/run-pass/ret-break-cont-in-block.rs", "status": "removed", "additions": 0, "deletions": 75, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/2a7be1c9e4d5a50dab4f3f95c8f1d843a7d6f084/src%2Ftest%2Frun-pass%2Fret-break-cont-in-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a7be1c9e4d5a50dab4f3f95c8f1d843a7d6f084/src%2Ftest%2Frun-pass%2Fret-break-cont-in-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fret-break-cont-in-block.rs?ref=2a7be1c9e4d5a50dab4f3f95c8f1d843a7d6f084", "patch": "@@ -1,75 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// xfail-fast\n-\n-use std::cmp::Eq;\n-use std::vec;\n-\n-fn iter<T>(v: ~[T], it: &fn(&T) -> bool) -> bool {\n-    let mut i = 0u;\n-    let mut l = v.len();\n-    while i < l {\n-        if !it(&v[i]) { return false; }\n-        i += 1u;\n-    }\n-    return true;\n-}\n-\n-fn find_pos<T:Eq + Clone>(n: T, h: ~[T]) -> Option<uint> {\n-    let mut i = 0u;\n-    for iter(h.clone()) |e| {\n-        if *e == n { return Some(i); }\n-        i += 1u;\n-    }\n-    None\n-}\n-\n-fn bail_deep(x: ~[~[bool]]) {\n-    let mut seen = false;\n-    for iter(x.clone()) |x| {\n-        for iter(x.clone()) |x| {\n-            assert!(!seen);\n-            if *x { seen = true; return; }\n-        }\n-    }\n-    assert!(!seen);\n-}\n-\n-fn ret_deep() -> ~str {\n-    for iter(~[1, 2]) |e| {\n-        for iter(~[3, 4]) |x| {\n-            if *e + *x > 4 { return ~\"hi\"; }\n-        }\n-    }\n-    return ~\"bye\";\n-}\n-\n-pub fn main() {\n-    let mut last = 0;\n-    let v = ~[1, 2, 3, 4, 5, 6, 7];\n-    for v.iter().all |e| {\n-        last = *e;\n-        if *e == 5 { break; }\n-        if *e % 2 == 1 { loop; }\n-        assert_eq!(*e % 2, 0);\n-    };\n-    assert_eq!(last, 5);\n-\n-    assert_eq!(find_pos(1, ~[0, 1, 2, 3]), Some(1u));\n-    assert_eq!(find_pos(1, ~[0, 4, 2, 3]), None);\n-    assert_eq!(find_pos(~\"hi\", ~[~\"foo\", ~\"bar\", ~\"baz\", ~\"hi\"]), Some(3u));\n-\n-    bail_deep(~[~[false, false], ~[true, true], ~[false, true]]);\n-    bail_deep(~[~[true]]);\n-    bail_deep(~[~[false, false, false]]);\n-\n-    assert_eq!(ret_deep(), ~\"hi\");\n-}"}]}