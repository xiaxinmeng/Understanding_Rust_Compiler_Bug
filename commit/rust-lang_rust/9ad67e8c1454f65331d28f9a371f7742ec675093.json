{"sha": "9ad67e8c1454f65331d28f9a371f7742ec675093", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhZDY3ZThjMTQ1NGY2NTMzMWQyOGY5YTM3MWY3NzQyZWM2NzUwOTM=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2012-03-27T05:51:18Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-04-06T22:35:48Z"}, "message": "test_uv_tcp_request() fully working on linux\n\n.. up next: windows!\n.. impl'd uv::direct::read_stop() and uv::direct::close() to wrap things up\n.. demonstrated sending data out of the uv_read_cb via a channel (which\nwe block on to recv all of it, complete w/ EOF notification) that is\nread from after the loop exits.\n.. helpers to read the guts of a uv_buf_t\n.. an idea im kicking around: starting to pile up all of these hideous\ndata accessor functions in uv::direct .. I might make impl/iface pairs\nfor the various uv_* types that I'm using, in order to encapsulate those\ndata access functions and, perhaps, make the access look a little cleaner\n(it still won't be straight field access, but it'll be a lot better)\n.. formatting cleanup to satisfy make check", "tree": {"sha": "b7245a263746b4ffb9a5f67390e35051a02567d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b7245a263746b4ffb9a5f67390e35051a02567d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9ad67e8c1454f65331d28f9a371f7742ec675093", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9ad67e8c1454f65331d28f9a371f7742ec675093", "html_url": "https://github.com/rust-lang/rust/commit/9ad67e8c1454f65331d28f9a371f7742ec675093", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9ad67e8c1454f65331d28f9a371f7742ec675093/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "877747d0acd53a7ec271d97d6620347cda0430c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/877747d0acd53a7ec271d97d6620347cda0430c6", "html_url": "https://github.com/rust-lang/rust/commit/877747d0acd53a7ec271d97d6620347cda0430c6"}], "stats": {"total": 89, "additions": 70, "deletions": 19}, "files": [{"sha": "1539fbb392b95816b66734fe3644e4cde3bbd3ee", "filename": "src/libstd/uv.rs", "status": "modified", "additions": 65, "deletions": 19, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/9ad67e8c1454f65331d28f9a371f7742ec675093/src%2Flibstd%2Fuv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ad67e8c1454f65331d28f9a371f7742ec675093/src%2Flibstd%2Fuv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv.rs?ref=9ad67e8c1454f65331d28f9a371f7742ec675093", "patch": "@@ -82,7 +82,7 @@ type uv_handle_fields = {\n    loop_handle: *libc::c_void,\n    type_: handle_type,\n    close_cb: *u8,\n-   mutable data: *libc::c_void,\n+   mut data: *libc::c_void,\n };\n \n // unix size: 8\n@@ -124,7 +124,7 @@ type uv_tcp_t = {\n fn gen_stub_uv_tcp_t() -> uv_tcp_t {\n     ret { fields: { loop_handle: ptr::null(), type_: 0u32,\n                     close_cb: ptr::null(),\n-                    mutable data: ptr::null() },\n+                    mut data: ptr::null() },\n         a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8, a03: 0 as *u8,\n         a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8, a07: 0 as *u8,\n         a08: 0 as *u8, a09: 0 as *u8, a10: 0 as *u8, a11: 0 as *u8,\n@@ -157,13 +157,13 @@ type uv_connect_t = {\n #[cfg(target_os = \"macos\")]\n #[cfg(target_os = \"freebsd\")]\n fn gen_stub_uv_connect_t() -> uv_connect_t {\n-    ret { \n+    ret {\n         a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8, a03: 0 as *u8,\n         a04: 0 as *u8, a05: 0 as *u8\n     };\n }\n \n-// ref #1402 .. don't use this, like sockaddr_in \n+// ref #1402 .. don't use this, like sockaddr_in\n // unix size: 16\n #[cfg(target_os = \"linux\")]\n #[cfg(target_os = \"macos\")]\n@@ -201,7 +201,7 @@ type uv_write_t = {\n fn gen_stub_uv_write_t() -> uv_write_t {\n     ret { fields: { loop_handle: ptr::null(), type_: 0u32,\n                     close_cb: ptr::null(),\n-                    mutable data: ptr::null() },\n+                    mut data: ptr::null() },\n         a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8, a03: 0 as *u8,\n         a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8, a07: 0 as *u8,\n         a08: 0 as *u8, a09: 0 as *u8, a10: 0 as *u8, a11: 0 as *u8,\n@@ -287,6 +287,7 @@ native mod rustrt {\n              cb: *u8) -> libc::c_int;\n     fn rust_uv_read_start(stream: *libc::c_void, on_alloc: *u8,\n                           on_read: *u8) -> libc::c_int;\n+    fn rust_uv_read_stop(stream: *libc::c_void) -> libc::c_int;\n     fn rust_uv_malloc_buf_base_of(sug_size: libc::size_t) -> *u8;\n     fn rust_uv_free_base_of_buf(++buf: uv_buf_t);\n \n@@ -314,6 +315,8 @@ native mod rustrt {\n     fn rust_uv_get_data_for_req(req: *libc::c_void) -> *libc::c_void;\n     fn rust_uv_set_data_for_req(req: *libc::c_void,\n                                 data: *libc::c_void);\n+    fn rust_uv_get_base_from_buf(++buf: uv_buf_t) -> *u8;\n+    fn rust_uv_get_len_from_buf(++buf: uv_buf_t) -> libc::size_t;\n }\n \n // this module is structured around functions that directly\n@@ -332,6 +335,10 @@ mod direct {\n         rustrt::rust_uv_run(loop_handle);\n     }\n \n+    unsafe fn close(handle: *libc::c_void, cb: *u8) {\n+        rustrt::rust_uv_close(handle, cb);\n+    }\n+\n     unsafe fn tcp_init(loop_handle: *libc::c_void, handle: *uv_tcp_t)\n         -> libc::c_int {\n         ret rustrt::rust_uv_tcp_init(loop_handle, handle);\n@@ -341,7 +348,8 @@ mod direct {\n                           address: sockaddr_in,\n                           after_connect_cb: *u8)\n     -> libc::c_int {\n-        io::println(#fmt(\"before native tcp_connect -- addr port: %u\", address.sin_port as uint));\n+        io::println(#fmt(\"b4 native tcp_connect--addr port: %u\",\n+                         address.sin_port as uint));\n         ret rustrt::rust_uv_tcp_connect(connect_ptr, tcp_handle_ptr,\n                                     address, after_connect_cb);\n     }\n@@ -361,6 +369,10 @@ mod direct {\n                                        on_alloc, on_read);\n     }\n \n+    unsafe fn read_stop(stream: *uv_stream_t) -> libc::c_int {\n+        ret rustrt::rust_uv_read_stop(stream as *libc::c_void);\n+    }\n+\n     unsafe fn uv_last_error(loop_handle: *libc::c_void) -> uv_err_t {\n         ret rustrt::rust_uv_last_error(loop_handle);\n     }\n@@ -391,14 +403,26 @@ mod direct {\n             write_req);\n     }\n \n+    unsafe fn get_data_for_uv_handle(handle: *libc::c_void) -> *libc::c_void {\n+        ret rustrt::rust_uv_get_data_for_uv_handle(handle);\n+    }\n+    unsafe fn set_data_for_uv_handle(handle: *libc::c_void,\n+                        data: *libc::c_void) {\n+        rustrt::rust_uv_set_data_for_uv_handle(handle, data);\n+    }\n     unsafe fn get_data_for_req(req: *libc::c_void) -> *libc::c_void {\n         ret rustrt::rust_uv_get_data_for_req(req);\n     }\n     unsafe fn set_data_for_req(req: *libc::c_void,\n                         data: *libc::c_void) {\n         rustrt::rust_uv_set_data_for_req(req, data);\n     }\n-    // TODO: see github issue #1402\n+    unsafe fn get_base_from_buf(buf: uv_buf_t) -> *u8 {\n+        ret rustrt::rust_uv_get_base_from_buf(buf);\n+    }\n+    unsafe fn get_len_from_buf(buf: uv_buf_t) -> libc::size_t {\n+        ret rustrt::rust_uv_get_len_from_buf(buf);\n+    }\n     unsafe fn buf_init(input: *u8, len: uint) -> uv_buf_t {\n         ret rustrt::rust_uv_buf_init(input, len);\n     }\n@@ -408,7 +432,8 @@ mod direct {\n         addr_vec += [0u8]; // add null terminator\n         let addr_vec_ptr = vec::unsafe::to_ptr(addr_vec);\n         let ip_back = str::from_bytes(addr_vec);\n-        io::println(#fmt(\"vec val: '%s' length: %u\",ip_back, vec::len(addr_vec)));\n+        io::println(#fmt(\"vec val: '%s' length: %u\",\n+                         ip_back, vec::len(addr_vec)));\n         ret rustrt::rust_uv_ip4_addr(addr_vec_ptr,\n                                      port as libc::c_int);\n     }\n@@ -982,6 +1007,10 @@ type request_wrapper = {\n     read_chan: comm::chan<tcp_read_data>\n };\n \n+crust fn after_close_cb(handle: *libc::c_void) {\n+    io::println(\"after uv_close!\");\n+}\n+\n crust fn on_alloc_cb(handle: *libc::c_void,\n                      suggested_size: libc::size_t) -> uv_buf_t\n     unsafe {\n@@ -990,12 +1019,22 @@ crust fn on_alloc_cb(handle: *libc::c_void,\n     ret direct::buf_init(char_ptr, suggested_size);\n }\n \n-// do I need the explicit copy on the buf param?\n crust fn on_read_cb(stream: *uv_stream_t, nread: libc::ssize_t,\n                     ++buf: uv_buf_t) unsafe {\n     if (nread > 0) {\n         // we have data\n         io::println(#fmt(\"read: data! nread: %d\", nread));\n+        direct::read_stop(stream);\n+        let client_data = direct::\n+            get_data_for_uv_handle(stream as *libc::c_void)\n+              as *request_wrapper;\n+        let buf_base = direct::get_base_from_buf(buf);\n+        let buf_len = direct::get_len_from_buf(buf);\n+        let bytes = vec::unsafe::from_buf(buf_base, buf_len);\n+        let read_chan = (*client_data).read_chan;\n+        comm::send(read_chan, tcp_read_more(bytes));\n+        comm::send(read_chan, tcp_read_eof);\n+        direct::close(stream as *libc::c_void, after_close_cb)\n     }\n     else if (nread == -1) {\n         // err .. possibly EOF\n@@ -1015,10 +1054,11 @@ crust fn on_write_complete_cb(write_req: *uv_write_t,\n     io::println(#fmt(\"beginning on_write_complete_cb status: %d\",\n                      status as int));\n     let stream = direct::get_stream_handle_from_write_req(write_req);\n-    io::println(#fmt(\"on_write_complete_cb: tcp stream: %d write_handle addr %d\",\n+    io::println(#fmt(\"on_write_complete_cb: tcp:%d write_handle:%d\",\n         stream as int, write_req as int));\n     let result = direct::read_start(stream, on_alloc_cb, on_read_cb);\n-    io::println(#fmt(\"ending on_write_complete_cb .. uv_read_start status: %d\", result as int));\n+    io::println(#fmt(\"ending on_write_complete_cb .. status: %d\",\n+                     result as int));\n }\n \n crust fn on_connect_cb(connect_req_ptr: *uv_connect_t,\n@@ -1078,19 +1118,19 @@ fn impl_uv_tcp_request() unsafe {\n     let client_data = { writer_handle: write_handle_ptr,\n                 req_buf: ptr::addr_of(req_msg),\n                 read_chan: read_chan };\n-    \n+\n     let tcp_init_result = direct::tcp_init(\n         test_loop as *libc::c_void, tcp_handle_ptr);\n     if (tcp_init_result == 0i32) {\n         io::println(\"sucessful tcp_init_result\");\n-        \n+\n         io::println(\"building addr...\");\n         let addr = direct::ip4_addr(\"173.194.33.40\", 80);\n         io::println(#fmt(\"after build addr in rust. port: %u\",\n                          addr.sin_port as uint));\n         //let addr: *libc::c_void = ptr::addr_of(addr_val) as\n         //                            *libc::c_void;\n-        \n+\n         // this should set up the connection request..\n         let tcp_connect_result = direct::tcp_connect(\n             connect_req_ptr, tcp_handle_ptr,\n@@ -1101,6 +1141,9 @@ fn impl_uv_tcp_request() unsafe {\n             direct::set_data_for_req(\n                 connect_req_ptr as *libc::c_void,\n                 ptr::addr_of(client_data) as *libc::c_void);\n+            direct::set_data_for_uv_handle(\n+                tcp_handle_ptr as *libc::c_void,\n+                ptr::addr_of(client_data) as *libc::c_void);\n             io::println(\"before run tcp req loop\");\n             direct::run(test_loop);\n             io::println(\"after run tcp req loop\");\n@@ -1120,21 +1163,24 @@ fn impl_uv_tcp_request() unsafe {\n                         // the stubbed out vec above\n                         // with our initial set of read\n                         // data\n+                        read_bytes = new_bytes;\n                     }\n                     else {\n                         // otherwise append\n-                        read_bytes = new_bytes;\n+                        read_bytes += new_bytes;\n                     }\n                   }\n                   _ {\n                     assert false;\n                   }\n                 }\n             }\n-            io::println(\"finished reading data\");\n+            io::println(\"finished reading data, output to follow:\");\n             let read_str = str::from_bytes(read_bytes);\n-                \n-                \n+\n+            io::println(read_str);\n+            io::println(\">>>>EOF<<<<\");\n+            direct::loop_delete(test_loop);\n         }\n         else {\n            io::println(\"direct::tcp_connect() failure\");\n@@ -1145,7 +1191,7 @@ fn impl_uv_tcp_request() unsafe {\n         io::println(\"direct::tcp_init() failure\");\n         assert false;\n     }\n-    \n+\n }\n // START HERE AND WORK YOUR WAY UP VIA CALLBACKS\n #[test]"}, {"sha": "90832f7c3cdf25a12343817fc8b88aa4d7becd03", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9ad67e8c1454f65331d28f9a371f7742ec675093/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/9ad67e8c1454f65331d28f9a371f7742ec675093/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=9ad67e8c1454f65331d28f9a371f7742ec675093", "patch": "@@ -322,6 +322,11 @@ rust_uv_read_start(uv_stream_t* stream, uv_alloc_cb on_alloc,\n     return uv_read_start(stream, on_alloc, on_read);\n }\n \n+extern \"C\" int\n+rust_uv_read_stop(uv_stream_t* stream) {\n+  return uv_read_stop(stream);\n+}\n+\n extern \"C\" char*\n rust_uv_malloc_buf_base_of(size_t suggested_size) {\n \treturn (char*) current_kernel_malloc(sizeof(char)*suggested_size,"}]}