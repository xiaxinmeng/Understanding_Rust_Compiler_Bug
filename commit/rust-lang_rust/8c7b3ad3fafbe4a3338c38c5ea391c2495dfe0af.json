{"sha": "8c7b3ad3fafbe4a3338c38c5ea391c2495dfe0af", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjN2IzYWQzZmFmYmU0YTMzMzhjMzhjNWVhMzkxYzI0OTVkZmUwYWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-04T13:30:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-04T13:30:08Z"}, "message": "Auto merge of #5266 - sinkuu:questionmark, r=flip1995\n\nLint `if let Some` and early return in question_mark lint\n\nFixes #5260\n\nchangelog: lint `if let Some` and early return in `question_mark` lint", "tree": {"sha": "44140e61a92d4e31fd6a1c95ee26a11cda0d10cc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/44140e61a92d4e31fd6a1c95ee26a11cda0d10cc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c7b3ad3fafbe4a3338c38c5ea391c2495dfe0af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c7b3ad3fafbe4a3338c38c5ea391c2495dfe0af", "html_url": "https://github.com/rust-lang/rust/commit/8c7b3ad3fafbe4a3338c38c5ea391c2495dfe0af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c7b3ad3fafbe4a3338c38c5ea391c2495dfe0af/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "36b65986afbc9f41535b1a08c8fb9454ce5bf48c", "url": "https://api.github.com/repos/rust-lang/rust/commits/36b65986afbc9f41535b1a08c8fb9454ce5bf48c", "html_url": "https://github.com/rust-lang/rust/commit/36b65986afbc9f41535b1a08c8fb9454ce5bf48c"}, {"sha": "a78a1fc97bfa78eba0d276add37aad543e0e610d", "url": "https://api.github.com/repos/rust-lang/rust/commits/a78a1fc97bfa78eba0d276add37aad543e0e610d", "html_url": "https://github.com/rust-lang/rust/commit/a78a1fc97bfa78eba0d276add37aad543e0e610d"}], "stats": {"total": 277, "additions": 244, "deletions": 33}, "files": [{"sha": "f054c6ef67d34d9ccb066552ec27f7f5f3c6073a", "filename": "clippy_lints/src/question_mark.rs", "status": "modified", "additions": 52, "deletions": 12, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/8c7b3ad3fafbe4a3338c38c5ea391c2495dfe0af/clippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c7b3ad3fafbe4a3338c38c5ea391c2495dfe0af/clippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fquestion_mark.rs?ref=8c7b3ad3fafbe4a3338c38c5ea391c2495dfe0af", "patch": "@@ -1,13 +1,15 @@\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::{def, Block, Expr, ExprKind, StmtKind};\n+use rustc_hir::{def, BindingAnnotation, Block, Expr, ExprKind, MatchSource, PatKind, StmtKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n use crate::utils::paths::{OPTION, OPTION_NONE};\n use crate::utils::sugg::Sugg;\n-use crate::utils::{higher, match_def_path, match_type, span_lint_and_then, SpanlessEq};\n+use crate::utils::{\n+    higher, match_def_path, match_qpath, match_type, snippet_with_applicability, span_lint_and_sugg, SpanlessEq,\n+};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for expressions that could be replaced by the question mark operator.\n@@ -55,7 +57,8 @@ impl QuestionMark {\n             if Self::is_option(cx, subject);\n \n             then {\n-                let receiver_str = &Sugg::hir(cx, subject, \"..\");\n+                let mut applicability = Applicability::MachineApplicable;\n+                let receiver_str = &Sugg::hir_with_applicability(cx, subject, \"..\", &mut applicability);\n                 let mut replacement: Option<String> = None;\n                 if let Some(else_) = else_ {\n                     if_chain! {\n@@ -74,25 +77,61 @@ impl QuestionMark {\n                 }\n \n                 if let Some(replacement_str) = replacement {\n-                    span_lint_and_then(\n+                    span_lint_and_sugg(\n                         cx,\n                         QUESTION_MARK,\n                         expr.span,\n                         \"this block may be rewritten with the `?` operator\",\n-                        |db| {\n-                            db.span_suggestion(\n-                                expr.span,\n-                                \"replace_it_with\",\n-                                replacement_str,\n-                                Applicability::MaybeIncorrect, // snippet\n-                            );\n-                        }\n+                        \"replace it with\",\n+                        replacement_str,\n+                        applicability,\n                     )\n                }\n             }\n         }\n     }\n \n+    fn check_if_let_some_and_early_return_none(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n+        if_chain! {\n+            if let ExprKind::Match(subject, arms, source) = &expr.kind;\n+            if *source == MatchSource::IfLetDesugar { contains_else_clause: true };\n+            if Self::is_option(cx, subject);\n+\n+            if let PatKind::TupleStruct(path1, fields, None) = &arms[0].pat.kind;\n+            if match_qpath(path1, &[\"Some\"]);\n+            if let PatKind::Binding(annot, _, bind, _) = &fields[0].kind;\n+            let by_ref = matches!(annot, BindingAnnotation::Ref | BindingAnnotation::RefMut);\n+\n+            if let ExprKind::Block(block, None) = &arms[0].body.kind;\n+            if block.stmts.is_empty();\n+            if let Some(trailing_expr) = &block.expr;\n+            if let ExprKind::Path(path) = &trailing_expr.kind;\n+            if match_qpath(path, &[&bind.as_str()]);\n+\n+            if let PatKind::Wild = arms[1].pat.kind;\n+            if Self::expression_returns_none(cx, arms[1].body);\n+            then {\n+                let mut applicability = Applicability::MachineApplicable;\n+                let receiver_str = snippet_with_applicability(cx, subject.span, \"..\", &mut applicability);\n+                let replacement = format!(\n+                    \"{}{}?\",\n+                    receiver_str,\n+                    if by_ref { \".as_ref()\" } else { \"\" },\n+                );\n+\n+                span_lint_and_sugg(\n+                    cx,\n+                    QUESTION_MARK,\n+                    expr.span,\n+                    \"this if-let-else may be rewritten with the `?` operator\",\n+                    \"replace it with\",\n+                    replacement,\n+                    applicability,\n+                )\n+            }\n+        }\n+    }\n+\n     fn moves_by_default(cx: &LateContext<'_, '_>, expression: &Expr<'_>) -> bool {\n         let expr_ty = cx.tables.expr_ty(expression);\n \n@@ -158,5 +197,6 @@ impl QuestionMark {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for QuestionMark {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n         Self::check_is_none_and_early_return_none(cx, expr);\n+        Self::check_if_let_some_and_early_return_none(cx, expr);\n     }\n }"}, {"sha": "58a909c845d6a056ee052878f51e0c99f17a4501", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8c7b3ad3fafbe4a3338c38c5ea391c2495dfe0af/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c7b3ad3fafbe4a3338c38c5ea391c2495dfe0af/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=8c7b3ad3fafbe4a3338c38c5ea391c2495dfe0af", "patch": "@@ -1698,12 +1698,7 @@ fn detect_absurd_comparison<'a, 'tcx>(\n         return None;\n     }\n \n-    let normalized = normalize_comparison(op, lhs, rhs);\n-    let (rel, normalized_lhs, normalized_rhs) = if let Some(val) = normalized {\n-        val\n-    } else {\n-        return None;\n-    };\n+    let (rel, normalized_lhs, normalized_rhs) = normalize_comparison(op, lhs, rhs)?;\n \n     let lx = detect_extreme_expr(cx, normalized_lhs);\n     let rx = detect_extreme_expr(cx, normalized_rhs);"}, {"sha": "2c3e4989d5340c61b9ba2af03eed73fa0aa2a5ab", "filename": "tests/ui/question_mark.fixed", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/8c7b3ad3fafbe4a3338c38c5ea391c2495dfe0af/tests%2Fui%2Fquestion_mark.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/8c7b3ad3fafbe4a3338c38c5ea391c2495dfe0af/tests%2Fui%2Fquestion_mark.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fquestion_mark.fixed?ref=8c7b3ad3fafbe4a3338c38c5ea391c2495dfe0af", "patch": "@@ -0,0 +1,113 @@\n+// run-rustfix\n+#![allow(unreachable_code)]\n+\n+fn some_func(a: Option<u32>) -> Option<u32> {\n+    a?;\n+\n+    a\n+}\n+\n+fn some_other_func(a: Option<u32>) -> Option<u32> {\n+    if a.is_none() {\n+        return None;\n+    } else {\n+        return Some(0);\n+    }\n+    unreachable!()\n+}\n+\n+pub enum SeemsOption<T> {\n+    Some(T),\n+    None,\n+}\n+\n+impl<T> SeemsOption<T> {\n+    pub fn is_none(&self) -> bool {\n+        match *self {\n+            SeemsOption::None => true,\n+            SeemsOption::Some(_) => false,\n+        }\n+    }\n+}\n+\n+fn returns_something_similar_to_option(a: SeemsOption<u32>) -> SeemsOption<u32> {\n+    if a.is_none() {\n+        return SeemsOption::None;\n+    }\n+\n+    a\n+}\n+\n+pub struct CopyStruct {\n+    pub opt: Option<u32>,\n+}\n+\n+impl CopyStruct {\n+    #[rustfmt::skip]\n+    pub fn func(&self) -> Option<u32> {\n+        (self.opt)?;\n+\n+        self.opt?;\n+\n+        let _ = Some(self.opt?);\n+\n+        let _ = self.opt?;\n+\n+        self.opt\n+    }\n+}\n+\n+#[derive(Clone)]\n+pub struct MoveStruct {\n+    pub opt: Option<Vec<u32>>,\n+}\n+\n+impl MoveStruct {\n+    pub fn ref_func(&self) -> Option<Vec<u32>> {\n+        self.opt.as_ref()?;\n+\n+        self.opt.clone()\n+    }\n+\n+    pub fn mov_func_reuse(self) -> Option<Vec<u32>> {\n+        self.opt.as_ref()?;\n+\n+        self.opt\n+    }\n+\n+    pub fn mov_func_no_use(self) -> Option<Vec<u32>> {\n+        self.opt.as_ref()?;\n+        Some(Vec::new())\n+    }\n+\n+    pub fn if_let_ref_func(self) -> Option<Vec<u32>> {\n+        let v: &Vec<_> = self.opt.as_ref()?;\n+\n+        Some(v.clone())\n+    }\n+\n+    pub fn if_let_mov_func(self) -> Option<Vec<u32>> {\n+        let v = self.opt?;\n+\n+        Some(v)\n+    }\n+}\n+\n+fn main() {\n+    some_func(Some(42));\n+    some_func(None);\n+    some_other_func(Some(42));\n+\n+    let copy_struct = CopyStruct { opt: Some(54) };\n+    copy_struct.func();\n+\n+    let move_struct = MoveStruct {\n+        opt: Some(vec![42, 1337]),\n+    };\n+    move_struct.ref_func();\n+    move_struct.clone().mov_func_reuse();\n+    move_struct.mov_func_no_use();\n+\n+    let so = SeemsOption::Some(45);\n+    returns_something_similar_to_option(so);\n+}"}, {"sha": "24df763443565ec0d39407f73cc919d9d080edde", "filename": "tests/ui/question_mark.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8c7b3ad3fafbe4a3338c38c5ea391c2495dfe0af/tests%2Fui%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c7b3ad3fafbe4a3338c38c5ea391c2495dfe0af/tests%2Fui%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fquestion_mark.rs?ref=8c7b3ad3fafbe4a3338c38c5ea391c2495dfe0af", "patch": "@@ -1,3 +1,6 @@\n+// run-rustfix\n+#![allow(unreachable_code)]\n+\n fn some_func(a: Option<u32>) -> Option<u32> {\n     if a.is_none() {\n         return None;\n@@ -58,6 +61,12 @@ impl CopyStruct {\n             self.opt\n         };\n \n+        let _ = if let Some(x) = self.opt {\n+            x\n+        } else {\n+            return None;\n+        };\n+\n         self.opt\n     }\n }\n@@ -90,11 +99,32 @@ impl MoveStruct {\n         }\n         Some(Vec::new())\n     }\n+\n+    pub fn if_let_ref_func(self) -> Option<Vec<u32>> {\n+        let v: &Vec<_> = if let Some(ref v) = self.opt {\n+            v\n+        } else {\n+            return None;\n+        };\n+\n+        Some(v.clone())\n+    }\n+\n+    pub fn if_let_mov_func(self) -> Option<Vec<u32>> {\n+        let v = if let Some(v) = self.opt {\n+            v\n+        } else {\n+            return None;\n+        };\n+\n+        Some(v)\n+    }\n }\n \n fn main() {\n     some_func(Some(42));\n     some_func(None);\n+    some_other_func(Some(42));\n \n     let copy_struct = CopyStruct { opt: Some(54) };\n     copy_struct.func();"}, {"sha": "97741069b50a85252e08f0679e63b779d39c4c98", "filename": "tests/ui/question_mark.stderr", "status": "modified", "additions": 48, "deletions": 15, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/8c7b3ad3fafbe4a3338c38c5ea391c2495dfe0af/tests%2Fui%2Fquestion_mark.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c7b3ad3fafbe4a3338c38c5ea391c2495dfe0af/tests%2Fui%2Fquestion_mark.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fquestion_mark.stderr?ref=8c7b3ad3fafbe4a3338c38c5ea391c2495dfe0af", "patch": "@@ -1,63 +1,96 @@\n error: this block may be rewritten with the `?` operator\n-  --> $DIR/question_mark.rs:2:5\n+  --> $DIR/question_mark.rs:5:5\n    |\n LL | /     if a.is_none() {\n LL | |         return None;\n LL | |     }\n-   | |_____^ help: replace_it_with: `a?;`\n+   | |_____^ help: replace it with: `a?;`\n    |\n    = note: `-D clippy::question-mark` implied by `-D warnings`\n \n error: this block may be rewritten with the `?` operator\n-  --> $DIR/question_mark.rs:47:9\n+  --> $DIR/question_mark.rs:50:9\n    |\n LL | /         if (self.opt).is_none() {\n LL | |             return None;\n LL | |         }\n-   | |_________^ help: replace_it_with: `(self.opt)?;`\n+   | |_________^ help: replace it with: `(self.opt)?;`\n \n error: this block may be rewritten with the `?` operator\n-  --> $DIR/question_mark.rs:51:9\n+  --> $DIR/question_mark.rs:54:9\n    |\n LL | /         if self.opt.is_none() {\n LL | |             return None\n LL | |         }\n-   | |_________^ help: replace_it_with: `self.opt?;`\n+   | |_________^ help: replace it with: `self.opt?;`\n \n error: this block may be rewritten with the `?` operator\n-  --> $DIR/question_mark.rs:55:17\n+  --> $DIR/question_mark.rs:58:17\n    |\n LL |           let _ = if self.opt.is_none() {\n    |  _________________^\n LL | |             return None;\n LL | |         } else {\n LL | |             self.opt\n LL | |         };\n-   | |_________^ help: replace_it_with: `Some(self.opt?)`\n+   | |_________^ help: replace it with: `Some(self.opt?)`\n+\n+error: this if-let-else may be rewritten with the `?` operator\n+  --> $DIR/question_mark.rs:64:17\n+   |\n+LL |           let _ = if let Some(x) = self.opt {\n+   |  _________________^\n+LL | |             x\n+LL | |         } else {\n+LL | |             return None;\n+LL | |         };\n+   | |_________^ help: replace it with: `self.opt?`\n \n error: this block may be rewritten with the `?` operator\n-  --> $DIR/question_mark.rs:72:9\n+  --> $DIR/question_mark.rs:81:9\n    |\n LL | /         if self.opt.is_none() {\n LL | |             return None;\n LL | |         }\n-   | |_________^ help: replace_it_with: `self.opt.as_ref()?;`\n+   | |_________^ help: replace it with: `self.opt.as_ref()?;`\n \n error: this block may be rewritten with the `?` operator\n-  --> $DIR/question_mark.rs:80:9\n+  --> $DIR/question_mark.rs:89:9\n    |\n LL | /         if self.opt.is_none() {\n LL | |             return None;\n LL | |         }\n-   | |_________^ help: replace_it_with: `self.opt.as_ref()?;`\n+   | |_________^ help: replace it with: `self.opt.as_ref()?;`\n \n error: this block may be rewritten with the `?` operator\n-  --> $DIR/question_mark.rs:88:9\n+  --> $DIR/question_mark.rs:97:9\n    |\n LL | /         if self.opt.is_none() {\n LL | |             return None;\n LL | |         }\n-   | |_________^ help: replace_it_with: `self.opt.as_ref()?;`\n+   | |_________^ help: replace it with: `self.opt.as_ref()?;`\n+\n+error: this if-let-else may be rewritten with the `?` operator\n+  --> $DIR/question_mark.rs:104:26\n+   |\n+LL |           let v: &Vec<_> = if let Some(ref v) = self.opt {\n+   |  __________________________^\n+LL | |             v\n+LL | |         } else {\n+LL | |             return None;\n+LL | |         };\n+   | |_________^ help: replace it with: `self.opt.as_ref()?`\n+\n+error: this if-let-else may be rewritten with the `?` operator\n+  --> $DIR/question_mark.rs:114:17\n+   |\n+LL |           let v = if let Some(v) = self.opt {\n+   |  _________________^\n+LL | |             v\n+LL | |         } else {\n+LL | |             return None;\n+LL | |         };\n+   | |_________^ help: replace it with: `self.opt?`\n \n-error: aborting due to 7 previous errors\n+error: aborting due to 10 previous errors\n "}]}