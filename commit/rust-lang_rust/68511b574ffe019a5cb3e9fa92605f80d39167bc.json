{"sha": "68511b574ffe019a5cb3e9fa92605f80d39167bc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4NTExYjU3NGZmZTAxOWE1Y2IzZTlmYTkyNjA1ZjgwZDM5MTY3YmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-17T17:56:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-17T17:56:46Z"}, "message": "Auto merge of #86676 - cjgillot:localexpn, r=petrochenkov\n\nMake expansions stable for incr. comp.\n\nThis PR aims to make expansions stable for incr. comp. by using the same architecture as definitions:\n- the interned identifier `ExpnId` contains a `CrateNum` and a crate-local id;\n- bidirectional maps `ExpnHash <-> ExpnId` are setup;\n- incr. comp. on-disk cache saves and reconstructs expansions using their `ExpnHash`.\n\nI tried to use as many `LocalExpnId` as I could in the resolver code, but I may have missed a few opportunities.\n\nAll this will allow to use an `ExpnId` as a query key, and to force this query without recomputing caller queries. For instance, this will be used to implement #85999.\n\nr? `@petrochenkov`", "tree": {"sha": "67a8c2f57159f448ed38ee933cf56dde3f2e75ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/67a8c2f57159f448ed38ee933cf56dde3f2e75ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68511b574ffe019a5cb3e9fa92605f80d39167bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68511b574ffe019a5cb3e9fa92605f80d39167bc", "html_url": "https://github.com/rust-lang/rust/commit/68511b574ffe019a5cb3e9fa92605f80d39167bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68511b574ffe019a5cb3e9fa92605f80d39167bc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "html_url": "https://github.com/rust-lang/rust/commit/c78ebb7bdcfc924a20fd069891ffe1364d6814e7"}, {"sha": "b35ceeeec706e957ee46166e0a8b6d912ac215a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/b35ceeeec706e957ee46166e0a8b6d912ac215a3", "html_url": "https://github.com/rust-lang/rust/commit/b35ceeeec706e957ee46166e0a8b6d912ac215a3"}], "stats": {"total": 1051, "additions": 615, "deletions": 436}, "files": [{"sha": "7f928cb5761808ff3079bdbfe999ee5ed18ff1a2", "filename": "compiler/rustc_ast/src/node_id.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/68511b574ffe019a5cb3e9fa92605f80d39167bc/compiler%2Frustc_ast%2Fsrc%2Fnode_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68511b574ffe019a5cb3e9fa92605f80d39167bc/compiler%2Frustc_ast%2Fsrc%2Fnode_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fnode_id.rs?ref=68511b574ffe019a5cb3e9fa92605f80d39167bc", "patch": "@@ -1,4 +1,4 @@\n-use rustc_span::ExpnId;\n+use rustc_span::LocalExpnId;\n use std::fmt;\n \n rustc_index::newtype_index! {\n@@ -24,12 +24,12 @@ pub const CRATE_NODE_ID: NodeId = NodeId::from_u32(0);\n pub const DUMMY_NODE_ID: NodeId = NodeId::MAX;\n \n impl NodeId {\n-    pub fn placeholder_from_expn_id(expn_id: ExpnId) -> Self {\n+    pub fn placeholder_from_expn_id(expn_id: LocalExpnId) -> Self {\n         NodeId::from_u32(expn_id.as_u32())\n     }\n \n-    pub fn placeholder_to_expn_id(self) -> ExpnId {\n-        ExpnId::from_u32(self.as_u32())\n+    pub fn placeholder_to_expn_id(self) -> LocalExpnId {\n+        LocalExpnId::from_u32(self.as_u32())\n     }\n }\n "}, {"sha": "90cdd62144d7246d5f5b5226786ea5865113b599", "filename": "compiler/rustc_builtin_macros/src/deriving/clone.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/68511b574ffe019a5cb3e9fa92605f80d39167bc/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68511b574ffe019a5cb3e9fa92605f80d39167bc/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs?ref=68511b574ffe019a5cb3e9fa92605f80d39167bc", "patch": "@@ -36,8 +36,9 @@ pub fn expand_deriving_clone(\n         Annotatable::Item(ref annitem) => match annitem.kind {\n             ItemKind::Struct(_, Generics { ref params, .. })\n             | ItemKind::Enum(_, Generics { ref params, .. }) => {\n-                let container_id = cx.current_expansion.id.expn_data().parent;\n-                if cx.resolver.has_derive_copy(container_id)\n+                let container_id = cx.current_expansion.id.expn_data().parent.expect_local();\n+                let has_derive_copy = cx.resolver.has_derive_copy(container_id);\n+                if has_derive_copy\n                     && !params\n                         .iter()\n                         .any(|param| matches!(param.kind, ast::GenericParamKind::Type { .. }))"}, {"sha": "417dedab60d08a0771668c7b0164d90964cc912d", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68511b574ffe019a5cb3e9fa92605f80d39167bc/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68511b574ffe019a5cb3e9fa92605f80d39167bc/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=68511b574ffe019a5cb3e9fa92605f80d39167bc", "patch": "@@ -410,7 +410,7 @@ impl<'a> TraitDef<'a> {\n                         .any(|param| matches!(param.kind, ast::GenericParamKind::Type { .. })),\n                     _ => unreachable!(),\n                 };\n-                let container_id = cx.current_expansion.id.expn_data().parent;\n+                let container_id = cx.current_expansion.id.expn_data().parent.expect_local();\n                 let always_copy = has_no_type_params && cx.resolver.has_derive_copy(container_id);\n                 let use_temporaries = is_packed && always_copy;\n "}, {"sha": "f83329ecba8241dd0fb97dd9a1d4684ed47acd85", "filename": "compiler/rustc_builtin_macros/src/proc_macro_harness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68511b574ffe019a5cb3e9fa92605f80d39167bc/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68511b574ffe019a5cb3e9fa92605f80d39167bc/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs?ref=68511b574ffe019a5cb3e9fa92605f80d39167bc", "patch": "@@ -304,7 +304,7 @@ fn mk_decls(\n         &[sym::rustc_attrs, sym::proc_macro_internals],\n         None,\n     );\n-    let span = DUMMY_SP.with_def_site_ctxt(expn_id);\n+    let span = DUMMY_SP.with_def_site_ctxt(expn_id.to_expn_id());\n \n     let proc_macro = Ident::new(sym::proc_macro, span);\n     let krate = cx.item(span, proc_macro, Vec::new(), ast::ItemKind::ExternCrate(None));"}, {"sha": "e0d57267525d9e12980e44b076f81fd688095466", "filename": "compiler/rustc_builtin_macros/src/standard_library_imports.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68511b574ffe019a5cb3e9fa92605f80d39167bc/compiler%2Frustc_builtin_macros%2Fsrc%2Fstandard_library_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68511b574ffe019a5cb3e9fa92605f80d39167bc/compiler%2Frustc_builtin_macros%2Fsrc%2Fstandard_library_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fstandard_library_imports.rs?ref=68511b574ffe019a5cb3e9fa92605f80d39167bc", "patch": "@@ -34,8 +34,8 @@ pub fn inject(\n         &[sym::prelude_import],\n         None,\n     );\n-    let span = DUMMY_SP.with_def_site_ctxt(expn_id);\n-    let call_site = DUMMY_SP.with_call_site_ctxt(expn_id);\n+    let span = DUMMY_SP.with_def_site_ctxt(expn_id.to_expn_id());\n+    let call_site = DUMMY_SP.with_call_site_ctxt(expn_id.to_expn_id());\n \n     let ecfg = ExpansionConfig::default(\"std_lib_injection\".to_string());\n     let cx = ExtCtxt::new(sess, ecfg, resolver, None);"}, {"sha": "74a97a4058fac41dc3abef27402d7160c45f1786", "filename": "compiler/rustc_builtin_macros/src/test_harness.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/68511b574ffe019a5cb3e9fa92605f80d39167bc/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68511b574ffe019a5cb3e9fa92605f80d39167bc/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs?ref=68511b574ffe019a5cb3e9fa92605f80d39167bc", "patch": "@@ -126,7 +126,8 @@ impl<'a> MutVisitor for TestHarnessGenerator<'a> {\n                 for test in &mut tests {\n                     // See the comment on `mk_main` for why we're using\n                     // `apply_mark` directly.\n-                    test.ident.span = test.ident.span.apply_mark(expn_id, Transparency::Opaque);\n+                    test.ident.span =\n+                        test.ident.span.apply_mark(expn_id.to_expn_id(), Transparency::Opaque);\n                 }\n                 self.cx.test_cases.extend(tests);\n             }\n@@ -223,7 +224,7 @@ fn generate_test_harness(\n         &[sym::test, sym::rustc_attrs],\n         None,\n     );\n-    let def_site = DUMMY_SP.with_def_site_ctxt(expn_id);\n+    let def_site = DUMMY_SP.with_def_site_ctxt(expn_id.to_expn_id());\n \n     // Remove the entry points\n     let mut cleaner = EntryPointCleaner { sess, depth: 0, def_site };"}, {"sha": "497be2d931872e2fd2d435089b365af6bdddfb27", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/68511b574ffe019a5cb3e9fa92605f80d39167bc/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68511b574ffe019a5cb3e9fa92605f80d39167bc/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=68511b574ffe019a5cb3e9fa92605f80d39167bc", "patch": "@@ -16,7 +16,7 @@ use rustc_parse::{self, nt_to_tokenstream, parser, MACRO_ARGUMENTS};\n use rustc_session::{parse::ParseSess, Limit, Session};\n use rustc_span::def_id::{CrateNum, DefId};\n use rustc_span::edition::Edition;\n-use rustc_span::hygiene::{AstPass, ExpnData, ExpnId, ExpnKind};\n+use rustc_span::hygiene::{AstPass, ExpnData, ExpnKind, LocalExpnId};\n use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{FileName, MultiSpan, Span, DUMMY_SP};\n@@ -813,15 +813,15 @@ impl SyntaxExtension {\n \n     pub fn expn_data(\n         &self,\n-        parent: ExpnId,\n+        parent: LocalExpnId,\n         call_site: Span,\n         descr: Symbol,\n         macro_def_id: Option<DefId>,\n         parent_module: Option<DefId>,\n     ) -> ExpnData {\n         ExpnData::new(\n             ExpnKind::Macro(self.macro_kind(), descr),\n-            parent,\n+            parent.to_expn_id(),\n             call_site,\n             self.span,\n             self.allow_internal_unstable.clone(),\n@@ -843,7 +843,11 @@ pub trait ResolverExpand {\n     fn next_node_id(&mut self) -> NodeId;\n \n     fn resolve_dollar_crates(&mut self);\n-    fn visit_ast_fragment_with_placeholders(&mut self, expn_id: ExpnId, fragment: &AstFragment);\n+    fn visit_ast_fragment_with_placeholders(\n+        &mut self,\n+        expn_id: LocalExpnId,\n+        fragment: &AstFragment,\n+    );\n     fn register_builtin_macro(&mut self, name: Symbol, ext: SyntaxExtensionKind);\n \n     fn expansion_for_ast_pass(\n@@ -852,37 +856,41 @@ pub trait ResolverExpand {\n         pass: AstPass,\n         features: &[Symbol],\n         parent_module_id: Option<NodeId>,\n-    ) -> ExpnId;\n+    ) -> LocalExpnId;\n \n     fn resolve_imports(&mut self);\n \n     fn resolve_macro_invocation(\n         &mut self,\n         invoc: &Invocation,\n-        eager_expansion_root: ExpnId,\n+        eager_expansion_root: LocalExpnId,\n         force: bool,\n     ) -> Result<Lrc<SyntaxExtension>, Indeterminate>;\n \n     fn check_unused_macros(&mut self);\n \n     /// Some parent node that is close enough to the given macro call.\n-    fn lint_node_id(&self, expn_id: ExpnId) -> NodeId;\n+    fn lint_node_id(&self, expn_id: LocalExpnId) -> NodeId;\n \n     // Resolver interfaces for specific built-in macros.\n     /// Does `#[derive(...)]` attribute with the given `ExpnId` have built-in `Copy` inside it?\n-    fn has_derive_copy(&self, expn_id: ExpnId) -> bool;\n+    fn has_derive_copy(&self, expn_id: LocalExpnId) -> bool;\n     /// Resolve paths inside the `#[derive(...)]` attribute with the given `ExpnId`.\n     fn resolve_derives(\n         &mut self,\n-        expn_id: ExpnId,\n+        expn_id: LocalExpnId,\n         force: bool,\n         derive_paths: &dyn Fn() -> DeriveResolutions,\n     ) -> Result<(), Indeterminate>;\n     /// Take resolutions for paths inside the `#[derive(...)]` attribute with the given `ExpnId`\n     /// back from resolver.\n-    fn take_derive_resolutions(&mut self, expn_id: ExpnId) -> Option<DeriveResolutions>;\n+    fn take_derive_resolutions(&mut self, expn_id: LocalExpnId) -> Option<DeriveResolutions>;\n     /// Path resolution logic for `#[cfg_accessible(path)]`.\n-    fn cfg_accessible(&mut self, expn_id: ExpnId, path: &ast::Path) -> Result<bool, Indeterminate>;\n+    fn cfg_accessible(\n+        &mut self,\n+        expn_id: LocalExpnId,\n+        path: &ast::Path,\n+    ) -> Result<bool, Indeterminate>;\n \n     /// Decodes the proc-macro quoted span in the specified crate, with the specified id.\n     /// No caching is performed.\n@@ -913,7 +921,7 @@ impl ModuleData {\n \n #[derive(Clone)]\n pub struct ExpansionData {\n-    pub id: ExpnId,\n+    pub id: LocalExpnId,\n     pub depth: usize,\n     pub module: Rc<ModuleData>,\n     pub dir_ownership: DirOwnership,\n@@ -958,7 +966,7 @@ impl<'a> ExtCtxt<'a> {\n             extern_mod_loaded,\n             root_path: PathBuf::new(),\n             current_expansion: ExpansionData {\n-                id: ExpnId::root(),\n+                id: LocalExpnId::ROOT,\n                 depth: 0,\n                 module: Default::default(),\n                 dir_ownership: DirOwnership::Owned { relative: None },\n@@ -995,19 +1003,19 @@ impl<'a> ExtCtxt<'a> {\n     /// Equivalent of `Span::def_site` from the proc macro API,\n     /// except that the location is taken from the span passed as an argument.\n     pub fn with_def_site_ctxt(&self, span: Span) -> Span {\n-        span.with_def_site_ctxt(self.current_expansion.id)\n+        span.with_def_site_ctxt(self.current_expansion.id.to_expn_id())\n     }\n \n     /// Equivalent of `Span::call_site` from the proc macro API,\n     /// except that the location is taken from the span passed as an argument.\n     pub fn with_call_site_ctxt(&self, span: Span) -> Span {\n-        span.with_call_site_ctxt(self.current_expansion.id)\n+        span.with_call_site_ctxt(self.current_expansion.id.to_expn_id())\n     }\n \n     /// Equivalent of `Span::mixed_site` from the proc macro API,\n     /// except that the location is taken from the span passed as an argument.\n     pub fn with_mixed_site_ctxt(&self, span: Span) -> Span {\n-        span.with_mixed_site_ctxt(self.current_expansion.id)\n+        span.with_mixed_site_ctxt(self.current_expansion.id.to_expn_id())\n     }\n \n     /// Returns span for the macro which originally caused the current expansion to happen."}, {"sha": "b9d40962411428850b0252b20faddbc981594b47", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/68511b574ffe019a5cb3e9fa92605f80d39167bc/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68511b574ffe019a5cb3e9fa92605f80d39167bc/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=68511b574ffe019a5cb3e9fa92605f80d39167bc", "patch": "@@ -31,7 +31,7 @@ use rustc_session::lint::BuiltinLintDiagnostics;\n use rustc_session::parse::{feature_err, ParseSess};\n use rustc_session::Limit;\n use rustc_span::symbol::{sym, Ident};\n-use rustc_span::{ExpnId, FileName, Span};\n+use rustc_span::{FileName, LocalExpnId, Span};\n \n use smallvec::{smallvec, SmallVec};\n use std::ops::DerefMut;\n@@ -508,7 +508,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                                 .map(|(path, item, _exts)| {\n                                     // FIXME: Consider using the derive resolutions (`_exts`)\n                                     // instead of enqueuing the derives to be resolved again later.\n-                                    let expn_id = ExpnId::fresh_empty();\n+                                    let expn_id = LocalExpnId::fresh_empty();\n                                     derive_invocations.push((\n                                         Invocation {\n                                             kind: InvocationKind::Derive { path, item },\n@@ -993,7 +993,7 @@ struct InvocationCollector<'a, 'b> {\n \n impl<'a, 'b> InvocationCollector<'a, 'b> {\n     fn collect(&mut self, fragment_kind: AstFragmentKind, kind: InvocationKind) -> AstFragment {\n-        let expn_id = ExpnId::fresh_empty();\n+        let expn_id = LocalExpnId::fresh_empty();\n         let vis = kind.placeholder_visibility();\n         self.invocations.push((\n             Invocation {"}, {"sha": "9ed5c8b8ffba5c814d4177fe50772285d1f36ec8", "filename": "compiler/rustc_expand/src/mbe/transcribe.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/68511b574ffe019a5cb3e9fa92605f80d39167bc/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68511b574ffe019a5cb3e9fa92605f80d39167bc/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs?ref=68511b574ffe019a5cb3e9fa92605f80d39167bc", "patch": "@@ -8,23 +8,23 @@ use rustc_ast::tokenstream::{DelimSpan, TokenStream, TokenTree, TreeAndSpacing};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{pluralize, PResult};\n-use rustc_span::hygiene::{ExpnId, Transparency};\n+use rustc_span::hygiene::{LocalExpnId, Transparency};\n use rustc_span::symbol::MacroRulesNormalizedIdent;\n use rustc_span::Span;\n \n use smallvec::{smallvec, SmallVec};\n use std::mem;\n \n // A Marker adds the given mark to the syntax context.\n-struct Marker(ExpnId, Transparency);\n+struct Marker(LocalExpnId, Transparency);\n \n impl MutVisitor for Marker {\n     fn token_visiting_enabled(&self) -> bool {\n         true\n     }\n \n     fn visit_span(&mut self, span: &mut Span) {\n-        *span = span.apply_mark(self.0, self.1)\n+        *span = span.apply_mark(self.0.to_expn_id(), self.1)\n     }\n }\n "}, {"sha": "8bdd4313de4c3b6329a99cd8f045cb5d75058382", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 74, "deletions": 39, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/68511b574ffe019a5cb3e9fa92605f80d39167bc/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68511b574ffe019a5cb3e9fa92605f80d39167bc/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=68511b574ffe019a5cb3e9fa92605f80d39167bc", "patch": "@@ -30,13 +30,12 @@ use rustc_middle::ty::codec::TyDecoder;\n use rustc_middle::ty::{self, Ty, TyCtxt, Visibility};\n use rustc_serialize::{opaque, Decodable, Decoder};\n use rustc_session::Session;\n-use rustc_span::hygiene::ExpnDataDecodeMode;\n+use rustc_span::hygiene::{ExpnIndex, MacroKind};\n use rustc_span::source_map::{respan, Spanned};\n use rustc_span::symbol::{sym, Ident, Symbol};\n-use rustc_span::{self, hygiene::MacroKind, BytePos, ExpnId, Pos, Span, SyntaxContext, DUMMY_SP};\n+use rustc_span::{self, BytePos, ExpnId, Pos, Span, SyntaxContext, DUMMY_SP};\n \n use proc_macro::bridge::client::ProcMacro;\n-use std::cell::Cell;\n use std::io;\n use std::mem;\n use std::num::NonZeroUsize;\n@@ -80,6 +79,8 @@ crate struct CrateMetadata {\n     /// `DefIndex`. See `raw_def_id_to_def_id` for more details about how\n     /// this is used.\n     def_path_hash_map: OnceCell<UnhashMap<DefPathHash, DefIndex>>,\n+    /// Likewise for ExpnHash.\n+    expn_hash_map: OnceCell<UnhashMap<ExpnHash, ExpnIndex>>,\n     /// Used for decoding interpret::AllocIds in a cached & thread-safe manner.\n     alloc_decoding_state: AllocDecodingState,\n     /// Caches decoded `DefKey`s.\n@@ -350,6 +351,12 @@ impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for DefIndex {\n     }\n }\n \n+impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for ExpnIndex {\n+    fn decode(d: &mut DecodeContext<'a, 'tcx>) -> Result<ExpnIndex, String> {\n+        Ok(ExpnIndex::from_u32(d.read_u32()?))\n+    }\n+}\n+\n impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for SyntaxContext {\n     fn decode(decoder: &mut DecodeContext<'a, 'tcx>) -> Result<SyntaxContext, String> {\n         let cdata = decoder.cdata();\n@@ -371,43 +378,35 @@ impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for ExpnId {\n     fn decode(decoder: &mut DecodeContext<'a, 'tcx>) -> Result<ExpnId, String> {\n         let local_cdata = decoder.cdata();\n         let sess = decoder.sess.unwrap();\n-        let expn_cnum = Cell::new(None);\n-        let get_ctxt = |cnum| {\n-            expn_cnum.set(Some(cnum));\n-            if cnum == LOCAL_CRATE {\n-                &local_cdata.hygiene_context\n-            } else {\n-                &local_cdata.cstore.get_crate_data(cnum).cdata.hygiene_context\n-            }\n-        };\n \n-        rustc_span::hygiene::decode_expn_id(\n-            decoder,\n-            ExpnDataDecodeMode::Metadata(get_ctxt),\n-            |_this, index| {\n-                let cnum = expn_cnum.get().unwrap();\n-                // Lookup local `ExpnData`s in our own crate data. Foreign `ExpnData`s\n-                // are stored in the owning crate, to avoid duplication.\n-                let crate_data = if cnum == LOCAL_CRATE {\n-                    local_cdata\n-                } else {\n-                    local_cdata.cstore.get_crate_data(cnum)\n-                };\n-                let expn_data = crate_data\n-                    .root\n-                    .expn_data\n-                    .get(&crate_data, index)\n-                    .unwrap()\n-                    .decode((&crate_data, sess));\n-                let expn_hash = crate_data\n-                    .root\n-                    .expn_hashes\n-                    .get(&crate_data, index)\n-                    .unwrap()\n-                    .decode((&crate_data, sess));\n-                Ok((expn_data, expn_hash))\n-            },\n-        )\n+        let cnum = CrateNum::decode(decoder)?;\n+        let index = u32::decode(decoder)?;\n+\n+        let expn_id = rustc_span::hygiene::decode_expn_id(cnum, index, |expn_id| {\n+            let ExpnId { krate: cnum, local_id: index } = expn_id;\n+            // Lookup local `ExpnData`s in our own crate data. Foreign `ExpnData`s\n+            // are stored in the owning crate, to avoid duplication.\n+            debug_assert_ne!(cnum, LOCAL_CRATE);\n+            let crate_data = if cnum == local_cdata.cnum {\n+                local_cdata\n+            } else {\n+                local_cdata.cstore.get_crate_data(cnum)\n+            };\n+            let expn_data = crate_data\n+                .root\n+                .expn_data\n+                .get(&crate_data, index)\n+                .unwrap()\n+                .decode((&crate_data, sess));\n+            let expn_hash = crate_data\n+                .root\n+                .expn_hashes\n+                .get(&crate_data, index)\n+                .unwrap()\n+                .decode((&crate_data, sess));\n+            (expn_data, expn_hash)\n+        });\n+        Ok(expn_id)\n     }\n }\n \n@@ -1622,6 +1621,41 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         self.def_path_hash_unlocked(index, &mut def_path_hashes)\n     }\n \n+    fn expn_hash_to_expn_id(&self, index_guess: u32, hash: ExpnHash) -> ExpnId {\n+        debug_assert_eq!(ExpnId::from_hash(hash), None);\n+        let index_guess = ExpnIndex::from_u32(index_guess);\n+        let old_hash = self.root.expn_hashes.get(self, index_guess).map(|lazy| lazy.decode(self));\n+\n+        let index = if old_hash == Some(hash) {\n+            // Fast path: the expn and its index is unchanged from the\n+            // previous compilation session. There is no need to decode anything\n+            // else.\n+            index_guess\n+        } else {\n+            // Slow path: We need to find out the new `DefIndex` of the provided\n+            // `DefPathHash`, if its still exists. This requires decoding every `DefPathHash`\n+            // stored in this crate.\n+            let map = self.cdata.expn_hash_map.get_or_init(|| {\n+                let end_id = self.root.expn_hashes.size() as u32;\n+                let mut map =\n+                    UnhashMap::with_capacity_and_hasher(end_id as usize, Default::default());\n+                for i in 0..end_id {\n+                    let i = ExpnIndex::from_u32(i);\n+                    if let Some(hash) = self.root.expn_hashes.get(self, i) {\n+                        map.insert(hash.decode(self), i);\n+                    } else {\n+                        panic!(\"Missing expn_hash entry for {:?}\", i);\n+                    }\n+                }\n+                map\n+            });\n+            map[&hash]\n+        };\n+\n+        let data = self.root.expn_data.get(self, index).unwrap().decode(self);\n+        rustc_span::hygiene::register_expn_id(self.cnum, index, data, hash)\n+    }\n+\n     /// Imports the source_map from an external crate into the source_map of the crate\n     /// currently being compiled (the \"local crate\").\n     ///\n@@ -1860,6 +1894,7 @@ impl CrateMetadata {\n             raw_proc_macros,\n             source_map_import_info: OnceCell::new(),\n             def_path_hash_map: Default::default(),\n+            expn_hash_map: Default::default(),\n             alloc_decoding_state,\n             cnum,\n             cnum_map,"}, {"sha": "41839c58021ab335c7b2e4c4391d9631544b2834", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/68511b574ffe019a5cb3e9fa92605f80d39167bc/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68511b574ffe019a5cb3e9fa92605f80d39167bc/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=68511b574ffe019a5cb3e9fa92605f80d39167bc", "patch": "@@ -18,11 +18,11 @@ use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, TyCtxt, Visibility};\n use rustc_session::utils::NativeLibKind;\n use rustc_session::{Session, StableCrateId};\n+use rustc_span::hygiene::{ExpnHash, ExpnId};\n use rustc_span::source_map::{Span, Spanned};\n use rustc_span::symbol::Symbol;\n \n use rustc_data_structures::sync::Lrc;\n-use rustc_span::ExpnId;\n use smallvec::SmallVec;\n use std::any::Any;\n \n@@ -528,6 +528,10 @@ impl CrateStore for CStore {\n         self.get_crate_data(cnum).def_path_hash_to_def_id(cnum, index_guess, hash)\n     }\n \n+    fn expn_hash_to_expn_id(&self, cnum: CrateNum, index_guess: u32, hash: ExpnHash) -> ExpnId {\n+        self.get_crate_data(cnum).expn_hash_to_expn_id(index_guess, hash)\n+    }\n+\n     fn encode_metadata(&self, tcx: TyCtxt<'_>) -> EncodedMetadata {\n         encoder::encode_metadata(tcx)\n     }"}, {"sha": "6877d6ef542c7fe76348a17206d1aaf8ea437f4f", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/68511b574ffe019a5cb3e9fa92605f80d39167bc/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68511b574ffe019a5cb3e9fa92605f80d39167bc/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=68511b574ffe019a5cb3e9fa92605f80d39167bc", "patch": "@@ -31,7 +31,7 @@ use rustc_session::config::CrateType;\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{self, ExternalSource, FileName, SourceFile, Span, SyntaxContext};\n use rustc_span::{\n-    hygiene::{ExpnDataEncodeMode, HygieneEncodeContext, MacroKind},\n+    hygiene::{ExpnIndex, HygieneEncodeContext, MacroKind},\n     RealFileName,\n };\n use rustc_target::abi::VariantIdx;\n@@ -168,6 +168,12 @@ impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for DefIndex {\n     }\n }\n \n+impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for ExpnIndex {\n+    fn encode(&self, s: &mut EncodeContext<'a, 'tcx>) -> opaque::EncodeResult {\n+        s.emit_u32(self.as_u32())\n+    }\n+}\n+\n impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for SyntaxContext {\n     fn encode(&self, s: &mut EncodeContext<'a, 'tcx>) -> opaque::EncodeResult {\n         rustc_span::hygiene::raw_encode_syntax_context(*self, &s.hygiene_ctxt, s)\n@@ -176,12 +182,15 @@ impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for SyntaxContext {\n \n impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for ExpnId {\n     fn encode(&self, s: &mut EncodeContext<'a, 'tcx>) -> opaque::EncodeResult {\n-        rustc_span::hygiene::raw_encode_expn_id(\n-            *self,\n-            &s.hygiene_ctxt,\n-            ExpnDataEncodeMode::Metadata,\n-            s,\n-        )\n+        if self.krate == LOCAL_CRATE {\n+            // We will only write details for local expansions.  Non-local expansions will fetch\n+            // data from the corresponding crate's metadata.\n+            // FIXME(#43047) FIXME(#74731) We may eventually want to avoid relying on external\n+            // metadata from proc-macro crates.\n+            s.hygiene_ctxt.schedule_expn_data_for_encoding(*self);\n+        }\n+        self.krate.encode(s)?;\n+        self.local_id.encode(s)\n     }\n }\n \n@@ -1593,8 +1602,10 @@ impl EncodeContext<'a, 'tcx> {\n                 Ok(())\n             },\n             |(this, _, expn_data_table, expn_hash_table), index, expn_data, hash| {\n-                expn_data_table.set(index, this.lazy(expn_data));\n-                expn_hash_table.set(index, this.lazy(hash));\n+                if let Some(index) = index.as_local() {\n+                    expn_data_table.set(index.as_raw(), this.lazy(expn_data));\n+                    expn_hash_table.set(index.as_raw(), this.lazy(hash));\n+                }\n                 Ok(())\n             },\n         );"}, {"sha": "a487753f4628a4548275019870d0eaf0c9336982", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/68511b574ffe019a5cb3e9fa92605f80d39167bc/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68511b574ffe019a5cb3e9fa92605f80d39167bc/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=68511b574ffe019a5cb3e9fa92605f80d39167bc", "patch": "@@ -19,7 +19,7 @@ use rustc_middle::ty::{self, ReprOptions, Ty};\n use rustc_serialize::opaque::Encoder;\n use rustc_session::config::SymbolManglingVersion;\n use rustc_span::edition::Edition;\n-use rustc_span::hygiene::MacroKind;\n+use rustc_span::hygiene::{ExpnIndex, MacroKind};\n use rustc_span::symbol::{Ident, Symbol};\n use rustc_span::{self, ExpnData, ExpnHash, ExpnId, Span};\n use rustc_target::spec::{PanicStrategy, TargetTriple};\n@@ -170,8 +170,8 @@ macro_rules! Lazy {\n }\n \n type SyntaxContextTable = Lazy<Table<u32, Lazy<SyntaxContextData>>>;\n-type ExpnDataTable = Lazy<Table<u32, Lazy<ExpnData>>>;\n-type ExpnHashTable = Lazy<Table<u32, Lazy<ExpnHash>>>;\n+type ExpnDataTable = Lazy<Table<ExpnIndex, Lazy<ExpnData>>>;\n+type ExpnHashTable = Lazy<Table<ExpnIndex, Lazy<ExpnHash>>>;\n \n #[derive(MetadataEncodable, MetadataDecodable)]\n crate struct ProcMacroData {"}, {"sha": "4c35b49bcefd73079d808d96a449e144e339ec65", "filename": "compiler/rustc_middle/src/middle/cstore.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/68511b574ffe019a5cb3e9fa92605f80d39167bc/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68511b574ffe019a5cb3e9fa92605f80d39167bc/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fcstore.rs?ref=68511b574ffe019a5cb3e9fa92605f80d39167bc", "patch": "@@ -6,12 +6,12 @@ use crate::ty::TyCtxt;\n \n use rustc_ast as ast;\n use rustc_data_structures::sync::{self, MetadataRef};\n-use rustc_hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n+use rustc_hir::def_id::{CrateNum, DefId, StableCrateId, LOCAL_CRATE};\n use rustc_hir::definitions::{DefKey, DefPath, DefPathHash};\n use rustc_macros::HashStable;\n use rustc_session::search_paths::PathKind;\n use rustc_session::utils::NativeLibKind;\n-use rustc_session::StableCrateId;\n+use rustc_span::hygiene::{ExpnHash, ExpnId};\n use rustc_span::symbol::Symbol;\n use rustc_span::Span;\n use rustc_target::spec::Target;\n@@ -207,6 +207,7 @@ pub trait CrateStore: std::fmt::Debug {\n         index_guess: u32,\n         hash: DefPathHash,\n     ) -> Option<DefId>;\n+    fn expn_hash_to_expn_id(&self, cnum: CrateNum, index_guess: u32, hash: ExpnHash) -> ExpnId;\n \n     // utility functions\n     fn encode_metadata(&self, tcx: TyCtxt<'_>) -> EncodedMetadata;"}, {"sha": "0ac80ebd6367b62c7e8088f216680af715e2b9f2", "filename": "compiler/rustc_middle/src/ty/query/on_disk_cache.rs", "status": "modified", "additions": 63, "deletions": 35, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/68511b574ffe019a5cb3e9fa92605f80d39167bc/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68511b574ffe019a5cb3e9fa92605f80d39167bc/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=68511b574ffe019a5cb3e9fa92605f80d39167bc", "patch": "@@ -20,8 +20,7 @@ use rustc_serialize::{\n };\n use rustc_session::Session;\n use rustc_span::hygiene::{\n-    ExpnDataDecodeMode, ExpnDataEncodeMode, ExpnId, HygieneDecodeContext, HygieneEncodeContext,\n-    SyntaxContext, SyntaxContextData,\n+    ExpnId, HygieneDecodeContext, HygieneEncodeContext, SyntaxContext, SyntaxContextData,\n };\n use rustc_span::source_map::{SourceMap, StableSourceFileId};\n use rustc_span::CachingSourceMapView;\n@@ -84,14 +83,16 @@ pub struct OnDiskCache<'sess> {\n     // `ExpnData` (e.g `ExpnData.krate` may not be `LOCAL_CRATE`). Alternatively,\n     // we could look up the `ExpnData` from the metadata of foreign crates,\n     // but it seemed easier to have `OnDiskCache` be independent of the `CStore`.\n-    expn_data: FxHashMap<u32, AbsoluteBytePos>,\n+    expn_data: UnhashMap<ExpnHash, AbsoluteBytePos>,\n     // Additional information used when decoding hygiene data.\n     hygiene_context: HygieneDecodeContext,\n     // Maps `DefPathHash`es to their `RawDefId`s from the *previous*\n     // compilation session. This is used as an initial 'guess' when\n     // we try to map a `DefPathHash` to its `DefId` in the current compilation\n     // session.\n     foreign_def_path_hashes: UnhashMap<DefPathHash, RawDefId>,\n+    // Likewise for ExpnId.\n+    foreign_expn_data: UnhashMap<ExpnHash, u32>,\n \n     // The *next* compilation sessison's `foreign_def_path_hashes` - at\n     // the end of our current compilation session, this will get written\n@@ -119,8 +120,9 @@ struct Footer {\n     // See `OnDiskCache.syntax_contexts`\n     syntax_contexts: FxHashMap<u32, AbsoluteBytePos>,\n     // See `OnDiskCache.expn_data`\n-    expn_data: FxHashMap<u32, AbsoluteBytePos>,\n+    expn_data: UnhashMap<ExpnHash, AbsoluteBytePos>,\n     foreign_def_path_hashes: UnhashMap<DefPathHash, RawDefId>,\n+    foreign_expn_data: UnhashMap<ExpnHash, u32>,\n }\n \n pub type EncodedQueryResultIndex = Vec<(SerializedDepNodeIndex, AbsoluteBytePos)>;\n@@ -218,6 +220,7 @@ impl<'sess> OnDiskCache<'sess> {\n             alloc_decoding_state: AllocDecodingState::new(footer.interpret_alloc_index),\n             syntax_contexts: footer.syntax_contexts,\n             expn_data: footer.expn_data,\n+            foreign_expn_data: footer.foreign_expn_data,\n             hygiene_context: Default::default(),\n             foreign_def_path_hashes: footer.foreign_def_path_hashes,\n             latest_foreign_def_path_hashes: Default::default(),\n@@ -237,7 +240,8 @@ impl<'sess> OnDiskCache<'sess> {\n             prev_diagnostics_index: Default::default(),\n             alloc_decoding_state: AllocDecodingState::new(Vec::new()),\n             syntax_contexts: FxHashMap::default(),\n-            expn_data: FxHashMap::default(),\n+            expn_data: UnhashMap::default(),\n+            foreign_expn_data: UnhashMap::default(),\n             hygiene_context: Default::default(),\n             foreign_def_path_hashes: Default::default(),\n             latest_foreign_def_path_hashes: Default::default(),\n@@ -351,7 +355,8 @@ impl<'sess> OnDiskCache<'sess> {\n             };\n \n             let mut syntax_contexts = FxHashMap::default();\n-            let mut expn_ids = FxHashMap::default();\n+            let mut expn_data = UnhashMap::default();\n+            let mut foreign_expn_data = UnhashMap::default();\n \n             // Encode all hygiene data (`SyntaxContextData` and `ExpnData`) from the current\n             // session.\n@@ -364,10 +369,14 @@ impl<'sess> OnDiskCache<'sess> {\n                     syntax_contexts.insert(index, pos);\n                     Ok(())\n                 },\n-                |encoder, index, expn_data, hash| -> FileEncodeResult {\n-                    let pos = AbsoluteBytePos::new(encoder.position());\n-                    encoder.encode_tagged(TAG_EXPN_DATA, &(expn_data, hash))?;\n-                    expn_ids.insert(index, pos);\n+                |encoder, expn_id, data, hash| -> FileEncodeResult {\n+                    if expn_id.krate == LOCAL_CRATE {\n+                        let pos = AbsoluteBytePos::new(encoder.position());\n+                        encoder.encode_tagged(TAG_EXPN_DATA, data)?;\n+                        expn_data.insert(hash, pos);\n+                    } else {\n+                        foreign_expn_data.insert(hash, expn_id.local_id.as_u32());\n+                    }\n                     Ok(())\n                 },\n             )?;\n@@ -385,7 +394,8 @@ impl<'sess> OnDiskCache<'sess> {\n                     diagnostics_index,\n                     interpret_alloc_index,\n                     syntax_contexts,\n-                    expn_data: expn_ids,\n+                    expn_data,\n+                    foreign_expn_data,\n                     foreign_def_path_hashes,\n                 },\n             )?;\n@@ -547,6 +557,7 @@ impl<'sess> OnDiskCache<'sess> {\n             alloc_decoding_session: self.alloc_decoding_state.new_decoding_session(),\n             syntax_contexts: &self.syntax_contexts,\n             expn_data: &self.expn_data,\n+            foreign_expn_data: &self.foreign_expn_data,\n             hygiene_context: &self.hygiene_context,\n         };\n         f(&mut decoder)\n@@ -641,7 +652,8 @@ pub struct CacheDecoder<'a, 'tcx> {\n     file_index_to_stable_id: &'a FxHashMap<SourceFileIndex, EncodedSourceFileId>,\n     alloc_decoding_session: AllocDecodingSession<'a>,\n     syntax_contexts: &'a FxHashMap<u32, AbsoluteBytePos>,\n-    expn_data: &'a FxHashMap<u32, AbsoluteBytePos>,\n+    expn_data: &'a UnhashMap<ExpnHash, AbsoluteBytePos>,\n+    foreign_expn_data: &'a UnhashMap<ExpnHash, u32>,\n     hygiene_context: &'a HygieneDecodeContext,\n }\n \n@@ -792,23 +804,43 @@ impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for SyntaxContext {\n \n impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for ExpnId {\n     fn decode(decoder: &mut CacheDecoder<'a, 'tcx>) -> Result<Self, String> {\n-        let expn_data = decoder.expn_data;\n-        rustc_span::hygiene::decode_expn_id(\n-            decoder,\n-            ExpnDataDecodeMode::incr_comp(decoder.hygiene_context),\n-            |this, index| {\n-                // This closure is invoked if we haven't already decoded the data for the `ExpnId` we are deserializing.\n-                // We look up the position of the associated `ExpnData` and decode it.\n-                let pos = expn_data\n-                    .get(&index)\n-                    .unwrap_or_else(|| panic!(\"Bad index {:?} (map {:?})\", index, expn_data));\n-\n-                this.with_position(pos.to_usize(), |decoder| {\n-                    let data: (ExpnData, ExpnHash) = decode_tagged(decoder, TAG_EXPN_DATA)?;\n-                    Ok(data)\n-                })\n-            },\n-        )\n+        let hash = ExpnHash::decode(decoder)?;\n+        if hash.is_root() {\n+            return Ok(ExpnId::root());\n+        }\n+\n+        if let Some(expn_id) = ExpnId::from_hash(hash) {\n+            return Ok(expn_id);\n+        }\n+\n+        let krate = decoder.cnum_map[&hash.stable_crate_id()];\n+\n+        let expn_id = if krate == LOCAL_CRATE {\n+            // We look up the position of the associated `ExpnData` and decode it.\n+            let pos = decoder\n+                .expn_data\n+                .get(&hash)\n+                .unwrap_or_else(|| panic!(\"Bad hash {:?} (map {:?})\", hash, decoder.expn_data));\n+\n+            let data: ExpnData = decoder\n+                .with_position(pos.to_usize(), |decoder| decode_tagged(decoder, TAG_EXPN_DATA))?;\n+            rustc_span::hygiene::register_local_expn_id(data, hash)\n+        } else {\n+            let index_guess = decoder.foreign_expn_data[&hash];\n+            decoder.tcx.untracked_resolutions.cstore.expn_hash_to_expn_id(krate, index_guess, hash)\n+        };\n+\n+        #[cfg(debug_assertions)]\n+        {\n+            use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+            let mut hcx = decoder.tcx.create_stable_hashing_context();\n+            let mut hasher = StableHasher::new();\n+            hcx.while_hashing_spans(true, |hcx| expn_id.expn_data().hash_stable(hcx, &mut hasher));\n+            let local_hash: u64 = hasher.finish();\n+            debug_assert_eq!(hash.local_hash(), local_hash);\n+        }\n+\n+        Ok(expn_id)\n     }\n }\n \n@@ -983,12 +1015,8 @@ where\n     E: 'a + OpaqueEncoder,\n {\n     fn encode(&self, s: &mut CacheEncoder<'a, 'tcx, E>) -> Result<(), E::Error> {\n-        rustc_span::hygiene::raw_encode_expn_id(\n-            *self,\n-            s.hygiene_context,\n-            ExpnDataEncodeMode::IncrComp,\n-            s,\n-        )\n+        s.hygiene_context.schedule_expn_data_for_encoding(*self);\n+        self.expn_hash().encode(s)\n     }\n }\n "}, {"sha": "178d727418d7426405a2ac8b24b09bf310ec931d", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 24, "deletions": 13, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/68511b574ffe019a5cb3e9fa92605f80d39167bc/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68511b574ffe019a5cb3e9fa92605f80d39167bc/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=68511b574ffe019a5cb3e9fa92605f80d39167bc", "patch": "@@ -31,7 +31,7 @@ use rustc_middle::bug;\n use rustc_middle::hir::exports::Export;\n use rustc_middle::middle::cstore::CrateStore;\n use rustc_middle::ty;\n-use rustc_span::hygiene::{ExpnId, MacroKind};\n+use rustc_span::hygiene::{ExpnId, LocalExpnId, MacroKind};\n use rustc_span::source_map::{respan, Spanned};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::Span;\n@@ -42,7 +42,7 @@ use tracing::debug;\n \n type Res = def::Res<NodeId>;\n \n-impl<'a> ToNameBinding<'a> for (Module<'a>, ty::Visibility, Span, ExpnId) {\n+impl<'a> ToNameBinding<'a> for (Module<'a>, ty::Visibility, Span, LocalExpnId) {\n     fn to_name_binding(self, arenas: &'a ResolverArenas<'a>) -> &'a NameBinding<'a> {\n         arenas.alloc_name_binding(NameBinding {\n             kind: NameBindingKind::Module(self.0),\n@@ -54,7 +54,7 @@ impl<'a> ToNameBinding<'a> for (Module<'a>, ty::Visibility, Span, ExpnId) {\n     }\n }\n \n-impl<'a> ToNameBinding<'a> for (Res, ty::Visibility, Span, ExpnId) {\n+impl<'a> ToNameBinding<'a> for (Res, ty::Visibility, Span, LocalExpnId) {\n     fn to_name_binding(self, arenas: &'a ResolverArenas<'a>) -> &'a NameBinding<'a> {\n         arenas.alloc_name_binding(NameBinding {\n             kind: NameBindingKind::Res(self.0, false),\n@@ -68,7 +68,7 @@ impl<'a> ToNameBinding<'a> for (Res, ty::Visibility, Span, ExpnId) {\n \n struct IsMacroExport;\n \n-impl<'a> ToNameBinding<'a> for (Res, ty::Visibility, Span, ExpnId, IsMacroExport) {\n+impl<'a> ToNameBinding<'a> for (Res, ty::Visibility, Span, LocalExpnId, IsMacroExport) {\n     fn to_name_binding(self, arenas: &'a ResolverArenas<'a>) -> &'a NameBinding<'a> {\n         arenas.alloc_name_binding(NameBinding {\n             kind: NameBindingKind::Res(self.0, true),\n@@ -157,7 +157,12 @@ impl<'a> Resolver<'a> {\n     crate fn macro_def_scope(&mut self, expn_id: ExpnId) -> Module<'a> {\n         let def_id = match expn_id.expn_data().macro_def_id {\n             Some(def_id) => def_id,\n-            None => return self.ast_transform_scopes.get(&expn_id).unwrap_or(&self.graph_root),\n+            None => {\n+                return expn_id\n+                    .as_local()\n+                    .and_then(|expn_id| self.ast_transform_scopes.get(&expn_id))\n+                    .unwrap_or(&self.graph_root);\n+            }\n         };\n         self.macro_def_scope_from_def_id(def_id)\n     }\n@@ -739,7 +744,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 if ptr::eq(parent, self.r.graph_root) {\n                     if let Some(entry) = self.r.extern_prelude.get(&ident.normalize_to_macros_2_0())\n                     {\n-                        if expansion != ExpnId::root()\n+                        if expansion != LocalExpnId::ROOT\n                             && orig_name.is_some()\n                             && entry.extern_crate_item.is_none()\n                         {\n@@ -769,7 +774,13 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                     no_implicit_prelude: parent.no_implicit_prelude || {\n                         self.r.session.contains_name(&item.attrs, sym::no_implicit_prelude)\n                     },\n-                    ..ModuleData::new(Some(parent), module_kind, def_id, expansion, item.span)\n+                    ..ModuleData::new(\n+                        Some(parent),\n+                        module_kind,\n+                        def_id,\n+                        expansion.to_expn_id(),\n+                        item.span,\n+                    )\n                 });\n                 self.r.define(parent, ident, TypeNS, (module, vis, sp, expansion));\n                 self.r.module_map.insert(local_def_id, module);\n@@ -808,7 +819,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                     parent,\n                     module_kind,\n                     parent.nearest_parent_mod,\n-                    expansion,\n+                    expansion.to_expn_id(),\n                     item.span,\n                 );\n                 self.r.define(parent, ident, TypeNS, (module, vis, sp, expansion));\n@@ -883,7 +894,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                     parent,\n                     module_kind,\n                     parent.nearest_parent_mod,\n-                    expansion,\n+                    expansion.to_expn_id(),\n                     item.span,\n                 );\n                 self.r.define(parent, ident, TypeNS, (module, vis, sp, expansion));\n@@ -926,7 +937,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 parent,\n                 ModuleKind::Block(block.id),\n                 parent.nearest_parent_mod,\n-                expansion,\n+                expansion.to_expn_id(),\n                 block.span,\n             );\n             self.r.block_map.insert(block.id, module);\n@@ -946,7 +957,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                     parent,\n                     ModuleKind::Def(kind, def_id, ident.name),\n                     def_id,\n-                    expansion,\n+                    expansion.to_expn_id(),\n                     span,\n                 );\n                 self.r.define(parent, ident, TypeNS, (module, vis, span, expansion));\n@@ -1112,7 +1123,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             })\n         };\n \n-        let allow_shadowing = self.parent_scope.expansion == ExpnId::root();\n+        let allow_shadowing = self.parent_scope.expansion == LocalExpnId::ROOT;\n         if let Some(span) = import_all {\n             let import = macro_use_import(self, span);\n             self.r.potentially_unused_imports.push(import);\n@@ -1175,7 +1186,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         false\n     }\n \n-    fn visit_invoc(&mut self, id: NodeId) -> ExpnId {\n+    fn visit_invoc(&mut self, id: NodeId) -> LocalExpnId {\n         let invoc_id = id.placeholder_to_expn_id();\n         let old_parent_scope = self.r.invocation_parent_scopes.insert(invoc_id, self.parent_scope);\n         assert!(old_parent_scope.is_none(), \"invocation data is reset for an invocation\");"}, {"sha": "6f4f1bdaea1b7a97929bea82a63ad24c867f4637", "filename": "compiler/rustc_resolve/src/def_collector.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/68511b574ffe019a5cb3e9fa92605f80d39167bc/compiler%2Frustc_resolve%2Fsrc%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68511b574ffe019a5cb3e9fa92605f80d39167bc/compiler%2Frustc_resolve%2Fsrc%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdef_collector.rs?ref=68511b574ffe019a5cb3e9fa92605f80d39167bc", "patch": "@@ -6,15 +6,15 @@ use rustc_ast_lowering::ResolverAstLowering;\n use rustc_expand::expand::AstFragment;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::definitions::*;\n-use rustc_span::hygiene::ExpnId;\n+use rustc_span::hygiene::LocalExpnId;\n use rustc_span::symbol::{kw, sym};\n use rustc_span::Span;\n use tracing::debug;\n \n crate fn collect_definitions(\n     resolver: &mut Resolver<'_>,\n     fragment: &AstFragment,\n-    expansion: ExpnId,\n+    expansion: LocalExpnId,\n ) {\n     let (parent_def, impl_trait_context) = resolver.invocation_parents[&expansion];\n     fragment.visit_with(&mut DefCollector { resolver, parent_def, expansion, impl_trait_context });\n@@ -25,14 +25,14 @@ struct DefCollector<'a, 'b> {\n     resolver: &'a mut Resolver<'b>,\n     parent_def: LocalDefId,\n     impl_trait_context: ImplTraitContext,\n-    expansion: ExpnId,\n+    expansion: LocalExpnId,\n }\n \n impl<'a, 'b> DefCollector<'a, 'b> {\n     fn create_def(&mut self, node_id: NodeId, data: DefPathData, span: Span) -> LocalDefId {\n         let parent_def = self.parent_def;\n         debug!(\"create_def(node_id={:?}, data={:?}, parent_def={:?})\", node_id, data, parent_def);\n-        self.resolver.create_def(parent_def, node_id, data, self.expansion, span)\n+        self.resolver.create_def(parent_def, node_id, data, self.expansion.to_expn_id(), span)\n     }\n \n     fn with_parent<F: FnOnce(&mut Self)>(&mut self, parent_def: LocalDefId, f: F) {\n@@ -285,7 +285,7 @@ impl<'a, 'b> visit::Visitor<'a> for DefCollector<'a, 'b> {\n                         item_def,\n                         node_id,\n                         DefPathData::ImplTrait,\n-                        self.expansion,\n+                        self.expansion.to_expn_id(),\n                         ty.span,\n                     ),\n                     ImplTraitContext::Existential => {"}, {"sha": "acfa389fed58abc32f6398d76b1121e642a9cc86", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/68511b574ffe019a5cb3e9fa92605f80d39167bc/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68511b574ffe019a5cb3e9fa92605f80d39167bc/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=68511b574ffe019a5cb3e9fa92605f80d39167bc", "patch": "@@ -22,7 +22,7 @@ use rustc_middle::span_bug;\n use rustc_middle::ty;\n use rustc_session::lint::builtin::{PUB_USE_OF_PRIVATE_EXTERN_CRATE, UNUSED_IMPORTS};\n use rustc_session::lint::BuiltinLintDiagnostics;\n-use rustc_span::hygiene::ExpnId;\n+use rustc_span::hygiene::LocalExpnId;\n use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::symbol::{kw, Ident, Symbol};\n use rustc_span::{MultiSpan, Span};\n@@ -237,8 +237,9 @@ impl<'a> Resolver<'a> {\n                 if ns == TypeNS {\n                     if ident.name == kw::Crate || ident.name == kw::DollarCrate {\n                         let module = self.resolve_crate_root(ident);\n-                        let binding = (module, ty::Visibility::Public, module.span, ExpnId::root())\n-                            .to_name_binding(self.arenas);\n+                        let binding =\n+                            (module, ty::Visibility::Public, module.span, LocalExpnId::ROOT)\n+                                .to_name_binding(self.arenas);\n                         return Ok(binding);\n                     } else if ident.name == kw::Super || ident.name == kw::SelfLower {\n                         // FIXME: Implement these with renaming requirements so that e.g.\n@@ -265,7 +266,7 @@ impl<'a> Resolver<'a> {\n             self.resolution(module, key).try_borrow_mut().map_err(|_| (Determined, Weak::No))?; // This happens when there is a cycle of imports.\n \n         if let Some(binding) = resolution.binding {\n-            if !restricted_shadowing && binding.expansion != ExpnId::root() {\n+            if !restricted_shadowing && binding.expansion != LocalExpnId::ROOT {\n                 if let NameBindingKind::Res(_, true) = binding.kind {\n                     self.macro_expanded_macro_export_errors.insert((path_span, binding.span));\n                 }\n@@ -307,7 +308,7 @@ impl<'a> Resolver<'a> {\n                         if let Some(shadowed_glob) = resolution.shadowed_glob {\n                             // Forbid expanded shadowing to avoid time travel.\n                             if restricted_shadowing\n-                                && binding.expansion != ExpnId::root()\n+                                && binding.expansion != LocalExpnId::ROOT\n                                 && binding.res() != shadowed_glob.res()\n                             {\n                                 self.ambiguity_errors.push(AmbiguityError {\n@@ -521,7 +522,7 @@ impl<'a> Resolver<'a> {\n                             if old_glob { (old_binding, binding) } else { (binding, old_binding) };\n                         if glob_binding.res() != nonglob_binding.res()\n                             && key.ns == MacroNS\n-                            && nonglob_binding.expansion != ExpnId::root()\n+                            && nonglob_binding.expansion != LocalExpnId::ROOT\n                         {\n                             resolution.binding = Some(this.ambiguity(\n                                 AmbiguityKind::GlobVsExpanded,\n@@ -1271,7 +1272,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         target: Ident,\n     ) {\n         // Skip if the import was produced by a macro.\n-        if import.parent_scope.expansion != ExpnId::root() {\n+        if import.parent_scope.expansion != LocalExpnId::ROOT {\n             return;\n         }\n "}, {"sha": "7114fd33188d972c1fa035deb83b16ed50084987", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/68511b574ffe019a5cb3e9fa92605f80d39167bc/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68511b574ffe019a5cb3e9fa92605f80d39167bc/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=68511b574ffe019a5cb3e9fa92605f80d39167bc", "patch": "@@ -53,7 +53,7 @@ use rustc_session::lint;\n use rustc_session::lint::{BuiltinLintDiagnostics, LintBuffer};\n use rustc_session::Session;\n use rustc_span::edition::Edition;\n-use rustc_span::hygiene::{ExpnId, ExpnKind, MacroKind, SyntaxContext, Transparency};\n+use rustc_span::hygiene::{ExpnId, ExpnKind, LocalExpnId, MacroKind, SyntaxContext, Transparency};\n use rustc_span::source_map::{CachingSourceMapView, Spanned};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n@@ -103,7 +103,7 @@ impl Determinacy {\n /// but not for late resolution yet.\n #[derive(Clone, Copy)]\n enum Scope<'a> {\n-    DeriveHelpers(ExpnId),\n+    DeriveHelpers(LocalExpnId),\n     DeriveHelpersCompat,\n     MacroRules(MacroRulesScopeRef<'a>),\n     CrateRoot,\n@@ -143,7 +143,7 @@ enum ScopeSet<'a> {\n #[derive(Clone, Copy, Debug)]\n pub struct ParentScope<'a> {\n     module: Module<'a>,\n-    expansion: ExpnId,\n+    expansion: LocalExpnId,\n     macro_rules: MacroRulesScopeRef<'a>,\n     derives: &'a [ast::Path],\n }\n@@ -154,7 +154,7 @@ impl<'a> ParentScope<'a> {\n     pub fn module(module: Module<'a>, resolver: &Resolver<'a>) -> ParentScope<'a> {\n         ParentScope {\n             module,\n-            expansion: ExpnId::root(),\n+            expansion: LocalExpnId::ROOT,\n             macro_rules: resolver.arenas.alloc_macro_rules_scope(MacroRulesScope::Empty),\n             derives: &[],\n         }\n@@ -515,7 +515,7 @@ pub struct ModuleData<'a> {\n     populate_on_access: Cell<bool>,\n \n     /// Macro invocations that can expand into items in this module.\n-    unexpanded_invocations: RefCell<FxHashSet<ExpnId>>,\n+    unexpanded_invocations: RefCell<FxHashSet<LocalExpnId>>,\n \n     /// Whether `#[no_implicit_prelude]` is active.\n     no_implicit_prelude: bool,\n@@ -645,7 +645,7 @@ impl<'a> fmt::Debug for ModuleData<'a> {\n pub struct NameBinding<'a> {\n     kind: NameBindingKind<'a>,\n     ambiguity: Option<(&'a NameBinding<'a>, AmbiguityKind)>,\n-    expansion: ExpnId,\n+    expansion: LocalExpnId,\n     span: Span,\n     vis: ty::Visibility,\n }\n@@ -829,7 +829,11 @@ impl<'a> NameBinding<'a> {\n     // in some later round and screw up our previously found resolution.\n     // See more detailed explanation in\n     // https://github.com/rust-lang/rust/pull/53778#issuecomment-419224049\n-    fn may_appear_after(&self, invoc_parent_expansion: ExpnId, binding: &NameBinding<'_>) -> bool {\n+    fn may_appear_after(\n+        &self,\n+        invoc_parent_expansion: LocalExpnId,\n+        binding: &NameBinding<'_>,\n+    ) -> bool {\n         // self > max(invoc, binding) => !(self <= invoc || self <= binding)\n         // Expansions are partially ordered, so \"may appear after\" is an inversion of\n         // \"certainly appears before or simultaneously\" and includes unordered cases.\n@@ -966,7 +970,7 @@ pub struct Resolver<'a> {\n     dummy_ext_derive: Lrc<SyntaxExtension>,\n     non_macro_attrs: [Lrc<SyntaxExtension>; 2],\n     local_macro_def_scopes: FxHashMap<LocalDefId, Module<'a>>,\n-    ast_transform_scopes: FxHashMap<ExpnId, Module<'a>>,\n+    ast_transform_scopes: FxHashMap<LocalExpnId, Module<'a>>,\n     unused_macros: FxHashMap<LocalDefId, (NodeId, Span)>,\n     proc_macro_stubs: FxHashSet<LocalDefId>,\n     /// Traces collected during macro resolution and validated when it's complete.\n@@ -978,18 +982,18 @@ pub struct Resolver<'a> {\n     /// `derive(Copy)` marks items they are applied to so they are treated specially later.\n     /// Derive macros cannot modify the item themselves and have to store the markers in the global\n     /// context, so they attach the markers to derive container IDs using this resolver table.\n-    containers_deriving_copy: FxHashSet<ExpnId>,\n+    containers_deriving_copy: FxHashSet<LocalExpnId>,\n     /// Parent scopes in which the macros were invoked.\n     /// FIXME: `derives` are missing in these parent scopes and need to be taken from elsewhere.\n-    invocation_parent_scopes: FxHashMap<ExpnId, ParentScope<'a>>,\n+    invocation_parent_scopes: FxHashMap<LocalExpnId, ParentScope<'a>>,\n     /// `macro_rules` scopes *produced* by expanding the macro invocations,\n     /// include all the `macro_rules` items and other invocations generated by them.\n-    output_macro_rules_scopes: FxHashMap<ExpnId, MacroRulesScopeRef<'a>>,\n+    output_macro_rules_scopes: FxHashMap<LocalExpnId, MacroRulesScopeRef<'a>>,\n     /// Helper attributes that are in scope for the given expansion.\n-    helper_attrs: FxHashMap<ExpnId, Vec<Ident>>,\n+    helper_attrs: FxHashMap<LocalExpnId, Vec<Ident>>,\n     /// Ready or in-progress results of resolving paths inside the `#[derive(...)]` attribute\n     /// with the given `ExpnId`.\n-    derive_data: FxHashMap<ExpnId, DeriveData>,\n+    derive_data: FxHashMap<LocalExpnId, DeriveData>,\n \n     /// Avoid duplicated errors for \"name already defined\".\n     name_already_seen: FxHashMap<Symbol, Span>,\n@@ -1018,7 +1022,7 @@ pub struct Resolver<'a> {\n     /// When collecting definitions from an AST fragment produced by a macro invocation `ExpnId`\n     /// we know what parent node that fragment should be attached to thanks to this table,\n     /// and how the `impl Trait` fragments were introduced.\n-    invocation_parents: FxHashMap<ExpnId, (LocalDefId, ImplTraitContext)>,\n+    invocation_parents: FxHashMap<LocalExpnId, (LocalDefId, ImplTraitContext)>,\n \n     next_disambiguator: FxHashMap<(LocalDefId, DefPathData), u32>,\n     /// Some way to know that we are in a *trait* impl in `visit_assoc_item`.\n@@ -1268,7 +1272,7 @@ impl<'a> Resolver<'a> {\n         node_id_to_def_id.insert(CRATE_NODE_ID, root);\n \n         let mut invocation_parents = FxHashMap::default();\n-        invocation_parents.insert(ExpnId::root(), (root, ImplTraitContext::Existential));\n+        invocation_parents.insert(LocalExpnId::ROOT, (root, ImplTraitContext::Existential));\n \n         let mut extern_prelude: FxHashMap<Ident, ExternPreludeEntry<'_>> = session\n             .opts\n@@ -1342,7 +1346,7 @@ impl<'a> Resolver<'a> {\n             dummy_binding: arenas.alloc_name_binding(NameBinding {\n                 kind: NameBindingKind::Res(Res::Err, false),\n                 ambiguity: None,\n-                expansion: ExpnId::root(),\n+                expansion: LocalExpnId::ROOT,\n                 span: DUMMY_SP,\n                 vis: ty::Visibility::Public,\n             }),\n@@ -1392,7 +1396,7 @@ impl<'a> Resolver<'a> {\n         };\n \n         let root_parent_scope = ParentScope::module(graph_root, &resolver);\n-        resolver.invocation_parent_scopes.insert(ExpnId::root(), root_parent_scope);\n+        resolver.invocation_parent_scopes.insert(LocalExpnId::ROOT, root_parent_scope);\n \n         resolver\n     }\n@@ -1810,18 +1814,18 @@ impl<'a> Resolver<'a> {\n             }\n \n             scope = match scope {\n-                Scope::DeriveHelpers(expn_id) if expn_id != ExpnId::root() => {\n+                Scope::DeriveHelpers(LocalExpnId::ROOT) => Scope::DeriveHelpersCompat,\n+                Scope::DeriveHelpers(expn_id) => {\n                     // Derive helpers are not visible to code generated by bang or derive macros.\n                     let expn_data = expn_id.expn_data();\n                     match expn_data.kind {\n                         ExpnKind::Root\n                         | ExpnKind::Macro(MacroKind::Bang | MacroKind::Derive, _) => {\n                             Scope::DeriveHelpersCompat\n                         }\n-                        _ => Scope::DeriveHelpers(expn_data.parent),\n+                        _ => Scope::DeriveHelpers(expn_data.parent.expect_local()),\n                     }\n                 }\n-                Scope::DeriveHelpers(..) => Scope::DeriveHelpersCompat,\n                 Scope::DeriveHelpersCompat => Scope::MacroRules(parent_scope.macro_rules),\n                 Scope::MacroRules(macro_rules_scope) => match macro_rules_scope.get() {\n                     MacroRulesScope::Binding(binding) => {\n@@ -3248,7 +3252,7 @@ impl<'a> Resolver<'a> {\n                 };\n                 let crate_root = self.get_module(DefId { krate: crate_id, index: CRATE_DEF_INDEX });\n                 Some(\n-                    (crate_root, ty::Visibility::Public, DUMMY_SP, ExpnId::root())\n+                    (crate_root, ty::Visibility::Public, DUMMY_SP, LocalExpnId::ROOT)\n                         .to_name_binding(self.arenas),\n                 )\n             }"}, {"sha": "86f271fdeceb8796a61a5be8c72c23162f597cd8", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/68511b574ffe019a5cb3e9fa92605f80d39167bc/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68511b574ffe019a5cb3e9fa92605f80d39167bc/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=68511b574ffe019a5cb3e9fa92605f80d39167bc", "patch": "@@ -30,7 +30,7 @@ use rustc_session::lint::BuiltinLintDiagnostics;\n use rustc_session::parse::feature_err;\n use rustc_session::Session;\n use rustc_span::edition::Edition;\n-use rustc_span::hygiene::{self, ExpnData, ExpnId, ExpnKind};\n+use rustc_span::hygiene::{self, ExpnData, ExpnKind, LocalExpnId};\n use rustc_span::hygiene::{AstPass, MacroKind};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n@@ -62,7 +62,7 @@ pub enum MacroRulesScope<'a> {\n     Binding(&'a MacroRulesBinding<'a>),\n     /// The scope introduced by a macro invocation that can potentially\n     /// create a `macro_rules!` macro definition.\n-    Invocation(ExpnId),\n+    Invocation(LocalExpnId),\n }\n \n /// `macro_rules!` scopes are always kept by reference and inside a cell.\n@@ -190,7 +190,11 @@ impl<'a> ResolverExpand for Resolver<'a> {\n         });\n     }\n \n-    fn visit_ast_fragment_with_placeholders(&mut self, expansion: ExpnId, fragment: &AstFragment) {\n+    fn visit_ast_fragment_with_placeholders(\n+        &mut self,\n+        expansion: LocalExpnId,\n+        fragment: &AstFragment,\n+    ) {\n         // Integrate the new AST fragment into all the definition and module structures.\n         // We are inside the `expansion` now, but other parent scope components are still the same.\n         let parent_scope = ParentScope { expansion, ..self.invocation_parent_scopes[&expansion] };\n@@ -216,9 +220,9 @@ impl<'a> ResolverExpand for Resolver<'a> {\n         pass: AstPass,\n         features: &[Symbol],\n         parent_module_id: Option<NodeId>,\n-    ) -> ExpnId {\n+    ) -> LocalExpnId {\n         let parent_module = parent_module_id.map(|module_id| self.local_def_id(module_id));\n-        let expn_id = ExpnId::fresh(\n+        let expn_id = LocalExpnId::fresh(\n             ExpnData::allow_unstable(\n                 ExpnKind::AstPass(pass),\n                 call_site,\n@@ -244,7 +248,7 @@ impl<'a> ResolverExpand for Resolver<'a> {\n     fn resolve_macro_invocation(\n         &mut self,\n         invoc: &Invocation,\n-        eager_expansion_root: ExpnId,\n+        eager_expansion_root: LocalExpnId,\n         force: bool,\n     ) -> Result<Lrc<SyntaxExtension>, Indeterminate> {\n         let invoc_id = invoc.expansion_data.id;\n@@ -328,7 +332,7 @@ impl<'a> ResolverExpand for Resolver<'a> {\n                             | ExpnKind::Macro(MacroKind::Bang | MacroKind::Derive, _) => {\n                                 break;\n                             }\n-                            _ => expn_id = expn_data.parent,\n+                            _ => expn_id = expn_data.parent.expect_local(),\n                         }\n                     }\n                 }\n@@ -344,21 +348,21 @@ impl<'a> ResolverExpand for Resolver<'a> {\n         }\n     }\n \n-    fn lint_node_id(&self, expn_id: ExpnId) -> NodeId {\n+    fn lint_node_id(&self, expn_id: LocalExpnId) -> NodeId {\n         // FIXME - make this more precise. This currently returns the NodeId of the\n         // nearest closing item - we should try to return the closest parent of the ExpnId\n         self.invocation_parents\n             .get(&expn_id)\n             .map_or(ast::CRATE_NODE_ID, |id| self.def_id_to_node_id[id.0])\n     }\n \n-    fn has_derive_copy(&self, expn_id: ExpnId) -> bool {\n+    fn has_derive_copy(&self, expn_id: LocalExpnId) -> bool {\n         self.containers_deriving_copy.contains(&expn_id)\n     }\n \n     fn resolve_derives(\n         &mut self,\n-        expn_id: ExpnId,\n+        expn_id: LocalExpnId,\n         force: bool,\n         derive_paths: &dyn Fn() -> DeriveResolutions,\n     ) -> Result<(), Indeterminate> {\n@@ -423,15 +427,19 @@ impl<'a> ResolverExpand for Resolver<'a> {\n         Ok(())\n     }\n \n-    fn take_derive_resolutions(&mut self, expn_id: ExpnId) -> Option<DeriveResolutions> {\n+    fn take_derive_resolutions(&mut self, expn_id: LocalExpnId) -> Option<DeriveResolutions> {\n         self.derive_data.remove(&expn_id).map(|data| data.resolutions)\n     }\n \n     // The function that implements the resolution logic of `#[cfg_accessible(path)]`.\n     // Returns true if the path can certainly be resolved in one of three namespaces,\n     // returns false if the path certainly cannot be resolved in any of the three namespaces.\n     // Returns `Indeterminate` if we cannot give a certain answer yet.\n-    fn cfg_accessible(&mut self, expn_id: ExpnId, path: &ast::Path) -> Result<bool, Indeterminate> {\n+    fn cfg_accessible(\n+        &mut self,\n+        expn_id: LocalExpnId,\n+        path: &ast::Path,\n+    ) -> Result<bool, Indeterminate> {\n         let span = path.span;\n         let path = &Segment::from_path(path);\n         let parent_scope = self.invocation_parent_scopes[&expn_id];\n@@ -714,7 +722,8 @@ impl<'a> Resolver<'a> {\n                 let ident = Ident::new(orig_ident.name, orig_ident.span.with_ctxt(ctxt));\n                 let ok = |res, span, arenas| {\n                     Ok((\n-                        (res, ty::Visibility::Public, span, ExpnId::root()).to_name_binding(arenas),\n+                        (res, ty::Visibility::Public, span, LocalExpnId::ROOT)\n+                            .to_name_binding(arenas),\n                         Flags::empty(),\n                     ))\n                 };"}, {"sha": "64baf94cc00631047475a4c5443751b23d209e62", "filename": "compiler/rustc_span/src/def_id.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68511b574ffe019a5cb3e9fa92605f80d39167bc/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68511b574ffe019a5cb3e9fa92605f80d39167bc/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs?ref=68511b574ffe019a5cb3e9fa92605f80d39167bc", "patch": "@@ -136,7 +136,7 @@ impl Borrow<Fingerprint> for DefPathHash {\n /// further trouble.\n #[derive(Copy, Clone, Hash, PartialEq, Eq, PartialOrd, Ord, Debug)]\n #[derive(HashStable_Generic, Encodable, Decodable)]\n-pub struct StableCrateId(u64);\n+pub struct StableCrateId(pub(crate) u64);\n \n impl StableCrateId {\n     pub fn to_u64(self) -> u64 {"}, {"sha": "cb3a08439d1290bc4940186d3759415a594e5dd3", "filename": "compiler/rustc_span/src/hygiene.rs", "status": "modified", "additions": 278, "deletions": 213, "changes": 491, "blob_url": "https://github.com/rust-lang/rust/blob/68511b574ffe019a5cb3e9fa92605f80d39167bc/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68511b574ffe019a5cb3e9fa92605f80d39167bc/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs?ref=68511b574ffe019a5cb3e9fa92605f80d39167bc", "patch": "@@ -29,12 +29,13 @@ use crate::symbol::{kw, sym, Symbol};\n use crate::with_session_globals;\n use crate::{HashStableContext, Span, DUMMY_SP};\n \n-use crate::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use crate::def_id::{CrateNum, DefId, StableCrateId, CRATE_DEF_ID, LOCAL_CRATE};\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::{Lock, Lrc};\n use rustc_data_structures::unhash::UnhashMap;\n+use rustc_index::vec::IndexVec;\n use rustc_macros::HashStable_Generic;\n use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n use std::fmt;\n@@ -58,14 +59,67 @@ pub struct SyntaxContextData {\n     dollar_crate_name: Symbol,\n }\n \n+rustc_index::newtype_index! {\n+    /// A unique ID associated with a macro invocation and expansion.\n+    pub struct ExpnIndex {\n+        ENCODABLE = custom\n+    }\n+}\n+\n /// A unique ID associated with a macro invocation and expansion.\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n-pub struct ExpnId(u32);\n+#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct ExpnId {\n+    pub krate: CrateNum,\n+    pub local_id: ExpnIndex,\n+}\n+\n+impl fmt::Debug for ExpnId {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        // Generate crate_::{{expn_}}.\n+        write!(f, \"{:?}::{{{{expn{}}}}}\", self.krate, self.local_id.private)\n+    }\n+}\n+\n+rustc_index::newtype_index! {\n+    /// A unique ID associated with a macro invocation and expansion.\n+    pub struct LocalExpnId {\n+        ENCODABLE = custom\n+        DEBUG_FORMAT = \"expn{}\"\n+    }\n+}\n \n /// A unique hash value associated to an expansion.\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, Encodable, Decodable, HashStable_Generic)]\n pub struct ExpnHash(Fingerprint);\n \n+impl ExpnHash {\n+    /// Returns the [StableCrateId] identifying the crate this [ExpnHash]\n+    /// originates from.\n+    #[inline]\n+    pub fn stable_crate_id(self) -> StableCrateId {\n+        StableCrateId(self.0.as_value().0)\n+    }\n+\n+    /// Returns the crate-local part of the [ExpnHash].\n+    ///\n+    /// Used for tests.\n+    #[inline]\n+    pub fn local_hash(self) -> u64 {\n+        self.0.as_value().1\n+    }\n+\n+    #[inline]\n+    pub fn is_root(self) -> bool {\n+        self.0 == Fingerprint::ZERO\n+    }\n+\n+    /// Builds a new [ExpnHash] with the given [StableCrateId] and\n+    /// `local_hash`, where `local_hash` must be unique within its crate.\n+    fn new(stable_crate_id: StableCrateId, local_hash: u64) -> ExpnHash {\n+        ExpnHash(Fingerprint::new(stable_crate_id.0, local_hash))\n+    }\n+}\n+\n /// A property of a macro expansion that determines how identifiers\n /// produced by that expansion are resolved.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Hash, Debug, Encodable, Decodable)]\n@@ -86,31 +140,102 @@ pub enum Transparency {\n     Opaque,\n }\n \n-impl ExpnId {\n-    pub fn fresh_empty() -> Self {\n-        HygieneData::with(|data| data.fresh_expn(None))\n+impl LocalExpnId {\n+    /// The ID of the theoretical expansion that generates freshly parsed, unexpanded AST.\n+    pub const ROOT: LocalExpnId = LocalExpnId::from_u32(0);\n+\n+    pub fn from_raw(idx: ExpnIndex) -> LocalExpnId {\n+        LocalExpnId::from_u32(idx.as_u32())\n     }\n \n-    pub fn fresh(expn_data: ExpnData, ctx: impl HashStableContext) -> Self {\n-        let expn_id = HygieneData::with(|data| data.fresh_expn(Some(expn_data)));\n-        update_disambiguator(expn_id, ctx);\n-        expn_id\n+    pub fn as_raw(self) -> ExpnIndex {\n+        ExpnIndex::from_u32(self.as_u32())\n+    }\n+\n+    pub fn fresh_empty() -> LocalExpnId {\n+        HygieneData::with(|data| {\n+            let expn_id = data.local_expn_data.push(None);\n+            let _eid = data.local_expn_hashes.push(ExpnHash(Fingerprint::ZERO));\n+            debug_assert_eq!(expn_id, _eid);\n+            expn_id\n+        })\n+    }\n+\n+    pub fn fresh(mut expn_data: ExpnData, ctx: impl HashStableContext) -> LocalExpnId {\n+        debug_assert_eq!(expn_data.parent.krate, LOCAL_CRATE);\n+        let expn_hash = update_disambiguator(&mut expn_data, ctx);\n+        HygieneData::with(|data| {\n+            let expn_id = data.local_expn_data.push(Some(expn_data));\n+            let _eid = data.local_expn_hashes.push(expn_hash);\n+            debug_assert_eq!(expn_id, _eid);\n+            let _old_id = data.expn_hash_to_expn_id.insert(expn_hash, expn_id.to_expn_id());\n+            debug_assert!(_old_id.is_none());\n+            expn_id\n+        })\n     }\n \n-    /// The ID of the theoretical expansion that generates freshly parsed, unexpanded AST.\n     #[inline]\n-    pub fn root() -> Self {\n-        ExpnId(0)\n+    pub fn expn_hash(self) -> ExpnHash {\n+        HygieneData::with(|data| data.local_expn_hash(self))\n     }\n \n     #[inline]\n-    pub fn as_u32(self) -> u32 {\n-        self.0\n+    pub fn expn_data(self) -> ExpnData {\n+        HygieneData::with(|data| data.local_expn_data(self).clone())\n+    }\n+\n+    #[inline]\n+    pub fn to_expn_id(self) -> ExpnId {\n+        ExpnId { krate: LOCAL_CRATE, local_id: self.as_raw() }\n+    }\n+\n+    #[inline]\n+    pub fn set_expn_data(self, mut expn_data: ExpnData, ctx: impl HashStableContext) {\n+        debug_assert_eq!(expn_data.parent.krate, LOCAL_CRATE);\n+        let expn_hash = update_disambiguator(&mut expn_data, ctx);\n+        HygieneData::with(|data| {\n+            let old_expn_data = &mut data.local_expn_data[self];\n+            assert!(old_expn_data.is_none(), \"expansion data is reset for an expansion ID\");\n+            *old_expn_data = Some(expn_data);\n+            debug_assert_eq!(data.local_expn_hashes[self].0, Fingerprint::ZERO);\n+            data.local_expn_hashes[self] = expn_hash;\n+            let _old_id = data.expn_hash_to_expn_id.insert(expn_hash, self.to_expn_id());\n+            debug_assert!(_old_id.is_none());\n+        });\n     }\n \n     #[inline]\n-    pub fn from_u32(raw: u32) -> ExpnId {\n-        ExpnId(raw)\n+    pub fn is_descendant_of(self, ancestor: LocalExpnId) -> bool {\n+        self.to_expn_id().is_descendant_of(ancestor.to_expn_id())\n+    }\n+\n+    /// `expn_id.outer_expn_is_descendant_of(ctxt)` is equivalent to but faster than\n+    /// `expn_id.is_descendant_of(ctxt.outer_expn())`.\n+    #[inline]\n+    pub fn outer_expn_is_descendant_of(self, ctxt: SyntaxContext) -> bool {\n+        self.to_expn_id().outer_expn_is_descendant_of(ctxt)\n+    }\n+\n+    /// Returns span for the macro which originally caused this expansion to happen.\n+    ///\n+    /// Stops backtracing at include! boundary.\n+    #[inline]\n+    pub fn expansion_cause(self) -> Option<Span> {\n+        self.to_expn_id().expansion_cause()\n+    }\n+\n+    #[inline]\n+    #[track_caller]\n+    pub fn parent(self) -> LocalExpnId {\n+        self.expn_data().parent.as_local().unwrap()\n+    }\n+}\n+\n+impl ExpnId {\n+    /// The ID of the theoretical expansion that generates freshly parsed, unexpanded AST.\n+    /// Invariant: we do not create any ExpnId with local_id == 0 and krate != 0.\n+    pub const fn root() -> ExpnId {\n+        ExpnId { krate: LOCAL_CRATE, local_id: ExpnIndex::from_u32(0) }\n     }\n \n     #[inline]\n@@ -124,20 +249,19 @@ impl ExpnId {\n     }\n \n     #[inline]\n-    pub fn expn_data(self) -> ExpnData {\n-        HygieneData::with(|data| data.expn_data(self).clone())\n+    pub fn as_local(self) -> Option<LocalExpnId> {\n+        if self.krate == LOCAL_CRATE { Some(LocalExpnId::from_raw(self.local_id)) } else { None }\n     }\n \n     #[inline]\n-    pub fn set_expn_data(self, mut expn_data: ExpnData, ctx: impl HashStableContext) {\n-        HygieneData::with(|data| {\n-            let old_expn_data = &mut data.expn_data[self.0 as usize];\n-            assert!(old_expn_data.is_none(), \"expansion data is reset for an expansion ID\");\n-            assert_eq!(expn_data.orig_id, None);\n-            expn_data.orig_id = Some(self.as_u32());\n-            *old_expn_data = Some(expn_data);\n-        });\n-        update_disambiguator(self, ctx)\n+    #[track_caller]\n+    pub fn expect_local(self) -> LocalExpnId {\n+        self.as_local().unwrap()\n+    }\n+\n+    #[inline]\n+    pub fn expn_data(self) -> ExpnData {\n+        HygieneData::with(|data| data.expn_data(self).clone())\n     }\n \n     pub fn is_descendant_of(self, ancestor: ExpnId) -> bool {\n@@ -175,34 +299,39 @@ pub struct HygieneData {\n     /// Each expansion should have an associated expansion data, but sometimes there's a delay\n     /// between creation of an expansion ID and obtaining its data (e.g. macros are collected\n     /// first and then resolved later), so we use an `Option` here.\n-    expn_data: Vec<Option<ExpnData>>,\n-    expn_hashes: Vec<ExpnHash>,\n+    local_expn_data: IndexVec<LocalExpnId, Option<ExpnData>>,\n+    local_expn_hashes: IndexVec<LocalExpnId, ExpnHash>,\n+    /// Data and hash information from external crates.  We may eventually want to remove these\n+    /// maps, and fetch the information directly from the other crate's metadata like DefIds do.\n+    foreign_expn_data: FxHashMap<ExpnId, ExpnData>,\n+    foreign_expn_hashes: FxHashMap<ExpnId, ExpnHash>,\n     expn_hash_to_expn_id: UnhashMap<ExpnHash, ExpnId>,\n     syntax_context_data: Vec<SyntaxContextData>,\n     syntax_context_map: FxHashMap<(SyntaxContext, ExpnId, Transparency), SyntaxContext>,\n-    /// Maps the `Fingerprint` of an `ExpnData` to the next disambiguator value.\n+    /// Maps the `local_hash` of an `ExpnData` to the next disambiguator value.\n     /// This is used by `update_disambiguator` to keep track of which `ExpnData`s\n     /// would have collisions without a disambiguator.\n     /// The keys of this map are always computed with `ExpnData.disambiguator`\n     /// set to 0.\n-    expn_data_disambiguators: FxHashMap<Fingerprint, u32>,\n+    expn_data_disambiguators: FxHashMap<u64, u32>,\n }\n \n impl HygieneData {\n     crate fn new(edition: Edition) -> Self {\n-        let mut root_data = ExpnData::default(\n+        let root_data = ExpnData::default(\n             ExpnKind::Root,\n             DUMMY_SP,\n             edition,\n-            Some(DefId::local(CRATE_DEF_INDEX)),\n+            Some(CRATE_DEF_ID.to_def_id()),\n             None,\n         );\n-        root_data.orig_id = Some(0);\n \n         HygieneData {\n-            expn_data: vec![Some(root_data)],\n-            expn_hashes: vec![ExpnHash(Fingerprint::ZERO)],\n-            expn_hash_to_expn_id: std::iter::once((ExpnHash(Fingerprint::ZERO), ExpnId(0)))\n+            local_expn_data: IndexVec::from_elem_n(Some(root_data), 1),\n+            local_expn_hashes: IndexVec::from_elem_n(ExpnHash(Fingerprint::ZERO), 1),\n+            foreign_expn_data: FxHashMap::default(),\n+            foreign_expn_hashes: FxHashMap::default(),\n+            expn_hash_to_expn_id: std::iter::once((ExpnHash(Fingerprint::ZERO), ExpnId::root()))\n                 .collect(),\n             syntax_context_data: vec![SyntaxContextData {\n                 outer_expn: ExpnId::root(),\n@@ -221,24 +350,29 @@ impl HygieneData {\n         with_session_globals(|session_globals| f(&mut *session_globals.hygiene_data.borrow_mut()))\n     }\n \n-    fn fresh_expn(&mut self, mut expn_data: Option<ExpnData>) -> ExpnId {\n-        let raw_id = self.expn_data.len() as u32;\n-        if let Some(data) = expn_data.as_mut() {\n-            assert_eq!(data.orig_id, None);\n-            data.orig_id = Some(raw_id);\n-        }\n-        self.expn_data.push(expn_data);\n-        self.expn_hashes.push(ExpnHash(Fingerprint::ZERO));\n-        ExpnId(raw_id)\n+    #[inline]\n+    fn local_expn_hash(&self, expn_id: LocalExpnId) -> ExpnHash {\n+        self.local_expn_hashes[expn_id]\n     }\n \n     #[inline]\n     fn expn_hash(&self, expn_id: ExpnId) -> ExpnHash {\n-        self.expn_hashes[expn_id.0 as usize]\n+        match expn_id.as_local() {\n+            Some(expn_id) => self.local_expn_hashes[expn_id],\n+            None => self.foreign_expn_hashes[&expn_id],\n+        }\n+    }\n+\n+    fn local_expn_data(&self, expn_id: LocalExpnId) -> &ExpnData {\n+        self.local_expn_data[expn_id].as_ref().expect(\"no expansion data for an expansion ID\")\n     }\n \n     fn expn_data(&self, expn_id: ExpnId) -> &ExpnData {\n-        self.expn_data[expn_id.0 as usize].as_ref().expect(\"no expansion data for an expansion ID\")\n+        if let Some(expn_id) = expn_id.as_local() {\n+            self.local_expn_data[expn_id].as_ref().expect(\"no expansion data for an expansion ID\")\n+        } else {\n+            &self.foreign_expn_data[&expn_id]\n+        }\n     }\n \n     fn is_descendant_of(&self, mut expn_id: ExpnId, ancestor: ExpnId) -> bool {\n@@ -453,17 +587,21 @@ pub fn debug_hygiene_data(verbose: bool) -> String {\n         } else {\n             let mut s = String::from(\"\");\n             s.push_str(\"Expansions:\");\n-            data.expn_data.iter().enumerate().for_each(|(id, expn_info)| {\n-                let expn_info = expn_info.as_ref().expect(\"no expansion data for an expansion ID\");\n+            let mut debug_expn_data = |(id, expn_data): (&ExpnId, &ExpnData)| {\n                 s.push_str(&format!(\n-                    \"\\n{}: parent: {:?}, call_site_ctxt: {:?}, def_site_ctxt: {:?}, kind: {:?}\",\n+                    \"\\n{:?}: parent: {:?}, call_site_ctxt: {:?}, def_site_ctxt: {:?}, kind: {:?}\",\n                     id,\n-                    expn_info.parent,\n-                    expn_info.call_site.ctxt(),\n-                    expn_info.def_site.ctxt(),\n-                    expn_info.kind,\n-                ));\n+                    expn_data.parent,\n+                    expn_data.call_site.ctxt(),\n+                    expn_data.def_site.ctxt(),\n+                    expn_data.kind,\n+                ))\n+            };\n+            data.local_expn_data.iter_enumerated().for_each(|(id, expn_data)| {\n+                let expn_data = expn_data.as_ref().expect(\"no expansion data for an expansion ID\");\n+                debug_expn_data((&id.to_expn_id(), expn_data))\n             });\n+            data.foreign_expn_data.iter().for_each(debug_expn_data);\n             s.push_str(\"\\n\\nSyntaxContexts:\");\n             data.syntax_context_data.iter().enumerate().for_each(|(id, ctxt)| {\n                 s.push_str(&format!(\n@@ -696,7 +834,7 @@ impl Span {\n         transparency: Transparency,\n         ctx: impl HashStableContext,\n     ) -> Span {\n-        let expn_id = ExpnId::fresh(expn_data, ctx);\n+        let expn_id = LocalExpnId::fresh(expn_data, ctx).to_expn_id();\n         HygieneData::with(|data| {\n             self.with_ctxt(data.apply_mark(SyntaxContext::root(), expn_id, transparency))\n         })\n@@ -738,20 +876,6 @@ pub struct ExpnData {\n     /// call_site span would have its own ExpnData, with the call_site\n     /// pointing to the `foo!` invocation.\n     pub call_site: Span,\n-    /// The crate that originally created this `ExpnData`. During\n-    /// metadata serialization, we only encode `ExpnData`s that were\n-    /// created locally - when our serialized metadata is decoded,\n-    /// foreign `ExpnId`s will have their `ExpnData` looked up\n-    /// from the crate specified by `Crate\n-    krate: CrateNum,\n-    /// The raw that this `ExpnData` had in its original crate.\n-    /// An `ExpnData` can be created before being assigned an `ExpnId`,\n-    /// so this might be `None` until `set_expn_data` is called\n-    // This is used only for serialization/deserialization purposes:\n-    // two `ExpnData`s that differ only in their `orig_id` should\n-    // be considered equivalent.\n-    #[stable_hasher(ignore)]\n-    orig_id: Option<u32>,\n     /// Used to force two `ExpnData`s to have different `Fingerprint`s.\n     /// Due to macro expansion, it's possible to end up with two `ExpnId`s\n     /// that have identical `ExpnData`s. This violates the contract of `HashStable`\n@@ -790,7 +914,6 @@ pub struct ExpnData {\n     pub parent_module: Option<DefId>,\n }\n \n-// These would require special handling of `orig_id`.\n impl !PartialEq for ExpnData {}\n impl !Hash for ExpnData {}\n \n@@ -818,8 +941,6 @@ impl ExpnData {\n             edition,\n             macro_def_id,\n             parent_module,\n-            krate: LOCAL_CRATE,\n-            orig_id: None,\n             disambiguator: 0,\n         }\n     }\n@@ -843,8 +964,6 @@ impl ExpnData {\n             edition,\n             macro_def_id,\n             parent_module,\n-            krate: LOCAL_CRATE,\n-            orig_id: None,\n             disambiguator: 0,\n         }\n     }\n@@ -869,7 +988,7 @@ impl ExpnData {\n     }\n \n     #[inline]\n-    fn hash_expn(&self, ctx: &mut impl HashStableContext) -> Fingerprint {\n+    fn hash_expn(&self, ctx: &mut impl HashStableContext) -> u64 {\n         let mut hasher = StableHasher::new();\n         self.hash_stable(ctx, &mut hasher);\n         hasher.finish()\n@@ -1020,11 +1139,18 @@ pub struct HygieneEncodeContext {\n }\n \n impl HygieneEncodeContext {\n+    /// Record the fact that we need to serialize the corresponding `ExpnData`.\n+    pub fn schedule_expn_data_for_encoding(&self, expn: ExpnId) {\n+        if !self.serialized_expns.lock().contains(&expn) {\n+            self.latest_expns.lock().insert(expn);\n+        }\n+    }\n+\n     pub fn encode<T, R>(\n         &self,\n         encoder: &mut T,\n         mut encode_ctxt: impl FnMut(&mut T, u32, &SyntaxContextData) -> Result<(), R>,\n-        mut encode_expn: impl FnMut(&mut T, u32, ExpnData, ExpnHash) -> Result<(), R>,\n+        mut encode_expn: impl FnMut(&mut T, ExpnId, &ExpnData, ExpnHash) -> Result<(), R>,\n     ) -> Result<(), R> {\n         // When we serialize a `SyntaxContextData`, we may end up serializing\n         // a `SyntaxContext` that we haven't seen before\n@@ -1051,9 +1177,9 @@ impl HygieneEncodeContext {\n \n             let latest_expns = { std::mem::take(&mut *self.latest_expns.lock()) };\n \n-            for_all_expns_in(latest_expns.into_iter(), |index, expn, data, hash| {\n+            for_all_expns_in(latest_expns.into_iter(), |expn, data, hash| {\n                 if self.serialized_expns.lock().insert(expn) {\n-                    encode_expn(encoder, index, data, hash)?;\n+                    encode_expn(encoder, expn, data, hash)?;\n                 }\n                 Ok(())\n             })?;\n@@ -1072,78 +1198,70 @@ pub struct HygieneDecodeContext {\n     // so that multiple occurrences of the same serialized id are decoded to the same\n     // `SyntaxContext`\n     remapped_ctxts: Lock<Vec<Option<SyntaxContext>>>,\n-    // The same as `remapepd_ctxts`, but for `ExpnId`s\n-    remapped_expns: Lock<Vec<Option<ExpnId>>>,\n }\n \n-pub fn decode_expn_id<'a, D: Decoder, G>(\n-    d: &mut D,\n-    mode: ExpnDataDecodeMode<'a, G>,\n-    decode_data: impl FnOnce(&mut D, u32) -> Result<(ExpnData, ExpnHash), D::Error>,\n-) -> Result<ExpnId, D::Error>\n-where\n-    G: FnOnce(CrateNum) -> &'a HygieneDecodeContext,\n-{\n-    let index = u32::decode(d)?;\n-    let context = match mode {\n-        ExpnDataDecodeMode::IncrComp(context) => context,\n-        ExpnDataDecodeMode::Metadata(get_context) => {\n-            let krate = CrateNum::decode(d)?;\n-            get_context(krate)\n-        }\n-    };\n+/// Register an expansion which has been decoded from the on-disk-cache for the local crate.\n+pub fn register_local_expn_id(data: ExpnData, hash: ExpnHash) -> ExpnId {\n+    HygieneData::with(|hygiene_data| {\n+        let expn_id = hygiene_data.local_expn_data.next_index();\n+        hygiene_data.local_expn_data.push(Some(data));\n+        let _eid = hygiene_data.local_expn_hashes.push(hash);\n+        debug_assert_eq!(expn_id, _eid);\n \n-    // Do this after decoding, so that we decode a `CrateNum`\n-    // if necessary\n-    if index == ExpnId::root().as_u32() {\n+        let expn_id = expn_id.to_expn_id();\n+\n+        let _old_id = hygiene_data.expn_hash_to_expn_id.insert(hash, expn_id);\n+        debug_assert!(_old_id.is_none());\n+        expn_id\n+    })\n+}\n+\n+/// Register an expansion which has been decoded from the metadata of a foreign crate.\n+pub fn register_expn_id(\n+    krate: CrateNum,\n+    local_id: ExpnIndex,\n+    data: ExpnData,\n+    hash: ExpnHash,\n+) -> ExpnId {\n+    let expn_id = ExpnId { krate, local_id };\n+    HygieneData::with(|hygiene_data| {\n+        let _old_data = hygiene_data.foreign_expn_data.insert(expn_id, data);\n+        debug_assert!(_old_data.is_none());\n+        let _old_hash = hygiene_data.foreign_expn_hashes.insert(expn_id, hash);\n+        debug_assert!(_old_hash.is_none());\n+        let _old_id = hygiene_data.expn_hash_to_expn_id.insert(hash, expn_id);\n+        debug_assert!(_old_id.is_none());\n+    });\n+    expn_id\n+}\n+\n+/// Decode an expansion from the metadata of a foreign crate.\n+pub fn decode_expn_id(\n+    krate: CrateNum,\n+    index: u32,\n+    decode_data: impl FnOnce(ExpnId) -> (ExpnData, ExpnHash),\n+) -> ExpnId {\n+    if index == 0 {\n         debug!(\"decode_expn_id: deserialized root\");\n-        return Ok(ExpnId::root());\n+        return ExpnId::root();\n     }\n \n-    let outer_expns = &context.remapped_expns;\n+    let index = ExpnIndex::from_u32(index);\n \n-    // Ensure that the lock() temporary is dropped early\n-    {\n-        if let Some(expn_id) = outer_expns.lock().get(index as usize).copied().flatten() {\n-            return Ok(expn_id);\n-        }\n+    // This function is used to decode metadata, so it cannot decode information about LOCAL_CRATE.\n+    debug_assert_ne!(krate, LOCAL_CRATE);\n+    let expn_id = ExpnId { krate, local_id: index };\n+\n+    // Fast path if the expansion has already been decoded.\n+    if HygieneData::with(|hygiene_data| hygiene_data.foreign_expn_data.contains_key(&expn_id)) {\n+        return expn_id;\n     }\n \n     // Don't decode the data inside `HygieneData::with`, since we need to recursively decode\n     // other ExpnIds\n-    let (mut expn_data, hash) = decode_data(d, index)?;\n+    let (expn_data, hash) = decode_data(expn_id);\n \n-    let expn_id = HygieneData::with(|hygiene_data| {\n-        if let Some(&expn_id) = hygiene_data.expn_hash_to_expn_id.get(&hash) {\n-            return expn_id;\n-        }\n-\n-        let expn_id = ExpnId(hygiene_data.expn_data.len() as u32);\n-\n-        // If we just deserialized an `ExpnData` owned by\n-        // the local crate, its `orig_id` will be stale,\n-        // so we need to update it to its own value.\n-        // This only happens when we deserialize the incremental cache,\n-        // since a crate will never decode its own metadata.\n-        if expn_data.krate == LOCAL_CRATE {\n-            expn_data.orig_id = Some(expn_id.0);\n-        }\n-\n-        hygiene_data.expn_data.push(Some(expn_data));\n-        hygiene_data.expn_hashes.push(hash);\n-        let _old_id = hygiene_data.expn_hash_to_expn_id.insert(hash, expn_id);\n-        debug_assert!(_old_id.is_none());\n-\n-        let mut expns = outer_expns.lock();\n-        let new_len = index as usize + 1;\n-        if expns.len() < new_len {\n-            expns.resize(new_len, None);\n-        }\n-        expns[index as usize] = Some(expn_id);\n-        drop(expns);\n-        expn_id\n-    });\n-    Ok(expn_id)\n+    register_expn_id(krate, index, expn_data, hash)\n }\n \n // Decodes `SyntaxContext`, using the provided `HygieneDecodeContext`\n@@ -1234,29 +1352,37 @@ fn for_all_ctxts_in<E, F: FnMut(u32, SyntaxContext, &SyntaxContextData) -> Resul\n \n fn for_all_expns_in<E>(\n     expns: impl Iterator<Item = ExpnId>,\n-    mut f: impl FnMut(u32, ExpnId, ExpnData, ExpnHash) -> Result<(), E>,\n+    mut f: impl FnMut(ExpnId, &ExpnData, ExpnHash) -> Result<(), E>,\n ) -> Result<(), E> {\n     let all_data: Vec<_> = HygieneData::with(|data| {\n         expns\n-            .map(|expn| {\n-                let idx = expn.0 as usize;\n-                (expn, data.expn_data[idx].clone(), data.expn_hashes[idx].clone())\n-            })\n+            .map(|expn| (expn, data.expn_data(expn).clone(), data.expn_hash(expn).clone()))\n             .collect()\n     });\n     for (expn, data, hash) in all_data.into_iter() {\n-        let data = data.unwrap_or_else(|| panic!(\"Missing data for {:?}\", expn));\n-        f(expn.0, expn, data, hash)?;\n+        f(expn, &data, hash)?;\n     }\n     Ok(())\n }\n \n+impl<E: Encoder> Encodable<E> for LocalExpnId {\n+    fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n+        self.to_expn_id().encode(e)\n+    }\n+}\n+\n impl<E: Encoder> Encodable<E> for ExpnId {\n     default fn encode(&self, _: &mut E) -> Result<(), E::Error> {\n         panic!(\"cannot encode `ExpnId` with `{}`\", std::any::type_name::<E>());\n     }\n }\n \n+impl<D: Decoder> Decodable<D> for LocalExpnId {\n+    fn decode(d: &mut D) -> Result<Self, D::Error> {\n+        ExpnId::decode(d).map(ExpnId::expect_local)\n+    }\n+}\n+\n impl<D: Decoder> Decodable<D> for ExpnId {\n     default fn decode(_: &mut D) -> Result<Self, D::Error> {\n         panic!(\"cannot decode `ExpnId` with `{}`\", std::any::type_name::<D>());\n@@ -1274,58 +1400,6 @@ pub fn raw_encode_syntax_context<E: Encoder>(\n     ctxt.0.encode(e)\n }\n \n-pub fn raw_encode_expn_id<E: Encoder>(\n-    expn: ExpnId,\n-    context: &HygieneEncodeContext,\n-    mode: ExpnDataEncodeMode,\n-    e: &mut E,\n-) -> Result<(), E::Error> {\n-    // Record the fact that we need to serialize the corresponding\n-    // `ExpnData`\n-    let needs_data = || {\n-        if !context.serialized_expns.lock().contains(&expn) {\n-            context.latest_expns.lock().insert(expn);\n-        }\n-    };\n-\n-    match mode {\n-        ExpnDataEncodeMode::IncrComp => {\n-            // Always serialize the `ExpnData` in incr comp mode\n-            needs_data();\n-            expn.0.encode(e)\n-        }\n-        ExpnDataEncodeMode::Metadata => {\n-            let data = expn.expn_data();\n-            // We only need to serialize the ExpnData\n-            // if it comes from this crate.\n-            // We currently don't serialize any hygiene information data for\n-            // proc-macro crates: see the `SpecializedEncoder<Span>` impl\n-            // for crate metadata.\n-            if data.krate == LOCAL_CRATE {\n-                needs_data();\n-            }\n-            data.orig_id.expect(\"Missing orig_id\").encode(e)?;\n-            data.krate.encode(e)\n-        }\n-    }\n-}\n-\n-pub enum ExpnDataEncodeMode {\n-    IncrComp,\n-    Metadata,\n-}\n-\n-pub enum ExpnDataDecodeMode<'a, F: FnOnce(CrateNum) -> &'a HygieneDecodeContext> {\n-    IncrComp(&'a HygieneDecodeContext),\n-    Metadata(F),\n-}\n-\n-impl<'a> ExpnDataDecodeMode<'a, Box<dyn FnOnce(CrateNum) -> &'a HygieneDecodeContext>> {\n-    pub fn incr_comp(ctxt: &'a HygieneDecodeContext) -> Self {\n-        ExpnDataDecodeMode::IncrComp(ctxt)\n-    }\n-}\n-\n impl<E: Encoder> Encodable<E> for SyntaxContext {\n     default fn encode(&self, _: &mut E) -> Result<(), E::Error> {\n         panic!(\"cannot encode `SyntaxContext` with `{}`\", std::any::type_name::<E>());\n@@ -1345,10 +1419,9 @@ impl<D: Decoder> Decodable<D> for SyntaxContext {\n /// This method is called only when an `ExpnData` is first associated\n /// with an `ExpnId` (when the `ExpnId` is initially constructed, or via\n /// `set_expn_data`). It is *not* called for foreign `ExpnId`s deserialized\n-/// from another crate's metadata - since `ExpnData` includes a `krate` field,\n+/// from another crate's metadata - since `ExpnHash` includes the stable crate id,\n /// collisions are only possible between `ExpnId`s within the same crate.\n-fn update_disambiguator(expn_id: ExpnId, mut ctx: impl HashStableContext) {\n-    let mut expn_data = expn_id.expn_data();\n+fn update_disambiguator(expn_data: &mut ExpnData, mut ctx: impl HashStableContext) -> ExpnHash {\n     // This disambiguator should not have been set yet.\n     assert_eq!(\n         expn_data.disambiguator, 0,\n@@ -1367,8 +1440,7 @@ fn update_disambiguator(expn_id: ExpnId, mut ctx: impl HashStableContext) {\n     });\n \n     if disambiguator != 0 {\n-        debug!(\"Set disambiguator for {:?} (hash {:?})\", expn_id, expn_hash);\n-        debug!(\"expn_data = {:?}\", expn_data);\n+        debug!(\"Set disambiguator for expn_data={:?} expn_hash={:?}\", expn_data, expn_hash);\n \n         expn_data.disambiguator = disambiguator;\n         expn_hash = expn_data.hash_expn(&mut ctx);\n@@ -1384,14 +1456,7 @@ fn update_disambiguator(expn_id: ExpnId, mut ctx: impl HashStableContext) {\n         });\n     }\n \n-    let expn_hash = ExpnHash(expn_hash);\n-    HygieneData::with(|data| {\n-        data.expn_data[expn_id.0 as usize].as_mut().unwrap().disambiguator = disambiguator;\n-        debug_assert_eq!(data.expn_hashes[expn_id.0 as usize].0, Fingerprint::ZERO);\n-        data.expn_hashes[expn_id.0 as usize] = expn_hash;\n-        let _old_id = data.expn_hash_to_expn_id.insert(expn_hash, expn_id);\n-        debug_assert!(_old_id.is_none());\n-    });\n+    ExpnHash::new(ctx.def_path_hash(LOCAL_CRATE.as_def_id()).stable_crate_id(), expn_hash)\n }\n \n impl<CTX: HashStableContext> HashStable<CTX> for SyntaxContext {"}, {"sha": "1c95cc91208d36f2cd0a3c98e42a8e3db9027e03", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68511b574ffe019a5cb3e9fa92605f80d39167bc/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68511b574ffe019a5cb3e9fa92605f80d39167bc/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=68511b574ffe019a5cb3e9fa92605f80d39167bc", "patch": "@@ -38,7 +38,7 @@ use edition::Edition;\n pub mod hygiene;\n use hygiene::Transparency;\n pub use hygiene::{DesugaringKind, ExpnKind, ForLoopLoc, MacroKind};\n-pub use hygiene::{ExpnData, ExpnHash, ExpnId, SyntaxContext};\n+pub use hygiene::{ExpnData, ExpnHash, ExpnId, LocalExpnId, SyntaxContext};\n pub mod def_id;\n use def_id::{CrateNum, DefId, DefPathHash, LOCAL_CRATE};\n pub mod lev_distance;"}, {"sha": "ffb9f9eed41fb92a1f20c322c893dff491fbf900", "filename": "src/test/ui/hygiene/unpretty-debug.stdout", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/68511b574ffe019a5cb3e9fa92605f80d39167bc/src%2Ftest%2Fui%2Fhygiene%2Funpretty-debug.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/68511b574ffe019a5cb3e9fa92605f80d39167bc/src%2Ftest%2Fui%2Fhygiene%2Funpretty-debug.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Funpretty-debug.stdout?ref=68511b574ffe019a5cb3e9fa92605f80d39167bc", "patch": "@@ -19,10 +19,10 @@ fn y /* 0#0 */() { }\n \n /*\n Expansions:\n-0: parent: ExpnId(0), call_site_ctxt: #0, def_site_ctxt: #0, kind: Root\n-1: parent: ExpnId(0), call_site_ctxt: #0, def_site_ctxt: #0, kind: Macro(Bang, \"foo\")\n+crate0::{{expn0}}: parent: crate0::{{expn0}}, call_site_ctxt: #0, def_site_ctxt: #0, kind: Root\n+crate0::{{expn1}}: parent: crate0::{{expn0}}, call_site_ctxt: #0, def_site_ctxt: #0, kind: Macro(Bang, \"foo\")\n \n SyntaxContexts:\n-#0: parent: #0, outer_mark: (ExpnId(0), Opaque)\n-#1: parent: #0, outer_mark: (ExpnId(1), SemiTransparent)\n+#0: parent: #0, outer_mark: (crate0::{{expn0}}, Opaque)\n+#1: parent: #0, outer_mark: (crate0::{{expn1}}, SemiTransparent)\n */"}, {"sha": "2524d8273b705163512b431191dbee7ac7d4654e", "filename": "src/test/ui/proc-macro/meta-macro-hygiene.stdout", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/68511b574ffe019a5cb3e9fa92605f80d39167bc/src%2Ftest%2Fui%2Fproc-macro%2Fmeta-macro-hygiene.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/68511b574ffe019a5cb3e9fa92605f80d39167bc/src%2Ftest%2Fui%2Fproc-macro%2Fmeta-macro-hygiene.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fmeta-macro-hygiene.stdout?ref=68511b574ffe019a5cb3e9fa92605f80d39167bc", "patch": "@@ -43,23 +43,23 @@ fn main /* 0#0 */() { ; }\n \n /*\n Expansions:\n-0: parent: ExpnId(0), call_site_ctxt: #0, def_site_ctxt: #0, kind: Root\n-1: parent: ExpnId(0), call_site_ctxt: #0, def_site_ctxt: #0, kind: AstPass(StdImports)\n-2: parent: ExpnId(0), call_site_ctxt: #0, def_site_ctxt: #0, kind: Macro(Bang, \"produce_it\")\n-3: parent: ExpnId(0), call_site_ctxt: #0, def_site_ctxt: #0, kind: AstPass(StdImports)\n-4: parent: ExpnId(2), call_site_ctxt: #4, def_site_ctxt: #0, kind: Macro(Bang, \"meta_macro::print_def_site\")\n-5: parent: ExpnId(4), call_site_ctxt: #5, def_site_ctxt: #0, kind: Macro(Bang, \"$crate::dummy\")\n+crate0::{{expn0}}: parent: crate0::{{expn0}}, call_site_ctxt: #0, def_site_ctxt: #0, kind: Root\n+crate0::{{expn1}}: parent: crate0::{{expn0}}, call_site_ctxt: #0, def_site_ctxt: #0, kind: AstPass(StdImports)\n+crate0::{{expn2}}: parent: crate0::{{expn0}}, call_site_ctxt: #0, def_site_ctxt: #0, kind: Macro(Bang, \"produce_it\")\n+crate0::{{expn3}}: parent: crate0::{{expn2}}, call_site_ctxt: #4, def_site_ctxt: #0, kind: Macro(Bang, \"meta_macro::print_def_site\")\n+crate0::{{expn4}}: parent: crate0::{{expn3}}, call_site_ctxt: #5, def_site_ctxt: #0, kind: Macro(Bang, \"$crate::dummy\")\n+crate2::{{expn1}}: parent: crate0::{{expn0}}, call_site_ctxt: #0, def_site_ctxt: #0, kind: AstPass(StdImports)\n \n SyntaxContexts:\n-#0: parent: #0, outer_mark: (ExpnId(0), Opaque)\n-#1: parent: #0, outer_mark: (ExpnId(1), Opaque)\n-#2: parent: #0, outer_mark: (ExpnId(1), Transparent)\n-#3: parent: #0, outer_mark: (ExpnId(3), Opaque)\n-#4: parent: #0, outer_mark: (ExpnId(2), SemiTransparent)\n-#5: parent: #0, outer_mark: (ExpnId(4), Opaque)\n-#6: parent: #4, outer_mark: (ExpnId(4), Transparent)\n-#7: parent: #0, outer_mark: (ExpnId(4), SemiTransparent)\n-#8: parent: #0, outer_mark: (ExpnId(5), Opaque)\n-#9: parent: #5, outer_mark: (ExpnId(5), Transparent)\n-#10: parent: #5, outer_mark: (ExpnId(5), SemiTransparent)\n+#0: parent: #0, outer_mark: (crate0::{{expn0}}, Opaque)\n+#1: parent: #0, outer_mark: (crate0::{{expn1}}, Opaque)\n+#2: parent: #0, outer_mark: (crate0::{{expn1}}, Transparent)\n+#3: parent: #0, outer_mark: (crate2::{{expn1}}, Opaque)\n+#4: parent: #0, outer_mark: (crate0::{{expn2}}, SemiTransparent)\n+#5: parent: #0, outer_mark: (crate0::{{expn3}}, Opaque)\n+#6: parent: #4, outer_mark: (crate0::{{expn3}}, Transparent)\n+#7: parent: #0, outer_mark: (crate0::{{expn3}}, SemiTransparent)\n+#8: parent: #0, outer_mark: (crate0::{{expn4}}, Opaque)\n+#9: parent: #5, outer_mark: (crate0::{{expn4}}, Transparent)\n+#10: parent: #5, outer_mark: (crate0::{{expn4}}, SemiTransparent)\n */"}, {"sha": "b5ab82737e9b615acf22b524892f1bd223eeb0bd", "filename": "src/test/ui/proc-macro/nonterminal-token-hygiene.stdout", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/68511b574ffe019a5cb3e9fa92605f80d39167bc/src%2Ftest%2Fui%2Fproc-macro%2Fnonterminal-token-hygiene.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/68511b574ffe019a5cb3e9fa92605f80d39167bc/src%2Ftest%2Fui%2Fproc-macro%2Fnonterminal-token-hygiene.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fnonterminal-token-hygiene.stdout?ref=68511b574ffe019a5cb3e9fa92605f80d39167bc", "patch": "@@ -67,22 +67,22 @@ fn main /* 0#0 */() { }\n \n /*\n Expansions:\n-0: parent: ExpnId(0), call_site_ctxt: #0, def_site_ctxt: #0, kind: Root\n-1: parent: ExpnId(0), call_site_ctxt: #0, def_site_ctxt: #0, kind: AstPass(StdImports)\n-2: parent: ExpnId(0), call_site_ctxt: #0, def_site_ctxt: #0, kind: Macro(Bang, \"outer\")\n-3: parent: ExpnId(0), call_site_ctxt: #0, def_site_ctxt: #0, kind: AstPass(StdImports)\n-4: parent: ExpnId(2), call_site_ctxt: #4, def_site_ctxt: #4, kind: Macro(Bang, \"inner\")\n-5: parent: ExpnId(4), call_site_ctxt: #6, def_site_ctxt: #0, kind: Macro(Bang, \"print_bang\")\n+crate0::{{expn0}}: parent: crate0::{{expn0}}, call_site_ctxt: #0, def_site_ctxt: #0, kind: Root\n+crate0::{{expn1}}: parent: crate0::{{expn0}}, call_site_ctxt: #0, def_site_ctxt: #0, kind: AstPass(StdImports)\n+crate0::{{expn2}}: parent: crate0::{{expn0}}, call_site_ctxt: #0, def_site_ctxt: #0, kind: Macro(Bang, \"outer\")\n+crate0::{{expn3}}: parent: crate0::{{expn2}}, call_site_ctxt: #4, def_site_ctxt: #4, kind: Macro(Bang, \"inner\")\n+crate0::{{expn4}}: parent: crate0::{{expn3}}, call_site_ctxt: #6, def_site_ctxt: #0, kind: Macro(Bang, \"print_bang\")\n+crate2::{{expn1}}: parent: crate0::{{expn0}}, call_site_ctxt: #0, def_site_ctxt: #0, kind: AstPass(StdImports)\n \n SyntaxContexts:\n-#0: parent: #0, outer_mark: (ExpnId(0), Opaque)\n-#1: parent: #0, outer_mark: (ExpnId(1), Opaque)\n-#2: parent: #0, outer_mark: (ExpnId(1), Transparent)\n-#3: parent: #0, outer_mark: (ExpnId(3), Opaque)\n-#4: parent: #0, outer_mark: (ExpnId(2), SemiTransparent)\n-#5: parent: #0, outer_mark: (ExpnId(4), Opaque)\n-#6: parent: #4, outer_mark: (ExpnId(4), Opaque)\n-#7: parent: #0, outer_mark: (ExpnId(5), Opaque)\n-#8: parent: #6, outer_mark: (ExpnId(5), Transparent)\n-#9: parent: #5, outer_mark: (ExpnId(5), SemiTransparent)\n+#0: parent: #0, outer_mark: (crate0::{{expn0}}, Opaque)\n+#1: parent: #0, outer_mark: (crate0::{{expn1}}, Opaque)\n+#2: parent: #0, outer_mark: (crate0::{{expn1}}, Transparent)\n+#3: parent: #0, outer_mark: (crate2::{{expn1}}, Opaque)\n+#4: parent: #0, outer_mark: (crate0::{{expn2}}, SemiTransparent)\n+#5: parent: #0, outer_mark: (crate0::{{expn3}}, Opaque)\n+#6: parent: #4, outer_mark: (crate0::{{expn3}}, Opaque)\n+#7: parent: #0, outer_mark: (crate0::{{expn4}}, Opaque)\n+#8: parent: #6, outer_mark: (crate0::{{expn4}}, Transparent)\n+#9: parent: #5, outer_mark: (crate0::{{expn4}}, SemiTransparent)\n */"}, {"sha": "614cda5f911c2354bcb5e9ebac60d78e44941d2d", "filename": "src/tools/rustfmt/src/utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68511b574ffe019a5cb3e9fa92605f80d39167bc/src%2Ftools%2Frustfmt%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68511b574ffe019a5cb3e9fa92605f80d39167bc/src%2Ftools%2Frustfmt%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Futils.rs?ref=68511b574ffe019a5cb3e9fa92605f80d39167bc", "patch": "@@ -6,7 +6,7 @@ use rustc_ast::ast::{\n };\n use rustc_ast::ptr;\n use rustc_ast_pretty::pprust;\n-use rustc_span::{sym, symbol, BytePos, ExpnId, Span, Symbol, SyntaxContext};\n+use rustc_span::{sym, symbol, BytePos, LocalExpnId, Span, Symbol, SyntaxContext};\n use unicode_width::UnicodeWidthStr;\n \n use crate::comment::{filter_normal_code, CharClasses, FullCodeCharKind, LineClasses};\n@@ -675,7 +675,7 @@ pub(crate) trait NodeIdExt {\n \n impl NodeIdExt for NodeId {\n     fn root() -> NodeId {\n-        NodeId::placeholder_from_expn_id(ExpnId::root())\n+        NodeId::placeholder_from_expn_id(LocalExpnId::ROOT)\n     }\n }\n "}]}