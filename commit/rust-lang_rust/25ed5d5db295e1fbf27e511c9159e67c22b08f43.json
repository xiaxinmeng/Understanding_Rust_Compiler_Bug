{"sha": "25ed5d5db295e1fbf27e511c9159e67c22b08f43", "node_id": "C_kwDOAAsO6NoAKDI1ZWQ1ZDVkYjI5NWUxZmJmMjdlNTExYzkxNTllNjdjMjJiMDhmNDM", "commit": {"author": {"name": "Boxy", "email": "supbscripter@gmail.com", "date": "2022-10-06T06:00:38Z"}, "committer": {"name": "Boxy", "email": "supbscripter@gmail.com", "date": "2022-10-06T06:00:38Z"}, "message": "reviews", "tree": {"sha": "75784bb8e2795eccbd04cc7d152e16f08aeb4aef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/75784bb8e2795eccbd04cc7d152e16f08aeb4aef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/25ed5d5db295e1fbf27e511c9159e67c22b08f43", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/25ed5d5db295e1fbf27e511c9159e67c22b08f43", "html_url": "https://github.com/rust-lang/rust/commit/25ed5d5db295e1fbf27e511c9159e67c22b08f43", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/25ed5d5db295e1fbf27e511c9159e67c22b08f43/comments", "author": {"login": "BoxyUwU", "id": 21149742, "node_id": "MDQ6VXNlcjIxMTQ5NzQy", "avatar_url": "https://avatars.githubusercontent.com/u/21149742?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BoxyUwU", "html_url": "https://github.com/BoxyUwU", "followers_url": "https://api.github.com/users/BoxyUwU/followers", "following_url": "https://api.github.com/users/BoxyUwU/following{/other_user}", "gists_url": "https://api.github.com/users/BoxyUwU/gists{/gist_id}", "starred_url": "https://api.github.com/users/BoxyUwU/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BoxyUwU/subscriptions", "organizations_url": "https://api.github.com/users/BoxyUwU/orgs", "repos_url": "https://api.github.com/users/BoxyUwU/repos", "events_url": "https://api.github.com/users/BoxyUwU/events{/privacy}", "received_events_url": "https://api.github.com/users/BoxyUwU/received_events", "type": "User", "site_admin": false}, "committer": {"login": "BoxyUwU", "id": 21149742, "node_id": "MDQ6VXNlcjIxMTQ5NzQy", "avatar_url": "https://avatars.githubusercontent.com/u/21149742?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BoxyUwU", "html_url": "https://github.com/BoxyUwU", "followers_url": "https://api.github.com/users/BoxyUwU/followers", "following_url": "https://api.github.com/users/BoxyUwU/following{/other_user}", "gists_url": "https://api.github.com/users/BoxyUwU/gists{/gist_id}", "starred_url": "https://api.github.com/users/BoxyUwU/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BoxyUwU/subscriptions", "organizations_url": "https://api.github.com/users/BoxyUwU/orgs", "repos_url": "https://api.github.com/users/BoxyUwU/repos", "events_url": "https://api.github.com/users/BoxyUwU/events{/privacy}", "received_events_url": "https://api.github.com/users/BoxyUwU/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "611db1d3f397005199c9bd9ea70535da9d16bfcd", "url": "https://api.github.com/repos/rust-lang/rust/commits/611db1d3f397005199c9bd9ea70535da9d16bfcd", "html_url": "https://github.com/rust-lang/rust/commit/611db1d3f397005199c9bd9ea70535da9d16bfcd"}], "stats": {"total": 82, "additions": 41, "deletions": 41}, "files": [{"sha": "f331354a044e0c6cdf1b8b913a49d99133932ad2", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/25ed5d5db295e1fbf27e511c9159e67c22b08f43/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ed5d5db295e1fbf27e511c9159e67c22b08f43/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=25ed5d5db295e1fbf27e511c9159e67c22b08f43", "patch": "@@ -1044,7 +1044,6 @@ fn check_impl_items_against_trait<'tcx>(\n         let impl_item_full = tcx.hir().impl_item(impl_item.id);\n         match impl_item_full.kind {\n             hir::ImplItemKind::Const(..) => {\n-                // Find associated const definition.\n                 let _ = tcx.compare_assoc_const_impl_item_with_trait_item((\n                     impl_item.id.def_id.def_id,\n                     ty_impl_item.trait_item_def_id.unwrap(),"}, {"sha": "d006948c587939eb201b9f74f22f447e51195747", "filename": "compiler/rustc_hir_analysis/src/check/compare_method.rs", "status": "modified", "additions": 41, "deletions": 40, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/25ed5d5db295e1fbf27e511c9159e67c22b08f43/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ed5d5db295e1fbf27e511c9159e67c22b08f43/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=25ed5d5db295e1fbf27e511c9159e67c22b08f43", "patch": "@@ -1349,53 +1349,54 @@ pub(crate) fn raw_compare_const_impl<'tcx>(\n \n         debug!(\"compare_const_impl: trait_ty={:?}\", trait_ty);\n \n-        let maybe_error_reported = infcx\n+        let err = infcx\n             .at(&cause, param_env)\n             .sup(trait_ty, impl_ty)\n-            .map(|ok| ocx.register_infer_ok_obligations(ok))\n-            .map_err(|terr| {\n-                debug!(\n-                    \"checking associated const for compatibility: impl ty {:?}, trait ty {:?}\",\n-                    impl_ty, trait_ty\n-                );\n+            .map(|ok| ocx.register_infer_ok_obligations(ok));\n \n-                // Locate the Span containing just the type of the offending impl\n-                match tcx.hir().expect_impl_item(impl_const_item_def).kind {\n-                    ImplItemKind::Const(ref ty, _) => cause.span = ty.span,\n-                    _ => bug!(\"{:?} is not a impl const\", impl_const_item),\n-                }\n+        if let Err(terr) = err {\n+            debug!(\n+                \"checking associated const for compatibility: impl ty {:?}, trait ty {:?}\",\n+                impl_ty, trait_ty\n+            );\n \n-                let mut diag = struct_span_err!(\n-                    tcx.sess,\n-                    cause.span,\n-                    E0326,\n-                    \"implemented const `{}` has an incompatible type for trait\",\n-                    trait_const_item.name\n-                );\n+            // Locate the Span containing just the type of the offending impl\n+            match tcx.hir().expect_impl_item(impl_const_item_def).kind {\n+                ImplItemKind::Const(ref ty, _) => cause.span = ty.span,\n+                _ => bug!(\"{:?} is not a impl const\", impl_const_item),\n+            }\n \n-                let trait_c_span = trait_const_item_def.as_local().map(|trait_c_def_id| {\n-                    // Add a label to the Span containing just the type of the const\n-                    match tcx.hir().expect_trait_item(trait_c_def_id).kind {\n-                        TraitItemKind::Const(ref ty, _) => ty.span,\n-                        _ => bug!(\"{:?} is not a trait const\", trait_const_item),\n-                    }\n-                });\n+            let mut diag = struct_span_err!(\n+                tcx.sess,\n+                cause.span,\n+                E0326,\n+                \"implemented const `{}` has an incompatible type for trait\",\n+                trait_const_item.name\n+            );\n \n-                infcx.note_type_err(\n-                    &mut diag,\n-                    &cause,\n-                    trait_c_span.map(|span| (span, \"type in trait\".to_owned())),\n-                    Some(infer::ValuePairs::Terms(ExpectedFound {\n-                        expected: trait_ty.into(),\n-                        found: impl_ty.into(),\n-                    })),\n-                    terr,\n-                    false,\n-                    false,\n-                );\n-                diag.emit()\n+            let trait_c_span = trait_const_item_def.as_local().map(|trait_c_def_id| {\n+                // Add a label to the Span containing just the type of the const\n+                match tcx.hir().expect_trait_item(trait_c_def_id).kind {\n+                    TraitItemKind::Const(ref ty, _) => ty.span,\n+                    _ => bug!(\"{:?} is not a trait const\", trait_const_item),\n+                }\n             });\n \n+            infcx.note_type_err(\n+                &mut diag,\n+                &cause,\n+                trait_c_span.map(|span| (span, \"type in trait\".to_owned())),\n+                Some(infer::ValuePairs::Terms(ExpectedFound {\n+                    expected: trait_ty.into(),\n+                    found: impl_ty.into(),\n+                })),\n+                terr,\n+                false,\n+                false,\n+            );\n+            return Err(diag.emit());\n+        };\n+\n         // Check that all obligations are satisfied by the implementation's\n         // version.\n         let errors = ocx.select_all_or_error();\n@@ -1407,7 +1408,7 @@ pub(crate) fn raw_compare_const_impl<'tcx>(\n         let outlives_environment = OutlivesEnvironment::new(param_env);\n         infcx\n             .check_region_obligations_and_report_errors(impl_const_item_def, &outlives_environment);\n-        maybe_error_reported\n+        Ok(())\n     })\n }\n "}]}