{"sha": "50541b90e98d7c9e420f7a60f58da9caf48fd487", "node_id": "C_kwDOAAsO6NoAKDUwNTQxYjkwZTk4ZDdjOWU0MjBmN2E2MGY1OGRhOWNhZjQ4ZmQ0ODc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-08T14:03:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-08T14:03:50Z"}, "message": "Auto merge of #8950 - Jarcho:derive_non_pub, r=dswij\n\nFixes for `derive_partial_eq_without_eq`\n\nfixes  #8875\n\nchangelog: Don't lint `derive_partial_eq_without_eq` on non-public types\nchangelog: Better handle generics in `derive_partial_eq_without_eq`", "tree": {"sha": "25b6e21163b8d79df578e3b208d02935e27e0649", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/25b6e21163b8d79df578e3b208d02935e27e0649"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/50541b90e98d7c9e420f7a60f58da9caf48fd487", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/50541b90e98d7c9e420f7a60f58da9caf48fd487", "html_url": "https://github.com/rust-lang/rust/commit/50541b90e98d7c9e420f7a60f58da9caf48fd487", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/50541b90e98d7c9e420f7a60f58da9caf48fd487/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ab8c8c608128643d5710a632e6ef18fdfff19268", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab8c8c608128643d5710a632e6ef18fdfff19268", "html_url": "https://github.com/rust-lang/rust/commit/ab8c8c608128643d5710a632e6ef18fdfff19268"}, {"sha": "648dbebfb116e028ff77cb539634bfc1fcc7b256", "url": "https://api.github.com/repos/rust-lang/rust/commits/648dbebfb116e028ff77cb539634bfc1fcc7b256", "html_url": "https://github.com/rust-lang/rust/commit/648dbebfb116e028ff77cb539634bfc1fcc7b256"}], "stats": {"total": 239, "additions": 159, "deletions": 80}, "files": [{"sha": "28f218a8e344f1228585e75829795a9683580018", "filename": "clippy_lints/src/derive.rs", "status": "modified", "additions": 54, "deletions": 43, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/50541b90e98d7c9e420f7a60f58da9caf48fd487/clippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50541b90e98d7c9e420f7a60f58da9caf48fd487/clippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fderive.rs?ref=50541b90e98d7c9e420f7a60f58da9caf48fd487", "patch": "@@ -4,14 +4,19 @@ use clippy_utils::ty::{implements_trait, implements_trait_with_env, is_copy};\n use clippy_utils::{is_lint_allowed, match_def_path};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n+use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::{walk_expr, walk_fn, walk_item, FnKind, Visitor};\n use rustc_hir::{\n-    self as hir, BlockCheckMode, BodyId, Expr, ExprKind, FnDecl, HirId, Impl, Item, ItemKind, UnsafeSource, Unsafety,\n+    self as hir, BlockCheckMode, BodyId, Constness, Expr, ExprKind, FnDecl, HirId, Impl, Item, ItemKind, UnsafeSource,\n+    Unsafety,\n };\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::nested_filter;\n-use rustc_middle::ty::subst::GenericArg;\n-use rustc_middle::ty::{self, BoundConstness, ImplPolarity, ParamEnv, PredicateKind, TraitPredicate, TraitRef, Ty};\n+use rustc_middle::traits::Reveal;\n+use rustc_middle::ty::{\n+    self, Binder, BoundConstness, GenericParamDefKind, ImplPolarity, ParamEnv, PredicateKind, TraitPredicate, TraitRef,\n+    Ty, TyCtxt, Visibility,\n+};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n use rustc_span::sym;\n@@ -459,50 +464,18 @@ impl<'tcx> Visitor<'tcx> for UnsafeVisitor<'_, 'tcx> {\n fn check_partial_eq_without_eq<'tcx>(cx: &LateContext<'tcx>, span: Span, trait_ref: &hir::TraitRef<'_>, ty: Ty<'tcx>) {\n     if_chain! {\n         if let ty::Adt(adt, substs) = ty.kind();\n+        if cx.tcx.visibility(adt.did()) == Visibility::Public;\n         if let Some(eq_trait_def_id) = cx.tcx.get_diagnostic_item(sym::Eq);\n-        if let Some(peq_trait_def_id) = cx.tcx.get_diagnostic_item(sym::PartialEq);\n         if let Some(def_id) = trait_ref.trait_def_id();\n         if cx.tcx.is_diagnostic_item(sym::PartialEq, def_id);\n-        // New `ParamEnv` replacing `T: PartialEq` with `T: Eq`\n-        let param_env = ParamEnv::new(\n-            cx.tcx.mk_predicates(cx.param_env.caller_bounds().iter().map(|p| {\n-                let kind = p.kind();\n-                match kind.skip_binder() {\n-                    PredicateKind::Trait(p)\n-                        if p.trait_ref.def_id == peq_trait_def_id\n-                            && p.trait_ref.substs.get(0) == p.trait_ref.substs.get(1)\n-                            && matches!(p.trait_ref.self_ty().kind(), ty::Param(_))\n-                            && p.constness == BoundConstness::NotConst\n-                            && p.polarity == ImplPolarity::Positive =>\n-                    {\n-                        cx.tcx.mk_predicate(kind.rebind(PredicateKind::Trait(TraitPredicate {\n-                            trait_ref: TraitRef::new(\n-                                eq_trait_def_id,\n-                                cx.tcx.mk_substs([GenericArg::from(p.trait_ref.self_ty())].into_iter()),\n-                            ),\n-                            constness: BoundConstness::NotConst,\n-                            polarity: ImplPolarity::Positive,\n-                        })))\n-                    },\n-                    _ => p,\n-                }\n-            })),\n-            cx.param_env.reveal(),\n-            cx.param_env.constness(),\n-        );\n-        if !implements_trait_with_env(cx.tcx, param_env, ty, eq_trait_def_id, substs);\n+        let param_env = param_env_for_derived_eq(cx.tcx, adt.did(), eq_trait_def_id);\n+        if !implements_trait_with_env(cx.tcx, param_env, ty, eq_trait_def_id, &[]);\n+        // If all of our fields implement `Eq`, we can implement `Eq` too\n+        if adt\n+            .all_fields()\n+            .map(|f| f.ty(cx.tcx, substs))\n+            .all(|ty| implements_trait_with_env(cx.tcx, param_env, ty, eq_trait_def_id, &[]));\n         then {\n-            // If all of our fields implement `Eq`, we can implement `Eq` too\n-            for variant in adt.variants() {\n-                for field in &variant.fields {\n-                    let ty = field.ty(cx.tcx, substs);\n-\n-                    if !implements_trait(cx, ty, eq_trait_def_id, substs) {\n-                        return;\n-                    }\n-                }\n-            }\n-\n             span_lint_and_sugg(\n                 cx,\n                 DERIVE_PARTIAL_EQ_WITHOUT_EQ,\n@@ -515,3 +488,41 @@ fn check_partial_eq_without_eq<'tcx>(cx: &LateContext<'tcx>, span: Span, trait_r\n         }\n     }\n }\n+\n+/// Creates the `ParamEnv` used for the give type's derived `Eq` impl.\n+fn param_env_for_derived_eq(tcx: TyCtxt<'_>, did: DefId, eq_trait_id: DefId) -> ParamEnv<'_> {\n+    // Initial map from generic index to param def.\n+    // Vec<(param_def, needs_eq)>\n+    let mut params = tcx\n+        .generics_of(did)\n+        .params\n+        .iter()\n+        .map(|p| (p, matches!(p.kind, GenericParamDefKind::Type { .. })))\n+        .collect::<Vec<_>>();\n+\n+    let ty_predicates = tcx.predicates_of(did).predicates;\n+    for (p, _) in ty_predicates {\n+        if let PredicateKind::Trait(p) = p.kind().skip_binder()\n+            && p.trait_ref.def_id == eq_trait_id\n+            && let ty::Param(self_ty) = p.trait_ref.self_ty().kind()\n+            && p.constness == BoundConstness::NotConst\n+        {\n+            // Flag types which already have an `Eq` bound.\n+            params[self_ty.index as usize].1 = false;\n+        }\n+    }\n+\n+    ParamEnv::new(\n+        tcx.mk_predicates(ty_predicates.iter().map(|&(p, _)| p).chain(\n+            params.iter().filter(|&&(_, needs_eq)| needs_eq).map(|&(param, _)| {\n+                tcx.mk_predicate(Binder::dummy(PredicateKind::Trait(TraitPredicate {\n+                    trait_ref: TraitRef::new(eq_trait_id, tcx.mk_substs([tcx.mk_param_from_def(param)].into_iter())),\n+                    constness: BoundConstness::NotConst,\n+                    polarity: ImplPolarity::Positive,\n+                })))\n+            }),\n+        )),\n+        Reveal::UserFacing,\n+        Constness::NotConst,\n+    )\n+}"}, {"sha": "bbbe467590f91ae9f5530c87fe734761ab5599ad", "filename": "tests/ui/derive_partial_eq_without_eq.fixed", "status": "modified", "additions": 41, "deletions": 19, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/50541b90e98d7c9e420f7a60f58da9caf48fd487/tests%2Fui%2Fderive_partial_eq_without_eq.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/50541b90e98d7c9e420f7a60f58da9caf48fd487/tests%2Fui%2Fderive_partial_eq_without_eq.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderive_partial_eq_without_eq.fixed?ref=50541b90e98d7c9e420f7a60f58da9caf48fd487", "patch": "@@ -4,28 +4,28 @@\n #![warn(clippy::derive_partial_eq_without_eq)]\n \n // Don't warn on structs that aren't PartialEq\n-struct NotPartialEq {\n+pub struct NotPartialEq {\n     foo: u32,\n     bar: String,\n }\n \n // Eq can be derived but is missing\n #[derive(Debug, PartialEq, Eq)]\n-struct MissingEq {\n+pub struct MissingEq {\n     foo: u32,\n     bar: String,\n }\n \n // Eq is derived\n #[derive(PartialEq, Eq)]\n-struct NotMissingEq {\n+pub struct NotMissingEq {\n     foo: u32,\n     bar: String,\n }\n \n // Eq is manually implemented\n #[derive(PartialEq)]\n-struct ManualEqImpl {\n+pub struct ManualEqImpl {\n     foo: u32,\n     bar: String,\n }\n@@ -34,13 +34,13 @@ impl Eq for ManualEqImpl {}\n \n // Cannot be Eq because f32 isn't Eq\n #[derive(PartialEq)]\n-struct CannotBeEq {\n+pub struct CannotBeEq {\n     foo: u32,\n     bar: f32,\n }\n \n // Don't warn if PartialEq is manually implemented\n-struct ManualPartialEqImpl {\n+pub struct ManualPartialEqImpl {\n     foo: u32,\n     bar: String,\n }\n@@ -52,53 +52,75 @@ impl PartialEq for ManualPartialEqImpl {\n }\n \n // Generic fields should be properly checked for Eq-ness\n-#[derive(PartialEq)]\n-struct GenericNotEq<T: Eq, U: PartialEq> {\n+#[derive(PartialEq, Eq)]\n+pub struct GenericNotEq<T: Eq, U: PartialEq> {\n     foo: T,\n     bar: U,\n }\n \n #[derive(PartialEq, Eq)]\n-struct GenericEq<T: Eq, U: Eq> {\n+pub struct GenericEq<T: Eq, U: Eq> {\n     foo: T,\n     bar: U,\n }\n \n #[derive(PartialEq, Eq)]\n-struct TupleStruct(u32);\n+pub struct TupleStruct(u32);\n \n #[derive(PartialEq, Eq)]\n-struct GenericTupleStruct<T: Eq>(T);\n+pub struct GenericTupleStruct<T: Eq>(T);\n \n #[derive(PartialEq)]\n-struct TupleStructNotEq(f32);\n+pub struct TupleStructNotEq(f32);\n \n #[derive(PartialEq, Eq)]\n-enum Enum {\n+pub enum Enum {\n     Foo(u32),\n     Bar { a: String, b: () },\n }\n \n #[derive(PartialEq, Eq)]\n-enum GenericEnum<T: Eq, U: Eq, V: Eq> {\n+pub enum GenericEnum<T: Eq, U: Eq, V: Eq> {\n     Foo(T),\n     Bar { a: U, b: V },\n }\n \n #[derive(PartialEq)]\n-enum EnumNotEq {\n+pub enum EnumNotEq {\n     Foo(u32),\n     Bar { a: String, b: f32 },\n }\n \n // Ensure that rustfix works properly when `PartialEq` has other derives on either side\n #[derive(Debug, PartialEq, Eq, Clone)]\n-struct RustFixWithOtherDerives;\n+pub struct RustFixWithOtherDerives;\n \n-#[derive(PartialEq)]\n-struct Generic<T>(T);\n+#[derive(PartialEq, Eq)]\n+pub struct Generic<T>(T);\n \n #[derive(PartialEq, Eq)]\n-struct GenericPhantom<T>(core::marker::PhantomData<T>);\n+pub struct GenericPhantom<T>(core::marker::PhantomData<T>);\n+\n+mod _hidden {\n+    #[derive(PartialEq, Eq)]\n+    pub struct Reexported;\n+\n+    #[derive(PartialEq, Eq)]\n+    pub struct InPubFn;\n+\n+    #[derive(PartialEq)]\n+    pub(crate) struct PubCrate;\n+\n+    #[derive(PartialEq)]\n+    pub(super) struct PubSuper;\n+}\n+\n+pub use _hidden::Reexported;\n+pub fn _from_mod() -> _hidden::InPubFn {\n+    _hidden::InPubFn\n+}\n+\n+#[derive(PartialEq)]\n+struct InternalTy;\n \n fn main() {}"}, {"sha": "88d6fbd1af7e8bf3ca35f614e1022dcdaca00be2", "filename": "tests/ui/derive_partial_eq_without_eq.rs", "status": "modified", "additions": 39, "deletions": 17, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/50541b90e98d7c9e420f7a60f58da9caf48fd487/tests%2Fui%2Fderive_partial_eq_without_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50541b90e98d7c9e420f7a60f58da9caf48fd487/tests%2Fui%2Fderive_partial_eq_without_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderive_partial_eq_without_eq.rs?ref=50541b90e98d7c9e420f7a60f58da9caf48fd487", "patch": "@@ -4,28 +4,28 @@\n #![warn(clippy::derive_partial_eq_without_eq)]\n \n // Don't warn on structs that aren't PartialEq\n-struct NotPartialEq {\n+pub struct NotPartialEq {\n     foo: u32,\n     bar: String,\n }\n \n // Eq can be derived but is missing\n #[derive(Debug, PartialEq)]\n-struct MissingEq {\n+pub struct MissingEq {\n     foo: u32,\n     bar: String,\n }\n \n // Eq is derived\n #[derive(PartialEq, Eq)]\n-struct NotMissingEq {\n+pub struct NotMissingEq {\n     foo: u32,\n     bar: String,\n }\n \n // Eq is manually implemented\n #[derive(PartialEq)]\n-struct ManualEqImpl {\n+pub struct ManualEqImpl {\n     foo: u32,\n     bar: String,\n }\n@@ -34,13 +34,13 @@ impl Eq for ManualEqImpl {}\n \n // Cannot be Eq because f32 isn't Eq\n #[derive(PartialEq)]\n-struct CannotBeEq {\n+pub struct CannotBeEq {\n     foo: u32,\n     bar: f32,\n }\n \n // Don't warn if PartialEq is manually implemented\n-struct ManualPartialEqImpl {\n+pub struct ManualPartialEqImpl {\n     foo: u32,\n     bar: String,\n }\n@@ -53,52 +53,74 @@ impl PartialEq for ManualPartialEqImpl {\n \n // Generic fields should be properly checked for Eq-ness\n #[derive(PartialEq)]\n-struct GenericNotEq<T: Eq, U: PartialEq> {\n+pub struct GenericNotEq<T: Eq, U: PartialEq> {\n     foo: T,\n     bar: U,\n }\n \n #[derive(PartialEq)]\n-struct GenericEq<T: Eq, U: Eq> {\n+pub struct GenericEq<T: Eq, U: Eq> {\n     foo: T,\n     bar: U,\n }\n \n #[derive(PartialEq)]\n-struct TupleStruct(u32);\n+pub struct TupleStruct(u32);\n \n #[derive(PartialEq)]\n-struct GenericTupleStruct<T: Eq>(T);\n+pub struct GenericTupleStruct<T: Eq>(T);\n \n #[derive(PartialEq)]\n-struct TupleStructNotEq(f32);\n+pub struct TupleStructNotEq(f32);\n \n #[derive(PartialEq)]\n-enum Enum {\n+pub enum Enum {\n     Foo(u32),\n     Bar { a: String, b: () },\n }\n \n #[derive(PartialEq)]\n-enum GenericEnum<T: Eq, U: Eq, V: Eq> {\n+pub enum GenericEnum<T: Eq, U: Eq, V: Eq> {\n     Foo(T),\n     Bar { a: U, b: V },\n }\n \n #[derive(PartialEq)]\n-enum EnumNotEq {\n+pub enum EnumNotEq {\n     Foo(u32),\n     Bar { a: String, b: f32 },\n }\n \n // Ensure that rustfix works properly when `PartialEq` has other derives on either side\n #[derive(Debug, PartialEq, Clone)]\n-struct RustFixWithOtherDerives;\n+pub struct RustFixWithOtherDerives;\n \n #[derive(PartialEq)]\n-struct Generic<T>(T);\n+pub struct Generic<T>(T);\n \n #[derive(PartialEq, Eq)]\n-struct GenericPhantom<T>(core::marker::PhantomData<T>);\n+pub struct GenericPhantom<T>(core::marker::PhantomData<T>);\n+\n+mod _hidden {\n+    #[derive(PartialEq)]\n+    pub struct Reexported;\n+\n+    #[derive(PartialEq)]\n+    pub struct InPubFn;\n+\n+    #[derive(PartialEq)]\n+    pub(crate) struct PubCrate;\n+\n+    #[derive(PartialEq)]\n+    pub(super) struct PubSuper;\n+}\n+\n+pub use _hidden::Reexported;\n+pub fn _from_mod() -> _hidden::InPubFn {\n+    _hidden::InPubFn\n+}\n+\n+#[derive(PartialEq)]\n+struct InternalTy;\n \n fn main() {}"}, {"sha": "794c5dab8445bb1f11a91f5cdd6f0d4f56fc5237", "filename": "tests/ui/derive_partial_eq_without_eq.stderr", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/50541b90e98d7c9e420f7a60f58da9caf48fd487/tests%2Fui%2Fderive_partial_eq_without_eq.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50541b90e98d7c9e420f7a60f58da9caf48fd487/tests%2Fui%2Fderive_partial_eq_without_eq.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderive_partial_eq_without_eq.stderr?ref=50541b90e98d7c9e420f7a60f58da9caf48fd487", "patch": "@@ -6,6 +6,12 @@ LL | #[derive(Debug, PartialEq)]\n    |\n    = note: `-D clippy::derive-partial-eq-without-eq` implied by `-D warnings`\n \n+error: you are deriving `PartialEq` and can implement `Eq`\n+  --> $DIR/derive_partial_eq_without_eq.rs:55:10\n+   |\n+LL | #[derive(PartialEq)]\n+   |          ^^^^^^^^^ help: consider deriving `Eq` as well: `PartialEq, Eq`\n+\n error: you are deriving `PartialEq` and can implement `Eq`\n   --> $DIR/derive_partial_eq_without_eq.rs:61:10\n    |\n@@ -42,5 +48,23 @@ error: you are deriving `PartialEq` and can implement `Eq`\n LL | #[derive(Debug, PartialEq, Clone)]\n    |                 ^^^^^^^^^ help: consider deriving `Eq` as well: `PartialEq, Eq`\n \n-error: aborting due to 7 previous errors\n+error: you are deriving `PartialEq` and can implement `Eq`\n+  --> $DIR/derive_partial_eq_without_eq.rs:98:10\n+   |\n+LL | #[derive(PartialEq)]\n+   |          ^^^^^^^^^ help: consider deriving `Eq` as well: `PartialEq, Eq`\n+\n+error: you are deriving `PartialEq` and can implement `Eq`\n+  --> $DIR/derive_partial_eq_without_eq.rs:105:14\n+   |\n+LL |     #[derive(PartialEq)]\n+   |              ^^^^^^^^^ help: consider deriving `Eq` as well: `PartialEq, Eq`\n+\n+error: you are deriving `PartialEq` and can implement `Eq`\n+  --> $DIR/derive_partial_eq_without_eq.rs:108:14\n+   |\n+LL |     #[derive(PartialEq)]\n+   |              ^^^^^^^^^ help: consider deriving `Eq` as well: `PartialEq, Eq`\n+\n+error: aborting due to 11 previous errors\n "}]}