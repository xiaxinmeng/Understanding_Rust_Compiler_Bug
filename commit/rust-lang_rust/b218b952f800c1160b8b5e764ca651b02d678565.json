{"sha": "b218b952f800c1160b8b5e764ca651b02d678565", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyMThiOTUyZjgwMGMxMTYwYjhiNWU3NjRjYTY1MWIwMmQ2Nzg1NjU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-01T01:12:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-01T01:12:41Z"}, "message": "Auto merge of #77381 - Dylan-DPC:rollup-0sr6p5p, r=Dylan-DPC\n\nRollup of 12 pull requests\n\nSuccessful merges:\n\n - #76909 (Add Iterator::advance_by and DoubleEndedIterator::advance_back_by)\n - #77153 (Fix recursive nonterminal expansion during pretty-print/reparse check)\n - #77202 (Defer Apple SDKROOT detection to link time.)\n - #77303 (const evaluatable: improve `TooGeneric` handling)\n - #77305 (move candidate_from_obligation_no_cache)\n - #77315 (Rename AllocErr to AllocError)\n - #77319 (Stable hashing: add comments and tests concerning platform-independence)\n - #77324 (Don't fire `const_item_mutation` lint on writes through a pointer)\n - #77343 (Validate `rustc_args_required_const`)\n - #77349 (Update cargo)\n - #77360 (References to ZSTs may be at arbitrary aligned addresses)\n - #77371 (Remove trailing space in error message)\n\nFailed merges:\n\nr? `@ghost`", "tree": {"sha": "8ed2c1c87dd2db480114c44082a4f58c8922e94d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8ed2c1c87dd2db480114c44082a4f58c8922e94d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b218b952f800c1160b8b5e764ca651b02d678565", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b218b952f800c1160b8b5e764ca651b02d678565", "html_url": "https://github.com/rust-lang/rust/commit/b218b952f800c1160b8b5e764ca651b02d678565", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b218b952f800c1160b8b5e764ca651b02d678565/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9bb55dc8642d811d66a7599812009cc063577e00", "url": "https://api.github.com/repos/rust-lang/rust/commits/9bb55dc8642d811d66a7599812009cc063577e00", "html_url": "https://github.com/rust-lang/rust/commit/9bb55dc8642d811d66a7599812009cc063577e00"}, {"sha": "85e77edc82f8052b865cf35f9aaade2d668ea4f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/85e77edc82f8052b865cf35f9aaade2d668ea4f1", "html_url": "https://github.com/rust-lang/rust/commit/85e77edc82f8052b865cf35f9aaade2d668ea4f1"}], "stats": {"total": 1710, "additions": 1194, "deletions": 516}, "files": [{"sha": "010fd4e9c5a2b675024a382f5ed7c382431ac898", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/b218b952f800c1160b8b5e764ca651b02d678565/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b218b952f800c1160b8b5e764ca651b02d678565/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=b218b952f800c1160b8b5e764ca651b02d678565", "patch": "@@ -1524,6 +1524,9 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n     // NO-OPT-OUT, OBJECT-FILES-MAYBE, CUSTOMIZATION-POINT\n     add_pre_link_args(cmd, sess, flavor);\n \n+    // NO-OPT-OUT, OBJECT-FILES-NO\n+    add_apple_sdk(cmd, sess, flavor);\n+\n     // NO-OPT-OUT\n     add_link_script(cmd, sess, tmpdir, crate_type);\n \n@@ -2083,3 +2086,86 @@ fn are_upstream_rust_objects_already_included(sess: &Session) -> bool {\n         config::Lto::No | config::Lto::ThinLocal => false,\n     }\n }\n+\n+fn add_apple_sdk(cmd: &mut dyn Linker, sess: &Session, flavor: LinkerFlavor) {\n+    let arch = &sess.target.target.arch;\n+    let os = &sess.target.target.target_os;\n+    let llvm_target = &sess.target.target.llvm_target;\n+    if sess.target.target.target_vendor != \"apple\"\n+        || !matches!(os.as_str(), \"ios\" | \"tvos\")\n+        || flavor != LinkerFlavor::Gcc\n+    {\n+        return;\n+    }\n+    let sdk_name = match (arch.as_str(), os.as_str()) {\n+        (\"aarch64\", \"tvos\") => \"appletvos\",\n+        (\"x86_64\", \"tvos\") => \"appletvsimulator\",\n+        (\"arm\", \"ios\") => \"iphoneos\",\n+        (\"aarch64\", \"ios\") => \"iphoneos\",\n+        (\"x86\", \"ios\") => \"iphonesimulator\",\n+        (\"x86_64\", \"ios\") if llvm_target.contains(\"macabi\") => \"macosx10.15\",\n+        (\"x86_64\", \"ios\") => \"iphonesimulator\",\n+        _ => {\n+            sess.err(&format!(\"unsupported arch `{}` for os `{}`\", arch, os));\n+            return;\n+        }\n+    };\n+    let sdk_root = match get_apple_sdk_root(sdk_name) {\n+        Ok(s) => s,\n+        Err(e) => {\n+            sess.err(&e);\n+            return;\n+        }\n+    };\n+    let arch_name = llvm_target.split('-').next().expect(\"LLVM target must have a hyphen\");\n+    cmd.args(&[\"-arch\", arch_name, \"-isysroot\", &sdk_root, \"-Wl,-syslibroot\", &sdk_root]);\n+}\n+\n+fn get_apple_sdk_root(sdk_name: &str) -> Result<String, String> {\n+    // Following what clang does\n+    // (https://github.com/llvm/llvm-project/blob/\n+    // 296a80102a9b72c3eda80558fb78a3ed8849b341/clang/lib/Driver/ToolChains/Darwin.cpp#L1661-L1678)\n+    // to allow the SDK path to be set. (For clang, xcrun sets\n+    // SDKROOT; for rustc, the user or build system can set it, or we\n+    // can fall back to checking for xcrun on PATH.)\n+    if let Ok(sdkroot) = env::var(\"SDKROOT\") {\n+        let p = Path::new(&sdkroot);\n+        match sdk_name {\n+            // Ignore `SDKROOT` if it's clearly set for the wrong platform.\n+            \"appletvos\"\n+                if sdkroot.contains(\"TVSimulator.platform\")\n+                    || sdkroot.contains(\"MacOSX.platform\") => {}\n+            \"appletvsimulator\"\n+                if sdkroot.contains(\"TVOS.platform\") || sdkroot.contains(\"MacOSX.platform\") => {}\n+            \"iphoneos\"\n+                if sdkroot.contains(\"iPhoneSimulator.platform\")\n+                    || sdkroot.contains(\"MacOSX.platform\") => {}\n+            \"iphonesimulator\"\n+                if sdkroot.contains(\"iPhoneOS.platform\") || sdkroot.contains(\"MacOSX.platform\") => {\n+            }\n+            \"macosx10.15\"\n+                if sdkroot.contains(\"iPhoneOS.platform\")\n+                    || sdkroot.contains(\"iPhoneSimulator.platform\") => {}\n+            // Ignore `SDKROOT` if it's not a valid path.\n+            _ if !p.is_absolute() || p == Path::new(\"/\") || !p.exists() => {}\n+            _ => return Ok(sdkroot),\n+        }\n+    }\n+    let res =\n+        Command::new(\"xcrun\").arg(\"--show-sdk-path\").arg(\"-sdk\").arg(sdk_name).output().and_then(\n+            |output| {\n+                if output.status.success() {\n+                    Ok(String::from_utf8(output.stdout).unwrap())\n+                } else {\n+                    let error = String::from_utf8(output.stderr);\n+                    let error = format!(\"process exit with error: {}\", error.unwrap());\n+                    Err(io::Error::new(io::ErrorKind::Other, &error[..]))\n+                }\n+            },\n+        );\n+\n+    match res {\n+        Ok(output) => Ok(output.trim().to_string()),\n+        Err(e) => Err(format!(\"failed to get {} SDK path: {}\", sdk_name, e)),\n+    }\n+}"}, {"sha": "2c4eff618c6854c838ff0ae2a30a8dc9d3d25206", "filename": "compiler/rustc_data_structures/src/sip128.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b218b952f800c1160b8b5e764ca651b02d678565/compiler%2Frustc_data_structures%2Fsrc%2Fsip128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b218b952f800c1160b8b5e764ca651b02d678565/compiler%2Frustc_data_structures%2Fsrc%2Fsip128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsip128.rs?ref=b218b952f800c1160b8b5e764ca651b02d678565", "patch": "@@ -125,15 +125,28 @@ impl SipHasher128 {\n \n     // A specialized write function for values with size <= 8.\n     //\n-    // The hashing of multi-byte integers depends on endianness. E.g.:\n+    // The input must be zero-extended to 64-bits by the caller. This extension\n+    // isn't hashed, but the implementation requires it for correctness.\n+    //\n+    // This function, given the same integer size and value, has the same effect\n+    // on both little- and big-endian hardware. It operates on values without\n+    // depending on their sequence in memory, so is independent of endianness.\n+    //\n+    // However, we want SipHasher128 to be platform-dependent, in order to be\n+    // consistent with the platform-dependent SipHasher in libstd. In other\n+    // words, we want:\n+    //\n     // - little-endian: `write_u32(0xDDCCBBAA)` == `write([0xAA, 0xBB, 0xCC, 0xDD])`\n     // - big-endian:    `write_u32(0xDDCCBBAA)` == `write([0xDD, 0xCC, 0xBB, 0xAA])`\n     //\n-    // This function does the right thing for little-endian hardware. On\n-    // big-endian hardware `x` must be byte-swapped first to give the right\n-    // behaviour. After any byte-swapping, the input must be zero-extended to\n-    // 64-bits. The caller is responsible for the byte-swapping and\n-    // zero-extension.\n+    // Therefore, in order to produce endian-dependent results, SipHasher128's\n+    // `write_xxx` Hasher trait methods byte-swap `x` prior to zero-extending.\n+    //\n+    // If clients of SipHasher128 itself want platform-independent results, they\n+    // *also* must byte-swap integer inputs before invoking the `write_xxx`\n+    // methods on big-endian hardware (that is, two byte-swaps must occur--one\n+    // in the client, and one in SipHasher128). Additionally, they must extend\n+    // `usize` and `isize` types to 64 bits on 32-bit systems.\n     #[inline]\n     fn short_write<T>(&mut self, _x: T, x: u64) {\n         let size = mem::size_of::<T>();"}, {"sha": "2e2274a7b775e94df3ddbc81fd320cf6a2eddf3c", "filename": "compiler/rustc_data_structures/src/sip128/tests.rs", "status": "modified", "additions": 45, "deletions": 11, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/b218b952f800c1160b8b5e764ca651b02d678565/compiler%2Frustc_data_structures%2Fsrc%2Fsip128%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b218b952f800c1160b8b5e764ca651b02d678565/compiler%2Frustc_data_structures%2Fsrc%2Fsip128%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsip128%2Ftests.rs?ref=b218b952f800c1160b8b5e764ca651b02d678565", "patch": "@@ -1,7 +1,6 @@\n use super::*;\n \n use std::hash::{Hash, Hasher};\n-use std::{mem, slice};\n \n // Hash just the bytes of the slice, without length prefix\n struct Bytes<'a>(&'a [u8]);\n@@ -399,20 +398,55 @@ fn test_hash_no_concat_alias() {\n }\n \n #[test]\n-fn test_write_short_works() {\n-    let test_usize = 0xd0c0b0a0usize;\n+fn test_short_write_works() {\n+    let test_u8 = 0xFF_u8;\n+    let test_u16 = 0x1122_u16;\n+    let test_u32 = 0x22334455_u32;\n+    let test_u64 = 0x33445566_778899AA_u64;\n+    let test_u128 = 0x11223344_55667788_99AABBCC_DDEEFF77_u128;\n+    let test_usize = 0xD0C0B0A0_usize;\n+\n+    let test_i8 = -1_i8;\n+    let test_i16 = -2_i16;\n+    let test_i32 = -3_i32;\n+    let test_i64 = -4_i64;\n+    let test_i128 = -5_i128;\n+    let test_isize = -6_isize;\n+\n     let mut h1 = SipHasher128::new_with_keys(0, 0);\n-    h1.write_usize(test_usize);\n     h1.write(b\"bytes\");\n     h1.write(b\"string\");\n-    h1.write_u8(0xFFu8);\n-    h1.write_u8(0x01u8);\n+    h1.write_u8(test_u8);\n+    h1.write_u16(test_u16);\n+    h1.write_u32(test_u32);\n+    h1.write_u64(test_u64);\n+    h1.write_u128(test_u128);\n+    h1.write_usize(test_usize);\n+    h1.write_i8(test_i8);\n+    h1.write_i16(test_i16);\n+    h1.write_i32(test_i32);\n+    h1.write_i64(test_i64);\n+    h1.write_i128(test_i128);\n+    h1.write_isize(test_isize);\n+\n     let mut h2 = SipHasher128::new_with_keys(0, 0);\n-    h2.write(unsafe {\n-        slice::from_raw_parts(&test_usize as *const _ as *const u8, mem::size_of::<usize>())\n-    });\n     h2.write(b\"bytes\");\n     h2.write(b\"string\");\n-    h2.write(&[0xFFu8, 0x01u8]);\n-    assert_eq!(h1.finish128(), h2.finish128());\n+    h2.write(&test_u8.to_ne_bytes());\n+    h2.write(&test_u16.to_ne_bytes());\n+    h2.write(&test_u32.to_ne_bytes());\n+    h2.write(&test_u64.to_ne_bytes());\n+    h2.write(&test_u128.to_ne_bytes());\n+    h2.write(&test_usize.to_ne_bytes());\n+    h2.write(&test_i8.to_ne_bytes());\n+    h2.write(&test_i16.to_ne_bytes());\n+    h2.write(&test_i32.to_ne_bytes());\n+    h2.write(&test_i64.to_ne_bytes());\n+    h2.write(&test_i128.to_ne_bytes());\n+    h2.write(&test_isize.to_ne_bytes());\n+\n+    let h1_hash = h1.finish128();\n+    let h2_hash = h2.finish128();\n+\n+    assert_eq!(h1_hash, h2_hash);\n }"}, {"sha": "68875b3fbde9b39d265bd2cb3c2cc2e976feba0a", "filename": "compiler/rustc_data_structures/src/stable_hasher.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b218b952f800c1160b8b5e764ca651b02d678565/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b218b952f800c1160b8b5e764ca651b02d678565/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs?ref=b218b952f800c1160b8b5e764ca651b02d678565", "patch": "@@ -5,6 +5,9 @@ use smallvec::SmallVec;\n use std::hash::{BuildHasher, Hash, Hasher};\n use std::mem;\n \n+#[cfg(test)]\n+mod tests;\n+\n /// When hashing something that ends up affecting properties like symbol names,\n /// we want these symbol names to be calculated independently of other factors\n /// like what architecture you're compiling *from*.\n@@ -129,7 +132,8 @@ impl Hasher for StableHasher {\n     fn write_isize(&mut self, i: isize) {\n         // Always treat isize as i64 so we get the same results on 32 and 64 bit\n         // platforms. This is important for symbol hashes when cross compiling,\n-        // for example.\n+        // for example. Sign extending here is preferable as it means that the\n+        // same negative number hashes the same on both 32 and 64 bit platforms.\n         self.state.write_i64((i as i64).to_le());\n     }\n }"}, {"sha": "cd6ff96a555f4785a4b47f53f4dff2fc20fd414c", "filename": "compiler/rustc_data_structures/src/stable_hasher/tests.rs", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/b218b952f800c1160b8b5e764ca651b02d678565/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b218b952f800c1160b8b5e764ca651b02d678565/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher%2Ftests.rs?ref=b218b952f800c1160b8b5e764ca651b02d678565", "patch": "@@ -0,0 +1,73 @@\n+use super::*;\n+\n+// The tests below compare the computed hashes to particular expected values\n+// in order to test that we produce the same results on different platforms,\n+// regardless of endianness and `usize` and `isize` size differences (this\n+// of course assumes we run these tests on platforms that differ in those\n+// ways). The expected values depend on the hashing algorithm used, so they\n+// need to be updated whenever StableHasher changes its hashing algorithm.\n+\n+#[test]\n+fn test_hash_integers() {\n+    // Test that integers are handled consistently across platforms.\n+    let test_u8 = 0xAB_u8;\n+    let test_u16 = 0xFFEE_u16;\n+    let test_u32 = 0x445577AA_u32;\n+    let test_u64 = 0x01234567_13243546_u64;\n+    let test_u128 = 0x22114433_66557788_99AACCBB_EEDDFF77_u128;\n+    let test_usize = 0xD0C0B0A0_usize;\n+\n+    let test_i8 = -100_i8;\n+    let test_i16 = -200_i16;\n+    let test_i32 = -300_i32;\n+    let test_i64 = -400_i64;\n+    let test_i128 = -500_i128;\n+    let test_isize = -600_isize;\n+\n+    let mut h = StableHasher::new();\n+    test_u8.hash(&mut h);\n+    test_u16.hash(&mut h);\n+    test_u32.hash(&mut h);\n+    test_u64.hash(&mut h);\n+    test_u128.hash(&mut h);\n+    test_usize.hash(&mut h);\n+    test_i8.hash(&mut h);\n+    test_i16.hash(&mut h);\n+    test_i32.hash(&mut h);\n+    test_i64.hash(&mut h);\n+    test_i128.hash(&mut h);\n+    test_isize.hash(&mut h);\n+\n+    // This depends on the hashing algorithm. See note at top of file.\n+    let expected = (2736651863462566372, 8121090595289675650);\n+\n+    assert_eq!(h.finalize(), expected);\n+}\n+\n+#[test]\n+fn test_hash_usize() {\n+    // Test that usize specifically is handled consistently across platforms.\n+    let test_usize = 0xABCDEF01_usize;\n+\n+    let mut h = StableHasher::new();\n+    test_usize.hash(&mut h);\n+\n+    // This depends on the hashing algorithm. See note at top of file.\n+    let expected = (5798740672699530587, 11186240177685111648);\n+\n+    assert_eq!(h.finalize(), expected);\n+}\n+\n+#[test]\n+fn test_hash_isize() {\n+    // Test that isize specifically is handled consistently across platforms.\n+    let test_isize = -7_isize;\n+\n+    let mut h = StableHasher::new();\n+    test_isize.hash(&mut h);\n+\n+    // This depends on the hashing algorithm. See note at top of file.\n+    let expected = (14721296605626097289, 11385941877786388409);\n+\n+    assert_eq!(h.finalize(), expected);\n+}"}, {"sha": "82d698b37ab1d4a2d97fc04f8663729a4f0cd059", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b218b952f800c1160b8b5e764ca651b02d678565/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b218b952f800c1160b8b5e764ca651b02d678565/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=b218b952f800c1160b8b5e764ca651b02d678565", "patch": "@@ -232,7 +232,7 @@ impl<'tcx> ty::TyS<'tcx> {\n                 let n = tcx.lift(&n).unwrap();\n                 match n.try_eval_usize(tcx, ty::ParamEnv::empty()) {\n                     _ if t.is_simple_ty() => format!(\"array `{}`\", self).into(),\n-                    Some(n) => format!(\"array of {} element{} \", n, pluralize!(n)).into(),\n+                    Some(n) => format!(\"array of {} element{}\", n, pluralize!(n)).into(),\n                     None => \"array\".into(),\n                 }\n             }"}, {"sha": "57aa216850aabc3181e064ff1c0111eccf84aee5", "filename": "compiler/rustc_mir/src/const_eval/eval_queries.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b218b952f800c1160b8b5e764ca651b02d678565/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b218b952f800c1160b8b5e764ca651b02d678565/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=b218b952f800c1160b8b5e764ca651b02d678565", "patch": "@@ -14,7 +14,7 @@ use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::{self, subst::Subst, TyCtxt};\n use rustc_span::source_map::Span;\n use rustc_target::abi::{Abi, LayoutOf};\n-use std::convert::TryInto;\n+use std::convert::{TryFrom, TryInto};\n \n pub fn note_on_undefined_behavior_error() -> &'static str {\n     \"The rules on what exactly is undefined behavior aren't clear, \\\n@@ -148,10 +148,10 @@ pub(super) fn op_to_const<'tcx>(\n         Scalar::Raw { data, .. } => {\n             assert!(mplace.layout.is_zst());\n             assert_eq!(\n-                data,\n-                mplace.layout.align.abi.bytes().into(),\n-                \"this MPlaceTy must come from `try_as_mplace` being used on a zst, so we know what\n-                 value this integer address must have\",\n+                u64::try_from(data).unwrap() % mplace.layout.align.abi.bytes(),\n+                0,\n+                \"this MPlaceTy must come from a validated constant, thus we can assume the \\\n+                alignment is correct\",\n             );\n             ConstValue::Scalar(Scalar::zst())\n         }"}, {"sha": "0281c478a6ca06fbee0bb8331bada6183114ae54", "filename": "compiler/rustc_mir/src/transform/check_const_item_mutation.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b218b952f800c1160b8b5e764ca651b02d678565/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_const_item_mutation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b218b952f800c1160b8b5e764ca651b02d678565/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_const_item_mutation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_const_item_mutation.rs?ref=b218b952f800c1160b8b5e764ca651b02d678565", "patch": "@@ -60,11 +60,15 @@ impl<'a, 'tcx> Visitor<'tcx> for ConstMutationChecker<'a, 'tcx> {\n             // so emitting a lint would be redundant.\n             if !lhs.projection.is_empty() {\n                 if let Some(def_id) = self.is_const_item(lhs.local) {\n-                    self.lint_const_item_usage(def_id, loc, |lint| {\n-                        let mut lint = lint.build(\"attempting to modify a `const` item\");\n-                        lint.note(\"each usage of a `const` item creates a new temporary - the original `const` item will not be modified\");\n-                        lint\n-                    })\n+                    // Don't lint on writes through a pointer\n+                    // (e.g. `unsafe { *FOO = 0; *BAR.field = 1; }`)\n+                    if !matches!(lhs.projection.last(), Some(PlaceElem::Deref)) {\n+                        self.lint_const_item_usage(def_id, loc, |lint| {\n+                            let mut lint = lint.build(\"attempting to modify a `const` item\");\n+                            lint.note(\"each usage of a `const` item creates a new temporary - the original `const` item will not be modified\");\n+                            lint\n+                        })\n+                    }\n                 }\n             }\n             // We are looking for MIR of the form:"}, {"sha": "89f7531b3a7fff1e504f94aafb57e5c8ebdc47a8", "filename": "compiler/rustc_mir/src/transform/promote_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b218b952f800c1160b8b5e764ca651b02d678565/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b218b952f800c1160b8b5e764ca651b02d678565/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=b218b952f800c1160b8b5e764ca651b02d678565", "patch": "@@ -137,7 +137,7 @@ fn args_required_const(tcx: TyCtxt<'_>, def_id: DefId) -> Option<Vec<usize>> {\n             LitKind::Int(a, _) => {\n                 ret.push(a as usize);\n             }\n-            _ => return None,\n+            _ => bug!(\"invalid arg index\"),\n         }\n     }\n     Some(ret)"}, {"sha": "b68d36c9a8e6fc3e0875098177d987475405e6b3", "filename": "compiler/rustc_parse/src/lib.rs", "status": "modified", "additions": 34, "deletions": 23, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/b218b952f800c1160b8b5e764ca651b02d678565/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b218b952f800c1160b8b5e764ca651b02d678565/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flib.rs?ref=b218b952f800c1160b8b5e764ca651b02d678565", "patch": "@@ -8,7 +8,7 @@\n \n use rustc_ast as ast;\n use rustc_ast::token::{self, Nonterminal, Token, TokenKind};\n-use rustc_ast::tokenstream::{self, Spacing, TokenStream, TokenTree};\n+use rustc_ast::tokenstream::{self, TokenStream, TokenTree};\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{Diagnostic, FatalError, Level, PResult};\n@@ -435,31 +435,42 @@ pub fn tokenstream_probably_equal_for_proc_macro(\n         token_trees.into_iter()\n     }\n \n-    let expand_nt = |tree: TokenTree| {\n-        if let TokenTree::Token(Token { kind: TokenKind::Interpolated(nt), span }) = &tree {\n-            // When checking tokenstreams for 'probable equality', we are comparing\n-            // a captured (from parsing) `TokenStream` to a reparsed tokenstream.\n-            // The reparsed Tokenstream will never have `None`-delimited groups,\n-            // since they are only ever inserted as a result of macro expansion.\n-            // Therefore, inserting a `None`-delimtied group here (when we\n-            // convert a nested `Nonterminal` to a tokenstream) would cause\n-            // a mismatch with the reparsed tokenstream.\n-            //\n-            // Note that we currently do not handle the case where the\n-            // reparsed stream has a `Parenthesis`-delimited group\n-            // inserted. This will cause a spurious mismatch:\n-            // issue #75734 tracks resolving this.\n-            nt_to_tokenstream(nt, sess, *span).into_trees()\n-        } else {\n-            TokenStream::new(vec![(tree, Spacing::Alone)]).into_trees()\n-        }\n-    };\n+    fn expand_token(tree: TokenTree, sess: &ParseSess) -> impl Iterator<Item = TokenTree> {\n+        // When checking tokenstreams for 'probable equality', we are comparing\n+        // a captured (from parsing) `TokenStream` to a reparsed tokenstream.\n+        // The reparsed Tokenstream will never have `None`-delimited groups,\n+        // since they are only ever inserted as a result of macro expansion.\n+        // Therefore, inserting a `None`-delimtied group here (when we\n+        // convert a nested `Nonterminal` to a tokenstream) would cause\n+        // a mismatch with the reparsed tokenstream.\n+        //\n+        // Note that we currently do not handle the case where the\n+        // reparsed stream has a `Parenthesis`-delimited group\n+        // inserted. This will cause a spurious mismatch:\n+        // issue #75734 tracks resolving this.\n+\n+        let expanded: SmallVec<[_; 1]> =\n+            if let TokenTree::Token(Token { kind: TokenKind::Interpolated(nt), span }) = &tree {\n+                nt_to_tokenstream(nt, sess, *span)\n+                    .into_trees()\n+                    .flat_map(|t| expand_token(t, sess))\n+                    .collect()\n+            } else {\n+                // Filter before and after breaking tokens,\n+                // since we may want to ignore both glued and unglued tokens.\n+                std::iter::once(tree)\n+                    .filter(semantic_tree)\n+                    .flat_map(break_tokens)\n+                    .filter(semantic_tree)\n+                    .collect()\n+            };\n+        expanded.into_iter()\n+    }\n \n     // Break tokens after we expand any nonterminals, so that we break tokens\n     // that are produced as a result of nonterminal expansion.\n-    let tokens = tokens.trees().filter(semantic_tree).flat_map(expand_nt).flat_map(break_tokens);\n-    let reparsed_tokens =\n-        reparsed_tokens.trees().filter(semantic_tree).flat_map(expand_nt).flat_map(break_tokens);\n+    let tokens = tokens.trees().flat_map(|t| expand_token(t, sess));\n+    let reparsed_tokens = reparsed_tokens.trees().flat_map(|t| expand_token(t, sess));\n \n     tokens.eq_by(reparsed_tokens, |t, rt| tokentree_probably_equal_for_proc_macro(&t, &rt, sess))\n }"}, {"sha": "1ec251326a8f6dc413b0811d975809427e354023", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 101, "deletions": 9, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/b218b952f800c1160b8b5e764ca651b02d678565/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b218b952f800c1160b8b5e764ca651b02d678565/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=b218b952f800c1160b8b5e764ca651b02d678565", "patch": "@@ -8,12 +8,12 @@ use rustc_middle::hir::map::Map;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::TyCtxt;\n \n-use rustc_ast::{Attribute, NestedMetaItem};\n-use rustc_errors::struct_span_err;\n+use rustc_ast::{Attribute, LitKind, NestedMetaItem};\n+use rustc_errors::{pluralize, struct_span_err};\n use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n-use rustc_hir::{self, HirId, Item, ItemKind, TraitItem};\n+use rustc_hir::{self, FnSig, ForeignItem, ForeignItemKind, HirId, Item, ItemKind, TraitItem};\n use rustc_hir::{MethodKind, Target};\n use rustc_session::lint::builtin::{CONFLICTING_REPR_HINTS, UNUSED_ATTRIBUTES};\n use rustc_session::parse::feature_err;\n@@ -43,6 +43,12 @@ pub(crate) fn target_from_impl_item<'tcx>(\n     }\n }\n \n+#[derive(Clone, Copy)]\n+enum ItemLike<'tcx> {\n+    Item(&'tcx Item<'tcx>),\n+    ForeignItem(&'tcx ForeignItem<'tcx>),\n+}\n+\n struct CheckAttrVisitor<'tcx> {\n     tcx: TyCtxt<'tcx>,\n }\n@@ -55,7 +61,7 @@ impl CheckAttrVisitor<'tcx> {\n         attrs: &'hir [Attribute],\n         span: &Span,\n         target: Target,\n-        item: Option<&Item<'_>>,\n+        item: Option<ItemLike<'_>>,\n     ) {\n         let mut is_valid = true;\n         for attr in attrs {\n@@ -75,6 +81,8 @@ impl CheckAttrVisitor<'tcx> {\n                 self.check_no_link(&attr, span, target)\n             } else if self.tcx.sess.check_name(attr, sym::export_name) {\n                 self.check_export_name(&attr, span, target)\n+            } else if self.tcx.sess.check_name(attr, sym::rustc_args_required_const) {\n+                self.check_rustc_args_required_const(&attr, span, target, item)\n             } else {\n                 // lint-only checks\n                 if self.tcx.sess.check_name(attr, sym::cold) {\n@@ -400,6 +408,71 @@ impl CheckAttrVisitor<'tcx> {\n         }\n     }\n \n+    /// Checks if `#[rustc_args_required_const]` is applied to a function and has a valid argument.\n+    fn check_rustc_args_required_const(\n+        &self,\n+        attr: &Attribute,\n+        span: &Span,\n+        target: Target,\n+        item: Option<ItemLike<'_>>,\n+    ) -> bool {\n+        if let Target::Fn | Target::Method(..) | Target::ForeignFn = target {\n+            let mut invalid_args = vec![];\n+            for meta in attr.meta_item_list().expect(\"no meta item list\") {\n+                if let Some(LitKind::Int(val, _)) = meta.literal().map(|lit| &lit.kind) {\n+                    if let Some(ItemLike::Item(Item {\n+                        kind: ItemKind::Fn(FnSig { decl, .. }, ..),\n+                        ..\n+                    }))\n+                    | Some(ItemLike::ForeignItem(ForeignItem {\n+                        kind: ForeignItemKind::Fn(decl, ..),\n+                        ..\n+                    })) = item\n+                    {\n+                        let arg_count = decl.inputs.len() as u128;\n+                        if *val >= arg_count {\n+                            let span = meta.span();\n+                            self.tcx\n+                                .sess\n+                                .struct_span_err(span, \"index exceeds number of arguments\")\n+                                .span_label(\n+                                    span,\n+                                    format!(\n+                                        \"there {} only {} argument{}\",\n+                                        if arg_count != 1 { \"are\" } else { \"is\" },\n+                                        arg_count,\n+                                        pluralize!(arg_count)\n+                                    ),\n+                                )\n+                                .emit();\n+                            return false;\n+                        }\n+                    } else {\n+                        bug!(\"should be a function item\");\n+                    }\n+                } else {\n+                    invalid_args.push(meta.span());\n+                }\n+            }\n+            if !invalid_args.is_empty() {\n+                self.tcx\n+                    .sess\n+                    .struct_span_err(invalid_args, \"arguments should be non-negative integers\")\n+                    .emit();\n+                false\n+            } else {\n+                true\n+            }\n+        } else {\n+            self.tcx\n+                .sess\n+                .struct_span_err(attr.span, \"attribute should be applied to a function\")\n+                .span_label(*span, \"not a function\")\n+                .emit();\n+            false\n+        }\n+    }\n+\n     /// Checks if `#[link_section]` is applied to a function or static.\n     fn check_link_section(&self, hir_id: HirId, attr: &Attribute, span: &Span, target: Target) {\n         match target {\n@@ -448,7 +521,7 @@ impl CheckAttrVisitor<'tcx> {\n         attrs: &'hir [Attribute],\n         span: &Span,\n         target: Target,\n-        item: Option<&Item<'_>>,\n+        item: Option<ItemLike<'_>>,\n         hir_id: HirId,\n     ) {\n         // Extract the names of all repr hints, e.g., [foo, bar, align] for:\n@@ -564,7 +637,14 @@ impl CheckAttrVisitor<'tcx> {\n         // Warn on repr(u8, u16), repr(C, simd), and c-like-enum-repr(C, u8)\n         if (int_reprs > 1)\n             || (is_simd && is_c)\n-            || (int_reprs == 1 && is_c && item.map_or(false, |item| is_c_like_enum(item)))\n+            || (int_reprs == 1\n+                && is_c\n+                && item.map_or(false, |item| {\n+                    if let ItemLike::Item(item) = item {\n+                        return is_c_like_enum(item);\n+                    }\n+                    return false;\n+                }))\n         {\n             self.tcx.struct_span_lint_hir(\n                 CONFLICTING_REPR_HINTS,\n@@ -649,7 +729,13 @@ impl Visitor<'tcx> for CheckAttrVisitor<'tcx> {\n \n     fn visit_item(&mut self, item: &'tcx Item<'tcx>) {\n         let target = Target::from_item(item);\n-        self.check_attributes(item.hir_id, item.attrs, &item.span, target, Some(item));\n+        self.check_attributes(\n+            item.hir_id,\n+            item.attrs,\n+            &item.span,\n+            target,\n+            Some(ItemLike::Item(item)),\n+        );\n         intravisit::walk_item(self, item)\n     }\n \n@@ -659,9 +745,15 @@ impl Visitor<'tcx> for CheckAttrVisitor<'tcx> {\n         intravisit::walk_trait_item(self, trait_item)\n     }\n \n-    fn visit_foreign_item(&mut self, f_item: &'tcx hir::ForeignItem<'tcx>) {\n+    fn visit_foreign_item(&mut self, f_item: &'tcx ForeignItem<'tcx>) {\n         let target = Target::from_foreign_item(f_item);\n-        self.check_attributes(f_item.hir_id, &f_item.attrs, &f_item.span, target, None);\n+        self.check_attributes(\n+            f_item.hir_id,\n+            &f_item.attrs,\n+            &f_item.span,\n+            target,\n+            Some(ItemLike::ForeignItem(f_item)),\n+        );\n         intravisit::walk_foreign_item(self, f_item)\n     }\n "}, {"sha": "168cd01878e52082d347e0e738f8b9f5591d4192", "filename": "compiler/rustc_target/src/spec/aarch64_apple_ios.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b218b952f800c1160b8b5e764ca651b02d678565/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_ios.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b218b952f800c1160b8b5e764ca651b02d678565/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_ios.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_ios.rs?ref=b218b952f800c1160b8b5e764ca651b02d678565", "patch": "@@ -1,8 +1,8 @@\n-use super::apple_sdk_base::{opts, AppleOS, Arch};\n+use super::apple_sdk_base::{opts, Arch};\n use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n \n pub fn target() -> TargetResult {\n-    let base = opts(Arch::Arm64, AppleOS::iOS)?;\n+    let base = opts(Arch::Arm64);\n     Ok(Target {\n         llvm_target: \"arm64-apple-ios\".to_string(),\n         target_endian: \"little\".to_string(),"}, {"sha": "5e2cab0df1e550ef13650a2a637fa29fcefaf085", "filename": "compiler/rustc_target/src/spec/aarch64_apple_tvos.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b218b952f800c1160b8b5e764ca651b02d678565/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_tvos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b218b952f800c1160b8b5e764ca651b02d678565/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_tvos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_tvos.rs?ref=b218b952f800c1160b8b5e764ca651b02d678565", "patch": "@@ -1,8 +1,8 @@\n-use super::apple_sdk_base::{opts, AppleOS, Arch};\n+use super::apple_sdk_base::{opts, Arch};\n use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n \n pub fn target() -> TargetResult {\n-    let base = opts(Arch::Arm64, AppleOS::tvOS)?;\n+    let base = opts(Arch::Arm64);\n     Ok(Target {\n         llvm_target: \"arm64-apple-tvos\".to_string(),\n         target_endian: \"little\".to_string(),"}, {"sha": "e34277d5af04cc374f8c5972f31c5df9a3435d7b", "filename": "compiler/rustc_target/src/spec/apple_sdk_base.rs", "status": "modified", "additions": 4, "deletions": 112, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/b218b952f800c1160b8b5e764ca651b02d678565/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_sdk_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b218b952f800c1160b8b5e764ca651b02d678565/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_sdk_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_sdk_base.rs?ref=b218b952f800c1160b8b5e764ca651b02d678565", "patch": "@@ -1,8 +1,4 @@\n-use crate::spec::{LinkArgs, LinkerFlavor, TargetOptions};\n-use std::env;\n-use std::io;\n-use std::path::Path;\n-use std::process::Command;\n+use crate::spec::TargetOptions;\n \n use Arch::*;\n #[allow(non_camel_case_types)]\n@@ -16,108 +12,6 @@ pub enum Arch {\n     X86_64_macabi,\n }\n \n-#[allow(non_camel_case_types)]\n-#[derive(Copy, Clone)]\n-pub enum AppleOS {\n-    tvOS,\n-    iOS,\n-}\n-\n-impl Arch {\n-    pub fn to_string(self) -> &'static str {\n-        match self {\n-            Armv7 => \"armv7\",\n-            Armv7s => \"armv7s\",\n-            Arm64 => \"arm64\",\n-            I386 => \"i386\",\n-            X86_64 => \"x86_64\",\n-            X86_64_macabi => \"x86_64\",\n-        }\n-    }\n-}\n-\n-pub fn get_sdk_root(sdk_name: &str) -> Result<String, String> {\n-    // Following what clang does\n-    // (https://github.com/llvm/llvm-project/blob/\n-    // 296a80102a9b72c3eda80558fb78a3ed8849b341/clang/lib/Driver/ToolChains/Darwin.cpp#L1661-L1678)\n-    // to allow the SDK path to be set. (For clang, xcrun sets\n-    // SDKROOT; for rustc, the user or build system can set it, or we\n-    // can fall back to checking for xcrun on PATH.)\n-    if let Ok(sdkroot) = env::var(\"SDKROOT\") {\n-        let p = Path::new(&sdkroot);\n-        match sdk_name {\n-            // Ignore `SDKROOT` if it's clearly set for the wrong platform.\n-            \"appletvos\"\n-                if sdkroot.contains(\"TVSimulator.platform\")\n-                    || sdkroot.contains(\"MacOSX.platform\") => {}\n-            \"appletvsimulator\"\n-                if sdkroot.contains(\"TVOS.platform\") || sdkroot.contains(\"MacOSX.platform\") => {}\n-            \"iphoneos\"\n-                if sdkroot.contains(\"iPhoneSimulator.platform\")\n-                    || sdkroot.contains(\"MacOSX.platform\") => {}\n-            \"iphonesimulator\"\n-                if sdkroot.contains(\"iPhoneOS.platform\") || sdkroot.contains(\"MacOSX.platform\") => {\n-            }\n-            \"macosx10.15\"\n-                if sdkroot.contains(\"iPhoneOS.platform\")\n-                    || sdkroot.contains(\"iPhoneSimulator.platform\") => {}\n-            // Ignore `SDKROOT` if it's not a valid path.\n-            _ if !p.is_absolute() || p == Path::new(\"/\") || !p.exists() => {}\n-            _ => return Ok(sdkroot),\n-        }\n-    }\n-    let res =\n-        Command::new(\"xcrun\").arg(\"--show-sdk-path\").arg(\"-sdk\").arg(sdk_name).output().and_then(\n-            |output| {\n-                if output.status.success() {\n-                    Ok(String::from_utf8(output.stdout).unwrap())\n-                } else {\n-                    let error = String::from_utf8(output.stderr);\n-                    let error = format!(\"process exit with error: {}\", error.unwrap());\n-                    Err(io::Error::new(io::ErrorKind::Other, &error[..]))\n-                }\n-            },\n-        );\n-\n-    match res {\n-        Ok(output) => Ok(output.trim().to_string()),\n-        Err(e) => Err(format!(\"failed to get {} SDK path: {}\", sdk_name, e)),\n-    }\n-}\n-\n-fn build_pre_link_args(arch: Arch, os: AppleOS) -> Result<LinkArgs, String> {\n-    let sdk_name = match (arch, os) {\n-        (Arm64, AppleOS::tvOS) => \"appletvos\",\n-        (X86_64, AppleOS::tvOS) => \"appletvsimulator\",\n-        (Armv7, AppleOS::iOS) => \"iphoneos\",\n-        (Armv7s, AppleOS::iOS) => \"iphoneos\",\n-        (Arm64, AppleOS::iOS) => \"iphoneos\",\n-        (I386, AppleOS::iOS) => \"iphonesimulator\",\n-        (X86_64, AppleOS::iOS) => \"iphonesimulator\",\n-        (X86_64_macabi, AppleOS::iOS) => \"macosx10.15\",\n-        _ => unreachable!(),\n-    };\n-\n-    let arch_name = arch.to_string();\n-\n-    let sdk_root = get_sdk_root(sdk_name)?;\n-\n-    let mut args = LinkArgs::new();\n-    args.insert(\n-        LinkerFlavor::Gcc,\n-        vec![\n-            \"-arch\".to_string(),\n-            arch_name.to_string(),\n-            \"-isysroot\".to_string(),\n-            sdk_root.clone(),\n-            \"-Wl,-syslibroot\".to_string(),\n-            sdk_root,\n-        ],\n-    );\n-\n-    Ok(args)\n-}\n-\n fn target_cpu(arch: Arch) -> String {\n     match arch {\n         Armv7 => \"cortex-a8\", // iOS7 is supported on iPhone 4 and higher\n@@ -137,15 +31,13 @@ fn link_env_remove(arch: Arch) -> Vec<String> {\n     }\n }\n \n-pub fn opts(arch: Arch, os: AppleOS) -> Result<TargetOptions, String> {\n-    let pre_link_args = build_pre_link_args(arch, os)?;\n-    Ok(TargetOptions {\n+pub fn opts(arch: Arch) -> TargetOptions {\n+    TargetOptions {\n         cpu: target_cpu(arch),\n         executables: true,\n-        pre_link_args,\n         link_env_remove: link_env_remove(arch),\n         has_elf_tls: false,\n         eliminate_frame_pointer: false,\n         ..super::apple_base::opts()\n-    })\n+    }\n }"}, {"sha": "6dafcc2c3453a3f3d3c066f50a00ae105909bbf5", "filename": "compiler/rustc_target/src/spec/armv7_apple_ios.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b218b952f800c1160b8b5e764ca651b02d678565/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7_apple_ios.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b218b952f800c1160b8b5e764ca651b02d678565/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7_apple_ios.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7_apple_ios.rs?ref=b218b952f800c1160b8b5e764ca651b02d678565", "patch": "@@ -1,8 +1,8 @@\n-use super::apple_sdk_base::{opts, AppleOS, Arch};\n+use super::apple_sdk_base::{opts, Arch};\n use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n \n pub fn target() -> TargetResult {\n-    let base = opts(Arch::Armv7, AppleOS::iOS)?;\n+    let base = opts(Arch::Armv7);\n     Ok(Target {\n         llvm_target: \"armv7-apple-ios\".to_string(),\n         target_endian: \"little\".to_string(),"}, {"sha": "d6c99c4ade6e807936138ed27cc517ef34a2a8a3", "filename": "compiler/rustc_target/src/spec/armv7s_apple_ios.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b218b952f800c1160b8b5e764ca651b02d678565/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7s_apple_ios.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b218b952f800c1160b8b5e764ca651b02d678565/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7s_apple_ios.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7s_apple_ios.rs?ref=b218b952f800c1160b8b5e764ca651b02d678565", "patch": "@@ -1,8 +1,8 @@\n-use super::apple_sdk_base::{opts, AppleOS, Arch};\n+use super::apple_sdk_base::{opts, Arch};\n use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n \n pub fn target() -> TargetResult {\n-    let base = opts(Arch::Armv7s, AppleOS::iOS)?;\n+    let base = opts(Arch::Armv7s);\n     Ok(Target {\n         llvm_target: \"armv7s-apple-ios\".to_string(),\n         target_endian: \"little\".to_string(),"}, {"sha": "6cb209ab1c0739ceb9c44a1587574c4241926e9f", "filename": "compiler/rustc_target/src/spec/i386_apple_ios.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b218b952f800c1160b8b5e764ca651b02d678565/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi386_apple_ios.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b218b952f800c1160b8b5e764ca651b02d678565/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi386_apple_ios.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi386_apple_ios.rs?ref=b218b952f800c1160b8b5e764ca651b02d678565", "patch": "@@ -1,8 +1,8 @@\n-use super::apple_sdk_base::{opts, AppleOS, Arch};\n+use super::apple_sdk_base::{opts, Arch};\n use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n \n pub fn target() -> TargetResult {\n-    let base = opts(Arch::I386, AppleOS::iOS)?;\n+    let base = opts(Arch::I386);\n     Ok(Target {\n         llvm_target: \"i386-apple-ios\".to_string(),\n         target_endian: \"little\".to_string(),"}, {"sha": "fd3e4e2f57b669079bc592d02c32d483665aa489", "filename": "compiler/rustc_target/src/spec/x86_64_apple_ios.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b218b952f800c1160b8b5e764ca651b02d678565/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_apple_ios.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b218b952f800c1160b8b5e764ca651b02d678565/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_apple_ios.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_apple_ios.rs?ref=b218b952f800c1160b8b5e764ca651b02d678565", "patch": "@@ -1,8 +1,8 @@\n-use super::apple_sdk_base::{opts, AppleOS, Arch};\n+use super::apple_sdk_base::{opts, Arch};\n use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n \n pub fn target() -> TargetResult {\n-    let base = opts(Arch::X86_64, AppleOS::iOS)?;\n+    let base = opts(Arch::X86_64);\n     Ok(Target {\n         llvm_target: \"x86_64-apple-ios\".to_string(),\n         target_endian: \"little\".to_string(),"}, {"sha": "4cfbd9eba06c78957d41ed7134d7bd938c33850d", "filename": "compiler/rustc_target/src/spec/x86_64_apple_ios_macabi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b218b952f800c1160b8b5e764ca651b02d678565/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_apple_ios_macabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b218b952f800c1160b8b5e764ca651b02d678565/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_apple_ios_macabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_apple_ios_macabi.rs?ref=b218b952f800c1160b8b5e764ca651b02d678565", "patch": "@@ -1,8 +1,8 @@\n-use super::apple_sdk_base::{opts, AppleOS, Arch};\n+use super::apple_sdk_base::{opts, Arch};\n use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n \n pub fn target() -> TargetResult {\n-    let base = opts(Arch::X86_64_macabi, AppleOS::iOS)?;\n+    let base = opts(Arch::X86_64_macabi);\n     Ok(Target {\n         llvm_target: \"x86_64-apple-ios13.0-macabi\".to_string(),\n         target_endian: \"little\".to_string(),"}, {"sha": "664a3ed8816c4c7fe67319f4ea8a3172fe44a27e", "filename": "compiler/rustc_target/src/spec/x86_64_apple_tvos.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b218b952f800c1160b8b5e764ca651b02d678565/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_apple_tvos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b218b952f800c1160b8b5e764ca651b02d678565/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_apple_tvos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_apple_tvos.rs?ref=b218b952f800c1160b8b5e764ca651b02d678565", "patch": "@@ -1,8 +1,8 @@\n-use super::apple_sdk_base::{opts, AppleOS, Arch};\n+use super::apple_sdk_base::{opts, Arch};\n use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n \n pub fn target() -> TargetResult {\n-    let base = opts(Arch::X86_64, AppleOS::iOS)?;\n+    let base = opts(Arch::X86_64);\n     Ok(Target {\n         llvm_target: \"x86_64-apple-tvos\".to_string(),\n         target_endian: \"little\".to_string(),"}, {"sha": "3828cf4d30210b89e35a471883b0768a59ea937a", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 138, "deletions": 15, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/b218b952f800c1160b8b5e764ca651b02d678565/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b218b952f800c1160b8b5e764ca651b02d678565/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=b218b952f800c1160b8b5e764ca651b02d678565", "patch": "@@ -23,6 +23,9 @@ use rustc_session::lint;\n use rustc_span::def_id::{DefId, LocalDefId};\n use rustc_span::Span;\n \n+use std::cmp;\n+\n+/// Check if a given constant can be evaluated.\n pub fn is_const_evaluatable<'cx, 'tcx>(\n     infcx: &InferCtxt<'cx, 'tcx>,\n     def: ty::WithOptConstParam<DefId>,\n@@ -32,23 +35,87 @@ pub fn is_const_evaluatable<'cx, 'tcx>(\n ) -> Result<(), ErrorHandled> {\n     debug!(\"is_const_evaluatable({:?}, {:?})\", def, substs);\n     if infcx.tcx.features().const_evaluatable_checked {\n-        if let Some(ct) = AbstractConst::new(infcx.tcx, def, substs)? {\n-            for pred in param_env.caller_bounds() {\n-                match pred.skip_binders() {\n-                    ty::PredicateAtom::ConstEvaluatable(b_def, b_substs) => {\n-                        debug!(\"is_const_evaluatable: caller_bound={:?}, {:?}\", b_def, b_substs);\n-                        if b_def == def && b_substs == substs {\n-                            debug!(\"is_const_evaluatable: caller_bound ~~> ok\");\n-                            return Ok(());\n-                        } else if AbstractConst::new(infcx.tcx, b_def, b_substs)?\n-                            .map_or(false, |b_ct| try_unify(infcx.tcx, ct, b_ct))\n-                        {\n-                            debug!(\"is_const_evaluatable: abstract_const ~~> ok\");\n-                            return Ok(());\n+        let tcx = infcx.tcx;\n+        match AbstractConst::new(tcx, def, substs)? {\n+            // We are looking at a generic abstract constant.\n+            Some(ct) => {\n+                for pred in param_env.caller_bounds() {\n+                    match pred.skip_binders() {\n+                        ty::PredicateAtom::ConstEvaluatable(b_def, b_substs) => {\n+                            debug!(\n+                                \"is_const_evaluatable: caller_bound={:?}, {:?}\",\n+                                b_def, b_substs\n+                            );\n+                            if b_def == def && b_substs == substs {\n+                                debug!(\"is_const_evaluatable: caller_bound ~~> ok\");\n+                                return Ok(());\n+                            } else if AbstractConst::new(tcx, b_def, b_substs)?\n+                                .map_or(false, |b_ct| try_unify(tcx, ct, b_ct))\n+                            {\n+                                debug!(\"is_const_evaluatable: abstract_const ~~> ok\");\n+                                return Ok(());\n+                            }\n                         }\n+                        _ => {} // don't care\n                     }\n-                    _ => {} // don't care\n                 }\n+\n+                // We were unable to unify the abstract constant with\n+                // a constant found in the caller bounds, there are\n+                // now three possible cases here.\n+                //\n+                // - The substs are concrete enough that we can simply\n+                //   try and evaluate the given constant.\n+                // - The abstract const still references an inference\n+                //   variable, in this case we return `TooGeneric`.\n+                // - The abstract const references a generic parameter,\n+                //   this means that we emit an error here.\n+                #[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]\n+                enum FailureKind {\n+                    MentionsInfer,\n+                    MentionsParam,\n+                    Concrete,\n+                }\n+                let mut failure_kind = FailureKind::Concrete;\n+                walk_abstract_const(tcx, ct, |node| match node {\n+                    Node::Leaf(leaf) => {\n+                        let leaf = leaf.subst(tcx, ct.substs);\n+                        if leaf.has_infer_types_or_consts() {\n+                            failure_kind = FailureKind::MentionsInfer;\n+                        } else if leaf.has_param_types_or_consts() {\n+                            failure_kind = cmp::min(failure_kind, FailureKind::MentionsParam);\n+                        }\n+                    }\n+                    Node::Binop(_, _, _) | Node::UnaryOp(_, _) | Node::FunctionCall(_, _) => (),\n+                });\n+\n+                match failure_kind {\n+                    FailureKind::MentionsInfer => {\n+                        return Err(ErrorHandled::TooGeneric);\n+                    }\n+                    FailureKind::MentionsParam => {\n+                        // FIXME(const_evaluatable_checked): Better error message.\n+                        infcx\n+                            .tcx\n+                            .sess\n+                            .struct_span_err(span, \"unconstrained generic constant\")\n+                            .span_help(\n+                                tcx.def_span(def.did),\n+                                \"consider adding a `where` bound for this expression\",\n+                            )\n+                            .emit();\n+                        return Err(ErrorHandled::Reported(ErrorReported));\n+                    }\n+                    FailureKind::Concrete => {\n+                        // Dealt with below by the same code which handles this\n+                        // without the feature gate.\n+                    }\n+                }\n+            }\n+            None => {\n+                // If we are dealing with a concrete constant, we can\n+                // reuse the old code path and try to evaluate\n+                // the constant.\n             }\n         }\n     }\n@@ -95,7 +162,36 @@ pub fn is_const_evaluatable<'cx, 'tcx>(\n     }\n \n     debug!(?concrete, \"is_const_evaluatable\");\n-    concrete.map(drop)\n+    match concrete {\n+        Err(ErrorHandled::TooGeneric) if !substs.has_infer_types_or_consts() => {\n+            // FIXME(const_evaluatable_checked): We really should move\n+            // emitting this error message to fulfill instead. For\n+            // now this is easier.\n+            //\n+            // This is not a problem without `const_evaluatable_checked` as\n+            // all `ConstEvaluatable` predicates have to be fulfilled for compilation\n+            // to succeed.\n+            //\n+            // @lcnr: We already emit an error for things like\n+            // `fn test<const N: usize>() -> [0 - N]` eagerly here,\n+            // so until we fix this I don't really care.\n+\n+            let mut err = infcx\n+                .tcx\n+                .sess\n+                .struct_span_err(span, \"constant expression depends on a generic parameter\");\n+            // FIXME(const_generics): we should suggest to the user how they can resolve this\n+            // issue. However, this is currently not actually possible\n+            // (see https://github.com/rust-lang/rust/issues/66962#issuecomment-575907083).\n+            //\n+            // Note that with `feature(const_evaluatable_checked)` this case should not\n+            // be reachable.\n+            err.note(\"this may fail depending on what value the parameter takes\");\n+            err.emit();\n+            Err(ErrorHandled::Reported(ErrorReported))\n+        }\n+        c => c.map(drop),\n+    }\n }\n \n /// A tree representing an anonymous constant.\n@@ -421,6 +517,33 @@ pub(super) fn try_unify_abstract_consts<'tcx>(\n     // on `ErrorReported`.\n }\n \n+fn walk_abstract_const<'tcx, F>(tcx: TyCtxt<'tcx>, ct: AbstractConst<'tcx>, mut f: F)\n+where\n+    F: FnMut(Node<'tcx>),\n+{\n+    recurse(tcx, ct, &mut f);\n+    fn recurse<'tcx>(tcx: TyCtxt<'tcx>, ct: AbstractConst<'tcx>, f: &mut dyn FnMut(Node<'tcx>)) {\n+        let root = ct.root();\n+        f(root);\n+        match root {\n+            Node::Leaf(_) => (),\n+            Node::Binop(_, l, r) => {\n+                recurse(tcx, ct.subtree(l), f);\n+                recurse(tcx, ct.subtree(r), f);\n+            }\n+            Node::UnaryOp(_, v) => {\n+                recurse(tcx, ct.subtree(v), f);\n+            }\n+            Node::FunctionCall(func, args) => {\n+                recurse(tcx, ct.subtree(func), f);\n+                for &arg in args {\n+                    recurse(tcx, ct.subtree(arg), f);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n /// Tries to unify two abstract constants using structural equality.\n pub(super) fn try_unify<'tcx>(\n     tcx: TyCtxt<'tcx>,"}, {"sha": "cb3de57cfed079952f2489af638c58582b0b2206", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b218b952f800c1160b8b5e764ca651b02d678565/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b218b952f800c1160b8b5e764ca651b02d678565/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=b218b952f800c1160b8b5e764ca651b02d678565", "patch": "@@ -745,25 +745,9 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 let violations = self.tcx.object_safety_violations(did);\n                 report_object_safety_error(self.tcx, span, did, violations)\n             }\n-\n             ConstEvalFailure(ErrorHandled::TooGeneric) => {\n-                // In this instance, we have a const expression containing an unevaluated\n-                // generic parameter. We have no idea whether this expression is valid or\n-                // not (e.g. it might result in an error), but we don't want to just assume\n-                // that it's okay, because that might result in post-monomorphisation time\n-                // errors. The onus is really on the caller to provide values that it can\n-                // prove are well-formed.\n-                let mut err = self\n-                    .tcx\n-                    .sess\n-                    .struct_span_err(span, \"constant expression depends on a generic parameter\");\n-                // FIXME(const_generics): we should suggest to the user how they can resolve this\n-                // issue. However, this is currently not actually possible\n-                // (see https://github.com/rust-lang/rust/issues/66962#issuecomment-575907083).\n-                err.note(\"this may fail depending on what value the parameter takes\");\n-                err\n+                bug!(\"too generic should have been handled in `is_const_evaluatable`\");\n             }\n-\n             // Already reported in the query.\n             ConstEvalFailure(ErrorHandled::Reported(ErrorReported)) => {\n                 // FIXME(eddyb) remove this once `ErrorReported` becomes a proof token."}, {"sha": "8586a550230f9ae03cbe03929fd5e1887d6f989f", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b218b952f800c1160b8b5e764ca651b02d678565/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b218b952f800c1160b8b5e764ca651b02d678565/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=b218b952f800c1160b8b5e764ca651b02d678565", "patch": "@@ -496,6 +496,13 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n                         obligation.cause.span,\n                     ) {\n                         Ok(()) => ProcessResult::Changed(vec![]),\n+                        Err(ErrorHandled::TooGeneric) => {\n+                            pending_obligation.stalled_on = substs\n+                                .iter()\n+                                .filter_map(|ty| TyOrConstInferVar::maybe_from_generic_arg(ty))\n+                                .collect();\n+                            ProcessResult::Unchanged\n+                        }\n                         Err(e) => ProcessResult::Error(CodeSelectionError(ConstEvalFailure(e))),\n                     }\n                 }\n@@ -537,8 +544,10 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n                                 Err(ErrorHandled::TooGeneric) => {\n                                     stalled_on.append(\n                                         &mut substs\n-                                            .types()\n-                                            .filter_map(|ty| TyOrConstInferVar::maybe_from_ty(ty))\n+                                            .iter()\n+                                            .filter_map(|arg| {\n+                                                TyOrConstInferVar::maybe_from_generic_arg(arg)\n+                                            })\n                                             .collect(),\n                                     );\n                                     Err(ErrorHandled::TooGeneric)"}, {"sha": "9cb5c232646f854e73457951643373a0eec25077", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 161, "deletions": 1, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/b218b952f800c1160b8b5e764ca651b02d678565/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b218b952f800c1160b8b5e764ca651b02d678565/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=b218b952f800c1160b8b5e764ca651b02d678565", "patch": "@@ -7,14 +7,19 @@\n //! [rustc dev guide]:https://rustc-dev-guide.rust-lang.org/traits/resolution.html#candidate-assembly\n use rustc_hir as hir;\n use rustc_infer::traits::{Obligation, SelectionError, TraitObligation};\n+use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::{self, TypeFoldable};\n use rustc_target::spec::abi::Abi;\n \n+use crate::traits::coherence::Conflict;\n use crate::traits::{util, SelectionResult};\n+use crate::traits::{Overflow, Unimplemented};\n \n use super::BuiltinImplConditions;\n+use super::IntercrateAmbiguityCause;\n+use super::OverflowError;\n use super::SelectionCandidate::{self, *};\n-use super::{SelectionCandidateSet, SelectionContext, TraitObligationStack};\n+use super::{EvaluatedCandidate, SelectionCandidateSet, SelectionContext, TraitObligationStack};\n \n impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     pub(super) fn candidate_from_obligation<'o>(\n@@ -62,6 +67,161 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         candidate\n     }\n \n+    fn candidate_from_obligation_no_cache<'o>(\n+        &mut self,\n+        stack: &TraitObligationStack<'o, 'tcx>,\n+    ) -> SelectionResult<'tcx, SelectionCandidate<'tcx>> {\n+        if let Some(conflict) = self.is_knowable(stack) {\n+            debug!(\"coherence stage: not knowable\");\n+            if self.intercrate_ambiguity_causes.is_some() {\n+                debug!(\"evaluate_stack: intercrate_ambiguity_causes is some\");\n+                // Heuristics: show the diagnostics when there are no candidates in crate.\n+                if let Ok(candidate_set) = self.assemble_candidates(stack) {\n+                    let mut no_candidates_apply = true;\n+\n+                    for c in candidate_set.vec.iter() {\n+                        if self.evaluate_candidate(stack, &c)?.may_apply() {\n+                            no_candidates_apply = false;\n+                            break;\n+                        }\n+                    }\n+\n+                    if !candidate_set.ambiguous && no_candidates_apply {\n+                        let trait_ref = stack.obligation.predicate.skip_binder().trait_ref;\n+                        let self_ty = trait_ref.self_ty();\n+                        let (trait_desc, self_desc) = with_no_trimmed_paths(|| {\n+                            let trait_desc = trait_ref.print_only_trait_path().to_string();\n+                            let self_desc = if self_ty.has_concrete_skeleton() {\n+                                Some(self_ty.to_string())\n+                            } else {\n+                                None\n+                            };\n+                            (trait_desc, self_desc)\n+                        });\n+                        let cause = if let Conflict::Upstream = conflict {\n+                            IntercrateAmbiguityCause::UpstreamCrateUpdate { trait_desc, self_desc }\n+                        } else {\n+                            IntercrateAmbiguityCause::DownstreamCrate { trait_desc, self_desc }\n+                        };\n+                        debug!(\"evaluate_stack: pushing cause = {:?}\", cause);\n+                        self.intercrate_ambiguity_causes.as_mut().unwrap().push(cause);\n+                    }\n+                }\n+            }\n+            return Ok(None);\n+        }\n+\n+        let candidate_set = self.assemble_candidates(stack)?;\n+\n+        if candidate_set.ambiguous {\n+            debug!(\"candidate set contains ambig\");\n+            return Ok(None);\n+        }\n+\n+        let mut candidates = candidate_set.vec;\n+\n+        debug!(\"assembled {} candidates for {:?}: {:?}\", candidates.len(), stack, candidates);\n+\n+        // At this point, we know that each of the entries in the\n+        // candidate set is *individually* applicable. Now we have to\n+        // figure out if they contain mutual incompatibilities. This\n+        // frequently arises if we have an unconstrained input type --\n+        // for example, we are looking for `$0: Eq` where `$0` is some\n+        // unconstrained type variable. In that case, we'll get a\n+        // candidate which assumes $0 == int, one that assumes `$0 ==\n+        // usize`, etc. This spells an ambiguity.\n+\n+        // If there is more than one candidate, first winnow them down\n+        // by considering extra conditions (nested obligations and so\n+        // forth). We don't winnow if there is exactly one\n+        // candidate. This is a relatively minor distinction but it\n+        // can lead to better inference and error-reporting. An\n+        // example would be if there was an impl:\n+        //\n+        //     impl<T:Clone> Vec<T> { fn push_clone(...) { ... } }\n+        //\n+        // and we were to see some code `foo.push_clone()` where `boo`\n+        // is a `Vec<Bar>` and `Bar` does not implement `Clone`.  If\n+        // we were to winnow, we'd wind up with zero candidates.\n+        // Instead, we select the right impl now but report \"`Bar` does\n+        // not implement `Clone`\".\n+        if candidates.len() == 1 {\n+            return self.filter_negative_and_reservation_impls(candidates.pop().unwrap());\n+        }\n+\n+        // Winnow, but record the exact outcome of evaluation, which\n+        // is needed for specialization. Propagate overflow if it occurs.\n+        let mut candidates = candidates\n+            .into_iter()\n+            .map(|c| match self.evaluate_candidate(stack, &c) {\n+                Ok(eval) if eval.may_apply() => {\n+                    Ok(Some(EvaluatedCandidate { candidate: c, evaluation: eval }))\n+                }\n+                Ok(_) => Ok(None),\n+                Err(OverflowError) => Err(Overflow),\n+            })\n+            .flat_map(Result::transpose)\n+            .collect::<Result<Vec<_>, _>>()?;\n+\n+        debug!(\"winnowed to {} candidates for {:?}: {:?}\", candidates.len(), stack, candidates);\n+\n+        let needs_infer = stack.obligation.predicate.needs_infer();\n+\n+        // If there are STILL multiple candidates, we can further\n+        // reduce the list by dropping duplicates -- including\n+        // resolving specializations.\n+        if candidates.len() > 1 {\n+            let mut i = 0;\n+            while i < candidates.len() {\n+                let is_dup = (0..candidates.len()).filter(|&j| i != j).any(|j| {\n+                    self.candidate_should_be_dropped_in_favor_of(\n+                        &candidates[i],\n+                        &candidates[j],\n+                        needs_infer,\n+                    )\n+                });\n+                if is_dup {\n+                    debug!(\"Dropping candidate #{}/{}: {:?}\", i, candidates.len(), candidates[i]);\n+                    candidates.swap_remove(i);\n+                } else {\n+                    debug!(\"Retaining candidate #{}/{}: {:?}\", i, candidates.len(), candidates[i]);\n+                    i += 1;\n+\n+                    // If there are *STILL* multiple candidates, give up\n+                    // and report ambiguity.\n+                    if i > 1 {\n+                        debug!(\"multiple matches, ambig\");\n+                        return Ok(None);\n+                    }\n+                }\n+            }\n+        }\n+\n+        // If there are *NO* candidates, then there are no impls --\n+        // that we know of, anyway. Note that in the case where there\n+        // are unbound type variables within the obligation, it might\n+        // be the case that you could still satisfy the obligation\n+        // from another crate by instantiating the type variables with\n+        // a type from another crate that does have an impl. This case\n+        // is checked for in `evaluate_stack` (and hence users\n+        // who might care about this case, like coherence, should use\n+        // that function).\n+        if candidates.is_empty() {\n+            // If there's an error type, 'downgrade' our result from\n+            // `Err(Unimplemented)` to `Ok(None)`. This helps us avoid\n+            // emitting additional spurious errors, since we're guaranteed\n+            // to have emitted at least one.\n+            if stack.obligation.references_error() {\n+                debug!(\"no results for error type, treating as ambiguous\");\n+                return Ok(None);\n+            }\n+            return Err(Unimplemented);\n+        }\n+\n+        // Just one candidate left.\n+        self.filter_negative_and_reservation_impls(candidates.pop().unwrap().candidate)\n+    }\n+\n     pub(super) fn assemble_candidates<'o>(\n         &mut self,\n         stack: &TraitObligationStack<'o, 'tcx>,"}, {"sha": "114dc79c44f50e58134f45cc14a8ba6ede5d5f1f", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 0, "deletions": 155, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/b218b952f800c1160b8b5e764ca651b02d678565/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b218b952f800c1160b8b5e764ca651b02d678565/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=b218b952f800c1160b8b5e764ca651b02d678565", "patch": "@@ -1029,161 +1029,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         Ok(Some(candidate))\n     }\n \n-    fn candidate_from_obligation_no_cache<'o>(\n-        &mut self,\n-        stack: &TraitObligationStack<'o, 'tcx>,\n-    ) -> SelectionResult<'tcx, SelectionCandidate<'tcx>> {\n-        if let Some(conflict) = self.is_knowable(stack) {\n-            debug!(\"coherence stage: not knowable\");\n-            if self.intercrate_ambiguity_causes.is_some() {\n-                debug!(\"evaluate_stack: intercrate_ambiguity_causes is some\");\n-                // Heuristics: show the diagnostics when there are no candidates in crate.\n-                if let Ok(candidate_set) = self.assemble_candidates(stack) {\n-                    let mut no_candidates_apply = true;\n-\n-                    for c in candidate_set.vec.iter() {\n-                        if self.evaluate_candidate(stack, &c)?.may_apply() {\n-                            no_candidates_apply = false;\n-                            break;\n-                        }\n-                    }\n-\n-                    if !candidate_set.ambiguous && no_candidates_apply {\n-                        let trait_ref = stack.obligation.predicate.skip_binder().trait_ref;\n-                        let self_ty = trait_ref.self_ty();\n-                        let (trait_desc, self_desc) = with_no_trimmed_paths(|| {\n-                            let trait_desc = trait_ref.print_only_trait_path().to_string();\n-                            let self_desc = if self_ty.has_concrete_skeleton() {\n-                                Some(self_ty.to_string())\n-                            } else {\n-                                None\n-                            };\n-                            (trait_desc, self_desc)\n-                        });\n-                        let cause = if let Conflict::Upstream = conflict {\n-                            IntercrateAmbiguityCause::UpstreamCrateUpdate { trait_desc, self_desc }\n-                        } else {\n-                            IntercrateAmbiguityCause::DownstreamCrate { trait_desc, self_desc }\n-                        };\n-                        debug!(\"evaluate_stack: pushing cause = {:?}\", cause);\n-                        self.intercrate_ambiguity_causes.as_mut().unwrap().push(cause);\n-                    }\n-                }\n-            }\n-            return Ok(None);\n-        }\n-\n-        let candidate_set = self.assemble_candidates(stack)?;\n-\n-        if candidate_set.ambiguous {\n-            debug!(\"candidate set contains ambig\");\n-            return Ok(None);\n-        }\n-\n-        let mut candidates = candidate_set.vec;\n-\n-        debug!(\"assembled {} candidates for {:?}: {:?}\", candidates.len(), stack, candidates);\n-\n-        // At this point, we know that each of the entries in the\n-        // candidate set is *individually* applicable. Now we have to\n-        // figure out if they contain mutual incompatibilities. This\n-        // frequently arises if we have an unconstrained input type --\n-        // for example, we are looking for `$0: Eq` where `$0` is some\n-        // unconstrained type variable. In that case, we'll get a\n-        // candidate which assumes $0 == int, one that assumes `$0 ==\n-        // usize`, etc. This spells an ambiguity.\n-\n-        // If there is more than one candidate, first winnow them down\n-        // by considering extra conditions (nested obligations and so\n-        // forth). We don't winnow if there is exactly one\n-        // candidate. This is a relatively minor distinction but it\n-        // can lead to better inference and error-reporting. An\n-        // example would be if there was an impl:\n-        //\n-        //     impl<T:Clone> Vec<T> { fn push_clone(...) { ... } }\n-        //\n-        // and we were to see some code `foo.push_clone()` where `boo`\n-        // is a `Vec<Bar>` and `Bar` does not implement `Clone`.  If\n-        // we were to winnow, we'd wind up with zero candidates.\n-        // Instead, we select the right impl now but report \"`Bar` does\n-        // not implement `Clone`\".\n-        if candidates.len() == 1 {\n-            return self.filter_negative_and_reservation_impls(candidates.pop().unwrap());\n-        }\n-\n-        // Winnow, but record the exact outcome of evaluation, which\n-        // is needed for specialization. Propagate overflow if it occurs.\n-        let mut candidates = candidates\n-            .into_iter()\n-            .map(|c| match self.evaluate_candidate(stack, &c) {\n-                Ok(eval) if eval.may_apply() => {\n-                    Ok(Some(EvaluatedCandidate { candidate: c, evaluation: eval }))\n-                }\n-                Ok(_) => Ok(None),\n-                Err(OverflowError) => Err(Overflow),\n-            })\n-            .flat_map(Result::transpose)\n-            .collect::<Result<Vec<_>, _>>()?;\n-\n-        debug!(\"winnowed to {} candidates for {:?}: {:?}\", candidates.len(), stack, candidates);\n-\n-        let needs_infer = stack.obligation.predicate.needs_infer();\n-\n-        // If there are STILL multiple candidates, we can further\n-        // reduce the list by dropping duplicates -- including\n-        // resolving specializations.\n-        if candidates.len() > 1 {\n-            let mut i = 0;\n-            while i < candidates.len() {\n-                let is_dup = (0..candidates.len()).filter(|&j| i != j).any(|j| {\n-                    self.candidate_should_be_dropped_in_favor_of(\n-                        &candidates[i],\n-                        &candidates[j],\n-                        needs_infer,\n-                    )\n-                });\n-                if is_dup {\n-                    debug!(\"Dropping candidate #{}/{}: {:?}\", i, candidates.len(), candidates[i]);\n-                    candidates.swap_remove(i);\n-                } else {\n-                    debug!(\"Retaining candidate #{}/{}: {:?}\", i, candidates.len(), candidates[i]);\n-                    i += 1;\n-\n-                    // If there are *STILL* multiple candidates, give up\n-                    // and report ambiguity.\n-                    if i > 1 {\n-                        debug!(\"multiple matches, ambig\");\n-                        return Ok(None);\n-                    }\n-                }\n-            }\n-        }\n-\n-        // If there are *NO* candidates, then there are no impls --\n-        // that we know of, anyway. Note that in the case where there\n-        // are unbound type variables within the obligation, it might\n-        // be the case that you could still satisfy the obligation\n-        // from another crate by instantiating the type variables with\n-        // a type from another crate that does have an impl. This case\n-        // is checked for in `evaluate_stack` (and hence users\n-        // who might care about this case, like coherence, should use\n-        // that function).\n-        if candidates.is_empty() {\n-            // If there's an error type, 'downgrade' our result from\n-            // `Err(Unimplemented)` to `Ok(None)`. This helps us avoid\n-            // emitting additional spurious errors, since we're guaranteed\n-            // to have emitted at least one.\n-            if stack.obligation.references_error() {\n-                debug!(\"no results for error type, treating as ambiguous\");\n-                return Ok(None);\n-            }\n-            return Err(Unimplemented);\n-        }\n-\n-        // Just one candidate left.\n-        self.filter_negative_and_reservation_impls(candidates.pop().unwrap().candidate)\n-    }\n-\n     fn is_knowable<'o>(&mut self, stack: &TraitObligationStack<'o, 'tcx>) -> Option<Conflict> {\n         debug!(\"is_knowable(intercrate={:?})\", self.intercrate);\n "}, {"sha": "75158eefcac28c11e1d62dd8a90cc9257f038964", "filename": "library/alloc/src/alloc.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b218b952f800c1160b8b5e764ca651b02d678565/library%2Falloc%2Fsrc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b218b952f800c1160b8b5e764ca651b02d678565/library%2Falloc%2Fsrc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Falloc.rs?ref=b218b952f800c1160b8b5e764ca651b02d678565", "patch": "@@ -145,13 +145,13 @@ pub unsafe fn alloc_zeroed(layout: Layout) -> *mut u8 {\n \n impl Global {\n     #[inline]\n-    fn alloc_impl(&self, layout: Layout, zeroed: bool) -> Result<NonNull<[u8]>, AllocErr> {\n+    fn alloc_impl(&self, layout: Layout, zeroed: bool) -> Result<NonNull<[u8]>, AllocError> {\n         match layout.size() {\n             0 => Ok(NonNull::slice_from_raw_parts(layout.dangling(), 0)),\n             // SAFETY: `layout` is non-zero in size,\n             size => unsafe {\n                 let raw_ptr = if zeroed { alloc_zeroed(layout) } else { alloc(layout) };\n-                let ptr = NonNull::new(raw_ptr).ok_or(AllocErr)?;\n+                let ptr = NonNull::new(raw_ptr).ok_or(AllocError)?;\n                 Ok(NonNull::slice_from_raw_parts(ptr, size))\n             },\n         }\n@@ -165,7 +165,7 @@ impl Global {\n         old_layout: Layout,\n         new_layout: Layout,\n         zeroed: bool,\n-    ) -> Result<NonNull<[u8]>, AllocErr> {\n+    ) -> Result<NonNull<[u8]>, AllocError> {\n         debug_assert!(\n             new_layout.size() >= old_layout.size(),\n             \"`new_layout.size()` must be greater than or equal to `old_layout.size()`\"\n@@ -183,7 +183,7 @@ impl Global {\n                 intrinsics::assume(new_size >= old_layout.size());\n \n                 let raw_ptr = realloc(ptr.as_ptr(), old_layout, new_size);\n-                let ptr = NonNull::new(raw_ptr).ok_or(AllocErr)?;\n+                let ptr = NonNull::new(raw_ptr).ok_or(AllocError)?;\n                 if zeroed {\n                     raw_ptr.add(old_size).write_bytes(0, new_size - old_size);\n                 }\n@@ -208,12 +208,12 @@ impl Global {\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n unsafe impl AllocRef for Global {\n     #[inline]\n-    fn alloc(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr> {\n+    fn alloc(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError> {\n         self.alloc_impl(layout, false)\n     }\n \n     #[inline]\n-    fn alloc_zeroed(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr> {\n+    fn alloc_zeroed(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError> {\n         self.alloc_impl(layout, true)\n     }\n \n@@ -232,7 +232,7 @@ unsafe impl AllocRef for Global {\n         ptr: NonNull<u8>,\n         old_layout: Layout,\n         new_layout: Layout,\n-    ) -> Result<NonNull<[u8]>, AllocErr> {\n+    ) -> Result<NonNull<[u8]>, AllocError> {\n         // SAFETY: all conditions must be upheld by the caller\n         unsafe { self.grow_impl(ptr, old_layout, new_layout, false) }\n     }\n@@ -243,7 +243,7 @@ unsafe impl AllocRef for Global {\n         ptr: NonNull<u8>,\n         old_layout: Layout,\n         new_layout: Layout,\n-    ) -> Result<NonNull<[u8]>, AllocErr> {\n+    ) -> Result<NonNull<[u8]>, AllocError> {\n         // SAFETY: all conditions must be upheld by the caller\n         unsafe { self.grow_impl(ptr, old_layout, new_layout, true) }\n     }\n@@ -254,7 +254,7 @@ unsafe impl AllocRef for Global {\n         ptr: NonNull<u8>,\n         old_layout: Layout,\n         new_layout: Layout,\n-    ) -> Result<NonNull<[u8]>, AllocErr> {\n+    ) -> Result<NonNull<[u8]>, AllocError> {\n         debug_assert!(\n             new_layout.size() <= old_layout.size(),\n             \"`new_layout.size()` must be smaller than or equal to `old_layout.size()`\"\n@@ -273,7 +273,7 @@ unsafe impl AllocRef for Global {\n                 intrinsics::assume(new_size <= old_layout.size());\n \n                 let raw_ptr = realloc(ptr.as_ptr(), old_layout, new_size);\n-                let ptr = NonNull::new(raw_ptr).ok_or(AllocErr)?;\n+                let ptr = NonNull::new(raw_ptr).ok_or(AllocError)?;\n                 Ok(NonNull::slice_from_raw_parts(ptr, new_size))\n             },\n "}, {"sha": "cb4fe1b46cd75161048476850159ae358013e90d", "filename": "library/alloc/src/raw_vec/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b218b952f800c1160b8b5e764ca651b02d678565/library%2Falloc%2Fsrc%2Fraw_vec%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b218b952f800c1160b8b5e764ca651b02d678565/library%2Falloc%2Fsrc%2Fraw_vec%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fraw_vec%2Ftests.rs?ref=b218b952f800c1160b8b5e764ca651b02d678565", "patch": "@@ -3,7 +3,7 @@ use std::cell::Cell;\n \n #[test]\n fn allocator_param() {\n-    use crate::alloc::AllocErr;\n+    use crate::alloc::AllocError;\n \n     // Writing a test of integration between third-party\n     // allocators and `RawVec` is a little tricky because the `RawVec`\n@@ -21,10 +21,10 @@ fn allocator_param() {\n         fuel: Cell<usize>,\n     }\n     unsafe impl AllocRef for BoundedAlloc {\n-        fn alloc(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr> {\n+        fn alloc(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError> {\n             let size = layout.size();\n             if size > self.fuel.get() {\n-                return Err(AllocErr);\n+                return Err(AllocError);\n             }\n             match Global.alloc(layout) {\n                 ok @ Ok(_) => {"}, {"sha": "5dbc42cc97d5b3f85d0bf0ec30f44c190afda307", "filename": "library/alloc/src/rc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b218b952f800c1160b8b5e764ca651b02d678565/library%2Falloc%2Fsrc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b218b952f800c1160b8b5e764ca651b02d678565/library%2Falloc%2Fsrc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Frc.rs?ref=b218b952f800c1160b8b5e764ca651b02d678565", "patch": "@@ -247,7 +247,7 @@ use core::pin::Pin;\n use core::ptr::{self, NonNull};\n use core::slice::from_raw_parts_mut;\n \n-use crate::alloc::{box_free, handle_alloc_error, AllocErr, AllocRef, Global, Layout};\n+use crate::alloc::{box_free, handle_alloc_error, AllocError, AllocRef, Global, Layout};\n use crate::borrow::{Cow, ToOwned};\n use crate::string::String;\n use crate::vec::Vec;\n@@ -996,7 +996,7 @@ impl<T: ?Sized> Rc<T> {\n     /// and must return back a (potentially fat)-pointer for the `RcBox<T>`.\n     unsafe fn allocate_for_layout(\n         value_layout: Layout,\n-        allocate: impl FnOnce(Layout) -> Result<NonNull<[u8]>, AllocErr>,\n+        allocate: impl FnOnce(Layout) -> Result<NonNull<[u8]>, AllocError>,\n         mem_to_rcbox: impl FnOnce(*mut u8) -> *mut RcBox<T>,\n     ) -> *mut RcBox<T> {\n         // Calculate layout using the given value layout."}, {"sha": "3d7411c79dc4f8831175ec53dfcc785296f66115", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b218b952f800c1160b8b5e764ca651b02d678565/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b218b952f800c1160b8b5e764ca651b02d678565/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=b218b952f800c1160b8b5e764ca651b02d678565", "patch": "@@ -21,7 +21,7 @@ use core::slice::from_raw_parts_mut;\n use core::sync::atomic;\n use core::sync::atomic::Ordering::{Acquire, Relaxed, Release, SeqCst};\n \n-use crate::alloc::{box_free, handle_alloc_error, AllocErr, AllocRef, Global, Layout};\n+use crate::alloc::{box_free, handle_alloc_error, AllocError, AllocRef, Global, Layout};\n use crate::borrow::{Cow, ToOwned};\n use crate::boxed::Box;\n use crate::rc::is_dangling;\n@@ -969,7 +969,7 @@ impl<T: ?Sized> Arc<T> {\n     /// and must return back a (potentially fat)-pointer for the `ArcInner<T>`.\n     unsafe fn allocate_for_layout(\n         value_layout: Layout,\n-        allocate: impl FnOnce(Layout) -> Result<NonNull<[u8]>, AllocErr>,\n+        allocate: impl FnOnce(Layout) -> Result<NonNull<[u8]>, AllocError>,\n         mem_to_arcinner: impl FnOnce(*mut u8) -> *mut ArcInner<T>,\n     ) -> *mut ArcInner<T> {\n         // Calculate layout using the given value layout."}, {"sha": "6d09b4f02635b21b409373eb34bd097f7428bce4", "filename": "library/core/src/alloc/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b218b952f800c1160b8b5e764ca651b02d678565/library%2Fcore%2Fsrc%2Falloc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b218b952f800c1160b8b5e764ca651b02d678565/library%2Fcore%2Fsrc%2Falloc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Falloc%2Fmod.rs?ref=b218b952f800c1160b8b5e764ca651b02d678565", "patch": "@@ -13,17 +13,17 @@ pub use self::layout::{Layout, LayoutErr};\n use crate::fmt;\n use crate::ptr::{self, NonNull};\n \n-/// The `AllocErr` error indicates an allocation failure\n+/// The `AllocError` error indicates an allocation failure\n /// that may be due to resource exhaustion or to\n /// something wrong when combining the given input arguments with this\n /// allocator.\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-pub struct AllocErr;\n+pub struct AllocError;\n \n // (we need this for downstream impl of trait Error)\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-impl fmt::Display for AllocErr {\n+impl fmt::Display for AllocError {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.write_str(\"memory allocation failed\")\n     }\n@@ -109,7 +109,7 @@ pub unsafe trait AllocRef {\n     /// call the [`handle_alloc_error`] function, rather than directly invoking `panic!` or similar.\n     ///\n     /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n-    fn alloc(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr>;\n+    fn alloc(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError>;\n \n     /// Behaves like `alloc`, but also ensures that the returned memory is zero-initialized.\n     ///\n@@ -126,7 +126,7 @@ pub unsafe trait AllocRef {\n     /// call the [`handle_alloc_error`] function, rather than directly invoking `panic!` or similar.\n     ///\n     /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n-    fn alloc_zeroed(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr> {\n+    fn alloc_zeroed(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError> {\n         let ptr = self.alloc(layout)?;\n         // SAFETY: `alloc` returns a valid memory block\n         unsafe { ptr.as_non_null_ptr().as_ptr().write_bytes(0, ptr.len()) }\n@@ -187,7 +187,7 @@ pub unsafe trait AllocRef {\n         ptr: NonNull<u8>,\n         old_layout: Layout,\n         new_layout: Layout,\n-    ) -> Result<NonNull<[u8]>, AllocErr> {\n+    ) -> Result<NonNull<[u8]>, AllocError> {\n         debug_assert!(\n             new_layout.size() >= old_layout.size(),\n             \"`new_layout.size()` must be greater than or equal to `old_layout.size()`\"\n@@ -248,7 +248,7 @@ pub unsafe trait AllocRef {\n         ptr: NonNull<u8>,\n         old_layout: Layout,\n         new_layout: Layout,\n-    ) -> Result<NonNull<[u8]>, AllocErr> {\n+    ) -> Result<NonNull<[u8]>, AllocError> {\n         debug_assert!(\n             new_layout.size() >= old_layout.size(),\n             \"`new_layout.size()` must be greater than or equal to `old_layout.size()`\"\n@@ -312,7 +312,7 @@ pub unsafe trait AllocRef {\n         ptr: NonNull<u8>,\n         old_layout: Layout,\n         new_layout: Layout,\n-    ) -> Result<NonNull<[u8]>, AllocErr> {\n+    ) -> Result<NonNull<[u8]>, AllocError> {\n         debug_assert!(\n             new_layout.size() <= old_layout.size(),\n             \"`new_layout.size()` must be smaller than or equal to `old_layout.size()`\"\n@@ -348,12 +348,12 @@ where\n     A: AllocRef + ?Sized,\n {\n     #[inline]\n-    fn alloc(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr> {\n+    fn alloc(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError> {\n         (**self).alloc(layout)\n     }\n \n     #[inline]\n-    fn alloc_zeroed(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr> {\n+    fn alloc_zeroed(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError> {\n         (**self).alloc_zeroed(layout)\n     }\n \n@@ -369,7 +369,7 @@ where\n         ptr: NonNull<u8>,\n         old_layout: Layout,\n         new_layout: Layout,\n-    ) -> Result<NonNull<[u8]>, AllocErr> {\n+    ) -> Result<NonNull<[u8]>, AllocError> {\n         // SAFETY: the safety contract must be upheld by the caller\n         unsafe { (**self).grow(ptr, old_layout, new_layout) }\n     }\n@@ -380,7 +380,7 @@ where\n         ptr: NonNull<u8>,\n         old_layout: Layout,\n         new_layout: Layout,\n-    ) -> Result<NonNull<[u8]>, AllocErr> {\n+    ) -> Result<NonNull<[u8]>, AllocError> {\n         // SAFETY: the safety contract must be upheld by the caller\n         unsafe { (**self).grow_zeroed(ptr, old_layout, new_layout) }\n     }\n@@ -391,7 +391,7 @@ where\n         ptr: NonNull<u8>,\n         old_layout: Layout,\n         new_layout: Layout,\n-    ) -> Result<NonNull<[u8]>, AllocErr> {\n+    ) -> Result<NonNull<[u8]>, AllocError> {\n         // SAFETY: the safety contract must be upheld by the caller\n         unsafe { (**self).shrink(ptr, old_layout, new_layout) }\n     }"}, {"sha": "1e520b62f77c40b8e3fc0365410b0504e1c593dd", "filename": "library/core/src/iter/adapters/mod.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b218b952f800c1160b8b5e764ca651b02d678565/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b218b952f800c1160b8b5e764ca651b02d678565/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs?ref=b218b952f800c1160b8b5e764ca651b02d678565", "patch": "@@ -124,6 +124,11 @@ where\n         self.iter.size_hint()\n     }\n \n+    #[inline]\n+    fn advance_by(&mut self, n: usize) -> Result<(), usize> {\n+        self.iter.advance_back_by(n)\n+    }\n+\n     #[inline]\n     fn nth(&mut self, n: usize) -> Option<<I as Iterator>::Item> {\n         self.iter.nth_back(n)\n@@ -164,6 +169,11 @@ where\n         self.iter.next()\n     }\n \n+    #[inline]\n+    fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n+        self.iter.advance_by(n)\n+    }\n+\n     #[inline]\n     fn nth_back(&mut self, n: usize) -> Option<<I as Iterator>::Item> {\n         self.iter.nth(n)"}, {"sha": "d370c16ea5a806d30cbb9a4aa0320c7f8ac0b544", "filename": "library/core/src/iter/traits/double_ended.rs", "status": "modified", "additions": 46, "deletions": 8, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/b218b952f800c1160b8b5e764ca651b02d678565/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fdouble_ended.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b218b952f800c1160b8b5e764ca651b02d678565/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fdouble_ended.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fdouble_ended.rs?ref=b218b952f800c1160b8b5e764ca651b02d678565", "patch": "@@ -91,6 +91,46 @@ pub trait DoubleEndedIterator: Iterator {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn next_back(&mut self) -> Option<Self::Item>;\n \n+    /// Advances the iterator from the back by `n` elements.\n+    ///\n+    /// `advance_back_by` is the reverse version of [`advance_by`]. This method will\n+    /// eagerly skip `n` elements starting from the back by calling [`next_back`] up\n+    /// to `n` times until [`None`] is encountered.\n+    ///\n+    /// `advance_back_by(n)` will return [`Ok(())`] if the iterator successfully advances by\n+    /// `n` elements, or [`Err(k)`] if [`None`] is encountered, where `k` is the number of\n+    /// elements the iterator is advanced by before running out of elements (i.e. the length\n+    /// of the iterator). Note that `k` is always less than `n`.\n+    ///\n+    /// Calling `advance_back_by(0)` does not consume any elements and always returns [`Ok(())`].\n+    ///\n+    /// [`advance_by`]: Iterator::advance_by\n+    /// [`next_back`]: DoubleEndedIterator::next_back\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(iter_advance_by)]\n+    ///\n+    /// let a = [3, 4, 5, 6];\n+    /// let mut iter = a.iter();\n+    ///\n+    /// assert_eq!(iter.advance_back_by(2), Ok(()));\n+    /// assert_eq!(iter.next_back(), Some(&4));\n+    /// assert_eq!(iter.advance_back_by(0), Ok(()));\n+    /// assert_eq!(iter.advance_back_by(100), Err(1)); // only `&3` was skipped\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"iter_advance_by\", reason = \"recently added\", issue = \"none\")]\n+    fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n+        for i in 0..n {\n+            self.next_back().ok_or(i)?;\n+        }\n+        Ok(())\n+    }\n+\n     /// Returns the `n`th element from the end of the iterator.\n     ///\n     /// This is essentially the reversed version of [`Iterator::nth()`].\n@@ -134,14 +174,9 @@ pub trait DoubleEndedIterator: Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"iter_nth_back\", since = \"1.37.0\")]\n-    fn nth_back(&mut self, mut n: usize) -> Option<Self::Item> {\n-        for x in self.rev() {\n-            if n == 0 {\n-                return Some(x);\n-            }\n-            n -= 1;\n-        }\n-        None\n+    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n+        self.advance_back_by(n).ok()?;\n+        self.next_back()\n     }\n \n     /// This is the reverse version of [`Iterator::try_fold()`]: it takes\n@@ -318,6 +353,9 @@ impl<'a, I: DoubleEndedIterator + ?Sized> DoubleEndedIterator for &'a mut I {\n     fn next_back(&mut self) -> Option<I::Item> {\n         (**self).next_back()\n     }\n+    fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n+        (**self).advance_back_by(n)\n+    }\n     fn nth_back(&mut self, n: usize) -> Option<I::Item> {\n         (**self).nth_back(n)\n     }"}, {"sha": "36d4a50856f53ae4b23a74419d1556066792774e", "filename": "library/core/src/iter/traits/iterator.rs", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/b218b952f800c1160b8b5e764ca651b02d678565/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b218b952f800c1160b8b5e764ca651b02d678565/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs?ref=b218b952f800c1160b8b5e764ca651b02d678565", "patch": "@@ -284,6 +284,44 @@ pub trait Iterator {\n         self.fold(None, some)\n     }\n \n+    /// Advances the iterator by `n` elements.\n+    ///\n+    /// This method will eagerly skip `n` elements by calling [`next`] up to `n`\n+    /// times until [`None`] is encountered.\n+    ///\n+    /// `advance_by(n)` will return [`Ok(())`] if the iterator successfully advances by\n+    /// `n` elements, or [`Err(k)`] if [`None`] is encountered, where `k` is the number\n+    /// of elements the iterator is advanced by before running out of elements (i.e. the\n+    /// length of the iterator). Note that `k` is always less than `n`.\n+    ///\n+    /// Calling `advance_by(0)` does not consume any elements and always returns [`Ok(())`].\n+    ///\n+    /// [`next`]: Iterator::next\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(iter_advance_by)]\n+    ///\n+    /// let a = [1, 2, 3, 4];\n+    /// let mut iter = a.iter();\n+    ///\n+    /// assert_eq!(iter.advance_by(2), Ok(()));\n+    /// assert_eq!(iter.next(), Some(&3));\n+    /// assert_eq!(iter.advance_by(0), Ok(()));\n+    /// assert_eq!(iter.advance_by(100), Err(1)); // only `&4` was skipped\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"iter_advance_by\", reason = \"recently added\", issue = \"none\")]\n+    fn advance_by(&mut self, n: usize) -> Result<(), usize> {\n+        for i in 0..n {\n+            self.next().ok_or(i)?;\n+        }\n+        Ok(())\n+    }\n+\n     /// Returns the `n`th element of the iterator.\n     ///\n     /// Like most indexing operations, the count starts from zero, so `nth(0)`\n@@ -325,14 +363,9 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn nth(&mut self, mut n: usize) -> Option<Self::Item> {\n-        while let Some(x) = self.next() {\n-            if n == 0 {\n-                return Some(x);\n-            }\n-            n -= 1;\n-        }\n-        None\n+    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n+        self.advance_by(n).ok()?;\n+        self.next()\n     }\n \n     /// Creates an iterator starting at the same point, but stepping by\n@@ -3265,6 +3298,9 @@ impl<I: Iterator + ?Sized> Iterator for &mut I {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         (**self).size_hint()\n     }\n+    fn advance_by(&mut self, n: usize) -> Result<(), usize> {\n+        (**self).advance_by(n)\n+    }\n     fn nth(&mut self, n: usize) -> Option<Self::Item> {\n         (**self).nth(n)\n     }"}, {"sha": "5dc7171a7dc26c4ac3cb474d7bce98d4f8e27dfa", "filename": "library/core/src/ptr/non_null.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b218b952f800c1160b8b5e764ca651b02d678565/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b218b952f800c1160b8b5e764ca651b02d678565/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs?ref=b218b952f800c1160b8b5e764ca651b02d678565", "patch": "@@ -448,7 +448,7 @@ impl<T> NonNull<[T]> {\n     /// // Note that calling `memory.as_mut()` is not allowed here as the content may be uninitialized.\n     /// # #[allow(unused_variables)]\n     /// let slice: &mut [MaybeUninit<u8>] = unsafe { memory.as_uninit_slice_mut() };\n-    /// # Ok::<_, std::alloc::AllocErr>(())\n+    /// # Ok::<_, std::alloc::AllocError>(())\n     /// ```\n     #[inline]\n     #[unstable(feature = \"ptr_as_uninit\", issue = \"75402\")]"}, {"sha": "b15d6d1b1f613cc2fd096de55e41784113d1174b", "filename": "library/core/tests/iter.rs", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/b218b952f800c1160b8b5e764ca651b02d678565/library%2Fcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b218b952f800c1160b8b5e764ca651b02d678565/library%2Fcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter.rs?ref=b218b952f800c1160b8b5e764ca651b02d678565", "patch": "@@ -1570,6 +1570,66 @@ fn test_iterator_rev_nth() {\n     assert_eq!(v.iter().rev().nth(v.len()), None);\n }\n \n+#[test]\n+fn test_iterator_advance_by() {\n+    let v: &[_] = &[0, 1, 2, 3, 4];\n+\n+    for i in 0..v.len() {\n+        let mut iter = v.iter();\n+        assert_eq!(iter.advance_by(i), Ok(()));\n+        assert_eq!(iter.next().unwrap(), &v[i]);\n+        assert_eq!(iter.advance_by(100), Err(v.len() - 1 - i));\n+    }\n+\n+    assert_eq!(v.iter().advance_by(v.len()), Ok(()));\n+    assert_eq!(v.iter().advance_by(100), Err(v.len()));\n+}\n+\n+#[test]\n+fn test_iterator_advance_back_by() {\n+    let v: &[_] = &[0, 1, 2, 3, 4];\n+\n+    for i in 0..v.len() {\n+        let mut iter = v.iter();\n+        assert_eq!(iter.advance_back_by(i), Ok(()));\n+        assert_eq!(iter.next_back().unwrap(), &v[v.len() - 1 - i]);\n+        assert_eq!(iter.advance_back_by(100), Err(v.len() - 1 - i));\n+    }\n+\n+    assert_eq!(v.iter().advance_back_by(v.len()), Ok(()));\n+    assert_eq!(v.iter().advance_back_by(100), Err(v.len()));\n+}\n+\n+#[test]\n+fn test_iterator_rev_advance_by() {\n+    let v: &[_] = &[0, 1, 2, 3, 4];\n+\n+    for i in 0..v.len() {\n+        let mut iter = v.iter().rev();\n+        assert_eq!(iter.advance_by(i), Ok(()));\n+        assert_eq!(iter.next().unwrap(), &v[v.len() - 1 - i]);\n+        assert_eq!(iter.advance_by(100), Err(v.len() - 1 - i));\n+    }\n+\n+    assert_eq!(v.iter().rev().advance_by(v.len()), Ok(()));\n+    assert_eq!(v.iter().rev().advance_by(100), Err(v.len()));\n+}\n+\n+#[test]\n+fn test_iterator_rev_advance_back_by() {\n+    let v: &[_] = &[0, 1, 2, 3, 4];\n+\n+    for i in 0..v.len() {\n+        let mut iter = v.iter().rev();\n+        assert_eq!(iter.advance_back_by(i), Ok(()));\n+        assert_eq!(iter.next_back().unwrap(), &v[i]);\n+        assert_eq!(iter.advance_back_by(100), Err(v.len() - 1 - i));\n+    }\n+\n+    assert_eq!(v.iter().rev().advance_back_by(v.len()), Ok(()));\n+    assert_eq!(v.iter().rev().advance_back_by(100), Err(v.len()));\n+}\n+\n #[test]\n fn test_iterator_last() {\n     let v: &[_] = &[0, 1, 2, 3, 4];"}, {"sha": "0c4ce867f542d64b08e5f393fa929beeabbdd900", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b218b952f800c1160b8b5e764ca651b02d678565/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b218b952f800c1160b8b5e764ca651b02d678565/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=b218b952f800c1160b8b5e764ca651b02d678565", "patch": "@@ -41,6 +41,7 @@\n #![feature(slice_partition_dedup)]\n #![feature(int_error_matching)]\n #![feature(array_value_iter)]\n+#![feature(iter_advance_by)]\n #![feature(iter_partition_in_place)]\n #![feature(iter_is_partitioned)]\n #![feature(iter_order_by)]"}, {"sha": "dd7600623801f86ec3daacf93a2cfd669a0767be", "filename": "library/std/src/alloc.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b218b952f800c1160b8b5e764ca651b02d678565/library%2Fstd%2Fsrc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b218b952f800c1160b8b5e764ca651b02d678565/library%2Fstd%2Fsrc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Falloc.rs?ref=b218b952f800c1160b8b5e764ca651b02d678565", "patch": "@@ -133,7 +133,7 @@ pub struct System;\n \n impl System {\n     #[inline]\n-    fn alloc_impl(&self, layout: Layout, zeroed: bool) -> Result<NonNull<[u8]>, AllocErr> {\n+    fn alloc_impl(&self, layout: Layout, zeroed: bool) -> Result<NonNull<[u8]>, AllocError> {\n         match layout.size() {\n             0 => Ok(NonNull::slice_from_raw_parts(layout.dangling(), 0)),\n             // SAFETY: `layout` is non-zero in size,\n@@ -143,7 +143,7 @@ impl System {\n                 } else {\n                     GlobalAlloc::alloc(self, layout)\n                 };\n-                let ptr = NonNull::new(raw_ptr).ok_or(AllocErr)?;\n+                let ptr = NonNull::new(raw_ptr).ok_or(AllocError)?;\n                 Ok(NonNull::slice_from_raw_parts(ptr, size))\n             },\n         }\n@@ -157,7 +157,7 @@ impl System {\n         old_layout: Layout,\n         new_layout: Layout,\n         zeroed: bool,\n-    ) -> Result<NonNull<[u8]>, AllocErr> {\n+    ) -> Result<NonNull<[u8]>, AllocError> {\n         debug_assert!(\n             new_layout.size() >= old_layout.size(),\n             \"`new_layout.size()` must be greater than or equal to `old_layout.size()`\"\n@@ -175,7 +175,7 @@ impl System {\n                 intrinsics::assume(new_size >= old_layout.size());\n \n                 let raw_ptr = GlobalAlloc::realloc(self, ptr.as_ptr(), old_layout, new_size);\n-                let ptr = NonNull::new(raw_ptr).ok_or(AllocErr)?;\n+                let ptr = NonNull::new(raw_ptr).ok_or(AllocError)?;\n                 if zeroed {\n                     raw_ptr.add(old_size).write_bytes(0, new_size - old_size);\n                 }\n@@ -202,12 +202,12 @@ impl System {\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n unsafe impl AllocRef for System {\n     #[inline]\n-    fn alloc(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr> {\n+    fn alloc(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError> {\n         self.alloc_impl(layout, false)\n     }\n \n     #[inline]\n-    fn alloc_zeroed(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr> {\n+    fn alloc_zeroed(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError> {\n         self.alloc_impl(layout, true)\n     }\n \n@@ -226,7 +226,7 @@ unsafe impl AllocRef for System {\n         ptr: NonNull<u8>,\n         old_layout: Layout,\n         new_layout: Layout,\n-    ) -> Result<NonNull<[u8]>, AllocErr> {\n+    ) -> Result<NonNull<[u8]>, AllocError> {\n         // SAFETY: all conditions must be upheld by the caller\n         unsafe { self.grow_impl(ptr, old_layout, new_layout, false) }\n     }\n@@ -237,7 +237,7 @@ unsafe impl AllocRef for System {\n         ptr: NonNull<u8>,\n         old_layout: Layout,\n         new_layout: Layout,\n-    ) -> Result<NonNull<[u8]>, AllocErr> {\n+    ) -> Result<NonNull<[u8]>, AllocError> {\n         // SAFETY: all conditions must be upheld by the caller\n         unsafe { self.grow_impl(ptr, old_layout, new_layout, true) }\n     }\n@@ -248,7 +248,7 @@ unsafe impl AllocRef for System {\n         ptr: NonNull<u8>,\n         old_layout: Layout,\n         new_layout: Layout,\n-    ) -> Result<NonNull<[u8]>, AllocErr> {\n+    ) -> Result<NonNull<[u8]>, AllocError> {\n         debug_assert!(\n             new_layout.size() <= old_layout.size(),\n             \"`new_layout.size()` must be smaller than or equal to `old_layout.size()`\"\n@@ -267,7 +267,7 @@ unsafe impl AllocRef for System {\n                 intrinsics::assume(new_size <= old_layout.size());\n \n                 let raw_ptr = GlobalAlloc::realloc(self, ptr.as_ptr(), old_layout, new_size);\n-                let ptr = NonNull::new(raw_ptr).ok_or(AllocErr)?;\n+                let ptr = NonNull::new(raw_ptr).ok_or(AllocError)?;\n                 Ok(NonNull::slice_from_raw_parts(ptr, new_size))\n             },\n "}, {"sha": "5771ca758afb0bb90c81716ef09d7d204ad71032", "filename": "library/std/src/error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b218b952f800c1160b8b5e764ca651b02d678565/library%2Fstd%2Fsrc%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b218b952f800c1160b8b5e764ca651b02d678565/library%2Fstd%2Fsrc%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ferror.rs?ref=b218b952f800c1160b8b5e764ca651b02d678565", "patch": "@@ -19,7 +19,7 @@ mod tests;\n use core::array;\n use core::convert::Infallible;\n \n-use crate::alloc::{AllocErr, LayoutErr};\n+use crate::alloc::{AllocError, LayoutErr};\n use crate::any::TypeId;\n use crate::backtrace::Backtrace;\n use crate::borrow::Cow;\n@@ -387,7 +387,7 @@ impl Error for ! {}\n     reason = \"the precise API and guarantees it provides may be tweaked.\",\n     issue = \"32838\"\n )]\n-impl Error for AllocErr {}\n+impl Error for AllocError {}\n \n #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n impl Error for LayoutErr {}"}, {"sha": "6c605f045e5e8e2759119bb2a398a7fe71c5fcf8", "filename": "src/doc/rustc/src/platform-support.md", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b218b952f800c1160b8b5e764ca651b02d678565/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "raw_url": "https://github.com/rust-lang/rust/raw/b218b952f800c1160b8b5e764ca651b02d678565/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md?ref=b218b952f800c1160b8b5e764ca651b02d678565", "patch": "@@ -57,7 +57,7 @@ Specifically, these platforms are required to have each of the following:\n \n target | std | host | notes\n -------|-----|------|-------\n-`aarch64-apple-ios` | \u2713[^apple] |  | ARM64 iOS\n+`aarch64-apple-ios` | \u2713 |  | ARM64 iOS\n `aarch64-fuchsia` | \u2713 |  | ARM64 Fuchsia\n `aarch64-linux-android` | \u2713 |  | ARM64 Android\n `aarch64-pc-windows-msvc` | \u2713 |  | ARM64 Windows MSVC\n@@ -122,7 +122,7 @@ target | std | host | notes\n `wasm32-unknown-emscripten` | \u2713 |  | WebAssembly via Emscripten\n `wasm32-unknown-unknown` | \u2713 |  | WebAssembly\n `wasm32-wasi` | \u2713 |  | WebAssembly with WASI\n-`x86_64-apple-ios` | \u2713[^apple] |  | 64-bit x86 iOS\n+`x86_64-apple-ios` | \u2713 |  | 64-bit x86 iOS\n `x86_64-fortanix-unknown-sgx` | \u2713 |  | [Fortanix ABI] for 64-bit Intel SGX\n `x86_64-fuchsia` | \u2713 |  | 64-bit Fuchsia\n `x86_64-linux-android` | \u2713 |  | 64-bit x86 Android\n@@ -146,7 +146,7 @@ not available.\n target | std | host | notes\n -------|-----|------|-------\n `aarch64-apple-darwin` | ? |  | ARM64 macOS\n-`aarch64-apple-tvos` | *[^apple] |  | ARM64 tvOS\n+`aarch64-apple-tvos` | * |  | ARM64 tvOS\n `aarch64-unknown-cloudabi` | \u2713 |  | ARM64 CloudABI\n `aarch64-unknown-freebsd` | \u2713 | \u2713 | ARM64 FreeBSD\n `aarch64-unknown-hermit` | ? |  |\n@@ -158,16 +158,16 @@ target | std | host | notes\n `armv4t-unknown-linux-gnueabi` | ? |  |\n `armv6-unknown-freebsd` | \u2713 | \u2713 | ARMv6 FreeBSD\n `armv6-unknown-netbsd-eabihf` | ? |  |\n-`armv7-apple-ios` | \u2713[^apple] |  | ARMv7 iOS, Cortex-a8\n+`armv7-apple-ios` | \u2713 |  | ARMv7 iOS, Cortex-a8\n `armv7-unknown-cloudabi-eabihf` | \u2713 |  | ARMv7 CloudABI, hardfloat\n `armv7-unknown-freebsd` | \u2713 | \u2713 | ARMv7 FreeBSD\n `armv7-unknown-netbsd-eabihf` | ? |  |\n `armv7-wrs-vxworks-eabihf` | ? |  |\n `armv7a-none-eabihf` | * | | ARM Cortex-A, hardfloat\n-`armv7s-apple-ios` | \u2713[^apple] |  |\n+`armv7s-apple-ios` | \u2713 |  |\n `avr-unknown-gnu-atmega328` | \u2717 |  | AVR. Requires `-Z build-std=core`\n `hexagon-unknown-linux-musl` | ? |  |\n-`i386-apple-ios` | \u2713[^apple] |  | 32-bit x86 iOS\n+`i386-apple-ios` | \u2713 |  | 32-bit x86 iOS\n `i686-apple-darwin` | \u2713 | \u2713 | 32-bit OSX (10.7+, Lion+)\n `i686-pc-windows-msvc` | \u2713 |  | 32-bit Windows XP support\n `i686-unknown-cloudabi` | \u2713 |  | 32-bit CloudABI\n@@ -203,8 +203,8 @@ target | std | host | notes\n `thumbv7a-uwp-windows-msvc` | \u2713 |  |\n `thumbv7neon-unknown-linux-musleabihf` | ? |  | Thumb2-mode ARMv7a Linux with NEON, MUSL\n `thumbv4t-none-eabi` | * |  | ARMv4T T32\n-`x86_64-apple-ios-macabi` | \u2713[^apple] |  | Apple Catalyst\n-`x86_64-apple-tvos` | *[^apple] | | x86 64-bit tvOS\n+`x86_64-apple-ios-macabi` | \u2713 |  | Apple Catalyst\n+`x86_64-apple-tvos` | * | | x86 64-bit tvOS\n `x86_64-linux-kernel` | * |  | Linux kernel modules\n `x86_64-pc-solaris` | ? |  |\n `x86_64-pc-windows-msvc` | \u2713 |  | 64-bit Windows XP support\n@@ -221,4 +221,3 @@ target | std | host | notes\n `x86_64-wrs-vxworks` | ? |  |\n \n [runs on NVIDIA GPUs]: https://github.com/japaric-archived/nvptx#targets\n-[^apple]: These targets are only available on macOS."}, {"sha": "e3a4d9a96aa1e3efe49be314fa05c5a2cb1e1760", "filename": "src/test/ui/const-generics/const_evaluatable_checked/cross_crate_predicate.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b218b952f800c1160b8b5e764ca651b02d678565/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fcross_crate_predicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b218b952f800c1160b8b5e764ca651b02d678565/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fcross_crate_predicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fcross_crate_predicate.rs?ref=b218b952f800c1160b8b5e764ca651b02d678565", "patch": "@@ -5,10 +5,10 @@ extern crate const_evaluatable_lib;\n \n fn user<T>() {\n     let _ = const_evaluatable_lib::test1::<T>();\n-    //~^ ERROR constant expression depends\n-    //~| ERROR constant expression depends\n-    //~| ERROR constant expression depends\n-    //~| ERROR constant expression depends\n+    //~^ ERROR unconstrained generic constant\n+    //~| ERROR unconstrained generic constant\n+    //~| ERROR unconstrained generic constant\n+    //~| ERROR unconstrained generic constant\n }\n \n fn main() {}"}, {"sha": "8a298b47fffa72a913431a3c017cae2d2af81bc3", "filename": "src/test/ui/const-generics/const_evaluatable_checked/cross_crate_predicate.stderr", "status": "modified", "additions": 20, "deletions": 24, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/b218b952f800c1160b8b5e764ca651b02d678565/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fcross_crate_predicate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b218b952f800c1160b8b5e764ca651b02d678565/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fcross_crate_predicate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fcross_crate_predicate.stderr?ref=b218b952f800c1160b8b5e764ca651b02d678565", "patch": "@@ -1,54 +1,50 @@\n-error: constant expression depends on a generic parameter\n+error: unconstrained generic constant\n   --> $DIR/cross_crate_predicate.rs:7:13\n    |\n LL |     let _ = const_evaluatable_lib::test1::<T>();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   | \n-  ::: $DIR/auxiliary/const_evaluatable_lib.rs:6:10\n    |\n-LL |     [u8; std::mem::size_of::<T>() - 1]: Sized,\n-   |          ---------------------------- required by this bound in `test1`\n+help: consider adding a `where` bound for this expression\n+  --> $DIR/auxiliary/const_evaluatable_lib.rs:6:10\n    |\n-   = note: this may fail depending on what value the parameter takes\n+LL |     [u8; std::mem::size_of::<T>() - 1]: Sized,\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: constant expression depends on a generic parameter\n+error: unconstrained generic constant\n   --> $DIR/cross_crate_predicate.rs:7:13\n    |\n LL |     let _ = const_evaluatable_lib::test1::<T>();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   | \n-  ::: $DIR/auxiliary/const_evaluatable_lib.rs:4:27\n    |\n-LL | pub fn test1<T>() -> [u8; std::mem::size_of::<T>() - 1]\n-   |                           ---------------------------- required by this bound in `test1`\n+help: consider adding a `where` bound for this expression\n+  --> $DIR/auxiliary/const_evaluatable_lib.rs:4:27\n    |\n-   = note: this may fail depending on what value the parameter takes\n+LL | pub fn test1<T>() -> [u8; std::mem::size_of::<T>() - 1]\n+   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: constant expression depends on a generic parameter\n+error: unconstrained generic constant\n   --> $DIR/cross_crate_predicate.rs:7:13\n    |\n LL |     let _ = const_evaluatable_lib::test1::<T>();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   | \n-  ::: $DIR/auxiliary/const_evaluatable_lib.rs:6:10\n    |\n-LL |     [u8; std::mem::size_of::<T>() - 1]: Sized,\n-   |          ---------------------------- required by this bound in `test1`\n+help: consider adding a `where` bound for this expression\n+  --> $DIR/auxiliary/const_evaluatable_lib.rs:6:10\n    |\n-   = note: this may fail depending on what value the parameter takes\n+LL |     [u8; std::mem::size_of::<T>() - 1]: Sized,\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: constant expression depends on a generic parameter\n+error: unconstrained generic constant\n   --> $DIR/cross_crate_predicate.rs:7:13\n    |\n LL |     let _ = const_evaluatable_lib::test1::<T>();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   | \n-  ::: $DIR/auxiliary/const_evaluatable_lib.rs:4:27\n    |\n-LL | pub fn test1<T>() -> [u8; std::mem::size_of::<T>() - 1]\n-   |                           ---------------------------- required by this bound in `test1`\n+help: consider adding a `where` bound for this expression\n+  --> $DIR/auxiliary/const_evaluatable_lib.rs:4:27\n    |\n-   = note: this may fail depending on what value the parameter takes\n+LL | pub fn test1<T>() -> [u8; std::mem::size_of::<T>() - 1]\n+   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 4 previous errors\n "}, {"sha": "cad06ea4004aff7176e291622f6d2cc3e8b0df45", "filename": "src/test/ui/const-generics/const_evaluatable_checked/infer-too-generic.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b218b952f800c1160b8b5e764ca651b02d678565/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Finfer-too-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b218b952f800c1160b8b5e764ca651b02d678565/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Finfer-too-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Finfer-too-generic.rs?ref=b218b952f800c1160b8b5e764ca651b02d678565", "patch": "@@ -0,0 +1,24 @@\n+// run-pass\n+#![feature(const_generics, const_evaluatable_checked)]\n+#![allow(incomplete_features)]\n+\n+use std::{mem, ptr};\n+\n+fn split_first<T, const N: usize>(arr: [T; N]) -> (T, [T; N - 1])\n+where\n+    [T; N - 1]: Sized,\n+{\n+    let arr = mem::ManuallyDrop::new(arr);\n+    unsafe {\n+        let head = ptr::read(&arr[0]);\n+        let tail = ptr::read(&arr[1..] as *const [T] as *const [T; N - 1]);\n+        (head, tail)\n+    }\n+}\n+\n+fn main() {\n+    let arr = [0, 1, 2, 3, 4];\n+    let (head, tail) = split_first(arr);\n+    assert_eq!(head, 0);\n+    assert_eq!(tail, [1, 2, 3, 4]);\n+}"}, {"sha": "9fdbbff66e9e90440436dec66f49cbd715196db9", "filename": "src/test/ui/const-generics/issues/issue-76595.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b218b952f800c1160b8b5e764ca651b02d678565/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-76595.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b218b952f800c1160b8b5e764ca651b02d678565/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-76595.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-76595.rs?ref=b218b952f800c1160b8b5e764ca651b02d678565", "patch": "@@ -14,5 +14,4 @@ fn test<T, const P: usize>() where Bool<{core::mem::size_of::<T>() > 4}>: True {\n fn main() {\n     test::<2>();\n     //~^ ERROR wrong number of type\n-    //~| ERROR constant expression depends\n }"}, {"sha": "f258d2977186f824cfeb3b2e5ed576d5c347b7fc", "filename": "src/test/ui/const-generics/issues/issue-76595.stderr", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b218b952f800c1160b8b5e764ca651b02d678565/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-76595.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b218b952f800c1160b8b5e764ca651b02d678565/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-76595.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-76595.stderr?ref=b218b952f800c1160b8b5e764ca651b02d678565", "patch": "@@ -4,17 +4,6 @@ error[E0107]: wrong number of type arguments: expected 1, found 0\n LL |     test::<2>();\n    |     ^^^^^^^^^ expected 1 type argument\n \n-error: constant expression depends on a generic parameter\n-  --> $DIR/issue-76595.rs:15:5\n-   |\n-LL | fn test<T, const P: usize>() where Bool<{core::mem::size_of::<T>() > 4}>: True {\n-   |                                         ------------------------------- required by this bound in `test`\n-...\n-LL |     test::<2>();\n-   |     ^^^^^^^^^\n-   |\n-   = note: this may fail depending on what value the parameter takes\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0107`."}, {"sha": "76c01c21301388eae15812726845e0bcc4d81fd7", "filename": "src/test/ui/invalid-rustc_args_required_const-arguments.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b218b952f800c1160b8b5e764ca651b02d678565/src%2Ftest%2Fui%2Finvalid-rustc_args_required_const-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b218b952f800c1160b8b5e764ca651b02d678565/src%2Ftest%2Fui%2Finvalid-rustc_args_required_const-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid-rustc_args_required_const-arguments.rs?ref=b218b952f800c1160b8b5e764ca651b02d678565", "patch": "@@ -0,0 +1,26 @@\n+#![feature(rustc_attrs)]\n+\n+#[rustc_args_required_const(0)] //~ ERROR index exceeds number of arguments\n+fn foo1() {}\n+\n+#[rustc_args_required_const(1)] //~ ERROR index exceeds number of arguments\n+fn foo2(_: u8) {}\n+\n+#[rustc_args_required_const(a)] //~ ERROR arguments should be non-negative integers\n+fn foo4() {}\n+\n+#[rustc_args_required_const(1, a, 2, b)] //~ ERROR arguments should be non-negative integers\n+fn foo5(_: u8, _: u8, _: u8) {}\n+\n+#[rustc_args_required_const(0)] //~ ERROR attribute should be applied to a function\n+struct S;\n+\n+#[rustc_args_required_const(0usize)] //~ ERROR suffixed literals are not allowed in attributes\n+fn foo6(_: u8) {}\n+\n+extern {\n+    #[rustc_args_required_const(1)] //~ ERROR index exceeds number of arguments\n+    fn foo7(_: u8);\n+}\n+\n+fn main() {}"}, {"sha": "39d0462616873bfe72bfc34516a1bf92dbdb40f5", "filename": "src/test/ui/invalid-rustc_args_required_const-arguments.stderr", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/b218b952f800c1160b8b5e764ca651b02d678565/src%2Ftest%2Fui%2Finvalid-rustc_args_required_const-arguments.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b218b952f800c1160b8b5e764ca651b02d678565/src%2Ftest%2Fui%2Finvalid-rustc_args_required_const-arguments.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid-rustc_args_required_const-arguments.stderr?ref=b218b952f800c1160b8b5e764ca651b02d678565", "patch": "@@ -0,0 +1,48 @@\n+error: suffixed literals are not allowed in attributes\n+  --> $DIR/invalid-rustc_args_required_const-arguments.rs:18:29\n+   |\n+LL | #[rustc_args_required_const(0usize)]\n+   |                             ^^^^^^\n+   |\n+   = help: instead of using a suffixed literal (`1u8`, `1.0f32`, etc.), use an unsuffixed version (`1`, `1.0`, etc.)\n+\n+error: index exceeds number of arguments\n+  --> $DIR/invalid-rustc_args_required_const-arguments.rs:3:29\n+   |\n+LL | #[rustc_args_required_const(0)]\n+   |                             ^ there are only 0 arguments\n+\n+error: index exceeds number of arguments\n+  --> $DIR/invalid-rustc_args_required_const-arguments.rs:6:29\n+   |\n+LL | #[rustc_args_required_const(1)]\n+   |                             ^ there is only 1 argument\n+\n+error: arguments should be non-negative integers\n+  --> $DIR/invalid-rustc_args_required_const-arguments.rs:9:29\n+   |\n+LL | #[rustc_args_required_const(a)]\n+   |                             ^\n+\n+error: arguments should be non-negative integers\n+  --> $DIR/invalid-rustc_args_required_const-arguments.rs:12:32\n+   |\n+LL | #[rustc_args_required_const(1, a, 2, b)]\n+   |                                ^     ^\n+\n+error: attribute should be applied to a function\n+  --> $DIR/invalid-rustc_args_required_const-arguments.rs:15:1\n+   |\n+LL | #[rustc_args_required_const(0)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | struct S;\n+   | --------- not a function\n+\n+error: index exceeds number of arguments\n+  --> $DIR/invalid-rustc_args_required_const-arguments.rs:22:33\n+   |\n+LL |     #[rustc_args_required_const(1)]\n+   |                                 ^ there is only 1 argument\n+\n+error: aborting due to 7 previous errors\n+"}, {"sha": "43371560e02c1d3e4eaae76ffd0f05727daf25b5", "filename": "src/test/ui/lint/lint-const-item-mutation.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b218b952f800c1160b8b5e764ca651b02d678565/src%2Ftest%2Fui%2Flint%2Flint-const-item-mutation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b218b952f800c1160b8b5e764ca651b02d678565/src%2Ftest%2Fui%2Flint%2Flint-const-item-mutation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-const-item-mutation.rs?ref=b218b952f800c1160b8b5e764ca651b02d678565", "patch": "@@ -3,13 +3,15 @@\n struct MyStruct {\n     field: bool,\n     inner_array: [char; 1],\n+    raw_ptr: *mut u8\n }\n impl MyStruct {\n     fn use_mut(&mut self) {}\n }\n \n const ARRAY: [u8; 1] = [25];\n-const MY_STRUCT: MyStruct = MyStruct { field: true, inner_array: ['a'] };\n+const MY_STRUCT: MyStruct = MyStruct { field: true, inner_array: ['a'], raw_ptr: 2 as *mut u8 };\n+const RAW_PTR: *mut u8 = 1 as *mut u8;\n \n fn main() {\n     ARRAY[0] = 5; //~ WARN attempting to modify\n@@ -18,4 +20,13 @@ fn main() {\n     MY_STRUCT.use_mut(); //~ WARN taking\n     &mut MY_STRUCT; //~ WARN taking\n     (&mut MY_STRUCT).use_mut(); //~ WARN taking\n+\n+    // Test that we don't warn when writing through\n+    // a raw pointer\n+    // This is U.B., but this test is check-pass,\n+    // so this never actually executes\n+    unsafe {\n+        *RAW_PTR = 0;\n+        *MY_STRUCT.raw_ptr = 0;\n+    }\n }"}, {"sha": "c5a221128ffaba262590a7d29e3b6224ae4a5fce", "filename": "src/test/ui/lint/lint-const-item-mutation.stderr", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/b218b952f800c1160b8b5e764ca651b02d678565/src%2Ftest%2Fui%2Flint%2Flint-const-item-mutation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b218b952f800c1160b8b5e764ca651b02d678565/src%2Ftest%2Fui%2Flint%2Flint-const-item-mutation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-const-item-mutation.stderr?ref=b218b952f800c1160b8b5e764ca651b02d678565", "patch": "@@ -1,89 +1,89 @@\n warning: attempting to modify a `const` item\n-  --> $DIR/lint-const-item-mutation.rs:15:5\n+  --> $DIR/lint-const-item-mutation.rs:17:5\n    |\n LL |     ARRAY[0] = 5;\n    |     ^^^^^^^^^^^^\n    |\n    = note: `#[warn(const_item_mutation)]` on by default\n    = note: each usage of a `const` item creates a new temporary - the original `const` item will not be modified\n note: `const` item defined here\n-  --> $DIR/lint-const-item-mutation.rs:11:1\n+  --> $DIR/lint-const-item-mutation.rs:12:1\n    |\n LL | const ARRAY: [u8; 1] = [25];\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: attempting to modify a `const` item\n-  --> $DIR/lint-const-item-mutation.rs:16:5\n+  --> $DIR/lint-const-item-mutation.rs:18:5\n    |\n LL |     MY_STRUCT.field = false;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: each usage of a `const` item creates a new temporary - the original `const` item will not be modified\n note: `const` item defined here\n-  --> $DIR/lint-const-item-mutation.rs:12:1\n+  --> $DIR/lint-const-item-mutation.rs:13:1\n    |\n-LL | const MY_STRUCT: MyStruct = MyStruct { field: true, inner_array: ['a'] };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | const MY_STRUCT: MyStruct = MyStruct { field: true, inner_array: ['a'], raw_ptr: 2 as *mut u8 };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: attempting to modify a `const` item\n-  --> $DIR/lint-const-item-mutation.rs:17:5\n+  --> $DIR/lint-const-item-mutation.rs:19:5\n    |\n LL |     MY_STRUCT.inner_array[0] = 'b';\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: each usage of a `const` item creates a new temporary - the original `const` item will not be modified\n note: `const` item defined here\n-  --> $DIR/lint-const-item-mutation.rs:12:1\n+  --> $DIR/lint-const-item-mutation.rs:13:1\n    |\n-LL | const MY_STRUCT: MyStruct = MyStruct { field: true, inner_array: ['a'] };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | const MY_STRUCT: MyStruct = MyStruct { field: true, inner_array: ['a'], raw_ptr: 2 as *mut u8 };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: taking a mutable reference to a `const` item\n-  --> $DIR/lint-const-item-mutation.rs:18:5\n+  --> $DIR/lint-const-item-mutation.rs:20:5\n    |\n LL |     MY_STRUCT.use_mut();\n    |     ^^^^^^^^^^^^^^^^^^^\n    |\n    = note: each usage of a `const` item creates a new temporary\n    = note: the mutable reference will refer to this temporary, not the original `const` item\n note: mutable reference created due to call to this method\n-  --> $DIR/lint-const-item-mutation.rs:8:5\n+  --> $DIR/lint-const-item-mutation.rs:9:5\n    |\n LL |     fn use_mut(&mut self) {}\n    |     ^^^^^^^^^^^^^^^^^^^^^\n note: `const` item defined here\n-  --> $DIR/lint-const-item-mutation.rs:12:1\n+  --> $DIR/lint-const-item-mutation.rs:13:1\n    |\n-LL | const MY_STRUCT: MyStruct = MyStruct { field: true, inner_array: ['a'] };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | const MY_STRUCT: MyStruct = MyStruct { field: true, inner_array: ['a'], raw_ptr: 2 as *mut u8 };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: taking a mutable reference to a `const` item\n-  --> $DIR/lint-const-item-mutation.rs:19:5\n+  --> $DIR/lint-const-item-mutation.rs:21:5\n    |\n LL |     &mut MY_STRUCT;\n    |     ^^^^^^^^^^^^^^\n    |\n    = note: each usage of a `const` item creates a new temporary\n    = note: the mutable reference will refer to this temporary, not the original `const` item\n note: `const` item defined here\n-  --> $DIR/lint-const-item-mutation.rs:12:1\n+  --> $DIR/lint-const-item-mutation.rs:13:1\n    |\n-LL | const MY_STRUCT: MyStruct = MyStruct { field: true, inner_array: ['a'] };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | const MY_STRUCT: MyStruct = MyStruct { field: true, inner_array: ['a'], raw_ptr: 2 as *mut u8 };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: taking a mutable reference to a `const` item\n-  --> $DIR/lint-const-item-mutation.rs:20:5\n+  --> $DIR/lint-const-item-mutation.rs:22:5\n    |\n LL |     (&mut MY_STRUCT).use_mut();\n    |     ^^^^^^^^^^^^^^^^\n    |\n    = note: each usage of a `const` item creates a new temporary\n    = note: the mutable reference will refer to this temporary, not the original `const` item\n note: `const` item defined here\n-  --> $DIR/lint-const-item-mutation.rs:12:1\n+  --> $DIR/lint-const-item-mutation.rs:13:1\n    |\n-LL | const MY_STRUCT: MyStruct = MyStruct { field: true, inner_array: ['a'] };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | const MY_STRUCT: MyStruct = MyStruct { field: true, inner_array: ['a'], raw_ptr: 2 as *mut u8 };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: 6 warnings emitted\n "}, {"sha": "a114fafb6473012e88b9975ee88deb085cef82cd", "filename": "src/test/ui/match/const_non_normal_zst_ref_pattern.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b218b952f800c1160b8b5e764ca651b02d678565/src%2Ftest%2Fui%2Fmatch%2Fconst_non_normal_zst_ref_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b218b952f800c1160b8b5e764ca651b02d678565/src%2Ftest%2Fui%2Fmatch%2Fconst_non_normal_zst_ref_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fconst_non_normal_zst_ref_pattern.rs?ref=b218b952f800c1160b8b5e764ca651b02d678565", "patch": "@@ -0,0 +1,9 @@\n+// check-pass\n+\n+const FOO: isize = 10;\n+const ZST: &() = unsafe { std::mem::transmute(FOO) };\n+fn main() {\n+    match &() {\n+        ZST => 9,\n+    };\n+}"}, {"sha": "2f5af10a40ac2cc1e0101ab3b9fa661fe0a41fb4", "filename": "src/test/ui/proc-macro/nested-nonterminal-tokens.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b218b952f800c1160b8b5e764ca651b02d678565/src%2Ftest%2Fui%2Fproc-macro%2Fnested-nonterminal-tokens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b218b952f800c1160b8b5e764ca651b02d678565/src%2Ftest%2Fui%2Fproc-macro%2Fnested-nonterminal-tokens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fnested-nonterminal-tokens.rs?ref=b218b952f800c1160b8b5e764ca651b02d678565", "patch": "@@ -0,0 +1,26 @@\n+// check-pass\n+// edition:2018\n+// compile-flags: -Z span-debug\n+// aux-build:test-macros.rs\n+\n+// Tests that we properly pass tokens to proc-macro when nested\n+// nonterminals are involved.\n+\n+#![no_std] // Don't load unnecessary hygiene information from std\n+extern crate std;\n+\n+#[macro_use]\n+extern crate test_macros;\n+\n+\n+macro_rules! wrap {\n+    (first, $e:expr) => { wrap!(second, $e + 1) };\n+    (second, $e:expr) => { wrap!(third, $e + 2) };\n+    (third, $e:expr) => {\n+        print_bang!($e + 3);\n+    };\n+}\n+\n+fn main() {\n+    let _ = wrap!(first, 0);\n+}"}, {"sha": "a3d24dd26fe978f19f3dac03d4f96773b613c215", "filename": "src/test/ui/proc-macro/nested-nonterminal-tokens.stdout", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/b218b952f800c1160b8b5e764ca651b02d678565/src%2Ftest%2Fui%2Fproc-macro%2Fnested-nonterminal-tokens.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/b218b952f800c1160b8b5e764ca651b02d678565/src%2Ftest%2Fui%2Fproc-macro%2Fnested-nonterminal-tokens.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fnested-nonterminal-tokens.stdout?ref=b218b952f800c1160b8b5e764ca651b02d678565", "patch": "@@ -0,0 +1,60 @@\n+PRINT-BANG INPUT (DISPLAY): 0 + 1 + 2 + 3\n+PRINT-BANG INPUT (DEBUG): TokenStream [\n+    Group {\n+        delimiter: None,\n+        stream: TokenStream [\n+            Group {\n+                delimiter: None,\n+                stream: TokenStream [\n+                    Group {\n+                        delimiter: None,\n+                        stream: TokenStream [\n+                            Literal {\n+                                kind: Integer,\n+                                symbol: \"0\",\n+                                suffix: None,\n+                                span: $DIR/nested-nonterminal-tokens.rs:25:26: 25:27 (#0),\n+                            },\n+                        ],\n+                        span: $DIR/nested-nonterminal-tokens.rs:17:41: 17:43 (#4),\n+                    },\n+                    Punct {\n+                        ch: '+',\n+                        spacing: Alone,\n+                        span: $DIR/nested-nonterminal-tokens.rs:17:44: 17:45 (#4),\n+                    },\n+                    Literal {\n+                        kind: Integer,\n+                        symbol: \"1\",\n+                        suffix: None,\n+                        span: $DIR/nested-nonterminal-tokens.rs:17:46: 17:47 (#4),\n+                    },\n+                ],\n+                span: $DIR/nested-nonterminal-tokens.rs:18:41: 18:43 (#5),\n+            },\n+            Punct {\n+                ch: '+',\n+                spacing: Alone,\n+                span: $DIR/nested-nonterminal-tokens.rs:18:44: 18:45 (#5),\n+            },\n+            Literal {\n+                kind: Integer,\n+                symbol: \"2\",\n+                suffix: None,\n+                span: $DIR/nested-nonterminal-tokens.rs:18:46: 18:47 (#5),\n+            },\n+        ],\n+        span: $DIR/nested-nonterminal-tokens.rs:20:21: 20:23 (#6),\n+    },\n+    Punct {\n+        ch: '+',\n+        spacing: Alone,\n+        span: $DIR/nested-nonterminal-tokens.rs:20:24: 20:25 (#6),\n+    },\n+    Literal {\n+        kind: Integer,\n+        symbol: \"3\",\n+        suffix: None,\n+        span: $DIR/nested-nonterminal-tokens.rs:20:26: 20:27 (#6),\n+    },\n+]"}, {"sha": "7026a49000c55d349766a586936fa0014f033656", "filename": "src/test/ui/slice-to-vec-comparison.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b218b952f800c1160b8b5e764ca651b02d678565/src%2Ftest%2Fui%2Fslice-to-vec-comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b218b952f800c1160b8b5e764ca651b02d678565/src%2Ftest%2Fui%2Fslice-to-vec-comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fslice-to-vec-comparison.rs?ref=b218b952f800c1160b8b5e764ca651b02d678565", "patch": "@@ -0,0 +1,6 @@\n+fn main() {\n+    let a = &[];\n+    let b: &Vec<u8> = &vec![];\n+    a > b;\n+    //~^ ERROR mismatched types\n+}"}, {"sha": "e3b3b040f66444e8e47c52198edd57b7340ecda7", "filename": "src/test/ui/slice-to-vec-comparison.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b218b952f800c1160b8b5e764ca651b02d678565/src%2Ftest%2Fui%2Fslice-to-vec-comparison.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b218b952f800c1160b8b5e764ca651b02d678565/src%2Ftest%2Fui%2Fslice-to-vec-comparison.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fslice-to-vec-comparison.stderr?ref=b218b952f800c1160b8b5e764ca651b02d678565", "patch": "@@ -0,0 +1,12 @@\n+error[E0308]: mismatched types\n+  --> $DIR/slice-to-vec-comparison.rs:4:9\n+   |\n+LL |     a > b;\n+   |         ^ expected array of 0 elements, found struct `Vec`\n+   |\n+   = note: expected reference `&[_; 0]`\n+              found reference `&Vec<u8>`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "75615f8e69f748d7ef0df7bc0b064a9b1f5c78b2", "filename": "src/tools/cargo", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcargo?ref=b218b952f800c1160b8b5e764ca651b02d678565", "patch": "@@ -1 +1 @@\n-Subproject commit 05c611ae3c4255b7a2bcf4fcfa65b20286a07839\n+Subproject commit 75615f8e69f748d7ef0df7bc0b064a9b1f5c78b2"}, {"sha": "6a492bbff4d4027ea3c150e11ca912cc6ecf2704", "filename": "src/tools/tier-check/src/main.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b218b952f800c1160b8b5e764ca651b02d678565/src%2Ftools%2Ftier-check%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b218b952f800c1160b8b5e764ca651b02d678565/src%2Ftools%2Ftier-check%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftier-check%2Fsrc%2Fmain.rs?ref=b218b952f800c1160b8b5e764ca651b02d678565", "patch": "@@ -25,8 +25,6 @@ fn main() {\n     let doc_targets: HashSet<_> = doc_targets_md\n         .lines()\n         .filter(|line| line.starts_with('`') && line.contains('|'))\n-        // These platforms only exist on macos.\n-        .filter(|line| !line.contains(\"[^apple]\") || cfg!(target_os = \"macos\"))\n         .map(|line| line.split('`').skip(1).next().expect(\"expected target code span\"))\n         .collect();\n "}]}