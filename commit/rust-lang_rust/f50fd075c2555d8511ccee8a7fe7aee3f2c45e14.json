{"sha": "f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1MGZkMDc1YzI1NTVkODUxMWNjZWU4YTdmZTdhZWUzZjJjNDVlMTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-19T22:12:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-19T22:12:22Z"}, "message": "Auto merge of #45225 - eddyb:trans-abi, r=arielb1\n\nRefactor type memory layouts and ABIs, to be more general and easier to optimize.\n\nTo combat combinatorial explosion, type layouts are now described through 3 orthogonal properties:\n* `Variants` describes the plurality of sum types (where applicable)\n  * `Single` is for one inhabited/active variant, including all C `struct`s and `union`s\n  * `Tagged` has its variants discriminated by an integer tag, including C `enum`s\n  * `NicheFilling` uses otherwise-invalid values (\"niches\") for all but one of its inhabited variants\n* `FieldPlacement` describes the number and memory offsets of fields (if any)\n  * `Union` has all its fields at offset `0`\n  * `Array` has offsets that are a multiple of its `stride`; guarantees all fields have one type\n  * `Arbitrary` records all the field offsets, which can be out-of-order\n* `Abi` describes how values of the type should be passed around, including for FFI\n  * `Uninhabited` corresponds to no values, associated with unreachable control-flow\n  * `Scalar` is ABI-identical to its only integer/floating-point/pointer \"scalar component\"\n  * `ScalarPair` has two \"scalar components\", but only applies to the Rust ABI\n  * `Vector` is for SIMD vectors, typically `#[repr(simd)]` `struct`s in Rust\n  * `Aggregate` has arbitrary contents, including all non-transparent C `struct`s and `union`s\n\nSize optimizations implemented so far:\n* ignoring uninhabited variants (i.e. containing uninhabited fields), e.g.:\n  * `Option<!>` is 0 bytes\n  * `Result<T, !>` has the same size as `T`\n* using arbitrary niches, not just `0`, to represent a data-less variant, e.g.:\n  * `Option<bool>`, `Option<Option<bool>>`, `Option<Ordering>` are all 1 byte\n  * `Option<char>` is 4 bytes\n* using a range of niches to represent *multiple* data-less variants, e.g.:\n  * `enum E { A(bool), B, C, D }` is 1 byte\n\nCode generation now takes advantage of `Scalar` and `ScalarPair` to, in more cases, pass around scalar components as immediates instead of indirectly, through pointers into temporary memory, while avoiding LLVM's \"first-class aggregates\", and there's more untapped potential here.\n\nCloses #44426, fixes #5977, fixes #14540, fixes #43278.", "tree": {"sha": "87e3759277a471d762fac9a06e1e6d66244a7ac2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/87e3759277a471d762fac9a06e1e6d66244a7ac2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "html_url": "https://github.com/rust-lang/rust/commit/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5041b3bb3d953a14f32b15d1e41341c629acae12", "url": "https://api.github.com/repos/rust-lang/rust/commits/5041b3bb3d953a14f32b15d1e41341c629acae12", "html_url": "https://github.com/rust-lang/rust/commit/5041b3bb3d953a14f32b15d1e41341c629acae12"}, {"sha": "f9f5ab98b0aae2a5ef8e41df2277ca3a2cd6e89a", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9f5ab98b0aae2a5ef8e41df2277ca3a2cd6e89a", "html_url": "https://github.com/rust-lang/rust/commit/f9f5ab98b0aae2a5ef8e41df2277ca3a2cd6e89a"}], "stats": {"total": 10610, "additions": 4986, "deletions": 5624}, "files": [{"sha": "2226cee6e3684c57048bdca16844d54c995e2030", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -151,7 +151,7 @@ impl<T> Place<T> for IntermediateBox<T> {\n unsafe fn finalize<T>(b: IntermediateBox<T>) -> Box<T> {\n     let p = b.ptr as *mut T;\n     mem::forget(b);\n-    mem::transmute(p)\n+    Box::from_raw(p)\n }\n \n fn make_place<T>() -> IntermediateBox<T> {\n@@ -300,7 +300,10 @@ impl<T: ?Sized> Box<T> {\n                issue = \"27730\")]\n     #[inline]\n     pub unsafe fn from_unique(u: Unique<T>) -> Self {\n-        mem::transmute(u)\n+        #[cfg(stage0)]\n+        return mem::transmute(u);\n+        #[cfg(not(stage0))]\n+        return Box(u);\n     }\n \n     /// Consumes the `Box`, returning the wrapped raw pointer.\n@@ -362,7 +365,14 @@ impl<T: ?Sized> Box<T> {\n                issue = \"27730\")]\n     #[inline]\n     pub fn into_unique(b: Box<T>) -> Unique<T> {\n-        unsafe { mem::transmute(b) }\n+        #[cfg(stage0)]\n+        return unsafe { mem::transmute(b) };\n+        #[cfg(not(stage0))]\n+        return {\n+            let unique = b.0;\n+            mem::forget(b);\n+            unique\n+        };\n     }\n }\n \n@@ -627,7 +637,7 @@ impl Box<Any + Send> {\n     pub fn downcast<T: Any>(self) -> Result<Box<T>, Box<Any + Send>> {\n         <Box<Any>>::downcast(self).map_err(|s| unsafe {\n             // reapply the Send marker\n-            mem::transmute::<Box<Any>, Box<Any + Send>>(s)\n+            Box::from_raw(Box::into_raw(s) as *mut (Any + Send))\n         })\n     }\n }"}, {"sha": "b59f7480476b8ff1b193f8507502b49da5a1d2ea", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -46,11 +46,13 @@\n #![feature(const_fn)]\n #![feature(core_intrinsics)]\n #![feature(drain_filter)]\n+#![feature(i128)]\n #![feature(i128_type)]\n-#![feature(match_default_bindings)]\n+#![feature(inclusive_range)]\n #![feature(inclusive_range_syntax)]\n #![cfg_attr(windows, feature(libc))]\n #![feature(macro_vis_matcher)]\n+#![feature(match_default_bindings)]\n #![feature(never_type)]\n #![feature(nonzero)]\n #![feature(quote)]"}, {"sha": "4496e07b13814857461296395116754e3899c8b0", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -34,7 +34,8 @@ use middle::privacy::AccessLevels;\n use rustc_serialize::{Decoder, Decodable, Encoder, Encodable};\n use session::{config, early_error, Session};\n use traits::Reveal;\n-use ty::{self, TyCtxt};\n+use ty::{self, TyCtxt, Ty};\n+use ty::layout::{LayoutError, LayoutOf, TyLayout};\n use util::nodemap::FxHashMap;\n \n use std::default::Default as StdDefault;\n@@ -626,6 +627,14 @@ impl<'a, 'tcx> LateContext<'a, 'tcx> {\n     }\n }\n \n+impl<'a, 'tcx> LayoutOf<Ty<'tcx>> for &'a LateContext<'a, 'tcx> {\n+    type TyLayout = Result<TyLayout<'tcx>, LayoutError<'tcx>>;\n+\n+    fn layout_of(self, ty: Ty<'tcx>) -> Self::TyLayout {\n+        (self.tcx, self.param_env.reveal_all()).layout_of(ty)\n+    }\n+}\n+\n impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n     /// Because lints are scoped lexically, we want to walk nested\n     /// items in the context of the outer item, so enable"}, {"sha": "c89d67d4aab8621baf6e98fb1ce93d295d59a14c", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -210,7 +210,7 @@ impl<'tcx> cmt_<'tcx> {\n                 adt_def.variant_with_id(variant_did)\n             }\n             _ => {\n-                assert!(adt_def.is_univariant());\n+                assert_eq!(adt_def.variants.len(), 1);\n                 &adt_def.variants[0]\n             }\n         };\n@@ -1096,7 +1096,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                                               -> cmt<'tcx> {\n         // univariant enums do not need downcasts\n         let base_did = self.tcx.parent_def_id(variant_did).unwrap();\n-        if !self.tcx.adt_def(base_did).is_univariant() {\n+        if self.tcx.adt_def(base_did).variants.len() != 1 {\n             let base_ty = base_cmt.ty;\n             let ret = Rc::new(cmt_ {\n                 id: node.id(),"}, {"sha": "904f9a091252255c2c339cdcd07a146db214eebc", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -41,7 +41,7 @@ use ty::{PolyFnSig, InferTy, ParamTy, ProjectionTy, ExistentialPredicate, Predic\n use ty::RegionKind;\n use ty::{TyVar, TyVid, IntVar, IntVid, FloatVar, FloatVid};\n use ty::TypeVariants::*;\n-use ty::layout::{Layout, TargetDataLayout};\n+use ty::layout::{LayoutDetails, TargetDataLayout};\n use ty::maps;\n use ty::steal::Steal;\n use ty::BindingMode;\n@@ -78,7 +78,7 @@ use hir;\n /// Internal storage\n pub struct GlobalArenas<'tcx> {\n     // internings\n-    layout: TypedArena<Layout>,\n+    layout: TypedArena<LayoutDetails>,\n \n     // references\n     generics: TypedArena<ty::Generics>,\n@@ -918,7 +918,7 @@ pub struct GlobalCtxt<'tcx> {\n \n     stability_interner: RefCell<FxHashSet<&'tcx attr::Stability>>,\n \n-    layout_interner: RefCell<FxHashSet<&'tcx Layout>>,\n+    layout_interner: RefCell<FxHashSet<&'tcx LayoutDetails>>,\n \n     /// A vector of every trait accessible in the whole crate\n     /// (i.e. including those from subcrates). This is used only for\n@@ -1016,7 +1016,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         interned\n     }\n \n-    pub fn intern_layout(self, layout: Layout) -> &'gcx Layout {\n+    pub fn intern_layout(self, layout: LayoutDetails) -> &'gcx LayoutDetails {\n         if let Some(layout) = self.layout_interner.borrow().get(&layout) {\n             return layout;\n         }"}, {"sha": "71bf333a8c6122cffd52110620976a3459792572", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 1387, "deletions": 1341, "changes": 2728, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14"}, {"sha": "2f648e8d3ff82c68e612278ec1c303b7c79e7a96", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -34,7 +34,6 @@ use session::config::OutputFilenames;\n use traits::Vtable;\n use traits::specialization_graph;\n use ty::{self, CrateInherentImpls, Ty, TyCtxt};\n-use ty::layout::{Layout, LayoutError};\n use ty::steal::Steal;\n use ty::subst::Substs;\n use util::nodemap::{DefIdSet, DefIdMap, ItemLocalSet};\n@@ -265,7 +264,8 @@ define_maps! { <'tcx>\n     [] fn is_freeze_raw: is_freeze_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n     [] fn needs_drop_raw: needs_drop_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n     [] fn layout_raw: layout_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n-                                  -> Result<&'tcx Layout, LayoutError<'tcx>>,\n+                                  -> Result<&'tcx ty::layout::LayoutDetails,\n+                                            ty::layout::LayoutError<'tcx>>,\n \n     [] fn dylib_dependency_formats: DylibDepFormats(CrateNum)\n                                     -> Rc<Vec<(CrateNum, LinkagePreference)>>,"}, {"sha": "48ec92a255b4c66275750c47d4992b562b994c84", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -1674,11 +1674,6 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         self.variants.iter().flat_map(|v| v.fields.iter())\n     }\n \n-    #[inline]\n-    pub fn is_univariant(&self) -> bool {\n-        self.variants.len() == 1\n-    }\n-\n     pub fn is_payloadfree(&self) -> bool {\n         !self.variants.is_empty() &&\n             self.variants.iter().all(|v| v.fields.is_empty())\n@@ -2622,9 +2617,10 @@ fn original_crate_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n pub fn provide(providers: &mut ty::maps::Providers) {\n-    util::provide(providers);\n     context::provide(providers);\n     erase_regions::provide(providers);\n+    layout::provide(providers);\n+    util::provide(providers);\n     *providers = ty::maps::Providers {\n         associated_item,\n         associated_item_def_ids,"}, {"sha": "23dd3f1bc2bba36e55bb9e22f10344afa538312f", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -19,7 +19,6 @@ use middle::const_val::ConstVal;\n use traits::{self, Reveal};\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n use ty::fold::TypeVisitor;\n-use ty::layout::{Layout, LayoutError};\n use ty::subst::{Subst, Kind};\n use ty::TypeVariants::*;\n use util::common::ErrorReported;\n@@ -852,30 +851,6 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n         tcx.needs_drop_raw(param_env.and(self))\n     }\n \n-    /// Computes the layout of a type. Note that this implicitly\n-    /// executes in \"reveal all\" mode.\n-    #[inline]\n-    pub fn layout<'lcx>(&'tcx self,\n-                        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                        param_env: ty::ParamEnv<'tcx>)\n-                        -> Result<&'tcx Layout, LayoutError<'tcx>> {\n-        let ty = tcx.erase_regions(&self);\n-        let layout = tcx.layout_raw(param_env.reveal_all().and(ty));\n-\n-        // NB: This recording is normally disabled; when enabled, it\n-        // can however trigger recursive invocations of `layout()`.\n-        // Therefore, we execute it *after* the main query has\n-        // completed, to avoid problems around recursive structures\n-        // and the like. (Admitedly, I wasn't able to reproduce a problem\n-        // here, but it seems like the right thing to do. -nmatsakis)\n-        if let Ok(l) = layout {\n-            Layout::record_layout_for_printing(tcx, ty, param_env, l);\n-        }\n-\n-        layout\n-    }\n-\n-\n     /// Check whether a type is representable. This means it cannot contain unboxed\n     /// structural recursion. This check is needed for structs and enums.\n     pub fn is_representable(&'tcx self,\n@@ -1184,26 +1159,6 @@ fn needs_drop_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-fn layout_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                        query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n-                        -> Result<&'tcx Layout, LayoutError<'tcx>>\n-{\n-    let (param_env, ty) = query.into_parts();\n-\n-    let rec_limit = tcx.sess.recursion_limit.get();\n-    let depth = tcx.layout_depth.get();\n-    if depth > rec_limit {\n-        tcx.sess.fatal(\n-            &format!(\"overflow representing the type `{}`\", ty));\n-    }\n-\n-    tcx.layout_depth.set(depth+1);\n-    let layout = Layout::compute_uncached(tcx, param_env, ty);\n-    tcx.layout_depth.set(depth);\n-\n-    layout\n-}\n-\n pub enum ExplicitSelf<'tcx> {\n     ByValue,\n     ByReference(ty::Region<'tcx>, hir::Mutability),\n@@ -1262,7 +1217,6 @@ pub fn provide(providers: &mut ty::maps::Providers) {\n         is_sized_raw,\n         is_freeze_raw,\n         needs_drop_raw,\n-        layout_raw,\n         ..*providers\n     };\n }"}, {"sha": "33d9bfa6e6b9c21b44d31f2ec37afbebc941832a", "filename": "src/librustc_const_eval/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_const_eval%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_const_eval%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2F_match.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -255,7 +255,7 @@ impl<'tcx> Constructor<'tcx> {\n         match self {\n             &Variant(vid) => adt.variant_index_with_id(vid),\n             &Single => {\n-                assert_eq!(adt.variants.len(), 1);\n+                assert!(!adt.is_enum());\n                 0\n             }\n             _ => bug!(\"bad constructor {:?} for adt {:?}\", self, adt)\n@@ -356,7 +356,7 @@ impl<'tcx> Witness<'tcx> {\n                     }).collect();\n \n                     if let ty::TyAdt(adt, substs) = ty.sty {\n-                        if adt.variants.len() > 1 {\n+                        if adt.is_enum() {\n                             PatternKind::Variant {\n                                 adt_def: adt,\n                                 substs,\n@@ -444,7 +444,7 @@ fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                 (0..pcx.max_slice_length+1).map(|length| Slice(length)).collect()\n             }\n         }\n-        ty::TyAdt(def, substs) if def.is_enum() && def.variants.len() != 1 => {\n+        ty::TyAdt(def, substs) if def.is_enum() => {\n             def.variants.iter()\n                 .filter(|v| !cx.is_variant_uninhabited(v, substs))\n                 .map(|v| Variant(v.did))"}, {"sha": "a548c1df16e28987e1e5d5c94e716935ef41c234", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -17,6 +17,7 @@ use rustc::hir::map::blocks::FnLikeNode;\n use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::def_id::DefId;\n use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::layout::LayoutOf;\n use rustc::ty::maps::Providers;\n use rustc::ty::util::IntTypeExt;\n use rustc::ty::subst::{Substs, Subst};\n@@ -313,18 +314,18 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n           if tcx.fn_sig(def_id).abi() == Abi::RustIntrinsic {\n             let layout_of = |ty: Ty<'tcx>| {\n                 let ty = tcx.erase_regions(&ty);\n-                tcx.at(e.span).layout_raw(cx.param_env.reveal_all().and(ty)).map_err(|err| {\n+                (tcx.at(e.span), cx.param_env).layout_of(ty).map_err(|err| {\n                     ConstEvalErr { span: e.span, kind: LayoutError(err) }\n                 })\n             };\n             match &tcx.item_name(def_id)[..] {\n                 \"size_of\" => {\n-                    let size = layout_of(substs.type_at(0))?.size(tcx).bytes();\n+                    let size = layout_of(substs.type_at(0))?.size.bytes();\n                     return Ok(mk_const(Integral(Usize(ConstUsize::new(size,\n                         tcx.sess.target.usize_ty).unwrap()))));\n                 }\n                 \"min_align_of\" => {\n-                    let align = layout_of(substs.type_at(0))?.align(tcx).abi();\n+                    let align = layout_of(substs.type_at(0))?.align.abi();\n                     return Ok(mk_const(Integral(Usize(ConstUsize::new(align,\n                         tcx.sess.target.usize_ty).unwrap()))));\n                 }"}, {"sha": "cfbb9623f7dc9ddf29b6f1e44fdf08a5c1dce298", "filename": "src/librustc_const_eval/pattern.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_const_eval%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_const_eval%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fpattern.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -150,7 +150,7 @@ impl<'tcx> fmt::Display for Pattern<'tcx> {\n                         Some(&adt_def.variants[variant_index])\n                     }\n                     _ => if let ty::TyAdt(adt, _) = self.ty.sty {\n-                        if adt.is_univariant() {\n+                        if !adt.is_enum() {\n                             Some(&adt.variants[0])\n                         } else {\n                             None\n@@ -598,7 +598,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n             Def::Variant(variant_id) | Def::VariantCtor(variant_id, ..) => {\n                 let enum_id = self.tcx.parent_def_id(variant_id).unwrap();\n                 let adt_def = self.tcx.adt_def(enum_id);\n-                if adt_def.variants.len() > 1 {\n+                if adt_def.is_enum() {\n                     let substs = match ty.sty {\n                         ty::TyAdt(_, substs) |\n                         ty::TyFnDef(_, substs) => substs,"}, {"sha": "1356574f646aa73b2ad026b60165661c39e21407", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -13,7 +13,7 @@\n use rustc::hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, AdtKind, Ty, TyCtxt};\n-use rustc::ty::layout::{Layout, Primitive};\n+use rustc::ty::layout::{self, LayoutOf};\n use middle::const_val::ConstVal;\n use rustc_const_eval::ConstContext;\n use util::nodemap::FxHashSet;\n@@ -748,25 +748,23 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VariantSizeDifferences {\n                 // sizes only make sense for non-generic types\n                 let item_def_id = cx.tcx.hir.local_def_id(it.id);\n                 let t = cx.tcx.type_of(item_def_id);\n-                let param_env = cx.param_env.reveal_all();\n                 let ty = cx.tcx.erase_regions(&t);\n-                let layout = ty.layout(cx.tcx, param_env).unwrap_or_else(|e| {\n+                let layout = cx.layout_of(ty).unwrap_or_else(|e| {\n                     bug!(\"failed to get layout for `{}`: {}\", t, e)\n                 });\n \n-                if let Layout::General { ref variants, ref size, discr, .. } = *layout {\n-                    let discr_size = Primitive::Int(discr).size(cx.tcx).bytes();\n+                if let layout::Variants::Tagged { ref variants, ref discr, .. } = layout.variants {\n+                    let discr_size = discr.value.size(cx.tcx).bytes();\n \n                     debug!(\"enum `{}` is {} bytes large with layout:\\n{:#?}\",\n-                      t, size.bytes(), layout);\n+                      t, layout.size.bytes(), layout);\n \n                     let (largest, slargest, largest_index) = enum_definition.variants\n                         .iter()\n                         .zip(variants)\n                         .map(|(variant, variant_layout)| {\n                             // Subtract the size of the enum discriminant\n-                            let bytes = variant_layout.min_size\n-                                .bytes()\n+                            let bytes = variant_layout.size.bytes()\n                                 .saturating_sub(discr_size);\n \n                             debug!(\"- variant `{}` is {} bytes large\", variant.node.name, bytes);"}, {"sha": "f8c71d4825513f30daa1b2b51e1b9b95da64a9ce", "filename": "src/librustc_llvm/ffi.rs", "status": "modified", "additions": 8, "deletions": 32, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -575,8 +575,6 @@ extern \"C\" {\n                                    ElementCount: c_uint,\n                                    Packed: Bool)\n                                    -> TypeRef;\n-    pub fn LLVMCountStructElementTypes(StructTy: TypeRef) -> c_uint;\n-    pub fn LLVMGetStructElementTypes(StructTy: TypeRef, Dest: *mut TypeRef);\n     pub fn LLVMIsPackedStruct(StructTy: TypeRef) -> Bool;\n \n     // Operations on array, pointer, and vector types (sequence types)\n@@ -585,7 +583,6 @@ extern \"C\" {\n     pub fn LLVMVectorType(ElementType: TypeRef, ElementCount: c_uint) -> TypeRef;\n \n     pub fn LLVMGetElementType(Ty: TypeRef) -> TypeRef;\n-    pub fn LLVMGetArrayLength(ArrayTy: TypeRef) -> c_uint;\n     pub fn LLVMGetVectorSize(VectorTy: TypeRef) -> c_uint;\n \n     // Operations on other types\n@@ -611,10 +608,7 @@ extern \"C\" {\n     pub fn LLVMConstNull(Ty: TypeRef) -> ValueRef;\n     pub fn LLVMConstICmp(Pred: IntPredicate, V1: ValueRef, V2: ValueRef) -> ValueRef;\n     pub fn LLVMConstFCmp(Pred: RealPredicate, V1: ValueRef, V2: ValueRef) -> ValueRef;\n-    // only for isize/vector\n     pub fn LLVMGetUndef(Ty: TypeRef) -> ValueRef;\n-    pub fn LLVMIsNull(Val: ValueRef) -> Bool;\n-    pub fn LLVMIsUndef(Val: ValueRef) -> Bool;\n \n     // Operations on metadata\n     pub fn LLVMMDStringInContext(C: ContextRef, Str: *const c_char, SLen: c_uint) -> ValueRef;\n@@ -736,7 +730,9 @@ extern \"C\" {\n                                        FunctionTy: TypeRef)\n                                        -> ValueRef;\n     pub fn LLVMSetFunctionCallConv(Fn: ValueRef, CC: c_uint);\n+    pub fn LLVMRustAddAlignmentAttr(Fn: ValueRef, index: c_uint, bytes: u32);\n     pub fn LLVMRustAddDereferenceableAttr(Fn: ValueRef, index: c_uint, bytes: u64);\n+    pub fn LLVMRustAddDereferenceableOrNullAttr(Fn: ValueRef, index: c_uint, bytes: u64);\n     pub fn LLVMRustAddFunctionAttribute(Fn: ValueRef, index: c_uint, attr: Attribute);\n     pub fn LLVMRustAddFunctionAttrStringValue(Fn: ValueRef,\n                                               index: c_uint,\n@@ -766,7 +762,11 @@ extern \"C\" {\n     // Operations on call sites\n     pub fn LLVMSetInstructionCallConv(Instr: ValueRef, CC: c_uint);\n     pub fn LLVMRustAddCallSiteAttribute(Instr: ValueRef, index: c_uint, attr: Attribute);\n+    pub fn LLVMRustAddAlignmentCallSiteAttr(Instr: ValueRef, index: c_uint, bytes: u32);\n     pub fn LLVMRustAddDereferenceableCallSiteAttr(Instr: ValueRef, index: c_uint, bytes: u64);\n+    pub fn LLVMRustAddDereferenceableOrNullCallSiteAttr(Instr: ValueRef,\n+                                                        index: c_uint,\n+                                                        bytes: u64);\n \n     // Operations on load/store instructions (only)\n     pub fn LLVMSetVolatile(MemoryAccessInst: ValueRef, volatile: Bool);\n@@ -1205,15 +1205,13 @@ extern \"C\" {\n     pub fn LLVMRustBuildAtomicLoad(B: BuilderRef,\n                                    PointerVal: ValueRef,\n                                    Name: *const c_char,\n-                                   Order: AtomicOrdering,\n-                                   Alignment: c_uint)\n+                                   Order: AtomicOrdering)\n                                    -> ValueRef;\n \n     pub fn LLVMRustBuildAtomicStore(B: BuilderRef,\n                                     Val: ValueRef,\n                                     Ptr: ValueRef,\n-                                    Order: AtomicOrdering,\n-                                    Alignment: c_uint)\n+                                    Order: AtomicOrdering)\n                                     -> ValueRef;\n \n     pub fn LLVMRustBuildAtomicCmpXchg(B: BuilderRef,\n@@ -1247,23 +1245,6 @@ extern \"C\" {\n \n     /// Creates target data from a target layout string.\n     pub fn LLVMCreateTargetData(StringRep: *const c_char) -> TargetDataRef;\n-    /// Number of bytes clobbered when doing a Store to *T.\n-    pub fn LLVMSizeOfTypeInBits(TD: TargetDataRef, Ty: TypeRef) -> c_ulonglong;\n-\n-    /// Distance between successive elements in an array of T. Includes ABI padding.\n-    pub fn LLVMABISizeOfType(TD: TargetDataRef, Ty: TypeRef) -> c_ulonglong;\n-\n-    /// Returns the preferred alignment of a type.\n-    pub fn LLVMPreferredAlignmentOfType(TD: TargetDataRef, Ty: TypeRef) -> c_uint;\n-    /// Returns the minimum alignment of a type.\n-    pub fn LLVMABIAlignmentOfType(TD: TargetDataRef, Ty: TypeRef) -> c_uint;\n-\n-    /// Computes the byte offset of the indexed struct element for a\n-    /// target.\n-    pub fn LLVMOffsetOfElement(TD: TargetDataRef,\n-                               StructTy: TypeRef,\n-                               Element: c_uint)\n-                               -> c_ulonglong;\n \n     /// Disposes target data.\n     pub fn LLVMDisposeTargetData(TD: TargetDataRef);\n@@ -1341,11 +1322,6 @@ extern \"C\" {\n                              ElementCount: c_uint,\n                              Packed: Bool);\n \n-    pub fn LLVMConstNamedStruct(S: TypeRef,\n-                                ConstantVals: *const ValueRef,\n-                                Count: c_uint)\n-                                -> ValueRef;\n-\n     /// Enables LLVM debug output.\n     pub fn LLVMRustSetDebug(Enabled: c_int);\n "}, {"sha": "592bd62056455534cfcbb331abb1aa555a2da635", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -74,22 +74,19 @@ pub fn AddFunctionAttrStringValue(llfn: ValueRef,\n     }\n }\n \n-#[repr(C)]\n #[derive(Copy, Clone)]\n pub enum AttributePlace {\n+    ReturnValue,\n     Argument(u32),\n     Function,\n }\n \n impl AttributePlace {\n-    pub fn ReturnValue() -> Self {\n-        AttributePlace::Argument(0)\n-    }\n-\n     pub fn as_uint(self) -> c_uint {\n         match self {\n+            AttributePlace::ReturnValue => 0,\n+            AttributePlace::Argument(i) => 1 + i,\n             AttributePlace::Function => !0,\n-            AttributePlace::Argument(i) => i,\n         }\n     }\n }"}, {"sha": "a7599f19244c215df39ef654b64adafff34e81f0", "filename": "src/librustc_mir/build/matches/simplify.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -98,19 +98,16 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }\n \n             PatternKind::Variant { adt_def, substs, variant_index, ref subpatterns } => {\n-                if self.hir.tcx().sess.features.borrow().never_type {\n-                    let irrefutable = adt_def.variants.iter().enumerate().all(|(i, v)| {\n-                        i == variant_index || {\n-                            self.hir.tcx().is_variant_uninhabited_from_all_modules(v, substs)\n-                        }\n-                    });\n-                    if irrefutable {\n-                        let lvalue = match_pair.lvalue.downcast(adt_def, variant_index);\n-                        candidate.match_pairs.extend(self.field_match_pairs(lvalue, subpatterns));\n-                        Ok(())\n-                    } else {\n-                        Err(match_pair)\n+                let irrefutable = adt_def.variants.iter().enumerate().all(|(i, v)| {\n+                    i == variant_index || {\n+                        self.hir.tcx().sess.features.borrow().never_type &&\n+                        self.hir.tcx().is_variant_uninhabited_from_all_modules(v, substs)\n                     }\n+                });\n+                if irrefutable {\n+                    let lvalue = match_pair.lvalue.downcast(adt_def, variant_index);\n+                    candidate.match_pairs.extend(self.field_match_pairs(lvalue, subpatterns));\n+                    Ok(())\n                 } else {\n                     Err(match_pair)\n                 }"}, {"sha": "02a7bc83f6ee822cece374180c16a62a9ea554c9", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -39,7 +39,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     span: match_pair.pattern.span,\n                     kind: TestKind::Switch {\n                         adt_def: adt_def.clone(),\n-                        variants: BitVector::new(self.hir.num_variants(adt_def)),\n+                        variants: BitVector::new(adt_def.variants.len()),\n                     },\n                 }\n             }\n@@ -184,7 +184,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         match test.kind {\n             TestKind::Switch { adt_def, ref variants } => {\n                 // Variants is a BitVec of indexes into adt_def.variants.\n-                let num_enum_variants = self.hir.num_variants(adt_def);\n+                let num_enum_variants = adt_def.variants.len();\n                 let used_variants = variants.count();\n                 let mut otherwise_block = None;\n                 let mut target_blocks = Vec::with_capacity(num_enum_variants);"}, {"sha": "b1f4b849b8928f4ec09c1cb9bd4c49f905733532", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -213,10 +213,6 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         bug!(\"found no method `{}` in `{:?}`\", method_name, trait_def_id);\n     }\n \n-    pub fn num_variants(&mut self, adt_def: &ty::AdtDef) -> usize {\n-        adt_def.variants.len()\n-    }\n-\n     pub fn all_fields(&mut self, adt_def: &ty::AdtDef, variant_index: usize) -> Vec<Field> {\n         (0..adt_def.variants[variant_index].fields.len())\n             .map(Field::new)"}, {"sha": "e2ecd4839fb483f0d8f202711a05f131ff182562", "filename": "src/librustc_mir/transform/deaggregator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -67,7 +67,7 @@ impl MirPass for Deaggregator {\n                     let ty = variant_def.fields[i].ty(tcx, substs);\n                     let rhs = Rvalue::Use(op.clone());\n \n-                    let lhs_cast = if adt_def.variants.len() > 1 {\n+                    let lhs_cast = if adt_def.is_enum() {\n                         Lvalue::Projection(Box::new(LvalueProjection {\n                             base: lhs.clone(),\n                             elem: ProjectionElem::Downcast(adt_def, variant),\n@@ -89,7 +89,7 @@ impl MirPass for Deaggregator {\n                 }\n \n                 // if the aggregate was an enum, we need to set the discriminant\n-                if adt_def.variants.len() > 1 {\n+                if adt_def.is_enum() {\n                     let set_discriminant = Statement {\n                         kind: StatementKind::SetDiscriminant {\n                             lvalue: lhs.clone(),"}, {"sha": "4b7856f857b778b10637d570279343e41f05936a", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -19,6 +19,7 @@ use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc::mir::*;\n use rustc::mir::visit::*;\n use rustc::ty::{self, Instance, Ty, TyCtxt, TypeFoldable};\n+use rustc::ty::layout::LayoutOf;\n use rustc::ty::subst::{Subst,Substs};\n \n use std::collections::VecDeque;\n@@ -625,9 +626,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n fn type_size_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           param_env: ty::ParamEnv<'tcx>,\n                           ty: Ty<'tcx>) -> Option<u64> {\n-    ty.layout(tcx, param_env).ok().map(|layout| {\n-        layout.size(&tcx.data_layout).bytes()\n-    })\n+    (tcx, param_env).layout_of(ty).ok().map(|layout| layout.size.bytes())\n }\n \n fn subst_and_normalize<'a, 'tcx: 'a>("}, {"sha": "cc6b702090314fc59fbface4ebe8e044ce818501", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -344,7 +344,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                 variant_index,\n             } => (&adt_def.variants[variant_index], substs),\n             LvalueTy::Ty { ty } => match ty.sty {\n-                ty::TyAdt(adt_def, substs) if adt_def.is_univariant() => {\n+                ty::TyAdt(adt_def, substs) if !adt_def.is_enum() => {\n                     (&adt_def.variants[0], substs)\n                 }\n                 ty::TyClosure(def_id, substs) => {"}, {"sha": "1852712a083751a02410e93fb3a3cbfe9a027590", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -384,7 +384,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n                                   substs: &'tcx Substs<'tcx>)\n                                   -> (BasicBlock, Unwind) {\n         let (succ, unwind) = self.drop_ladder_bottom();\n-        if adt.variants.len() == 1 {\n+        if !adt.is_enum() {\n             let fields = self.move_paths_for_fields(\n                 self.lvalue,\n                 self.path,"}, {"sha": "54828044de670a4636dd0db6b4ead816535aa85f", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 427, "deletions": 386, "changes": 813, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -11,7 +11,7 @@\n use llvm::{self, ValueRef, AttributePlace};\n use base;\n use builder::Builder;\n-use common::{instance_ty, ty_fn_sig, type_is_fat_ptr, C_usize};\n+use common::{instance_ty, ty_fn_sig, C_usize};\n use context::CrateContext;\n use cabi_x86;\n use cabi_x86_64;\n@@ -30,31 +30,34 @@ use cabi_sparc64;\n use cabi_nvptx;\n use cabi_nvptx64;\n use cabi_hexagon;\n-use machine::llalign_of_min;\n+use mir::lvalue::{Alignment, LvalueRef};\n+use mir::operand::OperandValue;\n use type_::Type;\n-use type_of;\n+use type_of::{LayoutLlvmExt, PointerKind};\n \n-use rustc::hir;\n use rustc::ty::{self, Ty};\n-use rustc::ty::layout::{self, Layout, LayoutTyper, TyLayout, Size};\n-use rustc_back::PanicStrategy;\n+use rustc::ty::layout::{self, Align, Size, TyLayout};\n+use rustc::ty::layout::{HasDataLayout, LayoutOf};\n \n use libc::c_uint;\n-use std::cmp;\n-use std::iter;\n+use std::{cmp, iter};\n \n pub use syntax::abi::Abi;\n pub use rustc::ty::layout::{FAT_PTR_ADDR, FAT_PTR_EXTRA};\n \n-#[derive(Clone, Copy, PartialEq, Debug)]\n-enum ArgKind {\n-    /// Pass the argument directly using the normal converted\n-    /// LLVM type or by coercing to another specified type\n-    Direct,\n-    /// Pass the argument indirectly via a hidden pointer\n-    Indirect,\n-    /// Ignore the argument (useful for empty struct)\n+#[derive(Clone, Copy, PartialEq, Eq, Debug)]\n+pub enum PassMode {\n+    /// Ignore the argument (useful for empty struct).\n     Ignore,\n+    /// Pass the argument directly.\n+    Direct(ArgAttributes),\n+    /// Pass a pair's elements directly in two arguments.\n+    Pair(ArgAttributes, ArgAttributes),\n+    /// Pass the argument after casting it, to either\n+    /// a single uniform or a pair of registers.\n+    Cast(CastTarget),\n+    /// Pass the argument indirectly via a hidden pointer.\n+    Indirect(ArgAttributes),\n }\n \n // Hack to disable non_upper_case_globals only for the bitflags! and not for the rest\n@@ -96,20 +99,24 @@ impl ArgAttribute {\n \n /// A compact representation of LLVM attributes (at least those relevant for this module)\n /// that can be manipulated without interacting with LLVM's Attribute machinery.\n-#[derive(Copy, Clone, Debug, Default)]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub struct ArgAttributes {\n     regular: ArgAttribute,\n-    dereferenceable_bytes: u64,\n+    pointee_size: Size,\n+    pointee_align: Option<Align>\n }\n \n impl ArgAttributes {\n-    pub fn set(&mut self, attr: ArgAttribute) -> &mut Self {\n-        self.regular = self.regular | attr;\n-        self\n+    fn new() -> Self {\n+        ArgAttributes {\n+            regular: ArgAttribute::default(),\n+            pointee_size: Size::from_bytes(0),\n+            pointee_align: None,\n+        }\n     }\n \n-    pub fn set_dereferenceable(&mut self, bytes: u64) -> &mut Self {\n-        self.dereferenceable_bytes = bytes;\n+    pub fn set(&mut self, attr: ArgAttribute) -> &mut Self {\n+        self.regular = self.regular | attr;\n         self\n     }\n \n@@ -118,24 +125,52 @@ impl ArgAttributes {\n     }\n \n     pub fn apply_llfn(&self, idx: AttributePlace, llfn: ValueRef) {\n+        let mut regular = self.regular;\n         unsafe {\n-            self.regular.for_each_kind(|attr| attr.apply_llfn(idx, llfn));\n-            if self.dereferenceable_bytes != 0 {\n-                llvm::LLVMRustAddDereferenceableAttr(llfn,\n-                                                     idx.as_uint(),\n-                                                     self.dereferenceable_bytes);\n+            let deref = self.pointee_size.bytes();\n+            if deref != 0 {\n+                if regular.contains(ArgAttribute::NonNull) {\n+                    llvm::LLVMRustAddDereferenceableAttr(llfn,\n+                                                         idx.as_uint(),\n+                                                         deref);\n+                } else {\n+                    llvm::LLVMRustAddDereferenceableOrNullAttr(llfn,\n+                                                               idx.as_uint(),\n+                                                               deref);\n+                }\n+                regular -= ArgAttribute::NonNull;\n             }\n+            if let Some(align) = self.pointee_align {\n+                llvm::LLVMRustAddAlignmentAttr(llfn,\n+                                               idx.as_uint(),\n+                                               align.abi() as u32);\n+            }\n+            regular.for_each_kind(|attr| attr.apply_llfn(idx, llfn));\n         }\n     }\n \n     pub fn apply_callsite(&self, idx: AttributePlace, callsite: ValueRef) {\n+        let mut regular = self.regular;\n         unsafe {\n-            self.regular.for_each_kind(|attr| attr.apply_callsite(idx, callsite));\n-            if self.dereferenceable_bytes != 0 {\n-                llvm::LLVMRustAddDereferenceableCallSiteAttr(callsite,\n-                                                             idx.as_uint(),\n-                                                             self.dereferenceable_bytes);\n+            let deref = self.pointee_size.bytes();\n+            if deref != 0 {\n+                if regular.contains(ArgAttribute::NonNull) {\n+                    llvm::LLVMRustAddDereferenceableCallSiteAttr(callsite,\n+                                                                 idx.as_uint(),\n+                                                                 deref);\n+                } else {\n+                    llvm::LLVMRustAddDereferenceableOrNullCallSiteAttr(callsite,\n+                                                                       idx.as_uint(),\n+                                                                       deref);\n+                }\n+                regular -= ArgAttribute::NonNull;\n+            }\n+            if let Some(align) = self.pointee_align {\n+                llvm::LLVMRustAddAlignmentCallSiteAttr(callsite,\n+                                                       idx.as_uint(),\n+                                                       align.abi() as u32);\n             }\n+            regular.for_each_kind(|attr| attr.apply_callsite(idx, callsite));\n         }\n     }\n }\n@@ -174,7 +209,32 @@ impl Reg {\n }\n \n impl Reg {\n-    fn llvm_type(&self, ccx: &CrateContext) -> Type {\n+    pub fn align(&self, ccx: &CrateContext) -> Align {\n+        let dl = ccx.data_layout();\n+        match self.kind {\n+            RegKind::Integer => {\n+                match self.size.bits() {\n+                    1 => dl.i1_align,\n+                    2...8 => dl.i8_align,\n+                    9...16 => dl.i16_align,\n+                    17...32 => dl.i32_align,\n+                    33...64 => dl.i64_align,\n+                    65...128 => dl.i128_align,\n+                    _ => bug!(\"unsupported integer: {:?}\", self)\n+                }\n+            }\n+            RegKind::Float => {\n+                match self.size.bits() {\n+                    32 => dl.f32_align,\n+                    64 => dl.f64_align,\n+                    _ => bug!(\"unsupported float: {:?}\", self)\n+                }\n+            }\n+            RegKind::Vector => dl.vector_align(self.size)\n+        }\n+    }\n+\n+    pub fn llvm_type(&self, ccx: &CrateContext) -> Type {\n         match self.kind {\n             RegKind::Integer => Type::ix(ccx, self.size.bits()),\n             RegKind::Float => {\n@@ -193,7 +253,7 @@ impl Reg {\n \n /// An argument passed entirely registers with the\n /// same kind (e.g. HFA / HVA on PPC64 and AArch64).\n-#[derive(Copy, Clone)]\n+#[derive(Clone, Copy, PartialEq, Eq, Debug)]\n pub struct Uniform {\n     pub unit: Reg,\n \n@@ -216,7 +276,11 @@ impl From<Reg> for Uniform {\n }\n \n impl Uniform {\n-    fn llvm_type(&self, ccx: &CrateContext) -> Type {\n+    pub fn align(&self, ccx: &CrateContext) -> Align {\n+        self.unit.align(ccx)\n+    }\n+\n+    pub fn llvm_type(&self, ccx: &CrateContext) -> Type {\n         let llunit = self.unit.llvm_type(ccx);\n \n         if self.total <= self.unit.size {\n@@ -248,106 +312,62 @@ pub trait LayoutExt<'tcx> {\n \n impl<'tcx> LayoutExt<'tcx> for TyLayout<'tcx> {\n     fn is_aggregate(&self) -> bool {\n-        match *self.layout {\n-            Layout::Scalar { .. } |\n-            Layout::RawNullablePointer { .. } |\n-            Layout::CEnum { .. } |\n-            Layout::Vector { .. } => false,\n-\n-            Layout::Array { .. } |\n-            Layout::FatPointer { .. } |\n-            Layout::Univariant { .. } |\n-            Layout::UntaggedUnion { .. } |\n-            Layout::General { .. } |\n-            Layout::StructWrappedNullablePointer { .. } => true\n+        match self.abi {\n+            layout::Abi::Uninhabited |\n+            layout::Abi::Scalar(_) |\n+            layout::Abi::Vector => false,\n+            layout::Abi::ScalarPair(..) |\n+            layout::Abi::Aggregate { .. } => true\n         }\n     }\n \n     fn homogeneous_aggregate<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> Option<Reg> {\n-        match *self.layout {\n-            // The primitives for this algorithm.\n-            Layout::Scalar { value, .. } |\n-            Layout::RawNullablePointer { value, .. } => {\n-                let kind = match value {\n-                    layout::Int(_) |\n+        match self.abi {\n+            layout::Abi::Uninhabited => None,\n+\n+            // The primitive for this algorithm.\n+            layout::Abi::Scalar(ref scalar) => {\n+                let kind = match scalar.value {\n+                    layout::Int(..) |\n                     layout::Pointer => RegKind::Integer,\n                     layout::F32 |\n                     layout::F64 => RegKind::Float\n                 };\n                 Some(Reg {\n                     kind,\n-                    size: self.size(ccx)\n+                    size: self.size\n                 })\n             }\n \n-            Layout::CEnum { .. } => {\n-                Some(Reg {\n-                    kind: RegKind::Integer,\n-                    size: self.size(ccx)\n-                })\n-            }\n-\n-            Layout::Vector { .. } => {\n+            layout::Abi::Vector => {\n                 Some(Reg {\n                     kind: RegKind::Vector,\n-                    size: self.size(ccx)\n+                    size: self.size\n                 })\n             }\n \n-            Layout::Array { count, .. } => {\n-                if count > 0 {\n-                    self.field(ccx, 0).homogeneous_aggregate(ccx)\n-                } else {\n-                    None\n-                }\n-            }\n-\n-            Layout::Univariant { ref variant, .. } => {\n-                let mut unaligned_offset = Size::from_bytes(0);\n+            layout::Abi::ScalarPair(..) |\n+            layout::Abi::Aggregate { .. } => {\n+                let mut total = Size::from_bytes(0);\n                 let mut result = None;\n \n-                for i in 0..self.field_count() {\n-                    if unaligned_offset != variant.offsets[i] {\n-                        return None;\n-                    }\n-\n-                    let field = self.field(ccx, i);\n-                    match (result, field.homogeneous_aggregate(ccx)) {\n-                        // The field itself must be a homogeneous aggregate.\n-                        (_, None) => return None,\n-                        // If this is the first field, record the unit.\n-                        (None, Some(unit)) => {\n-                            result = Some(unit);\n-                        }\n-                        // For all following fields, the unit must be the same.\n-                        (Some(prev_unit), Some(unit)) => {\n-                            if prev_unit != unit {\n-                                return None;\n-                            }\n+                let is_union = match self.fields {\n+                    layout::FieldPlacement::Array { count, .. } => {\n+                        if count > 0 {\n+                            return self.field(ccx, 0).homogeneous_aggregate(ccx);\n+                        } else {\n+                            return None;\n                         }\n                     }\n+                    layout::FieldPlacement::Union(_) => true,\n+                    layout::FieldPlacement::Arbitrary { .. } => false\n+                };\n \n-                    // Keep track of the offset (without padding).\n-                    let size = field.size(ccx);\n-                    match unaligned_offset.checked_add(size, ccx) {\n-                        Some(offset) => unaligned_offset = offset,\n-                        None => return None\n+                for i in 0..self.fields.count() {\n+                    if !is_union && total != self.fields.offset(i) {\n+                        return None;\n                     }\n-                }\n-\n-                // There needs to be no padding.\n-                if unaligned_offset != self.size(ccx) {\n-                    None\n-                } else {\n-                    result\n-                }\n-            }\n \n-            Layout::UntaggedUnion { .. } => {\n-                let mut max = Size::from_bytes(0);\n-                let mut result = None;\n-\n-                for i in 0..self.field_count() {\n                     let field = self.field(ccx, i);\n                     match (result, field.homogeneous_aggregate(ccx)) {\n                         // The field itself must be a homogeneous aggregate.\n@@ -365,28 +385,26 @@ impl<'tcx> LayoutExt<'tcx> for TyLayout<'tcx> {\n                     }\n \n                     // Keep track of the offset (without padding).\n-                    let size = field.size(ccx);\n-                    if size > max {\n-                        max = size;\n+                    let size = field.size;\n+                    if is_union {\n+                        total = cmp::max(total, size);\n+                    } else {\n+                        total += size;\n                     }\n                 }\n \n                 // There needs to be no padding.\n-                if max != self.size(ccx) {\n+                if total != self.size {\n                     None\n                 } else {\n                     result\n                 }\n             }\n-\n-            // Rust-specific types, which we can ignore for C ABIs.\n-            Layout::FatPointer { .. } |\n-            Layout::General { .. } |\n-            Layout::StructWrappedNullablePointer { .. } => None\n         }\n     }\n }\n \n+#[derive(Clone, Copy, PartialEq, Eq, Debug)]\n pub enum CastTarget {\n     Uniform(Uniform),\n     Pair(Reg, Reg)\n@@ -405,7 +423,28 @@ impl From<Uniform> for CastTarget {\n }\n \n impl CastTarget {\n-    fn llvm_type(&self, ccx: &CrateContext) -> Type {\n+    pub fn size(&self, ccx: &CrateContext) -> Size {\n+        match *self {\n+            CastTarget::Uniform(u) => u.total,\n+            CastTarget::Pair(a, b) => {\n+                (a.size.abi_align(a.align(ccx)) + b.size)\n+                    .abi_align(self.align(ccx))\n+            }\n+        }\n+    }\n+\n+    pub fn align(&self, ccx: &CrateContext) -> Align {\n+        match *self {\n+            CastTarget::Uniform(u) => u.align(ccx),\n+            CastTarget::Pair(a, b) => {\n+                ccx.data_layout().aggregate_align\n+                    .max(a.align(ccx))\n+                    .max(b.align(ccx))\n+            }\n+        }\n+    }\n+\n+    pub fn llvm_type(&self, ccx: &CrateContext) -> Type {\n         match *self {\n             CastTarget::Uniform(u) => u.llvm_type(ccx),\n             CastTarget::Pair(a, b) => {\n@@ -418,131 +457,118 @@ impl CastTarget {\n     }\n }\n \n-/// Information about how a specific C type\n-/// should be passed to or returned from a function\n-///\n-/// This is borrowed from clang's ABIInfo.h\n-#[derive(Clone, Copy, Debug)]\n+/// Information about how to pass an argument to,\n+/// or return a value from, a function, under some ABI.\n+#[derive(Debug)]\n pub struct ArgType<'tcx> {\n-    kind: ArgKind,\n     pub layout: TyLayout<'tcx>,\n-    /// Coerced LLVM Type\n-    pub cast: Option<Type>,\n-    /// Dummy argument, which is emitted before the real argument\n-    pub pad: Option<Type>,\n-    /// LLVM attributes of argument\n-    pub attrs: ArgAttributes\n+\n+    /// Dummy argument, which is emitted before the real argument.\n+    pub pad: Option<Reg>,\n+\n+    pub mode: PassMode,\n }\n \n impl<'a, 'tcx> ArgType<'tcx> {\n     fn new(layout: TyLayout<'tcx>) -> ArgType<'tcx> {\n         ArgType {\n-            kind: ArgKind::Direct,\n             layout,\n-            cast: None,\n             pad: None,\n-            attrs: ArgAttributes::default()\n+            mode: PassMode::Direct(ArgAttributes::new()),\n         }\n     }\n \n-    pub fn make_indirect(&mut self, ccx: &CrateContext<'a, 'tcx>) {\n-        assert_eq!(self.kind, ArgKind::Direct);\n-\n-        // Wipe old attributes, likely not valid through indirection.\n-        self.attrs = ArgAttributes::default();\n+    pub fn make_indirect(&mut self) {\n+        assert_eq!(self.mode, PassMode::Direct(ArgAttributes::new()));\n \n-        let llarg_sz = self.layout.size(ccx).bytes();\n+        // Start with fresh attributes for the pointer.\n+        let mut attrs = ArgAttributes::new();\n \n         // For non-immediate arguments the callee gets its own copy of\n         // the value on the stack, so there are no aliases. It's also\n         // program-invisible so can't possibly capture\n-        self.attrs.set(ArgAttribute::NoAlias)\n-                  .set(ArgAttribute::NoCapture)\n-                  .set_dereferenceable(llarg_sz);\n-\n-        self.kind = ArgKind::Indirect;\n+        attrs.set(ArgAttribute::NoAlias)\n+             .set(ArgAttribute::NoCapture)\n+             .set(ArgAttribute::NonNull);\n+        attrs.pointee_size = self.layout.size;\n+        // FIXME(eddyb) We should be doing this, but at least on\n+        // i686-pc-windows-msvc, it results in wrong stack offsets.\n+        // attrs.pointee_align = Some(self.layout.align);\n+\n+        self.mode = PassMode::Indirect(attrs);\n     }\n \n-    pub fn ignore(&mut self) {\n-        assert_eq!(self.kind, ArgKind::Direct);\n-        self.kind = ArgKind::Ignore;\n+    pub fn make_indirect_byval(&mut self) {\n+        self.make_indirect();\n+        match self.mode {\n+            PassMode::Indirect(ref mut attrs) => {\n+                attrs.set(ArgAttribute::ByVal);\n+            }\n+            _ => bug!()\n+        }\n     }\n \n     pub fn extend_integer_width_to(&mut self, bits: u64) {\n         // Only integers have signedness\n-        let (i, signed) = match *self.layout {\n-            Layout::Scalar { value, .. } => {\n-                match value {\n-                    layout::Int(i) => {\n-                        if self.layout.ty.is_integral() {\n-                            (i, self.layout.ty.is_signed())\n+        if let layout::Abi::Scalar(ref scalar) = self.layout.abi {\n+            if let layout::Int(i, signed) = scalar.value {\n+                if i.size().bits() < bits {\n+                    if let PassMode::Direct(ref mut attrs) = self.mode {\n+                        attrs.set(if signed {\n+                            ArgAttribute::SExt\n                         } else {\n-                            return;\n-                        }\n+                            ArgAttribute::ZExt\n+                        });\n                     }\n-                    _ => return\n                 }\n             }\n-\n-            // Rust enum types that map onto C enums also need to follow\n-            // the target ABI zero-/sign-extension rules.\n-            Layout::CEnum { discr, signed, .. } => (discr, signed),\n-\n-            _ => return\n-        };\n-\n-        if i.size().bits() < bits {\n-            self.attrs.set(if signed {\n-                ArgAttribute::SExt\n-            } else {\n-                ArgAttribute::ZExt\n-            });\n         }\n     }\n \n-    pub fn cast_to<T: Into<CastTarget>>(&mut self, ccx: &CrateContext, target: T) {\n-        self.cast = Some(target.into().llvm_type(ccx));\n+    pub fn cast_to<T: Into<CastTarget>>(&mut self, target: T) {\n+        assert_eq!(self.mode, PassMode::Direct(ArgAttributes::new()));\n+        self.mode = PassMode::Cast(target.into());\n     }\n \n-    pub fn pad_with(&mut self, ccx: &CrateContext, reg: Reg) {\n-        self.pad = Some(reg.llvm_type(ccx));\n+    pub fn pad_with(&mut self, reg: Reg) {\n+        self.pad = Some(reg);\n     }\n \n     pub fn is_indirect(&self) -> bool {\n-        self.kind == ArgKind::Indirect\n+        match self.mode {\n+            PassMode::Indirect(_) => true,\n+            _ => false\n+        }\n     }\n \n     pub fn is_ignore(&self) -> bool {\n-        self.kind == ArgKind::Ignore\n+        self.mode == PassMode::Ignore\n     }\n \n     /// Get the LLVM type for an lvalue of the original Rust type of\n     /// this argument/return, i.e. the result of `type_of::type_of`.\n     pub fn memory_ty(&self, ccx: &CrateContext<'a, 'tcx>) -> Type {\n-        type_of::type_of(ccx, self.layout.ty)\n+        self.layout.llvm_type(ccx)\n     }\n \n     /// Store a direct/indirect value described by this ArgType into a\n     /// lvalue for the original Rust type of this argument/return.\n     /// Can be used for both storing formal arguments into Rust variables\n     /// or results of call/invoke instructions into their destinations.\n-    pub fn store(&self, bcx: &Builder<'a, 'tcx>, mut val: ValueRef, dst: ValueRef) {\n+    pub fn store(&self, bcx: &Builder<'a, 'tcx>, val: ValueRef, dst: LvalueRef<'tcx>) {\n         if self.is_ignore() {\n             return;\n         }\n         let ccx = bcx.ccx;\n         if self.is_indirect() {\n-            let llsz = C_usize(ccx, self.layout.size(ccx).bytes());\n-            let llalign = self.layout.align(ccx).abi();\n-            base::call_memcpy(bcx, dst, val, llsz, llalign as u32);\n-        } else if let Some(ty) = self.cast {\n+            OperandValue::Ref(val, Alignment::AbiAligned).store(bcx, dst)\n+        } else if let PassMode::Cast(cast) = self.mode {\n             // FIXME(eddyb): Figure out when the simpler Store is safe, clang\n             // uses it for i16 -> {i8, i8}, but not for i24 -> {i8, i8, i8}.\n             let can_store_through_cast_ptr = false;\n             if can_store_through_cast_ptr {\n-                let cast_dst = bcx.pointercast(dst, ty.ptr_to());\n-                let llalign = self.layout.align(ccx).abi();\n-                bcx.store(val, cast_dst, Some(llalign as u32));\n+                let cast_dst = bcx.pointercast(dst.llval, cast.llvm_type(ccx).ptr_to());\n+                bcx.store(val, cast_dst, Some(self.layout.align));\n             } else {\n                 // The actual return type is a struct, but the ABI\n                 // adaptation code has cast it into some scalar type.  The\n@@ -559,40 +585,45 @@ impl<'a, 'tcx> ArgType<'tcx> {\n                 //   bitcasting to the struct type yields invalid cast errors.\n \n                 // We instead thus allocate some scratch space...\n-                let llscratch = bcx.alloca(ty, \"abi_cast\", None);\n-                base::Lifetime::Start.call(bcx, llscratch);\n+                let llscratch = bcx.alloca(cast.llvm_type(ccx), \"abi_cast\", cast.align(ccx));\n+                let scratch_size = cast.size(ccx);\n+                bcx.lifetime_start(llscratch, scratch_size);\n \n                 // ...where we first store the value...\n                 bcx.store(val, llscratch, None);\n \n                 // ...and then memcpy it to the intended destination.\n                 base::call_memcpy(bcx,\n-                                  bcx.pointercast(dst, Type::i8p(ccx)),\n+                                  bcx.pointercast(dst.llval, Type::i8p(ccx)),\n                                   bcx.pointercast(llscratch, Type::i8p(ccx)),\n-                                  C_usize(ccx, self.layout.size(ccx).bytes()),\n-                                  cmp::min(self.layout.align(ccx).abi() as u32,\n-                                           llalign_of_min(ccx, ty)));\n+                                  C_usize(ccx, self.layout.size.bytes()),\n+                                  self.layout.align.min(cast.align(ccx)));\n \n-                base::Lifetime::End.call(bcx, llscratch);\n+                bcx.lifetime_end(llscratch, scratch_size);\n             }\n         } else {\n-            if self.layout.ty == ccx.tcx().types.bool {\n-                val = bcx.zext(val, Type::i8(ccx));\n-            }\n-            bcx.store(val, dst, None);\n+            OperandValue::Immediate(val).store(bcx, dst);\n         }\n     }\n \n-    pub fn store_fn_arg(&self, bcx: &Builder<'a, 'tcx>, idx: &mut usize, dst: ValueRef) {\n+    pub fn store_fn_arg(&self, bcx: &Builder<'a, 'tcx>, idx: &mut usize, dst: LvalueRef<'tcx>) {\n         if self.pad.is_some() {\n             *idx += 1;\n         }\n-        if self.is_ignore() {\n-            return;\n+        let mut next = || {\n+            let val = llvm::get_param(bcx.llfn(), *idx as c_uint);\n+            *idx += 1;\n+            val\n+        };\n+        match self.mode {\n+            PassMode::Ignore => {},\n+            PassMode::Pair(..) => {\n+                OperandValue::Pair(next(), next()).store(bcx, dst);\n+            }\n+            PassMode::Direct(_) | PassMode::Indirect(_) | PassMode::Cast(_) => {\n+                self.store(bcx, next(), dst);\n+            }\n         }\n-        let val = llvm::get_param(bcx.llfn(), *idx as c_uint);\n-        *idx += 1;\n-        self.store(bcx, val, dst);\n     }\n }\n \n@@ -601,7 +632,7 @@ impl<'a, 'tcx> ArgType<'tcx> {\n ///\n /// I will do my best to describe this structure, but these\n /// comments are reverse-engineered and may be inaccurate. -NDM\n-#[derive(Clone, Debug)]\n+#[derive(Debug)]\n pub struct FnType<'tcx> {\n     /// The LLVM types of each argument.\n     pub args: Vec<ArgType<'tcx>>,\n@@ -620,14 +651,14 @@ impl<'a, 'tcx> FnType<'tcx> {\n         let fn_ty = instance_ty(ccx.tcx(), &instance);\n         let sig = ty_fn_sig(ccx, fn_ty);\n         let sig = ccx.tcx().erase_late_bound_regions_and_normalize(&sig);\n-        Self::new(ccx, sig, &[])\n+        FnType::new(ccx, sig, &[])\n     }\n \n     pub fn new(ccx: &CrateContext<'a, 'tcx>,\n                sig: ty::FnSig<'tcx>,\n                extra_args: &[Ty<'tcx>]) -> FnType<'tcx> {\n         let mut fn_ty = FnType::unadjusted(ccx, sig, extra_args);\n-        fn_ty.adjust_for_abi(ccx, sig);\n+        fn_ty.adjust_for_abi(ccx, sig.abi);\n         fn_ty\n     }\n \n@@ -636,8 +667,23 @@ impl<'a, 'tcx> FnType<'tcx> {\n                       extra_args: &[Ty<'tcx>]) -> FnType<'tcx> {\n         let mut fn_ty = FnType::unadjusted(ccx, sig, extra_args);\n         // Don't pass the vtable, it's not an argument of the virtual fn.\n-        fn_ty.args[1].ignore();\n-        fn_ty.adjust_for_abi(ccx, sig);\n+        {\n+            let self_arg = &mut fn_ty.args[0];\n+            match self_arg.mode {\n+                PassMode::Pair(data_ptr, _) => {\n+                    self_arg.mode = PassMode::Direct(data_ptr);\n+                }\n+                _ => bug!(\"FnType::new_vtable: non-pair self {:?}\", self_arg)\n+            }\n+\n+            let pointee = self_arg.layout.ty.builtin_deref(true, ty::NoPreference)\n+                .unwrap_or_else(|| {\n+                    bug!(\"FnType::new_vtable: non-pointer self {:?}\", self_arg)\n+                }).ty;\n+            let fat_ptr_ty = ccx.tcx().mk_mut_ptr(pointee);\n+            self_arg.layout = ccx.layout_of(fat_ptr_ty).field(ccx, 0);\n+        }\n+        fn_ty.adjust_for_abi(ccx, sig.abi);\n         fn_ty\n     }\n \n@@ -702,184 +748,152 @@ impl<'a, 'tcx> FnType<'tcx> {\n             _ => false\n         };\n \n-        let arg_of = |ty: Ty<'tcx>, is_return: bool| {\n-            let mut arg = ArgType::new(ccx.layout_of(ty));\n-            if ty.is_bool() {\n-                arg.attrs.set(ArgAttribute::ZExt);\n-            } else {\n-                if arg.layout.size(ccx).bytes() == 0 {\n-                    // For some forsaken reason, x86_64-pc-windows-gnu\n-                    // doesn't ignore zero-sized struct arguments.\n-                    // The same is true for s390x-unknown-linux-gnu.\n-                    if is_return || rust_abi ||\n-                       (!win_x64_gnu && !linux_s390x) {\n-                        arg.ignore();\n-                    }\n-                }\n+        // Handle safe Rust thin and fat pointers.\n+        let adjust_for_rust_scalar = |attrs: &mut ArgAttributes,\n+                                      scalar: &layout::Scalar,\n+                                      layout: TyLayout<'tcx>,\n+                                      offset: Size,\n+                                      is_return: bool| {\n+            // Booleans are always an i1 that needs to be zero-extended.\n+            if scalar.is_bool() {\n+                attrs.set(ArgAttribute::ZExt);\n+                return;\n             }\n-            arg\n-        };\n-\n-        let ret_ty = sig.output();\n-        let mut ret = arg_of(ret_ty, true);\n \n-        if !type_is_fat_ptr(ccx, ret_ty) {\n-            // The `noalias` attribute on the return value is useful to a\n-            // function ptr caller.\n-            if ret_ty.is_box() {\n-                // `Box` pointer return values never alias because ownership\n-                // is transferred\n-                ret.attrs.set(ArgAttribute::NoAlias);\n+            // Only pointer types handled below.\n+            if scalar.value != layout::Pointer {\n+                return;\n             }\n \n-            // We can also mark the return value as `dereferenceable` in certain cases\n-            match ret_ty.sty {\n-                // These are not really pointers but pairs, (pointer, len)\n-                ty::TyRef(_, ty::TypeAndMut { ty, .. }) => {\n-                    ret.attrs.set_dereferenceable(ccx.size_of(ty));\n-                }\n-                ty::TyAdt(def, _) if def.is_box() => {\n-                    ret.attrs.set_dereferenceable(ccx.size_of(ret_ty.boxed_ty()));\n+            if scalar.valid_range.start < scalar.valid_range.end {\n+                if scalar.valid_range.start > 0 {\n+                    attrs.set(ArgAttribute::NonNull);\n                 }\n-                _ => {}\n             }\n-        }\n \n-        let mut args = Vec::with_capacity(inputs.len() + extra_args.len());\n+            if let Some(pointee) = layout.pointee_info_at(ccx, offset) {\n+                if let Some(kind) = pointee.safe {\n+                    attrs.pointee_size = pointee.size;\n+                    attrs.pointee_align = Some(pointee.align);\n \n-        // Handle safe Rust thin and fat pointers.\n-        let rust_ptr_attrs = |ty: Ty<'tcx>, arg: &mut ArgType| match ty.sty {\n-            // `Box` pointer parameters never alias because ownership is transferred\n-            ty::TyAdt(def, _) if def.is_box() => {\n-                arg.attrs.set(ArgAttribute::NoAlias);\n-                Some(ty.boxed_ty())\n-            }\n+                    // HACK(eddyb) LLVM inserts `llvm.assume` calls when inlining functions\n+                    // with align attributes, and those calls later block optimizations.\n+                    if !is_return {\n+                        attrs.pointee_align = None;\n+                    }\n \n-            ty::TyRef(_, mt) => {\n-                // `&mut` pointer parameters never alias other parameters, or mutable global data\n-                //\n-                // `&T` where `T` contains no `UnsafeCell<U>` is immutable, and can be marked as\n-                // both `readonly` and `noalias`, as LLVM's definition of `noalias` is based solely\n-                // on memory dependencies rather than pointer equality\n-                let is_freeze = ccx.shared().type_is_freeze(mt.ty);\n-\n-                let no_alias_is_safe =\n-                    if ccx.shared().tcx().sess.opts.debugging_opts.mutable_noalias ||\n-                       ccx.shared().tcx().sess.panic_strategy() == PanicStrategy::Abort {\n-                        // Mutable refrences or immutable shared references\n-                        mt.mutbl == hir::MutMutable || is_freeze\n-                    } else {\n-                        // Only immutable shared references\n-                        mt.mutbl != hir::MutMutable && is_freeze\n+                    // `Box` pointer parameters never alias because ownership is transferred\n+                    // `&mut` pointer parameters never alias other parameters,\n+                    // or mutable global data\n+                    //\n+                    // `&T` where `T` contains no `UnsafeCell<U>` is immutable,\n+                    // and can be marked as both `readonly` and `noalias`, as\n+                    // LLVM's definition of `noalias` is based solely on memory\n+                    // dependencies rather than pointer equality\n+                    let no_alias = match kind {\n+                        PointerKind::Shared => false,\n+                        PointerKind::Frozen | PointerKind::UniqueOwned => true,\n+                        PointerKind::UniqueBorrowed => !is_return\n                     };\n+                    if no_alias {\n+                        attrs.set(ArgAttribute::NoAlias);\n+                    }\n \n-                if no_alias_is_safe {\n-                    arg.attrs.set(ArgAttribute::NoAlias);\n+                    if kind == PointerKind::Frozen && !is_return {\n+                        attrs.set(ArgAttribute::ReadOnly);\n+                    }\n                 }\n+            }\n+        };\n \n-                if mt.mutbl == hir::MutImmutable && is_freeze {\n-                    arg.attrs.set(ArgAttribute::ReadOnly);\n+        let arg_of = |ty: Ty<'tcx>, is_return: bool| {\n+            let mut arg = ArgType::new(ccx.layout_of(ty));\n+            if arg.layout.is_zst() {\n+                // For some forsaken reason, x86_64-pc-windows-gnu\n+                // doesn't ignore zero-sized struct arguments.\n+                // The same is true for s390x-unknown-linux-gnu.\n+                if is_return || rust_abi || (!win_x64_gnu && !linux_s390x) {\n+                    arg.mode = PassMode::Ignore;\n                 }\n-\n-                Some(mt.ty)\n             }\n-            _ => None\n-        };\n \n-        for ty in inputs.iter().chain(extra_args.iter()) {\n-            let mut arg = arg_of(ty, false);\n-\n-            if let ty::layout::FatPointer { .. } = *arg.layout {\n-                let mut data = ArgType::new(arg.layout.field(ccx, 0));\n-                let mut info = ArgType::new(arg.layout.field(ccx, 1));\n-\n-                if let Some(inner) = rust_ptr_attrs(ty, &mut data) {\n-                    data.attrs.set(ArgAttribute::NonNull);\n-                    if ccx.tcx().struct_tail(inner).is_trait() {\n-                        // vtables can be safely marked non-null, readonly\n-                        // and noalias.\n-                        info.attrs.set(ArgAttribute::NonNull);\n-                        info.attrs.set(ArgAttribute::ReadOnly);\n-                        info.attrs.set(ArgAttribute::NoAlias);\n-                    }\n+            // FIXME(eddyb) other ABIs don't have logic for scalar pairs.\n+            if !is_return && rust_abi {\n+                if let layout::Abi::ScalarPair(ref a, ref b) = arg.layout.abi {\n+                    let mut a_attrs = ArgAttributes::new();\n+                    let mut b_attrs = ArgAttributes::new();\n+                    adjust_for_rust_scalar(&mut a_attrs,\n+                                           a,\n+                                           arg.layout,\n+                                           Size::from_bytes(0),\n+                                           false);\n+                    adjust_for_rust_scalar(&mut b_attrs,\n+                                           b,\n+                                           arg.layout,\n+                                           a.value.size(ccx).abi_align(b.value.align(ccx)),\n+                                           false);\n+                    arg.mode = PassMode::Pair(a_attrs, b_attrs);\n+                    return arg;\n                 }\n-                args.push(data);\n-                args.push(info);\n-            } else {\n-                if let Some(inner) = rust_ptr_attrs(ty, &mut arg) {\n-                    arg.attrs.set_dereferenceable(ccx.size_of(inner));\n+            }\n+\n+            if let layout::Abi::Scalar(ref scalar) = arg.layout.abi {\n+                if let PassMode::Direct(ref mut attrs) = arg.mode {\n+                    adjust_for_rust_scalar(attrs,\n+                                           scalar,\n+                                           arg.layout,\n+                                           Size::from_bytes(0),\n+                                           is_return);\n                 }\n-                args.push(arg);\n             }\n-        }\n+\n+            arg\n+        };\n \n         FnType {\n-            args,\n-            ret,\n+            ret: arg_of(sig.output(), true),\n+            args: inputs.iter().chain(extra_args.iter()).map(|ty| {\n+                arg_of(ty, false)\n+            }).collect(),\n             variadic: sig.variadic,\n             cconv,\n         }\n     }\n \n     fn adjust_for_abi(&mut self,\n                       ccx: &CrateContext<'a, 'tcx>,\n-                      sig: ty::FnSig<'tcx>) {\n-        let abi = sig.abi;\n+                      abi: Abi) {\n         if abi == Abi::Unadjusted { return }\n \n         if abi == Abi::Rust || abi == Abi::RustCall ||\n            abi == Abi::RustIntrinsic || abi == Abi::PlatformIntrinsic {\n             let fixup = |arg: &mut ArgType<'tcx>| {\n-                if !arg.layout.is_aggregate() {\n-                    return;\n-                }\n+                if arg.is_ignore() { return; }\n \n-                let size = arg.layout.size(ccx);\n-\n-                if let Some(unit) = arg.layout.homogeneous_aggregate(ccx) {\n-                    // Replace newtypes with their inner-most type.\n-                    if unit.size == size {\n-                        // Needs a cast as we've unpacked a newtype.\n-                        arg.cast_to(ccx, unit);\n-                        return;\n-                    }\n-\n-                    // Pairs of floats.\n-                    if unit.kind == RegKind::Float {\n-                        if unit.size.checked_mul(2, ccx) == Some(size) {\n-                            // FIXME(eddyb) This should be using Uniform instead of a pair,\n-                            // but the resulting [2 x float/double] breaks emscripten.\n-                            // See https://github.com/kripken/emscripten-fastcomp/issues/178.\n-                            arg.cast_to(ccx, CastTarget::Pair(unit, unit));\n-                            return;\n-                        }\n-                    }\n+                match arg.layout.abi {\n+                    layout::Abi::Aggregate { .. } => {}\n+                    _ => return\n                 }\n \n+                let size = arg.layout.size;\n                 if size > layout::Pointer.size(ccx) {\n-                    arg.make_indirect(ccx);\n+                    arg.make_indirect();\n                 } else {\n                     // We want to pass small aggregates as immediates, but using\n                     // a LLVM aggregate type for this leads to bad optimizations,\n                     // so we pick an appropriately sized integer type instead.\n-                    arg.cast_to(ccx, Reg {\n+                    arg.cast_to(Reg {\n                         kind: RegKind::Integer,\n                         size\n                     });\n                 }\n             };\n-            // Fat pointers are returned by-value.\n-            if !self.ret.is_ignore() {\n-                if !type_is_fat_ptr(ccx, sig.output()) {\n-                    fixup(&mut self.ret);\n-                }\n-            }\n+            fixup(&mut self.ret);\n             for arg in &mut self.args {\n-                if arg.is_ignore() { continue; }\n                 fixup(arg);\n             }\n-            if self.ret.is_indirect() {\n-                self.ret.attrs.set(ArgAttribute::StructRet);\n+            if let PassMode::Indirect(ref mut attrs) = self.ret.mode {\n+                attrs.set(ArgAttribute::StructRet);\n             }\n             return;\n         }\n@@ -896,7 +910,7 @@ impl<'a, 'tcx> FnType<'tcx> {\n             \"x86_64\" => if abi == Abi::SysV64 {\n                 cabi_x86_64::compute_abi_info(ccx, self);\n             } else if abi == Abi::Win64 || ccx.sess().target.target.options.is_like_windows {\n-                cabi_x86_win64::compute_abi_info(ccx, self);\n+                cabi_x86_win64::compute_abi_info(self);\n             } else {\n                 cabi_x86_64::compute_abi_info(ccx, self);\n             },\n@@ -909,51 +923,52 @@ impl<'a, 'tcx> FnType<'tcx> {\n             \"s390x\" => cabi_s390x::compute_abi_info(ccx, self),\n             \"asmjs\" => cabi_asmjs::compute_abi_info(ccx, self),\n             \"wasm32\" => cabi_asmjs::compute_abi_info(ccx, self),\n-            \"msp430\" => cabi_msp430::compute_abi_info(ccx, self),\n+            \"msp430\" => cabi_msp430::compute_abi_info(self),\n             \"sparc\" => cabi_sparc::compute_abi_info(ccx, self),\n             \"sparc64\" => cabi_sparc64::compute_abi_info(ccx, self),\n-            \"nvptx\" => cabi_nvptx::compute_abi_info(ccx, self),\n-            \"nvptx64\" => cabi_nvptx64::compute_abi_info(ccx, self),\n-            \"hexagon\" => cabi_hexagon::compute_abi_info(ccx, self),\n+            \"nvptx\" => cabi_nvptx::compute_abi_info(self),\n+            \"nvptx64\" => cabi_nvptx64::compute_abi_info(self),\n+            \"hexagon\" => cabi_hexagon::compute_abi_info(self),\n             a => ccx.sess().fatal(&format!(\"unrecognized arch \\\"{}\\\" in target specification\", a))\n         }\n \n-        if self.ret.is_indirect() {\n-            self.ret.attrs.set(ArgAttribute::StructRet);\n+        if let PassMode::Indirect(ref mut attrs) = self.ret.mode {\n+            attrs.set(ArgAttribute::StructRet);\n         }\n     }\n \n     pub fn llvm_type(&self, ccx: &CrateContext<'a, 'tcx>) -> Type {\n         let mut llargument_tys = Vec::new();\n \n-        let llreturn_ty = if self.ret.is_ignore() {\n-            Type::void(ccx)\n-        } else if self.ret.is_indirect() {\n-            llargument_tys.push(self.ret.memory_ty(ccx).ptr_to());\n-            Type::void(ccx)\n-        } else {\n-            self.ret.cast.unwrap_or_else(|| {\n-                type_of::immediate_type_of(ccx, self.ret.layout.ty)\n-            })\n+        let llreturn_ty = match self.ret.mode {\n+            PassMode::Ignore => Type::void(ccx),\n+            PassMode::Direct(_) | PassMode::Pair(..) => {\n+                self.ret.layout.immediate_llvm_type(ccx)\n+            }\n+            PassMode::Cast(cast) => cast.llvm_type(ccx),\n+            PassMode::Indirect(_) => {\n+                llargument_tys.push(self.ret.memory_ty(ccx).ptr_to());\n+                Type::void(ccx)\n+            }\n         };\n \n         for arg in &self.args {\n-            if arg.is_ignore() {\n-                continue;\n-            }\n             // add padding\n             if let Some(ty) = arg.pad {\n-                llargument_tys.push(ty);\n+                llargument_tys.push(ty.llvm_type(ccx));\n             }\n \n-            let llarg_ty = if arg.is_indirect() {\n-                arg.memory_ty(ccx).ptr_to()\n-            } else {\n-                arg.cast.unwrap_or_else(|| {\n-                    type_of::immediate_type_of(ccx, arg.layout.ty)\n-                })\n+            let llarg_ty = match arg.mode {\n+                PassMode::Ignore => continue,\n+                PassMode::Direct(_) => arg.layout.immediate_llvm_type(ccx),\n+                PassMode::Pair(..) => {\n+                    llargument_tys.push(arg.layout.scalar_pair_element_llvm_type(ccx, 0));\n+                    llargument_tys.push(arg.layout.scalar_pair_element_llvm_type(ccx, 1));\n+                    continue;\n+                }\n+                PassMode::Cast(cast) => cast.llvm_type(ccx),\n+                PassMode::Indirect(_) => arg.memory_ty(ccx).ptr_to(),\n             };\n-\n             llargument_tys.push(llarg_ty);\n         }\n \n@@ -965,31 +980,61 @@ impl<'a, 'tcx> FnType<'tcx> {\n     }\n \n     pub fn apply_attrs_llfn(&self, llfn: ValueRef) {\n-        let mut i = if self.ret.is_indirect() { 1 } else { 0 };\n-        if !self.ret.is_ignore() {\n-            self.ret.attrs.apply_llfn(llvm::AttributePlace::Argument(i), llfn);\n+        let mut i = 0;\n+        let mut apply = |attrs: &ArgAttributes| {\n+            attrs.apply_llfn(llvm::AttributePlace::Argument(i), llfn);\n+            i += 1;\n+        };\n+        match self.ret.mode {\n+            PassMode::Direct(ref attrs) => {\n+                attrs.apply_llfn(llvm::AttributePlace::ReturnValue, llfn);\n+            }\n+            PassMode::Indirect(ref attrs) => apply(attrs),\n+            _ => {}\n         }\n-        i += 1;\n         for arg in &self.args {\n-            if !arg.is_ignore() {\n-                if arg.pad.is_some() { i += 1; }\n-                arg.attrs.apply_llfn(llvm::AttributePlace::Argument(i), llfn);\n-                i += 1;\n+            if arg.pad.is_some() {\n+                apply(&ArgAttributes::new());\n+            }\n+            match arg.mode {\n+                PassMode::Ignore => {}\n+                PassMode::Direct(ref attrs) |\n+                PassMode::Indirect(ref attrs) => apply(attrs),\n+                PassMode::Pair(ref a, ref b) => {\n+                    apply(a);\n+                    apply(b);\n+                }\n+                PassMode::Cast(_) => apply(&ArgAttributes::new()),\n             }\n         }\n     }\n \n     pub fn apply_attrs_callsite(&self, callsite: ValueRef) {\n-        let mut i = if self.ret.is_indirect() { 1 } else { 0 };\n-        if !self.ret.is_ignore() {\n-            self.ret.attrs.apply_callsite(llvm::AttributePlace::Argument(i), callsite);\n+        let mut i = 0;\n+        let mut apply = |attrs: &ArgAttributes| {\n+            attrs.apply_callsite(llvm::AttributePlace::Argument(i), callsite);\n+            i += 1;\n+        };\n+        match self.ret.mode {\n+            PassMode::Direct(ref attrs) => {\n+                attrs.apply_callsite(llvm::AttributePlace::ReturnValue, callsite);\n+            }\n+            PassMode::Indirect(ref attrs) => apply(attrs),\n+            _ => {}\n         }\n-        i += 1;\n         for arg in &self.args {\n-            if !arg.is_ignore() {\n-                if arg.pad.is_some() { i += 1; }\n-                arg.attrs.apply_callsite(llvm::AttributePlace::Argument(i), callsite);\n-                i += 1;\n+            if arg.pad.is_some() {\n+                apply(&ArgAttributes::new());\n+            }\n+            match arg.mode {\n+                PassMode::Ignore => {}\n+                PassMode::Direct(ref attrs) |\n+                PassMode::Indirect(ref attrs) => apply(attrs),\n+                PassMode::Pair(ref a, ref b) => {\n+                    apply(a);\n+                    apply(b);\n+                }\n+                PassMode::Cast(_) => apply(&ArgAttributes::new()),\n             }\n         }\n \n@@ -998,7 +1043,3 @@ impl<'a, 'tcx> FnType<'tcx> {\n         }\n     }\n }\n-\n-pub fn align_up_to(off: u64, a: u64) -> u64 {\n-    (off + a - 1) / a * a\n-}"}, {"sha": "b06f8e4e671162bc007e4a20392c3d9f43ddb601", "filename": "src/librustc_trans/adt.rs", "status": "removed", "additions": 0, "deletions": 497, "changes": 497, "blob_url": "https://github.com/rust-lang/rust/blob/5041b3bb3d953a14f32b15d1e41341c629acae12/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5041b3bb3d953a14f32b15d1e41341c629acae12/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=5041b3bb3d953a14f32b15d1e41341c629acae12", "patch": "@@ -1,497 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! # Representation of Algebraic Data Types\n-//!\n-//! This module determines how to represent enums, structs, and tuples\n-//! based on their monomorphized types; it is responsible both for\n-//! choosing a representation and translating basic operations on\n-//! values of those types.  (Note: exporting the representations for\n-//! debuggers is handled in debuginfo.rs, not here.)\n-//!\n-//! Note that the interface treats everything as a general case of an\n-//! enum, so structs/tuples/etc. have one pseudo-variant with\n-//! discriminant 0; i.e., as if they were a univariant enum.\n-//!\n-//! Having everything in one place will enable improvements to data\n-//! structure representation; possibilities include:\n-//!\n-//! - User-specified alignment (e.g., cacheline-aligning parts of\n-//!   concurrently accessed data structures); LLVM can't represent this\n-//!   directly, so we'd have to insert padding fields in any structure\n-//!   that might contain one and adjust GEP indices accordingly.  See\n-//!   issue #4578.\n-//!\n-//! - Store nested enums' discriminants in the same word.  Rather, if\n-//!   some variants start with enums, and those enums representations\n-//!   have unused alignment padding between discriminant and body, the\n-//!   outer enum's discriminant can be stored there and those variants\n-//!   can start at offset 0.  Kind of fancy, and might need work to\n-//!   make copies of the inner enum type cooperate, but it could help\n-//!   with `Option` or `Result` wrapped around another enum.\n-//!\n-//! - Tagged pointers would be neat, but given that any type can be\n-//!   used unboxed and any field can have pointers (including mutable)\n-//!   taken to it, implementing them for Rust seems difficult.\n-\n-use std;\n-\n-use llvm::{ValueRef, True, IntEQ, IntNE};\n-use rustc::ty::{self, Ty};\n-use rustc::ty::layout::{self, LayoutTyper};\n-use common::*;\n-use builder::Builder;\n-use base;\n-use machine;\n-use monomorphize;\n-use type_::Type;\n-use type_of;\n-\n-use mir::lvalue::Alignment;\n-\n-/// Given an enum, struct, closure, or tuple, extracts fields.\n-/// Treats closures as a struct with one variant.\n-/// `empty_if_no_variants` is a switch to deal with empty enums.\n-/// If true, `variant_index` is disregarded and an empty Vec returned in this case.\n-pub fn compute_fields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>,\n-                                variant_index: usize,\n-                                empty_if_no_variants: bool) -> Vec<Ty<'tcx>> {\n-    match t.sty {\n-        ty::TyAdt(ref def, _) if def.variants.len() == 0 && empty_if_no_variants => {\n-            Vec::default()\n-        },\n-        ty::TyAdt(ref def, ref substs) => {\n-            def.variants[variant_index].fields.iter().map(|f| {\n-                monomorphize::field_ty(cx.tcx(), substs, f)\n-            }).collect::<Vec<_>>()\n-        },\n-        ty::TyTuple(fields, _) => fields.to_vec(),\n-        ty::TyClosure(def_id, substs) => {\n-            if variant_index > 0 { bug!(\"{} is a closure, which only has one variant\", t);}\n-            substs.upvar_tys(def_id, cx.tcx()).collect()\n-        },\n-        ty::TyGenerator(def_id, substs, _) => {\n-            if variant_index > 0 { bug!(\"{} is a generator, which only has one variant\", t);}\n-            substs.field_tys(def_id, cx.tcx()).map(|t| {\n-                cx.tcx().fully_normalize_associated_types_in(&t)\n-            }).collect()\n-        },\n-        _ => bug!(\"{} is not a type that can have fields.\", t)\n-    }\n-}\n-\n-/// LLVM-level types are a little complicated.\n-///\n-/// C-like enums need to be actual ints, not wrapped in a struct,\n-/// because that changes the ABI on some platforms (see issue #10308).\n-///\n-/// For nominal types, in some cases, we need to use LLVM named structs\n-/// and fill in the actual contents in a second pass to prevent\n-/// unbounded recursion; see also the comments in `trans::type_of`.\n-pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n-    generic_type_of(cx, t, None)\n-}\n-\n-pub fn incomplete_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                    t: Ty<'tcx>, name: &str) -> Type {\n-    generic_type_of(cx, t, Some(name))\n-}\n-\n-pub fn finish_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                t: Ty<'tcx>, llty: &mut Type) {\n-    let l = cx.layout_of(t);\n-    debug!(\"finish_type_of: {} with layout {:#?}\", t, l);\n-    match *l {\n-        layout::CEnum { .. } | layout::General { .. }\n-        | layout::UntaggedUnion { .. } | layout::RawNullablePointer { .. } => { }\n-        layout::Univariant { ..}\n-        | layout::StructWrappedNullablePointer { .. } => {\n-            let (nonnull_variant_index, nonnull_variant, packed) = match *l {\n-                layout::Univariant { ref variant, .. } => (0, variant, variant.packed),\n-                layout::StructWrappedNullablePointer { nndiscr, ref nonnull, .. } =>\n-                    (nndiscr, nonnull, nonnull.packed),\n-                _ => unreachable!()\n-            };\n-            let fields = compute_fields(cx, t, nonnull_variant_index as usize, true);\n-            llty.set_struct_body(&struct_llfields(cx, &fields, nonnull_variant),\n-                                 packed)\n-        },\n-        _ => bug!(\"This function cannot handle {} with layout {:#?}\", t, l)\n-    }\n-}\n-\n-fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                             t: Ty<'tcx>,\n-                             name: Option<&str>) -> Type {\n-    let l = cx.layout_of(t);\n-    debug!(\"adt::generic_type_of t: {:?} name: {:?}\", t, name);\n-    match *l {\n-        layout::CEnum { discr, .. } => Type::from_integer(cx, discr),\n-        layout::RawNullablePointer { nndiscr, .. } => {\n-            let (def, substs) = match t.sty {\n-                ty::TyAdt(d, s) => (d, s),\n-                _ => bug!(\"{} is not an ADT\", t)\n-            };\n-            let nnty = monomorphize::field_ty(cx.tcx(), substs,\n-                &def.variants[nndiscr as usize].fields[0]);\n-            if let layout::Scalar { value: layout::Pointer, .. } = *cx.layout_of(nnty) {\n-                Type::i8p(cx)\n-            } else {\n-                type_of::type_of(cx, nnty)\n-            }\n-        }\n-        layout::StructWrappedNullablePointer { nndiscr, ref nonnull, .. } => {\n-            let fields = compute_fields(cx, t, nndiscr as usize, false);\n-            match name {\n-                None => {\n-                    Type::struct_(cx, &struct_llfields(cx, &fields, nonnull),\n-                                  nonnull.packed)\n-                }\n-                Some(name) => {\n-                    Type::named_struct(cx, name)\n-                }\n-            }\n-        }\n-        layout::Univariant { ref variant, .. } => {\n-            // Note that this case also handles empty enums.\n-            // Thus the true as the final parameter here.\n-            let fields = compute_fields(cx, t, 0, true);\n-            match name {\n-                None => {\n-                    let fields = struct_llfields(cx, &fields, &variant);\n-                    Type::struct_(cx, &fields, variant.packed)\n-                }\n-                Some(name) => {\n-                    // Hypothesis: named_struct's can never need a\n-                    // drop flag. (... needs validation.)\n-                    Type::named_struct(cx, name)\n-                }\n-            }\n-        }\n-        layout::UntaggedUnion { ref variants, .. }=> {\n-            // Use alignment-sized ints to fill all the union storage.\n-            let size = variants.stride().bytes();\n-            let align = variants.align.abi();\n-            let fill = union_fill(cx, size, align);\n-            match name {\n-                None => {\n-                    Type::struct_(cx, &[fill], variants.packed)\n-                }\n-                Some(name) => {\n-                    let mut llty = Type::named_struct(cx, name);\n-                    llty.set_struct_body(&[fill], variants.packed);\n-                    llty\n-                }\n-            }\n-        }\n-        layout::General { discr, size, align, primitive_align, .. } => {\n-            // We need a representation that has:\n-            // * The alignment of the most-aligned field\n-            // * The size of the largest variant (rounded up to that alignment)\n-            // * No alignment padding anywhere any variant has actual data\n-            //   (currently matters only for enums small enough to be immediate)\n-            // * The discriminant in an obvious place.\n-            //\n-            // So we start with the discriminant, pad it up to the alignment with\n-            // more of its own type, then use alignment-sized ints to get the rest\n-            // of the size.\n-            let size = size.bytes();\n-            let align = align.abi();\n-            let primitive_align = primitive_align.abi();\n-            assert!(align <= std::u32::MAX as u64);\n-            let discr_ty = Type::from_integer(cx, discr);\n-            let discr_size = discr.size().bytes();\n-            let padded_discr_size = roundup(discr_size, align as u32);\n-            let variant_part_size = size-padded_discr_size;\n-            let variant_fill = union_fill(cx, variant_part_size, primitive_align);\n-\n-            assert_eq!(machine::llalign_of_min(cx, variant_fill), primitive_align as u32);\n-            assert_eq!(padded_discr_size % discr_size, 0); // Ensure discr_ty can fill pad evenly\n-            let fields: Vec<Type> =\n-                [discr_ty,\n-                 Type::array(&discr_ty, (padded_discr_size - discr_size)/discr_size),\n-                 variant_fill].iter().cloned().collect();\n-            match name {\n-                None => {\n-                    Type::struct_(cx, &fields, false)\n-                }\n-                Some(name) => {\n-                    let mut llty = Type::named_struct(cx, name);\n-                    llty.set_struct_body(&fields, false);\n-                    llty\n-                }\n-            }\n-        }\n-        _ => bug!(\"Unsupported type {} represented as {:#?}\", t, l)\n-    }\n-}\n-\n-fn union_fill(cx: &CrateContext, size: u64, align: u64) -> Type {\n-    assert_eq!(size%align, 0);\n-    assert_eq!(align.count_ones(), 1, \"Alignment must be a power fof 2. Got {}\", align);\n-    let align_units = size/align;\n-    let layout_align = layout::Align::from_bytes(align, align).unwrap();\n-    if let Some(ity) = layout::Integer::for_abi_align(cx, layout_align) {\n-        Type::array(&Type::from_integer(cx, ity), align_units)\n-    } else {\n-        Type::array(&Type::vector(&Type::i32(cx), align/4),\n-                    align_units)\n-    }\n-}\n-\n-\n-// Double index to account for padding (FieldPath already uses `Struct::memory_index`)\n-fn struct_llfields_path(discrfield: &layout::FieldPath) -> Vec<usize> {\n-    discrfield.iter().map(|&i| (i as usize) << 1).collect::<Vec<_>>()\n-}\n-\n-\n-// Lookup `Struct::memory_index` and double it to account for padding\n-pub fn struct_llfields_index(variant: &layout::Struct, index: usize) -> usize {\n-    (variant.memory_index[index] as usize) << 1\n-}\n-\n-\n-pub fn struct_llfields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, field_tys: &Vec<Ty<'tcx>>,\n-                             variant: &layout::Struct) -> Vec<Type> {\n-    debug!(\"struct_llfields: variant: {:?}\", variant);\n-    let mut first_field = true;\n-    let mut min_offset = 0;\n-    let mut result: Vec<Type> = Vec::with_capacity(field_tys.len() * 2);\n-    let field_iter = variant.field_index_by_increasing_offset().map(|i| {\n-        (i, field_tys[i as usize], variant.offsets[i as usize].bytes()) });\n-    for (index, ty, target_offset) in field_iter {\n-        if first_field {\n-            debug!(\"struct_llfields: {} ty: {} min_offset: {} target_offset: {}\",\n-                index, ty, min_offset, target_offset);\n-            first_field = false;\n-        } else {\n-            assert!(target_offset >= min_offset);\n-            let padding_bytes = if variant.packed { 0 } else { target_offset - min_offset };\n-            result.push(Type::array(&Type::i8(cx), padding_bytes));\n-            debug!(\"struct_llfields: {} ty: {} pad_bytes: {} min_offset: {} target_offset: {}\",\n-                index, ty, padding_bytes, min_offset, target_offset);\n-        }\n-        let llty = type_of::in_memory_type_of(cx, ty);\n-        result.push(llty);\n-        let layout = cx.layout_of(ty);\n-        let target_size = layout.size(&cx.tcx().data_layout).bytes();\n-        min_offset = target_offset + target_size;\n-    }\n-    if variant.sized && !field_tys.is_empty() {\n-        if variant.stride().bytes() < min_offset {\n-            bug!(\"variant: {:?} stride: {} min_offset: {}\", variant, variant.stride().bytes(),\n-            min_offset);\n-        }\n-        let padding_bytes = variant.stride().bytes() - min_offset;\n-        debug!(\"struct_llfields: pad_bytes: {} min_offset: {} min_size: {} stride: {}\\n\",\n-               padding_bytes, min_offset, variant.min_size.bytes(), variant.stride().bytes());\n-        result.push(Type::array(&Type::i8(cx), padding_bytes));\n-        assert!(result.len() == (field_tys.len() * 2));\n-    } else {\n-        debug!(\"struct_llfields: min_offset: {} min_size: {} stride: {}\\n\",\n-               min_offset, variant.min_size.bytes(), variant.stride().bytes());\n-    }\n-\n-    result\n-}\n-\n-pub fn is_discr_signed<'tcx>(l: &layout::Layout) -> bool {\n-    match *l {\n-        layout::CEnum { signed, .. }=> signed,\n-        _ => false,\n-    }\n-}\n-\n-/// Obtain the actual discriminant of a value.\n-pub fn trans_get_discr<'a, 'tcx>(\n-    bcx: &Builder<'a, 'tcx>,\n-    t: Ty<'tcx>,\n-    scrutinee: ValueRef,\n-    alignment: Alignment,\n-    cast_to: Option<Type>,\n-    range_assert: bool\n-) -> ValueRef {\n-    debug!(\"trans_get_discr t: {:?}\", t);\n-    let l = bcx.ccx.layout_of(t);\n-\n-    let val = match *l {\n-        layout::CEnum { discr, min, max, .. } => {\n-            load_discr(bcx, discr, scrutinee, alignment, min, max, range_assert)\n-        }\n-        layout::General { discr, ref variants, .. } => {\n-            let ptr = bcx.struct_gep(scrutinee, 0);\n-            load_discr(bcx, discr, ptr, alignment,\n-                       0, variants.len() as u64 - 1,\n-                       range_assert)\n-        }\n-        layout::Univariant { .. } | layout::UntaggedUnion { .. } => C_u8(bcx.ccx, 0),\n-        layout::RawNullablePointer { nndiscr, .. } => {\n-            let cmp = if nndiscr == 0 { IntEQ } else { IntNE };\n-            let discr = bcx.load(scrutinee, alignment.to_align());\n-            bcx.icmp(cmp, discr, C_null(val_ty(discr)))\n-        }\n-        layout::StructWrappedNullablePointer { nndiscr, ref discrfield, .. } => {\n-            struct_wrapped_nullable_bitdiscr(bcx, nndiscr, discrfield, scrutinee, alignment)\n-        },\n-        _ => bug!(\"{} is not an enum\", t)\n-    };\n-    match cast_to {\n-        None => val,\n-        Some(llty) => bcx.intcast(val, llty, is_discr_signed(&l))\n-    }\n-}\n-\n-fn struct_wrapped_nullable_bitdiscr(\n-    bcx: &Builder,\n-    nndiscr: u64,\n-    discrfield: &layout::FieldPath,\n-    scrutinee: ValueRef,\n-    alignment: Alignment,\n-) -> ValueRef {\n-    let path = struct_llfields_path(discrfield);\n-    let llptrptr = bcx.gepi(scrutinee, &path);\n-    let llptr = bcx.load(llptrptr, alignment.to_align());\n-    let cmp = if nndiscr == 0 { IntEQ } else { IntNE };\n-    bcx.icmp(cmp, llptr, C_null(val_ty(llptr)))\n-}\n-\n-/// Helper for cases where the discriminant is simply loaded.\n-fn load_discr(bcx: &Builder, ity: layout::Integer, ptr: ValueRef,\n-              alignment: Alignment, min: u64, max: u64,\n-              range_assert: bool)\n-    -> ValueRef {\n-    let llty = Type::from_integer(bcx.ccx, ity);\n-    assert_eq!(val_ty(ptr), llty.ptr_to());\n-    let bits = ity.size().bits();\n-    assert!(bits <= 64);\n-    let bits = bits as usize;\n-    let mask = !0u64 >> (64 - bits);\n-    // For a (max) discr of -1, max will be `-1 as usize`, which overflows.\n-    // However, that is fine here (it would still represent the full range),\n-    if max.wrapping_add(1) & mask == min & mask || !range_assert {\n-        // i.e., if the range is everything.  The lo==hi case would be\n-        // rejected by the LLVM verifier (it would mean either an\n-        // empty set, which is impossible, or the entire range of the\n-        // type, which is pointless).\n-        bcx.load(ptr, alignment.to_align())\n-    } else {\n-        // llvm::ConstantRange can deal with ranges that wrap around,\n-        // so an overflow on (max + 1) is fine.\n-        bcx.load_range_assert(ptr, min, max.wrapping_add(1), /* signed: */ True,\n-                              alignment.to_align())\n-    }\n-}\n-\n-/// Set the discriminant for a new value of the given case of the given\n-/// representation.\n-pub fn trans_set_discr<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, val: ValueRef, to: u64) {\n-    let l = bcx.ccx.layout_of(t);\n-    match *l {\n-        layout::CEnum{ discr, min, max, .. } => {\n-            assert_discr_in_range(min, max, to);\n-            bcx.store(C_int(Type::from_integer(bcx.ccx, discr), to as i64),\n-                  val, None);\n-        }\n-        layout::General{ discr, .. } => {\n-            bcx.store(C_int(Type::from_integer(bcx.ccx, discr), to as i64),\n-                  bcx.struct_gep(val, 0), None);\n-        }\n-        layout::Univariant { .. }\n-        | layout::UntaggedUnion { .. }\n-        | layout::Vector { .. } => {\n-            assert_eq!(to, 0);\n-        }\n-        layout::RawNullablePointer { nndiscr, .. } => {\n-            if to != nndiscr {\n-                let llptrty = val_ty(val).element_type();\n-                bcx.store(C_null(llptrty), val, None);\n-            }\n-        }\n-        layout::StructWrappedNullablePointer { nndiscr, ref discrfield, ref nonnull, .. } => {\n-            if to != nndiscr {\n-                if target_sets_discr_via_memset(bcx) {\n-                    // Issue #34427: As workaround for LLVM bug on\n-                    // ARM, use memset of 0 on whole struct rather\n-                    // than storing null to single target field.\n-                    let llptr = bcx.pointercast(val, Type::i8(bcx.ccx).ptr_to());\n-                    let fill_byte = C_u8(bcx.ccx, 0);\n-                    let size = C_usize(bcx.ccx, nonnull.stride().bytes());\n-                    let align = C_i32(bcx.ccx, nonnull.align.abi() as i32);\n-                    base::call_memset(bcx, llptr, fill_byte, size, align, false);\n-                } else {\n-                    let path = struct_llfields_path(discrfield);\n-                    let llptrptr = bcx.gepi(val, &path);\n-                    let llptrty = val_ty(llptrptr).element_type();\n-                    bcx.store(C_null(llptrty), llptrptr, None);\n-                }\n-            }\n-        }\n-        _ => bug!(\"Cannot handle {} represented as {:#?}\", t, l)\n-    }\n-}\n-\n-fn target_sets_discr_via_memset<'a, 'tcx>(bcx: &Builder<'a, 'tcx>) -> bool {\n-    bcx.sess().target.target.arch == \"arm\" || bcx.sess().target.target.arch == \"aarch64\"\n-}\n-\n-pub fn assert_discr_in_range<D: PartialOrd>(min: D, max: D, discr: D) {\n-    if min <= max {\n-        assert!(min <= discr && discr <= max)\n-    } else {\n-        assert!(min <= discr || discr <= max)\n-    }\n-}\n-\n-// FIXME this utility routine should be somewhere more general\n-#[inline]\n-fn roundup(x: u64, a: u32) -> u64 { let a = a as u64; ((x + (a - 1)) / a) * a }\n-\n-/// Extract a field of a constant value, as appropriate for its\n-/// representation.\n-///\n-/// (Not to be confused with `common::const_get_elt`, which operates on\n-/// raw LLVM-level structs and arrays.)\n-pub fn const_get_field<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>,\n-                       val: ValueRef,\n-                       ix: usize) -> ValueRef {\n-    let l = ccx.layout_of(t);\n-    match *l {\n-        layout::CEnum { .. } => bug!(\"element access in C-like enum const\"),\n-        layout::Univariant { ref variant, .. } => {\n-            const_struct_field(val, variant.memory_index[ix] as usize)\n-        }\n-        layout::Vector { .. } => const_struct_field(val, ix),\n-        layout::UntaggedUnion { .. } => const_struct_field(val, 0),\n-        _ => bug!(\"{} does not have fields.\", t)\n-    }\n-}\n-\n-/// Extract field of struct-like const, skipping our alignment padding.\n-fn const_struct_field(val: ValueRef, ix: usize) -> ValueRef {\n-    // Get the ix-th non-undef element of the struct.\n-    let mut real_ix = 0; // actual position in the struct\n-    let mut ix = ix; // logical index relative to real_ix\n-    let mut field;\n-    loop {\n-        loop {\n-            field = const_get_elt(val, &[real_ix]);\n-            if !is_undef(field) {\n-                break;\n-            }\n-            real_ix = real_ix + 1;\n-        }\n-        if ix == 0 {\n-            return field;\n-        }\n-        ix = ix - 1;\n-        real_ix = real_ix + 1;\n-    }\n-}"}, {"sha": "1959fd13ccb294d0fcbda5a667cd0cdcd084bceb", "filename": "src/librustc_trans/asm.rs", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fasm.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -11,16 +11,15 @@\n //! # Translation of inline assembly.\n \n use llvm::{self, ValueRef};\n-use base;\n use common::*;\n-use type_of;\n use type_::Type;\n+use type_of::LayoutLlvmExt;\n use builder::Builder;\n \n use rustc::hir;\n-use rustc::ty::Ty;\n \n-use mir::lvalue::Alignment;\n+use mir::lvalue::LvalueRef;\n+use mir::operand::OperandValue;\n \n use std::ffi::CString;\n use syntax::ast::AsmDialect;\n@@ -30,28 +29,23 @@ use libc::{c_uint, c_char};\n pub fn trans_inline_asm<'a, 'tcx>(\n     bcx: &Builder<'a, 'tcx>,\n     ia: &hir::InlineAsm,\n-    outputs: Vec<(ValueRef, Ty<'tcx>)>,\n+    outputs: Vec<LvalueRef<'tcx>>,\n     mut inputs: Vec<ValueRef>\n ) {\n     let mut ext_constraints = vec![];\n     let mut output_types = vec![];\n \n     // Prepare the output operands\n     let mut indirect_outputs = vec![];\n-    for (i, (out, &(val, ty))) in ia.outputs.iter().zip(&outputs).enumerate() {\n-        let val = if out.is_rw || out.is_indirect {\n-            Some(base::load_ty(bcx, val, Alignment::Packed, ty))\n-        } else {\n-            None\n-        };\n+    for (i, (out, lvalue)) in ia.outputs.iter().zip(&outputs).enumerate() {\n         if out.is_rw {\n-            inputs.push(val.unwrap());\n+            inputs.push(lvalue.load(bcx).immediate());\n             ext_constraints.push(i.to_string());\n         }\n         if out.is_indirect {\n-            indirect_outputs.push(val.unwrap());\n+            indirect_outputs.push(lvalue.load(bcx).immediate());\n         } else {\n-            output_types.push(type_of::type_of(bcx.ccx, ty));\n+            output_types.push(lvalue.layout.llvm_type(bcx.ccx));\n         }\n     }\n     if !indirect_outputs.is_empty() {\n@@ -106,9 +100,9 @@ pub fn trans_inline_asm<'a, 'tcx>(\n \n     // Again, based on how many outputs we have\n     let outputs = ia.outputs.iter().zip(&outputs).filter(|&(ref o, _)| !o.is_indirect);\n-    for (i, (_, &(val, _))) in outputs.enumerate() {\n-        let v = if num_outputs == 1 { r } else { bcx.extract_value(r, i) };\n-        bcx.store(v, val, None);\n+    for (i, (_, &lvalue)) in outputs.enumerate() {\n+        let v = if num_outputs == 1 { r } else { bcx.extract_value(r, i as u64) };\n+        OperandValue::Immediate(v).store(bcx, lvalue);\n     }\n \n     // Store mark in a metadata node so we can map LLVM errors"}, {"sha": "745aa0da82900d1681a7432a9afd6745c4ce5c0b", "filename": "src/librustc_trans/attributes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fattributes.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -116,7 +116,7 @@ pub fn from_fn_attrs(ccx: &CrateContext, attrs: &[ast::Attribute], llfn: ValueRe\n             naked(llfn, true);\n         } else if attr.check_name(\"allocator\") {\n             Attribute::NoAlias.apply_llfn(\n-                llvm::AttributePlace::ReturnValue(), llfn);\n+                llvm::AttributePlace::ReturnValue, llfn);\n         } else if attr.check_name(\"unwind\") {\n             unwind(llfn, true);\n         } else if attr.check_name(\"rustc_allocator_nounwind\") {"}, {"sha": "b7408681ed0c8a214e24237f94953dc28a4cd499", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 79, "deletions": 193, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -28,6 +28,7 @@ use super::ModuleSource;\n use super::ModuleTranslation;\n use super::ModuleKind;\n \n+use abi;\n use assert_module_sources;\n use back::link;\n use back::symbol_export;\n@@ -40,40 +41,35 @@ use rustc::middle::lang_items::StartFnLangItem;\n use rustc::middle::trans::{Linkage, Visibility, Stats};\n use rustc::middle::cstore::{EncodedMetadata, EncodedMetadataHashes};\n use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::layout::{self, Align, TyLayout, LayoutOf};\n use rustc::ty::maps::Providers;\n use rustc::dep_graph::{DepNode, DepKind, DepConstructor};\n use rustc::middle::cstore::{self, LinkMeta, LinkagePreference};\n use rustc::util::common::{time, print_time_passes_entry};\n use rustc::session::config::{self, NoDebugInfo};\n use rustc::session::Session;\n use rustc_incremental;\n-use abi;\n use allocator;\n use mir::lvalue::LvalueRef;\n use attributes;\n use builder::Builder;\n use callee;\n use common::{C_bool, C_bytes_in_context, C_i32, C_usize};\n use collector::{self, TransItemCollectionMode};\n-use common::{C_struct_in_context, C_u64, C_undef, C_array};\n-use common::CrateContext;\n-use common::{type_is_zero_size, val_ty};\n-use common;\n+use common::{self, C_struct_in_context, C_array, CrateContext, val_ty};\n use consts;\n use context::{self, LocalCrateContext, SharedCrateContext};\n use debuginfo;\n use declare;\n-use machine;\n use meth;\n use mir;\n-use monomorphize::{self, Instance};\n+use monomorphize::Instance;\n use partitioning::{self, PartitioningStrategy, CodegenUnit, CodegenUnitExt};\n use symbol_names_test;\n use time_graph;\n use trans_item::{TransItem, BaseTransItemExt, TransItemExt, DefPathBasedNames};\n use type_::Type;\n-use type_of;\n-use value::Value;\n+use type_of::LayoutLlvmExt;\n use rustc::util::nodemap::{NodeSet, FxHashMap, FxHashSet, DefIdSet};\n use CrateInfo;\n \n@@ -90,7 +86,7 @@ use syntax::attr;\n use rustc::hir;\n use syntax::ast;\n \n-use mir::lvalue::Alignment;\n+use mir::operand::OperandValue;\n \n pub use rustc_trans_utils::{find_exported_symbols, check_for_rustc_errors_attr};\n pub use rustc_trans_utils::trans_item::linkage_by_name;\n@@ -125,14 +121,6 @@ impl<'a, 'tcx> Drop for StatRecorder<'a, 'tcx> {\n     }\n }\n \n-pub fn get_meta(bcx: &Builder, fat_ptr: ValueRef) -> ValueRef {\n-    bcx.struct_gep(fat_ptr, abi::FAT_PTR_EXTRA)\n-}\n-\n-pub fn get_dataptr(bcx: &Builder, fat_ptr: ValueRef) -> ValueRef {\n-    bcx.struct_gep(fat_ptr, abi::FAT_PTR_ADDR)\n-}\n-\n pub fn bin_op_to_icmp_predicate(op: hir::BinOp_,\n                                 signed: bool)\n                                 -> llvm::IntPredicate {\n@@ -216,8 +204,10 @@ pub fn unsized_info<'ccx, 'tcx>(ccx: &CrateContext<'ccx, 'tcx>,\n             old_info.expect(\"unsized_info: missing old info for trait upcast\")\n         }\n         (_, &ty::TyDynamic(ref data, ..)) => {\n+            let vtable_ptr = ccx.layout_of(ccx.tcx().mk_mut_ptr(target))\n+                .field(ccx, abi::FAT_PTR_EXTRA);\n             consts::ptrcast(meth::get_vtable(ccx, source, data.principal()),\n-                            Type::vtable_ptr(ccx))\n+                            vtable_ptr.llvm_type(ccx))\n         }\n         _ => bug!(\"unsized_info: invalid unsizing {:?} -> {:?}\",\n                                      source,\n@@ -241,41 +231,67 @@ pub fn unsize_thin_ptr<'a, 'tcx>(\n         (&ty::TyRawPtr(ty::TypeAndMut { ty: a, .. }),\n          &ty::TyRawPtr(ty::TypeAndMut { ty: b, .. })) => {\n             assert!(bcx.ccx.shared().type_is_sized(a));\n-            let ptr_ty = type_of::in_memory_type_of(bcx.ccx, b).ptr_to();\n+            let ptr_ty = bcx.ccx.layout_of(b).llvm_type(bcx.ccx).ptr_to();\n             (bcx.pointercast(src, ptr_ty), unsized_info(bcx.ccx, a, b, None))\n         }\n         (&ty::TyAdt(def_a, _), &ty::TyAdt(def_b, _)) if def_a.is_box() && def_b.is_box() => {\n             let (a, b) = (src_ty.boxed_ty(), dst_ty.boxed_ty());\n             assert!(bcx.ccx.shared().type_is_sized(a));\n-            let ptr_ty = type_of::in_memory_type_of(bcx.ccx, b).ptr_to();\n+            let ptr_ty = bcx.ccx.layout_of(b).llvm_type(bcx.ccx).ptr_to();\n             (bcx.pointercast(src, ptr_ty), unsized_info(bcx.ccx, a, b, None))\n         }\n+        (&ty::TyAdt(def_a, _), &ty::TyAdt(def_b, _)) => {\n+            assert_eq!(def_a, def_b);\n+\n+            let src_layout = bcx.ccx.layout_of(src_ty);\n+            let dst_layout = bcx.ccx.layout_of(dst_ty);\n+            let mut result = None;\n+            for i in 0..src_layout.fields.count() {\n+                let src_f = src_layout.field(bcx.ccx, i);\n+                assert_eq!(src_layout.fields.offset(i).bytes(), 0);\n+                assert_eq!(dst_layout.fields.offset(i).bytes(), 0);\n+                if src_f.is_zst() {\n+                    continue;\n+                }\n+                assert_eq!(src_layout.size, src_f.size);\n+\n+                let dst_f = dst_layout.field(bcx.ccx, i);\n+                assert_ne!(src_f.ty, dst_f.ty);\n+                assert_eq!(result, None);\n+                result = Some(unsize_thin_ptr(bcx, src, src_f.ty, dst_f.ty));\n+            }\n+            let (lldata, llextra) = result.unwrap();\n+            // HACK(eddyb) have to bitcast pointers until LLVM removes pointee types.\n+            (bcx.bitcast(lldata, dst_layout.scalar_pair_element_llvm_type(bcx.ccx, 0)),\n+             bcx.bitcast(llextra, dst_layout.scalar_pair_element_llvm_type(bcx.ccx, 1)))\n+        }\n         _ => bug!(\"unsize_thin_ptr: called on bad types\"),\n     }\n }\n \n /// Coerce `src`, which is a reference to a value of type `src_ty`,\n /// to a value of type `dst_ty` and store the result in `dst`\n pub fn coerce_unsized_into<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n-                                     src: &LvalueRef<'tcx>,\n-                                     dst: &LvalueRef<'tcx>) {\n-    let src_ty = src.ty.to_ty(bcx.tcx());\n-    let dst_ty = dst.ty.to_ty(bcx.tcx());\n+                                     src: LvalueRef<'tcx>,\n+                                     dst: LvalueRef<'tcx>) {\n+    let src_ty = src.layout.ty;\n+    let dst_ty = dst.layout.ty;\n     let coerce_ptr = || {\n-        let (base, info) = if common::type_is_fat_ptr(bcx.ccx, src_ty) {\n-            // fat-ptr to fat-ptr unsize preserves the vtable\n-            // i.e. &'a fmt::Debug+Send => &'a fmt::Debug\n-            // So we need to pointercast the base to ensure\n-            // the types match up.\n-            let (base, info) = load_fat_ptr(bcx, src.llval, src.alignment, src_ty);\n-            let llcast_ty = type_of::fat_ptr_base_ty(bcx.ccx, dst_ty);\n-            let base = bcx.pointercast(base, llcast_ty);\n-            (base, info)\n-        } else {\n-            let base = load_ty(bcx, src.llval, src.alignment, src_ty);\n-            unsize_thin_ptr(bcx, base, src_ty, dst_ty)\n+        let (base, info) = match src.load(bcx).val {\n+            OperandValue::Pair(base, info) => {\n+                // fat-ptr to fat-ptr unsize preserves the vtable\n+                // i.e. &'a fmt::Debug+Send => &'a fmt::Debug\n+                // So we need to pointercast the base to ensure\n+                // the types match up.\n+                let thin_ptr = dst.layout.field(bcx.ccx, abi::FAT_PTR_ADDR);\n+                (bcx.pointercast(base, thin_ptr.llvm_type(bcx.ccx)), info)\n+            }\n+            OperandValue::Immediate(base) => {\n+                unsize_thin_ptr(bcx, base, src_ty, dst_ty)\n+            }\n+            OperandValue::Ref(..) => bug!()\n         };\n-        store_fat_ptr(bcx, base, info, dst.llval, dst.alignment, dst_ty);\n+        OperandValue::Pair(base, info).store(bcx, dst);\n     };\n     match (&src_ty.sty, &dst_ty.sty) {\n         (&ty::TyRef(..), &ty::TyRef(..)) |\n@@ -287,32 +303,22 @@ pub fn coerce_unsized_into<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             coerce_ptr()\n         }\n \n-        (&ty::TyAdt(def_a, substs_a), &ty::TyAdt(def_b, substs_b)) => {\n+        (&ty::TyAdt(def_a, _), &ty::TyAdt(def_b, _)) => {\n             assert_eq!(def_a, def_b);\n \n-            let src_fields = def_a.variants[0].fields.iter().map(|f| {\n-                monomorphize::field_ty(bcx.tcx(), substs_a, f)\n-            });\n-            let dst_fields = def_b.variants[0].fields.iter().map(|f| {\n-                monomorphize::field_ty(bcx.tcx(), substs_b, f)\n-            });\n+            for i in 0..def_a.variants[0].fields.len() {\n+                let src_f = src.project_field(bcx, i);\n+                let dst_f = dst.project_field(bcx, i);\n \n-            let iter = src_fields.zip(dst_fields).enumerate();\n-            for (i, (src_fty, dst_fty)) in iter {\n-                if type_is_zero_size(bcx.ccx, dst_fty) {\n+                if dst_f.layout.is_zst() {\n                     continue;\n                 }\n \n-                let (src_f, src_f_align) = src.trans_field_ptr(bcx, i);\n-                let (dst_f, dst_f_align) = dst.trans_field_ptr(bcx, i);\n-                if src_fty == dst_fty {\n-                    memcpy_ty(bcx, dst_f, src_f, src_fty, None);\n+                if src_f.layout.ty == dst_f.layout.ty {\n+                    memcpy_ty(bcx, dst_f.llval, src_f.llval, src_f.layout,\n+                        (src_f.alignment | dst_f.alignment).non_abi());\n                 } else {\n-                    coerce_unsized_into(\n-                        bcx,\n-                        &LvalueRef::new_sized_ty(src_f, src_fty, src_f_align),\n-                        &LvalueRef::new_sized_ty(dst_f, dst_fty, dst_f_align)\n-                    );\n+                    coerce_unsized_into(bcx, src_f, dst_f);\n                 }\n             }\n         }\n@@ -385,94 +391,6 @@ pub fn call_assume<'a, 'tcx>(b: &Builder<'a, 'tcx>, val: ValueRef) {\n     b.call(assume_intrinsic, &[val], None);\n }\n \n-/// Helper for loading values from memory. Does the necessary conversion if the in-memory type\n-/// differs from the type used for SSA values. Also handles various special cases where the type\n-/// gives us better information about what we are loading.\n-pub fn load_ty<'a, 'tcx>(b: &Builder<'a, 'tcx>, ptr: ValueRef,\n-                         alignment: Alignment, t: Ty<'tcx>) -> ValueRef {\n-    let ccx = b.ccx;\n-    if type_is_zero_size(ccx, t) {\n-        return C_undef(type_of::type_of(ccx, t));\n-    }\n-\n-    unsafe {\n-        let global = llvm::LLVMIsAGlobalVariable(ptr);\n-        if !global.is_null() && llvm::LLVMIsGlobalConstant(global) == llvm::True {\n-            let val = llvm::LLVMGetInitializer(global);\n-            if !val.is_null() {\n-                if t.is_bool() {\n-                    return llvm::LLVMConstTrunc(val, Type::i1(ccx).to_ref());\n-                }\n-                return val;\n-            }\n-        }\n-    }\n-\n-    if t.is_bool() {\n-        b.trunc(b.load_range_assert(ptr, 0, 2, llvm::False, alignment.to_align()),\n-                Type::i1(ccx))\n-    } else if t.is_char() {\n-        // a char is a Unicode codepoint, and so takes values from 0\n-        // to 0x10FFFF inclusive only.\n-        b.load_range_assert(ptr, 0, 0x10FFFF + 1, llvm::False, alignment.to_align())\n-    } else if (t.is_region_ptr() || t.is_box() || t.is_fn())\n-        && !common::type_is_fat_ptr(ccx, t)\n-    {\n-        b.load_nonnull(ptr, alignment.to_align())\n-    } else {\n-        b.load(ptr, alignment.to_align())\n-    }\n-}\n-\n-/// Helper for storing values in memory. Does the necessary conversion if the in-memory type\n-/// differs from the type used for SSA values.\n-pub fn store_ty<'a, 'tcx>(cx: &Builder<'a, 'tcx>, v: ValueRef, dst: ValueRef,\n-                          dst_align: Alignment, t: Ty<'tcx>) {\n-    debug!(\"store_ty: {:?} : {:?} <- {:?}\", Value(dst), t, Value(v));\n-\n-    if common::type_is_fat_ptr(cx.ccx, t) {\n-        let lladdr = cx.extract_value(v, abi::FAT_PTR_ADDR);\n-        let llextra = cx.extract_value(v, abi::FAT_PTR_EXTRA);\n-        store_fat_ptr(cx, lladdr, llextra, dst, dst_align, t);\n-    } else {\n-        cx.store(from_immediate(cx, v), dst, dst_align.to_align());\n-    }\n-}\n-\n-pub fn store_fat_ptr<'a, 'tcx>(cx: &Builder<'a, 'tcx>,\n-                               data: ValueRef,\n-                               extra: ValueRef,\n-                               dst: ValueRef,\n-                               dst_align: Alignment,\n-                               _ty: Ty<'tcx>) {\n-    // FIXME: emit metadata\n-    cx.store(data, get_dataptr(cx, dst), dst_align.to_align());\n-    cx.store(extra, get_meta(cx, dst), dst_align.to_align());\n-}\n-\n-pub fn load_fat_ptr<'a, 'tcx>(\n-    b: &Builder<'a, 'tcx>, src: ValueRef, alignment: Alignment, t: Ty<'tcx>\n-) -> (ValueRef, ValueRef) {\n-    let ptr = get_dataptr(b, src);\n-    let ptr = if t.is_region_ptr() || t.is_box() {\n-        b.load_nonnull(ptr, alignment.to_align())\n-    } else {\n-        b.load(ptr, alignment.to_align())\n-    };\n-\n-    let meta = get_meta(b, src);\n-    let meta_ty = val_ty(meta);\n-    // If the 'meta' field is a pointer, it's a vtable, so use load_nonnull\n-    // instead\n-    let meta = if meta_ty.element_type().kind() == llvm::TypeKind::Pointer {\n-        b.load_nonnull(meta, None)\n-    } else {\n-        b.load(meta, None)\n-    };\n-\n-    (ptr, meta)\n-}\n-\n pub fn from_immediate(bcx: &Builder, val: ValueRef) -> ValueRef {\n     if val_ty(val) == Type::i1(bcx.ccx) {\n         bcx.zext(val, Type::i8(bcx.ccx))\n@@ -481,58 +399,28 @@ pub fn from_immediate(bcx: &Builder, val: ValueRef) -> ValueRef {\n     }\n }\n \n-pub fn to_immediate(bcx: &Builder, val: ValueRef, ty: Ty) -> ValueRef {\n-    if ty.is_bool() {\n-        bcx.trunc(val, Type::i1(bcx.ccx))\n-    } else {\n-        val\n-    }\n-}\n-\n-pub enum Lifetime { Start, End }\n-\n-impl Lifetime {\n-    // If LLVM lifetime intrinsic support is enabled (i.e. optimizations\n-    // on), and `ptr` is nonzero-sized, then extracts the size of `ptr`\n-    // and the intrinsic for `lt` and passes them to `emit`, which is in\n-    // charge of generating code to call the passed intrinsic on whatever\n-    // block of generated code is targeted for the intrinsic.\n-    //\n-    // If LLVM lifetime intrinsic support is disabled (i.e.  optimizations\n-    // off) or `ptr` is zero-sized, then no-op (does not call `emit`).\n-    pub fn call(self, b: &Builder, ptr: ValueRef) {\n-        if b.ccx.sess().opts.optimize == config::OptLevel::No {\n-            return;\n+pub fn to_immediate(bcx: &Builder, val: ValueRef, layout: layout::TyLayout) -> ValueRef {\n+    if let layout::Abi::Scalar(ref scalar) = layout.abi {\n+        if scalar.is_bool() {\n+            return bcx.trunc(val, Type::i1(bcx.ccx));\n         }\n-\n-        let size = machine::llsize_of_alloc(b.ccx, val_ty(ptr).element_type());\n-        if size == 0 {\n-            return;\n-        }\n-\n-        let lifetime_intrinsic = b.ccx.get_intrinsic(match self {\n-            Lifetime::Start => \"llvm.lifetime.start\",\n-            Lifetime::End => \"llvm.lifetime.end\"\n-        });\n-\n-        let ptr = b.pointercast(ptr, Type::i8p(b.ccx));\n-        b.call(lifetime_intrinsic, &[C_u64(b.ccx, size), ptr], None);\n     }\n+    val\n }\n \n-pub fn call_memcpy<'a, 'tcx>(b: &Builder<'a, 'tcx>,\n-                               dst: ValueRef,\n-                               src: ValueRef,\n-                               n_bytes: ValueRef,\n-                               align: u32) {\n+pub fn call_memcpy(b: &Builder,\n+                   dst: ValueRef,\n+                   src: ValueRef,\n+                   n_bytes: ValueRef,\n+                   align: Align) {\n     let ccx = b.ccx;\n     let ptr_width = &ccx.sess().target.target.target_pointer_width;\n     let key = format!(\"llvm.memcpy.p0i8.p0i8.i{}\", ptr_width);\n     let memcpy = ccx.get_intrinsic(&key);\n     let src_ptr = b.pointercast(src, Type::i8p(ccx));\n     let dst_ptr = b.pointercast(dst, Type::i8p(ccx));\n     let size = b.intcast(n_bytes, ccx.isize_ty(), false);\n-    let align = C_i32(ccx, align as i32);\n+    let align = C_i32(ccx, align.abi() as i32);\n     let volatile = C_bool(ccx, false);\n     b.call(memcpy, &[dst_ptr, src_ptr, size, align, volatile], None);\n }\n@@ -541,18 +429,16 @@ pub fn memcpy_ty<'a, 'tcx>(\n     bcx: &Builder<'a, 'tcx>,\n     dst: ValueRef,\n     src: ValueRef,\n-    t: Ty<'tcx>,\n-    align: Option<u32>,\n+    layout: TyLayout<'tcx>,\n+    align: Option<Align>,\n ) {\n-    let ccx = bcx.ccx;\n-\n-    let size = ccx.size_of(t);\n+    let size = layout.size.bytes();\n     if size == 0 {\n         return;\n     }\n \n-    let align = align.unwrap_or_else(|| ccx.align_of(t));\n-    call_memcpy(bcx, dst, src, C_usize(ccx, size), align);\n+    let align = align.unwrap_or(layout.align);\n+    call_memcpy(bcx, dst, src, C_usize(bcx.ccx, size), align);\n }\n \n pub fn call_memset<'a, 'tcx>(b: &Builder<'a, 'tcx>,"}, {"sha": "50e673bdbfdd77a068b33bb00a2525b7a1c84821", "filename": "src/librustc_trans/builder.rs", "status": "modified", "additions": 70, "deletions": 62, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuilder.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -15,15 +15,16 @@ use llvm::{AtomicRmwBinOp, AtomicOrdering, SynchronizationScope, AsmDialect};\n use llvm::{Opcode, IntPredicate, RealPredicate, False, OperandBundleDef};\n use llvm::{ValueRef, BasicBlockRef, BuilderRef, ModuleRef};\n use common::*;\n-use machine::llalign_of_pref;\n use type_::Type;\n use value::Value;\n use libc::{c_uint, c_char};\n use rustc::ty::TyCtxt;\n-use rustc::session::Session;\n+use rustc::ty::layout::{Align, Size};\n+use rustc::session::{config, Session};\n \n use std::borrow::Cow;\n use std::ffi::CString;\n+use std::ops::Range;\n use std::ptr;\n use syntax_pos::Span;\n \n@@ -487,15 +488,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn alloca(&self, ty: Type, name: &str, align: Option<u32>) -> ValueRef {\n+    pub fn alloca(&self, ty: Type, name: &str, align: Align) -> ValueRef {\n         let builder = Builder::with_ccx(self.ccx);\n         builder.position_at_start(unsafe {\n             llvm::LLVMGetFirstBasicBlock(self.llfn())\n         });\n         builder.dynamic_alloca(ty, name, align)\n     }\n \n-    pub fn dynamic_alloca(&self, ty: Type, name: &str, align: Option<u32>) -> ValueRef {\n+    pub fn dynamic_alloca(&self, ty: Type, name: &str, align: Align) -> ValueRef {\n         self.count_insn(\"alloca\");\n         unsafe {\n             let alloca = if name.is_empty() {\n@@ -505,9 +506,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 llvm::LLVMBuildAlloca(self.llbuilder, ty.to_ref(),\n                                       name.as_ptr())\n             };\n-            if let Some(align) = align {\n-                llvm::LLVMSetAlignment(alloca, align as c_uint);\n-            }\n+            llvm::LLVMSetAlignment(alloca, align.abi() as c_uint);\n             alloca\n         }\n     }\n@@ -519,12 +518,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn load(&self, ptr: ValueRef, align: Option<u32>) -> ValueRef {\n+    pub fn load(&self, ptr: ValueRef, align: Option<Align>) -> ValueRef {\n         self.count_insn(\"load\");\n         unsafe {\n             let load = llvm::LLVMBuildLoad(self.llbuilder, ptr, noname());\n             if let Some(align) = align {\n-                llvm::LLVMSetAlignment(load, align as c_uint);\n+                llvm::LLVMSetAlignment(load, align.abi() as c_uint);\n             }\n             load\n         }\n@@ -539,57 +538,50 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn atomic_load(&self, ptr: ValueRef, order: AtomicOrdering) -> ValueRef {\n+    pub fn atomic_load(&self, ptr: ValueRef, order: AtomicOrdering, align: Align) -> ValueRef {\n         self.count_insn(\"load.atomic\");\n         unsafe {\n-            let ty = Type::from_ref(llvm::LLVMTypeOf(ptr));\n-            let align = llalign_of_pref(self.ccx, ty.element_type());\n-            llvm::LLVMRustBuildAtomicLoad(self.llbuilder, ptr, noname(), order,\n-                                          align as c_uint)\n+            let load = llvm::LLVMRustBuildAtomicLoad(self.llbuilder, ptr, noname(), order);\n+            // FIXME(eddyb) Isn't it UB to use `pref` instead of `abi` here?\n+            // However, 64-bit atomic loads on `i686-apple-darwin` appear to\n+            // require `___atomic_load` with ABI-alignment, so it's staying.\n+            llvm::LLVMSetAlignment(load, align.pref() as c_uint);\n+            load\n         }\n     }\n \n \n-    pub fn load_range_assert(&self, ptr: ValueRef, lo: u64,\n-                             hi: u64, signed: llvm::Bool,\n-                             align: Option<u32>) -> ValueRef {\n-        let value = self.load(ptr, align);\n-\n+    pub fn range_metadata(&self, load: ValueRef, range: Range<u128>) {\n         unsafe {\n-            let t = llvm::LLVMGetElementType(llvm::LLVMTypeOf(ptr));\n-            let min = llvm::LLVMConstInt(t, lo, signed);\n-            let max = llvm::LLVMConstInt(t, hi, signed);\n-\n-            let v = [min, max];\n+            let llty = val_ty(load);\n+            let v = [\n+                C_uint_big(llty, range.start),\n+                C_uint_big(llty, range.end)\n+            ];\n \n-            llvm::LLVMSetMetadata(value, llvm::MD_range as c_uint,\n+            llvm::LLVMSetMetadata(load, llvm::MD_range as c_uint,\n                                   llvm::LLVMMDNodeInContext(self.ccx.llcx(),\n                                                             v.as_ptr(),\n                                                             v.len() as c_uint));\n         }\n-\n-        value\n     }\n \n-    pub fn load_nonnull(&self, ptr: ValueRef, align: Option<u32>) -> ValueRef {\n-        let value = self.load(ptr, align);\n+    pub fn nonnull_metadata(&self, load: ValueRef) {\n         unsafe {\n-            llvm::LLVMSetMetadata(value, llvm::MD_nonnull as c_uint,\n+            llvm::LLVMSetMetadata(load, llvm::MD_nonnull as c_uint,\n                                   llvm::LLVMMDNodeInContext(self.ccx.llcx(), ptr::null(), 0));\n         }\n-\n-        value\n     }\n \n-    pub fn store(&self, val: ValueRef, ptr: ValueRef, align: Option<u32>) -> ValueRef {\n+    pub fn store(&self, val: ValueRef, ptr: ValueRef, align: Option<Align>) -> ValueRef {\n         debug!(\"Store {:?} -> {:?}\", Value(val), Value(ptr));\n         assert!(!self.llbuilder.is_null());\n         self.count_insn(\"store\");\n         let ptr = self.check_store(val, ptr);\n         unsafe {\n             let store = llvm::LLVMBuildStore(self.llbuilder, val, ptr);\n             if let Some(align) = align {\n-                llvm::LLVMSetAlignment(store, align as c_uint);\n+                llvm::LLVMSetAlignment(store, align.abi() as c_uint);\n             }\n             store\n         }\n@@ -607,14 +599,16 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn atomic_store(&self, val: ValueRef, ptr: ValueRef, order: AtomicOrdering) {\n+    pub fn atomic_store(&self, val: ValueRef, ptr: ValueRef,\n+                        order: AtomicOrdering, align: Align) {\n         debug!(\"Store {:?} -> {:?}\", Value(val), Value(ptr));\n         self.count_insn(\"store.atomic\");\n         let ptr = self.check_store(val, ptr);\n         unsafe {\n-            let ty = Type::from_ref(llvm::LLVMTypeOf(ptr));\n-            let align = llalign_of_pref(self.ccx, ty.element_type());\n-            llvm::LLVMRustBuildAtomicStore(self.llbuilder, val, ptr, order, align as c_uint);\n+            let store = llvm::LLVMRustBuildAtomicStore(self.llbuilder, val, ptr, order);\n+            // FIXME(eddyb) Isn't it UB to use `pref` instead of `abi` here?\n+            // Also see `atomic_load` for more context.\n+            llvm::LLVMSetAlignment(store, align.pref() as c_uint);\n         }\n     }\n \n@@ -626,25 +620,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    // Simple wrapper around GEP that takes an array of ints and wraps them\n-    // in C_i32()\n-    #[inline]\n-    pub fn gepi(&self, base: ValueRef, ixs: &[usize]) -> ValueRef {\n-        // Small vector optimization. This should catch 100% of the cases that\n-        // we care about.\n-        if ixs.len() < 16 {\n-            let mut small_vec = [ C_i32(self.ccx, 0); 16 ];\n-            for (small_vec_e, &ix) in small_vec.iter_mut().zip(ixs) {\n-                *small_vec_e = C_i32(self.ccx, ix as i32);\n-            }\n-            self.inbounds_gep(base, &small_vec[..ixs.len()])\n-        } else {\n-            let v = ixs.iter().map(|i| C_i32(self.ccx, *i as i32)).collect::<Vec<ValueRef>>();\n-            self.count_insn(\"gepi\");\n-            self.inbounds_gep(base, &v)\n-        }\n-    }\n-\n     pub fn inbounds_gep(&self, ptr: ValueRef, indices: &[ValueRef]) -> ValueRef {\n         self.count_insn(\"inboundsgep\");\n         unsafe {\n@@ -653,8 +628,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn struct_gep(&self, ptr: ValueRef, idx: usize) -> ValueRef {\n+    pub fn struct_gep(&self, ptr: ValueRef, idx: u64) -> ValueRef {\n         self.count_insn(\"structgep\");\n+        assert_eq!(idx as c_uint as u64, idx);\n         unsafe {\n             llvm::LLVMBuildStructGEP(self.llbuilder, ptr, idx as c_uint, noname())\n         }\n@@ -960,16 +936,18 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn extract_value(&self, agg_val: ValueRef, idx: usize) -> ValueRef {\n+    pub fn extract_value(&self, agg_val: ValueRef, idx: u64) -> ValueRef {\n         self.count_insn(\"extractvalue\");\n+        assert_eq!(idx as c_uint as u64, idx);\n         unsafe {\n             llvm::LLVMBuildExtractValue(self.llbuilder, agg_val, idx as c_uint, noname())\n         }\n     }\n \n     pub fn insert_value(&self, agg_val: ValueRef, elt: ValueRef,\n-                       idx: usize) -> ValueRef {\n+                       idx: u64) -> ValueRef {\n         self.count_insn(\"insertvalue\");\n+        assert_eq!(idx as c_uint as u64, idx);\n         unsafe {\n             llvm::LLVMBuildInsertValue(self.llbuilder, agg_val, elt, idx as c_uint,\n                                        noname())\n@@ -1151,14 +1129,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n     pub fn add_case(&self, s: ValueRef, on_val: ValueRef, dest: BasicBlockRef) {\n         unsafe {\n-            if llvm::LLVMIsUndef(s) == llvm::True { return; }\n             llvm::LLVMAddCase(s, on_val, dest)\n         }\n     }\n \n     pub fn add_incoming_to_phi(&self, phi: ValueRef, val: ValueRef, bb: BasicBlockRef) {\n         unsafe {\n-            if llvm::LLVMIsUndef(phi) == llvm::True { return; }\n             llvm::LLVMAddIncoming(phi, &val, &bb, 1 as c_uint);\n         }\n     }\n@@ -1233,4 +1209,36 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         return Cow::Owned(casted_args);\n     }\n+\n+    pub fn lifetime_start(&self, ptr: ValueRef, size: Size) {\n+        self.call_lifetime_intrinsic(\"llvm.lifetime.start\", ptr, size);\n+    }\n+\n+    pub fn lifetime_end(&self, ptr: ValueRef, size: Size) {\n+        self.call_lifetime_intrinsic(\"llvm.lifetime.end\", ptr, size);\n+    }\n+\n+    /// If LLVM lifetime intrinsic support is enabled (i.e. optimizations\n+    /// on), and `ptr` is nonzero-sized, then extracts the size of `ptr`\n+    /// and the intrinsic for `lt` and passes them to `emit`, which is in\n+    /// charge of generating code to call the passed intrinsic on whatever\n+    /// block of generated code is targetted for the intrinsic.\n+    ///\n+    /// If LLVM lifetime intrinsic support is disabled (i.e.  optimizations\n+    /// off) or `ptr` is zero-sized, then no-op (does not call `emit`).\n+    fn call_lifetime_intrinsic(&self, intrinsic: &str, ptr: ValueRef, size: Size) {\n+        if self.ccx.sess().opts.optimize == config::OptLevel::No {\n+            return;\n+        }\n+\n+        let size = size.bytes();\n+        if size == 0 {\n+            return;\n+        }\n+\n+        let lifetime_intrinsic = self.ccx.get_intrinsic(intrinsic);\n+\n+        let ptr = self.pointercast(ptr, Type::i8p(self.ccx));\n+        self.call(lifetime_intrinsic, &[C_u64(self.ccx, size), ptr], None);\n+    }\n }"}, {"sha": "d5f341f9685833dd987b2e0b1d94afed5b8ba875", "filename": "src/librustc_trans/cabi_aarch64.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fcabi_aarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fcabi_aarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_aarch64.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -14,7 +14,7 @@ use context::CrateContext;\n fn is_homogeneous_aggregate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>)\n                                      -> Option<Uniform> {\n     arg.layout.homogeneous_aggregate(ccx).and_then(|unit| {\n-        let size = arg.layout.size(ccx);\n+        let size = arg.layout.size;\n \n         // Ensure we have at most four uniquely addressable members.\n         if size > unit.size.checked_mul(4, ccx).unwrap() {\n@@ -44,10 +44,10 @@ fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tc\n         return;\n     }\n     if let Some(uniform) = is_homogeneous_aggregate(ccx, ret) {\n-        ret.cast_to(ccx, uniform);\n+        ret.cast_to(uniform);\n         return;\n     }\n-    let size = ret.layout.size(ccx);\n+    let size = ret.layout.size;\n     let bits = size.bits();\n     if bits <= 128 {\n         let unit = if bits <= 8 {\n@@ -60,13 +60,13 @@ fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tc\n             Reg::i64()\n         };\n \n-        ret.cast_to(ccx, Uniform {\n+        ret.cast_to(Uniform {\n             unit,\n             total: size\n         });\n         return;\n     }\n-    ret.make_indirect(ccx);\n+    ret.make_indirect();\n }\n \n fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>) {\n@@ -75,10 +75,10 @@ fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tc\n         return;\n     }\n     if let Some(uniform) = is_homogeneous_aggregate(ccx, arg) {\n-        arg.cast_to(ccx, uniform);\n+        arg.cast_to(uniform);\n         return;\n     }\n-    let size = arg.layout.size(ccx);\n+    let size = arg.layout.size;\n     let bits = size.bits();\n     if bits <= 128 {\n         let unit = if bits <= 8 {\n@@ -91,13 +91,13 @@ fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tc\n             Reg::i64()\n         };\n \n-        arg.cast_to(ccx, Uniform {\n+        arg.cast_to(Uniform {\n             unit,\n             total: size\n         });\n         return;\n     }\n-    arg.make_indirect(ccx);\n+    arg.make_indirect();\n }\n \n pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {"}, {"sha": "438053d63b51d37bd638ad3c699464cc5b17ef17", "filename": "src/librustc_trans/cabi_arm.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_arm.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -15,7 +15,7 @@ use llvm::CallConv;\n fn is_homogeneous_aggregate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>)\n                                      -> Option<Uniform> {\n     arg.layout.homogeneous_aggregate(ccx).and_then(|unit| {\n-        let size = arg.layout.size(ccx);\n+        let size = arg.layout.size;\n \n         // Ensure we have at most four uniquely addressable members.\n         if size > unit.size.checked_mul(4, ccx).unwrap() {\n@@ -47,12 +47,12 @@ fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tc\n \n     if vfp {\n         if let Some(uniform) = is_homogeneous_aggregate(ccx, ret) {\n-            ret.cast_to(ccx, uniform);\n+            ret.cast_to(uniform);\n             return;\n         }\n     }\n \n-    let size = ret.layout.size(ccx);\n+    let size = ret.layout.size;\n     let bits = size.bits();\n     if bits <= 32 {\n         let unit = if bits <= 8 {\n@@ -62,13 +62,13 @@ fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tc\n         } else {\n             Reg::i32()\n         };\n-        ret.cast_to(ccx, Uniform {\n+        ret.cast_to(Uniform {\n             unit,\n             total: size\n         });\n         return;\n     }\n-    ret.make_indirect(ccx);\n+    ret.make_indirect();\n }\n \n fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>, vfp: bool) {\n@@ -79,14 +79,14 @@ fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tc\n \n     if vfp {\n         if let Some(uniform) = is_homogeneous_aggregate(ccx, arg) {\n-            arg.cast_to(ccx, uniform);\n+            arg.cast_to(uniform);\n             return;\n         }\n     }\n \n-    let align = arg.layout.align(ccx).abi();\n-    let total = arg.layout.size(ccx);\n-    arg.cast_to(ccx, Uniform {\n+    let align = arg.layout.align.abi();\n+    let total = arg.layout.size;\n+    arg.cast_to(Uniform {\n         unit: if align <= 4 { Reg::i32() } else { Reg::i64() },\n         total\n     });"}, {"sha": "1664251cf897b0edd10b84bc6787814714dc695c", "filename": "src/librustc_trans/cabi_asmjs.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fcabi_asmjs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fcabi_asmjs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_asmjs.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use abi::{FnType, ArgType, ArgAttribute, LayoutExt, Uniform};\n+use abi::{FnType, ArgType, LayoutExt, Uniform};\n use context::CrateContext;\n \n // Data layout: e-p:32:32-i64:64-v128:32:128-n32-S128\n@@ -19,24 +19,23 @@ use context::CrateContext;\n fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n     if ret.layout.is_aggregate() {\n         if let Some(unit) = ret.layout.homogeneous_aggregate(ccx) {\n-            let size = ret.layout.size(ccx);\n+            let size = ret.layout.size;\n             if unit.size == size {\n-                ret.cast_to(ccx, Uniform {\n+                ret.cast_to(Uniform {\n                     unit,\n                     total: size\n                 });\n                 return;\n             }\n         }\n \n-        ret.make_indirect(ccx);\n+        ret.make_indirect();\n     }\n }\n \n-fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>) {\n+fn classify_arg_ty(arg: &mut ArgType) {\n     if arg.layout.is_aggregate() {\n-        arg.make_indirect(ccx);\n-        arg.attrs.set(ArgAttribute::ByVal);\n+        arg.make_indirect_byval();\n     }\n }\n \n@@ -47,6 +46,6 @@ pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType\n \n     for arg in &mut fty.args {\n         if arg.is_ignore() { continue; }\n-        classify_arg_ty(ccx, arg);\n+        classify_arg_ty(arg);\n     }\n }"}, {"sha": "7e7e483fea0c0cd340cdddf514a0303c6b61e6ec", "filename": "src/librustc_trans/cabi_hexagon.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fcabi_hexagon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fcabi_hexagon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_hexagon.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -11,33 +11,32 @@\n #![allow(non_upper_case_globals)]\n \n use abi::{FnType, ArgType, LayoutExt};\n-use context::CrateContext;\n \n-fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n-    if ret.layout.is_aggregate() && ret.layout.size(ccx).bits() > 64 {\n-        ret.make_indirect(ccx);\n+fn classify_ret_ty(ret: &mut ArgType) {\n+    if ret.layout.is_aggregate() && ret.layout.size.bits() > 64 {\n+        ret.make_indirect();\n     } else {\n         ret.extend_integer_width_to(32);\n     }\n }\n \n-fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>) {\n-    if arg.layout.is_aggregate() && arg.layout.size(ccx).bits() > 64 {\n-        arg.make_indirect(ccx);\n+fn classify_arg_ty(arg: &mut ArgType) {\n+    if arg.layout.is_aggregate() && arg.layout.size.bits() > 64 {\n+        arg.make_indirect();\n     } else {\n         arg.extend_integer_width_to(32);\n     }\n }\n \n-pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+pub fn compute_abi_info(fty: &mut FnType) {\n     if !fty.ret.is_ignore() {\n-        classify_ret_ty(ccx, &mut fty.ret);\n+        classify_ret_ty(&mut fty.ret);\n     }\n \n     for arg in &mut fty.args {\n         if arg.is_ignore() {\n             continue;\n         }\n-        classify_arg_ty(ccx, arg);\n+        classify_arg_ty(arg);\n     }\n }"}, {"sha": "fe61670a1086f93157f8f8c02ee6e835f37bfbc0", "filename": "src/librustc_trans/cabi_mips.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_mips.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -8,45 +8,48 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::cmp;\n-use abi::{align_up_to, ArgType, FnType, LayoutExt, Reg, Uniform};\n+use abi::{ArgType, FnType, LayoutExt, Reg, Uniform};\n use context::CrateContext;\n \n-fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n+use rustc::ty::layout::Size;\n+\n+fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                             ret: &mut ArgType<'tcx>,\n+                             offset: &mut Size) {\n     if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(32);\n     } else {\n-        ret.make_indirect(ccx);\n+        ret.make_indirect();\n+        *offset += ccx.tcx().data_layout.pointer_size;\n     }\n }\n \n-fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut u64) {\n-    let size = arg.layout.size(ccx);\n-    let mut align = arg.layout.align(ccx).abi();\n-    align = cmp::min(cmp::max(align, 4), 8);\n+fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut Size) {\n+    let dl = &ccx.tcx().data_layout;\n+    let size = arg.layout.size;\n+    let align = arg.layout.align.max(dl.i32_align).min(dl.i64_align);\n \n     if arg.layout.is_aggregate() {\n-        arg.cast_to(ccx, Uniform {\n+        arg.cast_to(Uniform {\n             unit: Reg::i32(),\n             total: size\n         });\n-        if ((align - 1) & *offset) > 0 {\n-            arg.pad_with(ccx, Reg::i32());\n+        if !offset.is_abi_aligned(align) {\n+            arg.pad_with(Reg::i32());\n         }\n     } else {\n         arg.extend_integer_width_to(32);\n     }\n \n-    *offset = align_up_to(*offset, align);\n-    *offset += align_up_to(size.bytes(), align);\n+    *offset = offset.abi_align(align) + size.abi_align(align);\n }\n \n pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+    let mut offset = Size::from_bytes(0);\n     if !fty.ret.is_ignore() {\n-        classify_ret_ty(ccx, &mut fty.ret);\n+        classify_ret_ty(ccx, &mut fty.ret, &mut offset);\n     }\n \n-    let mut offset = if fty.ret.is_indirect() { 4 } else { 0 };\n     for arg in &mut fty.args {\n         if arg.is_ignore() { continue; }\n         classify_arg_ty(ccx, arg, &mut offset);"}, {"sha": "16d0cfe072d5772d2070df703fbc7ff6dad219fe", "filename": "src/librustc_trans/cabi_mips64.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fcabi_mips64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fcabi_mips64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_mips64.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -8,45 +8,48 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::cmp;\n-use abi::{align_up_to, ArgType, FnType, LayoutExt, Reg, Uniform};\n+use abi::{ArgType, FnType, LayoutExt, Reg, Uniform};\n use context::CrateContext;\n \n-fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n+use rustc::ty::layout::Size;\n+\n+fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                             ret: &mut ArgType<'tcx>,\n+                             offset: &mut Size) {\n     if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(64);\n     } else {\n-        ret.make_indirect(ccx);\n+        ret.make_indirect();\n+        *offset += ccx.tcx().data_layout.pointer_size;\n     }\n }\n \n-fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut u64) {\n-    let size = arg.layout.size(ccx);\n-    let mut align = arg.layout.align(ccx).abi();\n-    align = cmp::min(cmp::max(align, 4), 8);\n+fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut Size) {\n+    let dl = &ccx.tcx().data_layout;\n+    let size = arg.layout.size;\n+    let align = arg.layout.align.max(dl.i32_align).min(dl.i64_align);\n \n     if arg.layout.is_aggregate() {\n-        arg.cast_to(ccx, Uniform {\n+        arg.cast_to(Uniform {\n             unit: Reg::i64(),\n             total: size\n         });\n-        if ((align - 1) & *offset) > 0 {\n-            arg.pad_with(ccx, Reg::i64());\n+        if !offset.is_abi_aligned(align) {\n+            arg.pad_with(Reg::i64());\n         }\n     } else {\n         arg.extend_integer_width_to(64);\n     }\n \n-    *offset = align_up_to(*offset, align);\n-    *offset += align_up_to(size.bytes(), align);\n+    *offset = offset.abi_align(align) + size.abi_align(align);\n }\n \n pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+    let mut offset = Size::from_bytes(0);\n     if !fty.ret.is_ignore() {\n-        classify_ret_ty(ccx, &mut fty.ret);\n+        classify_ret_ty(ccx, &mut fty.ret, &mut offset);\n     }\n \n-    let mut offset = if fty.ret.is_indirect() { 8 } else { 0 };\n     for arg in &mut fty.args {\n         if arg.is_ignore() { continue; }\n         classify_arg_ty(ccx, arg, &mut offset);"}, {"sha": "d270886a19cd11c835da1cccde7230d153ed6f3f", "filename": "src/librustc_trans/cabi_msp430.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fcabi_msp430.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fcabi_msp430.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_msp430.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -12,39 +12,38 @@\n // http://www.ti.com/lit/an/slaa534/slaa534.pdf\n \n use abi::{ArgType, FnType, LayoutExt};\n-use context::CrateContext;\n \n // 3.5 Structures or Unions Passed and Returned by Reference\n //\n // \"Structures (including classes) and unions larger than 32 bits are passed and\n // returned by reference. To pass a structure or union by reference, the caller\n // places its address in the appropriate location: either in a register or on\n // the stack, according to its position in the argument list. (..)\"\n-fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n-    if ret.layout.is_aggregate() && ret.layout.size(ccx).bits() > 32 {\n-        ret.make_indirect(ccx);\n+fn classify_ret_ty(ret: &mut ArgType) {\n+    if ret.layout.is_aggregate() && ret.layout.size.bits() > 32 {\n+        ret.make_indirect();\n     } else {\n         ret.extend_integer_width_to(16);\n     }\n }\n \n-fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>) {\n-    if arg.layout.is_aggregate() && arg.layout.size(ccx).bits() > 32 {\n-        arg.make_indirect(ccx);\n+fn classify_arg_ty(arg: &mut ArgType) {\n+    if arg.layout.is_aggregate() && arg.layout.size.bits() > 32 {\n+        arg.make_indirect();\n     } else {\n         arg.extend_integer_width_to(16);\n     }\n }\n \n-pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+pub fn compute_abi_info(fty: &mut FnType) {\n     if !fty.ret.is_ignore() {\n-        classify_ret_ty(ccx, &mut fty.ret);\n+        classify_ret_ty(&mut fty.ret);\n     }\n \n     for arg in &mut fty.args {\n         if arg.is_ignore() {\n             continue;\n         }\n-        classify_arg_ty(ccx, arg);\n+        classify_arg_ty(arg);\n     }\n }"}, {"sha": "69cfc690a9f9d311888547718118789a8868b391", "filename": "src/librustc_trans/cabi_nvptx.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fcabi_nvptx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fcabi_nvptx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_nvptx.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -12,33 +12,32 @@\n // http://docs.nvidia.com/cuda/ptx-writers-guide-to-interoperability\n \n use abi::{ArgType, FnType, LayoutExt};\n-use context::CrateContext;\n \n-fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n-    if ret.layout.is_aggregate() && ret.layout.size(ccx).bits() > 32 {\n-        ret.make_indirect(ccx);\n+fn classify_ret_ty(ret: &mut ArgType) {\n+    if ret.layout.is_aggregate() && ret.layout.size.bits() > 32 {\n+        ret.make_indirect();\n     } else {\n         ret.extend_integer_width_to(32);\n     }\n }\n \n-fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>) {\n-    if arg.layout.is_aggregate() && arg.layout.size(ccx).bits() > 32 {\n-        arg.make_indirect(ccx);\n+fn classify_arg_ty(arg: &mut ArgType) {\n+    if arg.layout.is_aggregate() && arg.layout.size.bits() > 32 {\n+        arg.make_indirect();\n     } else {\n         arg.extend_integer_width_to(32);\n     }\n }\n \n-pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+pub fn compute_abi_info(fty: &mut FnType) {\n     if !fty.ret.is_ignore() {\n-        classify_ret_ty(ccx, &mut fty.ret);\n+        classify_ret_ty(&mut fty.ret);\n     }\n \n     for arg in &mut fty.args {\n         if arg.is_ignore() {\n             continue;\n         }\n-        classify_arg_ty(ccx, arg);\n+        classify_arg_ty(arg);\n     }\n }"}, {"sha": "4d76c156038001569228bc8ca9770de4b65dc62d", "filename": "src/librustc_trans/cabi_nvptx64.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fcabi_nvptx64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fcabi_nvptx64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_nvptx64.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -12,33 +12,32 @@\n // http://docs.nvidia.com/cuda/ptx-writers-guide-to-interoperability\n \n use abi::{ArgType, FnType, LayoutExt};\n-use context::CrateContext;\n \n-fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n-    if ret.layout.is_aggregate() && ret.layout.size(ccx).bits() > 64 {\n-        ret.make_indirect(ccx);\n+fn classify_ret_ty(ret: &mut ArgType) {\n+    if ret.layout.is_aggregate() && ret.layout.size.bits() > 64 {\n+        ret.make_indirect();\n     } else {\n         ret.extend_integer_width_to(64);\n     }\n }\n \n-fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>) {\n-    if arg.layout.is_aggregate() && arg.layout.size(ccx).bits() > 64 {\n-        arg.make_indirect(ccx);\n+fn classify_arg_ty(arg: &mut ArgType) {\n+    if arg.layout.is_aggregate() && arg.layout.size.bits() > 64 {\n+        arg.make_indirect();\n     } else {\n         arg.extend_integer_width_to(64);\n     }\n }\n \n-pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+pub fn compute_abi_info(fty: &mut FnType) {\n     if !fty.ret.is_ignore() {\n-        classify_ret_ty(ccx, &mut fty.ret);\n+        classify_ret_ty(&mut fty.ret);\n     }\n \n     for arg in &mut fty.args {\n         if arg.is_ignore() {\n             continue;\n         }\n-        classify_arg_ty(ccx, arg);\n+        classify_arg_ty(arg);\n     }\n }"}, {"sha": "c3c8c745e3a61c175b96b2abc8cc2511b6c872fe", "filename": "src/librustc_trans/cabi_powerpc.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fcabi_powerpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fcabi_powerpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_powerpc.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -8,46 +8,48 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use abi::{align_up_to, FnType, ArgType, LayoutExt, Reg, Uniform};\n+use abi::{ArgType, FnType, LayoutExt, Reg, Uniform};\n use context::CrateContext;\n \n-use std::cmp;\n+use rustc::ty::layout::Size;\n \n-fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n+fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                             ret: &mut ArgType<'tcx>,\n+                             offset: &mut Size) {\n     if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(32);\n     } else {\n-        ret.make_indirect(ccx);\n+        ret.make_indirect();\n+        *offset += ccx.tcx().data_layout.pointer_size;\n     }\n }\n \n-fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut u64) {\n-    let size = arg.layout.size(ccx);\n-    let mut align = arg.layout.align(ccx).abi();\n-    align = cmp::min(cmp::max(align, 4), 8);\n+fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut Size) {\n+    let dl = &ccx.tcx().data_layout;\n+    let size = arg.layout.size;\n+    let align = arg.layout.align.max(dl.i32_align).min(dl.i64_align);\n \n     if arg.layout.is_aggregate() {\n-        arg.cast_to(ccx, Uniform {\n+        arg.cast_to(Uniform {\n             unit: Reg::i32(),\n             total: size\n         });\n-        if ((align - 1) & *offset) > 0 {\n-            arg.pad_with(ccx, Reg::i32());\n+        if !offset.is_abi_aligned(align) {\n+            arg.pad_with(Reg::i32());\n         }\n     } else {\n         arg.extend_integer_width_to(32);\n     }\n \n-    *offset = align_up_to(*offset, align);\n-    *offset += align_up_to(size.bytes(), align);\n+    *offset = offset.abi_align(align) + size.abi_align(align);\n }\n \n pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+    let mut offset = Size::from_bytes(0);\n     if !fty.ret.is_ignore() {\n-        classify_ret_ty(ccx, &mut fty.ret);\n+        classify_ret_ty(ccx, &mut fty.ret, &mut offset);\n     }\n \n-    let mut offset = if fty.ret.is_indirect() { 4 } else { 0 };\n     for arg in &mut fty.args {\n         if arg.is_ignore() { continue; }\n         classify_arg_ty(ccx, arg, &mut offset);"}, {"sha": "2206a4fa00cc3af1ff41b49af4c9b142199604d5", "filename": "src/librustc_trans/cabi_powerpc64.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fcabi_powerpc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fcabi_powerpc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_powerpc64.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -28,25 +28,23 @@ fn is_homogeneous_aggregate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                       abi: ABI)\n                                      -> Option<Uniform> {\n     arg.layout.homogeneous_aggregate(ccx).and_then(|unit| {\n-        let size = arg.layout.size(ccx);\n-\n         // ELFv1 only passes one-member aggregates transparently.\n         // ELFv2 passes up to eight uniquely addressable members.\n-        if (abi == ELFv1 && size > unit.size)\n-                || size > unit.size.checked_mul(8, ccx).unwrap() {\n+        if (abi == ELFv1 && arg.layout.size > unit.size)\n+                || arg.layout.size > unit.size.checked_mul(8, ccx).unwrap() {\n             return None;\n         }\n \n         let valid_unit = match unit.kind {\n             RegKind::Integer => false,\n             RegKind::Float => true,\n-            RegKind::Vector => size.bits() == 128\n+            RegKind::Vector => arg.layout.size.bits() == 128\n         };\n \n         if valid_unit {\n             Some(Uniform {\n                 unit,\n-                total: size\n+                total: arg.layout.size\n             })\n         } else {\n             None\n@@ -62,16 +60,16 @@ fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tc\n \n     // The ELFv1 ABI doesn't return aggregates in registers\n     if abi == ELFv1 {\n-        ret.make_indirect(ccx);\n+        ret.make_indirect();\n         return;\n     }\n \n     if let Some(uniform) = is_homogeneous_aggregate(ccx, ret, abi) {\n-        ret.cast_to(ccx, uniform);\n+        ret.cast_to(uniform);\n         return;\n     }\n \n-    let size = ret.layout.size(ccx);\n+    let size = ret.layout.size;\n     let bits = size.bits();\n     if bits <= 128 {\n         let unit = if bits <= 8 {\n@@ -84,14 +82,14 @@ fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tc\n             Reg::i64()\n         };\n \n-        ret.cast_to(ccx, Uniform {\n+        ret.cast_to(Uniform {\n             unit,\n             total: size\n         });\n         return;\n     }\n \n-    ret.make_indirect(ccx);\n+    ret.make_indirect();\n }\n \n fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>, abi: ABI) {\n@@ -101,11 +99,11 @@ fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tc\n     }\n \n     if let Some(uniform) = is_homogeneous_aggregate(ccx, arg, abi) {\n-        arg.cast_to(ccx, uniform);\n+        arg.cast_to(uniform);\n         return;\n     }\n \n-    let size = arg.layout.size(ccx);\n+    let size = arg.layout.size;\n     let (unit, total) = match abi {\n         ELFv1 => {\n             // In ELFv1, aggregates smaller than a doubleword should appear in\n@@ -124,7 +122,7 @@ fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tc\n         },\n     };\n \n-    arg.cast_to(ccx, Uniform {\n+    arg.cast_to(Uniform {\n         unit,\n         total\n     });"}, {"sha": "9fb460043ae81d55490f25a3edae5f0054f57d65", "filename": "src/librustc_trans/cabi_s390x.rs", "status": "modified", "additions": 25, "deletions": 22, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fcabi_s390x.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fcabi_s390x.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_s390x.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -14,23 +14,27 @@\n use abi::{FnType, ArgType, LayoutExt, Reg};\n use context::CrateContext;\n \n-use rustc::ty::layout::{self, Layout, TyLayout};\n+use rustc::ty::layout::{self, TyLayout};\n \n-fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n-    if !ret.layout.is_aggregate() && ret.layout.size(ccx).bits() <= 64 {\n+fn classify_ret_ty(ret: &mut ArgType) {\n+    if !ret.layout.is_aggregate() && ret.layout.size.bits() <= 64 {\n         ret.extend_integer_width_to(64);\n     } else {\n-        ret.make_indirect(ccx);\n+        ret.make_indirect();\n     }\n }\n \n fn is_single_fp_element<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                   layout: TyLayout<'tcx>) -> bool {\n-    match *layout {\n-        Layout::Scalar { value: layout::F32, .. } |\n-        Layout::Scalar { value: layout::F64, .. } => true,\n-        Layout::Univariant { .. } => {\n-            if layout.field_count() == 1 {\n+    match layout.abi {\n+        layout::Abi::Scalar(ref scalar) => {\n+            match scalar.value {\n+                layout::F32 | layout::F64 => true,\n+                _ => false\n+            }\n+        }\n+        layout::Abi::Aggregate { .. } => {\n+            if layout.fields.count() == 1 && layout.fields.offset(0).bytes() == 0 {\n                 is_single_fp_element(ccx, layout.field(ccx, 0))\n             } else {\n                 false\n@@ -41,32 +45,31 @@ fn is_single_fp_element<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n }\n \n fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>) {\n-    let size = arg.layout.size(ccx);\n-    if !arg.layout.is_aggregate() && size.bits() <= 64 {\n+    if !arg.layout.is_aggregate() && arg.layout.size.bits() <= 64 {\n         arg.extend_integer_width_to(64);\n         return;\n     }\n \n     if is_single_fp_element(ccx, arg.layout) {\n-        match size.bytes() {\n-            4 => arg.cast_to(ccx, Reg::f32()),\n-            8 => arg.cast_to(ccx, Reg::f64()),\n-            _ => arg.make_indirect(ccx)\n+        match arg.layout.size.bytes() {\n+            4 => arg.cast_to(Reg::f32()),\n+            8 => arg.cast_to(Reg::f64()),\n+            _ => arg.make_indirect()\n         }\n     } else {\n-        match size.bytes() {\n-            1 => arg.cast_to(ccx, Reg::i8()),\n-            2 => arg.cast_to(ccx, Reg::i16()),\n-            4 => arg.cast_to(ccx, Reg::i32()),\n-            8 => arg.cast_to(ccx, Reg::i64()),\n-            _ => arg.make_indirect(ccx)\n+        match arg.layout.size.bytes() {\n+            1 => arg.cast_to(Reg::i8()),\n+            2 => arg.cast_to(Reg::i16()),\n+            4 => arg.cast_to(Reg::i32()),\n+            8 => arg.cast_to(Reg::i64()),\n+            _ => arg.make_indirect()\n         }\n     }\n }\n \n pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n     if !fty.ret.is_ignore() {\n-        classify_ret_ty(ccx, &mut fty.ret);\n+        classify_ret_ty(&mut fty.ret);\n     }\n \n     for arg in &mut fty.args {"}, {"sha": "fe61670a1086f93157f8f8c02ee6e835f37bfbc0", "filename": "src/librustc_trans/cabi_sparc.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fcabi_sparc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fcabi_sparc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_sparc.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -8,45 +8,48 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::cmp;\n-use abi::{align_up_to, ArgType, FnType, LayoutExt, Reg, Uniform};\n+use abi::{ArgType, FnType, LayoutExt, Reg, Uniform};\n use context::CrateContext;\n \n-fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n+use rustc::ty::layout::Size;\n+\n+fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                             ret: &mut ArgType<'tcx>,\n+                             offset: &mut Size) {\n     if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(32);\n     } else {\n-        ret.make_indirect(ccx);\n+        ret.make_indirect();\n+        *offset += ccx.tcx().data_layout.pointer_size;\n     }\n }\n \n-fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut u64) {\n-    let size = arg.layout.size(ccx);\n-    let mut align = arg.layout.align(ccx).abi();\n-    align = cmp::min(cmp::max(align, 4), 8);\n+fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut Size) {\n+    let dl = &ccx.tcx().data_layout;\n+    let size = arg.layout.size;\n+    let align = arg.layout.align.max(dl.i32_align).min(dl.i64_align);\n \n     if arg.layout.is_aggregate() {\n-        arg.cast_to(ccx, Uniform {\n+        arg.cast_to(Uniform {\n             unit: Reg::i32(),\n             total: size\n         });\n-        if ((align - 1) & *offset) > 0 {\n-            arg.pad_with(ccx, Reg::i32());\n+        if !offset.is_abi_aligned(align) {\n+            arg.pad_with(Reg::i32());\n         }\n     } else {\n-        arg.extend_integer_width_to(32)\n+        arg.extend_integer_width_to(32);\n     }\n \n-    *offset = align_up_to(*offset, align);\n-    *offset += align_up_to(size.bytes(), align);\n+    *offset = offset.abi_align(align) + size.abi_align(align);\n }\n \n pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+    let mut offset = Size::from_bytes(0);\n     if !fty.ret.is_ignore() {\n-        classify_ret_ty(ccx, &mut fty.ret);\n+        classify_ret_ty(ccx, &mut fty.ret, &mut offset);\n     }\n \n-    let mut offset = if fty.ret.is_indirect() { 4 } else { 0 };\n     for arg in &mut fty.args {\n         if arg.is_ignore() { continue; }\n         classify_arg_ty(ccx, arg, &mut offset);"}, {"sha": "7c52e27fa67d1b2d2310e07f0090008ac0c82f61", "filename": "src/librustc_trans/cabi_sparc64.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fcabi_sparc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fcabi_sparc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_sparc64.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -16,23 +16,21 @@ use context::CrateContext;\n fn is_homogeneous_aggregate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>)\n                                      -> Option<Uniform> {\n     arg.layout.homogeneous_aggregate(ccx).and_then(|unit| {\n-        let size = arg.layout.size(ccx);\n-\n         // Ensure we have at most eight uniquely addressable members.\n-        if size > unit.size.checked_mul(8, ccx).unwrap() {\n+        if arg.layout.size > unit.size.checked_mul(8, ccx).unwrap() {\n             return None;\n         }\n \n         let valid_unit = match unit.kind {\n             RegKind::Integer => false,\n             RegKind::Float => true,\n-            RegKind::Vector => size.bits() == 128\n+            RegKind::Vector => arg.layout.size.bits() == 128\n         };\n \n         if valid_unit {\n             Some(Uniform {\n                 unit,\n-                total: size\n+                total: arg.layout.size\n             })\n         } else {\n             None\n@@ -47,10 +45,10 @@ fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tc\n     }\n \n     if let Some(uniform) = is_homogeneous_aggregate(ccx, ret) {\n-        ret.cast_to(ccx, uniform);\n+        ret.cast_to(uniform);\n         return;\n     }\n-    let size = ret.layout.size(ccx);\n+    let size = ret.layout.size;\n     let bits = size.bits();\n     if bits <= 128 {\n         let unit = if bits <= 8 {\n@@ -63,15 +61,15 @@ fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tc\n             Reg::i64()\n         };\n \n-        ret.cast_to(ccx, Uniform {\n+        ret.cast_to(Uniform {\n             unit,\n             total: size\n         });\n         return;\n     }\n \n     // don't return aggregates in registers\n-    ret.make_indirect(ccx);\n+    ret.make_indirect();\n }\n \n fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>) {\n@@ -81,12 +79,12 @@ fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tc\n     }\n \n     if let Some(uniform) = is_homogeneous_aggregate(ccx, arg) {\n-        arg.cast_to(ccx, uniform);\n+        arg.cast_to(uniform);\n         return;\n     }\n \n-    let total = arg.layout.size(ccx);\n-    arg.cast_to(ccx, Uniform {\n+    let total = arg.layout.size;\n+    arg.cast_to(Uniform {\n         unit: Reg::i64(),\n         total\n     });"}, {"sha": "6fd0140c39901d7ce6ee4f7df3c0cb530e17a7d9", "filename": "src/librustc_trans/cabi_x86.rs", "status": "modified", "additions": 36, "deletions": 28, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fcabi_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fcabi_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use abi::{ArgAttribute, FnType, LayoutExt, Reg, RegKind};\n+use abi::{ArgAttribute, FnType, LayoutExt, PassMode, Reg, RegKind};\n use common::CrateContext;\n \n-use rustc::ty::layout::{self, Layout, TyLayout};\n+use rustc::ty::layout::{self, TyLayout};\n \n #[derive(PartialEq)]\n pub enum Flavor {\n@@ -21,11 +21,15 @@ pub enum Flavor {\n \n fn is_single_fp_element<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                   layout: TyLayout<'tcx>) -> bool {\n-    match *layout {\n-        Layout::Scalar { value: layout::F32, .. } |\n-        Layout::Scalar { value: layout::F64, .. } => true,\n-        Layout::Univariant { .. } => {\n-            if layout.field_count() == 1 {\n+    match layout.abi {\n+        layout::Abi::Scalar(ref scalar) => {\n+            match scalar.value {\n+                layout::F32 | layout::F64 => true,\n+                _ => false\n+            }\n+        }\n+        layout::Abi::Aggregate { .. } => {\n+            if layout.fields.count() == 1 && layout.fields.offset(0).bytes() == 0 {\n                 is_single_fp_element(ccx, layout.field(ccx, 0))\n             } else {\n                 false\n@@ -50,27 +54,25 @@ pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             let t = &ccx.sess().target.target;\n             if t.options.is_like_osx || t.options.is_like_windows\n                 || t.options.is_like_openbsd {\n-                let size = fty.ret.layout.size(ccx);\n-\n                 // According to Clang, everyone but MSVC returns single-element\n                 // float aggregates directly in a floating-point register.\n                 if !t.options.is_like_msvc && is_single_fp_element(ccx, fty.ret.layout) {\n-                    match size.bytes() {\n-                        4 => fty.ret.cast_to(ccx, Reg::f32()),\n-                        8 => fty.ret.cast_to(ccx, Reg::f64()),\n-                        _ => fty.ret.make_indirect(ccx)\n+                    match fty.ret.layout.size.bytes() {\n+                        4 => fty.ret.cast_to(Reg::f32()),\n+                        8 => fty.ret.cast_to(Reg::f64()),\n+                        _ => fty.ret.make_indirect()\n                     }\n                 } else {\n-                    match size.bytes() {\n-                        1 => fty.ret.cast_to(ccx, Reg::i8()),\n-                        2 => fty.ret.cast_to(ccx, Reg::i16()),\n-                        4 => fty.ret.cast_to(ccx, Reg::i32()),\n-                        8 => fty.ret.cast_to(ccx, Reg::i64()),\n-                        _ => fty.ret.make_indirect(ccx)\n+                    match fty.ret.layout.size.bytes() {\n+                        1 => fty.ret.cast_to(Reg::i8()),\n+                        2 => fty.ret.cast_to(Reg::i16()),\n+                        4 => fty.ret.cast_to(Reg::i32()),\n+                        8 => fty.ret.cast_to(Reg::i64()),\n+                        _ => fty.ret.make_indirect()\n                     }\n                 }\n             } else {\n-                fty.ret.make_indirect(ccx);\n+                fty.ret.make_indirect();\n             }\n         } else {\n             fty.ret.extend_integer_width_to(32);\n@@ -80,8 +82,7 @@ pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     for arg in &mut fty.args {\n         if arg.is_ignore() { continue; }\n         if arg.layout.is_aggregate() {\n-            arg.make_indirect(ccx);\n-            arg.attrs.set(ArgAttribute::ByVal);\n+            arg.make_indirect_byval();\n         } else {\n             arg.extend_integer_width_to(32);\n         }\n@@ -100,17 +101,24 @@ pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         let mut free_regs = 2;\n \n         for arg in &mut fty.args {\n-            if arg.is_ignore() || arg.is_indirect() { continue; }\n+            let attrs = match arg.mode {\n+                PassMode::Ignore |\n+                PassMode::Indirect(_) => continue,\n+                PassMode::Direct(ref mut attrs) => attrs,\n+                PassMode::Pair(..) |\n+                PassMode::Cast(_) => {\n+                    bug!(\"x86 shouldn't be passing arguments by {:?}\", arg.mode)\n+                }\n+            };\n \n             // At this point we know this must be a primitive of sorts.\n             let unit = arg.layout.homogeneous_aggregate(ccx).unwrap();\n-            let size = arg.layout.size(ccx);\n-            assert_eq!(unit.size, size);\n+            assert_eq!(unit.size, arg.layout.size);\n             if unit.kind == RegKind::Float {\n                 continue;\n             }\n \n-            let size_in_regs = (size.bits() + 31) / 32;\n+            let size_in_regs = (arg.layout.size.bits() + 31) / 32;\n \n             if size_in_regs == 0 {\n                 continue;\n@@ -122,8 +130,8 @@ pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n             free_regs -= size_in_regs;\n \n-            if size.bits() <= 32 && unit.kind == RegKind::Integer {\n-                arg.attrs.set(ArgAttribute::InReg);\n+            if arg.layout.size.bits() <= 32 && unit.kind == RegKind::Integer {\n+                attrs.set(ArgAttribute::InReg);\n             }\n \n             if free_regs == 0 {"}, {"sha": "81eb362ca46dc776281e3a7d62cd763dd12d2bd3", "filename": "src/librustc_trans/cabi_x86_64.rs", "status": "modified", "additions": 40, "deletions": 55, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86_64.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -11,10 +11,10 @@\n // The classification code for the x86_64 ABI is taken from the clay language\n // https://github.com/jckarter/clay/blob/master/compiler/src/externals.cpp\n \n-use abi::{ArgType, ArgAttribute, CastTarget, FnType, LayoutExt, Reg, RegKind};\n+use abi::{ArgType, CastTarget, FnType, LayoutExt, Reg, RegKind};\n use context::CrateContext;\n \n-use rustc::ty::layout::{self, Layout, TyLayout, Size};\n+use rustc::ty::layout::{self, TyLayout, Size};\n \n #[derive(Clone, Copy, PartialEq, Debug)]\n enum Class {\n@@ -34,9 +34,9 @@ const MAX_EIGHTBYTES: usize = LARGEST_VECTOR_SIZE / 64;\n fn classify_arg<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &ArgType<'tcx>)\n                           -> Result<[Class; MAX_EIGHTBYTES], Memory> {\n     fn unify(cls: &mut [Class],\n-             off: u64,\n+             off: Size,\n              c: Class) {\n-        let i = (off / 8) as usize;\n+        let i = (off.bytes() / 8) as usize;\n         let to_write = match (cls[i], c) {\n             (Class::None, _) => c,\n             (_, Class::None) => return,\n@@ -55,80 +55,65 @@ fn classify_arg<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &ArgType<'tcx>)\n     fn classify<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                           layout: TyLayout<'tcx>,\n                           cls: &mut [Class],\n-                          off: u64)\n+                          off: Size)\n                           -> Result<(), Memory> {\n-        if off % layout.align(ccx).abi() != 0 {\n-            if layout.size(ccx).bytes() > 0 {\n+        if !off.is_abi_aligned(layout.align) {\n+            if !layout.is_zst() {\n                 return Err(Memory);\n             }\n             return Ok(());\n         }\n \n-        match *layout {\n-            Layout::Scalar { value, .. } |\n-            Layout::RawNullablePointer { value, .. } => {\n-                let reg = match value {\n-                    layout::Int(_) |\n+        match layout.abi {\n+            layout::Abi::Uninhabited => {}\n+\n+            layout::Abi::Scalar(ref scalar) => {\n+                let reg = match scalar.value {\n+                    layout::Int(..) |\n                     layout::Pointer => Class::Int,\n                     layout::F32 |\n                     layout::F64 => Class::Sse\n                 };\n                 unify(cls, off, reg);\n             }\n \n-            Layout::CEnum { .. } => {\n-                unify(cls, off, Class::Int);\n-            }\n-\n-            Layout::Vector { element, count } => {\n+            layout::Abi::Vector => {\n                 unify(cls, off, Class::Sse);\n \n                 // everything after the first one is the upper\n                 // half of a register.\n-                let eltsz = element.size(ccx).bytes();\n-                for i in 1..count {\n-                    unify(cls, off + i * eltsz, Class::SseUp);\n+                for i in 1..layout.fields.count() {\n+                    let field_off = off + layout.fields.offset(i);\n+                    unify(cls, field_off, Class::SseUp);\n                 }\n             }\n \n-            Layout::Array { count, .. } => {\n-                if count > 0 {\n-                    let elt = layout.field(ccx, 0);\n-                    let eltsz = elt.size(ccx).bytes();\n-                    for i in 0..count {\n-                        classify(ccx, elt, cls, off + i * eltsz)?;\n+            layout::Abi::ScalarPair(..) |\n+            layout::Abi::Aggregate { .. } => {\n+                match layout.variants {\n+                    layout::Variants::Single { .. } => {\n+                        for i in 0..layout.fields.count() {\n+                            let field_off = off + layout.fields.offset(i);\n+                            classify(ccx, layout.field(ccx, i), cls, field_off)?;\n+                        }\n                     }\n+                    layout::Variants::Tagged { .. } |\n+                    layout::Variants::NicheFilling { .. } => return Err(Memory),\n                 }\n             }\n \n-            Layout::Univariant { ref variant, .. } => {\n-                for i in 0..layout.field_count() {\n-                    let field_off = off + variant.offsets[i].bytes();\n-                    classify(ccx, layout.field(ccx, i), cls, field_off)?;\n-                }\n-            }\n-\n-            Layout::UntaggedUnion { .. } => {\n-                for i in 0..layout.field_count() {\n-                    classify(ccx, layout.field(ccx, i), cls, off)?;\n-                }\n-            }\n-\n-            Layout::FatPointer { .. } |\n-            Layout::General { .. } |\n-            Layout::StructWrappedNullablePointer { .. } => return Err(Memory)\n         }\n \n         Ok(())\n     }\n \n-    let n = ((arg.layout.size(ccx).bytes() + 7) / 8) as usize;\n+    let n = ((arg.layout.size.bytes() + 7) / 8) as usize;\n     if n > MAX_EIGHTBYTES {\n         return Err(Memory);\n     }\n \n     let mut cls = [Class::None; MAX_EIGHTBYTES];\n-    classify(ccx, arg.layout, &mut cls, 0)?;\n+    classify(ccx, arg.layout, &mut cls, Size::from_bytes(0))?;\n     if n > 2 {\n         if cls[0] != Class::Sse {\n             return Err(Memory);\n@@ -153,7 +138,7 @@ fn classify_arg<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &ArgType<'tcx>)\n     Ok(cls)\n }\n \n-fn reg_component(cls: &[Class], i: &mut usize, size: u64) -> Option<Reg> {\n+fn reg_component(cls: &[Class], i: &mut usize, size: Size) -> Option<Reg> {\n     if *i >= cls.len() {\n         return None;\n     }\n@@ -162,7 +147,7 @@ fn reg_component(cls: &[Class], i: &mut usize, size: u64) -> Option<Reg> {\n         Class::None => None,\n         Class::Int => {\n             *i += 1;\n-            Some(match size {\n+            Some(match size.bytes() {\n                 1 => Reg::i8(),\n                 2 => Reg::i16(),\n                 3 |\n@@ -174,32 +159,32 @@ fn reg_component(cls: &[Class], i: &mut usize, size: u64) -> Option<Reg> {\n             let vec_len = 1 + cls[*i+1..].iter().take_while(|&&c| c == Class::SseUp).count();\n             *i += vec_len;\n             Some(if vec_len == 1 {\n-                match size {\n+                match size.bytes() {\n                     4 => Reg::f32(),\n                     _ => Reg::f64()\n                 }\n             } else {\n                 Reg {\n                     kind: RegKind::Vector,\n-                    size: Size::from_bytes(vec_len as u64 * 8)\n+                    size: Size::from_bytes(8) * (vec_len as u64)\n                 }\n             })\n         }\n         c => bug!(\"reg_component: unhandled class {:?}\", c)\n     }\n }\n \n-fn cast_target(cls: &[Class], size: u64) -> CastTarget {\n+fn cast_target(cls: &[Class], size: Size) -> CastTarget {\n     let mut i = 0;\n     let lo = reg_component(cls, &mut i, size).unwrap();\n-    let offset = i as u64 * 8;\n+    let offset = Size::from_bytes(8) * (i as u64);\n     let target = if size <= offset {\n         CastTarget::from(lo)\n     } else {\n         let hi = reg_component(cls, &mut i, size - offset).unwrap();\n         CastTarget::Pair(lo, hi)\n     };\n-    assert_eq!(reg_component(cls, &mut i, 0), None);\n+    assert_eq!(reg_component(cls, &mut i, Size::from_bytes(0)), None);\n     target\n }\n \n@@ -229,11 +214,11 @@ pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType\n         };\n \n         if in_mem {\n-            arg.make_indirect(ccx);\n             if is_arg {\n-                arg.attrs.set(ArgAttribute::ByVal);\n+                arg.make_indirect_byval();\n             } else {\n                 // `sret` parameter thus one less integer register available\n+                arg.make_indirect();\n                 int_regs -= 1;\n             }\n         } else {\n@@ -242,8 +227,8 @@ pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType\n             sse_regs -= needed_sse;\n \n             if arg.layout.is_aggregate() {\n-                let size = arg.layout.size(ccx).bytes();\n-                arg.cast_to(ccx, cast_target(cls.as_ref().unwrap(), size))\n+                let size = arg.layout.size;\n+                arg.cast_to(cast_target(cls.as_ref().unwrap(), size))\n             } else {\n                 arg.extend_integer_width_to(32);\n             }"}, {"sha": "473c00120a740c6b2d3e3e4068a975f36c373ce1", "filename": "src/librustc_trans/cabi_x86_win64.rs", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fcabi_x86_win64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fcabi_x86_win64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86_win64.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -8,32 +8,36 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use abi::{ArgType, FnType, LayoutExt, Reg};\n-use common::CrateContext;\n+use abi::{ArgType, FnType, Reg};\n \n-use rustc::ty::layout::Layout;\n+use rustc::ty::layout;\n \n // Win64 ABI: http://msdn.microsoft.com/en-us/library/zthk2dkh.aspx\n \n-pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n-    let fixup = |a: &mut ArgType<'tcx>| {\n-        let size = a.layout.size(ccx);\n-        if a.layout.is_aggregate() {\n-            match size.bits() {\n-                8 => a.cast_to(ccx, Reg::i8()),\n-                16 => a.cast_to(ccx, Reg::i16()),\n-                32 => a.cast_to(ccx, Reg::i32()),\n-                64 => a.cast_to(ccx, Reg::i64()),\n-                _ => a.make_indirect(ccx)\n-            };\n-        } else {\n-            if let Layout::Vector { .. } = *a.layout {\n+pub fn compute_abi_info(fty: &mut FnType) {\n+    let fixup = |a: &mut ArgType| {\n+        match a.layout.abi {\n+            layout::Abi::Uninhabited => {}\n+            layout::Abi::ScalarPair(..) |\n+            layout::Abi::Aggregate { .. } => {\n+                match a.layout.size.bits() {\n+                    8 => a.cast_to(Reg::i8()),\n+                    16 => a.cast_to(Reg::i16()),\n+                    32 => a.cast_to(Reg::i32()),\n+                    64 => a.cast_to(Reg::i64()),\n+                    _ => a.make_indirect()\n+                }\n+            }\n+            layout::Abi::Vector => {\n                 // FIXME(eddyb) there should be a size cap here\n                 // (probably what clang calls \"illegal vectors\").\n-            } else if size.bytes() > 8 {\n-                a.make_indirect(ccx);\n-            } else {\n-                a.extend_integer_width_to(32);\n+            }\n+            layout::Abi::Scalar(_) => {\n+                if a.layout.size.bytes() > 8 {\n+                    a.make_indirect();\n+                } else {\n+                    a.extend_integer_width_to(32);\n+                }\n             }\n         }\n     };"}, {"sha": "4afeac2e8f5895380d6c20c7ed22e824a242fc28", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -20,12 +20,14 @@ use consts;\n use declare;\n use llvm::{self, ValueRef};\n use monomorphize::Instance;\n+use type_of::LayoutLlvmExt;\n+\n use rustc::hir::def_id::DefId;\n use rustc::ty::{self, TypeFoldable};\n+use rustc::ty::layout::LayoutOf;\n use rustc::traits;\n use rustc::ty::subst::Substs;\n use rustc_back::PanicStrategy;\n-use type_of;\n \n /// Translates a reference to a fn/method item, monomorphizing and\n /// inlining as it goes.\n@@ -56,7 +58,7 @@ pub fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     // Create a fn pointer with the substituted signature.\n     let fn_ptr_ty = tcx.mk_fn_ptr(common::ty_fn_sig(ccx, fn_ty));\n-    let llptrty = type_of::type_of(ccx, fn_ptr_ty);\n+    let llptrty = ccx.layout_of(fn_ptr_ty).llvm_type(ccx);\n \n     let llfn = if let Some(llfn) = declare::get_declared_value(ccx, &sym) {\n         // This is subtle and surprising, but sometimes we have to bitcast"}, {"sha": "7bd8a0c81ee3438d6c3eac4b9c30e315709a8bef", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 20, "deletions": 135, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -18,17 +18,17 @@ use llvm::{True, False, Bool, OperandBundleDef};\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::DefPathData;\n use rustc::middle::lang_items::LangItem;\n+use abi;\n use base;\n use builder::Builder;\n use consts;\n use declare;\n-use machine;\n-use monomorphize;\n use type_::Type;\n+use type_of::LayoutLlvmExt;\n use value::Value;\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::layout::{Layout, LayoutTyper};\n+use rustc::ty::layout::{HasDataLayout, LayoutOf};\n use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::hir;\n \n@@ -41,105 +41,6 @@ use syntax_pos::{Span, DUMMY_SP};\n \n pub use context::{CrateContext, SharedCrateContext};\n \n-pub fn type_is_fat_ptr<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n-    if let Layout::FatPointer { .. } = *ccx.layout_of(ty) {\n-        true\n-    } else {\n-        false\n-    }\n-}\n-\n-pub fn type_is_immediate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n-    let layout = ccx.layout_of(ty);\n-    match *layout {\n-        Layout::CEnum { .. } |\n-        Layout::Scalar { .. } |\n-        Layout::Vector { .. } => true,\n-\n-        Layout::FatPointer { .. } => false,\n-\n-        Layout::Array { .. } |\n-        Layout::Univariant { .. } |\n-        Layout::General { .. } |\n-        Layout::UntaggedUnion { .. } |\n-        Layout::RawNullablePointer { .. } |\n-        Layout::StructWrappedNullablePointer { .. } => {\n-            !layout.is_unsized() && layout.size(ccx).bytes() == 0\n-        }\n-    }\n-}\n-\n-/// Returns Some([a, b]) if the type has a pair of fields with types a and b.\n-pub fn type_pair_fields<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>)\n-                                  -> Option<[Ty<'tcx>; 2]> {\n-    match ty.sty {\n-        ty::TyAdt(adt, substs) => {\n-            assert_eq!(adt.variants.len(), 1);\n-            let fields = &adt.variants[0].fields;\n-            if fields.len() != 2 {\n-                return None;\n-            }\n-            Some([monomorphize::field_ty(ccx.tcx(), substs, &fields[0]),\n-                  monomorphize::field_ty(ccx.tcx(), substs, &fields[1])])\n-        }\n-        ty::TyClosure(def_id, substs) => {\n-            let mut tys = substs.upvar_tys(def_id, ccx.tcx());\n-            tys.next().and_then(|first_ty| tys.next().and_then(|second_ty| {\n-                if tys.next().is_some() {\n-                    None\n-                } else {\n-                    Some([first_ty, second_ty])\n-                }\n-            }))\n-        }\n-        ty::TyGenerator(def_id, substs, _) => {\n-            let mut tys = substs.field_tys(def_id, ccx.tcx());\n-            tys.next().and_then(|first_ty| tys.next().and_then(|second_ty| {\n-                if tys.next().is_some() {\n-                    None\n-                } else {\n-                    Some([first_ty, second_ty])\n-                }\n-            }))\n-        }\n-        ty::TyTuple(tys, _) => {\n-            if tys.len() != 2 {\n-                return None;\n-            }\n-            Some([tys[0], tys[1]])\n-        }\n-        _ => None\n-    }\n-}\n-\n-/// Returns true if the type is represented as a pair of immediates.\n-pub fn type_is_imm_pair<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>)\n-                                  -> bool {\n-    match *ccx.layout_of(ty) {\n-        Layout::FatPointer { .. } => true,\n-        Layout::Univariant { ref variant, .. } => {\n-            // There must be only 2 fields.\n-            if variant.offsets.len() != 2 {\n-                return false;\n-            }\n-\n-            match type_pair_fields(ccx, ty) {\n-                Some([a, b]) => {\n-                    type_is_immediate(ccx, a) && type_is_immediate(ccx, b)\n-                }\n-                None => false\n-            }\n-        }\n-        _ => false\n-    }\n-}\n-\n-/// Identify types which have size zero at runtime.\n-pub fn type_is_zero_size<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n-    let layout = ccx.layout_of(ty);\n-    !layout.is_unsized() && layout.size(ccx).bytes() == 0\n-}\n-\n pub fn type_needs_drop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> bool {\n     ty.needs_drop(tcx, ty::ParamEnv::empty(traits::Reveal::All))\n }\n@@ -245,17 +146,13 @@ pub fn C_uint(t: Type, i: u64) -> ValueRef {\n     }\n }\n \n-pub fn C_big_integral(t: Type, u: u128) -> ValueRef {\n+pub fn C_uint_big(t: Type, u: u128) -> ValueRef {\n     unsafe {\n-        let words = [u as u64, u.wrapping_shr(64) as u64];\n+        let words = [u as u64, (u >> 64) as u64];\n         llvm::LLVMConstIntOfArbitraryPrecision(t.to_ref(), 2, words.as_ptr())\n     }\n }\n \n-pub fn C_nil(ccx: &CrateContext) -> ValueRef {\n-    C_struct(ccx, &[], false)\n-}\n-\n pub fn C_bool(ccx: &CrateContext, val: bool) -> ValueRef {\n     C_uint(Type::i1(ccx), val as u64)\n }\n@@ -273,8 +170,7 @@ pub fn C_u64(ccx: &CrateContext, i: u64) -> ValueRef {\n }\n \n pub fn C_usize(ccx: &CrateContext, i: u64) -> ValueRef {\n-    let bit_size = machine::llbitsize_of_real(ccx, ccx.isize_ty());\n-\n+    let bit_size = ccx.data_layout().pointer_size.bits();\n     if bit_size < 64 {\n         // make sure it doesn't overflow\n         assert!(i < (1<<bit_size));\n@@ -317,8 +213,15 @@ pub fn C_cstr(cx: &CrateContext, s: InternedString, null_terminated: bool) -> Va\n // you will be kicked off fast isel. See issue #4352 for an example of this.\n pub fn C_str_slice(cx: &CrateContext, s: InternedString) -> ValueRef {\n     let len = s.len();\n-    let cs = consts::ptrcast(C_cstr(cx, s, false), Type::i8p(cx));\n-    C_named_struct(cx.str_slice_type(), &[cs, C_usize(cx, len as u64)])\n+    let cs = consts::ptrcast(C_cstr(cx, s, false),\n+        cx.layout_of(cx.tcx().mk_str()).llvm_type(cx).ptr_to());\n+    C_fat_ptr(cx, cs, C_usize(cx, len as u64))\n+}\n+\n+pub fn C_fat_ptr(cx: &CrateContext, ptr: ValueRef, meta: ValueRef) -> ValueRef {\n+    assert_eq!(abi::FAT_PTR_ADDR, 0);\n+    assert_eq!(abi::FAT_PTR_EXTRA, 1);\n+    C_struct(cx, &[ptr, meta], false)\n }\n \n pub fn C_struct(cx: &CrateContext, elts: &[ValueRef], packed: bool) -> ValueRef {\n@@ -333,12 +236,6 @@ pub fn C_struct_in_context(llcx: ContextRef, elts: &[ValueRef], packed: bool) ->\n     }\n }\n \n-pub fn C_named_struct(t: Type, elts: &[ValueRef]) -> ValueRef {\n-    unsafe {\n-        llvm::LLVMConstNamedStruct(t.to_ref(), elts.as_ptr(), elts.len() as c_uint)\n-    }\n-}\n-\n pub fn C_array(ty: Type, elts: &[ValueRef]) -> ValueRef {\n     unsafe {\n         return llvm::LLVMConstArray(ty.to_ref(), elts.as_ptr(), elts.len() as c_uint);\n@@ -362,13 +259,14 @@ pub fn C_bytes_in_context(llcx: ContextRef, bytes: &[u8]) -> ValueRef {\n     }\n }\n \n-pub fn const_get_elt(v: ValueRef, us: &[c_uint])\n-              -> ValueRef {\n+pub fn const_get_elt(v: ValueRef, idx: u64) -> ValueRef {\n     unsafe {\n+        assert_eq!(idx as c_uint as u64, idx);\n+        let us = &[idx as c_uint];\n         let r = llvm::LLVMConstExtractValue(v, us.as_ptr(), us.len() as c_uint);\n \n-        debug!(\"const_get_elt(v={:?}, us={:?}, r={:?})\",\n-               Value(v), us, Value(r));\n+        debug!(\"const_get_elt(v={:?}, idx={}, r={:?})\",\n+               Value(v), idx, Value(r));\n \n         r\n     }\n@@ -408,19 +306,6 @@ pub fn const_to_opt_u128(v: ValueRef, sign_ext: bool) -> Option<u128> {\n     }\n }\n \n-pub fn is_undef(val: ValueRef) -> bool {\n-    unsafe {\n-        llvm::LLVMIsUndef(val) != False\n-    }\n-}\n-\n-#[allow(dead_code)] // potentially useful\n-pub fn is_null(val: ValueRef) -> bool {\n-    unsafe {\n-        llvm::LLVMIsNull(val) != False\n-    }\n-}\n-\n pub fn langcall(tcx: TyCtxt,\n                 span: Option<Span>,\n                 msg: &str,"}, {"sha": "cfca3b57cb9d7a7a875e71af0d7d5fcbfa018f2a", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -14,19 +14,19 @@ use llvm::{ValueRef, True};\n use rustc::hir::def_id::DefId;\n use rustc::hir::map as hir_map;\n use rustc::middle::const_val::ConstEvalErr;\n-use {debuginfo, machine};\n+use debuginfo;\n use base;\n use trans_item::{TransItem, TransItemExt};\n use common::{self, CrateContext, val_ty};\n use declare;\n use monomorphize::Instance;\n use type_::Type;\n-use type_of;\n+use type_of::LayoutLlvmExt;\n use rustc::ty;\n+use rustc::ty::layout::{Align, LayoutOf};\n \n use rustc::hir;\n \n-use std::cmp;\n use std::ffi::{CStr, CString};\n use syntax::ast;\n use syntax::attr;\n@@ -45,26 +45,26 @@ pub fn bitcast(val: ValueRef, ty: Type) -> ValueRef {\n \n fn set_global_alignment(ccx: &CrateContext,\n                         gv: ValueRef,\n-                        mut align: machine::llalign) {\n+                        mut align: Align) {\n     // The target may require greater alignment for globals than the type does.\n     // Note: GCC and Clang also allow `__attribute__((aligned))` on variables,\n     // which can force it to be smaller.  Rust doesn't support this yet.\n     if let Some(min) = ccx.sess().target.target.options.min_global_align {\n         match ty::layout::Align::from_bits(min, min) {\n-            Ok(min) => align = cmp::max(align, min.abi() as machine::llalign),\n+            Ok(min) => align = align.max(min),\n             Err(err) => {\n                 ccx.sess().err(&format!(\"invalid minimum global alignment: {}\", err));\n             }\n         }\n     }\n     unsafe {\n-        llvm::LLVMSetAlignment(gv, align);\n+        llvm::LLVMSetAlignment(gv, align.abi() as u32);\n     }\n }\n \n pub fn addr_of_mut(ccx: &CrateContext,\n                    cv: ValueRef,\n-                   align: machine::llalign,\n+                   align: Align,\n                    kind: &str)\n                     -> ValueRef {\n     unsafe {\n@@ -82,15 +82,16 @@ pub fn addr_of_mut(ccx: &CrateContext,\n \n pub fn addr_of(ccx: &CrateContext,\n                cv: ValueRef,\n-               align: machine::llalign,\n+               align: Align,\n                kind: &str)\n                -> ValueRef {\n     if let Some(&gv) = ccx.const_globals().borrow().get(&cv) {\n         unsafe {\n             // Upgrade the alignment in cases where the same constant is used with different\n             // alignment requirements\n-            if align > llvm::LLVMGetAlignment(gv) {\n-                llvm::LLVMSetAlignment(gv, align);\n+            let llalign = align.abi() as u32;\n+            if llalign > llvm::LLVMGetAlignment(gv) {\n+                llvm::LLVMSetAlignment(gv, llalign);\n             }\n         }\n         return gv;\n@@ -112,7 +113,7 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n     let ty = common::instance_ty(ccx.tcx(), &instance);\n     let g = if let Some(id) = ccx.tcx().hir.as_local_node_id(def_id) {\n \n-        let llty = type_of::type_of(ccx, ty);\n+        let llty = ccx.layout_of(ty).llvm_type(ccx);\n         let (g, attrs) = match ccx.tcx().hir.get(id) {\n             hir_map::NodeItem(&hir::Item {\n                 ref attrs, span, node: hir::ItemStatic(..), ..\n@@ -157,7 +158,7 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n                         }\n                     };\n                     let llty2 = match ty.sty {\n-                        ty::TyRawPtr(ref mt) => type_of::type_of(ccx, mt.ty),\n+                        ty::TyRawPtr(ref mt) => ccx.layout_of(mt.ty).llvm_type(ccx),\n                         _ => {\n                             ccx.sess().span_fatal(span, \"must have type `*const T` or `*mut T`\");\n                         }\n@@ -206,7 +207,7 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n \n         // FIXME(nagisa): perhaps the map of externs could be offloaded to llvm somehow?\n         // FIXME(nagisa): investigate whether it can be changed into define_global\n-        let g = declare::declare_global(ccx, &sym, type_of::type_of(ccx, ty));\n+        let g = declare::declare_global(ccx, &sym, ccx.layout_of(ty).llvm_type(ccx));\n         // Thread-local statics in some other crate need to *always* be linked\n         // against in a thread-local fashion, so we need to be sure to apply the\n         // thread-local attribute locally if it was present remotely. If we\n@@ -266,7 +267,7 @@ pub fn trans_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n         let instance = Instance::mono(ccx.tcx(), def_id);\n         let ty = common::instance_ty(ccx.tcx(), &instance);\n-        let llty = type_of::type_of(ccx, ty);\n+        let llty = ccx.layout_of(ty).llvm_type(ccx);\n         let g = if val_llty == llty {\n             g\n         } else {"}, {"sha": "b2bb605d01b462cee3d90c05e89a353a9d7af540", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 36, "deletions": 39, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -24,12 +24,14 @@ use monomorphize::Instance;\n \n use partitioning::CodegenUnit;\n use type_::Type;\n+use type_of::PointeeInfo;\n+\n use rustc_data_structures::base_n;\n use rustc::middle::trans::Stats;\n use rustc_data_structures::stable_hasher::StableHashingContextProvider;\n use rustc::session::config::{self, NoDebugInfo};\n use rustc::session::Session;\n-use rustc::ty::layout::{LayoutCx, LayoutError, LayoutTyper, TyLayout};\n+use rustc::ty::layout::{LayoutError, LayoutOf, Size, TyLayout};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::util::nodemap::FxHashMap;\n use rustc_trans_utils;\n@@ -99,10 +101,10 @@ pub struct LocalCrateContext<'a, 'tcx: 'a> {\n     /// See http://llvm.org/docs/LangRef.html#the-llvm-used-global-variable for details\n     used_statics: RefCell<Vec<ValueRef>>,\n \n-    lltypes: RefCell<FxHashMap<Ty<'tcx>, Type>>,\n+    lltypes: RefCell<FxHashMap<(Ty<'tcx>, Option<usize>), Type>>,\n+    scalar_lltypes: RefCell<FxHashMap<Ty<'tcx>, Type>>,\n+    pointee_infos: RefCell<FxHashMap<(Ty<'tcx>, Size), Option<PointeeInfo>>>,\n     isize_ty: Type,\n-    opaque_vec_type: Type,\n-    str_slice_type: Type,\n \n     dbg_cx: Option<debuginfo::CrateDebugContext<'tcx>>,\n \n@@ -377,9 +379,9 @@ impl<'a, 'tcx> LocalCrateContext<'a, 'tcx> {\n                 statics_to_rauw: RefCell::new(Vec::new()),\n                 used_statics: RefCell::new(Vec::new()),\n                 lltypes: RefCell::new(FxHashMap()),\n+                scalar_lltypes: RefCell::new(FxHashMap()),\n+                pointee_infos: RefCell::new(FxHashMap()),\n                 isize_ty: Type::from_ref(ptr::null_mut()),\n-                opaque_vec_type: Type::from_ref(ptr::null_mut()),\n-                str_slice_type: Type::from_ref(ptr::null_mut()),\n                 dbg_cx,\n                 eh_personality: Cell::new(None),\n                 eh_unwind_resume: Cell::new(None),\n@@ -389,25 +391,19 @@ impl<'a, 'tcx> LocalCrateContext<'a, 'tcx> {\n                 placeholder: PhantomData,\n             };\n \n-            let (isize_ty, opaque_vec_type, str_slice_ty, mut local_ccx) = {\n+            let (isize_ty, mut local_ccx) = {\n                 // Do a little dance to create a dummy CrateContext, so we can\n                 // create some things in the LLVM module of this codegen unit\n                 let mut local_ccxs = vec![local_ccx];\n-                let (isize_ty, opaque_vec_type, str_slice_ty) = {\n+                let isize_ty = {\n                     let dummy_ccx = LocalCrateContext::dummy_ccx(shared,\n                                                                  local_ccxs.as_mut_slice());\n-                    let mut str_slice_ty = Type::named_struct(&dummy_ccx, \"str_slice\");\n-                    str_slice_ty.set_struct_body(&[Type::i8p(&dummy_ccx),\n-                                                   Type::isize(&dummy_ccx)],\n-                                                 false);\n-                    (Type::isize(&dummy_ccx), Type::opaque_vec(&dummy_ccx), str_slice_ty)\n+                    Type::isize(&dummy_ccx)\n                 };\n-                (isize_ty, opaque_vec_type, str_slice_ty, local_ccxs.pop().unwrap())\n+                (isize_ty, local_ccxs.pop().unwrap())\n             };\n \n             local_ccx.isize_ty = isize_ty;\n-            local_ccx.opaque_vec_type = opaque_vec_type;\n-            local_ccx.str_slice_type = str_slice_ty;\n \n             local_ccx\n         }\n@@ -512,10 +508,19 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local().used_statics\n     }\n \n-    pub fn lltypes<'a>(&'a self) -> &'a RefCell<FxHashMap<Ty<'tcx>, Type>> {\n+    pub fn lltypes<'a>(&'a self) -> &'a RefCell<FxHashMap<(Ty<'tcx>, Option<usize>), Type>> {\n         &self.local().lltypes\n     }\n \n+    pub fn scalar_lltypes<'a>(&'a self) -> &'a RefCell<FxHashMap<Ty<'tcx>, Type>> {\n+        &self.local().scalar_lltypes\n+    }\n+\n+    pub fn pointee_infos<'a>(&'a self)\n+                             -> &'a RefCell<FxHashMap<(Ty<'tcx>, Size), Option<PointeeInfo>>> {\n+        &self.local().pointee_infos\n+    }\n+\n     pub fn stats<'a>(&'a self) -> &'a RefCell<Stats> {\n         &self.local().stats\n     }\n@@ -524,10 +529,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         self.local().isize_ty\n     }\n \n-    pub fn str_slice_type(&self) -> Type {\n-        self.local().str_slice_type\n-    }\n-\n     pub fn dbg_cx<'a>(&'a self) -> &'a Option<debuginfo::CrateDebugContext<'tcx>> {\n         &self.local().dbg_cx\n     }\n@@ -647,48 +648,44 @@ impl<'a, 'tcx> ty::layout::HasDataLayout for &'a SharedCrateContext<'a, 'tcx> {\n     }\n }\n \n+impl<'a, 'tcx> ty::layout::HasTyCtxt<'tcx> for &'a SharedCrateContext<'a, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> {\n+        self.tcx\n+    }\n+}\n+\n impl<'a, 'tcx> ty::layout::HasDataLayout for &'a CrateContext<'a, 'tcx> {\n     fn data_layout(&self) -> &ty::layout::TargetDataLayout {\n         &self.shared.tcx.data_layout\n     }\n }\n \n-impl<'a, 'tcx> LayoutTyper<'tcx> for &'a SharedCrateContext<'a, 'tcx> {\n-    type TyLayout = TyLayout<'tcx>;\n-\n+impl<'a, 'tcx> ty::layout::HasTyCtxt<'tcx> for &'a CrateContext<'a, 'tcx> {\n     fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> {\n-        self.tcx\n+        self.shared.tcx\n     }\n+}\n+\n+impl<'a, 'tcx> LayoutOf<Ty<'tcx>> for &'a SharedCrateContext<'a, 'tcx> {\n+    type TyLayout = TyLayout<'tcx>;\n \n     fn layout_of(self, ty: Ty<'tcx>) -> Self::TyLayout {\n-        let param_env = ty::ParamEnv::empty(traits::Reveal::All);\n-        LayoutCx::new(self.tcx, param_env)\n+        (self.tcx, ty::ParamEnv::empty(traits::Reveal::All))\n             .layout_of(ty)\n             .unwrap_or_else(|e| match e {\n                 LayoutError::SizeOverflow(_) => self.sess().fatal(&e.to_string()),\n                 _ => bug!(\"failed to get layout for `{}`: {}\", ty, e)\n             })\n     }\n-\n-    fn normalize_projections(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.tcx().fully_normalize_associated_types_in(&ty)\n-    }\n }\n \n-impl<'a, 'tcx> LayoutTyper<'tcx> for &'a CrateContext<'a, 'tcx> {\n+impl<'a, 'tcx> LayoutOf<Ty<'tcx>> for &'a CrateContext<'a, 'tcx> {\n     type TyLayout = TyLayout<'tcx>;\n \n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> {\n-        self.shared.tcx\n-    }\n \n     fn layout_of(self, ty: Ty<'tcx>) -> Self::TyLayout {\n         self.shared.layout_of(ty)\n     }\n-\n-    fn normalize_projections(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.shared.normalize_projections(ty)\n-    }\n }\n \n /// Declare any llvm intrinsics that you might need"}, {"sha": "b2ad538a8ab290f9f1e84bede3f02ccf99e18e11", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 258, "deletions": 451, "changes": 709, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -9,11 +9,10 @@\n // except according to those terms.\n \n use self::RecursiveTypeDescription::*;\n-use self::MemberOffset::*;\n use self::MemberDescriptionFactory::*;\n use self::EnumDiscriminantInfo::*;\n \n-use super::utils::{debug_context, DIB, span_start, bytes_to_bits, size_and_align_of,\n+use super::utils::{debug_context, DIB, span_start,\n                    get_namespace_for_item, create_DIArray, is_node_local_to_unit};\n use super::namespace::mangled_name_of_item;\n use super::type_names::compute_debuginfo_type_name;\n@@ -30,19 +29,17 @@ use rustc::hir::def_id::{DefId, CrateNum, LOCAL_CRATE};\n use rustc::ty::fold::TypeVisitor;\n use rustc::ty::subst::Substs;\n use rustc::ty::util::TypeIdHasher;\n-use rustc::hir;\n use rustc::ich::Fingerprint;\n-use {type_of, machine, monomorphize};\n use common::{self, CrateContext};\n-use type_::Type;\n use rustc::ty::{self, AdtKind, Ty};\n-use rustc::ty::layout::{self, LayoutTyper};\n+use rustc::ty::layout::{self, Align, LayoutOf, Size, TyLayout};\n use rustc::session::{Session, config};\n use rustc::util::nodemap::FxHashMap;\n use rustc::util::common::path2cstr;\n \n use libc::{c_uint, c_longlong};\n use std::ffi::CString;\n+use std::fmt::Write;\n use std::ptr;\n use std::path::Path;\n use syntax::ast;\n@@ -184,7 +181,6 @@ enum RecursiveTypeDescription<'tcx> {\n         unfinished_type: Ty<'tcx>,\n         unique_type_id: UniqueTypeId,\n         metadata_stub: DICompositeType,\n-        llvm_type: Type,\n         member_description_factory: MemberDescriptionFactory<'tcx>,\n     },\n     FinalMetadata(DICompositeType)\n@@ -195,7 +191,6 @@ fn create_and_register_recursive_type_forward_declaration<'a, 'tcx>(\n     unfinished_type: Ty<'tcx>,\n     unique_type_id: UniqueTypeId,\n     metadata_stub: DICompositeType,\n-    llvm_type: Type,\n     member_description_factory: MemberDescriptionFactory<'tcx>)\n  -> RecursiveTypeDescription<'tcx> {\n \n@@ -208,7 +203,6 @@ fn create_and_register_recursive_type_forward_declaration<'a, 'tcx>(\n         unfinished_type,\n         unique_type_id,\n         metadata_stub,\n-        llvm_type,\n         member_description_factory,\n     }\n }\n@@ -224,9 +218,7 @@ impl<'tcx> RecursiveTypeDescription<'tcx> {\n                 unfinished_type,\n                 unique_type_id,\n                 metadata_stub,\n-                llvm_type,\n                 ref member_description_factory,\n-                ..\n             } => {\n                 // Make sure that we have a forward declaration of the type in\n                 // the TypeMap so that recursive references are possible. This\n@@ -251,7 +243,6 @@ impl<'tcx> RecursiveTypeDescription<'tcx> {\n                 // ... and attach them to the stub to complete it.\n                 set_members_of_composite_type(cx,\n                                               metadata_stub,\n-                                              llvm_type,\n                                               &member_descriptions[..]);\n                 return MetadataCreationResult::new(metadata_stub, true);\n             }\n@@ -274,20 +265,21 @@ macro_rules! return_if_metadata_created_in_meantime {\n \n fn fixed_vec_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                 unique_type_id: UniqueTypeId,\n+                                array_or_slice_type: Ty<'tcx>,\n                                 element_type: Ty<'tcx>,\n-                                len: Option<u64>,\n                                 span: Span)\n                                 -> MetadataCreationResult {\n     let element_type_metadata = type_metadata(cx, element_type, span);\n \n     return_if_metadata_created_in_meantime!(cx, unique_type_id);\n \n-    let element_llvm_type = type_of::type_of(cx, element_type);\n-    let (element_type_size, element_type_align) = size_and_align_of(cx, element_llvm_type);\n+    let (size, align) = cx.size_and_align_of(array_or_slice_type);\n \n-    let (array_size_in_bytes, upper_bound) = match len {\n-        Some(len) => (element_type_size * len, len as c_longlong),\n-        None => (0, -1)\n+    let upper_bound = match array_or_slice_type.sty {\n+        ty::TyArray(_, len) => {\n+            len.val.to_const_int().unwrap().to_u64().unwrap() as c_longlong\n+        }\n+        _ => -1\n     };\n \n     let subrange = unsafe {\n@@ -298,8 +290,8 @@ fn fixed_vec_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let metadata = unsafe {\n         llvm::LLVMRustDIBuilderCreateArrayType(\n             DIB(cx),\n-            bytes_to_bits(array_size_in_bytes),\n-            bytes_to_bits(element_type_align),\n+            size.bits(),\n+            align.abi_bits() as u32,\n             element_type_metadata,\n             subscripts)\n     };\n@@ -308,66 +300,52 @@ fn fixed_vec_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n }\n \n fn vec_slice_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                vec_type: Ty<'tcx>,\n+                                slice_ptr_type: Ty<'tcx>,\n                                 element_type: Ty<'tcx>,\n                                 unique_type_id: UniqueTypeId,\n                                 span: Span)\n                                 -> MetadataCreationResult {\n-    let data_ptr_type = cx.tcx().mk_ptr(ty::TypeAndMut {\n-        ty: element_type,\n-        mutbl: hir::MutImmutable\n-    });\n+    let data_ptr_type = cx.tcx().mk_imm_ptr(element_type);\n \n-    let element_type_metadata = type_metadata(cx, data_ptr_type, span);\n+    let data_ptr_metadata = type_metadata(cx, data_ptr_type, span);\n \n     return_if_metadata_created_in_meantime!(cx, unique_type_id);\n \n-    let slice_llvm_type = type_of::type_of(cx, vec_type);\n-    let slice_type_name = compute_debuginfo_type_name(cx, vec_type, true);\n+    let slice_type_name = compute_debuginfo_type_name(cx, slice_ptr_type, true);\n+\n+    let (pointer_size, pointer_align) = cx.size_and_align_of(data_ptr_type);\n+    let (usize_size, usize_align) = cx.size_and_align_of(cx.tcx().types.usize);\n \n-    let member_llvm_types = slice_llvm_type.field_types();\n-    assert!(slice_layout_is_correct(cx,\n-                                    &member_llvm_types[..],\n-                                    element_type));\n     let member_descriptions = [\n         MemberDescription {\n             name: \"data_ptr\".to_string(),\n-            llvm_type: member_llvm_types[0],\n-            type_metadata: element_type_metadata,\n-            offset: ComputedMemberOffset,\n+            type_metadata: data_ptr_metadata,\n+            offset: Size::from_bytes(0),\n+            size: pointer_size,\n+            align: pointer_align,\n             flags: DIFlags::FlagZero,\n         },\n         MemberDescription {\n             name: \"length\".to_string(),\n-            llvm_type: member_llvm_types[1],\n             type_metadata: type_metadata(cx, cx.tcx().types.usize, span),\n-            offset: ComputedMemberOffset,\n+            offset: pointer_size,\n+            size: usize_size,\n+            align: usize_align,\n             flags: DIFlags::FlagZero,\n         },\n     ];\n \n-    assert!(member_descriptions.len() == member_llvm_types.len());\n-\n     let file_metadata = unknown_file_metadata(cx);\n \n     let metadata = composite_type_metadata(cx,\n-                                           slice_llvm_type,\n+                                           slice_ptr_type,\n                                            &slice_type_name[..],\n                                            unique_type_id,\n                                            &member_descriptions,\n                                            NO_SCOPE_METADATA,\n                                            file_metadata,\n                                            span);\n-    return MetadataCreationResult::new(metadata, false);\n-\n-    fn slice_layout_is_correct<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                         member_llvm_types: &[Type],\n-                                         element_type: Ty<'tcx>)\n-                                         -> bool {\n-        member_llvm_types.len() == 2 &&\n-        member_llvm_types[0] == type_of::type_of(cx, element_type).ptr_to() &&\n-        member_llvm_types[1] == cx.isize_ty()\n-    }\n+    MetadataCreationResult::new(metadata, false)\n }\n \n fn subroutine_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n@@ -436,38 +414,38 @@ fn trait_pointer_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let trait_type_name =\n         compute_debuginfo_type_name(cx, trait_object_type, false);\n \n-    let trait_llvm_type = type_of::type_of(cx, trait_object_type);\n     let file_metadata = unknown_file_metadata(cx);\n \n-\n-    let ptr_type = cx.tcx().mk_ptr(ty::TypeAndMut {\n-        ty: cx.tcx().types.u8,\n-        mutbl: hir::MutImmutable\n-    });\n-    let ptr_type_metadata = type_metadata(cx, ptr_type, syntax_pos::DUMMY_SP);\n-    let llvm_type = type_of::type_of(cx, ptr_type);\n+    let layout = cx.layout_of(cx.tcx().mk_mut_ptr(trait_type));\n \n     assert_eq!(abi::FAT_PTR_ADDR, 0);\n     assert_eq!(abi::FAT_PTR_EXTRA, 1);\n+\n+    let data_ptr_field = layout.field(cx, 0);\n+    let vtable_field = layout.field(cx, 1);\n     let member_descriptions = [\n         MemberDescription {\n             name: \"pointer\".to_string(),\n-            llvm_type: llvm_type,\n-            type_metadata: ptr_type_metadata,\n-            offset: ComputedMemberOffset,\n+            type_metadata: type_metadata(cx,\n+                cx.tcx().mk_mut_ptr(cx.tcx().types.u8),\n+                syntax_pos::DUMMY_SP),\n+            offset: layout.fields.offset(0),\n+            size: data_ptr_field.size,\n+            align: data_ptr_field.align,\n             flags: DIFlags::FlagArtificial,\n         },\n         MemberDescription {\n             name: \"vtable\".to_string(),\n-            llvm_type: llvm_type,\n-            type_metadata: ptr_type_metadata,\n-            offset: ComputedMemberOffset,\n+            type_metadata: type_metadata(cx, vtable_field.ty, syntax_pos::DUMMY_SP),\n+            offset: layout.fields.offset(1),\n+            size: vtable_field.size,\n+            align: vtable_field.align,\n             flags: DIFlags::FlagArtificial,\n         },\n     ];\n \n     composite_type_metadata(cx,\n-                            trait_llvm_type,\n+                            trait_object_type,\n                             &trait_type_name[..],\n                             unique_type_id,\n                             &member_descriptions,\n@@ -556,15 +534,12 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::TyTuple(ref elements, _) if elements.is_empty() => {\n             MetadataCreationResult::new(basic_type_metadata(cx, t), false)\n         }\n-        ty::TyArray(typ, len) => {\n-            let len = len.val.to_const_int().unwrap().to_u64().unwrap();\n-            fixed_vec_metadata(cx, unique_type_id, typ, Some(len), usage_site_span)\n-        }\n+        ty::TyArray(typ, _) |\n         ty::TySlice(typ) => {\n-            fixed_vec_metadata(cx, unique_type_id, typ, None, usage_site_span)\n+            fixed_vec_metadata(cx, unique_type_id, t, typ, usage_site_span)\n         }\n         ty::TyStr => {\n-            fixed_vec_metadata(cx, unique_type_id, cx.tcx().types.i8, None, usage_site_span)\n+            fixed_vec_metadata(cx, unique_type_id, t, cx.tcx().types.i8, usage_site_span)\n         }\n         ty::TyDynamic(..) => {\n             MetadataCreationResult::new(\n@@ -770,15 +745,14 @@ fn basic_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         _ => bug!(\"debuginfo::basic_type_metadata - t is invalid type\")\n     };\n \n-    let llvm_type = type_of::type_of(cx, t);\n-    let (size, align) = size_and_align_of(cx, llvm_type);\n+    let (size, align) = cx.size_and_align_of(t);\n     let name = CString::new(name).unwrap();\n     let ty_metadata = unsafe {\n         llvm::LLVMRustDIBuilderCreateBasicType(\n             DIB(cx),\n             name.as_ptr(),\n-            bytes_to_bits(size),\n-            bytes_to_bits(align),\n+            size.bits(),\n+            align.abi_bits() as u32,\n             encoding)\n     };\n \n@@ -790,29 +764,25 @@ fn foreign_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                    unique_type_id: UniqueTypeId) -> DIType {\n     debug!(\"foreign_type_metadata: {:?}\", t);\n \n-    let llvm_type = type_of::type_of(cx, t);\n-\n     let name = compute_debuginfo_type_name(cx, t, false);\n-    create_struct_stub(cx, llvm_type, &name, unique_type_id, NO_SCOPE_METADATA)\n+    create_struct_stub(cx, t, &name, unique_type_id, NO_SCOPE_METADATA)\n }\n \n fn pointer_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                    pointer_type: Ty<'tcx>,\n                                    pointee_type_metadata: DIType)\n                                    -> DIType {\n-    let pointer_llvm_type = type_of::type_of(cx, pointer_type);\n-    let (pointer_size, pointer_align) = size_and_align_of(cx, pointer_llvm_type);\n+    let (pointer_size, pointer_align) = cx.size_and_align_of(pointer_type);\n     let name = compute_debuginfo_type_name(cx, pointer_type, false);\n     let name = CString::new(name).unwrap();\n-    let ptr_metadata = unsafe {\n+    unsafe {\n         llvm::LLVMRustDIBuilderCreatePointerType(\n             DIB(cx),\n             pointee_type_metadata,\n-            bytes_to_bits(pointer_size),\n-            bytes_to_bits(pointer_align),\n+            pointer_size.bits(),\n+            pointer_align.abi_bits() as u32,\n             name.as_ptr())\n-    };\n-    return ptr_metadata;\n+    }\n }\n \n pub fn compile_unit_metadata(scc: &SharedCrateContext,\n@@ -907,21 +877,15 @@ impl MetadataCreationResult {\n     }\n }\n \n-#[derive(Debug)]\n-enum MemberOffset {\n-    FixedMemberOffset { bytes: usize },\n-    // For ComputedMemberOffset, the offset is read from the llvm type definition.\n-    ComputedMemberOffset\n-}\n-\n // Description of a type member, which can either be a regular field (as in\n // structs or tuples) or an enum variant.\n #[derive(Debug)]\n struct MemberDescription {\n     name: String,\n-    llvm_type: Type,\n     type_metadata: DIType,\n-    offset: MemberOffset,\n+    offset: Size,\n+    size: Size,\n+    align: Align,\n     flags: DIFlags,\n }\n \n@@ -968,43 +932,27 @@ impl<'tcx> MemberDescriptionFactory<'tcx> {\n struct StructMemberDescriptionFactory<'tcx> {\n     ty: Ty<'tcx>,\n     variant: &'tcx ty::VariantDef,\n-    substs: &'tcx Substs<'tcx>,\n     span: Span,\n }\n \n impl<'tcx> StructMemberDescriptionFactory<'tcx> {\n     fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n                                       -> Vec<MemberDescription> {\n         let layout = cx.layout_of(self.ty);\n-\n-        let tmp;\n-        let offsets = match *layout {\n-            layout::Univariant { ref variant, .. } => &variant.offsets,\n-            layout::Vector { element, count } => {\n-                let element_size = element.size(cx).bytes();\n-                tmp = (0..count).\n-                  map(|i| layout::Size::from_bytes(i*element_size))\n-                  .collect::<Vec<layout::Size>>();\n-                &tmp\n-            }\n-            _ => bug!(\"{} is not a struct\", self.ty)\n-        };\n-\n         self.variant.fields.iter().enumerate().map(|(i, f)| {\n             let name = if self.variant.ctor_kind == CtorKind::Fn {\n                 format!(\"__{}\", i)\n             } else {\n                 f.name.to_string()\n             };\n-            let fty = monomorphize::field_ty(cx.tcx(), self.substs, f);\n-\n-            let offset = FixedMemberOffset { bytes: offsets[i].bytes() as usize};\n-\n+            let field = layout.field(cx, i);\n+            let (size, align) = field.size_and_align();\n             MemberDescription {\n                 name,\n-                llvm_type: type_of::in_memory_type_of(cx, fty),\n-                type_metadata: type_metadata(cx, fty, self.span),\n-                offset,\n+                type_metadata: type_metadata(cx, field.ty, self.span),\n+                offset: layout.fields.offset(i),\n+                size,\n+                align,\n                 flags: DIFlags::FlagZero,\n             }\n         }).collect()\n@@ -1018,17 +966,16 @@ fn prepare_struct_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                      span: Span)\n                                      -> RecursiveTypeDescription<'tcx> {\n     let struct_name = compute_debuginfo_type_name(cx, struct_type, false);\n-    let struct_llvm_type = type_of::in_memory_type_of(cx, struct_type);\n \n-    let (struct_def_id, variant, substs) = match struct_type.sty {\n-        ty::TyAdt(def, substs) => (def.did, def.struct_variant(), substs),\n+    let (struct_def_id, variant) = match struct_type.sty {\n+        ty::TyAdt(def, _) => (def.did, def.struct_variant()),\n         _ => bug!(\"prepare_struct_metadata on a non-ADT\")\n     };\n \n     let containing_scope = get_namespace_for_item(cx, struct_def_id);\n \n     let struct_metadata_stub = create_struct_stub(cx,\n-                                                  struct_llvm_type,\n+                                                  struct_type,\n                                                   &struct_name,\n                                                   unique_type_id,\n                                                   containing_scope);\n@@ -1038,11 +985,9 @@ fn prepare_struct_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         struct_type,\n         unique_type_id,\n         struct_metadata_stub,\n-        struct_llvm_type,\n         StructMDF(StructMemberDescriptionFactory {\n             ty: struct_type,\n             variant,\n-            substs,\n             span,\n         })\n     )\n@@ -1063,21 +1008,14 @@ impl<'tcx> TupleMemberDescriptionFactory<'tcx> {\n     fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n                                       -> Vec<MemberDescription> {\n         let layout = cx.layout_of(self.ty);\n-        let offsets = if let layout::Univariant { ref variant, .. } = *layout {\n-            &variant.offsets\n-        } else {\n-            bug!(\"{} is not a tuple\", self.ty);\n-        };\n-\n-        self.component_types\n-            .iter()\n-            .enumerate()\n-            .map(|(i, &component_type)| {\n+        self.component_types.iter().enumerate().map(|(i, &component_type)| {\n+            let (size, align) = cx.size_and_align_of(component_type);\n             MemberDescription {\n                 name: format!(\"__{}\", i),\n-                llvm_type: type_of::type_of(cx, component_type),\n                 type_metadata: type_metadata(cx, component_type, self.span),\n-                offset: FixedMemberOffset { bytes: offsets[i].bytes() as usize },\n+                offset: layout.fields.offset(i),\n+                size,\n+                align,\n                 flags: DIFlags::FlagZero,\n             }\n         }).collect()\n@@ -1091,18 +1029,16 @@ fn prepare_tuple_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                     span: Span)\n                                     -> RecursiveTypeDescription<'tcx> {\n     let tuple_name = compute_debuginfo_type_name(cx, tuple_type, false);\n-    let tuple_llvm_type = type_of::type_of(cx, tuple_type);\n \n     create_and_register_recursive_type_forward_declaration(\n         cx,\n         tuple_type,\n         unique_type_id,\n         create_struct_stub(cx,\n-                           tuple_llvm_type,\n+                           tuple_type,\n                            &tuple_name[..],\n                            unique_type_id,\n                            NO_SCOPE_METADATA),\n-        tuple_llvm_type,\n         TupleMDF(TupleMemberDescriptionFactory {\n             ty: tuple_type,\n             component_types: component_types.to_vec(),\n@@ -1116,21 +1052,23 @@ fn prepare_tuple_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n //=-----------------------------------------------------------------------------\n \n struct UnionMemberDescriptionFactory<'tcx> {\n+    layout: TyLayout<'tcx>,\n     variant: &'tcx ty::VariantDef,\n-    substs: &'tcx Substs<'tcx>,\n     span: Span,\n }\n \n impl<'tcx> UnionMemberDescriptionFactory<'tcx> {\n     fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n                                       -> Vec<MemberDescription> {\n-        self.variant.fields.iter().map(|field| {\n-            let fty = monomorphize::field_ty(cx.tcx(), self.substs, field);\n+        self.variant.fields.iter().enumerate().map(|(i, f)| {\n+            let field = self.layout.field(cx, i);\n+            let (size, align) = field.size_and_align();\n             MemberDescription {\n-                name: field.name.to_string(),\n-                llvm_type: type_of::type_of(cx, fty),\n-                type_metadata: type_metadata(cx, fty, self.span),\n-                offset: FixedMemberOffset { bytes: 0 },\n+                name: f.name.to_string(),\n+                type_metadata: type_metadata(cx, field.ty, self.span),\n+                offset: Size::from_bytes(0),\n+                size,\n+                align,\n                 flags: DIFlags::FlagZero,\n             }\n         }).collect()\n@@ -1143,17 +1081,16 @@ fn prepare_union_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                     span: Span)\n                                     -> RecursiveTypeDescription<'tcx> {\n     let union_name = compute_debuginfo_type_name(cx, union_type, false);\n-    let union_llvm_type = type_of::in_memory_type_of(cx, union_type);\n \n-    let (union_def_id, variant, substs) = match union_type.sty {\n-        ty::TyAdt(def, substs) => (def.did, def.struct_variant(), substs),\n+    let (union_def_id, variant) = match union_type.sty {\n+        ty::TyAdt(def, _) => (def.did, def.struct_variant()),\n         _ => bug!(\"prepare_union_metadata on a non-ADT\")\n     };\n \n     let containing_scope = get_namespace_for_item(cx, union_def_id);\n \n     let union_metadata_stub = create_union_stub(cx,\n-                                                union_llvm_type,\n+                                                union_type,\n                                                 &union_name,\n                                                 unique_type_id,\n                                                 containing_scope);\n@@ -1163,10 +1100,9 @@ fn prepare_union_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         union_type,\n         unique_type_id,\n         union_metadata_stub,\n-        union_llvm_type,\n         UnionMDF(UnionMemberDescriptionFactory {\n+            layout: cx.layout_of(union_type),\n             variant,\n-            substs,\n             span,\n         })\n     )\n@@ -1183,173 +1119,80 @@ fn prepare_union_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n // offset of zero bytes).\n struct EnumMemberDescriptionFactory<'tcx> {\n     enum_type: Ty<'tcx>,\n-    type_rep: &'tcx layout::Layout,\n+    layout: TyLayout<'tcx>,\n     discriminant_type_metadata: Option<DIType>,\n     containing_scope: DIScope,\n-    file_metadata: DIFile,\n     span: Span,\n }\n \n impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n     fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n                                       -> Vec<MemberDescription> {\n         let adt = &self.enum_type.ty_adt_def().unwrap();\n-        let substs = match self.enum_type.sty {\n-            ty::TyAdt(def, ref s) if def.adt_kind() == AdtKind::Enum => s,\n-            _ => bug!(\"{} is not an enum\", self.enum_type)\n-        };\n-        match *self.type_rep {\n-            layout::General { ref variants, .. } => {\n+        match self.layout.variants {\n+            layout::Variants::Single { .. } if adt.variants.is_empty() => vec![],\n+            layout::Variants::Single { index } => {\n+                let (variant_type_metadata, member_description_factory) =\n+                    describe_enum_variant(cx,\n+                                          self.layout,\n+                                          &adt.variants[index],\n+                                          NoDiscriminant,\n+                                          self.containing_scope,\n+                                          self.span);\n+\n+                let member_descriptions =\n+                    member_description_factory.create_member_descriptions(cx);\n+\n+                set_members_of_composite_type(cx,\n+                                              variant_type_metadata,\n+                                              &member_descriptions[..]);\n+                vec![\n+                    MemberDescription {\n+                        name: \"\".to_string(),\n+                        type_metadata: variant_type_metadata,\n+                        offset: Size::from_bytes(0),\n+                        size: self.layout.size,\n+                        align: self.layout.align,\n+                        flags: DIFlags::FlagZero\n+                    }\n+                ]\n+            }\n+            layout::Variants::Tagged { ref variants, .. } => {\n                 let discriminant_info = RegularDiscriminant(self.discriminant_type_metadata\n                     .expect(\"\"));\n-                variants\n-                    .iter()\n-                    .enumerate()\n-                    .map(|(i, struct_def)| {\n-                        let (variant_type_metadata,\n-                             variant_llvm_type,\n-                             member_desc_factory) =\n-                            describe_enum_variant(cx,\n-                                                  self.enum_type,\n-                                                  struct_def,\n-                                                  &adt.variants[i],\n-                                                  discriminant_info,\n-                                                  self.containing_scope,\n-                                                  self.span);\n-\n-                        let member_descriptions = member_desc_factory\n-                            .create_member_descriptions(cx);\n-\n-                        set_members_of_composite_type(cx,\n-                                                      variant_type_metadata,\n-                                                      variant_llvm_type,\n-                                                      &member_descriptions);\n-                        MemberDescription {\n-                            name: \"\".to_string(),\n-                            llvm_type: variant_llvm_type,\n-                            type_metadata: variant_type_metadata,\n-                            offset: FixedMemberOffset { bytes: 0 },\n-                            flags: DIFlags::FlagZero\n-                        }\n-                    }).collect()\n-            },\n-            layout::Univariant{ ref variant, .. } => {\n-                assert!(adt.variants.len() <= 1);\n-\n-                if adt.variants.is_empty() {\n-                    vec![]\n-                } else {\n-                    let (variant_type_metadata,\n-                         variant_llvm_type,\n-                         member_description_factory) =\n+                (0..variants.len()).map(|i| {\n+                    let variant = self.layout.for_variant(cx, i);\n+                    let (variant_type_metadata, member_desc_factory) =\n                         describe_enum_variant(cx,\n-                                              self.enum_type,\n                                               variant,\n-                                              &adt.variants[0],\n-                                              NoDiscriminant,\n+                                              &adt.variants[i],\n+                                              discriminant_info,\n                                               self.containing_scope,\n                                               self.span);\n \n-                    let member_descriptions =\n-                        member_description_factory.create_member_descriptions(cx);\n+                    let member_descriptions = member_desc_factory\n+                        .create_member_descriptions(cx);\n \n                     set_members_of_composite_type(cx,\n                                                   variant_type_metadata,\n-                                                  variant_llvm_type,\n-                                                  &member_descriptions[..]);\n-                    vec![\n-                        MemberDescription {\n-                            name: \"\".to_string(),\n-                            llvm_type: variant_llvm_type,\n-                            type_metadata: variant_type_metadata,\n-                            offset: FixedMemberOffset { bytes: 0 },\n-                            flags: DIFlags::FlagZero\n-                        }\n-                    ]\n-                }\n-            }\n-            layout::RawNullablePointer { nndiscr: non_null_variant_index, .. } => {\n-                // As far as debuginfo is concerned, the pointer this enum\n-                // represents is still wrapped in a struct. This is to make the\n-                // DWARF representation of enums uniform.\n-\n-                // First create a description of the artificial wrapper struct:\n-                let non_null_variant = &adt.variants[non_null_variant_index as usize];\n-                let non_null_variant_name = non_null_variant.name.as_str();\n-\n-                // The llvm type and metadata of the pointer\n-                let nnty = monomorphize::field_ty(cx.tcx(), &substs, &non_null_variant.fields[0] );\n-                let non_null_llvm_type = type_of::type_of(cx, nnty);\n-                let non_null_type_metadata = type_metadata(cx, nnty, self.span);\n-\n-                // The type of the artificial struct wrapping the pointer\n-                let artificial_struct_llvm_type = Type::struct_(cx,\n-                                                                &[non_null_llvm_type],\n-                                                                false);\n-\n-                // For the metadata of the wrapper struct, we need to create a\n-                // MemberDescription of the struct's single field.\n-                let sole_struct_member_description = MemberDescription {\n-                    name: match non_null_variant.ctor_kind {\n-                        CtorKind::Fn => \"__0\".to_string(),\n-                        CtorKind::Fictive => {\n-                            non_null_variant.fields[0].name.to_string()\n-                        }\n-                        CtorKind::Const => bug!()\n-                    },\n-                    llvm_type: non_null_llvm_type,\n-                    type_metadata: non_null_type_metadata,\n-                    offset: FixedMemberOffset { bytes: 0 },\n-                    flags: DIFlags::FlagZero\n-                };\n-\n-                let unique_type_id = debug_context(cx).type_map\n-                                                      .borrow_mut()\n-                                                      .get_unique_type_id_of_enum_variant(\n-                                                          cx,\n-                                                          self.enum_type,\n-                                                          &non_null_variant_name);\n-\n-                // Now we can create the metadata of the artificial struct\n-                let artificial_struct_metadata =\n-                    composite_type_metadata(cx,\n-                                            artificial_struct_llvm_type,\n-                                            &non_null_variant_name,\n-                                            unique_type_id,\n-                                            &[sole_struct_member_description],\n-                                            self.containing_scope,\n-                                            self.file_metadata,\n-                                            syntax_pos::DUMMY_SP);\n-\n-                // Encode the information about the null variant in the union\n-                // member's name.\n-                let null_variant_index = (1 - non_null_variant_index) as usize;\n-                let null_variant_name = adt.variants[null_variant_index].name;\n-                let union_member_name = format!(\"RUST$ENCODED$ENUM${}${}\",\n-                                                0,\n-                                                null_variant_name);\n-\n-                // Finally create the (singleton) list of descriptions of union\n-                // members.\n-                vec![\n+                                                  &member_descriptions);\n                     MemberDescription {\n-                        name: union_member_name,\n-                        llvm_type: artificial_struct_llvm_type,\n-                        type_metadata: artificial_struct_metadata,\n-                        offset: FixedMemberOffset { bytes: 0 },\n+                        name: \"\".to_string(),\n+                        type_metadata: variant_type_metadata,\n+                        offset: Size::from_bytes(0),\n+                        size: variant.size,\n+                        align: variant.align,\n                         flags: DIFlags::FlagZero\n                     }\n-                ]\n-            },\n-            layout::StructWrappedNullablePointer { nonnull: ref struct_def,\n-                                                nndiscr,\n-                                                ref discrfield_source, ..} => {\n+                }).collect()\n+            }\n+            layout::Variants::NicheFilling { dataful_variant, ref niche_variants, .. } => {\n+                let variant = self.layout.for_variant(cx, dataful_variant);\n                 // Create a description of the non-null variant\n-                let (variant_type_metadata, variant_llvm_type, member_description_factory) =\n+                let (variant_type_metadata, member_description_factory) =\n                     describe_enum_variant(cx,\n-                                          self.enum_type,\n-                                          struct_def,\n-                                          &adt.variants[nndiscr as usize],\n+                                          variant,\n+                                          &adt.variants[dataful_variant],\n                                           OptimizedDiscriminant,\n                                           self.containing_scope,\n                                           self.span);\n@@ -1359,42 +1202,59 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n \n                 set_members_of_composite_type(cx,\n                                               variant_type_metadata,\n-                                              variant_llvm_type,\n                                               &variant_member_descriptions[..]);\n \n                 // Encode the information about the null variant in the union\n                 // member's name.\n-                let null_variant_index = (1 - nndiscr) as usize;\n-                let null_variant_name = adt.variants[null_variant_index].name;\n-                let discrfield_source = discrfield_source.iter()\n-                                           .skip(1)\n-                                           .map(|x| x.to_string())\n-                                           .collect::<Vec<_>>().join(\"$\");\n-                let union_member_name = format!(\"RUST$ENCODED$ENUM${}${}\",\n-                                                discrfield_source,\n-                                                null_variant_name);\n+                let mut name = String::from(\"RUST$ENCODED$ENUM$\");\n+                // HACK(eddyb) the debuggers should just handle offset+size\n+                // of discriminant instead of us having to recover its path.\n+                // Right now it's not even going to work for `niche_start > 0`,\n+                // and for multiple niche variants it only supports the first.\n+                fn compute_field_path<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                                name: &mut String,\n+                                                layout: TyLayout<'tcx>,\n+                                                offset: Size,\n+                                                size: Size) {\n+                    for i in 0..layout.fields.count() {\n+                        let field_offset = layout.fields.offset(i);\n+                        if field_offset > offset {\n+                            continue;\n+                        }\n+                        let inner_offset = offset - field_offset;\n+                        let field = layout.field(ccx, i);\n+                        if inner_offset + size <= field.size {\n+                            write!(name, \"{}$\", i).unwrap();\n+                            compute_field_path(ccx, name, field, inner_offset, size);\n+                        }\n+                    }\n+                }\n+                compute_field_path(cx, &mut name,\n+                                   self.layout,\n+                                   self.layout.fields.offset(0),\n+                                   self.layout.field(cx, 0).size);\n+                name.push_str(&adt.variants[niche_variants.start].name.as_str());\n \n                 // Create the (singleton) list of descriptions of union members.\n                 vec![\n                     MemberDescription {\n-                        name: union_member_name,\n-                        llvm_type: variant_llvm_type,\n+                        name,\n                         type_metadata: variant_type_metadata,\n-                        offset: FixedMemberOffset { bytes: 0 },\n+                        offset: Size::from_bytes(0),\n+                        size: variant.size,\n+                        align: variant.align,\n                         flags: DIFlags::FlagZero\n                     }\n                 ]\n-            },\n-            layout::CEnum { .. } => span_bug!(self.span, \"This should be unreachable.\"),\n-            ref l @ _ => bug!(\"Not an enum layout: {:#?}\", l)\n+            }\n         }\n     }\n }\n \n // Creates MemberDescriptions for the fields of a single enum variant.\n struct VariantMemberDescriptionFactory<'tcx> {\n     // Cloned from the layout::Struct describing the variant.\n-    offsets: &'tcx [layout::Size],\n+    offsets: Vec<layout::Size>,\n     args: Vec<(String, Ty<'tcx>)>,\n     discriminant_type_metadata: Option<DIType>,\n     span: Span,\n@@ -1404,14 +1264,16 @@ impl<'tcx> VariantMemberDescriptionFactory<'tcx> {\n     fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n                                       -> Vec<MemberDescription> {\n         self.args.iter().enumerate().map(|(i, &(ref name, ty))| {\n+            let (size, align) = cx.size_and_align_of(ty);\n             MemberDescription {\n                 name: name.to_string(),\n-                llvm_type: type_of::type_of(cx, ty),\n                 type_metadata: match self.discriminant_type_metadata {\n                     Some(metadata) if i == 0 => metadata,\n                     _ => type_metadata(cx, ty, self.span)\n                 },\n-                offset: FixedMemberOffset { bytes: self.offsets[i].bytes() as usize },\n+                offset: self.offsets[i],\n+                size,\n+                align,\n                 flags: DIFlags::FlagZero\n             }\n         }).collect()\n@@ -1430,92 +1292,52 @@ enum EnumDiscriminantInfo {\n // descriptions of the fields of the variant. This is a rudimentary version of a\n // full RecursiveTypeDescription.\n fn describe_enum_variant<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                   enum_type: Ty<'tcx>,\n-                                   struct_def: &'tcx layout::Struct,\n+                                   layout: layout::TyLayout<'tcx>,\n                                    variant: &'tcx ty::VariantDef,\n                                    discriminant_info: EnumDiscriminantInfo,\n                                    containing_scope: DIScope,\n                                    span: Span)\n-                                   -> (DICompositeType, Type, MemberDescriptionFactory<'tcx>) {\n-    let substs = match enum_type.sty {\n-        ty::TyAdt(def, s) if def.adt_kind() == AdtKind::Enum => s,\n-        ref t @ _ => bug!(\"{:#?} is not an enum\", t)\n-    };\n-\n-    let maybe_discr_and_signed: Option<(layout::Integer, bool)> = match *cx.layout_of(enum_type) {\n-        layout::CEnum {discr, ..} => Some((discr, true)),\n-        layout::General{discr, ..} => Some((discr, false)),\n-        layout::Univariant { .. }\n-        | layout::RawNullablePointer { .. }\n-        | layout::StructWrappedNullablePointer { .. } => None,\n-        ref l @ _ => bug!(\"This should be unreachable. Type is {:#?} layout is {:#?}\", enum_type, l)\n-    };\n-\n-    let mut field_tys = variant.fields.iter().map(|f| {\n-        monomorphize::field_ty(cx.tcx(), &substs, f)\n-    }).collect::<Vec<_>>();\n-\n-    if let Some((discr, signed)) = maybe_discr_and_signed {\n-        field_tys.insert(0, discr.to_ty(&cx.tcx(), signed));\n-    }\n-\n-\n-    let variant_llvm_type =\n-        Type::struct_(cx, &field_tys\n-                                    .iter()\n-                                    .map(|t| type_of::type_of(cx, t))\n-                                    .collect::<Vec<_>>()\n-                                    ,\n-                      struct_def.packed);\n-    // Could do some consistency checks here: size, align, field count, discr type\n-\n+                                   -> (DICompositeType, MemberDescriptionFactory<'tcx>) {\n     let variant_name = variant.name.as_str();\n     let unique_type_id = debug_context(cx).type_map\n                                           .borrow_mut()\n                                           .get_unique_type_id_of_enum_variant(\n                                               cx,\n-                                              enum_type,\n+                                              layout.ty,\n                                               &variant_name);\n \n     let metadata_stub = create_struct_stub(cx,\n-                                           variant_llvm_type,\n+                                           layout.ty,\n                                            &variant_name,\n                                            unique_type_id,\n                                            containing_scope);\n \n-    // Get the argument names from the enum variant info\n-    let mut arg_names: Vec<_> = match variant.ctor_kind {\n-        CtorKind::Const => vec![],\n-        CtorKind::Fn => {\n-            variant.fields\n-                   .iter()\n-                   .enumerate()\n-                   .map(|(i, _)| format!(\"__{}\", i))\n-                   .collect()\n-        }\n-        CtorKind::Fictive => {\n-            variant.fields\n-                   .iter()\n-                   .map(|f| f.name.to_string())\n-                   .collect()\n-        }\n-    };\n-\n     // If this is not a univariant enum, there is also the discriminant field.\n-    match discriminant_info {\n-        RegularDiscriminant(_) => arg_names.insert(0, \"RUST$ENUM$DISR\".to_string()),\n-        _ => { /* do nothing */ }\n+    let (discr_offset, discr_arg) = match discriminant_info {\n+        RegularDiscriminant(_) => {\n+            let enum_layout = cx.layout_of(layout.ty);\n+            (Some(enum_layout.fields.offset(0)),\n+             Some((\"RUST$ENUM$DISR\".to_string(), enum_layout.field(cx, 0).ty)))\n+        }\n+        _ => (None, None),\n     };\n+    let offsets = discr_offset.into_iter().chain((0..layout.fields.count()).map(|i| {\n+        layout.fields.offset(i)\n+    })).collect();\n \n     // Build an array of (field name, field type) pairs to be captured in the factory closure.\n-    let args: Vec<(String, Ty)> = arg_names.iter()\n-        .zip(field_tys.iter())\n-        .map(|(s, &t)| (s.to_string(), t))\n-        .collect();\n+    let args = discr_arg.into_iter().chain((0..layout.fields.count()).map(|i| {\n+        let name = if variant.ctor_kind == CtorKind::Fn {\n+            format!(\"__{}\", i)\n+        } else {\n+            variant.fields[i].name.to_string()\n+        };\n+        (name, layout.field(cx, i).ty)\n+    })).collect();\n \n     let member_description_factory =\n         VariantMDF(VariantMemberDescriptionFactory {\n-            offsets: &struct_def.offsets[..],\n+            offsets,\n             args,\n             discriminant_type_metadata: match discriminant_info {\n                 RegularDiscriminant(discriminant_type_metadata) => {\n@@ -1526,7 +1348,7 @@ fn describe_enum_variant<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             span,\n         });\n \n-    (metadata_stub, variant_llvm_type, member_description_factory)\n+    (metadata_stub, member_description_factory)\n }\n \n fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n@@ -1562,21 +1384,18 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         })\n         .collect();\n \n-    let discriminant_type_metadata = |inttype: layout::Integer, signed: bool| {\n-        let disr_type_key = (enum_def_id, inttype);\n+    let discriminant_type_metadata = |discr: layout::Primitive| {\n+        let disr_type_key = (enum_def_id, discr);\n         let cached_discriminant_type_metadata = debug_context(cx).created_enum_disr_types\n                                                                  .borrow()\n                                                                  .get(&disr_type_key).cloned();\n         match cached_discriminant_type_metadata {\n             Some(discriminant_type_metadata) => discriminant_type_metadata,\n             None => {\n-                let discriminant_llvm_type = Type::from_integer(cx, inttype);\n                 let (discriminant_size, discriminant_align) =\n-                    size_and_align_of(cx, discriminant_llvm_type);\n+                    (discr.size(cx), discr.align(cx));\n                 let discriminant_base_type_metadata =\n-                    type_metadata(cx,\n-                                  inttype.to_ty(&cx.tcx(), signed),\n-                                  syntax_pos::DUMMY_SP);\n+                    type_metadata(cx, discr.to_ty(cx.tcx()), syntax_pos::DUMMY_SP);\n                 let discriminant_name = get_enum_discriminant_name(cx, enum_def_id);\n \n                 let name = CString::new(discriminant_name.as_bytes()).unwrap();\n@@ -1587,8 +1406,8 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                         name.as_ptr(),\n                         file_metadata,\n                         UNKNOWN_LINE_NUMBER,\n-                        bytes_to_bits(discriminant_size),\n-                        bytes_to_bits(discriminant_align),\n+                        discriminant_size.bits(),\n+                        discriminant_align.abi_bits() as u32,\n                         create_DIArray(DIB(cx), &enumerators_metadata),\n                         discriminant_base_type_metadata)\n                 };\n@@ -1602,21 +1421,22 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         }\n     };\n \n-    let type_rep = cx.layout_of(enum_type);\n+    let layout = cx.layout_of(enum_type);\n \n-    let discriminant_type_metadata = match *type_rep {\n-        layout::CEnum { discr, signed, .. } => {\n-            return FinalMetadata(discriminant_type_metadata(discr, signed))\n-        },\n-        layout::RawNullablePointer { .. }           |\n-        layout::StructWrappedNullablePointer { .. } |\n-        layout::Univariant { .. }                      => None,\n-        layout::General { discr, .. } => Some(discriminant_type_metadata(discr, false)),\n-        ref l @ _ => bug!(\"Not an enum layout: {:#?}\", l)\n+    let discriminant_type_metadata = match layout.variants {\n+        layout::Variants::Single { .. } |\n+        layout::Variants::NicheFilling { .. } => None,\n+        layout::Variants::Tagged { ref discr, .. } => {\n+            Some(discriminant_type_metadata(discr.value))\n+        }\n     };\n \n-    let enum_llvm_type = type_of::type_of(cx, enum_type);\n-    let (enum_type_size, enum_type_align) = size_and_align_of(cx, enum_llvm_type);\n+    match (&layout.abi, discriminant_type_metadata) {\n+        (&layout::Abi::Scalar(_), Some(discr)) => return FinalMetadata(discr),\n+        _ => {}\n+    }\n+\n+    let (enum_type_size, enum_type_align) = layout.size_and_align();\n \n     let enum_name = CString::new(enum_name).unwrap();\n     let unique_type_id_str = CString::new(\n@@ -1629,8 +1449,8 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         enum_name.as_ptr(),\n         file_metadata,\n         UNKNOWN_LINE_NUMBER,\n-        bytes_to_bits(enum_type_size),\n-        bytes_to_bits(enum_type_align),\n+        enum_type_size.bits(),\n+        enum_type_align.abi_bits() as u32,\n         DIFlags::FlagZero,\n         ptr::null_mut(),\n         0, // RuntimeLang\n@@ -1642,13 +1462,11 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         enum_type,\n         unique_type_id,\n         enum_metadata,\n-        enum_llvm_type,\n         EnumMDF(EnumMemberDescriptionFactory {\n             enum_type,\n-            type_rep: type_rep.layout,\n+            layout,\n             discriminant_type_metadata,\n             containing_scope,\n-            file_metadata,\n             span,\n         }),\n     );\n@@ -1664,36 +1482,34 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n /// results in a LLVM struct.\n ///\n /// Examples of Rust types to use this are: structs, tuples, boxes, vecs, and enums.\n-fn composite_type_metadata(cx: &CrateContext,\n-                           composite_llvm_type: Type,\n-                           composite_type_name: &str,\n-                           composite_type_unique_id: UniqueTypeId,\n-                           member_descriptions: &[MemberDescription],\n-                           containing_scope: DIScope,\n-\n-                           // Ignore source location information as long as it\n-                           // can't be reconstructed for non-local crates.\n-                           _file_metadata: DIFile,\n-                           _definition_span: Span)\n-                           -> DICompositeType {\n+fn composite_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                     composite_type: Ty<'tcx>,\n+                                     composite_type_name: &str,\n+                                     composite_type_unique_id: UniqueTypeId,\n+                                     member_descriptions: &[MemberDescription],\n+                                     containing_scope: DIScope,\n+\n+                                     // Ignore source location information as long as it\n+                                     // can't be reconstructed for non-local crates.\n+                                     _file_metadata: DIFile,\n+                                     _definition_span: Span)\n+                                     -> DICompositeType {\n     // Create the (empty) struct metadata node ...\n     let composite_type_metadata = create_struct_stub(cx,\n-                                                     composite_llvm_type,\n+                                                     composite_type,\n                                                      composite_type_name,\n                                                      composite_type_unique_id,\n                                                      containing_scope);\n     // ... and immediately create and add the member descriptions.\n     set_members_of_composite_type(cx,\n                                   composite_type_metadata,\n-                                  composite_llvm_type,\n                                   member_descriptions);\n \n     return composite_type_metadata;\n }\n \n fn set_members_of_composite_type(cx: &CrateContext,\n                                  composite_type_metadata: DICompositeType,\n-                                 composite_llvm_type: Type,\n                                  member_descriptions: &[MemberDescription]) {\n     // In some rare cases LLVM metadata uniquing would lead to an existing type\n     // description being used instead of a new one created in\n@@ -1714,14 +1530,7 @@ fn set_members_of_composite_type(cx: &CrateContext,\n \n     let member_metadata: Vec<DIDescriptor> = member_descriptions\n         .iter()\n-        .enumerate()\n-        .map(|(i, member_description)| {\n-            let (member_size, member_align) = size_and_align_of(cx, member_description.llvm_type);\n-            let member_offset = match member_description.offset {\n-                FixedMemberOffset { bytes } => bytes as u64,\n-                ComputedMemberOffset => machine::llelement_offset(cx, composite_llvm_type, i)\n-            };\n-\n+        .map(|member_description| {\n             let member_name = member_description.name.as_bytes();\n             let member_name = CString::new(member_name).unwrap();\n             unsafe {\n@@ -1731,9 +1540,9 @@ fn set_members_of_composite_type(cx: &CrateContext,\n                     member_name.as_ptr(),\n                     unknown_file_metadata(cx),\n                     UNKNOWN_LINE_NUMBER,\n-                    bytes_to_bits(member_size),\n-                    bytes_to_bits(member_align),\n-                    bytes_to_bits(member_offset),\n+                    member_description.size.bits(),\n+                    member_description.align.abi_bits() as u32,\n+                    member_description.offset.bits(),\n                     member_description.flags,\n                     member_description.type_metadata)\n             }\n@@ -1750,13 +1559,13 @@ fn set_members_of_composite_type(cx: &CrateContext,\n // A convenience wrapper around LLVMRustDIBuilderCreateStructType(). Does not do\n // any caching, does not add any fields to the struct. This can be done later\n // with set_members_of_composite_type().\n-fn create_struct_stub(cx: &CrateContext,\n-                      struct_llvm_type: Type,\n-                      struct_type_name: &str,\n-                      unique_type_id: UniqueTypeId,\n-                      containing_scope: DIScope)\n-                   -> DICompositeType {\n-    let (struct_size, struct_align) = size_and_align_of(cx, struct_llvm_type);\n+fn create_struct_stub<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                struct_type: Ty<'tcx>,\n+                                struct_type_name: &str,\n+                                unique_type_id: UniqueTypeId,\n+                                containing_scope: DIScope)\n+                                -> DICompositeType {\n+    let (struct_size, struct_align) = cx.size_and_align_of(struct_type);\n \n     let name = CString::new(struct_type_name).unwrap();\n     let unique_type_id = CString::new(\n@@ -1774,8 +1583,8 @@ fn create_struct_stub(cx: &CrateContext,\n             name.as_ptr(),\n             unknown_file_metadata(cx),\n             UNKNOWN_LINE_NUMBER,\n-            bytes_to_bits(struct_size),\n-            bytes_to_bits(struct_align),\n+            struct_size.bits(),\n+            struct_align.abi_bits() as u32,\n             DIFlags::FlagZero,\n             ptr::null_mut(),\n             empty_array,\n@@ -1787,13 +1596,13 @@ fn create_struct_stub(cx: &CrateContext,\n     return metadata_stub;\n }\n \n-fn create_union_stub(cx: &CrateContext,\n-                     union_llvm_type: Type,\n-                     union_type_name: &str,\n-                     unique_type_id: UniqueTypeId,\n-                     containing_scope: DIScope)\n-                   -> DICompositeType {\n-    let (union_size, union_align) = size_and_align_of(cx, union_llvm_type);\n+fn create_union_stub<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                               union_type: Ty<'tcx>,\n+                               union_type_name: &str,\n+                               unique_type_id: UniqueTypeId,\n+                               containing_scope: DIScope)\n+                               -> DICompositeType {\n+    let (union_size, union_align) = cx.size_and_align_of(union_type);\n \n     let name = CString::new(union_type_name).unwrap();\n     let unique_type_id = CString::new(\n@@ -1811,8 +1620,8 @@ fn create_union_stub(cx: &CrateContext,\n             name.as_ptr(),\n             unknown_file_metadata(cx),\n             UNKNOWN_LINE_NUMBER,\n-            bytes_to_bits(union_size),\n-            bytes_to_bits(union_align),\n+            union_size.bits(),\n+            union_align.abi_bits() as u32,\n             DIFlags::FlagZero,\n             empty_array,\n             0, // RuntimeLang\n@@ -1867,7 +1676,7 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n                                                     is_local_to_unit,\n                                                     global,\n                                                     ptr::null_mut(),\n-                                                    global_align,\n+                                                    global_align.abi() as u32,\n         );\n     }\n }\n@@ -1899,8 +1708,6 @@ pub fn create_vtable_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     }\n \n     let type_metadata = type_metadata(cx, ty, syntax_pos::DUMMY_SP);\n-    let llvm_vtable_type = Type::vtable_ptr(cx).element_type();\n-    let (struct_size, struct_align) = size_and_align_of(cx, llvm_vtable_type);\n \n     unsafe {\n         // LLVMRustDIBuilderCreateStructType() wants an empty array. A null\n@@ -1919,8 +1726,8 @@ pub fn create_vtable_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             name.as_ptr(),\n             unknown_file_metadata(cx),\n             UNKNOWN_LINE_NUMBER,\n-            bytes_to_bits(struct_size),\n-            bytes_to_bits(struct_align),\n+            Size::from_bytes(0).bits(),\n+            cx.tcx().data_layout.pointer_align.abi_bits() as u32,\n             DIFlags::FlagArtificial,\n             ptr::null_mut(),\n             empty_array,"}, {"sha": "c0df25202d8a9379f2730cf27ae7813ebdc59233", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -43,7 +43,7 @@ use std::ptr;\n use syntax_pos::{self, Span, Pos};\n use syntax::ast;\n use syntax::symbol::Symbol;\n-use rustc::ty::layout::{self, LayoutTyper};\n+use rustc::ty::layout::{self, LayoutOf};\n \n pub mod gdb;\n mod utils;\n@@ -71,7 +71,7 @@ pub struct CrateDebugContext<'tcx> {\n     llmod: ModuleRef,\n     builder: DIBuilderRef,\n     created_files: RefCell<FxHashMap<(Symbol, Symbol), DIFile>>,\n-    created_enum_disr_types: RefCell<FxHashMap<(DefId, layout::Integer), DIType>>,\n+    created_enum_disr_types: RefCell<FxHashMap<(DefId, layout::Primitive), DIType>>,\n \n     type_map: RefCell<TypeMap<'tcx>>,\n     namespace_map: RefCell<DefIdMap<DIScope>>,\n@@ -335,8 +335,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             signature.extend(inputs.iter().map(|&t| {\n                 let t = match t.sty {\n                     ty::TyArray(ct, _)\n-                        if (ct == cx.tcx().types.u8) ||\n-                           (cx.layout_of(ct).size(cx).bytes() == 0) => {\n+                        if (ct == cx.tcx().types.u8) || cx.layout_of(ct).is_zst() => {\n                         cx.tcx().mk_imm_ptr(ct)\n                     }\n                     _ => t\n@@ -499,7 +498,7 @@ pub fn declare_local<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                     cx.sess().opts.optimize != config::OptLevel::No,\n                     DIFlags::FlagZero,\n                     argument_index,\n-                    align,\n+                    align.abi() as u32,\n                 )\n             };\n             source_loc::set_debug_location(bcx,"}, {"sha": "95427d9b3cd4e76a8f1606b75e98be0092b50858", "filename": "src/librustc_trans/debuginfo/utils.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -18,15 +18,11 @@ use rustc::ty::DefIdTree;\n \n use llvm;\n use llvm::debuginfo::{DIScope, DIBuilderRef, DIDescriptor, DIArray};\n-use machine;\n use common::{CrateContext};\n-use type_::Type;\n \n use syntax_pos::{self, Span};\n use syntax::ast;\n \n-use std::ops;\n-\n pub fn is_node_local_to_unit(cx: &CrateContext, node_id: ast::NodeId) -> bool\n {\n     // The is_local_to_unit flag indicates whether a function is local to the\n@@ -53,15 +49,6 @@ pub fn span_start(cx: &CrateContext, span: Span) -> syntax_pos::Loc {\n     cx.sess().codemap().lookup_char_pos(span.lo())\n }\n \n-pub fn size_and_align_of(cx: &CrateContext, llvm_type: Type) -> (u64, u32) {\n-    (machine::llsize_of_alloc(cx, llvm_type), machine::llalign_of_min(cx, llvm_type))\n-}\n-\n-pub fn bytes_to_bits<T>(bytes: T) -> T\n-    where T: ops::Mul<Output=T> + From<u8> {\n-    bytes * 8u8.into()\n-}\n-\n #[inline]\n pub fn debug_context<'a, 'tcx>(cx: &'a CrateContext<'a, 'tcx>)\n                            -> &'a CrateDebugContext<'tcx> {"}, {"sha": "6c7d7700adeb28b9b043e02c7c9a18a5ecaa4f44", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 22, "deletions": 37, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -19,8 +19,7 @@ use common::*;\n use llvm::{ValueRef};\n use llvm;\n use meth;\n-use monomorphize;\n-use rustc::ty::layout::LayoutTyper;\n+use rustc::ty::layout::LayoutOf;\n use rustc::ty::{self, Ty};\n use value::Value;\n \n@@ -29,17 +28,28 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, inf\n     debug!(\"calculate size of DST: {}; with lost info: {:?}\",\n            t, Value(info));\n     if bcx.ccx.shared().type_is_sized(t) {\n-        let size = bcx.ccx.size_of(t);\n-        let align = bcx.ccx.align_of(t);\n-        debug!(\"size_and_align_of_dst t={} info={:?} size: {} align: {}\",\n+        let (size, align) = bcx.ccx.size_and_align_of(t);\n+        debug!(\"size_and_align_of_dst t={} info={:?} size: {:?} align: {:?}\",\n                t, Value(info), size, align);\n-        let size = C_usize(bcx.ccx, size);\n-        let align = C_usize(bcx.ccx, align as u64);\n+        let size = C_usize(bcx.ccx, size.bytes());\n+        let align = C_usize(bcx.ccx, align.abi());\n         return (size, align);\n     }\n     assert!(!info.is_null());\n     match t.sty {\n-        ty::TyAdt(..) | ty::TyTuple(..) => {\n+        ty::TyDynamic(..) => {\n+            // load size/align from vtable\n+            (meth::SIZE.get_usize(bcx, info), meth::ALIGN.get_usize(bcx, info))\n+        }\n+        ty::TySlice(_) | ty::TyStr => {\n+            let unit = t.sequence_element_type(bcx.tcx());\n+            // The info in this case is the length of the str, so the size is that\n+            // times the unit size.\n+            let (size, align) = bcx.ccx.size_and_align_of(unit);\n+            (bcx.mul(info, C_usize(bcx.ccx, size.bytes())),\n+             C_usize(bcx.ccx, align.abi()))\n+        }\n+        _ => {\n             let ccx = bcx.ccx;\n             // First get the size of all statically known fields.\n             // Don't use size_of because it also rounds up to alignment, which we\n@@ -48,30 +58,17 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, inf\n             let layout = ccx.layout_of(t);\n             debug!(\"DST {} layout: {:?}\", t, layout);\n \n-            let (sized_size, sized_align) = match *layout {\n-                ty::layout::Layout::Univariant { ref variant, .. } => {\n-                    (variant.offsets.last().map_or(0, |o| o.bytes()), variant.align.abi())\n-                }\n-                _ => {\n-                    bug!(\"size_and_align_of_dst: expcted Univariant for `{}`, found {:#?}\",\n-                         t, layout);\n-                }\n-            };\n+            let i = layout.fields.count() - 1;\n+            let sized_size = layout.fields.offset(i).bytes();\n+            let sized_align = layout.align.abi();\n             debug!(\"DST {} statically sized prefix size: {} align: {}\",\n                    t, sized_size, sized_align);\n             let sized_size = C_usize(ccx, sized_size);\n             let sized_align = C_usize(ccx, sized_align);\n \n             // Recurse to get the size of the dynamically sized field (must be\n             // the last field).\n-            let field_ty = match t.sty {\n-                ty::TyAdt(def, substs) => {\n-                    let last_field = def.struct_variant().fields.last().unwrap();\n-                    monomorphize::field_ty(bcx.tcx(), substs, last_field)\n-                },\n-                ty::TyTuple(tys, _) => tys.last().unwrap(),\n-                _ => unreachable!(),\n-            };\n+            let field_ty = layout.field(ccx, i).ty;\n             let (unsized_size, unsized_align) = size_and_align_of_dst(bcx, field_ty, info);\n \n             // FIXME (#26403, #27023): We should be adding padding\n@@ -114,17 +111,5 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, inf\n \n             (size, align)\n         }\n-        ty::TyDynamic(..) => {\n-            // load size/align from vtable\n-            (meth::SIZE.get_usize(bcx, info), meth::ALIGN.get_usize(bcx, info))\n-        }\n-        ty::TySlice(_) | ty::TyStr => {\n-            let unit = t.sequence_element_type(bcx.tcx());\n-            // The info in this case is the length of the str, so the size is that\n-            // times the unit size.\n-            (bcx.mul(info, C_usize(bcx.ccx, bcx.ccx.size_of(unit))),\n-             C_usize(bcx.ccx, bcx.ccx.align_of(unit) as u64))\n-        }\n-        _ => bug!(\"Unexpected unsized type, found {}\", t)\n     }\n }"}, {"sha": "adbb45f893b08778d763e5a6e042d01c04437a97", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 258, "deletions": 258, "changes": 516, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -11,20 +11,19 @@\n #![allow(non_upper_case_globals)]\n \n use intrinsics::{self, Intrinsic};\n-use libc;\n use llvm;\n use llvm::{ValueRef};\n-use abi::{Abi, FnType};\n-use adt;\n+use abi::{Abi, FnType, PassMode};\n use mir::lvalue::{LvalueRef, Alignment};\n+use mir::operand::{OperandRef, OperandValue};\n use base::*;\n use common::*;\n use declare;\n use glue;\n-use type_of;\n-use machine;\n use type_::Type;\n+use type_of::LayoutLlvmExt;\n use rustc::ty::{self, Ty};\n+use rustc::ty::layout::{HasDataLayout, LayoutOf};\n use rustc::hir;\n use syntax::ast;\n use syntax::symbol::Symbol;\n@@ -88,8 +87,8 @@ fn get_simple_intrinsic(ccx: &CrateContext, name: &str) -> Option<ValueRef> {\n /// add them to librustc_trans/trans/context.rs\n pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                                       callee_ty: Ty<'tcx>,\n-                                      fn_ty: &FnType,\n-                                      llargs: &[ValueRef],\n+                                      fn_ty: &FnType<'tcx>,\n+                                      args: &[OperandRef<'tcx>],\n                                       llresult: ValueRef,\n                                       span: Span) {\n     let ccx = bcx.ccx;\n@@ -106,70 +105,70 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n     let ret_ty = sig.output();\n     let name = &*tcx.item_name(def_id);\n \n-    let llret_ty = type_of::type_of(ccx, ret_ty);\n+    let llret_ty = ccx.layout_of(ret_ty).llvm_type(ccx);\n+    let result = LvalueRef::new_sized(llresult, fn_ty.ret.layout, Alignment::AbiAligned);\n \n     let simple = get_simple_intrinsic(ccx, name);\n     let llval = match name {\n         _ if simple.is_some() => {\n-            bcx.call(simple.unwrap(), &llargs, None)\n+            bcx.call(simple.unwrap(),\n+                     &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(),\n+                     None)\n         }\n         \"unreachable\" => {\n             return;\n         },\n         \"likely\" => {\n             let expect = ccx.get_intrinsic(&(\"llvm.expect.i1\"));\n-            bcx.call(expect, &[llargs[0], C_bool(ccx, true)], None)\n+            bcx.call(expect, &[args[0].immediate(), C_bool(ccx, true)], None)\n         }\n         \"unlikely\" => {\n             let expect = ccx.get_intrinsic(&(\"llvm.expect.i1\"));\n-            bcx.call(expect, &[llargs[0], C_bool(ccx, false)], None)\n+            bcx.call(expect, &[args[0].immediate(), C_bool(ccx, false)], None)\n         }\n         \"try\" => {\n-            try_intrinsic(bcx, ccx, llargs[0], llargs[1], llargs[2], llresult);\n-            C_nil(ccx)\n+            try_intrinsic(bcx, ccx,\n+                          args[0].immediate(),\n+                          args[1].immediate(),\n+                          args[2].immediate(),\n+                          llresult);\n+            return;\n         }\n         \"breakpoint\" => {\n             let llfn = ccx.get_intrinsic(&(\"llvm.debugtrap\"));\n             bcx.call(llfn, &[], None)\n         }\n         \"size_of\" => {\n             let tp_ty = substs.type_at(0);\n-            let lltp_ty = type_of::type_of(ccx, tp_ty);\n-            C_usize(ccx, machine::llsize_of_alloc(ccx, lltp_ty))\n+            C_usize(ccx, ccx.size_of(tp_ty).bytes())\n         }\n         \"size_of_val\" => {\n             let tp_ty = substs.type_at(0);\n-            if bcx.ccx.shared().type_is_sized(tp_ty) {\n-                let lltp_ty = type_of::type_of(ccx, tp_ty);\n-                C_usize(ccx, machine::llsize_of_alloc(ccx, lltp_ty))\n-            } else if bcx.ccx.shared().type_has_metadata(tp_ty) {\n+            if let OperandValue::Pair(_, meta) = args[0].val {\n                 let (llsize, _) =\n-                    glue::size_and_align_of_dst(bcx, tp_ty, llargs[1]);\n+                    glue::size_and_align_of_dst(bcx, tp_ty, meta);\n                 llsize\n             } else {\n-                C_usize(ccx, 0u64)\n+                C_usize(ccx, ccx.size_of(tp_ty).bytes())\n             }\n         }\n         \"min_align_of\" => {\n             let tp_ty = substs.type_at(0);\n-            C_usize(ccx, ccx.align_of(tp_ty) as u64)\n+            C_usize(ccx, ccx.align_of(tp_ty).abi())\n         }\n         \"min_align_of_val\" => {\n             let tp_ty = substs.type_at(0);\n-            if bcx.ccx.shared().type_is_sized(tp_ty) {\n-                C_usize(ccx, ccx.align_of(tp_ty) as u64)\n-            } else if bcx.ccx.shared().type_has_metadata(tp_ty) {\n+            if let OperandValue::Pair(_, meta) = args[0].val {\n                 let (_, llalign) =\n-                    glue::size_and_align_of_dst(bcx, tp_ty, llargs[1]);\n+                    glue::size_and_align_of_dst(bcx, tp_ty, meta);\n                 llalign\n             } else {\n-                C_usize(ccx, 1u64)\n+                C_usize(ccx, ccx.align_of(tp_ty).abi())\n             }\n         }\n         \"pref_align_of\" => {\n             let tp_ty = substs.type_at(0);\n-            let lltp_ty = type_of::type_of(ccx, tp_ty);\n-            C_usize(ccx, machine::llalign_of_pref(ccx, lltp_ty) as u64)\n+            C_usize(ccx, ccx.align_of(tp_ty).pref())\n         }\n         \"type_name\" => {\n             let tp_ty = substs.type_at(0);\n@@ -181,88 +180,94 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n         }\n         \"init\" => {\n             let ty = substs.type_at(0);\n-            if !type_is_zero_size(ccx, ty) {\n+            if !ccx.layout_of(ty).is_zst() {\n                 // Just zero out the stack slot.\n                 // If we store a zero constant, LLVM will drown in vreg allocation for large data\n                 // structures, and the generated code will be awful. (A telltale sign of this is\n                 // large quantities of `mov [byte ptr foo],0` in the generated code.)\n                 memset_intrinsic(bcx, false, ty, llresult, C_u8(ccx, 0), C_usize(ccx, 1));\n             }\n-            C_nil(ccx)\n+            return;\n         }\n         // Effectively no-ops\n         \"uninit\" => {\n-            C_nil(ccx)\n+            return;\n         }\n         \"needs_drop\" => {\n             let tp_ty = substs.type_at(0);\n \n             C_bool(ccx, bcx.ccx.shared().type_needs_drop(tp_ty))\n         }\n         \"offset\" => {\n-            let ptr = llargs[0];\n-            let offset = llargs[1];\n+            let ptr = args[0].immediate();\n+            let offset = args[1].immediate();\n             bcx.inbounds_gep(ptr, &[offset])\n         }\n         \"arith_offset\" => {\n-            let ptr = llargs[0];\n-            let offset = llargs[1];\n+            let ptr = args[0].immediate();\n+            let offset = args[1].immediate();\n             bcx.gep(ptr, &[offset])\n         }\n \n         \"copy_nonoverlapping\" => {\n-            copy_intrinsic(bcx, false, false, substs.type_at(0), llargs[1], llargs[0], llargs[2])\n+            copy_intrinsic(bcx, false, false, substs.type_at(0),\n+                           args[1].immediate(), args[0].immediate(), args[2].immediate())\n         }\n         \"copy\" => {\n-            copy_intrinsic(bcx, true, false, substs.type_at(0), llargs[1], llargs[0], llargs[2])\n+            copy_intrinsic(bcx, true, false, substs.type_at(0),\n+                           args[1].immediate(), args[0].immediate(), args[2].immediate())\n         }\n         \"write_bytes\" => {\n-            memset_intrinsic(bcx, false, substs.type_at(0), llargs[0], llargs[1], llargs[2])\n+            memset_intrinsic(bcx, false, substs.type_at(0),\n+                             args[0].immediate(), args[1].immediate(), args[2].immediate())\n         }\n \n         \"volatile_copy_nonoverlapping_memory\" => {\n-            copy_intrinsic(bcx, false, true, substs.type_at(0), llargs[0], llargs[1], llargs[2])\n+            copy_intrinsic(bcx, false, true, substs.type_at(0),\n+                           args[0].immediate(), args[1].immediate(), args[2].immediate())\n         }\n         \"volatile_copy_memory\" => {\n-            copy_intrinsic(bcx, true, true, substs.type_at(0), llargs[0], llargs[1], llargs[2])\n+            copy_intrinsic(bcx, true, true, substs.type_at(0),\n+                           args[0].immediate(), args[1].immediate(), args[2].immediate())\n         }\n         \"volatile_set_memory\" => {\n-            memset_intrinsic(bcx, true, substs.type_at(0), llargs[0], llargs[1], llargs[2])\n+            memset_intrinsic(bcx, true, substs.type_at(0),\n+                             args[0].immediate(), args[1].immediate(), args[2].immediate())\n         }\n         \"volatile_load\" => {\n             let tp_ty = substs.type_at(0);\n-            let mut ptr = llargs[0];\n-            if let Some(ty) = fn_ty.ret.cast {\n-                ptr = bcx.pointercast(ptr, ty.ptr_to());\n+            let mut ptr = args[0].immediate();\n+            if let PassMode::Cast(ty) = fn_ty.ret.mode {\n+                ptr = bcx.pointercast(ptr, ty.llvm_type(ccx).ptr_to());\n             }\n             let load = bcx.volatile_load(ptr);\n             unsafe {\n-                llvm::LLVMSetAlignment(load, ccx.align_of(tp_ty));\n+                llvm::LLVMSetAlignment(load, ccx.align_of(tp_ty).abi() as u32);\n             }\n-            to_immediate(bcx, load, tp_ty)\n+            to_immediate(bcx, load, ccx.layout_of(tp_ty))\n         },\n         \"volatile_store\" => {\n             let tp_ty = substs.type_at(0);\n-            if type_is_fat_ptr(bcx.ccx, tp_ty) {\n-                bcx.volatile_store(llargs[1], get_dataptr(bcx, llargs[0]));\n-                bcx.volatile_store(llargs[2], get_meta(bcx, llargs[0]));\n+            let dst = args[0].deref(bcx.ccx);\n+            if let OperandValue::Pair(a, b) = args[1].val {\n+                bcx.volatile_store(a, dst.project_field(bcx, 0).llval);\n+                bcx.volatile_store(b, dst.project_field(bcx, 1).llval);\n             } else {\n-                let val = if fn_ty.args[1].is_indirect() {\n-                    bcx.load(llargs[1], None)\n+                let val = if let OperandValue::Ref(ptr, align) = args[1].val {\n+                    bcx.load(ptr, align.non_abi())\n                 } else {\n-                    if !type_is_zero_size(ccx, tp_ty) {\n-                        from_immediate(bcx, llargs[1])\n-                    } else {\n-                        C_nil(ccx)\n+                    if dst.layout.is_zst() {\n+                        return;\n                     }\n+                    from_immediate(bcx, args[1].immediate())\n                 };\n-                let ptr = bcx.pointercast(llargs[0], val_ty(val).ptr_to());\n+                let ptr = bcx.pointercast(dst.llval, val_ty(val).ptr_to());\n                 let store = bcx.volatile_store(val, ptr);\n                 unsafe {\n-                    llvm::LLVMSetAlignment(store, ccx.align_of(tp_ty));\n+                    llvm::LLVMSetAlignment(store, ccx.align_of(tp_ty).abi() as u32);\n                 }\n             }\n-            C_nil(ccx)\n+            return;\n         },\n         \"prefetch_read_data\" | \"prefetch_write_data\" |\n         \"prefetch_read_instruction\" | \"prefetch_write_instruction\" => {\n@@ -274,35 +279,40 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                 \"prefetch_write_instruction\" => (1, 0),\n                 _ => bug!()\n             };\n-            bcx.call(expect, &[llargs[0], C_i32(ccx, rw), llargs[1], C_i32(ccx, cache_type)], None)\n+            bcx.call(expect, &[\n+                args[0].immediate(),\n+                C_i32(ccx, rw),\n+                args[1].immediate(),\n+                C_i32(ccx, cache_type)\n+            ], None)\n         },\n         \"ctlz\" | \"ctlz_nonzero\" | \"cttz\" | \"cttz_nonzero\" | \"ctpop\" | \"bswap\" |\n         \"add_with_overflow\" | \"sub_with_overflow\" | \"mul_with_overflow\" |\n         \"overflowing_add\" | \"overflowing_sub\" | \"overflowing_mul\" |\n         \"unchecked_div\" | \"unchecked_rem\" | \"unchecked_shl\" | \"unchecked_shr\" => {\n-            let sty = &arg_tys[0].sty;\n-            match int_type_width_signed(sty, ccx) {\n+            let ty = arg_tys[0];\n+            match int_type_width_signed(ty, ccx) {\n                 Some((width, signed)) =>\n                     match name {\n                         \"ctlz\" | \"cttz\" => {\n                             let y = C_bool(bcx.ccx, false);\n                             let llfn = ccx.get_intrinsic(&format!(\"llvm.{}.i{}\", name, width));\n-                            bcx.call(llfn, &[llargs[0], y], None)\n+                            bcx.call(llfn, &[args[0].immediate(), y], None)\n                         }\n                         \"ctlz_nonzero\" | \"cttz_nonzero\" => {\n                             let y = C_bool(bcx.ccx, true);\n                             let llvm_name = &format!(\"llvm.{}.i{}\", &name[..4], width);\n                             let llfn = ccx.get_intrinsic(llvm_name);\n-                            bcx.call(llfn, &[llargs[0], y], None)\n+                            bcx.call(llfn, &[args[0].immediate(), y], None)\n                         }\n                         \"ctpop\" => bcx.call(ccx.get_intrinsic(&format!(\"llvm.ctpop.i{}\", width)),\n-                                        &llargs, None),\n+                                        &[args[0].immediate()], None),\n                         \"bswap\" => {\n                             if width == 8 {\n-                                llargs[0] // byte swap a u8/i8 is just a no-op\n+                                args[0].immediate() // byte swap a u8/i8 is just a no-op\n                             } else {\n                                 bcx.call(ccx.get_intrinsic(&format!(\"llvm.bswap.i{}\", width)),\n-                                        &llargs, None)\n+                                        &[args[0].immediate()], None)\n                             }\n                         }\n                         \"add_with_overflow\" | \"sub_with_overflow\" | \"mul_with_overflow\" => {\n@@ -312,44 +322,50 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                             let llfn = bcx.ccx.get_intrinsic(&intrinsic);\n \n                             // Convert `i1` to a `bool`, and write it to the out parameter\n-                            let val = bcx.call(llfn, &[llargs[0], llargs[1]], None);\n-                            let result = bcx.extract_value(val, 0);\n-                            let overflow = bcx.zext(bcx.extract_value(val, 1), Type::bool(ccx));\n-                            bcx.store(result, bcx.struct_gep(llresult, 0), None);\n-                            bcx.store(overflow, bcx.struct_gep(llresult, 1), None);\n-\n-                            C_nil(bcx.ccx)\n+                            let pair = bcx.call(llfn, &[\n+                                args[0].immediate(),\n+                                args[1].immediate()\n+                            ], None);\n+                            let val = bcx.extract_value(pair, 0);\n+                            let overflow = bcx.zext(bcx.extract_value(pair, 1), Type::bool(ccx));\n+\n+                            let dest = result.project_field(bcx, 0);\n+                            bcx.store(val, dest.llval, dest.alignment.non_abi());\n+                            let dest = result.project_field(bcx, 1);\n+                            bcx.store(overflow, dest.llval, dest.alignment.non_abi());\n+\n+                            return;\n                         },\n-                        \"overflowing_add\" => bcx.add(llargs[0], llargs[1]),\n-                        \"overflowing_sub\" => bcx.sub(llargs[0], llargs[1]),\n-                        \"overflowing_mul\" => bcx.mul(llargs[0], llargs[1]),\n+                        \"overflowing_add\" => bcx.add(args[0].immediate(), args[1].immediate()),\n+                        \"overflowing_sub\" => bcx.sub(args[0].immediate(), args[1].immediate()),\n+                        \"overflowing_mul\" => bcx.mul(args[0].immediate(), args[1].immediate()),\n                         \"unchecked_div\" =>\n                             if signed {\n-                                bcx.sdiv(llargs[0], llargs[1])\n+                                bcx.sdiv(args[0].immediate(), args[1].immediate())\n                             } else {\n-                                bcx.udiv(llargs[0], llargs[1])\n+                                bcx.udiv(args[0].immediate(), args[1].immediate())\n                             },\n                         \"unchecked_rem\" =>\n                             if signed {\n-                                bcx.srem(llargs[0], llargs[1])\n+                                bcx.srem(args[0].immediate(), args[1].immediate())\n                             } else {\n-                                bcx.urem(llargs[0], llargs[1])\n+                                bcx.urem(args[0].immediate(), args[1].immediate())\n                             },\n-                        \"unchecked_shl\" => bcx.shl(llargs[0], llargs[1]),\n+                        \"unchecked_shl\" => bcx.shl(args[0].immediate(), args[1].immediate()),\n                         \"unchecked_shr\" =>\n                             if signed {\n-                                bcx.ashr(llargs[0], llargs[1])\n+                                bcx.ashr(args[0].immediate(), args[1].immediate())\n                             } else {\n-                                bcx.lshr(llargs[0], llargs[1])\n+                                bcx.lshr(args[0].immediate(), args[1].immediate())\n                             },\n                         _ => bug!(),\n                     },\n                 None => {\n                     span_invalid_monomorphization_error(\n                         tcx.sess, span,\n                         &format!(\"invalid monomorphization of `{}` intrinsic: \\\n-                                  expected basic integer type, found `{}`\", name, sty));\n-                        C_nil(ccx)\n+                                  expected basic integer type, found `{}`\", name, ty));\n+                    return;\n                 }\n             }\n \n@@ -359,52 +375,49 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             match float_type_width(sty) {\n                 Some(_width) =>\n                     match name {\n-                        \"fadd_fast\" => bcx.fadd_fast(llargs[0], llargs[1]),\n-                        \"fsub_fast\" => bcx.fsub_fast(llargs[0], llargs[1]),\n-                        \"fmul_fast\" => bcx.fmul_fast(llargs[0], llargs[1]),\n-                        \"fdiv_fast\" => bcx.fdiv_fast(llargs[0], llargs[1]),\n-                        \"frem_fast\" => bcx.frem_fast(llargs[0], llargs[1]),\n+                        \"fadd_fast\" => bcx.fadd_fast(args[0].immediate(), args[1].immediate()),\n+                        \"fsub_fast\" => bcx.fsub_fast(args[0].immediate(), args[1].immediate()),\n+                        \"fmul_fast\" => bcx.fmul_fast(args[0].immediate(), args[1].immediate()),\n+                        \"fdiv_fast\" => bcx.fdiv_fast(args[0].immediate(), args[1].immediate()),\n+                        \"frem_fast\" => bcx.frem_fast(args[0].immediate(), args[1].immediate()),\n                         _ => bug!(),\n                     },\n                 None => {\n                     span_invalid_monomorphization_error(\n                         tcx.sess, span,\n                         &format!(\"invalid monomorphization of `{}` intrinsic: \\\n                                   expected basic float type, found `{}`\", name, sty));\n-                        C_nil(ccx)\n+                    return;\n                 }\n             }\n \n         },\n \n         \"discriminant_value\" => {\n-            let val_ty = substs.type_at(0);\n-            match val_ty.sty {\n-                ty::TyAdt(adt, ..) if adt.is_enum() => {\n-                    adt::trans_get_discr(bcx, val_ty, llargs[0], Alignment::AbiAligned,\n-                                         Some(llret_ty), true)\n-                }\n-                _ => C_null(llret_ty)\n-            }\n+            args[0].deref(bcx.ccx).trans_get_discr(bcx, ret_ty)\n         }\n \n         \"align_offset\" => {\n             // `ptr as usize`\n-            let ptr_val = bcx.ptrtoint(llargs[0], bcx.ccx.isize_ty());\n+            let ptr_val = bcx.ptrtoint(args[0].immediate(), bcx.ccx.isize_ty());\n             // `ptr_val % align`\n-            let offset = bcx.urem(ptr_val, llargs[1]);\n+            let align = args[1].immediate();\n+            let offset = bcx.urem(ptr_val, align);\n             let zero = C_null(bcx.ccx.isize_ty());\n             // `offset == 0`\n             let is_zero = bcx.icmp(llvm::IntPredicate::IntEQ, offset, zero);\n             // `if offset == 0 { 0 } else { offset - align }`\n-            bcx.select(is_zero, zero, bcx.sub(offset, llargs[1]))\n+            bcx.select(is_zero, zero, bcx.sub(offset, align))\n         }\n         name if name.starts_with(\"simd_\") => {\n-            generic_simd_intrinsic(bcx, name,\n-                                   callee_ty,\n-                                   &llargs,\n-                                   ret_ty, llret_ty,\n-                                   span)\n+            match generic_simd_intrinsic(bcx, name,\n+                                         callee_ty,\n+                                         args,\n+                                         ret_ty, llret_ty,\n+                                         span) {\n+                Ok(llval) => llval,\n+                Err(()) => return\n+            }\n         }\n         // This requires that atomic intrinsics follow a specific naming pattern:\n         // \"atomic_<operation>[_<ordering>]\", and no ordering means SeqCst\n@@ -438,57 +451,66 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                 _ => ccx.sess().fatal(\"Atomic intrinsic not in correct format\"),\n             };\n \n-            let invalid_monomorphization = |sty| {\n+            let invalid_monomorphization = |ty| {\n                 span_invalid_monomorphization_error(tcx.sess, span,\n                     &format!(\"invalid monomorphization of `{}` intrinsic: \\\n-                              expected basic integer type, found `{}`\", name, sty));\n+                              expected basic integer type, found `{}`\", name, ty));\n             };\n \n             match split[1] {\n                 \"cxchg\" | \"cxchgweak\" => {\n-                    let sty = &substs.type_at(0).sty;\n-                    if int_type_width_signed(sty, ccx).is_some() {\n+                    let ty = substs.type_at(0);\n+                    if int_type_width_signed(ty, ccx).is_some() {\n                         let weak = if split[1] == \"cxchgweak\" { llvm::True } else { llvm::False };\n-                        let val = bcx.atomic_cmpxchg(llargs[0], llargs[1], llargs[2], order,\n-                            failorder, weak);\n-                        let result = bcx.extract_value(val, 0);\n-                        let success = bcx.zext(bcx.extract_value(val, 1), Type::bool(bcx.ccx));\n-                        bcx.store(result, bcx.struct_gep(llresult, 0), None);\n-                        bcx.store(success, bcx.struct_gep(llresult, 1), None);\n+                        let pair = bcx.atomic_cmpxchg(\n+                            args[0].immediate(),\n+                            args[1].immediate(),\n+                            args[2].immediate(),\n+                            order,\n+                            failorder,\n+                            weak);\n+                        let val = bcx.extract_value(pair, 0);\n+                        let success = bcx.zext(bcx.extract_value(pair, 1), Type::bool(bcx.ccx));\n+\n+                        let dest = result.project_field(bcx, 0);\n+                        bcx.store(val, dest.llval, dest.alignment.non_abi());\n+                        let dest = result.project_field(bcx, 1);\n+                        bcx.store(success, dest.llval, dest.alignment.non_abi());\n+                        return;\n                     } else {\n-                        invalid_monomorphization(sty);\n+                        return invalid_monomorphization(ty);\n                     }\n-                    C_nil(ccx)\n                 }\n \n                 \"load\" => {\n-                    let sty = &substs.type_at(0).sty;\n-                    if int_type_width_signed(sty, ccx).is_some() {\n-                        bcx.atomic_load(llargs[0], order)\n+                    let ty = substs.type_at(0);\n+                    if int_type_width_signed(ty, ccx).is_some() {\n+                        let align = ccx.align_of(ty);\n+                        bcx.atomic_load(args[0].immediate(), order, align)\n                     } else {\n-                        invalid_monomorphization(sty);\n-                        C_nil(ccx)\n+                        return invalid_monomorphization(ty);\n                     }\n                 }\n \n                 \"store\" => {\n-                    let sty = &substs.type_at(0).sty;\n-                    if int_type_width_signed(sty, ccx).is_some() {\n-                        bcx.atomic_store(llargs[1], llargs[0], order);\n+                    let ty = substs.type_at(0);\n+                    if int_type_width_signed(ty, ccx).is_some() {\n+                        let align = ccx.align_of(ty);\n+                        bcx.atomic_store(args[1].immediate(), args[0].immediate(), order, align);\n+                        return;\n                     } else {\n-                        invalid_monomorphization(sty);\n+                        return invalid_monomorphization(ty);\n                     }\n-                    C_nil(ccx)\n                 }\n \n                 \"fence\" => {\n                     bcx.atomic_fence(order, llvm::SynchronizationScope::CrossThread);\n-                    C_nil(ccx)\n+                    return;\n                 }\n \n                 \"singlethreadfence\" => {\n                     bcx.atomic_fence(order, llvm::SynchronizationScope::SingleThread);\n-                    C_nil(ccx)\n+                    return;\n                 }\n \n                 // These are all AtomicRMW ops\n@@ -508,12 +530,11 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                         _ => ccx.sess().fatal(\"unknown atomic operation\")\n                     };\n \n-                    let sty = &substs.type_at(0).sty;\n-                    if int_type_width_signed(sty, ccx).is_some() {\n-                        bcx.atomic_rmw(atom_op, llargs[0], llargs[1], order)\n+                    let ty = substs.type_at(0);\n+                    if int_type_width_signed(ty, ccx).is_some() {\n+                        bcx.atomic_rmw(atom_op, args[0].immediate(), args[1].immediate(), order)\n                     } else {\n-                        invalid_monomorphization(sty);\n-                        C_nil(ccx)\n+                        return invalid_monomorphization(ty);\n                     }\n                 }\n             }\n@@ -528,13 +549,11 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                 assert_eq!(x.len(), 1);\n                 x.into_iter().next().unwrap()\n             }\n-            fn ty_to_type(ccx: &CrateContext, t: &intrinsics::Type,\n-                          any_changes_needed: &mut bool) -> Vec<Type> {\n+            fn ty_to_type(ccx: &CrateContext, t: &intrinsics::Type) -> Vec<Type> {\n                 use intrinsics::Type::*;\n                 match *t {\n                     Void => vec![Type::void(ccx)],\n-                    Integer(_signed, width, llvm_width) => {\n-                        *any_changes_needed |= width != llvm_width;\n+                    Integer(_signed, _width, llvm_width) => {\n                         vec![Type::ix(ccx, llvm_width as u64)]\n                     }\n                     Float(x) => {\n@@ -545,29 +564,24 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                         }\n                     }\n                     Pointer(ref t, ref llvm_elem, _const) => {\n-                        *any_changes_needed |= llvm_elem.is_some();\n-\n                         let t = llvm_elem.as_ref().unwrap_or(t);\n-                        let elem = one(ty_to_type(ccx, t, any_changes_needed));\n+                        let elem = one(ty_to_type(ccx, t));\n                         vec![elem.ptr_to()]\n                     }\n                     Vector(ref t, ref llvm_elem, length) => {\n-                        *any_changes_needed |= llvm_elem.is_some();\n-\n                         let t = llvm_elem.as_ref().unwrap_or(t);\n-                        let elem = one(ty_to_type(ccx, t, any_changes_needed));\n+                        let elem = one(ty_to_type(ccx, t));\n                         vec![Type::vector(&elem, length as u64)]\n                     }\n                     Aggregate(false, ref contents) => {\n                         let elems = contents.iter()\n-                                            .map(|t| one(ty_to_type(ccx, t, any_changes_needed)))\n+                                            .map(|t| one(ty_to_type(ccx, t)))\n                                             .collect::<Vec<_>>();\n                         vec![Type::struct_(ccx, &elems, false)]\n                     }\n                     Aggregate(true, ref contents) => {\n-                        *any_changes_needed = true;\n                         contents.iter()\n-                                .flat_map(|t| ty_to_type(ccx, t, any_changes_needed))\n+                                .flat_map(|t| ty_to_type(ccx, t))\n                                 .collect()\n                     }\n                 }\n@@ -579,8 +593,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             // cast.\n             fn modify_as_needed<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                                           t: &intrinsics::Type,\n-                                          arg_type: Ty<'tcx>,\n-                                          llarg: ValueRef)\n+                                          arg: &OperandRef<'tcx>)\n                                           -> Vec<ValueRef>\n             {\n                 match *t {\n@@ -591,55 +604,44 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                         // This assumes the type is \"simple\", i.e. no\n                         // destructors, and the contents are SIMD\n                         // etc.\n-                        assert!(!bcx.ccx.shared().type_needs_drop(arg_type));\n-                        let arg = LvalueRef::new_sized_ty(llarg, arg_type, Alignment::AbiAligned);\n+                        assert!(!bcx.ccx.shared().type_needs_drop(arg.layout.ty));\n+                        let (ptr, align) = match arg.val {\n+                            OperandValue::Ref(ptr, align) => (ptr, align),\n+                            _ => bug!()\n+                        };\n+                        let arg = LvalueRef::new_sized(ptr, arg.layout, align);\n                         (0..contents.len()).map(|i| {\n-                            let (ptr, align) = arg.trans_field_ptr(bcx, i);\n-                            bcx.load(ptr, align.to_align())\n+                            arg.project_field(bcx, i).load(bcx).immediate()\n                         }).collect()\n                     }\n                     intrinsics::Type::Pointer(_, Some(ref llvm_elem), _) => {\n-                        let llvm_elem = one(ty_to_type(bcx.ccx, llvm_elem, &mut false));\n-                        vec![bcx.pointercast(llarg, llvm_elem.ptr_to())]\n+                        let llvm_elem = one(ty_to_type(bcx.ccx, llvm_elem));\n+                        vec![bcx.pointercast(arg.immediate(), llvm_elem.ptr_to())]\n                     }\n                     intrinsics::Type::Vector(_, Some(ref llvm_elem), length) => {\n-                        let llvm_elem = one(ty_to_type(bcx.ccx, llvm_elem, &mut false));\n-                        vec![bcx.bitcast(llarg, Type::vector(&llvm_elem, length as u64))]\n+                        let llvm_elem = one(ty_to_type(bcx.ccx, llvm_elem));\n+                        vec![bcx.bitcast(arg.immediate(), Type::vector(&llvm_elem, length as u64))]\n                     }\n                     intrinsics::Type::Integer(_, width, llvm_width) if width != llvm_width => {\n                         // the LLVM intrinsic uses a smaller integer\n                         // size than the C intrinsic's signature, so\n                         // we have to trim it down here.\n-                        vec![bcx.trunc(llarg, Type::ix(bcx.ccx, llvm_width as u64))]\n+                        vec![bcx.trunc(arg.immediate(), Type::ix(bcx.ccx, llvm_width as u64))]\n                     }\n-                    _ => vec![llarg],\n+                    _ => vec![arg.immediate()],\n                 }\n             }\n \n \n-            let mut any_changes_needed = false;\n             let inputs = intr.inputs.iter()\n-                                    .flat_map(|t| ty_to_type(ccx, t, &mut any_changes_needed))\n+                                    .flat_map(|t| ty_to_type(ccx, t))\n                                     .collect::<Vec<_>>();\n \n-            let mut out_changes = false;\n-            let outputs = one(ty_to_type(ccx, &intr.output, &mut out_changes));\n-            // outputting a flattened aggregate is nonsense\n-            assert!(!out_changes);\n+            let outputs = one(ty_to_type(ccx, &intr.output));\n \n-            let llargs = if !any_changes_needed {\n-                // no aggregates to flatten, so no change needed\n-                llargs.to_vec()\n-            } else {\n-                // there are some aggregates that need to be flattened\n-                // in the LLVM call, so we need to run over the types\n-                // again to find them and extract the arguments\n-                intr.inputs.iter()\n-                           .zip(llargs)\n-                           .zip(arg_tys)\n-                           .flat_map(|((t, llarg), ty)| modify_as_needed(bcx, t, ty, *llarg))\n-                           .collect()\n-            };\n+            let llargs: Vec<_> = intr.inputs.iter().zip(args).flat_map(|(t, arg)| {\n+                modify_as_needed(bcx, t, arg)\n+            }).collect();\n             assert_eq!(inputs.len(), llargs.len());\n \n             let val = match intr.definition {\n@@ -657,50 +659,49 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                     assert!(!flatten);\n \n                     for i in 0..elems.len() {\n-                        let val = bcx.extract_value(val, i);\n-                        let lval = LvalueRef::new_sized_ty(llresult, ret_ty,\n-                                                           Alignment::AbiAligned);\n-                        let (dest, align) = lval.trans_field_ptr(bcx, i);\n-                        bcx.store(val, dest, align.to_align());\n+                        let dest = result.project_field(bcx, i);\n+                        let val = bcx.extract_value(val, i as u64);\n+                        bcx.store(val, dest.llval, dest.alignment.non_abi());\n                     }\n-                    C_nil(ccx)\n+                    return;\n                 }\n                 _ => val,\n             }\n         }\n     };\n \n-    if val_ty(llval) != Type::void(ccx) && machine::llsize_of_alloc(ccx, val_ty(llval)) != 0 {\n-        if let Some(ty) = fn_ty.ret.cast {\n-            let ptr = bcx.pointercast(llresult, ty.ptr_to());\n+    if !fn_ty.ret.is_ignore() {\n+        if let PassMode::Cast(ty) = fn_ty.ret.mode {\n+            let ptr = bcx.pointercast(llresult, ty.llvm_type(ccx).ptr_to());\n             bcx.store(llval, ptr, Some(ccx.align_of(ret_ty)));\n         } else {\n-            store_ty(bcx, llval, llresult, Alignment::AbiAligned, ret_ty);\n+            OperandRef::from_immediate_or_packed_pair(bcx, llval, result.layout)\n+                .val.store(bcx, result);\n         }\n     }\n }\n \n fn copy_intrinsic<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                             allow_overlap: bool,\n                             volatile: bool,\n-                            tp_ty: Ty<'tcx>,\n+                            ty: Ty<'tcx>,\n                             dst: ValueRef,\n                             src: ValueRef,\n                             count: ValueRef)\n                             -> ValueRef {\n     let ccx = bcx.ccx;\n-    let lltp_ty = type_of::type_of(ccx, tp_ty);\n-    let align = C_i32(ccx, ccx.align_of(tp_ty) as i32);\n-    let size = machine::llsize_of(ccx, lltp_ty);\n-    let int_size = machine::llbitsize_of_real(ccx, ccx.isize_ty());\n+    let (size, align) = ccx.size_and_align_of(ty);\n+    let size = C_usize(ccx, size.bytes());\n+    let align = C_i32(ccx, align.abi() as i32);\n \n     let operation = if allow_overlap {\n         \"memmove\"\n     } else {\n         \"memcpy\"\n     };\n \n-    let name = format!(\"llvm.{}.p0i8.p0i8.i{}\", operation, int_size);\n+    let name = format!(\"llvm.{}.p0i8.p0i8.i{}\", operation,\n+                       ccx.data_layout().pointer_size.bits());\n \n     let dst_ptr = bcx.pointercast(dst, Type::i8p(ccx));\n     let src_ptr = bcx.pointercast(src, Type::i8p(ccx));\n@@ -724,9 +725,9 @@ fn memset_intrinsic<'a, 'tcx>(\n     count: ValueRef\n ) -> ValueRef {\n     let ccx = bcx.ccx;\n-    let align = C_i32(ccx, ccx.align_of(ty) as i32);\n-    let lltp_ty = type_of::type_of(ccx, ty);\n-    let size = machine::llsize_of(ccx, lltp_ty);\n+    let (size, align) = ccx.size_and_align_of(ty);\n+    let size = C_usize(ccx, size.bytes());\n+    let align = C_i32(ccx, align.abi() as i32);\n     let dst = bcx.pointercast(dst, Type::i8p(ccx));\n     call_memset(bcx, dst, val, bcx.mul(size, count), align, volatile)\n }\n@@ -816,7 +817,7 @@ fn trans_msvc_try<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n         //\n         // More information can be found in libstd's seh.rs implementation.\n         let i64p = Type::i64(ccx).ptr_to();\n-        let slot = bcx.alloca(i64p, \"slot\", None);\n+        let slot = bcx.alloca(i64p, \"slot\", ccx.data_layout().pointer_align);\n         bcx.invoke(func, &[data], normal.llbb(), catchswitch.llbb(),\n             None);\n \n@@ -972,11 +973,11 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n     bcx: &Builder<'a, 'tcx>,\n     name: &str,\n     callee_ty: Ty<'tcx>,\n-    llargs: &[ValueRef],\n+    args: &[OperandRef<'tcx>],\n     ret_ty: Ty<'tcx>,\n     llret_ty: Type,\n     span: Span\n-) -> ValueRef {\n+) -> Result<ValueRef, ()> {\n     // macros for error handling:\n     macro_rules! emit_error {\n         ($msg: tt) => {\n@@ -994,7 +995,7 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n         ($cond: expr, $($fmt: tt)*) => {\n             if !$cond {\n                 emit_error!($($fmt)*);\n-                return C_nil(bcx.ccx)\n+                return Err(());\n             }\n         }\n     }\n@@ -1040,12 +1041,12 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n                  ret_ty,\n                  ret_ty.simd_type(tcx));\n \n-        return compare_simd_types(bcx,\n-                                  llargs[0],\n-                                  llargs[1],\n-                                  in_elem,\n-                                  llret_ty,\n-                                  cmp_op)\n+        return Ok(compare_simd_types(bcx,\n+                                     args[0].immediate(),\n+                                     args[1].immediate(),\n+                                     in_elem,\n+                                     llret_ty,\n+                                     cmp_op))\n     }\n \n     if name.starts_with(\"simd_shuffle\") {\n@@ -1069,12 +1070,12 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n \n         let total_len = in_len as u128 * 2;\n \n-        let vector = llargs[2];\n+        let vector = args[2].immediate();\n \n         let indices: Option<Vec<_>> = (0..n)\n             .map(|i| {\n                 let arg_idx = i;\n-                let val = const_get_elt(vector, &[i as libc::c_uint]);\n+                let val = const_get_elt(vector, i as u64);\n                 match const_to_opt_u128(val, true) {\n                     None => {\n                         emit_error!(\"shuffle index #{} is not a constant\", arg_idx);\n@@ -1091,23 +1092,27 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n             .collect();\n         let indices = match indices {\n             Some(i) => i,\n-            None => return C_null(llret_ty)\n+            None => return Ok(C_null(llret_ty))\n         };\n \n-        return bcx.shuffle_vector(llargs[0], llargs[1], C_vector(&indices))\n+        return Ok(bcx.shuffle_vector(args[0].immediate(),\n+                                     args[1].immediate(),\n+                                     C_vector(&indices)))\n     }\n \n     if name == \"simd_insert\" {\n         require!(in_elem == arg_tys[2],\n                  \"expected inserted type `{}` (element of input `{}`), found `{}`\",\n                  in_elem, in_ty, arg_tys[2]);\n-        return bcx.insert_element(llargs[0], llargs[2], llargs[1])\n+        return Ok(bcx.insert_element(args[0].immediate(),\n+                                     args[2].immediate(),\n+                                     args[1].immediate()))\n     }\n     if name == \"simd_extract\" {\n         require!(ret_ty == in_elem,\n                  \"expected return type `{}` (element of input `{}`), found `{}`\",\n                  in_elem, in_ty, ret_ty);\n-        return bcx.extract_element(llargs[0], llargs[1])\n+        return Ok(bcx.extract_element(args[0].immediate(), args[1].immediate()))\n     }\n \n     if name == \"simd_cast\" {\n@@ -1121,7 +1126,7 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n         // casting cares about nominal type, not just structural type\n         let out_elem = ret_ty.simd_type(tcx);\n \n-        if in_elem == out_elem { return llargs[0]; }\n+        if in_elem == out_elem { return Ok(args[0].immediate()); }\n \n         enum Style { Float, Int(/* is signed? */ bool), Unsupported }\n \n@@ -1142,36 +1147,36 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n \n         match (in_style, out_style) {\n             (Style::Int(in_is_signed), Style::Int(_)) => {\n-                return match in_width.cmp(&out_width) {\n-                    Ordering::Greater => bcx.trunc(llargs[0], llret_ty),\n-                    Ordering::Equal => llargs[0],\n+                return Ok(match in_width.cmp(&out_width) {\n+                    Ordering::Greater => bcx.trunc(args[0].immediate(), llret_ty),\n+                    Ordering::Equal => args[0].immediate(),\n                     Ordering::Less => if in_is_signed {\n-                        bcx.sext(llargs[0], llret_ty)\n+                        bcx.sext(args[0].immediate(), llret_ty)\n                     } else {\n-                        bcx.zext(llargs[0], llret_ty)\n+                        bcx.zext(args[0].immediate(), llret_ty)\n                     }\n-                }\n+                })\n             }\n             (Style::Int(in_is_signed), Style::Float) => {\n-                return if in_is_signed {\n-                    bcx.sitofp(llargs[0], llret_ty)\n+                return Ok(if in_is_signed {\n+                    bcx.sitofp(args[0].immediate(), llret_ty)\n                 } else {\n-                    bcx.uitofp(llargs[0], llret_ty)\n-                }\n+                    bcx.uitofp(args[0].immediate(), llret_ty)\n+                })\n             }\n             (Style::Float, Style::Int(out_is_signed)) => {\n-                return if out_is_signed {\n-                    bcx.fptosi(llargs[0], llret_ty)\n+                return Ok(if out_is_signed {\n+                    bcx.fptosi(args[0].immediate(), llret_ty)\n                 } else {\n-                    bcx.fptoui(llargs[0], llret_ty)\n-                }\n+                    bcx.fptoui(args[0].immediate(), llret_ty)\n+                })\n             }\n             (Style::Float, Style::Float) => {\n-                return match in_width.cmp(&out_width) {\n-                    Ordering::Greater => bcx.fptrunc(llargs[0], llret_ty),\n-                    Ordering::Equal => llargs[0],\n-                    Ordering::Less => bcx.fpext(llargs[0], llret_ty)\n-                }\n+                return Ok(match in_width.cmp(&out_width) {\n+                    Ordering::Greater => bcx.fptrunc(args[0].immediate(), llret_ty),\n+                    Ordering::Equal => args[0].immediate(),\n+                    Ordering::Less => bcx.fpext(args[0].immediate(), llret_ty)\n+                })\n             }\n             _ => {/* Unsupported. Fallthrough. */}\n         }\n@@ -1182,21 +1187,18 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n     }\n     macro_rules! arith {\n         ($($name: ident: $($($p: ident),* => $call: ident),*;)*) => {\n-            $(\n-                if name == stringify!($name) {\n-                    match in_elem.sty {\n-                        $(\n-                            $(ty::$p(_))|* => {\n-                                return bcx.$call(llargs[0], llargs[1])\n-                            }\n-                            )*\n-                        _ => {},\n-                    }\n-                    require!(false,\n-                             \"unsupported operation on `{}` with element `{}`\",\n-                             in_ty,\n-                             in_elem)\n-                })*\n+            $(if name == stringify!($name) {\n+                match in_elem.sty {\n+                    $($(ty::$p(_))|* => {\n+                        return Ok(bcx.$call(args[0].immediate(), args[1].immediate()))\n+                    })*\n+                    _ => {},\n+                }\n+                require!(false,\n+                            \"unsupported operation on `{}` with element `{}`\",\n+                            in_ty,\n+                            in_elem)\n+            })*\n         }\n     }\n     arith! {\n@@ -1214,15 +1216,13 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n     span_bug!(span, \"unknown SIMD intrinsic\");\n }\n \n-// Returns the width of an int TypeVariant, and if it's signed or not\n+// Returns the width of an int Ty, and if it's signed or not\n // Returns None if the type is not an integer\n // FIXME: there\u2019s multiple of this functions, investigate using some of the already existing\n // stuffs.\n-fn int_type_width_signed<'tcx>(sty: &ty::TypeVariants<'tcx>, ccx: &CrateContext)\n-        -> Option<(u64, bool)> {\n-    use rustc::ty::{TyInt, TyUint};\n-    match *sty {\n-        TyInt(t) => Some((match t {\n+fn int_type_width_signed(ty: Ty, ccx: &CrateContext) -> Option<(u64, bool)> {\n+    match ty.sty {\n+        ty::TyInt(t) => Some((match t {\n             ast::IntTy::Is => {\n                 match &ccx.tcx().sess.target.target.target_pointer_width[..] {\n                     \"16\" => 16,\n@@ -1237,7 +1237,7 @@ fn int_type_width_signed<'tcx>(sty: &ty::TypeVariants<'tcx>, ccx: &CrateContext)\n             ast::IntTy::I64 => 64,\n             ast::IntTy::I128 => 128,\n         }, true)),\n-        TyUint(t) => Some((match t {\n+        ty::TyUint(t) => Some((match t {\n             ast::UintTy::Us => {\n                 match &ccx.tcx().sess.target.target.target_pointer_width[..] {\n                     \"16\" => 16,"}, {"sha": "f6c4153c183de7203ac492ba5c41c8c3acf2e763", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -25,6 +25,8 @@\n #![allow(unused_attributes)]\n #![feature(i128_type)]\n #![feature(i128)]\n+#![feature(inclusive_range)]\n+#![feature(inclusive_range_syntax)]\n #![feature(libc)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n@@ -103,7 +105,6 @@ pub mod back {\n }\n \n mod abi;\n-mod adt;\n mod allocator;\n mod asm;\n mod assert_module_sources;\n@@ -136,15 +137,13 @@ mod declare;\n mod glue;\n mod intrinsic;\n mod llvm_util;\n-mod machine;\n mod metadata;\n mod meth;\n mod mir;\n mod partitioning;\n mod symbol_names_test;\n mod time_graph;\n mod trans_item;\n-mod tvec;\n mod type_;\n mod type_of;\n mod value;"}, {"sha": "bc383abc7e0ecc96aeb18ead69c13991aaa3d55f", "filename": "src/librustc_trans/machine.rs", "status": "removed", "additions": 0, "deletions": 79, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/5041b3bb3d953a14f32b15d1e41341c629acae12/src%2Flibrustc_trans%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5041b3bb3d953a14f32b15d1e41341c629acae12/src%2Flibrustc_trans%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmachine.rs?ref=5041b3bb3d953a14f32b15d1e41341c629acae12", "patch": "@@ -1,79 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Information concerning the machine representation of various types.\n-\n-#![allow(non_camel_case_types)]\n-\n-use llvm::{self, ValueRef};\n-use common::*;\n-\n-use type_::Type;\n-\n-pub type llbits = u64;\n-pub type llsize = u64;\n-pub type llalign = u32;\n-\n-// ______________________________________________________________________\n-// compute sizeof / alignof\n-\n-// Returns the number of bytes between successive elements of type T in an\n-// array of T. This is the \"ABI\" size. It includes any ABI-mandated padding.\n-pub fn llsize_of_alloc(cx: &CrateContext, ty: Type) -> llsize {\n-    unsafe {\n-        return llvm::LLVMABISizeOfType(cx.td(), ty.to_ref());\n-    }\n-}\n-\n-/// Returns the \"real\" size of the type in bits.\n-pub fn llbitsize_of_real(cx: &CrateContext, ty: Type) -> llbits {\n-    unsafe {\n-        llvm::LLVMSizeOfTypeInBits(cx.td(), ty.to_ref())\n-    }\n-}\n-\n-/// Returns the size of the type as an LLVM constant integer value.\n-pub fn llsize_of(cx: &CrateContext, ty: Type) -> ValueRef {\n-    // Once upon a time, this called LLVMSizeOf, which does a\n-    // getelementptr(1) on a null pointer and casts to an int, in\n-    // order to obtain the type size as a value without requiring the\n-    // target data layout.  But we have the target data layout, so\n-    // there's no need for that contrivance.  The instruction\n-    // selection DAG generator would flatten that GEP(1) node into a\n-    // constant of the type's alloc size, so let's save it some work.\n-    return C_usize(cx, llsize_of_alloc(cx, ty));\n-}\n-\n-// Returns the preferred alignment of the given type for the current target.\n-// The preferred alignment may be larger than the alignment used when\n-// packing the type into structs. This will be used for things like\n-// allocations inside a stack frame, which LLVM has a free hand in.\n-pub fn llalign_of_pref(cx: &CrateContext, ty: Type) -> llalign {\n-    unsafe {\n-        return llvm::LLVMPreferredAlignmentOfType(cx.td(), ty.to_ref());\n-    }\n-}\n-\n-// Returns the minimum alignment of a type required by the platform.\n-// This is the alignment that will be used for struct fields, arrays,\n-// and similar ABI-mandated things.\n-pub fn llalign_of_min(cx: &CrateContext, ty: Type) -> llalign {\n-    unsafe {\n-        return llvm::LLVMABIAlignmentOfType(cx.td(), ty.to_ref());\n-    }\n-}\n-\n-pub fn llelement_offset(cx: &CrateContext, struct_ty: Type, element: usize) -> u64 {\n-    unsafe {\n-        return llvm::LLVMOffsetOfElement(cx.td(),\n-                                         struct_ty.to_ref(),\n-                                         element as u32);\n-    }\n-}"}, {"sha": "a7d467f1cc5f3f572cb4d2dc0fb2f29b3952bba5", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -9,34 +9,39 @@\n // except according to those terms.\n \n use llvm::ValueRef;\n+use abi::FnType;\n use callee;\n use common::*;\n use builder::Builder;\n use consts;\n-use machine;\n use monomorphize;\n use type_::Type;\n use value::Value;\n use rustc::ty::{self, Ty};\n+use rustc::ty::layout::HasDataLayout;\n use debuginfo;\n \n #[derive(Copy, Clone, Debug)]\n-pub struct VirtualIndex(usize);\n+pub struct VirtualIndex(u64);\n \n pub const DESTRUCTOR: VirtualIndex = VirtualIndex(0);\n pub const SIZE: VirtualIndex = VirtualIndex(1);\n pub const ALIGN: VirtualIndex = VirtualIndex(2);\n \n impl<'a, 'tcx> VirtualIndex {\n     pub fn from_index(index: usize) -> Self {\n-        VirtualIndex(index + 3)\n+        VirtualIndex(index as u64 + 3)\n     }\n \n-    pub fn get_fn(self, bcx: &Builder<'a, 'tcx>, llvtable: ValueRef) -> ValueRef {\n+    pub fn get_fn(self, bcx: &Builder<'a, 'tcx>,\n+                  llvtable: ValueRef,\n+                  fn_ty: &FnType<'tcx>) -> ValueRef {\n         // Load the data pointer from the object.\n         debug!(\"get_fn({:?}, {:?})\", Value(llvtable), self);\n \n-        let ptr = bcx.load_nonnull(bcx.gepi(llvtable, &[self.0]), None);\n+        let llvtable = bcx.pointercast(llvtable, fn_ty.llvm_type(bcx.ccx).ptr_to().ptr_to());\n+        let ptr = bcx.load(bcx.inbounds_gep(llvtable, &[C_usize(bcx.ccx, self.0)]), None);\n+        bcx.nonnull_metadata(ptr);\n         // Vtable loads are invariant\n         bcx.set_invariant_load(ptr);\n         ptr\n@@ -47,7 +52,7 @@ impl<'a, 'tcx> VirtualIndex {\n         debug!(\"get_int({:?}, {:?})\", Value(llvtable), self);\n \n         let llvtable = bcx.pointercast(llvtable, Type::isize(bcx.ccx).ptr_to());\n-        let ptr = bcx.load(bcx.gepi(llvtable, &[self.0]), None);\n+        let ptr = bcx.load(bcx.inbounds_gep(llvtable, &[C_usize(bcx.ccx, self.0)]), None);\n         // Vtable loads are invariant\n         bcx.set_invariant_load(ptr);\n         ptr\n@@ -77,12 +82,13 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     }\n \n     // Not in the cache. Build it.\n-    let nullptr = C_null(Type::nil(ccx).ptr_to());\n+    let nullptr = C_null(Type::i8p(ccx));\n \n+    let (size, align) = ccx.size_and_align_of(ty);\n     let mut components: Vec<_> = [\n         callee::get_fn(ccx, monomorphize::resolve_drop_in_place(ccx.tcx(), ty)),\n-        C_usize(ccx, ccx.size_of(ty)),\n-        C_usize(ccx, ccx.align_of(ty) as u64)\n+        C_usize(ccx, size.bytes()),\n+        C_usize(ccx, align.abi())\n     ].iter().cloned().collect();\n \n     if let Some(trait_ref) = trait_ref {\n@@ -97,7 +103,7 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     }\n \n     let vtable_const = C_struct(ccx, &components, false);\n-    let align = machine::llalign_of_pref(ccx, val_ty(vtable_const));\n+    let align = ccx.data_layout().pointer_align;\n     let vtable = consts::addr_of(ccx, vtable_const, align, \"vtable\");\n \n     debuginfo::create_vtable_metadata(ccx, ty, vtable);"}, {"sha": "223379527c989aee07d5a0409d7a6ea034201228", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 26, "deletions": 20, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -18,7 +18,8 @@ use rustc::mir::{self, Location, TerminatorKind, Literal};\n use rustc::mir::visit::{Visitor, LvalueContext};\n use rustc::mir::traversal;\n use rustc::ty;\n-use common;\n+use rustc::ty::layout::LayoutOf;\n+use type_of::LayoutLlvmExt;\n use super::MirContext;\n \n pub fn lvalue_locals<'a, 'tcx>(mircx: &MirContext<'a, 'tcx>) -> BitVector {\n@@ -30,21 +31,15 @@ pub fn lvalue_locals<'a, 'tcx>(mircx: &MirContext<'a, 'tcx>) -> BitVector {\n     for (index, ty) in mir.local_decls.iter().map(|l| l.ty).enumerate() {\n         let ty = mircx.monomorphize(&ty);\n         debug!(\"local {} has type {:?}\", index, ty);\n-        if ty.is_scalar() ||\n-            ty.is_box() ||\n-            ty.is_region_ptr() ||\n-            ty.is_simd() ||\n-            common::type_is_zero_size(mircx.ccx, ty)\n-        {\n+        let layout = mircx.ccx.layout_of(ty);\n+        if layout.is_llvm_immediate() {\n             // These sorts of types are immediates that we can store\n             // in an ValueRef without an alloca.\n-            assert!(common::type_is_immediate(mircx.ccx, ty) ||\n-                    common::type_is_fat_ptr(mircx.ccx, ty));\n-        } else if common::type_is_imm_pair(mircx.ccx, ty) {\n+        } else if layout.is_llvm_scalar_pair() {\n             // We allow pairs and uses of any of their 2 fields.\n         } else {\n             // These sorts of types require an alloca. Note that\n-            // type_is_immediate() may *still* be true, particularly\n+            // is_llvm_immediate() may *still* be true, particularly\n             // for newtypes, but we currently force some types\n             // (e.g. structs) into an alloca unconditionally, just so\n             // that we don't have to deal with having two pathways\n@@ -141,18 +136,29 @@ impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n                     context: LvalueContext<'tcx>,\n                     location: Location) {\n         debug!(\"visit_lvalue(lvalue={:?}, context={:?})\", lvalue, context);\n+        let ccx = self.cx.ccx;\n \n         if let mir::Lvalue::Projection(ref proj) = *lvalue {\n-            // Allow uses of projections of immediate pair fields.\n+            // Allow uses of projections that are ZSTs or from scalar fields.\n             if let LvalueContext::Consume = context {\n-                if let mir::Lvalue::Local(_) = proj.base {\n-                    if let mir::ProjectionElem::Field(..) = proj.elem {\n-                        let ty = proj.base.ty(self.cx.mir, self.cx.ccx.tcx());\n+                let base_ty = proj.base.ty(self.cx.mir, ccx.tcx());\n+                let base_ty = self.cx.monomorphize(&base_ty);\n+\n+                // ZSTs don't require any actual memory access.\n+                let elem_ty = base_ty.projection_ty(ccx.tcx(), &proj.elem).to_ty(ccx.tcx());\n+                let elem_ty = self.cx.monomorphize(&elem_ty);\n+                if ccx.layout_of(elem_ty).is_zst() {\n+                    return;\n+                }\n \n-                        let ty = self.cx.monomorphize(&ty.to_ty(self.cx.ccx.tcx()));\n-                        if common::type_is_imm_pair(self.cx.ccx, ty) {\n-                            return;\n-                        }\n+                if let mir::ProjectionElem::Field(..) = proj.elem {\n+                    let layout = ccx.layout_of(base_ty.to_ty(ccx.tcx()));\n+                    if layout.is_llvm_immediate() || layout.is_llvm_scalar_pair() {\n+                        // Recurse as a `Consume` instead of `Projection`,\n+                        // potentially stopping at non-operand projections,\n+                        // which would trigger `mark_as_lvalue` on locals.\n+                        self.visit_lvalue(&proj.base, LvalueContext::Consume, location);\n+                        return;\n                     }\n                 }\n             }\n@@ -178,9 +184,9 @@ impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n             LvalueContext::StorageLive |\n             LvalueContext::StorageDead |\n             LvalueContext::Validate |\n-            LvalueContext::Inspect |\n             LvalueContext::Consume => {}\n \n+            LvalueContext::Inspect |\n             LvalueContext::Store |\n             LvalueContext::Borrow { .. } |\n             LvalueContext::Projection(..) => {"}, {"sha": "f43eba36a8232fa8fdb188efb13e73ec93bc8320", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 267, "deletions": 309, "changes": 576, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -11,28 +11,24 @@\n use llvm::{self, ValueRef, BasicBlockRef};\n use rustc::middle::lang_items;\n use rustc::middle::const_val::{ConstEvalErr, ConstInt, ErrKind};\n-use rustc::ty::{self, Ty, TypeFoldable};\n-use rustc::ty::layout::{self, LayoutTyper};\n+use rustc::ty::{self, TypeFoldable};\n+use rustc::ty::layout::{self, LayoutOf};\n use rustc::traits;\n use rustc::mir;\n-use abi::{Abi, FnType, ArgType};\n-use adt;\n-use base::{self, Lifetime};\n+use abi::{Abi, FnType, ArgType, PassMode};\n+use base;\n use callee;\n use builder::Builder;\n use common::{self, C_bool, C_str_slice, C_struct, C_u32, C_undef};\n use consts;\n-use machine::llalign_of_min;\n use meth;\n use monomorphize;\n-use type_of;\n+use type_of::LayoutLlvmExt;\n use type_::Type;\n \n use syntax::symbol::Symbol;\n use syntax_pos::Pos;\n \n-use std::cmp;\n-\n use super::{MirContext, LocalRef};\n use super::constant::Const;\n use super::lvalue::{Alignment, LvalueRef};\n@@ -120,11 +116,11 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             fn_ty: FnType<'tcx>,\n             fn_ptr: ValueRef,\n             llargs: &[ValueRef],\n-            destination: Option<(ReturnDest, Ty<'tcx>, mir::BasicBlock)>,\n+            destination: Option<(ReturnDest<'tcx>, mir::BasicBlock)>,\n             cleanup: Option<mir::BasicBlock>\n         | {\n             if let Some(cleanup) = cleanup {\n-                let ret_bcx = if let Some((_, _, target)) = destination {\n+                let ret_bcx = if let Some((_, target)) = destination {\n                     this.blocks[target]\n                 } else {\n                     this.unreachable_block()\n@@ -136,14 +132,10 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                                            cleanup_bundle);\n                 fn_ty.apply_attrs_callsite(invokeret);\n \n-                if let Some((ret_dest, ret_ty, target)) = destination {\n+                if let Some((ret_dest, target)) = destination {\n                     let ret_bcx = this.get_builder(target);\n                     this.set_debug_loc(&ret_bcx, terminator.source_info);\n-                    let op = OperandRef {\n-                        val: Immediate(invokeret),\n-                        ty: ret_ty,\n-                    };\n-                    this.store_return(&ret_bcx, ret_dest, &fn_ty.ret, op);\n+                    this.store_return(&ret_bcx, ret_dest, &fn_ty.ret, invokeret);\n                 }\n             } else {\n                 let llret = bcx.call(fn_ptr, &llargs, cleanup_bundle);\n@@ -156,12 +148,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     llvm::Attribute::NoInline.apply_callsite(llvm::AttributePlace::Function, llret);\n                 }\n \n-                if let Some((ret_dest, ret_ty, target)) = destination {\n-                    let op = OperandRef {\n-                        val: Immediate(llret),\n-                        ty: ret_ty,\n-                    };\n-                    this.store_return(&bcx, ret_dest, &fn_ty.ret, op);\n+                if let Some((ret_dest, target)) = destination {\n+                    this.store_return(&bcx, ret_dest, &fn_ty.ret, llret);\n                     funclet_br(this, bcx, target);\n                 } else {\n                     bcx.unreachable();\n@@ -175,14 +163,18 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 if let Some(cleanup_pad) = cleanup_pad {\n                     bcx.cleanup_ret(cleanup_pad, None);\n                 } else {\n-                    let ps = self.get_personality_slot(&bcx);\n-                    let lp = bcx.load(ps, None);\n-                    Lifetime::End.call(&bcx, ps);\n+                    let slot = self.get_personality_slot(&bcx);\n+                    let lp0 = slot.project_field(&bcx, 0).load(&bcx).immediate();\n+                    let lp1 = slot.project_field(&bcx, 1).load(&bcx).immediate();\n+                    slot.storage_dead(&bcx);\n+\n                     if !bcx.sess().target.target.options.custom_unwind_resume {\n+                        let mut lp = C_undef(self.landing_pad_type());\n+                        lp = bcx.insert_value(lp, lp0, 0);\n+                        lp = bcx.insert_value(lp, lp1, 1);\n                         bcx.resume(lp);\n                     } else {\n-                        let exc_ptr = bcx.extract_value(lp, 0);\n-                        bcx.call(bcx.ccx.eh_unwind_resume(), &[exc_ptr], cleanup_bundle);\n+                        bcx.call(bcx.ccx.eh_unwind_resume(), &[lp0], cleanup_bundle);\n                         bcx.unreachable();\n                     }\n                 }\n@@ -215,45 +207,47 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             }\n \n             mir::TerminatorKind::Return => {\n-                let ret = self.fn_ty.ret;\n-                if ret.is_ignore() || ret.is_indirect() {\n-                    bcx.ret_void();\n-                    return;\n-                }\n+                let llval = match self.fn_ty.ret.mode {\n+                    PassMode::Ignore | PassMode::Indirect(_) => {\n+                        bcx.ret_void();\n+                        return;\n+                    }\n \n-                let llval = if let Some(cast_ty) = ret.cast {\n-                    let op = match self.locals[mir::RETURN_POINTER] {\n-                        LocalRef::Operand(Some(op)) => op,\n-                        LocalRef::Operand(None) => bug!(\"use of return before def\"),\n-                        LocalRef::Lvalue(tr_lvalue) => {\n-                            OperandRef {\n-                                val: Ref(tr_lvalue.llval, tr_lvalue.alignment),\n-                                ty: tr_lvalue.ty.to_ty(bcx.tcx())\n-                            }\n-                        }\n-                    };\n-                    let llslot = match op.val {\n-                        Immediate(_) | Pair(..) => {\n-                            let llscratch = bcx.alloca(ret.memory_ty(bcx.ccx), \"ret\", None);\n-                            self.store_operand(&bcx, llscratch, None, op);\n-                            llscratch\n-                        }\n-                        Ref(llval, align) => {\n-                            assert_eq!(align, Alignment::AbiAligned,\n-                                       \"return pointer is unaligned!\");\n-                            llval\n+                    PassMode::Direct(_) | PassMode::Pair(..) => {\n+                        let op = self.trans_consume(&bcx, &mir::Lvalue::Local(mir::RETURN_POINTER));\n+                        if let Ref(llval, align) = op.val {\n+                            bcx.load(llval, align.non_abi())\n+                        } else {\n+                            op.immediate_or_packed_pair(&bcx)\n                         }\n-                    };\n-                    let load = bcx.load(\n-                        bcx.pointercast(llslot, cast_ty.ptr_to()),\n-                        Some(ret.layout.align(bcx.ccx).abi() as u32));\n-                    load\n-                } else {\n-                    let op = self.trans_consume(&bcx, &mir::Lvalue::Local(mir::RETURN_POINTER));\n-                    if let Ref(llval, align) = op.val {\n-                        base::load_ty(&bcx, llval, align, op.ty)\n-                    } else {\n-                        op.pack_if_pair(&bcx).immediate()\n+                    }\n+\n+                    PassMode::Cast(cast_ty) => {\n+                        let op = match self.locals[mir::RETURN_POINTER] {\n+                            LocalRef::Operand(Some(op)) => op,\n+                            LocalRef::Operand(None) => bug!(\"use of return before def\"),\n+                            LocalRef::Lvalue(tr_lvalue) => {\n+                                OperandRef {\n+                                    val: Ref(tr_lvalue.llval, tr_lvalue.alignment),\n+                                    layout: tr_lvalue.layout\n+                                }\n+                            }\n+                        };\n+                        let llslot = match op.val {\n+                            Immediate(_) | Pair(..) => {\n+                                let scratch = LvalueRef::alloca(&bcx, self.fn_ty.ret.layout, \"ret\");\n+                                op.val.store(&bcx, scratch);\n+                                scratch.llval\n+                            }\n+                            Ref(llval, align) => {\n+                                assert_eq!(align, Alignment::AbiAligned,\n+                                           \"return pointer is unaligned!\");\n+                                llval\n+                            }\n+                        };\n+                        bcx.load(\n+                            bcx.pointercast(llslot, cast_ty.llvm_type(bcx.ccx).ptr_to()),\n+                            Some(self.fn_ty.ret.layout.align))\n                     }\n                 };\n                 bcx.ret(llval);\n@@ -275,15 +269,24 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 }\n \n                 let lvalue = self.trans_lvalue(&bcx, location);\n-                let fn_ty = FnType::of_instance(bcx.ccx, &drop_fn);\n-                let (drop_fn, need_extra) = match ty.sty {\n-                    ty::TyDynamic(..) => (meth::DESTRUCTOR.get_fn(&bcx, lvalue.llextra),\n-                                          false),\n-                    _ => (callee::get_fn(bcx.ccx, drop_fn), lvalue.has_extra())\n+                let mut args: &[_] = &[lvalue.llval, lvalue.llextra];\n+                args = &args[..1 + lvalue.has_extra() as usize];\n+                let (drop_fn, fn_ty) = match ty.sty {\n+                    ty::TyDynamic(..) => {\n+                        let fn_ty = common::instance_ty(bcx.ccx.tcx(), &drop_fn);\n+                        let sig = common::ty_fn_sig(bcx.ccx, fn_ty);\n+                        let sig = bcx.tcx().erase_late_bound_regions_and_normalize(&sig);\n+                        let fn_ty = FnType::new_vtable(bcx.ccx, sig, &[]);\n+                        args = &args[..1];\n+                        (meth::DESTRUCTOR.get_fn(&bcx, lvalue.llextra, &fn_ty), fn_ty)\n+                    }\n+                    _ => {\n+                        (callee::get_fn(bcx.ccx, drop_fn),\n+                         FnType::of_instance(bcx.ccx, &drop_fn))\n+                    }\n                 };\n-                let args = &[lvalue.llval, lvalue.llextra][..1 + need_extra as usize];\n                 do_call(self, bcx, fn_ty, drop_fn, args,\n-                        Some((ReturnDest::Nothing, tcx.mk_nil(), target)),\n+                        Some((ReturnDest::Nothing, target)),\n                         unwind);\n             }\n \n@@ -336,6 +339,9 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let filename = C_str_slice(bcx.ccx, filename);\n                 let line = C_u32(bcx.ccx, loc.line as u32);\n                 let col = C_u32(bcx.ccx, loc.col.to_usize() as u32 + 1);\n+                let align = tcx.data_layout.aggregate_align\n+                    .max(tcx.data_layout.i32_align)\n+                    .max(tcx.data_layout.pointer_align);\n \n                 // Put together the arguments to the panic entry point.\n                 let (lang_item, args, const_err) = match *msg {\n@@ -351,7 +357,6 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                                 }));\n \n                         let file_line_col = C_struct(bcx.ccx, &[filename, line, col], false);\n-                        let align = llalign_of_min(bcx.ccx, common::val_ty(file_line_col));\n                         let file_line_col = consts::addr_of(bcx.ccx,\n                                                             file_line_col,\n                                                             align,\n@@ -366,7 +371,6 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         let msg_file_line_col = C_struct(bcx.ccx,\n                                                      &[msg_str, filename, line, col],\n                                                      false);\n-                        let align = llalign_of_min(bcx.ccx, common::val_ty(msg_file_line_col));\n                         let msg_file_line_col = consts::addr_of(bcx.ccx,\n                                                                 msg_file_line_col,\n                                                                 align,\n@@ -387,7 +391,6 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         let msg_file_line_col = C_struct(bcx.ccx,\n                                                      &[msg_str, filename, line, col],\n                                                      false);\n-                        let align = llalign_of_min(bcx.ccx, common::val_ty(msg_file_line_col));\n                         let msg_file_line_col = consts::addr_of(bcx.ccx,\n                                                                 msg_file_line_col,\n                                                                 align,\n@@ -428,7 +431,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 // Create the callee. This is a fn ptr or zero-sized and hence a kind of scalar.\n                 let callee = self.trans_operand(&bcx, func);\n \n-                let (instance, mut llfn) = match callee.ty.sty {\n+                let (instance, mut llfn) = match callee.layout.ty.sty {\n                     ty::TyFnDef(def_id, substs) => {\n                         (Some(ty::Instance::resolve(bcx.ccx.tcx(),\n                                                     ty::ParamEnv::empty(traits::Reveal::All),\n@@ -439,10 +442,10 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     ty::TyFnPtr(_) => {\n                         (None, Some(callee.immediate()))\n                     }\n-                    _ => bug!(\"{} is not callable\", callee.ty)\n+                    _ => bug!(\"{} is not callable\", callee.layout.ty)\n                 };\n                 let def = instance.map(|i| i.def);\n-                let sig = callee.ty.fn_sig(bcx.tcx());\n+                let sig = callee.layout.ty.fn_sig(bcx.tcx());\n                 let sig = bcx.tcx().erase_late_bound_regions_and_normalize(&sig);\n                 let abi = sig.abi;\n \n@@ -493,83 +496,51 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     ReturnDest::Nothing\n                 };\n \n-                // Split the rust-call tupled arguments off.\n-                let (first_args, untuple) = if abi == Abi::RustCall && !args.is_empty() {\n-                    let (tup, args) = args.split_last().unwrap();\n-                    (args, Some(tup))\n-                } else {\n-                    (&args[..], None)\n-                };\n-\n-                let is_shuffle = intrinsic.map_or(false, |name| {\n-                    name.starts_with(\"simd_shuffle\")\n-                });\n-                let mut idx = 0;\n-                for arg in first_args {\n-                    // The indices passed to simd_shuffle* in the\n-                    // third argument must be constant. This is\n-                    // checked by const-qualification, which also\n-                    // promotes any complex rvalues to constants.\n-                    if is_shuffle && idx == 2 {\n-                        match *arg {\n-                            mir::Operand::Consume(_) => {\n-                                span_bug!(span, \"shuffle indices must be constant\");\n-                            }\n-                            mir::Operand::Constant(ref constant) => {\n-                                let val = self.trans_constant(&bcx, constant);\n-                                llargs.push(val.llval);\n-                                idx += 1;\n-                                continue;\n-                            }\n-                        }\n-                    }\n-\n-                    let mut op = self.trans_operand(&bcx, arg);\n-\n-                    // The callee needs to own the argument memory if we pass it\n-                    // by-ref, so make a local copy of non-immediate constants.\n-                    if let (&mir::Operand::Constant(_), Ref(..)) = (arg, op.val) {\n-                        let tmp = LvalueRef::alloca(&bcx, op.ty, \"const\");\n-                        self.store_operand(&bcx, tmp.llval, tmp.alignment.to_align(), op);\n-                        op.val = Ref(tmp.llval, tmp.alignment);\n-                    }\n-\n-                    self.trans_argument(&bcx, op, &mut llargs, &fn_ty,\n-                                        &mut idx, &mut llfn, &def);\n-                }\n-                if let Some(tup) = untuple {\n-                    self.trans_arguments_untupled(&bcx, tup, &mut llargs, &fn_ty,\n-                                                  &mut idx, &mut llfn, &def)\n-                }\n-\n                 if intrinsic.is_some() && intrinsic != Some(\"drop_in_place\") {\n                     use intrinsic::trans_intrinsic_call;\n \n-                    let (dest, llargs) = match ret_dest {\n-                        _ if fn_ty.ret.is_indirect() => {\n-                            (llargs[0], &llargs[1..])\n-                        }\n+                    let dest = match ret_dest {\n+                        _ if fn_ty.ret.is_indirect() => llargs[0],\n                         ReturnDest::Nothing => {\n-                            (C_undef(fn_ty.ret.memory_ty(bcx.ccx).ptr_to()), &llargs[..])\n+                            C_undef(fn_ty.ret.memory_ty(bcx.ccx).ptr_to())\n                         }\n                         ReturnDest::IndirectOperand(dst, _) |\n-                        ReturnDest::Store(dst) => (dst, &llargs[..]),\n+                        ReturnDest::Store(dst) => dst.llval,\n                         ReturnDest::DirectOperand(_) =>\n                             bug!(\"Cannot use direct operand with an intrinsic call\")\n                     };\n \n+                    let args: Vec<_> = args.iter().enumerate().map(|(i, arg)| {\n+                        // The indices passed to simd_shuffle* in the\n+                        // third argument must be constant. This is\n+                        // checked by const-qualification, which also\n+                        // promotes any complex rvalues to constants.\n+                        if i == 2 && intrinsic.unwrap().starts_with(\"simd_shuffle\") {\n+                            match *arg {\n+                                mir::Operand::Consume(_) => {\n+                                    span_bug!(span, \"shuffle indices must be constant\");\n+                                }\n+                                mir::Operand::Constant(ref constant) => {\n+                                    let val = self.trans_constant(&bcx, constant);\n+                                    return OperandRef {\n+                                        val: Immediate(val.llval),\n+                                        layout: bcx.ccx.layout_of(val.ty)\n+                                    };\n+                                }\n+                            }\n+                        }\n+\n+                        self.trans_operand(&bcx, arg)\n+                    }).collect();\n+\n+\n                     let callee_ty = common::instance_ty(\n                         bcx.ccx.tcx(), instance.as_ref().unwrap());\n-                    trans_intrinsic_call(&bcx, callee_ty, &fn_ty, &llargs, dest,\n+                    trans_intrinsic_call(&bcx, callee_ty, &fn_ty, &args, dest,\n                                          terminator.source_info.span);\n \n                     if let ReturnDest::IndirectOperand(dst, _) = ret_dest {\n-                        // Make a fake operand for store_return\n-                        let op = OperandRef {\n-                            val: Ref(dst, Alignment::AbiAligned),\n-                            ty: sig.output(),\n-                        };\n-                        self.store_return(&bcx, ret_dest, &fn_ty.ret, op);\n+                        self.store_return(&bcx, ret_dest, &fn_ty.ret, dst.llval);\n                     }\n \n                     if let Some((_, target)) = *destination {\n@@ -581,14 +552,48 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     return;\n                 }\n \n+                // Split the rust-call tupled arguments off.\n+                let (first_args, untuple) = if abi == Abi::RustCall && !args.is_empty() {\n+                    let (tup, args) = args.split_last().unwrap();\n+                    (args, Some(tup))\n+                } else {\n+                    (&args[..], None)\n+                };\n+\n+                for (i, arg) in first_args.iter().enumerate() {\n+                    let mut op = self.trans_operand(&bcx, arg);\n+                    if let (0, Some(ty::InstanceDef::Virtual(_, idx))) = (i, def) {\n+                        if let Pair(data_ptr, meta) = op.val {\n+                            llfn = Some(meth::VirtualIndex::from_index(idx)\n+                                .get_fn(&bcx, meta, &fn_ty));\n+                            llargs.push(data_ptr);\n+                            continue;\n+                        }\n+                    }\n+\n+                    // The callee needs to own the argument memory if we pass it\n+                    // by-ref, so make a local copy of non-immediate constants.\n+                    if let (&mir::Operand::Constant(_), Ref(..)) = (arg, op.val) {\n+                        let tmp = LvalueRef::alloca(&bcx, op.layout, \"const\");\n+                        op.val.store(&bcx, tmp);\n+                        op.val = Ref(tmp.llval, tmp.alignment);\n+                    }\n+\n+                    self.trans_argument(&bcx, op, &mut llargs, &fn_ty.args[i]);\n+                }\n+                if let Some(tup) = untuple {\n+                    self.trans_arguments_untupled(&bcx, tup, &mut llargs,\n+                        &fn_ty.args[first_args.len()..])\n+                }\n+\n                 let fn_ptr = match (llfn, instance) {\n                     (Some(llfn), _) => llfn,\n                     (None, Some(instance)) => callee::get_fn(bcx.ccx, instance),\n                     _ => span_bug!(span, \"no llfn for call\"),\n                 };\n \n                 do_call(self, bcx, fn_ty, fn_ptr, &llargs,\n-                        destination.as_ref().map(|&(_, target)| (ret_dest, sig.output(), target)),\n+                        destination.as_ref().map(|&(_, target)| (ret_dest, target)),\n                         cleanup);\n             }\n             mir::TerminatorKind::GeneratorDrop |\n@@ -601,79 +606,73 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                       bcx: &Builder<'a, 'tcx>,\n                       op: OperandRef<'tcx>,\n                       llargs: &mut Vec<ValueRef>,\n-                      fn_ty: &FnType<'tcx>,\n-                      next_idx: &mut usize,\n-                      llfn: &mut Option<ValueRef>,\n-                      def: &Option<ty::InstanceDef<'tcx>>) {\n-        if let Pair(a, b) = op.val {\n-            // Treat the values in a fat pointer separately.\n-            if common::type_is_fat_ptr(bcx.ccx, op.ty) {\n-                let (ptr, meta) = (a, b);\n-                if *next_idx == 0 {\n-                    if let Some(ty::InstanceDef::Virtual(_, idx)) = *def {\n-                        let llmeth = meth::VirtualIndex::from_index(idx).get_fn(bcx, meta);\n-                        let llty = fn_ty.llvm_type(bcx.ccx).ptr_to();\n-                        *llfn = Some(bcx.pointercast(llmeth, llty));\n-                    }\n-                }\n-\n-                let imm_op = |x| OperandRef {\n-                    val: Immediate(x),\n-                    // We won't be checking the type again.\n-                    ty: bcx.tcx().types.err\n-                };\n-                self.trans_argument(bcx, imm_op(ptr), llargs, fn_ty, next_idx, llfn, def);\n-                self.trans_argument(bcx, imm_op(meta), llargs, fn_ty, next_idx, llfn, def);\n-                return;\n-            }\n-        }\n-\n-        let arg = &fn_ty.args[*next_idx];\n-        *next_idx += 1;\n-\n+                      arg: &ArgType<'tcx>) {\n         // Fill padding with undef value, where applicable.\n         if let Some(ty) = arg.pad {\n-            llargs.push(C_undef(ty));\n+            llargs.push(C_undef(ty.llvm_type(bcx.ccx)));\n         }\n \n         if arg.is_ignore() {\n             return;\n         }\n \n+        if let PassMode::Pair(..) = arg.mode {\n+            match op.val {\n+                Pair(a, b) => {\n+                    llargs.push(a);\n+                    llargs.push(b);\n+                    return;\n+                }\n+                _ => bug!(\"trans_argument: {:?} invalid for pair arugment\", op)\n+            }\n+        }\n+\n         // Force by-ref if we have to load through a cast pointer.\n         let (mut llval, align, by_ref) = match op.val {\n             Immediate(_) | Pair(..) => {\n-                if arg.is_indirect() || arg.cast.is_some() {\n-                    let llscratch = bcx.alloca(arg.memory_ty(bcx.ccx), \"arg\", None);\n-                    self.store_operand(bcx, llscratch, None, op);\n-                    (llscratch, Alignment::AbiAligned, true)\n-                } else {\n-                    (op.pack_if_pair(bcx).immediate(), Alignment::AbiAligned, false)\n+                match arg.mode {\n+                    PassMode::Indirect(_) | PassMode::Cast(_) => {\n+                        let scratch = LvalueRef::alloca(bcx, arg.layout, \"arg\");\n+                        op.val.store(bcx, scratch);\n+                        (scratch.llval, Alignment::AbiAligned, true)\n+                    }\n+                    _ => {\n+                        (op.immediate_or_packed_pair(bcx), Alignment::AbiAligned, false)\n+                    }\n                 }\n             }\n-            Ref(llval, Alignment::Packed) if arg.is_indirect() => {\n+            Ref(llval, align @ Alignment::Packed(_)) if arg.is_indirect() => {\n                 // `foo(packed.large_field)`. We can't pass the (unaligned) field directly. I\n                 // think that ATM (Rust 1.16) we only pass temporaries, but we shouldn't\n                 // have scary latent bugs around.\n \n-                let llscratch = bcx.alloca(arg.memory_ty(bcx.ccx), \"arg\", None);\n-                base::memcpy_ty(bcx, llscratch, llval, op.ty, Some(1));\n-                (llscratch, Alignment::AbiAligned, true)\n+                let scratch = LvalueRef::alloca(bcx, arg.layout, \"arg\");\n+                base::memcpy_ty(bcx, scratch.llval, llval, op.layout, align.non_abi());\n+                (scratch.llval, Alignment::AbiAligned, true)\n             }\n             Ref(llval, align) => (llval, align, true)\n         };\n \n         if by_ref && !arg.is_indirect() {\n             // Have to load the argument, maybe while casting it.\n-            if arg.layout.ty == bcx.tcx().types.bool {\n-                // We store bools as i8 so we need to truncate to i1.\n-                llval = bcx.load_range_assert(llval, 0, 2, llvm::False, None);\n-                llval = bcx.trunc(llval, Type::i1(bcx.ccx));\n-            } else if let Some(ty) = arg.cast {\n-                llval = bcx.load(bcx.pointercast(llval, ty.ptr_to()),\n-                                 align.min_with(arg.layout.align(bcx.ccx).abi() as u32));\n+            if let PassMode::Cast(ty) = arg.mode {\n+                llval = bcx.load(bcx.pointercast(llval, ty.llvm_type(bcx.ccx).ptr_to()),\n+                                 (align | Alignment::Packed(arg.layout.align))\n+                                    .non_abi());\n             } else {\n-                llval = bcx.load(llval, align.to_align());\n+                // We can't use `LvalueRef::load` here because the argument\n+                // may have a type we don't treat as immediate, but the ABI\n+                // used for this call is passing it by-value. In that case,\n+                // the load would just produce `OperandValue::Ref` instead\n+                // of the `OperandValue::Immediate` we need for the call.\n+                llval = bcx.load(llval, align.non_abi());\n+                if let layout::Abi::Scalar(ref scalar) = arg.layout.abi {\n+                    if scalar.is_bool() {\n+                        bcx.range_metadata(llval, 0..2);\n+                    }\n+                }\n+                // We store bools as i8 so we need to truncate to i1.\n+                llval = base::to_immediate(bcx, llval, arg.layout);\n             }\n         }\n \n@@ -684,89 +683,36 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                                 bcx: &Builder<'a, 'tcx>,\n                                 operand: &mir::Operand<'tcx>,\n                                 llargs: &mut Vec<ValueRef>,\n-                                fn_ty: &FnType<'tcx>,\n-                                next_idx: &mut usize,\n-                                llfn: &mut Option<ValueRef>,\n-                                def: &Option<ty::InstanceDef<'tcx>>) {\n+                                args: &[ArgType<'tcx>]) {\n         let tuple = self.trans_operand(bcx, operand);\n \n-        let arg_types = match tuple.ty.sty {\n-            ty::TyTuple(ref tys, _) => tys,\n-            _ => span_bug!(self.mir.span,\n-                           \"bad final argument to \\\"rust-call\\\" fn {:?}\", tuple.ty)\n-        };\n-\n         // Handle both by-ref and immediate tuples.\n-        match tuple.val {\n-            Ref(llval, align) => {\n-                for (n, &ty) in arg_types.iter().enumerate() {\n-                    let ptr = LvalueRef::new_sized_ty(llval, tuple.ty, align);\n-                    let (ptr, align) = ptr.trans_field_ptr(bcx, n);\n-                    let val = if common::type_is_fat_ptr(bcx.ccx, ty) {\n-                        let (lldata, llextra) = base::load_fat_ptr(bcx, ptr, align, ty);\n-                        Pair(lldata, llextra)\n-                    } else {\n-                        // trans_argument will load this if it needs to\n-                        Ref(ptr, align)\n-                    };\n-                    let op = OperandRef {\n-                        val,\n-                        ty,\n-                    };\n-                    self.trans_argument(bcx, op, llargs, fn_ty, next_idx, llfn, def);\n-                }\n-\n-            }\n-            Immediate(llval) => {\n-                let l = bcx.ccx.layout_of(tuple.ty);\n-                let v = if let layout::Univariant { ref variant, .. } = *l {\n-                    variant\n-                } else {\n-                    bug!(\"Not a tuple.\");\n-                };\n-                for (n, &ty) in arg_types.iter().enumerate() {\n-                    let mut elem = bcx.extract_value(\n-                        llval, adt::struct_llfields_index(v, n));\n-                    // Truncate bools to i1, if needed\n-                    if ty.is_bool() && common::val_ty(elem) != Type::i1(bcx.ccx) {\n-                        elem = bcx.trunc(elem, Type::i1(bcx.ccx));\n-                    }\n-                    // If the tuple is immediate, the elements are as well\n-                    let op = OperandRef {\n-                        val: Immediate(elem),\n-                        ty,\n-                    };\n-                    self.trans_argument(bcx, op, llargs, fn_ty, next_idx, llfn, def);\n-                }\n+        if let Ref(llval, align) = tuple.val {\n+            let tuple_ptr = LvalueRef::new_sized(llval, tuple.layout, align);\n+            for i in 0..tuple.layout.fields.count() {\n+                let field_ptr = tuple_ptr.project_field(bcx, i);\n+                self.trans_argument(bcx, field_ptr.load(bcx), llargs, &args[i]);\n             }\n-            Pair(a, b) => {\n-                let elems = [a, b];\n-                for (n, &ty) in arg_types.iter().enumerate() {\n-                    let mut elem = elems[n];\n-                    // Truncate bools to i1, if needed\n-                    if ty.is_bool() && common::val_ty(elem) != Type::i1(bcx.ccx) {\n-                        elem = bcx.trunc(elem, Type::i1(bcx.ccx));\n-                    }\n-                    // Pair is always made up of immediates\n-                    let op = OperandRef {\n-                        val: Immediate(elem),\n-                        ty,\n-                    };\n-                    self.trans_argument(bcx, op, llargs, fn_ty, next_idx, llfn, def);\n-                }\n+        } else {\n+            // If the tuple is immediate, the elements are as well.\n+            for i in 0..tuple.layout.fields.count() {\n+                let op = tuple.extract_field(bcx, i);\n+                self.trans_argument(bcx, op, llargs, &args[i]);\n             }\n         }\n-\n     }\n \n-    fn get_personality_slot(&mut self, bcx: &Builder<'a, 'tcx>) -> ValueRef {\n+    fn get_personality_slot(&mut self, bcx: &Builder<'a, 'tcx>) -> LvalueRef<'tcx> {\n         let ccx = bcx.ccx;\n-        if let Some(slot) = self.llpersonalityslot {\n+        if let Some(slot) = self.personality_slot {\n             slot\n         } else {\n-            let llretty = Type::struct_(ccx, &[Type::i8p(ccx), Type::i32(ccx)], false);\n-            let slot = bcx.alloca(llretty, \"personalityslot\", None);\n-            self.llpersonalityslot = Some(slot);\n+            let layout = ccx.layout_of(ccx.tcx().intern_tup(&[\n+                ccx.tcx().mk_mut_ptr(ccx.tcx().types.u8),\n+                ccx.tcx().types.i32\n+            ], false));\n+            let slot = LvalueRef::alloca(bcx, layout, \"personalityslot\");\n+            self.personality_slot = Some(slot);\n             slot\n         }\n     }\n@@ -792,18 +738,24 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n         let bcx = self.new_block(\"cleanup\");\n \n-        let ccx = bcx.ccx;\n         let llpersonality = self.ccx.eh_personality();\n-        let llretty = Type::struct_(ccx, &[Type::i8p(ccx), Type::i32(ccx)], false);\n-        let llretval = bcx.landing_pad(llretty, llpersonality, 1, self.llfn);\n-        bcx.set_cleanup(llretval);\n+        let llretty = self.landing_pad_type();\n+        let lp = bcx.landing_pad(llretty, llpersonality, 1, self.llfn);\n+        bcx.set_cleanup(lp);\n+\n         let slot = self.get_personality_slot(&bcx);\n-        Lifetime::Start.call(&bcx, slot);\n-        bcx.store(llretval, slot, None);\n+        slot.storage_live(&bcx);\n+        Pair(bcx.extract_value(lp, 0), bcx.extract_value(lp, 1)).store(&bcx, slot);\n+\n         bcx.br(target_bb);\n         bcx.llbb()\n     }\n \n+    fn landing_pad_type(&self) -> Type {\n+        let ccx = self.ccx;\n+        Type::struct_(ccx, &[Type::i8p(ccx), Type::i32(ccx)], false)\n+    }\n+\n     fn unreachable_block(&mut self) -> BasicBlockRef {\n         self.unreachable_block.unwrap_or_else(|| {\n             let bl = self.new_block(\"unreachable\");\n@@ -824,31 +776,33 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     }\n \n     fn make_return_dest(&mut self, bcx: &Builder<'a, 'tcx>,\n-                        dest: &mir::Lvalue<'tcx>, fn_ret_ty: &ArgType,\n-                        llargs: &mut Vec<ValueRef>, is_intrinsic: bool) -> ReturnDest {\n+                        dest: &mir::Lvalue<'tcx>, fn_ret: &ArgType<'tcx>,\n+                        llargs: &mut Vec<ValueRef>, is_intrinsic: bool)\n+                        -> ReturnDest<'tcx> {\n         // If the return is ignored, we can just return a do-nothing ReturnDest\n-        if fn_ret_ty.is_ignore() {\n+        if fn_ret.is_ignore() {\n             return ReturnDest::Nothing;\n         }\n         let dest = if let mir::Lvalue::Local(index) = *dest {\n-            let ret_ty = self.monomorphized_lvalue_ty(dest);\n             match self.locals[index] {\n                 LocalRef::Lvalue(dest) => dest,\n                 LocalRef::Operand(None) => {\n                     // Handle temporary lvalues, specifically Operand ones, as\n                     // they don't have allocas\n-                    return if fn_ret_ty.is_indirect() {\n+                    return if fn_ret.is_indirect() {\n                         // Odd, but possible, case, we have an operand temporary,\n                         // but the calling convention has an indirect return.\n-                        let tmp = LvalueRef::alloca(bcx, ret_ty, \"tmp_ret\");\n+                        let tmp = LvalueRef::alloca(bcx, fn_ret.layout, \"tmp_ret\");\n+                        tmp.storage_live(bcx);\n                         llargs.push(tmp.llval);\n-                        ReturnDest::IndirectOperand(tmp.llval, index)\n+                        ReturnDest::IndirectOperand(tmp, index)\n                     } else if is_intrinsic {\n                         // Currently, intrinsics always need a location to store\n                         // the result. so we create a temporary alloca for the\n                         // result\n-                        let tmp = LvalueRef::alloca(bcx, ret_ty, \"tmp_ret\");\n-                        ReturnDest::IndirectOperand(tmp.llval, index)\n+                        let tmp = LvalueRef::alloca(bcx, fn_ret.layout, \"tmp_ret\");\n+                        tmp.storage_live(bcx);\n+                        ReturnDest::IndirectOperand(tmp, index)\n                     } else {\n                         ReturnDest::DirectOperand(index)\n                     };\n@@ -860,13 +814,13 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         } else {\n             self.trans_lvalue(bcx, dest)\n         };\n-        if fn_ret_ty.is_indirect() {\n+        if fn_ret.is_indirect() {\n             match dest.alignment {\n                 Alignment::AbiAligned => {\n                     llargs.push(dest.llval);\n                     ReturnDest::Nothing\n                 },\n-                Alignment::Packed => {\n+                Alignment::Packed(_) => {\n                     // Currently, MIR code generation does not create calls\n                     // that store directly to fields of packed structs (in\n                     // fact, the calls it creates write only to temps),\n@@ -877,7 +831,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 }\n             }\n         } else {\n-            ReturnDest::Store(dest.llval)\n+            ReturnDest::Store(dest)\n         }\n     }\n \n@@ -886,77 +840,81 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                        dst: &mir::Lvalue<'tcx>) {\n         if let mir::Lvalue::Local(index) = *dst {\n             match self.locals[index] {\n-                LocalRef::Lvalue(lvalue) => self.trans_transmute_into(bcx, src, &lvalue),\n+                LocalRef::Lvalue(lvalue) => self.trans_transmute_into(bcx, src, lvalue),\n                 LocalRef::Operand(None) => {\n-                    let lvalue_ty = self.monomorphized_lvalue_ty(dst);\n-                    assert!(!lvalue_ty.has_erasable_regions());\n-                    let lvalue = LvalueRef::alloca(bcx, lvalue_ty, \"transmute_temp\");\n-                    self.trans_transmute_into(bcx, src, &lvalue);\n-                    let op = self.trans_load(bcx, lvalue.llval, lvalue.alignment, lvalue_ty);\n+                    let dst_layout = bcx.ccx.layout_of(self.monomorphized_lvalue_ty(dst));\n+                    assert!(!dst_layout.ty.has_erasable_regions());\n+                    let lvalue = LvalueRef::alloca(bcx, dst_layout, \"transmute_temp\");\n+                    lvalue.storage_live(bcx);\n+                    self.trans_transmute_into(bcx, src, lvalue);\n+                    let op = lvalue.load(bcx);\n+                    lvalue.storage_dead(bcx);\n                     self.locals[index] = LocalRef::Operand(Some(op));\n                 }\n-                LocalRef::Operand(Some(_)) => {\n-                    let ty = self.monomorphized_lvalue_ty(dst);\n-                    assert!(common::type_is_zero_size(bcx.ccx, ty),\n+                LocalRef::Operand(Some(op)) => {\n+                    assert!(op.layout.is_zst(),\n                             \"assigning to initialized SSAtemp\");\n                 }\n             }\n         } else {\n             let dst = self.trans_lvalue(bcx, dst);\n-            self.trans_transmute_into(bcx, src, &dst);\n+            self.trans_transmute_into(bcx, src, dst);\n         }\n     }\n \n     fn trans_transmute_into(&mut self, bcx: &Builder<'a, 'tcx>,\n                             src: &mir::Operand<'tcx>,\n-                            dst: &LvalueRef<'tcx>) {\n-        let val = self.trans_operand(bcx, src);\n-        let llty = type_of::type_of(bcx.ccx, val.ty);\n+                            dst: LvalueRef<'tcx>) {\n+        let src = self.trans_operand(bcx, src);\n+        let llty = src.layout.llvm_type(bcx.ccx);\n         let cast_ptr = bcx.pointercast(dst.llval, llty.ptr_to());\n-        let in_type = val.ty;\n-        let out_type = dst.ty.to_ty(bcx.tcx());\n-        let llalign = cmp::min(bcx.ccx.align_of(in_type), bcx.ccx.align_of(out_type));\n-        self.store_operand(bcx, cast_ptr, Some(llalign), val);\n+        let align = src.layout.align.min(dst.layout.align);\n+        src.val.store(bcx,\n+            LvalueRef::new_sized(cast_ptr, src.layout, Alignment::Packed(align)));\n     }\n \n \n     // Stores the return value of a function call into it's final location.\n     fn store_return(&mut self,\n                     bcx: &Builder<'a, 'tcx>,\n-                    dest: ReturnDest,\n+                    dest: ReturnDest<'tcx>,\n                     ret_ty: &ArgType<'tcx>,\n-                    op: OperandRef<'tcx>) {\n+                    llval: ValueRef) {\n         use self::ReturnDest::*;\n \n         match dest {\n             Nothing => (),\n-            Store(dst) => ret_ty.store(bcx, op.immediate(), dst),\n+            Store(dst) => ret_ty.store(bcx, llval, dst),\n             IndirectOperand(tmp, index) => {\n-                let op = self.trans_load(bcx, tmp, Alignment::AbiAligned, op.ty);\n+                let op = tmp.load(bcx);\n+                tmp.storage_dead(bcx);\n                 self.locals[index] = LocalRef::Operand(Some(op));\n             }\n             DirectOperand(index) => {\n                 // If there is a cast, we have to store and reload.\n-                let op = if ret_ty.cast.is_some() {\n-                    let tmp = LvalueRef::alloca(bcx, op.ty, \"tmp_ret\");\n-                    ret_ty.store(bcx, op.immediate(), tmp.llval);\n-                    self.trans_load(bcx, tmp.llval, tmp.alignment, op.ty)\n+                let op = if let PassMode::Cast(_) = ret_ty.mode {\n+                    let tmp = LvalueRef::alloca(bcx, ret_ty.layout, \"tmp_ret\");\n+                    tmp.storage_live(bcx);\n+                    ret_ty.store(bcx, llval, tmp);\n+                    let op = tmp.load(bcx);\n+                    tmp.storage_dead(bcx);\n+                    op\n                 } else {\n-                    op.unpack_if_pair(bcx)\n+                    OperandRef::from_immediate_or_packed_pair(bcx, llval, ret_ty.layout)\n                 };\n                 self.locals[index] = LocalRef::Operand(Some(op));\n             }\n         }\n     }\n }\n \n-enum ReturnDest {\n+enum ReturnDest<'tcx> {\n     // Do nothing, the return value is indirect or ignored\n     Nothing,\n     // Store the return value to the pointer\n-    Store(ValueRef),\n+    Store(LvalueRef<'tcx>),\n     // Stores an indirect return value to an operand local lvalue\n-    IndirectOperand(ValueRef, mir::Local),\n+    IndirectOperand(LvalueRef<'tcx>, mir::Local),\n     // Stores a direct return value to an operand local lvalue\n     DirectOperand(mir::Local)\n }"}, {"sha": "8c013330e5bcb506dd792ee1103612da777f2adc", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 220, "deletions": 172, "changes": 392, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -18,21 +18,21 @@ use rustc::traits;\n use rustc::mir;\n use rustc::mir::tcx::LvalueTy;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n-use rustc::ty::layout::{self, LayoutTyper};\n+use rustc::ty::layout::{self, LayoutOf, Size};\n use rustc::ty::cast::{CastTy, IntTy};\n use rustc::ty::subst::{Kind, Substs, Subst};\n use rustc_apfloat::{ieee, Float, Status};\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n-use {adt, base, machine};\n+use base;\n use abi::{self, Abi};\n use callee;\n use builder::Builder;\n use common::{self, CrateContext, const_get_elt, val_ty};\n-use common::{C_array, C_bool, C_bytes, C_int, C_uint, C_big_integral, C_u32, C_u64};\n-use common::{C_null, C_struct, C_str_slice, C_undef, C_usize, C_vector, is_undef};\n+use common::{C_array, C_bool, C_bytes, C_int, C_uint, C_uint_big, C_u32, C_u64};\n+use common::{C_null, C_struct, C_str_slice, C_undef, C_usize, C_vector, C_fat_ptr};\n use common::const_to_opt_u128;\n use consts;\n-use type_of;\n+use type_of::LayoutLlvmExt;\n use type_::Type;\n use value::Value;\n \n@@ -55,40 +55,39 @@ pub struct Const<'tcx> {\n     pub ty: Ty<'tcx>\n }\n \n-impl<'tcx> Const<'tcx> {\n+impl<'a, 'tcx> Const<'tcx> {\n     pub fn new(llval: ValueRef, ty: Ty<'tcx>) -> Const<'tcx> {\n         Const {\n             llval,\n             ty,\n         }\n     }\n \n-    pub fn from_constint<'a>(ccx: &CrateContext<'a, 'tcx>, ci: &ConstInt)\n-    -> Const<'tcx> {\n+    pub fn from_constint(ccx: &CrateContext<'a, 'tcx>, ci: &ConstInt) -> Const<'tcx> {\n         let tcx = ccx.tcx();\n         let (llval, ty) = match *ci {\n             I8(v) => (C_int(Type::i8(ccx), v as i64), tcx.types.i8),\n             I16(v) => (C_int(Type::i16(ccx), v as i64), tcx.types.i16),\n             I32(v) => (C_int(Type::i32(ccx), v as i64), tcx.types.i32),\n             I64(v) => (C_int(Type::i64(ccx), v as i64), tcx.types.i64),\n-            I128(v) => (C_big_integral(Type::i128(ccx), v as u128), tcx.types.i128),\n+            I128(v) => (C_uint_big(Type::i128(ccx), v as u128), tcx.types.i128),\n             Isize(v) => (C_int(Type::isize(ccx), v.as_i64()), tcx.types.isize),\n             U8(v) => (C_uint(Type::i8(ccx), v as u64), tcx.types.u8),\n             U16(v) => (C_uint(Type::i16(ccx), v as u64), tcx.types.u16),\n             U32(v) => (C_uint(Type::i32(ccx), v as u64), tcx.types.u32),\n             U64(v) => (C_uint(Type::i64(ccx), v), tcx.types.u64),\n-            U128(v) => (C_big_integral(Type::i128(ccx), v), tcx.types.u128),\n+            U128(v) => (C_uint_big(Type::i128(ccx), v), tcx.types.u128),\n             Usize(v) => (C_uint(Type::isize(ccx), v.as_u64()), tcx.types.usize),\n         };\n         Const { llval: llval, ty: ty }\n     }\n \n     /// Translate ConstVal into a LLVM constant value.\n-    pub fn from_constval<'a>(ccx: &CrateContext<'a, 'tcx>,\n-                             cv: &ConstVal,\n-                             ty: Ty<'tcx>)\n-                             -> Const<'tcx> {\n-        let llty = type_of::type_of(ccx, ty);\n+    pub fn from_constval(ccx: &CrateContext<'a, 'tcx>,\n+                         cv: &ConstVal,\n+                         ty: Ty<'tcx>)\n+                         -> Const<'tcx> {\n+        let llty = ccx.layout_of(ty).llvm_type(ccx);\n         let val = match *cv {\n             ConstVal::Float(v) => {\n                 let bits = match v.ty {\n@@ -100,9 +99,11 @@ impl<'tcx> Const<'tcx> {\n             ConstVal::Bool(v) => C_bool(ccx, v),\n             ConstVal::Integral(ref i) => return Const::from_constint(ccx, i),\n             ConstVal::Str(ref v) => C_str_slice(ccx, v.clone()),\n-            ConstVal::ByteStr(v) => consts::addr_of(ccx, C_bytes(ccx, v.data), 1, \"byte_str\"),\n+            ConstVal::ByteStr(v) => {\n+                consts::addr_of(ccx, C_bytes(ccx, v.data), ccx.align_of(ty), \"byte_str\")\n+            }\n             ConstVal::Char(c) => C_uint(Type::char(ccx), c as u64),\n-            ConstVal::Function(..) => C_null(type_of::type_of(ccx, ty)),\n+            ConstVal::Function(..) => C_undef(llty),\n             ConstVal::Variant(_) |\n             ConstVal::Aggregate(..) |\n             ConstVal::Unevaluated(..) => {\n@@ -115,15 +116,44 @@ impl<'tcx> Const<'tcx> {\n         Const::new(val, ty)\n     }\n \n-    fn get_pair(&self) -> (ValueRef, ValueRef) {\n-        (const_get_elt(self.llval, &[0]),\n-         const_get_elt(self.llval, &[1]))\n+    fn get_field(&self, ccx: &CrateContext<'a, 'tcx>, i: usize) -> ValueRef {\n+        let layout = ccx.layout_of(self.ty);\n+        let field = layout.field(ccx, i);\n+        if field.is_zst() {\n+            return C_undef(field.immediate_llvm_type(ccx));\n+        }\n+        match layout.abi {\n+            layout::Abi::Scalar(_) => self.llval,\n+            layout::Abi::ScalarPair(ref a, ref b) => {\n+                let offset = layout.fields.offset(i);\n+                if offset.bytes() == 0 {\n+                    if field.size == layout.size {\n+                        self.llval\n+                    } else {\n+                        assert_eq!(field.size, a.value.size(ccx));\n+                        const_get_elt(self.llval, 0)\n+                    }\n+                } else {\n+                    assert_eq!(offset, a.value.size(ccx)\n+                        .abi_align(b.value.align(ccx)));\n+                    assert_eq!(field.size, b.value.size(ccx));\n+                    const_get_elt(self.llval, 1)\n+                }\n+            }\n+            _ => {\n+                const_get_elt(self.llval, layout.llvm_field_index(i))\n+            }\n+        }\n+    }\n+\n+    fn get_pair(&self, ccx: &CrateContext<'a, 'tcx>) -> (ValueRef, ValueRef) {\n+        (self.get_field(ccx, 0), self.get_field(ccx, 1))\n     }\n \n-    fn get_fat_ptr(&self) -> (ValueRef, ValueRef) {\n+    fn get_fat_ptr(&self, ccx: &CrateContext<'a, 'tcx>) -> (ValueRef, ValueRef) {\n         assert_eq!(abi::FAT_PTR_ADDR, 0);\n         assert_eq!(abi::FAT_PTR_EXTRA, 1);\n-        self.get_pair()\n+        self.get_pair(ccx)\n     }\n \n     fn as_lvalue(&self) -> ConstLvalue<'tcx> {\n@@ -134,27 +164,30 @@ impl<'tcx> Const<'tcx> {\n         }\n     }\n \n-    pub fn to_operand<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> OperandRef<'tcx> {\n-        let llty = type_of::immediate_type_of(ccx, self.ty);\n+    pub fn to_operand(&self, ccx: &CrateContext<'a, 'tcx>) -> OperandRef<'tcx> {\n+        let layout = ccx.layout_of(self.ty);\n+        let llty = layout.immediate_llvm_type(ccx);\n         let llvalty = val_ty(self.llval);\n \n-        let val = if llty == llvalty && common::type_is_imm_pair(ccx, self.ty) {\n-            let (a, b) = self.get_pair();\n-            OperandValue::Pair(a, b)\n-        } else if llty == llvalty && common::type_is_immediate(ccx, self.ty) {\n+        let val = if llty == llvalty && layout.is_llvm_scalar_pair() {\n+            OperandValue::Pair(\n+                const_get_elt(self.llval, 0),\n+                const_get_elt(self.llval, 1))\n+        } else if llty == llvalty && layout.is_llvm_immediate() {\n             // If the types match, we can use the value directly.\n             OperandValue::Immediate(self.llval)\n         } else {\n             // Otherwise, or if the value is not immediate, we create\n             // a constant LLVM global and cast its address if necessary.\n             let align = ccx.align_of(self.ty);\n             let ptr = consts::addr_of(ccx, self.llval, align, \"const\");\n-            OperandValue::Ref(consts::ptrcast(ptr, llty.ptr_to()), Alignment::AbiAligned)\n+            OperandValue::Ref(consts::ptrcast(ptr, layout.llvm_type(ccx).ptr_to()),\n+                              Alignment::AbiAligned)\n         };\n \n         OperandRef {\n             val,\n-            ty: self.ty\n+            layout: ccx.layout_of(self.ty)\n         }\n     }\n }\n@@ -368,12 +401,12 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                             match &tcx.item_name(def_id)[..] {\n                                 \"size_of\" => {\n                                     let llval = C_usize(self.ccx,\n-                                        self.ccx.size_of(substs.type_at(0)));\n+                                        self.ccx.size_of(substs.type_at(0)).bytes());\n                                     Ok(Const::new(llval, tcx.types.usize))\n                                 }\n                                 \"min_align_of\" => {\n                                     let llval = C_usize(self.ccx,\n-                                        self.ccx.align_of(substs.type_at(0)) as u64);\n+                                        self.ccx.align_of(substs.type_at(0)).abi());\n                                     Ok(Const::new(llval, tcx.types.usize))\n                                 }\n                                 _ => span_bug!(span, \"{:?} in constant\", terminator.kind)\n@@ -436,7 +469,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                         let (base, extra) = if !has_metadata {\n                             (base.llval, ptr::null_mut())\n                         } else {\n-                            base.get_fat_ptr()\n+                            base.get_fat_ptr(self.ccx)\n                         };\n                         if self.ccx.statics().borrow().contains_key(&base) {\n                             (Base::Static(base), extra)\n@@ -450,9 +483,10 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                                 span_bug!(span, \"dereference of non-constant pointer `{:?}`\",\n                                           Value(base));\n                             }\n-                            if projected_ty.is_bool() {\n+                            let layout = self.ccx.layout_of(projected_ty);\n+                            if let layout::Abi::Scalar(ref scalar) = layout.abi {\n                                 let i1_type = Type::i1(self.ccx);\n-                                if val_ty(val) != i1_type {\n+                                if scalar.is_bool() && val_ty(val) != i1_type {\n                                     unsafe {\n                                         val = llvm::LLVMConstTrunc(val, i1_type.to_ref());\n                                     }\n@@ -462,8 +496,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                         }\n                     }\n                     mir::ProjectionElem::Field(ref field, _) => {\n-                        let llprojected = adt::const_get_field(self.ccx, tr_base.ty, base.llval,\n-                                                               field.index());\n+                        let llprojected = base.get_field(self.ccx, field.index());\n                         let llextra = if !has_metadata {\n                             ptr::null_mut()\n                         } else {\n@@ -484,9 +517,9 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                         // Produce an undef instead of a LLVM assertion on OOB.\n                         let len = common::const_to_uint(tr_base.len(self.ccx));\n                         let llelem = if iv < len as u128 {\n-                            const_get_elt(base.llval, &[iv as u32])\n+                            const_get_elt(base.llval, iv as u64)\n                         } else {\n-                            C_undef(type_of::type_of(self.ccx, projected_ty))\n+                            C_undef(self.ccx.layout_of(projected_ty).llvm_type(self.ccx))\n                         };\n \n                         (Base::Value(llelem), ptr::null_mut())\n@@ -540,7 +573,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n         let elem_ty = array_ty.builtin_index().unwrap_or_else(|| {\n             bug!(\"bad array type {:?}\", array_ty)\n         });\n-        let llunitty = type_of::type_of(self.ccx, elem_ty);\n+        let llunitty = self.ccx.layout_of(elem_ty).llvm_type(self.ccx);\n         // If the array contains enums, an LLVM array won't work.\n         let val = if fields.iter().all(|&f| val_ty(f) == llunitty) {\n             C_array(llunitty, fields)\n@@ -566,7 +599,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                 self.const_array(dest_ty, &fields)\n             }\n \n-            mir::Rvalue::Aggregate(ref kind, ref operands) => {\n+            mir::Rvalue::Aggregate(box mir::AggregateKind::Array(_), ref operands) => {\n                 // Make sure to evaluate all operands to\n                 // report as many errors as we possibly can.\n                 let mut fields = Vec::with_capacity(operands.len());\n@@ -579,17 +612,23 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                 }\n                 failure?;\n \n-                match **kind {\n-                    mir::AggregateKind::Array(_) => {\n-                        self.const_array(dest_ty, &fields)\n-                    }\n-                    mir::AggregateKind::Adt(..) |\n-                    mir::AggregateKind::Closure(..) |\n-                    mir::AggregateKind::Generator(..) |\n-                    mir::AggregateKind::Tuple => {\n-                        Const::new(trans_const(self.ccx, dest_ty, kind, &fields), dest_ty)\n+                self.const_array(dest_ty, &fields)\n+            }\n+\n+            mir::Rvalue::Aggregate(ref kind, ref operands) => {\n+                // Make sure to evaluate all operands to\n+                // report as many errors as we possibly can.\n+                let mut fields = Vec::with_capacity(operands.len());\n+                let mut failure = Ok(());\n+                for operand in operands {\n+                    match self.const_operand(operand, span) {\n+                        Ok(val) => fields.push(val),\n+                        Err(err) => if failure.is_ok() { failure = Err(err); }\n                     }\n                 }\n+                failure?;\n+\n+                trans_const_adt(self.ccx, dest_ty, kind, &fields)\n             }\n \n             mir::Rvalue::Cast(ref kind, ref source, cast_ty) => {\n@@ -635,10 +674,6 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                         operand.llval\n                     }\n                     mir::CastKind::Unsize => {\n-                        // unsize targets other than to a fat pointer currently\n-                        // can't be in constants.\n-                        assert!(common::type_is_fat_ptr(self.ccx, cast_ty));\n-\n                         let pointee_ty = operand.ty.builtin_deref(true, ty::NoPreference)\n                             .expect(\"consts: unsizing got non-pointer type\").ty;\n                         let (base, old_info) = if !self.ccx.shared().type_is_sized(pointee_ty) {\n@@ -648,15 +683,15 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                             // to use a different vtable. In that case, we want to\n                             // load out the original data pointer so we can repackage\n                             // it.\n-                            let (base, extra) = operand.get_fat_ptr();\n+                            let (base, extra) = operand.get_fat_ptr(self.ccx);\n                             (base, Some(extra))\n                         } else {\n                             (operand.llval, None)\n                         };\n \n                         let unsized_ty = cast_ty.builtin_deref(true, ty::NoPreference)\n                             .expect(\"consts: unsizing got non-pointer target type\").ty;\n-                        let ptr_ty = type_of::in_memory_type_of(self.ccx, unsized_ty).ptr_to();\n+                        let ptr_ty = self.ccx.layout_of(unsized_ty).llvm_type(self.ccx).ptr_to();\n                         let base = consts::ptrcast(base, ptr_ty);\n                         let info = base::unsized_info(self.ccx, pointee_ty,\n                                                       unsized_ty, old_info);\n@@ -666,22 +701,23 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                                                      .insert(base, operand.llval);\n                             assert!(prev_const.is_none() || prev_const == Some(operand.llval));\n                         }\n-                        assert_eq!(abi::FAT_PTR_ADDR, 0);\n-                        assert_eq!(abi::FAT_PTR_EXTRA, 1);\n-                        C_struct(self.ccx, &[base, info], false)\n+                        C_fat_ptr(self.ccx, base, info)\n                     }\n-                    mir::CastKind::Misc if common::type_is_immediate(self.ccx, operand.ty) => {\n-                        debug_assert!(common::type_is_immediate(self.ccx, cast_ty));\n+                    mir::CastKind::Misc if self.ccx.layout_of(operand.ty).is_llvm_immediate() => {\n                         let r_t_in = CastTy::from_ty(operand.ty).expect(\"bad input type for cast\");\n                         let r_t_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n-                        let ll_t_out = type_of::immediate_type_of(self.ccx, cast_ty);\n+                        let cast_layout = self.ccx.layout_of(cast_ty);\n+                        assert!(cast_layout.is_llvm_immediate());\n+                        let ll_t_out = cast_layout.immediate_llvm_type(self.ccx);\n                         let llval = operand.llval;\n-                        let signed = if let CastTy::Int(IntTy::CEnum) = r_t_in {\n-                            let l = self.ccx.layout_of(operand.ty);\n-                            adt::is_discr_signed(&l)\n-                        } else {\n-                            operand.ty.is_signed()\n-                        };\n+\n+                        let mut signed = false;\n+                        let l = self.ccx.layout_of(operand.ty);\n+                        if let layout::Abi::Scalar(ref scalar) = l.abi {\n+                            if let layout::Int(_, true) = scalar.value {\n+                                signed = true;\n+                            }\n+                        }\n \n                         unsafe {\n                             match (r_t_in, r_t_out) {\n@@ -720,20 +756,19 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                         }\n                     }\n                     mir::CastKind::Misc => { // Casts from a fat-ptr.\n-                        let ll_cast_ty = type_of::immediate_type_of(self.ccx, cast_ty);\n-                        let ll_from_ty = type_of::immediate_type_of(self.ccx, operand.ty);\n-                        if common::type_is_fat_ptr(self.ccx, operand.ty) {\n-                            let (data_ptr, meta_ptr) = operand.get_fat_ptr();\n-                            if common::type_is_fat_ptr(self.ccx, cast_ty) {\n-                                let ll_cft = ll_cast_ty.field_types();\n-                                let ll_fft = ll_from_ty.field_types();\n-                                let data_cast = consts::ptrcast(data_ptr, ll_cft[0]);\n-                                assert_eq!(ll_cft[1].kind(), ll_fft[1].kind());\n-                                C_struct(self.ccx, &[data_cast, meta_ptr], false)\n+                        let l = self.ccx.layout_of(operand.ty);\n+                        let cast = self.ccx.layout_of(cast_ty);\n+                        if l.is_llvm_scalar_pair() {\n+                            let (data_ptr, meta) = operand.get_fat_ptr(self.ccx);\n+                            if cast.is_llvm_scalar_pair() {\n+                                let data_cast = consts::ptrcast(data_ptr,\n+                                    cast.scalar_pair_element_llvm_type(self.ccx, 0));\n+                                C_fat_ptr(self.ccx, data_cast, meta)\n                             } else { // cast to thin-ptr\n                                 // Cast of fat-ptr to thin-ptr is an extraction of data-ptr and\n                                 // pointer-cast of that pointer to desired pointer type.\n-                                consts::ptrcast(data_ptr, ll_cast_ty)\n+                                let llcast_ty = cast.immediate_llvm_type(self.ccx);\n+                                consts::ptrcast(data_ptr, llcast_ty)\n                             }\n                         } else {\n                             bug!(\"Unexpected non-fat-pointer operand\")\n@@ -756,7 +791,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                         let align = if self.ccx.shared().type_is_sized(ty) {\n                             self.ccx.align_of(ty)\n                         } else {\n-                            self.ccx.tcx().data_layout.pointer_align.abi() as machine::llalign\n+                            self.ccx.tcx().data_layout.pointer_align\n                         };\n                         if bk == mir::BorrowKind::Mut {\n                             consts::addr_of_mut(self.ccx, llval, align, \"ref_mut\")\n@@ -771,7 +806,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                 let ptr = if self.ccx.shared().type_is_sized(ty) {\n                     base\n                 } else {\n-                    C_struct(self.ccx, &[base, tr_lvalue.llextra], false)\n+                    C_fat_ptr(self.ccx, base, tr_lvalue.llextra)\n                 };\n                 Const::new(ptr, ref_ty)\n             }\n@@ -801,8 +836,10 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n \n                 match const_scalar_checked_binop(tcx, op, lhs, rhs, ty) {\n                     Some((llval, of)) => {\n-                        let llof = C_bool(self.ccx, of);\n-                        Const::new(C_struct(self.ccx, &[llval, llof], false), binop_ty)\n+                        trans_const_adt(self.ccx, binop_ty, &mir::AggregateKind::Tuple, &[\n+                            Const::new(llval, val_ty),\n+                            Const::new(C_bool(self.ccx, of), tcx.types.bool)\n+                        ])\n                     }\n                     None => {\n                         span_bug!(span, \"{:?} got non-integer operands: {:?} and {:?}\",\n@@ -836,7 +873,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n \n             mir::Rvalue::NullaryOp(mir::NullOp::SizeOf, ty) => {\n                 assert!(self.ccx.shared().type_is_sized(ty));\n-                let llval = C_usize(self.ccx, self.ccx.size_of(ty));\n+                let llval = C_usize(self.ccx, self.ccx.size_of(ty).bytes());\n                 Const::new(llval, tcx.types.usize)\n             }\n \n@@ -986,7 +1023,7 @@ unsafe fn cast_const_float_to_int(ccx: &CrateContext,\n         let err = ConstEvalErr { span: span, kind: ErrKind::CannotCast };\n         err.report(ccx.tcx(), span, \"expression\");\n     }\n-    C_big_integral(int_ty, cast_result.value)\n+    C_uint_big(int_ty, cast_result.value)\n }\n \n unsafe fn cast_const_int_to_float(ccx: &CrateContext,\n@@ -1037,7 +1074,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n         let result = result.unwrap_or_else(|_| {\n             // We've errored, so we don't have to produce working code.\n-            let llty = type_of::type_of(bcx.ccx, ty);\n+            let llty = bcx.ccx.layout_of(ty).llvm_type(bcx.ccx);\n             Const::new(C_undef(llty), ty)\n         });\n \n@@ -1075,134 +1112,145 @@ pub fn trans_static_initializer<'a, 'tcx>(\n /// Currently the returned value has the same size as the type, but\n /// this could be changed in the future to avoid allocating unnecessary\n /// space after values of shorter-than-maximum cases.\n-fn trans_const<'a, 'tcx>(\n+fn trans_const_adt<'a, 'tcx>(\n     ccx: &CrateContext<'a, 'tcx>,\n     t: Ty<'tcx>,\n     kind: &mir::AggregateKind,\n-    vals: &[ValueRef]\n-) -> ValueRef {\n+    vals: &[Const<'tcx>]\n+) -> Const<'tcx> {\n     let l = ccx.layout_of(t);\n     let variant_index = match *kind {\n         mir::AggregateKind::Adt(_, index, _, _) => index,\n         _ => 0,\n     };\n-    match *l {\n-        layout::CEnum { discr: d, min, max, .. } => {\n+\n+    if let layout::Abi::Uninhabited = l.abi {\n+        return Const::new(C_undef(l.llvm_type(ccx)), t);\n+    }\n+\n+    match l.variants {\n+        layout::Variants::Single { index } => {\n+            assert_eq!(variant_index, index);\n+            if let layout::Abi::Vector = l.abi {\n+                Const::new(C_vector(&vals.iter().map(|x| x.llval).collect::<Vec<_>>()), t)\n+            } else if let layout::FieldPlacement::Union(_) = l.fields {\n+                assert_eq!(variant_index, 0);\n+                assert_eq!(vals.len(), 1);\n+                let contents = [\n+                    vals[0].llval,\n+                    padding(ccx, l.size - ccx.size_of(vals[0].ty))\n+                ];\n+\n+                Const::new(C_struct(ccx, &contents, l.is_packed()), t)\n+            } else {\n+                build_const_struct(ccx, l, vals, None)\n+            }\n+        }\n+        layout::Variants::Tagged { .. } => {\n             let discr = match *kind {\n                 mir::AggregateKind::Adt(adt_def, _, _, _) => {\n                     adt_def.discriminant_for_variant(ccx.tcx(), variant_index)\n                            .to_u128_unchecked() as u64\n                 },\n                 _ => 0,\n             };\n-            assert_eq!(vals.len(), 0);\n-            adt::assert_discr_in_range(min, max, discr);\n-            C_int(Type::from_integer(ccx, d), discr as i64)\n-        }\n-        layout::General { discr: d, ref variants, .. } => {\n-            let variant = &variants[variant_index];\n-            let lldiscr = C_int(Type::from_integer(ccx, d), variant_index as i64);\n-            let mut vals_with_discr = vec![lldiscr];\n-            vals_with_discr.extend_from_slice(vals);\n-            let mut contents = build_const_struct(ccx, &variant, &vals_with_discr[..]);\n-            let needed_padding = l.size(ccx).bytes() - variant.stride().bytes();\n-            if needed_padding > 0 {\n-                contents.push(padding(ccx, needed_padding));\n-            }\n-            C_struct(ccx, &contents[..], false)\n-        }\n-        layout::UntaggedUnion { ref variants, .. }=> {\n-            assert_eq!(variant_index, 0);\n-            let contents = build_const_union(ccx, variants, vals[0]);\n-            C_struct(ccx, &contents, variants.packed)\n-        }\n-        layout::Univariant { ref variant, .. } => {\n-            assert_eq!(variant_index, 0);\n-            let contents = build_const_struct(ccx, &variant, vals);\n-            C_struct(ccx, &contents[..], variant.packed)\n-        }\n-        layout::Vector { .. } => {\n-            C_vector(vals)\n-        }\n-        layout::RawNullablePointer { nndiscr, .. } => {\n-            if variant_index as u64 == nndiscr {\n-                assert_eq!(vals.len(), 1);\n-                vals[0]\n+            let discr_field = l.field(ccx, 0);\n+            let discr = C_int(discr_field.llvm_type(ccx), discr as i64);\n+            if let layout::Abi::Scalar(_) = l.abi {\n+                Const::new(discr, t)\n             } else {\n-                C_null(type_of::type_of(ccx, t))\n+                let discr = Const::new(discr, discr_field.ty);\n+                build_const_struct(ccx, l.for_variant(ccx, variant_index), vals, Some(discr))\n             }\n         }\n-        layout::StructWrappedNullablePointer { ref nonnull, nndiscr, .. } => {\n-            if variant_index as u64 == nndiscr {\n-                C_struct(ccx, &build_const_struct(ccx, &nonnull, vals), false)\n+        layout::Variants::NicheFilling {\n+            dataful_variant,\n+            ref niche_variants,\n+            niche_start,\n+            ..\n+        } => {\n+            if variant_index == dataful_variant {\n+                build_const_struct(ccx, l.for_variant(ccx, dataful_variant), vals, None)\n             } else {\n-                // Always use null even if it's not the `discrfield`th\n-                // field; see #8506.\n-                C_null(type_of::type_of(ccx, t))\n+                let niche = l.field(ccx, 0);\n+                let niche_llty = niche.llvm_type(ccx);\n+                let niche_value = ((variant_index - niche_variants.start) as u128)\n+                    .wrapping_add(niche_start);\n+                // FIXME(eddyb) Check the actual primitive type here.\n+                let niche_llval = if niche_value == 0 {\n+                    // HACK(eddyb) Using `C_null` as it works on all types.\n+                    C_null(niche_llty)\n+                } else {\n+                    C_uint_big(niche_llty, niche_value)\n+                };\n+                build_const_struct(ccx, l, &[Const::new(niche_llval, niche.ty)], None)\n             }\n         }\n-        _ => bug!(\"trans_const: cannot handle type {} repreented as {:#?}\", t, l)\n     }\n }\n \n /// Building structs is a little complicated, because we might need to\n /// insert padding if a field's value is less aligned than its type.\n ///\n-/// Continuing the example from `trans_const`, a value of type `(u32,\n+/// Continuing the example from `trans_const_adt`, a value of type `(u32,\n /// E)` should have the `E` at offset 8, but if that field's\n /// initializer is 4-byte aligned then simply translating the tuple as\n /// a two-element struct will locate it at offset 4, and accesses to it\n /// will read the wrong memory.\n fn build_const_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                st: &layout::Struct,\n-                                vals: &[ValueRef])\n-                                -> Vec<ValueRef> {\n-    assert_eq!(vals.len(), st.offsets.len());\n-\n-    if vals.len() == 0 {\n-        return Vec::new();\n+                                layout: layout::TyLayout<'tcx>,\n+                                vals: &[Const<'tcx>],\n+                                discr: Option<Const<'tcx>>)\n+                                -> Const<'tcx> {\n+    assert_eq!(vals.len(), layout.fields.count());\n+\n+    match layout.abi {\n+        layout::Abi::Scalar(_) |\n+        layout::Abi::ScalarPair(..) if discr.is_none() => {\n+            let mut non_zst_fields = vals.iter().enumerate().map(|(i, f)| {\n+                (f, layout.fields.offset(i))\n+            }).filter(|&(f, _)| !ccx.layout_of(f.ty).is_zst());\n+            match (non_zst_fields.next(), non_zst_fields.next()) {\n+                (Some((x, offset)), None) if offset.bytes() == 0 => {\n+                    return Const::new(x.llval, layout.ty);\n+                }\n+                (Some((a, a_offset)), Some((b, _))) if a_offset.bytes() == 0 => {\n+                    return Const::new(C_struct(ccx, &[a.llval, b.llval], false), layout.ty);\n+                }\n+                (Some((a, _)), Some((b, b_offset))) if b_offset.bytes() == 0 => {\n+                    return Const::new(C_struct(ccx, &[b.llval, a.llval], false), layout.ty);\n+                }\n+                _ => {}\n+            }\n+        }\n+        _ => {}\n     }\n \n     // offset of current value\n-    let mut offset = 0;\n+    let mut offset = Size::from_bytes(0);\n     let mut cfields = Vec::new();\n-    cfields.reserve(st.offsets.len()*2);\n+    cfields.reserve(discr.is_some() as usize + 1 + layout.fields.count() * 2);\n \n-    let parts = st.field_index_by_increasing_offset().map(|i| {\n-        (&vals[i], st.offsets[i].bytes())\n-    });\n-    for (&val, target_offset) in parts {\n-        if offset < target_offset {\n-            cfields.push(padding(ccx, target_offset - offset));\n-            offset = target_offset;\n-        }\n-        assert!(!is_undef(val));\n-        cfields.push(val);\n-        offset += machine::llsize_of_alloc(ccx, val_ty(val));\n+    if let Some(discr) = discr {\n+        cfields.push(discr.llval);\n+        offset = ccx.size_of(discr.ty);\n     }\n \n-    if offset < st.stride().bytes() {\n-        cfields.push(padding(ccx, st.stride().bytes() - offset));\n+    let parts = layout.fields.index_by_increasing_offset().map(|i| {\n+        (vals[i], layout.fields.offset(i))\n+    });\n+    for (val, target_offset) in parts {\n+        cfields.push(padding(ccx, target_offset - offset));\n+        cfields.push(val.llval);\n+        offset = target_offset + ccx.size_of(val.ty);\n     }\n \n-    cfields\n-}\n-\n-fn build_const_union<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                               un: &layout::Union,\n-                               field_val: ValueRef)\n-                               -> Vec<ValueRef> {\n-    let mut cfields = vec![field_val];\n-\n-    let offset = machine::llsize_of_alloc(ccx, val_ty(field_val));\n-    let size = un.stride().bytes();\n-    if offset != size {\n-        cfields.push(padding(ccx, size - offset));\n-    }\n+    // Pad to the size of the whole type, not e.g. the variant.\n+    cfields.push(padding(ccx, ccx.size_of(layout.ty) - offset));\n \n-    cfields\n+    Const::new(C_struct(ccx, &cfields, layout.is_packed()), layout.ty)\n }\n \n-fn padding(ccx: &CrateContext, size: u64) -> ValueRef {\n-    C_undef(Type::array(&Type::i8(ccx), size))\n+fn padding(ccx: &CrateContext, size: Size) -> ValueRef {\n+    C_undef(Type::array(&Type::i8(ccx), size.bytes()))\n }"}, {"sha": "891d52045c217a2ae99a7de9a17ff90d7dc8378e", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 323, "deletions": 199, "changes": 522, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -8,18 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use llvm::ValueRef;\n-use rustc::ty::{self, Ty, TypeFoldable};\n-use rustc::ty::layout::{self, LayoutTyper};\n+use llvm::{self, ValueRef};\n+use rustc::ty::{self, Ty};\n+use rustc::ty::layout::{self, Align, TyLayout, LayoutOf};\n use rustc::mir;\n use rustc::mir::tcx::LvalueTy;\n use rustc_data_structures::indexed_vec::Idx;\n-use adt;\n+use base;\n use builder::Builder;\n-use common::{self, CrateContext, C_usize};\n+use common::{CrateContext, C_usize, C_u8, C_u32, C_uint, C_int, C_null, C_uint_big};\n use consts;\n-use machine;\n-use type_of;\n+use type_of::LayoutLlvmExt;\n use type_::Type;\n use value::Value;\n use glue;\n@@ -28,10 +27,11 @@ use std::ptr;\n use std::ops;\n \n use super::{MirContext, LocalRef};\n+use super::operand::{OperandRef, OperandValue};\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub enum Alignment {\n-    Packed,\n+    Packed(Align),\n     AbiAligned,\n }\n \n@@ -40,34 +40,36 @@ impl ops::BitOr for Alignment {\n \n     fn bitor(self, rhs: Self) -> Self {\n         match (self, rhs) {\n-            (Alignment::Packed, _) => Alignment::Packed,\n-            (Alignment::AbiAligned, a) => a,\n+            (Alignment::Packed(a), Alignment::Packed(b)) => {\n+                Alignment::Packed(a.min(b))\n+            }\n+            (Alignment::Packed(x), _) | (_, Alignment::Packed(x)) => {\n+                Alignment::Packed(x)\n+            }\n+            (Alignment::AbiAligned, Alignment::AbiAligned) => {\n+                Alignment::AbiAligned\n+            }\n         }\n     }\n }\n \n-impl Alignment {\n-    pub fn from_packed(packed: bool) -> Self {\n-        if packed {\n-            Alignment::Packed\n+impl<'a> From<TyLayout<'a>> for Alignment {\n+    fn from(layout: TyLayout) -> Self {\n+        if layout.is_packed() {\n+            Alignment::Packed(layout.align)\n         } else {\n             Alignment::AbiAligned\n         }\n     }\n+}\n \n-    pub fn to_align(self) -> Option<u32> {\n+impl Alignment {\n+    pub fn non_abi(self) -> Option<Align> {\n         match self {\n-            Alignment::Packed => Some(1),\n+            Alignment::Packed(x) => Some(x),\n             Alignment::AbiAligned => None,\n         }\n     }\n-\n-    pub fn min_with(self, align: u32) -> Option<u32> {\n-        match self {\n-            Alignment::Packed => Some(1),\n-            Alignment::AbiAligned => Some(align),\n-        }\n-    }\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -79,95 +81,176 @@ pub struct LvalueRef<'tcx> {\n     pub llextra: ValueRef,\n \n     /// Monomorphized type of this lvalue, including variant information\n-    pub ty: LvalueTy<'tcx>,\n+    pub layout: TyLayout<'tcx>,\n \n     /// Whether this lvalue is known to be aligned according to its layout\n     pub alignment: Alignment,\n }\n \n impl<'a, 'tcx> LvalueRef<'tcx> {\n-    pub fn new_sized(llval: ValueRef, lvalue_ty: LvalueTy<'tcx>,\n-                     alignment: Alignment) -> LvalueRef<'tcx> {\n-        LvalueRef { llval: llval, llextra: ptr::null_mut(), ty: lvalue_ty, alignment: alignment }\n-    }\n-\n-    pub fn new_sized_ty(llval: ValueRef, ty: Ty<'tcx>, alignment: Alignment) -> LvalueRef<'tcx> {\n-        LvalueRef::new_sized(llval, LvalueTy::from_ty(ty), alignment)\n+    pub fn new_sized(llval: ValueRef,\n+                     layout: TyLayout<'tcx>,\n+                     alignment: Alignment)\n+                     -> LvalueRef<'tcx> {\n+        LvalueRef {\n+            llval,\n+            llextra: ptr::null_mut(),\n+            layout,\n+            alignment\n+        }\n     }\n \n-    pub fn alloca(bcx: &Builder<'a, 'tcx>, ty: Ty<'tcx>, name: &str) -> LvalueRef<'tcx> {\n-        debug!(\"alloca({:?}: {:?})\", name, ty);\n-        let tmp = bcx.alloca(\n-            type_of::type_of(bcx.ccx, ty), name, bcx.ccx.over_align_of(ty));\n-        assert!(!ty.has_param_types());\n-        Self::new_sized_ty(tmp, ty, Alignment::AbiAligned)\n+    pub fn alloca(bcx: &Builder<'a, 'tcx>, layout: TyLayout<'tcx>, name: &str)\n+                  -> LvalueRef<'tcx> {\n+        debug!(\"alloca({:?}: {:?})\", name, layout);\n+        let tmp = bcx.alloca(layout.llvm_type(bcx.ccx), name, layout.align);\n+        Self::new_sized(tmp, layout, Alignment::AbiAligned)\n     }\n \n     pub fn len(&self, ccx: &CrateContext<'a, 'tcx>) -> ValueRef {\n-        let ty = self.ty.to_ty(ccx.tcx());\n-        match ty.sty {\n-            ty::TyArray(_, n) => {\n-                common::C_usize(ccx, n.val.to_const_int().unwrap().to_u64().unwrap())\n-            }\n-            ty::TySlice(_) | ty::TyStr => {\n-                assert!(self.llextra != ptr::null_mut());\n+        if let layout::FieldPlacement::Array { count, .. } = self.layout.fields {\n+            if self.layout.is_unsized() {\n+                assert!(self.has_extra());\n+                assert_eq!(count, 0);\n                 self.llextra\n+            } else {\n+                C_usize(ccx, count)\n             }\n-            _ => bug!(\"unexpected type `{}` in LvalueRef::len\", ty)\n+        } else {\n+            bug!(\"unexpected layout `{:#?}` in LvalueRef::len\", self.layout)\n         }\n     }\n \n     pub fn has_extra(&self) -> bool {\n         !self.llextra.is_null()\n     }\n \n-    fn struct_field_ptr(\n-        self,\n-        bcx: &Builder<'a, 'tcx>,\n-        st: &layout::Struct,\n-        fields: &Vec<Ty<'tcx>>,\n-        ix: usize,\n-        needs_cast: bool\n-    ) -> (ValueRef, Alignment) {\n-        let fty = fields[ix];\n-        let ccx = bcx.ccx;\n+    pub fn load(&self, bcx: &Builder<'a, 'tcx>) -> OperandRef<'tcx> {\n+        debug!(\"LvalueRef::load: {:?}\", self);\n \n-        let alignment = self.alignment | Alignment::from_packed(st.packed);\n+        assert!(!self.has_extra());\n+\n+        if self.layout.is_zst() {\n+            return OperandRef::new_zst(bcx.ccx, self.layout);\n+        }\n \n-        let llfields = adt::struct_llfields(ccx, fields, st);\n-        let ptr_val = if needs_cast {\n-            let real_ty = Type::struct_(ccx, &llfields[..], st.packed);\n-            bcx.pointercast(self.llval, real_ty.ptr_to())\n+        let scalar_load_metadata = |load, scalar: &layout::Scalar| {\n+            let (min, max) = (scalar.valid_range.start, scalar.valid_range.end);\n+            let max_next = max.wrapping_add(1);\n+            let bits = scalar.value.size(bcx.ccx).bits();\n+            assert!(bits <= 128);\n+            let mask = !0u128 >> (128 - bits);\n+            // For a (max) value of -1, max will be `-1 as usize`, which overflows.\n+            // However, that is fine here (it would still represent the full range),\n+            // i.e., if the range is everything.  The lo==hi case would be\n+            // rejected by the LLVM verifier (it would mean either an\n+            // empty set, which is impossible, or the entire range of the\n+            // type, which is pointless).\n+            match scalar.value {\n+                layout::Int(..) if max_next & mask != min & mask => {\n+                    // llvm::ConstantRange can deal with ranges that wrap around,\n+                    // so an overflow on (max + 1) is fine.\n+                    bcx.range_metadata(load, min..max_next);\n+                }\n+                layout::Pointer if 0 < min && min < max => {\n+                    bcx.nonnull_metadata(load);\n+                }\n+                _ => {}\n+            }\n+        };\n+\n+        let val = if self.layout.is_llvm_immediate() {\n+            let mut const_llval = ptr::null_mut();\n+            unsafe {\n+                let global = llvm::LLVMIsAGlobalVariable(self.llval);\n+                if !global.is_null() && llvm::LLVMIsGlobalConstant(global) == llvm::True {\n+                    const_llval = llvm::LLVMGetInitializer(global);\n+                }\n+            }\n+\n+            let llval = if !const_llval.is_null() {\n+                const_llval\n+            } else {\n+                let load = bcx.load(self.llval, self.alignment.non_abi());\n+                if let layout::Abi::Scalar(ref scalar) = self.layout.abi {\n+                    scalar_load_metadata(load, scalar);\n+                }\n+                load\n+            };\n+            OperandValue::Immediate(base::to_immediate(bcx, llval, self.layout))\n+        } else if let layout::Abi::ScalarPair(ref a, ref b) = self.layout.abi {\n+            let load = |i, scalar: &layout::Scalar| {\n+                let mut llptr = bcx.struct_gep(self.llval, i as u64);\n+                // Make sure to always load i1 as i8.\n+                if scalar.is_bool() {\n+                    llptr = bcx.pointercast(llptr, Type::i8p(bcx.ccx));\n+                }\n+                let load = bcx.load(llptr, self.alignment.non_abi());\n+                scalar_load_metadata(load, scalar);\n+                if scalar.is_bool() {\n+                    bcx.trunc(load, Type::i1(bcx.ccx))\n+                } else {\n+                    load\n+                }\n+            };\n+            OperandValue::Pair(load(0, a), load(1, b))\n         } else {\n-            self.llval\n+            OperandValue::Ref(self.llval, self.alignment)\n+        };\n+\n+        OperandRef { val, layout: self.layout }\n+    }\n+\n+    /// Access a field, at a point when the value's case is known.\n+    pub fn project_field(self, bcx: &Builder<'a, 'tcx>, ix: usize) -> LvalueRef<'tcx> {\n+        let ccx = bcx.ccx;\n+        let field = self.layout.field(ccx, ix);\n+        let offset = self.layout.fields.offset(ix);\n+        let alignment = self.alignment | Alignment::from(self.layout);\n+\n+        let simple = || {\n+            // Unions and newtypes only use an offset of 0.\n+            let llval = if offset.bytes() == 0 {\n+                self.llval\n+            } else if let layout::Abi::ScalarPair(ref a, ref b) = self.layout.abi {\n+                // Offsets have to match either first or second field.\n+                assert_eq!(offset, a.value.size(ccx).abi_align(b.value.align(ccx)));\n+                bcx.struct_gep(self.llval, 1)\n+            } else {\n+                bcx.struct_gep(self.llval, self.layout.llvm_field_index(ix))\n+            };\n+            LvalueRef {\n+                // HACK(eddyb) have to bitcast pointers until LLVM removes pointee types.\n+                llval: bcx.pointercast(llval, field.llvm_type(ccx).ptr_to()),\n+                llextra: if ccx.shared().type_has_metadata(field.ty) {\n+                    self.llextra\n+                } else {\n+                    ptr::null_mut()\n+                },\n+                layout: field,\n+                alignment,\n+            }\n         };\n \n         // Simple case - we can just GEP the field\n-        //   * First field - Always aligned properly\n         //   * Packed struct - There is no alignment padding\n         //   * Field is sized - pointer is properly aligned already\n-        if st.offsets[ix] == layout::Size::from_bytes(0) || st.packed ||\n-            bcx.ccx.shared().type_is_sized(fty)\n-        {\n-            return (bcx.struct_gep(\n-                    ptr_val, adt::struct_llfields_index(st, ix)), alignment);\n+        if self.layout.is_packed() || !field.is_unsized() {\n+            return simple();\n         }\n \n         // If the type of the last field is [T], str or a foreign type, then we don't need to do\n         // any adjusments\n-        match fty.sty {\n-            ty::TySlice(..) | ty::TyStr | ty::TyForeign(..) => {\n-                return (bcx.struct_gep(\n-                        ptr_val, adt::struct_llfields_index(st, ix)), alignment);\n-            }\n+        match field.ty.sty {\n+            ty::TySlice(..) | ty::TyStr | ty::TyForeign(..) => return simple(),\n             _ => ()\n         }\n \n         // There's no metadata available, log the case and just do the GEP.\n         if !self.has_extra() {\n             debug!(\"Unsized field `{}`, of `{:?}` has no metadata for adjustment\",\n-                ix, Value(ptr_val));\n-            return (bcx.struct_gep(ptr_val, adt::struct_llfields_index(st, ix)), alignment);\n+                ix, Value(self.llval));\n+            return simple();\n         }\n \n         // We need to get the pointer manually now.\n@@ -187,102 +270,177 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n \n         let meta = self.llextra;\n \n-\n-        let offset = st.offsets[ix].bytes();\n-        let unaligned_offset = C_usize(bcx.ccx, offset);\n+        let unaligned_offset = C_usize(ccx, offset.bytes());\n \n         // Get the alignment of the field\n-        let (_, align) = glue::size_and_align_of_dst(bcx, fty, meta);\n+        let (_, align) = glue::size_and_align_of_dst(bcx, field.ty, meta);\n \n         // Bump the unaligned offset up to the appropriate alignment using the\n         // following expression:\n         //\n         //   (unaligned offset + (align - 1)) & -align\n \n         // Calculate offset\n-        let align_sub_1 = bcx.sub(align, C_usize(bcx.ccx, 1));\n+        let align_sub_1 = bcx.sub(align, C_usize(ccx, 1u64));\n         let offset = bcx.and(bcx.add(unaligned_offset, align_sub_1),\n         bcx.neg(align));\n \n         debug!(\"struct_field_ptr: DST field offset: {:?}\", Value(offset));\n \n         // Cast and adjust pointer\n-        let byte_ptr = bcx.pointercast(ptr_val, Type::i8p(bcx.ccx));\n+        let byte_ptr = bcx.pointercast(self.llval, Type::i8p(ccx));\n         let byte_ptr = bcx.gep(byte_ptr, &[offset]);\n \n         // Finally, cast back to the type expected\n-        let ll_fty = type_of::in_memory_type_of(bcx.ccx, fty);\n+        let ll_fty = field.llvm_type(ccx);\n         debug!(\"struct_field_ptr: Field type is {:?}\", ll_fty);\n-        (bcx.pointercast(byte_ptr, ll_fty.ptr_to()), alignment)\n+\n+        LvalueRef {\n+            llval: bcx.pointercast(byte_ptr, ll_fty.ptr_to()),\n+            llextra: self.llextra,\n+            layout: field,\n+            alignment,\n+        }\n     }\n \n-    /// Access a field, at a point when the value's case is known.\n-    pub fn trans_field_ptr(self, bcx: &Builder<'a, 'tcx>, ix: usize) -> (ValueRef, Alignment) {\n-        let discr = match self.ty {\n-            LvalueTy::Ty { .. } => 0,\n-            LvalueTy::Downcast { variant_index, .. } => variant_index,\n-        };\n-        let t = self.ty.to_ty(bcx.tcx());\n-        let l = bcx.ccx.layout_of(t);\n-        // Note: if this ever needs to generate conditionals (e.g., if we\n-        // decide to do some kind of cdr-coding-like non-unique repr\n-        // someday), it will need to return a possibly-new bcx as well.\n-        match *l {\n-            layout::Univariant { ref variant, .. } => {\n-                assert_eq!(discr, 0);\n-                self.struct_field_ptr(bcx, &variant,\n-                    &adt::compute_fields(bcx.ccx, t, 0, false), ix, false)\n+    /// Obtain the actual discriminant of a value.\n+    pub fn trans_get_discr(self, bcx: &Builder<'a, 'tcx>, cast_to: Ty<'tcx>) -> ValueRef {\n+        let cast_to = bcx.ccx.layout_of(cast_to).immediate_llvm_type(bcx.ccx);\n+        match self.layout.variants {\n+            layout::Variants::Single { index } => {\n+                return C_uint(cast_to, index as u64);\n             }\n-            layout::Vector { count, .. } => {\n-                assert_eq!(discr, 0);\n-                assert!((ix as u64) < count);\n-                (bcx.struct_gep(self.llval, ix), self.alignment)\n-            }\n-            layout::General { discr: d, ref variants, .. } => {\n-                let mut fields = adt::compute_fields(bcx.ccx, t, discr, false);\n-                fields.insert(0, d.to_ty(&bcx.tcx(), false));\n-                self.struct_field_ptr(bcx, &variants[discr], &fields, ix + 1, true)\n+            layout::Variants::Tagged { .. } |\n+            layout::Variants::NicheFilling { .. } => {},\n+        }\n+\n+        let discr = self.project_field(bcx, 0);\n+        let lldiscr = discr.load(bcx).immediate();\n+        match self.layout.variants {\n+            layout::Variants::Single { .. } => bug!(),\n+            layout::Variants::Tagged { ref discr, .. } => {\n+                let signed = match discr.value {\n+                    layout::Int(_, signed) => signed,\n+                    _ => false\n+                };\n+                bcx.intcast(lldiscr, cast_to, signed)\n             }\n-            layout::UntaggedUnion { ref variants } => {\n-                let fields = adt::compute_fields(bcx.ccx, t, 0, false);\n-                let ty = type_of::in_memory_type_of(bcx.ccx, fields[ix]);\n-                (bcx.pointercast(self.llval, ty.ptr_to()),\n-                 self.alignment | Alignment::from_packed(variants.packed))\n+            layout::Variants::NicheFilling {\n+                dataful_variant,\n+                ref niche_variants,\n+                niche_start,\n+                ..\n+            } => {\n+                let niche_llty = discr.layout.immediate_llvm_type(bcx.ccx);\n+                if niche_variants.start == niche_variants.end {\n+                    // FIXME(eddyb) Check the actual primitive type here.\n+                    let niche_llval = if niche_start == 0 {\n+                        // HACK(eddyb) Using `C_null` as it works on all types.\n+                        C_null(niche_llty)\n+                    } else {\n+                        C_uint_big(niche_llty, niche_start)\n+                    };\n+                    bcx.select(bcx.icmp(llvm::IntEQ, lldiscr, niche_llval),\n+                        C_uint(cast_to, niche_variants.start as u64),\n+                        C_uint(cast_to, dataful_variant as u64))\n+                } else {\n+                    // Rebase from niche values to discriminant values.\n+                    let delta = niche_start.wrapping_sub(niche_variants.start as u128);\n+                    let lldiscr = bcx.sub(lldiscr, C_uint_big(niche_llty, delta));\n+                    let lldiscr_max = C_uint(niche_llty, niche_variants.end as u64);\n+                    bcx.select(bcx.icmp(llvm::IntULE, lldiscr, lldiscr_max),\n+                        bcx.intcast(lldiscr, cast_to, false),\n+                        C_uint(cast_to, dataful_variant as u64))\n+                }\n             }\n-            layout::RawNullablePointer { nndiscr, .. } |\n-            layout::StructWrappedNullablePointer { nndiscr,  .. } if discr as u64 != nndiscr => {\n-                let nullfields = adt::compute_fields(bcx.ccx, t, (1-nndiscr) as usize, false);\n-                // The unit-like case might have a nonzero number of unit-like fields.\n-                // (e.d., Result of Either with (), as one side.)\n-                let ty = type_of::type_of(bcx.ccx, nullfields[ix]);\n-                assert_eq!(machine::llsize_of_alloc(bcx.ccx, ty), 0);\n-                (bcx.pointercast(self.llval, ty.ptr_to()), Alignment::Packed)\n+        }\n+    }\n+\n+    /// Set the discriminant for a new value of the given case of the given\n+    /// representation.\n+    pub fn trans_set_discr(&self, bcx: &Builder<'a, 'tcx>, variant_index: usize) {\n+        match self.layout.variants {\n+            layout::Variants::Single { index } => {\n+                if index != variant_index {\n+                    // If the layout of an enum is `Single`, all\n+                    // other variants are necessarily uninhabited.\n+                    assert_eq!(self.layout.for_variant(bcx.ccx, variant_index).abi,\n+                               layout::Abi::Uninhabited);\n+                }\n             }\n-            layout::RawNullablePointer { nndiscr, .. } => {\n-                let nnty = adt::compute_fields(bcx.ccx, t, nndiscr as usize, false)[0];\n-                assert_eq!(ix, 0);\n-                assert_eq!(discr as u64, nndiscr);\n-                let ty = type_of::type_of(bcx.ccx, nnty);\n-                (bcx.pointercast(self.llval, ty.ptr_to()), self.alignment)\n+            layout::Variants::Tagged { .. } => {\n+                let ptr = self.project_field(bcx, 0);\n+                let to = self.layout.ty.ty_adt_def().unwrap()\n+                    .discriminant_for_variant(bcx.tcx(), variant_index)\n+                    .to_u128_unchecked() as u64;\n+                bcx.store(C_int(ptr.layout.llvm_type(bcx.ccx), to as i64),\n+                    ptr.llval, ptr.alignment.non_abi());\n             }\n-            layout::StructWrappedNullablePointer { ref nonnull, nndiscr, .. } => {\n-                assert_eq!(discr as u64, nndiscr);\n-                self.struct_field_ptr(bcx, &nonnull,\n-                     &adt::compute_fields(bcx.ccx, t, discr, false), ix, false)\n+            layout::Variants::NicheFilling {\n+                dataful_variant,\n+                ref niche_variants,\n+                niche_start,\n+                ..\n+            } => {\n+                if variant_index != dataful_variant {\n+                    if bcx.sess().target.target.arch == \"arm\" ||\n+                       bcx.sess().target.target.arch == \"aarch64\" {\n+                        // Issue #34427: As workaround for LLVM bug on ARM,\n+                        // use memset of 0 before assigning niche value.\n+                        let llptr = bcx.pointercast(self.llval, Type::i8(bcx.ccx).ptr_to());\n+                        let fill_byte = C_u8(bcx.ccx, 0);\n+                        let (size, align) = self.layout.size_and_align();\n+                        let size = C_usize(bcx.ccx, size.bytes());\n+                        let align = C_u32(bcx.ccx, align.abi() as u32);\n+                        base::call_memset(bcx, llptr, fill_byte, size, align, false);\n+                    }\n+\n+                    let niche = self.project_field(bcx, 0);\n+                    let niche_llty = niche.layout.immediate_llvm_type(bcx.ccx);\n+                    let niche_value = ((variant_index - niche_variants.start) as u128)\n+                        .wrapping_add(niche_start);\n+                    // FIXME(eddyb) Check the actual primitive type here.\n+                    let niche_llval = if niche_value == 0 {\n+                        // HACK(eddyb) Using `C_null` as it works on all types.\n+                        C_null(niche_llty)\n+                    } else {\n+                        C_uint_big(niche_llty, niche_value)\n+                    };\n+                    OperandValue::Immediate(niche_llval).store(bcx, niche);\n+                }\n             }\n-            _ => bug!(\"element access in type without elements: {} represented as {:#?}\", t, l)\n         }\n     }\n \n-    pub fn project_index(&self, bcx: &Builder<'a, 'tcx>, llindex: ValueRef) -> ValueRef {\n-        if let ty::TySlice(_) = self.ty.to_ty(bcx.tcx()).sty {\n-            // Slices already point to the array element type.\n-            bcx.inbounds_gep(self.llval, &[llindex])\n-        } else {\n-            let zero = common::C_usize(bcx.ccx, 0);\n-            bcx.inbounds_gep(self.llval, &[zero, llindex])\n+    pub fn project_index(&self, bcx: &Builder<'a, 'tcx>, llindex: ValueRef)\n+                         -> LvalueRef<'tcx> {\n+        LvalueRef {\n+            llval: bcx.inbounds_gep(self.llval, &[C_usize(bcx.ccx, 0), llindex]),\n+            llextra: ptr::null_mut(),\n+            layout: self.layout.field(bcx.ccx, 0),\n+            alignment: self.alignment\n         }\n     }\n+\n+    pub fn project_downcast(&self, bcx: &Builder<'a, 'tcx>, variant_index: usize)\n+                            -> LvalueRef<'tcx> {\n+        let mut downcast = *self;\n+        downcast.layout = self.layout.for_variant(bcx.ccx, variant_index);\n+\n+        // Cast to the appropriate variant struct type.\n+        let variant_ty = downcast.layout.llvm_type(bcx.ccx);\n+        downcast.llval = bcx.pointercast(downcast.llval, variant_ty.ptr_to());\n+\n+        downcast\n+    }\n+\n+    pub fn storage_live(&self, bcx: &Builder<'a, 'tcx>) {\n+        bcx.lifetime_start(self.llval, self.layout.size);\n+    }\n+\n+    pub fn storage_dead(&self, bcx: &Builder<'a, 'tcx>) {\n+        bcx.lifetime_end(self.llval, self.layout.size);\n+    }\n }\n \n impl<'a, 'tcx> MirContext<'a, 'tcx> {\n@@ -310,108 +468,74 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             mir::Lvalue::Local(_) => bug!(), // handled above\n             mir::Lvalue::Static(box mir::Static { def_id, ty }) => {\n                 LvalueRef::new_sized(consts::get_static(ccx, def_id),\n-                                     LvalueTy::from_ty(self.monomorphize(&ty)),\n+                                     ccx.layout_of(self.monomorphize(&ty)),\n                                      Alignment::AbiAligned)\n             },\n             mir::Lvalue::Projection(box mir::Projection {\n                 ref base,\n                 elem: mir::ProjectionElem::Deref\n             }) => {\n                 // Load the pointer from its location.\n-                self.trans_consume(bcx, base).deref()\n+                self.trans_consume(bcx, base).deref(bcx.ccx)\n             }\n             mir::Lvalue::Projection(ref projection) => {\n                 let tr_base = self.trans_lvalue(bcx, &projection.base);\n-                let projected_ty = tr_base.ty.projection_ty(tcx, &projection.elem);\n-                let projected_ty = self.monomorphize(&projected_ty);\n-                let align = tr_base.alignment;\n \n-                let ((llprojected, align), llextra) = match projection.elem {\n+                match projection.elem {\n                     mir::ProjectionElem::Deref => bug!(),\n                     mir::ProjectionElem::Field(ref field, _) => {\n-                        let has_metadata = self.ccx.shared()\n-                            .type_has_metadata(projected_ty.to_ty(tcx));\n-                        let llextra = if !has_metadata {\n-                            ptr::null_mut()\n-                        } else {\n-                            tr_base.llextra\n-                        };\n-                        (tr_base.trans_field_ptr(bcx, field.index()), llextra)\n+                        tr_base.project_field(bcx, field.index())\n                     }\n                     mir::ProjectionElem::Index(index) => {\n                         let index = &mir::Operand::Consume(mir::Lvalue::Local(index));\n                         let index = self.trans_operand(bcx, index);\n-                        let llindex = self.prepare_index(bcx, index.immediate());\n-                        ((tr_base.project_index(bcx, llindex), align), ptr::null_mut())\n+                        let llindex = index.immediate();\n+                        tr_base.project_index(bcx, llindex)\n                     }\n                     mir::ProjectionElem::ConstantIndex { offset,\n                                                          from_end: false,\n                                                          min_length: _ } => {\n                         let lloffset = C_usize(bcx.ccx, offset as u64);\n-                        ((tr_base.project_index(bcx, lloffset), align), ptr::null_mut())\n+                        tr_base.project_index(bcx, lloffset)\n                     }\n                     mir::ProjectionElem::ConstantIndex { offset,\n                                                          from_end: true,\n                                                          min_length: _ } => {\n                         let lloffset = C_usize(bcx.ccx, offset as u64);\n                         let lllen = tr_base.len(bcx.ccx);\n                         let llindex = bcx.sub(lllen, lloffset);\n-                        ((tr_base.project_index(bcx, llindex), align), ptr::null_mut())\n+                        tr_base.project_index(bcx, llindex)\n                     }\n                     mir::ProjectionElem::Subslice { from, to } => {\n-                        let llbase = tr_base.project_index(bcx, C_usize(bcx.ccx, from as u64));\n-\n-                        let base_ty = tr_base.ty.to_ty(bcx.tcx());\n-                        match base_ty.sty {\n-                            ty::TyArray(..) => {\n-                                // must cast the lvalue pointer type to the new\n-                                // array type (*[%_; new_len]).\n-                                let base_ty = self.monomorphized_lvalue_ty(lvalue);\n-                                let llbasety = type_of::type_of(bcx.ccx, base_ty).ptr_to();\n-                                let llbase = bcx.pointercast(llbase, llbasety);\n-                                ((llbase, align), ptr::null_mut())\n-                            }\n-                            ty::TySlice(..) => {\n-                                assert!(tr_base.llextra != ptr::null_mut());\n-                                let lllen = bcx.sub(tr_base.llextra,\n-                                                    C_usize(bcx.ccx, (from as u64)+(to as u64)));\n-                                ((llbase, align), lllen)\n-                            }\n-                            _ => bug!(\"unexpected type {:?} in Subslice\", base_ty)\n+                        let mut subslice = tr_base.project_index(bcx,\n+                            C_usize(bcx.ccx, from as u64));\n+                        let projected_ty = LvalueTy::Ty { ty: tr_base.layout.ty }\n+                            .projection_ty(tcx, &projection.elem).to_ty(bcx.tcx());\n+                        subslice.layout = bcx.ccx.layout_of(self.monomorphize(&projected_ty));\n+\n+                        if subslice.layout.is_unsized() {\n+                            assert!(tr_base.has_extra());\n+                            subslice.llextra = bcx.sub(tr_base.llextra,\n+                                C_usize(bcx.ccx, (from as u64) + (to as u64)));\n                         }\n+\n+                        // Cast the lvalue pointer type to the new\n+                        // array or slice type (*[%_; new_len]).\n+                        subslice.llval = bcx.pointercast(subslice.llval,\n+                            subslice.layout.llvm_type(bcx.ccx).ptr_to());\n+\n+                        subslice\n                     }\n-                    mir::ProjectionElem::Downcast(..) => {\n-                        ((tr_base.llval, align), tr_base.llextra)\n+                    mir::ProjectionElem::Downcast(_, v) => {\n+                        tr_base.project_downcast(bcx, v)\n                     }\n-                };\n-                LvalueRef {\n-                    llval: llprojected,\n-                    llextra,\n-                    ty: projected_ty,\n-                    alignment: align,\n                 }\n             }\n         };\n         debug!(\"trans_lvalue(lvalue={:?}) => {:?}\", lvalue, result);\n         result\n     }\n \n-    /// Adjust the bitwidth of an index since LLVM is less forgiving\n-    /// than we are.\n-    ///\n-    /// nmatsakis: is this still necessary? Not sure.\n-    fn prepare_index(&mut self, bcx: &Builder<'a, 'tcx>, llindex: ValueRef) -> ValueRef {\n-        let index_size = machine::llbitsize_of_real(bcx.ccx, common::val_ty(llindex));\n-        let int_size = machine::llbitsize_of_real(bcx.ccx, bcx.ccx.isize_ty());\n-        if index_size < int_size {\n-            bcx.zext(llindex, bcx.ccx.isize_ty())\n-        } else if index_size > int_size {\n-            bcx.trunc(llindex, bcx.ccx.isize_ty())\n-        } else {\n-            llindex\n-        }\n-    }\n-\n     pub fn monomorphized_lvalue_ty(&self, lvalue: &mir::Lvalue<'tcx>) -> Ty<'tcx> {\n         let tcx = self.ccx.tcx();\n         let lvalue_ty = lvalue.ty(self.mir, tcx);"}, {"sha": "7f3a430c418e9451df4cc682a1722e19a090efe1", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 91, "deletions": 132, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -11,20 +11,18 @@\n use libc::c_uint;\n use llvm::{self, ValueRef, BasicBlockRef};\n use llvm::debuginfo::DIScope;\n-use rustc::ty::{self, Ty, TypeFoldable};\n-use rustc::ty::layout::{self, LayoutTyper};\n+use rustc::ty::{self, TypeFoldable};\n+use rustc::ty::layout::{LayoutOf, TyLayout};\n use rustc::mir::{self, Mir};\n-use rustc::mir::tcx::LvalueTy;\n use rustc::ty::subst::Substs;\n use rustc::infer::TransNormalize;\n use rustc::session::config::FullDebugInfo;\n use base;\n use builder::Builder;\n-use common::{self, CrateContext, Funclet};\n+use common::{CrateContext, Funclet};\n use debuginfo::{self, declare_local, VariableAccess, VariableKind, FunctionDebugContext};\n use monomorphize::Instance;\n-use abi::{ArgAttribute, FnType};\n-use type_of;\n+use abi::{ArgAttribute, FnType, PassMode};\n \n use syntax_pos::{DUMMY_SP, NO_EXPANSION, BytePos, Span};\n use syntax::symbol::keywords;\n@@ -61,7 +59,7 @@ pub struct MirContext<'a, 'tcx:'a> {\n     /// don't really care about it very much. Anyway, this value\n     /// contains an alloca into which the personality is stored and\n     /// then later loaded when generating the DIVERGE_BLOCK.\n-    llpersonalityslot: Option<ValueRef>,\n+    personality_slot: Option<LvalueRef<'tcx>>,\n \n     /// A `Block` for each MIR `BasicBlock`\n     blocks: IndexVec<mir::BasicBlock, BasicBlockRef>,\n@@ -86,7 +84,7 @@ pub struct MirContext<'a, 'tcx:'a> {\n     /// directly using an `OperandRef`, which makes for tighter LLVM\n     /// IR. The conditions for using an `OperandRef` are as follows:\n     ///\n-    /// - the type of the local must be judged \"immediate\" by `type_is_immediate`\n+    /// - the type of the local must be judged \"immediate\" by `is_llvm_immediate`\n     /// - the operand must never be referenced indirectly\n     ///     - we should not take its address using the `&` operator\n     ///     - nor should it appear in an lvalue path like `tmp.a`\n@@ -177,14 +175,13 @@ enum LocalRef<'tcx> {\n     Operand(Option<OperandRef<'tcx>>),\n }\n \n-impl<'tcx> LocalRef<'tcx> {\n-    fn new_operand<'a>(ccx: &CrateContext<'a, 'tcx>,\n-                       ty: Ty<'tcx>) -> LocalRef<'tcx> {\n-        if common::type_is_zero_size(ccx, ty) {\n+impl<'a, 'tcx> LocalRef<'tcx> {\n+    fn new_operand(ccx: &CrateContext<'a, 'tcx>, layout: TyLayout<'tcx>) -> LocalRef<'tcx> {\n+        if layout.is_zst() {\n             // Zero-size temporaries aren't always initialized, which\n             // doesn't matter because they don't contain data, but\n             // we need something in the operand.\n-            LocalRef::Operand(Some(OperandRef::new_zst(ccx, ty)))\n+            LocalRef::Operand(Some(OperandRef::new_zst(ccx, layout)))\n         } else {\n             LocalRef::Operand(None)\n         }\n@@ -232,7 +229,7 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n         llfn,\n         fn_ty,\n         ccx,\n-        llpersonalityslot: None,\n+        personality_slot: None,\n         blocks: block_bcxs,\n         unreachable_block: None,\n         cleanup_kinds,\n@@ -255,7 +252,8 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n \n         let mut allocate_local = |local| {\n             let decl = &mir.local_decls[local];\n-            let ty = mircx.monomorphize(&decl.ty);\n+            let layout = bcx.ccx.layout_of(mircx.monomorphize(&decl.ty));\n+            assert!(!layout.ty.has_erasable_regions());\n \n             if let Some(name) = decl.name {\n                 // User variable\n@@ -264,15 +262,14 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n \n                 if !lvalue_locals.contains(local.index()) && !dbg {\n                     debug!(\"alloc: {:?} ({}) -> operand\", local, name);\n-                    return LocalRef::new_operand(bcx.ccx, ty);\n+                    return LocalRef::new_operand(bcx.ccx, layout);\n                 }\n \n                 debug!(\"alloc: {:?} ({}) -> lvalue\", local, name);\n-                assert!(!ty.has_erasable_regions());\n-                let lvalue = LvalueRef::alloca(&bcx, ty, &name.as_str());\n+                let lvalue = LvalueRef::alloca(&bcx, layout, &name.as_str());\n                 if dbg {\n                     let (scope, span) = mircx.debug_loc(decl.source_info);\n-                    declare_local(&bcx, &mircx.debug_context, name, ty, scope,\n+                    declare_local(&bcx, &mircx.debug_context, name, layout.ty, scope,\n                         VariableAccess::DirectVariable { alloca: lvalue.llval },\n                         VariableKind::LocalVariable, span);\n                 }\n@@ -282,18 +279,18 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n                 if local == mir::RETURN_POINTER && mircx.fn_ty.ret.is_indirect() {\n                     debug!(\"alloc: {:?} (return pointer) -> lvalue\", local);\n                     let llretptr = llvm::get_param(llfn, 0);\n-                    LocalRef::Lvalue(LvalueRef::new_sized(llretptr, LvalueTy::from_ty(ty),\n+                    LocalRef::Lvalue(LvalueRef::new_sized(llretptr,\n+                                                          layout,\n                                                           Alignment::AbiAligned))\n                 } else if lvalue_locals.contains(local.index()) {\n                     debug!(\"alloc: {:?} -> lvalue\", local);\n-                    assert!(!ty.has_erasable_regions());\n-                    LocalRef::Lvalue(LvalueRef::alloca(&bcx, ty,  &format!(\"{:?}\", local)))\n+                    LocalRef::Lvalue(LvalueRef::alloca(&bcx, layout, &format!(\"{:?}\", local)))\n                 } else {\n                     // If this is an immediate local, we do not create an\n                     // alloca in advance. Instead we wait until we see the\n                     // definition and update the operand there.\n                     debug!(\"alloc: {:?} -> operand\", local);\n-                    LocalRef::new_operand(bcx.ccx, ty)\n+                    LocalRef::new_operand(bcx.ccx, layout)\n                 }\n             }\n         };\n@@ -384,7 +381,6 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n \n     mir.args_iter().enumerate().map(|(arg_index, local)| {\n         let arg_decl = &mir.local_decls[local];\n-        let arg_ty = mircx.monomorphize(&arg_decl.ty);\n \n         let name = if let Some(name) = arg_decl.name {\n             name.as_str().to_string()\n@@ -398,26 +394,17 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             // to reconstruct it into a tuple local variable, from multiple\n             // individual LLVM function arguments.\n \n+            let arg_ty = mircx.monomorphize(&arg_decl.ty);\n             let tupled_arg_tys = match arg_ty.sty {\n                 ty::TyTuple(ref tys, _) => tys,\n                 _ => bug!(\"spread argument isn't a tuple?!\")\n             };\n \n-            let lvalue = LvalueRef::alloca(bcx, arg_ty, &name);\n-            for (i, &tupled_arg_ty) in tupled_arg_tys.iter().enumerate() {\n-                let (dst, _) = lvalue.trans_field_ptr(bcx, i);\n+            let lvalue = LvalueRef::alloca(bcx, bcx.ccx.layout_of(arg_ty), &name);\n+            for i in 0..tupled_arg_tys.len() {\n                 let arg = &mircx.fn_ty.args[idx];\n                 idx += 1;\n-                if common::type_is_fat_ptr(bcx.ccx, tupled_arg_ty) {\n-                    // We pass fat pointers as two words, but inside the tuple\n-                    // they are the two sub-fields of a single aggregate field.\n-                    let meta = &mircx.fn_ty.args[idx];\n-                    idx += 1;\n-                    arg.store_fn_arg(bcx, &mut llarg_idx, base::get_dataptr(bcx, dst));\n-                    meta.store_fn_arg(bcx, &mut llarg_idx, base::get_meta(bcx, dst));\n-                } else {\n-                    arg.store_fn_arg(bcx, &mut llarg_idx, dst);\n-                }\n+                arg.store_fn_arg(bcx, &mut llarg_idx, lvalue.project_field(bcx, i));\n             }\n \n             // Now that we have one alloca that contains the aggregate value,\n@@ -442,104 +429,81 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n \n         let arg = &mircx.fn_ty.args[idx];\n         idx += 1;\n-        let llval = if arg.is_indirect() {\n-            // Don't copy an indirect argument to an alloca, the caller\n-            // already put it in a temporary alloca and gave it up\n-            // FIXME: lifetimes\n-            if arg.pad.is_some() {\n-                llarg_idx += 1;\n-            }\n-            let llarg = llvm::get_param(bcx.llfn(), llarg_idx as c_uint);\n-            bcx.set_value_name(llarg, &name);\n+        if arg.pad.is_some() {\n             llarg_idx += 1;\n-            llarg\n-        } else if !lvalue_locals.contains(local.index()) &&\n-                  arg.cast.is_none() && arg_scope.is_none() {\n-            if arg.is_ignore() {\n-                return LocalRef::new_operand(bcx.ccx, arg_ty);\n-            }\n+        }\n \n+        if arg_scope.is_none() && !lvalue_locals.contains(local.index()) {\n             // We don't have to cast or keep the argument in the alloca.\n             // FIXME(eddyb): We should figure out how to use llvm.dbg.value instead\n             // of putting everything in allocas just so we can use llvm.dbg.declare.\n-            if arg.pad.is_some() {\n-                llarg_idx += 1;\n+            let local = |op| LocalRef::Operand(Some(op));\n+            match arg.mode {\n+                PassMode::Ignore => {\n+                    return local(OperandRef::new_zst(bcx.ccx, arg.layout));\n+                }\n+                PassMode::Direct(_) => {\n+                    let llarg = llvm::get_param(bcx.llfn(), llarg_idx as c_uint);\n+                    bcx.set_value_name(llarg, &name);\n+                    llarg_idx += 1;\n+                    return local(\n+                        OperandRef::from_immediate_or_packed_pair(bcx, llarg, arg.layout));\n+                }\n+                PassMode::Pair(..) => {\n+                    let a = llvm::get_param(bcx.llfn(), llarg_idx as c_uint);\n+                    bcx.set_value_name(a, &(name.clone() + \".0\"));\n+                    llarg_idx += 1;\n+\n+                    let b = llvm::get_param(bcx.llfn(), llarg_idx as c_uint);\n+                    bcx.set_value_name(b, &(name + \".1\"));\n+                    llarg_idx += 1;\n+\n+                    return local(OperandRef {\n+                        val: OperandValue::Pair(a, b),\n+                        layout: arg.layout\n+                    });\n+                }\n+                _ => {}\n             }\n+        }\n+\n+        let lvalue = if arg.is_indirect() {\n+            // Don't copy an indirect argument to an alloca, the caller\n+            // already put it in a temporary alloca and gave it up.\n+            // FIXME: lifetimes\n             let llarg = llvm::get_param(bcx.llfn(), llarg_idx as c_uint);\n+            bcx.set_value_name(llarg, &name);\n             llarg_idx += 1;\n-            let val = if common::type_is_fat_ptr(bcx.ccx, arg_ty) {\n-                let meta = &mircx.fn_ty.args[idx];\n-                idx += 1;\n-                assert_eq!((meta.cast, meta.pad), (None, None));\n-                let llmeta = llvm::get_param(bcx.llfn(), llarg_idx as c_uint);\n-                llarg_idx += 1;\n-\n-                // FIXME(eddyb) As we can't perfectly represent the data and/or\n-                // vtable pointer in a fat pointers in Rust's typesystem, and\n-                // because we split fat pointers into two ArgType's, they're\n-                // not the right type so we have to cast them for now.\n-                let pointee = match arg_ty.sty {\n-                    ty::TyRef(_, ty::TypeAndMut{ty, ..}) |\n-                    ty::TyRawPtr(ty::TypeAndMut{ty, ..}) => ty,\n-                    ty::TyAdt(def, _) if def.is_box() => arg_ty.boxed_ty(),\n-                    _ => bug!()\n-                };\n-                let data_llty = type_of::in_memory_type_of(bcx.ccx, pointee);\n-                let meta_llty = type_of::unsized_info_ty(bcx.ccx, pointee);\n-\n-                let llarg = bcx.pointercast(llarg, data_llty.ptr_to());\n-                bcx.set_value_name(llarg, &(name.clone() + \".ptr\"));\n-                let llmeta = bcx.pointercast(llmeta, meta_llty);\n-                bcx.set_value_name(llmeta, &(name + \".meta\"));\n-\n-                OperandValue::Pair(llarg, llmeta)\n-            } else {\n-                bcx.set_value_name(llarg, &name);\n-                OperandValue::Immediate(llarg)\n-            };\n-            let operand = OperandRef {\n-                val,\n-                ty: arg_ty\n-            };\n-            return LocalRef::Operand(Some(operand.unpack_if_pair(bcx)));\n+            LvalueRef::new_sized(llarg, arg.layout, Alignment::AbiAligned)\n         } else {\n-            let lltemp = LvalueRef::alloca(bcx, arg_ty, &name);\n-            if common::type_is_fat_ptr(bcx.ccx, arg_ty) {\n-                // we pass fat pointers as two words, but we want to\n-                // represent them internally as a pointer to two words,\n-                // so make an alloca to store them in.\n-                let meta = &mircx.fn_ty.args[idx];\n-                idx += 1;\n-                arg.store_fn_arg(bcx, &mut llarg_idx, base::get_dataptr(bcx, lltemp.llval));\n-                meta.store_fn_arg(bcx, &mut llarg_idx, base::get_meta(bcx, lltemp.llval));\n-            } else  {\n-                // otherwise, arg is passed by value, so make a\n-                // temporary and store it there\n-                arg.store_fn_arg(bcx, &mut llarg_idx, lltemp.llval);\n-            }\n-            lltemp.llval\n+            let tmp = LvalueRef::alloca(bcx, arg.layout, &name);\n+            arg.store_fn_arg(bcx, &mut llarg_idx, tmp);\n+            tmp\n         };\n         arg_scope.map(|scope| {\n             // Is this a regular argument?\n             if arg_index > 0 || mir.upvar_decls.is_empty() {\n                 // The Rust ABI passes indirect variables using a pointer and a manual copy, so we\n                 // need to insert a deref here, but the C ABI uses a pointer and a copy using the\n                 // byval attribute, for which LLVM does the deref itself, so we must not add it.\n-                let variable_access = if arg.is_indirect() &&\n-                    !arg.attrs.contains(ArgAttribute::ByVal) {\n-                    VariableAccess::IndirectVariable {\n-                        alloca: llval,\n-                        address_operations: &deref_op,\n-                    }\n-                } else {\n-                    VariableAccess::DirectVariable { alloca: llval }\n+                let mut variable_access = VariableAccess::DirectVariable {\n+                    alloca: lvalue.llval\n                 };\n \n+                if let PassMode::Indirect(ref attrs) = arg.mode {\n+                    if !attrs.contains(ArgAttribute::ByVal) {\n+                        variable_access = VariableAccess::IndirectVariable {\n+                            alloca: lvalue.llval,\n+                            address_operations: &deref_op,\n+                        };\n+                    }\n+                }\n+\n                 declare_local(\n                     bcx,\n                     &mircx.debug_context,\n                     arg_decl.name.unwrap_or(keywords::Invalid.name()),\n-                    arg_ty,\n+                    arg.layout.ty,\n                     scope,\n                     variable_access,\n                     VariableKind::ArgumentVariable(arg_index + 1),\n@@ -549,15 +513,15 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             }\n \n             // Or is it the closure environment?\n-            let (closure_ty, env_ref) = match arg_ty.sty {\n-                ty::TyRef(_, mt) | ty::TyRawPtr(mt) => (mt.ty, true),\n-                _ => (arg_ty, false)\n+            let (closure_layout, env_ref) = match arg.layout.ty.sty {\n+                ty::TyRef(_, mt) | ty::TyRawPtr(mt) => (bcx.ccx.layout_of(mt.ty), true),\n+                _ => (arg.layout, false)\n             };\n \n-            let upvar_tys = match closure_ty.sty {\n+            let upvar_tys = match closure_layout.ty.sty {\n                 ty::TyClosure(def_id, substs) |\n                 ty::TyGenerator(def_id, substs, _) => substs.upvar_tys(def_id, tcx),\n-                _ => bug!(\"upvar_decls with non-closure arg0 type `{}`\", closure_ty)\n+                _ => bug!(\"upvar_decls with non-closure arg0 type `{}`\", closure_layout.ty)\n             };\n \n             // Store the pointer to closure data in an alloca for debuginfo\n@@ -568,21 +532,17 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             // doesn't actually strip the offset when splitting the closure\n             // environment into its components so it ends up out of bounds.\n             let env_ptr = if !env_ref {\n-                let alloc = bcx.alloca(common::val_ty(llval), \"__debuginfo_env_ptr\", None);\n-                bcx.store(llval, alloc, None);\n-                alloc\n+                let alloc = LvalueRef::alloca(bcx,\n+                    bcx.ccx.layout_of(tcx.mk_mut_ptr(arg.layout.ty)),\n+                    \"__debuginfo_env_ptr\");\n+                bcx.store(lvalue.llval, alloc.llval, None);\n+                alloc.llval\n             } else {\n-                llval\n-            };\n-\n-            let layout = bcx.ccx.layout_of(closure_ty);\n-            let offsets = match *layout {\n-                layout::Univariant { ref variant, .. } => &variant.offsets[..],\n-                _ => bug!(\"Closures are only supposed to be Univariant\")\n+                lvalue.llval\n             };\n \n             for (i, (decl, ty)) in mir.upvar_decls.iter().zip(upvar_tys).enumerate() {\n-                let byte_offset_of_var_in_env = offsets[i].bytes();\n+                let byte_offset_of_var_in_env = closure_layout.fields.offset(i).bytes();\n \n                 let ops = unsafe {\n                     [llvm::LLVMRustDIBuilderCreateOpDeref(),\n@@ -620,15 +580,14 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                 );\n             }\n         });\n-        LocalRef::Lvalue(LvalueRef::new_sized(llval, LvalueTy::from_ty(arg_ty),\n-                                              Alignment::AbiAligned))\n+        LocalRef::Lvalue(lvalue)\n     }).collect()\n }\n \n mod analyze;\n mod block;\n mod constant;\n pub mod lvalue;\n-mod operand;\n+pub mod operand;\n mod rvalue;\n mod statement;"}, {"sha": "8c43bded1bf217415ab4ca75e25eb5a6623e0e7e", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 173, "deletions": 204, "changes": 377, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -9,18 +9,16 @@\n // except according to those terms.\n \n use llvm::ValueRef;\n-use rustc::ty::{self, Ty};\n-use rustc::ty::layout::{Layout, LayoutTyper};\n+use rustc::ty;\n+use rustc::ty::layout::{self, LayoutOf, TyLayout};\n use rustc::mir;\n-use rustc::mir::tcx::LvalueTy;\n use rustc_data_structures::indexed_vec::Idx;\n \n-use adt;\n use base;\n-use common::{self, CrateContext, C_null};\n+use common::{self, CrateContext, C_undef, C_usize};\n use builder::Builder;\n use value::Value;\n-use type_of;\n+use type_of::LayoutLlvmExt;\n use type_::Type;\n \n use std::fmt;\n@@ -43,63 +41,52 @@ pub enum OperandValue {\n     Pair(ValueRef, ValueRef)\n }\n \n+impl fmt::Debug for OperandValue {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            OperandValue::Ref(r, align) => {\n+                write!(f, \"Ref({:?}, {:?})\", Value(r), align)\n+            }\n+            OperandValue::Immediate(i) => {\n+                write!(f, \"Immediate({:?})\", Value(i))\n+            }\n+            OperandValue::Pair(a, b) => {\n+                write!(f, \"Pair({:?}, {:?})\", Value(a), Value(b))\n+            }\n+        }\n+    }\n+}\n+\n /// An `OperandRef` is an \"SSA\" reference to a Rust value, along with\n /// its type.\n ///\n /// NOTE: unless you know a value's type exactly, you should not\n /// generate LLVM opcodes acting on it and instead act via methods,\n-/// to avoid nasty edge cases. In particular, using `Builder.store`\n-/// directly is sure to cause problems -- use `MirContext.store_operand`\n+/// to avoid nasty edge cases. In particular, using `Builder::store`\n+/// directly is sure to cause problems -- use `OperandRef::store`\n /// instead.\n #[derive(Copy, Clone)]\n pub struct OperandRef<'tcx> {\n     // The value.\n     pub val: OperandValue,\n \n-    // The type of value being returned.\n-    pub ty: Ty<'tcx>\n+    // The layout of value, based on its Rust type.\n+    pub layout: TyLayout<'tcx>,\n }\n \n impl<'tcx> fmt::Debug for OperandRef<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match self.val {\n-            OperandValue::Ref(r, align) => {\n-                write!(f, \"OperandRef(Ref({:?}, {:?}) @ {:?})\",\n-                       Value(r), align, self.ty)\n-            }\n-            OperandValue::Immediate(i) => {\n-                write!(f, \"OperandRef(Immediate({:?}) @ {:?})\",\n-                       Value(i), self.ty)\n-            }\n-            OperandValue::Pair(a, b) => {\n-                write!(f, \"OperandRef(Pair({:?}, {:?}) @ {:?})\",\n-                       Value(a), Value(b), self.ty)\n-            }\n-        }\n+        write!(f, \"OperandRef({:?} @ {:?})\", self.val, self.layout)\n     }\n }\n \n impl<'a, 'tcx> OperandRef<'tcx> {\n     pub fn new_zst(ccx: &CrateContext<'a, 'tcx>,\n-                   ty: Ty<'tcx>) -> OperandRef<'tcx> {\n-        assert!(common::type_is_zero_size(ccx, ty));\n-        let llty = type_of::type_of(ccx, ty);\n-        let val = if common::type_is_imm_pair(ccx, ty) {\n-            let layout = ccx.layout_of(ty);\n-            let (ix0, ix1) = if let Layout::Univariant { ref variant, .. } = *layout {\n-                (adt::struct_llfields_index(variant, 0),\n-                adt::struct_llfields_index(variant, 1))\n-            } else {\n-                (0, 1)\n-            };\n-            let fields = llty.field_types();\n-            OperandValue::Pair(C_null(fields[ix0]), C_null(fields[ix1]))\n-        } else {\n-            OperandValue::Immediate(C_null(llty))\n-        };\n+                   layout: TyLayout<'tcx>) -> OperandRef<'tcx> {\n+        assert!(layout.is_zst());\n         OperandRef {\n-            val,\n-            ty,\n+            val: OperandValue::Immediate(C_undef(layout.immediate_llvm_type(ccx))),\n+            layout\n         }\n     }\n \n@@ -112,8 +99,8 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n         }\n     }\n \n-    pub fn deref(self) -> LvalueRef<'tcx> {\n-        let projected_ty = self.ty.builtin_deref(true, ty::NoPreference)\n+    pub fn deref(self, ccx: &CrateContext<'a, 'tcx>) -> LvalueRef<'tcx> {\n+        let projected_ty = self.layout.ty.builtin_deref(true, ty::NoPreference)\n             .unwrap_or_else(|| bug!(\"deref of non-pointer {:?}\", self)).ty;\n         let (llptr, llextra) = match self.val {\n             OperandValue::Immediate(llptr) => (llptr, ptr::null_mut()),\n@@ -123,126 +110,150 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n         LvalueRef {\n             llval: llptr,\n             llextra,\n-            ty: LvalueTy::from_ty(projected_ty),\n+            layout: ccx.layout_of(projected_ty),\n             alignment: Alignment::AbiAligned,\n         }\n     }\n \n-    /// If this operand is a Pair, we return an\n-    /// Immediate aggregate with the two values.\n-    pub fn pack_if_pair(mut self, bcx: &Builder<'a, 'tcx>) -> OperandRef<'tcx> {\n+    /// If this operand is a `Pair`, we return an aggregate with the two values.\n+    /// For other cases, see `immediate`.\n+    pub fn immediate_or_packed_pair(self, bcx: &Builder<'a, 'tcx>) -> ValueRef {\n         if let OperandValue::Pair(a, b) = self.val {\n+            let llty = self.layout.llvm_type(bcx.ccx);\n+            debug!(\"Operand::immediate_or_packed_pair: packing {:?} into {:?}\",\n+                   self, llty);\n             // Reconstruct the immediate aggregate.\n-            let llty = type_of::type_of(bcx.ccx, self.ty);\n-            let mut llpair = common::C_undef(llty);\n-            let elems = [a, b];\n-            for i in 0..2 {\n-                let mut elem = elems[i];\n-                // Extend boolean i1's to i8.\n-                if common::val_ty(elem) == Type::i1(bcx.ccx) {\n-                    elem = bcx.zext(elem, Type::i8(bcx.ccx));\n-                }\n-                let layout = bcx.ccx.layout_of(self.ty);\n-                let i = if let Layout::Univariant { ref variant, .. } = *layout {\n-                    adt::struct_llfields_index(variant, i)\n-                } else {\n-                    i\n-                };\n-                llpair = bcx.insert_value(llpair, elem, i);\n-            }\n-            self.val = OperandValue::Immediate(llpair);\n+            let mut llpair = C_undef(llty);\n+            llpair = bcx.insert_value(llpair, a, 0);\n+            llpair = bcx.insert_value(llpair, b, 1);\n+            llpair\n+        } else {\n+            self.immediate()\n         }\n-        self\n     }\n \n-    /// If this operand is a pair in an Immediate,\n-    /// we return a Pair with the two halves.\n-    pub fn unpack_if_pair(mut self, bcx: &Builder<'a, 'tcx>) -> OperandRef<'tcx> {\n-        if let OperandValue::Immediate(llval) = self.val {\n+    /// If the type is a pair, we return a `Pair`, otherwise, an `Immediate`.\n+    pub fn from_immediate_or_packed_pair(bcx: &Builder<'a, 'tcx>,\n+                                         llval: ValueRef,\n+                                         layout: TyLayout<'tcx>)\n+                                         -> OperandRef<'tcx> {\n+        let val = if layout.is_llvm_scalar_pair() {\n+            debug!(\"Operand::from_immediate_or_packed_pair: unpacking {:?} @ {:?}\",\n+                    llval, layout);\n+\n             // Deconstruct the immediate aggregate.\n-            if common::type_is_imm_pair(bcx.ccx, self.ty) {\n-                debug!(\"Operand::unpack_if_pair: unpacking {:?}\", self);\n+            OperandValue::Pair(bcx.extract_value(llval, 0),\n+                               bcx.extract_value(llval, 1))\n+        } else {\n+            OperandValue::Immediate(llval)\n+        };\n+        OperandRef { val, layout }\n+    }\n \n-                let layout = bcx.ccx.layout_of(self.ty);\n-                let (ix0, ix1) = if let Layout::Univariant { ref variant, .. } = *layout {\n-                    (adt::struct_llfields_index(variant, 0),\n-                    adt::struct_llfields_index(variant, 1))\n-                } else {\n-                    (0, 1)\n+    pub fn extract_field(&self, bcx: &Builder<'a, 'tcx>, i: usize) -> OperandRef<'tcx> {\n+        let field = self.layout.field(bcx.ccx, i);\n+        let offset = self.layout.fields.offset(i);\n+\n+        let mut val = match (self.val, &self.layout.abi) {\n+            // If we're uninhabited, or the field is ZST, it has no data.\n+            _ if self.layout.abi == layout::Abi::Uninhabited || field.is_zst() => {\n+                return OperandRef {\n+                    val: OperandValue::Immediate(C_undef(field.immediate_llvm_type(bcx.ccx))),\n+                    layout: field\n                 };\n+            }\n \n-                let mut a = bcx.extract_value(llval, ix0);\n-                let mut b = bcx.extract_value(llval, ix1);\n+            // Newtype of a scalar or scalar pair.\n+            (OperandValue::Immediate(_), _) |\n+            (OperandValue::Pair(..), _) if field.size == self.layout.size => {\n+                assert_eq!(offset.bytes(), 0);\n+                self.val\n+            }\n \n-                let pair_fields = common::type_pair_fields(bcx.ccx, self.ty);\n-                if let Some([a_ty, b_ty]) = pair_fields {\n-                    if a_ty.is_bool() {\n-                        a = bcx.trunc(a, Type::i1(bcx.ccx));\n-                    }\n-                    if b_ty.is_bool() {\n-                        b = bcx.trunc(b, Type::i1(bcx.ccx));\n-                    }\n+            // Extract a scalar component from a pair.\n+            (OperandValue::Pair(a_llval, b_llval), &layout::Abi::ScalarPair(ref a, ref b)) => {\n+                if offset.bytes() == 0 {\n+                    assert_eq!(field.size, a.value.size(bcx.ccx));\n+                    OperandValue::Immediate(a_llval)\n+                } else {\n+                    assert_eq!(offset, a.value.size(bcx.ccx)\n+                        .abi_align(b.value.align(bcx.ccx)));\n+                    assert_eq!(field.size, b.value.size(bcx.ccx));\n+                    OperandValue::Immediate(b_llval)\n                 }\n+            }\n+\n+            // `#[repr(simd)]` types are also immediate.\n+            (OperandValue::Immediate(llval), &layout::Abi::Vector) => {\n+                OperandValue::Immediate(\n+                    bcx.extract_element(llval, C_usize(bcx.ccx, i as u64)))\n+            }\n+\n+            _ => bug!(\"OperandRef::extract_field({:?}): not applicable\", self)\n+        };\n \n-                self.val = OperandValue::Pair(a, b);\n+        // HACK(eddyb) have to bitcast pointers until LLVM removes pointee types.\n+        match val {\n+            OperandValue::Immediate(ref mut llval) => {\n+                *llval = bcx.bitcast(*llval, field.immediate_llvm_type(bcx.ccx));\n+            }\n+            OperandValue::Pair(ref mut a, ref mut b) => {\n+                *a = bcx.bitcast(*a, field.scalar_pair_element_llvm_type(bcx.ccx, 0));\n+                *b = bcx.bitcast(*b, field.scalar_pair_element_llvm_type(bcx.ccx, 1));\n             }\n+            OperandValue::Ref(..) => bug!()\n+        }\n+\n+        OperandRef {\n+            val,\n+            layout: field\n         }\n-        self\n     }\n }\n \n-impl<'a, 'tcx> MirContext<'a, 'tcx> {\n-    pub fn trans_load(&mut self,\n-                      bcx: &Builder<'a, 'tcx>,\n-                      llval: ValueRef,\n-                      align: Alignment,\n-                      ty: Ty<'tcx>)\n-                      -> OperandRef<'tcx>\n-    {\n-        debug!(\"trans_load: {:?} @ {:?}\", Value(llval), ty);\n-\n-        let val = if common::type_is_fat_ptr(bcx.ccx, ty) {\n-            let (lldata, llextra) = base::load_fat_ptr(bcx, llval, align, ty);\n-            OperandValue::Pair(lldata, llextra)\n-        } else if common::type_is_imm_pair(bcx.ccx, ty) {\n-            let (ix0, ix1, f_align) = match *bcx.ccx.layout_of(ty) {\n-                Layout::Univariant { ref variant, .. } => {\n-                    (adt::struct_llfields_index(variant, 0),\n-                    adt::struct_llfields_index(variant, 1),\n-                    Alignment::from_packed(variant.packed) | align)\n-                },\n-                _ => (0, 1, align)\n-            };\n-            let [a_ty, b_ty] = common::type_pair_fields(bcx.ccx, ty).unwrap();\n-            let a_ptr = bcx.struct_gep(llval, ix0);\n-            let b_ptr = bcx.struct_gep(llval, ix1);\n-\n-            OperandValue::Pair(\n-                base::load_ty(bcx, a_ptr, f_align, a_ty),\n-                base::load_ty(bcx, b_ptr, f_align, b_ty)\n-            )\n-        } else if common::type_is_immediate(bcx.ccx, ty) {\n-            OperandValue::Immediate(base::load_ty(bcx, llval, align, ty))\n-        } else {\n-            OperandValue::Ref(llval, align)\n-        };\n-\n-        OperandRef { val: val, ty: ty }\n+impl<'a, 'tcx> OperandValue {\n+    pub fn store(self, bcx: &Builder<'a, 'tcx>, dest: LvalueRef<'tcx>) {\n+        debug!(\"OperandRef::store: operand={:?}, dest={:?}\", self, dest);\n+        // Avoid generating stores of zero-sized values, because the only way to have a zero-sized\n+        // value is through `undef`, and store itself is useless.\n+        if dest.layout.is_zst() {\n+            return;\n+        }\n+        match self {\n+            OperandValue::Ref(r, source_align) =>\n+                base::memcpy_ty(bcx, dest.llval, r, dest.layout,\n+                                (source_align | dest.alignment).non_abi()),\n+            OperandValue::Immediate(s) => {\n+                bcx.store(base::from_immediate(bcx, s), dest.llval, dest.alignment.non_abi());\n+            }\n+            OperandValue::Pair(a, b) => {\n+                for (i, &x) in [a, b].iter().enumerate() {\n+                    let mut llptr = bcx.struct_gep(dest.llval, i as u64);\n+                    // Make sure to always store i1 as i8.\n+                    if common::val_ty(x) == Type::i1(bcx.ccx) {\n+                        llptr = bcx.pointercast(llptr, Type::i8p(bcx.ccx));\n+                    }\n+                    bcx.store(base::from_immediate(bcx, x), llptr, dest.alignment.non_abi());\n+                }\n+            }\n+        }\n     }\n+}\n \n-    pub fn trans_consume(&mut self,\n-                         bcx: &Builder<'a, 'tcx>,\n-                         lvalue: &mir::Lvalue<'tcx>)\n-                         -> OperandRef<'tcx>\n+impl<'a, 'tcx> MirContext<'a, 'tcx> {\n+    fn maybe_trans_consume_direct(&mut self,\n+                                  bcx: &Builder<'a, 'tcx>,\n+                                  lvalue: &mir::Lvalue<'tcx>)\n+                                   -> Option<OperandRef<'tcx>>\n     {\n-        debug!(\"trans_consume(lvalue={:?})\", lvalue);\n+        debug!(\"maybe_trans_consume_direct(lvalue={:?})\", lvalue);\n \n         // watch out for locals that do not have an\n         // alloca; they are handled somewhat differently\n         if let mir::Lvalue::Local(index) = *lvalue {\n             match self.locals[index] {\n                 LocalRef::Operand(Some(o)) => {\n-                    return o;\n+                    return Some(o);\n                 }\n                 LocalRef::Operand(None) => {\n                     bug!(\"use of {:?} before def\", lvalue);\n@@ -253,33 +264,40 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             }\n         }\n \n-        // Moves out of pair fields are trivial.\n+        // Moves out of scalar and scalar pair fields are trivial.\n         if let &mir::Lvalue::Projection(ref proj) = lvalue {\n-            if let mir::Lvalue::Local(index) = proj.base {\n-                if let LocalRef::Operand(Some(o)) = self.locals[index] {\n-                    match (o.val, &proj.elem) {\n-                        (OperandValue::Pair(a, b),\n-                         &mir::ProjectionElem::Field(ref f, ty)) => {\n-                            let llval = [a, b][f.index()];\n-                            let op = OperandRef {\n-                                val: OperandValue::Immediate(llval),\n-                                ty: self.monomorphize(&ty)\n-                            };\n-\n-                            // Handle nested pairs.\n-                            return op.unpack_if_pair(bcx);\n-                        }\n-                        _ => {}\n-                    }\n+            if let mir::ProjectionElem::Field(ref f, _) = proj.elem {\n+                if let Some(o) = self.maybe_trans_consume_direct(bcx, &proj.base) {\n+                    return Some(o.extract_field(bcx, f.index()));\n                 }\n             }\n         }\n \n+        None\n+    }\n+\n+    pub fn trans_consume(&mut self,\n+                         bcx: &Builder<'a, 'tcx>,\n+                         lvalue: &mir::Lvalue<'tcx>)\n+                         -> OperandRef<'tcx>\n+    {\n+        debug!(\"trans_consume(lvalue={:?})\", lvalue);\n+\n+        let ty = self.monomorphized_lvalue_ty(lvalue);\n+        let layout = bcx.ccx.layout_of(ty);\n+\n+        // ZSTs don't require any actual memory access.\n+        if layout.is_zst() {\n+            return OperandRef::new_zst(bcx.ccx, layout);\n+        }\n+\n+        if let Some(o) = self.maybe_trans_consume_direct(bcx, lvalue) {\n+            return o;\n+        }\n+\n         // for most lvalues, to consume them we just load them\n         // out from their home\n-        let tr_lvalue = self.trans_lvalue(bcx, lvalue);\n-        let ty = tr_lvalue.ty.to_ty(bcx.tcx());\n-        self.trans_load(bcx, tr_lvalue.llval, tr_lvalue.alignment, ty)\n+        self.trans_lvalue(bcx, lvalue).load(bcx)\n     }\n \n     pub fn trans_operand(&mut self,\n@@ -299,60 +317,11 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let operand = val.to_operand(bcx.ccx);\n                 if let OperandValue::Ref(ptr, align) = operand.val {\n                     // If this is a OperandValue::Ref to an immediate constant, load it.\n-                    self.trans_load(bcx, ptr, align, operand.ty)\n+                    LvalueRef::new_sized(ptr, operand.layout, align).load(bcx)\n                 } else {\n                     operand\n                 }\n             }\n         }\n     }\n-\n-    pub fn store_operand(&mut self,\n-                         bcx: &Builder<'a, 'tcx>,\n-                         lldest: ValueRef,\n-                         align: Option<u32>,\n-                         operand: OperandRef<'tcx>) {\n-        debug!(\"store_operand: operand={:?}, align={:?}\", operand, align);\n-        // Avoid generating stores of zero-sized values, because the only way to have a zero-sized\n-        // value is through `undef`, and store itself is useless.\n-        if common::type_is_zero_size(bcx.ccx, operand.ty) {\n-            return;\n-        }\n-        match operand.val {\n-            OperandValue::Ref(r, Alignment::Packed) =>\n-                base::memcpy_ty(bcx, lldest, r, operand.ty, Some(1)),\n-            OperandValue::Ref(r, Alignment::AbiAligned) =>\n-                base::memcpy_ty(bcx, lldest, r, operand.ty, align),\n-            OperandValue::Immediate(s) => {\n-                bcx.store(base::from_immediate(bcx, s), lldest, align);\n-            }\n-            OperandValue::Pair(a, b) => {\n-                let (ix0, ix1, f_align) = match *bcx.ccx.layout_of(operand.ty) {\n-                    Layout::Univariant { ref variant, .. } => {\n-                        (adt::struct_llfields_index(variant, 0),\n-                        adt::struct_llfields_index(variant, 1),\n-                        if variant.packed { Some(1) } else { None })\n-                    }\n-                    _ => (0, 1, align)\n-                };\n-\n-                let a = base::from_immediate(bcx, a);\n-                let b = base::from_immediate(bcx, b);\n-\n-                // See comment above about zero-sized values.\n-                let (a_zst, b_zst) = common::type_pair_fields(bcx.ccx, operand.ty)\n-                    .map_or((false, false), |[a_ty, b_ty]| {\n-                        (common::type_is_zero_size(bcx.ccx, a_ty),\n-                         common::type_is_zero_size(bcx.ccx, b_ty))\n-                    });\n-\n-                if !a_zst {\n-                    bcx.store(a, bcx.struct_gep(lldest, ix0), f_align);\n-                }\n-                if !b_zst {\n-                    bcx.store(b, bcx.struct_gep(lldest, ix1), f_align);\n-                }\n-            }\n-        }\n-    }\n }"}, {"sha": "4781425f491f8ef8978eb9626638bdf3d6633ead", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 175, "deletions": 206, "changes": 381, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -11,8 +11,7 @@\n use llvm::{self, ValueRef};\n use rustc::ty::{self, Ty};\n use rustc::ty::cast::{CastTy, IntTy};\n-use rustc::ty::layout::{Layout, LayoutTyper};\n-use rustc::mir::tcx::LvalueTy;\n+use rustc::ty::layout::{self, LayoutOf};\n use rustc::mir;\n use rustc::middle::lang_items::ExchangeMallocFnLangItem;\n use rustc_apfloat::{ieee, Float, Status, Round};\n@@ -22,14 +21,12 @@ use std::{u128, i128};\n use base;\n use builder::Builder;\n use callee;\n-use common::{self, val_ty, C_bool, C_i32, C_u32, C_u64, C_null, C_usize, C_uint, C_big_integral};\n+use common::{self, val_ty};\n+use common::{C_bool, C_u8, C_i32, C_u32, C_u64, C_null, C_usize, C_uint, C_uint_big};\n use consts;\n-use adt;\n-use machine;\n use monomorphize;\n use type_::Type;\n-use type_of;\n-use tvec;\n+use type_of::LayoutLlvmExt;\n use value::Value;\n \n use super::{MirContext, LocalRef};\n@@ -52,18 +49,18 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                let tr_operand = self.trans_operand(&bcx, operand);\n                // FIXME: consider not copying constants through stack. (fixable by translating\n                // constants into OperandValue::Ref, why don\u2019t we do that yet if we don\u2019t?)\n-               self.store_operand(&bcx, dest.llval, dest.alignment.to_align(), tr_operand);\n+               tr_operand.val.store(&bcx, dest);\n                bcx\n            }\n \n-            mir::Rvalue::Cast(mir::CastKind::Unsize, ref source, cast_ty) => {\n-                let cast_ty = self.monomorphize(&cast_ty);\n-\n-                if common::type_is_fat_ptr(bcx.ccx, cast_ty) {\n+            mir::Rvalue::Cast(mir::CastKind::Unsize, ref source, _) => {\n+                // The destination necessarily contains a fat pointer, so if\n+                // it's a scalar pair, it's a fat pointer or newtype thereof.\n+                if dest.layout.is_llvm_scalar_pair() {\n                     // into-coerce of a thin pointer to a fat pointer - just\n                     // use the operand path.\n                     let (bcx, temp) = self.trans_rvalue_operand(bcx, rvalue);\n-                    self.store_operand(&bcx, dest.llval, dest.alignment.to_align(), temp);\n+                    temp.val.store(&bcx, dest);\n                     return bcx;\n                 }\n \n@@ -72,126 +69,112 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 // `CoerceUnsized` can be passed by a where-clause,\n                 // so the (generic) MIR may not be able to expand it.\n                 let operand = self.trans_operand(&bcx, source);\n-                let operand = operand.pack_if_pair(&bcx);\n-                let llref = match operand.val {\n-                    OperandValue::Pair(..) => bug!(),\n-                    OperandValue::Immediate(llval) => {\n+                match operand.val {\n+                    OperandValue::Pair(..) |\n+                    OperandValue::Immediate(_) => {\n                         // unsize from an immediate structure. We don't\n                         // really need a temporary alloca here, but\n                         // avoiding it would require us to have\n                         // `coerce_unsized_into` use extractvalue to\n                         // index into the struct, and this case isn't\n                         // important enough for it.\n                         debug!(\"trans_rvalue: creating ugly alloca\");\n-                        let scratch = LvalueRef::alloca(&bcx, operand.ty, \"__unsize_temp\");\n-                        base::store_ty(&bcx, llval, scratch.llval, scratch.alignment, operand.ty);\n-                        scratch\n+                        let scratch = LvalueRef::alloca(&bcx, operand.layout, \"__unsize_temp\");\n+                        scratch.storage_live(&bcx);\n+                        operand.val.store(&bcx, scratch);\n+                        base::coerce_unsized_into(&bcx, scratch, dest);\n+                        scratch.storage_dead(&bcx);\n                     }\n                     OperandValue::Ref(llref, align) => {\n-                        LvalueRef::new_sized_ty(llref, operand.ty, align)\n+                        let source = LvalueRef::new_sized(llref, operand.layout, align);\n+                        base::coerce_unsized_into(&bcx, source, dest);\n                     }\n-                };\n-                base::coerce_unsized_into(&bcx, &llref, &dest);\n+                }\n                 bcx\n             }\n \n             mir::Rvalue::Repeat(ref elem, count) => {\n-                let dest_ty = dest.ty.to_ty(bcx.tcx());\n+                let tr_elem = self.trans_operand(&bcx, elem);\n \n-                // No need to inizialize memory of a zero-sized slice\n-                if common::type_is_zero_size(bcx.ccx, dest_ty) {\n+                // Do not generate the loop for zero-sized elements or empty arrays.\n+                if dest.layout.is_zst() {\n                     return bcx;\n                 }\n \n-                let tr_elem = self.trans_operand(&bcx, elem);\n-                let size = count.as_u64();\n-                let size = C_usize(bcx.ccx, size);\n-                let base = base::get_dataptr(&bcx, dest.llval);\n-                let align = dest.alignment.to_align();\n+                let start = dest.project_index(&bcx, C_usize(bcx.ccx, 0)).llval;\n \n                 if let OperandValue::Immediate(v) = tr_elem.val {\n+                    let align = dest.alignment.non_abi()\n+                        .unwrap_or(tr_elem.layout.align);\n+                    let align = C_i32(bcx.ccx, align.abi() as i32);\n+                    let size = C_usize(bcx.ccx, dest.layout.size.bytes());\n+\n                     // Use llvm.memset.p0i8.* to initialize all zero arrays\n                     if common::is_const_integral(v) && common::const_to_uint(v) == 0 {\n-                        let align = align.unwrap_or_else(|| bcx.ccx.align_of(tr_elem.ty));\n-                        let align = C_i32(bcx.ccx, align as i32);\n-                        let ty = type_of::type_of(bcx.ccx, dest_ty);\n-                        let size = machine::llsize_of(bcx.ccx, ty);\n-                        let fill = C_uint(Type::i8(bcx.ccx), 0);\n-                        base::call_memset(&bcx, base, fill, size, align, false);\n+                        let fill = C_u8(bcx.ccx, 0);\n+                        base::call_memset(&bcx, start, fill, size, align, false);\n                         return bcx;\n                     }\n \n                     // Use llvm.memset.p0i8.* to initialize byte arrays\n+                    let v = base::from_immediate(&bcx, v);\n                     if common::val_ty(v) == Type::i8(bcx.ccx) {\n-                        let align = align.unwrap_or_else(|| bcx.ccx.align_of(tr_elem.ty));\n-                        let align = C_i32(bcx.ccx, align as i32);\n-                        base::call_memset(&bcx, base, v, size, align, false);\n+                        base::call_memset(&bcx, start, v, size, align, false);\n                         return bcx;\n                     }\n                 }\n \n-                tvec::slice_for_each(&bcx, base, tr_elem.ty, size, |bcx, llslot, loop_bb| {\n-                    self.store_operand(bcx, llslot, align, tr_elem);\n-                    bcx.br(loop_bb);\n-                })\n+                let count = count.as_u64();\n+                let count = C_usize(bcx.ccx, count);\n+                let end = dest.project_index(&bcx, count).llval;\n+\n+                let header_bcx = bcx.build_sibling_block(\"repeat_loop_header\");\n+                let body_bcx = bcx.build_sibling_block(\"repeat_loop_body\");\n+                let next_bcx = bcx.build_sibling_block(\"repeat_loop_next\");\n+\n+                bcx.br(header_bcx.llbb());\n+                let current = header_bcx.phi(common::val_ty(start), &[start], &[bcx.llbb()]);\n+\n+                let keep_going = header_bcx.icmp(llvm::IntNE, current, end);\n+                header_bcx.cond_br(keep_going, body_bcx.llbb(), next_bcx.llbb());\n+\n+                tr_elem.val.store(&body_bcx,\n+                    LvalueRef::new_sized(current, tr_elem.layout, dest.alignment));\n+\n+                let next = body_bcx.inbounds_gep(current, &[C_usize(bcx.ccx, 1)]);\n+                body_bcx.br(header_bcx.llbb());\n+                header_bcx.add_incoming_to_phi(current, next, body_bcx.llbb());\n+\n+                next_bcx\n             }\n \n             mir::Rvalue::Aggregate(ref kind, ref operands) => {\n-                match **kind {\n-                    mir::AggregateKind::Adt(adt_def, variant_index, substs, active_field_index) => {\n-                        let discr = adt_def.discriminant_for_variant(bcx.tcx(), variant_index)\n-                           .to_u128_unchecked() as u64;\n-                        let dest_ty = dest.ty.to_ty(bcx.tcx());\n-                        adt::trans_set_discr(&bcx, dest_ty, dest.llval, discr);\n-                        for (i, operand) in operands.iter().enumerate() {\n-                            let op = self.trans_operand(&bcx, operand);\n-                            // Do not generate stores and GEPis for zero-sized fields.\n-                            if !common::type_is_zero_size(bcx.ccx, op.ty) {\n-                                let mut val = LvalueRef::new_sized(\n-                                    dest.llval, dest.ty, dest.alignment);\n-                                let field_index = active_field_index.unwrap_or(i);\n-                                val.ty = LvalueTy::Downcast {\n-                                    adt_def,\n-                                    substs: self.monomorphize(&substs),\n-                                    variant_index,\n-                                };\n-                                let (lldest_i, align) = val.trans_field_ptr(&bcx, field_index);\n-                                self.store_operand(&bcx, lldest_i, align.to_align(), op);\n-                            }\n-                        }\n-                    },\n-                    _ => {\n-                        // If this is a tuple or closure, we need to translate GEP indices.\n-                        let layout = bcx.ccx.layout_of(dest.ty.to_ty(bcx.tcx()));\n-                        let get_memory_index = |i| {\n-                            if let Layout::Univariant { ref variant, .. } = *layout {\n-                                adt::struct_llfields_index(variant, i)\n-                            } else {\n-                                i\n-                            }\n-                        };\n-                        let alignment = dest.alignment;\n-                        for (i, operand) in operands.iter().enumerate() {\n-                            let op = self.trans_operand(&bcx, operand);\n-                            // Do not generate stores and GEPis for zero-sized fields.\n-                            if !common::type_is_zero_size(bcx.ccx, op.ty) {\n-                                // Note: perhaps this should be StructGep, but\n-                                // note that in some cases the values here will\n-                                // not be structs but arrays.\n-                                let i = get_memory_index(i);\n-                                let dest = bcx.gepi(dest.llval, &[0, i]);\n-                                self.store_operand(&bcx, dest, alignment.to_align(), op);\n-                            }\n+                let (dest, active_field_index) = match **kind {\n+                    mir::AggregateKind::Adt(adt_def, variant_index, _, active_field_index) => {\n+                        dest.trans_set_discr(&bcx, variant_index);\n+                        if adt_def.is_enum() {\n+                            (dest.project_downcast(&bcx, variant_index), active_field_index)\n+                        } else {\n+                            (dest, active_field_index)\n                         }\n                     }\n+                    _ => (dest, None)\n+                };\n+                for (i, operand) in operands.iter().enumerate() {\n+                    let op = self.trans_operand(&bcx, operand);\n+                    // Do not generate stores and GEPis for zero-sized fields.\n+                    if !op.layout.is_zst() {\n+                        let field_index = active_field_index.unwrap_or(i);\n+                        op.val.store(&bcx, dest.project_field(&bcx, field_index));\n+                    }\n                 }\n                 bcx\n             }\n \n             _ => {\n                 assert!(self.rvalue_creates_operand(rvalue));\n                 let (bcx, temp) = self.trans_rvalue_operand(bcx, rvalue);\n-                self.store_operand(&bcx, dest.llval, dest.alignment.to_align(), temp);\n+                temp.val.store(&bcx, dest);\n                 bcx\n             }\n         }\n@@ -205,32 +188,32 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         assert!(self.rvalue_creates_operand(rvalue), \"cannot trans {:?} to operand\", rvalue);\n \n         match *rvalue {\n-            mir::Rvalue::Cast(ref kind, ref source, cast_ty) => {\n+            mir::Rvalue::Cast(ref kind, ref source, mir_cast_ty) => {\n                 let operand = self.trans_operand(&bcx, source);\n                 debug!(\"cast operand is {:?}\", operand);\n-                let cast_ty = self.monomorphize(&cast_ty);\n+                let cast = bcx.ccx.layout_of(self.monomorphize(&mir_cast_ty));\n \n                 let val = match *kind {\n                     mir::CastKind::ReifyFnPointer => {\n-                        match operand.ty.sty {\n+                        match operand.layout.ty.sty {\n                             ty::TyFnDef(def_id, substs) => {\n                                 OperandValue::Immediate(\n                                     callee::resolve_and_get_fn(bcx.ccx, def_id, substs))\n                             }\n                             _ => {\n-                                bug!(\"{} cannot be reified to a fn ptr\", operand.ty)\n+                                bug!(\"{} cannot be reified to a fn ptr\", operand.layout.ty)\n                             }\n                         }\n                     }\n                     mir::CastKind::ClosureFnPointer => {\n-                        match operand.ty.sty {\n+                        match operand.layout.ty.sty {\n                             ty::TyClosure(def_id, substs) => {\n                                 let instance = monomorphize::resolve_closure(\n                                     bcx.ccx.tcx(), def_id, substs, ty::ClosureKind::FnOnce);\n                                 OperandValue::Immediate(callee::get_fn(bcx.ccx, instance))\n                             }\n                             _ => {\n-                                bug!(\"{} cannot be cast to a fn ptr\", operand.ty)\n+                                bug!(\"{} cannot be cast to a fn ptr\", operand.layout.ty)\n                             }\n                         }\n                     }\n@@ -239,26 +222,24 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         operand.val\n                     }\n                     mir::CastKind::Unsize => {\n-                        // unsize targets other than to a fat pointer currently\n-                        // can't be operands.\n-                        assert!(common::type_is_fat_ptr(bcx.ccx, cast_ty));\n-\n+                        assert!(cast.is_llvm_scalar_pair());\n                         match operand.val {\n                             OperandValue::Pair(lldata, llextra) => {\n                                 // unsize from a fat pointer - this is a\n                                 // \"trait-object-to-supertrait\" coercion, for\n                                 // example,\n                                 //   &'a fmt::Debug+Send => &'a fmt::Debug,\n-                                // So we need to pointercast the base to ensure\n-                                // the types match up.\n-                                let llcast_ty = type_of::fat_ptr_base_ty(bcx.ccx, cast_ty);\n-                                let lldata = bcx.pointercast(lldata, llcast_ty);\n+\n+                                // HACK(eddyb) have to bitcast pointers\n+                                // until LLVM removes pointee types.\n+                                let lldata = bcx.pointercast(lldata,\n+                                    cast.scalar_pair_element_llvm_type(bcx.ccx, 0));\n                                 OperandValue::Pair(lldata, llextra)\n                             }\n                             OperandValue::Immediate(lldata) => {\n                                 // \"standard\" unsize\n                                 let (lldata, llextra) = base::unsize_thin_ptr(&bcx, lldata,\n-                                    operand.ty, cast_ty);\n+                                    operand.layout.ty, cast.ty);\n                                 OperandValue::Pair(lldata, llextra)\n                             }\n                             OperandValue::Ref(..) => {\n@@ -267,51 +248,50 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                             }\n                         }\n                     }\n-                    mir::CastKind::Misc if common::type_is_fat_ptr(bcx.ccx, operand.ty) => {\n-                        let ll_cast_ty = type_of::immediate_type_of(bcx.ccx, cast_ty);\n-                        let ll_from_ty = type_of::immediate_type_of(bcx.ccx, operand.ty);\n-                        if let OperandValue::Pair(data_ptr, meta_ptr) = operand.val {\n-                            if common::type_is_fat_ptr(bcx.ccx, cast_ty) {\n-                                let ll_cft = ll_cast_ty.field_types();\n-                                let ll_fft = ll_from_ty.field_types();\n-                                let data_cast = bcx.pointercast(data_ptr, ll_cft[0]);\n-                                assert_eq!(ll_cft[1].kind(), ll_fft[1].kind());\n-                                OperandValue::Pair(data_cast, meta_ptr)\n+                    mir::CastKind::Misc if operand.layout.is_llvm_scalar_pair() => {\n+                        if let OperandValue::Pair(data_ptr, meta) = operand.val {\n+                            if cast.is_llvm_scalar_pair() {\n+                                let data_cast = bcx.pointercast(data_ptr,\n+                                    cast.scalar_pair_element_llvm_type(bcx.ccx, 0));\n+                                OperandValue::Pair(data_cast, meta)\n                             } else { // cast to thin-ptr\n                                 // Cast of fat-ptr to thin-ptr is an extraction of data-ptr and\n                                 // pointer-cast of that pointer to desired pointer type.\n-                                let llval = bcx.pointercast(data_ptr, ll_cast_ty);\n+                                let llcast_ty = cast.immediate_llvm_type(bcx.ccx);\n+                                let llval = bcx.pointercast(data_ptr, llcast_ty);\n                                 OperandValue::Immediate(llval)\n                             }\n                         } else {\n                             bug!(\"Unexpected non-Pair operand\")\n                         }\n                     }\n                     mir::CastKind::Misc => {\n-                        debug_assert!(common::type_is_immediate(bcx.ccx, cast_ty));\n-                        let r_t_in = CastTy::from_ty(operand.ty).expect(\"bad input type for cast\");\n-                        let r_t_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n-                        let ll_t_in = type_of::immediate_type_of(bcx.ccx, operand.ty);\n-                        let ll_t_out = type_of::immediate_type_of(bcx.ccx, cast_ty);\n+                        assert!(cast.is_llvm_immediate());\n+                        let r_t_in = CastTy::from_ty(operand.layout.ty)\n+                            .expect(\"bad input type for cast\");\n+                        let r_t_out = CastTy::from_ty(cast.ty).expect(\"bad output type for cast\");\n+                        let ll_t_in = operand.layout.immediate_llvm_type(bcx.ccx);\n+                        let ll_t_out = cast.immediate_llvm_type(bcx.ccx);\n                         let llval = operand.immediate();\n-                        let l = bcx.ccx.layout_of(operand.ty);\n-                        let signed = if let Layout::CEnum { signed, min, max, .. } = *l {\n-                            if max > min {\n-                                // We want `table[e as usize]` to not\n-                                // have bound checks, and this is the most\n-                                // convenient place to put the `assume`.\n-\n-                                base::call_assume(&bcx, bcx.icmp(\n-                                    llvm::IntULE,\n-                                    llval,\n-                                    C_uint(common::val_ty(llval), max)\n-                                ));\n-                            }\n \n-                            signed\n-                        } else {\n-                            operand.ty.is_signed()\n-                        };\n+                        let mut signed = false;\n+                        if let layout::Abi::Scalar(ref scalar) = operand.layout.abi {\n+                            if let layout::Int(_, s) = scalar.value {\n+                                signed = s;\n+\n+                                if scalar.valid_range.end > scalar.valid_range.start {\n+                                    // We want `table[e as usize]` to not\n+                                    // have bound checks, and this is the most\n+                                    // convenient place to put the `assume`.\n+\n+                                    base::call_assume(&bcx, bcx.icmp(\n+                                        llvm::IntULE,\n+                                        llval,\n+                                        C_uint_big(ll_t_in, scalar.valid_range.end)\n+                                    ));\n+                                }\n+                            }\n+                        }\n \n                         let newval = match (r_t_in, r_t_out) {\n                             (CastTy::Int(_), CastTy::Int(_)) => {\n@@ -343,76 +323,70 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                                 cast_float_to_int(&bcx, true, llval, ll_t_in, ll_t_out),\n                             (CastTy::Float, CastTy::Int(_)) =>\n                                 cast_float_to_int(&bcx, false, llval, ll_t_in, ll_t_out),\n-                            _ => bug!(\"unsupported cast: {:?} to {:?}\", operand.ty, cast_ty)\n+                            _ => bug!(\"unsupported cast: {:?} to {:?}\", operand.layout.ty, cast.ty)\n                         };\n                         OperandValue::Immediate(newval)\n                     }\n                 };\n-                let operand = OperandRef {\n+                (bcx, OperandRef {\n                     val,\n-                    ty: cast_ty\n-                };\n-                (bcx, operand)\n+                    layout: cast\n+                })\n             }\n \n             mir::Rvalue::Ref(_, bk, ref lvalue) => {\n                 let tr_lvalue = self.trans_lvalue(&bcx, lvalue);\n \n-                let ty = tr_lvalue.ty.to_ty(bcx.tcx());\n-                let ref_ty = bcx.tcx().mk_ref(\n-                    bcx.tcx().types.re_erased,\n-                    ty::TypeAndMut { ty: ty, mutbl: bk.to_mutbl_lossy() }\n-                );\n+                let ty = tr_lvalue.layout.ty;\n \n                 // Note: lvalues are indirect, so storing the `llval` into the\n                 // destination effectively creates a reference.\n-                let operand = if !bcx.ccx.shared().type_has_metadata(ty) {\n-                    OperandRef {\n-                        val: OperandValue::Immediate(tr_lvalue.llval),\n-                        ty: ref_ty,\n-                    }\n+                let val = if !bcx.ccx.shared().type_has_metadata(ty) {\n+                    OperandValue::Immediate(tr_lvalue.llval)\n                 } else {\n-                    OperandRef {\n-                        val: OperandValue::Pair(tr_lvalue.llval,\n-                                                tr_lvalue.llextra),\n-                        ty: ref_ty,\n-                    }\n+                    OperandValue::Pair(tr_lvalue.llval, tr_lvalue.llextra)\n                 };\n-                (bcx, operand)\n+                (bcx, OperandRef {\n+                    val,\n+                    layout: self.ccx.layout_of(self.ccx.tcx().mk_ref(\n+                        self.ccx.tcx().types.re_erased,\n+                        ty::TypeAndMut { ty, mutbl: bk.to_mutbl_lossy() }\n+                    )),\n+                })\n             }\n \n             mir::Rvalue::Len(ref lvalue) => {\n                 let size = self.evaluate_array_len(&bcx, lvalue);\n                 let operand = OperandRef {\n                     val: OperandValue::Immediate(size),\n-                    ty: bcx.tcx().types.usize,\n+                    layout: bcx.ccx.layout_of(bcx.tcx().types.usize),\n                 };\n                 (bcx, operand)\n             }\n \n             mir::Rvalue::BinaryOp(op, ref lhs, ref rhs) => {\n                 let lhs = self.trans_operand(&bcx, lhs);\n                 let rhs = self.trans_operand(&bcx, rhs);\n-                let llresult = if common::type_is_fat_ptr(bcx.ccx, lhs.ty) {\n-                    match (lhs.val, rhs.val) {\n-                        (OperandValue::Pair(lhs_addr, lhs_extra),\n-                         OperandValue::Pair(rhs_addr, rhs_extra)) => {\n-                            self.trans_fat_ptr_binop(&bcx, op,\n-                                                     lhs_addr, lhs_extra,\n-                                                     rhs_addr, rhs_extra,\n-                                                     lhs.ty)\n-                        }\n-                        _ => bug!()\n+                let llresult = match (lhs.val, rhs.val) {\n+                    (OperandValue::Pair(lhs_addr, lhs_extra),\n+                     OperandValue::Pair(rhs_addr, rhs_extra)) => {\n+                        self.trans_fat_ptr_binop(&bcx, op,\n+                                                 lhs_addr, lhs_extra,\n+                                                 rhs_addr, rhs_extra,\n+                                                 lhs.layout.ty)\n                     }\n \n-                } else {\n-                    self.trans_scalar_binop(&bcx, op,\n-                                            lhs.immediate(), rhs.immediate(),\n-                                            lhs.ty)\n+                    (OperandValue::Immediate(lhs_val),\n+                     OperandValue::Immediate(rhs_val)) => {\n+                        self.trans_scalar_binop(&bcx, op, lhs_val, rhs_val, lhs.layout.ty)\n+                    }\n+\n+                    _ => bug!()\n                 };\n                 let operand = OperandRef {\n                     val: OperandValue::Immediate(llresult),\n-                    ty: op.ty(bcx.tcx(), lhs.ty, rhs.ty),\n+                    layout: bcx.ccx.layout_of(\n+                        op.ty(bcx.tcx(), lhs.layout.ty, rhs.layout.ty)),\n                 };\n                 (bcx, operand)\n             }\n@@ -421,12 +395,12 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let rhs = self.trans_operand(&bcx, rhs);\n                 let result = self.trans_scalar_checked_binop(&bcx, op,\n                                                              lhs.immediate(), rhs.immediate(),\n-                                                             lhs.ty);\n-                let val_ty = op.ty(bcx.tcx(), lhs.ty, rhs.ty);\n+                                                             lhs.layout.ty);\n+                let val_ty = op.ty(bcx.tcx(), lhs.layout.ty, rhs.layout.ty);\n                 let operand_ty = bcx.tcx().intern_tup(&[val_ty, bcx.tcx().types.bool], false);\n                 let operand = OperandRef {\n                     val: result,\n-                    ty: operand_ty\n+                    layout: bcx.ccx.layout_of(operand_ty)\n                 };\n \n                 (bcx, operand)\n@@ -435,7 +409,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             mir::Rvalue::UnaryOp(op, ref operand) => {\n                 let operand = self.trans_operand(&bcx, operand);\n                 let lloperand = operand.immediate();\n-                let is_float = operand.ty.is_fp();\n+                let is_float = operand.layout.ty.is_fp();\n                 let llval = match op {\n                     mir::UnOp::Not => bcx.not(lloperand),\n                     mir::UnOp::Neg => if is_float {\n@@ -446,47 +420,43 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 };\n                 (bcx, OperandRef {\n                     val: OperandValue::Immediate(llval),\n-                    ty: operand.ty,\n+                    layout: operand.layout,\n                 })\n             }\n \n             mir::Rvalue::Discriminant(ref lvalue) => {\n-                let discr_lvalue = self.trans_lvalue(&bcx, lvalue);\n-                let enum_ty = discr_lvalue.ty.to_ty(bcx.tcx());\n                 let discr_ty = rvalue.ty(&*self.mir, bcx.tcx());\n-                let discr_type = type_of::immediate_type_of(bcx.ccx, discr_ty);\n-                let discr = adt::trans_get_discr(&bcx, enum_ty, discr_lvalue.llval,\n-                                                  discr_lvalue.alignment, Some(discr_type), true);\n+                let discr =  self.trans_lvalue(&bcx, lvalue)\n+                    .trans_get_discr(&bcx, discr_ty);\n                 (bcx, OperandRef {\n                     val: OperandValue::Immediate(discr),\n-                    ty: discr_ty\n+                    layout: self.ccx.layout_of(discr_ty)\n                 })\n             }\n \n             mir::Rvalue::NullaryOp(mir::NullOp::SizeOf, ty) => {\n                 assert!(bcx.ccx.shared().type_is_sized(ty));\n-                let val = C_usize(bcx.ccx, bcx.ccx.size_of(ty));\n+                let val = C_usize(bcx.ccx, bcx.ccx.size_of(ty).bytes());\n                 let tcx = bcx.tcx();\n                 (bcx, OperandRef {\n                     val: OperandValue::Immediate(val),\n-                    ty: tcx.types.usize,\n+                    layout: self.ccx.layout_of(tcx.types.usize),\n                 })\n             }\n \n             mir::Rvalue::NullaryOp(mir::NullOp::Box, content_ty) => {\n                 let content_ty: Ty<'tcx> = self.monomorphize(&content_ty);\n-                let llty = type_of::type_of(bcx.ccx, content_ty);\n-                let llsize = machine::llsize_of(bcx.ccx, llty);\n-                let align = bcx.ccx.align_of(content_ty);\n-                let llalign = C_usize(bcx.ccx, align as u64);\n-                let llty_ptr = llty.ptr_to();\n-                let box_ty = bcx.tcx().mk_box(content_ty);\n+                let (size, align) = bcx.ccx.size_and_align_of(content_ty);\n+                let llsize = C_usize(bcx.ccx, size.bytes());\n+                let llalign = C_usize(bcx.ccx, align.abi());\n+                let box_layout = bcx.ccx.layout_of(bcx.tcx().mk_box(content_ty));\n+                let llty_ptr = box_layout.llvm_type(bcx.ccx);\n \n                 // Allocate space:\n                 let def_id = match bcx.tcx().lang_items().require(ExchangeMallocFnLangItem) {\n                     Ok(id) => id,\n                     Err(s) => {\n-                        bcx.sess().fatal(&format!(\"allocation of `{}` {}\", box_ty, s));\n+                        bcx.sess().fatal(&format!(\"allocation of `{}` {}\", box_layout.ty, s));\n                     }\n                 };\n                 let instance = ty::Instance::mono(bcx.tcx(), def_id);\n@@ -495,7 +465,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n                 let operand = OperandRef {\n                     val: OperandValue::Immediate(val),\n-                    ty: box_ty,\n+                    layout: box_layout,\n                 };\n                 (bcx, operand)\n             }\n@@ -508,7 +478,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 // According to `rvalue_creates_operand`, only ZST\n                 // aggregate rvalues are allowed to be operands.\n                 let ty = rvalue.ty(self.mir, self.ccx.tcx());\n-                (bcx, OperandRef::new_zst(self.ccx, self.monomorphize(&ty)))\n+                (bcx, OperandRef::new_zst(self.ccx,\n+                    self.ccx.layout_of(self.monomorphize(&ty))))\n             }\n         }\n     }\n@@ -521,11 +492,9 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         // because trans_lvalue() panics if Local is operand.\n         if let mir::Lvalue::Local(index) = *lvalue {\n             if let LocalRef::Operand(Some(op)) = self.locals[index] {\n-                if common::type_is_zero_size(bcx.ccx, op.ty) {\n-                    if let ty::TyArray(_, n) = op.ty.sty {\n-                        let n = n.val.to_const_int().unwrap().to_u64().unwrap();\n-                        return common::C_usize(bcx.ccx, n);\n-                    }\n+                if let ty::TyArray(_, n) = op.layout.ty.sty {\n+                    let n = n.val.to_const_int().unwrap().to_u64().unwrap();\n+                    return common::C_usize(bcx.ccx, n);\n                 }\n             }\n         }\n@@ -730,7 +699,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             mir::Rvalue::Aggregate(..) => {\n                 let ty = rvalue.ty(self.mir, self.ccx.tcx());\n                 let ty = self.monomorphize(&ty);\n-                common::type_is_zero_size(self.ccx, ty)\n+                self.ccx.layout_of(ty).is_zst()\n             }\n         }\n \n@@ -830,7 +799,7 @@ fn cast_int_to_float(bcx: &Builder,\n     if is_u128_to_f32 {\n         // All inputs greater or equal to (f32::MAX + 0.5 ULP) are rounded to infinity,\n         // and for everything else LLVM's uitofp works just fine.\n-        let max = C_big_integral(int_ty, MAX_F32_PLUS_HALF_ULP);\n+        let max = C_uint_big(int_ty, MAX_F32_PLUS_HALF_ULP);\n         let overflow = bcx.icmp(llvm::IntUGE, x, max);\n         let infinity_bits = C_u32(bcx.ccx, ieee::Single::INFINITY.to_bits() as u32);\n         let infinity = consts::bitcast(infinity_bits, float_ty);\n@@ -957,8 +926,8 @@ fn cast_float_to_int(bcx: &Builder,\n     // performed is ultimately up to the backend, but at least x86 does perform them.\n     let less_or_nan = bcx.fcmp(llvm::RealULT, x, f_min);\n     let greater = bcx.fcmp(llvm::RealOGT, x, f_max);\n-    let int_max = C_big_integral(int_ty, int_max(signed, int_ty));\n-    let int_min = C_big_integral(int_ty, int_min(signed, int_ty) as u128);\n+    let int_max = C_uint_big(int_ty, int_max(signed, int_ty));\n+    let int_min = C_uint_big(int_ty, int_min(signed, int_ty) as u128);\n     let s0 = bcx.select(less_or_nan, int_min, fptosui_result);\n     let s1 = bcx.select(greater, int_max, s0);\n "}, {"sha": "607ecd887fa7823be86285c0086af2f3c505d30d", "filename": "src/librustc_trans/mir/statement.rs", "status": "modified", "additions": 17, "deletions": 32, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fstatement.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -10,14 +10,11 @@\n \n use rustc::mir;\n \n-use base;\n use asm;\n-use common;\n use builder::Builder;\n \n use super::MirContext;\n use super::LocalRef;\n-use super::super::adt;\n \n impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     pub fn trans_statement(&mut self,\n@@ -39,18 +36,16 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                             self.locals[index] = LocalRef::Operand(Some(operand));\n                             bcx\n                         }\n-                        LocalRef::Operand(Some(_)) => {\n-                            let ty = self.monomorphized_lvalue_ty(lvalue);\n-\n-                            if !common::type_is_zero_size(bcx.ccx, ty) {\n+                        LocalRef::Operand(Some(op)) => {\n+                            if !op.layout.is_zst() {\n                                 span_bug!(statement.source_info.span,\n                                           \"operand {:?} already assigned\",\n                                           rvalue);\n-                            } else {\n-                                // If the type is zero-sized, it's already been set here,\n-                                // but we still need to make sure we translate the operand\n-                                self.trans_rvalue_operand(bcx, rvalue).0\n                             }\n+\n+                            // If the type is zero-sized, it's already been set here,\n+                            // but we still need to make sure we translate the operand\n+                            self.trans_rvalue_operand(bcx, rvalue).0\n                         }\n                     }\n                 } else {\n@@ -59,24 +54,25 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 }\n             }\n             mir::StatementKind::SetDiscriminant{ref lvalue, variant_index} => {\n-                let ty = self.monomorphized_lvalue_ty(lvalue);\n-                let lvalue_transed = self.trans_lvalue(&bcx, lvalue);\n-                adt::trans_set_discr(&bcx,\n-                    ty,\n-                    lvalue_transed.llval,\n-                    variant_index as u64);\n+                self.trans_lvalue(&bcx, lvalue)\n+                    .trans_set_discr(&bcx, variant_index);\n                 bcx\n             }\n             mir::StatementKind::StorageLive(local) => {\n-                self.trans_storage_liveness(bcx, local, base::Lifetime::Start)\n+                if let LocalRef::Lvalue(tr_lval) = self.locals[local] {\n+                    tr_lval.storage_live(&bcx);\n+                }\n+                bcx\n             }\n             mir::StatementKind::StorageDead(local) => {\n-                self.trans_storage_liveness(bcx, local, base::Lifetime::End)\n+                if let LocalRef::Lvalue(tr_lval) = self.locals[local] {\n+                    tr_lval.storage_dead(&bcx);\n+                }\n+                bcx\n             }\n             mir::StatementKind::InlineAsm { ref asm, ref outputs, ref inputs } => {\n                 let outputs = outputs.iter().map(|output| {\n-                    let lvalue = self.trans_lvalue(&bcx, output);\n-                    (lvalue.llval, lvalue.ty.to_ty(bcx.tcx()))\n+                    self.trans_lvalue(&bcx, output)\n                 }).collect();\n \n                 let input_vals = inputs.iter().map(|input| {\n@@ -91,15 +87,4 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             mir::StatementKind::Nop => bcx,\n         }\n     }\n-\n-    fn trans_storage_liveness(&self,\n-                              bcx: Builder<'a, 'tcx>,\n-                              index: mir::Local,\n-                              intrinsic: base::Lifetime)\n-                              -> Builder<'a, 'tcx> {\n-        if let LocalRef::Lvalue(tr_lval) = self.locals[index] {\n-            intrinsic.call(&bcx, tr_lval.llval);\n-        }\n-        bcx\n-    }\n }"}, {"sha": "991f99e0f6c9963c74ddc68a75aa6468332d3855", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -23,14 +23,15 @@ use common;\n use declare;\n use llvm;\n use monomorphize::Instance;\n+use type_of::LayoutLlvmExt;\n use rustc::hir;\n use rustc::middle::trans::{Linkage, Visibility};\n use rustc::ty::{self, TyCtxt, TypeFoldable};\n+use rustc::ty::layout::LayoutOf;\n use syntax::ast;\n use syntax::attr;\n use syntax_pos::Span;\n use syntax_pos::symbol::Symbol;\n-use type_of;\n use std::fmt;\n \n pub use rustc::middle::trans::TransItem;\n@@ -173,7 +174,7 @@ fn predefine_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let def_id = ccx.tcx().hir.local_def_id(node_id);\n     let instance = Instance::mono(ccx.tcx(), def_id);\n     let ty = common::instance_ty(ccx.tcx(), &instance);\n-    let llty = type_of::type_of(ccx, ty);\n+    let llty = ccx.layout_of(ty).llvm_type(ccx);\n \n     let g = declare::define_global(ccx, symbol_name, llty).unwrap_or_else(|| {\n         ccx.sess().span_fatal(ccx.tcx().hir.span(node_id),"}, {"sha": "da4a4e55a67f4819356305a7b692979f8006b1af", "filename": "src/librustc_trans/tvec.rs", "status": "removed", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/5041b3bb3d953a14f32b15d1e41341c629acae12/src%2Flibrustc_trans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5041b3bb3d953a14f32b15d1e41341c629acae12/src%2Flibrustc_trans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftvec.rs?ref=5041b3bb3d953a14f32b15d1e41341c629acae12", "patch": "@@ -1,53 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use llvm;\n-use builder::Builder;\n-use llvm::{BasicBlockRef, ValueRef};\n-use common::*;\n-use rustc::ty::Ty;\n-\n-pub fn slice_for_each<'a, 'tcx, F>(\n-    bcx: &Builder<'a, 'tcx>,\n-    data_ptr: ValueRef,\n-    unit_ty: Ty<'tcx>,\n-    len: ValueRef,\n-    f: F\n-) -> Builder<'a, 'tcx> where F: FnOnce(&Builder<'a, 'tcx>, ValueRef, BasicBlockRef) {\n-    // Special-case vectors with elements of size 0  so they don't go out of bounds (#9890)\n-    let zst = type_is_zero_size(bcx.ccx, unit_ty);\n-    let add = |bcx: &Builder, a, b| if zst {\n-        bcx.add(a, b)\n-    } else {\n-        bcx.inbounds_gep(a, &[b])\n-    };\n-\n-    let body_bcx = bcx.build_sibling_block(\"slice_loop_body\");\n-    let header_bcx = bcx.build_sibling_block(\"slice_loop_header\");\n-    let next_bcx = bcx.build_sibling_block(\"slice_loop_next\");\n-\n-    let start = if zst {\n-        C_usize(bcx.ccx, 1)\n-    } else {\n-        data_ptr\n-    };\n-    let end = add(&bcx, start, len);\n-\n-    bcx.br(header_bcx.llbb());\n-    let current = header_bcx.phi(val_ty(start), &[start], &[bcx.llbb()]);\n-\n-    let keep_going = header_bcx.icmp(llvm::IntNE, current, end);\n-    header_bcx.cond_br(keep_going, body_bcx.llbb(), next_bcx.llbb());\n-\n-    let next = add(&body_bcx, current, C_usize(bcx.ccx, 1));\n-    f(&body_bcx, if zst { data_ptr } else { current }, header_bcx.llbb());\n-    header_bcx.add_incoming_to_phi(current, next, body_bcx.llbb());\n-    next_bcx\n-}"}, {"sha": "02224858b4692acb515d90e186cf794d0da1fc2b", "filename": "src/librustc_trans/type_.rs", "status": "modified", "additions": 12, "deletions": 36, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -17,7 +17,7 @@ use llvm::{Float, Double, X86_FP80, PPC_FP128, FP128};\n use context::CrateContext;\n \n use syntax::ast;\n-use rustc::ty::layout;\n+use rustc::ty::layout::{self, Align};\n \n use std::ffi::CString;\n use std::fmt;\n@@ -66,10 +66,6 @@ impl Type {\n         ty!(llvm::LLVMVoidTypeInContext(ccx.llcx()))\n     }\n \n-    pub fn nil(ccx: &CrateContext) -> Type {\n-        Type::empty_struct(ccx)\n-    }\n-\n     pub fn metadata(ccx: &CrateContext) -> Type {\n         ty!(llvm::LLVMRustMetadataTypeInContext(ccx.llcx()))\n     }\n@@ -202,9 +198,6 @@ impl Type {\n         ty!(llvm::LLVMStructCreateNamed(ccx.llcx(), name.as_ptr()))\n     }\n \n-    pub fn empty_struct(ccx: &CrateContext) -> Type {\n-        Type::struct_(ccx, &[], false)\n-    }\n \n     pub fn array(ty: &Type, len: u64) -> Type {\n         ty!(llvm::LLVMRustArrayType(ty.to_ref(), len))\n@@ -214,20 +207,6 @@ impl Type {\n         ty!(llvm::LLVMVectorType(ty.to_ref(), len as c_uint))\n     }\n \n-    pub fn vec(ccx: &CrateContext, ty: &Type) -> Type {\n-        Type::struct_(ccx,\n-            &[Type::array(ty, 0), Type::isize(ccx)],\n-        false)\n-    }\n-\n-    pub fn opaque_vec(ccx: &CrateContext) -> Type {\n-        Type::vec(ccx, &Type::i8(ccx))\n-    }\n-\n-    pub fn vtable_ptr(ccx: &CrateContext) -> Type {\n-        Type::func(&[Type::i8p(ccx)], &Type::void(ccx)).ptr_to().ptr_to()\n-    }\n-\n     pub fn kind(&self) -> TypeKind {\n         unsafe {\n             llvm::LLVMRustGetTypeKind(self.to_ref())\n@@ -259,19 +238,6 @@ impl Type {\n         }\n     }\n \n-    pub fn field_types(&self) -> Vec<Type> {\n-        unsafe {\n-            let n_elts = llvm::LLVMCountStructElementTypes(self.to_ref()) as usize;\n-            if n_elts == 0 {\n-                return Vec::new();\n-            }\n-            let mut elts = vec![Type { rf: ptr::null_mut() }; n_elts];\n-            llvm::LLVMGetStructElementTypes(self.to_ref(),\n-                                            elts.as_mut_ptr() as *mut TypeRef);\n-            elts\n-        }\n-    }\n-\n     pub fn func_params(&self) -> Vec<Type> {\n         unsafe {\n             let n_args = llvm::LLVMCountParamTypes(self.to_ref()) as usize;\n@@ -302,12 +268,22 @@ impl Type {\n     pub fn from_integer(cx: &CrateContext, i: layout::Integer) -> Type {\n         use rustc::ty::layout::Integer::*;\n         match i {\n-            I1 => Type::i1(cx),\n             I8 => Type::i8(cx),\n             I16 => Type::i16(cx),\n             I32 => Type::i32(cx),\n             I64 => Type::i64(cx),\n             I128 => Type::i128(cx),\n         }\n     }\n+\n+    /// Return a LLVM type that has at most the required alignment,\n+    /// as a conservative approximation for unknown pointee types.\n+    pub fn pointee_for_abi_align(ccx: &CrateContext, align: Align) -> Type {\n+        if let Some(ity) = layout::Integer::for_abi_align(ccx, align) {\n+            Type::from_integer(ccx, ity)\n+        } else {\n+            // FIXME(eddyb) We could find a better approximation here.\n+            Type::i8(ccx)\n+        }\n+    }\n }"}, {"sha": "9b32c825117ee32d14ee1fd78d90503db554dffb", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 438, "deletions": 185, "changes": 623, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -9,231 +9,484 @@\n // except according to those terms.\n \n use abi::FnType;\n-use adt;\n use common::*;\n-use machine;\n+use rustc::hir;\n use rustc::ty::{self, Ty, TypeFoldable};\n-use rustc::ty::layout::LayoutTyper;\n+use rustc::ty::layout::{self, Align, LayoutOf, Size, TyLayout};\n+use rustc_back::PanicStrategy;\n use trans_item::DefPathBasedNames;\n use type_::Type;\n \n-use syntax::ast;\n+use std::fmt::Write;\n \n-pub fn fat_ptr_base_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> Type {\n-    match ty.sty {\n-        ty::TyRef(_, ty::TypeAndMut { ty: t, .. }) |\n-        ty::TyRawPtr(ty::TypeAndMut { ty: t, .. }) if ccx.shared().type_has_metadata(t) => {\n-            in_memory_type_of(ccx, t).ptr_to()\n+fn uncached_llvm_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                layout: TyLayout<'tcx>,\n+                                defer: &mut Option<(Type, TyLayout<'tcx>)>)\n+                                -> Type {\n+    match layout.abi {\n+        layout::Abi::Scalar(_) => bug!(\"handled elsewhere\"),\n+        layout::Abi::Vector => {\n+            return Type::vector(&layout.field(ccx, 0).llvm_type(ccx),\n+                                layout.fields.count() as u64);\n         }\n-        ty::TyAdt(def, _) if def.is_box() => {\n-            in_memory_type_of(ccx, ty.boxed_ty()).ptr_to()\n+        layout::Abi::ScalarPair(..) => {\n+            return Type::struct_(ccx, &[\n+                layout.scalar_pair_element_llvm_type(ccx, 0),\n+                layout.scalar_pair_element_llvm_type(ccx, 1),\n+            ], false);\n         }\n-        _ => bug!(\"expected fat ptr ty but got {:?}\", ty)\n+        layout::Abi::Uninhabited |\n+        layout::Abi::Aggregate { .. } => {}\n     }\n-}\n \n-pub fn unsized_info_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> Type {\n-    let unsized_part = ccx.tcx().struct_tail(ty);\n-    match unsized_part.sty {\n-        ty::TyStr | ty::TyArray(..) | ty::TySlice(_) => {\n-            Type::uint_from_ty(ccx, ast::UintTy::Us)\n+    let name = match layout.ty.sty {\n+        ty::TyClosure(..) |\n+        ty::TyGenerator(..) |\n+        ty::TyAdt(..) |\n+        ty::TyDynamic(..) |\n+        ty::TyForeign(..) |\n+        ty::TyStr => {\n+            let mut name = String::with_capacity(32);\n+            let printer = DefPathBasedNames::new(ccx.tcx(), true, true);\n+            printer.push_type_name(layout.ty, &mut name);\n+            match (&layout.ty.sty, &layout.variants) {\n+                (&ty::TyAdt(def, _), &layout::Variants::Single { index }) => {\n+                    if def.is_enum() && !def.variants.is_empty() {\n+                        write!(&mut name, \"::{}\", def.variants[index].name).unwrap();\n+                    }\n+                }\n+                _ => {}\n+            }\n+            Some(name)\n+        }\n+        _ => None\n+    };\n+\n+    match layout.fields {\n+        layout::FieldPlacement::Union(_) => {\n+            let size = layout.size.bytes();\n+            let fill = Type::array(&Type::i8(ccx), size);\n+            match name {\n+                None => {\n+                    Type::struct_(ccx, &[fill], layout.is_packed())\n+                }\n+                Some(ref name) => {\n+                    let mut llty = Type::named_struct(ccx, name);\n+                    llty.set_struct_body(&[fill], layout.is_packed());\n+                    llty\n+                }\n+            }\n+        }\n+        layout::FieldPlacement::Array { count, .. } => {\n+            Type::array(&layout.field(ccx, 0).llvm_type(ccx), count)\n+        }\n+        layout::FieldPlacement::Arbitrary { .. } => {\n+            match name {\n+                None => {\n+                    Type::struct_(ccx, &struct_llfields(ccx, layout), layout.is_packed())\n+                }\n+                Some(ref name) => {\n+                    let llty = Type::named_struct(ccx, name);\n+                    *defer = Some((llty, layout));\n+                    llty\n+                }\n+            }\n         }\n-        ty::TyDynamic(..) => Type::vtable_ptr(ccx),\n-        _ => bug!(\"Unexpected tail in unsized_info_ty: {:?} for ty={:?}\",\n-                          unsized_part, ty)\n     }\n }\n \n-pub fn immediate_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n-    if t.is_bool() {\n-        Type::i1(cx)\n+fn struct_llfields<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                             layout: TyLayout<'tcx>) -> Vec<Type> {\n+    debug!(\"struct_llfields: {:#?}\", layout);\n+    let field_count = layout.fields.count();\n+\n+    let mut offset = Size::from_bytes(0);\n+    let mut result: Vec<Type> = Vec::with_capacity(1 + field_count * 2);\n+    for i in layout.fields.index_by_increasing_offset() {\n+        let field = layout.field(ccx, i);\n+        let target_offset = layout.fields.offset(i as usize);\n+        debug!(\"struct_llfields: {}: {:?} offset: {:?} target_offset: {:?}\",\n+            i, field, offset, target_offset);\n+        assert!(target_offset >= offset);\n+        let padding = target_offset - offset;\n+        result.push(Type::array(&Type::i8(ccx), padding.bytes()));\n+        debug!(\"    padding before: {:?}\", padding);\n+\n+        result.push(field.llvm_type(ccx));\n+\n+        if layout.is_packed() {\n+            assert_eq!(padding.bytes(), 0);\n+        } else {\n+            assert!(field.align.abi() <= layout.align.abi(),\n+                    \"non-packed type has field with larger align ({}): {:#?}\",\n+                    field.align.abi(), layout);\n+        }\n+\n+        offset = target_offset + field.size;\n+    }\n+    if !layout.is_unsized() && field_count > 0 {\n+        if offset > layout.size {\n+            bug!(\"layout: {:#?} stride: {:?} offset: {:?}\",\n+                 layout, layout.size, offset);\n+        }\n+        let padding = layout.size - offset;\n+        debug!(\"struct_llfields: pad_bytes: {:?} offset: {:?} stride: {:?}\",\n+               padding, offset, layout.size);\n+        result.push(Type::array(&Type::i8(ccx), padding.bytes()));\n+        assert!(result.len() == 1 + field_count * 2);\n     } else {\n-        type_of(cx, t)\n+        debug!(\"struct_llfields: offset: {:?} stride: {:?}\",\n+               offset, layout.size);\n     }\n-}\n \n-/// Get the LLVM type corresponding to a Rust type, i.e. `rustc::ty::Ty`.\n-/// This is the right LLVM type for an alloca containing a value of that type,\n-/// and the pointee of an Lvalue Datum (which is always a LLVM pointer).\n-/// For unsized types, the returned type is a fat pointer, thus the resulting\n-/// LLVM type for a `Trait` Lvalue is `{ i8*, void(i8*)** }*`, which is a double\n-/// indirection to the actual data, unlike a `i8` Lvalue, which is just `i8*`.\n-/// This is needed due to the treatment of immediate values, as a fat pointer\n-/// is too large for it to be placed in SSA value (by our rules).\n-/// For the raw type without far pointer indirection, see `in_memory_type_of`.\n-pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> Type {\n-    let ty = if cx.shared().type_has_metadata(ty) {\n-        cx.tcx().mk_imm_ptr(ty)\n-    } else {\n-        ty\n-    };\n-    in_memory_type_of(cx, ty)\n+    result\n }\n \n-/// Get the LLVM type corresponding to a Rust type, i.e. `rustc::ty::Ty`.\n-/// This is the right LLVM type for a field/array element of that type,\n-/// and is the same as `type_of` for all Sized types.\n-/// Unsized types, however, are represented by a \"minimal unit\", e.g.\n-/// `[T]` becomes `T`, while `str` and `Trait` turn into `i8` - this\n-/// is useful for indexing slices, as `&[T]`'s data pointer is `T*`.\n-/// If the type is an unsized struct, the regular layout is generated,\n-/// with the inner-most trailing unsized field using the \"minimal unit\"\n-/// of that field's type - this is useful for taking the address of\n-/// that field and ensuring the struct has the right alignment.\n-/// For the LLVM type of a value as a whole, see `type_of`.\n-pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n-    // Check the cache.\n-    if let Some(&llty) = cx.lltypes().borrow().get(&t) {\n-        return llty;\n+impl<'a, 'tcx> CrateContext<'a, 'tcx> {\n+    pub fn align_of(&self, ty: Ty<'tcx>) -> Align {\n+        self.layout_of(ty).align\n     }\n \n-    debug!(\"type_of {:?}\", t);\n+    pub fn size_of(&self, ty: Ty<'tcx>) -> Size {\n+        self.layout_of(ty).size\n+    }\n \n-    assert!(!t.has_escaping_regions(), \"{:?} has escaping regions\", t);\n+    pub fn size_and_align_of(&self, ty: Ty<'tcx>) -> (Size, Align) {\n+        self.layout_of(ty).size_and_align()\n+    }\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq)]\n+pub enum PointerKind {\n+    /// Most general case, we know no restrictions to tell LLVM.\n+    Shared,\n \n-    // Replace any typedef'd types with their equivalent non-typedef\n-    // type. This ensures that all LLVM nominal types that contain\n-    // Rust types are defined as the same LLVM types.  If we don't do\n-    // this then, e.g. `Option<{myfield: bool}>` would be a different\n-    // type than `Option<myrec>`.\n-    let t_norm = cx.tcx().erase_regions(&t);\n+    /// `&T` where `T` contains no `UnsafeCell`, is `noalias` and `readonly`.\n+    Frozen,\n+\n+    /// `&mut T`, when we know `noalias` is safe for LLVM.\n+    UniqueBorrowed,\n+\n+    /// `Box<T>`, unlike `UniqueBorrowed`, it also has `noalias` on returns.\n+    UniqueOwned\n+}\n \n-    if t != t_norm {\n-        let llty = in_memory_type_of(cx, t_norm);\n-        debug!(\"--> normalized {:?} to {:?} llty={:?}\", t, t_norm, llty);\n-        cx.lltypes().borrow_mut().insert(t, llty);\n-        return llty;\n+#[derive(Copy, Clone)]\n+pub struct PointeeInfo {\n+    pub size: Size,\n+    pub align: Align,\n+    pub safe: Option<PointerKind>,\n+}\n+\n+pub trait LayoutLlvmExt<'tcx> {\n+    fn is_llvm_immediate(&self) -> bool;\n+    fn is_llvm_scalar_pair<'a>(&self) -> bool;\n+    fn llvm_type<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> Type;\n+    fn immediate_llvm_type<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> Type;\n+    fn scalar_pair_element_llvm_type<'a>(&self, ccx: &CrateContext<'a, 'tcx>,\n+                                         index: usize) -> Type;\n+    fn llvm_field_index(&self, index: usize) -> u64;\n+    fn pointee_info_at<'a>(&self, ccx: &CrateContext<'a, 'tcx>, offset: Size)\n+                           -> Option<PointeeInfo>;\n+}\n+\n+impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n+    fn is_llvm_immediate(&self) -> bool {\n+        match self.abi {\n+            layout::Abi::Uninhabited |\n+            layout::Abi::Scalar(_) |\n+            layout::Abi::Vector => true,\n+            layout::Abi::ScalarPair(..) => false,\n+            layout::Abi::Aggregate { .. } => self.is_zst()\n+        }\n     }\n \n-    let ptr_ty = |ty: Ty<'tcx>| {\n-        if cx.shared().type_has_metadata(ty) {\n-            if let ty::TyStr = ty.sty {\n-                // This means we get a nicer name in the output (str is always\n-                // unsized).\n-                cx.str_slice_type()\n-            } else {\n-                let ptr_ty = in_memory_type_of(cx, ty).ptr_to();\n-                let info_ty = unsized_info_ty(cx, ty);\n-                Type::struct_(cx, &[ptr_ty, info_ty], false)\n+    fn is_llvm_scalar_pair<'a>(&self) -> bool {\n+        match self.abi {\n+            layout::Abi::ScalarPair(..) => true,\n+            layout::Abi::Uninhabited |\n+            layout::Abi::Scalar(_) |\n+            layout::Abi::Vector |\n+            layout::Abi::Aggregate { .. } => false\n+        }\n+    }\n+\n+    /// Get the LLVM type corresponding to a Rust type, i.e. `rustc::ty::Ty`.\n+    /// The pointee type of the pointer in `LvalueRef` is always this type.\n+    /// For sized types, it is also the right LLVM type for an `alloca`\n+    /// containing a value of that type, and most immediates (except `bool`).\n+    /// Unsized types, however, are represented by a \"minimal unit\", e.g.\n+    /// `[T]` becomes `T`, while `str` and `Trait` turn into `i8` - this\n+    /// is useful for indexing slices, as `&[T]`'s data pointer is `T*`.\n+    /// If the type is an unsized struct, the regular layout is generated,\n+    /// with the inner-most trailing unsized field using the \"minimal unit\"\n+    /// of that field's type - this is useful for taking the address of\n+    /// that field and ensuring the struct has the right alignment.\n+    fn llvm_type<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> Type {\n+        if let layout::Abi::Scalar(ref scalar) = self.abi {\n+            // Use a different cache for scalars because pointers to DSTs\n+            // can be either fat or thin (data pointers of fat pointers).\n+            if let Some(&llty) = ccx.scalar_lltypes().borrow().get(&self.ty) {\n+                return llty;\n             }\n-        } else {\n-            in_memory_type_of(cx, ty).ptr_to()\n+            let llty = match scalar.value {\n+                layout::Int(i, _) => Type::from_integer(ccx, i),\n+                layout::F32 => Type::f32(ccx),\n+                layout::F64 => Type::f64(ccx),\n+                layout::Pointer => {\n+                    let pointee = match self.ty.sty {\n+                        ty::TyRef(_, ty::TypeAndMut { ty, .. }) |\n+                        ty::TyRawPtr(ty::TypeAndMut { ty, .. }) => {\n+                            ccx.layout_of(ty).llvm_type(ccx)\n+                        }\n+                        ty::TyAdt(def, _) if def.is_box() => {\n+                            ccx.layout_of(self.ty.boxed_ty()).llvm_type(ccx)\n+                        }\n+                        ty::TyFnPtr(sig) => {\n+                            let sig = ccx.tcx().erase_late_bound_regions_and_normalize(&sig);\n+                            FnType::new(ccx, sig, &[]).llvm_type(ccx)\n+                        }\n+                        _ => {\n+                            // If we know the alignment, pick something better than i8.\n+                            if let Some(pointee) = self.pointee_info_at(ccx, Size::from_bytes(0)) {\n+                                Type::pointee_for_abi_align(ccx, pointee.align)\n+                            } else {\n+                                Type::i8(ccx)\n+                            }\n+                        }\n+                    };\n+                    pointee.ptr_to()\n+                }\n+            };\n+            ccx.scalar_lltypes().borrow_mut().insert(self.ty, llty);\n+            return llty;\n         }\n-    };\n \n-    let mut llty = match t.sty {\n-      ty::TyBool => Type::bool(cx),\n-      ty::TyChar => Type::char(cx),\n-      ty::TyInt(t) => Type::int_from_ty(cx, t),\n-      ty::TyUint(t) => Type::uint_from_ty(cx, t),\n-      ty::TyFloat(t) => Type::float_from_ty(cx, t),\n-      ty::TyNever => Type::nil(cx),\n-      ty::TyClosure(..) => {\n-          // Only create the named struct, but don't fill it in. We\n-          // fill it in *after* placing it into the type cache.\n-          adt::incomplete_type_of(cx, t, \"closure\")\n-      }\n-      ty::TyGenerator(..) => {\n-          // Only create the named struct, but don't fill it in. We\n-          // fill it in *after* placing it into the type cache.\n-          adt::incomplete_type_of(cx, t, \"generator\")\n-      }\n-\n-      ty::TyRef(_, ty::TypeAndMut{ty, ..}) |\n-      ty::TyRawPtr(ty::TypeAndMut{ty, ..}) => {\n-          ptr_ty(ty)\n-      }\n-      ty::TyAdt(def, _) if def.is_box() => {\n-          ptr_ty(t.boxed_ty())\n-      }\n-\n-      ty::TyArray(ty, size) => {\n-          let llty = in_memory_type_of(cx, ty);\n-          let size = size.val.to_const_int().unwrap().to_u64().unwrap();\n-          Type::array(&llty, size)\n-      }\n-\n-      // Unsized slice types (and str) have the type of their element, and\n-      // traits have the type of u8. This is so that the data pointer inside\n-      // fat pointers is of the right type (e.g. for array accesses), even\n-      // when taking the address of an unsized field in a struct.\n-      ty::TySlice(ty) => in_memory_type_of(cx, ty),\n-      ty::TyStr | ty::TyDynamic(..) | ty::TyForeign(..) => Type::i8(cx),\n-\n-      ty::TyFnDef(..) => Type::nil(cx),\n-      ty::TyFnPtr(sig) => {\n-        let sig = cx.tcx().erase_late_bound_regions_and_normalize(&sig);\n-        FnType::new(cx, sig, &[]).llvm_type(cx).ptr_to()\n-      }\n-      ty::TyTuple(ref tys, _) if tys.is_empty() => Type::nil(cx),\n-      ty::TyTuple(..) => {\n-          adt::type_of(cx, t)\n-      }\n-      ty::TyAdt(..) if t.is_simd() => {\n-          let e = t.simd_type(cx.tcx());\n-          if !e.is_machine() {\n-              cx.sess().fatal(&format!(\"monomorphising SIMD type `{}` with \\\n-                                        a non-machine element type `{}`\",\n-                                       t, e))\n-          }\n-          let llet = in_memory_type_of(cx, e);\n-          let n = t.simd_size(cx.tcx()) as u64;\n-          Type::vector(&llet, n)\n-      }\n-      ty::TyAdt(..) => {\n-          // Only create the named struct, but don't fill it in. We\n-          // fill it in *after* placing it into the type cache. This\n-          // avoids creating more than one copy of the enum when one\n-          // of the enum's variants refers to the enum itself.\n-          let name = llvm_type_name(cx, t);\n-          adt::incomplete_type_of(cx, t, &name[..])\n-      }\n-\n-      ty::TyInfer(..) |\n-      ty::TyProjection(..) |\n-      ty::TyParam(..) |\n-      ty::TyAnon(..) |\n-      ty::TyError => bug!(\"type_of with {:?}\", t),\n-    };\n \n-    debug!(\"--> mapped t={:?} to llty={:?}\", t, llty);\n+        // Check the cache.\n+        let variant_index = match self.variants {\n+            layout::Variants::Single { index } => Some(index),\n+            _ => None\n+        };\n+        if let Some(&llty) = ccx.lltypes().borrow().get(&(self.ty, variant_index)) {\n+            return llty;\n+        }\n+\n+        debug!(\"llvm_type({:#?})\", self);\n \n-    cx.lltypes().borrow_mut().insert(t, llty);\n+        assert!(!self.ty.has_escaping_regions(), \"{:?} has escaping regions\", self.ty);\n \n-    // If this was an enum or struct, fill in the type now.\n-    match t.sty {\n-        ty::TyAdt(..) | ty::TyClosure(..) | ty::TyGenerator(..) if !t.is_simd() && !t.is_box() => {\n-            adt::finish_type_of(cx, t, &mut llty);\n+        // Make sure lifetimes are erased, to avoid generating distinct LLVM\n+        // types for Rust types that only differ in the choice of lifetimes.\n+        let normal_ty = ccx.tcx().erase_regions(&self.ty);\n+\n+        let mut defer = None;\n+        let llty = if self.ty != normal_ty {\n+            let mut layout = ccx.layout_of(normal_ty);\n+            if let Some(v) = variant_index {\n+                layout = layout.for_variant(ccx, v);\n+            }\n+            layout.llvm_type(ccx)\n+        } else {\n+            uncached_llvm_type(ccx, *self, &mut defer)\n+        };\n+        debug!(\"--> mapped {:#?} to llty={:?}\", self, llty);\n+\n+        ccx.lltypes().borrow_mut().insert((self.ty, variant_index), llty);\n+\n+        if let Some((mut llty, layout)) = defer {\n+            llty.set_struct_body(&struct_llfields(ccx, layout), layout.is_packed())\n         }\n-        _ => ()\n-    }\n \n-    llty\n-}\n+        llty\n+    }\n \n-impl<'a, 'tcx> CrateContext<'a, 'tcx> {\n-    pub fn align_of(&self, ty: Ty<'tcx>) -> machine::llalign {\n-        self.layout_of(ty).align(self).abi() as machine::llalign\n+    fn immediate_llvm_type<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> Type {\n+        if let layout::Abi::Scalar(ref scalar) = self.abi {\n+            if scalar.is_bool() {\n+                return Type::i1(ccx);\n+            }\n+        }\n+        self.llvm_type(ccx)\n     }\n \n-    pub fn size_of(&self, ty: Ty<'tcx>) -> machine::llsize {\n-        self.layout_of(ty).size(self).bytes() as machine::llsize\n+    fn scalar_pair_element_llvm_type<'a>(&self, ccx: &CrateContext<'a, 'tcx>,\n+                                         index: usize) -> Type {\n+        // HACK(eddyb) special-case fat pointers until LLVM removes\n+        // pointee types, to avoid bitcasting every `OperandRef::deref`.\n+        match self.ty.sty {\n+            ty::TyRef(..) |\n+            ty::TyRawPtr(_) => {\n+                return self.field(ccx, index).llvm_type(ccx);\n+            }\n+            ty::TyAdt(def, _) if def.is_box() => {\n+                let ptr_ty = ccx.tcx().mk_mut_ptr(self.ty.boxed_ty());\n+                return ccx.layout_of(ptr_ty).scalar_pair_element_llvm_type(ccx, index);\n+            }\n+            _ => {}\n+        }\n+\n+        let (a, b) = match self.abi {\n+            layout::Abi::ScalarPair(ref a, ref b) => (a, b),\n+            _ => bug!(\"TyLayout::scalar_pair_element_llty({:?}): not applicable\", self)\n+        };\n+        let scalar = [a, b][index];\n+\n+        // Make sure to return the same type `immediate_llvm_type` would,\n+        // to avoid dealing with two types and the associated conversions.\n+        // This means that `(bool, bool)` is represented as `{i1, i1}`,\n+        // both in memory and as an immediate, while `bool` is typically\n+        // `i8` in memory and only `i1` when immediate. While we need to\n+        // load/store `bool` as `i8` to avoid crippling LLVM optimizations,\n+        // `i1` in a LLVM aggregate is valid and mostly equivalent to `i8`.\n+        if scalar.is_bool() {\n+            return Type::i1(ccx);\n+        }\n+\n+        match scalar.value {\n+            layout::Int(i, _) => Type::from_integer(ccx, i),\n+            layout::F32 => Type::f32(ccx),\n+            layout::F64 => Type::f64(ccx),\n+            layout::Pointer => {\n+                // If we know the alignment, pick something better than i8.\n+                let offset = if index == 0 {\n+                    Size::from_bytes(0)\n+                } else {\n+                    a.value.size(ccx).abi_align(b.value.align(ccx))\n+                };\n+                let pointee = if let Some(pointee) = self.pointee_info_at(ccx, offset) {\n+                    Type::pointee_for_abi_align(ccx, pointee.align)\n+                } else {\n+                    Type::i8(ccx)\n+                };\n+                pointee.ptr_to()\n+            }\n+        }\n     }\n \n-    pub fn over_align_of(&self, t: Ty<'tcx>)\n-                              -> Option<machine::llalign> {\n-        let layout = self.layout_of(t);\n-        if let Some(align) = layout.over_align(&self.tcx().data_layout) {\n-            Some(align as machine::llalign)\n-        } else {\n-            None\n+    fn llvm_field_index(&self, index: usize) -> u64 {\n+        match self.abi {\n+            layout::Abi::Scalar(_) |\n+            layout::Abi::ScalarPair(..) => {\n+                bug!(\"TyLayout::llvm_field_index({:?}): not applicable\", self)\n+            }\n+            _ => {}\n+        }\n+        match self.fields {\n+            layout::FieldPlacement::Union(_) => {\n+                bug!(\"TyLayout::llvm_field_index({:?}): not applicable\", self)\n+            }\n+\n+            layout::FieldPlacement::Array { .. } => {\n+                index as u64\n+            }\n+\n+            layout::FieldPlacement::Arbitrary { .. } => {\n+                1 + (self.fields.memory_index(index) as u64) * 2\n+            }\n         }\n     }\n-}\n \n-fn llvm_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> String {\n-    let mut name = String::with_capacity(32);\n-    let printer = DefPathBasedNames::new(cx.tcx(), true, true);\n-    printer.push_type_name(ty, &mut name);\n-    name\n+    fn pointee_info_at<'a>(&self, ccx: &CrateContext<'a, 'tcx>, offset: Size)\n+                           -> Option<PointeeInfo> {\n+        if let Some(&pointee) = ccx.pointee_infos().borrow().get(&(self.ty, offset)) {\n+            return pointee;\n+        }\n+\n+        let mut result = None;\n+        match self.ty.sty {\n+            ty::TyRawPtr(mt) if offset.bytes() == 0 => {\n+                let (size, align) = ccx.size_and_align_of(mt.ty);\n+                result = Some(PointeeInfo {\n+                    size,\n+                    align,\n+                    safe: None\n+                });\n+            }\n+\n+            ty::TyRef(_, mt) if offset.bytes() == 0 => {\n+                let (size, align) = ccx.size_and_align_of(mt.ty);\n+\n+                let kind = match mt.mutbl {\n+                    hir::MutImmutable => if ccx.shared().type_is_freeze(mt.ty) {\n+                        PointerKind::Frozen\n+                    } else {\n+                        PointerKind::Shared\n+                    },\n+                    hir::MutMutable => {\n+                        if ccx.shared().tcx().sess.opts.debugging_opts.mutable_noalias ||\n+                           ccx.shared().tcx().sess.panic_strategy() == PanicStrategy::Abort {\n+                            PointerKind::UniqueBorrowed\n+                        } else {\n+                            PointerKind::Shared\n+                        }\n+                    }\n+                };\n+\n+                result = Some(PointeeInfo {\n+                    size,\n+                    align,\n+                    safe: Some(kind)\n+                });\n+            }\n+\n+            _ => {\n+                let mut data_variant = match self.variants {\n+                    layout::Variants::NicheFilling { dataful_variant, .. } => {\n+                        // Only the niche itself is always initialized,\n+                        // so only check for a pointer at its offset.\n+                        //\n+                        // If the niche is a pointer, it's either valid\n+                        // (according to its type), or null (which the\n+                        // niche field's scalar validity range encodes).\n+                        // This allows using `dereferenceable_or_null`\n+                        // for e.g. `Option<&T>`, and this will continue\n+                        // to work as long as we don't start using more\n+                        // niches than just null (e.g. the first page\n+                        // of the address space, or unaligned pointers).\n+                        if self.fields.offset(0) == offset {\n+                            Some(self.for_variant(ccx, dataful_variant))\n+                        } else {\n+                            None\n+                        }\n+                    }\n+                    _ => Some(*self)\n+                };\n+\n+                if let Some(variant) = data_variant {\n+                    // We're not interested in any unions.\n+                    if let layout::FieldPlacement::Union(_) = variant.fields {\n+                        data_variant = None;\n+                    }\n+                }\n+\n+                if let Some(variant) = data_variant {\n+                    let ptr_end = offset + layout::Pointer.size(ccx);\n+                    for i in 0..variant.fields.count() {\n+                        let field_start = variant.fields.offset(i);\n+                        if field_start <= offset {\n+                            let field = variant.field(ccx, i);\n+                            if ptr_end <= field_start + field.size {\n+                                // We found the right field, look inside it.\n+                                result = field.pointee_info_at(ccx, offset - field_start);\n+                                break;\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                // FIXME(eddyb) This should be for `ptr::Unique<T>`, not `Box<T>`.\n+                if let Some(ref mut pointee) = result {\n+                    if let ty::TyAdt(def, _) = self.ty.sty {\n+                        if def.is_box() && offset.bytes() == 0 {\n+                            pointee.safe = Some(PointerKind::UniqueOwned);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        ccx.pointee_infos().borrow_mut().insert((self.ty, offset), result);\n+        result\n+    }\n }"}, {"sha": "eee5c1d9ef238c6a397590ed63390a1ea46a7642", "filename": "src/librustc_trans_utils/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans_utils%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Flibrustc_trans_utils%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Fmonomorphize.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -12,7 +12,7 @@ use rustc::hir::def_id::DefId;\n use rustc::middle::lang_items::DropInPlaceFnLangItem;\n use rustc::traits;\n use rustc::ty::adjustment::CustomCoerceUnsized;\n-use rustc::ty::subst::{Kind, Subst, Substs};\n+use rustc::ty::subst::{Kind, Subst};\n use rustc::ty::{self, Ty, TyCtxt};\n \n pub use rustc::ty::Instance;\n@@ -125,12 +125,3 @@ pub fn custom_coerce_unsize_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-/// Returns the normalized type of a struct field\n-pub fn field_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          param_substs: &Substs<'tcx>,\n-                          f: &'tcx ty::FieldDef)\n-                          -> Ty<'tcx>\n-{\n-    tcx.fully_normalize_associated_types_in(&f.ty(tcx, param_substs))\n-}\n-"}, {"sha": "9aa172591b86f7410d7c030d303c89ce13bdf891", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 60, "deletions": 5, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -178,6 +178,22 @@ extern \"C\" void LLVMRustAddCallSiteAttribute(LLVMValueRef Instr, unsigned Index,\n #endif\n }\n \n+extern \"C\" void LLVMRustAddAlignmentCallSiteAttr(LLVMValueRef Instr,\n+                                                 unsigned Index,\n+                                                 uint32_t Bytes) {\n+  CallSite Call = CallSite(unwrap<Instruction>(Instr));\n+  AttrBuilder B;\n+  B.addAlignmentAttr(Bytes);\n+#if LLVM_VERSION_GE(5, 0)\n+  Call.setAttributes(Call.getAttributes().addAttributes(\n+      Call->getContext(), Index, B));\n+#else\n+  Call.setAttributes(Call.getAttributes().addAttributes(\n+      Call->getContext(), Index,\n+      AttributeSet::get(Call->getContext(), Index, B)));\n+#endif\n+}\n+\n extern \"C\" void LLVMRustAddDereferenceableCallSiteAttr(LLVMValueRef Instr,\n                                                        unsigned Index,\n                                                        uint64_t Bytes) {\n@@ -194,6 +210,22 @@ extern \"C\" void LLVMRustAddDereferenceableCallSiteAttr(LLVMValueRef Instr,\n #endif\n }\n \n+extern \"C\" void LLVMRustAddDereferenceableOrNullCallSiteAttr(LLVMValueRef Instr,\n+                                                             unsigned Index,\n+                                                             uint64_t Bytes) {\n+  CallSite Call = CallSite(unwrap<Instruction>(Instr));\n+  AttrBuilder B;\n+  B.addDereferenceableOrNullAttr(Bytes);\n+#if LLVM_VERSION_GE(5, 0)\n+  Call.setAttributes(Call.getAttributes().addAttributes(\n+      Call->getContext(), Index, B));\n+#else\n+  Call.setAttributes(Call.getAttributes().addAttributes(\n+      Call->getContext(), Index,\n+      AttributeSet::get(Call->getContext(), Index, B)));\n+#endif\n+}\n+\n extern \"C\" void LLVMRustAddFunctionAttribute(LLVMValueRef Fn, unsigned Index,\n                                              LLVMRustAttribute RustAttr) {\n   Function *A = unwrap<Function>(Fn);\n@@ -206,6 +238,19 @@ extern \"C\" void LLVMRustAddFunctionAttribute(LLVMValueRef Fn, unsigned Index,\n #endif\n }\n \n+extern \"C\" void LLVMRustAddAlignmentAttr(LLVMValueRef Fn,\n+                                         unsigned Index,\n+                                         uint32_t Bytes) {\n+  Function *A = unwrap<Function>(Fn);\n+  AttrBuilder B;\n+  B.addAlignmentAttr(Bytes);\n+#if LLVM_VERSION_GE(5, 0)\n+  A->addAttributes(Index, B);\n+#else\n+  A->addAttributes(Index, AttributeSet::get(A->getContext(), Index, B));\n+#endif\n+}\n+\n extern \"C\" void LLVMRustAddDereferenceableAttr(LLVMValueRef Fn, unsigned Index,\n                                                uint64_t Bytes) {\n   Function *A = unwrap<Function>(Fn);\n@@ -218,6 +263,19 @@ extern \"C\" void LLVMRustAddDereferenceableAttr(LLVMValueRef Fn, unsigned Index,\n #endif\n }\n \n+extern \"C\" void LLVMRustAddDereferenceableOrNullAttr(LLVMValueRef Fn,\n+                                                     unsigned Index,\n+                                                     uint64_t Bytes) {\n+  Function *A = unwrap<Function>(Fn);\n+  AttrBuilder B;\n+  B.addDereferenceableOrNullAttr(Bytes);\n+#if LLVM_VERSION_GE(5, 0)\n+  A->addAttributes(Index, B);\n+#else\n+  A->addAttributes(Index, AttributeSet::get(A->getContext(), Index, B));\n+#endif\n+}\n+\n extern \"C\" void LLVMRustAddFunctionAttrStringValue(LLVMValueRef Fn,\n                                                    unsigned Index,\n                                                    const char *Name,\n@@ -257,21 +315,18 @@ extern \"C\" void LLVMRustSetHasUnsafeAlgebra(LLVMValueRef V) {\n \n extern \"C\" LLVMValueRef\n LLVMRustBuildAtomicLoad(LLVMBuilderRef B, LLVMValueRef Source, const char *Name,\n-                        LLVMAtomicOrdering Order, unsigned Alignment) {\n+                        LLVMAtomicOrdering Order) {\n   LoadInst *LI = new LoadInst(unwrap(Source), 0);\n   LI->setAtomic(fromRust(Order));\n-  LI->setAlignment(Alignment);\n   return wrap(unwrap(B)->Insert(LI, Name));\n }\n \n extern \"C\" LLVMValueRef LLVMRustBuildAtomicStore(LLVMBuilderRef B,\n                                                  LLVMValueRef V,\n                                                  LLVMValueRef Target,\n-                                                 LLVMAtomicOrdering Order,\n-                                                 unsigned Alignment) {\n+                                                 LLVMAtomicOrdering Order) {\n   StoreInst *SI = new StoreInst(unwrap(V), unwrap(Target));\n   SI->setAtomic(fromRust(Order));\n-  SI->setAlignment(Alignment);\n   return wrap(unwrap(B)->Insert(SI));\n }\n "}, {"sha": "2b35d4547395a0d08b5ddab9aeb717ef511c0720", "filename": "src/test/codegen/adjustments.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Ftest%2Fcodegen%2Fadjustments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Ftest%2Fcodegen%2Fadjustments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fadjustments.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n // compile-flags: -C no-prepopulate-passes\n+// ignore-tidy-linelength\n \n #![crate_type = \"lib\"]\n \n@@ -23,9 +24,9 @@ pub fn helper(_: usize) {\n pub fn no_op_slice_adjustment(x: &[u8]) -> &[u8] {\n     // We used to generate an extra alloca and memcpy for the block's trailing expression value, so\n     // check that we copy directly to the return value slot\n-// CHECK: %0 = insertvalue { i8*, [[USIZE]] } undef, i8* %x.ptr, 0\n-// CHECK: %1 = insertvalue { i8*, [[USIZE]] } %0, [[USIZE]] %x.meta, 1\n-// CHECK: ret { i8*, [[USIZE]] } %1\n+// CHECK: %0 = insertvalue { [0 x i8]*, [[USIZE]] } undef, [0 x i8]* %x.0, 0\n+// CHECK: %1 = insertvalue { [0 x i8]*, [[USIZE]] } %0, [[USIZE]] %x.1, 1\n+// CHECK: ret { [0 x i8]*, [[USIZE]] } %1\n     { x }\n }\n "}, {"sha": "a75b8f3992d0795ea76697d761dd7f596dfbf80e", "filename": "src/test/codegen/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Ftest%2Fcodegen%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Ftest%2Fcodegen%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fconsts.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -54,14 +54,14 @@ pub fn inline_enum_const() -> E<i8, i16> {\n #[no_mangle]\n pub fn low_align_const() -> E<i16, [i16; 3]> {\n // Check that low_align_const and high_align_const use the same constant\n-// CHECK: load {{.*}} bitcast ({ i16, i16, [4 x i8] }** [[LOW_HIGH_REF]]\n+// CHECK: load {{.*}} bitcast ({ i16, [0 x i8], i16, [4 x i8] }** [[LOW_HIGH_REF]]\n     *&E::A(0)\n }\n \n // CHECK-LABEL: @high_align_const\n #[no_mangle]\n pub fn high_align_const() -> E<i16, i32> {\n // Check that low_align_const and high_align_const use the same constant\n-// CHECK: load {{.*}} bitcast ({ i16, i16, [4 x i8] }** [[LOW_HIGH_REF]]\n+// CHECK: load {{.*}} bitcast ({ i16, [0 x i8], i16, [4 x i8] }** [[LOW_HIGH_REF]]\n     *&E::A(0)\n }"}, {"sha": "f8945a6ee8d93aeb0eba51b16923d601f02b0f59", "filename": "src/test/codegen/function-arguments.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -9,12 +9,13 @@\n // except according to those terms.\n \n // compile-flags: -C no-prepopulate-passes\n+// ignore-tidy-linelength\n \n #![crate_type = \"lib\"]\n #![feature(custom_attribute)]\n \n pub struct S {\n-  _field: [i64; 4],\n+  _field: [i32; 8],\n }\n \n pub struct UnsafeInner {\n@@ -45,13 +46,13 @@ pub fn static_borrow(_: &'static i32) {\n pub fn named_borrow<'r>(_: &'r i32) {\n }\n \n-// CHECK: @unsafe_borrow(%UnsafeInner* dereferenceable(2) %arg0)\n+// CHECK: @unsafe_borrow(i16* dereferenceable(2) %arg0)\n // unsafe interior means this isn't actually readonly and there may be aliases ...\n #[no_mangle]\n pub fn unsafe_borrow(_: &UnsafeInner) {\n }\n \n-// CHECK: @mutable_unsafe_borrow(%UnsafeInner* dereferenceable(2) %arg0)\n+// CHECK: @mutable_unsafe_borrow(i16* dereferenceable(2) %arg0)\n // ... unless this is a mutable borrow, those never alias\n // ... except that there's this LLVM bug that forces us to not use noalias, see #29485\n #[no_mangle]\n@@ -76,7 +77,7 @@ pub fn indirect_struct(_: S) {\n pub fn borrowed_struct(_: &S) {\n }\n \n-// CHECK: noalias dereferenceable(4) i32* @_box(i32* noalias dereferenceable(4) %x)\n+// CHECK: noalias align 4 dereferenceable(4) i32* @_box(i32* noalias dereferenceable(4) %x)\n #[no_mangle]\n pub fn _box(x: Box<i32>) -> Box<i32> {\n   x\n@@ -86,7 +87,7 @@ pub fn _box(x: Box<i32>) -> Box<i32> {\n #[no_mangle]\n pub fn struct_return() -> S {\n   S {\n-    _field: [0, 0, 0, 0]\n+    _field: [0, 0, 0, 0, 0, 0, 0, 0]\n   }\n }\n \n@@ -96,43 +97,43 @@ pub fn struct_return() -> S {\n pub fn helper(_: usize) {\n }\n \n-// CHECK: @slice(i8* noalias nonnull readonly %arg0.ptr, [[USIZE]] %arg0.meta)\n+// CHECK: @slice([0 x i8]* noalias nonnull readonly %arg0.0, [[USIZE]] %arg0.1)\n // FIXME #25759 This should also have `nocapture`\n #[no_mangle]\n pub fn slice(_: &[u8]) {\n }\n \n-// CHECK: @mutable_slice(i8* nonnull %arg0.ptr, [[USIZE]] %arg0.meta)\n+// CHECK: @mutable_slice([0 x i8]* nonnull %arg0.0, [[USIZE]] %arg0.1)\n // FIXME #25759 This should also have `nocapture`\n // ... there's this LLVM bug that forces us to not use noalias, see #29485\n #[no_mangle]\n pub fn mutable_slice(_: &mut [u8]) {\n }\n \n-// CHECK: @unsafe_slice(%UnsafeInner* nonnull %arg0.ptr, [[USIZE]] %arg0.meta)\n+// CHECK: @unsafe_slice([0 x i16]* nonnull %arg0.0, [[USIZE]] %arg0.1)\n // unsafe interior means this isn't actually readonly and there may be aliases ...\n #[no_mangle]\n pub fn unsafe_slice(_: &[UnsafeInner]) {\n }\n \n-// CHECK: @str(i8* noalias nonnull readonly %arg0.ptr, [[USIZE]] %arg0.meta)\n+// CHECK: @str([0 x i8]* noalias nonnull readonly %arg0.0, [[USIZE]] %arg0.1)\n // FIXME #25759 This should also have `nocapture`\n #[no_mangle]\n pub fn str(_: &[u8]) {\n }\n \n-// CHECK: @trait_borrow({}* nonnull, {}* noalias nonnull readonly)\n+// CHECK: @trait_borrow(%\"core::ops::drop::Drop\"* nonnull %arg0.0, {}* noalias nonnull readonly %arg0.1)\n // FIXME #25759 This should also have `nocapture`\n #[no_mangle]\n pub fn trait_borrow(_: &Drop) {\n }\n \n-// CHECK: @trait_box({}* noalias nonnull, {}* noalias nonnull readonly)\n+// CHECK: @trait_box(%\"core::ops::drop::Drop\"* noalias nonnull, {}* noalias nonnull readonly)\n #[no_mangle]\n pub fn trait_box(_: Box<Drop>) {\n }\n \n-// CHECK: { i16*, [[USIZE]] } @return_slice(i16* noalias nonnull readonly %x.ptr, [[USIZE]] %x.meta)\n+// CHECK: { [0 x i16]*, [[USIZE]] } @return_slice([0 x i16]* noalias nonnull readonly %x.0, [[USIZE]] %x.1)\n #[no_mangle]\n pub fn return_slice(x: &[u16]) -> &[u16] {\n   x"}, {"sha": "e5ec17385455e24d59089e7ea7a887e48d7ea329", "filename": "src/test/codegen/issue-32031.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Ftest%2Fcodegen%2Fissue-32031.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Ftest%2Fcodegen%2Fissue-32031.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fissue-32031.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -15,7 +15,7 @@\n #[no_mangle]\n pub struct F32(f32);\n \n-// CHECK: define float @add_newtype_f32(float, float)\n+// CHECK: define float @add_newtype_f32(float %a, float %b)\n #[inline(never)]\n #[no_mangle]\n pub fn add_newtype_f32(a: F32, b: F32) -> F32 {\n@@ -25,7 +25,7 @@ pub fn add_newtype_f32(a: F32, b: F32) -> F32 {\n #[no_mangle]\n pub struct F64(f64);\n \n-// CHECK: define double @add_newtype_f64(double, double)\n+// CHECK: define double @add_newtype_f64(double %a, double %b)\n #[inline(never)]\n #[no_mangle]\n pub fn add_newtype_f64(a: F64, b: F64) -> F64 {"}, {"sha": "1879002e7f3d7cb2750ca73b9aad7aedda4a8347", "filename": "src/test/codegen/link_section.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Ftest%2Fcodegen%2Flink_section.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Ftest%2Fcodegen%2Flink_section.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Flink_section.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -22,12 +22,12 @@ pub enum E {\n     B(f32)\n }\n \n-// CHECK: @VAR2 = constant {{.*}} { i32 0, i32 666 }, section \".test_two\"\n+// CHECK: @VAR2 = constant {{.*}}, section \".test_two\"\n #[no_mangle]\n #[link_section = \".test_two\"]\n pub static VAR2: E = E::A(666);\n \n-// CHECK: @VAR3 = constant {{.*}} { i32 1, float 1.000000e+00 }, section \".test_three\"\n+// CHECK: @VAR3 = constant {{.*}}, section \".test_three\"\n #[no_mangle]\n #[link_section = \".test_three\"]\n pub static VAR3: E = E::B(1.);"}, {"sha": "d7b779374314dc94576b914886e6983454be6f98", "filename": "src/test/codegen/match-optimizes-away.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Ftest%2Fcodegen%2Fmatch-optimizes-away.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Ftest%2Fcodegen%2Fmatch-optimizes-away.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fmatch-optimizes-away.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -12,21 +12,19 @@\n // compile-flags: -O\n #![crate_type=\"lib\"]\n \n-pub enum Three { First, Second, Third }\n-use Three::*;\n+pub enum Three { A, B, C }\n \n-pub enum Four { First, Second, Third, Fourth }\n-use Four::*;\n+pub enum Four { A, B, C, D }\n \n #[no_mangle]\n pub fn three_valued(x: Three) -> Three {\n     // CHECK-LABEL: @three_valued\n     // CHECK-NEXT: {{^.*:$}}\n     // CHECK-NEXT: ret i8 %0\n     match x {\n-        First => First,\n-        Second => Second,\n-        Third => Third,\n+        Three::A => Three::A,\n+        Three::B => Three::B,\n+        Three::C => Three::C,\n     }\n }\n \n@@ -36,9 +34,9 @@ pub fn four_valued(x: Four) -> Four {\n     // CHECK-NEXT: {{^.*:$}}\n     // CHECK-NEXT: ret i8 %0\n     match x {\n-        First => First,\n-        Second => Second,\n-        Third => Third,\n-        Fourth => Fourth,\n+        Four::A => Four::A,\n+        Four::B => Four::B,\n+        Four::C => Four::C,\n+        Four::D => Four::D,\n     }\n }"}, {"sha": "dd530cf03cd41f3d0a20dd613d096827ab9564eb", "filename": "src/test/codegen/packed.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Ftest%2Fcodegen%2Fpacked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Ftest%2Fcodegen%2Fpacked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fpacked.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -54,9 +54,6 @@ pub struct PackedPair(u8, u32);\n // CHECK-LABEL: @pkd_pair\n #[no_mangle]\n pub fn pkd_pair(pair1: &mut PackedPair, pair2: &mut PackedPair) {\n-    // CHECK: [[V1:%[a-z0-9]+]] = load i8, i8* %{{.*}}, align 1\n-    // CHECK: [[V2:%[a-z0-9]+]] = load i32, i32* %{{.*}}, align 1\n-    // CHECK: store i8 [[V1]], i8* {{.*}}, align 1\n-    // CHECK: store i32 [[V2]], i32* {{.*}}, align 1\n+// CHECK: call void @llvm.memcpy.{{.*}}(i8* %{{.*}}, i8* %{{.*}}, i{{[0-9]+}} 5, i32 1, i1 false)\n     *pair2 = *pair1;\n }"}, {"sha": "6c00ffa754b060f0c4357627f3e89a227c2d3794", "filename": "src/test/codegen/refs.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Ftest%2Fcodegen%2Frefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Ftest%2Fcodegen%2Frefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Frefs.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n // compile-flags: -C no-prepopulate-passes\n+// ignore-tidy-linelength\n \n #![crate_type = \"lib\"]\n \n@@ -23,10 +24,10 @@ pub fn helper(_: usize) {\n pub fn ref_dst(s: &[u8]) {\n     // We used to generate an extra alloca and memcpy to ref the dst, so check that we copy\n     // directly to the alloca for \"x\"\n-// CHECK: [[X0:%[0-9]+]] = getelementptr {{.*}} { i8*, [[USIZE]] }* %x, i32 0, i32 0\n-// CHECK: store i8* %s.ptr, i8** [[X0]]\n-// CHECK: [[X1:%[0-9]+]] = getelementptr {{.*}} { i8*, [[USIZE]] }* %x, i32 0, i32 1\n-// CHECK: store [[USIZE]] %s.meta, [[USIZE]]* [[X1]]\n+// CHECK: [[X0:%[0-9]+]] = getelementptr {{.*}} { [0 x i8]*, [[USIZE]] }* %x, i32 0, i32 0\n+// CHECK: store [0 x i8]* %s.0, [0 x i8]** [[X0]]\n+// CHECK: [[X1:%[0-9]+]] = getelementptr {{.*}} { [0 x i8]*, [[USIZE]] }* %x, i32 0, i32 1\n+// CHECK: store [[USIZE]] %s.1, [[USIZE]]* [[X1]]\n \n     let x = &*s;\n     &x; // keep variable in an alloca"}, {"sha": "915db493fc2a4f2068971228e38eecd05fa4a7c3", "filename": "src/test/codegen/slice-init.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Ftest%2Fcodegen%2Fslice-init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Ftest%2Fcodegen%2Fslice-init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fslice-init.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -15,7 +15,7 @@\n // CHECK-LABEL: @zero_sized_elem\n #[no_mangle]\n pub fn zero_sized_elem() {\n-    // CHECK-NOT: br label %slice_loop_header{{.*}}\n+    // CHECK-NOT: br label %repeat_loop_header{{.*}}\n     // CHECK-NOT: call void @llvm.memset.p0i8\n     let x = [(); 4];\n     drop(&x);\n@@ -24,7 +24,7 @@ pub fn zero_sized_elem() {\n // CHECK-LABEL: @zero_len_array\n #[no_mangle]\n pub fn zero_len_array() {\n-    // CHECK-NOT: br label %slice_loop_header{{.*}}\n+    // CHECK-NOT: br label %repeat_loop_header{{.*}}\n     // CHECK-NOT: call void @llvm.memset.p0i8\n     let x = [4; 0];\n     drop(&x);\n@@ -34,7 +34,7 @@ pub fn zero_len_array() {\n #[no_mangle]\n pub fn byte_array() {\n     // CHECK: call void @llvm.memset.p0i8.i[[WIDTH:[0-9]+]](i8* {{.*}}, i8 7, i[[WIDTH]] 4\n-    // CHECK-NOT: br label %slice_loop_header{{.*}}\n+    // CHECK-NOT: br label %repeat_loop_header{{.*}}\n     let x = [7u8; 4];\n     drop(&x);\n }\n@@ -50,7 +50,7 @@ enum Init {\n #[no_mangle]\n pub fn byte_enum_array() {\n     // CHECK: call void @llvm.memset.p0i8.i[[WIDTH:[0-9]+]](i8* {{.*}}, i8 {{.*}}, i[[WIDTH]] 4\n-    // CHECK-NOT: br label %slice_loop_header{{.*}}\n+    // CHECK-NOT: br label %repeat_loop_header{{.*}}\n     let x = [Init::Memset; 4];\n     drop(&x);\n }\n@@ -59,15 +59,15 @@ pub fn byte_enum_array() {\n #[no_mangle]\n pub fn zeroed_integer_array() {\n     // CHECK: call void @llvm.memset.p0i8.i[[WIDTH:[0-9]+]](i8* {{.*}}, i8 0, i[[WIDTH]] 16\n-    // CHECK-NOT: br label %slice_loop_header{{.*}}\n+    // CHECK-NOT: br label %repeat_loop_header{{.*}}\n     let x = [0u32; 4];\n     drop(&x);\n }\n \n // CHECK-LABEL: @nonzero_integer_array\n #[no_mangle]\n pub fn nonzero_integer_array() {\n-    // CHECK: br label %slice_loop_header{{.*}}\n+    // CHECK: br label %repeat_loop_header{{.*}}\n     // CHECK-NOT: call void @llvm.memset.p0i8\n     let x = [0x1a_2b_3c_4d_u32; 4];\n     drop(&x);"}, {"sha": "39c6e97268f980e3d9aebdcd8a33ba64256be49e", "filename": "src/test/compile-fail/issue-26548.rs", "status": "renamed", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Ftest%2Fcompile-fail%2Fissue-26548.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Ftest%2Fcompile-fail%2Fissue-26548.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-26548.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -8,7 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: overflow representing the type\n+// error-pattern: unsupported cyclic reference between types/traits detected\n+// note-pattern: the cycle begins when computing layout of\n+// note-pattern: ...which then requires computing layout of\n+// note-pattern: ...which then again requires computing layout of\n \n \n trait Mirror { type It: ?Sized; }", "previous_filename": "src/test/ui/issue-26548.rs"}, {"sha": "5736b1730216d4bd87775c16036a7b687cc35076", "filename": "src/test/run-make/issue-25581/test.c", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Ftest%2Frun-make%2Fissue-25581%2Ftest.c", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Ftest%2Frun-make%2Fissue-25581%2Ftest.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-25581%2Ftest.c?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -2,10 +2,15 @@\n #include <stddef.h>\n #include <stdint.h>\n \n-size_t slice_len(uint8_t *data, size_t len) {\n-    return len;\n+struct ByteSlice {\n+        uint8_t *data;\n+        size_t len;\n+};\n+\n+size_t slice_len(struct ByteSlice bs) {\n+        return bs.len;\n }\n \n-uint8_t slice_elem(uint8_t *data, size_t len, size_t idx) {\n-    return data[idx];\n+uint8_t slice_elem(struct ByteSlice bs, size_t idx) {\n+        return bs.data[idx];\n }"}, {"sha": "8557c065dc69c0694c18f20b0b9abe67820bdcf8", "filename": "src/test/run-pass/enum-discrim-manual-sizing.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Ftest%2Frun-pass%2Fenum-discrim-manual-sizing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Ftest%2Frun-pass%2Fenum-discrim-manual-sizing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenum-discrim-manual-sizing.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -108,6 +108,9 @@ pub fn main() {\n     let array_expected_size = round_up(28, align_of::<Eu64NonCLike<[u32; 5]>>());\n     assert_eq!(size_of::<Eu64NonCLike<[u32; 5]>>(), array_expected_size);\n     assert_eq!(size_of::<Eu64NonCLike<[u32; 6]>>(), 32);\n+\n+    assert_eq!(align_of::<Eu32>(), align_of::<u32>());\n+    assert_eq!(align_of::<Eu64NonCLike<u8>>(), align_of::<u64>());\n }\n \n // Rounds x up to the next multiple of a"}, {"sha": "17d614b54969cd9953bd529406783e6663afccba", "filename": "src/test/run-pass/enum-univariant-repr.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Ftest%2Frun-pass%2Fenum-univariant-repr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Ftest%2Frun-pass%2Fenum-univariant-repr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenum-univariant-repr.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -22,6 +22,11 @@ enum UnivariantWithoutDescr {\n     Y\n }\n \n+#[repr(u8)]\n+enum UnivariantWithData {\n+    Z(u8),\n+}\n+\n pub fn main() {\n     {\n         assert_eq!(4, mem::size_of::<Univariant>());\n@@ -44,4 +49,12 @@ pub fn main() {\n         // check it has the same memory layout as u16\n         assert_eq!(&[descr, descr, descr], ints);\n     }\n+\n+    {\n+        assert_eq!(2, mem::size_of::<UnivariantWithData>());\n+\n+        match UnivariantWithData::Z(4) {\n+            UnivariantWithData::Z(x) => assert_eq!(x, 4),\n+        }\n+    }\n }"}, {"sha": "1179f16daa238c699752302617b8b1905a518daf", "filename": "src/test/run-pass/packed-struct-optimized-enum.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Ftest%2Frun-pass%2Fpacked-struct-optimized-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Ftest%2Frun-pass%2Fpacked-struct-optimized-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-struct-optimized-enum.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[repr(packed)]\n+#[derive(Copy, Clone)]\n+struct Packed<T>(T);\n+\n+fn main() {\n+    let one = (Some(Packed((&(), 0))), true);\n+    let two = [one, one];\n+    let stride = (&two[1] as *const _ as usize) - (&two[0] as *const _ as usize);\n+\n+    // This can fail if rustc and LLVM disagree on the size of a type.\n+    // In this case, `Option<Packed<(&(), u32)>>` was erronously not\n+    // marked as packed despite needing alignment `1` and containing\n+    // its `&()` discriminant, which has alignment larger than `1`.\n+    assert_eq!(stride, std::mem::size_of_val(&one));\n+}"}, {"sha": "8bfe4ac733b6d91c97d783b55e6a20fa95af4f4f", "filename": "src/test/ui/issue-26548.stderr", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5041b3bb3d953a14f32b15d1e41341c629acae12/src%2Ftest%2Fui%2Fissue-26548.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5041b3bb3d953a14f32b15d1e41341c629acae12/src%2Ftest%2Fui%2Fissue-26548.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-26548.stderr?ref=5041b3bb3d953a14f32b15d1e41341c629acae12", "patch": "@@ -1,9 +0,0 @@\n-error[E0391]: unsupported cyclic reference between types/traits detected\n-  |\n-note: the cycle begins when computing layout of `S`...\n-note: ...which then requires computing layout of `std::option::Option<<S as Mirror>::It>`...\n-note: ...which then requires computing layout of `<S as Mirror>::It`...\n-  = note: ...which then again requires computing layout of `S`, completing the cycle.\n-\n-error: aborting due to previous error\n-"}, {"sha": "f1c419d889556968346229911c65297faa26c34e", "filename": "src/test/ui/print_type_sizes/niche-filling.rs", "status": "renamed", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Ftest%2Fui%2Fprint_type_sizes%2Fniche-filling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Ftest%2Fui%2Fprint_type_sizes%2Fniche-filling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Fniche-filling.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -10,8 +10,8 @@\n \n // compile-flags: -Z print-type-sizes\n \n-// This file illustrates how enums with a non-null field are handled,\n-// modelled after cases like `Option<&u32>` and such.\n+// This file illustrates how niche-filling enums are handled,\n+// modelled after cases like `Option<&u32>`, `Option<bool>` and such.\n //\n // It uses NonZero directly, rather than `&_` or `Unique<_>`, because\n // the test is not set up to deal with target-dependent pointer width.\n@@ -68,8 +68,22 @@ impl One for u32 {\n     fn one() -> Self { 1 }\n }\n \n+pub enum Enum4<A, B, C, D> {\n+    One(A),\n+    Two(B),\n+    Three(C),\n+    Four(D)\n+}\n+\n pub fn main() {\n     let _x: MyOption<NonZero<u32>> = Default::default();\n     let _y: EmbeddedDiscr = Default::default();\n     let _z: MyOption<IndirectNonZero<u32>> = Default::default();\n+    let _a: MyOption<bool> = Default::default();\n+    let _b: MyOption<char> = Default::default();\n+    let _c: MyOption<std::cmp::Ordering> = Default::default();\n+    let _b: MyOption<MyOption<u8>> = Default::default();\n+    let _e: Enum4<(), char, (), ()> = Enum4::One(());\n+    let _f: Enum4<(), (), bool, ()> = Enum4::One(());\n+    let _g: Enum4<(), (), (), MyOption<u8>> = Enum4::One(());\n }", "previous_filename": "src/test/ui/print_type_sizes/nullable.rs"}, {"sha": "af3e89a936ee05cc85b4a41823fa8b0668e286cf", "filename": "src/test/ui/print_type_sizes/niche-filling.stdout", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Ftest%2Fui%2Fprint_type_sizes%2Fniche-filling.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Ftest%2Fui%2Fprint_type_sizes%2Fniche-filling.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Fniche-filling.stdout?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -0,0 +1,80 @@\n+print-type-size type: `IndirectNonZero<u32>`: 12 bytes, alignment: 4 bytes\n+print-type-size     field `.nested`: 8 bytes\n+print-type-size     field `.post`: 2 bytes\n+print-type-size     field `.pre`: 1 bytes\n+print-type-size     end padding: 1 bytes\n+print-type-size type: `MyOption<IndirectNonZero<u32>>`: 12 bytes, alignment: 4 bytes\n+print-type-size     variant `None`: 0 bytes\n+print-type-size     variant `Some`: 12 bytes\n+print-type-size         field `.0`: 12 bytes\n+print-type-size type: `EmbeddedDiscr`: 8 bytes, alignment: 4 bytes\n+print-type-size     variant `None`: 0 bytes\n+print-type-size     variant `Record`: 7 bytes\n+print-type-size         field `.val`: 4 bytes\n+print-type-size         field `.post`: 2 bytes\n+print-type-size         field `.pre`: 1 bytes\n+print-type-size     end padding: 1 bytes\n+print-type-size type: `NestedNonZero<u32>`: 8 bytes, alignment: 4 bytes\n+print-type-size     field `.val`: 4 bytes\n+print-type-size     field `.post`: 2 bytes\n+print-type-size     field `.pre`: 1 bytes\n+print-type-size     end padding: 1 bytes\n+print-type-size type: `Enum4<(), char, (), ()>`: 4 bytes, alignment: 4 bytes\n+print-type-size     variant `One`: 0 bytes\n+print-type-size         field `.0`: 0 bytes\n+print-type-size     variant `Two`: 4 bytes\n+print-type-size         field `.0`: 4 bytes\n+print-type-size     variant `Three`: 0 bytes\n+print-type-size         field `.0`: 0 bytes\n+print-type-size     variant `Four`: 0 bytes\n+print-type-size         field `.0`: 0 bytes\n+print-type-size type: `MyOption<char>`: 4 bytes, alignment: 4 bytes\n+print-type-size     variant `None`: 0 bytes\n+print-type-size     variant `Some`: 4 bytes\n+print-type-size         field `.0`: 4 bytes\n+print-type-size type: `MyOption<core::nonzero::NonZero<u32>>`: 4 bytes, alignment: 4 bytes\n+print-type-size     variant `None`: 0 bytes\n+print-type-size     variant `Some`: 4 bytes\n+print-type-size         field `.0`: 4 bytes\n+print-type-size type: `core::nonzero::NonZero<u32>`: 4 bytes, alignment: 4 bytes\n+print-type-size     field `.0`: 4 bytes\n+print-type-size type: `Enum4<(), (), (), MyOption<u8>>`: 2 bytes, alignment: 1 bytes\n+print-type-size     variant `One`: 0 bytes\n+print-type-size         field `.0`: 0 bytes\n+print-type-size     variant `Two`: 0 bytes\n+print-type-size         field `.0`: 0 bytes\n+print-type-size     variant `Three`: 0 bytes\n+print-type-size         field `.0`: 0 bytes\n+print-type-size     variant `Four`: 2 bytes\n+print-type-size         field `.0`: 2 bytes\n+print-type-size type: `MyOption<MyOption<u8>>`: 2 bytes, alignment: 1 bytes\n+print-type-size     variant `None`: 0 bytes\n+print-type-size     variant `Some`: 2 bytes\n+print-type-size         field `.0`: 2 bytes\n+print-type-size type: `MyOption<u8>`: 2 bytes, alignment: 1 bytes\n+print-type-size     discriminant: 1 bytes\n+print-type-size     variant `None`: 0 bytes\n+print-type-size     variant `Some`: 1 bytes\n+print-type-size         field `.0`: 1 bytes\n+print-type-size type: `Enum4<(), (), bool, ()>`: 1 bytes, alignment: 1 bytes\n+print-type-size     variant `One`: 0 bytes\n+print-type-size         field `.0`: 0 bytes\n+print-type-size     variant `Two`: 0 bytes\n+print-type-size         field `.0`: 0 bytes\n+print-type-size     variant `Three`: 1 bytes\n+print-type-size         field `.0`: 1 bytes\n+print-type-size     variant `Four`: 0 bytes\n+print-type-size         field `.0`: 0 bytes\n+print-type-size type: `MyOption<bool>`: 1 bytes, alignment: 1 bytes\n+print-type-size     variant `None`: 0 bytes\n+print-type-size     variant `Some`: 1 bytes\n+print-type-size         field `.0`: 1 bytes\n+print-type-size type: `MyOption<core::cmp::Ordering>`: 1 bytes, alignment: 1 bytes\n+print-type-size     variant `None`: 0 bytes\n+print-type-size     variant `Some`: 1 bytes\n+print-type-size         field `.0`: 1 bytes\n+print-type-size type: `core::cmp::Ordering`: 1 bytes, alignment: 1 bytes\n+print-type-size     discriminant: 1 bytes\n+print-type-size     variant `Less`: 0 bytes\n+print-type-size     variant `Equal`: 0 bytes\n+print-type-size     variant `Greater`: 0 bytes"}, {"sha": "830678f174f88cf38e0d76836bac2cc7c9a9ee96", "filename": "src/test/ui/print_type_sizes/nullable.stdout", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5041b3bb3d953a14f32b15d1e41341c629acae12/src%2Ftest%2Fui%2Fprint_type_sizes%2Fnullable.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/5041b3bb3d953a14f32b15d1e41341c629acae12/src%2Ftest%2Fui%2Fprint_type_sizes%2Fnullable.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Fnullable.stdout?ref=5041b3bb3d953a14f32b15d1e41341c629acae12", "patch": "@@ -1,24 +0,0 @@\n-print-type-size type: `IndirectNonZero<u32>`: 12 bytes, alignment: 4 bytes\n-print-type-size     field `.nested`: 8 bytes\n-print-type-size     field `.post`: 2 bytes\n-print-type-size     field `.pre`: 1 bytes\n-print-type-size     end padding: 1 bytes\n-print-type-size type: `MyOption<IndirectNonZero<u32>>`: 12 bytes, alignment: 4 bytes\n-print-type-size     variant `Some`: 12 bytes\n-print-type-size         field `.0`: 12 bytes\n-print-type-size type: `EmbeddedDiscr`: 8 bytes, alignment: 4 bytes\n-print-type-size     variant `Record`: 7 bytes\n-print-type-size         field `.val`: 4 bytes\n-print-type-size         field `.post`: 2 bytes\n-print-type-size         field `.pre`: 1 bytes\n-print-type-size     end padding: 1 bytes\n-print-type-size type: `NestedNonZero<u32>`: 8 bytes, alignment: 4 bytes\n-print-type-size     field `.val`: 4 bytes\n-print-type-size     field `.post`: 2 bytes\n-print-type-size     field `.pre`: 1 bytes\n-print-type-size     end padding: 1 bytes\n-print-type-size type: `MyOption<core::nonzero::NonZero<u32>>`: 4 bytes, alignment: 4 bytes\n-print-type-size     variant `Some`: 4 bytes\n-print-type-size         field `.0`: 4 bytes\n-print-type-size type: `core::nonzero::NonZero<u32>`: 4 bytes, alignment: 4 bytes\n-print-type-size     field `.0`: 4 bytes"}, {"sha": "69cc4c933601e0eb685346f9d29932e6e0179c01", "filename": "src/test/ui/print_type_sizes/uninhabited.rs", "status": "renamed", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Ftest%2Fui%2Fprint_type_sizes%2Funinhabited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Ftest%2Fui%2Fprint_type_sizes%2Funinhabited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Funinhabited.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,7 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct Test([i32]);\n-fn main() {\n-    let _x: fn(_) -> Test = Test;\n+// compile-flags: -Z print-type-sizes\n+\n+#![feature(never_type)]\n+\n+pub fn main() {\n+    let _x: Option<!> = None;\n+    let _y: Result<u32, !> = Ok(42);\n }", "previous_filename": "src/test/run-pass/issue-30276.rs"}, {"sha": "2a8706f7ac5514591adba5f5d323cb0b356b1116", "filename": "src/test/ui/print_type_sizes/uninhabited.stdout", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Ftest%2Fui%2Fprint_type_sizes%2Funinhabited.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Ftest%2Fui%2Fprint_type_sizes%2Funinhabited.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Funinhabited.stdout?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -0,0 +1,5 @@\n+print-type-size type: `std::result::Result<u32, !>`: 4 bytes, alignment: 4 bytes\n+print-type-size     variant `Ok`: 4 bytes\n+print-type-size         field `.0`: 4 bytes\n+print-type-size type: `std::option::Option<!>`: 0 bytes, alignment: 1 bytes\n+print-type-size     variant `None`: 0 bytes"}, {"sha": "b1122f401feb9b8c30fac7df90c8d1feeea2c5ff", "filename": "src/tools/cargotest/main.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Ftools%2Fcargotest%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Ftools%2Fcargotest%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcargotest%2Fmain.rs?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -60,8 +60,8 @@ const TEST_REPOS: &'static [Test] = &[\n     },\n     Test {\n         name: \"servo\",\n-        repo: \"https://github.com/servo/servo\",\n-        sha: \"38fe9533b93e985657f99a29772bf3d3c8694822\",\n+        repo: \"https://github.com/eddyb/servo\",\n+        sha: \"6031de9a397e2feba4ff98725991825f62b68518\",\n         lock: None,\n         // Only test Stylo a.k.a. Quantum CSS, the parts of Servo going into Firefox.\n         // This takes much less time to build than all of Servo and supports stable Rust."}, {"sha": "f1684f4c5acbe42f5f8eb94ba87a3408b9bd5bc9", "filename": "src/tools/toolstate.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Ftools%2Ftoolstate.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14/src%2Ftools%2Ftoolstate.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftoolstate.toml?ref=f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "patch": "@@ -26,7 +26,7 @@\n miri = \"Broken\"\n \n # ping @Manishearth @llogiq @mcarton @oli-obk\n-clippy = \"Testing\"\n+clippy = \"Broken\"\n \n # ping @nrc\n rls = \"Testing\""}]}