{"sha": "a25c841e884517eb48b67c36326d31192aff82d9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyNWM4NDFlODg0NTE3ZWI0OGI2N2MzNjMyNmQzMTE5MmFmZjgyZDk=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-09-03T22:14:58Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-09-10T01:00:48Z"}, "message": "resolve: Split macro prelude into built-in and user-defined parts", "tree": {"sha": "b6c137c5b19376d9c4c3fbca4551357adce31e46", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b6c137c5b19376d9c4c3fbca4551357adce31e46"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a25c841e884517eb48b67c36326d31192aff82d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a25c841e884517eb48b67c36326d31192aff82d9", "html_url": "https://github.com/rust-lang/rust/commit/a25c841e884517eb48b67c36326d31192aff82d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a25c841e884517eb48b67c36326d31192aff82d9/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5", "html_url": "https://github.com/rust-lang/rust/commit/2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5"}], "stats": {"total": 81, "additions": 48, "deletions": 33}, "files": [{"sha": "21c0f13baa4a99bd8cd56fbf5f117c5db7844b5e", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a25c841e884517eb48b67c36326d31192aff82d9/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a25c841e884517eb48b67c36326d31192aff82d9/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=a25c841e884517eb48b67c36326d31192aff82d9", "patch": "@@ -833,7 +833,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                            binding: &'a NameBinding<'a>,\n                            span: Span,\n                            allow_shadowing: bool) {\n-        if self.macro_prelude.insert(name, binding).is_some() && !allow_shadowing {\n+        if self.macro_use_prelude.insert(name, binding).is_some() && !allow_shadowing {\n             let msg = format!(\"`{}` is already in scope\", name);\n             let note =\n                 \"macro-expanded `#[macro_use]`s may not shadow existing macros (see RFC 1560)\";"}, {"sha": "98fbcd1fb183bff8ad5da0612bdab341bfc0390d", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a25c841e884517eb48b67c36326d31192aff82d9/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a25c841e884517eb48b67c36326d31192aff82d9/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=a25c841e884517eb48b67c36326d31192aff82d9", "patch": "@@ -1278,6 +1278,13 @@ impl<'a> NameBinding<'a> {\n         }\n     }\n \n+    fn macro_kind(&self) -> Option<MacroKind> {\n+        match self.def_ignoring_ambiguity() {\n+            Def::Macro(_, kind) => Some(kind),\n+            _ => None,\n+        }\n+    }\n+\n     fn descr(&self) -> &'static str {\n         if self.is_extern_crate() { \"extern crate\" } else { self.def().kind_name() }\n     }\n@@ -1440,7 +1447,8 @@ pub struct Resolver<'a, 'b: 'a> {\n \n     crate_loader: &'a mut CrateLoader<'b>,\n     macro_names: FxHashSet<Ident>,\n-    macro_prelude: FxHashMap<Name, &'a NameBinding<'a>>,\n+    builtin_macros: FxHashMap<Name, &'a NameBinding<'a>>,\n+    macro_use_prelude: FxHashMap<Name, &'a NameBinding<'a>>,\n     unshadowable_attrs: FxHashMap<Name, &'a NameBinding<'a>>,\n     pub all_macros: FxHashMap<Name, Def>,\n     macro_map: FxHashMap<DefId, Lrc<SyntaxExtension>>,\n@@ -1757,7 +1765,8 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n \n             crate_loader,\n             macro_names: FxHashSet(),\n-            macro_prelude: FxHashMap(),\n+            builtin_macros: FxHashMap(),\n+            macro_use_prelude: FxHashMap(),\n             unshadowable_attrs: FxHashMap(),\n             all_macros: FxHashMap(),\n             macro_map: FxHashMap(),\n@@ -3340,10 +3349,12 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                 };\n             }\n         }\n-        let is_global = self.macro_prelude.get(&path[0].name).cloned()\n-            .map(|binding| binding.get_macro(self).kind() == MacroKind::Bang).unwrap_or(false);\n-        if primary_ns != MacroNS && (is_global ||\n-                                     self.macro_names.contains(&path[0].modern())) {\n+        if primary_ns != MacroNS &&\n+           (self.macro_names.contains(&path[0].modern()) ||\n+            self.builtin_macros.get(&path[0].name).cloned()\n+                               .and_then(NameBinding::macro_kind) == Some(MacroKind::Bang) ||\n+            self.macro_use_prelude.get(&path[0].name).cloned()\n+                                  .and_then(NameBinding::macro_kind) == Some(MacroKind::Bang)) {\n             // Return some dummy definition, it's enough for error reporting.\n             return Some(\n                 PathResolution::new(Def::Macro(DefId::local(CRATE_DEF_INDEX), MacroKind::Bang))"}, {"sha": "b4c772cb8c63fd97ac3fb720cbf73de4a585a206", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 30, "deletions": 26, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/a25c841e884517eb48b67c36326d31192aff82d9/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a25c841e884517eb48b67c36326d31192aff82d9/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=a25c841e884517eb48b67c36326d31192aff82d9", "patch": "@@ -214,7 +214,10 @@ impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n             vis: ty::Visibility::Invisible,\n             expansion: Mark::root(),\n         });\n-        self.macro_prelude.insert(ident.name, binding);\n+        if self.builtin_macros.insert(ident.name, binding).is_some() {\n+            self.session.span_err(ident.span,\n+                                  &format!(\"built-in macro `{}` was already defined\", ident));\n+        }\n     }\n \n     fn add_unshadowable_attr(&mut self, ident: ast::Ident, ext: Lrc<SyntaxExtension>) {\n@@ -249,7 +252,7 @@ impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n                 attr::mark_known(&attrs[i]);\n             }\n \n-            match self.macro_prelude.get(&name).cloned() {\n+            match self.builtin_macros.get(&name).cloned() {\n                 Some(binding) => match *binding.get_macro(self) {\n                     MultiModifier(..) | MultiDecorator(..) | SyntaxExtension::AttrProcMacro(..) => {\n                         return Some(attrs.remove(i))\n@@ -285,7 +288,7 @@ impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n                     }\n                     let trait_name = traits[j].segments[0].ident.name;\n                     let legacy_name = Symbol::intern(&format!(\"derive_{}\", trait_name));\n-                    if !self.macro_prelude.contains_key(&legacy_name) {\n+                    if !self.builtin_macros.contains_key(&legacy_name) {\n                         continue\n                     }\n                     let span = traits.remove(j).span;\n@@ -585,14 +588,12 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         // (Macro NS)\n         // 1. Names in modules (both normal `mod`ules and blocks), loop through hygienic parents\n         //    (open, not controlled).\n-        // 2. Macro prelude (language, standard library, user-defined legacy plugins lumped into\n-        //    one set) (open, the open part is from macro expansions, not controlled).\n+        // 2. `macro_use` prelude (open, the open part is from macro expansions, not controlled).\n         // 2a. User-defined prelude from macro-use\n         //    (open, the open part is from macro expansions, not controlled).\n-        // 2b. Standard library prelude, currently just a macro-use (closed, controlled)\n-        // 2c. Language prelude, perhaps including builtin attributes\n-        //    (closed, controlled, except for legacy plugins).\n-        // 3. Builtin attributes (closed, controlled).\n+        // 2b. Standard library prelude is currently implemented as `macro-use` (closed, controlled)\n+        // 3. Language prelude: builtin macros (closed, controlled, except for legacy plugins).\n+        // 4. Language prelude: builtin attributes (closed, controlled).\n \n         assert!(ns == TypeNS  || ns == MacroNS);\n         assert!(force || !record_used); // `record_used` implies `force`\n@@ -613,12 +614,13 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n \n         enum WhereToResolve<'a> {\n             Module(Module<'a>),\n-            MacroPrelude,\n+            MacroUsePrelude,\n+            BuiltinMacros,\n             BuiltinAttrs,\n             ExternPrelude,\n             ToolPrelude,\n             StdLibPrelude,\n-            PrimitiveTypes,\n+            BuiltinTypes,\n         }\n \n         // Go through all the scopes and try to resolve the name.\n@@ -639,8 +641,14 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     self.current_module = orig_current_module;\n                     binding.map(|binding| (binding, FromPrelude(false)))\n                 }\n-                WhereToResolve::MacroPrelude => {\n-                    match self.macro_prelude.get(&ident.name).cloned() {\n+                WhereToResolve::MacroUsePrelude => {\n+                    match self.macro_use_prelude.get(&ident.name).cloned() {\n+                        Some(binding) => Ok((binding, FromPrelude(true))),\n+                        None => Err(Determinacy::Determined),\n+                    }\n+                }\n+                WhereToResolve::BuiltinMacros => {\n+                    match self.builtin_macros.get(&ident.name).cloned() {\n                         Some(binding) => Ok((binding, FromPrelude(true))),\n                         None => Err(Determinacy::Determined),\n                     }\n@@ -708,7 +716,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     }\n                     result\n                 }\n-                WhereToResolve::PrimitiveTypes => {\n+                WhereToResolve::BuiltinTypes => {\n                     if let Some(prim_ty) =\n                             self.primitive_type_table.primitive_types.get(&ident.name).cloned() {\n                         let binding = (Def::PrimTy(prim_ty), ty::Visibility::Public,\n@@ -728,19 +736,20 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                             None => {\n                                 use_prelude = !module.no_implicit_prelude;\n                                 if ns == MacroNS {\n-                                    WhereToResolve::MacroPrelude\n+                                    WhereToResolve::MacroUsePrelude\n                                 } else {\n                                     WhereToResolve::ExternPrelude\n                                 }\n                             }\n                         }\n                     }\n-                    WhereToResolve::MacroPrelude => WhereToResolve::BuiltinAttrs,\n+                    WhereToResolve::MacroUsePrelude => WhereToResolve::BuiltinMacros,\n+                    WhereToResolve::BuiltinMacros => WhereToResolve::BuiltinAttrs,\n                     WhereToResolve::BuiltinAttrs => break, // nowhere else to search\n                     WhereToResolve::ExternPrelude => WhereToResolve::ToolPrelude,\n                     WhereToResolve::ToolPrelude => WhereToResolve::StdLibPrelude,\n-                    WhereToResolve::StdLibPrelude => WhereToResolve::PrimitiveTypes,\n-                    WhereToResolve::PrimitiveTypes => break, // nowhere else to search\n+                    WhereToResolve::StdLibPrelude => WhereToResolve::BuiltinTypes,\n+                    WhereToResolve::BuiltinTypes => break, // nowhere else to search\n                 };\n \n                 continue;\n@@ -958,14 +967,9 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             None\n         // Then check global macros.\n         }.or_else(|| {\n-            // FIXME: get_macro needs an &mut Resolver, can we do it without cloning?\n-            let macro_prelude = self.macro_prelude.clone();\n-            let names = macro_prelude.iter().filter_map(|(name, binding)| {\n-                if binding.get_macro(self).kind() == kind {\n-                    Some(name)\n-                } else {\n-                    None\n-                }\n+            let names = self.builtin_macros.iter().chain(self.macro_use_prelude.iter())\n+                                                  .filter_map(|(name, binding)| {\n+                if binding.macro_kind() == Some(kind) { Some(name) } else { None }\n             });\n             find_best_match_for_name(names, name, None)\n         // Then check modules."}]}