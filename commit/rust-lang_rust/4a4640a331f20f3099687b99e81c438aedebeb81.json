{"sha": "4a4640a331f20f3099687b99e81c438aedebeb81", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhNDY0MGEzMzFmMjBmMzA5OTY4N2I5OWU4MWM0MzhhZWRlYmViODE=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-07-25T09:32:48Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-08-01T07:56:21Z"}, "message": "Move more non-CTFE operations to the Machine", "tree": {"sha": "e4d2eb003f925c24f11767d59aff7efa93cba675", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e4d2eb003f925c24f11767d59aff7efa93cba675"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4a4640a331f20f3099687b99e81c438aedebeb81", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYFTdM4NKd7XQft77pp+NIls619kFAlmANCUACgkQpp+NIls6\n19kgTQ/7Bj8nhP9BosatL7gT4mgOx7+hFkPCrr///kGJCMrD4fmxjKm0aTGN7Xy4\nOASVv/Txo9Sr9IRokPEgirkJ0fz0a7ihx9nD1pSoroO4Mg9X2bNgQ+URn2H7YF2G\nCvzQKc6WunvD7FrF/iV+nvcQbMS4DZdYfwgUrrf/343tOwcRMRrs5z7t5SIF6aKp\n02oFLqKYwlo/9MmFMsoeZ6V3UZEwi2g0zeMvsp8kpuZoNBwTkJNHlQofN8ztJ3xt\nbIr8CEDnz4NtjwavYXa36A+aiPzYv9zFThx0dvHDB1kvgZetHG7LIxzGqENyEt/d\nSZ974brj9Jm4bhfe33983KHrjXQEgXtP6juoM2/CesskNuWNsUmS8m3gya07ygks\nP9y9vgNgCv/lZ9newFDp2P9hQL6dLa/R3GmWvdxeuJ9waqcC1MOumpBjt+j6Txbe\npLuEx9olnDoSj0/iU8BoWG+SDUUfpKPIHt8w5Jt+GEiwDvvOahTNIxm1eKU6cOjx\npUEAW4xm3HQ8WVuO9wTZmXMLRMKfRsRxZZ4LC7sEZQLFiQTjdgC9jPV77jQPkgBB\nwGfqVqaZinZhUbjBmOrq9OQxIh7P7hUniof3MlbD4ViYNAQG10ya2ZEH2yvAfkQ3\nzOipxAUZ2kZ2RidCiDew8cYtjETj6dxbARifLyu3R9urMPauV9Y=\n=Pmik\n-----END PGP SIGNATURE-----", "payload": "tree e4d2eb003f925c24f11767d59aff7efa93cba675\nparent dc6e877ead0004bd90f5891a1556ecdc7a2b1aa9\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1500975168 +0200\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1501574181 +0200\n\nMove more non-CTFE operations to the Machine\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4a4640a331f20f3099687b99e81c438aedebeb81", "html_url": "https://github.com/rust-lang/rust/commit/4a4640a331f20f3099687b99e81c438aedebeb81", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4a4640a331f20f3099687b99e81c438aedebeb81/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc6e877ead0004bd90f5891a1556ecdc7a2b1aa9", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc6e877ead0004bd90f5891a1556ecdc7a2b1aa9", "html_url": "https://github.com/rust-lang/rust/commit/dc6e877ead0004bd90f5891a1556ecdc7a2b1aa9"}], "stats": {"total": 435, "additions": 282, "deletions": 153}, "files": [{"sha": "4482e8fcb7cc883b80feb063be7a278401e77619", "filename": "miri/lib.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4a4640a331f20f3099687b99e81c438aedebeb81/miri%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4640a331f20f3099687b99e81c438aedebeb81/miri%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Flib.rs?ref=4a4640a331f20f3099687b99e81c438aedebeb81", "patch": "@@ -7,6 +7,7 @@\n #[macro_use]\n extern crate log;\n extern crate log_settings;\n+#[macro_use]\n extern crate rustc;\n extern crate rustc_const_math;\n extern crate rustc_data_structures;\n@@ -25,8 +26,10 @@ extern crate rustc_miri;\n pub use rustc_miri::interpret::*;\n \n mod missing_fns;\n+mod operator;\n \n use missing_fns::EvalContextExt as MissingFnsEvalContextExt;\n+use operator::EvalContextExt as OperatorEvalContextExt;\n \n pub fn eval_main<'a, 'tcx: 'a>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -280,4 +283,18 @@ impl<'tcx> Machine<'tcx> for Evaluator {\n     ) -> EvalResult<'tcx> {\n         ecx.call_missing_fn(instance, destination, arg_operands, sig, path)\n     }\n+    fn ptr_op<'a>(\n+        ecx: &rustc_miri::interpret::EvalContext<'a, 'tcx, Self>,\n+        bin_op: mir::BinOp,\n+        left: PrimVal,\n+        left_ty: ty::Ty<'tcx>,\n+        right: PrimVal,\n+        right_ty: ty::Ty<'tcx>,\n+    ) -> EvalResult<'tcx, Option<(PrimVal, bool)>> {\n+        ecx.ptr_op(bin_op, left, left_ty, right, right_ty)\n+    }\n+\n+    fn check_non_const_fn_call(_instance: ty::Instance<'tcx>) -> EvalResult<'tcx> {\n+        Ok(())\n+    }\n }"}, {"sha": "fcc3986015d9115ac5bb77e6170095eea1442888", "filename": "miri/operator.rs", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/4a4640a331f20f3099687b99e81c438aedebeb81/miri%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4640a331f20f3099687b99e81c438aedebeb81/miri%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Foperator.rs?ref=4a4640a331f20f3099687b99e81c438aedebeb81", "patch": "@@ -0,0 +1,152 @@\n+use rustc::ty;\n+use rustc::mir;\n+\n+use rustc_miri::interpret::*;\n+\n+pub trait EvalContextExt<'tcx> {\n+    fn ptr_op(\n+        &self,\n+        bin_op: mir::BinOp,\n+        left: PrimVal,\n+        left_ty: ty::Ty<'tcx>,\n+        right: PrimVal,\n+        right_ty: ty::Ty<'tcx>,\n+    ) -> EvalResult<'tcx, Option<(PrimVal, bool)>>;\n+\n+    fn ptr_int_arithmetic(\n+        &self,\n+        bin_op: mir::BinOp,\n+        left: MemoryPointer,\n+        right: i128,\n+        signed: bool,\n+    ) -> EvalResult<'tcx, (PrimVal, bool)>;\n+}\n+\n+impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator> {\n+    fn ptr_op(\n+        &self,\n+        bin_op: mir::BinOp,\n+        left: PrimVal,\n+        left_ty: ty::Ty<'tcx>,\n+        right: PrimVal,\n+        right_ty: ty::Ty<'tcx>,\n+    ) -> EvalResult<'tcx, Option<(PrimVal, bool)>> {\n+        use rustc_miri::interpret::PrimValKind::*;\n+        use rustc::mir::BinOp::*;\n+        let usize = PrimValKind::from_uint_size(self.memory.pointer_size());\n+        let isize = PrimValKind::from_int_size(self.memory.pointer_size());\n+        let left_kind  = self.ty_to_primval_kind(left_ty)?;\n+        let right_kind = self.ty_to_primval_kind(right_ty)?;\n+        match bin_op {\n+            Offset if left_kind == Ptr && right_kind == usize => {\n+                let pointee_ty = left_ty.builtin_deref(true, ty::LvaluePreference::NoPreference).expect(\"Offset called on non-ptr type\").ty;\n+                let ptr = self.pointer_offset(left.into(), pointee_ty, right.to_bytes()? as i64)?;\n+                Ok(Some((ptr.into_inner_primval(), false)))\n+            },\n+            // These work on anything\n+            Eq if left_kind == right_kind => {\n+                let result = match (left, right) {\n+                    (PrimVal::Bytes(left), PrimVal::Bytes(right)) => left == right,\n+                    (PrimVal::Ptr(left), PrimVal::Ptr(right)) => left == right,\n+                    (PrimVal::Undef, _) | (_, PrimVal::Undef) => return Err(EvalError::ReadUndefBytes),\n+                    _ => false,\n+                };\n+                Ok(Some((PrimVal::from_bool(result), false)))\n+            }\n+            Ne if left_kind == right_kind => {\n+                let result = match (left, right) {\n+                    (PrimVal::Bytes(left), PrimVal::Bytes(right)) => left != right,\n+                    (PrimVal::Ptr(left), PrimVal::Ptr(right)) => left != right,\n+                    (PrimVal::Undef, _) | (_, PrimVal::Undef) => return Err(EvalError::ReadUndefBytes),\n+                    _ => true,\n+                };\n+                Ok(Some((PrimVal::from_bool(result), false)))\n+            }\n+            // These need both pointers to be in the same allocation\n+            Lt | Le | Gt | Ge | Sub\n+            if left_kind == right_kind\n+            && (left_kind == Ptr || left_kind == usize || left_kind == isize)\n+            && left.is_ptr() && right.is_ptr() => {\n+                let left = left.to_ptr()?;\n+                let right = right.to_ptr()?;\n+                if left.alloc_id == right.alloc_id {\n+                    let res = match bin_op {\n+                        Lt => left.offset < right.offset,\n+                        Le => left.offset <= right.offset,\n+                        Gt => left.offset > right.offset,\n+                        Ge => left.offset >= right.offset,\n+                        Sub => return self.binary_op(\n+                            Sub,\n+                            PrimVal::Bytes(left.offset as u128),\n+                            self.tcx.types.usize,\n+                            PrimVal::Bytes(right.offset as u128),\n+                            self.tcx.types.usize,\n+                        ).map(Some),\n+                        _ => bug!(\"We already established it has to be one of these operators.\"),\n+                    };\n+                    Ok(Some((PrimVal::from_bool(res), false)))\n+                } else {\n+                    // Both are pointers, but from different allocations.\n+                    Err(EvalError::InvalidPointerMath)\n+                }\n+            }\n+            // These work if one operand is a pointer, the other an integer\n+            Add | BitAnd | Sub\n+            if left_kind == right_kind && (left_kind == usize || left_kind == isize)\n+            && left.is_ptr() && right.is_bytes() => {\n+                // Cast to i128 is fine as we checked the kind to be ptr-sized\n+                self.ptr_int_arithmetic(bin_op, left.to_ptr()?, right.to_bytes()? as i128, left_kind == isize).map(Some)\n+            }\n+            Add | BitAnd\n+            if left_kind == right_kind && (left_kind == usize || left_kind == isize)\n+            && left.is_bytes() && right.is_ptr() => {\n+                // This is a commutative operation, just swap the operands\n+                self.ptr_int_arithmetic(bin_op, right.to_ptr()?, left.to_bytes()? as i128, left_kind == isize).map(Some)\n+            }\n+            _ => Ok(None)\n+        }\n+    }\n+\n+    fn ptr_int_arithmetic(\n+        &self,\n+        bin_op: mir::BinOp,\n+        left: MemoryPointer,\n+        right: i128,\n+        signed: bool,\n+    ) -> EvalResult<'tcx, (PrimVal, bool)> {\n+        use rustc::mir::BinOp::*;\n+\n+        fn map_to_primval((res, over) : (MemoryPointer, bool)) -> (PrimVal, bool) {\n+            (PrimVal::Ptr(res), over)\n+        }\n+\n+        Ok(match bin_op {\n+            Sub =>\n+                // The only way this can overflow is by underflowing, so signdeness of the right operands does not matter\n+                map_to_primval(left.overflowing_signed_offset(-right, self)),\n+            Add if signed =>\n+                map_to_primval(left.overflowing_signed_offset(right, self)),\n+            Add if !signed =>\n+                map_to_primval(left.overflowing_offset(right as u64, self)),\n+\n+            BitAnd if !signed => {\n+                let base_mask : u64 = !(self.memory.get(left.alloc_id)?.align - 1);\n+                let right = right as u64;\n+                if right & base_mask == base_mask {\n+                    // Case 1: The base address bits are all preserved, i.e., right is all-1 there\n+                    (PrimVal::Ptr(MemoryPointer::new(left.alloc_id, left.offset & right)), false)\n+                } else if right & base_mask == 0 {\n+                    // Case 2: The base address bits are all taken away, i.e., right is all-0 there\n+                    (PrimVal::from_u128((left.offset & right) as u128), false)\n+                } else {\n+                    return Err(EvalError::ReadPointerAsBytes);\n+                }\n+            }\n+\n+            _ => {\n+                let msg = format!(\"unimplemented binary op on pointer {:?}: {:?}, {:?} ({})\", bin_op, left, right, if signed { \"signed\" } else { \"unsigned\" });\n+                return Err(EvalError::Unimplemented(msg));\n+            }\n+        })\n+    }\n+}"}, {"sha": "4eec7d712abd23f0956da952179822a7100c5707", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 62, "deletions": 4, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/4a4640a331f20f3099687b99e81c438aedebeb81/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4640a331f20f3099687b99e81c438aedebeb81/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=4a4640a331f20f3099687b99e81c438aedebeb81", "patch": "@@ -5,14 +5,17 @@ use rustc::mir;\n use syntax::ast::Mutability;\n \n use super::{\n-    EvalError, EvalResult,\n+    EvalResult, EvalError,\n     Global, GlobalId, Lvalue,\n     PrimVal,\n     EvalContext, StackPopCleanup,\n };\n \n use rustc_const_math::ConstInt;\n \n+use std::fmt;\n+use std::error::Error;\n+\n pub fn eval_body_as_primval<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     instance: Instance<'tcx>,\n@@ -21,7 +24,7 @@ pub fn eval_body_as_primval<'a, 'tcx>(\n     let mut ecx = EvalContext::<Evaluator>::new(tcx, limits, (), ());\n     let cid = GlobalId { instance, promoted: None };\n     if ecx.tcx.has_attr(instance.def_id(), \"linkage\") {\n-        return Err(EvalError::NotConst(\"extern global\".to_string()));\n+        return Err(ConstEvalError::NotConst(\"extern global\".to_string()).into());\n     }\n     \n     let mir = ecx.load_mir(instance.def)?;\n@@ -75,12 +78,52 @@ pub fn eval_body_as_integer<'a, 'tcx>(\n         TyUint(UintTy::U64) => ConstInt::U64(prim as u64),\n         TyUint(UintTy::U128) => ConstInt::U128(prim),\n         TyUint(UintTy::Us) => ConstInt::Usize(ConstUsize::new(prim as u64, tcx.sess.target.uint_type).expect(\"miri should already have errored\")),\n-        _ => return Err(EvalError::NeedsRfc(\"evaluating anything other than isize/usize during typeck\".to_string())),\n+        _ => return Err(ConstEvalError::NeedsRfc(\"evaluating anything other than isize/usize during typeck\".to_string()).into()),\n     })\n }\n \n struct Evaluator;\n \n+impl<'tcx> Into<EvalError<'tcx>> for ConstEvalError {\n+    fn into(self) -> EvalError<'tcx> {\n+        EvalError::MachineError(Box::new(self))\n+    }\n+}\n+\n+#[derive(Clone, Debug)]\n+enum ConstEvalError {\n+    NeedsRfc(String),\n+    NotConst(String),\n+}\n+\n+impl fmt::Display for ConstEvalError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        use self::ConstEvalError::*;\n+        match *self {\n+            NeedsRfc(ref msg) =>\n+                write!(f, \"\\\"{}\\\" needs an rfc before being allowed inside constants\", msg),\n+            NotConst(ref msg) =>\n+                write!(f, \"Cannot evaluate within constants: \\\"{}\\\"\", msg),\n+        }\n+    }\n+}\n+\n+impl Error for ConstEvalError {\n+    fn description(&self) -> &str {\n+        use self::ConstEvalError::*;\n+        match *self {\n+            NeedsRfc(_) =>\n+                \"this feature needs an rfc before being allowed inside constants\",\n+            NotConst(_) =>\n+                \"this feature is not compatible with constant evaluation\",\n+        }\n+    }\n+\n+    fn cause(&self) -> Option<&Error> {\n+        None\n+    }\n+}\n+\n impl<'tcx> super::Machine<'tcx> for Evaluator {\n     type Data = ();\n     type MemoryData = ();\n@@ -93,6 +136,21 @@ impl<'tcx> super::Machine<'tcx> for Evaluator {\n         path: String,\n     ) -> EvalResult<'tcx> {\n         // some simple things like `malloc` might get accepted in the future\n-        Err(EvalError::NeedsRfc(format!(\"calling extern function `{}`\", path)))\n+        Err(ConstEvalError::NeedsRfc(format!(\"calling extern function `{}`\", path)).into())\n+    }\n+\n+    fn ptr_op<'a>(\n+        _ecx: &EvalContext<'a, 'tcx, Self>,\n+        _bin_op: mir::BinOp,\n+        _left: PrimVal,\n+        _left_ty: Ty<'tcx>,\n+        _right: PrimVal,\n+        _right_ty: Ty<'tcx>,\n+    ) -> EvalResult<'tcx, Option<(PrimVal, bool)>> {\n+        Err(ConstEvalError::NeedsRfc(\"Pointer arithmetic or comparison\".to_string()).into())\n+    }\n+\n+    fn check_non_const_fn_call(instance: ty::Instance<'tcx>) -> EvalResult<'tcx> {\n+        return Err(ConstEvalError::NotConst(format!(\"calling non-const fn `{}`\", instance)).into());\n     }\n }"}, {"sha": "dd718c737af7acb95c905c9fe602c7e28a4654a7", "filename": "src/librustc_mir/interpret/error.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4a4640a331f20f3099687b99e81c438aedebeb81/src%2Flibrustc_mir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4640a331f20f3099687b99e81c438aedebeb81/src%2Flibrustc_mir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ferror.rs?ref=4a4640a331f20f3099687b99e81c438aedebeb81", "patch": "@@ -10,8 +10,11 @@ use super::{\n use rustc_const_math::ConstMathErr;\n use syntax::codemap::Span;\n \n-#[derive(Clone, Debug)]\n+#[derive(Debug)]\n pub enum EvalError<'tcx> {\n+    /// This variant is used by machines to signal their own errors that do not\n+    /// match an existing variant\n+    MachineError(Box<Error>),\n     FunctionPointerTyMismatch(FnSig<'tcx>, FnSig<'tcx>),\n     NoMirFor(String),\n     UnterminatedCString(MemoryPointer),\n@@ -95,8 +98,6 @@ pub enum EvalError<'tcx> {\n     HeapAllocNonPowerOfTwoAlignment(u64),\n     Unreachable,\n     Panic,\n-    NeedsRfc(String),\n-    NotConst(String),\n     ReadFromReturnPointer,\n     PathNotFound(Vec<String>),\n }\n@@ -107,6 +108,7 @@ impl<'tcx> Error for EvalError<'tcx> {\n     fn description(&self) -> &str {\n         use self::EvalError::*;\n         match *self {\n+            MachineError(ref inner) => inner.description(),\n             FunctionPointerTyMismatch(..) =>\n                 \"tried to call a function through a function pointer of a different type\",\n             InvalidMemoryAccess =>\n@@ -211,18 +213,20 @@ impl<'tcx> Error for EvalError<'tcx> {\n                 \"entered unreachable code\",\n             Panic =>\n                 \"the evaluated program panicked\",\n-            NeedsRfc(_) =>\n-                \"this feature needs an rfc before being allowed inside constants\",\n-            NotConst(_) =>\n-                \"this feature is not compatible with constant evaluation\",\n             ReadFromReturnPointer =>\n                 \"tried to read from the return pointer\",\n             EvalError::PathNotFound(_) =>\n                 \"a path could not be resolved, maybe the crate is not loaded\",\n         }\n     }\n \n-    fn cause(&self) -> Option<&Error> { None }\n+    fn cause(&self) -> Option<&Error> {\n+        use self::EvalError::*;\n+        match *self {\n+            MachineError(ref inner) => Some(&**inner),\n+            _ => None,\n+        }\n+    }\n }\n \n impl<'tcx> fmt::Display for EvalError<'tcx> {\n@@ -278,12 +282,10 @@ impl<'tcx> fmt::Display for EvalError<'tcx> {\n                 write!(f, \"expected primitive type, got {}\", ty),\n             Layout(ref err) =>\n                 write!(f, \"rustc layout computation failed: {:?}\", err),\n-            NeedsRfc(ref msg) =>\n-                write!(f, \"\\\"{}\\\" needs an rfc before being allowed inside constants\", msg),\n-            NotConst(ref msg) =>\n-                write!(f, \"Cannot evaluate within constants: \\\"{}\\\"\", msg),\n-            EvalError::PathNotFound(ref path) =>\n+            PathNotFound(ref path) =>\n                 write!(f, \"Cannot find path {:?}\", path),\n+            MachineError(ref inner) =>\n+                write!(f, \"machine error: {}\", inner),\n             _ => write!(f, \"{}\", self.description()),\n         }\n     }"}, {"sha": "88f9af75f95087f13ceafdd113efdbf75444f640", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4a4640a331f20f3099687b99e81c438aedebeb81/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4640a331f20f3099687b99e81c438aedebeb81/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=4a4640a331f20f3099687b99e81c438aedebeb81", "patch": "@@ -666,9 +666,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             }\n \n             Len(ref lvalue) => {\n-                if self.const_env() {\n-                    return Err(EvalError::NeedsRfc(\"computing the length of arrays\".to_string()));\n-                }\n+                // FIXME(CTFE): don't allow computing the length of arrays in const eval\n                 let src = self.eval_lvalue(lvalue)?;\n                 let ty = self.lvalue_ty(lvalue);\n                 let (_, len) = src.elem_ty_and_len(ty);\n@@ -692,9 +690,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             }\n \n             NullaryOp(mir::NullOp::Box, ty) => {\n-                if self.const_env() {\n-                    return Err(EvalError::NeedsRfc(\"\\\"heap\\\" allocations\".to_string()));\n-                }\n+                // FIXME(CTFE): don't allow heap allocations in const eval\n                 // FIXME: call the `exchange_malloc` lang item if available\n                 let size = self.type_size(ty)?.expect(\"box only works with sized types\");\n                 if size == 0 {\n@@ -708,9 +704,6 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             }\n \n             NullaryOp(mir::NullOp::SizeOf, ty) => {\n-                if self.const_env() {\n-                    return Err(EvalError::NeedsRfc(\"computing the size of types (size_of)\".to_string()));\n-                }\n                 let size = self.type_size(ty)?.expect(\"SizeOf nullary MIR operator called for unsized type\");\n                 self.write_primval(dest, PrimVal::from_u128(size as u128), dest_ty)?;\n             }\n@@ -944,7 +937,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         ptr.wrapping_signed_offset(offset, self)\n     }\n \n-    pub(super) fn pointer_offset(&self, ptr: Pointer, pointee_ty: Ty<'tcx>, offset: i64) -> EvalResult<'tcx, Pointer> {\n+    pub fn pointer_offset(&self, ptr: Pointer, pointee_ty: Ty<'tcx>, offset: i64) -> EvalResult<'tcx, Pointer> {\n         // This function raises an error if the offset moves the pointer outside of its allocation.  We consider\n         // ZSTs their own huge allocation that doesn't overlap with anything (and nothing moves in there because the size is 0).\n         // We also consider the NULL pointer its own separate allocation, and all the remaining integers pointers their own"}, {"sha": "5d762c81a9ba7261fb5738e9151e177ff6d5816f", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4a4640a331f20f3099687b99e81c438aedebeb81/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4640a331f20f3099687b99e81c438aedebeb81/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=4a4640a331f20f3099687b99e81c438aedebeb81", "patch": "@@ -6,6 +6,7 @@ use super::{\n     EvalResult,\n     EvalContext,\n     Lvalue,\n+    PrimVal\n };\n \n use rustc::{mir, ty};\n@@ -29,5 +30,25 @@ pub trait Machine<'tcx>: Sized {\n         sig: ty::FnSig<'tcx>,\n         path: String,\n     ) -> EvalResult<'tcx>;\n+\n+    /// Called when operating on the value of pointers.\n+    ///\n+    /// Returns `None` if the operation should be handled by the integer\n+    /// op code\n+    ///\n+    /// Returns a (value, overflowed) pair otherwise\n+    fn ptr_op<'a>(\n+        ecx: &EvalContext<'a, 'tcx, Self>,\n+        bin_op: mir::BinOp,\n+        left: PrimVal,\n+        left_ty: ty::Ty<'tcx>,\n+        right: PrimVal,\n+        right_ty: ty::Ty<'tcx>,\n+    ) -> EvalResult<'tcx, Option<(PrimVal, bool)>>;\n+\n+    /// Called when adding a frame for a function that's not `const fn`\n+    ///\n+    /// Const eval returns `Err`, miri returns `Ok`\n+    fn check_non_const_fn_call(instance: ty::Instance<'tcx>) -> EvalResult<'tcx>;\n }\n "}, {"sha": "28cc9b9a25e26a076196ea35d9ec36d45cc6daf6", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a4640a331f20f3099687b99e81c438aedebeb81/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4640a331f20f3099687b99e81c438aedebeb81/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=4a4640a331f20f3099687b99e81c438aedebeb81", "patch": "@@ -198,7 +198,7 @@ impl<'tcx> MemoryPointer {\n         MemoryPointer::new(self.alloc_id, cx.data_layout().wrapping_signed_offset(self.offset, i))\n     }\n \n-    pub(crate) fn overflowing_signed_offset<C: HasDataLayout>(self, i: i128, cx: C) -> (Self, bool) {\n+    pub fn overflowing_signed_offset<C: HasDataLayout>(self, i: i128, cx: C) -> (Self, bool) {\n         let (res, over) = cx.data_layout().overflowing_signed_offset(self.offset, i);\n         (MemoryPointer::new(self.alloc_id, res), over)\n     }\n@@ -207,7 +207,7 @@ impl<'tcx> MemoryPointer {\n         Ok(MemoryPointer::new(self.alloc_id, cx.data_layout().signed_offset(self.offset, i)?))\n     }\n \n-    pub(crate) fn overflowing_offset<C: HasDataLayout>(self, i: u64, cx: C) -> (Self, bool) {\n+    pub fn overflowing_offset<C: HasDataLayout>(self, i: u64, cx: C) -> (Self, bool) {\n         let (res, over) = cx.data_layout().overflowing_offset(self.offset, i);\n         (MemoryPointer::new(self.alloc_id, res), over)\n     }"}, {"sha": "606761f371c2c4fa925633f95f75010aa2998354", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 6, "deletions": 113, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/4a4640a331f20f3099687b99e81c438aedebeb81/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4640a331f20f3099687b99e81c438aedebeb81/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=4a4640a331f20f3099687b99e81c438aedebeb81", "patch": "@@ -1,10 +1,9 @@\n use rustc::mir;\n-use rustc::ty::{self, Ty};\n+use rustc::ty::Ty;\n \n use super::{\n     EvalError, EvalResult,\n     EvalContext,\n-    MemoryPointer,\n     Lvalue,\n     Machine,\n };\n@@ -153,75 +152,9 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         //trace!(\"Running binary op {:?}: {:?} ({:?}), {:?} ({:?})\", bin_op, left, left_kind, right, right_kind);\n \n         // I: Handle operations that support pointers\n-        let usize = PrimValKind::from_uint_size(self.memory.pointer_size());\n-        let isize = PrimValKind::from_int_size(self.memory.pointer_size());\n         if !left_kind.is_float() && !right_kind.is_float() {\n-            if (!left.is_bytes() && !right.is_bytes()) && self.const_env() {\n-                return Err(EvalError::NeedsRfc(\"Pointer arithmetic or comparison\".to_string()));\n-            }\n-            match bin_op {\n-                Offset if left_kind == Ptr && right_kind == usize => {\n-                    let pointee_ty = left_ty.builtin_deref(true, ty::LvaluePreference::NoPreference).expect(\"Offset called on non-ptr type\").ty;\n-                    let ptr = self.pointer_offset(left.into(), pointee_ty, right.to_bytes()? as i64)?;\n-                    return Ok((ptr.into_inner_primval(), false));\n-                },\n-                // These work on anything\n-                Eq if left_kind == right_kind => {\n-                    let result = match (left, right) {\n-                        (PrimVal::Bytes(left), PrimVal::Bytes(right)) => left == right,\n-                        (PrimVal::Ptr(left), PrimVal::Ptr(right)) => left == right,\n-                        (PrimVal::Undef, _) | (_, PrimVal::Undef) => return Err(EvalError::ReadUndefBytes),\n-                        _ => false,\n-                    };\n-                    return Ok((PrimVal::from_bool(result), false));\n-                }\n-                Ne if left_kind == right_kind => {\n-                    let result = match (left, right) {\n-                        (PrimVal::Bytes(left), PrimVal::Bytes(right)) => left != right,\n-                        (PrimVal::Ptr(left), PrimVal::Ptr(right)) => left != right,\n-                        (PrimVal::Undef, _) | (_, PrimVal::Undef) => return Err(EvalError::ReadUndefBytes),\n-                        _ => true,\n-                    };\n-                    return Ok((PrimVal::from_bool(result), false));\n-                }\n-                // These need both pointers to be in the same allocation\n-                Lt | Le | Gt | Ge | Sub\n-                if left_kind == right_kind\n-                && (left_kind == Ptr || left_kind == usize || left_kind == isize)\n-                && left.is_ptr() && right.is_ptr() => {\n-                    let left = left.to_ptr()?;\n-                    let right = right.to_ptr()?;\n-                    if left.alloc_id == right.alloc_id {\n-                        let res = match bin_op {\n-                            Lt => left.offset < right.offset,\n-                            Le => left.offset <= right.offset,\n-                            Gt => left.offset > right.offset,\n-                            Ge => left.offset >= right.offset,\n-                            Sub => {\n-                                return int_arithmetic!(left_kind, overflowing_sub, left.offset, right.offset);\n-                            }\n-                            _ => bug!(\"We already established it has to be one of these operators.\"),\n-                        };\n-                        return Ok((PrimVal::from_bool(res), false));\n-                    } else {\n-                        // Both are pointers, but from different allocations.\n-                        return Err(EvalError::InvalidPointerMath);\n-                    }\n-                }\n-                // These work if one operand is a pointer, the other an integer\n-                Add | BitAnd | Sub\n-                if left_kind == right_kind && (left_kind == usize || left_kind == isize)\n-                && left.is_ptr() && right.is_bytes() => {\n-                    // Cast to i128 is fine as we checked the kind to be ptr-sized\n-                    return self.ptr_int_arithmetic(bin_op, left.to_ptr()?, right.to_bytes()? as i128, left_kind == isize);\n-                }\n-                Add | BitAnd\n-                if left_kind == right_kind && (left_kind == usize || left_kind == isize)\n-                && left.is_bytes() && right.is_ptr() => {\n-                    // This is a commutative operation, just swap the operands\n-                    return self.ptr_int_arithmetic(bin_op, right.to_ptr()?, left.to_bytes()? as i128, left_kind == isize);\n-                }\n-                _ => {}\n+            if let Some(handled) = M::ptr_op(self, bin_op, left, left_ty, right, right_ty)? {\n+                return Ok(handled);\n             }\n         }\n \n@@ -270,6 +203,9 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             (Div, F64) => f64_arithmetic!(/, l, r),\n             (Rem, F64) => f64_arithmetic!(%, l, r),\n \n+            (Eq, _) => PrimVal::from_bool(l == r),\n+            (Ne, _) => PrimVal::from_bool(l != r),\n+\n             (Lt, k) if k.is_signed_int() => PrimVal::from_bool((l as i128) < (r as i128)),\n             (Lt, _) => PrimVal::from_bool(l <  r),\n             (Le, k) if k.is_signed_int() => PrimVal::from_bool((l as i128) <= (r as i128)),\n@@ -297,49 +233,6 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n \n         Ok((val, false))\n     }\n-\n-    fn ptr_int_arithmetic(\n-        &self,\n-        bin_op: mir::BinOp,\n-        left: MemoryPointer,\n-        right: i128,\n-        signed: bool,\n-    ) -> EvalResult<'tcx, (PrimVal, bool)> {\n-        use rustc::mir::BinOp::*;\n-\n-        fn map_to_primval((res, over) : (MemoryPointer, bool)) -> (PrimVal, bool) {\n-            (PrimVal::Ptr(res), over)\n-        }\n-\n-        Ok(match bin_op {\n-            Sub =>\n-                // The only way this can overflow is by underflowing, so signdeness of the right operands does not matter\n-                map_to_primval(left.overflowing_signed_offset(-right, self)),\n-            Add if signed =>\n-                map_to_primval(left.overflowing_signed_offset(right, self)),\n-            Add if !signed =>\n-                map_to_primval(left.overflowing_offset(right as u64, self)),\n-\n-            BitAnd if !signed => {\n-                let base_mask : u64 = !(self.memory.get(left.alloc_id)?.align - 1);\n-                let right = right as u64;\n-                if right & base_mask == base_mask {\n-                    // Case 1: The base address bits are all preserved, i.e., right is all-1 there\n-                    (PrimVal::Ptr(MemoryPointer::new(left.alloc_id, left.offset & right)), false)\n-                } else if right & base_mask == 0 {\n-                    // Case 2: The base address bits are all taken away, i.e., right is all-0 there\n-                    (PrimVal::from_u128((left.offset & right) as u128), false)\n-                } else {\n-                    return Err(EvalError::ReadPointerAsBytes);\n-                }\n-            }\n-\n-            _ => {\n-                let msg = format!(\"unimplemented binary op on pointer {:?}: {:?}, {:?} ({})\", bin_op, left, right, if signed { \"signed\" } else { \"unsigned\" });\n-                return Err(EvalError::Unimplemented(msg));\n-            }\n-        })\n-    }\n }\n \n pub fn unary_op<'tcx>("}, {"sha": "779ab8c98742bf4b54af8c90c0ed6cb49b176b29", "filename": "src/librustc_mir/interpret/terminator/mod.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4a4640a331f20f3099687b99e81c438aedebeb81/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4640a331f20f3099687b99e81c438aedebeb81/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs?ref=4a4640a331f20f3099687b99e81c438aedebeb81", "patch": "@@ -40,9 +40,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             Goto { target } => self.goto_block(target),\n \n             SwitchInt { ref discr, ref values, ref targets, .. } => {\n-                if self.const_env() {\n-                    return Err(EvalError::NeedsRfc(\"branching (if, match, loop, ...)\".to_string()));\n-                }\n+                // FIXME(CTFE): forbid branching\n                 let discr_val = self.eval_operand(discr)?;\n                 let discr_ty = self.operand_ty(discr);\n                 let discr_prim = self.value_to_primval(discr_val, discr_ty)?;\n@@ -100,9 +98,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n \n             Drop { ref location, target, .. } => {\n                 trace!(\"TerminatorKind::drop: {:?}, {:?}\", location, self.substs());\n-                if self.const_env() {\n-                    return Err(EvalError::NeedsRfc(\"invoking `Drop::drop`\".to_string()));\n-                }\n+                // FIXME(CTFE): forbid drop in const eval\n                 let lval = self.eval_lvalue(location)?;\n                 let ty = self.lvalue_ty(location);\n                 self.goto_block(target);\n@@ -436,17 +432,14 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         let mir = match self.load_mir(instance.def) {\n             Ok(mir) => mir,\n             Err(EvalError::NoMirFor(path)) => {\n-                if self.const_env() {\n-                    return Err(EvalError::NeedsRfc(format!(\"calling extern function `{}`\", path)));\n-                }\n                 M::call_missing_fn(self, instance, destination, arg_operands, sig, path)?;\n                 return Ok(true);\n             },\n             Err(other) => return Err(other),\n         };\n \n-        if self.const_env() && !self.tcx.is_const_fn(instance.def_id()) {\n-            return Err(EvalError::NotConst(format!(\"calling non-const fn `{}`\", instance)));\n+        if !self.tcx.is_const_fn(instance.def_id()) {\n+            M::check_non_const_fn_call(instance)?;\n         }\n         \n         let (return_lvalue, return_to_block) = match destination {"}]}