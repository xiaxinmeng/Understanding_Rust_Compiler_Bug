{"sha": "b0b48511dae63b2e86d002930e54cef7c0d6009e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwYjQ4NTExZGFlNjNiMmU4NmQwMDI5MzBlNTRjZWY3YzBkNjAwOWU=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2014-08-23T17:22:36Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2014-08-23T17:23:02Z"}, "message": "Test case to illustate/reproduce bug.", "tree": {"sha": "3a6f7bf93e41e3114bd906eb68cc2028db598f80", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a6f7bf93e41e3114bd906eb68cc2028db598f80"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b0b48511dae63b2e86d002930e54cef7c0d6009e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b0b48511dae63b2e86d002930e54cef7c0d6009e", "html_url": "https://github.com/rust-lang/rust/commit/b0b48511dae63b2e86d002930e54cef7c0d6009e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b0b48511dae63b2e86d002930e54cef7c0d6009e/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f66fd2eed10de2acacd8af73c704bf4d140410bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/f66fd2eed10de2acacd8af73c704bf4d140410bb", "html_url": "https://github.com/rust-lang/rust/commit/f66fd2eed10de2acacd8af73c704bf4d140410bb"}], "stats": {"total": 167, "additions": 167, "deletions": 0}, "files": [{"sha": "2e8c23fe5ba2c0fd36eed01d04ea98e7f7868ca5", "filename": "src/test/run-pass/realloc-16687.rs", "status": "added", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/b0b48511dae63b2e86d002930e54cef7c0d6009e/src%2Ftest%2Frun-pass%2Frealloc-16687.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0b48511dae63b2e86d002930e54cef7c0d6009e/src%2Ftest%2Frun-pass%2Frealloc-16687.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frealloc-16687.rs?ref=b0b48511dae63b2e86d002930e54cef7c0d6009e", "patch": "@@ -0,0 +1,167 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// alloc::heap::reallocate test.\n+//\n+// Ideally this would be revised to use no_std, but for now it serves\n+// well enough to reproduce (and illustrate) the bug from #16687.\n+\n+extern crate alloc;\n+\n+use alloc::heap;\n+use std::ptr;\n+\n+fn main() {\n+    unsafe {\n+        assert!(test_triangle());\n+    }\n+}\n+\n+unsafe fn test_triangle() -> bool {\n+    static COUNT : uint = 16;\n+    let mut ascend = Vec::from_elem(COUNT, ptr::mut_null());\n+    let ascend = ascend.as_mut_slice();\n+    static ALIGN : uint = 1;\n+\n+    // Checks that `ascend` forms triangle of acending size formed\n+    // from pairs of rows (where each pair of rows is equally sized),\n+    // and the elements of the triangle match their row-pair index.\n+    unsafe fn sanity_check(ascend: &[*mut u8]) {\n+        for i in range(0u, COUNT / 2) {\n+            let (p0, p1, size) = (ascend[2*i], ascend[2*i+1], idx_to_size(i));\n+            for j in range(0u, size) {\n+                assert_eq!(*p0.offset(j as int), i as u8);\n+                assert_eq!(*p1.offset(j as int), i as u8);\n+            }\n+        }\n+    }\n+\n+    static PRINT : bool = false;\n+\n+    unsafe fn allocate(size: uint, align: uint) -> *mut u8 {\n+        if PRINT { println!(\"allocate(size={:u} align={:u})\", size, align); }\n+\n+        let ret = heap::allocate(size, align);\n+\n+        if PRINT { println!(\"allocate(size={:u} align={:u}) ret: 0x{:010x}\",\n+                            size, align, ret as uint);\n+        }\n+\n+        ret\n+    }\n+    unsafe fn reallocate(ptr: *mut u8, size: uint, align: uint,\n+                             old_size: uint) -> *mut u8 {\n+        if PRINT {\n+            println!(\"reallocate(ptr=0x{:010x} size={:u} align={:u} old_size={:u})\",\n+                     ptr as uint, size, align, old_size);\n+        }\n+\n+        let ret = heap::reallocate(ptr, size, align, old_size);\n+\n+        if PRINT {\n+            println!(\"reallocate(ptr=0x{:010x} size={:u} align={:u} old_size={:u}) \\\n+                      ret: 0x{:010x}\",\n+                     ptr as uint, size, align, old_size, ret as uint);\n+        }\n+        ret\n+    }\n+\n+    fn idx_to_size(i: uint) -> uint { (i+1) * 10 }\n+\n+    // Allocate pairs of rows that form a triangle shape.  (Hope is\n+    // that at least two rows will be allocated near each other, so\n+    // that we trigger the bug (a buffer overrun) in an observable\n+    // way.)\n+    for i in range(0u, COUNT / 2) {\n+        let size = idx_to_size(i);\n+        ascend[2*i]   = allocate(size, ALIGN);\n+        ascend[2*i+1] = allocate(size, ALIGN);\n+    }\n+\n+    // Initialize each pair of rows to distinct value.\n+    for i in range(0u, COUNT / 2) {\n+        let (p0, p1, size) = (ascend[2*i], ascend[2*i+1], idx_to_size(i));\n+        for j in range(0, size) {\n+            *p0.offset(j as int) = i as u8;\n+            *p1.offset(j as int) = i as u8;\n+        }\n+    }\n+\n+    sanity_check(ascend.as_slice());\n+    test_1(ascend);\n+    test_2(ascend);\n+    test_3(ascend);\n+    test_4(ascend);\n+\n+    return true;\n+\n+    // Test 1: turn the triangle into a square (in terms of\n+    // allocation; initialized portion remains a triangle) by\n+    // realloc'ing each row from top to bottom, and checking all the\n+    // rows as we go.\n+    unsafe fn test_1(ascend: &mut [*mut u8]) {\n+        let new_size = idx_to_size(COUNT-1);\n+        for i in range(0u, COUNT / 2) {\n+            let (p0, p1, old_size) = (ascend[2*i], ascend[2*i+1], idx_to_size(i));\n+            assert!(old_size < new_size);\n+\n+            ascend[2*i] = reallocate(p0, new_size, ALIGN, old_size);\n+            sanity_check(ascend.as_slice());\n+\n+            ascend[2*i+1] = reallocate(p1, new_size, ALIGN, old_size);\n+            sanity_check(ascend.as_slice());\n+        }\n+    }\n+\n+    // Test 2: turn the square back into a triangle, top to bottom.\n+    unsafe fn test_2(ascend: &mut [*mut u8]) {\n+        let old_size = idx_to_size(COUNT-1);\n+        for i in range(0u, COUNT / 2) {\n+            let (p0, p1, new_size) = (ascend[2*i], ascend[2*i+1], idx_to_size(i));\n+            assert!(new_size < old_size);\n+\n+            ascend[2*i] = reallocate(p0, new_size, ALIGN, old_size);\n+            sanity_check(ascend.as_slice());\n+\n+            ascend[2*i+1] = reallocate(p1, new_size, ALIGN, old_size);\n+            sanity_check(ascend.as_slice());\n+        }\n+    }\n+\n+    // Test 3: turn triangle into a square, bottom to top.\n+    unsafe fn test_3(ascend: &mut [*mut u8]) {\n+        let new_size = idx_to_size(COUNT-1);\n+        for i in range(0u, COUNT / 2).rev() {\n+            let (p0, p1, old_size) = (ascend[2*i], ascend[2*i+1], idx_to_size(i));\n+            assert!(old_size < new_size);\n+\n+            ascend[2*i+1] = reallocate(p1, new_size, ALIGN, old_size);\n+            sanity_check(ascend.as_slice());\n+\n+            ascend[2*i] = reallocate(p0, new_size, ALIGN, old_size);\n+            sanity_check(ascend.as_slice());\n+        }\n+    }\n+\n+    // Test 4: turn the square back into a triangle, bottom to top.\n+    unsafe fn test_4(ascend: &mut [*mut u8]) {\n+        let old_size = idx_to_size(COUNT-1);\n+        for i in range(0u, COUNT / 2).rev() {\n+            let (p0, p1, new_size) = (ascend[2*i], ascend[2*i+1], idx_to_size(i));\n+            assert!(new_size < old_size);\n+\n+            ascend[2*i+1] = reallocate(p1, new_size, ALIGN, old_size);\n+            sanity_check(ascend.as_slice());\n+\n+            ascend[2*i] = reallocate(p0, new_size, ALIGN, old_size);\n+            sanity_check(ascend.as_slice());\n+        }\n+    }\n+}"}]}