{"sha": "4f96ca353ec2f48e02efe592dc9d7ebaa1e66f60", "node_id": "C_kwDOAAsO6NoAKDRmOTZjYTM1M2VjMmY0OGUwMmVmZTU5MmRjOWQ3ZWJhYTFlNjZmNjA", "commit": {"author": {"name": "Jaeyong Sung", "email": "jaeyong0201@gmail.com", "date": "2022-02-12T17:32:09Z"}, "committer": {"name": "Jaeyong Sung", "email": "jaeyong0201@gmail.com", "date": "2022-02-12T17:32:09Z"}, "message": "add only_used_in_recursion lint\n\n- fix code that have variables that is \"only used in recursion\"\n- add test", "tree": {"sha": "221fff63148580c6d25726fb18caee2a7a9aba81", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/221fff63148580c6d25726fb18caee2a7a9aba81"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f96ca353ec2f48e02efe592dc9d7ebaa1e66f60", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEErNAvdl6JhsmcOZwWK4aJjMsqVIYFAmIH7xkACgkQK4aJjMsq\nVIbGEhAAmafWaVX8JjXgucrILWCiyPEHaF/vEREFbNwbG5LuYzsp3P3KoRbcTn6G\nPOMNAm/uATOhxCehznvovP4DsPy1qwSoRTEUa4MhN9t3v+uH9SgIW2/ki5HEjdP1\nYReE88z77fRConI6cPaFmFZt1DQykiZXBBsz/7RMwwkMvufXYO3q8Y7YcF1IWOEO\nvVeI92lcrqDNy4dW6JRzrBc1F+RQuGzBHBBwqFRTtX+6xws62YwN3lczkRGnhafx\naH881fmWi6o3gdOBzCjBzFCmCQJuoZVJuhHOB54vDpRco6/S33JlT+eQ1rvBebBY\nsB0M27pvBRjtzlSCybQfHGiOU2T5D80cWSTOPwOT8CkReKidlUTV4oRPnZ3xAXEC\nG6pZ1MsaMvnBsRTwKM6A/40i4YsOOWGJk8cTUxbrW9pA6cfoH3SRybRhOGpPmt0K\nYVd+w/qS2J/cRLENpH+vC8eWl/dRXNCLkBqkXEz9YWQNaSeOPiv1wCKtGQiT2K1E\nhPpgB9PcZJ8wMEWAR8TamOInOdeC0kXqX/98uBJVhFSWpwyAp9epCGn3Tm2HnOLl\nOdruqAK4k1Mi4ppBiySm8kpcvt1ja9FFtopsd32rIVuzt7/uzidXgKrrlXLf09ch\nsJM2QK+NhYo6l2m9/AMaX7hN1RKE3vfTAQnrLCookxmvKRmuDn8=\n=9wIf\n-----END PGP SIGNATURE-----", "payload": "tree 221fff63148580c6d25726fb18caee2a7a9aba81\nparent 6966a42c1a56bca8df305496274682a01139099c\nauthor Jaeyong Sung <jaeyong0201@gmail.com> 1644687129 +0900\ncommitter Jaeyong Sung <jaeyong0201@gmail.com> 1644687129 +0900\n\nadd only_used_in_recursion lint\n\n- fix code that have variables that is \"only used in recursion\"\n- add test\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f96ca353ec2f48e02efe592dc9d7ebaa1e66f60", "html_url": "https://github.com/rust-lang/rust/commit/4f96ca353ec2f48e02efe592dc9d7ebaa1e66f60", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f96ca353ec2f48e02efe592dc9d7ebaa1e66f60/comments", "author": {"login": "buttercrab", "id": 34997549, "node_id": "MDQ6VXNlcjM0OTk3NTQ5", "avatar_url": "https://avatars.githubusercontent.com/u/34997549?v=4", "gravatar_id": "", "url": "https://api.github.com/users/buttercrab", "html_url": "https://github.com/buttercrab", "followers_url": "https://api.github.com/users/buttercrab/followers", "following_url": "https://api.github.com/users/buttercrab/following{/other_user}", "gists_url": "https://api.github.com/users/buttercrab/gists{/gist_id}", "starred_url": "https://api.github.com/users/buttercrab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/buttercrab/subscriptions", "organizations_url": "https://api.github.com/users/buttercrab/orgs", "repos_url": "https://api.github.com/users/buttercrab/repos", "events_url": "https://api.github.com/users/buttercrab/events{/privacy}", "received_events_url": "https://api.github.com/users/buttercrab/received_events", "type": "User", "site_admin": false}, "committer": {"login": "buttercrab", "id": 34997549, "node_id": "MDQ6VXNlcjM0OTk3NTQ5", "avatar_url": "https://avatars.githubusercontent.com/u/34997549?v=4", "gravatar_id": "", "url": "https://api.github.com/users/buttercrab", "html_url": "https://github.com/buttercrab", "followers_url": "https://api.github.com/users/buttercrab/followers", "following_url": "https://api.github.com/users/buttercrab/following{/other_user}", "gists_url": "https://api.github.com/users/buttercrab/gists{/gist_id}", "starred_url": "https://api.github.com/users/buttercrab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/buttercrab/subscriptions", "organizations_url": "https://api.github.com/users/buttercrab/orgs", "repos_url": "https://api.github.com/users/buttercrab/repos", "events_url": "https://api.github.com/users/buttercrab/events{/privacy}", "received_events_url": "https://api.github.com/users/buttercrab/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6966a42c1a56bca8df305496274682a01139099c", "url": "https://api.github.com/repos/rust-lang/rust/commits/6966a42c1a56bca8df305496274682a01139099c", "html_url": "https://github.com/rust-lang/rust/commit/6966a42c1a56bca8df305496274682a01139099c"}], "stats": {"total": 766, "additions": 732, "deletions": 34}, "files": [{"sha": "46f002aeeb39a26830e2509ad04b0dba2aa0eacc", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f96ca353ec2f48e02efe592dc9d7ebaa1e66f60/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/4f96ca353ec2f48e02efe592dc9d7ebaa1e66f60/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=4f96ca353ec2f48e02efe592dc9d7ebaa1e66f60", "patch": "@@ -3349,6 +3349,7 @@ Released 2018-09-13\n [`not_unsafe_ptr_arg_deref`]: https://rust-lang.github.io/rust-clippy/master/index.html#not_unsafe_ptr_arg_deref\n [`octal_escapes`]: https://rust-lang.github.io/rust-clippy/master/index.html#octal_escapes\n [`ok_expect`]: https://rust-lang.github.io/rust-clippy/master/index.html#ok_expect\n+[`only_used_in_recursion`]: https://rust-lang.github.io/rust-clippy/master/index.html#only_used_in_recursion\n [`op_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#op_ref\n [`option_as_ref_deref`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_as_ref_deref\n [`option_env_unwrap`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_env_unwrap"}, {"sha": "7410d965ec183802eab921a46e383ded78da2945", "filename": "clippy_lints/src/lib.register_all.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f96ca353ec2f48e02efe592dc9d7ebaa1e66f60/clippy_lints%2Fsrc%2Flib.register_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f96ca353ec2f48e02efe592dc9d7ebaa1e66f60/clippy_lints%2Fsrc%2Flib.register_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_all.rs?ref=4f96ca353ec2f48e02efe592dc9d7ebaa1e66f60", "patch": "@@ -226,6 +226,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(non_expressive_names::JUST_UNDERSCORES_AND_DIGITS),\n     LintId::of(non_octal_unix_permissions::NON_OCTAL_UNIX_PERMISSIONS),\n     LintId::of(octal_escapes::OCTAL_ESCAPES),\n+    LintId::of(only_used_in_recursion::ONLY_USED_IN_RECURSION),\n     LintId::of(open_options::NONSENSICAL_OPEN_OPTIONS),\n     LintId::of(option_env_unwrap::OPTION_ENV_UNWRAP),\n     LintId::of(overflow_check_conditional::OVERFLOW_CHECK_CONDITIONAL),"}, {"sha": "0cdf0cd19172a205ef84e4fb5f277290df60e39d", "filename": "clippy_lints/src/lib.register_complexity.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f96ca353ec2f48e02efe592dc9d7ebaa1e66f60/clippy_lints%2Fsrc%2Flib.register_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f96ca353ec2f48e02efe592dc9d7ebaa1e66f60/clippy_lints%2Fsrc%2Flib.register_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_complexity.rs?ref=4f96ca353ec2f48e02efe592dc9d7ebaa1e66f60", "patch": "@@ -63,6 +63,7 @@ store.register_group(true, \"clippy::complexity\", Some(\"clippy_complexity\"), vec!\n     LintId::of(neg_cmp_op_on_partial_ord::NEG_CMP_OP_ON_PARTIAL_ORD),\n     LintId::of(no_effect::NO_EFFECT),\n     LintId::of(no_effect::UNNECESSARY_OPERATION),\n+    LintId::of(only_used_in_recursion::ONLY_USED_IN_RECURSION),\n     LintId::of(overflow_check_conditional::OVERFLOW_CHECK_CONDITIONAL),\n     LintId::of(partialeq_ne_impl::PARTIALEQ_NE_IMPL),\n     LintId::of(precedence::PRECEDENCE),"}, {"sha": "431bd6227027b19dc41881f2423c31480f605684", "filename": "clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f96ca353ec2f48e02efe592dc9d7ebaa1e66f60/clippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f96ca353ec2f48e02efe592dc9d7ebaa1e66f60/clippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_lints.rs?ref=4f96ca353ec2f48e02efe592dc9d7ebaa1e66f60", "patch": "@@ -388,6 +388,7 @@ store.register_lints(&[\n     non_send_fields_in_send_ty::NON_SEND_FIELDS_IN_SEND_TY,\n     nonstandard_macro_braces::NONSTANDARD_MACRO_BRACES,\n     octal_escapes::OCTAL_ESCAPES,\n+    only_used_in_recursion::ONLY_USED_IN_RECURSION,\n     open_options::NONSENSICAL_OPEN_OPTIONS,\n     option_env_unwrap::OPTION_ENV_UNWRAP,\n     option_if_let_else::OPTION_IF_LET_ELSE,"}, {"sha": "bd49ad0652c28e6ad8d15b7fd8fd99299fd61ba1", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f96ca353ec2f48e02efe592dc9d7ebaa1e66f60/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f96ca353ec2f48e02efe592dc9d7ebaa1e66f60/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=4f96ca353ec2f48e02efe592dc9d7ebaa1e66f60", "patch": "@@ -316,6 +316,7 @@ mod non_octal_unix_permissions;\n mod non_send_fields_in_send_ty;\n mod nonstandard_macro_braces;\n mod octal_escapes;\n+mod only_used_in_recursion;\n mod open_options;\n mod option_env_unwrap;\n mod option_if_let_else;\n@@ -862,6 +863,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(move || Box::new(borrow_as_ptr::BorrowAsPtr::new(msrv)));\n     store.register_late_pass(move || Box::new(manual_bits::ManualBits::new(msrv)));\n     store.register_late_pass(|| Box::new(default_union_representation::DefaultUnionRepresentation));\n+    store.register_late_pass(|| Box::new(only_used_in_recursion::OnlyUsedInRecursion));\n     // add lints here, do not remove this comment, it's used in `new_lint`\n }\n "}, {"sha": "2a5ab6e625c111ae0bec3d204db34d7f5c6653f0", "filename": "clippy_lints/src/methods/option_map_or_none.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4f96ca353ec2f48e02efe592dc9d7ebaa1e66f60/clippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f96ca353ec2f48e02efe592dc9d7ebaa1e66f60/clippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs?ref=4f96ca353ec2f48e02efe592dc9d7ebaa1e66f60", "patch": "@@ -14,18 +14,15 @@ use super::RESULT_MAP_OR_INTO_OPTION;\n \n // The expression inside a closure may or may not have surrounding braces\n // which causes problems when generating a suggestion.\n-fn reduce_unit_expression<'a>(\n-    cx: &LateContext<'_>,\n-    expr: &'a hir::Expr<'_>,\n-) -> Option<(&'a hir::Expr<'a>, &'a [hir::Expr<'a>])> {\n+fn reduce_unit_expression<'a>(expr: &'a hir::Expr<'_>) -> Option<(&'a hir::Expr<'a>, &'a [hir::Expr<'a>])> {\n     match expr.kind {\n         hir::ExprKind::Call(func, arg_char) => Some((func, arg_char)),\n         hir::ExprKind::Block(block, _) => {\n             match (block.stmts, block.expr) {\n                 (&[], Some(inner_expr)) => {\n                     // If block only contains an expression,\n                     // reduce `|x| { x + 1 }` to `|x| x + 1`\n-                    reduce_unit_expression(cx, inner_expr)\n+                    reduce_unit_expression(inner_expr)\n                 },\n                 _ => None,\n             }\n@@ -77,7 +74,7 @@ pub(super) fn check<'tcx>(\n         if let hir::ExprKind::Closure(_, _, id, span, _) = map_arg.kind;\n             let arg_snippet = snippet(cx, span, \"..\");\n             let body = cx.tcx.hir().body(id);\n-                if let Some((func, [arg_char])) = reduce_unit_expression(cx, &body.value);\n+                if let Some((func, [arg_char])) = reduce_unit_expression(&body.value);\n                 if let Some(id) = path_def_id(cx, func).and_then(|ctor_id| cx.tcx.parent(ctor_id));\n                 if Some(id) == cx.tcx.lang_items().option_some_variant();\n                 then {"}, {"sha": "ace00333bd1b5573dd199ed653f164dbd2f72211", "filename": "clippy_lints/src/only_used_in_recursion.rs", "status": "added", "additions": 563, "deletions": 0, "changes": 563, "blob_url": "https://github.com/rust-lang/rust/blob/4f96ca353ec2f48e02efe592dc9d7ebaa1e66f60/clippy_lints%2Fsrc%2Fonly_used_in_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f96ca353ec2f48e02efe592dc9d7ebaa1e66f60/clippy_lints%2Fsrc%2Fonly_used_in_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fonly_used_in_recursion.rs?ref=4f96ca353ec2f48e02efe592dc9d7ebaa1e66f60", "patch": "@@ -0,0 +1,563 @@\n+use std::collections::VecDeque;\n+\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use itertools::{izip, Itertools};\n+use rustc_ast::{walk_list, Label, Mutability};\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_errors::Applicability;\n+use rustc_hir::def::Res;\n+use rustc_hir::intravisit::{walk_expr, FnKind, Visitor};\n+use rustc_hir::{\n+    Arm, Block, Body, Expr, ExprKind, Guard, HirId, Let, Local, Pat, PatKind, Path, PathSegment, QPath, Stmt, StmtKind,\n+    UnOp,\n+};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty;\n+use rustc_middle::ty::{Ty, TyCtxt, TypeckResults};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::symbol::kw;\n+use rustc_span::symbol::Ident;\n+use rustc_span::Span;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for arguments that is only used in recursion with no side-effects.\n+    /// The arguments can be involved in calculations and assignments but as long as\n+    /// the calculations have no side-effects (function calls or mutating dereference)\n+    /// and the assigned variables are also only in recursion, it is useless.\n+    ///\n+    /// ### Why is this bad?\n+    /// The could contain a useless calculation and can make function simpler.\n+    ///\n+    /// ### Known Issues\n+    /// It could not catch the variable that has no side effects but only used in recursion.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// fn f(a: usize, b: usize) -> usize {\n+    ///     if a == 0 {\n+    ///         1\n+    ///     } else {\n+    ///         f(a - 1, b + 1)\n+    ///     }\n+    /// }\n+    /// # fn main() {\n+    /// #     print!(\"{}\", f(1, 1));\n+    /// # }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// fn f(a: usize) -> usize {\n+    ///     if a == 0 {\n+    ///         1\n+    ///     } else {\n+    ///         f(a - 1)\n+    ///     }\n+    /// }\n+    /// # fn main() {\n+    /// #     print!(\"{}\", f(1));\n+    /// # }\n+    /// ```\n+    #[clippy::version = \"1.60.0\"]\n+    pub ONLY_USED_IN_RECURSION,\n+    complexity,\n+    \"default lint description\"\n+}\n+declare_lint_pass!(OnlyUsedInRecursion => [ONLY_USED_IN_RECURSION]);\n+\n+impl<'tcx> LateLintPass<'tcx> for OnlyUsedInRecursion {\n+    fn check_fn(\n+        &mut self,\n+        cx: &LateContext<'tcx>,\n+        kind: FnKind<'tcx>,\n+        _: &'tcx rustc_hir::FnDecl<'tcx>,\n+        body: &'tcx Body<'tcx>,\n+        _: Span,\n+        _: HirId,\n+    ) {\n+        if let FnKind::ItemFn(ident, ..) | FnKind::Method(ident, ..) = kind {\n+            let ty_res = cx.typeck_results();\n+            let param_span = body\n+                .params\n+                .iter()\n+                .flat_map(|param| {\n+                    let mut v = Vec::new();\n+                    param.pat.each_binding(|_, hir_id, span, ident| {\n+                        v.push((hir_id, span, ident));\n+                    });\n+                    v\n+                })\n+                .skip(match kind {\n+                    FnKind::Method(..) => 1,\n+                    _ => 0,\n+                })\n+                .filter(|(_, _, ident)| !ident.name.as_str().starts_with('_'))\n+                .collect_vec();\n+\n+            let params = body.params.iter().map(|param| param.pat).collect();\n+\n+            let mut visitor = SideEffectVisit {\n+                graph: FxHashMap::default(),\n+                has_side_effect: FxHashSet::default(),\n+                ret_vars: Vec::new(),\n+                contains_side_effect: false,\n+                break_vars: FxHashMap::default(),\n+                params,\n+                fn_ident: ident,\n+                is_method: matches!(kind, FnKind::Method(..)),\n+                ty_res,\n+                ty_ctx: cx.tcx,\n+            };\n+\n+            visitor.visit_expr(&body.value);\n+            let vars = std::mem::take(&mut visitor.ret_vars);\n+            visitor.add_side_effect(vars);\n+\n+            let mut queue = visitor.has_side_effect.iter().copied().collect::<VecDeque<_>>();\n+\n+            while let Some(id) = queue.pop_front() {\n+                if let Some(next) = visitor.graph.get(&id) {\n+                    for i in next {\n+                        if !visitor.has_side_effect.contains(i) {\n+                            visitor.has_side_effect.insert(*i);\n+                            queue.push_back(*i);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            for (id, span, ident) in param_span {\n+                if !visitor.has_side_effect.contains(&id) {\n+                    span_lint_and_sugg(\n+                        cx,\n+                        ONLY_USED_IN_RECURSION,\n+                        span,\n+                        \"parameter is only used in recursion with no side-effects\",\n+                        \"if this is intentional, prefix with an underscore\",\n+                        format!(\"_{}\", ident.name.as_str()),\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+pub fn is_primitive(ty: Ty<'_>) -> bool {\n+    match ty.kind() {\n+        ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Str => true,\n+        ty::Ref(_, t, _) => is_primitive(t),\n+        _ => false,\n+    }\n+}\n+\n+pub fn is_array(ty: Ty<'_>) -> bool {\n+    match ty.kind() {\n+        ty::Array(..) | ty::Slice(..) => true,\n+        ty::Ref(_, t, _) => is_array(t),\n+        _ => false,\n+    }\n+}\n+\n+pub struct SideEffectVisit<'tcx> {\n+    graph: FxHashMap<HirId, FxHashSet<HirId>>,\n+    has_side_effect: FxHashSet<HirId>,\n+    // bool for if the variable was dereferenced from mutable reference\n+    ret_vars: Vec<(HirId, bool)>,\n+    contains_side_effect: bool,\n+    // break label\n+    break_vars: FxHashMap<Ident, Vec<(HirId, bool)>>,\n+    params: Vec<&'tcx Pat<'tcx>>,\n+    fn_ident: Ident,\n+    is_method: bool,\n+    ty_res: &'tcx TypeckResults<'tcx>,\n+    ty_ctx: TyCtxt<'tcx>,\n+}\n+\n+impl<'tcx> Visitor<'tcx> for SideEffectVisit<'tcx> {\n+    fn visit_block(&mut self, b: &'tcx Block<'tcx>) {\n+        b.stmts.iter().for_each(|stmt| {\n+            self.visit_stmt(stmt);\n+            self.ret_vars.clear();\n+        });\n+        walk_list!(self, visit_expr, b.expr);\n+    }\n+\n+    fn visit_stmt(&mut self, s: &'tcx Stmt<'tcx>) {\n+        match s.kind {\n+            StmtKind::Local(Local {\n+                pat, init: Some(init), ..\n+            }) => {\n+                self.visit_pat_expr(pat, init);\n+            },\n+            StmtKind::Item(i) => {\n+                let item = self.ty_ctx.hir().item(i);\n+                self.visit_item(item);\n+            },\n+            StmtKind::Expr(e) | StmtKind::Semi(e) => self.visit_expr(e),\n+            StmtKind::Local(_) => {},\n+        }\n+    }\n+\n+    fn visit_expr(&mut self, ex: &'tcx Expr<'tcx>) {\n+        debug_assert!(self.ret_vars.is_empty());\n+        match ex.kind {\n+            ExprKind::Array(exprs) | ExprKind::Tup(exprs) => {\n+                self.ret_vars = exprs\n+                    .iter()\n+                    .flat_map(|expr| {\n+                        self.visit_expr(expr);\n+                        std::mem::take(&mut self.ret_vars)\n+                    })\n+                    .collect();\n+            },\n+            ExprKind::Call(callee, args) => self.visit_fn(callee, args),\n+            ExprKind::MethodCall(path, args, _) => self.visit_method_call(path, args),\n+            ExprKind::Binary(_, lhs, rhs) => {\n+                self.visit_bin_op(lhs, rhs);\n+            },\n+            ExprKind::Unary(op, expr) => self.visit_un_op(op, expr),\n+            ExprKind::Let(Let { pat, init, .. }) => self.visit_pat_expr(pat, init),\n+            ExprKind::If(bind, then_expr, else_expr) => {\n+                self.visit_if(bind, then_expr, else_expr);\n+            },\n+            ExprKind::Match(expr, arms, _) => self.visit_match(expr, arms),\n+            ExprKind::Closure(_, _, body_id, _, _) => {\n+                let body = self.ty_ctx.hir().body(body_id);\n+                self.visit_body(body);\n+                let vars = std::mem::take(&mut self.ret_vars);\n+                self.add_side_effect(vars);\n+            },\n+            ExprKind::Loop(block, label, _, _) | ExprKind::Block(block, label) => {\n+                self.visit_block_label(block, label);\n+            },\n+            ExprKind::Assign(bind, expr, _) => {\n+                self.visit_assign(bind, expr);\n+            },\n+            ExprKind::AssignOp(_, bind, expr) => {\n+                self.visit_assign(bind, expr);\n+                self.visit_bin_op(bind, expr);\n+            },\n+            ExprKind::Field(expr, _) => {\n+                self.visit_expr(expr);\n+                if matches!(self.ty_res.expr_ty(expr).kind(), ty::Ref(_, _, Mutability::Mut)) {\n+                    self.ret_vars.iter_mut().for_each(|(_, b)| *b = true);\n+                }\n+            },\n+            ExprKind::Index(expr, index) => {\n+                self.visit_expr(expr);\n+                let mut vars = std::mem::take(&mut self.ret_vars);\n+                self.visit_expr(index);\n+                self.ret_vars.append(&mut vars);\n+\n+                if !is_array(self.ty_res.expr_ty(expr)) {\n+                    self.add_side_effect(self.ret_vars.clone());\n+                } else if matches!(self.ty_res.expr_ty(expr).kind(), ty::Ref(_, _, Mutability::Mut)) {\n+                    self.ret_vars.iter_mut().for_each(|(_, b)| *b = true);\n+                }\n+            },\n+            ExprKind::Break(dest, Some(expr)) => {\n+                self.visit_expr(expr);\n+                if let Some(label) = dest.label {\n+                    self.break_vars\n+                        .entry(label.ident)\n+                        .or_insert(Vec::new())\n+                        .append(&mut self.ret_vars);\n+                }\n+                self.contains_side_effect = true;\n+            },\n+            ExprKind::Ret(Some(expr)) => {\n+                self.visit_expr(expr);\n+                let vars = std::mem::take(&mut self.ret_vars);\n+                self.add_side_effect(vars);\n+                self.contains_side_effect = true;\n+            },\n+            ExprKind::Break(_, None) | ExprKind::Continue(_) | ExprKind::Ret(None) => {\n+                self.contains_side_effect = true;\n+            },\n+            ExprKind::Struct(_, exprs, expr) => {\n+                let mut ret_vars = exprs\n+                    .iter()\n+                    .flat_map(|field| {\n+                        self.visit_expr(field.expr);\n+                        std::mem::take(&mut self.ret_vars)\n+                    })\n+                    .collect();\n+\n+                walk_list!(self, visit_expr, expr);\n+                self.ret_vars.append(&mut ret_vars);\n+            },\n+            _ => walk_expr(self, ex),\n+        }\n+    }\n+\n+    fn visit_path(&mut self, path: &'tcx Path<'tcx>, _id: HirId) {\n+        if let Res::Local(id) = path.res {\n+            self.ret_vars.push((id, false));\n+        }\n+    }\n+}\n+\n+impl<'tcx> SideEffectVisit<'tcx> {\n+    fn visit_assign(&mut self, lhs: &'tcx Expr<'tcx>, rhs: &'tcx Expr<'tcx>) {\n+        // Just support array and tuple unwrapping for now.\n+        //\n+        // ex) `(a, b) = (c, d);`\n+        // The graph would look like this:\n+        //   a -> c\n+        //   b -> d\n+        //\n+        // This would minimize the connection of the side-effect graph.\n+        match (&lhs.kind, &rhs.kind) {\n+            (ExprKind::Array(lhs), ExprKind::Array(rhs)) | (ExprKind::Tup(lhs), ExprKind::Tup(rhs)) => {\n+                // if not, it is a compile error\n+                debug_assert!(lhs.len() == rhs.len());\n+                izip!(*lhs, *rhs).for_each(|(lhs, rhs)| self.visit_assign(lhs, rhs));\n+            },\n+            // in other assigns, we have to connect all each other\n+            // because they can be connected somehow\n+            _ => {\n+                self.visit_expr(lhs);\n+                let lhs_vars = std::mem::take(&mut self.ret_vars);\n+                self.visit_expr(rhs);\n+                let rhs_vars = std::mem::take(&mut self.ret_vars);\n+                self.connect_assign(&lhs_vars, &rhs_vars);\n+            },\n+        }\n+    }\n+\n+    fn visit_block_label(&mut self, block: &'tcx Block<'tcx>, label: Option<Label>) {\n+        self.visit_block(block);\n+        let _ = label.and_then(|label| {\n+            self.break_vars\n+                .remove(&label.ident)\n+                .map(|mut break_vars| self.ret_vars.append(&mut break_vars))\n+        });\n+    }\n+\n+    fn visit_bin_op(&mut self, lhs: &'tcx Expr<'tcx>, rhs: &'tcx Expr<'tcx>) {\n+        self.visit_expr(lhs);\n+        let mut ret_vars = std::mem::take(&mut self.ret_vars);\n+        self.visit_expr(rhs);\n+        self.ret_vars.append(&mut ret_vars);\n+        if !is_primitive(self.ty_res.expr_ty(lhs)) || !is_primitive(self.ty_res.expr_ty(rhs)) {\n+            self.ret_vars.iter().for_each(|id| {\n+                self.has_side_effect.insert(id.0);\n+            });\n+            self.contains_side_effect = true;\n+        }\n+    }\n+\n+    fn visit_un_op(&mut self, op: UnOp, expr: &'tcx Expr<'tcx>) {\n+        self.visit_expr(expr);\n+        let ty = self.ty_res.expr_ty(expr);\n+        // dereferencing a reference has no side-effect\n+        if !is_primitive(ty) && !matches!((op, ty.kind()), (UnOp::Deref, ty::Ref(..))) {\n+            self.add_side_effect(self.ret_vars.clone());\n+        }\n+\n+        if matches!((op, ty.kind()), (UnOp::Deref, ty::Ref(_, _, Mutability::Mut))) {\n+            self.ret_vars.iter_mut().for_each(|(_, b)| *b = true);\n+        }\n+    }\n+\n+    fn visit_pat_expr(&mut self, pat: &'tcx Pat<'tcx>, expr: &'tcx Expr<'tcx>) {\n+        match (&pat.kind, &expr.kind) {\n+            (PatKind::Tuple(pats, _), ExprKind::Tup(exprs)) => {\n+                self.ret_vars = izip!(*pats, *exprs)\n+                    .flat_map(|(pat, expr)| {\n+                        self.visit_pat_expr(pat, expr);\n+                        std::mem::take(&mut self.ret_vars)\n+                    })\n+                    .collect();\n+            },\n+            (PatKind::Slice(front_exprs, _, back_exprs), ExprKind::Array(exprs)) => {\n+                let mut vars = izip!(*front_exprs, *exprs)\n+                    .flat_map(|(pat, expr)| {\n+                        self.visit_pat_expr(pat, expr);\n+                        std::mem::take(&mut self.ret_vars)\n+                    })\n+                    .collect();\n+                self.ret_vars = izip!(back_exprs.iter().rev(), exprs.iter().rev())\n+                    .flat_map(|(pat, expr)| {\n+                        self.visit_pat_expr(pat, expr);\n+                        std::mem::take(&mut self.ret_vars)\n+                    })\n+                    .collect();\n+                self.ret_vars.append(&mut vars);\n+            },\n+            _ => {\n+                let mut lhs_vars = Vec::new();\n+                pat.each_binding(|_, id, _, _| lhs_vars.push((id, false)));\n+                self.visit_expr(expr);\n+                let rhs_vars = std::mem::take(&mut self.ret_vars);\n+                self.connect_assign(&lhs_vars, &rhs_vars);\n+                self.ret_vars = rhs_vars;\n+            },\n+        }\n+    }\n+\n+    fn visit_fn(&mut self, callee: &'tcx Expr<'tcx>, args: &'tcx [Expr<'tcx>]) {\n+        self.visit_expr(callee);\n+        let mut ret_vars = std::mem::take(&mut self.ret_vars);\n+        self.add_side_effect(ret_vars.clone());\n+\n+        if_chain! {\n+            if !self.is_method;\n+            if let ExprKind::Path(QPath::Resolved(_, path)) = callee.kind;\n+            if let Res::Def(..) = path.res;\n+            if path.segments.len() == 1;\n+            let ident = path.segments.last().unwrap().ident;\n+            if ident == self.fn_ident;\n+            then {\n+                izip!(self.params.clone(), args)\n+                    .for_each(|(pat, expr)| {\n+                        self.visit_pat_expr(pat, expr);\n+                        self.ret_vars.clear();\n+                    });\n+            } else {\n+                // This would set arguments used in closure that does not have side-effect.\n+                // Closure itself can be detected whether there is a side-effect, but the\n+                // value of variable that is holding closure can change.\n+                // So, we just check the variables.\n+                self.ret_vars = args\n+                    .iter()\n+                    .flat_map(|expr| {\n+                        self.visit_expr(expr);\n+                        std::mem::take(&mut self.ret_vars)\n+                    })\n+                    .collect_vec()\n+                    .into_iter()\n+                    .map(|id| {\n+                        self.has_side_effect.insert(id.0);\n+                        id\n+                    })\n+                    .collect();\n+                self.contains_side_effect = true;\n+            }\n+        }\n+\n+        self.ret_vars.append(&mut ret_vars);\n+    }\n+\n+    fn visit_method_call(&mut self, path: &'tcx PathSegment<'tcx>, args: &'tcx [Expr<'tcx>]) {\n+        if_chain! {\n+            if self.is_method;\n+            if path.ident == self.fn_ident;\n+            if let ExprKind::Path(QPath::Resolved(_, path)) = args.first().unwrap().kind;\n+            if let Res::Local(..) = path.res;\n+            let ident = path.segments.last().unwrap().ident;\n+            if ident.name == kw::SelfLower;\n+            then {\n+                izip!(self.params.clone(), args.iter())\n+                    .for_each(|(pat, expr)| {\n+                        self.visit_pat_expr(pat, expr);\n+                        self.ret_vars.clear();\n+                    });\n+            } else {\n+                self.ret_vars = args\n+                    .iter()\n+                    .flat_map(|expr| {\n+                        self.visit_expr(expr);\n+                        std::mem::take(&mut self.ret_vars)\n+                    })\n+                    .collect_vec()\n+                    .into_iter()\n+                    .map(|a| {\n+                        self.has_side_effect.insert(a.0);\n+                        a\n+                    })\n+                    .collect();\n+                self.contains_side_effect = true;\n+            }\n+        }\n+    }\n+\n+    fn visit_if(&mut self, bind: &'tcx Expr<'tcx>, then_expr: &'tcx Expr<'tcx>, else_expr: Option<&'tcx Expr<'tcx>>) {\n+        let contains_side_effect = self.contains_side_effect;\n+        self.contains_side_effect = false;\n+        self.visit_expr(bind);\n+        let mut vars = std::mem::take(&mut self.ret_vars);\n+        self.visit_expr(then_expr);\n+        let mut then_vars = std::mem::take(&mut self.ret_vars);\n+        walk_list!(self, visit_expr, else_expr);\n+        if self.contains_side_effect {\n+            self.add_side_effect(vars.clone());\n+        }\n+        self.contains_side_effect |= contains_side_effect;\n+        self.ret_vars.append(&mut vars);\n+        self.ret_vars.append(&mut then_vars);\n+    }\n+\n+    fn visit_match(&mut self, expr: &'tcx Expr<'tcx>, arms: &'tcx [Arm<'tcx>]) {\n+        self.visit_expr(expr);\n+        let mut expr_vars = std::mem::take(&mut self.ret_vars);\n+        self.ret_vars = arms\n+            .iter()\n+            .flat_map(|arm| {\n+                let contains_side_effect = self.contains_side_effect;\n+                self.contains_side_effect = false;\n+                // this would visit `expr` multiple times\n+                // but couldn't think of a better way\n+                self.visit_pat_expr(arm.pat, expr);\n+                let mut vars = std::mem::take(&mut self.ret_vars);\n+                let _ = arm.guard.as_ref().map(|guard| {\n+                    self.visit_expr(match guard {\n+                        Guard::If(expr) | Guard::IfLet(_, expr) => expr,\n+                    });\n+                    vars.append(&mut self.ret_vars);\n+                });\n+                self.visit_expr(arm.body);\n+                if self.contains_side_effect {\n+                    self.add_side_effect(vars.clone());\n+                    self.add_side_effect(expr_vars.clone());\n+                }\n+                self.contains_side_effect |= contains_side_effect;\n+                vars.append(&mut self.ret_vars);\n+                vars\n+            })\n+            .collect();\n+        self.ret_vars.append(&mut expr_vars);\n+    }\n+\n+    fn connect_assign(&mut self, lhs: &[(HirId, bool)], rhs: &[(HirId, bool)]) {\n+        // if mutable dereference is on assignment it can have side-effect\n+        // (this can lead to parameter mutable dereference and change the original value)\n+        // too hard to detect whether this value is from parameter, so this would all\n+        // check mutable dereference assignment to side effect\n+        lhs.iter().filter(|(_, b)| *b).for_each(|(id, _)| {\n+            self.has_side_effect.insert(*id);\n+            self.contains_side_effect = true;\n+        });\n+\n+        // there is no connection\n+        if lhs.is_empty() || rhs.is_empty() {\n+            return;\n+        }\n+\n+        // by connected rhs in cycle, the connections would decrease\n+        // from `n * m` to `n + m`\n+        // where `n` and `m` are length of `lhs` and `rhs`.\n+\n+        // unwrap is possible since rhs is not empty\n+        let rhs_first = rhs.first().unwrap();\n+        for (id, _) in lhs.iter() {\n+            self.graph\n+                .entry(*id)\n+                .or_insert_with(FxHashSet::default)\n+                .insert(rhs_first.0);\n+        }\n+\n+        let rhs = rhs.iter();\n+        izip!(rhs.clone().cycle().skip(1), rhs).for_each(|(from, to)| {\n+            self.graph.entry(from.0).or_insert_with(FxHashSet::default).insert(to.0);\n+        });\n+    }\n+\n+    fn add_side_effect(&mut self, v: Vec<(HirId, bool)>) {\n+        for (id, _) in v {\n+            self.has_side_effect.insert(id);\n+            self.contains_side_effect = true;\n+        }\n+    }\n+}"}, {"sha": "fbc601becacfd57a63827e779236ec60700a7829", "filename": "clippy_lints/src/unnecessary_sort_by.rs", "status": "modified", "additions": 17, "deletions": 28, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/4f96ca353ec2f48e02efe592dc9d7ebaa1e66f60/clippy_lints%2Fsrc%2Funnecessary_sort_by.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f96ca353ec2f48e02efe592dc9d7ebaa1e66f60/clippy_lints%2Fsrc%2Funnecessary_sort_by.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnecessary_sort_by.rs?ref=4f96ca353ec2f48e02efe592dc9d7ebaa1e66f60", "patch": "@@ -67,59 +67,51 @@ struct SortByKeyDetection {\n \n /// Detect if the two expressions are mirrored (identical, except one\n /// contains a and the other replaces it with b)\n-fn mirrored_exprs(\n-    cx: &LateContext<'_>,\n-    a_expr: &Expr<'_>,\n-    a_ident: &Ident,\n-    b_expr: &Expr<'_>,\n-    b_ident: &Ident,\n-) -> bool {\n+fn mirrored_exprs(a_expr: &Expr<'_>, a_ident: &Ident, b_expr: &Expr<'_>, b_ident: &Ident) -> bool {\n     match (&a_expr.kind, &b_expr.kind) {\n         // Two boxes with mirrored contents\n         (ExprKind::Box(left_expr), ExprKind::Box(right_expr)) => {\n-            mirrored_exprs(cx, left_expr, a_ident, right_expr, b_ident)\n+            mirrored_exprs(left_expr, a_ident, right_expr, b_ident)\n         },\n         // Two arrays with mirrored contents\n         (ExprKind::Array(left_exprs), ExprKind::Array(right_exprs)) => {\n-            iter::zip(*left_exprs, *right_exprs).all(|(left, right)| mirrored_exprs(cx, left, a_ident, right, b_ident))\n+            iter::zip(*left_exprs, *right_exprs).all(|(left, right)| mirrored_exprs(left, a_ident, right, b_ident))\n         },\n         // The two exprs are function calls.\n         // Check to see that the function itself and its arguments are mirrored\n         (ExprKind::Call(left_expr, left_args), ExprKind::Call(right_expr, right_args)) => {\n-            mirrored_exprs(cx, left_expr, a_ident, right_expr, b_ident)\n-                && iter::zip(*left_args, *right_args)\n-                    .all(|(left, right)| mirrored_exprs(cx, left, a_ident, right, b_ident))\n+            mirrored_exprs(left_expr, a_ident, right_expr, b_ident)\n+                && iter::zip(*left_args, *right_args).all(|(left, right)| mirrored_exprs(left, a_ident, right, b_ident))\n         },\n         // The two exprs are method calls.\n         // Check to see that the function is the same and the arguments are mirrored\n         // This is enough because the receiver of the method is listed in the arguments\n         (ExprKind::MethodCall(left_segment, left_args, _), ExprKind::MethodCall(right_segment, right_args, _)) => {\n             left_segment.ident == right_segment.ident\n-                && iter::zip(*left_args, *right_args)\n-                    .all(|(left, right)| mirrored_exprs(cx, left, a_ident, right, b_ident))\n+                && iter::zip(*left_args, *right_args).all(|(left, right)| mirrored_exprs(left, a_ident, right, b_ident))\n         },\n         // Two tuples with mirrored contents\n         (ExprKind::Tup(left_exprs), ExprKind::Tup(right_exprs)) => {\n-            iter::zip(*left_exprs, *right_exprs).all(|(left, right)| mirrored_exprs(cx, left, a_ident, right, b_ident))\n+            iter::zip(*left_exprs, *right_exprs).all(|(left, right)| mirrored_exprs(left, a_ident, right, b_ident))\n         },\n         // Two binary ops, which are the same operation and which have mirrored arguments\n         (ExprKind::Binary(left_op, left_left, left_right), ExprKind::Binary(right_op, right_left, right_right)) => {\n             left_op.node == right_op.node\n-                && mirrored_exprs(cx, left_left, a_ident, right_left, b_ident)\n-                && mirrored_exprs(cx, left_right, a_ident, right_right, b_ident)\n+                && mirrored_exprs(left_left, a_ident, right_left, b_ident)\n+                && mirrored_exprs(left_right, a_ident, right_right, b_ident)\n         },\n         // Two unary ops, which are the same operation and which have the same argument\n         (ExprKind::Unary(left_op, left_expr), ExprKind::Unary(right_op, right_expr)) => {\n-            left_op == right_op && mirrored_exprs(cx, left_expr, a_ident, right_expr, b_ident)\n+            left_op == right_op && mirrored_exprs(left_expr, a_ident, right_expr, b_ident)\n         },\n         // The two exprs are literals of some kind\n         (ExprKind::Lit(left_lit), ExprKind::Lit(right_lit)) => left_lit.node == right_lit.node,\n-        (ExprKind::Cast(left, _), ExprKind::Cast(right, _)) => mirrored_exprs(cx, left, a_ident, right, b_ident),\n+        (ExprKind::Cast(left, _), ExprKind::Cast(right, _)) => mirrored_exprs(left, a_ident, right, b_ident),\n         (ExprKind::DropTemps(left_block), ExprKind::DropTemps(right_block)) => {\n-            mirrored_exprs(cx, left_block, a_ident, right_block, b_ident)\n+            mirrored_exprs(left_block, a_ident, right_block, b_ident)\n         },\n         (ExprKind::Field(left_expr, left_ident), ExprKind::Field(right_expr, right_ident)) => {\n-            left_ident.name == right_ident.name && mirrored_exprs(cx, left_expr, a_ident, right_expr, right_ident)\n+            left_ident.name == right_ident.name && mirrored_exprs(left_expr, a_ident, right_expr, right_ident)\n         },\n         // Two paths: either one is a and the other is b, or they're identical to each other\n         (\n@@ -151,11 +143,9 @@ fn mirrored_exprs(\n         (\n             ExprKind::AddrOf(left_kind, Mutability::Not, left_expr),\n             ExprKind::AddrOf(right_kind, Mutability::Not, right_expr),\n-        ) => left_kind == right_kind && mirrored_exprs(cx, left_expr, a_ident, right_expr, b_ident),\n-        (_, ExprKind::AddrOf(_, Mutability::Not, right_expr)) => {\n-            mirrored_exprs(cx, a_expr, a_ident, right_expr, b_ident)\n-        },\n-        (ExprKind::AddrOf(_, Mutability::Not, left_expr), _) => mirrored_exprs(cx, left_expr, a_ident, b_expr, b_ident),\n+        ) => left_kind == right_kind && mirrored_exprs(left_expr, a_ident, right_expr, b_ident),\n+        (_, ExprKind::AddrOf(_, Mutability::Not, right_expr)) => mirrored_exprs(a_expr, a_ident, right_expr, b_ident),\n+        (ExprKind::AddrOf(_, Mutability::Not, left_expr), _) => mirrored_exprs(left_expr, a_ident, b_expr, b_ident),\n         _ => false,\n     }\n }\n@@ -176,14 +166,13 @@ fn detect_lint(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<LintTrigger> {\n         if method_path.ident.name == sym::cmp;\n         then {\n             let (closure_body, closure_arg, reverse) = if mirrored_exprs(\n-                cx,\n                 left_expr,\n                 left_ident,\n                 right_expr,\n                 right_ident\n             ) {\n                 (Sugg::hir(cx, left_expr, \"..\").to_string(), left_ident.name.to_string(), false)\n-            } else if mirrored_exprs(cx, left_expr, right_ident, right_expr, left_ident) {\n+            } else if mirrored_exprs(left_expr, right_ident, right_expr, left_ident) {\n                 (Sugg::hir(cx, left_expr, \"..\").to_string(), right_ident.name.to_string(), true)\n             } else {\n                 return None;"}, {"sha": "a0c40eb082672bbe4ccc43c862c2f8666daec7f3", "filename": "tests/ui/only_used_in_recursion.rs", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/4f96ca353ec2f48e02efe592dc9d7ebaa1e66f60/tests%2Fui%2Fonly_used_in_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f96ca353ec2f48e02efe592dc9d7ebaa1e66f60/tests%2Fui%2Fonly_used_in_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fonly_used_in_recursion.rs?ref=4f96ca353ec2f48e02efe592dc9d7ebaa1e66f60", "patch": "@@ -0,0 +1,73 @@\n+#![warn(clippy::only_used_in_recursion)]\n+\n+fn simple(a: usize, b: usize) -> usize {\n+    if a == 0 { 1 } else { simple(a - 1, b) }\n+}\n+\n+fn with_calc(a: usize, b: isize) -> usize {\n+    if a == 0 { 1 } else { with_calc(a - 1, -b + 1) }\n+}\n+\n+fn tuple((a, b): (usize, usize)) -> usize {\n+    if a == 0 { 1 } else { tuple((a - 1, b + 1)) }\n+}\n+\n+fn let_tuple(a: usize, b: usize) -> usize {\n+    let (c, d) = (a, b);\n+    if c == 0 { 1 } else { let_tuple(c - 1, d + 1) }\n+}\n+\n+fn array([a, b]: [usize; 2]) -> usize {\n+    if a == 0 { 1 } else { array([a - 1, b + 1]) }\n+}\n+\n+fn index(a: usize, mut b: &[usize], c: usize) -> usize {\n+    if a == 0 { 1 } else { index(a - 1, b, c + b[0]) }\n+}\n+\n+fn break_(a: usize, mut b: usize, mut c: usize) -> usize {\n+    let c = loop {\n+        b += 1;\n+        c += 1;\n+        if c == 10 {\n+            break b;\n+        }\n+    };\n+\n+    if a == 0 { 1 } else { break_(a - 1, c, c) }\n+}\n+\n+// this has a side effect\n+fn mut_ref(a: usize, b: &mut usize) -> usize {\n+    *b = 1;\n+    if a == 0 { 1 } else { mut_ref(a - 1, b) }\n+}\n+\n+fn mut_ref2(a: usize, b: &mut usize) -> usize {\n+    let mut c = *b;\n+    if a == 0 { 1 } else { mut_ref2(a - 1, &mut c) }\n+}\n+\n+fn not_primitive(a: usize, b: String) -> usize {\n+    if a == 0 { 1 } else { not_primitive(a - 1, b) }\n+}\n+\n+// this doesn't have a side effect,\n+// but `String` is not primitive.\n+fn not_primitive_op(a: usize, b: String, c: &str) -> usize {\n+    if a == 1 { 1 } else { not_primitive_op(a, b + c, c) }\n+}\n+\n+struct A;\n+\n+impl A {\n+    fn method(&self, a: usize, b: usize) -> usize {\n+        if a == 0 { 1 } else { self.method(a - 1, b + 1) }\n+    }\n+}\n+\n+fn ignore(a: usize, _: usize) -> usize {\n+    if a == 1 { 1 } else { ignore(a - 1, 0) }\n+}\n+\n+fn main() {}"}, {"sha": "29d2b4034278b7bddf8116ac130627776f740654", "filename": "tests/ui/only_used_in_recursion.stderr", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/4f96ca353ec2f48e02efe592dc9d7ebaa1e66f60/tests%2Fui%2Fonly_used_in_recursion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4f96ca353ec2f48e02efe592dc9d7ebaa1e66f60/tests%2Fui%2Fonly_used_in_recursion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fonly_used_in_recursion.stderr?ref=4f96ca353ec2f48e02efe592dc9d7ebaa1e66f60", "patch": "@@ -0,0 +1,70 @@\n+error: parameter is only used in recursion with no side-effects\n+  --> $DIR/only_used_in_recursion.rs:3:21\n+   |\n+LL | fn simple(a: usize, b: usize) -> usize {\n+   |                     ^ help: if this is intentional, prefix with an underscore: `_b`\n+   |\n+   = note: `-D clippy::only-used-in-recursion` implied by `-D warnings`\n+\n+error: parameter is only used in recursion with no side-effects\n+  --> $DIR/only_used_in_recursion.rs:7:24\n+   |\n+LL | fn with_calc(a: usize, b: isize) -> usize {\n+   |                        ^ help: if this is intentional, prefix with an underscore: `_b`\n+\n+error: parameter is only used in recursion with no side-effects\n+  --> $DIR/only_used_in_recursion.rs:11:14\n+   |\n+LL | fn tuple((a, b): (usize, usize)) -> usize {\n+   |              ^ help: if this is intentional, prefix with an underscore: `_b`\n+\n+error: parameter is only used in recursion with no side-effects\n+  --> $DIR/only_used_in_recursion.rs:15:24\n+   |\n+LL | fn let_tuple(a: usize, b: usize) -> usize {\n+   |                        ^ help: if this is intentional, prefix with an underscore: `_b`\n+\n+error: parameter is only used in recursion with no side-effects\n+  --> $DIR/only_used_in_recursion.rs:20:14\n+   |\n+LL | fn array([a, b]: [usize; 2]) -> usize {\n+   |              ^ help: if this is intentional, prefix with an underscore: `_b`\n+\n+error: parameter is only used in recursion with no side-effects\n+  --> $DIR/only_used_in_recursion.rs:24:20\n+   |\n+LL | fn index(a: usize, mut b: &[usize], c: usize) -> usize {\n+   |                    ^^^^^ help: if this is intentional, prefix with an underscore: `_b`\n+\n+error: parameter is only used in recursion with no side-effects\n+  --> $DIR/only_used_in_recursion.rs:24:37\n+   |\n+LL | fn index(a: usize, mut b: &[usize], c: usize) -> usize {\n+   |                                     ^ help: if this is intentional, prefix with an underscore: `_c`\n+\n+error: parameter is only used in recursion with no side-effects\n+  --> $DIR/only_used_in_recursion.rs:28:21\n+   |\n+LL | fn break_(a: usize, mut b: usize, mut c: usize) -> usize {\n+   |                     ^^^^^ help: if this is intentional, prefix with an underscore: `_b`\n+\n+error: parameter is only used in recursion with no side-effects\n+  --> $DIR/only_used_in_recursion.rs:46:23\n+   |\n+LL | fn mut_ref2(a: usize, b: &mut usize) -> usize {\n+   |                       ^ help: if this is intentional, prefix with an underscore: `_b`\n+\n+error: parameter is only used in recursion with no side-effects\n+  --> $DIR/only_used_in_recursion.rs:51:28\n+   |\n+LL | fn not_primitive(a: usize, b: String) -> usize {\n+   |                            ^ help: if this is intentional, prefix with an underscore: `_b`\n+\n+error: parameter is only used in recursion with no side-effects\n+  --> $DIR/only_used_in_recursion.rs:64:32\n+   |\n+LL |     fn method(&self, a: usize, b: usize) -> usize {\n+   |                                ^ help: if this is intentional, prefix with an underscore: `_b`\n+\n+error: aborting due to 11 previous errors\n+"}]}