{"sha": "4eaf05c4ec1172203362637e743bbbf31e6a0be6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlYWYwNWM0ZWMxMTcyMjAzMzYyNjM3ZTc0M2JiYmYzMWU2YTBiZTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-09T10:06:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-09T10:06:04Z"}, "message": "Auto merge of #1404 - RalfJung:cargo-miri-host-detect, r=RalfJung\n\nre-do cargo-miri host/target detection logic to match rustbuild\n\n@oli-obk I think that's better than looking at `--emit` like we did before... what do you think?", "tree": {"sha": "02729ecae5a42c7aab23a5dcdf4c221923c103ab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/02729ecae5a42c7aab23a5dcdf4c221923c103ab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4eaf05c4ec1172203362637e743bbbf31e6a0be6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4eaf05c4ec1172203362637e743bbbf31e6a0be6", "html_url": "https://github.com/rust-lang/rust/commit/4eaf05c4ec1172203362637e743bbbf31e6a0be6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4eaf05c4ec1172203362637e743bbbf31e6a0be6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "17f740e9d325f97a82db659279186c780a40b8c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/17f740e9d325f97a82db659279186c780a40b8c3", "html_url": "https://github.com/rust-lang/rust/commit/17f740e9d325f97a82db659279186c780a40b8c3"}, {"sha": "024cc435f4e19e2d34f8e2099f8da1fb2bf1b952", "url": "https://api.github.com/repos/rust-lang/rust/commits/024cc435f4e19e2d34f8e2099f8da1fb2bf1b952", "html_url": "https://github.com/rust-lang/rust/commit/024cc435f4e19e2d34f8e2099f8da1fb2bf1b952"}], "stats": {"total": 91, "additions": 48, "deletions": 43}, "files": [{"sha": "37ab41b317db5106e6af287449fe4d33f0d99593", "filename": "src/bin/cargo-miri.rs", "status": "modified", "additions": 43, "deletions": 39, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/4eaf05c4ec1172203362637e743bbbf31e6a0be6/src%2Fbin%2Fcargo-miri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eaf05c4ec1172203362637e743bbbf31e6a0be6/src%2Fbin%2Fcargo-miri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fcargo-miri.rs?ref=4eaf05c4ec1172203362637e743bbbf31e6a0be6", "patch": "@@ -6,6 +6,7 @@ use std::io::{self, BufRead, Write};\n use std::ops::Not;\n use std::path::{Path, PathBuf};\n use std::process::Command;\n+use std::ffi::OsString;\n \n const XARGO_MIN_VERSION: (u32, u32, u32) = (0, 3, 20);\n \n@@ -85,29 +86,23 @@ fn get_arg_flag_value(name: &str) -> Option<String> {\n     }\n }\n \n-/// Returns the path to the `miri` binary\n-fn find_miri() -> PathBuf {\n+/// Returns a command for the right `miri` binary.\n+fn miri() -> Command {\n     let mut path = std::env::current_exe().expect(\"current executable path invalid\");\n     path.set_file_name(\"miri\");\n-    path\n+    Command::new(path)\n }\n \n fn cargo() -> Command {\n-    if let Ok(val) = std::env::var(\"CARGO\") {\n-        // Bootstrap tells us where to find cargo\n-        Command::new(val)\n-    } else {\n-        Command::new(\"cargo\")\n-    }\n+    Command::new(env::var_os(\"CARGO\").unwrap_or_else(|| OsString::from(\"cargo\")))\n }\n \n fn xargo_check() -> Command {\n-    if let Ok(val) = std::env::var(\"XARGO_CHECK\") {\n-        // Bootstrap tells us where to find xargo\n-        Command::new(val)\n-    } else {\n-        Command::new(\"xargo-check\")\n-    }\n+    Command::new(env::var_os(\"XARGO_CHECK\").unwrap_or_else(|| OsString::from(\"xargo-check\")))\n+}\n+\n+fn rustc() -> Command {\n+    Command::new(env::var_os(\"RUSTC\").unwrap_or_else(|| OsString::from(\"rustc\")))\n }\n \n fn list_targets() -> impl Iterator<Item = cargo_metadata::Target> {\n@@ -188,8 +183,8 @@ fn test_sysroot_consistency() {\n         return;\n     }\n \n-    let rustc_sysroot = get_sysroot(Command::new(\"rustc\"));\n-    let miri_sysroot = get_sysroot(Command::new(find_miri()));\n+    let rustc_sysroot = get_sysroot(rustc());\n+    let miri_sysroot = get_sysroot(miri());\n \n     if rustc_sysroot != miri_sysroot {\n         show_error(format!(\n@@ -274,7 +269,7 @@ fn ask_to_run(mut cmd: Command, ask: bool, text: &str) {\n /// `MIRI_SYSROOT`. Skipped if `MIRI_SYSROOT` is already set, in which case we expect the user has\n /// done all this already.\n fn setup(subcommand: MiriCommand) {\n-    if std::env::var(\"MIRI_SYSROOT\").is_ok() {\n+    if std::env::var_os(\"MIRI_SYSROOT\").is_some() {\n         if subcommand == MiriCommand::Setup {\n             println!(\"WARNING: MIRI_SYSROOT already set, not doing anything.\")\n         }\n@@ -287,7 +282,7 @@ fn setup(subcommand: MiriCommand) {\n \n     // First, we need xargo.\n     if xargo_version().map_or(true, |v| v < XARGO_MIN_VERSION) {\n-        if std::env::var(\"XARGO_CHECK\").is_ok() {\n+        if std::env::var_os(\"XARGO_CHECK\").is_some() {\n             // The user manually gave us a xargo binary; don't do anything automatically.\n             show_error(format!(\"Your xargo is too old; please upgrade to the latest version\"))\n         }\n@@ -297,11 +292,11 @@ fn setup(subcommand: MiriCommand) {\n     }\n \n     // Determine where the rust sources are located.  `XARGO_RUST_SRC` env var trumps everything.\n-    let rust_src = match std::env::var(\"XARGO_RUST_SRC\") {\n-        Ok(val) => PathBuf::from(val),\n-        Err(_) => {\n+    let rust_src = match std::env::var_os(\"XARGO_RUST_SRC\") {\n+        Some(val) => PathBuf::from(val),\n+        None => {\n             // Check for `rust-src` rustup component.\n-            let sysroot = Command::new(\"rustc\")\n+            let sysroot = rustc()\n                 .args(&[\"--print\", \"sysroot\"])\n                 .output()\n                 .expect(\"failed to get rustc sysroot\")\n@@ -462,6 +457,14 @@ fn in_cargo_miri() {\n             }\n             cmd.arg(arg);\n         }\n+        // We want to always run `cargo` with `--target`. This later helps us detect\n+        // which crates are proc-macro/build-script (host crates) and which crates are\n+        // needed for the program itself.\n+        if get_arg_flag_value(\"--target\").is_none() {\n+            // When no `--target` is given, default to the host.\n+            cmd.arg(\"--target\");\n+            cmd.arg(rustc_version::version_meta().unwrap().host);\n+        }\n \n         // Serialize the remaining args into a special environemt variable.\n         // This will be read by `inside_cargo_rustc` when we go to invoke\n@@ -491,24 +494,22 @@ fn in_cargo_miri() {\n }\n \n fn inside_cargo_rustc() {\n-    /// Determines if we are being invoked (as rustc) to build a runnable\n-    /// executable. We run \"cargo check\", so this should only happen when\n-    /// we are trying to compile a build script or build script dependency,\n-    /// which actually needs to be executed on the host platform.\n+    /// Determines if we are being invoked (as rustc) to build a crate for\n+    /// the \"target\" architecture, in contrast to the \"host\" architecture.\n+    /// Host crates are for build scripts and proc macros and still need to\n+    /// be built like normal; target crates need to be built for or interpreted\n+    /// by Miri.\n     ///\n-    /// Currently, we detect this by checking for \"--emit=link\",\n-    /// which indicates that Cargo instruced rustc to output\n-    /// a native object.\n+    /// Currently, we detect this by checking for \"--target=\", which is\n+    /// never set for host crates. This matches what rustc bootstrap does,\n+    /// which hopefully makes it \"reliable enough\". This relies on us always\n+    /// invoking cargo itself with `--target`, which `in_cargo_miri` ensures.\n     fn is_target_crate() -> bool {\n-        // `--emit` is sometimes missing, e.g. cargo calls rustc for \"--print\".\n-        // That is definitely not a target crate.\n-        // If `--emit` is present, then host crates are built (\"--emit=link,...),\n-        // while the rest is only checked.\n-        get_arg_flag_value(\"--emit\").map_or(false, |emit| !emit.contains(\"link\"))\n+        get_arg_flag_value(\"--target\").is_some()\n     }\n \n     /// Returns whether or not Cargo invoked the wrapper (this binary) to compile\n-    /// the final, target crate (either a test for 'cargo test', or a binary for 'cargo run')\n+    /// the final, binary crate (either a test for 'cargo test', or a binary for 'cargo run')\n     /// Cargo does not give us this information directly, so we need to check\n     /// various command-line flags.\n     fn is_runnable_crate() -> bool {\n@@ -521,7 +522,7 @@ fn inside_cargo_rustc() {\n         is_bin || is_test\n     }\n \n-    let verbose = std::env::var(\"MIRI_VERBOSE\").is_ok();\n+    let verbose = std::env::var_os(\"MIRI_VERBOSE\").is_some();\n     let target_crate = is_target_crate();\n \n     // Figure out which arguments we need to pass.\n@@ -530,6 +531,7 @@ fn inside_cargo_rustc() {\n     // other args for target crates - that is, crates which are ultimately\n     // going to get interpreted by Miri.\n     if target_crate {\n+        // FIXME: breaks for non-UTF-8 sysroots (use `var_os` instead).\n         let sysroot =\n             std::env::var(\"MIRI_SYSROOT\").expect(\"The wrapper should have set MIRI_SYSROOT\");\n         args.push(\"--sysroot\".to_owned());\n@@ -544,14 +546,16 @@ fn inside_cargo_rustc() {\n         // we want to interpret under Miri. We deserialize the user-provided arguments\n         // from the special environment variable \"MIRI_ARGS\", and feed them\n         // to the 'miri' binary.\n+        //\n+        // `env::var` is okay here, well-formed JSON is always UTF-8.\n         let magic = std::env::var(\"MIRI_ARGS\").expect(\"missing MIRI_ARGS\");\n         let mut user_args: Vec<String> =\n             serde_json::from_str(&magic).expect(\"failed to deserialize MIRI_ARGS\");\n         args.append(&mut user_args);\n         // Run this in Miri.\n-        Command::new(find_miri())\n+        miri()\n     } else {\n-        Command::new(\"rustc\")\n+        rustc()\n     };\n \n     // Run it."}, {"sha": "31f78aa9895afd185710448be33371062e41d71e", "filename": "src/bin/miri.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4eaf05c4ec1172203362637e743bbbf31e6a0be6/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eaf05c4ec1172203362637e743bbbf31e6a0be6/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=4eaf05c4ec1172203362637e743bbbf31e6a0be6", "patch": "@@ -61,16 +61,17 @@ fn init_early_loggers() {\n     // If it is not set, we avoid initializing now so that we can initialize\n     // later with our custom settings, and *not* log anything for what happens before\n     // `miri` gets started.\n-    if env::var(\"RUSTC_LOG\").is_ok() {\n+    if env::var_os(\"RUSTC_LOG\").is_some() {\n         rustc_driver::init_rustc_env_logger();\n     }\n }\n \n fn init_late_loggers(tcx: TyCtxt<'_>) {\n     // We initialize loggers right before we start evaluation. We overwrite the `RUSTC_LOG`\n     // env var if it is not set, control it based on `MIRI_LOG`.\n+    // (FIXE: use `var_os`, but then we need to manually concatenate instead of `format!`.)\n     if let Ok(var) = env::var(\"MIRI_LOG\") {\n-        if env::var(\"RUSTC_LOG\").is_err() {\n+        if env::var_os(\"RUSTC_LOG\").is_none() {\n             // We try to be a bit clever here: if `MIRI_LOG` is just a single level\n             // used for everything, we only apply it to the parts of rustc that are\n             // CTFE-related. Otherwise, we use it verbatim for `RUSTC_LOG`.\n@@ -90,8 +91,8 @@ fn init_late_loggers(tcx: TyCtxt<'_>) {\n \n     // If `MIRI_BACKTRACE` is set and `RUSTC_CTFE_BACKTRACE` is not, set `RUSTC_CTFE_BACKTRACE`.\n     // Do this late, so we ideally only apply this to Miri's errors.\n-    if let Ok(val) = env::var(\"MIRI_BACKTRACE\") {\n-        let ctfe_backtrace = match &*val {\n+    if let Some(val) = env::var_os(\"MIRI_BACKTRACE\") {\n+        let ctfe_backtrace = match &*val.to_string_lossy() {\n             \"immediate\" => CtfeBacktrace::Immediate,\n             \"0\" => CtfeBacktrace::Disabled,\n             _ => CtfeBacktrace::Capture,"}]}