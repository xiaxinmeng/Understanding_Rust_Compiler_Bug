{"sha": "397641f3bd4f4211d0a1e9ada8d477bf495735b2", "node_id": "C_kwDOAAsO6NoAKDM5NzY0MWYzYmQ0ZjQyMTFkMGExZTlhZGE4ZDQ3N2JmNDk1NzM1YjI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-09T15:37:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-09T15:37:22Z"}, "message": "Auto merge of #112465 - GuillaumeGomez:rollup-gyh5buc, r=GuillaumeGomez\n\nRollup of 3 pull requests\n\nSuccessful merges:\n\n - #112260 (Improve document of `unsafe_code` lint)\n - #112429 ([rustdoc] List matching impls on type aliases)\n - #112442 (Deduplicate identical region constraints in new solver)\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "3e950c94237c0536a7dd83019c953df48aeba7e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e950c94237c0536a7dd83019c953df48aeba7e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/397641f3bd4f4211d0a1e9ada8d477bf495735b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/397641f3bd4f4211d0a1e9ada8d477bf495735b2", "html_url": "https://github.com/rust-lang/rust/commit/397641f3bd4f4211d0a1e9ada8d477bf495735b2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/397641f3bd4f4211d0a1e9ada8d477bf495735b2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d7ad9d9797e595e9daed98c291a8eb6e4be838ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7ad9d9797e595e9daed98c291a8eb6e4be838ff", "html_url": "https://github.com/rust-lang/rust/commit/d7ad9d9797e595e9daed98c291a8eb6e4be838ff"}, {"sha": "4ef72570189401dee5b148fd423b36cfd37fa3f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ef72570189401dee5b148fd423b36cfd37fa3f7", "html_url": "https://github.com/rust-lang/rust/commit/4ef72570189401dee5b148fd423b36cfd37fa3f7"}], "stats": {"total": 274, "additions": 232, "deletions": 42}, "files": [{"sha": "ff2989112af1a9ee949a5507d312662f4161ad48", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/397641f3bd4f4211d0a1e9ada8d477bf495735b2/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/397641f3bd4f4211d0a1e9ada8d477bf495735b2/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=397641f3bd4f4211d0a1e9ada8d477bf495735b2", "patch": "@@ -286,7 +286,9 @@ impl<'tcx> LateLintPass<'tcx> for NonShorthandFieldPatterns {\n }\n \n declare_lint! {\n-    /// The `unsafe_code` lint catches usage of `unsafe` code.\n+    /// The `unsafe_code` lint catches usage of `unsafe` code and other\n+    /// potentially unsound constructs like `no_mangle`, `export_name`,\n+    /// and `link_section`.\n     ///\n     /// ### Example\n     ///\n@@ -297,17 +299,29 @@ declare_lint! {\n     ///\n     ///     }\n     /// }\n+    ///\n+    /// #[no_mangle]\n+    /// fn func_0() { }\n+    ///\n+    /// #[export_name = \"exported_symbol_name\"]\n+    /// pub fn name_in_rust() { }\n+    ///\n+    /// #[no_mangle]\n+    /// #[link_section = \".example_section\"]\n+    /// pub static VAR1: u32 = 1;\n     /// ```\n     ///\n     /// {{produces}}\n     ///\n     /// ### Explanation\n     ///\n-    /// This lint is intended to restrict the usage of `unsafe`, which can be\n-    /// difficult to use correctly.\n+    /// This lint is intended to restrict the usage of `unsafe` blocks and other\n+    /// constructs (including, but not limited to `no_mangle`, `link_section`\n+    /// and `export_name` attributes) wrong usage of which causes undefined\n+    /// behavior.\n     UNSAFE_CODE,\n     Allow,\n-    \"usage of `unsafe` code\"\n+    \"usage of `unsafe` code and other potentially unsound constructs\"\n }\n \n declare_lint_pass!(UnsafeCode => [UNSAFE_CODE]);"}, {"sha": "72b3c3d01804aa928f9bd8b42020824372279dcb", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt/canonical.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/397641f3bd4f4211d0a1e9ada8d477bf495735b2/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/397641f3bd4f4211d0a1e9ada8d477bf495735b2/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt%2Fcanonical.rs?ref=397641f3bd4f4211d0a1e9ada8d477bf495735b2", "patch": "@@ -11,6 +11,7 @@\n use super::{CanonicalInput, Certainty, EvalCtxt, Goal};\n use crate::solve::canonicalize::{CanonicalizeMode, Canonicalizer};\n use crate::solve::{CanonicalResponse, QueryResult, Response};\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_index::IndexVec;\n use rustc_infer::infer::canonical::query_response::make_query_region_constraints;\n use rustc_infer::infer::canonical::CanonicalVarValues;\n@@ -147,7 +148,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         // Cannot use `take_registered_region_obligations` as we may compute the response\n         // inside of a `probe` whenever we have multiple choices inside of the solver.\n         let region_obligations = self.infcx.inner.borrow().region_obligations().to_owned();\n-        let region_constraints = self.infcx.with_region_constraints(|region_constraints| {\n+        let mut region_constraints = self.infcx.with_region_constraints(|region_constraints| {\n             make_query_region_constraints(\n                 self.tcx(),\n                 region_obligations\n@@ -157,6 +158,9 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             )\n         });\n \n+        let mut seen = FxHashSet::default();\n+        region_constraints.outlives.retain(|outlives| seen.insert(*outlives));\n+\n         let mut opaque_types = self.infcx.clone_opaque_types_for_query_response();\n         // Only return opaque type keys for newly-defined opaques\n         opaque_types.retain(|(a, _)| {"}, {"sha": "e753647ff786821584c8dfccf4604b930c55565d", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/397641f3bd4f4211d0a1e9ada8d477bf495735b2/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/397641f3bd4f4211d0a1e9ada8d477bf495735b2/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=397641f3bd4f4211d0a1e9ada8d477bf495735b2", "patch": "@@ -106,7 +106,7 @@ impl<T: ?Sized> *mut T {\n     /// with [`cast_mut`] on `*const T` and may have documentation value if used instead of implicit\n     /// coercion.\n     ///\n-    /// [`cast_mut`]: #method.cast_mut\n+    /// [`cast_mut`]: pointer::cast_mut\n     #[stable(feature = \"ptr_const_cast\", since = \"1.65.0\")]\n     #[rustc_const_stable(feature = \"ptr_const_cast\", since = \"1.65.0\")]\n     #[inline(always)]\n@@ -117,7 +117,7 @@ impl<T: ?Sized> *mut T {\n     /// Casts a pointer to its raw bits.\n     ///\n     /// This is equivalent to `as usize`, but is more specific to enhance readability.\n-    /// The inverse method is [`from_bits`](#method.from_bits-1).\n+    /// The inverse method is [`from_bits`](pointer#method.from_bits-1).\n     ///\n     /// In particular, `*p as usize` and `p as usize` will both compile for\n     /// pointers to numeric types but do very different things, so using this\n@@ -153,7 +153,7 @@ impl<T: ?Sized> *mut T {\n     /// Creates a pointer from its raw bits.\n     ///\n     /// This is equivalent to `as *mut T`, but is more specific to enhance readability.\n-    /// The inverse method is [`to_bits`](#method.to_bits-1).\n+    /// The inverse method is [`to_bits`](pointer#method.to_bits-1).\n     ///\n     /// # Examples\n     ///\n@@ -303,7 +303,7 @@ impl<T: ?Sized> *mut T {\n     ///\n     /// For the mutable counterpart see [`as_mut`].\n     ///\n-    /// [`as_uninit_ref`]: #method.as_uninit_ref-1\n+    /// [`as_uninit_ref`]: pointer#method.as_uninit_ref-1\n     /// [`as_mut`]: #method.as_mut\n     ///\n     /// # Safety\n@@ -369,7 +369,7 @@ impl<T: ?Sized> *mut T {\n     ///\n     /// For the mutable counterpart see [`as_uninit_mut`].\n     ///\n-    /// [`as_ref`]: #method.as_ref-1\n+    /// [`as_ref`]: pointer#method.as_ref-1\n     /// [`as_uninit_mut`]: #method.as_uninit_mut\n     ///\n     /// # Safety\n@@ -624,7 +624,7 @@ impl<T: ?Sized> *mut T {\n     /// For the shared counterpart see [`as_ref`].\n     ///\n     /// [`as_uninit_mut`]: #method.as_uninit_mut\n-    /// [`as_ref`]: #method.as_ref-1\n+    /// [`as_ref`]: pointer#method.as_ref-1\n     ///\n     /// # Safety\n     ///\n@@ -689,7 +689,7 @@ impl<T: ?Sized> *mut T {\n     /// For the shared counterpart see [`as_uninit_ref`].\n     ///\n     /// [`as_mut`]: #method.as_mut\n-    /// [`as_uninit_ref`]: #method.as_uninit_ref-1\n+    /// [`as_uninit_ref`]: pointer#method.as_uninit_ref-1\n     ///\n     /// # Safety\n     ///\n@@ -779,7 +779,7 @@ impl<T: ?Sized> *mut T {\n     ///\n     /// This function is the inverse of [`offset`].\n     ///\n-    /// [`offset`]: #method.offset-1\n+    /// [`offset`]: pointer#method.offset-1\n     ///\n     /// # Safety\n     ///\n@@ -2051,7 +2051,7 @@ impl<T> *mut [T] {\n     ///\n     /// For the mutable counterpart see [`as_uninit_slice_mut`].\n     ///\n-    /// [`as_ref`]: #method.as_ref-1\n+    /// [`as_ref`]: pointer#method.as_ref-1\n     /// [`as_uninit_slice_mut`]: #method.as_uninit_slice_mut\n     ///\n     /// # Safety"}, {"sha": "baffee0964da9c7e1ea6ff135ef608ede39dfeea", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 78, "deletions": 12, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/397641f3bd4f4211d0a1e9ada8d477bf495735b2/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/397641f3bd4f4211d0a1e9ada8d477bf495735b2/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=397641f3bd4f4211d0a1e9ada8d477bf495735b2", "patch": "@@ -53,12 +53,15 @@ use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir::def_id::{DefId, DefIdSet};\n use rustc_hir::Mutability;\n+use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_infer::traits::{Obligation, ObligationCause};\n use rustc_middle::middle::stability;\n-use rustc_middle::ty::TyCtxt;\n+use rustc_middle::ty::{ParamEnv, TyCtxt};\n use rustc_span::{\n     symbol::{sym, Symbol},\n     BytePos, FileName, RealFileName,\n };\n+use rustc_trait_selection::traits::ObligationCtxt;\n use serde::ser::{SerializeMap, SerializeSeq};\n use serde::{Serialize, Serializer};\n \n@@ -1112,28 +1115,76 @@ fn render_assoc_items<'a, 'cx: 'a>(\n     containing_item: &'a clean::Item,\n     it: DefId,\n     what: AssocItemRender<'a>,\n+    aliased_type: Option<DefId>,\n ) -> impl fmt::Display + 'a + Captures<'cx> {\n     let mut derefs = DefIdSet::default();\n     derefs.insert(it);\n     display_fn(move |f| {\n-        render_assoc_items_inner(f, cx, containing_item, it, what, &mut derefs);\n+        render_assoc_items_inner(f, cx, containing_item, it, what, &mut derefs, aliased_type);\n         Ok(())\n     })\n }\n \n+/// Check whether `impl_def_id` may apply to *some instantiation* of `item_def_id`.\n+fn is_valid_impl_for(tcx: TyCtxt<'_>, item_def_id: DefId, impl_def_id: DefId) -> bool {\n+    let infcx = tcx.infer_ctxt().intercrate(true).build();\n+    let ocx = ObligationCtxt::new(&infcx);\n+    let param_env = ParamEnv::empty();\n+\n+    let alias_substs = infcx.fresh_substs_for_item(rustc_span::DUMMY_SP, item_def_id);\n+    let alias_ty = tcx.type_of(item_def_id).subst(tcx, alias_substs);\n+    let alias_bounds = tcx.predicates_of(item_def_id).instantiate(tcx, alias_substs);\n+\n+    let impl_substs = infcx.fresh_substs_for_item(rustc_span::DUMMY_SP, impl_def_id);\n+    let impl_self_ty = tcx.type_of(impl_def_id).subst(tcx, impl_substs);\n+    let impl_bounds = tcx.predicates_of(impl_def_id).instantiate(tcx, impl_substs);\n+\n+    if ocx.eq(&ObligationCause::dummy(), param_env, impl_self_ty, alias_ty).is_err() {\n+        return false;\n+    }\n+    ocx.register_obligations(\n+        alias_bounds\n+            .iter()\n+            .chain(impl_bounds)\n+            .map(|(p, _)| Obligation::new(tcx, ObligationCause::dummy(), param_env, p)),\n+    );\n+\n+    let errors = ocx.select_where_possible();\n+    errors.is_empty()\n+}\n+\n+// If `aliased_type` is `Some`, it means `it` is a type alias and `aliased_type` is the \"actual\"\n+// type aliased behind `it`. It is used to check whether or not the implementation of the aliased\n+// type can be displayed on the alias doc page.\n fn render_assoc_items_inner(\n     mut w: &mut dyn fmt::Write,\n     cx: &mut Context<'_>,\n     containing_item: &clean::Item,\n     it: DefId,\n     what: AssocItemRender<'_>,\n     derefs: &mut DefIdSet,\n+    aliased_type: Option<DefId>,\n ) {\n     info!(\"Documenting associated items of {:?}\", containing_item.name);\n     let shared = Rc::clone(&cx.shared);\n     let cache = &shared.cache;\n-    let Some(v) = cache.impls.get(&it) else { return };\n-    let (non_trait, traits): (Vec<_>, _) = v.iter().partition(|i| i.inner_impl().trait_.is_none());\n+    let empty = Vec::new();\n+    let v = match cache.impls.get(&it) {\n+        Some(v) => v,\n+        None => &empty,\n+    };\n+    let v2 = match aliased_type {\n+        Some(aliased_type) => cache.impls.get(&aliased_type).unwrap_or(&empty),\n+        None => &empty,\n+    };\n+    if v.is_empty() && v2.is_empty() {\n+        return;\n+    }\n+    let mut saw_impls = FxHashSet::default();\n+    let (non_trait, traits): (Vec<_>, _) =\n+        v.iter().chain(v2).partition(|i| i.inner_impl().trait_.is_none());\n+    let tcx = cx.tcx();\n+    let is_alias = aliased_type.is_some();\n     if !non_trait.is_empty() {\n         let mut tmp_buf = Buffer::html();\n         let (render_mode, id, class_html) = match what {\n@@ -1165,6 +1216,12 @@ fn render_assoc_items_inner(\n         };\n         let mut impls_buf = Buffer::html();\n         for i in &non_trait {\n+            if !saw_impls.insert(i.def_id()) {\n+                continue;\n+            }\n+            if is_alias && !is_valid_impl_for(tcx, it, i.def_id()) {\n+                continue;\n+            }\n             render_impl(\n                 &mut impls_buf,\n                 cx,\n@@ -1193,9 +1250,14 @@ fn render_assoc_items_inner(\n     if !traits.is_empty() {\n         let deref_impl =\n             traits.iter().find(|t| t.trait_did() == cx.tcx().lang_items().deref_trait());\n-        if let Some(impl_) = deref_impl {\n+        if let Some(impl_) = deref_impl &&\n+            (!is_alias || is_valid_impl_for(tcx, it, impl_.def_id()))\n+        {\n             let has_deref_mut =\n-                traits.iter().any(|t| t.trait_did() == cx.tcx().lang_items().deref_mut_trait());\n+                traits.iter().any(|t| {\n+                    t.trait_did() == cx.tcx().lang_items().deref_mut_trait() &&\n+                    (!is_alias || is_valid_impl_for(tcx, it, t.def_id()))\n+                });\n             render_deref_methods(&mut w, cx, impl_, containing_item, has_deref_mut, derefs);\n         }\n \n@@ -1205,10 +1267,14 @@ fn render_assoc_items_inner(\n             return;\n         }\n \n-        let (synthetic, concrete): (Vec<&Impl>, Vec<&Impl>) =\n-            traits.into_iter().partition(|t| t.inner_impl().kind.is_auto());\n-        let (blanket_impl, concrete): (Vec<&Impl>, _) =\n-            concrete.into_iter().partition(|t| t.inner_impl().kind.is_blanket());\n+        let (synthetic, concrete): (Vec<&Impl>, Vec<&Impl>) = traits\n+            .into_iter()\n+            .filter(|t| saw_impls.insert(t.def_id()))\n+            .partition(|t| t.inner_impl().kind.is_auto());\n+        let (blanket_impl, concrete): (Vec<&Impl>, _) = concrete\n+            .into_iter()\n+            .filter(|t| !is_alias || is_valid_impl_for(tcx, it, t.def_id()))\n+            .partition(|t| t.inner_impl().kind.is_blanket());\n \n         render_all_impls(w, cx, containing_item, &concrete, &synthetic, &blanket_impl);\n     }\n@@ -1247,10 +1313,10 @@ fn render_deref_methods(\n                 return;\n             }\n         }\n-        render_assoc_items_inner(&mut w, cx, container_item, did, what, derefs);\n+        render_assoc_items_inner(&mut w, cx, container_item, did, what, derefs, None);\n     } else if let Some(prim) = target.primitive_type() {\n         if let Some(&did) = cache.primitive_locations.get(&prim) {\n-            render_assoc_items_inner(&mut w, cx, container_item, did, what, derefs);\n+            render_assoc_items_inner(&mut w, cx, container_item, did, what, derefs, None);\n         }\n     }\n }"}, {"sha": "01089ed348bfdd3190dc796ebdee37a4d6d4d974", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 32, "deletions": 16, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/397641f3bd4f4211d0a1e9ada8d477bf495735b2/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/397641f3bd4f4211d0a1e9ada8d477bf495735b2/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=397641f3bd4f4211d0a1e9ada8d477bf495735b2", "patch": "@@ -260,7 +260,7 @@ fn item_template_render_assoc_items<'a: 'b, 'b, 'cx: 'a>(\n     display_fn(move |f| {\n         let (item, mut cx) = templ.item_and_mut_cx();\n         let def_id = item.item_id.expect_def_id();\n-        let v = render_assoc_items(*cx, item, def_id, AssocItemRender::All);\n+        let v = render_assoc_items(*cx, item, def_id, AssocItemRender::All, None);\n         write!(f, \"{v}\")\n     })\n }\n@@ -893,7 +893,11 @@ fn item_trait(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean:\n     }\n \n     // If there are methods directly on this trait object, render them here.\n-    write!(w, \"{}\", render_assoc_items(cx, it, it.item_id.expect_def_id(), AssocItemRender::All));\n+    write!(\n+        w,\n+        \"{}\",\n+        render_assoc_items(cx, it, it.item_id.expect_def_id(), AssocItemRender::All, None)\n+    );\n \n     let cloned_shared = Rc::clone(&cx.shared);\n     let cache = &cloned_shared.cache;\n@@ -1125,8 +1129,12 @@ fn item_trait_alias(\n     // won't be visible anywhere in the docs. It would be nice to also show\n     // associated items from the aliased type (see discussion in #32077), but\n     // we need #14072 to make sense of the generics.\n-    write!(w, \"{}\", render_assoc_items(cx, it, it.item_id.expect_def_id(), AssocItemRender::All))\n-        .unwrap();\n+    write!(\n+        w,\n+        \"{}\",\n+        render_assoc_items(cx, it, it.item_id.expect_def_id(), AssocItemRender::All, None)\n+    )\n+    .unwrap();\n }\n \n fn item_opaque_ty(\n@@ -1154,8 +1162,12 @@ fn item_opaque_ty(\n     // won't be visible anywhere in the docs. It would be nice to also show\n     // associated items from the aliased type (see discussion in #32077), but\n     // we need #14072 to make sense of the generics.\n-    write!(w, \"{}\", render_assoc_items(cx, it, it.item_id.expect_def_id(), AssocItemRender::All))\n-        .unwrap();\n+    write!(\n+        w,\n+        \"{}\",\n+        render_assoc_items(cx, it, it.item_id.expect_def_id(), AssocItemRender::All, None)\n+    )\n+    .unwrap();\n }\n \n fn item_typedef(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean::Typedef) {\n@@ -1179,11 +1191,11 @@ fn item_typedef(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clea\n     write!(w, \"{}\", document(cx, it, None, HeadingOffset::H2));\n \n     let def_id = it.item_id.expect_def_id();\n-    // Render any items associated directly to this alias, as otherwise they\n-    // won't be visible anywhere in the docs. It would be nice to also show\n-    // associated items from the aliased type (see discussion in #32077), but\n-    // we need #14072 to make sense of the generics.\n-    write!(w, \"{}\", render_assoc_items(cx, it, def_id, AssocItemRender::All));\n+    write!(\n+        w,\n+        \"{}\",\n+        render_assoc_items(cx, it, def_id, AssocItemRender::All, t.type_.def_id(&cx.cache()))\n+    );\n     write!(w, \"{}\", document_type_layout(cx, def_id));\n }\n \n@@ -1423,7 +1435,7 @@ fn item_enum(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, e: &clean::\n         write!(w, \"</div>\");\n     }\n     let def_id = it.item_id.expect_def_id();\n-    write!(w, \"{}\", render_assoc_items(cx, it, def_id, AssocItemRender::All));\n+    write!(w, \"{}\", render_assoc_items(cx, it, def_id, AssocItemRender::All, None));\n     write!(w, \"{}\", document_type_layout(cx, def_id));\n }\n \n@@ -1466,7 +1478,7 @@ fn item_primitive(w: &mut impl fmt::Write, cx: &mut Context<'_>, it: &clean::Ite\n     let def_id = it.item_id.expect_def_id();\n     write!(w, \"{}\", document(cx, it, None, HeadingOffset::H2)).unwrap();\n     if it.name.map(|n| n.as_str() != \"reference\").unwrap_or(false) {\n-        write!(w, \"{}\", render_assoc_items(cx, it, def_id, AssocItemRender::All)).unwrap();\n+        write!(w, \"{}\", render_assoc_items(cx, it, def_id, AssocItemRender::All, None)).unwrap();\n     } else {\n         // We handle the \"reference\" primitive type on its own because we only want to list\n         // implementations on generic types.\n@@ -1571,7 +1583,7 @@ fn item_struct(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, s: &clean\n         }\n     }\n     let def_id = it.item_id.expect_def_id();\n-    write!(w, \"{}\", render_assoc_items(cx, it, def_id, AssocItemRender::All));\n+    write!(w, \"{}\", render_assoc_items(cx, it, def_id, AssocItemRender::All, None));\n     write!(w, \"{}\", document_type_layout(cx, def_id));\n }\n \n@@ -1606,8 +1618,12 @@ fn item_foreign_type(w: &mut impl fmt::Write, cx: &mut Context<'_>, it: &clean::\n     });\n \n     write!(w, \"{}\", document(cx, it, None, HeadingOffset::H2)).unwrap();\n-    write!(w, \"{}\", render_assoc_items(cx, it, it.item_id.expect_def_id(), AssocItemRender::All))\n-        .unwrap();\n+    write!(\n+        w,\n+        \"{}\",\n+        render_assoc_items(cx, it, it.item_id.expect_def_id(), AssocItemRender::All, None)\n+    )\n+    .unwrap();\n }\n \n fn item_keyword(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item) {"}, {"sha": "555d0579bee79b174570baee4c317f4004f859e4", "filename": "tests/rustdoc/issue-32077-type-alias-impls.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/397641f3bd4f4211d0a1e9ada8d477bf495735b2/tests%2Frustdoc%2Fissue-32077-type-alias-impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/397641f3bd4f4211d0a1e9ada8d477bf495735b2/tests%2Frustdoc%2Fissue-32077-type-alias-impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fissue-32077-type-alias-impls.rs?ref=397641f3bd4f4211d0a1e9ada8d477bf495735b2", "patch": "@@ -0,0 +1,59 @@\n+// Regression test for <https://github.com/rust-lang/rust/issues/32077>.\n+\n+#![crate_name = \"foo\"]\n+\n+pub struct GenericStruct<T>(T);\n+\n+impl<T> GenericStruct<T> {\n+    pub fn on_gen(arg: T) {}\n+}\n+\n+impl GenericStruct<u32> {\n+    pub fn on_u32(arg: u32) {}\n+}\n+\n+pub trait Foo {}\n+pub trait Bar {}\n+\n+impl<T> Foo for GenericStruct<T> {}\n+impl Bar for GenericStruct<u32> {}\n+\n+// @has 'foo/type.TypedefStruct.html'\n+// We check that we have the implementation of the type alias itself.\n+// @has - '//*[@id=\"impl-TypedefStruct\"]/h3' 'impl TypedefStruct'\n+// @has - '//*[@id=\"method.on_alias\"]/h4' 'pub fn on_alias()'\n+// @has - '//*[@id=\"impl-GenericStruct%3CT%3E\"]/h3' 'impl<T> GenericStruct<T>'\n+// @has - '//*[@id=\"method.on_gen\"]/h4' 'pub fn on_gen(arg: T)'\n+// @has - '//*[@id=\"impl-Foo-for-GenericStruct%3CT%3E\"]/h3' 'impl<T> Foo for GenericStruct<T>'\n+// This trait implementation doesn't match the type alias parameters so shouldn't appear in docs.\n+// @!has - '//h3' 'impl Bar for GenericStruct<u32> {}'\n+// Same goes for the `Deref` impl.\n+// @!has - '//h2' 'Methods from Deref<Target = u32>'\n+pub type TypedefStruct = GenericStruct<u8>;\n+\n+impl TypedefStruct {\n+    pub fn on_alias() {}\n+}\n+\n+impl std::ops::Deref for GenericStruct<u32> {\n+    type Target = u32;\n+\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+\n+pub struct Wrap<T>(GenericStruct<T>);\n+\n+// @has 'foo/type.Alias.html'\n+// @has - '//h2' 'Methods from Deref<Target = u32>'\n+// @has - '//*[@id=\"impl-Deref-for-Wrap%3CT%3E\"]/h3' 'impl<T> Deref for Wrap<T>'\n+pub type Alias = Wrap<u32>;\n+\n+impl<T> std::ops::Deref for Wrap<T> {\n+    type Target = GenericStruct<T>;\n+\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}"}, {"sha": "f376f39a5a6624d33aab48b824c0c6a6e85f8f29", "filename": "tests/ui/traits/new-solver/dedup-regions.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/397641f3bd4f4211d0a1e9ada8d477bf495735b2/tests%2Fui%2Ftraits%2Fnew-solver%2Fdedup-regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/397641f3bd4f4211d0a1e9ada8d477bf495735b2/tests%2Fui%2Ftraits%2Fnew-solver%2Fdedup-regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fdedup-regions.rs?ref=397641f3bd4f4211d0a1e9ada8d477bf495735b2", "patch": "@@ -0,0 +1,31 @@\n+// compile-flags: -Ztrait-solver=next\n+// check-pass\n+\n+struct A(*mut ());\n+\n+unsafe impl Send for A where A: 'static {}\n+\n+macro_rules! mk {\n+    ($name:ident $ty:ty) => {\n+        struct $name($ty, $ty, $ty, $ty, $ty, $ty, $ty, $ty, $ty, $ty);\n+    };\n+}\n+\n+mk!(B A);\n+mk!(C B);\n+mk!(D C);\n+mk!(E D);\n+mk!(F E);\n+mk!(G F);\n+mk!(H G);\n+mk!(I H);\n+mk!(J I);\n+mk!(K J);\n+mk!(L K);\n+mk!(M L);\n+\n+fn needs_send<T: Send>() {}\n+\n+fn main() {\n+    needs_send::<M>();\n+}"}]}