{"sha": "750a2d57bde6fca3bbd856410fe4fb54c4c068dc", "node_id": "C_kwDOAAsO6NoAKDc1MGEyZDU3YmRlNmZjYTNiYmQ4NTY0MTBmZTRmYjU0YzRjMDY4ZGM", "commit": {"author": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2022-09-03T15:00:44Z"}, "committer": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2022-09-03T15:00:44Z"}, "message": "Fix `unnecessary_to_owned` false positive\n\nFixes #9351.\n\nNote that this commit reworks that fix for #9317. The change\nis to check that the type implements `AsRef<str>` before regarding\n`to_string` as an equivalent of `to_owned`. This was suggested\nby Jarcho in the #9317 issue comments.\n\nThe benefit of this is that it moves some complexity out of\n`check_other_call_arg` and simplifies the module as a whole.", "tree": {"sha": "2908bbab43b0bb6ac472f00a3a89b807b1615bd8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2908bbab43b0bb6ac472f00a3a89b807b1615bd8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/750a2d57bde6fca3bbd856410fe4fb54c4c068dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/750a2d57bde6fca3bbd856410fe4fb54c4c068dc", "html_url": "https://github.com/rust-lang/rust/commit/750a2d57bde6fca3bbd856410fe4fb54c4c068dc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/750a2d57bde6fca3bbd856410fe4fb54c4c068dc/comments", "author": null, "committer": null, "parents": [{"sha": "99ab5fe53a421e0ae3f1d922442fb994bcfcaf24", "url": "https://api.github.com/repos/rust-lang/rust/commits/99ab5fe53a421e0ae3f1d922442fb994bcfcaf24", "html_url": "https://github.com/rust-lang/rust/commit/99ab5fe53a421e0ae3f1d922442fb994bcfcaf24"}], "stats": {"total": 333, "additions": 262, "deletions": 71}, "files": [{"sha": "d59b26c314423ad53207c77490a14761667275ec", "filename": "clippy_lints/src/methods/unnecessary_to_owned.rs", "status": "modified", "additions": 135, "deletions": 70, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/750a2d57bde6fca3bbd856410fe4fb54c4c068dc/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/750a2d57bde6fca3bbd856410fe4fb54c4c068dc/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs?ref=750a2d57bde6fca3bbd856410fe4fb54c4c068dc", "patch": "@@ -1,21 +1,25 @@\n use super::implicit_clone::is_clone_like;\n use super::unnecessary_iter_cloned::{self, is_into_iter};\n+use crate::rustc_middle::ty::Subst;\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_opt;\n-use clippy_utils::ty::{\n-    get_associated_type, get_iterator_item_ty, implements_trait, is_copy, is_type_diagnostic_item, peel_mid_ty_refs,\n-};\n-use clippy_utils::{fn_def_id, get_parent_expr, is_diag_item_method, is_diag_trait_item};\n+use clippy_utils::ty::{get_associated_type, get_iterator_item_ty, implements_trait, is_copy, peel_mid_ty_refs};\n+use clippy_utils::visitors::find_all_ret_expressions;\n+use clippy_utils::{fn_def_id, get_parent_expr, is_diag_item_method, is_diag_trait_item, return_ty};\n use clippy_utils::{meets_msrv, msrvs};\n use rustc_errors::Applicability;\n-use rustc_hir::{def_id::DefId, BorrowKind, Expr, ExprKind};\n+use rustc_hir::{def_id::DefId, BorrowKind, Expr, ExprKind, ItemKind, Node};\n+use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::LateContext;\n use rustc_middle::mir::Mutability;\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, OverloadedDeref};\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, SubstsRef};\n-use rustc_middle::ty::{self, PredicateKind, ProjectionPredicate, TraitPredicate, Ty};\n+use rustc_middle::ty::EarlyBinder;\n+use rustc_middle::ty::{self, ParamTy, PredicateKind, ProjectionPredicate, TraitPredicate, Ty};\n use rustc_semver::RustcVersion;\n use rustc_span::{sym, Symbol};\n+use rustc_trait_selection::traits::{query::evaluate_obligation::InferCtxtExt as _, Obligation, ObligationCause};\n+use rustc_typeck::check::{FnCtxt, Inherited};\n use std::cmp::max;\n \n use super::UNNECESSARY_TO_OWNED;\n@@ -33,7 +37,7 @@ pub fn check<'tcx>(\n         then {\n             if is_cloned_or_copied(cx, method_name, method_def_id) {\n                 unnecessary_iter_cloned::check(cx, expr, method_name, receiver);\n-            } else if is_to_owned_like(cx, method_name, method_def_id) {\n+            } else if is_to_owned_like(cx, expr, method_name, method_def_id) {\n                 // At this point, we know the call is of a `to_owned`-like function. The functions\n                 // `check_addr_of_expr` and `check_call_arg` determine whether the call is unnecessary\n                 // based on its context, that is, whether it is a referent in an `AddrOf` expression, an\n@@ -245,65 +249,26 @@ fn check_other_call_arg<'tcx>(\n ) -> bool {\n     if_chain! {\n         if let Some((maybe_call, maybe_arg)) = skip_addr_of_ancestors(cx, expr);\n-        if let Some((callee_def_id, call_substs, call_args)) = get_callee_substs_and_args(cx, maybe_call);\n+        if let Some((callee_def_id, _, call_args)) = get_callee_substs_and_args(cx, maybe_call);\n         let fn_sig = cx.tcx.fn_sig(callee_def_id).skip_binder();\n         if let Some(i) = call_args.iter().position(|arg| arg.hir_id == maybe_arg.hir_id);\n         if let Some(input) = fn_sig.inputs().get(i);\n         let (input, n_refs) = peel_mid_ty_refs(*input);\n-        if let (trait_predicates, projection_predicates) = get_input_traits_and_projections(cx, callee_def_id, input);\n+        if let (trait_predicates, _) = get_input_traits_and_projections(cx, callee_def_id, input);\n         if let Some(sized_def_id) = cx.tcx.lang_items().sized_trait();\n         if let [trait_predicate] = trait_predicates\n             .iter()\n             .filter(|trait_predicate| trait_predicate.def_id() != sized_def_id)\n             .collect::<Vec<_>>()[..];\n         if let Some(deref_trait_id) = cx.tcx.get_diagnostic_item(sym::Deref);\n         if let Some(as_ref_trait_id) = cx.tcx.get_diagnostic_item(sym::AsRef);\n+        if trait_predicate.def_id() == deref_trait_id || trait_predicate.def_id() == as_ref_trait_id;\n         let receiver_ty = cx.typeck_results().expr_ty(receiver);\n-        // If the callee has type parameters, they could appear in `projection_predicate.ty` or the\n-        // types of `trait_predicate.trait_ref.substs`.\n-        if if trait_predicate.def_id() == deref_trait_id {\n-            if let [projection_predicate] = projection_predicates[..] {\n-                let normalized_ty =\n-                    cx.tcx\n-                        .subst_and_normalize_erasing_regions(call_substs, cx.param_env, projection_predicate.term);\n-                implements_trait(cx, receiver_ty, deref_trait_id, &[])\n-                    && get_associated_type(cx, receiver_ty, deref_trait_id, \"Target\")\n-                        .map_or(false, |ty| ty::Term::Ty(ty) == normalized_ty)\n-            } else {\n-                false\n-            }\n-        } else if trait_predicate.def_id() == as_ref_trait_id {\n-            let composed_substs = compose_substs(\n-                cx,\n-                &trait_predicate.trait_ref.substs.iter().skip(1).collect::<Vec<_>>()[..],\n-                call_substs,\n-            );\n-            // if `expr` is a `String` and generic target is [u8], skip\n-            // (https://github.com/rust-lang/rust-clippy/issues/9317).\n-            if let [subst] = composed_substs[..]\n-                && let GenericArgKind::Type(arg_ty) = subst.unpack()\n-                && arg_ty.is_slice()\n-                && let inner_ty = arg_ty.builtin_index().unwrap()\n-                && let ty::Uint(ty::UintTy::U8) = inner_ty.kind()\n-                && let self_ty = cx.typeck_results().expr_ty(expr).peel_refs()\n-                && is_type_diagnostic_item(cx, self_ty, sym::String) {\n-                false\n-            } else {\n-                implements_trait(cx, receiver_ty, as_ref_trait_id, &composed_substs)\n-            }\n-        } else {\n-            false\n-        };\n+        if can_change_type(cx, maybe_arg, receiver_ty);\n         // We can't add an `&` when the trait is `Deref` because `Target = &T` won't match\n         // `Target = T`.\n         if n_refs > 0 || is_copy(cx, receiver_ty) || trait_predicate.def_id() != deref_trait_id;\n         let n_refs = max(n_refs, if is_copy(cx, receiver_ty) { 0 } else { 1 });\n-        // If the trait is `AsRef` and the input type variable `T` occurs in the output type, then\n-        // `T` must not be instantiated with a reference\n-        // (https://github.com/rust-lang/rust-clippy/issues/8507).\n-        if (n_refs == 0 && !receiver_ty.is_ref())\n-            || trait_predicate.def_id() != as_ref_trait_id\n-            || !fn_sig.output().contains(input);\n         if let Some(receiver_snippet) = snippet_opt(cx, receiver.span);\n         then {\n             span_lint_and_sugg(\n@@ -389,22 +354,102 @@ fn get_input_traits_and_projections<'tcx>(\n     (trait_predicates, projection_predicates)\n }\n \n-/// Composes two substitutions by applying the latter to the types of the former.\n-fn compose_substs<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    left: &[GenericArg<'tcx>],\n-    right: SubstsRef<'tcx>,\n-) -> Vec<GenericArg<'tcx>> {\n-    left.iter()\n-        .map(|arg| {\n-            if let GenericArgKind::Type(arg_ty) = arg.unpack() {\n-                let normalized_ty = cx.tcx.subst_and_normalize_erasing_regions(right, cx.param_env, arg_ty);\n-                GenericArg::from(normalized_ty)\n-            } else {\n-                *arg\n+fn can_change_type<'a>(cx: &LateContext<'a>, mut expr: &'a Expr<'a>, mut ty: Ty<'a>) -> bool {\n+    for (_, node) in cx.tcx.hir().parent_iter(expr.hir_id) {\n+        match node {\n+            Node::Stmt(_) => return true,\n+            Node::Block(..) => continue,\n+            Node::Item(item) => {\n+                if let ItemKind::Fn(_, _, body_id) = &item.kind\n+                && let output_ty = return_ty(cx, item.hir_id())\n+                && let local_def_id = cx.tcx.hir().local_def_id(item.hir_id())\n+                && Inherited::build(cx.tcx, local_def_id).enter(|inherited| {\n+                    let fn_ctxt = FnCtxt::new(&inherited, cx.param_env, item.hir_id());\n+                    fn_ctxt.can_coerce(ty, output_ty)\n+                }) {\n+                    if has_lifetime(output_ty) && has_lifetime(ty) {\n+                        return false;\n+                    }\n+                    let body = cx.tcx.hir().body(*body_id);\n+                    let body_expr = &body.value;\n+                    let mut count = 0;\n+                    return find_all_ret_expressions(cx, body_expr, |_| { count += 1; count <= 1 });\n+                }\n             }\n-        })\n-        .collect()\n+            Node::Expr(parent_expr) => {\n+                if let Some((callee_def_id, call_substs, call_args)) = get_callee_substs_and_args(cx, parent_expr) {\n+                    let fn_sig = cx.tcx.fn_sig(callee_def_id).skip_binder();\n+                    if let Some(arg_index) = call_args.iter().position(|arg| arg.hir_id == expr.hir_id)\n+                        && let Some(param_ty) = fn_sig.inputs().get(arg_index)\n+                        && let ty::Param(ParamTy { index: param_index , ..}) = param_ty.kind()\n+                    {\n+                        if fn_sig\n+                            .inputs()\n+                            .iter()\n+                            .enumerate()\n+                            .filter(|(i, _)| *i != arg_index)\n+                            .any(|(_, ty)| ty.contains(*param_ty))\n+                        {\n+                            return false;\n+                        }\n+\n+                        let mut trait_predicates = cx.tcx.param_env(callee_def_id)\n+                            .caller_bounds().iter().filter(|predicate| {\n+                            if let PredicateKind::Trait(trait_predicate) =  predicate.kind().skip_binder()\n+                                && trait_predicate.trait_ref.self_ty() == *param_ty {\n+                                    true\n+                                } else {\n+                                false\n+                            }\n+                        });\n+\n+                        let new_subst = cx.tcx.mk_substs(\n+                            call_substs.iter()\n+                                .enumerate()\n+                                .map(|(i, t)|\n+                                     if i == (*param_index as usize) {\n+                                         GenericArg::from(ty)\n+                                     } else {\n+                                         t\n+                                     }));\n+\n+                        if trait_predicates.any(|predicate| {\n+                            let predicate = EarlyBinder(predicate).subst(cx.tcx, new_subst);\n+                            let obligation = Obligation::new(ObligationCause::dummy(), cx.param_env, predicate);\n+                            !cx.tcx\n+                                .infer_ctxt()\n+                                .enter(|infcx| infcx.predicate_must_hold_modulo_regions(&obligation))\n+                        }) {\n+                            return false;\n+                        }\n+\n+                        let output_ty = fn_sig.output();\n+                        if output_ty.contains(*param_ty) {\n+                            if let Ok(new_ty)  = cx.tcx.try_subst_and_normalize_erasing_regions(\n+                                new_subst, cx.param_env, output_ty) {\n+                                expr = parent_expr;\n+                                ty = new_ty;\n+                                continue;\n+                            }\n+                            return false;\n+                        }\n+\n+                        return true;\n+                    }\n+                } else if let ExprKind::Block(..) = parent_expr.kind {\n+                    continue;\n+                }\n+                return false;\n+            },\n+            _ => return false,\n+        }\n+    }\n+\n+    false\n+}\n+\n+fn has_lifetime(ty: Ty<'_>) -> bool {\n+    ty.walk().any(|t| matches!(t.unpack(), GenericArgKind::Lifetime(_)))\n }\n \n /// Returns true if the named method is `Iterator::cloned` or `Iterator::copied`.\n@@ -415,18 +460,38 @@ fn is_cloned_or_copied(cx: &LateContext<'_>, method_name: Symbol, method_def_id:\n \n /// Returns true if the named method can be used to convert the receiver to its \"owned\"\n /// representation.\n-fn is_to_owned_like(cx: &LateContext<'_>, method_name: Symbol, method_def_id: DefId) -> bool {\n+fn is_to_owned_like<'a>(cx: &LateContext<'a>, call_expr: &Expr<'a>, method_name: Symbol, method_def_id: DefId) -> bool {\n     is_clone_like(cx, method_name.as_str(), method_def_id)\n         || is_cow_into_owned(cx, method_name, method_def_id)\n-        || is_to_string(cx, method_name, method_def_id)\n+        || is_to_string_on_string_like(cx, call_expr, method_name, method_def_id)\n }\n \n /// Returns true if the named method is `Cow::into_owned`.\n fn is_cow_into_owned(cx: &LateContext<'_>, method_name: Symbol, method_def_id: DefId) -> bool {\n     method_name.as_str() == \"into_owned\" && is_diag_item_method(cx, method_def_id, sym::Cow)\n }\n \n-/// Returns true if the named method is `ToString::to_string`.\n-fn is_to_string(cx: &LateContext<'_>, method_name: Symbol, method_def_id: DefId) -> bool {\n-    method_name == sym::to_string && is_diag_trait_item(cx, method_def_id, sym::ToString)\n+/// Returns true if the named method is `ToString::to_string` and it's called on a type that\n+/// is string-like i.e. implements `AsRef<str>` or `Deref<str>`.\n+fn is_to_string_on_string_like<'a>(\n+    cx: &LateContext<'_>,\n+    call_expr: &'a Expr<'a>,\n+    method_name: Symbol,\n+    method_def_id: DefId,\n+) -> bool {\n+    if method_name != sym::to_string || !is_diag_trait_item(cx, method_def_id, sym::ToString) {\n+        return false;\n+    }\n+\n+    if let Some(substs) = cx.typeck_results().node_substs_opt(call_expr.hir_id)\n+        && let [generic_arg] = substs.as_slice()\n+        && let GenericArgKind::Type(ty) = generic_arg.unpack()\n+        && let Some(deref_trait_id) = cx.tcx.get_diagnostic_item(sym::Deref)\n+        && let Some(as_ref_trait_id) = cx.tcx.get_diagnostic_item(sym::AsRef)\n+        && (implements_trait(cx, ty, deref_trait_id, &[cx.tcx.types.str_.into()]) ||\n+            implements_trait(cx, ty, as_ref_trait_id, &[cx.tcx.types.str_.into()])) {\n+            true\n+        } else {\n+            false\n+        }\n }"}, {"sha": "a920c63b199c1e194697c33066be47f19c88e78c", "filename": "tests/ui/unnecessary_to_owned.fixed", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/750a2d57bde6fca3bbd856410fe4fb54c4c068dc/tests%2Fui%2Funnecessary_to_owned.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/750a2d57bde6fca3bbd856410fe4fb54c4c068dc/tests%2Fui%2Funnecessary_to_owned.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_to_owned.fixed?ref=750a2d57bde6fca3bbd856410fe4fb54c4c068dc", "patch": "@@ -357,3 +357,63 @@ mod issue_9317 {\n         consume(b.to_string());\n     }\n }\n+\n+mod issue_9351 {\n+    #![allow(dead_code)]\n+\n+    use std::ops::Deref;\n+    use std::path::{Path, PathBuf};\n+\n+    fn require_deref_path<T: Deref<Target = std::path::Path>>(x: T) -> T {\n+        x\n+    }\n+\n+    fn generic_arg_used_elsewhere<T: AsRef<Path>>(_x: T, _y: T) {}\n+\n+    fn id<T: AsRef<str>>(x: T) -> T {\n+        x\n+    }\n+\n+    fn predicates_are_satisfied(_x: impl std::fmt::Write) {}\n+\n+    // Should lint\n+    fn single_return() -> impl AsRef<str> {\n+        id(\"abc\")\n+    }\n+\n+    // Should not lint\n+    fn multiple_returns(b: bool) -> impl AsRef<str> {\n+        if b {\n+            return String::new();\n+        }\n+\n+        id(\"abc\".to_string())\n+    }\n+\n+    struct S1(String);\n+\n+    // Should not lint\n+    fn fields1() -> S1 {\n+        S1(id(\"abc\".to_string()))\n+    }\n+\n+    struct S2 {\n+        s: String,\n+    }\n+\n+    // Should not lint\n+    fn fields2() {\n+        let mut s = S2 { s: \"abc\".into() };\n+        s.s = id(\"abc\".to_string());\n+    }\n+\n+    pub fn main() {\n+        let path = std::path::Path::new(\"x\");\n+        let path_buf = path.to_owned();\n+\n+        // Should not lint.\n+        let _x: PathBuf = require_deref_path(path.to_owned());\n+        generic_arg_used_elsewhere(path.to_owned(), path_buf);\n+        predicates_are_satisfied(id(\"abc\".to_string()));\n+    }\n+}"}, {"sha": "2128bdacddadf03fa7736e020583e5912b00a6e7", "filename": "tests/ui/unnecessary_to_owned.rs", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/750a2d57bde6fca3bbd856410fe4fb54c4c068dc/tests%2Fui%2Funnecessary_to_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/750a2d57bde6fca3bbd856410fe4fb54c4c068dc/tests%2Fui%2Funnecessary_to_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_to_owned.rs?ref=750a2d57bde6fca3bbd856410fe4fb54c4c068dc", "patch": "@@ -357,3 +357,63 @@ mod issue_9317 {\n         consume(b.to_string());\n     }\n }\n+\n+mod issue_9351 {\n+    #![allow(dead_code)]\n+\n+    use std::ops::Deref;\n+    use std::path::{Path, PathBuf};\n+\n+    fn require_deref_path<T: Deref<Target = std::path::Path>>(x: T) -> T {\n+        x\n+    }\n+\n+    fn generic_arg_used_elsewhere<T: AsRef<Path>>(_x: T, _y: T) {}\n+\n+    fn id<T: AsRef<str>>(x: T) -> T {\n+        x\n+    }\n+\n+    fn predicates_are_satisfied(_x: impl std::fmt::Write) {}\n+\n+    // Should lint\n+    fn single_return() -> impl AsRef<str> {\n+        id(\"abc\".to_string())\n+    }\n+\n+    // Should not lint\n+    fn multiple_returns(b: bool) -> impl AsRef<str> {\n+        if b {\n+            return String::new();\n+        }\n+\n+        id(\"abc\".to_string())\n+    }\n+\n+    struct S1(String);\n+\n+    // Should not lint\n+    fn fields1() -> S1 {\n+        S1(id(\"abc\".to_string()))\n+    }\n+\n+    struct S2 {\n+        s: String,\n+    }\n+\n+    // Should not lint\n+    fn fields2() {\n+        let mut s = S2 { s: \"abc\".into() };\n+        s.s = id(\"abc\".to_string());\n+    }\n+\n+    pub fn main() {\n+        let path = std::path::Path::new(\"x\");\n+        let path_buf = path.to_owned();\n+\n+        // Should not lint.\n+        let _x: PathBuf = require_deref_path(path.to_owned());\n+        generic_arg_used_elsewhere(path.to_owned(), path_buf);\n+        predicates_are_satisfied(id(\"abc\".to_string()));\n+    }\n+}"}, {"sha": "7deb90b06f3b7bd6e73cfed25eef9481e69e3c05", "filename": "tests/ui/unnecessary_to_owned.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/750a2d57bde6fca3bbd856410fe4fb54c4c068dc/tests%2Fui%2Funnecessary_to_owned.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/750a2d57bde6fca3bbd856410fe4fb54c4c068dc/tests%2Fui%2Funnecessary_to_owned.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_to_owned.stderr?ref=750a2d57bde6fca3bbd856410fe4fb54c4c068dc", "patch": "@@ -509,5 +509,11 @@ error: unnecessary use of `to_string`\n LL |         Box::new(build(y.to_string()))\n    |                        ^^^^^^^^^^^^^ help: use: `y`\n \n-error: aborting due to 78 previous errors\n+error: unnecessary use of `to_string`\n+  --> $DIR/unnecessary_to_owned.rs:381:12\n+   |\n+LL |         id(\"abc\".to_string())\n+   |            ^^^^^^^^^^^^^^^^^ help: use: `\"abc\"`\n+\n+error: aborting due to 79 previous errors\n "}]}