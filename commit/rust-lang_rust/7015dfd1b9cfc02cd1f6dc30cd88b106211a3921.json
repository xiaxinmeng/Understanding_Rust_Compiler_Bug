{"sha": "7015dfd1b9cfc02cd1f6dc30cd88b106211a3921", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwMTVkZmQxYjljZmMwMmNkMWY2ZGMzMGNkODhiMTA2MjExYTM5MjE=", "commit": {"author": {"name": "Dror Levin", "email": "spatz@psybear.com", "date": "2018-06-26T10:29:36Z"}, "committer": {"name": "Dror Levin", "email": "spatz@psybear.com", "date": "2018-06-26T13:07:24Z"}, "message": "Add read_exact_at and write_all_at methods to FileExt on unix", "tree": {"sha": "3fb76849ef1bcce338aa8984c99f207eda3e2eba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3fb76849ef1bcce338aa8984c99f207eda3e2eba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7015dfd1b9cfc02cd1f6dc30cd88b106211a3921", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7015dfd1b9cfc02cd1f6dc30cd88b106211a3921", "html_url": "https://github.com/rust-lang/rust/commit/7015dfd1b9cfc02cd1f6dc30cd88b106211a3921", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7015dfd1b9cfc02cd1f6dc30cd88b106211a3921/comments", "author": {"login": "drrlvn", "id": 38856, "node_id": "MDQ6VXNlcjM4ODU2", "avatar_url": "https://avatars.githubusercontent.com/u/38856?v=4", "gravatar_id": "", "url": "https://api.github.com/users/drrlvn", "html_url": "https://github.com/drrlvn", "followers_url": "https://api.github.com/users/drrlvn/followers", "following_url": "https://api.github.com/users/drrlvn/following{/other_user}", "gists_url": "https://api.github.com/users/drrlvn/gists{/gist_id}", "starred_url": "https://api.github.com/users/drrlvn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/drrlvn/subscriptions", "organizations_url": "https://api.github.com/users/drrlvn/orgs", "repos_url": "https://api.github.com/users/drrlvn/repos", "events_url": "https://api.github.com/users/drrlvn/events{/privacy}", "received_events_url": "https://api.github.com/users/drrlvn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "drrlvn", "id": 38856, "node_id": "MDQ6VXNlcjM4ODU2", "avatar_url": "https://avatars.githubusercontent.com/u/38856?v=4", "gravatar_id": "", "url": "https://api.github.com/users/drrlvn", "html_url": "https://github.com/drrlvn", "followers_url": "https://api.github.com/users/drrlvn/followers", "following_url": "https://api.github.com/users/drrlvn/following{/other_user}", "gists_url": "https://api.github.com/users/drrlvn/gists{/gist_id}", "starred_url": "https://api.github.com/users/drrlvn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/drrlvn/subscriptions", "organizations_url": "https://api.github.com/users/drrlvn/orgs", "repos_url": "https://api.github.com/users/drrlvn/repos", "events_url": "https://api.github.com/users/drrlvn/events{/privacy}", "received_events_url": "https://api.github.com/users/drrlvn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "773ce53ce7b3acb97cfbd3d189dc3fbf33ec05c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/773ce53ce7b3acb97cfbd3d189dc3fbf33ec05c6", "html_url": "https://github.com/rust-lang/rust/commit/773ce53ce7b3acb97cfbd3d189dc3fbf33ec05c6"}], "stats": {"total": 127, "additions": 127, "deletions": 0}, "files": [{"sha": "4c2cea0d32c35ec80c9e70312e1cb4e93b7c2a4b", "filename": "src/libstd/sys/unix/ext/fs.rs", "status": "modified", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/7015dfd1b9cfc02cd1f6dc30cd88b106211a3921/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7015dfd1b9cfc02cd1f6dc30cd88b106211a3921/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs?ref=7015dfd1b9cfc02cd1f6dc30cd88b106211a3921", "patch": "@@ -59,6 +59,78 @@ pub trait FileExt {\n     #[stable(feature = \"file_offset\", since = \"1.15.0\")]\n     fn read_at(&self, buf: &mut [u8], offset: u64) -> io::Result<usize>;\n \n+    /// Reads the exact number of byte required to fill `buf` from the given offset.\n+    ///\n+    /// The offset is relative to the start of the file and thus independent\n+    /// from the current cursor.\n+    ///\n+    /// The current file cursor is not affected by this function.\n+    ///\n+    /// Similar to [`Read::read_exact`] but uses [`read_at`] instead of `read`.\n+    ///\n+    /// [`Read::read_exact`]: ../../../../std/io/trait.Read.html#method.read_exact\n+    /// [`read_at`]: #tymethod.read_at\n+    ///\n+    /// # Errors\n+    ///\n+    /// If this function encounters an error of the kind\n+    /// [`ErrorKind::Interrupted`] then the error is ignored and the operation\n+    /// will continue.\n+    ///\n+    /// If this function encounters an \"end of file\" before completely filling\n+    /// the buffer, it returns an error of the kind [`ErrorKind::UnexpectedEof`].\n+    /// The contents of `buf` are unspecified in this case.\n+    ///\n+    /// If any other read error is encountered then this function immediately\n+    /// returns. The contents of `buf` are unspecified in this case.\n+    ///\n+    /// If this function returns an error, it is unspecified how many bytes it\n+    /// has read, but it will never read more than would be necessary to\n+    /// completely fill the buffer.\n+    ///\n+    /// [`ErrorKind::Interrupted`]: ../../../../std/io/enum.ErrorKind.html#variant.Interrupted\n+    /// [`ErrorKind::UnexpectedEof`]: ../../../../std/io/enum.ErrorKind.html#variant.UnexpectedEof\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(rw_exact_all_at)]\n+    /// use std::io;\n+    /// use std::fs::File;\n+    /// use std::os::unix::prelude::FileExt;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let mut buf = [0u8; 8];\n+    ///     let file = File::open(\"foo.txt\")?;\n+    ///\n+    ///     // We now read exactly 8 bytes from the offset 10.\n+    ///     file.read_exact_at(&mut buf, 10)?;\n+    ///     println!(\"read {} bytes: {:?}\", buf.len(), buf);\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"rw_exact_all_at\", issue = \"0\")]\n+    fn read_exact_at(&self, mut buf: &mut [u8], mut offset: u64) -> io::Result<()> {\n+        while !buf.is_empty() {\n+            match self.read_at(buf, offset) {\n+                Ok(0) => break,\n+                Ok(n) => {\n+                    let tmp = buf;\n+                    buf = &mut tmp[n..];\n+                    offset += n as u64;\n+                }\n+                Err(ref e) if e.kind() == io::ErrorKind::Interrupted => {}\n+                Err(e) => return Err(e),\n+            }\n+        }\n+        if !buf.is_empty() {\n+            Err(io::Error::new(io::ErrorKind::UnexpectedEof,\n+                               \"failed to fill whole buffer\"))\n+        } else {\n+            Ok(())\n+        }\n+    }\n+\n     /// Writes a number of bytes starting from a given offset.\n     ///\n     /// Returns the number of bytes written.\n@@ -93,6 +165,61 @@ pub trait FileExt {\n     /// ```\n     #[stable(feature = \"file_offset\", since = \"1.15.0\")]\n     fn write_at(&self, buf: &[u8], offset: u64) -> io::Result<usize>;\n+\n+    /// Attempts to write an entire buffer starting from a given offset.\n+    ///\n+    /// The offset is relative to the start of the file and thus independent\n+    /// from the current cursor.\n+    ///\n+    /// The current file cursor is not affected by this function.\n+    ///\n+    /// This method will continuously call [`write_at`] until there is no more data\n+    /// to be written or an error of non-[`ErrorKind::Interrupted`] kind is\n+    /// returned. This method will not return until the entire buffer has been\n+    /// successfully written or such an error occurs. The first error that is\n+    /// not of [`ErrorKind::Interrupted`] kind generated from this method will be\n+    /// returned.\n+    ///\n+    /// # Errors\n+    ///\n+    /// This function will return the first error of\n+    /// non-[`ErrorKind::Interrupted`] kind that [`write_at`] returns.\n+    ///\n+    /// [`ErrorKind::Interrupted`]: ../../../../std/io/enum.ErrorKind.html#variant.Interrupted\n+    /// [`write_at`]: #tymethod.write_at\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(rw_exact_all_at)]\n+    /// use std::fs::File;\n+    /// use std::io;\n+    /// use std::os::unix::prelude::FileExt;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let file = File::open(\"foo.txt\")?;\n+    ///\n+    ///     // We now write at the offset 10.\n+    ///     file.write_all_at(b\"sushi\", 10)?;\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"rw_exact_all_at\", issue = \"0\")]\n+    fn write_all_at(&self, mut buf: &[u8], mut offset: u64) -> io::Result<()> {\n+        while !buf.is_empty() {\n+            match self.write_at(buf, offset) {\n+                Ok(0) => return Err(io::Error::new(io::ErrorKind::WriteZero,\n+                                                   \"failed to write whole buffer\")),\n+                Ok(n) => {\n+                    buf = &buf[n..];\n+                    offset += n as u64\n+                }\n+                Err(ref e) if e.kind() == io::ErrorKind::Interrupted => {}\n+                Err(e) => return Err(e),\n+            }\n+        }\n+        Ok(())\n+    }\n }\n \n #[stable(feature = \"file_offset\", since = \"1.15.0\")]"}]}