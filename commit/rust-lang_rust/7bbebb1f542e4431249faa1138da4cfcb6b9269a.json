{"sha": "7bbebb1f542e4431249faa1138da4cfcb6b9269a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiYmViYjFmNTQyZTQ0MzEyNDlmYWExMTM4ZGE0Y2ZjYjZiOTI2OWE=", "commit": {"author": {"name": "Mark-Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-11-03T04:33:35Z"}, "committer": {"name": "Mark-Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-11-11T14:38:48Z"}, "message": "Change implementation of syntax::util::SmallVector to use data_structures::SmallVec.", "tree": {"sha": "670a2512abae6206e3d6f8623d1302c839066346", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/670a2512abae6206e3d6f8623d1302c839066346"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7bbebb1f542e4431249faa1138da4cfcb6b9269a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7bbebb1f542e4431249faa1138da4cfcb6b9269a", "html_url": "https://github.com/rust-lang/rust/commit/7bbebb1f542e4431249faa1138da4cfcb6b9269a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7bbebb1f542e4431249faa1138da4cfcb6b9269a/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4da129d98419733bb408141ca53610bb77368cf0", "url": "https://api.github.com/repos/rust-lang/rust/commits/4da129d98419733bb408141ca53610bb77368cf0", "html_url": "https://github.com/rust-lang/rust/commit/4da129d98419733bb408141ca53610bb77368cf0"}], "stats": {"total": 859, "additions": 573, "deletions": 286}, "files": [{"sha": "7ae5846c54b9965b8f26d6db7eca6d26bd0d8cdf", "filename": "mk/crates.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bbebb1f542e4431249faa1138da4cfcb6b9269a/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/7bbebb1f542e4431249faa1138da4cfcb6b9269a/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=7bbebb1f542e4431249faa1138da4cfcb6b9269a", "patch": "@@ -100,7 +100,7 @@ DEPS_serialize := std log\n DEPS_term := std\n DEPS_test := std getopts term native:rust_test_helpers\n \n-DEPS_syntax := std term serialize log arena libc rustc_bitflags rustc_unicode rustc_errors syntax_pos\n+DEPS_syntax := std term serialize log arena libc rustc_bitflags rustc_unicode rustc_errors syntax_pos rustc_data_structures\n DEPS_syntax_ext := syntax syntax_pos rustc_errors fmt_macros proc_macro\n DEPS_syntax_pos := serialize\n DEPS_proc_macro_tokens := syntax syntax_pos log"}, {"sha": "ee38a043b122cd5d78a7598c7e2a3d3afb59d7f1", "filename": "src/Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7bbebb1f542e4431249faa1138da4cfcb6b9269a/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/7bbebb1f542e4431249faa1138da4cfcb6b9269a/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=7bbebb1f542e4431249faa1138da4cfcb6b9269a", "patch": "@@ -621,6 +621,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"log 0.0.0\",\n  \"rustc_bitflags 0.0.0\",\n+ \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n  \"serialize 0.0.0\",\n  \"syntax_pos 0.0.0\","}, {"sha": "641273d2b7626df326fbaccac265def14c2af3de", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bbebb1f542e4431249faa1138da4cfcb6b9269a/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbebb1f542e4431249faa1138da4cfcb6b9269a/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=7bbebb1f542e4431249faa1138da4cfcb6b9269a", "patch": "@@ -184,7 +184,7 @@ impl<'infcx, 'gcx, 'tcx> CombineFields<'infcx, 'gcx, 'tcx> {\n     {\n         // We use SmallVector here instead of Vec because this code is hot and\n         // it's rare that the stack length exceeds 1.\n-        let mut stack = SmallVector::zero();\n+        let mut stack = SmallVector::new();\n         stack.push((a_ty, dir, b_vid));\n         loop {\n             // For each turn of the loop, we extract a tuple"}, {"sha": "937cb3f600746cc7ace32a3cce6c5546858fa489", "filename": "src/librustc_data_structures/accumulate_vec.rs", "status": "modified", "additions": 152, "deletions": 6, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/7bbebb1f542e4431249faa1138da4cfcb6b9269a/src%2Flibrustc_data_structures%2Faccumulate_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbebb1f542e4431249faa1138da4cfcb6b9269a/src%2Flibrustc_data_structures%2Faccumulate_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Faccumulate_vec.rs?ref=7bbebb1f542e4431249faa1138da4cfcb6b9269a", "patch": "@@ -11,22 +11,68 @@\n //! A vector type intended to be used for collecting from iterators onto the stack.\n //!\n //! Space for up to N elements is provided on the stack.  If more elements are collected, Vec is\n-//! used to store the values on the heap. This type does not support re-allocating onto the heap,\n-//! and there is no way to push more elements onto the existing storage.\n+//! used to store the values on the heap.\n //!\n //! The N above is determined by Array's implementor, by way of an associatated constant.\n \n-use std::ops::Deref;\n-use std::iter::{IntoIterator, FromIterator};\n+use std::ops::{Deref, DerefMut};\n+use std::iter::{self, IntoIterator, FromIterator};\n+use std::slice;\n+use std::vec;\n \n-use array_vec::{Array, ArrayVec};\n+use rustc_serialize::{Encodable, Encoder, Decodable, Decoder};\n \n-#[derive(Debug)]\n+use array_vec::{self, Array, ArrayVec};\n+\n+#[derive(PartialEq, Eq, Hash, Debug)]\n pub enum AccumulateVec<A: Array> {\n     Array(ArrayVec<A>),\n     Heap(Vec<A::Element>)\n }\n \n+impl<A> Clone for AccumulateVec<A>\n+    where A: Array,\n+          A::Element: Clone {\n+    fn clone(&self) -> Self {\n+        match *self {\n+            AccumulateVec::Array(ref arr) => AccumulateVec::Array(arr.clone()),\n+            AccumulateVec::Heap(ref vec) => AccumulateVec::Heap(vec.clone()),\n+        }\n+    }\n+}\n+\n+impl<A: Array> AccumulateVec<A> {\n+    pub fn new() -> AccumulateVec<A> {\n+        AccumulateVec::Array(ArrayVec::new())\n+    }\n+\n+    pub fn one(el: A::Element) -> Self {\n+        iter::once(el).collect()\n+    }\n+\n+    pub fn many<I: IntoIterator<Item=A::Element>>(iter: I) -> Self {\n+        iter.into_iter().collect()\n+    }\n+\n+    pub fn len(&self) -> usize {\n+        match *self {\n+            AccumulateVec::Array(ref arr) => arr.len(),\n+            AccumulateVec::Heap(ref vec) => vec.len(),\n+        }\n+    }\n+\n+    pub fn is_empty(&self) -> bool {\n+        self.len() == 0\n+    }\n+\n+    pub fn pop(&mut self) -> Option<A::Element> {\n+        match *self {\n+            AccumulateVec::Array(ref mut arr) => arr.pop(),\n+            AccumulateVec::Heap(ref mut vec) => vec.pop(),\n+        }\n+    }\n+}\n+\n impl<A: Array> Deref for AccumulateVec<A> {\n     type Target = [A::Element];\n     fn deref(&self) -> &Self::Target {\n@@ -37,6 +83,15 @@ impl<A: Array> Deref for AccumulateVec<A> {\n     }\n }\n \n+impl<A: Array> DerefMut for AccumulateVec<A> {\n+    fn deref_mut(&mut self) -> &mut [A::Element] {\n+        match *self {\n+            AccumulateVec::Array(ref mut v) => &mut v[..],\n+            AccumulateVec::Heap(ref mut v) => &mut v[..],\n+        }\n+    }\n+}\n+\n impl<A: Array> FromIterator<A::Element> for AccumulateVec<A> {\n     fn from_iter<I>(iter: I) -> AccumulateVec<A> where I: IntoIterator<Item=A::Element> {\n         let iter = iter.into_iter();\n@@ -50,3 +105,94 @@ impl<A: Array> FromIterator<A::Element> for AccumulateVec<A> {\n     }\n }\n \n+pub struct IntoIter<A: Array> {\n+    repr: IntoIterRepr<A>,\n+}\n+\n+enum IntoIterRepr<A: Array> {\n+    Array(array_vec::Iter<A>),\n+    Heap(vec::IntoIter<A::Element>),\n+}\n+\n+impl<A: Array> Iterator for IntoIter<A> {\n+    type Item = A::Element;\n+\n+    fn next(&mut self) -> Option<A::Element> {\n+        match self.repr {\n+            IntoIterRepr::Array(ref mut arr) => arr.next(),\n+            IntoIterRepr::Heap(ref mut iter) => iter.next(),\n+        }\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        match self.repr {\n+            IntoIterRepr::Array(ref iter) => iter.size_hint(),\n+            IntoIterRepr::Heap(ref iter) => iter.size_hint(),\n+        }\n+    }\n+}\n+\n+impl<A: Array> IntoIterator for AccumulateVec<A> {\n+    type Item = A::Element;\n+    type IntoIter = IntoIter<A>;\n+    fn into_iter(self) -> Self::IntoIter {\n+        IntoIter {\n+            repr: match self {\n+                AccumulateVec::Array(arr) => IntoIterRepr::Array(arr.into_iter()),\n+                AccumulateVec::Heap(vec) => IntoIterRepr::Heap(vec.into_iter()),\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, A: Array> IntoIterator for &'a AccumulateVec<A> {\n+    type Item = &'a A::Element;\n+    type IntoIter = slice::Iter<'a, A::Element>;\n+    fn into_iter(self) -> Self::IntoIter {\n+        self.iter()\n+    }\n+}\n+\n+impl<'a, A: Array> IntoIterator for &'a mut AccumulateVec<A> {\n+    type Item = &'a mut A::Element;\n+    type IntoIter = slice::IterMut<'a, A::Element>;\n+    fn into_iter(self) -> Self::IntoIter {\n+        self.iter_mut()\n+    }\n+}\n+\n+impl<A: Array> From<Vec<A::Element>> for AccumulateVec<A> {\n+    fn from(v: Vec<A::Element>) -> AccumulateVec<A> {\n+        AccumulateVec::many(v)\n+    }\n+}\n+\n+impl<A: Array> Default for AccumulateVec<A> {\n+    fn default() -> AccumulateVec<A> {\n+        AccumulateVec::new()\n+    }\n+}\n+\n+impl<A> Encodable for AccumulateVec<A>\n+    where A: Array,\n+          A::Element: Encodable {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        s.emit_seq(self.len(), |s| {\n+            for (i, e) in self.iter().enumerate() {\n+                try!(s.emit_seq_elt(i, |s| e.encode(s)));\n+            }\n+            Ok(())\n+        })\n+    }\n+}\n+\n+impl<A> Decodable for AccumulateVec<A>\n+    where A: Array,\n+          A::Element: Decodable {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<AccumulateVec<A>, D::Error> {\n+        d.read_seq(|d, len| {\n+            Ok(try!((0..len).map(|i| d.read_seq_elt(i, |d| Decodable::decode(d))).collect()))\n+        })\n+    }\n+}\n+"}, {"sha": "631cf2cfcf6db1fdc63a2d666f340af980ef0312", "filename": "src/librustc_data_structures/array_vec.rs", "status": "modified", "additions": 139, "deletions": 10, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/7bbebb1f542e4431249faa1138da4cfcb6b9269a/src%2Flibrustc_data_structures%2Farray_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbebb1f542e4431249faa1138da4cfcb6b9269a/src%2Flibrustc_data_structures%2Farray_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Farray_vec.rs?ref=7bbebb1f542e4431249faa1138da4cfcb6b9269a", "patch": "@@ -9,22 +9,28 @@\n // except according to those terms.\n \n //! A stack-allocated vector, allowing storage of N elements on the stack.\n-//!\n-//! Currently, only the N = 8 case is supported (due to Array only being impl-ed for [T; 8]).\n \n use std::marker::Unsize;\n use std::iter::Extend;\n-use std::ptr::drop_in_place;\n-use std::ops::{Deref, DerefMut};\n+use std::ptr::{self, drop_in_place};\n+use std::ops::{Deref, DerefMut, Range};\n+use std::hash::{Hash, Hasher};\n use std::slice;\n use std::fmt;\n+use std::mem;\n \n pub unsafe trait Array {\n     type Element;\n     type PartialStorage: Default + Unsize<[ManuallyDrop<Self::Element>]>;\n     const LEN: usize;\n }\n \n+unsafe impl<T> Array for [T; 1] {\n+    type Element = T;\n+    type PartialStorage = [ManuallyDrop<T>; 1];\n+    const LEN: usize = 1;\n+}\n+\n unsafe impl<T> Array for [T; 8] {\n     type Element = T;\n     type PartialStorage = [ManuallyDrop<T>; 8];\n@@ -36,13 +42,74 @@ pub struct ArrayVec<A: Array> {\n     values: A::PartialStorage\n }\n \n+impl<A> Hash for ArrayVec<A>\n+    where A: Array,\n+          A::Element: Hash {\n+    fn hash<H>(&self, state: &mut H) where H: Hasher {\n+        (&self[..]).hash(state);\n+    }\n+}\n+\n+impl<A: Array> PartialEq for ArrayVec<A> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self == other\n+    }\n+}\n+\n+impl<A: Array> Eq for ArrayVec<A> {}\n+\n+impl<A> Clone for ArrayVec<A>\n+    where A: Array,\n+          A::Element: Clone {\n+    fn clone(&self) -> Self {\n+        let mut v = ArrayVec::new();\n+        v.extend(self.iter().cloned());\n+        v\n+    }\n+}\n+\n impl<A: Array> ArrayVec<A> {\n     pub fn new() -> Self {\n         ArrayVec {\n             count: 0,\n             values: Default::default(),\n         }\n     }\n+\n+    pub fn len(&self) -> usize {\n+        self.count\n+    }\n+\n+    pub unsafe fn set_len(&mut self, len: usize) {\n+        self.count = len;\n+    }\n+\n+    /// Panics when the stack vector is full.\n+    pub fn push(&mut self, el: A::Element) {\n+        let arr = &mut self.values as &mut [ManuallyDrop<_>];\n+        arr[self.count] = ManuallyDrop { value: el };\n+        self.count += 1;\n+    }\n+\n+    pub fn pop(&mut self) -> Option<A::Element> {\n+        if self.count > 0 {\n+            let arr = &mut self.values as &mut [ManuallyDrop<_>];\n+            self.count -= 1;\n+            unsafe {\n+                let value = ptr::read(&arr[self.count]);\n+                Some(value.value)\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+impl<A> Default for ArrayVec<A>\n+    where A: Array {\n+    fn default() -> Self {\n+        ArrayVec::new()\n+    }\n }\n \n impl<A> fmt::Debug for ArrayVec<A>\n@@ -81,15 +148,69 @@ impl<A: Array> Drop for ArrayVec<A> {\n impl<A: Array> Extend<A::Element> for ArrayVec<A> {\n     fn extend<I>(&mut self, iter: I) where I: IntoIterator<Item=A::Element> {\n         for el in iter {\n-            unsafe {\n-                let arr = &mut self.values as &mut [ManuallyDrop<_>];\n-                arr[self.count].value = el;\n-            }\n-            self.count += 1;\n+            self.push(el);\n+        }\n+    }\n+}\n+\n+pub struct Iter<A: Array> {\n+    indices: Range<usize>,\n+    store: A::PartialStorage,\n+}\n+\n+impl<A: Array> Drop for Iter<A> {\n+    fn drop(&mut self) {\n+        for _ in self {}\n+    }\n+}\n+\n+impl<A: Array> Iterator for Iter<A> {\n+    type Item = A::Element;\n+\n+    fn next(&mut self) -> Option<A::Element> {\n+        let arr = &self.store as &[ManuallyDrop<_>];\n+        unsafe {\n+            self.indices.next().map(|i| ptr::read(&arr[i]).value)\n+        }\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.indices.size_hint()\n+    }\n+}\n+\n+impl<A: Array> IntoIterator for ArrayVec<A> {\n+    type Item = A::Element;\n+    type IntoIter = Iter<A>;\n+    fn into_iter(self) -> Self::IntoIter {\n+        let store = unsafe {\n+            ptr::read(&self.values)\n+        };\n+        let indices = 0..self.count;\n+        mem::forget(self);\n+        Iter {\n+            indices: indices,\n+            store: store,\n         }\n     }\n }\n \n+impl<'a, A: Array> IntoIterator for &'a ArrayVec<A> {\n+    type Item = &'a A::Element;\n+    type IntoIter = slice::Iter<'a, A::Element>;\n+    fn into_iter(self) -> Self::IntoIter {\n+        self.iter()\n+    }\n+}\n+\n+impl<'a, A: Array> IntoIterator for &'a mut ArrayVec<A> {\n+    type Item = &'a mut A::Element;\n+    type IntoIter = slice::IterMut<'a, A::Element>;\n+    fn into_iter(self) -> Self::IntoIter {\n+        self.iter_mut()\n+    }\n+}\n+\n // FIXME: This should use repr(transparent) from rust-lang/rfcs#1758.\n #[allow(unions_with_drop_fields)]\n pub union ManuallyDrop<T> {\n@@ -98,9 +219,17 @@ pub union ManuallyDrop<T> {\n     empty: (),\n }\n \n+impl<T> ManuallyDrop<T> {\n+    fn new() -> ManuallyDrop<T> {\n+        ManuallyDrop {\n+            empty: ()\n+        }\n+    }\n+}\n+\n impl<T> Default for ManuallyDrop<T> {\n     fn default() -> Self {\n-        ManuallyDrop { empty: () }\n+        ManuallyDrop::new()\n     }\n }\n "}, {"sha": "2e4206d2ee1ee48efdc0fd1add328a2824b313df", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7bbebb1f542e4431249faa1138da4cfcb6b9269a/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbebb1f542e4431249faa1138da4cfcb6b9269a/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=7bbebb1f542e4431249faa1138da4cfcb6b9269a", "patch": "@@ -46,6 +46,7 @@ extern crate libc;\n \n pub mod array_vec;\n pub mod accumulate_vec;\n+pub mod small_vec;\n pub mod bitslice;\n pub mod blake2b;\n pub mod bitvec;"}, {"sha": "565a3c443a34ab0581c33bdb6cd1045c33c0d24f", "filename": "src/librustc_data_structures/small_vec.rs", "status": "added", "additions": 203, "deletions": 0, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/7bbebb1f542e4431249faa1138da4cfcb6b9269a/src%2Flibrustc_data_structures%2Fsmall_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbebb1f542e4431249faa1138da4cfcb6b9269a/src%2Flibrustc_data_structures%2Fsmall_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsmall_vec.rs?ref=7bbebb1f542e4431249faa1138da4cfcb6b9269a", "patch": "@@ -0,0 +1,203 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! A vector type intended to be used for collecting from iterators onto the stack.\n+//!\n+//! Space for up to N elements is provided on the stack.  If more elements are collected, Vec is\n+//! used to store the values on the heap. SmallVec is similar to AccumulateVec, but adds\n+//! the ability to push elements.\n+//!\n+//! The N above is determined by Array's implementor, by way of an associatated constant.\n+\n+use std::ops::{Deref, DerefMut};\n+use std::iter::{IntoIterator, FromIterator};\n+use std::fmt::{self, Debug};\n+use std::mem;\n+use std::ptr;\n+\n+use rustc_serialize::{Encodable, Encoder, Decodable, Decoder};\n+\n+use accumulate_vec::{IntoIter, AccumulateVec};\n+use array_vec::Array;\n+\n+pub struct SmallVec<A: Array>(AccumulateVec<A>);\n+\n+impl<A> Clone for SmallVec<A>\n+    where A: Array,\n+          A::Element: Clone {\n+    fn clone(&self) -> Self {\n+        SmallVec(self.0.clone())\n+    }\n+}\n+\n+impl<A> Debug for SmallVec<A>\n+    where A: Array + Debug,\n+          A::Element: Debug {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_tuple(\"SmallVec\").field(&self.0).finish()\n+    }\n+}\n+\n+impl<A: Array> SmallVec<A> {\n+    pub fn new() -> Self {\n+        SmallVec(AccumulateVec::new())\n+    }\n+\n+    pub fn with_capacity(cap: usize) -> Self {\n+        let mut vec = SmallVec::new();\n+        vec.reserve(cap);\n+        vec\n+    }\n+\n+    pub fn one(el: A::Element) -> Self {\n+        SmallVec(AccumulateVec::one(el))\n+    }\n+\n+    pub fn many<I: IntoIterator<Item=A::Element>>(els: I) -> Self {\n+        SmallVec(AccumulateVec::many(els))\n+    }\n+\n+    pub fn expect_one(self, err: &'static str) -> A::Element {\n+        assert!(self.len() == 1, err);\n+        match self.0 {\n+            AccumulateVec::Array(arr) => arr.into_iter().next().unwrap(),\n+            AccumulateVec::Heap(vec) => vec.into_iter().next().unwrap(),\n+        }\n+    }\n+\n+    /// Will reallocate onto the heap if needed.\n+    pub fn push(&mut self, el: A::Element) {\n+        self.reserve(1);\n+        match self.0 {\n+            AccumulateVec::Array(ref mut array) => array.push(el),\n+            AccumulateVec::Heap(ref mut vec) => vec.push(el),\n+        }\n+    }\n+\n+    pub fn reserve(&mut self, n: usize) {\n+        match self.0 {\n+            AccumulateVec::Array(_) => {\n+                if self.len() + n > A::LEN {\n+                    let len = self.len();\n+                    let array = mem::replace(&mut self.0,\n+                            AccumulateVec::Heap(Vec::with_capacity(len + n)));\n+                    if let AccumulateVec::Array(array) = array {\n+                        match self.0 {\n+                            AccumulateVec::Heap(ref mut vec) => vec.extend(array),\n+                            _ => unreachable!()\n+                        }\n+                    }\n+                }\n+            }\n+            AccumulateVec::Heap(ref mut vec) => vec.reserve(n)\n+        }\n+    }\n+\n+    pub unsafe fn set_len(&mut self, len: usize) {\n+        match self.0 {\n+            AccumulateVec::Array(ref mut arr) => arr.set_len(len),\n+            AccumulateVec::Heap(ref mut vec) => vec.set_len(len),\n+        }\n+    }\n+\n+    pub fn insert(&mut self, index: usize, element: A::Element) {\n+        let len = self.len();\n+\n+        // Reserve space for shifting elements to the right\n+        self.reserve(1);\n+\n+        assert!(index <= len);\n+\n+        unsafe {\n+            // infallible\n+            // The spot to put the new value\n+            {\n+                let p = self.as_mut_ptr().offset(index as isize);\n+                // Shift everything over to make space. (Duplicating the\n+                // `index`th element into two consecutive places.)\n+                ptr::copy(p, p.offset(1), len - index);\n+                // Write it in, overwriting the first copy of the `index`th\n+                // element.\n+                ptr::write(p, element);\n+            }\n+            self.set_len(len + 1);\n+        }\n+    }\n+}\n+\n+impl<A: Array> Deref for SmallVec<A> {\n+    type Target = AccumulateVec<A>;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+\n+impl<A: Array> DerefMut for SmallVec<A> {\n+    fn deref_mut(&mut self) -> &mut AccumulateVec<A> {\n+        &mut self.0\n+    }\n+}\n+\n+impl<A: Array> FromIterator<A::Element> for SmallVec<A> {\n+    fn from_iter<I>(iter: I) -> Self where I: IntoIterator<Item=A::Element> {\n+        SmallVec(iter.into_iter().collect())\n+    }\n+}\n+\n+impl<A: Array> Extend<A::Element> for SmallVec<A> {\n+    fn extend<I: IntoIterator<Item=A::Element>>(&mut self, iter: I) {\n+        let iter = iter.into_iter();\n+        self.reserve(iter.size_hint().0);\n+        for el in iter {\n+            self.push(el);\n+        }\n+    }\n+}\n+\n+impl<A: Array> IntoIterator for SmallVec<A> {\n+    type Item = A::Element;\n+    type IntoIter = IntoIter<A>;\n+    fn into_iter(self) -> Self::IntoIter {\n+        self.0.into_iter()\n+    }\n+}\n+\n+impl<A: Array> Default for SmallVec<A> {\n+    fn default() -> SmallVec<A> {\n+        SmallVec::new()\n+    }\n+}\n+\n+impl<A> Encodable for SmallVec<A>\n+    where A: Array,\n+          A::Element: Encodable {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        s.emit_seq(self.len(), |s| {\n+            for (i, e) in self.iter().enumerate() {\n+                try!(s.emit_seq_elt(i, |s| e.encode(s)));\n+            }\n+            Ok(())\n+        })\n+    }\n+}\n+\n+impl<A> Decodable for SmallVec<A>\n+    where A: Array,\n+          A::Element: Decodable {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<SmallVec<A>, D::Error> {\n+        d.read_seq(|d, len| {\n+            let mut vec = SmallVec::with_capacity(len);\n+            for i in 0..len {\n+                vec.push(try!(d.read_seq_elt(i, |d| Decodable::decode(d))));\n+            }\n+            Ok(vec)\n+        })\n+    }\n+}"}, {"sha": "0b38f5450b63faf09251971ad20926318130c2ff", "filename": "src/libsyntax/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7bbebb1f542e4431249faa1138da4cfcb6b9269a/src%2Flibsyntax%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7bbebb1f542e4431249faa1138da4cfcb6b9269a/src%2Flibsyntax%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2FCargo.toml?ref=7bbebb1f542e4431249faa1138da4cfcb6b9269a", "patch": "@@ -14,3 +14,4 @@ log = { path = \"../liblog\" }\n rustc_bitflags = { path = \"../librustc_bitflags\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n rustc_errors = { path = \"../librustc_errors\" }\n+rustc_data_structures = { path = \"../librustc_data_structures\" }"}, {"sha": "02429f02738fdcfe5c7bc77845d993443b3458e8", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bbebb1f542e4431249faa1138da4cfcb6b9269a/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbebb1f542e4431249faa1138da4cfcb6b9269a/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=7bbebb1f542e4431249faa1138da4cfcb6b9269a", "patch": "@@ -277,7 +277,7 @@ impl<'a> fold::Folder for StripUnconfigured<'a> {\n     fn fold_stmt(&mut self, stmt: ast::Stmt) -> SmallVector<ast::Stmt> {\n         match self.configure_stmt(stmt) {\n             Some(stmt) => fold::noop_fold_stmt(stmt, self),\n-            None => return SmallVector::zero(),\n+            None => return SmallVector::new(),\n         }\n     }\n "}, {"sha": "b4ac576f57a534b20010da304d3c276f9470203a", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7bbebb1f542e4431249faa1138da4cfcb6b9269a/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbebb1f542e4431249faa1138da4cfcb6b9269a/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=7bbebb1f542e4431249faa1138da4cfcb6b9269a", "patch": "@@ -440,23 +440,23 @@ impl MacResult for DummyResult {\n         if self.expr_only {\n             None\n         } else {\n-            Some(SmallVector::zero())\n+            Some(SmallVector::new())\n         }\n     }\n \n     fn make_impl_items(self: Box<DummyResult>) -> Option<SmallVector<ast::ImplItem>> {\n         if self.expr_only {\n             None\n         } else {\n-            Some(SmallVector::zero())\n+            Some(SmallVector::new())\n         }\n     }\n \n     fn make_trait_items(self: Box<DummyResult>) -> Option<SmallVector<ast::TraitItem>> {\n         if self.expr_only {\n             None\n         } else {\n-            Some(SmallVector::zero())\n+            Some(SmallVector::new())\n         }\n     }\n "}, {"sha": "877b312539f92d63e5f1d3cbbe0b5157dbad9b70", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7bbebb1f542e4431249faa1138da4cfcb6b9269a/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbebb1f542e4431249faa1138da4cfcb6b9269a/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=7bbebb1f542e4431249faa1138da4cfcb6b9269a", "patch": "@@ -89,7 +89,7 @@ macro_rules! expansions {\n                     Expansion::OptExpr(Some(ref expr)) => visitor.visit_expr(expr),\n                     Expansion::OptExpr(None) => {}\n                     $($( Expansion::$kind(ref ast) => visitor.$visit(ast), )*)*\n-                    $($( Expansion::$kind(ref ast) => for ast in ast.as_slice() {\n+                    $($( Expansion::$kind(ref ast) => for ast in &ast[..] {\n                         visitor.$visit_elt(ast);\n                     }, )*)*\n                 }\n@@ -511,28 +511,28 @@ impl<'a> Parser<'a> {\n                            -> PResult<'a, Expansion> {\n         Ok(match kind {\n             ExpansionKind::Items => {\n-                let mut items = SmallVector::zero();\n+                let mut items = SmallVector::new();\n                 while let Some(item) = self.parse_item()? {\n                     items.push(item);\n                 }\n                 Expansion::Items(items)\n             }\n             ExpansionKind::TraitItems => {\n-                let mut items = SmallVector::zero();\n+                let mut items = SmallVector::new();\n                 while self.token != token::Eof {\n                     items.push(self.parse_trait_item()?);\n                 }\n                 Expansion::TraitItems(items)\n             }\n             ExpansionKind::ImplItems => {\n-                let mut items = SmallVector::zero();\n+                let mut items = SmallVector::new();\n                 while self.token != token::Eof {\n                     items.push(self.parse_impl_item()?);\n                 }\n                 Expansion::ImplItems(items)\n             }\n             ExpansionKind::Stmts => {\n-                let mut stmts = SmallVector::zero();\n+                let mut stmts = SmallVector::new();\n                 while self.token != token::Eof &&\n                       // won't make progress on a `}`\n                       self.token != token::CloseDelim(token::Brace) {\n@@ -573,7 +573,7 @@ macro_rules! fully_configure {\n     ($this:ident, $node:ident, $noop_fold:ident) => {\n         match $noop_fold($node, &mut $this.cfg).pop() {\n             Some(node) => node,\n-            None => return SmallVector::zero(),\n+            None => return SmallVector::new(),\n         }\n     }\n }\n@@ -689,7 +689,7 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n     fn fold_stmt(&mut self, stmt: ast::Stmt) -> SmallVector<ast::Stmt> {\n         let stmt = match self.cfg.configure_stmt(stmt) {\n             Some(stmt) => stmt,\n-            None => return SmallVector::zero(),\n+            None => return SmallVector::new(),\n         };\n \n         let (mac, style, attrs) = if let StmtKind::Mac(mac) = stmt.node {"}, {"sha": "bda84cdaf39eb6d568e98ff900c1551b97ad964b", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bbebb1f542e4431249faa1138da4cfcb6b9269a/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbebb1f542e4431249faa1138da4cfcb6b9269a/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=7bbebb1f542e4431249faa1138da4cfcb6b9269a", "patch": "@@ -104,7 +104,7 @@ pub fn expand_include<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[tokenstream::T\n         }\n         fn make_items(mut self: Box<ExpandResult<'a>>)\n                       -> Option<SmallVector<P<ast::Item>>> {\n-            let mut ret = SmallVector::zero();\n+            let mut ret = SmallVector::new();\n             while self.p.token != token::Eof {\n                 match panictry!(self.p.parse_item()) {\n                     Some(item) => ret.push(item),"}, {"sha": "34280812421a131f74ca0db319e67365f452f38c", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7bbebb1f542e4431249faa1138da4cfcb6b9269a/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbebb1f542e4431249faa1138da4cfcb6b9269a/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=7bbebb1f542e4431249faa1138da4cfcb6b9269a", "patch": "@@ -45,6 +45,7 @@ extern crate libc;\n extern crate rustc_unicode;\n pub extern crate rustc_errors as errors;\n extern crate syntax_pos;\n+extern crate rustc_data_structures;\n \n extern crate serialize as rustc_serialize; // used by deriving\n "}, {"sha": "fe05e2958b3a851dd1e6828a99560cf07b3e082a", "filename": "src/libsyntax/util/move_map.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/7bbebb1f542e4431249faa1138da4cfcb6b9269a/src%2Flibsyntax%2Futil%2Fmove_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbebb1f542e4431249faa1138da4cfcb6b9269a/src%2Flibsyntax%2Futil%2Fmove_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fmove_map.rs?ref=7bbebb1f542e4431249faa1138da4cfcb6b9269a", "patch": "@@ -10,6 +10,8 @@\n \n use std::ptr;\n \n+use util::small_vector::SmallVector;\n+\n pub trait MoveMap<T>: Sized {\n     fn move_map<F>(self, mut f: F) -> Self where F: FnMut(T) -> T {\n         self.move_flat_map(|e| Some(f(e)))\n@@ -75,3 +77,50 @@ impl<T> MoveMap<T> for ::ptr::P<[T]> {\n         ::ptr::P::from_vec(self.into_vec().move_flat_map(f))\n     }\n }\n+\n+impl<T> MoveMap<T> for SmallVector<T> {\n+    fn move_flat_map<F, I>(mut self, mut f: F) -> Self\n+        where F: FnMut(T) -> I,\n+              I: IntoIterator<Item=T>\n+    {\n+        let mut read_i = 0;\n+        let mut write_i = 0;\n+        unsafe {\n+            let mut old_len = self.len();\n+            self.set_len(0); // make sure we just leak elements in case of panic\n+\n+            while read_i < old_len {\n+                // move the read_i'th item out of the vector and map it\n+                // to an iterator\n+                let e = ptr::read(self.get_unchecked(read_i));\n+                let mut iter = f(e).into_iter();\n+                read_i += 1;\n+\n+                while let Some(e) = iter.next() {\n+                    if write_i < read_i {\n+                        ptr::write(self.get_unchecked_mut(write_i), e);\n+                        write_i += 1;\n+                    } else {\n+                        // If this is reached we ran out of space\n+                        // in the middle of the vector.\n+                        // However, the vector is in a valid state here,\n+                        // so we just do a somewhat inefficient insert.\n+                        self.set_len(old_len);\n+                        self.insert(write_i, e);\n+\n+                        old_len = self.len();\n+                        self.set_len(0);\n+\n+                        read_i += 1;\n+                        write_i += 1;\n+                    }\n+                }\n+            }\n+\n+            // write_i tracks the number of actually written new items.\n+            self.set_len(write_i);\n+        }\n+\n+        self\n+    }\n+}"}, {"sha": "31e675836fc72b9e876c97eef8e137a739d3120a", "filename": "src/libsyntax/util/small_vector.rs", "status": "modified", "additions": 12, "deletions": 256, "changes": 268, "blob_url": "https://github.com/rust-lang/rust/blob/7bbebb1f542e4431249faa1138da4cfcb6b9269a/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbebb1f542e4431249faa1138da4cfcb6b9269a/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fsmall_vector.rs?ref=7bbebb1f542e4431249faa1138da4cfcb6b9269a", "patch": "@@ -8,261 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use self::SmallVectorRepr::*;\n-use self::IntoIterRepr::*;\n+use rustc_data_structures::small_vec::SmallVec;\n \n-use core::ops;\n-use std::iter::{IntoIterator, FromIterator};\n-use std::mem;\n-use std::slice;\n-use std::vec;\n-\n-use util::move_map::MoveMap;\n-\n-/// A vector type optimized for cases where the size is almost always 0 or 1\n-#[derive(Clone)]\n-pub struct SmallVector<T> {\n-    repr: SmallVectorRepr<T>,\n-}\n-\n-#[derive(Clone)]\n-enum SmallVectorRepr<T> {\n-    Zero,\n-    One(T),\n-    Many(Vec<T>),\n-}\n-\n-impl<T> Default for SmallVector<T> {\n-    fn default() -> Self {\n-        SmallVector { repr: Zero }\n-    }\n-}\n-\n-impl<T> Into<Vec<T>> for SmallVector<T> {\n-    fn into(self) -> Vec<T> {\n-        match self.repr {\n-            Zero => Vec::new(),\n-            One(t) => vec![t],\n-            Many(vec) => vec,\n-        }\n-    }\n-}\n-\n-impl<T> FromIterator<T> for SmallVector<T> {\n-    fn from_iter<I: IntoIterator<Item=T>>(iter: I) -> SmallVector<T> {\n-        let mut v = SmallVector::zero();\n-        v.extend(iter);\n-        v\n-    }\n-}\n-\n-impl<T> Extend<T> for SmallVector<T> {\n-    fn extend<I: IntoIterator<Item=T>>(&mut self, iter: I) {\n-        for val in iter {\n-            self.push(val);\n-        }\n-    }\n-}\n-\n-impl<T> SmallVector<T> {\n-    pub fn zero() -> SmallVector<T> {\n-        SmallVector { repr: Zero }\n-    }\n-\n-    pub fn one(v: T) -> SmallVector<T> {\n-        SmallVector { repr: One(v) }\n-    }\n-\n-    pub fn many(vs: Vec<T>) -> SmallVector<T> {\n-        SmallVector { repr: Many(vs) }\n-    }\n-\n-    pub fn as_slice(&self) -> &[T] {\n-        self\n-    }\n-\n-    pub fn as_mut_slice(&mut self) -> &mut [T] {\n-        self\n-    }\n-\n-    pub fn pop(&mut self) -> Option<T> {\n-        match self.repr {\n-            Zero => None,\n-            One(..) => {\n-                let one = mem::replace(&mut self.repr, Zero);\n-                match one {\n-                    One(v1) => Some(v1),\n-                    _ => unreachable!()\n-                }\n-            }\n-            Many(ref mut vs) => vs.pop(),\n-        }\n-    }\n-\n-    pub fn push(&mut self, v: T) {\n-        match self.repr {\n-            Zero => self.repr = One(v),\n-            One(..) => {\n-                let one = mem::replace(&mut self.repr, Zero);\n-                match one {\n-                    One(v1) => mem::replace(&mut self.repr, Many(vec![v1, v])),\n-                    _ => unreachable!()\n-                };\n-            }\n-            Many(ref mut vs) => vs.push(v)\n-        }\n-    }\n-\n-    pub fn push_all(&mut self, other: SmallVector<T>) {\n-        for v in other.into_iter() {\n-            self.push(v);\n-        }\n-    }\n-\n-    pub fn get(&self, idx: usize) -> &T {\n-        match self.repr {\n-            One(ref v) if idx == 0 => v,\n-            Many(ref vs) => &vs[idx],\n-            _ => panic!(\"out of bounds access\")\n-        }\n-    }\n-\n-    pub fn expect_one(self, err: &'static str) -> T {\n-        match self.repr {\n-            One(v) => v,\n-            Many(v) => {\n-                if v.len() == 1 {\n-                    v.into_iter().next().unwrap()\n-                } else {\n-                    panic!(err)\n-                }\n-            }\n-            _ => panic!(err)\n-        }\n-    }\n-\n-    pub fn len(&self) -> usize {\n-        match self.repr {\n-            Zero => 0,\n-            One(..) => 1,\n-            Many(ref vals) => vals.len()\n-        }\n-    }\n-\n-    pub fn is_empty(&self) -> bool { self.len() == 0 }\n-\n-    pub fn map<U, F: FnMut(T) -> U>(self, mut f: F) -> SmallVector<U> {\n-        let repr = match self.repr {\n-            Zero => Zero,\n-            One(t) => One(f(t)),\n-            Many(vec) => Many(vec.into_iter().map(f).collect()),\n-        };\n-        SmallVector { repr: repr }\n-    }\n-}\n-\n-impl<T> ops::Deref for SmallVector<T> {\n-    type Target = [T];\n-\n-    fn deref(&self) -> &[T] {\n-        match self.repr {\n-            Zero => {\n-                let result: &[T] = &[];\n-                result\n-            }\n-            One(ref v) => {\n-                unsafe { slice::from_raw_parts(v, 1) }\n-            }\n-            Many(ref vs) => vs\n-        }\n-    }\n-}\n-\n-impl<T> ops::DerefMut for SmallVector<T> {\n-    fn deref_mut(&mut self) -> &mut [T] {\n-        match self.repr {\n-            Zero => {\n-                let result: &mut [T] = &mut [];\n-                result\n-            }\n-            One(ref mut v) => {\n-                unsafe { slice::from_raw_parts_mut(v, 1) }\n-            }\n-            Many(ref mut vs) => vs\n-        }\n-    }\n-}\n-\n-impl<T> IntoIterator for SmallVector<T> {\n-    type Item = T;\n-    type IntoIter = IntoIter<T>;\n-    fn into_iter(self) -> Self::IntoIter {\n-        let repr = match self.repr {\n-            Zero => ZeroIterator,\n-            One(v) => OneIterator(v),\n-            Many(vs) => ManyIterator(vs.into_iter())\n-        };\n-        IntoIter { repr: repr }\n-    }\n-}\n-\n-pub struct IntoIter<T> {\n-    repr: IntoIterRepr<T>,\n-}\n-\n-enum IntoIterRepr<T> {\n-    ZeroIterator,\n-    OneIterator(T),\n-    ManyIterator(vec::IntoIter<T>),\n-}\n-\n-impl<T> Iterator for IntoIter<T> {\n-    type Item = T;\n-\n-    fn next(&mut self) -> Option<T> {\n-        match self.repr {\n-            ZeroIterator => None,\n-            OneIterator(..) => {\n-                let mut replacement = ZeroIterator;\n-                mem::swap(&mut self.repr, &mut replacement);\n-                match replacement {\n-                    OneIterator(v) => Some(v),\n-                    _ => unreachable!()\n-                }\n-            }\n-            ManyIterator(ref mut inner) => inner.next()\n-        }\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        match self.repr {\n-            ZeroIterator => (0, Some(0)),\n-            OneIterator(..) => (1, Some(1)),\n-            ManyIterator(ref inner) => inner.size_hint()\n-        }\n-    }\n-}\n-\n-impl<T> MoveMap<T> for SmallVector<T> {\n-    fn move_flat_map<F, I>(self, mut f: F) -> Self\n-        where F: FnMut(T) -> I,\n-              I: IntoIterator<Item=T>\n-    {\n-        match self.repr {\n-            Zero => Self::zero(),\n-            One(v) => f(v).into_iter().collect(),\n-            Many(vs) => SmallVector { repr: Many(vs.move_flat_map(f)) },\n-        }\n-    }\n-}\n+pub type SmallVector<T> = SmallVec<[T; 1]>;\n \n #[cfg(test)]\n mod tests {\n     use super::*;\n \n     #[test]\n     fn test_len() {\n-        let v: SmallVector<isize> = SmallVector::zero();\n+        let v: SmallVector<isize> = SmallVector::new();\n         assert_eq!(0, v.len());\n \n         assert_eq!(1, SmallVector::one(1).len());\n@@ -271,30 +27,30 @@ mod tests {\n \n     #[test]\n     fn test_push_get() {\n-        let mut v = SmallVector::zero();\n+        let mut v = SmallVector::new();\n         v.push(1);\n         assert_eq!(1, v.len());\n-        assert_eq!(&1, v.get(0));\n+        assert_eq!(1, v[0]);\n         v.push(2);\n         assert_eq!(2, v.len());\n-        assert_eq!(&2, v.get(1));\n+        assert_eq!(2, v[1]);\n         v.push(3);\n         assert_eq!(3, v.len());\n-        assert_eq!(&3, v.get(2));\n+        assert_eq!(3, v[2]);\n     }\n \n     #[test]\n     fn test_from_iter() {\n         let v: SmallVector<isize> = (vec![1, 2, 3]).into_iter().collect();\n         assert_eq!(3, v.len());\n-        assert_eq!(&1, v.get(0));\n-        assert_eq!(&2, v.get(1));\n-        assert_eq!(&3, v.get(2));\n+        assert_eq!(1, v[0]);\n+        assert_eq!(2, v[1]);\n+        assert_eq!(3, v[2]);\n     }\n \n     #[test]\n     fn test_move_iter() {\n-        let v = SmallVector::zero();\n+        let v = SmallVector::new();\n         let v: Vec<isize> = v.into_iter().collect();\n         assert_eq!(v, Vec::new());\n \n@@ -308,7 +64,7 @@ mod tests {\n     #[test]\n     #[should_panic]\n     fn test_expect_one_zero() {\n-        let _: isize = SmallVector::zero().expect_one(\"\");\n+        let _: isize = SmallVector::new().expect_one(\"\");\n     }\n \n     #[test]"}]}