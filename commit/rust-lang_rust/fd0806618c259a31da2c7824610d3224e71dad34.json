{"sha": "fd0806618c259a31da2c7824610d3224e71dad34", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkMDgwNjYxOGMyNTlhMzFkYTJjNzgyNDYxMGQzMjI0ZTcxZGFkMzQ=", "commit": {"author": {"name": "David Wood", "email": "david@davidtw.co", "date": "2018-06-12T19:43:14Z"}, "committer": {"name": "David Wood", "email": "david@davidtw.co", "date": "2018-07-01T14:33:05Z"}, "message": "Constraints are now being categorized, sorted and the error labelled. Categorization needs a bit of work.", "tree": {"sha": "c4eef6c968f35c85c0edc59e71e292c7987b7e4c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c4eef6c968f35c85c0edc59e71e292c7987b7e4c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fd0806618c259a31da2c7824610d3224e71dad34", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEWwgxPGhT5b/6kagXAXYLT59T8VQFAls45iIACgkQAXYLT59T\n8VRqJg//Qasgl2OWANJyAIrakcNWlsQJlL7QM7fl124YLqSM6cg/7se1Eoe0NOvV\nUxU9jsQrAzwMREqYc/Wymksl+U56xCv0wZvChfpNoFh/YY9CaE8VAQMJu2U1JRuW\nNGT3JiGxyuH5K7hRDkkrWg1Cdl88v2+vGrx1NiDmWnFS1Nl3OQqQOdlr5wwJjhkm\nNLwqmTw2Kfgq2Ve7qejwKcqjbnL68ASq0HqN7INtHe6rOoK2VjCfejjrSIA3Gm6q\nCfkaRDiNdE6Huvs796wvO+UveW3L2zp4R32LY2aCMVkO6/oLl7pQX3Q5QPVQRNl9\nCv4RR7hHjppSC94ugpNj+pi47dNxkk0heJXwls8QK/k5k//tslMUAY3KXtCSOT2t\nfU3YtbUbFy18O3PcxNYgEU/pjMmeWeg0iV63I1rSmBFybZdjrdNVWvWxrmtM3tCy\nNapWRgc5WIK0ObDeqz3WFhUsV+U2VLG5sJU+SYm3+VOTDc/uydA3oTXHiBoL/bxi\nINL1zaTmosRxNaGk+zrlYMzynHii5ktn/XN2Kc0xNnYDX5gjxnmqIW052o9vd+NQ\n6UN821/kQxCSGxcziaqSF7IQm7z7FPxzT+Zs+zsDj34UVeJysB4/kYXcjyrCTr0q\n2sDZch5TktR3x95Kg50zFtD7oMV8xAmzVp4kdb9ZjWFJWKyVpDE=\n=k91i\n-----END PGP SIGNATURE-----", "payload": "tree c4eef6c968f35c85c0edc59e71e292c7987b7e4c\nparent 56274be4b541599b0a1a02c710cc293659715345\nauthor David Wood <david@davidtw.co> 1528832594 +0100\ncommitter David Wood <david@davidtw.co> 1530455585 +0100\n\nConstraints are now being categorized, sorted and the error labelled. Categorization needs a bit of work.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fd0806618c259a31da2c7824610d3224e71dad34", "html_url": "https://github.com/rust-lang/rust/commit/fd0806618c259a31da2c7824610d3224e71dad34", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fd0806618c259a31da2c7824610d3224e71dad34/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "56274be4b541599b0a1a02c710cc293659715345", "url": "https://api.github.com/repos/rust-lang/rust/commits/56274be4b541599b0a1a02c710cc293659715345", "html_url": "https://github.com/rust-lang/rust/commit/56274be4b541599b0a1a02c710cc293659715345"}], "stats": {"total": 132, "additions": 116, "deletions": 16}, "files": [{"sha": "232242b552f7f8ffc2644c7087f07c98317ed4c3", "filename": "src/librustc_mir/borrow_check/nll/constraint_set.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/fd0806618c259a31da2c7824610d3224e71dad34/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd0806618c259a31da2c7824610d3224e71dad34/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_set.rs?ref=fd0806618c259a31da2c7824610d3224e71dad34", "patch": "@@ -13,6 +13,7 @@ use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use borrow_check::nll::type_check::Locations;\n \n use std::fmt;\n+use std::cmp::Ordering;\n use std::ops::Deref;\n \n #[derive(Clone, Default)]\n@@ -109,4 +110,39 @@ impl fmt::Debug for OutlivesConstraint {\n     }\n }\n \n+/// Constraints that are considered interesting can be categorized to\n+/// determine why they are interesting.\n+#[derive(Debug, Eq, PartialEq)]\n+crate enum ConstraintCategory {\n+    Assignment,\n+    CallArgument,\n+    Cast,\n+    Other,\n+}\n+\n+impl Ord for ConstraintCategory {\n+    fn cmp(&self, other: &Self) -> Ordering {\n+        if self == other {\n+            return Ordering::Equal;\n+        }\n+\n+        match (self, other) {\n+            (ConstraintCategory::Assignment, _) => Ordering::Greater,\n+            (_, ConstraintCategory::Assignment) => Ordering::Less,\n+            (ConstraintCategory::CallArgument, _) => Ordering::Greater,\n+            (_, ConstraintCategory::CallArgument) => Ordering::Less,\n+            (ConstraintCategory::Cast, _) => Ordering::Greater,\n+            (_, ConstraintCategory::Cast) => Ordering::Less,\n+            (ConstraintCategory::Other, _) => Ordering::Greater,\n+        }\n+    }\n+}\n+\n+impl PartialOrd for ConstraintCategory {\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        Some(self.cmp(other))\n+    }\n+}\n+\n+\n newtype_index!(ConstraintIndex { DEBUG_FORMAT = \"ConstraintIndex({})\" });"}, {"sha": "713ff7002b3246100e5167ce3761c271b01b8692", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 80, "deletions": 16, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/fd0806618c259a31da2c7824610d3224e71dad34/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd0806618c259a31da2c7824610d3224e71dad34/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=fd0806618c259a31da2c7824610d3224e71dad34", "patch": "@@ -10,7 +10,8 @@\n \n use super::universal_regions::UniversalRegions;\n use borrow_check::nll::region_infer::values::ToElementIndex;\n-use borrow_check::nll::constraint_set::{ConstraintIndex, ConstraintSet, OutlivesConstraint};\n+use borrow_check::nll::constraint_set::{ConstraintIndex, ConstraintCategory, ConstraintSet};\n+use borrow_check::nll::constraint_set::{OutlivesConstraint};\n use borrow_check::nll::type_check::Locations;\n use rustc::hir::def_id::DefId;\n use rustc::infer::canonical::QueryRegionConstraint;\n@@ -21,13 +22,14 @@ use rustc::infer::NLLRegionVariableOrigin;\n use rustc::infer::RegionVariableOrigin;\n use rustc::mir::{\n     ClosureOutlivesRequirement, ClosureOutlivesSubject, ClosureRegionRequirements, Local, Location,\n-    Mir,\n+    Mir, StatementKind, TerminatorKind, Rvalue\n };\n use rustc::ty::{self, RegionVid, Ty, TyCtxt, TypeFoldable};\n use rustc::util::common::{self, ErrorReported};\n use rustc_data_structures::bitvec::BitVector;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n+\n use std::rc::Rc;\n use syntax_pos::Span;\n \n@@ -961,10 +963,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             // Note: in this case, we use the unapproximated regions\n             // to report the error. This gives better error messages\n             // in some cases.\n-            self.report_error(infcx, mir_def_id, longer_fr, shorter_fr, blame_span);\n+            self.report_error(mir, infcx, mir_def_id, longer_fr, shorter_fr, blame_span);\n         }\n     }\n \n+    /// When reporting an error, it is useful to be able to determine which constraints influenced\n+    /// the region being reported as an error. This function finds all of the paths from the\n+    /// constraint.\n     fn find_constraint_paths_from_region(\n         &self,\n         r0: RegionVid\n@@ -1055,6 +1060,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         paths\n     }\n \n+    /// This function will return true if a constraint is interesting and false if a constraint\n+    /// is not. It is useful in filtering constraint paths to only interesting points.\n     fn constraint_is_interesting(&self, index: &ConstraintIndex) -> bool {\n         self.constraints.get(*index).filter(|constraint| {\n             debug!(\"constraint_is_interesting: locations={:?} constraint={:?}\",\n@@ -1063,6 +1070,32 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         }).is_some()\n     }\n \n+    /// This function classifies a constraint from a location.\n+    fn classify_constraint(&self, location: Location, mir: &Mir<'tcx>) -> ConstraintCategory {\n+        let data = &mir[location.block];\n+        if location.statement_index == data.statements.len() {\n+            if let Some(ref terminator) = data.terminator {\n+                match terminator.kind {\n+                    TerminatorKind::DropAndReplace { .. } => ConstraintCategory::Assignment,\n+                    TerminatorKind::Call { .. } => ConstraintCategory::CallArgument,\n+                    _ => ConstraintCategory::Other,\n+                }\n+            } else {\n+                ConstraintCategory::Other\n+            }\n+        } else {\n+            let statement = &data.statements[location.statement_index];\n+            match statement.kind {\n+                StatementKind::Assign(_, ref rvalue) => match rvalue {\n+                    Rvalue::Cast(..) => ConstraintCategory::Cast,\n+                    Rvalue::Use(..) => ConstraintCategory::Assignment,\n+                    _ => ConstraintCategory::Other,\n+                },\n+                _ => ConstraintCategory::Other,\n+            }\n+        }\n+    }\n+\n     /// Report an error because the universal region `fr` was required to outlive\n     /// `outlived_fr` but it is not known to do so. For example:\n     ///\n@@ -1073,6 +1106,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Here we would be invoked with `fr = 'a` and `outlived_fr = `'b`.\n     fn report_error(\n         &self,\n+        mir: &Mir<'tcx>,\n         infcx: &InferCtxt<'_, '_, 'tcx>,\n         mir_def_id: DefId,\n         fr: RegionVid,\n@@ -1095,27 +1129,57 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let constraints = self.find_constraint_paths_from_region(fr.clone());\n         let path = constraints.iter().min_by_key(|p| p.len()).unwrap();\n         debug!(\"report_error: path={:?}\", path);\n+\n         let path = path.iter()\n             .filter(|index| self.constraint_is_interesting(index))\n             .collect::<Vec<&ConstraintIndex>>();\n         debug!(\"report_error: path={:?}\", path);\n \n-        let fr_string = match fr_name {\n-            Some(r) => format!(\"free region `{}`\", r),\n-            None => format!(\"free region `{:?}`\", fr),\n-        };\n+        let mut categorized_path = path.iter().filter_map(|index| {\n+            self.constraints.get(**index).iter().filter_map(|constraint| {\n+                let span = constraint.locations.span(mir);\n+                constraint.locations.from_location().iter().filter_map(|location| {\n+                    let classification = self.classify_constraint(*location, mir);\n+                    Some((classification, span))\n+                }).next()\n+            }).next()\n+        }).collect::<Vec<(ConstraintCategory, Span)>>();\n+        debug!(\"report_error: categorized_path={:?}\", categorized_path);\n+\n+        categorized_path.sort_by(|p0, p1| p0.0.cmp(&p1.0));\n+        debug!(\"report_error: sorted_path={:?}\", categorized_path);\n+\n+        if categorized_path.len() > 0 {\n+            let blame_constraint = &categorized_path[0];\n+\n+            let mut diag = infcx.tcx.sess.struct_span_err(\n+                blame_constraint.1,\n+                &format!(\"{:?}\", blame_constraint.0),\n+            );\n \n-        let outlived_fr_string = match outlived_fr_name {\n-            Some(r) => format!(\"free region `{}`\", r),\n-            None => format!(\"free region `{:?}`\", outlived_fr),\n-        };\n+            for secondary in categorized_path.iter().skip(1) {\n+                diag.span_label(secondary.1, format!(\"{:?}\", secondary.0));\n+            }\n \n-        let mut diag = infcx.tcx.sess.struct_span_err(\n-            blame_span,\n-            &format!(\"{} does not outlive {}\", fr_string, outlived_fr_string,),\n-        );\n+            diag.emit();\n+        } else {\n+            let fr_string = match fr_name {\n+                Some(r) => format!(\"free region `{}`\", r),\n+                None => format!(\"free region `{:?}`\", fr),\n+            };\n+\n+            let outlived_fr_string = match outlived_fr_name {\n+                Some(r) => format!(\"free region `{}`\", r),\n+                None => format!(\"free region `{:?}`\", outlived_fr),\n+            };\n+\n+            let mut diag = infcx.tcx.sess.struct_span_err(\n+                blame_span,\n+                &format!(\"{} does not outlive {}\", fr_string, outlived_fr_string,),\n+            );\n \n-        diag.emit();\n+            diag.emit();\n+        }\n     }\n \n     crate fn why_region_contains_point(&self, fr1: RegionVid, elem: Location) -> Option<Cause> {"}]}