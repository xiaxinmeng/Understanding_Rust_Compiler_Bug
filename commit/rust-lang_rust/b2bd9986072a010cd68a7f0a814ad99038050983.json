{"sha": "b2bd9986072a010cd68a7f0a814ad99038050983", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyYmQ5OTg2MDcyYTAxMGNkNjhhN2YwYTgxNGFkOTkwMzgwNTA5ODM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-28T22:36:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-28T22:36:39Z"}, "message": "auto merge of #16027 : treeman/rust/doc-string, r=alexcrichton", "tree": {"sha": "18f791925b0ee0801a83aa8ea64f9e0433dc23de", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/18f791925b0ee0801a83aa8ea64f9e0433dc23de"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b2bd9986072a010cd68a7f0a814ad99038050983", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b2bd9986072a010cd68a7f0a814ad99038050983", "html_url": "https://github.com/rust-lang/rust/commit/b2bd9986072a010cd68a7f0a814ad99038050983", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b2bd9986072a010cd68a7f0a814ad99038050983/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "279a7808041f5b63050b05c134d9985efb7ffb73", "url": "https://api.github.com/repos/rust-lang/rust/commits/279a7808041f5b63050b05c134d9985efb7ffb73", "html_url": "https://github.com/rust-lang/rust/commit/279a7808041f5b63050b05c134d9985efb7ffb73"}, {"sha": "3f568464608ad39f1d620b81d97f844015f971a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f568464608ad39f1d620b81d97f844015f971a1", "html_url": "https://github.com/rust-lang/rust/commit/3f568464608ad39f1d620b81d97f844015f971a1"}], "stats": {"total": 286, "additions": 261, "deletions": 25}, "files": [{"sha": "e5c2d98519163926720ceccbbd5c78194e8d1ece", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 261, "deletions": 25, "changes": 286, "blob_url": "https://github.com/rust-lang/rust/blob/b2bd9986072a010cd68a7f0a814ad99038050983/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2bd9986072a010cd68a7f0a814ad99038050983/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=b2bd9986072a010cd68a7f0a814ad99038050983", "patch": "@@ -34,6 +34,12 @@ pub struct String {\n \n impl String {\n     /// Creates a new string buffer initialized with the empty string.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let mut s = String::new();\n+    /// ```\n     #[inline]\n     pub fn new() -> String {\n         String {\n@@ -42,6 +48,14 @@ impl String {\n     }\n \n     /// Creates a new string buffer with the given capacity.\n+    /// The string will be able to hold exactly `capacity` bytes without\n+    /// reallocating. If `capacity` is 0, the string will not allocate.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let mut s = String::with_capacity(10);\n+    /// ```\n     #[inline]\n     pub fn with_capacity(capacity: uint) -> String {\n         String {\n@@ -50,6 +64,13 @@ impl String {\n     }\n \n     /// Creates a new string buffer from the given string.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let s = String::from_str(\"hello\");\n+    /// assert_eq!(s.as_slice(), \"hello\");\n+    /// ```\n     #[inline]\n     pub fn from_str(string: &str) -> String {\n         String {\n@@ -64,7 +85,7 @@ impl String {\n         raw::from_parts(ptr, length, capacity)\n     }\n \n-    #[allow(missing_doc)]\n+    /// Deprecated.\n     #[deprecated = \"obsoleted by the removal of ~str\"]\n     #[inline]\n     pub fn from_owned_str(string: String) -> String {\n@@ -81,8 +102,12 @@ impl String {\n     ///\n     /// ```rust\n     /// let hello_vec = vec![104, 101, 108, 108, 111];\n-    /// let string = String::from_utf8(hello_vec);\n-    /// assert_eq!(string, Ok(\"hello\".to_string()));\n+    /// let s = String::from_utf8(hello_vec);\n+    /// assert_eq!(s, Ok(\"hello\".to_string()));\n+    ///\n+    /// let invalid_vec = vec![240, 144, 128];\n+    /// let s = String::from_utf8(invalid_vec);\n+    /// assert_eq!(s, Err(vec![240, 144, 128]));\n     /// ```\n     #[inline]\n     pub fn from_utf8(vec: Vec<u8>) -> Result<String, Vec<u8>> {\n@@ -262,35 +287,60 @@ impl String {\n         str::utf16_items(v).map(|c| c.to_char_lossy()).collect()\n     }\n \n-    /// Convert a vector of chars to a string\n+    /// Convert a vector of chars to a string.\n     ///\n     /// # Example\n     ///\n     /// ```rust\n     /// let chars = ['h', 'e', 'l', 'l', 'o'];\n-    /// let string = String::from_chars(chars);\n-    /// assert_eq!(string.as_slice(), \"hello\");\n+    /// let s = String::from_chars(chars);\n+    /// assert_eq!(s.as_slice(), \"hello\");\n     /// ```\n     #[inline]\n     pub fn from_chars(chs: &[char]) -> String {\n         chs.iter().map(|c| *c).collect()\n     }\n \n     /// Return the underlying byte buffer, encoded as UTF-8.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let s = String::from_str(\"hello\");\n+    /// let bytes = s.into_bytes();\n+    /// assert_eq!(bytes, vec![104, 101, 108, 108, 111]);\n+    /// ```\n     #[inline]\n     pub fn into_bytes(self) -> Vec<u8> {\n         self.vec\n     }\n \n     /// Pushes the given string onto this buffer; then, returns `self` so that it can be used\n     /// again.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let s = String::from_str(\"hello\");\n+    /// let big = s.append(\" \").append(\"world\").append(\"!\");\n+    /// // s has now been moved and cannot be used\n+    ///\n+    /// assert_eq!(big.as_slice(), \"hello world!\");\n+    /// ```\n     #[inline]\n     pub fn append(mut self, second: &str) -> String {\n         self.push_str(second);\n         self\n     }\n \n     /// Creates a string buffer by repeating a character `length` times.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let s = String::from_char(5, 'a');\n+    /// assert_eq!(s.as_slice(), \"aaaaa\");\n+    /// ```\n     #[inline]\n     pub fn from_char(length: uint, ch: char) -> String {\n         if length == 0 {\n@@ -307,7 +357,7 @@ impl String {\n         buf\n     }\n \n-    /// Convert a byte to a UTF-8 string\n+    /// Convert a byte to a UTF-8 string.\n     ///\n     /// # Failure\n     ///\n@@ -316,21 +366,37 @@ impl String {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let string = String::from_byte(104);\n-    /// assert_eq!(string.as_slice(), \"h\");\n+    /// let s = String::from_byte(104);\n+    /// assert_eq!(s.as_slice(), \"h\");\n     /// ```\n     pub fn from_byte(b: u8) -> String {\n         assert!(b < 128u8);\n         String::from_char(1, b as char)\n     }\n \n     /// Pushes the given string onto this string buffer.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let mut s = String::from_str(\"foo\");\n+    /// s.push_str(\"bar\");\n+    /// assert_eq!(s.as_slice(), \"foobar\");\n+    /// ```\n     #[inline]\n     pub fn push_str(&mut self, string: &str) {\n         self.vec.push_all(string.as_bytes())\n     }\n \n     /// Push `ch` onto the given string `count` times.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let mut s = String::from_str(\"foo\");\n+    /// s.grow(5, 'Z');\n+    /// assert_eq!(s.as_slice(), \"fooZZZZZ\");\n+    /// ```\n     #[inline]\n     pub fn grow(&mut self, count: uint, ch: char) {\n         for _ in range(0, count) {\n@@ -339,36 +405,88 @@ impl String {\n     }\n \n     /// Returns the number of bytes that this string buffer can hold without reallocating.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let s = String::with_capacity(10);\n+    /// assert!(s.byte_capacity() >= 10);\n+    /// ```\n     #[inline]\n     pub fn byte_capacity(&self) -> uint {\n         self.vec.capacity()\n     }\n \n     /// Reserves capacity for at least `extra` additional bytes in this string buffer.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let mut s = String::with_capacity(10);\n+    /// let before = s.byte_capacity();\n+    /// s.reserve_additional(100);\n+    /// assert!(s.byte_capacity() - before >= 100);\n+    /// ```\n     #[inline]\n     pub fn reserve_additional(&mut self, extra: uint) {\n         self.vec.reserve_additional(extra)\n     }\n \n     /// Reserves capacity for at least `capacity` bytes in this string buffer.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let mut s = String::new();\n+    /// s.reserve(10);\n+    /// assert!(s.byte_capacity() >= 10);\n+    /// ```\n     #[inline]\n     pub fn reserve(&mut self, capacity: uint) {\n         self.vec.reserve(capacity)\n     }\n \n     /// Reserves capacity for exactly `capacity` bytes in this string buffer.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let mut s = String::new();\n+    /// s.reserve_exact(10);\n+    /// assert_eq!(s.byte_capacity(), 10);\n+    /// ```\n     #[inline]\n     pub fn reserve_exact(&mut self, capacity: uint) {\n         self.vec.reserve_exact(capacity)\n     }\n \n     /// Shrinks the capacity of this string buffer to match its length.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let mut s = String::from_str(\"foo\");\n+    /// s.reserve(100);\n+    /// assert!(s.byte_capacity() >= 100);\n+    /// s.shrink_to_fit();\n+    /// assert_eq!(s.byte_capacity(), 3);\n+    /// ```\n     #[inline]\n     pub fn shrink_to_fit(&mut self) {\n         self.vec.shrink_to_fit()\n     }\n \n     /// Adds the given character to the end of the string.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let mut s = String::from_str(\"abc\");\n+    /// s.push_char('1');\n+    /// s.push_char('2');\n+    /// s.push_char('3');\n+    /// assert_eq!(s.as_slice(), \"abc123\");\n+    /// ```\n     #[inline]\n     pub fn push_char(&mut self, ch: char) {\n         let cur_len = self.len();\n@@ -387,43 +505,114 @@ impl String {\n         }\n     }\n \n-    /// Pushes the given bytes onto this string buffer. This is unsafe because it does not check\n+    /// Pushes the given bytes onto this string buffer.\n+    /// This is unsafe because it does not check\n     /// to ensure that the resulting string will be valid UTF-8.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let mut s = String::new();\n+    /// unsafe {\n+    ///     s.push_bytes([104, 101, 108, 108, 111]);\n+    /// }\n+    /// assert_eq!(s.as_slice(), \"hello\");\n+    /// ```\n     #[inline]\n     pub unsafe fn push_bytes(&mut self, bytes: &[u8]) {\n         self.vec.push_all(bytes)\n     }\n \n     /// Works with the underlying buffer as a byte slice.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let s = String::from_str(\"hello\");\n+    /// assert_eq!(s.as_bytes(), &[104, 101, 108, 108, 111]);\n+    /// ```\n     #[inline]\n     pub fn as_bytes<'a>(&'a self) -> &'a [u8] {\n         self.vec.as_slice()\n     }\n \n-    /// Works with the underlying buffer as a mutable byte slice. Unsafe\n-    /// because this can be used to violate the UTF-8 property.\n+    /// Works with the underlying buffer as a mutable byte slice.\n+    ///\n+    /// This is unsafe because it does not check\n+    /// to ensure that the resulting string will be valid UTF-8.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let mut s = String::from_str(\"hello\");\n+    /// unsafe {\n+    ///     let bytes = s.as_mut_bytes();\n+    ///     bytes[1] = 51;\n+    ///     bytes[4] = 48;\n+    /// }\n+    /// assert_eq!(s.as_bytes(), &[104, 51, 108, 108, 48]);\n+    /// assert_eq!(s.as_slice(), \"h3ll0\")\n+    /// ```\n     #[inline]\n     pub unsafe fn as_mut_bytes<'a>(&'a mut self) -> &'a mut [u8] {\n         self.vec.as_mut_slice()\n     }\n \n-    /// Shorten a string to the specified length (which must be <= the current length)\n+    /// Shorten a string to the specified length.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if `len` > current length.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let mut s = String::from_str(\"hello\");\n+    /// s.truncate(2);\n+    /// assert_eq!(s.as_slice(), \"he\");\n+    /// ```\n     #[inline]\n     pub fn truncate(&mut self, len: uint) {\n         assert!(self.as_slice().is_char_boundary(len));\n         self.vec.truncate(len)\n     }\n \n-    /// Appends a byte to this string buffer. The caller must preserve the valid UTF-8 property.\n+    /// Appends a byte to this string buffer.\n+    ///\n+    /// This is unsafe because it does not check\n+    /// to ensure that the resulting string will be valid UTF-8.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let mut s = String::from_str(\"hell\");\n+    /// unsafe {\n+    ///     s.push_byte(111);\n+    /// }\n+    /// assert_eq!(s.as_slice(), \"hello\");\n+    /// ```\n     #[inline]\n     pub unsafe fn push_byte(&mut self, byte: u8) {\n         self.vec.push(byte)\n     }\n \n-    /// Removes the last byte from the string buffer and returns it. Returns `None` if this string\n-    /// buffer is empty.\n+    /// Removes the last byte from the string buffer and returns it.\n+    /// Returns `None` if this string buffer is empty.\n+    ///\n+    /// This is unsafe because it does not check\n+    /// to ensure that the resulting string will be valid UTF-8.\n+    ///\n+    /// # Example\n     ///\n-    /// The caller must preserve the valid UTF-8 property.\n+    /// ```\n+    /// let mut s = String::from_str(\"foo\");\n+    /// unsafe {\n+    ///     assert_eq!(s.pop_byte(), Some(111));\n+    ///     assert_eq!(s.pop_byte(), Some(111));\n+    ///     assert_eq!(s.pop_byte(), Some(102));\n+    ///     assert_eq!(s.pop_byte(), None);\n+    /// }\n+    /// ```\n     #[inline]\n     pub unsafe fn pop_byte(&mut self) -> Option<u8> {\n         let len = self.len();\n@@ -436,8 +625,18 @@ impl String {\n         Some(byte)\n     }\n \n-    /// Removes the last character from the string buffer and returns it. Returns `None` if this\n-    /// string buffer is empty.\n+    /// Removes the last character from the string buffer and returns it.\n+    /// Returns `None` if this string buffer is empty.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let mut s = String::from_str(\"foo\");\n+    /// assert_eq!(s.pop_char(), Some('o'));\n+    /// assert_eq!(s.pop_char(), Some('o'));\n+    /// assert_eq!(s.pop_char(), Some('f'));\n+    /// assert_eq!(s.pop_char(), None);\n+    /// ```\n     #[inline]\n     pub fn pop_char(&mut self) -> Option<char> {\n         let len = self.len();\n@@ -452,20 +651,43 @@ impl String {\n         Some(ch)\n     }\n \n-    /// Removes the first byte from the string buffer and returns it. Returns `None` if this string\n-    /// buffer is empty.\n+    /// Removes the first byte from the string buffer and returns it.\n+    /// Returns `None` if this string buffer is empty.\n     ///\n-    /// The caller must preserve the valid UTF-8 property.\n+    /// This is unsafe because it does not check\n+    /// to ensure that the resulting string will be valid UTF-8.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let mut s = String::from_str(\"foo\");\n+    /// unsafe {\n+    ///     assert_eq!(s.shift_byte(), Some(102));\n+    ///     assert_eq!(s.shift_byte(), Some(111));\n+    ///     assert_eq!(s.shift_byte(), Some(111));\n+    ///     assert_eq!(s.shift_byte(), None);\n+    /// }\n+    /// ```\n     pub unsafe fn shift_byte(&mut self) -> Option<u8> {\n         self.vec.shift()\n     }\n \n-    /// Removes the first character from the string buffer and returns it. Returns `None` if this\n-    /// string buffer is empty.\n+    /// Removes the first character from the string buffer and returns it.\n+    /// Returns `None` if this string buffer is empty.\n     ///\n     /// # Warning\n     ///\n     /// This is a O(n) operation as it requires copying every element in the buffer.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let mut s = String::from_str(\"foo\");\n+    /// assert_eq!(s.shift_char(), Some('f'));\n+    /// assert_eq!(s.shift_char(), Some('o'));\n+    /// assert_eq!(s.shift_char(), Some('o'));\n+    /// assert_eq!(s.shift_char(), None);\n+    /// ```\n     pub fn shift_char (&mut self) -> Option<char> {\n         let len = self.len();\n         if len == 0 {\n@@ -483,7 +705,20 @@ impl String {\n \n     /// Views the string buffer as a mutable sequence of bytes.\n     ///\n-    /// Callers must preserve the valid UTF-8 property.\n+    /// This is unsafe because it does not check\n+    /// to ensure that the resulting string will be valid UTF-8.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let mut s = String::from_str(\"hello\");\n+    /// unsafe {\n+    ///     let vec = s.as_mut_vec();\n+    ///     assert!(vec == &mut vec![104, 101, 108, 108, 111]);\n+    ///     vec.reverse();\n+    /// }\n+    /// assert_eq!(s.as_slice(), \"olleh\");\n+    /// ```\n     pub unsafe fn as_mut_vec<'a>(&'a mut self) -> &'a mut Vec<u8> {\n         &mut self.vec\n     }\n@@ -569,6 +804,7 @@ impl<S: Str> Add<S, String> for String {\n     }\n }\n \n+/// Unsafe operations\n pub mod raw {\n     use core::mem;\n     use core::ptr::RawPtr;"}]}