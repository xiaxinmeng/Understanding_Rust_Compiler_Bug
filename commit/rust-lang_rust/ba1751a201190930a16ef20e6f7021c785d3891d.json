{"sha": "ba1751a201190930a16ef20e6f7021c785d3891d", "node_id": "C_kwDOAAsO6NoAKGJhMTc1MWEyMDExOTA5MzBhMTZlZjIwZTZmNzAyMWM3ODVkMzg5MWQ", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-11-29T07:43:44Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-11-29T07:43:53Z"}, "message": "Avoid more `MetaItem`-to-`Attribute` conversions.\n\nThere is code for converting `Attribute` (syntactic) to `MetaItem`\n(semantic). There is also code for the reverse direction. The reverse\ndirection isn't really necessary; it's currently only used when\ngenerating attributes, e.g. in `derive` code.\n\nThis commit adds some new functions for creating `Attributes`s directly,\nwithout involving `MetaItem`s: `mk_attr_word`, `mk_attr_name_value_str`,\n`mk_attr_nested_word`, and\n`ExtCtxt::attr_{word,name_value_str,nested_word}`.\n\nThese new methods replace the old functions for creating `Attribute`s:\n`mk_attr_inner`, `mk_attr_outer`, and `ExtCtxt::attribute`. Those\nfunctions took `MetaItem`s as input, and relied on many other functions\nthat created `MetaItems`, which are also removed: `mk_name_value_item`,\n`mk_list_item`, `mk_word_item`, `mk_nested_word_item`,\n`{MetaItem,MetaItemKind,NestedMetaItem}::token_trees`,\n`MetaItemKind::attr_args`, `MetaItemLit::{from_lit_kind,to_token}`,\n`ExtCtxt::meta_word`.\n\nOverall this cuts more than 100 lines of code and makes thing simpler.", "tree": {"sha": "92ed98b14b8dff861b25e35c0f0d3cbb1379aafa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/92ed98b14b8dff861b25e35c0f0d3cbb1379aafa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ba1751a201190930a16ef20e6f7021c785d3891d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ba1751a201190930a16ef20e6f7021c785d3891d", "html_url": "https://github.com/rust-lang/rust/commit/ba1751a201190930a16ef20e6f7021c785d3891d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ba1751a201190930a16ef20e6f7021c785d3891d/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1b61a31c5d28075f7c5a7f376315350672e2d93", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1b61a31c5d28075f7c5a7f376315350672e2d93", "html_url": "https://github.com/rust-lang/rust/commit/d1b61a31c5d28075f7c5a7f376315350672e2d93"}], "stats": {"total": 327, "additions": 116, "deletions": 211}, "files": [{"sha": "057cc26b5799e7eff82d0d6b7ad30eade281be53", "filename": "compiler/rustc_ast/src/attr/mod.rs", "status": "modified", "additions": 52, "deletions": 115, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/ba1751a201190930a16ef20e6f7021c785d3891d/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba1751a201190930a16ef20e6f7021c785d3891d/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs?ref=ba1751a201190930a16ef20e6f7021c785d3891d", "patch": "@@ -1,18 +1,17 @@\n //! Functions dealing with attributes and meta items.\n \n use crate::ast;\n-use crate::ast::{AttrArgs, AttrArgsEq, AttrId, AttrItem, AttrKind, AttrStyle, Attribute};\n-use crate::ast::{DelimArgs, LitKind, MetaItemLit};\n-use crate::ast::{MacDelimiter, MetaItem, MetaItemKind, NestedMetaItem};\n-use crate::ast::{Path, PathSegment};\n+use crate::ast::{AttrArgs, AttrArgsEq, AttrId, AttrItem, AttrKind, AttrStyle, AttrVec, Attribute};\n+use crate::ast::{DelimArgs, Expr, ExprKind, LitKind, MetaItemLit};\n+use crate::ast::{MacDelimiter, MetaItem, MetaItemKind, NestedMetaItem, NormalAttr};\n+use crate::ast::{Path, PathSegment, StrStyle, DUMMY_NODE_ID};\n use crate::ptr::P;\n use crate::token::{self, CommentKind, Delimiter, Token};\n use crate::tokenstream::{DelimSpan, Spacing, TokenTree};\n use crate::tokenstream::{LazyAttrTokenStream, TokenStream};\n use crate::util::comments;\n use rustc_data_structures::sync::WorkerLocal;\n use rustc_index::bit_set::GrowableBitSet;\n-use rustc_span::source_map::BytePos;\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::Span;\n use std::cell::Cell;\n@@ -223,11 +222,7 @@ impl AttrItem {\n     }\n \n     pub fn meta(&self, span: Span) -> Option<MetaItem> {\n-        Some(MetaItem {\n-            path: self.path.clone(),\n-            kind: MetaItemKind::from_attr_args(&self.args)?,\n-            span,\n-        })\n+        Some(MetaItem { path: self.path.clone(), kind: self.meta_kind()?, span })\n     }\n \n     pub fn meta_kind(&self) -> Option<MetaItemKind> {\n@@ -329,26 +324,13 @@ impl Attribute {\n /* Constructors */\n \n pub fn mk_name_value_item_str(ident: Ident, str: Symbol, str_span: Span) -> MetaItem {\n-    let lit_kind = LitKind::Str(str, ast::StrStyle::Cooked);\n-    mk_name_value_item(ident, lit_kind, str_span)\n+    mk_name_value_item(ident, LitKind::Str(str, ast::StrStyle::Cooked), str_span)\n }\n \n pub fn mk_name_value_item(ident: Ident, kind: LitKind, lit_span: Span) -> MetaItem {\n     let lit = MetaItemLit { token_lit: kind.to_token_lit(), kind, span: lit_span };\n     let span = ident.span.to(lit_span);\n-    MetaItem { path: Path::from_ident(ident), span, kind: MetaItemKind::NameValue(lit) }\n-}\n-\n-pub fn mk_list_item(ident: Ident, items: Vec<NestedMetaItem>) -> MetaItem {\n-    MetaItem { path: Path::from_ident(ident), span: ident.span, kind: MetaItemKind::List(items) }\n-}\n-\n-pub fn mk_word_item(ident: Ident) -> MetaItem {\n-    MetaItem { path: Path::from_ident(ident), span: ident.span, kind: MetaItemKind::Word }\n-}\n-\n-pub fn mk_nested_word_item(ident: Ident) -> NestedMetaItem {\n-    NestedMetaItem::MetaItem(mk_word_item(ident))\n+    MetaItem { path: Path::from_ident(ident), kind: MetaItemKind::NameValue(lit), span }\n }\n \n pub struct AttrIdGenerator(WorkerLocal<Cell<u32>>);\n@@ -406,21 +388,58 @@ pub fn mk_attr_from_item(\n     span: Span,\n ) -> Attribute {\n     Attribute {\n-        kind: AttrKind::Normal(P(ast::NormalAttr { item, tokens })),\n+        kind: AttrKind::Normal(P(NormalAttr { item, tokens })),\n         id: g.mk_attr_id(),\n         style,\n         span,\n     }\n }\n \n-/// Returns an inner attribute with the given value and span.\n-pub fn mk_attr_inner(g: &AttrIdGenerator, item: MetaItem) -> Attribute {\n-    mk_attr(g, AttrStyle::Inner, item.path, item.kind.attr_args(item.span), item.span)\n+pub fn mk_attr_word(g: &AttrIdGenerator, style: AttrStyle, name: Symbol, span: Span) -> Attribute {\n+    let path = Path::from_ident(Ident::new(name, span));\n+    let args = AttrArgs::Empty;\n+    mk_attr(g, style, path, args, span)\n+}\n+\n+pub fn mk_attr_name_value_str(\n+    g: &AttrIdGenerator,\n+    style: AttrStyle,\n+    name: Symbol,\n+    val: Symbol,\n+    span: Span,\n+) -> Attribute {\n+    let lit = LitKind::Str(val, StrStyle::Cooked).to_token_lit();\n+    let expr = P(Expr {\n+        id: DUMMY_NODE_ID,\n+        kind: ExprKind::Lit(lit),\n+        span,\n+        attrs: AttrVec::new(),\n+        tokens: None,\n+    });\n+    let path = Path::from_ident(Ident::new(name, span));\n+    let args = AttrArgs::Eq(span, AttrArgsEq::Ast(expr));\n+    mk_attr(g, style, path, args, span)\n }\n \n-/// Returns an outer attribute with the given value and span.\n-pub fn mk_attr_outer(g: &AttrIdGenerator, item: MetaItem) -> Attribute {\n-    mk_attr(g, AttrStyle::Outer, item.path, item.kind.attr_args(item.span), item.span)\n+pub fn mk_attr_nested_word(\n+    g: &AttrIdGenerator,\n+    style: AttrStyle,\n+    outer: Symbol,\n+    inner: Symbol,\n+    span: Span,\n+) -> Attribute {\n+    let inner_tokens = TokenStream::new(vec![TokenTree::Token(\n+        Token::from_ast_ident(Ident::new(inner, span)),\n+        Spacing::Alone,\n+    )]);\n+    let outer_ident = Ident::new(outer, span);\n+    let path = Path::from_ident(outer_ident);\n+    let attr_args = AttrArgs::Delimited(DelimArgs {\n+        dspan: DelimSpan::from_single(span),\n+        delim: MacDelimiter::Parenthesis,\n+        tokens: inner_tokens,\n+    });\n+    mk_attr(g, style, path, attr_args, span)\n }\n \n pub fn mk_doc_comment(\n@@ -438,23 +457,6 @@ pub fn list_contains_name(items: &[NestedMetaItem], name: Symbol) -> bool {\n }\n \n impl MetaItem {\n-    fn token_trees(&self) -> Vec<TokenTree> {\n-        let mut idents = vec![];\n-        let mut last_pos = BytePos(0_u32);\n-        for (i, segment) in self.path.segments.iter().enumerate() {\n-            let is_first = i == 0;\n-            if !is_first {\n-                let mod_sep_span =\n-                    Span::new(last_pos, segment.ident.span.lo(), segment.ident.span.ctxt(), None);\n-                idents.push(TokenTree::token_alone(token::ModSep, mod_sep_span));\n-            }\n-            idents.push(TokenTree::Token(Token::from_ast_ident(segment.ident), Spacing::Alone));\n-            last_pos = segment.ident.span.hi();\n-        }\n-        idents.extend(self.kind.token_trees(self.span));\n-        idents\n-    }\n-\n     fn from_tokens<I>(tokens: &mut iter::Peekable<I>) -> Option<MetaItem>\n     where\n         I: Iterator<Item = TokenTree>,\n@@ -526,62 +528,6 @@ impl MetaItemKind {\n         }\n     }\n \n-    pub fn attr_args(&self, span: Span) -> AttrArgs {\n-        match self {\n-            MetaItemKind::Word => AttrArgs::Empty,\n-            MetaItemKind::NameValue(lit) => {\n-                let expr = P(ast::Expr {\n-                    id: ast::DUMMY_NODE_ID,\n-                    kind: ast::ExprKind::Lit(lit.token_lit.clone()),\n-                    span: lit.span,\n-                    attrs: ast::AttrVec::new(),\n-                    tokens: None,\n-                });\n-                AttrArgs::Eq(span, AttrArgsEq::Ast(expr))\n-            }\n-            MetaItemKind::List(list) => {\n-                let mut tts = Vec::new();\n-                for (i, item) in list.iter().enumerate() {\n-                    if i > 0 {\n-                        tts.push(TokenTree::token_alone(token::Comma, span));\n-                    }\n-                    tts.extend(item.token_trees())\n-                }\n-                AttrArgs::Delimited(DelimArgs {\n-                    dspan: DelimSpan::from_single(span),\n-                    delim: MacDelimiter::Parenthesis,\n-                    tokens: TokenStream::new(tts),\n-                })\n-            }\n-        }\n-    }\n-\n-    fn token_trees(&self, span: Span) -> Vec<TokenTree> {\n-        match self {\n-            MetaItemKind::Word => vec![],\n-            MetaItemKind::NameValue(lit) => {\n-                vec![\n-                    TokenTree::token_alone(token::Eq, span),\n-                    TokenTree::Token(lit.to_token(), Spacing::Alone),\n-                ]\n-            }\n-            MetaItemKind::List(list) => {\n-                let mut tokens = Vec::new();\n-                for (i, item) in list.iter().enumerate() {\n-                    if i > 0 {\n-                        tokens.push(TokenTree::token_alone(token::Comma, span));\n-                    }\n-                    tokens.extend(item.token_trees())\n-                }\n-                vec![TokenTree::Delimited(\n-                    DelimSpan::from_single(span),\n-                    Delimiter::Parenthesis,\n-                    TokenStream::new(tokens),\n-                )]\n-            }\n-        }\n-    }\n-\n     fn list_from_tokens(tokens: TokenStream) -> Option<MetaItemKind> {\n         let mut tokens = tokens.into_trees().peekable();\n         let mut result = Vec::new();\n@@ -620,7 +566,7 @@ impl MetaItemKind {\n             }) => MetaItemKind::list_from_tokens(tokens.clone()),\n             AttrArgs::Delimited(..) => None,\n             AttrArgs::Eq(_, AttrArgsEq::Ast(expr)) => match expr.kind {\n-                ast::ExprKind::Lit(token_lit) => {\n+                ExprKind::Lit(token_lit) => {\n                     // Turn failures to `None`, we'll get parse errors elsewhere.\n                     MetaItemLit::from_token_lit(token_lit, expr.span)\n                         .ok()\n@@ -659,15 +605,6 @@ impl NestedMetaItem {\n         }\n     }\n \n-    fn token_trees(&self) -> Vec<TokenTree> {\n-        match self {\n-            NestedMetaItem::MetaItem(item) => item.token_trees(),\n-            NestedMetaItem::Lit(lit) => {\n-                vec![TokenTree::Token(lit.to_token(), Spacing::Alone)]\n-            }\n-        }\n-    }\n-\n     fn from_tokens<I>(tokens: &mut iter::Peekable<I>) -> Option<NestedMetaItem>\n     where\n         I: Iterator<Item = TokenTree>,"}, {"sha": "1d6e7914f3a5c8d0395de312564765bc7dbcb688", "filename": "compiler/rustc_ast/src/util/literal.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ba1751a201190930a16ef20e6f7021c785d3891d/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba1751a201190930a16ef20e6f7021c785d3891d/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs?ref=ba1751a201190930a16ef20e6f7021c785d3891d", "patch": "@@ -206,15 +206,6 @@ impl MetaItemLit {\n         token::Lit::from_token(token)\n             .and_then(|token_lit| MetaItemLit::from_token_lit(token_lit, token.span).ok())\n     }\n-\n-    /// Losslessly convert a meta item literal into a token.\n-    pub fn to_token(&self) -> Token {\n-        let kind = match self.token_lit.kind {\n-            token::Bool => token::Ident(self.token_lit.symbol, false),\n-            _ => token::Literal(self.token_lit),\n-        };\n-        Token::new(kind, self.span)\n-    }\n }\n \n fn strip_underscores(symbol: Symbol) -> Symbol {"}, {"sha": "82912a733d55222ca2a29b324eb0f106934054ae", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ba1751a201190930a16ef20e6f7021c785d3891d/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba1751a201190930a16ef20e6f7021c785d3891d/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=ba1751a201190930a16ef20e6f7021c785d3891d", "patch": "@@ -1606,16 +1606,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         };\n \n         // `#[allow(unreachable_code)]`\n-        let attr = {\n-            // `allow(unreachable_code)`\n-            let allow = {\n-                let allow_ident = Ident::new(sym::allow, self.lower_span(span));\n-                let uc_ident = Ident::new(sym::unreachable_code, self.lower_span(span));\n-                let uc_nested = attr::mk_nested_word_item(uc_ident);\n-                attr::mk_list_item(allow_ident, vec![uc_nested])\n-            };\n-            attr::mk_attr_outer(&self.tcx.sess.parse_sess.attr_id_generator, allow)\n-        };\n+        let attr = attr::mk_attr_nested_word(\n+            &self.tcx.sess.parse_sess.attr_id_generator,\n+            AttrStyle::Outer,\n+            sym::allow,\n+            sym::unreachable_code,\n+            self.lower_span(span),\n+        );\n         let attrs: AttrVec = thin_vec![attr];\n \n         // `ControlFlow::Continue(val) => #[allow(unreachable_code)] val,`"}, {"sha": "2d7fd83195d9448f1f660e48b5e6b0205ea2061c", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ba1751a201190930a16ef20e6f7021c785d3891d/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba1751a201190930a16ef20e6f7021c785d3891d/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=ba1751a201190930a16ef20e6f7021c785d3891d", "patch": "@@ -19,7 +19,7 @@ use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n use rustc_span::edition::Edition;\n use rustc_span::source_map::{SourceMap, Spanned};\n use rustc_span::symbol::{kw, sym, Ident, IdentPrinter, Symbol};\n-use rustc_span::{BytePos, FileName, Span};\n+use rustc_span::{BytePos, FileName, Span, DUMMY_SP};\n \n use rustc_ast::attr::AttrIdGenerator;\n use std::borrow::Cow;\n@@ -119,17 +119,20 @@ pub fn print_crate<'a>(\n         // of the feature gate, so we fake them up here.\n \n         // `#![feature(prelude_import)]`\n-        let pi_nested = attr::mk_nested_word_item(Ident::with_dummy_span(sym::prelude_import));\n-        let list = attr::mk_list_item(Ident::with_dummy_span(sym::feature), vec![pi_nested]);\n-        let fake_attr = attr::mk_attr_inner(g, list);\n+        let fake_attr = attr::mk_attr_nested_word(\n+            g,\n+            ast::AttrStyle::Inner,\n+            sym::feature,\n+            sym::prelude_import,\n+            DUMMY_SP,\n+        );\n         s.print_attribute(&fake_attr);\n \n         // Currently, in Rust 2018 we don't have `extern crate std;` at the crate\n         // root, so this is not needed, and actually breaks things.\n         if edition == Edition::Edition2015 {\n             // `#![no_std]`\n-            let no_std_meta = attr::mk_word_item(Ident::with_dummy_span(sym::no_std));\n-            let fake_attr = attr::mk_attr_inner(g, no_std_meta);\n+            let fake_attr = attr::mk_attr_word(g, ast::AttrStyle::Inner, sym::no_std, DUMMY_SP);\n             s.print_attribute(&fake_attr);\n         }\n     }\n@@ -1712,9 +1715,9 @@ impl<'a> State<'a> {\n             where_clause: ast::WhereClause {\n                 has_where_token: false,\n                 predicates: Vec::new(),\n-                span: rustc_span::DUMMY_SP,\n+                span: DUMMY_SP,\n             },\n-            span: rustc_span::DUMMY_SP,\n+            span: DUMMY_SP,\n         };\n         let header = ast::FnHeader { unsafety, ext, ..ast::FnHeader::default() };\n         self.print_fn(decl, header, name, &generics);"}, {"sha": "460175ed2ac84bb35abb7d29181ac418ecb5cd61", "filename": "compiler/rustc_builtin_macros/src/alloc_error_handler.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ba1751a201190930a16ef20e6f7021c785d3891d/compiler%2Frustc_builtin_macros%2Fsrc%2Falloc_error_handler.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba1751a201190930a16ef20e6f7021c785d3891d/compiler%2Frustc_builtin_macros%2Fsrc%2Falloc_error_handler.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Falloc_error_handler.rs?ref=ba1751a201190930a16ef20e6f7021c785d3891d", "patch": "@@ -95,9 +95,7 @@ fn generate_handler(cx: &ExtCtxt<'_>, handler: Ident, span: Span, sig_span: Span\n         body,\n     }));\n \n-    let special = sym::rustc_std_internal_symbol;\n-    let special = cx.meta_word(span, special);\n-    let attrs = thin_vec![cx.attribute(special)];\n+    let attrs = thin_vec![cx.attr_word(sym::rustc_std_internal_symbol, span)];\n \n     let item = cx.item(span, Ident::from_str_and_span(\"__rg_oom\", span), attrs, kind);\n     cx.stmt_item(sig_span, item)"}, {"sha": "bd415901ae34dc7d900b818ba5fd965bc509d89e", "filename": "compiler/rustc_builtin_macros/src/assert/context.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ba1751a201190930a16ef20e6f7021c785d3891d/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba1751a201190930a16ef20e6f7021c785d3891d/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs?ref=ba1751a201190930a16ef20e6f7021c785d3891d", "patch": "@@ -1,5 +1,4 @@\n use rustc_ast::{\n-    attr,\n     ptr::P,\n     token,\n     tokenstream::{DelimSpan, TokenStream, TokenTree},\n@@ -118,10 +117,7 @@ impl<'cx, 'a> Context<'cx, 'a> {\n             self.cx.item(\n                 self.span,\n                 Ident::empty(),\n-                thin_vec![self.cx.attribute(attr::mk_list_item(\n-                    Ident::new(sym::allow, self.span),\n-                    vec![attr::mk_nested_word_item(Ident::new(sym::unused_imports, self.span))],\n-                ))],\n+                thin_vec![self.cx.attr_nested_word(sym::allow, sym::unused_imports, self.span)],\n                 ItemKind::Use(UseTree {\n                     prefix: self.cx.path(self.span, self.cx.std_path(&[sym::asserting])),\n                     kind: UseTreeKind::Nested(vec!["}, {"sha": "23b96d4176d3a27391d2d5d80491eae91b2b719e", "filename": "compiler/rustc_builtin_macros/src/deriving/clone.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ba1751a201190930a16ef20e6f7021c785d3891d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba1751a201190930a16ef20e6f7021c785d3891d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs?ref=ba1751a201190930a16ef20e6f7021c785d3891d", "patch": "@@ -68,8 +68,7 @@ pub fn expand_deriving_clone(\n         _ => cx.span_bug(span, \"`#[derive(Clone)]` on trait item or impl item\"),\n     }\n \n-    let inline = cx.meta_word(span, sym::inline);\n-    let attrs = thin_vec![cx.attribute(inline)];\n+    let attrs = thin_vec![cx.attr_word(sym::inline, span)];\n     let trait_def = TraitDef {\n         span,\n         path: path_std!(clone::Clone),"}, {"sha": "f861d47ed408e45fc02ecc6e7c75f76357d47a83", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/eq.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ba1751a201190930a16ef20e6f7021c785d3891d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba1751a201190930a16ef20e6f7021c785d3891d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs?ref=ba1751a201190930a16ef20e6f7021c785d3891d", "patch": "@@ -5,7 +5,7 @@ use crate::deriving::path_std;\n use rustc_ast::{self as ast, MetaItem};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_expand::base::{Annotatable, ExtCtxt};\n-use rustc_span::symbol::{sym, Ident};\n+use rustc_span::symbol::sym;\n use rustc_span::Span;\n use thin_vec::thin_vec;\n \n@@ -18,11 +18,11 @@ pub fn expand_deriving_eq(\n     is_const: bool,\n ) {\n     let span = cx.with_def_site_ctxt(span);\n-    let inline = cx.meta_word(span, sym::inline);\n-    let hidden = rustc_ast::attr::mk_nested_word_item(Ident::new(sym::hidden, span));\n-    let doc = rustc_ast::attr::mk_list_item(Ident::new(sym::doc, span), vec![hidden]);\n-    let no_coverage = cx.meta_word(span, sym::no_coverage);\n-    let attrs = thin_vec![cx.attribute(inline), cx.attribute(doc), cx.attribute(no_coverage)];\n+    let attrs = thin_vec![\n+        cx.attr_word(sym::inline, span),\n+        cx.attr_nested_word(sym::doc, sym::hidden, span),\n+        cx.attr_word(sym::no_coverage, span)\n+    ];\n     let trait_def = TraitDef {\n         span,\n         path: path_std!(cmp::Eq),"}, {"sha": "96d18c7afb924c56a6fb6d949a414cbfead310ae", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/ord.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ba1751a201190930a16ef20e6f7021c785d3891d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba1751a201190930a16ef20e6f7021c785d3891d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs?ref=ba1751a201190930a16ef20e6f7021c785d3891d", "patch": "@@ -15,8 +15,7 @@ pub fn expand_deriving_ord(\n     push: &mut dyn FnMut(Annotatable),\n     is_const: bool,\n ) {\n-    let inline = cx.meta_word(span, sym::inline);\n-    let attrs = thin_vec![cx.attribute(inline)];\n+    let attrs = thin_vec![cx.attr_word(sym::inline, span)];\n     let trait_def = TraitDef {\n         span,\n         path: path_std!(cmp::Ord),"}, {"sha": "7f95551fc483a6bd69c4386a30191617581ec77e", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ba1751a201190930a16ef20e6f7021c785d3891d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba1751a201190930a16ef20e6f7021c785d3891d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=ba1751a201190930a16ef20e6f7021c785d3891d", "patch": "@@ -68,8 +68,7 @@ pub fn expand_deriving_partial_eq(\n \n     // No need to generate `ne`, the default suffices, and not generating it is\n     // faster.\n-    let inline = cx.meta_word(span, sym::inline);\n-    let attrs = thin_vec![cx.attribute(inline)];\n+    let attrs = thin_vec![cx.attr_word(sym::inline, span)];\n     let methods = vec![MethodDef {\n         name: sym::eq,\n         generics: Bounds::empty(),"}, {"sha": "5c4e5b7f8167500c1fd16a51b43d2a099e6548f5", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ba1751a201190930a16ef20e6f7021c785d3891d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba1751a201190930a16ef20e6f7021c785d3891d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=ba1751a201190930a16ef20e6f7021c785d3891d", "patch": "@@ -19,8 +19,7 @@ pub fn expand_deriving_partial_ord(\n     let ret_ty =\n         Path(Path::new_(pathvec_std!(option::Option), vec![Box::new(ordering_ty)], PathKind::Std));\n \n-    let inline = cx.meta_word(span, sym::inline);\n-    let attrs = thin_vec![cx.attribute(inline)];\n+    let attrs = thin_vec![cx.attr_word(sym::inline, span)];\n \n     let partial_cmp_def = MethodDef {\n         name: sym::partial_cmp,"}, {"sha": "e4e2435848dd2c46c1fedd0c83fa7129fe904c78", "filename": "compiler/rustc_builtin_macros/src/deriving/default.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ba1751a201190930a16ef20e6f7021c785d3891d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba1751a201190930a16ef20e6f7021c785d3891d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs?ref=ba1751a201190930a16ef20e6f7021c785d3891d", "patch": "@@ -20,8 +20,7 @@ pub fn expand_deriving_default(\n ) {\n     item.visit_with(&mut DetectNonVariantDefaultAttr { cx });\n \n-    let inline = cx.meta_word(span, sym::inline);\n-    let attrs = thin_vec![cx.attribute(inline)];\n+    let attrs = thin_vec![cx.attr_word(sym::inline, span)];\n     let trait_def = TraitDef {\n         span,\n         path: Path::new(vec![kw::Default, sym::Default]),"}, {"sha": "7fcaf0b436b9079742bd0261455ae0d613b9ad2f", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ba1751a201190930a16ef20e6f7021c785d3891d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba1751a201190930a16ef20e6f7021c785d3891d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=ba1751a201190930a16ef20e6f7021c785d3891d", "patch": "@@ -718,7 +718,7 @@ impl<'a> TraitDef<'a> {\n         let path = cx.path_all(self.span, false, vec![type_ident], self_params);\n         let self_type = cx.ty_path(path);\n \n-        let attr = cx.attribute(cx.meta_word(self.span, sym::automatically_derived));\n+        let attr = cx.attr_word(sym::automatically_derived, self.span);\n         let attrs = thin_vec![attr];\n         let opt_trait_ref = Some(trait_ref);\n "}, {"sha": "13fdd4fa68c43cd1e70c3683c6ed6db7a5cd7e12", "filename": "compiler/rustc_builtin_macros/src/deriving/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ba1751a201190930a16ef20e6f7021c785d3891d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba1751a201190930a16ef20e6f7021c785d3891d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs?ref=ba1751a201190930a16ef20e6f7021c785d3891d", "patch": "@@ -188,7 +188,7 @@ fn inject_impl_of_structural_trait(\n             .cloned(),\n     );\n     // Mark as `automatically_derived` to avoid some silly lints.\n-    attrs.push(cx.attribute(cx.meta_word(span, sym::automatically_derived)));\n+    attrs.push(cx.attr_word(sym::automatically_derived, span));\n \n     let newitem = cx.item(\n         span,"}, {"sha": "0817aed037ef814aab672a3f132da1b57f2c865b", "filename": "compiler/rustc_builtin_macros/src/global_allocator.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ba1751a201190930a16ef20e6f7021c785d3891d/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba1751a201190930a16ef20e6f7021c785d3891d/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_allocator.rs?ref=ba1751a201190930a16ef20e6f7021c785d3891d", "patch": "@@ -115,9 +115,7 @@ impl AllocFnFactory<'_, '_> {\n     }\n \n     fn attrs(&self) -> AttrVec {\n-        let special = sym::rustc_std_internal_symbol;\n-        let special = self.cx.meta_word(self.span, special);\n-        thin_vec![self.cx.attribute(special)]\n+        thin_vec![self.cx.attr_word(sym::rustc_std_internal_symbol, self.span)]\n     }\n \n     fn arg_ty("}, {"sha": "ece660cf6f64506fd55ce481e369efcf0e98f6c8", "filename": "compiler/rustc_builtin_macros/src/proc_macro_harness.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ba1751a201190930a16ef20e6f7021c785d3891d/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba1751a201190930a16ef20e6f7021c785d3891d/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs?ref=ba1751a201190930a16ef20e6f7021c785d3891d", "patch": "@@ -1,6 +1,3 @@\n-use std::mem;\n-\n-use rustc_ast::attr;\n use rustc_ast::ptr::P;\n use rustc_ast::visit::{self, Visitor};\n use rustc_ast::{self as ast, NodeId};\n@@ -13,6 +10,7 @@ use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n use smallvec::smallvec;\n+use std::mem;\n \n struct ProcMacroDerive {\n     id: NodeId,\n@@ -365,14 +363,8 @@ fn mk_decls(cx: &mut ExtCtxt<'_>, macros: &[ProcMacro]) -> P<ast::Item> {\n             cx.expr_array_ref(span, decls),\n         )\n         .map(|mut i| {\n-            let attr = cx.meta_word(span, sym::rustc_proc_macro_decls);\n-            i.attrs.push(cx.attribute(attr));\n-\n-            let deprecated_attr = attr::mk_nested_word_item(Ident::new(sym::deprecated, span));\n-            let allow_deprecated_attr =\n-                attr::mk_list_item(Ident::new(sym::allow, span), vec![deprecated_attr]);\n-            i.attrs.push(cx.attribute(allow_deprecated_attr));\n-\n+            i.attrs.push(cx.attr_word(sym::rustc_proc_macro_decls, span));\n+            i.attrs.push(cx.attr_nested_word(sym::allow, sym::deprecated, span));\n             i\n         });\n "}, {"sha": "f73f20c84a39d145911dbff56883d1dca807e565", "filename": "compiler/rustc_builtin_macros/src/standard_library_imports.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ba1751a201190930a16ef20e6f7021c785d3891d/compiler%2Frustc_builtin_macros%2Fsrc%2Fstandard_library_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba1751a201190930a16ef20e6f7021c785d3891d/compiler%2Frustc_builtin_macros%2Fsrc%2Fstandard_library_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fstandard_library_imports.rs?ref=ba1751a201190930a16ef20e6f7021c785d3891d", "patch": "@@ -52,7 +52,7 @@ pub fn inject(\n             cx.item(\n                 span,\n                 ident,\n-                thin_vec![cx.attribute(cx.meta_word(span, sym::macro_use))],\n+                thin_vec![cx.attr_word(sym::macro_use, span)],\n                 ast::ItemKind::ExternCrate(None),\n             ),\n         );\n@@ -79,7 +79,7 @@ pub fn inject(\n     let use_item = cx.item(\n         span,\n         Ident::empty(),\n-        thin_vec![cx.attribute(cx.meta_word(span, sym::prelude_import))],\n+        thin_vec![cx.attr_word(sym::prelude_import, span)],\n         ast::ItemKind::Use(ast::UseTree {\n             prefix: cx.path(span, import_path),\n             kind: ast::UseTreeKind::Glob,"}, {"sha": "3bcb60478efbc58db96665ce497c42373806fac3", "filename": "compiler/rustc_builtin_macros/src/test.rs", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ba1751a201190930a16ef20e6f7021c785d3891d/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba1751a201190930a16ef20e6f7021c785d3891d/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs?ref=ba1751a201190930a16ef20e6f7021c785d3891d", "patch": "@@ -2,7 +2,6 @@\n /// Ideally, this code would be in libtest but for efficiency and error messages it lives here.\n use crate::util::{check_builtin_macro_attribute, warn_on_duplicate_attribute};\n use rustc_ast as ast;\n-use rustc_ast::attr;\n use rustc_ast::ptr::P;\n use rustc_ast_pretty::pprust;\n use rustc_errors::Applicability;\n@@ -47,11 +46,7 @@ pub fn expand_test_case(\n             tokens: None,\n         };\n         item.ident.span = item.ident.span.with_ctxt(sp.ctxt());\n-        item.attrs.push(ecx.attribute(attr::mk_name_value_item_str(\n-            Ident::new(sym::rustc_test_marker, sp),\n-            test_path_symbol,\n-            sp,\n-        )));\n+        item.attrs.push(ecx.attr_name_value_str(sym::rustc_test_marker, test_path_symbol, sp));\n         item\n     });\n \n@@ -241,16 +236,9 @@ pub fn expand_test_or_bench(\n         Ident::new(item.ident.name, sp),\n         thin_vec![\n             // #[cfg(test)]\n-            cx.attribute(attr::mk_list_item(\n-                Ident::new(sym::cfg, attr_sp),\n-                vec![attr::mk_nested_word_item(Ident::new(sym::test, attr_sp))],\n-            )),\n+            cx.attr_nested_word(sym::cfg, sym::test, attr_sp),\n             // #[rustc_test_marker = \"test_case_sort_key\"]\n-            cx.attribute(attr::mk_name_value_item_str(\n-                Ident::new(sym::rustc_test_marker, attr_sp),\n-                test_path_symbol,\n-                attr_sp,\n-            )),\n+            cx.attr_name_value_str(sym::rustc_test_marker, test_path_symbol, attr_sp),\n         ]\n         .into(),\n         // const $ident: test::TestDescAndFn ="}, {"sha": "b5bce9278a907311d22e90493dba96dff9aee7b2", "filename": "compiler/rustc_builtin_macros/src/test_harness.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ba1751a201190930a16ef20e6f7021c785d3891d/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba1751a201190930a16ef20e6f7021c785d3891d/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs?ref=ba1751a201190930a16ef20e6f7021c785d3891d", "patch": "@@ -185,13 +185,12 @@ impl<'a> MutVisitor for EntryPointCleaner<'a> {\n         let item = match entry_point_type(self.sess, &item, self.depth) {\n             EntryPointType::MainNamed | EntryPointType::RustcMainAttr | EntryPointType::Start => {\n                 item.map(|ast::Item { id, ident, attrs, kind, vis, span, tokens }| {\n-                    let allow_ident = Ident::new(sym::allow, self.def_site);\n-                    let dc_nested =\n-                        attr::mk_nested_word_item(Ident::new(sym::dead_code, self.def_site));\n-                    let allow_dead_code_item = attr::mk_list_item(allow_ident, vec![dc_nested]);\n-                    let allow_dead_code = attr::mk_attr_outer(\n+                    let allow_dead_code = attr::mk_attr_nested_word(\n                         &self.sess.parse_sess.attr_id_generator,\n-                        allow_dead_code_item,\n+                        ast::AttrStyle::Outer,\n+                        sym::allow,\n+                        sym::dead_code,\n+                        self.def_site,\n                     );\n                     let attrs = attrs\n                         .into_iter()\n@@ -309,8 +308,7 @@ fn mk_main(cx: &mut TestCtxt<'_>) -> P<ast::Item> {\n     );\n \n     // #[rustc_main]\n-    let main_meta = ecx.meta_word(sp, sym::rustc_main);\n-    let main_attr = ecx.attribute(main_meta);\n+    let main_attr = ecx.attr_word(sym::rustc_main, sp);\n \n     // pub fn main() { ... }\n     let main_ret_ty = ecx.ty(sp, ast::TyKind::Tup(vec![]));"}, {"sha": "c978297295d4003420c0b978c5b4222e3b0097e8", "filename": "compiler/rustc_expand/src/build.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ba1751a201190930a16ef20e6f7021c785d3891d/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba1751a201190930a16ef20e6f7021c785d3891d/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs?ref=ba1751a201190930a16ef20e6f7021c785d3891d", "patch": "@@ -616,11 +616,23 @@ impl<'a> ExtCtxt<'a> {\n         self.item(span, name, AttrVec::new(), ast::ItemKind::Const(def, ty, Some(expr)))\n     }\n \n-    pub fn attribute(&self, mi: ast::MetaItem) -> ast::Attribute {\n-        attr::mk_attr_outer(&self.sess.parse_sess.attr_id_generator, mi)\n+    // Builds `#[name]`.\n+    pub fn attr_word(&self, name: Symbol, span: Span) -> ast::Attribute {\n+        let g = &self.sess.parse_sess.attr_id_generator;\n+        attr::mk_attr_word(g, ast::AttrStyle::Outer, name, span)\n     }\n \n-    pub fn meta_word(&self, sp: Span, w: Symbol) -> ast::MetaItem {\n-        attr::mk_word_item(Ident::new(w, sp))\n+    // Builds `#[name = val]`.\n+    //\n+    // Note: `span` is used for both the identifer and the value.\n+    pub fn attr_name_value_str(&self, name: Symbol, val: Symbol, span: Span) -> ast::Attribute {\n+        let g = &self.sess.parse_sess.attr_id_generator;\n+        attr::mk_attr_name_value_str(g, ast::AttrStyle::Outer, name, val, span)\n+    }\n+\n+    // Builds `#[outer(inner)]`.\n+    pub fn attr_nested_word(&self, outer: Symbol, inner: Symbol, span: Span) -> ast::Attribute {\n+        let g = &self.sess.parse_sess.attr_id_generator;\n+        attr::mk_attr_nested_word(g, ast::AttrStyle::Outer, outer, inner, span)\n     }\n }"}]}