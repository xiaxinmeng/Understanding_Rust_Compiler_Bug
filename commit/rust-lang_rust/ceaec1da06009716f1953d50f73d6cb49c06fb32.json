{"sha": "ceaec1da06009716f1953d50f73d6cb49c06fb32", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlYWVjMWRhMDYwMDk3MTZmMTk1M2Q1MGY3M2Q2Y2I0OWMwNmZiMzI=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-12-19T21:16:33Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-12-19T21:27:06Z"}, "message": "`check_pat_slice`: extract `check_aray_pat_len`.\n\nAlso use `types.err` when matching on `expected.kind`s\nwhich don't match `ty::Array(..) | ty::Slice(_)`.", "tree": {"sha": "473e963c8f4d6f78f21ac08e60d783b5101f30ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/473e963c8f4d6f78f21ac08e60d783b5101f30ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ceaec1da06009716f1953d50f73d6cb49c06fb32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ceaec1da06009716f1953d50f73d6cb49c06fb32", "html_url": "https://github.com/rust-lang/rust/commit/ceaec1da06009716f1953d50f73d6cb49c06fb32", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ceaec1da06009716f1953d50f73d6cb49c06fb32/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "13b71018c1845d9ab6b80199d20adfc3835f7341", "url": "https://api.github.com/repos/rust-lang/rust/commits/13b71018c1845d9ab6b80199d20adfc3835f7341", "html_url": "https://github.com/rust-lang/rust/commit/13b71018c1845d9ab6b80199d20adfc3835f7341"}], "stats": {"total": 73, "additions": 43, "deletions": 30}, "files": [{"sha": "26e87007adf01700ccd1389fe5bf49a5182ec5a3", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 43, "deletions": 30, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/ceaec1da06009716f1953d50f73d6cb49c06fb32/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaec1da06009716f1953d50f73d6cb49c06fb32/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=ceaec1da06009716f1953d50f73d6cb49c06fb32", "patch": "@@ -1174,38 +1174,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         def_bm: BindingMode,\n         discrim_span: Option<Span>,\n     ) -> Ty<'tcx> {\n-        let tcx = self.tcx;\n+        let err = self.tcx.types.err;\n         let expected = self.structurally_resolved_type(span, expected);\n         let (inner_ty, slice_ty, expected) = match expected.kind {\n             // An array, so we might have something like `let [a, b, c] = [0, 1, 2];`.\n-            ty::Array(inner_ty, size) => {\n-                let slice_ty = if let Some(size) = size.try_eval_usize(tcx, self.param_env) {\n-                    // Now we know the length...\n-                    let min_len = before.len() as u64 + after.len() as u64;\n-                    if slice.is_none() {\n-                        // ...and since there is no variable-length pattern,\n-                        // we require an exact match between the number of elements\n-                        // in the array pattern and as provided by the matched type.\n-                        if min_len != size {\n-                            self.error_scrutinee_inconsistent_length(span, min_len, size)\n-                        }\n-                        tcx.types.err\n-                    } else if let Some(rest) = size.checked_sub(min_len) {\n-                        // The variable-length pattern was there,\n-                        // so it has an array type with the remaining elements left as its size...\n-                        tcx.mk_array(inner_ty, rest)\n-                    } else {\n-                        // ...however, in this case, there were no remaining elements.\n-                        // That is, the slice pattern requires more than the array type offers.\n-                        self.error_scrutinee_with_rest_inconsistent_length(span, min_len, size);\n-                        tcx.types.err\n-                    }\n-                } else {\n-                    // No idea what the length is, which happens if we have e.g.,\n-                    // `let [a, b] = arr` where `arr: [T; N]` where `const N: usize`.\n-                    self.error_scrutinee_unfixed_length(span);\n-                    tcx.types.err\n-                };\n+            ty::Array(inner_ty, len) => {\n+                let min = before.len() as u64 + after.len() as u64;\n+                let slice_ty = self.check_array_pat_len(span, slice, len, min)\n+                    .map_or(err, |len| self.tcx.mk_array(inner_ty, len));\n                 (inner_ty, slice_ty, expected)\n             }\n             ty::Slice(inner_ty) => (inner_ty, expected, expected),\n@@ -1214,7 +1190,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 if !expected.references_error() {\n                     self.error_expected_array_or_slice(span, expected);\n                 }\n-                (tcx.types.err, tcx.types.err, tcx.types.err)\n+                (err, err, err)\n             }\n         };\n \n@@ -1233,6 +1209,43 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected\n     }\n \n+    /// Type check the length of an array pattern.\n+    ///\n+    /// Return the length of the variable length pattern,\n+    /// if it exists and there are no errors.\n+    fn check_array_pat_len(\n+        &self,\n+        span: Span,\n+        slice: Option<&'tcx Pat>,\n+        len: &ty::Const<'tcx>,\n+        min_len: u64,\n+    ) -> Option<u64> {\n+        if let Some(len) = len.try_eval_usize(self.tcx, self.param_env) {\n+            // Now we know the length...\n+            if slice.is_none() {\n+                // ...and since there is no variable-length pattern,\n+                // we require an exact match between the number of elements\n+                // in the array pattern and as provided by the matched type.\n+                if min_len != len {\n+                    self.error_scrutinee_inconsistent_length(span, min_len, len);\n+                }\n+            } else if let r @ Some(_) = len.checked_sub(min_len) {\n+                // The variable-length pattern was there,\n+                // so it has an array type with the remaining elements left as its size...\n+                return r;\n+            } else {\n+                // ...however, in this case, there were no remaining elements.\n+                // That is, the slice pattern requires more than the array type offers.\n+                self.error_scrutinee_with_rest_inconsistent_length(span, min_len, len);\n+            }\n+        } else {\n+            // No idea what the length is, which happens if we have e.g.,\n+            // `let [a, b] = arr` where `arr: [T; N]` where `const N: usize`.\n+            self.error_scrutinee_unfixed_length(span);\n+        }\n+        None\n+    }\n+\n     fn error_scrutinee_inconsistent_length(&self, span: Span, min_len: u64, size: u64) {\n         struct_span_err!(\n             self.tcx.sess,"}]}