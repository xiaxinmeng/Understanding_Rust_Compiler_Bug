{"sha": "1c2c6b670023efda0fea8e1837f9542d3ed12f5d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjMmM2YjY3MDAyM2VmZGEwZmVhOGUxODM3Zjk1NDJkM2VkMTJmNWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-01T07:48:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-01T07:48:24Z"}, "message": "Auto merge of #84582 - richkadel:issue-84561, r=tmandry\n\nVastly improves coverage spans for macros\n\nFixes: #84561\n\nThis resolves problems where macros like `trace!(...)` would show zero coverage if tracing was disabled, and `assert_eq!(...)` would show zero coverage if the assertion did not fail, because only one coverage span was generated, for the branch.\n\nThis PR started with an idea that I could just drop branching blocks with same span as expanded macro. (See the fixed issue for more details.)\n\nThat did help, but it didn't resolve everything.\n\nI also needed to add a span specifically for the macro name (plus `!`) to ensure the macro gets coverage even if it's internal expansion adds conditional branching blocks that are retained, and would otherwise drop the outer span. Now that outer span is _only_ the `(argument, list)`, which can safely be dropped now), because the macro name has its own span.\n\nWhile testing, I also noticed the spanview debug output can cause an ICE on a function with no body. The\nworkaround for this is included in this PR (separate commit).\n\nr? `@tmandry`\ncc? `@wesleywiser`", "tree": {"sha": "d193bf641984b88b313e848c7c194a62925ebd61", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d193bf641984b88b313e848c7c194a62925ebd61"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1c2c6b670023efda0fea8e1837f9542d3ed12f5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1c2c6b670023efda0fea8e1837f9542d3ed12f5d", "html_url": "https://github.com/rust-lang/rust/commit/1c2c6b670023efda0fea8e1837f9542d3ed12f5d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1c2c6b670023efda0fea8e1837f9542d3ed12f5d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d67e0747238c392bfb03984db132576aa19bec1", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d67e0747238c392bfb03984db132576aa19bec1", "html_url": "https://github.com/rust-lang/rust/commit/3d67e0747238c392bfb03984db132576aa19bec1"}, {"sha": "0312bf5fb919cb22280367ff445d4a9cbd842539", "url": "https://api.github.com/repos/rust-lang/rust/commits/0312bf5fb919cb22280367ff445d4a9cbd842539", "html_url": "https://github.com/rust-lang/rust/commit/0312bf5fb919cb22280367ff445d4a9cbd842539"}], "stats": {"total": 929, "additions": 861, "deletions": 68}, "files": [{"sha": "b3fc2a0cb5e90cc1def39b9fed5ceb9a4cf06fe5", "filename": "compiler/rustc_mir/src/transform/coverage/spans.rs", "status": "modified", "additions": 201, "deletions": 41, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/1c2c6b670023efda0fea8e1837f9542d3ed12f5d/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fspans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c2c6b670023efda0fea8e1837f9542d3ed12f5d/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fspans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fspans.rs?ref=1c2c6b670023efda0fea8e1837f9542d3ed12f5d", "patch": "@@ -11,8 +11,9 @@ use rustc_middle::mir::{\n use rustc_middle::ty::TyCtxt;\n \n use rustc_span::source_map::original_sp;\n-use rustc_span::{BytePos, Span};\n+use rustc_span::{BytePos, ExpnKind, MacroKind, Span, Symbol};\n \n+use std::cell::RefCell;\n use std::cmp::Ordering;\n \n #[derive(Debug, Copy, Clone)]\n@@ -67,19 +68,29 @@ impl CoverageStatement {\n #[derive(Debug, Clone)]\n pub(super) struct CoverageSpan {\n     pub span: Span,\n+    pub expn_span: Span,\n+    pub current_macro_or_none: RefCell<Option<Option<Symbol>>>,\n     pub bcb: BasicCoverageBlock,\n     pub coverage_statements: Vec<CoverageStatement>,\n     pub is_closure: bool,\n }\n \n impl CoverageSpan {\n     pub fn for_fn_sig(fn_sig_span: Span) -> Self {\n-        Self { span: fn_sig_span, bcb: START_BCB, coverage_statements: vec![], is_closure: false }\n+        Self {\n+            span: fn_sig_span,\n+            expn_span: fn_sig_span,\n+            current_macro_or_none: Default::default(),\n+            bcb: START_BCB,\n+            coverage_statements: vec![],\n+            is_closure: false,\n+        }\n     }\n \n     pub fn for_statement(\n         statement: &Statement<'tcx>,\n         span: Span,\n+        expn_span: Span,\n         bcb: BasicCoverageBlock,\n         bb: BasicBlock,\n         stmt_index: usize,\n@@ -94,15 +105,24 @@ impl CoverageSpan {\n \n         Self {\n             span,\n+            expn_span,\n+            current_macro_or_none: Default::default(),\n             bcb,\n             coverage_statements: vec![CoverageStatement::Statement(bb, span, stmt_index)],\n             is_closure,\n         }\n     }\n \n-    pub fn for_terminator(span: Span, bcb: BasicCoverageBlock, bb: BasicBlock) -> Self {\n+    pub fn for_terminator(\n+        span: Span,\n+        expn_span: Span,\n+        bcb: BasicCoverageBlock,\n+        bb: BasicBlock,\n+    ) -> Self {\n         Self {\n             span,\n+            expn_span,\n+            current_macro_or_none: Default::default(),\n             bcb,\n             coverage_statements: vec![CoverageStatement::Terminator(bb, span)],\n             is_closure: false,\n@@ -158,6 +178,38 @@ impl CoverageSpan {\n             .collect::<Vec<_>>()\n             .join(\"\\n\")\n     }\n+\n+    /// If the span is part of a macro, returns the macro name symbol.\n+    pub fn current_macro(&self) -> Option<Symbol> {\n+        self.current_macro_or_none\n+            .borrow_mut()\n+            .get_or_insert_with(|| {\n+                if let ExpnKind::Macro(MacroKind::Bang, current_macro) =\n+                    self.expn_span.ctxt().outer_expn_data().kind\n+                {\n+                    return Some(current_macro);\n+                }\n+                None\n+            })\n+            .map(|symbol| symbol)\n+    }\n+\n+    /// If the span is part of a macro, and the macro is visible (expands directly to the given\n+    /// body_span), returns the macro name symbol.\n+    pub fn visible_macro(&self, body_span: Span) -> Option<Symbol> {\n+        if let Some(current_macro) = self.current_macro() {\n+            if self.expn_span.parent().unwrap_or_else(|| bug!(\"macro must have a parent\")).ctxt()\n+                == body_span.ctxt()\n+            {\n+                return Some(current_macro);\n+            }\n+        }\n+        None\n+    }\n+\n+    pub fn is_macro_expansion(&self) -> bool {\n+        self.current_macro().is_some()\n+    }\n }\n \n /// Converts the initial set of `CoverageSpan`s (one per MIR `Statement` or `Terminator`) into a\n@@ -191,16 +243,23 @@ pub struct CoverageSpans<'a, 'tcx> {\n     /// iteration.\n     some_curr: Option<CoverageSpan>,\n \n-    /// The original `span` for `curr`, in case the `curr` span is modified.\n+    /// The original `span` for `curr`, in case `curr.span()` is modified. The `curr_original_span`\n+    /// **must not be mutated** (except when advancing to the next `curr`), even if `curr.span()`\n+    /// is mutated.\n     curr_original_span: Span,\n \n     /// The CoverageSpan from a prior iteration; typically assigned from that iteration's `curr`.\n     /// If that `curr` was discarded, `prev` retains its value from the previous iteration.\n     some_prev: Option<CoverageSpan>,\n \n-    /// Assigned from `curr_original_span` from the previous iteration.\n+    /// Assigned from `curr_original_span` from the previous iteration. The `prev_original_span`\n+    /// **must not be mutated** (except when advancing to the next `prev`), even if `prev.span()`\n+    /// is mutated.\n     prev_original_span: Span,\n \n+    /// A copy of the expn_span from the prior iteration.\n+    prev_expn_span: Option<Span>,\n+\n     /// One or more `CoverageSpan`s with the same `Span` but different `BasicCoverageBlock`s, and\n     /// no `BasicCoverageBlock` in this list dominates another `BasicCoverageBlock` in the list.\n     /// If a new `curr` span also fits this criteria (compared to an existing list of\n@@ -255,15 +314,13 @@ impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n             curr_original_span: Span::with_root_ctxt(BytePos(0), BytePos(0)),\n             some_prev: None,\n             prev_original_span: Span::with_root_ctxt(BytePos(0), BytePos(0)),\n+            prev_expn_span: None,\n             pending_dups: Vec::new(),\n         };\n \n         let sorted_spans = coverage_spans.mir_to_initial_sorted_coverage_spans();\n \n         coverage_spans.sorted_spans_iter = Some(sorted_spans.into_iter());\n-        coverage_spans.some_prev = coverage_spans.sorted_spans_iter.as_mut().unwrap().next();\n-        coverage_spans.prev_original_span =\n-            coverage_spans.some_prev.as_ref().expect(\"at least one span\").span;\n \n         coverage_spans.to_refined_spans()\n     }\n@@ -317,10 +374,14 @@ impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n     /// de-duplicated `CoverageSpan`s.\n     fn to_refined_spans(mut self) -> Vec<CoverageSpan> {\n         while self.next_coverage_span() {\n-            if self.curr().is_mergeable(self.prev()) {\n+            if self.some_prev.is_none() {\n+                debug!(\"  initial span\");\n+                self.check_invoked_macro_name_span();\n+            } else if self.curr().is_mergeable(self.prev()) {\n                 debug!(\"  same bcb (and neither is a closure), merge with prev={:?}\", self.prev());\n                 let prev = self.take_prev();\n                 self.curr_mut().merge_from(prev);\n+                self.check_invoked_macro_name_span();\n             // Note that curr.span may now differ from curr_original_span\n             } else if self.prev_ends_before_curr() {\n                 debug!(\n@@ -329,7 +390,8 @@ impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n                     self.prev()\n                 );\n                 let prev = self.take_prev();\n-                self.refined_spans.push(prev);\n+                self.push_refined_span(prev);\n+                self.check_invoked_macro_name_span();\n             } else if self.prev().is_closure {\n                 // drop any equal or overlapping span (`curr`) and keep `prev` to test again in the\n                 // next iter\n@@ -342,20 +404,45 @@ impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n             } else if self.curr().is_closure {\n                 self.carve_out_span_for_closure();\n             } else if self.prev_original_span == self.curr().span {\n-                // Note that this compares the new span to `prev_original_span`, which may not\n-                // be the full `prev.span` (if merged during the previous iteration).\n-                self.hold_pending_dups_unless_dominated();\n+                // Note that this compares the new (`curr`) span to `prev_original_span`.\n+                // In this branch, the actual span byte range of `prev_original_span` is not\n+                // important. What is important is knowing whether the new `curr` span was\n+                // **originally** the same as the original span of `prev()`. The original spans\n+                // reflect their original sort order, and for equal spans, conveys a partial\n+                // ordering based on CFG dominator priority.\n+                if self.prev().is_macro_expansion() && self.curr().is_macro_expansion() {\n+                    // Macros that expand to include branching (such as\n+                    // `assert_eq!()`, `assert_ne!()`, `info!()`, `debug!()`, or\n+                    // `trace!()) typically generate callee spans with identical\n+                    // ranges (typically the full span of the macro) for all\n+                    // `BasicBlocks`. This makes it impossible to distinguish\n+                    // the condition (`if val1 != val2`) from the optional\n+                    // branched statements (such as the call to `panic!()` on\n+                    // assert failure). In this case it is better (or less\n+                    // worse) to drop the optional branch bcbs and keep the\n+                    // non-conditional statements, to count when reached.\n+                    debug!(\n+                        \"  curr and prev are part of a macro expansion, and curr has the same span \\\n+                        as prev, but is in a different bcb. Drop curr and keep prev for next iter. \\\n+                        prev={:?}\",\n+                        self.prev()\n+                    );\n+                    self.take_curr();\n+                } else {\n+                    self.hold_pending_dups_unless_dominated();\n+                }\n             } else {\n                 self.cutoff_prev_at_overlapping_curr();\n+                self.check_invoked_macro_name_span();\n             }\n         }\n \n         debug!(\"    AT END, adding last prev={:?}\", self.prev());\n         let prev = self.take_prev();\n-        let CoverageSpans { pending_dups, mut refined_spans, .. } = self;\n+        let pending_dups = self.pending_dups.split_off(0);\n         for dup in pending_dups {\n             debug!(\"    ...adding at least one pending dup={:?}\", dup);\n-            refined_spans.push(dup);\n+            self.push_refined_span(dup);\n         }\n \n         // Async functions wrap a closure that implements the body to be executed. The enclosing\n@@ -365,21 +452,60 @@ impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n         // excluded. The closure's `Return` is the only one that will be counted. This provides\n         // adequate coverage, and more intuitive counts. (Avoids double-counting the closing brace\n         // of the function body.)\n-        let body_ends_with_closure = if let Some(last_covspan) = refined_spans.last() {\n+        let body_ends_with_closure = if let Some(last_covspan) = self.refined_spans.last() {\n             last_covspan.is_closure && last_covspan.span.hi() == self.body_span.hi()\n         } else {\n             false\n         };\n \n         if !body_ends_with_closure {\n-            refined_spans.push(prev);\n+            self.push_refined_span(prev);\n         }\n \n         // Remove `CoverageSpan`s derived from closures, originally added to ensure the coverage\n         // regions for the current function leave room for the closure's own coverage regions\n         // (injected separately, from the closure's own MIR).\n-        refined_spans.retain(|covspan| !covspan.is_closure);\n-        refined_spans\n+        self.refined_spans.retain(|covspan| !covspan.is_closure);\n+        self.refined_spans\n+    }\n+\n+    fn push_refined_span(&mut self, covspan: CoverageSpan) {\n+        let len = self.refined_spans.len();\n+        if len > 0 {\n+            let last = &mut self.refined_spans[len - 1];\n+            if last.is_mergeable(&covspan) {\n+                debug!(\n+                    \"merging new refined span with last refined span, last={:?}, covspan={:?}\",\n+                    last, covspan\n+                );\n+                last.merge_from(covspan);\n+                return;\n+            }\n+        }\n+        self.refined_spans.push(covspan)\n+    }\n+\n+    fn check_invoked_macro_name_span(&mut self) {\n+        if let Some(visible_macro) = self.curr().visible_macro(self.body_span) {\n+            if self.prev_expn_span.map_or(true, |prev_expn_span| {\n+                self.curr().expn_span.ctxt() != prev_expn_span.ctxt()\n+            }) {\n+                let merged_prefix_len = self.curr_original_span.lo() - self.curr().span.lo();\n+                let after_macro_bang =\n+                    merged_prefix_len + BytePos(visible_macro.as_str().bytes().count() as u32 + 1);\n+                let mut macro_name_cov = self.curr().clone();\n+                self.curr_mut().span =\n+                    self.curr().span.with_lo(self.curr().span.lo() + after_macro_bang);\n+                macro_name_cov.span =\n+                    macro_name_cov.span.with_hi(macro_name_cov.span.lo() + after_macro_bang);\n+                debug!(\n+                    \"  and curr starts a new macro expansion, so add a new span just for \\\n+                            the macro `{}!`, new span={:?}\",\n+                    visible_macro, macro_name_cov\n+                );\n+                self.push_refined_span(macro_name_cov);\n+            }\n+        }\n     }\n \n     // Generate a set of `CoverageSpan`s from the filtered set of `Statement`s and `Terminator`s of\n@@ -401,14 +527,17 @@ impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n                     .iter()\n                     .enumerate()\n                     .filter_map(move |(index, statement)| {\n-                        filtered_statement_span(statement, self.body_span).map(|span| {\n-                            CoverageSpan::for_statement(statement, span, bcb, bb, index)\n-                        })\n+                        filtered_statement_span(statement, self.body_span).map(\n+                            |(span, expn_span)| {\n+                                CoverageSpan::for_statement(\n+                                    statement, span, expn_span, bcb, bb, index,\n+                                )\n+                            },\n+                        )\n                     })\n-                    .chain(\n-                        filtered_terminator_span(data.terminator(), self.body_span)\n-                            .map(|span| CoverageSpan::for_terminator(span, bcb, bb)),\n-                    )\n+                    .chain(filtered_terminator_span(data.terminator(), self.body_span).map(\n+                        |(span, expn_span)| CoverageSpan::for_terminator(span, expn_span, bcb, bb),\n+                    ))\n             })\n             .collect()\n     }\n@@ -461,7 +590,7 @@ impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n                     let pending_dups = self.pending_dups.split_off(0);\n                     for dup in pending_dups.into_iter() {\n                         debug!(\"    ...adding at least one pending={:?}\", dup);\n-                        self.refined_spans.push(dup);\n+                        self.push_refined_span(dup);\n                     }\n                 } else {\n                     self.pending_dups.clear();\n@@ -473,12 +602,13 @@ impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n     /// Advance `prev` to `curr` (if any), and `curr` to the next `CoverageSpan` in sorted order.\n     fn next_coverage_span(&mut self) -> bool {\n         if let Some(curr) = self.some_curr.take() {\n+            self.prev_expn_span = Some(curr.expn_span);\n             self.some_prev = Some(curr);\n             self.prev_original_span = self.curr_original_span;\n         }\n         while let Some(curr) = self.sorted_spans_iter.as_mut().unwrap().next() {\n             debug!(\"FOR curr={:?}\", curr);\n-            if self.prev_starts_after_next(&curr) {\n+            if self.some_prev.is_some() && self.prev_starts_after_next(&curr) {\n                 debug!(\n                     \"  prev.span starts after curr.span, so curr will be dropped (skipping past \\\n                     closure?); prev={:?}\",\n@@ -535,29 +665,38 @@ impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n                 for mut dup in pending_dups.iter().cloned() {\n                     dup.span = dup.span.with_hi(left_cutoff);\n                     debug!(\"    ...and at least one pre_closure dup={:?}\", dup);\n-                    self.refined_spans.push(dup);\n+                    self.push_refined_span(dup);\n                 }\n             }\n-            self.refined_spans.push(pre_closure);\n+            self.push_refined_span(pre_closure);\n         }\n         if has_post_closure_span {\n-            // Update prev.span to start after the closure (and discard curr)\n+            // Mutate `prev.span()` to start after the closure (and discard curr).\n+            // (**NEVER** update `prev_original_span` because it affects the assumptions\n+            // about how the `CoverageSpan`s are ordered.)\n             self.prev_mut().span = self.prev().span.with_lo(right_cutoff);\n-            self.prev_original_span = self.prev().span;\n+            debug!(\"  Mutated prev.span to start after the closure. prev={:?}\", self.prev());\n             for dup in pending_dups.iter_mut() {\n+                debug!(\"    ...and at least one overlapping dup={:?}\", dup);\n                 dup.span = dup.span.with_lo(right_cutoff);\n             }\n             self.pending_dups.append(&mut pending_dups);\n             let closure_covspan = self.take_curr();\n-            self.refined_spans.push(closure_covspan); // since self.prev() was already updated\n+            self.push_refined_span(closure_covspan); // since self.prev() was already updated\n         } else {\n             pending_dups.clear();\n         }\n     }\n \n     /// Called if `curr.span` equals `prev_original_span` (and potentially equal to all\n-    /// `pending_dups` spans, if any); but keep in mind, `prev.span` may start at a `Span.lo()` that\n-    /// is less than (further left of) `prev_original_span.lo()`.\n+    /// `pending_dups` spans, if any). Keep in mind, `prev.span()` may have been changed.\n+    /// If prev.span() was merged into other spans (with matching BCB, for instance),\n+    /// `prev.span.hi()` will be greater than (further right of) `prev_original_span.hi()`.\n+    /// If prev.span() was split off to the right of a closure, prev.span().lo() will be\n+    /// greater than prev_original_span.lo(). The actual span of `prev_original_span` is\n+    /// not as important as knowing that `prev()` **used to have the same span** as `curr(),\n+    /// which means their sort order is still meaningful for determinating the dominator\n+    /// relationship.\n     ///\n     /// When two `CoverageSpan`s have the same `Span`, dominated spans can be discarded; but if\n     /// neither `CoverageSpan` dominates the other, both (or possibly more than two) are held,\n@@ -640,7 +779,7 @@ impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n             } else {\n                 debug!(\"  ... adding modified prev={:?}\", self.prev());\n                 let prev = self.take_prev();\n-                self.refined_spans.push(prev);\n+                self.push_refined_span(prev);\n             }\n         } else {\n             // with `pending_dups`, `prev` cannot have any statements that don't overlap\n@@ -653,10 +792,13 @@ impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n     }\n }\n \n+/// See `function_source_span()` for a description of the two returned spans.\n+/// If the MIR `Statement` is not contributive to computing coverage spans,\n+/// returns `None`.\n pub(super) fn filtered_statement_span(\n     statement: &'a Statement<'tcx>,\n     body_span: Span,\n-) -> Option<Span> {\n+) -> Option<(Span, Span)> {\n     match statement.kind {\n         // These statements have spans that are often outside the scope of the executed source code\n         // for their parent `BasicBlock`.\n@@ -698,10 +840,13 @@ pub(super) fn filtered_statement_span(\n     }\n }\n \n+/// See `function_source_span()` for a description of the two returned spans.\n+/// If the MIR `Terminator` is not contributive to computing coverage spans,\n+/// returns `None`.\n pub(super) fn filtered_terminator_span(\n     terminator: &'a Terminator<'tcx>,\n     body_span: Span,\n-) -> Option<Span> {\n+) -> Option<(Span, Span)> {\n     match terminator.kind {\n         // These terminators have spans that don't positively contribute to computing a reasonable\n         // span of actually executed source code. (For example, SwitchInt terminators extracted from\n@@ -741,8 +886,23 @@ pub(super) fn filtered_terminator_span(\n     }\n }\n \n+/// Returns two spans from the given span (the span associated with a\n+/// `Statement` or `Terminator`):\n+///\n+///   1. An extrapolated span (pre-expansion[^1]) corresponding to a range within\n+///      the function's body source. This span is guaranteed to be contained\n+///      within, or equal to, the `body_span`. If the extrapolated span is not\n+///      contained within the `body_span`, the `body_span` is returned.\n+///   2. The actual `span` value from the `Statement`, before expansion.\n+///\n+/// Only the first span is used when computing coverage code regions. The second\n+/// span is useful if additional expansion data is needed (such as to look up\n+/// the macro name for a composed span within that macro).)\n+///\n+/// [^1]Expansions result from Rust syntax including macros, syntactic\n+/// sugar, etc.).\n #[inline]\n-fn function_source_span(span: Span, body_span: Span) -> Span {\n-    let span = original_sp(span, body_span).with_ctxt(body_span.ctxt());\n-    if body_span.contains(span) { span } else { body_span }\n+fn function_source_span(span: Span, body_span: Span) -> (Span, Span) {\n+    let original_span = original_sp(span, body_span).with_ctxt(body_span.ctxt());\n+    (if body_span.contains(original_span) { original_span } else { body_span }, span)\n }"}, {"sha": "9b84173c8a29307ba11ed5b15a007c11e8e22177", "filename": "compiler/rustc_mir/src/transform/coverage/tests.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1c2c6b670023efda0fea8e1837f9542d3ed12f5d/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c2c6b670023efda0fea8e1837f9542d3ed12f5d/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Ftests.rs?ref=1c2c6b670023efda0fea8e1837f9542d3ed12f5d", "patch": "@@ -1,6 +1,10 @@\n //! This crate hosts a selection of \"unit tests\" for components of the `InstrumentCoverage` MIR\n //! pass.\n //!\n+//! ```shell\n+//! ./x.py test --keep-stage 1 compiler/rustc_mir --test-args '--show-output coverage'\n+//! ```\n+//!\n //! The tests construct a few \"mock\" objects, as needed, to support the `InstrumentCoverage`\n //! functions and algorithms. Mocked objects include instances of `mir::Body`; including\n //! `Terminator`s of various `kind`s, and `Span` objects. Some functions used by or used on\n@@ -679,10 +683,15 @@ fn test_make_bcb_counters() {\n         let mut basic_coverage_blocks = graph::CoverageGraph::from_mir(&mir_body);\n         let mut coverage_spans = Vec::new();\n         for (bcb, data) in basic_coverage_blocks.iter_enumerated() {\n-            if let Some(span) =\n+            if let Some((span, expn_span)) =\n                 spans::filtered_terminator_span(data.terminator(&mir_body), body_span)\n             {\n-                coverage_spans.push(spans::CoverageSpan::for_terminator(span, bcb, data.last_bb()));\n+                coverage_spans.push(spans::CoverageSpan::for_terminator(\n+                    span,\n+                    expn_span,\n+                    bcb,\n+                    data.last_bb(),\n+                ));\n             }\n         }\n         let mut coverage_counters = counters::CoverageCounters::new(0);"}, {"sha": "9abfa4a8dc68b7856be0d07aea205157a3dd8e22", "filename": "compiler/rustc_mir/src/util/spanview.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1c2c6b670023efda0fea8e1837f9542d3ed12f5d/compiler%2Frustc_mir%2Fsrc%2Futil%2Fspanview.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c2c6b670023efda0fea8e1837f9542d3ed12f5d/compiler%2Frustc_mir%2Fsrc%2Futil%2Fspanview.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Futil%2Fspanview.rs?ref=1c2c6b670023efda0fea8e1837f9542d3ed12f5d", "patch": "@@ -99,7 +99,11 @@ where\n     W: Write,\n {\n     let def_id = body.source.def_id();\n-    let body_span = hir_body(tcx, def_id).value.span;\n+    let hir_body = hir_body(tcx, def_id);\n+    if hir_body.is_none() {\n+        return Ok(());\n+    }\n+    let body_span = hir_body.unwrap().value.span;\n     let mut span_viewables = Vec::new();\n     for (bb, data) in body.basic_blocks().iter_enumerated() {\n         match spanview {\n@@ -664,19 +668,16 @@ fn fn_span<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Span {\n     let hir_id =\n         tcx.hir().local_def_id_to_hir_id(def_id.as_local().expect(\"expected DefId is local\"));\n     let fn_decl_span = tcx.hir().span(hir_id);\n-    let body_span = hir_body(tcx, def_id).value.span;\n-    if fn_decl_span.ctxt() == body_span.ctxt() {\n-        fn_decl_span.to(body_span)\n+    if let Some(body_span) = hir_body(tcx, def_id).map(|hir_body| hir_body.value.span) {\n+        if fn_decl_span.ctxt() == body_span.ctxt() { fn_decl_span.to(body_span) } else { body_span }\n     } else {\n-        // This probably occurs for functions defined via macros\n-        body_span\n+        fn_decl_span\n     }\n }\n \n-fn hir_body<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx rustc_hir::Body<'tcx> {\n+fn hir_body<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Option<&'tcx rustc_hir::Body<'tcx>> {\n     let hir_node = tcx.hir().get_if_local(def_id).expect(\"expected DefId is local\");\n-    let fn_body_id = hir::map::associated_body(hir_node).expect(\"HIR node is a function with body\");\n-    tcx.hir().body(fn_body_id)\n+    hir::map::associated_body(hir_node).map(|fn_body_id| tcx.hir().body(fn_body_id))\n }\n \n fn escape_html(s: &str) -> String {"}, {"sha": "a030035f13bae284c41182e4eb305b9e84e8bba3", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.closure_macro.txt", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/1c2c6b670023efda0fea8e1837f9542d3ed12f5d/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.closure_macro.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1c2c6b670023efda0fea8e1837f9542d3ed12f5d/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.closure_macro.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.closure_macro.txt?ref=1c2c6b670023efda0fea8e1837f9542d3ed12f5d", "patch": "@@ -0,0 +1,42 @@\n+    1|       |// compile-flags: --edition=2018\n+    2|       |#![feature(no_coverage)]\n+    3|       |\n+    4|       |macro_rules! bail {\n+    5|       |    ($msg:literal $(,)?) => {\n+    6|       |        if $msg.len() > 0 {\n+    7|       |            println!(\"no msg\");\n+    8|       |        } else {\n+    9|       |            println!($msg);\n+   10|       |        }\n+   11|       |        return Err(String::from($msg));\n+   12|       |    };\n+   13|       |}\n+   14|       |\n+   15|       |macro_rules! on_error {\n+   16|       |    ($value:expr, $error_message:expr) => {\n+   17|      0|        $value.or_else(|e| {\n+   18|      0|            let message = format!($error_message, e);\n+   19|      0|            if message.len() > 0 {\n+   20|      0|                println!(\"{}\", message);\n+   21|      0|                Ok(String::from(\"ok\"))\n+   22|       |            } else {\n+   23|      0|                bail!(\"error\");\n+   24|       |            }\n+   25|      0|        })\n+   26|       |    };\n+   27|       |}\n+   28|       |\n+   29|      1|fn load_configuration_files() -> Result<String, String> {\n+   30|      1|    Ok(String::from(\"config\"))\n+   31|      1|}\n+   32|       |\n+   33|      1|pub fn main() -> Result<(), String> {\n+   34|      1|    println!(\"Starting service\");\n+   35|      1|    let config = on_error!(load_configuration_files(), \"Error loading configs: {}\")?;\n+                                                                                                 ^0\n+   36|       |\n+   37|      1|    let startup_delay_duration = String::from(\"arg\");\n+   38|      1|    let _ = (config, startup_delay_duration);\n+   39|      1|    Ok(())\n+   40|      1|}\n+"}, {"sha": "a954eb3037832ef35b66dd59be8e59561daecf4c", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.closure_macro_async.txt", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/1c2c6b670023efda0fea8e1837f9542d3ed12f5d/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.closure_macro_async.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1c2c6b670023efda0fea8e1837f9542d3ed12f5d/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.closure_macro_async.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.closure_macro_async.txt?ref=1c2c6b670023efda0fea8e1837f9542d3ed12f5d", "patch": "@@ -0,0 +1,83 @@\n+    1|       |// compile-flags: --edition=2018\n+    2|       |#![feature(no_coverage)]\n+    3|       |\n+    4|       |macro_rules! bail {\n+    5|       |    ($msg:literal $(,)?) => {\n+    6|       |        if $msg.len() > 0 {\n+    7|       |            println!(\"no msg\");\n+    8|       |        } else {\n+    9|       |            println!($msg);\n+   10|       |        }\n+   11|       |        return Err(String::from($msg));\n+   12|       |    };\n+   13|       |}\n+   14|       |\n+   15|       |macro_rules! on_error {\n+   16|       |    ($value:expr, $error_message:expr) => {\n+   17|      0|        $value.or_else(|e| {\n+   18|      0|            let message = format!($error_message, e);\n+   19|      0|            if message.len() > 0 {\n+   20|      0|                println!(\"{}\", message);\n+   21|      0|                Ok(String::from(\"ok\"))\n+   22|       |            } else {\n+   23|      0|                bail!(\"error\");\n+   24|       |            }\n+   25|      0|        })\n+   26|       |    };\n+   27|       |}\n+   28|       |\n+   29|      1|fn load_configuration_files() -> Result<String, String> {\n+   30|      1|    Ok(String::from(\"config\"))\n+   31|      1|}\n+   32|       |\n+   33|      1|pub async fn test() -> Result<(), String> {\n+   34|      1|    println!(\"Starting service\");\n+   35|      1|    let config = on_error!(load_configuration_files(), \"Error loading configs: {}\")?;\n+                                                                                                 ^0\n+   36|       |\n+   37|      1|    let startup_delay_duration = String::from(\"arg\");\n+   38|      1|    let _ = (config, startup_delay_duration);\n+   39|      1|    Ok(())\n+   40|      1|}\n+   41|       |\n+   42|       |#[no_coverage]\n+   43|       |fn main() {\n+   44|       |    executor::block_on(test());\n+   45|       |}\n+   46|       |\n+   47|       |mod executor {\n+   48|       |    use core::{\n+   49|       |        future::Future,\n+   50|       |        pin::Pin,\n+   51|       |        task::{Context, Poll, RawWaker, RawWakerVTable, Waker},\n+   52|       |    };\n+   53|       |\n+   54|       |    #[no_coverage]\n+   55|       |    pub fn block_on<F: Future>(mut future: F) -> F::Output {\n+   56|       |        let mut future = unsafe { Pin::new_unchecked(&mut future) };\n+   57|       |        use std::hint::unreachable_unchecked;\n+   58|       |        static VTABLE: RawWakerVTable = RawWakerVTable::new(\n+   59|       |\n+   60|       |            #[no_coverage]\n+   61|       |            |_| unsafe { unreachable_unchecked() }, // clone\n+   62|       |\n+   63|       |            #[no_coverage]\n+   64|       |            |_| unsafe { unreachable_unchecked() }, // wake\n+   65|       |\n+   66|       |            #[no_coverage]\n+   67|       |            |_| unsafe { unreachable_unchecked() }, // wake_by_ref\n+   68|       |\n+   69|       |            #[no_coverage]\n+   70|       |            |_| (),\n+   71|       |        );\n+   72|       |        let waker = unsafe { Waker::from_raw(RawWaker::new(core::ptr::null(), &VTABLE)) };\n+   73|       |        let mut context = Context::from_waker(&waker);\n+   74|       |\n+   75|       |        loop {\n+   76|       |            if let Poll::Ready(val) = future.as_mut().poll(&mut context) {\n+   77|       |                break val;\n+   78|       |            }\n+   79|       |        }\n+   80|       |    }\n+   81|       |}\n+"}, {"sha": "883254a09ba7d64edeac10c5c96dbe7a6abf453c", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.inner_items.txt", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1c2c6b670023efda0fea8e1837f9542d3ed12f5d/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.inner_items.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1c2c6b670023efda0fea8e1837f9542d3ed12f5d/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.inner_items.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.inner_items.txt?ref=1c2c6b670023efda0fea8e1837f9542d3ed12f5d", "patch": "@@ -1,9 +1,9 @@\n     1|       |#![allow(unused_assignments, unused_variables, dead_code)]\n     2|       |\n     3|      1|fn main() {\n-    4|       |    // Initialize test constants in a way that cannot be determined at compile time, to ensure\n-    5|       |    // rustc and LLVM cannot optimize out statements (or coverage counters) downstream from\n-    6|       |    // dependent conditions.\n+    4|      1|    // Initialize test constants in a way that cannot be determined at compile time, to ensure\n+    5|      1|    // rustc and LLVM cannot optimize out statements (or coverage counters) downstream from\n+    6|      1|    // dependent conditions.\n     7|      1|    let is_true = std::env::args().len() == 1;\n     8|      1|\n     9|      1|    let mut countdown = 0;"}, {"sha": "de32c88b725dc1d2741a36fcf0ba8c23b484454d", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.issue-83601.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1c2c6b670023efda0fea8e1837f9542d3ed12f5d/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.issue-83601.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1c2c6b670023efda0fea8e1837f9542d3ed12f5d/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.issue-83601.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.issue-83601.txt?ref=1c2c6b670023efda0fea8e1837f9542d3ed12f5d", "patch": "@@ -12,9 +12,9 @@\n     5|       |\n     6|      1|fn main() {\n     7|      1|    let bar = Foo(1);\n-    8|      0|    assert_eq!(bar, Foo(1));\n+    8|      1|    assert_eq!(bar, Foo(1));\n     9|      1|    let baz = Foo(0);\n-   10|      0|    assert_ne!(baz, Foo(1));\n+   10|      1|    assert_ne!(baz, Foo(1));\n    11|      1|    println!(\"{:?}\", Foo(1));\n    12|      1|    println!(\"{:?}\", bar);\n    13|      1|    println!(\"{:?}\", baz);"}, {"sha": "f24f7c69404731214ef8cfad027233d6f6727c01", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.issue-84561.txt", "status": "added", "additions": 195, "deletions": 0, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/1c2c6b670023efda0fea8e1837f9542d3ed12f5d/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.issue-84561.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1c2c6b670023efda0fea8e1837f9542d3ed12f5d/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.issue-84561.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.issue-84561.txt?ref=1c2c6b670023efda0fea8e1837f9542d3ed12f5d", "patch": "@@ -0,0 +1,195 @@\n+    1|       |// This demonstrated Issue #84561: function-like macros produce unintuitive coverage results.\n+    2|       |\n+    3|       |// expect-exit-status-101\n+    4|     21|#[derive(PartialEq, Eq)]\n+  ------------------\n+  | <issue_84561::Foo as core::cmp::PartialEq>::eq:\n+  |    4|     21|#[derive(PartialEq, Eq)]\n+  ------------------\n+  | Unexecuted instantiation: <issue_84561::Foo as core::cmp::PartialEq>::ne\n+  ------------------\n+    5|       |struct Foo(u32);\n+    6|      1|fn test3() {\n+    7|      1|    let is_true = std::env::args().len() == 1;\n+    8|      1|    let bar = Foo(1);\n+    9|      1|    assert_eq!(bar, Foo(1));\n+   10|      1|    let baz = Foo(0);\n+   11|      1|    assert_ne!(baz, Foo(1));\n+   12|      1|    println!(\"{:?}\", Foo(1));\n+   13|      1|    println!(\"{:?}\", bar);\n+   14|      1|    println!(\"{:?}\", baz);\n+   15|      1|\n+   16|      1|    assert_eq!(Foo(1), Foo(1));\n+   17|      1|    assert_ne!(Foo(0), Foo(1));\n+   18|      1|    assert_eq!(Foo(2), Foo(2));\n+   19|      1|    let bar = Foo(0);\n+   20|      1|    assert_ne!(bar, Foo(3));\n+   21|      1|    assert_ne!(Foo(0), Foo(4));\n+   22|      1|    assert_eq!(Foo(3), Foo(3), \"with a message\");\n+                                             ^0\n+   23|      1|    println!(\"{:?}\", bar);\n+   24|      1|    println!(\"{:?}\", Foo(1));\n+   25|      1|\n+   26|      1|    assert_ne!(Foo(0), Foo(5), \"{}\", if is_true { \"true message\" } else { \"false message\" });\n+                                             ^0                 ^0                      ^0\n+   27|      1|    assert_ne!(\n+   28|       |        Foo(0)\n+   29|       |        ,\n+   30|       |        Foo(5)\n+   31|       |        ,\n+   32|      0|        \"{}\"\n+   33|      0|        ,\n+   34|      0|        if\n+   35|      0|        is_true\n+   36|       |        {\n+   37|      0|            \"true message\"\n+   38|       |        } else {\n+   39|      0|            \"false message\"\n+   40|       |        }\n+   41|       |    );\n+   42|       |\n+   43|      1|    let is_true = std::env::args().len() == 1;\n+   44|      1|\n+   45|      1|    assert_eq!(\n+   46|      1|        Foo(1),\n+   47|      1|        Foo(1)\n+   48|      1|    );\n+   49|      1|    assert_ne!(\n+   50|      1|        Foo(0),\n+   51|      1|        Foo(1)\n+   52|      1|    );\n+   53|      1|    assert_eq!(\n+   54|      1|        Foo(2),\n+   55|      1|        Foo(2)\n+   56|      1|    );\n+   57|      1|    let bar = Foo(1);\n+   58|      1|    assert_ne!(\n+   59|      1|        bar,\n+   60|      1|        Foo(3)\n+   61|      1|    );\n+   62|      1|    if is_true {\n+   63|      1|        assert_ne!(\n+   64|      1|            Foo(0),\n+   65|      1|            Foo(4)\n+   66|      1|        );\n+   67|       |    } else {\n+   68|      0|        assert_eq!(\n+   69|      0|            Foo(3),\n+   70|      0|            Foo(3)\n+   71|      0|        );\n+   72|       |    }\n+   73|      1|    if is_true {\n+   74|      1|        assert_ne!(\n+   75|       |            Foo(0),\n+   76|       |            Foo(4),\n+   77|      0|            \"with a message\"\n+   78|       |        );\n+   79|       |    } else {\n+   80|      0|        assert_eq!(\n+   81|       |            Foo(3),\n+   82|       |            Foo(3),\n+   83|      0|            \"with a message\"\n+   84|       |        );\n+   85|       |    }\n+   86|      1|    assert_ne!(\n+   87|      1|        if is_true {\n+   88|      1|            Foo(0)\n+   89|       |        } else {\n+   90|      0|            Foo(1)\n+   91|       |        },\n+   92|       |        Foo(5)\n+   93|       |    );\n+   94|      1|    assert_ne!(\n+   95|      1|        Foo(5),\n+   96|      1|        if is_true {\n+   97|      1|            Foo(0)\n+   98|       |        } else {\n+   99|      0|            Foo(1)\n+  100|       |        }\n+  101|       |    );\n+  102|      1|    assert_ne!(\n+  103|      1|        if is_true {\n+  104|      1|            assert_eq!(\n+  105|      1|                Foo(3),\n+  106|      1|                Foo(3)\n+  107|      1|            );\n+  108|      1|            Foo(0)\n+  109|       |        } else {\n+  110|      0|            assert_ne!(\n+  111|      0|                if is_true {\n+  112|      0|                    Foo(0)\n+  113|       |                } else {\n+  114|      0|                    Foo(1)\n+  115|       |                },\n+  116|       |                Foo(5)\n+  117|       |            );\n+  118|      0|            Foo(1)\n+  119|       |        },\n+  120|       |        Foo(5),\n+  121|      0|        \"with a message\"\n+  122|       |    );\n+  123|      1|    assert_eq!(\n+  124|       |        Foo(1),\n+  125|       |        Foo(3),\n+  126|      1|        \"this assert should fail\"\n+  127|       |    );\n+  128|      0|    assert_eq!(\n+  129|       |        Foo(3),\n+  130|       |        Foo(3),\n+  131|      0|        \"this assert should not be reached\"\n+  132|       |    );\n+  133|      0|}\n+  134|       |\n+  135|       |impl std::fmt::Debug for Foo {\n+  136|       |    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+  137|      7|        write!(f, \"try and succeed\")?;\n+                                                  ^0\n+  138|      7|        Ok(())\n+  139|      7|    }\n+  140|       |}\n+  141|       |\n+  142|       |static mut DEBUG_LEVEL_ENABLED: bool = false;\n+  143|       |\n+  144|       |macro_rules! debug {\n+  145|       |    ($($arg:tt)+) => (\n+  146|       |        if unsafe { DEBUG_LEVEL_ENABLED } {\n+  147|       |            println!($($arg)+);\n+  148|       |        }\n+  149|       |    );\n+  150|       |}\n+  151|       |\n+  152|      1|fn test1() {\n+  153|      1|    debug!(\"debug is enabled\");\n+                         ^0\n+  154|      1|    debug!(\"debug is enabled\");\n+                         ^0\n+  155|      1|    let _ = 0;\n+  156|      1|    debug!(\"debug is enabled\");\n+                         ^0\n+  157|      1|    unsafe {\n+  158|      1|        DEBUG_LEVEL_ENABLED = true;\n+  159|      1|    }\n+  160|      1|    debug!(\"debug is enabled\");\n+  161|      1|}\n+  162|       |\n+  163|       |macro_rules! call_debug {\n+  164|       |    ($($arg:tt)+) => (\n+  165|      1|        fn call_print(s: &str) {\n+  166|      1|            print!(\"{}\", s);\n+  167|      1|        }\n+  168|       |\n+  169|       |        call_print(\"called from call_debug: \");\n+  170|       |        debug!($($arg)+);\n+  171|       |    );\n+  172|       |}\n+  173|       |\n+  174|      1|fn test2() {\n+  175|      1|    call_debug!(\"debug is enabled\");\n+  176|      1|}\n+  177|       |\n+  178|      1|fn main() {\n+  179|      1|    test1();\n+  180|      1|    test2();\n+  181|      1|    test3();\n+  182|      1|}\n+"}, {"sha": "018d264234468af4ca4a4415f9baf139b97fe9f0", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.uses_crate.txt", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1c2c6b670023efda0fea8e1837f9542d3ed12f5d/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.uses_crate.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1c2c6b670023efda0fea8e1837f9542d3ed12f5d/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.uses_crate.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.uses_crate.txt?ref=1c2c6b670023efda0fea8e1837f9542d3ed12f5d", "patch": "@@ -3,9 +3,9 @@\n     3|       |use std::fmt::Debug;\n     4|       |\n     5|      1|pub fn used_function() {\n-    6|       |    // Initialize test constants in a way that cannot be determined at compile time, to ensure\n-    7|       |    // rustc and LLVM cannot optimize out statements (or coverage counters) downstream from\n-    8|       |    // dependent conditions.\n+    6|      1|    // Initialize test constants in a way that cannot be determined at compile time, to ensure\n+    7|      1|    // rustc and LLVM cannot optimize out statements (or coverage counters) downstream from\n+    8|      1|    // dependent conditions.\n     9|      1|    let is_true = std::env::args().len() == 1;\n    10|      1|    let mut countdown = 0;\n    11|      1|    if is_true {\n@@ -36,12 +36,12 @@\n    22|      2|    println!(\"used_only_from_this_lib_crate_generic_function with {:?}\", arg);\n    23|      2|}\n   ------------------\n-  | used_crate::used_only_from_this_lib_crate_generic_function::<&str>:\n+  | used_crate::used_only_from_this_lib_crate_generic_function::<alloc::vec::Vec<i32>>:\n   |   21|      1|pub fn used_only_from_this_lib_crate_generic_function<T: Debug>(arg: T) {\n   |   22|      1|    println!(\"used_only_from_this_lib_crate_generic_function with {:?}\", arg);\n   |   23|      1|}\n   ------------------\n-  | used_crate::used_only_from_this_lib_crate_generic_function::<alloc::vec::Vec<i32>>:\n+  | used_crate::used_only_from_this_lib_crate_generic_function::<&str>:\n   |   21|      1|pub fn used_only_from_this_lib_crate_generic_function<T: Debug>(arg: T) {\n   |   22|      1|    println!(\"used_only_from_this_lib_crate_generic_function with {:?}\", arg);\n   |   23|      1|}"}, {"sha": "dab31cbf4ac9eef4770d4c4a0b292c5da3f0aa25", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.uses_inline_crate.txt", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1c2c6b670023efda0fea8e1837f9542d3ed12f5d/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.uses_inline_crate.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1c2c6b670023efda0fea8e1837f9542d3ed12f5d/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.uses_inline_crate.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.uses_inline_crate.txt?ref=1c2c6b670023efda0fea8e1837f9542d3ed12f5d", "patch": "@@ -5,9 +5,9 @@\n     5|       |use std::fmt::Debug;\n     6|       |\n     7|      1|pub fn used_function() {\n-    8|       |    // Initialize test constants in a way that cannot be determined at compile time, to ensure\n-    9|       |    // rustc and LLVM cannot optimize out statements (or coverage counters) downstream from\n-   10|       |    // dependent conditions.\n+    8|      1|    // Initialize test constants in a way that cannot be determined at compile time, to ensure\n+    9|      1|    // rustc and LLVM cannot optimize out statements (or coverage counters) downstream from\n+   10|      1|    // dependent conditions.\n    11|      1|    let is_true = std::env::args().len() == 1;\n    12|      1|    let mut countdown = 0;\n    13|      1|    if is_true {\n@@ -19,9 +19,9 @@\n    18|       |\n    19|       |#[inline(always)]\n    20|      1|pub fn used_inline_function() {\n-   21|       |    // Initialize test constants in a way that cannot be determined at compile time, to ensure\n-   22|       |    // rustc and LLVM cannot optimize out statements (or coverage counters) downstream from\n-   23|       |    // dependent conditions.\n+   21|      1|    // Initialize test constants in a way that cannot be determined at compile time, to ensure\n+   22|      1|    // rustc and LLVM cannot optimize out statements (or coverage counters) downstream from\n+   23|      1|    // dependent conditions.\n    24|      1|    let is_true = std::env::args().len() == 1;\n    25|      1|    let mut countdown = 0;\n    26|      1|    if is_true {"}, {"sha": "10e434007b88487219b3659dff873de59e0c07bc", "filename": "src/test/run-make-fulldeps/coverage/closure_macro.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/1c2c6b670023efda0fea8e1837f9542d3ed12f5d/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fclosure_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c2c6b670023efda0fea8e1837f9542d3ed12f5d/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fclosure_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fclosure_macro.rs?ref=1c2c6b670023efda0fea8e1837f9542d3ed12f5d", "patch": "@@ -0,0 +1,40 @@\n+// compile-flags: --edition=2018\n+#![feature(no_coverage)]\n+\n+macro_rules! bail {\n+    ($msg:literal $(,)?) => {\n+        if $msg.len() > 0 {\n+            println!(\"no msg\");\n+        } else {\n+            println!($msg);\n+        }\n+        return Err(String::from($msg));\n+    };\n+}\n+\n+macro_rules! on_error {\n+    ($value:expr, $error_message:expr) => {\n+        $value.or_else(|e| {\n+            let message = format!($error_message, e);\n+            if message.len() > 0 {\n+                println!(\"{}\", message);\n+                Ok(String::from(\"ok\"))\n+            } else {\n+                bail!(\"error\");\n+            }\n+        })\n+    };\n+}\n+\n+fn load_configuration_files() -> Result<String, String> {\n+    Ok(String::from(\"config\"))\n+}\n+\n+pub fn main() -> Result<(), String> {\n+    println!(\"Starting service\");\n+    let config = on_error!(load_configuration_files(), \"Error loading configs: {}\")?;\n+\n+    let startup_delay_duration = String::from(\"arg\");\n+    let _ = (config, startup_delay_duration);\n+    Ok(())\n+}"}, {"sha": "bcdfd11f8990da2eaab02e0a592f637640981407", "filename": "src/test/run-make-fulldeps/coverage/closure_macro_async.rs", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/1c2c6b670023efda0fea8e1837f9542d3ed12f5d/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fclosure_macro_async.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c2c6b670023efda0fea8e1837f9542d3ed12f5d/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fclosure_macro_async.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fclosure_macro_async.rs?ref=1c2c6b670023efda0fea8e1837f9542d3ed12f5d", "patch": "@@ -0,0 +1,81 @@\n+// compile-flags: --edition=2018\n+#![feature(no_coverage)]\n+\n+macro_rules! bail {\n+    ($msg:literal $(,)?) => {\n+        if $msg.len() > 0 {\n+            println!(\"no msg\");\n+        } else {\n+            println!($msg);\n+        }\n+        return Err(String::from($msg));\n+    };\n+}\n+\n+macro_rules! on_error {\n+    ($value:expr, $error_message:expr) => {\n+        $value.or_else(|e| {\n+            let message = format!($error_message, e);\n+            if message.len() > 0 {\n+                println!(\"{}\", message);\n+                Ok(String::from(\"ok\"))\n+            } else {\n+                bail!(\"error\");\n+            }\n+        })\n+    };\n+}\n+\n+fn load_configuration_files() -> Result<String, String> {\n+    Ok(String::from(\"config\"))\n+}\n+\n+pub async fn test() -> Result<(), String> {\n+    println!(\"Starting service\");\n+    let config = on_error!(load_configuration_files(), \"Error loading configs: {}\")?;\n+\n+    let startup_delay_duration = String::from(\"arg\");\n+    let _ = (config, startup_delay_duration);\n+    Ok(())\n+}\n+\n+#[no_coverage]\n+fn main() {\n+    executor::block_on(test());\n+}\n+\n+mod executor {\n+    use core::{\n+        future::Future,\n+        pin::Pin,\n+        task::{Context, Poll, RawWaker, RawWakerVTable, Waker},\n+    };\n+\n+    #[no_coverage]\n+    pub fn block_on<F: Future>(mut future: F) -> F::Output {\n+        let mut future = unsafe { Pin::new_unchecked(&mut future) };\n+        use std::hint::unreachable_unchecked;\n+        static VTABLE: RawWakerVTable = RawWakerVTable::new(\n+\n+            #[no_coverage]\n+            |_| unsafe { unreachable_unchecked() }, // clone\n+\n+            #[no_coverage]\n+            |_| unsafe { unreachable_unchecked() }, // wake\n+\n+            #[no_coverage]\n+            |_| unsafe { unreachable_unchecked() }, // wake_by_ref\n+\n+            #[no_coverage]\n+            |_| (),\n+        );\n+        let waker = unsafe { Waker::from_raw(RawWaker::new(core::ptr::null(), &VTABLE)) };\n+        let mut context = Context::from_waker(&waker);\n+\n+        loop {\n+            if let Poll::Ready(val) = future.as_mut().poll(&mut context) {\n+                break val;\n+            }\n+        }\n+    }\n+}"}, {"sha": "b39a289c45e209bc71529a0a1d6c64c77580c405", "filename": "src/test/run-make-fulldeps/coverage/issue-84561.rs", "status": "added", "additions": 182, "deletions": 0, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/1c2c6b670023efda0fea8e1837f9542d3ed12f5d/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fissue-84561.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c2c6b670023efda0fea8e1837f9542d3ed12f5d/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fissue-84561.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fissue-84561.rs?ref=1c2c6b670023efda0fea8e1837f9542d3ed12f5d", "patch": "@@ -0,0 +1,182 @@\n+// This demonstrated Issue #84561: function-like macros produce unintuitive coverage results.\n+\n+// expect-exit-status-101\n+#[derive(PartialEq, Eq)]\n+struct Foo(u32);\n+fn test3() {\n+    let is_true = std::env::args().len() == 1;\n+    let bar = Foo(1);\n+    assert_eq!(bar, Foo(1));\n+    let baz = Foo(0);\n+    assert_ne!(baz, Foo(1));\n+    println!(\"{:?}\", Foo(1));\n+    println!(\"{:?}\", bar);\n+    println!(\"{:?}\", baz);\n+\n+    assert_eq!(Foo(1), Foo(1));\n+    assert_ne!(Foo(0), Foo(1));\n+    assert_eq!(Foo(2), Foo(2));\n+    let bar = Foo(0);\n+    assert_ne!(bar, Foo(3));\n+    assert_ne!(Foo(0), Foo(4));\n+    assert_eq!(Foo(3), Foo(3), \"with a message\");\n+    println!(\"{:?}\", bar);\n+    println!(\"{:?}\", Foo(1));\n+\n+    assert_ne!(Foo(0), Foo(5), \"{}\", if is_true { \"true message\" } else { \"false message\" });\n+    assert_ne!(\n+        Foo(0)\n+        ,\n+        Foo(5)\n+        ,\n+        \"{}\"\n+        ,\n+        if\n+        is_true\n+        {\n+            \"true message\"\n+        } else {\n+            \"false message\"\n+        }\n+    );\n+\n+    let is_true = std::env::args().len() == 1;\n+\n+    assert_eq!(\n+        Foo(1),\n+        Foo(1)\n+    );\n+    assert_ne!(\n+        Foo(0),\n+        Foo(1)\n+    );\n+    assert_eq!(\n+        Foo(2),\n+        Foo(2)\n+    );\n+    let bar = Foo(1);\n+    assert_ne!(\n+        bar,\n+        Foo(3)\n+    );\n+    if is_true {\n+        assert_ne!(\n+            Foo(0),\n+            Foo(4)\n+        );\n+    } else {\n+        assert_eq!(\n+            Foo(3),\n+            Foo(3)\n+        );\n+    }\n+    if is_true {\n+        assert_ne!(\n+            Foo(0),\n+            Foo(4),\n+            \"with a message\"\n+        );\n+    } else {\n+        assert_eq!(\n+            Foo(3),\n+            Foo(3),\n+            \"with a message\"\n+        );\n+    }\n+    assert_ne!(\n+        if is_true {\n+            Foo(0)\n+        } else {\n+            Foo(1)\n+        },\n+        Foo(5)\n+    );\n+    assert_ne!(\n+        Foo(5),\n+        if is_true {\n+            Foo(0)\n+        } else {\n+            Foo(1)\n+        }\n+    );\n+    assert_ne!(\n+        if is_true {\n+            assert_eq!(\n+                Foo(3),\n+                Foo(3)\n+            );\n+            Foo(0)\n+        } else {\n+            assert_ne!(\n+                if is_true {\n+                    Foo(0)\n+                } else {\n+                    Foo(1)\n+                },\n+                Foo(5)\n+            );\n+            Foo(1)\n+        },\n+        Foo(5),\n+        \"with a message\"\n+    );\n+    assert_eq!(\n+        Foo(1),\n+        Foo(3),\n+        \"this assert should fail\"\n+    );\n+    assert_eq!(\n+        Foo(3),\n+        Foo(3),\n+        \"this assert should not be reached\"\n+    );\n+}\n+\n+impl std::fmt::Debug for Foo {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        write!(f, \"try and succeed\")?;\n+        Ok(())\n+    }\n+}\n+\n+static mut DEBUG_LEVEL_ENABLED: bool = false;\n+\n+macro_rules! debug {\n+    ($($arg:tt)+) => (\n+        if unsafe { DEBUG_LEVEL_ENABLED } {\n+            println!($($arg)+);\n+        }\n+    );\n+}\n+\n+fn test1() {\n+    debug!(\"debug is enabled\");\n+    debug!(\"debug is enabled\");\n+    let _ = 0;\n+    debug!(\"debug is enabled\");\n+    unsafe {\n+        DEBUG_LEVEL_ENABLED = true;\n+    }\n+    debug!(\"debug is enabled\");\n+}\n+\n+macro_rules! call_debug {\n+    ($($arg:tt)+) => (\n+        fn call_print(s: &str) {\n+            print!(\"{}\", s);\n+        }\n+\n+        call_print(\"called from call_debug: \");\n+        debug!($($arg)+);\n+    );\n+}\n+\n+fn test2() {\n+    call_debug!(\"debug is enabled\");\n+}\n+\n+fn main() {\n+    test1();\n+    test2();\n+    test3();\n+}"}]}