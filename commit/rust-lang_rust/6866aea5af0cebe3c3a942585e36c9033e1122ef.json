{"sha": "6866aea5af0cebe3c3a942585e36c9033e1122ef", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4NjZhZWE1YWYwY2ViZTNjM2E5NDI1ODVlMzZjOTAzM2UxMTIyZWY=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-08-30T20:40:43Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-09-03T10:10:54Z"}, "message": "implement improved on_unimplemented directives", "tree": {"sha": "df707ffd3bc1dd32a1c6512433f481636444b894", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df707ffd3bc1dd32a1c6512433f481636444b894"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6866aea5af0cebe3c3a942585e36c9033e1122ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6866aea5af0cebe3c3a942585e36c9033e1122ef", "html_url": "https://github.com/rust-lang/rust/commit/6866aea5af0cebe3c3a942585e36c9033e1122ef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6866aea5af0cebe3c3a942585e36c9033e1122ef/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf07ebd2a2d148667d2fa79e6fc683ee3b4c7e48", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf07ebd2a2d148667d2fa79e6fc683ee3b4c7e48", "html_url": "https://github.com/rust-lang/rust/commit/cf07ebd2a2d148667d2fa79e6fc683ee3b4c7e48"}], "stats": {"total": 340, "additions": 290, "deletions": 50}, "files": [{"sha": "be7bb4d8114132d042132107c6de1e5da71a3ef1", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6866aea5af0cebe3c3a942585e36c9033e1122ef/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6866aea5af0cebe3c3a942585e36c9033e1122ef/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=6866aea5af0cebe3c3a942585e36c9033e1122ef", "patch": "@@ -2012,9 +2012,9 @@ register_diagnostics! {\n //  E0102, // replaced with E0282\n //  E0134,\n //  E0135,\n-//  E0271, // on_unimplemented #0\n-//  E0272, // on_unimplemented #1\n-//  E0273, // on_unimplemented #2\n+//  E0272, // on_unimplemented #0\n+//  E0273, // on_unimplemented #1\n+//  E0274, // on_unimplemented #2\n     E0278, // requirement is not satisfied\n     E0279, // requirement is not satisfied\n     E0280, // requirement is not satisfied"}, {"sha": "48cd03585912ca9af1f45cf7b195a647edd6cd58", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 27, "deletions": 16, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/6866aea5af0cebe3c3a942585e36c9033e1122ef/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6866aea5af0cebe3c3a942585e36c9033e1122ef/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=6866aea5af0cebe3c3a942585e36c9033e1122ef", "patch": "@@ -15,7 +15,8 @@ use super::{\n     Obligation,\n     ObligationCause,\n     ObligationCauseCode,\n-    OnUnimplementedInfo,\n+    OnUnimplementedDirective,\n+    OnUnimplementedNote,\n     OutputTypeParameterMismatch,\n     TraitNotObjectSafe,\n     PredicateObligation,\n@@ -316,18 +317,22 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn on_unimplemented_note(&self,\n-                             trait_ref: ty::PolyTraitRef<'tcx>,\n-                             obligation: &PredicateObligation<'tcx>) -> Option<String> {\n+    fn on_unimplemented_note(\n+        &self,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n+        obligation: &PredicateObligation<'tcx>) ->\n+        OnUnimplementedNote\n+    {\n         let def_id = self.impl_similar_to(trait_ref, obligation)\n             .unwrap_or(trait_ref.def_id());\n-        let trait_ref = trait_ref.skip_binder();\n+        let trait_ref = *trait_ref.skip_binder();\n \n-        match OnUnimplementedInfo::of_item(\n-            self.tcx, trait_ref.def_id, def_id, obligation.cause.span\n+        if let Ok(Some(command)) = OnUnimplementedDirective::of_item(\n+            self.tcx, trait_ref.def_id, def_id\n         ) {\n-            Ok(Some(info)) => Some(info.label.format(self.tcx, *trait_ref)),\n-            _ => None\n+            command.evaluate(self.tcx, trait_ref, &[])\n+        } else {\n+            OnUnimplementedNote::empty()\n         }\n     }\n \n@@ -519,17 +524,23 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         let (post_message, pre_message) =\n                             self.get_parent_trait_ref(&obligation.cause.code)\n                                 .map(|t| (format!(\" in `{}`\", t), format!(\"within `{}`, \", t)))\n-                                .unwrap_or((String::new(), String::new()));\n+                            .unwrap_or((String::new(), String::new()));\n+\n+                        let OnUnimplementedNote { message, label }\n+                            = self.on_unimplemented_note(trait_ref, obligation);\n+                        let have_alt_message = message.is_some() || label.is_some();\n+\n                         let mut err = struct_span_err!(\n                             self.tcx.sess,\n                             span,\n                             E0277,\n-                            \"the trait bound `{}` is not satisfied{}\",\n-                            trait_ref.to_predicate(),\n-                            post_message);\n+                            \"{}\",\n+                            message.unwrap_or_else(|| {\n+                                format!(\"the trait bound `{}` is not satisfied{}\",\n+                                         trait_ref.to_predicate(), post_message)\n+                            }));\n \n-                        let unimplemented_note = self.on_unimplemented_note(trait_ref, obligation);\n-                        if let Some(ref s) = unimplemented_note {\n+                        if let Some(ref s) = label {\n                             // If it has a custom \"#[rustc_on_unimplemented]\"\n                             // error message, let's display it as the label!\n                             err.span_label(span, s.as_str());\n@@ -557,7 +568,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                             // which is somewhat confusing.\n                             err.help(&format!(\"consider adding a `where {}` bound\",\n                                                 trait_ref.to_predicate()));\n-                        } else if unimplemented_note.is_none() {\n+                        } else if !have_alt_message {\n                             // Can't show anything else useful, try to find similar impls.\n                             let impl_candidates = self.find_similar_impl_candidates(trait_ref);\n                             self.report_similar_impl_candidates(impl_candidates, &mut err);"}, {"sha": "875cca5b670ea12e74dfc5da5b4d0d27bc5e5640", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6866aea5af0cebe3c3a942585e36c9033e1122ef/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6866aea5af0cebe3c3a942585e36c9033e1122ef/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=6866aea5af0cebe3c3a942585e36c9033e1122ef", "patch": "@@ -37,7 +37,7 @@ pub use self::project::{normalize, normalize_projection_type, Normalized};\n pub use self::project::{ProjectionCache, ProjectionCacheSnapshot, Reveal};\n pub use self::object_safety::ObjectSafetyViolation;\n pub use self::object_safety::MethodViolationCode;\n-pub use self::on_unimplemented::OnUnimplementedInfo;\n+pub use self::on_unimplemented::{OnUnimplementedDirective, OnUnimplementedNote};\n pub use self::select::{EvaluationCache, SelectionContext, SelectionCache};\n pub use self::specialize::{OverlapError, specialization_graph, translate_substs};\n pub use self::specialize::{SpecializesCache, find_associated_item};"}, {"sha": "6d2138f6234b5cac7c3589264549271d51e26bf2", "filename": "src/librustc/traits/on_unimplemented.rs", "status": "modified", "additions": 157, "deletions": 17, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/6866aea5af0cebe3c3a942585e36c9033e1122ef/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6866aea5af0cebe3c3a942585e36c9033e1122ef/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs?ref=6866aea5af0cebe3c3a942585e36c9033e1122ef", "patch": "@@ -15,19 +15,127 @@ use ty::{self, TyCtxt};\n use util::common::ErrorReported;\n use util::nodemap::FxHashMap;\n \n+use syntax::ast::{MetaItem, NestedMetaItem};\n+use syntax::attr;\n use syntax_pos::Span;\n use syntax_pos::symbol::InternedString;\n \n+#[derive(Clone, Debug)]\n pub struct OnUnimplementedFormatString(InternedString);\n-pub struct OnUnimplementedInfo {\n-    pub label: OnUnimplementedFormatString\n+\n+#[derive(Debug)]\n+pub struct OnUnimplementedDirective {\n+    pub condition: Option<MetaItem>,\n+    pub subcommands: Vec<OnUnimplementedDirective>,\n+    pub message: Option<OnUnimplementedFormatString>,\n+    pub label: Option<OnUnimplementedFormatString>,\n+}\n+\n+pub struct OnUnimplementedNote {\n+    pub message: Option<String>,\n+    pub label: Option<String>,\n+}\n+\n+impl OnUnimplementedNote {\n+    pub fn empty() -> Self {\n+        OnUnimplementedNote { message: None, label: None }\n+    }\n }\n \n-impl<'a, 'gcx, 'tcx> OnUnimplementedInfo {\n+fn parse_error(tcx: TyCtxt, span: Span,\n+               message: &str,\n+               label: &str,\n+               note: Option<&str>)\n+               -> ErrorReported\n+{\n+    let mut diag = struct_span_err!(\n+        tcx.sess, span, E0232, \"{}\", message);\n+    diag.span_label(span, label);\n+    if let Some(note) = note {\n+        diag.note(note);\n+    }\n+    diag.emit();\n+    ErrorReported\n+}\n+\n+impl<'a, 'gcx, 'tcx> OnUnimplementedDirective {\n+    pub fn parse(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                 trait_def_id: DefId,\n+                 items: &[NestedMetaItem],\n+                 span: Span,\n+                 is_root: bool)\n+                 -> Result<Self, ErrorReported>\n+    {\n+        let mut errored = false;\n+        let mut item_iter = items.iter();\n+\n+        let condition = if is_root {\n+            None\n+        } else {\n+            let cond = item_iter.next().ok_or_else(|| {\n+                parse_error(tcx, span,\n+                            \"empty `on`-clause in `#[rustc_on_unimplemented]`\",\n+                            \"empty on-clause here\",\n+                            None)\n+            })?.meta_item().ok_or_else(|| {\n+                parse_error(tcx, span,\n+                            \"invalid `on`-clause in `#[rustc_on_unimplemented]`\",\n+                            \"invalid on-clause here\",\n+                            None)\n+            })?;\n+            attr::eval_condition(cond, &tcx.sess.parse_sess, &mut |_| true);\n+            Some(cond.clone())\n+        };\n+\n+        let mut message = None;\n+        let mut label = None;\n+        let mut subcommands = vec![];\n+        for item in item_iter {\n+            if item.check_name(\"message\") && message.is_none() {\n+                if let Some(message_) = item.value_str() {\n+                    message = Some(OnUnimplementedFormatString::try_parse(\n+                        tcx, trait_def_id, message_.as_str(), span)?);\n+                    continue;\n+                }\n+            } else if item.check_name(\"label\") && label.is_none() {\n+                if let Some(label_) = item.value_str() {\n+                    label = Some(OnUnimplementedFormatString::try_parse(\n+                        tcx, trait_def_id, label_.as_str(), span)?);\n+                    continue;\n+                }\n+            } else if item.check_name(\"on\") && is_root &&\n+                message.is_none() && label.is_none()\n+            {\n+                if let Some(items) = item.meta_item_list() {\n+                    if let Ok(subcommand) =\n+                        Self::parse(tcx, trait_def_id, &items, item.span, false)\n+                    {\n+                        subcommands.push(subcommand);\n+                    } else {\n+                        errored = true;\n+                    }\n+                    continue\n+                }\n+            }\n+\n+            // nothing found\n+            parse_error(tcx, item.span,\n+                        \"this attribute must have a valid value\",\n+                        \"expected value here\",\n+                        Some(r#\"eg `#[rustc_on_unimplemented = \"foo\"]`\"#));\n+        }\n+\n+        if errored {\n+            Err(ErrorReported)\n+        } else {\n+            Ok(OnUnimplementedDirective { condition, message, label, subcommands })\n+        }\n+    }\n+\n+\n     pub fn of_item(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                    trait_def_id: DefId,\n-                   impl_def_id: DefId,\n-                   span: Span)\n+                   impl_def_id: DefId)\n                    -> Result<Option<Self>, ErrorReported>\n     {\n         let attrs = tcx.get_attrs(impl_def_id);\n@@ -40,20 +148,52 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedInfo {\n             return Ok(None);\n         };\n \n-        let span = attr.span.substitute_dummy(span);\n-        if let Some(label) = attr.value_str() {\n-            Ok(Some(OnUnimplementedInfo {\n-                label: OnUnimplementedFormatString::try_parse(\n-                    tcx, trait_def_id, label.as_str(), span)?\n+        let result = if let Some(items) = attr.meta_item_list() {\n+            Self::parse(tcx, trait_def_id, &items, attr.span, true).map(Some)\n+        } else if let Some(value) = attr.value_str() {\n+            Ok(Some(OnUnimplementedDirective {\n+                condition: None,\n+                message: None,\n+                subcommands: vec![],\n+                label: Some(OnUnimplementedFormatString::try_parse(\n+                    tcx, trait_def_id, value.as_str(), attr.span)?)\n             }))\n         } else {\n-            struct_span_err!(\n-                tcx.sess, span, E0232,\n-                \"this attribute must have a value\")\n-                .span_label(attr.span, \"attribute requires a value\")\n-                .note(&format!(\"eg `#[rustc_on_unimplemented = \\\"foo\\\"]`\"))\n-                .emit();\n-            Err(ErrorReported)\n+            return Err(parse_error(tcx, attr.span,\n+                                   \"`#[rustc_on_unimplemented]` requires a value\",\n+                                   \"value required here\",\n+                                   Some(r#\"eg `#[rustc_on_unimplemented = \"foo\"]`\"#)));\n+        };\n+        debug!(\"of_item({:?}/{:?}) = {:?}\", trait_def_id, impl_def_id, result);\n+        result\n+    }\n+\n+    pub fn evaluate(&self,\n+                    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                    trait_ref: ty::TraitRef<'tcx>,\n+                    options: &[&str])\n+                    -> OnUnimplementedNote\n+    {\n+        let mut message = None;\n+        let mut label = None;\n+\n+        for command in self.subcommands.iter().chain(Some(self)).rev() {\n+            if let Some(ref condition) = command.condition {\n+                if !attr::eval_condition(condition, &tcx.sess.parse_sess, &mut |c| {\n+                    options.iter().any(|o| c.check_name(o))\n+                }) {\n+                    debug!(\"evaluate: skipping {:?} due to condition\", command);\n+                    continue\n+                }\n+            }\n+            debug!(\"evaluate: {:?} succeeded\", command);\n+            message = command.message.clone();\n+            label = command.label.clone();\n+        }\n+\n+        OnUnimplementedNote {\n+            label: label.map(|l| l.format(tcx, trait_ref)),\n+            message: message.map(|m| m.format(tcx, trait_ref))\n         }\n     }\n }"}, {"sha": "d2e74917fed082d0012ccf860cb9f1a9cd4b9f0a", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6866aea5af0cebe3c3a942585e36c9033e1122ef/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6866aea5af0cebe3c3a942585e36c9033e1122ef/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=6866aea5af0cebe3c3a942585e36c9033e1122ef", "patch": "@@ -1218,8 +1218,8 @@ fn check_on_unimplemented<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                     item: &hir::Item) {\n     let item_def_id = tcx.hir.local_def_id(item.id);\n     // an error would be reported if this fails.\n-    let _ = traits::OnUnimplementedInfo::of_item(\n-        tcx, trait_def_id, item_def_id, item.span);\n+    let _ = traits::OnUnimplementedDirective::of_item(\n+        tcx, trait_def_id, item_def_id);\n }\n \n fn report_forbidden_specialization<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,"}, {"sha": "adbbc1b0ac5885b6f7aaaa9a3923ac4a97be47a7", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6866aea5af0cebe3c3a942585e36c9033e1122ef/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6866aea5af0cebe3c3a942585e36c9033e1122ef/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=6866aea5af0cebe3c3a942585e36c9033e1122ef", "patch": "@@ -585,6 +585,20 @@ pub fn requests_inline(attrs: &[Attribute]) -> bool {\n \n /// Tests if a cfg-pattern matches the cfg set\n pub fn cfg_matches(cfg: &ast::MetaItem, sess: &ParseSess, features: Option<&Features>) -> bool {\n+    eval_condition(cfg, sess, &mut |cfg| {\n+        if let (Some(feats), Some(gated_cfg)) = (features, GatedCfg::gate(cfg)) {\n+            gated_cfg.check_and_emit(sess, feats);\n+        }\n+        sess.config.contains(&(cfg.name(), cfg.value_str()))\n+    })\n+}\n+\n+/// Evaluate a cfg-like condition (with `any` and `all`), using `eval` to\n+/// evaluate individual items.\n+pub fn eval_condition<F>(cfg: &ast::MetaItem, sess: &ParseSess, eval: &mut F)\n+                         -> bool\n+    where F: FnMut(&ast::MetaItem) -> bool\n+{\n     match cfg.node {\n         ast::MetaItemKind::List(ref mis) => {\n             for mi in mis.iter() {\n@@ -598,18 +612,18 @@ pub fn cfg_matches(cfg: &ast::MetaItem, sess: &ParseSess, features: Option<&Feat\n             // that they won't fail with the loop above.\n             match &*cfg.name.as_str() {\n                 \"any\" => mis.iter().any(|mi| {\n-                    cfg_matches(mi.meta_item().unwrap(), sess, features)\n+                    eval_condition(mi.meta_item().unwrap(), sess, eval)\n                 }),\n                 \"all\" => mis.iter().all(|mi| {\n-                    cfg_matches(mi.meta_item().unwrap(), sess, features)\n+                    eval_condition(mi.meta_item().unwrap(), sess, eval)\n                 }),\n                 \"not\" => {\n                     if mis.len() != 1 {\n                         span_err!(sess.span_diagnostic, cfg.span, E0536, \"expected 1 cfg-pattern\");\n                         return false;\n                     }\n \n-                    !cfg_matches(mis[0].meta_item().unwrap(), sess, features)\n+                    !eval_condition(mis[0].meta_item().unwrap(), sess, eval)\n                 },\n                 p => {\n                     span_err!(sess.span_diagnostic, cfg.span, E0537, \"invalid predicate `{}`\", p);\n@@ -618,10 +632,7 @@ pub fn cfg_matches(cfg: &ast::MetaItem, sess: &ParseSess, features: Option<&Feat\n             }\n         },\n         ast::MetaItemKind::Word | ast::MetaItemKind::NameValue(..) => {\n-            if let (Some(feats), Some(gated_cfg)) = (features, GatedCfg::gate(cfg)) {\n-                gated_cfg.check_and_emit(sess, feats);\n-            }\n-            sess.config.contains(&(cfg.name(), cfg.value_str()))\n+            eval(cfg)\n         }\n     }\n }"}, {"sha": "a33120bbebd2321d47093e20daddb732ca31bea2", "filename": "src/test/compile-fail/E0232.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6866aea5af0cebe3c3a942585e36c9033e1122ef/src%2Ftest%2Fcompile-fail%2FE0232.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6866aea5af0cebe3c3a942585e36c9033e1122ef/src%2Ftest%2Fcompile-fail%2FE0232.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0232.rs?ref=6866aea5af0cebe3c3a942585e36c9033e1122ef", "patch": "@@ -12,7 +12,7 @@\n \n #[rustc_on_unimplemented]\n //~^ ERROR E0232\n-//~| NOTE attribute requires a value\n+//~| NOTE value required here\n //~| NOTE eg `#[rustc_on_unimplemented = \"foo\"]`\n trait Bar {}\n "}, {"sha": "54d3b3e087653f2ec63505526c71bd018c8c95fb", "filename": "src/test/ui/on-unimplemented/bad-annotation.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6866aea5af0cebe3c3a942585e36c9033e1122ef/src%2Ftest%2Fui%2Fon-unimplemented%2Fbad-annotation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6866aea5af0cebe3c3a942585e36c9033e1122ef/src%2Ftest%2Fui%2Fon-unimplemented%2Fbad-annotation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fon-unimplemented%2Fbad-annotation.rs?ref=6866aea5af0cebe3c3a942585e36c9033e1122ef", "patch": "@@ -37,5 +37,29 @@ trait BadAnnotation2<A,B>\n trait BadAnnotation3<A,B>\n {}\n \n+#[rustc_on_unimplemented(lorem=\"\")]\n+trait BadAnnotation4 {}\n+\n+#[rustc_on_unimplemented(lorem(ipsum(dolor)))]\n+trait BadAnnotation5 {}\n+\n+#[rustc_on_unimplemented(message=\"x\", message=\"y\")]\n+trait BadAnnotation6 {}\n+\n+#[rustc_on_unimplemented(message=\"x\", on(desugared, message=\"y\"))]\n+trait BadAnnotation7 {}\n+\n+#[rustc_on_unimplemented(on(), message=\"y\")]\n+trait BadAnnotation8 {}\n+\n+#[rustc_on_unimplemented(on=\"x\", message=\"y\")]\n+trait BadAnnotation9 {}\n+\n+#[rustc_on_unimplemented(on(x=\"y\"), message=\"y\")]\n+trait BadAnnotation10 {}\n+\n+#[rustc_on_unimplemented(on(desugared, on(desugared, message=\"x\")), message=\"y\")]\n+trait BadAnnotation11 {}\n+\n pub fn main() {\n }"}, {"sha": "73834f4422d388e4be10d190944cb06a35f639bf", "filename": "src/test/ui/on-unimplemented/bad-annotation.stderr", "status": "modified", "additions": 57, "deletions": 3, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/6866aea5af0cebe3c3a942585e36c9033e1122ef/src%2Ftest%2Fui%2Fon-unimplemented%2Fbad-annotation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6866aea5af0cebe3c3a942585e36c9033e1122ef/src%2Ftest%2Fui%2Fon-unimplemented%2Fbad-annotation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fon-unimplemented%2Fbad-annotation.stderr?ref=6866aea5af0cebe3c3a942585e36c9033e1122ef", "patch": "@@ -1,8 +1,8 @@\n-error[E0232]: this attribute must have a value\n+error[E0232]: `#[rustc_on_unimplemented]` requires a value\n   --> $DIR/bad-annotation.rs:26:1\n    |\n 26 | #[rustc_on_unimplemented] //~ ERROR this attribute must have a value\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^ attribute requires a value\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^ value required here\n    |\n    = note: eg `#[rustc_on_unimplemented = \"foo\"]`\n \n@@ -18,5 +18,59 @@ error[E0231]: only named substitution parameters are allowed\n 35 | #[rustc_on_unimplemented = \"Unimplemented trait error on `{Self}` with params `<{A},{B},{}>`\"]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 3 previous errors\n+error[E0232]: this attribute must have a valid value\n+  --> $DIR/bad-annotation.rs:40:26\n+   |\n+40 | #[rustc_on_unimplemented(lorem=\"\")]\n+   |                          ^^^^^^^^ expected value here\n+   |\n+   = note: eg `#[rustc_on_unimplemented = \"foo\"]`\n+\n+error[E0232]: this attribute must have a valid value\n+  --> $DIR/bad-annotation.rs:43:26\n+   |\n+43 | #[rustc_on_unimplemented(lorem(ipsum(dolor)))]\n+   |                          ^^^^^^^^^^^^^^^^^^^ expected value here\n+   |\n+   = note: eg `#[rustc_on_unimplemented = \"foo\"]`\n+\n+error[E0232]: this attribute must have a valid value\n+  --> $DIR/bad-annotation.rs:46:39\n+   |\n+46 | #[rustc_on_unimplemented(message=\"x\", message=\"y\")]\n+   |                                       ^^^^^^^^^^^ expected value here\n+   |\n+   = note: eg `#[rustc_on_unimplemented = \"foo\"]`\n+\n+error[E0232]: this attribute must have a valid value\n+  --> $DIR/bad-annotation.rs:49:39\n+   |\n+49 | #[rustc_on_unimplemented(message=\"x\", on(desugared, message=\"y\"))]\n+   |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected value here\n+   |\n+   = note: eg `#[rustc_on_unimplemented = \"foo\"]`\n+\n+error[E0232]: empty `on`-clause in `#[rustc_on_unimplemented]`\n+  --> $DIR/bad-annotation.rs:52:26\n+   |\n+52 | #[rustc_on_unimplemented(on(), message=\"y\")]\n+   |                          ^^^^ empty on-clause here\n+\n+error[E0232]: this attribute must have a valid value\n+  --> $DIR/bad-annotation.rs:55:26\n+   |\n+55 | #[rustc_on_unimplemented(on=\"x\", message=\"y\")]\n+   |                          ^^^^^^ expected value here\n+   |\n+   = note: eg `#[rustc_on_unimplemented = \"foo\"]`\n+\n+error[E0232]: this attribute must have a valid value\n+  --> $DIR/bad-annotation.rs:61:40\n+   |\n+61 | #[rustc_on_unimplemented(on(desugared, on(desugared, message=\"x\")), message=\"y\")]\n+   |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected value here\n+   |\n+   = note: eg `#[rustc_on_unimplemented = \"foo\"]`\n+\n+error: aborting due to 10 previous errors\n "}]}