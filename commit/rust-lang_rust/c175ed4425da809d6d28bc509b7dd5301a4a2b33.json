{"sha": "c175ed4425da809d6d28bc509b7dd5301a4a2b33", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxNzVlZDQ0MjVkYTgwOWQ2ZDI4YmM1MDliN2RkNTMwMWE0YTJiMzM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-07T21:01:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-07T21:01:42Z"}, "message": "auto merge of #15440 : pcwalton/rust/struct-aliases, r=brson\n\nCloses #4508.\r\n\r\nr? @nick29581", "tree": {"sha": "b62bfd745481069fd82c59daa47ee63371ad07d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b62bfd745481069fd82c59daa47ee63371ad07d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c175ed4425da809d6d28bc509b7dd5301a4a2b33", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c175ed4425da809d6d28bc509b7dd5301a4a2b33", "html_url": "https://github.com/rust-lang/rust/commit/c175ed4425da809d6d28bc509b7dd5301a4a2b33", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c175ed4425da809d6d28bc509b7dd5301a4a2b33/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "49bc17bfdd7143909aede81652d7d624cecd8a70", "url": "https://api.github.com/repos/rust-lang/rust/commits/49bc17bfdd7143909aede81652d7d624cecd8a70", "html_url": "https://github.com/rust-lang/rust/commit/49bc17bfdd7143909aede81652d7d624cecd8a70"}, {"sha": "aaaf7e00ec67961e89806e0ad58a0ec9bad07ae8", "url": "https://api.github.com/repos/rust-lang/rust/commits/aaaf7e00ec67961e89806e0ad58a0ec9bad07ae8", "html_url": "https://github.com/rust-lang/rust/commit/aaaf7e00ec67961e89806e0ad58a0ec9bad07ae8"}], "stats": {"total": 241, "additions": 173, "deletions": 68}, "files": [{"sha": "4758825bf0e1cd0d42370dc540cd2efdc3ab0ede", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c175ed4425da809d6d28bc509b7dd5301a4a2b33/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c175ed4425da809d6d28bc509b7dd5301a4a2b33/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=c175ed4425da809d6d28bc509b7dd5301a4a2b33", "patch": "@@ -671,8 +671,17 @@ pub fn specialize(cx: &MatchCheckCtxt, r: &[Gc<Pat>],\n                 } else {\n                     None\n                 },\n-                DefStruct(struct_id) => Some(struct_id),\n-                _ => None\n+                _ => {\n+                    // Assume this is a struct.\n+                    match ty::ty_to_def_id(node_id_to_type(cx.tcx, pat_id)) {\n+                        None => {\n+                            cx.tcx.sess.span_bug(pat_span,\n+                                                 \"struct pattern wasn't of a \\\n+                                                  type with a def ID?!\")\n+                        }\n+                        Some(def_id) => Some(def_id),\n+                    }\n+                }\n             };\n             class_id.map(|variant_id| {\n                 let struct_fields = ty::lookup_struct_fields(cx.tcx, variant_id);"}, {"sha": "9ec167ee8263ef7d9db5f036d3c67e6142e22d93", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c175ed4425da809d6d28bc509b7dd5301a4a2b33/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c175ed4425da809d6d28bc509b7dd5301a4a2b33/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=c175ed4425da809d6d28bc509b7dd5301a4a2b33", "patch": "@@ -141,16 +141,25 @@ impl<'a> MarkSymbolVisitor<'a> {\n     }\n \n     fn handle_field_pattern_match(&mut self, lhs: &ast::Pat, pats: &[ast::FieldPat]) {\n-        match self.tcx.def_map.borrow().get(&lhs.id) {\n-            &def::DefStruct(id) | &def::DefVariant(_, id, _) => {\n-                let fields = ty::lookup_struct_fields(self.tcx, id);\n-                for pat in pats.iter() {\n-                    let field_id = fields.iter()\n-                        .find(|field| field.name == pat.ident.name).unwrap().id;\n-                    self.live_symbols.insert(field_id.node);\n+        let id = match self.tcx.def_map.borrow().get(&lhs.id) {\n+            &def::DefVariant(_, id, _) => id,\n+            _ => {\n+                match ty::ty_to_def_id(ty::node_id_to_type(self.tcx,\n+                                                           lhs.id)) {\n+                    None => {\n+                        self.tcx.sess.span_bug(lhs.span,\n+                                               \"struct pattern wasn't of a \\\n+                                                type with a def ID?!\")\n+                    }\n+                    Some(def_id) => def_id,\n                 }\n             }\n-            _ => ()\n+        };\n+        let fields = ty::lookup_struct_fields(self.tcx, id);\n+        for pat in pats.iter() {\n+            let field_id = fields.iter()\n+                .find(|field| field.name == pat.ident.name).unwrap().id;\n+            self.live_symbols.insert(field_id.node);\n         }\n     }\n "}, {"sha": "6ec1f23cdbd0818e1a6f3e10c374059c82569490", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 5, "deletions": 21, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c175ed4425da809d6d28bc509b7dd5301a4a2b33/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c175ed4425da809d6d28bc509b7dd5301a4a2b33/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=c175ed4425da809d6d28bc509b7dd5301a4a2b33", "patch": "@@ -4470,17 +4470,7 @@ impl<'a> Resolver<'a> {\n \n                 PatStruct(ref path, _, _) => {\n                     match self.resolve_path(pat_id, path, TypeNS, false) {\n-                        Some((DefTy(class_id), lp))\n-                                if self.structs.contains_key(&class_id) => {\n-                            let class_def = DefStruct(class_id);\n-                            self.record_def(pattern.id, (class_def, lp));\n-                        }\n-                        Some(definition @ (DefStruct(class_id), _)) => {\n-                            assert!(self.structs.contains_key(&class_id));\n-                            self.record_def(pattern.id, definition);\n-                        }\n-                        Some(definition @ (DefVariant(_, variant_id, _), _))\n-                                if self.structs.contains_key(&variant_id) => {\n+                        Some(definition) => {\n                             self.record_def(pattern.id, definition);\n                         }\n                         result => {\n@@ -5200,17 +5190,11 @@ impl<'a> Resolver<'a> {\n             }\n \n             ExprStruct(ref path, _, _) => {\n-                // Resolve the path to the structure it goes to.\n+                // Resolve the path to the structure it goes to. We don't\n+                // check to ensure that the path is actually a structure; that\n+                // is checked later during typeck.\n                 match self.resolve_path(expr.id, path, TypeNS, false) {\n-                    Some((DefTy(class_id), lp)) | Some((DefStruct(class_id), lp))\n-                            if self.structs.contains_key(&class_id) => {\n-                        let class_def = DefStruct(class_id);\n-                        self.record_def(expr.id, (class_def, lp));\n-                    }\n-                    Some(definition @ (DefVariant(_, class_id, _), _))\n-                            if self.structs.contains_key(&class_id) => {\n-                        self.record_def(expr.id, definition);\n-                    }\n+                    Some(definition) => self.record_def(expr.id, definition),\n                     result => {\n                         debug!(\"(resolving expression) didn't find struct \\\n                                 def: {:?}\", result);"}, {"sha": "11d09aa49cfcd3b7f2a7ae20e169aa8933c57184", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c175ed4425da809d6d28bc509b7dd5301a4a2b33/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c175ed4425da809d6d28bc509b7dd5301a4a2b33/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=c175ed4425da809d6d28bc509b7dd5301a4a2b33", "patch": "@@ -803,12 +803,19 @@ fn any_irrefutable_adt_pat(bcx: &Block, m: &[Match], col: uint) -> bool {\n         let pat = *br.pats.get(col);\n         match pat.node {\n             ast::PatTup(_) => true,\n-            ast::PatEnum(..) | ast::PatIdent(_, _, None) | ast::PatStruct(..) =>\n+            ast::PatStruct(..) => {\n+                match bcx.tcx().def_map.borrow().find(&pat.id) {\n+                    Some(&def::DefVariant(..)) => false,\n+                    _ => true,\n+                }\n+            }\n+            ast::PatEnum(..) | ast::PatIdent(_, _, None) => {\n                 match bcx.tcx().def_map.borrow().find(&pat.id) {\n                     Some(&def::DefFn(..)) |\n                     Some(&def::DefStruct(..)) => true,\n                     _ => false\n-                },\n+                }\n+            }\n             _ => false\n         }\n     })"}, {"sha": "a5e7db1d6fdab70e2cb257ca6a491b6703b612d9", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 25, "deletions": 26, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/c175ed4425da809d6d28bc509b7dd5301a4a2b33/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c175ed4425da809d6d28bc509b7dd5301a4a2b33/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=c175ed4425da809d6d28bc509b7dd5301a4a2b33", "patch": "@@ -362,36 +362,16 @@ pub fn check_struct_pat_fields(pcx: &pat_ctxt,\n     }\n }\n \n-pub fn check_struct_pat(pcx: &pat_ctxt, pat_id: ast::NodeId, span: Span,\n-                        expected: ty::t, path: &ast::Path,\n+pub fn check_struct_pat(pcx: &pat_ctxt, _pat_id: ast::NodeId, span: Span,\n+                        _expected: ty::t, _path: &ast::Path,\n                         fields: &[ast::FieldPat], etc: bool,\n                         struct_id: ast::DefId,\n                         substitutions: &subst::Substs) {\n-    let fcx = pcx.fcx;\n+    let _fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n \n     let class_fields = ty::lookup_struct_fields(tcx, struct_id);\n \n-    // Check to ensure that the struct is the one specified.\n-    match tcx.def_map.borrow().find(&pat_id) {\n-        Some(&def::DefStruct(supplied_def_id))\n-                if supplied_def_id == struct_id => {\n-            // OK.\n-        }\n-        Some(&def::DefStruct(..)) | Some(&def::DefVariant(..)) => {\n-            let name = pprust::path_to_str(path);\n-            tcx.sess\n-               .span_err(span,\n-                         format!(\"mismatched types: expected `{}` but found \\\n-                                  `{}`\",\n-                                 fcx.infcx().ty_to_str(expected),\n-                                 name).as_slice());\n-        }\n-        _ => {\n-            tcx.sess.span_bug(span, \"resolve didn't write in struct ID\");\n-        }\n-    }\n-\n     check_struct_pat_fields(pcx, span, fields, class_fields, struct_id,\n                             substitutions, etc);\n }\n@@ -535,6 +515,21 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n         let mut error_happened = false;\n         match *structure {\n             ty::ty_struct(cid, ref substs) => {\n+                // Verify that the pattern named the right structure.\n+                let item_did = tcx.def_map.borrow().get(&pat.id).def_id();\n+                let struct_did =\n+                    ty::ty_to_def_id(\n+                        ty::lookup_item_type(tcx, item_did).ty).unwrap();\n+                if struct_did != cid {\n+                    tcx.sess\n+                       .span_err(path.span,\n+                                 format!(\"`{}` does not name the \\\n+                                          structure `{}`\",\n+                                         pprust::path_to_str(path),\n+                                         fcx.infcx()\n+                                            .ty_to_str(expected)).as_slice())\n+                }\n+\n                 check_struct_pat(pcx, pat.id, pat.span, expected, path,\n                                  fields.as_slice(), etc, cid, substs);\n             }\n@@ -562,18 +557,22 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n                             \"a structure pattern\".to_string(),\n                             None);\n                 match tcx.def_map.borrow().find(&pat.id) {\n-                    Some(&def::DefStruct(supplied_def_id)) => {\n+                    Some(def) => {\n                          check_struct_pat(pcx,\n                                           pat.id,\n                                           pat.span,\n                                           ty::mk_err(),\n                                           path,\n                                           fields.as_slice(),\n                                           etc,\n-                                          supplied_def_id,\n+                                          def.def_id(),\n                                           &subst::Substs::empty());\n                     }\n-                    _ => () // Error, but we're already in an error case\n+                    None => {\n+                        tcx.sess.span_bug(pat.span,\n+                                          \"whoops, looks like resolve didn't \\\n+                                           write a def in here\")\n+                    }\n                 }\n                 error_happened = true;\n             }"}, {"sha": "973227c7116913147d8d107a3fea5e6b4d6d6482", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c175ed4425da809d6d28bc509b7dd5301a4a2b33/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c175ed4425da809d6d28bc509b7dd5301a4a2b33/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=c175ed4425da809d6d28bc509b7dd5301a4a2b33", "patch": "@@ -3296,17 +3296,34 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         // Resolve the path.\n         let def = tcx.def_map.borrow().find(&id).map(|i| *i);\n         match def {\n-            Some(def::DefStruct(type_def_id)) => {\n-                check_struct_constructor(fcx, id, expr.span, type_def_id,\n-                                         fields.as_slice(), base_expr);\n-            }\n             Some(def::DefVariant(enum_id, variant_id, _)) => {\n                 check_struct_enum_variant(fcx, id, expr.span, enum_id,\n                                           variant_id, fields.as_slice());\n             }\n+            Some(def) => {\n+                // Verify that this was actually a struct.\n+                let typ = ty::lookup_item_type(fcx.ccx.tcx, def.def_id());\n+                match ty::get(typ.ty).sty {\n+                    ty::ty_struct(struct_did, _) => {\n+                        check_struct_constructor(fcx,\n+                                                 id,\n+                                                 expr.span,\n+                                                 struct_did,\n+                                                 fields.as_slice(),\n+                                                 base_expr);\n+                    }\n+                    _ => {\n+                        tcx.sess\n+                           .span_err(path.span,\n+                                     format!(\"`{}` does not name a structure\",\n+                                             pprust::path_to_str(\n+                                                 path)).as_slice())\n+                    }\n+                }\n+            }\n             _ => {\n                 tcx.sess.span_bug(path.span,\n-                                  \"structure constructor does not name a structure type\");\n+                                  \"structure constructor wasn't resolved\")\n             }\n         }\n       }"}, {"sha": "f228ea32ae522ffb6be2c8649c38e09a6a66e898", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c175ed4425da809d6d28bc509b7dd5301a4a2b33/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c175ed4425da809d6d28bc509b7dd5301a4a2b33/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=c175ed4425da809d6d28bc509b7dd5301a4a2b33", "patch": "@@ -16,8 +16,7 @@ use middle::ty::{ReSkolemized, ReVar};\n use middle::ty::{BoundRegion, BrAnon, BrNamed};\n use middle::ty::{BrFresh, ctxt};\n use middle::ty::{mt, t, ParamTy};\n-use middle::ty::{ReFree, ReScope, ReInfer, ReStatic, Region,\n-                 ReEmpty};\n+use middle::ty::{ReFree, ReScope, ReInfer, ReStatic, Region, ReEmpty};\n use middle::ty::{ty_bool, ty_char, ty_bot, ty_box, ty_struct, ty_enum};\n use middle::ty::{ty_err, ty_str, ty_vec, ty_float, ty_bare_fn, ty_closure};\n use middle::ty::{ty_nil, ty_param, ty_ptr, ty_rptr, ty_tup};"}, {"sha": "a0ec7272720dc09da96a8dfe7b0216967cd55909", "filename": "src/test/auxiliary/xcrate_struct_aliases.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c175ed4425da809d6d28bc509b7dd5301a4a2b33/src%2Ftest%2Fauxiliary%2Fxcrate_struct_aliases.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c175ed4425da809d6d28bc509b7dd5301a4a2b33/src%2Ftest%2Fauxiliary%2Fxcrate_struct_aliases.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fxcrate_struct_aliases.rs?ref=c175ed4425da809d6d28bc509b7dd5301a4a2b33", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub struct S {\n+    pub x: int,\n+    pub y: int,\n+}\n+\n+pub type S2 = S;\n+"}, {"sha": "921e331e960dcbf57aa857b2b1b3080eeaabbb7c", "filename": "src/test/compile-fail/issue-14541.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c175ed4425da809d6d28bc509b7dd5301a4a2b33/src%2Ftest%2Fcompile-fail%2Fissue-14541.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c175ed4425da809d6d28bc509b7dd5301a4a2b33/src%2Ftest%2Fcompile-fail%2Fissue-14541.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-14541.rs?ref=c175ed4425da809d6d28bc509b7dd5301a4a2b33", "patch": "@@ -13,8 +13,8 @@ struct vec3 { y: f32, z: f32 }\n \n fn make(v: vec2) {\n     let vec3 { y: _, z: _ } = v;\n-    //~^ ERROR mismatched types: expected `vec2` but found `vec3`\n+    //~^ ERROR `vec3` does not name the structure `vec2`\n     //~^^ ERROR struct `vec2` does not have a field named `z`\n }\n \n-fn main() { }\n\\ No newline at end of file\n+fn main() { }"}, {"sha": "9046cafe7579ac7767ebfc97c4e062f2fd40512a", "filename": "src/test/run-pass/struct-aliases-xcrate.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c175ed4425da809d6d28bc509b7dd5301a4a2b33/src%2Ftest%2Frun-pass%2Fstruct-aliases-xcrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c175ed4425da809d6d28bc509b7dd5301a4a2b33/src%2Ftest%2Frun-pass%2Fstruct-aliases-xcrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstruct-aliases-xcrate.rs?ref=c175ed4425da809d6d28bc509b7dd5301a4a2b33", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:xcrate_struct_aliases.rs\n+extern crate xcrate_struct_aliases;\n+\n+use xcrate_struct_aliases::{S, S2};\n+\n+fn main() {\n+    let s = S2 {\n+        x: 1,\n+        y: 2,\n+    };\n+    match s {\n+        S2 {\n+            x: x,\n+            y: y\n+        } => {\n+            assert_eq!(x, 1);\n+            assert_eq!(y, 2);\n+        }\n+    }\n+}\n+"}, {"sha": "2cf961a5c0c947caaaa7517ef34df4e23e87c865", "filename": "src/test/run-pass/struct-aliases.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/c175ed4425da809d6d28bc509b7dd5301a4a2b33/src%2Ftest%2Frun-pass%2Fstruct-aliases.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c175ed4425da809d6d28bc509b7dd5301a4a2b33/src%2Ftest%2Frun-pass%2Fstruct-aliases.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstruct-aliases.rs?ref=c175ed4425da809d6d28bc509b7dd5301a4a2b33", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct S {\n+    x: int,\n+    y: int,\n+}\n+\n+type S2 = S;\n+\n+fn main() {\n+    let s = S2 {\n+        x: 1,\n+        y: 2,\n+    };\n+    match s {\n+        S2 {\n+            x: x,\n+            y: y\n+        } => {\n+            assert_eq!(x, 1);\n+            assert_eq!(y, 2);\n+        }\n+    }\n+}\n+"}]}