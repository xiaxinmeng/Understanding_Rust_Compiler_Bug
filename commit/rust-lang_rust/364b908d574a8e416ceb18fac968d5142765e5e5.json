{"sha": "364b908d574a8e416ceb18fac968d5142765e5e5", "node_id": "C_kwDOAAsO6NoAKDM2NGI5MDhkNTc0YThlNDE2Y2ViMThmYWM5NjhkNTE0Mjc2NWU1ZTU", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-03-25T01:39:12Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-03-27T23:03:02Z"}, "message": "Remove `Nonterminal::NtTT`.\n\nIt's only needed for macro expansion, not as a general element in the\nAST. This commit removes it, adds `NtOrTt` for the parser and macro\nexpansion cases, and renames the variants in `NamedMatch` to better\nmatch the new type.", "tree": {"sha": "e97808e29c2ad1dca4f3531bfeaf8989ab4b05e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e97808e29c2ad1dca4f3531bfeaf8989ab4b05e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/364b908d574a8e416ceb18fac968d5142765e5e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/364b908d574a8e416ceb18fac968d5142765e5e5", "html_url": "https://github.com/rust-lang/rust/commit/364b908d574a8e416ceb18fac968d5142765e5e5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/364b908d574a8e416ceb18fac968d5142765e5e5/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a0c55046c7092d9e019dad03729e8d32e38df72", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a0c55046c7092d9e019dad03729e8d32e38df72", "html_url": "https://github.com/rust-lang/rust/commit/8a0c55046c7092d9e019dad03729e8d32e38df72"}], "stats": {"total": 107, "additions": 52, "deletions": 55}, "files": [{"sha": "1a271b0adef921d09e340800f8d6a9e21bc7fb26", "filename": "compiler/rustc_ast/src/ast_like.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/364b908d574a8e416ceb18fac968d5142765e5e5/compiler%2Frustc_ast%2Fsrc%2Fast_like.rs", "raw_url": "https://github.com/rust-lang/rust/raw/364b908d574a8e416ceb18fac968d5142765e5e5/compiler%2Frustc_ast%2Fsrc%2Fast_like.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast_like.rs?ref=364b908d574a8e416ceb18fac968d5142765e5e5", "patch": "@@ -51,7 +51,6 @@ impl AstLike for crate::token::Nonterminal {\n             | Nonterminal::NtMeta(_)\n             | Nonterminal::NtPath(_)\n             | Nonterminal::NtVis(_)\n-            | Nonterminal::NtTT(_)\n             | Nonterminal::NtBlock(_)\n             | Nonterminal::NtIdent(..)\n             | Nonterminal::NtLifetime(_) => &[],\n@@ -67,7 +66,6 @@ impl AstLike for crate::token::Nonterminal {\n             | Nonterminal::NtMeta(_)\n             | Nonterminal::NtPath(_)\n             | Nonterminal::NtVis(_)\n-            | Nonterminal::NtTT(_)\n             | Nonterminal::NtBlock(_)\n             | Nonterminal::NtIdent(..)\n             | Nonterminal::NtLifetime(_) => {}\n@@ -84,7 +82,7 @@ impl AstLike for crate::token::Nonterminal {\n             Nonterminal::NtPath(path) => path.tokens_mut(),\n             Nonterminal::NtVis(vis) => vis.tokens_mut(),\n             Nonterminal::NtBlock(block) => block.tokens_mut(),\n-            Nonterminal::NtIdent(..) | Nonterminal::NtLifetime(..) | Nonterminal::NtTT(..) => None,\n+            Nonterminal::NtIdent(..) | Nonterminal::NtLifetime(..) => None,\n         }\n     }\n }"}, {"sha": "32621eb5f2f666773dc17407883adcbf375471b7", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/364b908d574a8e416ceb18fac968d5142765e5e5/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/364b908d574a8e416ceb18fac968d5142765e5e5/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=364b908d574a8e416ceb18fac968d5142765e5e5", "patch": "@@ -787,7 +787,6 @@ pub fn visit_interpolated<T: MutVisitor>(nt: &mut token::Nonterminal, vis: &mut\n             visit_lazy_tts(tokens, vis);\n         }\n         token::NtPath(path) => vis.visit_path(path),\n-        token::NtTT(tt) => visit_tt(tt, vis),\n         token::NtVis(visib) => vis.visit_vis(visib),\n     }\n }"}, {"sha": "7df385873c11639e49441dcef49830623edf7be0", "filename": "compiler/rustc_ast/src/token.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/364b908d574a8e416ceb18fac968d5142765e5e5/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/364b908d574a8e416ceb18fac968d5142765e5e5/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs?ref=364b908d574a8e416ceb18fac968d5142765e5e5", "patch": "@@ -6,7 +6,6 @@ pub use TokenKind::*;\n \n use crate::ast;\n use crate::ptr::P;\n-use crate::tokenstream::TokenTree;\n \n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::Lrc;\n@@ -680,7 +679,6 @@ pub enum Nonterminal {\n     NtMeta(P<ast::AttrItem>),\n     NtPath(ast::Path),\n     NtVis(ast::Visibility),\n-    NtTT(TokenTree),\n }\n \n // `Nonterminal` is used a lot. Make sure it doesn't unintentionally get bigger.\n@@ -778,7 +776,6 @@ impl Nonterminal {\n             NtMeta(attr_item) => attr_item.span(),\n             NtPath(path) => path.span,\n             NtVis(vis) => vis.span,\n-            NtTT(tt) => tt.span(),\n         }\n     }\n }\n@@ -790,7 +787,6 @@ impl PartialEq for Nonterminal {\n                 ident_lhs == ident_rhs && is_raw_lhs == is_raw_rhs\n             }\n             (NtLifetime(ident_lhs), NtLifetime(ident_rhs)) => ident_lhs == ident_rhs,\n-            (NtTT(tt_lhs), NtTT(tt_rhs)) => tt_lhs == tt_rhs,\n             // FIXME: Assume that all \"complex\" nonterminal are not equal, we can't compare them\n             // correctly based on data from AST. This will prevent them from matching each other\n             // in macros. The comparison will become possible only when each nonterminal has an\n@@ -813,7 +809,6 @@ impl fmt::Debug for Nonterminal {\n             NtLiteral(..) => f.pad(\"NtLiteral(..)\"),\n             NtMeta(..) => f.pad(\"NtMeta(..)\"),\n             NtPath(..) => f.pad(\"NtPath(..)\"),\n-            NtTT(..) => f.pad(\"NtTT(..)\"),\n             NtVis(..) => f.pad(\"NtVis(..)\"),\n             NtLifetime(..) => f.pad(\"NtLifetime(..)\"),\n         }"}, {"sha": "719fd2710932185213c279573fa57ec3c98c339d", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/364b908d574a8e416ceb18fac968d5142765e5e5/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/364b908d574a8e416ceb18fac968d5142765e5e5/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=364b908d574a8e416ceb18fac968d5142765e5e5", "patch": "@@ -714,7 +714,6 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n             token::NtIdent(e, is_raw) => IdentPrinter::for_ast_ident(e, is_raw).to_string(),\n             token::NtLifetime(e) => e.to_string(),\n             token::NtLiteral(ref e) => self.expr_to_string(e),\n-            token::NtTT(ref tree) => self.tt_to_string(tree),\n             token::NtVis(ref e) => self.vis_to_string(e),\n         }\n     }"}, {"sha": "a8db96a199d003b2c67ffd3caa570aa0b6c3796d", "filename": "compiler/rustc_expand/src/mbe/macro_parser.rs", "status": "modified", "additions": 17, "deletions": 20, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/364b908d574a8e416ceb18fac968d5142765e5e5/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/364b908d574a8e416ceb18fac968d5142765e5e5/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs?ref=364b908d574a8e416ceb18fac968d5142765e5e5", "patch": "@@ -76,7 +76,7 @@ crate use ParseResult::*;\n use crate::mbe::{self, SequenceRepetition, TokenTree};\n \n use rustc_ast::token::{self, DocComment, Nonterminal, Token};\n-use rustc_parse::parser::Parser;\n+use rustc_parse::parser::{NtOrTt, Parser};\n use rustc_session::parse::ParseSess;\n use rustc_span::symbol::MacroRulesNormalizedIdent;\n \n@@ -275,7 +275,7 @@ pub(super) fn count_names(ms: &[TokenTree]) -> usize {\n }\n \n /// `NamedMatch` is a pattern-match result for a single metavar. All\n-/// `MatchedNtNonTt`s in the `NamedMatch` have the same non-terminal type\n+/// `MatchedNonterminal`s in the `NamedMatch` have the same non-terminal type\n /// (expr, item, etc).\n ///\n /// The in-memory structure of a particular `NamedMatch` represents the match\n@@ -306,32 +306,29 @@ pub(super) fn count_names(ms: &[TokenTree]) -> usize {\n /// ```rust\n /// MatchedSeq([\n ///   MatchedSeq([\n-///     MatchedNtNonTt(a),\n-///     MatchedNtNonTt(b),\n-///     MatchedNtNonTt(c),\n-///     MatchedNtNonTt(d),\n+///     MatchedNonterminal(a),\n+///     MatchedNonterminal(b),\n+///     MatchedNonterminal(c),\n+///     MatchedNonterminal(d),\n ///   ]),\n ///   MatchedSeq([\n-///     MatchedNtNonTt(a),\n-///     MatchedNtNonTt(b),\n-///     MatchedNtNonTt(c),\n-///     MatchedNtNonTt(d),\n-///     MatchedNtNonTt(e),\n+///     MatchedNonterminal(a),\n+///     MatchedNonterminal(b),\n+///     MatchedNonterminal(c),\n+///     MatchedNonterminal(d),\n+///     MatchedNonterminal(e),\n ///   ])\n /// ])\n /// ```\n #[derive(Debug, Clone)]\n crate enum NamedMatch {\n     MatchedSeq(Lrc<NamedMatchVec>),\n \n-    // This variant should never hold an `NtTT`. `MatchedNtTt` should be used\n-    // for that case.\n-    MatchedNtNonTt(Lrc<Nonterminal>),\n+    // A metavar match of type `tt`.\n+    MatchedTokenTree(rustc_ast::tokenstream::TokenTree),\n \n-    // `NtTT` is handled without any cloning when transcribing, unlike other\n-    // nonterminals. Therefore, an `Lrc` isn't helpful and causes unnecessary\n-    // allocations. Hence this separate variant.\n-    MatchedNtTt(rustc_ast::tokenstream::TokenTree),\n+    // A metavar match of any type other than `tt`.\n+    MatchedNonterminal(Lrc<Nonterminal>),\n }\n \n /// Takes a slice of token trees `ms` representing a matcher which successfully matched input\n@@ -677,8 +674,8 @@ impl<'tt> TtParser<'tt> {\n                             Ok(nt) => nt,\n                         };\n                         let m = match nt {\n-                            Nonterminal::NtTT(tt) => MatchedNtTt(tt),\n-                            _ => MatchedNtNonTt(Lrc::new(nt)),\n+                            NtOrTt::Nt(nt) => MatchedNonterminal(Lrc::new(nt)),\n+                            NtOrTt::Tt(tt) => MatchedTokenTree(tt),\n                         };\n                         item.push_match(match_cur, m);\n                         item.idx += 1;"}, {"sha": "10b2b9f07e2a57dc423c392487d9e342c52b2b0c", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/364b908d574a8e416ceb18fac968d5142765e5e5/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/364b908d574a8e416ceb18fac968d5142765e5e5/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=364b908d574a8e416ceb18fac968d5142765e5e5", "patch": "@@ -4,7 +4,7 @@ use crate::expand::{ensure_complete_parse, parse_ast_fragment, AstFragment, AstF\n use crate::mbe;\n use crate::mbe::macro_check;\n use crate::mbe::macro_parser::{Error, ErrorReported, Failure, Success, TtParser};\n-use crate::mbe::macro_parser::{MatchedNtTt, MatchedSeq};\n+use crate::mbe::macro_parser::{MatchedSeq, MatchedTokenTree};\n use crate::mbe::transcribe::transcribe;\n \n use rustc_ast as ast;\n@@ -470,7 +470,7 @@ pub fn compile_declarative_macro(\n         MatchedSeq(ref s) => s\n             .iter()\n             .map(|m| {\n-                if let MatchedNtTt(ref tt) = *m {\n+                if let MatchedTokenTree(ref tt) = *m {\n                     let mut tts = vec![];\n                     mbe::quoted::parse(\n                         tt.clone().into(),\n@@ -495,7 +495,7 @@ pub fn compile_declarative_macro(\n         MatchedSeq(ref s) => s\n             .iter()\n             .map(|m| {\n-                if let MatchedNtTt(ref tt) = *m {\n+                if let MatchedTokenTree(ref tt) = *m {\n                     let mut tts = vec![];\n                     mbe::quoted::parse(\n                         tt.clone().into(),"}, {"sha": "cd016bfd8f4d73b6cfb1ec948298d4ef365db2e0", "filename": "compiler/rustc_expand/src/mbe/transcribe.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/364b908d574a8e416ceb18fac968d5142765e5e5/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/364b908d574a8e416ceb18fac968d5142765e5e5/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs?ref=364b908d574a8e416ceb18fac968d5142765e5e5", "patch": "@@ -1,8 +1,8 @@\n use crate::base::ExtCtxt;\n-use crate::mbe::macro_parser::{MatchedNtNonTt, MatchedNtTt, MatchedSeq, NamedMatch};\n+use crate::mbe::macro_parser::{MatchedNonterminal, MatchedSeq, MatchedTokenTree, NamedMatch};\n use crate::mbe::{self, MetaVarExpr};\n use rustc_ast::mut_visit::{self, MutVisitor};\n-use rustc_ast::token::{self, Nonterminal, Token, TokenKind};\n+use rustc_ast::token::{self, Token, TokenKind};\n use rustc_ast::tokenstream::{DelimSpan, TokenStream, TokenTree, TreeAndSpacing};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n@@ -234,17 +234,16 @@ pub(super) fn transcribe<'a>(\n                 let ident = MacroRulesNormalizedIdent::new(orignal_ident);\n                 if let Some(cur_matched) = lookup_cur_matched(ident, interp, &repeats) {\n                     match cur_matched {\n-                        MatchedNtTt(ref tt) => {\n+                        MatchedTokenTree(ref tt) => {\n                             // `tt`s are emitted into the output stream directly as \"raw tokens\",\n                             // without wrapping them into groups.\n                             let token = tt.clone();\n                             result.push(token.into());\n                         }\n-                        MatchedNtNonTt(ref nt) => {\n+                        MatchedNonterminal(ref nt) => {\n                             // Other variables are emitted into the output stream as groups with\n                             // `Delimiter::None` to maintain parsing priorities.\n                             // `Interpolated` is currently used for such groups in rustc parser.\n-                            debug_assert!(!matches!(**nt, Nonterminal::NtTT(_)));\n                             marker.visit_span(&mut sp);\n                             let token = TokenTree::token(token::Interpolated(nt.clone()), sp);\n                             result.push(token.into());\n@@ -312,7 +311,7 @@ fn lookup_cur_matched<'a>(\n         let mut matched = matched;\n         for &(idx, _) in repeats {\n             match matched {\n-                MatchedNtTt(_) | MatchedNtNonTt(_) => break,\n+                MatchedTokenTree(_) | MatchedNonterminal(_) => break,\n                 MatchedSeq(ref ads) => matched = ads.get(idx).unwrap(),\n             }\n         }\n@@ -402,7 +401,7 @@ fn lockstep_iter_size(\n             let name = MacroRulesNormalizedIdent::new(name);\n             match lookup_cur_matched(name, interpolations, repeats) {\n                 Some(matched) => match matched {\n-                    MatchedNtTt(_) | MatchedNtNonTt(_) => LockstepIterSize::Unconstrained,\n+                    MatchedTokenTree(_) | MatchedNonterminal(_) => LockstepIterSize::Unconstrained,\n                     MatchedSeq(ref ads) => LockstepIterSize::Constraint(ads.len(), name),\n                 },\n                 _ => LockstepIterSize::Unconstrained,\n@@ -449,7 +448,7 @@ fn count_repetitions<'a>(\n         sp: &DelimSpan,\n     ) -> PResult<'a, usize> {\n         match matched {\n-            MatchedNtTt(_) | MatchedNtNonTt(_) => {\n+            MatchedTokenTree(_) | MatchedNonterminal(_) => {\n                 if declared_lhs_depth == 0 {\n                     return Err(cx.struct_span_err(\n                         sp.entire(),"}, {"sha": "a614aed692df2de6dd4374405ff871df4beac177", "filename": "compiler/rustc_parse/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/364b908d574a8e416ceb18fac968d5142765e5e5/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/364b908d574a8e416ceb18fac968d5142765e5e5/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flib.rs?ref=364b908d574a8e416ceb18fac968d5142765e5e5", "patch": "@@ -289,7 +289,6 @@ pub fn nt_to_tokenstream(\n         Nonterminal::NtMeta(ref attr) => convert_tokens(attr.tokens.as_ref()),\n         Nonterminal::NtPath(ref path) => convert_tokens(path.tokens.as_ref()),\n         Nonterminal::NtVis(ref vis) => convert_tokens(vis.tokens.as_ref()),\n-        Nonterminal::NtTT(ref tt) => Some(tt.clone().into()),\n         Nonterminal::NtExpr(ref expr) | Nonterminal::NtLiteral(ref expr) => {\n             prepend_attrs(&expr.attrs, expr.tokens.as_ref())\n         }"}, {"sha": "5d244ef9118a64e61cfce9d79edde016f2f53bf9", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/364b908d574a8e416ceb18fac968d5142765e5e5/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/364b908d574a8e416ceb18fac968d5142765e5e5/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=364b908d574a8e416ceb18fac968d5142765e5e5", "patch": "@@ -19,7 +19,7 @@ pub use pat::{CommaRecoveryMode, RecoverColon, RecoverComma};\n pub use path::PathStyle;\n \n use rustc_ast::ptr::P;\n-use rustc_ast::token::{self, DelimToken, Token, TokenKind};\n+use rustc_ast::token::{self, DelimToken, Nonterminal, Token, TokenKind};\n use rustc_ast::tokenstream::AttributesData;\n use rustc_ast::tokenstream::{self, DelimSpan, Spacing};\n use rustc_ast::tokenstream::{TokenStream, TokenTree};\n@@ -1507,3 +1507,9 @@ pub enum FlatToken {\n     /// handling of replace ranges.\n     Empty,\n }\n+\n+#[derive(Debug)]\n+pub enum NtOrTt {\n+    Nt(Nonterminal),\n+    Tt(TokenTree),\n+}"}, {"sha": "c105fbfaee053a02d2bbe452e16203eb7683d164", "filename": "compiler/rustc_parse/src/parser/nonterminal.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/364b908d574a8e416ceb18fac968d5142765e5e5/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/364b908d574a8e416ceb18fac968d5142765e5e5/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs?ref=364b908d574a8e416ceb18fac968d5142765e5e5", "patch": "@@ -1,12 +1,12 @@\n use rustc_ast::ptr::P;\n-use rustc_ast::token::{self, Nonterminal, NonterminalKind, Token};\n+use rustc_ast::token::{self, NonterminalKind, Token};\n use rustc_ast::AstLike;\n use rustc_ast_pretty::pprust;\n use rustc_errors::PResult;\n use rustc_span::symbol::{kw, Ident};\n \n use crate::parser::pat::{CommaRecoveryMode, RecoverColon, RecoverComma};\n-use crate::parser::{FollowedByType, ForceCollect, Parser, PathStyle};\n+use crate::parser::{FollowedByType, ForceCollect, NtOrTt, Parser, PathStyle};\n \n impl<'a> Parser<'a> {\n     /// Checks whether a non-terminal may begin with a particular token.\n@@ -85,7 +85,7 @@ impl<'a> Parser<'a> {\n             NonterminalKind::Lifetime => match token.kind {\n                 token::Lifetime(_) => true,\n                 token::Interpolated(ref nt) => {\n-                    matches!(**nt, token::NtLifetime(_) | token::NtTT(_))\n+                    matches!(**nt, token::NtLifetime(_))\n                 }\n                 _ => false,\n             },\n@@ -96,14 +96,16 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse a non-terminal (e.g. MBE `:pat` or `:ident`).\n-    pub fn parse_nonterminal(&mut self, kind: NonterminalKind) -> PResult<'a, Nonterminal> {\n+    pub fn parse_nonterminal(&mut self, kind: NonterminalKind) -> PResult<'a, NtOrTt> {\n         // Any `Nonterminal` which stores its tokens (currently `NtItem` and `NtExpr`)\n         // needs to have them force-captured here.\n         // A `macro_rules!` invocation may pass a captured item/expr to a proc-macro,\n         // which requires having captured tokens available. Since we cannot determine\n         // in advance whether or not a proc-macro will be (transitively) invoked,\n         // we always capture tokens for any `Nonterminal` which needs them.\n         let mut nt = match kind {\n+            // Note that TT is treated differently to all the others.\n+            NonterminalKind::TT => return Ok(NtOrTt::Tt(self.parse_token_tree())),\n             NonterminalKind::Item => match self.parse_item(ForceCollect::Yes)? {\n                 Some(item) => token::NtItem(item),\n                 None => {\n@@ -124,9 +126,12 @@ impl<'a> Parser<'a> {\n             NonterminalKind::PatParam { .. } | NonterminalKind::PatWithOr { .. } => {\n                 token::NtPat(self.collect_tokens_no_attrs(|this| match kind {\n                     NonterminalKind::PatParam { .. } => this.parse_pat_no_top_alt(None),\n-                    NonterminalKind::PatWithOr { .. } => {\n-                        this.parse_pat_allow_top_alt(None, RecoverComma::No, RecoverColon::No, CommaRecoveryMode::EitherTupleOrPipe)\n-                    }\n+                    NonterminalKind::PatWithOr { .. } => this.parse_pat_allow_top_alt(\n+                        None,\n+                        RecoverComma::No,\n+                        RecoverColon::No,\n+                        CommaRecoveryMode::EitherTupleOrPipe,\n+                    ),\n                     _ => unreachable!(),\n                 })?)\n             }\n@@ -139,9 +144,10 @@ impl<'a> Parser<'a> {\n                 )\n             }\n \n-            NonterminalKind::Ty => {\n-                token::NtTy(self.collect_tokens_no_attrs(|this| this.parse_no_question_mark_recover())?)\n-            }\n+            NonterminalKind::Ty => token::NtTy(\n+                self.collect_tokens_no_attrs(|this| this.parse_no_question_mark_recover())?,\n+            ),\n+\n             // this could be handled like a token, since it is one\n             NonterminalKind::Ident\n                 if let Some((ident, is_raw)) = get_macro_ident(&self.token) =>\n@@ -158,7 +164,6 @@ impl<'a> Parser<'a> {\n                 self.collect_tokens_no_attrs(|this| this.parse_path(PathStyle::Type))?,\n             ),\n             NonterminalKind::Meta => token::NtMeta(P(self.parse_attr_item(true)?)),\n-            NonterminalKind::TT => token::NtTT(self.parse_token_tree()),\n             NonterminalKind::Vis => token::NtVis(\n                 self.collect_tokens_no_attrs(|this| this.parse_visibility(FollowedByType::Yes))?,\n             ),\n@@ -183,7 +188,7 @@ impl<'a> Parser<'a> {\n             );\n         }\n \n-        Ok(nt)\n+        Ok(NtOrTt::Nt(nt))\n     }\n }\n "}]}