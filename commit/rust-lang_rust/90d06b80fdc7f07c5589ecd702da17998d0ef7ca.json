{"sha": "90d06b80fdc7f07c5589ecd702da17998d0ef7ca", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkwZDA2YjgwZmRjN2YwN2M1NTg5ZWNkNzAyZGExNzk5OGQwZWY3Y2E=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-09-19T05:35:42Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-10-13T03:43:37Z"}, "message": "Make moves explicit in std tests", "tree": {"sha": "74892761df632abb29a469b6192d541b7ac13e37", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/74892761df632abb29a469b6192d541b7ac13e37"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/90d06b80fdc7f07c5589ecd702da17998d0ef7ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/90d06b80fdc7f07c5589ecd702da17998d0ef7ca", "html_url": "https://github.com/rust-lang/rust/commit/90d06b80fdc7f07c5589ecd702da17998d0ef7ca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/90d06b80fdc7f07c5589ecd702da17998d0ef7ca/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "30a62793fa54a413a265591879c9775b798d762c", "url": "https://api.github.com/repos/rust-lang/rust/commits/30a62793fa54a413a265591879c9775b798d762c", "html_url": "https://github.com/rust-lang/rust/commit/30a62793fa54a413a265591879c9775b798d762c"}], "stats": {"total": 194, "additions": 98, "deletions": 96}, "files": [{"sha": "9c793028a52d04b458ec368f573d840a0a3a4c02", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/90d06b80fdc7f07c5589ecd702da17998d0ef7ca/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90d06b80fdc7f07c5589ecd702da17998d0ef7ca/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=90d06b80fdc7f07c5589ecd702da17998d0ef7ca", "patch": "@@ -124,7 +124,7 @@ pub fn mutex_arc_with_condvars<T: Send>(user_data: T,\n                                     num_condvars: uint) -> MutexARC<T> {\n     let data =\n         MutexARCInner { lock: mutex_with_condvars(num_condvars),\n-                          failed: false, data: user_data };\n+                          failed: false, data: move user_data };\n     MutexARC { x: unsafe { shared_mutable_state(move data) } }\n }\n \n@@ -258,7 +258,7 @@ pub fn rw_arc_with_condvars<T: Const Send>(user_data: T,\n                                        num_condvars: uint) -> RWARC<T> {\n     let data =\n         RWARCInner { lock: rwlock_with_condvars(num_condvars),\n-                     failed: false, data: user_data };\n+                     failed: false, data: move user_data };\n     RWARC { x: unsafe { shared_mutable_state(move data) }, cant_nest: () }\n }\n \n@@ -448,7 +448,7 @@ mod tests {\n \n         let (c, p) = pipes::stream();\n \n-        do task::spawn() {\n+        do task::spawn() |move c| {\n             let p = pipes::PortSet();\n             c.send(p.chan());\n \n@@ -471,8 +471,8 @@ mod tests {\n         let arc = ~MutexARC(false);\n         let arc2 = ~arc.clone();\n         let (c,p) = pipes::oneshot();\n-        let (c,p) = (~mut Some(c), ~mut Some(p));\n-        do task::spawn {\n+        let (c,p) = (~mut Some(move c), ~mut Some(move p));\n+        do task::spawn |move arc2, move p| {\n             // wait until parent gets in\n             pipes::recv_one(option::swap_unwrap(p));\n             do arc2.access_cond |state, cond| {\n@@ -494,7 +494,7 @@ mod tests {\n         let arc2 = ~arc.clone();\n         let (c,p) = pipes::stream();\n \n-        do task::spawn_unlinked {\n+        do task::spawn_unlinked |move arc2, move p| {\n             let _ = p.recv();\n             do arc2.access_cond |one, cond| {\n                 cond.signal();\n@@ -513,7 +513,7 @@ mod tests {\n     fn test_mutex_arc_poison() {\n         let arc = ~MutexARC(1);\n         let arc2 = ~arc.clone();\n-        do task::try {\n+        do task::try |move arc2| {\n             do arc2.access |one| {\n                 assert *one == 2;\n             }\n@@ -527,21 +527,21 @@ mod tests {\n         let arc = MutexARC(1);\n         let arc2 = ~(&arc).clone();\n         let (c,p) = pipes::stream();\n-        do task::spawn {\n+        do task::spawn |move c, move arc2| {\n             do arc2.access |one| {\n                 c.send(());\n                 assert *one == 2;\n             }\n         }\n         let _ = p.recv();\n-        let one = unwrap_mutex_arc(arc);\n+        let one = unwrap_mutex_arc(move arc);\n         assert one == 1;\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n     fn test_rw_arc_poison_wr() {\n         let arc = ~RWARC(1);\n         let arc2 = ~arc.clone();\n-        do task::try {\n+        do task::try |move arc2| {\n             do arc2.write |one| {\n                 assert *one == 2;\n             }\n@@ -554,7 +554,7 @@ mod tests {\n     fn test_rw_arc_poison_ww() {\n         let arc = ~RWARC(1);\n         let arc2 = ~arc.clone();\n-        do task::try {\n+        do task::try |move arc2| {\n             do arc2.write |one| {\n                 assert *one == 2;\n             }\n@@ -567,7 +567,7 @@ mod tests {\n     fn test_rw_arc_poison_dw() {\n         let arc = ~RWARC(1);\n         let arc2 = ~arc.clone();\n-        do task::try {\n+        do task::try |move arc2| {\n             do arc2.write_downgrade |write_mode| {\n                 do (&write_mode).write |one| {\n                     assert *one == 2;\n@@ -582,7 +582,7 @@ mod tests {\n     fn test_rw_arc_no_poison_rr() {\n         let arc = ~RWARC(1);\n         let arc2 = ~arc.clone();\n-        do task::try {\n+        do task::try |move arc2| {\n             do arc2.read |one| {\n                 assert *one == 2;\n             }\n@@ -595,7 +595,7 @@ mod tests {\n     fn test_rw_arc_no_poison_rw() {\n         let arc = ~RWARC(1);\n         let arc2 = ~arc.clone();\n-        do task::try {\n+        do task::try |move arc2| {\n             do arc2.read |one| {\n                 assert *one == 2;\n             }\n@@ -608,9 +608,9 @@ mod tests {\n     fn test_rw_arc_no_poison_dr() {\n         let arc = ~RWARC(1);\n         let arc2 = ~arc.clone();\n-        do task::try {\n+        do task::try |move arc2| {\n             do arc2.write_downgrade |write_mode| {\n-                let read_mode = arc2.downgrade(write_mode);\n+                let read_mode = arc2.downgrade(move write_mode);\n                 do (&read_mode).read |one| {\n                     assert *one == 2;\n                 }\n@@ -626,7 +626,7 @@ mod tests {\n         let arc2 = ~arc.clone();\n         let (c,p) = pipes::stream();\n \n-        do task::spawn {\n+        do task::spawn |move arc2, move c| {\n             do arc2.write |num| {\n                 for 10.times {\n                     let tmp = *num;\n@@ -642,7 +642,8 @@ mod tests {\n         let mut children = ~[];\n         for 5.times {\n             let arc3 = ~arc.clone();\n-            do task::task().future_result(|+r| children.push(r)).spawn {\n+            do task::task().future_result(|+r| children.push(move r)).spawn\n+                |move arc3| {\n                 do arc3.read |num| {\n                     assert *num >= 0;\n                 }\n@@ -670,9 +671,9 @@ mod tests {\n         let mut reader_convos = ~[];\n         for 10.times {\n             let ((rc1,rp1),(rc2,rp2)) = (pipes::stream(),pipes::stream());\n-            reader_convos.push((rc1,rp2));\n+            reader_convos.push((move rc1, move rp2));\n             let arcn = ~arc.clone();\n-            do task::spawn {\n+            do task::spawn |move rp1, move rc2, move arcn| {\n                 rp1.recv(); // wait for downgrader to give go-ahead\n                 do arcn.read |state| {\n                     assert *state == 31337;\n@@ -684,7 +685,7 @@ mod tests {\n         // Writer task\n         let arc2 = ~arc.clone();\n         let ((wc1,wp1),(wc2,wp2)) = (pipes::stream(),pipes::stream());\n-        do task::spawn {\n+        do task::spawn |move arc2, move wc2, move wp1| {\n             wp1.recv();\n             do arc2.write_cond |state, cond| {\n                 assert *state == 0;\n@@ -717,7 +718,7 @@ mod tests {\n                     }\n                 }\n             }\n-            let read_mode = arc.downgrade(write_mode);\n+            let read_mode = arc.downgrade(move write_mode);\n             do (&read_mode).read |state| {\n                 // complete handshake with other readers\n                 for vec::each(reader_convos) |x| {"}, {"sha": "2b8e9b6bbd9642361ade00ab4aab602ed1e00bc8", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/90d06b80fdc7f07c5589ecd702da17998d0ef7ca/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90d06b80fdc7f07c5589ecd702da17998d0ef7ca/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=90d06b80fdc7f07c5589ecd702da17998d0ef7ca", "patch": "@@ -96,7 +96,7 @@ struct BigBitv {\n }\n \n fn BigBitv(storage: ~[mut uint]) -> BigBitv {\n-    BigBitv {storage: storage}\n+    BigBitv {storage: move storage}\n }\n \n /**\n@@ -223,7 +223,7 @@ pub fn Bitv (nbits: uint, init: bool) -> Bitv {\n         let s = to_mut(from_elem(nelems, elem));\n         Big(~BigBitv(move s))\n     };\n-    Bitv {rep: rep, nbits: nbits}\n+    Bitv {rep: move rep, nbits: nbits}\n }\n \n priv impl Bitv {\n@@ -301,7 +301,7 @@ impl Bitv {\n             let st = to_mut(from_elem(self.nbits / uint_bits + 1, 0));\n             let len = st.len();\n             for uint::range(0, len) |i| { st[i] = b.storage[i]; };\n-            Bitv{nbits: self.nbits, rep: Big(~BigBitv{storage: st})}\n+            Bitv{nbits: self.nbits, rep: Big(~BigBitv{storage: move st})}\n           }\n         }\n     }"}, {"sha": "4f79bf2b31698a8886d1125937f80ea33c96bc47", "filename": "src/libstd/cell.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90d06b80fdc7f07c5589ecd702da17998d0ef7ca/src%2Flibstd%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90d06b80fdc7f07c5589ecd702da17998d0ef7ca/src%2Flibstd%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcell.rs?ref=90d06b80fdc7f07c5589ecd702da17998d0ef7ca", "patch": "@@ -57,7 +57,7 @@ fn test_basic() {\n     let value = value_cell.take();\n     assert value == ~10;\n     assert value_cell.is_empty();\n-    value_cell.put_back(value);\n+    value_cell.put_back(move value);\n     assert !value_cell.is_empty();\n }\n "}, {"sha": "e604b87b2afdabc49eaaaee0cb229fa6a179890e", "filename": "src/libstd/comm.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/90d06b80fdc7f07c5589ecd702da17998d0ef7ca/src%2Flibstd%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90d06b80fdc7f07c5589ecd702da17998d0ef7ca/src%2Flibstd%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm.rs?ref=90d06b80fdc7f07c5589ecd702da17998d0ef7ca", "patch": "@@ -52,12 +52,12 @@ pub fn DuplexStream<T: Send, U: Send>()\n     let (c2, p1) = pipes::stream();\n     let (c1, p2) = pipes::stream();\n     (DuplexStream {\n-        chan: c1,\n-        port: p1\n+        chan: move c1,\n+        port: move p1\n     },\n      DuplexStream {\n-         chan: c2,\n-         port: p2\n+         chan: move c2,\n+         port: move p2\n      })\n }\n "}, {"sha": "0d3391c1867c243fc5dda9f46ebd4f2b51d79858", "filename": "src/libstd/json.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/90d06b80fdc7f07c5589ecd702da17998d0ef7ca/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90d06b80fdc7f07c5589ecd702da17998d0ef7ca/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=90d06b80fdc7f07c5589ecd702da17998d0ef7ca", "patch": "@@ -329,8 +329,8 @@ pub fn Parser(rdr: io::Reader) -> Parser {\n     Parser {\n         rdr: rdr,\n         ch: rdr.read_char(),\n-        line: 1u,\n-        col: 1u,\n+        line: 1,\n+        col: 1,\n     }\n }\n \n@@ -342,7 +342,7 @@ pub impl Parser {\n             self.parse_whitespace();\n             // Make sure there is no trailing characters.\n             if self.eof() {\n-                Ok(value)\n+                Ok(move value)\n             } else {\n                 self.error(~\"trailing characters\")\n             }\n@@ -610,12 +610,12 @@ priv impl Parser {\n \n         if self.ch == ']' {\n             self.bump();\n-            return Ok(List(values));\n+            return Ok(List(move values));\n         }\n \n         loop {\n             match move self.parse_value() {\n-              Ok(move v) => values.push(v),\n+              Ok(move v) => values.push(move v),\n               Err(move e) => return Err(e)\n             }\n \n@@ -626,7 +626,7 @@ priv impl Parser {\n \n             match self.ch {\n               ',' => self.bump(),\n-              ']' => { self.bump(); return Ok(List(values)); }\n+              ']' => { self.bump(); return Ok(List(move values)); }\n               _ => return self.error(~\"expected `,` or `]`\")\n             }\n         };\n@@ -640,7 +640,7 @@ priv impl Parser {\n \n         if self.ch == '}' {\n           self.bump();\n-          return Ok(Object(values));\n+          return Ok(Object(move values));\n         }\n \n         while !self.eof() {\n@@ -664,14 +664,14 @@ priv impl Parser {\n             self.bump();\n \n             match move self.parse_value() {\n-              Ok(move value) => { values.insert(key, value); }\n+              Ok(move value) => { values.insert(key, move value); }\n               Err(move e) => return Err(e)\n             }\n             self.parse_whitespace();\n \n             match self.ch {\n               ',' => self.bump(),\n-              '}' => { self.bump(); return Ok(Object(values)); }\n+              '}' => { self.bump(); return Ok(Object(move values)); }\n               _ => {\n                   if self.eof() { break; }\n                   return self.error(~\"expected `,` or `}`\");\n@@ -703,7 +703,7 @@ pub struct Deserializer {\n pub fn Deserializer(rdr: io::Reader) -> Result<Deserializer, Error> {\n     match move from_reader(rdr) {\n         Ok(move json) => {\n-            let des = Deserializer { json: json, stack: ~[] };\n+            let des = Deserializer { json: move json, stack: ~[] };\n             Ok(move des)\n         }\n         Err(move e) => Err(e)\n@@ -819,7 +819,7 @@ pub impl Deserializer: serialization::Deserializer {\n         };\n         let res = f(len);\n         self.pop();\n-        res\n+        move res\n     }\n \n     fn read_managed_vec<T>(&self, f: fn(uint) -> T) -> T {\n@@ -830,7 +830,7 @@ pub impl Deserializer: serialization::Deserializer {\n         };\n         let res = f(len);\n         self.pop();\n-        res\n+        move res\n     }\n \n     fn read_vec_elt<T>(&self, idx: uint, f: fn() -> T) -> T {\n@@ -851,14 +851,14 @@ pub impl Deserializer: serialization::Deserializer {\n         debug!(\"read_rec()\");\n         let value = f();\n         self.pop();\n-        value\n+        move value\n     }\n \n     fn read_struct<T>(&self, _name: &str, f: fn() -> T) -> T {\n         debug!(\"read_struct()\");\n         let value = f();\n         self.pop();\n-        value\n+        move value\n     }\n \n     fn read_field<T>(&self, name: &str, idx: uint, f: fn() -> T) -> T {\n@@ -891,7 +891,7 @@ pub impl Deserializer: serialization::Deserializer {\n         debug!(\"read_tup(len=%u)\", len);\n         let value = f();\n         self.pop();\n-        value\n+        move value\n     }\n \n     fn read_tup_elt<T>(&self, idx: uint, f: fn() -> T) -> T {\n@@ -1183,11 +1183,11 @@ mod tests {\n \n         for items.each |item| {\n             match *item {\n-                (copy key, copy value) => { d.insert(key, value); },\n+                (copy key, copy value) => { d.insert(key, move value); },\n             }\n         };\n \n-        Object(d)\n+        Object(move d)\n     }\n \n     #[test]"}, {"sha": "cf5323c498b73227ba7128450f338e9fc2c5c6c2", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/90d06b80fdc7f07c5589ecd702da17998d0ef7ca/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90d06b80fdc7f07c5589ecd702da17998d0ef7ca/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=90d06b80fdc7f07c5589ecd702da17998d0ef7ca", "patch": "@@ -128,7 +128,7 @@ pub mod v4 {\n      */\n     pub fn parse_addr(ip: &str) -> IpAddr {\n         match try_parse_addr(ip) {\n-          result::Ok(copy addr) => addr,\n+          result::Ok(move addr) => move addr,\n           result::Err(ref err_data) => fail err_data.err_msg\n         }\n     }\n@@ -214,7 +214,7 @@ pub mod v6 {\n      */\n     pub fn parse_addr(ip: &str) -> IpAddr {\n         match try_parse_addr(ip) {\n-          result::Ok(copy addr) => addr,\n+          result::Ok(move addr) => move addr,\n           result::Err(copy err_data) => fail err_data.err_msg\n         }\n     }\n@@ -353,7 +353,7 @@ mod test {\n         }\n         // note really sure how to realiably test/assert\n         // this.. mostly just wanting to see it work, atm.\n-        let results = result::unwrap(ga_result);\n+        let results = result::unwrap(move ga_result);\n         log(debug, fmt!(\"test_get_addr: Number of results for %s: %?\",\n                         localhost_name, vec::len(results)));\n         for vec::each(results) |r| {\n@@ -366,7 +366,7 @@ mod test {\n         }\n         // at least one result.. this is going to vary from system\n         // to system, based on stuff like the contents of /etc/hosts\n-        assert vec::len(results) > 0;\n+        assert !results.is_empty();\n     }\n     #[test]\n     #[ignore(reason = \"valgrind says it's leaky\")]"}, {"sha": "db5c1328e62b259dd84d2a90842a4aeab3871527", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/90d06b80fdc7f07c5589ecd702da17998d0ef7ca/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90d06b80fdc7f07c5589ecd702da17998d0ef7ca/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=90d06b80fdc7f07c5589ecd702da17998d0ef7ca", "patch": "@@ -562,7 +562,8 @@ pub fn listen(host_ip: ip::IpAddr, port: uint, backlog: uint,\n           new_connect_cb: fn~(TcpNewConnection,\n                                comm::Chan<Option<TcpErrData>>))\n     -> result::Result<(), TcpListenErrData> unsafe {\n-    do listen_common(move host_ip, port, backlog, iotask, on_establish_cb)\n+    do listen_common(move host_ip, port, backlog, iotask,\n+                     move on_establish_cb)\n         // on_connect_cb\n         |move new_connect_cb, handle| unsafe {\n             let server_data_ptr = uv::ll::get_data_for_uv_handle(handle)"}, {"sha": "0b00da9f81d7bca9cda13ffc9e6bae7a013565df", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90d06b80fdc7f07c5589ecd702da17998d0ef7ca/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90d06b80fdc7f07c5589ecd702da17998d0ef7ca/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=90d06b80fdc7f07c5589ecd702da17998d0ef7ca", "patch": "@@ -250,7 +250,7 @@ mod test_qsort {\n \n         sort::quick_sort(|x, y| { int::le(*x, *y) }, names);\n \n-        let immut_names = vec::from_mut(names);\n+        let immut_names = vec::from_mut(move names);\n \n         let pairs = vec::zip(expected, immut_names);\n         for vec::each(pairs) |p| {"}, {"sha": "73fc78a091a4fd89e8ca7d022628f6581f96d165", "filename": "src/libstd/sync.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/90d06b80fdc7f07c5589ecd702da17998d0ef7ca/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90d06b80fdc7f07c5589ecd702da17998d0ef7ca/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=90d06b80fdc7f07c5589ecd702da17998d0ef7ca", "patch": "@@ -25,7 +25,7 @@ struct Waitqueue { head: pipes::Port<SignalEnd>,\n \n fn new_waitqueue() -> Waitqueue {\n     let (block_tail, block_head) = pipes::stream();\n-    Waitqueue { head: block_head, tail: block_tail }\n+    Waitqueue { head: move block_head, tail: move block_tail }\n }\n \n // Signals one live task from the queue.\n@@ -71,7 +71,7 @@ enum Sem<Q: Send> = Exclusive<SemInner<Q>>;\n #[doc(hidden)]\n fn new_sem<Q: Send>(count: int, q: Q) -> Sem<Q> {\n     Sem(exclusive(SemInner {\n-        mut count: count, waiters: new_waitqueue(), blocked: q }))\n+        mut count: count, waiters: new_waitqueue(), blocked: move q }))\n }\n #[doc(hidden)]\n fn new_sem_and_signal(count: int, num_condvars: uint)\n@@ -686,7 +686,7 @@ mod tests {\n     fn test_sem_as_mutex() {\n         let s = ~semaphore(1);\n         let s2 = ~s.clone();\n-        do task::spawn {\n+        do task::spawn |move s2| {\n             do s2.access {\n                 for 5.times { task::yield(); }\n             }\n@@ -701,7 +701,7 @@ mod tests {\n         let (c,p) = pipes::stream();\n         let s = ~semaphore(0);\n         let s2 = ~s.clone();\n-        do task::spawn {\n+        do task::spawn |move s2, move c| {\n             s2.acquire();\n             c.send(());\n         }\n@@ -713,7 +713,7 @@ mod tests {\n         let (c,p) = pipes::stream();\n         let s = ~semaphore(0);\n         let s2 = ~s.clone();\n-        do task::spawn {\n+        do task::spawn |move s2, move p| {\n             for 5.times { task::yield(); }\n             s2.release();\n             let _ = p.recv();\n@@ -729,7 +729,7 @@ mod tests {\n         let s2 = ~s.clone();\n         let (c1,p1) = pipes::stream();\n         let (c2,p2) = pipes::stream();\n-        do task::spawn {\n+        do task::spawn |move s2, move c1, move p2| {\n             do s2.access {\n                 let _ = p2.recv();\n                 c1.send(());\n@@ -748,10 +748,10 @@ mod tests {\n             let s = ~semaphore(1);\n             let s2 = ~s.clone();\n             let (c,p) = pipes::stream();\n-            let child_data = ~mut Some((s2,c));\n+            let child_data = ~mut Some((move s2, move c));\n             do s.access {\n                 let (s2,c) = option::swap_unwrap(child_data);\n-                do task::spawn {\n+                do task::spawn |move c, move s2| {\n                     c.send(());\n                     do s2.access { }\n                     c.send(());\n@@ -774,7 +774,7 @@ mod tests {\n         let m2 = ~m.clone();\n         let mut sharedstate = ~0;\n         let ptr = ptr::addr_of(&(*sharedstate));\n-        do task::spawn {\n+        do task::spawn |move m2, move c| {\n             let sharedstate: &mut int =\n                 unsafe { cast::reinterpret_cast(&ptr) };\n             access_shared(sharedstate, m2, 10);\n@@ -803,7 +803,7 @@ mod tests {\n         // Child wakes up parent\n         do m.lock_cond |cond| {\n             let m2 = ~m.clone();\n-            do task::spawn {\n+            do task::spawn |move m2| {\n                 do m2.lock_cond |cond| {\n                     let woken = cond.signal();\n                     assert woken;\n@@ -814,7 +814,7 @@ mod tests {\n         // Parent wakes up child\n         let (chan,port) = pipes::stream();\n         let m3 = ~m.clone();\n-        do task::spawn {\n+        do task::spawn |move chan, move m3| {\n             do m3.lock_cond |cond| {\n                 chan.send(());\n                 cond.wait();\n@@ -836,8 +836,8 @@ mod tests {\n         for num_waiters.times {\n             let mi = ~m.clone();\n             let (chan, port) = pipes::stream();\n-            ports.push(port);\n-            do task::spawn {\n+            ports.push(move port);\n+            do task::spawn |move chan, move mi| {\n                 do mi.lock_cond |cond| {\n                     chan.send(());\n                     cond.wait();\n@@ -867,7 +867,7 @@ mod tests {\n     fn test_mutex_cond_no_waiter() {\n         let m = ~Mutex();\n         let m2 = ~m.clone();\n-        do task::try {\n+        do task::try |move m| {\n             do m.lock_cond |_x| { }\n         };\n         do m2.lock_cond |cond| {\n@@ -880,7 +880,7 @@ mod tests {\n         let m = ~Mutex();\n         let m2 = ~m.clone();\n \n-        let result: result::Result<(),()> = do task::try {\n+        let result: result::Result<(),()> = do task::try |move m2| {\n             do m2.lock {\n                 fail;\n             }\n@@ -896,9 +896,9 @@ mod tests {\n         let m = ~Mutex();\n         let m2 = ~m.clone();\n \n-        let result: result::Result<(),()> = do task::try {\n+        let result: result::Result<(),()> = do task::try |move m2| {\n             let (c,p) = pipes::stream();\n-            do task::spawn { // linked\n+            do task::spawn |move p| { // linked\n                 let _ = p.recv(); // wait for sibling to get in the mutex\n                 task::yield();\n                 fail;\n@@ -921,19 +921,19 @@ mod tests {\n         let m2 = ~m.clone();\n         let (c,p) = pipes::stream();\n \n-        let result: result::Result<(),()> = do task::try {\n+        let result: result::Result<(),()> = do task::try |move c, move m2| {\n             let mut sibling_convos = ~[];\n             for 2.times {\n                 let (c,p) = pipes::stream();\n-                let c = ~mut Some(c);\n-                sibling_convos.push(p);\n+                let c = ~mut Some(move c);\n+                sibling_convos.push(move p);\n                 let mi = ~m2.clone();\n                 // spawn sibling task\n-                do task::spawn { // linked\n+                do task::spawn |move mi, move c| { // linked\n                     do mi.lock_cond |cond| {\n                         let c = option::swap_unwrap(c);\n                         c.send(()); // tell sibling to go ahead\n-                        let _z = SendOnFailure(c);\n+                        let _z = SendOnFailure(move c);\n                         cond.wait(); // block forever\n                     }\n                 }\n@@ -942,7 +942,7 @@ mod tests {\n                 let _ = p.recv(); // wait for sibling to get in the mutex\n             }\n             do m2.lock { }\n-            c.send(sibling_convos); // let parent wait on all children\n+            c.send(move sibling_convos); // let parent wait on all children\n             fail;\n         };\n         assert result.is_err();\n@@ -959,7 +959,7 @@ mod tests {\n \n         fn SendOnFailure(c: pipes::Chan<()>) -> SendOnFailure {\n             SendOnFailure {\n-                c: c\n+                c: move c\n             }\n         }\n     }\n@@ -969,7 +969,7 @@ mod tests {\n         let m = ~Mutex();\n         do m.lock_cond |cond| {\n             let m2 = ~m.clone();\n-            do task::spawn {\n+            do task::spawn |move m2| {\n                 do m2.lock_cond |cond| {\n                     cond.signal_on(0);\n                 }\n@@ -983,7 +983,7 @@ mod tests {\n             let m = ~mutex_with_condvars(2);\n             let m2 = ~m.clone();\n             let (c,p) = pipes::stream();\n-            do task::spawn {\n+            do task::spawn |move m2, move c| {\n                 do m2.lock_cond |cond| {\n                     c.send(());\n                     cond.wait_on(1);\n@@ -1032,7 +1032,7 @@ mod tests {\n                 },\n             DowngradeRead =>\n                 do x.write_downgrade |mode| {\n-                    let mode = x.downgrade(mode);\n+                    let mode = x.downgrade(move mode);\n                     (&mode).read(blk);\n                 },\n         }\n@@ -1046,7 +1046,7 @@ mod tests {\n         let x2 = ~x.clone();\n         let mut sharedstate = ~0;\n         let ptr = ptr::addr_of(&(*sharedstate));\n-        do task::spawn {\n+        do task::spawn |move c, move x2| {\n             let sharedstate: &mut int =\n                 unsafe { cast::reinterpret_cast(&ptr) };\n             access_shared(sharedstate, x2, mode1, 10);\n@@ -1089,7 +1089,7 @@ mod tests {\n         let x2 = ~x.clone();\n         let (c1,p1) = pipes::stream();\n         let (c2,p2) = pipes::stream();\n-        do task::spawn {\n+        do task::spawn |move c1, move x2, move p2| {\n             if !make_mode2_go_first {\n                 let _ = p2.recv(); // parent sends to us once it locks, or ...\n             }\n@@ -1126,10 +1126,10 @@ mod tests {\n         // Tests that downgrade can unlock the lock in both modes\n         let x = ~RWlock();\n         do lock_rwlock_in_mode(x, Downgrade) { }\n-        test_rwlock_handshake(x, Read, Read, false);\n+        test_rwlock_handshake(move x, Read, Read, false);\n         let y = ~RWlock();\n         do lock_rwlock_in_mode(y, DowngradeRead) { }\n-        test_rwlock_exclusion(y, Write, Write);\n+        test_rwlock_exclusion(move y, Write, Write);\n     }\n     #[test]\n     fn test_rwlock_read_recursive() {\n@@ -1144,7 +1144,7 @@ mod tests {\n         // Child wakes up parent\n         do x.write_cond |cond| {\n             let x2 = ~x.clone();\n-            do task::spawn {\n+            do task::spawn |move x2| {\n                 do x2.write_cond |cond| {\n                     let woken = cond.signal();\n                     assert woken;\n@@ -1155,7 +1155,7 @@ mod tests {\n         // Parent wakes up child\n         let (chan,port) = pipes::stream();\n         let x3 = ~x.clone();\n-        do task::spawn {\n+        do task::spawn |move x3, move chan| {\n             do x3.write_cond |cond| {\n                 chan.send(());\n                 cond.wait();\n@@ -1190,8 +1190,8 @@ mod tests {\n         for num_waiters.times {\n             let xi = ~x.clone();\n             let (chan, port) = pipes::stream();\n-            ports.push(port);\n-            do task::spawn {\n+            ports.push(move port);\n+            do task::spawn |move chan, move xi| {\n                 do lock_cond(xi, dg1) |cond| {\n                     chan.send(());\n                     cond.wait();\n@@ -1226,7 +1226,7 @@ mod tests {\n         let x = ~RWlock();\n         let x2 = ~x.clone();\n \n-        let result: result::Result<(),()> = do task::try {\n+        let result: result::Result<(),()> = do task::try |move x2| {\n             do lock_rwlock_in_mode(x2, mode1) {\n                 fail;\n             }\n@@ -1264,7 +1264,7 @@ mod tests {\n         let x = ~RWlock();\n         let y = ~RWlock();\n         do x.write_downgrade |xwrite| {\n-            let mut xopt = Some(xwrite);\n+            let mut xopt = Some(move xwrite);\n             do y.write_downgrade |_ywrite| {\n                 y.downgrade(option::swap_unwrap(&mut xopt));\n                 error!(\"oops, y.downgrade(x) should have failed!\");"}, {"sha": "ca83dbf17ed135893d48a5f454fa9d5000572faf", "filename": "src/libstd/test.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/90d06b80fdc7f07c5589ecd702da17998d0ef7ca/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90d06b80fdc7f07c5589ecd702da17998d0ef7ca/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=90d06b80fdc7f07c5589ecd702da17998d0ef7ca", "patch": "@@ -130,7 +130,7 @@ pub fn run_tests_console(opts: &TestOpts,\n                 st.failed += 1u;\n                 write_failed(st.out, st.use_color);\n                 st.out.write_line(~\"\");\n-                st.failures.push(test);\n+                st.failures.push(move test);\n               }\n               TrIgnored => {\n                 st.ignored += 1u;\n@@ -249,7 +249,7 @@ fn should_sort_failures_before_printing_them() {\n               mut passed: 0u,\n               mut failed: 0u,\n               mut ignored: 0u,\n-              mut failures: ~[test_b, test_a]};\n+              mut failures: ~[move test_b, move test_a]};\n \n         print_failures(st);\n     };\n@@ -534,9 +534,9 @@ mod tests {\n             for vec::each(names) |name| {\n                 let test = {name: *name, testfn: copy testfn, ignore: false,\n                             should_fail: false};\n-                tests.push(test);\n+                tests.push(move test);\n             }\n-            tests\n+            move tests\n         };\n         let filtered = filter_tests(&opts, tests);\n \n@@ -549,7 +549,7 @@ mod tests {\n               ~\"test::parse_ignored_flag\",\n               ~\"test::sort_tests\"];\n \n-        let pairs = vec::zip(expected, filtered);\n+        let pairs = vec::zip(expected, move filtered);\n \n         for vec::each(pairs) |p| {\n             match *p {"}, {"sha": "199fba4591444cb7f5dc99274219962a69d43578", "filename": "src/libstd/timer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90d06b80fdc7f07c5589ecd702da17998d0ef7ca/src%2Flibstd%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90d06b80fdc7f07c5589ecd702da17998d0ef7ca/src%2Flibstd%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftimer.rs?ref=90d06b80fdc7f07c5589ecd702da17998d0ef7ca", "patch": "@@ -55,7 +55,7 @@ pub fn delayed_send<T: Send>(iotask: IoTask,\n             // delayed_send_cb has been processed by libuv\n             core::comm::recv(timer_done_po);\n             // notify the caller immediately\n-            core::comm::send(ch, copy(val));\n+            core::comm::send(ch, move(val));\n             // uv_close for this timer has been processed\n             core::comm::recv(timer_done_po);\n     };"}]}