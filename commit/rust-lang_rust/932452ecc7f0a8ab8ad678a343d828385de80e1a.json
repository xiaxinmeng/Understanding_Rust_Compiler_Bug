{"sha": "932452ecc7f0a8ab8ad678a343d828385de80e1a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzMjQ1MmVjYzdmMGE4YWI4YWQ2NzhhMzQzZDgyODM4NWRlODBlMWE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-10T10:25:03Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-04T13:25:20Z"}, "message": "separate out the liveness constraints from the final value\n\nIt will be useful later for diagnostics to be able to remember where\nthings were live.", "tree": {"sha": "f4dbd89ca9ee10708fa2a32a15b860ad870e9bc1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f4dbd89ca9ee10708fa2a32a15b860ad870e9bc1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/932452ecc7f0a8ab8ad678a343d828385de80e1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/932452ecc7f0a8ab8ad678a343d828385de80e1a", "html_url": "https://github.com/rust-lang/rust/commit/932452ecc7f0a8ab8ad678a343d828385de80e1a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/932452ecc7f0a8ab8ad678a343d828385de80e1a/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c16f480fa6eb6b28f51c7218347bcaf1377dedea", "url": "https://api.github.com/repos/rust-lang/rust/commits/c16f480fa6eb6b28f51c7218347bcaf1377dedea", "html_url": "https://github.com/rust-lang/rust/commit/c16f480fa6eb6b28f51c7218347bcaf1377dedea"}], "stats": {"total": 81, "additions": 47, "deletions": 34}, "files": [{"sha": "78b6a9eb6bc7bb8c259c04b23dc9af5fed8dff06", "filename": "src/librustc_mir/transform/nll/region_infer.rs", "status": "modified", "additions": 47, "deletions": 34, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/932452ecc7f0a8ab8ad678a343d828385de80e1a/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fregion_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/932452ecc7f0a8ab8ad678a343d828385de80e1a/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fregion_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fregion_infer.rs?ref=932452ecc7f0a8ab8ad678a343d828385de80e1a", "patch": "@@ -28,6 +28,16 @@ pub struct RegionInferenceContext<'tcx> {\n     /// from as well as its final inferred value.\n     definitions: IndexVec<RegionVid, RegionDefinition<'tcx>>,\n \n+    /// The liveness constraints added to each region. For most\n+    /// regions, these start out empty and steadily grow, though for\n+    /// each free region R they start out containing the entire CFG\n+    /// and `end(R)`.\n+    liveness_constraints: IndexVec<RegionVid, Region>,\n+\n+    /// The final inferred values of the inference variables; `None`\n+    /// until `solve` is invoked.\n+    inferred_values: Option<IndexVec<RegionVid, Region>>,\n+\n     /// The constraints we have accumulated and used during solving.\n     constraints: Vec<Constraint>,\n }\n@@ -46,11 +56,6 @@ struct RegionDefinition<'tcx> {\n     /// If true, this is a constant region which cannot grow larger.\n     /// This is used for named regions as well as `'static`.\n     constant: bool,\n-\n-    /// The current value of this inference variable. This starts out\n-    /// empty, but grows as we add constraints. The final value is\n-    /// determined when `solve()` is executed.\n-    value: Region,\n }\n \n /// The value of an individual region variable. Region variables\n@@ -115,6 +120,8 @@ impl<'a, 'gcx, 'tcx> RegionInferenceContext<'tcx> {\n     /// of those will be constant regions representing the free\n     /// regions defined in `free_regions`.\n     pub fn new(var_origins: VarOrigins, free_regions: &FreeRegions<'tcx>, mir: &Mir<'tcx>) -> Self {\n+        let num_region_variables = var_origins.len();\n+\n         // Create a RegionDefinition for each inference variable.\n         let definitions = var_origins\n             .into_iter()\n@@ -123,6 +130,8 @@ impl<'a, 'gcx, 'tcx> RegionInferenceContext<'tcx> {\n \n         let mut result = Self {\n             definitions: definitions,\n+            liveness_constraints: IndexVec::from_elem_n(Region::default(), num_region_variables),\n+            inferred_values: None,\n             constraints: Vec::new(),\n         };\n \n@@ -170,24 +179,23 @@ impl<'a, 'gcx, 'tcx> RegionInferenceContext<'tcx> {\n \n             // Add all nodes in the CFG to `definition.value`.\n             for (block, block_data) in mir.basic_blocks().iter_enumerated() {\n-                let definition = &mut self.definitions[variable];\n+                let liveness_constraint = &mut self.liveness_constraints[variable];\n                 for statement_index in 0..block_data.statements.len() + 1 {\n                     let location = Location {\n                         block,\n                         statement_index,\n                     };\n-                    definition.value.add_point(location);\n+                    liveness_constraint.add_point(location);\n                 }\n             }\n \n             // Add `end(X)` into the set for X.\n-            self.definitions[variable].value.add_free_region(variable);\n+            self.liveness_constraints[variable].add_free_region(variable);\n \n             // `'static` outlives all other free regions as well.\n             if let ty::ReStatic = free_region {\n                 for &other_variable in indices.values() {\n-                    self.definitions[variable]\n-                        .value\n+                    self.liveness_constraints[variable]\n                         .add_free_region(other_variable);\n                 }\n             }\n@@ -196,16 +204,14 @@ impl<'a, 'gcx, 'tcx> RegionInferenceContext<'tcx> {\n             // Y: X is true). Add `end(X)` into the set for `Y`.\n             for superregion in free_region_map.regions_that_outlive(&free_region) {\n                 let superregion_index = indices[superregion];\n-                self.definitions[superregion_index]\n-                    .value\n-                    .add_free_region(variable);\n+                self.liveness_constraints[superregion_index].add_free_region(variable);\n             }\n \n             debug!(\n                 \"init_free_regions: region variable for `{:?}` is `{:?}` with value `{:?}`\",\n                 free_region,\n                 variable,\n-                self.definitions[variable].value\n+                self.liveness_constraints[variable],\n             );\n         }\n     }\n@@ -219,25 +225,25 @@ impl<'a, 'gcx, 'tcx> RegionInferenceContext<'tcx> {\n     ///\n     /// Until `solve()` executes, this value is not particularly meaningful.\n     pub fn region_contains_point(&self, r: RegionVid, p: Location) -> bool {\n-        self.definitions[r].value.contains_point(p)\n+        let inferred_values = self.inferred_values\n+            .as_ref()\n+            .expect(\"region values not yet inferred\");\n+        inferred_values[r].contains_point(p)\n     }\n \n     /// Returns access to the value of `r` for debugging purposes.\n     pub(super) fn region_value(&self, r: RegionVid) -> &fmt::Debug {\n-        &self.definitions[r].value\n+        let inferred_values = self.inferred_values\n+            .as_ref()\n+            .expect(\"region values not yet inferred\");\n+        &inferred_values[r]\n     }\n \n     /// Indicates that the region variable `v` is live at the point `point`.\n     pub(super) fn add_live_point(&mut self, v: RegionVid, point: Location) {\n         debug!(\"add_live_point({:?}, {:?})\", v, point);\n-        let definition = &mut self.definitions[v];\n-        if !definition.constant {\n-            definition.value.add_point(point);\n-        } else {\n-            // Constants are used for free regions, which already\n-            // contain all the points in the control-flow graph.\n-            assert!(definition.value.contains_point(point));\n-        }\n+        assert!(self.inferred_values.is_none(), \"values already inferred\");\n+        self.liveness_constraints[v].add_point(point);\n     }\n \n     /// Indicates that the region variable `sup` must outlive `sub` is live at the point `point`.\n@@ -249,6 +255,7 @@ impl<'a, 'gcx, 'tcx> RegionInferenceContext<'tcx> {\n         point: Location,\n     ) {\n         debug!(\"add_outlives({:?}: {:?} @ {:?}\", sup, sub, point);\n+        assert!(self.inferred_values.is_none(), \"values already inferred\");\n         self.constraints.push(Constraint {\n             span,\n             sup,\n@@ -259,6 +266,7 @@ impl<'a, 'gcx, 'tcx> RegionInferenceContext<'tcx> {\n \n     /// Perform region inference.\n     pub(super) fn solve(&mut self, infcx: &InferCtxt<'a, 'gcx, 'tcx>, mir: &Mir<'tcx>) {\n+        assert!(self.inferred_values.is_none(), \"values already inferred\");\n         let errors = self.propagate_constraints(mir);\n \n         // worst error msg ever\n@@ -291,39 +299,43 @@ impl<'a, 'gcx, 'tcx> RegionInferenceContext<'tcx> {\n             constraints\n         });\n \n+        // The initial values for each region are derived from the liveness\n+        // constraints we have accumulated.\n+        let mut inferred_values = self.liveness_constraints.clone();\n+\n         while changed {\n             changed = false;\n             for constraint in &self.constraints {\n                 debug!(\"propagate_constraints: constraint={:?}\", constraint);\n-                let sub = &self.definitions[constraint.sub].value.clone();\n-                let sup_def = &mut self.definitions[constraint.sup];\n+                let sub = &inferred_values[constraint.sub].clone();\n+                let sup_value = &mut inferred_values[constraint.sup];\n \n                 debug!(\"propagate_constraints:    sub (before): {:?}\", sub);\n-                debug!(\"propagate_constraints:    sup (before): {:?}\", sup_def.value);\n+                debug!(\"propagate_constraints:    sup (before): {:?}\", sup_value);\n \n-                if !sup_def.constant {\n+                if !self.definitions[constraint.sup].constant {\n                     // If this is not a constant, then grow the value as needed to\n                     // accommodate the outlives constraint.\n \n-                    if dfs.copy(sub, &mut sup_def.value, constraint.point) {\n+                    if dfs.copy(sub, sup_value, constraint.point) {\n                         changed = true;\n                     }\n \n-                    debug!(\"propagate_constraints:    sup (after) : {:?}\", sup_def.value);\n+                    debug!(\"propagate_constraints:    sup (after) : {:?}\", sup_value);\n                     debug!(\"propagate_constraints:    changed     : {:?}\", changed);\n                 } else {\n                     // If this is a constant, check whether it *would\n                     // have* to grow in order for the constraint to be\n                     // satisfied. If so, create an error.\n \n-                    let mut sup_value = sup_def.value.clone();\n-                    if dfs.copy(sub, &mut sup_value, constraint.point) {\n+                    let sup_value = &mut sup_value.clone();\n+                    if dfs.copy(sub, sup_value, constraint.point) {\n                         // Constant values start out with the entire\n                         // CFG, so it must be some new free region\n                         // that was added. Find one.\n                         let &new_region = sup_value\n                             .free_regions\n-                            .difference(&sup_def.value.free_regions)\n+                            .difference(&sup_value.free_regions)\n                             .next()\n                             .unwrap();\n                         debug!(\"propagate_constraints:    new_region : {:?}\", new_region);\n@@ -335,6 +347,8 @@ impl<'a, 'gcx, 'tcx> RegionInferenceContext<'tcx> {\n             }\n             debug!(\"\\n\");\n         }\n+\n+        self.inferred_values = Some(inferred_values);\n         errors\n     }\n }\n@@ -424,7 +438,6 @@ impl<'tcx> RegionDefinition<'tcx> {\n             origin,\n             name: None,\n             constant: false,\n-            value: Region::default(),\n         }\n     }\n }"}]}