{"sha": "72b6f7049c0903ac266dc67510b655441528bdf2", "node_id": "C_kwDOAAsO6NoAKDcyYjZmNzA0OWMwOTAzYWMyNjZkYzY3NTEwYjY1NTQ0MTUyOGJkZjI", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-11-29T21:59:13Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-12-07T20:21:57Z"}, "message": "Use collect_in_band_defs for async lifetime captures.", "tree": {"sha": "2e279cbfe09db3ef2bca713d8b0426b7e05b637b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2e279cbfe09db3ef2bca713d8b0426b7e05b637b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/72b6f7049c0903ac266dc67510b655441528bdf2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/72b6f7049c0903ac266dc67510b655441528bdf2", "html_url": "https://github.com/rust-lang/rust/commit/72b6f7049c0903ac266dc67510b655441528bdf2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/72b6f7049c0903ac266dc67510b655441528bdf2/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e7ec0c5b4b961a9260e72613b7d5477f09d7187", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e7ec0c5b4b961a9260e72613b7d5477f09d7187", "html_url": "https://github.com/rust-lang/rust/commit/6e7ec0c5b4b961a9260e72613b7d5477f09d7187"}], "stats": {"total": 109, "additions": 55, "deletions": 54}, "files": [{"sha": "667e94656f60086c456a1f9999d6c592282bbaf0", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 44, "deletions": 54, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/72b6f7049c0903ac266dc67510b655441528bdf2/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72b6f7049c0903ac266dc67510b655441528bdf2/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=72b6f7049c0903ac266dc67510b655441528bdf2", "patch": "@@ -648,15 +648,13 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         &mut self,\n         f: impl FnOnce(&mut Self) -> T,\n     ) -> (Vec<(Span, ParamName)>, T) {\n-        assert!(!self.is_collecting_in_band_lifetimes);\n-        assert!(self.lifetimes_to_define.is_empty());\n-        self.is_collecting_in_band_lifetimes = true;\n+        let was_collecting = std::mem::replace(&mut self.is_collecting_in_band_lifetimes, true);\n+        let len = self.lifetimes_to_define.len();\n \n         let res = f(self);\n \n-        self.is_collecting_in_band_lifetimes = false;\n-\n-        let lifetimes_to_define = std::mem::take(&mut self.lifetimes_to_define);\n+        let lifetimes_to_define = self.lifetimes_to_define.split_off(len);\n+        self.is_collecting_in_band_lifetimes = was_collecting;\n         (lifetimes_to_define, res)\n     }\n \n@@ -1688,18 +1686,29 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // this is because the elided lifetimes from the return type\n         // should be figured out using the ordinary elision rules, and\n         // this desugaring achieves that.\n+\n+        debug!(\"lower_async_fn_ret_ty: in_scope_lifetimes={:#?}\", self.in_scope_lifetimes);\n+        debug!(\"lower_async_fn_ret_ty: lifetimes_to_define={:#?}\", self.lifetimes_to_define);\n+\n+        // Calculate all the lifetimes that should be captured\n+        // by the opaque type. This should include all in-scope\n+        // lifetime parameters, including those defined in-band.\n         //\n-        // The variable `input_lifetimes_count` tracks the number of\n-        // lifetime parameters to the opaque type *not counting* those\n-        // lifetimes elided in the return type. This includes those\n-        // that are explicitly declared (`in_scope_lifetimes`) and\n-        // those elided lifetimes we found in the arguments (current\n-        // content of `lifetimes_to_define`). Next, we will process\n-        // the return type, which will cause `lifetimes_to_define` to\n-        // grow.\n-        let input_lifetimes_count = self.in_scope_lifetimes.len() + self.lifetimes_to_define.len();\n-\n-        let mut lifetime_params = Vec::new();\n+        // `lifetime_params` is a vector of tuple (span, parameter name, lifetime name).\n+\n+        // Input lifetime like `'a` or `'1`:\n+        let mut lifetime_params: Vec<_> = self\n+            .in_scope_lifetimes\n+            .iter()\n+            .cloned()\n+            .map(|name| (name.ident().span, name, hir::LifetimeName::Param(name)))\n+            .chain(\n+                self.lifetimes_to_define\n+                    .iter()\n+                    .map(|&(span, name)| (span, name, hir::LifetimeName::Param(name))),\n+            )\n+            .collect();\n+\n         self.with_hir_id_owner(opaque_ty_node_id, |this| {\n             // We have to be careful to get elision right here. The\n             // idea is that we create a lifetime parameter for each\n@@ -1709,34 +1718,26 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             //\n             // Then, we will create `fn foo(..) -> Foo<'_, '_>`, and\n             // hence the elision takes place at the fn site.\n-            let future_bound = this\n-                .with_anonymous_lifetime_mode(AnonymousLifetimeMode::CreateParameter, |this| {\n-                    this.lower_async_fn_output_type_to_future_bound(output, fn_def_id, span)\n+            let (lifetimes_to_define, future_bound) =\n+                this.with_anonymous_lifetime_mode(AnonymousLifetimeMode::CreateParameter, |this| {\n+                    this.collect_in_band_defs(|this| {\n+                        this.lower_async_fn_output_type_to_future_bound(output, fn_def_id, span)\n+                    })\n                 });\n-\n             debug!(\"lower_async_fn_ret_ty: future_bound={:#?}\", future_bound);\n+            debug!(\"lower_async_fn_ret_ty: lifetimes_to_define={:#?}\", lifetimes_to_define);\n \n-            // Calculate all the lifetimes that should be captured\n-            // by the opaque type. This should include all in-scope\n-            // lifetime parameters, including those defined in-band.\n-            //\n-            // Note: this must be done after lowering the output type,\n-            // as the output type may introduce new in-band lifetimes.\n-            lifetime_params = this\n-                .in_scope_lifetimes\n-                .iter()\n-                .cloned()\n-                .map(|name| (name.ident().span, name))\n-                .chain(this.lifetimes_to_define.iter().cloned())\n-                .collect();\n-\n-            debug!(\"lower_async_fn_ret_ty: in_scope_lifetimes={:#?}\", this.in_scope_lifetimes);\n-            debug!(\"lower_async_fn_ret_ty: lifetimes_to_define={:#?}\", this.lifetimes_to_define);\n+            lifetime_params.extend(\n+                // Output lifetime like `'_`:\n+                lifetimes_to_define\n+                    .into_iter()\n+                    .map(|(span, name)| (span, name, hir::LifetimeName::Implicit(false))),\n+            );\n             debug!(\"lower_async_fn_ret_ty: lifetime_params={:#?}\", lifetime_params);\n \n             let generic_params =\n-                this.arena.alloc_from_iter(lifetime_params.iter().map(|(span, hir_name)| {\n-                    this.lifetime_to_generic_param(*span, *hir_name, opaque_ty_def_id)\n+                this.arena.alloc_from_iter(lifetime_params.iter().map(|&(span, hir_name, _)| {\n+                    this.lifetime_to_generic_param(span, hir_name, opaque_ty_def_id)\n                 }));\n \n             let opaque_ty_item = hir::OpaqueTy {\n@@ -1770,25 +1771,14 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         //\n         // For the \"output\" lifetime parameters, we just want to\n         // generate `'_`.\n-        let mut generic_args = Vec::with_capacity(lifetime_params.len());\n-        generic_args.extend(lifetime_params[..input_lifetimes_count].iter().map(\n-            |&(span, hir_name)| {\n-                // Input lifetime like `'a` or `'1`:\n+        let generic_args =\n+            self.arena.alloc_from_iter(lifetime_params.into_iter().map(|(span, _, name)| {\n                 GenericArg::Lifetime(hir::Lifetime {\n                     hir_id: self.next_id(),\n                     span: self.lower_span(span),\n-                    name: hir::LifetimeName::Param(hir_name),\n+                    name,\n                 })\n-            },\n-        ));\n-        generic_args.extend(lifetime_params[input_lifetimes_count..].iter().map(|&(span, _)|\n-            // Output lifetime like `'_`.\n-            GenericArg::Lifetime(hir::Lifetime {\n-                hir_id: self.next_id(),\n-                span: self.lower_span(span),\n-                name: hir::LifetimeName::Implicit(false),\n-            })));\n-        let generic_args = self.arena.alloc_from_iter(generic_args);\n+            }));\n \n         // Create the `Foo<...>` reference itself. Note that the `type\n         // Foo = impl Trait` is, internally, created as a child of the"}, {"sha": "90ab0c01f5450f086ad569fdb911eecaf721284c", "filename": "src/test/ui/async-await/generics-and-bounds.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/72b6f7049c0903ac266dc67510b655441528bdf2/src%2Ftest%2Fui%2Fasync-await%2Fgenerics-and-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72b6f7049c0903ac266dc67510b655441528bdf2/src%2Ftest%2Fui%2Fasync-await%2Fgenerics-and-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fgenerics-and-bounds.rs?ref=72b6f7049c0903ac266dc67510b655441528bdf2", "patch": "@@ -2,6 +2,8 @@\n // edition:2018\n // compile-flags: --crate-type lib\n \n+#![feature(in_band_lifetimes)]\n+\n use std::future::Future;\n \n pub async fn simple_generic<T>() {}\n@@ -71,6 +73,10 @@ pub fn call_with_ref_block<'a>(f: &'a (impl Foo + 'a)) -> impl Future<Output = (\n     async move { f.foo() }\n }\n \n+pub fn call_with_ref_block_in_band(f: &'a (impl Foo + 'a)) -> impl Future<Output = ()> + 'a {\n+    async move { f.foo() }\n+}\n+\n pub fn async_block_with_same_generic_params_unifies() {\n     let mut a = call_generic_bound_block(FooType);\n     a = call_generic_bound_block(FooType);\n@@ -85,4 +91,9 @@ pub fn async_block_with_same_generic_params_unifies() {\n     let f_two = FooType;\n     let mut d = call_with_ref_block(&f_one);\n     d = call_with_ref_block(&f_two);\n+\n+    let f_one = FooType;\n+    let f_two = FooType;\n+    let mut d = call_with_ref_block_in_band(&f_one);\n+    d = call_with_ref_block_in_band(&f_two);\n }"}]}