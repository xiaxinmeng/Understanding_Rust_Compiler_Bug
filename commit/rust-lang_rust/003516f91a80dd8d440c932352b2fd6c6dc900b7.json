{"sha": "003516f91a80dd8d440c932352b2fd6c6dc900b7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwMzUxNmY5MWE4MGRkOGQ0NDBjOTMyMzUyYjJmZDZjNmRjOTAwYjc=", "commit": {"author": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-10-17T15:00:59Z"}, "committer": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-10-18T11:13:23Z"}, "message": "BTreeMap: split off most code of remove and split_off", "tree": {"sha": "569ca587a2032c90d67a6a3d35a92febd6b84713", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/569ca587a2032c90d67a6a3d35a92febd6b84713"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/003516f91a80dd8d440c932352b2fd6c6dc900b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/003516f91a80dd8d440c932352b2fd6c6dc900b7", "html_url": "https://github.com/rust-lang/rust/commit/003516f91a80dd8d440c932352b2fd6c6dc900b7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/003516f91a80dd8d440c932352b2fd6c6dc900b7/comments", "author": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c38ddb8040edce1b05bc09a0e8439472e9f67623", "url": "https://api.github.com/repos/rust-lang/rust/commits/c38ddb8040edce1b05bc09a0e8439472e9f67623", "html_url": "https://github.com/rust-lang/rust/commit/c38ddb8040edce1b05bc09a0e8439472e9f67623"}], "stats": {"total": 461, "additions": 239, "deletions": 222}, "files": [{"sha": "20c6ebd22928bb59c52d2af5056585ea4158117f", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 1, "deletions": 222, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/003516f91a80dd8d440c932352b2fd6c6dc900b7/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/003516f91a80dd8d440c932352b2fd6c6dc900b7/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=003516f91a80dd8d440c932352b2fd6c6dc900b7", "patch": "@@ -13,8 +13,6 @@ use super::node::{self, marker, ForceResult::*, Handle, NodeRef};\n use super::search::{self, SearchResult::*};\n use super::unwrap_unchecked;\n \n-use UnderflowResult::*;\n-\n mod entry;\n pub use entry::{Entry, OccupiedEntry, VacantEntry};\n use Entry::*;\n@@ -1154,40 +1152,8 @@ impl<K: Ord, V> BTreeMap<K, V> {\n \n         let mut right = Self::new();\n         let right_root = Self::ensure_is_owned(&mut right.root);\n-        for _ in 0..left_root.height() {\n-            right_root.push_internal_level();\n-        }\n-\n-        {\n-            let mut left_node = left_root.node_as_mut();\n-            let mut right_node = right_root.node_as_mut();\n-\n-            loop {\n-                let mut split_edge = match search::search_node(left_node, key) {\n-                    // key is going to the right tree\n-                    Found(handle) => handle.left_edge(),\n-                    GoDown(handle) => handle,\n-                };\n \n-                split_edge.move_suffix(&mut right_node);\n-\n-                match (split_edge.force(), right_node.force()) {\n-                    (Internal(edge), Internal(node)) => {\n-                        left_node = edge.descend();\n-                        right_node = node.first_edge().descend();\n-                    }\n-                    (Leaf(_), Leaf(_)) => {\n-                        break;\n-                    }\n-                    _ => {\n-                        unreachable!();\n-                    }\n-                }\n-            }\n-        }\n-\n-        left_root.fix_right_border();\n-        right_root.fix_left_border();\n+        left_root.split_off(right_root, key);\n \n         if left_root.height() < right_root.height() {\n             self.length = left_root.node_as_ref().calc_length();\n@@ -2250,193 +2216,6 @@ impl<K, V> BTreeMap<K, V> {\n     }\n }\n \n-impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::KV> {\n-    /// Removes a key/value-pair from the map, and returns that pair, as well as\n-    /// the leaf edge corresponding to that former pair.\n-    fn remove_kv_tracking<F: FnOnce()>(\n-        self,\n-        handle_emptied_internal_root: F,\n-    ) -> ((K, V), Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>) {\n-        let (old_kv, mut pos, was_internal) = match self.force() {\n-            Leaf(leaf) => {\n-                let (old_kv, pos) = leaf.remove();\n-                (old_kv, pos, false)\n-            }\n-            Internal(mut internal) => {\n-                // Replace the location freed in the internal node with an\n-                // adjacent KV, and remove that adjacent KV from its leaf.\n-                // Always choose the adjacent KV on the left side because\n-                // it is typically faster to pop an element from the end\n-                // of the KV arrays without needing to shift other elements.\n-\n-                let key_loc = internal.kv_mut().0 as *mut K;\n-                let val_loc = internal.kv_mut().1 as *mut V;\n-\n-                let to_remove = internal.left_edge().descend().last_leaf_edge().left_kv().ok();\n-                let to_remove = unsafe { unwrap_unchecked(to_remove) };\n-\n-                let (kv, pos) = to_remove.remove();\n-\n-                let old_key = unsafe { mem::replace(&mut *key_loc, kv.0) };\n-                let old_val = unsafe { mem::replace(&mut *val_loc, kv.1) };\n-\n-                ((old_key, old_val), pos, true)\n-            }\n-        };\n-\n-        // Handle underflow\n-        let mut cur_node = unsafe { ptr::read(&pos).into_node().forget_type() };\n-        let mut at_leaf = true;\n-        while cur_node.len() < node::MIN_LEN {\n-            match handle_underfull_node(cur_node) {\n-                AtRoot => break,\n-                Merged(edge, merged_with_left, offset) => {\n-                    // If we merged with our right sibling then our tracked\n-                    // position has not changed. However if we merged with our\n-                    // left sibling then our tracked position is now dangling.\n-                    if at_leaf && merged_with_left {\n-                        let idx = pos.idx() + offset;\n-                        let node = match unsafe { ptr::read(&edge).descend().force() } {\n-                            Leaf(leaf) => leaf,\n-                            Internal(_) => unreachable!(),\n-                        };\n-                        pos = unsafe { Handle::new_edge(node, idx) };\n-                    }\n-\n-                    let parent = edge.into_node();\n-                    if parent.len() == 0 {\n-                        // The parent that was just emptied must be the root,\n-                        // because nodes on a lower level would not have been\n-                        // left with a single child.\n-                        handle_emptied_internal_root();\n-                        break;\n-                    } else {\n-                        cur_node = parent.forget_type();\n-                        at_leaf = false;\n-                    }\n-                }\n-                Stole(stole_from_left) => {\n-                    // Adjust the tracked position if we stole from a left sibling\n-                    if stole_from_left && at_leaf {\n-                        // SAFETY: This is safe since we just added an element to our node.\n-                        unsafe {\n-                            pos.move_next_unchecked();\n-                        }\n-                    }\n-                    break;\n-                }\n-            }\n-        }\n-\n-        // If we deleted from an internal node then we need to compensate for\n-        // the earlier swap and adjust the tracked position to point to the\n-        // next element.\n-        if was_internal {\n-            pos = unsafe { unwrap_unchecked(pos.next_kv().ok()).next_leaf_edge() };\n-        }\n-\n-        (old_kv, pos)\n-    }\n-}\n-\n-impl<K, V> node::Root<K, V> {\n-    /// Removes empty levels on the top, but keep an empty leaf if the entire tree is empty.\n-    fn fix_top(&mut self) {\n-        while self.height() > 0 && self.node_as_ref().len() == 0 {\n-            self.pop_internal_level();\n-        }\n-    }\n-\n-    fn fix_right_border(&mut self) {\n-        self.fix_top();\n-\n-        {\n-            let mut cur_node = self.node_as_mut();\n-\n-            while let Internal(node) = cur_node.force() {\n-                let mut last_kv = node.last_kv();\n-\n-                if last_kv.can_merge() {\n-                    cur_node = last_kv.merge().descend();\n-                } else {\n-                    let right_len = last_kv.reborrow().right_edge().descend().len();\n-                    // `MINLEN + 1` to avoid readjust if merge happens on the next level.\n-                    if right_len < node::MIN_LEN + 1 {\n-                        last_kv.bulk_steal_left(node::MIN_LEN + 1 - right_len);\n-                    }\n-                    cur_node = last_kv.right_edge().descend();\n-                }\n-            }\n-        }\n-\n-        self.fix_top();\n-    }\n-\n-    /// The symmetric clone of `fix_right_border`.\n-    fn fix_left_border(&mut self) {\n-        self.fix_top();\n-\n-        {\n-            let mut cur_node = self.node_as_mut();\n-\n-            while let Internal(node) = cur_node.force() {\n-                let mut first_kv = node.first_kv();\n-\n-                if first_kv.can_merge() {\n-                    cur_node = first_kv.merge().descend();\n-                } else {\n-                    let left_len = first_kv.reborrow().left_edge().descend().len();\n-                    if left_len < node::MIN_LEN + 1 {\n-                        first_kv.bulk_steal_right(node::MIN_LEN + 1 - left_len);\n-                    }\n-                    cur_node = first_kv.left_edge().descend();\n-                }\n-            }\n-        }\n-\n-        self.fix_top();\n-    }\n-}\n-\n-enum UnderflowResult<'a, K, V> {\n-    AtRoot,\n-    Merged(Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::Edge>, bool, usize),\n-    Stole(bool),\n-}\n-\n-fn handle_underfull_node<'a, K: 'a, V: 'a>(\n-    node: NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>,\n-) -> UnderflowResult<'_, K, V> {\n-    let parent = match node.ascend() {\n-        Ok(parent) => parent,\n-        Err(_) => return AtRoot,\n-    };\n-\n-    // Prefer the left KV if it exists. Merging with the left side is faster,\n-    // since merging happens towards the left and `node` has fewer elements.\n-    // Stealing from the left side is faster, since we can pop from the end of\n-    // the KV arrays.\n-    let (is_left, mut handle) = match parent.left_kv() {\n-        Ok(left) => (true, left),\n-        Err(parent) => {\n-            let right = unsafe { unwrap_unchecked(parent.right_kv().ok()) };\n-            (false, right)\n-        }\n-    };\n-\n-    if handle.can_merge() {\n-        let offset = if is_left { handle.reborrow().left_edge().descend().len() + 1 } else { 0 };\n-        Merged(handle.merge(), is_left, offset)\n-    } else {\n-        if is_left {\n-            handle.steal_left();\n-        } else {\n-            handle.steal_right();\n-        }\n-        Stole(is_left)\n-    }\n-}\n-\n impl<K: Ord, V, I: Iterator<Item = (K, V)>> Iterator for MergeIter<K, V, I> {\n     type Item = (K, V);\n "}, {"sha": "bcc50ed56158710cbff6af424d33d0eecef3639f", "filename": "library/alloc/src/collections/btree/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/003516f91a80dd8d440c932352b2fd6c6dc900b7/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/003516f91a80dd8d440c932352b2fd6c6dc900b7/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmod.rs?ref=003516f91a80dd8d440c932352b2fd6c6dc900b7", "patch": "@@ -2,8 +2,10 @@ mod borrow;\n pub mod map;\n mod navigate;\n mod node;\n+mod remove;\n mod search;\n pub mod set;\n+mod split;\n \n #[doc(hidden)]\n trait Recover<Q: ?Sized> {"}, {"sha": "9733b7d608425eff05919461b9d7a8720b50fd83", "filename": "library/alloc/src/collections/btree/remove.rs", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/003516f91a80dd8d440c932352b2fd6c6dc900b7/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fremove.rs", "raw_url": "https://github.com/rust-lang/rust/raw/003516f91a80dd8d440c932352b2fd6c6dc900b7/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fremove.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fremove.rs?ref=003516f91a80dd8d440c932352b2fd6c6dc900b7", "patch": "@@ -0,0 +1,132 @@\n+use super::node::{self, marker, ForceResult, Handle, NodeRef};\n+use super::unwrap_unchecked;\n+use core::mem;\n+use core::ptr;\n+\n+impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::KV> {\n+    /// Removes a key/value-pair from the map, and returns that pair, as well as\n+    /// the leaf edge corresponding to that former pair.\n+    pub fn remove_kv_tracking<F: FnOnce()>(\n+        self,\n+        handle_emptied_internal_root: F,\n+    ) -> ((K, V), Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>) {\n+        let (old_kv, mut pos, was_internal) = match self.force() {\n+            ForceResult::Leaf(leaf) => {\n+                let (old_kv, pos) = leaf.remove();\n+                (old_kv, pos, false)\n+            }\n+            ForceResult::Internal(mut internal) => {\n+                // Replace the location freed in the internal node with an\n+                // adjacent KV, and remove that adjacent KV from its leaf.\n+                // Always choose the adjacent KV on the left side because\n+                // it is typically faster to pop an element from the end\n+                // of the KV arrays without needing to shift other elements.\n+\n+                let key_loc = internal.kv_mut().0 as *mut K;\n+                let val_loc = internal.kv_mut().1 as *mut V;\n+\n+                let to_remove = internal.left_edge().descend().last_leaf_edge().left_kv().ok();\n+                let to_remove = unsafe { unwrap_unchecked(to_remove) };\n+\n+                let (kv, pos) = to_remove.remove();\n+\n+                let old_key = unsafe { mem::replace(&mut *key_loc, kv.0) };\n+                let old_val = unsafe { mem::replace(&mut *val_loc, kv.1) };\n+\n+                ((old_key, old_val), pos, true)\n+            }\n+        };\n+\n+        // Handle underflow\n+        let mut cur_node = unsafe { ptr::read(&pos).into_node().forget_type() };\n+        let mut at_leaf = true;\n+        while cur_node.len() < node::MIN_LEN {\n+            match handle_underfull_node(cur_node) {\n+                UnderflowResult::AtRoot => break,\n+                UnderflowResult::Merged(edge, merged_with_left, offset) => {\n+                    // If we merged with our right sibling then our tracked\n+                    // position has not changed. However if we merged with our\n+                    // left sibling then our tracked position is now dangling.\n+                    if at_leaf && merged_with_left {\n+                        let idx = pos.idx() + offset;\n+                        let node = match unsafe { ptr::read(&edge).descend().force() } {\n+                            ForceResult::Leaf(leaf) => leaf,\n+                            ForceResult::Internal(_) => unreachable!(),\n+                        };\n+                        pos = unsafe { Handle::new_edge(node, idx) };\n+                    }\n+\n+                    let parent = edge.into_node();\n+                    if parent.len() == 0 {\n+                        // The parent that was just emptied must be the root,\n+                        // because nodes on a lower level would not have been\n+                        // left with a single child.\n+                        handle_emptied_internal_root();\n+                        break;\n+                    } else {\n+                        cur_node = parent.forget_type();\n+                        at_leaf = false;\n+                    }\n+                }\n+                UnderflowResult::Stole(stole_from_left) => {\n+                    // Adjust the tracked position if we stole from a left sibling\n+                    if stole_from_left && at_leaf {\n+                        // SAFETY: This is safe since we just added an element to our node.\n+                        unsafe {\n+                            pos.move_next_unchecked();\n+                        }\n+                    }\n+                    break;\n+                }\n+            }\n+        }\n+\n+        // If we deleted from an internal node then we need to compensate for\n+        // the earlier swap and adjust the tracked position to point to the\n+        // next element.\n+        if was_internal {\n+            pos = unsafe { unwrap_unchecked(pos.next_kv().ok()).next_leaf_edge() };\n+        }\n+\n+        (old_kv, pos)\n+    }\n+}\n+\n+enum UnderflowResult<'a, K, V> {\n+    AtRoot,\n+    Merged(Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::Edge>, bool, usize),\n+    Stole(bool),\n+}\n+\n+fn handle_underfull_node<'a, K: 'a, V: 'a>(\n+    node: NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>,\n+) -> UnderflowResult<'_, K, V> {\n+    let parent = match node.ascend() {\n+        Ok(parent) => parent,\n+        Err(_) => return UnderflowResult::AtRoot,\n+    };\n+\n+    // Prefer the left KV if it exists. Merging with the left side is faster,\n+    // since merging happens towards the left and `node` has fewer elements.\n+    // Stealing from the left side is faster, since we can pop from the end of\n+    // the KV arrays.\n+    let (is_left, mut handle) = match parent.left_kv() {\n+        Ok(left) => (true, left),\n+        Err(parent) => {\n+            let right = unsafe { unwrap_unchecked(parent.right_kv().ok()) };\n+            (false, right)\n+        }\n+    };\n+\n+    if handle.can_merge() {\n+        let offset = if is_left { handle.reborrow().left_edge().descend().len() + 1 } else { 0 };\n+        UnderflowResult::Merged(handle.merge(), is_left, offset)\n+    } else {\n+        if is_left {\n+            handle.steal_left();\n+        } else {\n+            handle.steal_right();\n+        }\n+        UnderflowResult::Stole(is_left)\n+    }\n+}"}, {"sha": "0e6e213f6e87d9f8581899d641d6dae9a92e27c9", "filename": "library/alloc/src/collections/btree/split.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/003516f91a80dd8d440c932352b2fd6c6dc900b7/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsplit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/003516f91a80dd8d440c932352b2fd6c6dc900b7/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsplit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsplit.rs?ref=003516f91a80dd8d440c932352b2fd6c6dc900b7", "patch": "@@ -0,0 +1,104 @@\n+use super::node::{self, ForceResult::*, Root};\n+use super::search::{self, SearchResult::*};\n+use core::borrow::Borrow;\n+\n+impl<K, V> Root<K, V> {\n+    pub fn split_off<Q: ?Sized + Ord>(&mut self, right_root: &mut Self, key: &Q)\n+    where\n+        K: Borrow<Q>,\n+    {\n+        debug_assert!(right_root.height() == 0);\n+        debug_assert!(right_root.node_as_ref().len() == 0);\n+\n+        let left_root = self;\n+        for _ in 0..left_root.height() {\n+            right_root.push_internal_level();\n+        }\n+\n+        {\n+            let mut left_node = left_root.node_as_mut();\n+            let mut right_node = right_root.node_as_mut();\n+\n+            loop {\n+                let mut split_edge = match search::search_node(left_node, key) {\n+                    // key is going to the right tree\n+                    Found(handle) => handle.left_edge(),\n+                    GoDown(handle) => handle,\n+                };\n+\n+                split_edge.move_suffix(&mut right_node);\n+\n+                match (split_edge.force(), right_node.force()) {\n+                    (Internal(edge), Internal(node)) => {\n+                        left_node = edge.descend();\n+                        right_node = node.first_edge().descend();\n+                    }\n+                    (Leaf(_), Leaf(_)) => {\n+                        break;\n+                    }\n+                    _ => unreachable!(),\n+                }\n+            }\n+        }\n+\n+        left_root.fix_right_border();\n+        right_root.fix_left_border();\n+    }\n+\n+    /// Removes empty levels on the top, but keeps an empty leaf if the entire tree is empty.\n+    fn fix_top(&mut self) {\n+        while self.height() > 0 && self.node_as_ref().len() == 0 {\n+            self.pop_internal_level();\n+        }\n+    }\n+\n+    fn fix_right_border(&mut self) {\n+        self.fix_top();\n+\n+        {\n+            let mut cur_node = self.node_as_mut();\n+\n+            while let Internal(node) = cur_node.force() {\n+                let mut last_kv = node.last_kv();\n+\n+                if last_kv.can_merge() {\n+                    cur_node = last_kv.merge().descend();\n+                } else {\n+                    let right_len = last_kv.reborrow().right_edge().descend().len();\n+                    // `MINLEN + 1` to avoid readjust if merge happens on the next level.\n+                    if right_len < node::MIN_LEN + 1 {\n+                        last_kv.bulk_steal_left(node::MIN_LEN + 1 - right_len);\n+                    }\n+                    cur_node = last_kv.right_edge().descend();\n+                }\n+            }\n+        }\n+\n+        self.fix_top();\n+    }\n+\n+    /// The symmetric clone of `fix_right_border`.\n+    fn fix_left_border(&mut self) {\n+        self.fix_top();\n+\n+        {\n+            let mut cur_node = self.node_as_mut();\n+\n+            while let Internal(node) = cur_node.force() {\n+                let mut first_kv = node.first_kv();\n+\n+                if first_kv.can_merge() {\n+                    cur_node = first_kv.merge().descend();\n+                } else {\n+                    let left_len = first_kv.reborrow().left_edge().descend().len();\n+                    if left_len < node::MIN_LEN + 1 {\n+                        first_kv.bulk_steal_right(node::MIN_LEN + 1 - left_len);\n+                    }\n+                    cur_node = first_kv.left_edge().descend();\n+                }\n+            }\n+        }\n+\n+        self.fix_top();\n+    }\n+}"}]}