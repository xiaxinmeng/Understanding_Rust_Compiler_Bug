{"sha": "88906cd097e5c088f42bfa1f963765624a7c420e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4OTA2Y2QwOTdlNWMwODhmNDJiZmExZjk2Mzc2NTYyNGE3YzQyMGU=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-06-10T04:01:11Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-06-10T04:01:11Z"}, "message": "cargo: Update for recent language changes", "tree": {"sha": "d0e9e6fe118f0627d2dd5fb56c3eb371a0dfeff4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d0e9e6fe118f0627d2dd5fb56c3eb371a0dfeff4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/88906cd097e5c088f42bfa1f963765624a7c420e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/88906cd097e5c088f42bfa1f963765624a7c420e", "html_url": "https://github.com/rust-lang/rust/commit/88906cd097e5c088f42bfa1f963765624a7c420e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/88906cd097e5c088f42bfa1f963765624a7c420e/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "67eb4e978a0b62133d64d6b1a599752f10aa421d", "url": "https://api.github.com/repos/rust-lang/rust/commits/67eb4e978a0b62133d64d6b1a599752f10aa421d", "html_url": "https://github.com/rust-lang/rust/commit/67eb4e978a0b62133d64d6b1a599752f10aa421d"}], "stats": {"total": 186, "additions": 91, "deletions": 95}, "files": [{"sha": "7514f37cc0512f53384233162388b9e26547c000", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 91, "deletions": 95, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/88906cd097e5c088f42bfa1f963765624a7c420e/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88906cd097e5c088f42bfa1f963765624a7c420e/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=88906cd097e5c088f42bfa1f963765624a7c420e", "patch": "@@ -17,30 +17,30 @@ import vec;\n import getopts::{optflag, optopt, opt_present};\n \n type package = {\n-    mut name: str,\n-    mut uuid: str,\n-    mut url: str,\n-    mut method: str,\n-    mut description: str,\n-    mut ref: option<str>,\n-    mut tags: [str],\n-    mut versions: [(str, str)]\n+    name: str,\n+    uuid: str,\n+    url: str,\n+    method: str,\n+    description: str,\n+    ref: option<str>,\n+    tags: [str],\n+    versions: [(str, str)]\n };\n \n type local_package = {\n-    mut name: str,\n-    mut metaname: str,\n-    mut version: str,\n-    mut files: [str]\n+    name: str,\n+    metaname: str,\n+    version: str,\n+    files: [str]\n };\n \n-type source = {\n-    mut name: str,\n+type source = @{\n+    name: str,\n     mut url: str,\n     mut method: str,\n     mut key: option<str>,\n     mut keyfp: option<str>,\n-    mut packages: [package]\n+    mut packages: [mut package]\n };\n \n type cargo = {\n@@ -58,13 +58,13 @@ type cargo = {\n };\n \n type crate = {\n-    mut name: str,\n-    mut vers: str,\n-    mut uuid: str,\n-    mut desc: option<str>,\n-    mut sigs: option<str>,\n-    mut crate_type: option<str>,\n-    mut deps: [str]\n+    name: str,\n+    vers: str,\n+    uuid: str,\n+    desc: option<str>,\n+    sigs: option<str>,\n+    crate_type: option<str>,\n+    deps: [str]\n };\n \n type options = {\n@@ -350,13 +350,13 @@ fn load_crate(filename: str) -> option<crate> {\n     alt (name, vers, uuid) {\n         (some(name0), some(vers0), some(uuid0)) {\n             some({\n-                mut name: name0,\n-                mut vers: vers0,\n-                mut uuid: uuid0,\n-                mut desc: desc,\n-                mut sigs: sigs,\n-                mut crate_type: crate_type,\n-                mut deps: deps })\n+                name: name0,\n+                vers: vers0,\n+                uuid: uuid0,\n+                desc: desc,\n+                sigs: sigs,\n+                crate_type: crate_type,\n+                deps: deps })\n         }\n         _ { ret none; }\n     }\n@@ -427,12 +427,13 @@ fn parse_source(name: str, j: json::json) -> source {\n             if method == \"file\" {\n                 url = os::make_absolute(url);\n             }\n-            ret { mut name: name,\n-                  mut url: url,\n-                  mut method: method,\n-                  mut key: key,\n-                  mut keyfp: keyfp,\n-                  mut packages: [] };\n+            ret @{\n+                name: name,\n+                mut url: url,\n+                mut method: method,\n+                mut key: key,\n+                mut keyfp: keyfp,\n+                mut packages: [mut] };\n         }\n         _ { fail \"needed dict value in source\"; }\n     };\n@@ -453,7 +454,7 @@ fn try_parse_sources(filename: str, sources: map::hashmap<str, source>) {\n     }\n }\n \n-fn load_one_source_package(&&src: source, p: map::hashmap<str, json::json>) {\n+fn load_one_source_package(src: source, p: map::hashmap<str, json::json>) {\n     let name = alt p.find(\"name\") {\n         some(json::string(_n)) {\n             if !valid_pkg_name(_n) {\n@@ -529,36 +530,30 @@ fn load_one_source_package(&&src: source, p: map::hashmap<str, json::json>) {\n     };\n \n     let newpkg = {\n-        mut name: name,\n-        mut uuid: uuid,\n-        mut url: url,\n-        mut method: method,\n-        mut description: description,\n-        mut ref: ref,\n-        mut tags: tags,\n-        mut versions: []\n+        name: name,\n+        uuid: uuid,\n+        url: url,\n+        method: method,\n+        description: description,\n+        ref: ref,\n+        tags: tags,\n+        versions: []\n     };\n \n-    for src.packages.each { |pkg|\n-        if pkg.uuid == uuid {\n-            pkg.name = newpkg.name;\n-            pkg.uuid = newpkg.uuid;\n-            pkg.url = newpkg.url;\n-            pkg.method = newpkg.method;\n-            pkg.description = newpkg.description;\n-            pkg.ref = newpkg.ref;\n-            pkg.tags = newpkg.tags;\n-            pkg.versions = newpkg.versions;\n-            log(debug, \"  updated package: \" + src.name + \"/\" + name);\n-            ret;\n-        }\n+    alt src.packages.position({ |pkg| pkg.uuid == uuid }) {\n+      some(idx) {\n+        src.packages[idx] = newpkg;\n+        log(debug, \"  updated package: \" + src.name + \"/\" + name);\n+      }\n+      none {\n+        vec::grow(src.packages, 1u, newpkg);\n+      }\n     }\n \n-    vec::grow(src.packages, 1u, newpkg);\n     log(debug, \"  loaded package: \" + src.name + \"/\" + name);\n }\n \n-fn load_source_info(&c: cargo, &src: source) {\n+fn load_source_info(c: cargo, src: source) {\n     let dir = path::connect(c.sourcedir, src.name);\n     let srcfile = path::connect(dir, \"source.json\");\n     if !os::path_exists(srcfile) { ret; }\n@@ -579,7 +574,7 @@ fn load_source_info(&c: cargo, &src: source) {\n         }\n     };\n }\n-fn load_source_packages(&&c: cargo, &src: source) {\n+fn load_source_packages(c: cargo, src: source) {\n     log(debug, \"loading source: \" + src.name);\n     let dir = path::connect(c.sourcedir, src.name);\n     let pkgfile = path::connect(dir, \"packages.json\");\n@@ -698,7 +693,7 @@ fn configure(opts: options) -> cargo {\n     c\n }\n \n-fn for_each_package(&c: cargo, b: fn(source, package)) {\n+fn for_each_package(c: cargo, b: fn(source, package)) {\n     for c.sources.each_value {|v|\n         // FIXME (#2280): this temporary shouldn't be\n         // necessary, but seems to be, for borrowing.\n@@ -742,7 +737,7 @@ fn test_one_crate(_c: cargo, path: str, cf: str) {\n   run_programs(buildpath);\n }\n \n-fn install_one_crate(&c: cargo, path: str, cf: str) {\n+fn install_one_crate(c: cargo, path: str, cf: str) {\n     let buildpath = alt run_in_buildpath(\"installing\", path,\n                                          \"/build\", cf, []) {\n       none { ret; }\n@@ -782,7 +777,7 @@ fn rustc_sysroot() -> str {\n     }\n }\n \n-fn install_source(&c: cargo, path: str) {\n+fn install_source(c: cargo, path: str) {\n     #debug(\"source: %s\", path);\n     os::change_dir(path);\n \n@@ -824,7 +819,7 @@ fn install_source(&c: cargo, path: str) {\n     }\n }\n \n-fn install_git(&c: cargo, wd: str, url: str, ref: option<str>) {\n+fn install_git(c: cargo, wd: str, url: str, ref: option<str>) {\n     run::program_output(\"git\", [\"clone\", url, wd]);\n     if option::is_some::<str>(ref) {\n         let r = option::get::<str>(ref);\n@@ -835,7 +830,7 @@ fn install_git(&c: cargo, wd: str, url: str, ref: option<str>) {\n     install_source(c, wd);\n }\n \n-fn install_curl(&c: cargo, wd: str, url: str) {\n+fn install_curl(c: cargo, wd: str, url: str) {\n     let tarpath = path::connect(wd, \"pkg.tar\");\n     let p = run::program_output(\"curl\", [\"-f\", \"-s\", \"-o\",\n                                          tarpath, url]);\n@@ -847,13 +842,13 @@ fn install_curl(&c: cargo, wd: str, url: str) {\n     install_source(c, wd);\n }\n \n-fn install_file(&c: cargo, wd: str, path: str) {\n+fn install_file(c: cargo, wd: str, path: str) {\n     run::program_output(\"tar\", [\"-x\", \"--strip-components=1\",\n                              \"-C\", wd, \"-f\", path]);\n     install_source(c, wd);\n }\n \n-fn install_package(&c: cargo, src: str, wd: str, pkg: package) {\n+fn install_package(c: cargo, src: str, wd: str, pkg: package) {\n     let url = copy pkg.url;\n     let method = alt pkg.method {\n         \"git\" { \"git\" }\n@@ -871,7 +866,7 @@ fn install_package(&c: cargo, src: str, wd: str, pkg: package) {\n     }\n }\n \n-fn cargo_suggestion(&c: cargo, fallback: fn())\n+fn cargo_suggestion(c: cargo, fallback: fn())\n {\n     if c.sources.size() == 0u {\n         error(\"no sources defined - you may wish to run \" +\n@@ -881,7 +876,7 @@ fn cargo_suggestion(&c: cargo, fallback: fn())\n     fallback();\n }\n \n-fn install_uuid(&c: cargo, wd: str, uuid: str) {\n+fn install_uuid(c: cargo, wd: str, uuid: str) {\n     let mut ps = [];\n     for_each_package(c, { |s, p|\n         if p.uuid == uuid {\n@@ -905,7 +900,7 @@ fn install_uuid(&c: cargo, wd: str, uuid: str) {\n     }\n }\n \n-fn install_named(&c: cargo, wd: str, name: str) {\n+fn install_named(c: cargo, wd: str, name: str) {\n     let mut ps = [];\n     for_each_package(c, { |s, p|\n         if p.name == name {\n@@ -929,7 +924,7 @@ fn install_named(&c: cargo, wd: str, name: str) {\n     }\n }\n \n-fn install_uuid_specific(&c: cargo, wd: str, src: str, uuid: str) {\n+fn install_uuid_specific(c: cargo, wd: str, src: str, uuid: str) {\n     alt c.sources.find(src) {\n       some(s) {\n         let packages = copy s.packages;\n@@ -945,7 +940,7 @@ fn install_uuid_specific(&c: cargo, wd: str, src: str, uuid: str) {\n     error(\"can't find package: \" + src + \"/\" + uuid);\n }\n \n-fn install_named_specific(&c: cargo, wd: str, src: str, name: str) {\n+fn install_named_specific(c: cargo, wd: str, src: str, name: str) {\n     alt c.sources.find(src) {\n         some(s) {\n           let packages = copy s.packages;\n@@ -961,7 +956,7 @@ fn install_named_specific(&c: cargo, wd: str, src: str, name: str) {\n     error(\"can't find package: \" + src + \"/\" + name);\n }\n \n-fn cmd_uninstall(&c: cargo) {\n+fn cmd_uninstall(c: cargo) {\n     if vec::len(c.opts.free) < 3u {\n         cmd_usage();\n         ret;\n@@ -1026,7 +1021,7 @@ fn cmd_uninstall(&c: cargo) {\n     }\n }\n \n-fn install_query(&c: cargo, wd: str, target: str) {\n+fn install_query(c: cargo, wd: str, target: str) {\n     alt c.dep_cache.find(target) {\n         some(_inst) {\n             if _inst {\n@@ -1086,7 +1081,7 @@ fn install_query(&c: cargo, wd: str, target: str) {\n     }\n }\n \n-fn cmd_install(&c: cargo) unsafe {\n+fn cmd_install(c: cargo) unsafe {\n     let wd_base = c.workdir + path::path_sep();\n     let wd = alt tempfile::mkdtemp(wd_base, \"\") {\n         some(_wd) { _wd }\n@@ -1113,15 +1108,15 @@ fn cmd_install(&c: cargo) unsafe {\n     install_query(c, wd, copy query);\n }\n \n-fn sync(&c: cargo) {\n+fn sync(c: cargo) {\n     for c.sources.each_key { |k|\n         let mut s = c.sources.get(k);\n         sync_one(c, s);\n         c.sources.insert(k, s);\n     }\n }\n \n-fn sync_one_file(&c: cargo, dir: str, &src: source) -> bool {\n+fn sync_one_file(c: cargo, dir: str, src: source) -> bool {\n     let name = src.name;\n     let srcfile = path::connect(dir, \"source.json.new\");\n     let destsrcfile = path::connect(dir, \"source.json\");\n@@ -1145,7 +1140,7 @@ fn sync_one_file(&c: cargo, dir: str, &src: source) -> bool {\n     os::copy_file(path::connect(url, \"source.json.sig\"), srcsigfile);\n     os::copy_file(path::connect(url, \"packages.json.sig\"), sigfile);\n \n-    alt src.key {\n+    alt copy src.key {\n         some(u) {\n             let p = run::program_output(\"curl\",  [\"-f\", \"-s\", \"-o\", keyfile,\n                                                   u]);\n@@ -1197,7 +1192,7 @@ fn sync_one_file(&c: cargo, dir: str, &src: source) -> bool {\n     ret true;\n }\n \n-fn sync_one_git(&c: cargo, dir: str, &src: source) -> bool {\n+fn sync_one_git(c: cargo, dir: str, src: source) -> bool {\n     let name = src.name;\n     let srcfile = path::connect(dir, \"source.json\");\n     let pkgfile = path::connect(dir, \"packages.json\");\n@@ -1254,7 +1249,7 @@ fn sync_one_git(&c: cargo, dir: str, &src: source) -> bool {\n \n     let has_src_file = os::path_exists(srcfile);\n \n-    alt src.key {\n+    alt copy src.key {\n         some(u) {\n             let p = run::program_output(\"curl\",  [\"-f\", \"-s\", \"-o\", keyfile,\n                                                   u]);\n@@ -1299,7 +1294,7 @@ fn sync_one_git(&c: cargo, dir: str, &src: source) -> bool {\n     ret true;\n }\n \n-fn sync_one_curl(&c: cargo, dir: str, &src: source) -> bool {\n+fn sync_one_curl(c: cargo, dir: str, src: source) -> bool {\n     let name = src.name;\n     let srcfile = path::connect(dir, \"source.json.new\");\n     let destsrcfile = path::connect(dir, \"source.json\");\n@@ -1331,7 +1326,7 @@ fn sync_one_curl(&c: cargo, dir: str, &src: source) -> bool {\n         }\n     }\n \n-    alt src.key {\n+    alt copy src.key {\n         some(u) {\n             let p = run::program_output(\"curl\",  [\"-f\", \"-s\", \"-o\", keyfile,\n                                                   u]);\n@@ -1407,7 +1402,7 @@ fn sync_one_curl(&c: cargo, dir: str, &src: source) -> bool {\n     ret true;\n }\n \n-fn sync_one(&c: cargo, &src: source) {\n+fn sync_one(c: cargo, src: source) {\n     let name = src.name;\n     let dir = path::connect(c.sourcedir, name);\n \n@@ -1427,7 +1422,7 @@ fn sync_one(&c: cargo, &src: source) {\n     }\n }\n \n-fn cmd_init(&c: cargo) {\n+fn cmd_init(c: cargo) {\n     let srcurl = \"http://www.rust-lang.org/cargo/sources.json\";\n     let sigurl = \"http://www.rust-lang.org/cargo/sources.json.sig\";\n \n@@ -1494,7 +1489,7 @@ fn print_source(s: source) {\n     });\n }\n \n-fn cmd_list(&c: cargo) {\n+fn cmd_list(c: cargo) {\n     sync(c);\n \n     if vec::len(c.opts.free) >= 3u {\n@@ -1519,7 +1514,7 @@ fn cmd_list(&c: cargo) {\n     }\n }\n \n-fn cmd_search(&c: cargo) {\n+fn cmd_search(c: cargo) {\n     if vec::len(c.opts.free) < 3u {\n         cmd_usage();\n         ret;\n@@ -1551,7 +1546,7 @@ fn install_to_dir(srcfile: str, destdir: str) {\n     }\n }\n \n-fn dump_cache(&c: cargo) {\n+fn dump_cache(c: cargo) {\n     need_dir(c.root);\n \n     let out = path::connect(c.root, \"cache.json\");\n@@ -1561,7 +1556,7 @@ fn dump_cache(&c: cargo) {\n         copy_warn(out, path::connect(c.root, \"cache.json.old\"));\n     }\n }\n-fn dump_sources(&c: cargo) {\n+fn dump_sources(c: cargo) {\n     if c.sources.size() < 1u {\n         ret;\n     }\n@@ -1586,13 +1581,13 @@ fn dump_sources(&c: cargo) {\n                 chash.insert(\"url\", json::string(v.url));\n                 chash.insert(\"method\", json::string(v.method));\n \n-                alt v.key {\n+                alt copy v.key {\n                     some(key) {\n                         chash.insert(\"key\", json::string(key));\n                     }\n                     _ {}\n                 }\n-                alt v.keyfp {\n+                alt copy v.keyfp {\n                     some(keyfp) {\n                         chash.insert(\"keyfp\", json::string(keyfp));\n                     }\n@@ -1616,10 +1611,11 @@ fn copy_warn(srcfile: str, destfile: str) {\n     }\n }\n \n-fn cmd_sources(&c: cargo) {\n+fn cmd_sources(c: cargo) {\n     if vec::len(c.opts.free) < 3u {\n         for c.sources.each_value { |v|\n-            info(#fmt(\"%s (%s) via %s\", v.name, v.url, v.method));\n+            info(#fmt(\"%s (%s) via %s\",\n+                      copy v.name, copy v.url, copy v.method));\n         }\n         ret;\n     }\n@@ -1653,13 +1649,13 @@ fn cmd_sources(&c: cargo) {\n                     error(#fmt(\"source already exists: %s\", name));\n                 }\n                 none {\n-                    c.sources.insert(name, {\n-                        mut name: name,\n+                    c.sources.insert(name, @{\n+                        name: name,\n                         mut url: url,\n                         mut method: assume_source_method(url),\n                         mut key: none,\n                         mut keyfp: none,\n-                        mut packages: []\n+                        mut packages: [mut]\n                     });\n                     info(#fmt(\"added source: %s\", name));\n                 }"}]}