{"sha": "392d853589721ffef1f32181d6c3959f0284e4fb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5MmQ4NTM1ODk3MjFmZmVmMWYzMjE4MWQ2YzM5NTlmMDI4NGU0ZmI=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-02-19T22:26:46Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-02-28T19:37:59Z"}, "message": "Suggest constraining type parameters", "tree": {"sha": "72e80f022de8c7d23e9c90f76cc53c60505e14bb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/72e80f022de8c7d23e9c90f76cc53c60505e14bb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/392d853589721ffef1f32181d6c3959f0284e4fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/392d853589721ffef1f32181d6c3959f0284e4fb", "html_url": "https://github.com/rust-lang/rust/commit/392d853589721ffef1f32181d6c3959f0284e4fb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/392d853589721ffef1f32181d6c3959f0284e4fb/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1e7bcc733a10098bc06d93c8fe183c8c61307298", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e7bcc733a10098bc06d93c8fe183c8c61307298", "html_url": "https://github.com/rust-lang/rust/commit/1e7bcc733a10098bc06d93c8fe183c8c61307298"}], "stats": {"total": 161, "additions": 144, "deletions": 17}, "files": [{"sha": "4d9a3266567f3d718c90579df6ace9991eeb2798", "filename": "src/librustc_parse/parser/generics.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/392d853589721ffef1f32181d6c3959f0284e4fb/src%2Flibrustc_parse%2Fparser%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/392d853589721ffef1f32181d6c3959f0284e4fb/src%2Flibrustc_parse%2Fparser%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fgenerics.rs?ref=392d853589721ffef1f32181d6c3959f0284e4fb", "patch": "@@ -1,7 +1,6 @@\n use super::Parser;\n \n use rustc_errors::PResult;\n-use rustc_span::source_map::DUMMY_SP;\n use rustc_span::symbol::{kw, sym};\n use syntax::ast::{self, Attribute, GenericBounds, GenericParam, GenericParamKind, WhereClause};\n use syntax::token;\n@@ -160,7 +159,10 @@ impl<'a> Parser<'a> {\n         };\n         Ok(ast::Generics {\n             params,\n-            where_clause: WhereClause { predicates: Vec::new(), span: DUMMY_SP },\n+            where_clause: WhereClause {\n+                predicates: Vec::new(),\n+                span: self.prev_span.shrink_to_hi(),\n+            },\n             span,\n         })\n     }"}, {"sha": "410b8883a29d98b4db45ff2761b7ce39c09cf673", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 65, "deletions": 15, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/392d853589721ffef1f32181d6c3959f0284e4fb/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/392d853589721ffef1f32181d6c3959f0284e4fb/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=392d853589721ffef1f32181d6c3959f0284e4fb", "patch": "@@ -7,7 +7,7 @@ use rustc::hir::map as hir_map;\n use rustc::hir::map::Map;\n use rustc::ty::print::with_crate_prefix;\n use rustc::ty::{self, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness};\n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Namespace, Res};\n@@ -537,10 +537,43 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 if !unsatisfied_predicates.is_empty() {\n                     let def_span =\n                         |def_id| self.tcx.sess.source_map().def_span(self.tcx.def_span(def_id));\n+                    let mut type_params = FxHashMap::default();\n                     let mut bound_spans = vec![];\n+                    let mut collect_type_param_suggestions =\n+                        |self_ty: Ty<'_>, parent_pred: &ty::Predicate<'_>, obligation: &str| {\n+                            if let (ty::Param(_), ty::Predicate::Trait(p, _)) =\n+                                (&self_ty.kind, parent_pred)\n+                            {\n+                                if let ty::Adt(def, _) = p.skip_binder().trait_ref.self_ty().kind {\n+                                    let id = self.tcx.hir().as_local_hir_id(def.did).unwrap();\n+                                    let node = self.tcx.hir().get(id);\n+                                    match node {\n+                                        hir::Node::Item(hir::Item { kind, .. }) => {\n+                                            if let Some(g) = kind.generics() {\n+                                                let key = match &g.where_clause.predicates[..] {\n+                                                    [.., pred] => {\n+                                                        (pred.span().shrink_to_hi(), false)\n+                                                    }\n+                                                    [] => (\n+                                                        g.where_clause\n+                                                            .span_for_predicates_or_empty_place(),\n+                                                        true,\n+                                                    ),\n+                                                };\n+                                                type_params\n+                                                    .entry(key)\n+                                                    .or_insert_with(FxHashSet::default)\n+                                                    .insert(obligation.to_owned());\n+                                            }\n+                                        }\n+                                        _ => {}\n+                                    }\n+                                }\n+                            }\n+                        };\n                     let mut bound_span_label = |self_ty: Ty<'_>, obligation: &str, quiet: &str| {\n                         let msg = format!(\n-                            \"doesn't satisfy {}\",\n+                            \"doesn't satisfy `{}`\",\n                             if obligation.len() > 50 { quiet } else { obligation }\n                         );\n                         match &self_ty.kind {\n@@ -560,7 +593,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             }\n                             // Point at the closure that couldn't satisfy the bound.\n                             ty::Closure(def_id, _) => bound_spans\n-                                .push((def_span(*def_id), format!(\"doesn't satisfy {}\", quiet))),\n+                                .push((def_span(*def_id), format!(\"doesn't satisfy `{}`\", quiet))),\n                             _ => {}\n                         }\n                     };\n@@ -574,43 +607,60 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     .tcx\n                                     .associated_item(pred.skip_binder().projection_ty.item_def_id);\n                                 let ty = pred.skip_binder().ty;\n-                                let obligation =\n-                                    format!(\"`{}::{} = {}`\", trait_ref, assoc.ident, ty);\n+                                let obligation = format!(\"{}::{} = {}\", trait_ref, assoc.ident, ty);\n                                 let quiet = format!(\n-                                    \"`<_ as {}>::{} = {}`\",\n+                                    \"<_ as {}>::{} = {}\",\n                                     trait_ref.print_only_trait_path(),\n                                     assoc.ident,\n                                     ty\n                                 );\n                                 bound_span_label(trait_ref.self_ty(), &obligation, &quiet);\n-                                Some(obligation)\n+                                Some((obligation, trait_ref.self_ty()))\n                             }\n                             ty::Predicate::Trait(poly_trait_ref, _) => {\n                                 let p = poly_trait_ref.skip_binder().trait_ref;\n                                 let self_ty = p.self_ty();\n                                 let path = p.print_only_trait_path();\n-                                let obligation = format!(\"`{}: {}`\", self_ty, path);\n-                                let quiet = format!(\"`_: {}`\", path);\n+                                let obligation = format!(\"{}: {}\", self_ty, path);\n+                                let quiet = format!(\"_: {}\", path);\n                                 bound_span_label(self_ty, &obligation, &quiet);\n-                                Some(obligation)\n+                                Some((obligation, self_ty))\n                             }\n                             _ => None,\n                         }\n                     };\n                     let mut bound_list = unsatisfied_predicates\n                         .iter()\n                         .filter_map(|(pred, parent_pred)| {\n-                            format_pred(*pred).map(|pred| match parent_pred {\n-                                None => pred,\n+                            format_pred(*pred).map(|(p, self_ty)| match parent_pred {\n+                                None => format!(\"`{}`\", p),\n                                 Some(parent_pred) => match format_pred(*parent_pred) {\n-                                    None => pred,\n-                                    Some(parent_pred) => {\n-                                        format!(\"{} which is required by {}\", pred, parent_pred)\n+                                    None => format!(\"`{}`\", p),\n+                                    Some((parent_p, _)) => {\n+                                        collect_type_param_suggestions(self_ty, parent_pred, &p);\n+                                        format!(\"`{}` which is required by `{}`\", p, parent_p)\n                                     }\n                                 },\n                             })\n                         })\n                         .collect::<Vec<String>>();\n+                    for ((span, empty_where), obligations) in type_params.into_iter() {\n+                        err.span_suggestion_verbose(\n+                            span,\n+                            &format!(\n+                                \"consider restricting the type parameter{s} to satisfy the \\\n+                                 obligation{s}\",\n+                                s = pluralize!(obligations.len())\n+                            ),\n+                            format!(\n+                                \"{} {}\",\n+                                if empty_where { \" where\" } else { \",\" },\n+                                obligations.into_iter().collect::<Vec<_>>().join(\", \")\n+                            ),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n+\n                     bound_list.sort();\n                     bound_list.dedup(); // #35677\n                     bound_spans.sort();"}, {"sha": "fefdf149f556c85cfe029f7fb4ce7f90609b324c", "filename": "src/test/ui/suggestions/missing-trait-bounds-for-method-call.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/392d853589721ffef1f32181d6c3959f0284e4fb/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-trait-bounds-for-method-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/392d853589721ffef1f32181d6c3959f0284e4fb/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-trait-bounds-for-method-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-trait-bounds-for-method-call.rs?ref=392d853589721ffef1f32181d6c3959f0284e4fb", "patch": "@@ -0,0 +1,31 @@\n+#[derive(Default, PartialEq)]\n+struct Foo<T> {\n+    bar: Box<[T]>,\n+}\n+\n+trait Bar {\n+    fn foo(&self) {}\n+}\n+\n+impl<T: Default + Bar> Bar for Foo<T> {}\n+\n+impl<T> Foo<T> {\n+    fn bar(&self) {\n+        self.foo();\n+        //~^ ERROR no method named `foo` found for reference `&Foo<T>` in the current scope\n+    }\n+}\n+\n+struct Fin<T> where T: Bar {\n+    bar: Box<[T]>,\n+}\n+\n+impl<T: Default + Bar> Bar for Fin<T> {}\n+\n+impl<T: Bar> Fin<T> {\n+    fn bar(&self) {\n+        self.foo();\n+        //~^ ERROR no method named `foo` found for reference `&Fin<T>` in the current scope\n+    }\n+}\n+fn main() {}"}, {"sha": "b1b31a67650b61c356570608e3f08ce6caecdbdf", "filename": "src/test/ui/suggestions/missing-trait-bounds-for-method-call.stderr", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/392d853589721ffef1f32181d6c3959f0284e4fb/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-trait-bounds-for-method-call.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/392d853589721ffef1f32181d6c3959f0284e4fb/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-trait-bounds-for-method-call.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-trait-bounds-for-method-call.stderr?ref=392d853589721ffef1f32181d6c3959f0284e4fb", "patch": "@@ -0,0 +1,44 @@\n+error[E0599]: no method named `foo` found for reference `&Foo<T>` in the current scope\n+  --> $DIR/missing-trait-bounds-for-method-call.rs:14:14\n+   |\n+LL | struct Foo<T> {\n+   | ------------- doesn't satisfy `Foo<T>: Bar`\n+...\n+LL | trait Bar {\n+   | --------- `Bar` defines an item `foo`, perhaps you need to implement it\n+...\n+LL |         self.foo();\n+   |              ^^^ method not found in `&Foo<T>`\n+   |\n+   = note: the method `foo` exists but the following trait bounds were not satisfied:\n+           `T: Bar` which is required by `Foo<T>: Bar`\n+           `T: std::default::Default` which is required by `Foo<T>: Bar`\n+   = help: items from traits can only be used if the trait is implemented and in scope\n+help: consider restricting the type parameters to satisfy the obligations\n+   |\n+LL | struct Foo<T> where T: Bar, T: std::default::Default {\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0599]: no method named `foo` found for reference `&Fin<T>` in the current scope\n+  --> $DIR/missing-trait-bounds-for-method-call.rs:27:14\n+   |\n+LL | trait Bar {\n+   | --------- `Bar` defines an item `foo`, perhaps you need to implement it\n+...\n+LL | struct Fin<T> where T: Bar {\n+   | -------------------------- doesn't satisfy `Fin<T>: Bar`\n+...\n+LL |         self.foo();\n+   |              ^^^ method not found in `&Fin<T>`\n+   |\n+   = note: the method `foo` exists but the following trait bounds were not satisfied:\n+           `T: std::default::Default` which is required by `Fin<T>: Bar`\n+   = help: items from traits can only be used if the trait is implemented and in scope\n+help: consider restricting the type parameter to satisfy the obligation\n+   |\n+LL | struct Fin<T> where T: Bar, T: std::default::Default {\n+   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0599`."}]}