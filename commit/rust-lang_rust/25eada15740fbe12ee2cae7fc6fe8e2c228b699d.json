{"sha": "25eada15740fbe12ee2cae7fc6fe8e2c228b699d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1ZWFkYTE1NzQwZmJlMTJlZTJjYWU3ZmM2ZmU4ZTJjMjI4YjY5OWQ=", "commit": {"author": {"name": "Dylan Ede", "email": "dylanede@googlemail.com", "date": "2015-01-06T16:36:30Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-06T19:59:26Z"}, "message": "[breaking change] Revert Entry behaviour to take keys by value.", "tree": {"sha": "bc24dedaf97ab376c4ac4f73b4c40d068c5ef84b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bc24dedaf97ab376c4ac4f73b4c40d068c5ef84b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/25eada15740fbe12ee2cae7fc6fe8e2c228b699d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/25eada15740fbe12ee2cae7fc6fe8e2c228b699d", "html_url": "https://github.com/rust-lang/rust/commit/25eada15740fbe12ee2cae7fc6fe8e2c228b699d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/25eada15740fbe12ee2cae7fc6fe8e2c228b699d/comments", "author": {"login": "dylanede", "id": 10339269, "node_id": "MDQ6VXNlcjEwMzM5MjY5", "avatar_url": "https://avatars.githubusercontent.com/u/10339269?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dylanede", "html_url": "https://github.com/dylanede", "followers_url": "https://api.github.com/users/dylanede/followers", "following_url": "https://api.github.com/users/dylanede/following{/other_user}", "gists_url": "https://api.github.com/users/dylanede/gists{/gist_id}", "starred_url": "https://api.github.com/users/dylanede/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dylanede/subscriptions", "organizations_url": "https://api.github.com/users/dylanede/orgs", "repos_url": "https://api.github.com/users/dylanede/repos", "events_url": "https://api.github.com/users/dylanede/events{/privacy}", "received_events_url": "https://api.github.com/users/dylanede/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6539cb417f4a7c2d9d1afce44c196578d2b67f38", "url": "https://api.github.com/repos/rust-lang/rust/commits/6539cb417f4a7c2d9d1afce44c196578d2b67f38", "html_url": "https://github.com/rust-lang/rust/commit/6539cb417f4a7c2d9d1afce44c196578d2b67f38"}], "stats": {"total": 129, "additions": 60, "deletions": 69}, "files": [{"sha": "6e8b1a662ce76a84879210603384f2d65f35fb34", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/25eada15740fbe12ee2cae7fc6fe8e2c228b699d/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25eada15740fbe12ee2cae7fc6fe8e2c228b699d/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=25eada15740fbe12ee2cae7fc6fe8e2c228b699d", "patch": "@@ -19,7 +19,7 @@ pub use self::Entry::*;\n \n use core::prelude::*;\n \n-use core::borrow::{BorrowFrom, ToOwned};\n+use core::borrow::BorrowFrom;\n use core::cmp::Ordering;\n use core::default::Default;\n use core::fmt::Show;\n@@ -130,17 +130,17 @@ pub struct Values<'a, K: 'a, V: 'a> {\n \n #[stable]\n /// A view into a single entry in a map, which may either be vacant or occupied.\n-pub enum Entry<'a, Q: ?Sized +'a, K:'a, V:'a> {\n+pub enum Entry<'a, K:'a, V:'a> {\n     /// A vacant Entry\n-    Vacant(VacantEntry<'a, Q, K, V>),\n+    Vacant(VacantEntry<'a, K, V>),\n     /// An occupied Entry\n     Occupied(OccupiedEntry<'a, K, V>),\n }\n \n #[stable]\n /// A vacant Entry.\n-pub struct VacantEntry<'a, Q: ?Sized +'a, K:'a, V:'a> {\n-    key: &'a Q,\n+pub struct VacantEntry<'a, K:'a, V:'a> {\n+    key: K,\n     stack: stack::SearchStack<'a, K, V, node::handle::Edge, node::handle::Leaf>,\n }\n \n@@ -1111,23 +1111,23 @@ impl<'a, K, V> DoubleEndedIterator for Values<'a, K, V> {\n #[stable]\n impl<'a, K, V> ExactSizeIterator for Values<'a, K, V> {}\n \n-impl<'a, Q: ?Sized, K: Ord, V> Entry<'a, Q, K, V> {\n+impl<'a, K: Ord, V> Entry<'a, K, V> {\n     #[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n     /// Returns a mutable reference to the entry if occupied, or the VacantEntry if vacant\n-    pub fn get(self) -> Result<&'a mut V, VacantEntry<'a, Q, K, V>> {\n+    pub fn get(self) -> Result<&'a mut V, VacantEntry<'a, K, V>> {\n         match self {\n             Occupied(entry) => Ok(entry.into_mut()),\n             Vacant(entry) => Err(entry),\n         }\n     }\n }\n \n-impl<'a, Q: ?Sized + ToOwned<K>, K: Ord, V> VacantEntry<'a, Q, K, V> {\n+impl<'a, K: Ord, V> VacantEntry<'a, K, V> {\n     #[stable]\n     /// Sets the value of the entry with the VacantEntry's key,\n     /// and returns a mutable reference to it.\n     pub fn insert(self, value: V) -> &'a mut V {\n-        self.stack.insert(self.key.to_owned(), value)\n+        self.stack.insert(self.key, value)\n     }\n }\n \n@@ -1362,14 +1362,12 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     /// The key must have the same ordering before or after `.to_owned()` is called.\n     #[stable]\n-    pub fn entry<'a, Q: ?Sized>(&'a mut self, mut key: &'a Q) -> Entry<'a, Q, K, V>\n-        where Q: Ord + ToOwned<K>\n-    {\n+    pub fn entry<'a>(&'a mut self, mut key: K) -> Entry<'a, K, V> {\n         // same basic logic of `swap` and `pop`, blended together\n         let mut stack = stack::PartialSearchStack::new(self);\n         loop {\n             let result = stack.with(move |pusher, node| {\n-                return match Node::search(node, key) {\n+                return match Node::search(node, &key) {\n                     Found(handle) => {\n                         // Perfect match\n                         Finished(Occupied(OccupiedEntry {\n@@ -1412,7 +1410,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n #[cfg(test)]\n mod test {\n     use prelude::*;\n-    use std::borrow::{ToOwned, BorrowFrom};\n+    use std::borrow::BorrowFrom;\n \n     use super::{BTreeMap, Occupied, Vacant};\n \n@@ -1562,7 +1560,7 @@ mod test {\n         let mut map: BTreeMap<int, int> = xs.iter().map(|&x| x).collect();\n \n         // Existing key (insert)\n-        match map.entry(&1) {\n+        match map.entry(1) {\n             Vacant(_) => unreachable!(),\n             Occupied(mut view) => {\n                 assert_eq!(view.get(), &10);\n@@ -1574,7 +1572,7 @@ mod test {\n \n \n         // Existing key (update)\n-        match map.entry(&2) {\n+        match map.entry(2) {\n             Vacant(_) => unreachable!(),\n             Occupied(mut view) => {\n                 let v = view.get_mut();\n@@ -1585,7 +1583,7 @@ mod test {\n         assert_eq!(map.len(), 6);\n \n         // Existing key (take)\n-        match map.entry(&3) {\n+        match map.entry(3) {\n             Vacant(_) => unreachable!(),\n             Occupied(view) => {\n                 assert_eq!(view.remove(), 30);\n@@ -1596,7 +1594,7 @@ mod test {\n \n \n         // Inexistent key (insert)\n-        match map.entry(&10) {\n+        match map.entry(10) {\n             Occupied(_) => unreachable!(),\n             Vacant(view) => {\n                 assert_eq!(*view.insert(1000), 1000);"}, {"sha": "a510a194c987093010e1389b76e15bb5dfb3eea2", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25eada15740fbe12ee2cae7fc6fe8e2c228b699d/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25eada15740fbe12ee2cae7fc6fe8e2c228b699d/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=25eada15740fbe12ee2cae7fc6fe8e2c228b699d", "patch": "@@ -1328,7 +1328,7 @@ impl UnusedMut {\n                 let ident = path1.node;\n                 if let ast::BindByValue(ast::MutMutable) = mode {\n                     if !token::get_ident(ident).get().starts_with(\"_\") {\n-                        match mutables.entry(&ident.name.uint()) {\n+                        match mutables.entry(ident.name.uint()) {\n                             Vacant(entry) => { entry.insert(vec![id]); },\n                             Occupied(mut entry) => { entry.get_mut().push(id); },\n                         }"}, {"sha": "d02277062863acd6ab5b2d947494a8ded0cb8030", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25eada15740fbe12ee2cae7fc6fe8e2c228b699d/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25eada15740fbe12ee2cae7fc6fe8e2c228b699d/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=25eada15740fbe12ee2cae7fc6fe8e2c228b699d", "patch": "@@ -400,7 +400,7 @@ impl<'a> Context<'a> {\n             info!(\"lib candidate: {}\", path.display());\n \n             let hash_str = hash.to_string();\n-            let slot = candidates.entry(&hash_str).get().unwrap_or_else(\n+            let slot = candidates.entry(hash_str).get().unwrap_or_else(\n                 |vacant_entry| vacant_entry.insert((HashSet::new(), HashSet::new())));\n             let (ref mut rlibs, ref mut dylibs) = *slot;\n             if rlib {"}, {"sha": "25967fb8784634266f50b7d8961972aa2d679dd3", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25eada15740fbe12ee2cae7fc6fe8e2c228b699d/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25eada15740fbe12ee2cae7fc6fe8e2c228b699d/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=25eada15740fbe12ee2cae7fc6fe8e2c228b699d", "patch": "@@ -311,7 +311,7 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr) -> P<ast::Pat> {\n \n         ast::ExprCall(ref callee, ref args) => {\n             let def = tcx.def_map.borrow()[callee.id].clone();\n-            if let Vacant(entry) = tcx.def_map.borrow_mut().entry(&expr.id) {\n+            if let Vacant(entry) = tcx.def_map.borrow_mut().entry(expr.id) {\n                entry.insert(def);\n             }\n             let path = match def {"}, {"sha": "02c52f82967613316bc9be19fd016e07c4941e65", "filename": "src/librustc/middle/infer/freshen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25eada15740fbe12ee2cae7fc6fe8e2c228b699d/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25eada15740fbe12ee2cae7fc6fe8e2c228b699d/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs?ref=25eada15740fbe12ee2cae7fc6fe8e2c228b699d", "patch": "@@ -66,7 +66,7 @@ impl<'a, 'tcx> TypeFreshener<'a, 'tcx> {\n             None => { }\n         }\n \n-        match self.freshen_map.entry(&key) {\n+        match self.freshen_map.entry(key) {\n             Entry::Occupied(entry) => *entry.get(),\n             Entry::Vacant(entry) => {\n                 let index = self.freshen_count;"}, {"sha": "8135c1ca137927db6c6a66229db6d7e5e03126ca", "filename": "src/librustc/middle/infer/region_inference/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25eada15740fbe12ee2cae7fc6fe8e2c228b699d/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25eada15740fbe12ee2cae7fc6fe8e2c228b699d/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=25eada15740fbe12ee2cae7fc6fe8e2c228b699d", "patch": "@@ -137,7 +137,7 @@ impl<'a, 'tcx> ConstraintGraph<'a, 'tcx> {\n         let mut node_ids = FnvHashMap::new();\n         {\n             let mut add_node = |&mut : node| {\n-                if let Vacant(e) = node_ids.entry(&node) {\n+                if let Vacant(e) = node_ids.entry(node) {\n                     e.insert(i);\n                     i += 1;\n                 }"}, {"sha": "1f37fc357b8ecd9077bbd017eccdff3d5120688a", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/25eada15740fbe12ee2cae7fc6fe8e2c228b699d/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25eada15740fbe12ee2cae7fc6fe8e2c228b699d/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=25eada15740fbe12ee2cae7fc6fe8e2c228b699d", "patch": "@@ -437,11 +437,9 @@ fn register_region_obligation<'tcx>(tcx: &ty::ctxt<'tcx>,\n     debug!(\"register_region_obligation({})\",\n            region_obligation.repr(tcx));\n \n-    let body_id = region_obligation.cause.body_id;\n-    match region_obligations.entry(&body_id) {\n+    match region_obligations.entry(region_obligation.cause.body_id) {\n         Vacant(entry) => { entry.insert(vec![region_obligation]); },\n         Occupied(mut entry) => { entry.get_mut().push(region_obligation); },\n     }\n \n }\n-"}, {"sha": "652b9b294fa3b40473a5815fad45270b4e2c31e0", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/25eada15740fbe12ee2cae7fc6fe8e2c228b699d/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25eada15740fbe12ee2cae7fc6fe8e2c228b699d/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=25eada15740fbe12ee2cae7fc6fe8e2c228b699d", "patch": "@@ -5584,7 +5584,7 @@ pub fn lookup_field_type<'tcx>(tcx: &ctxt<'tcx>,\n         node_id_to_type(tcx, id.node)\n     } else {\n         let mut tcache = tcx.tcache.borrow_mut();\n-        let pty = tcache.entry(&id).get().unwrap_or_else(\n+        let pty = tcache.entry(id).get().unwrap_or_else(\n             |vacant_entry| vacant_entry.insert(csearch::get_field_type(tcx, struct_id, id)));\n         pty.ty\n     };\n@@ -6747,7 +6747,7 @@ pub fn replace_late_bound_regions<'tcx, T, F>(\n         debug!(\"region={}\", region.repr(tcx));\n         match region {\n             ty::ReLateBound(debruijn, br) if debruijn.depth == current_depth => {\n-                * map.entry(&br).get().unwrap_or_else(\n+                * map.entry(br).get().unwrap_or_else(\n                       |vacant_entry| vacant_entry.insert(mapf(br, debruijn)))\n             }\n             _ => {"}, {"sha": "7928dad970f03ff012b57c912e7e4e344900b330", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25eada15740fbe12ee2cae7fc6fe8e2c228b699d/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25eada15740fbe12ee2cae7fc6fe8e2c228b699d/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=25eada15740fbe12ee2cae7fc6fe8e2c228b699d", "patch": "@@ -1115,7 +1115,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n             None => early_error(\"--extern value must be of the format `foo=bar`\"),\n         };\n \n-        match externs.entry(&name.to_string()) {\n+        match externs.entry(name.to_string()) {\n             Vacant(entry) => { entry.insert(vec![location.to_string()]); },\n             Occupied(mut entry) => { entry.get_mut().push(location.to_string()); },\n         }"}, {"sha": "1927f204bc69ba19f3d7606a5cf6350cfa5ca8e1", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/25eada15740fbe12ee2cae7fc6fe8e2c228b699d/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25eada15740fbe12ee2cae7fc6fe8e2c228b699d/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=25eada15740fbe12ee2cae7fc6fe8e2c228b699d", "patch": "@@ -1701,7 +1701,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let is_public = import_directive.is_public;\n \n         let mut import_resolutions = module_.import_resolutions.borrow_mut();\n-        let dest_import_resolution = import_resolutions.entry(&name).get().unwrap_or_else(\n+        let dest_import_resolution = import_resolutions.entry(name).get().unwrap_or_else(\n             |vacant_entry| {\n                 // Create a new import resolution from this child.\n                 vacant_entry.insert(ImportResolution::new(id, is_public))\n@@ -2639,14 +2639,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             def = DefUpvar(node_id, function_id, last_proc_body_id);\n \n                             let mut seen = self.freevars_seen.borrow_mut();\n-                            let seen = match seen.entry(&function_id) {\n+                            let seen = match seen.entry(function_id) {\n                                 Occupied(v) => v.into_mut(),\n                                 Vacant(v) => v.insert(NodeSet::new()),\n                             };\n                             if seen.contains(&node_id) {\n                                 continue;\n                             }\n-                            match self.freevars.borrow_mut().entry(&function_id) {\n+                            match self.freevars.borrow_mut().entry(function_id) {\n                                 Occupied(v) => v.into_mut(),\n                                 Vacant(v) => v.insert(vec![]),\n                             }.push(Freevar { def: prev_def, span: span });\n@@ -4723,7 +4723,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 \"Import should only be used for `use` directives\");\n         self.last_private.insert(node_id, lp);\n \n-        match self.def_map.borrow_mut().entry(&node_id) {\n+        match self.def_map.borrow_mut().entry(node_id) {\n             // Resolve appears to \"resolve\" the same ID multiple\n             // times, so here is a sanity check it at least comes to\n             // the same conclusion! - nmatsakis"}, {"sha": "44dc1d11c0f89563789b103ac226007124525390", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25eada15740fbe12ee2cae7fc6fe8e2c228b699d/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25eada15740fbe12ee2cae7fc6fe8e2c228b699d/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=25eada15740fbe12ee2cae7fc6fe8e2c228b699d", "patch": "@@ -603,7 +603,7 @@ pub fn check_struct_pat_fields<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n \n     // Typecheck each field.\n     for &Spanned { node: ref field, span } in fields.iter() {\n-        let field_type = match used_fields.entry(&field.ident.name) {\n+        let field_type = match used_fields.entry(field.ident.name) {\n             Occupied(occupied) => {\n                 span_err!(tcx.sess, span, E0025,\n                     \"field `{}` bound multiple times in the pattern\","}, {"sha": "5aa96cedb5c3ab891713c623d80cfcbe86ddeea9", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/25eada15740fbe12ee2cae7fc6fe8e2c228b699d/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25eada15740fbe12ee2cae7fc6fe8e2c228b699d/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=25eada15740fbe12ee2cae7fc6fe8e2c228b699d", "patch": "@@ -821,7 +821,7 @@ impl DocFolder for Cache {\n         if let clean::ImplItem(ref i) = item.inner {\n             match i.trait_ {\n                 Some(clean::ResolvedPath{ did, .. }) => {\n-                    let v = self.implementors.entry(&did).get().unwrap_or_else(\n+                    let v = self.implementors.entry(did).get().unwrap_or_else(\n                         |vacant_entry| vacant_entry.insert(Vec::with_capacity(1)));\n                     v.push(Implementor {\n                         def_id: item.def_id,\n@@ -1011,7 +1011,7 @@ impl DocFolder for Cache {\n                         };\n \n                         if let Some(did) = did {\n-                            let v = self.impls.entry(&did).get().unwrap_or_else(\n+                            let v = self.impls.entry(did).get().unwrap_or_else(\n                                 |vacant_entry| vacant_entry.insert(Vec::with_capacity(1)));\n                             v.push(Impl {\n                                 impl_: i,\n@@ -1260,7 +1260,7 @@ impl Context {\n                 Some(ref s) => s.to_string(),\n             };\n             let short = short.to_string();\n-            let v = map.entry(&short).get().unwrap_or_else(\n+            let v = map.entry(short).get().unwrap_or_else(\n                 |vacant_entry| vacant_entry.insert(Vec::with_capacity(1)));\n             v.push(myname);\n         }"}, {"sha": "98f66fa4878202d7517be220afd8daee029d84a3", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25eada15740fbe12ee2cae7fc6fe8e2c228b699d/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25eada15740fbe12ee2cae7fc6fe8e2c228b699d/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=25eada15740fbe12ee2cae7fc6fe8e2c228b699d", "patch": "@@ -330,7 +330,7 @@ fn parse_externs(matches: &getopts::Matches) -> Result<core::Externs, String> {\n             }\n         };\n         let name = name.to_string();\n-        let locs = externs.entry(&name).get().unwrap_or_else(\n+        let locs = externs.entry(name).get().unwrap_or_else(\n             |vacant_entry| vacant_entry.insert(Vec::with_capacity(1)));\n         locs.push(location.to_string());\n     }"}, {"sha": "ae53bc615992cf614047bebad2304fdac33a529d", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 20, "deletions": 25, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/25eada15740fbe12ee2cae7fc6fe8e2c228b699d/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25eada15740fbe12ee2cae7fc6fe8e2c228b699d/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=25eada15740fbe12ee2cae7fc6fe8e2c228b699d", "patch": "@@ -14,7 +14,7 @@ use self::Entry::*;\n use self::SearchResult::*;\n use self::VacantEntryState::*;\n \n-use borrow::{BorrowFrom, ToOwned};\n+use borrow::BorrowFrom;\n use clone::Clone;\n use cmp::{max, Eq, PartialEq};\n use default::Default;\n@@ -922,14 +922,12 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n \n     #[stable]\n     /// Gets the given key's corresponding entry in the map for in-place manipulation.\n-    /// Regardless of whether or not `to_owned()` has been called, the key must hash the same way.\n-    pub fn entry<'a, Q: ?Sized>(&'a mut self, key: &'a Q) -> Entry<'a, Q, K, V>\n-        where Q: Eq + Hash<S> + ToOwned<K>\n+    pub fn entry<'a>(&'a mut self, key: K) -> Entry<'a, K, V>\n     {\n         // Gotta resize now.\n         self.reserve(1);\n \n-        let hash = self.make_hash(key);\n+        let hash = self.make_hash(&key);\n         search_entry_hashed(&mut self.table, hash, key)\n     }\n \n@@ -1142,9 +1140,8 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     }\n }\n \n-fn search_entry_hashed<'a, K, V, Q: ?Sized>(table: &'a mut RawTable<K,V>, hash: SafeHash, k: &'a Q)\n-        -> Entry<'a, Q, K, V>\n-    where Q: Eq + ToOwned<K>\n+fn search_entry_hashed<'a, K: Eq, V>(table: &'a mut RawTable<K,V>, hash: SafeHash, k: K)\n+        -> Entry<'a, K, V>\n {\n     // Worst case, we'll find one empty bucket among `size + 1` buckets.\n     let size = table.size();\n@@ -1167,7 +1164,7 @@ fn search_entry_hashed<'a, K, V, Q: ?Sized>(table: &'a mut RawTable<K,V>, hash:\n         // hash matches?\n         if bucket.hash() == hash {\n             // key matches?\n-            if *k == *BorrowFrom::borrow_from(bucket.read().0) {\n+            if k == *bucket.read().0 {\n                 return Occupied(OccupiedEntry{\n                     elem: bucket,\n                 });\n@@ -1331,19 +1328,19 @@ pub struct OccupiedEntry<'a, K: 'a, V: 'a> {\n \n #[stable]\n /// A view into a single empty location in a HashMap\n-pub struct VacantEntry<'a, Q: ?Sized + 'a, K: 'a, V: 'a> {\n+pub struct VacantEntry<'a, K: 'a, V: 'a> {\n     hash: SafeHash,\n-    key: &'a Q,\n+    key: K,\n     elem: VacantEntryState<K, V, &'a mut RawTable<K, V>>,\n }\n \n #[stable]\n /// A view into a single location in a map, which may be vacant or occupied\n-pub enum Entry<'a, Q: ?Sized + 'a, K: 'a, V: 'a> {\n+pub enum Entry<'a, K: 'a, V: 'a> {\n     /// An occupied Entry\n     Occupied(OccupiedEntry<'a, K, V>),\n     /// A vacant Entry\n-    Vacant(VacantEntry<'a, Q, K, V>),\n+    Vacant(VacantEntry<'a, K, V>),\n }\n \n /// Possible states of a VacantEntry\n@@ -1409,10 +1406,10 @@ impl<'a, K: 'a, V: 'a> Iterator for Drain<'a, K, V> {\n     }\n }\n \n-impl<'a, Q: ?Sized, K, V> Entry<'a, Q, K, V> {\n+impl<'a, K, V> Entry<'a, K, V> {\n     #[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n     /// Returns a mutable reference to the entry if occupied, or the VacantEntry if vacant\n-    pub fn get(self) -> Result<&'a mut V, VacantEntry<'a, Q, K, V>> {\n+    pub fn get(self) -> Result<&'a mut V, VacantEntry<'a, K, V>> {\n         match self {\n             Occupied(entry) => Ok(entry.into_mut()),\n             Vacant(entry) => Err(entry),\n@@ -1455,17 +1452,17 @@ impl<'a, K, V> OccupiedEntry<'a, K, V> {\n     }\n }\n \n-impl<'a, Q: ?Sized + 'a + ToOwned<K>, K: 'a, V: 'a> VacantEntry<'a, Q, K, V> {\n+impl<'a, K: 'a, V: 'a> VacantEntry<'a, K, V> {\n     #[stable]\n     /// Sets the value of the entry with the VacantEntry's key,\n     /// and returns a mutable reference to it\n     pub fn insert(self, value: V) -> &'a mut V {\n         match self.elem {\n             NeqElem(bucket, ib) => {\n-                robin_hood(bucket, ib, self.hash, self.key.to_owned(), value)\n+                robin_hood(bucket, ib, self.hash, self.key, value)\n             }\n             NoElem(bucket) => {\n-                bucket.put(self.hash, self.key.to_owned(), value).into_mut_refs().1\n+                bucket.put(self.hash, self.key, value).into_mut_refs().1\n             }\n         }\n     }\n@@ -1497,8 +1494,6 @@ mod test_map {\n     use super::HashMap;\n     use super::Entry::{Occupied, Vacant};\n     use iter::{range_inclusive, range_step_inclusive, repeat};\n-    use borrow::ToOwned;\n-    use hash;\n     use cell::RefCell;\n     use rand::{weak_rng, Rng};\n \n@@ -2092,7 +2087,7 @@ mod test_map {\n         let mut map: HashMap<int, int> = xs.iter().map(|&x| x).collect();\n \n         // Existing key (insert)\n-        match map.entry(&1) {\n+        match map.entry(1) {\n             Vacant(_) => unreachable!(),\n             Occupied(mut view) => {\n                 assert_eq!(view.get(), &10);\n@@ -2104,7 +2099,7 @@ mod test_map {\n \n \n         // Existing key (update)\n-        match map.entry(&2) {\n+        match map.entry(2) {\n             Vacant(_) => unreachable!(),\n             Occupied(mut view) => {\n                 let v = view.get_mut();\n@@ -2116,7 +2111,7 @@ mod test_map {\n         assert_eq!(map.len(), 6);\n \n         // Existing key (take)\n-        match map.entry(&3) {\n+        match map.entry(3) {\n             Vacant(_) => unreachable!(),\n             Occupied(view) => {\n                 assert_eq!(view.remove(), 30);\n@@ -2127,7 +2122,7 @@ mod test_map {\n \n \n         // Inexistent key (insert)\n-        match map.entry(&10) {\n+        match map.entry(10) {\n             Occupied(_) => unreachable!(),\n             Vacant(view) => {\n                 assert_eq!(*view.insert(1000), 1000);\n@@ -2158,7 +2153,7 @@ mod test_map {\n \n         for i in range(0u, 1000) {\n             let x = rng.gen_range(-10, 10);\n-            match m.entry(&x) {\n+            match m.entry(x) {\n                 Vacant(_) => {},\n                 Occupied(e) => {\n                     println!(\"{}: remove {}\", i, x);"}, {"sha": "9b2a4926bcb925cc985dcb1cdacaacb7d6c61bdf", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/25eada15740fbe12ee2cae7fc6fe8e2c228b699d/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25eada15740fbe12ee2cae7fc6fe8e2c228b699d/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=25eada15740fbe12ee2cae7fc6fe8e2c228b699d", "patch": "@@ -255,7 +255,7 @@\n //! let message = \"she sells sea shells by the sea shore\";\n //!\n //! for c in message.chars() {\n-//!     match count.entry(&c) {\n+//!     match count.entry(c) {\n //!         Vacant(entry) => { entry.insert(1u); },\n //!         Occupied(mut entry) => *entry.get_mut() += 1,\n //!     }\n@@ -290,7 +290,7 @@\n //! for id in orders.into_iter() {\n //!     // If this is the first time we've seen this customer, initialize them\n //!     // with no blood alcohol. Otherwise, just retrieve them.\n-//!     let person = match blood_alcohol.entry(&id) {\n+//!     let person = match blood_alcohol.entry(id) {\n //!         Vacant(entry) => entry.insert(Person{id: id, blood_alcohol: 0.0}),\n //!         Occupied(entry) => entry.into_mut(),\n //!     };"}, {"sha": "19af198bffa8288a109f14a90229ded01b49e124", "filename": "src/libsyntax/ext/mtwt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/25eada15740fbe12ee2cae7fc6fe8e2c228b699d/src%2Flibsyntax%2Fext%2Fmtwt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25eada15740fbe12ee2cae7fc6fe8e2c228b699d/src%2Flibsyntax%2Fext%2Fmtwt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmtwt.rs?ref=25eada15740fbe12ee2cae7fc6fe8e2c228b699d", "patch": "@@ -66,7 +66,7 @@ pub fn apply_mark(m: Mrk, ctxt: SyntaxContext) -> SyntaxContext {\n /// Extend a syntax context with a given mark and sctable (explicit memoization)\n fn apply_mark_internal(m: Mrk, ctxt: SyntaxContext, table: &SCTable) -> SyntaxContext {\n     let key = (ctxt, m);\n-    * table.mark_memo.borrow_mut().entry(&key).get().unwrap_or_else(\n+    * table.mark_memo.borrow_mut().entry(key).get().unwrap_or_else(\n           |vacant_entry|\n               vacant_entry.insert(idx_push(&mut *table.table.borrow_mut(), Mark(m, ctxt))))\n }\n@@ -84,7 +84,7 @@ fn apply_rename_internal(id: Ident,\n                        table: &SCTable) -> SyntaxContext {\n     let key = (ctxt, id, to);\n \n-    * table.rename_memo.borrow_mut().entry(&key).get().unwrap_or_else(\n+    * table.rename_memo.borrow_mut().entry(key).get().unwrap_or_else(\n           |vacant_entry|\n               vacant_entry.insert(idx_push(&mut *table.table.borrow_mut(), Rename(id, to, ctxt))))\n }"}, {"sha": "88f79c504d7575c23e7076c947c1fe0457ddc587", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25eada15740fbe12ee2cae7fc6fe8e2c228b699d/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25eada15740fbe12ee2cae7fc6fe8e2c228b699d/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=25eada15740fbe12ee2cae7fc6fe8e2c228b699d", "patch": "@@ -219,7 +219,7 @@ pub fn nameize(p_s: &ParseSess, ms: &[TokenTree], res: &[Rc<NamedMatch>])\n                 }\n             }\n             &TtToken(sp, MatchNt(bind_name, _, _, _)) => {\n-                match ret_val.entry(&bind_name) {\n+                match ret_val.entry(bind_name) {\n                     Vacant(spot) => {\n                         spot.insert(res[*idx].clone());\n                         *idx += 1;"}, {"sha": "8d79460ec1712d9332472b1b9f4680bcb1e48fbe", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25eada15740fbe12ee2cae7fc6fe8e2c228b699d/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25eada15740fbe12ee2cae7fc6fe8e2c228b699d/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=25eada15740fbe12ee2cae7fc6fe8e2c228b699d", "patch": "@@ -444,7 +444,7 @@ pub fn freq_count<T, U>(mut iter: T) -> hash_map::HashMap<U, uint>\n {\n     let mut map: hash_map::HashMap<U,uint> = hash_map::HashMap::new();\n     for elem in iter {\n-        match map.entry(&elem) {\n+        match map.entry(elem) {\n             Occupied(mut entry) => { *entry.get_mut() += 1; },\n             Vacant(entry) => { entry.insert(1); },\n         }"}]}