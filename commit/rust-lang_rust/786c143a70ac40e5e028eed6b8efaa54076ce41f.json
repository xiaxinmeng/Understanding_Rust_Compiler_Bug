{"sha": "786c143a70ac40e5e028eed6b8efaa54076ce41f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4NmMxNDNhNzBhYzQwZTVlMDI4ZWVkNmI4ZWZhYTU0MDc2Y2U0MWY=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2012-12-11T04:37:21Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2012-12-14T02:16:31Z"}, "message": "Begin renaming serialization to std::serialize. (snapshot)", "tree": {"sha": "7b591cf45dc738ff78d99528f94883179cf4e4bd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7b591cf45dc738ff78d99528f94883179cf4e4bd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/786c143a70ac40e5e028eed6b8efaa54076ce41f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/786c143a70ac40e5e028eed6b8efaa54076ce41f", "html_url": "https://github.com/rust-lang/rust/commit/786c143a70ac40e5e028eed6b8efaa54076ce41f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/786c143a70ac40e5e028eed6b8efaa54076ce41f/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c3f0aa973e9391c15bdfef92f72c410d3c32bc75", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3f0aa973e9391c15bdfef92f72c410d3c32bc75", "html_url": "https://github.com/rust-lang/rust/commit/c3f0aa973e9391c15bdfef92f72c410d3c32bc75"}], "stats": {"total": 1894, "additions": 1759, "deletions": 135}, "files": [{"sha": "a2c80914fd66122784c25efdaf34593fcf3ab82c", "filename": "src/libstd/serialize.rs", "status": "added", "additions": 585, "deletions": 0, "changes": 585, "blob_url": "https://github.com/rust-lang/rust/blob/786c143a70ac40e5e028eed6b8efaa54076ce41f/src%2Flibstd%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786c143a70ac40e5e028eed6b8efaa54076ce41f/src%2Flibstd%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialize.rs?ref=786c143a70ac40e5e028eed6b8efaa54076ce41f", "patch": "@@ -0,0 +1,585 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Support code for encoding and decoding types.\n+\n+/*\n+Core encoding and decoding interfaces.\n+*/\n+\n+#[forbid(deprecated_mode)];\n+#[forbid(non_camel_case_types)];\n+\n+pub trait Encoder {\n+    // Primitive types:\n+    fn emit_nil(&self);\n+    fn emit_uint(&self, v: uint);\n+    fn emit_u64(&self, v: u64);\n+    fn emit_u32(&self, v: u32);\n+    fn emit_u16(&self, v: u16);\n+    fn emit_u8(&self, v: u8);\n+    fn emit_int(&self, v: int);\n+    fn emit_i64(&self, v: i64);\n+    fn emit_i32(&self, v: i32);\n+    fn emit_i16(&self, v: i16);\n+    fn emit_i8(&self, v: i8);\n+    fn emit_bool(&self, v: bool);\n+    fn emit_float(&self, v: float);\n+    fn emit_f64(&self, v: f64);\n+    fn emit_f32(&self, v: f32);\n+    fn emit_char(&self, v: char);\n+    fn emit_borrowed_str(&self, v: &str);\n+    fn emit_owned_str(&self, v: &str);\n+    fn emit_managed_str(&self, v: &str);\n+\n+    // Compound types:\n+    fn emit_borrowed(&self, f: fn());\n+    fn emit_owned(&self, f: fn());\n+    fn emit_managed(&self, f: fn());\n+\n+    fn emit_enum(&self, name: &str, f: fn());\n+    fn emit_enum_variant(&self, v_name: &str, v_id: uint, sz: uint, f: fn());\n+    fn emit_enum_variant_arg(&self, idx: uint, f: fn());\n+\n+    fn emit_borrowed_vec(&self, len: uint, f: fn());\n+    fn emit_owned_vec(&self, len: uint, f: fn());\n+    fn emit_managed_vec(&self, len: uint, f: fn());\n+    fn emit_vec_elt(&self, idx: uint, f: fn());\n+\n+    fn emit_rec(&self, f: fn());\n+    fn emit_struct(&self, name: &str, f: fn());\n+    fn emit_field(&self, f_name: &str, f_idx: uint, f: fn());\n+\n+    fn emit_tup(&self, len: uint, f: fn());\n+    fn emit_tup_elt(&self, idx: uint, f: fn());\n+}\n+\n+pub trait Decoder {\n+    // Primitive types:\n+    fn read_nil(&self) -> ();\n+    fn read_uint(&self) -> uint;\n+    fn read_u64(&self) -> u64;\n+    fn read_u32(&self) -> u32;\n+    fn read_u16(&self) -> u16;\n+    fn read_u8(&self) -> u8;\n+    fn read_int(&self) -> int;\n+    fn read_i64(&self) -> i64;\n+    fn read_i32(&self) -> i32;\n+    fn read_i16(&self) -> i16;\n+    fn read_i8(&self) -> i8;\n+    fn read_bool(&self) -> bool;\n+    fn read_f64(&self) -> f64;\n+    fn read_f32(&self) -> f32;\n+    fn read_float(&self) -> float;\n+    fn read_char(&self) -> char;\n+    fn read_owned_str(&self) -> ~str;\n+    fn read_managed_str(&self) -> @str;\n+\n+    // Compound types:\n+    fn read_enum<T>(&self, name: &str, f: fn() -> T) -> T;\n+    fn read_enum_variant<T>(&self, f: fn(uint) -> T) -> T;\n+    fn read_enum_variant_arg<T>(&self, idx: uint, f: fn() -> T) -> T;\n+\n+    fn read_owned<T>(&self, f: fn() -> T) -> T;\n+    fn read_managed<T>(&self, f: fn() -> T) -> T;\n+\n+    fn read_owned_vec<T>(&self, f: fn(uint) -> T) -> T;\n+    fn read_managed_vec<T>(&self, f: fn(uint) -> T) -> T;\n+    fn read_vec_elt<T>(&self, idx: uint, f: fn() -> T) -> T;\n+\n+    fn read_rec<T>(&self, f: fn() -> T) -> T;\n+    fn read_struct<T>(&self, name: &str, f: fn() -> T) -> T;\n+    fn read_field<T>(&self, name: &str, idx: uint, f: fn() -> T) -> T;\n+\n+    fn read_tup<T>(&self, sz: uint, f: fn() -> T) -> T;\n+    fn read_tup_elt<T>(&self, idx: uint, f: fn() -> T) -> T;\n+}\n+\n+pub mod traits {\n+pub trait Encodable<S: Encoder> {\n+    fn encode(&self, s: &S);\n+}\n+\n+pub trait Decodable<D: Decoder> {\n+    static fn decode(&self, d: &D) -> self;\n+}\n+\n+pub impl<S: Encoder> uint: Encodable<S> {\n+    fn encode(&self, s: &S) { s.emit_uint(*self) }\n+}\n+\n+pub impl<D: Decoder> uint: Decodable<D> {\n+    static fn decode(&self, d: &D) -> uint {\n+        d.read_uint()\n+    }\n+}\n+\n+pub impl<S: Encoder> u8: Encodable<S> {\n+    fn encode(&self, s: &S) { s.emit_u8(*self) }\n+}\n+\n+pub impl<D: Decoder> u8: Decodable<D> {\n+    static fn decode(&self, d: &D) -> u8 {\n+        d.read_u8()\n+    }\n+}\n+\n+pub impl<S: Encoder> u16: Encodable<S> {\n+    fn encode(&self, s: &S) { s.emit_u16(*self) }\n+}\n+\n+pub impl<D: Decoder> u16: Decodable<D> {\n+    static fn decode(&self, d: &D) -> u16 {\n+        d.read_u16()\n+    }\n+}\n+\n+pub impl<S: Encoder> u32: Encodable<S> {\n+    fn encode(&self, s: &S) { s.emit_u32(*self) }\n+}\n+\n+pub impl<D: Decoder> u32: Decodable<D> {\n+    static fn decode(&self, d: &D) -> u32 {\n+        d.read_u32()\n+    }\n+}\n+\n+pub impl<S: Encoder> u64: Encodable<S> {\n+    fn encode(&self, s: &S) { s.emit_u64(*self) }\n+}\n+\n+pub impl<D: Decoder> u64: Decodable<D> {\n+    static fn decode(&self, d: &D) -> u64 {\n+        d.read_u64()\n+    }\n+}\n+\n+pub impl<S: Encoder> int: Encodable<S> {\n+    fn encode(&self, s: &S) { s.emit_int(*self) }\n+}\n+\n+pub impl<D: Decoder> int: Decodable<D> {\n+    static fn decode(&self, d: &D) -> int {\n+        d.read_int()\n+    }\n+}\n+\n+pub impl<S: Encoder> i8: Encodable<S> {\n+    fn encode(&self, s: &S) { s.emit_i8(*self) }\n+}\n+\n+pub impl<D: Decoder> i8: Decodable<D> {\n+    static fn decode(&self, d: &D) -> i8 {\n+        d.read_i8()\n+    }\n+}\n+\n+pub impl<S: Encoder> i16: Encodable<S> {\n+    fn encode(&self, s: &S) { s.emit_i16(*self) }\n+}\n+\n+pub impl<D: Decoder> i16: Decodable<D> {\n+    static fn decode(&self, d: &D) -> i16 {\n+        d.read_i16()\n+    }\n+}\n+\n+pub impl<S: Encoder> i32: Encodable<S> {\n+    fn encode(&self, s: &S) { s.emit_i32(*self) }\n+}\n+\n+pub impl<D: Decoder> i32: Decodable<D> {\n+    static fn decode(&self, d: &D) -> i32 {\n+        d.read_i32()\n+    }\n+}\n+\n+pub impl<S: Encoder> i64: Encodable<S> {\n+    fn encode(&self, s: &S) { s.emit_i64(*self) }\n+}\n+\n+pub impl<D: Decoder> i64: Decodable<D> {\n+    static fn decode(&self, d: &D) -> i64 {\n+        d.read_i64()\n+    }\n+}\n+\n+pub impl<S: Encoder> &str: Encodable<S> {\n+    fn encode(&self, s: &S) { s.emit_borrowed_str(*self) }\n+}\n+\n+pub impl<S: Encoder> ~str: Encodable<S> {\n+    fn encode(&self, s: &S) { s.emit_owned_str(*self) }\n+}\n+\n+pub impl<D: Decoder> ~str: Decodable<D> {\n+    static fn decode(&self, d: &D) -> ~str {\n+        d.read_owned_str()\n+    }\n+}\n+\n+pub impl<S: Encoder> @str: Encodable<S> {\n+    fn encode(&self, s: &S) { s.emit_managed_str(*self) }\n+}\n+\n+pub impl<D: Decoder> @str: Decodable<D> {\n+    static fn decode(&self, d: &D) -> @str {\n+        d.read_managed_str()\n+    }\n+}\n+\n+pub impl<S: Encoder> float: Encodable<S> {\n+    fn encode(&self, s: &S) { s.emit_float(*self) }\n+}\n+\n+pub impl<D: Decoder> float: Decodable<D> {\n+    static fn decode(&self, d: &D) -> float {\n+        d.read_float()\n+    }\n+}\n+\n+pub impl<S: Encoder> f32: Encodable<S> {\n+    fn encode(&self, s: &S) { s.emit_f32(*self) }\n+}\n+\n+pub impl<D: Decoder> f32: Decodable<D> {\n+    static fn decode(&self, d: &D) -> f32 {\n+        d.read_f32() }\n+}\n+\n+pub impl<S: Encoder> f64: Encodable<S> {\n+    fn encode(&self, s: &S) { s.emit_f64(*self) }\n+}\n+\n+pub impl<D: Decoder> f64: Decodable<D> {\n+    static fn decode(&self, d: &D) -> f64 {\n+        d.read_f64()\n+    }\n+}\n+\n+pub impl<S: Encoder> bool: Encodable<S> {\n+    fn encode(&self, s: &S) { s.emit_bool(*self) }\n+}\n+\n+pub impl<D: Decoder> bool: Decodable<D> {\n+    static fn decode(&self, d: &D) -> bool {\n+        d.read_bool()\n+    }\n+}\n+\n+pub impl<S: Encoder> (): Encodable<S> {\n+    fn encode(&self, s: &S) { s.emit_nil() }\n+}\n+\n+pub impl<D: Decoder> (): Decodable<D> {\n+    static fn decode(&self, d: &D) -> () {\n+        d.read_nil()\n+    }\n+}\n+\n+pub impl<S: Encoder, T: Encodable<S>> &T: Encodable<S> {\n+    fn encode(&self, s: &S) {\n+        s.emit_borrowed(|| (**self).encode(s))\n+    }\n+}\n+\n+pub impl<S: Encoder, T: Encodable<S>> ~T: Encodable<S> {\n+    fn encode(&self, s: &S) {\n+        s.emit_owned(|| (**self).encode(s))\n+    }\n+}\n+\n+pub impl<D: Decoder, T: Decodable<D>> ~T: Decodable<D> {\n+    static fn decode(&self, d: &D) -> ~T {\n+        d.read_owned(|| ~decode(d))\n+    }\n+}\n+\n+pub impl<S: Encoder, T: Encodable<S>> @T: Encodable<S> {\n+    fn encode(&self, s: &S) {\n+        s.emit_managed(|| (**self).encode(s))\n+    }\n+}\n+\n+pub impl<D: Decoder, T: Decodable<D>> @T: Decodable<D> {\n+    static fn decode(&self, d: &D) -> @T {\n+        d.read_managed(|| @decode(d))\n+    }\n+}\n+\n+pub impl<S: Encoder, T: Encodable<S>> &[T]: Encodable<S> {\n+    fn encode(&self, s: &S) {\n+        do s.emit_borrowed_vec(self.len()) {\n+            for self.eachi |i, e| {\n+                s.emit_vec_elt(i, || e.encode(s))\n+            }\n+        }\n+    }\n+}\n+\n+pub impl<S: Encoder, T: Encodable<S>> ~[T]: Encodable<S> {\n+    fn encode(&self, s: &S) {\n+        do s.emit_owned_vec(self.len()) {\n+            for self.eachi |i, e| {\n+                s.emit_vec_elt(i, || e.encode(s))\n+            }\n+        }\n+    }\n+}\n+\n+pub impl<D: Decoder, T: Decodable<D>> ~[T]: Decodable<D> {\n+    static fn decode(&self, d: &D) -> ~[T] {\n+        do d.read_owned_vec |len| {\n+            do vec::from_fn(len) |i| {\n+                d.read_vec_elt(i, || decode(d))\n+            }\n+        }\n+    }\n+}\n+\n+pub impl<S: Encoder, T: Encodable<S>> @[T]: Encodable<S> {\n+    fn encode(&self, s: &S) {\n+        do s.emit_managed_vec(self.len()) {\n+            for self.eachi |i, e| {\n+                s.emit_vec_elt(i, || e.encode(s))\n+            }\n+        }\n+    }\n+}\n+\n+pub impl<D: Decoder, T: Decodable<D>> @[T]: Decodable<D> {\n+    static fn decode(&self, d: &D) -> @[T] {\n+        do d.read_managed_vec |len| {\n+            do at_vec::from_fn(len) |i| {\n+                d.read_vec_elt(i, || decode(d))\n+            }\n+        }\n+    }\n+}\n+\n+pub impl<S: Encoder, T: Encodable<S>> Option<T>: Encodable<S> {\n+    fn encode(&self, s: &S) {\n+        do s.emit_enum(~\"option\") {\n+            match *self {\n+              None => do s.emit_enum_variant(~\"none\", 0u, 0u) {\n+              },\n+\n+              Some(ref v) => do s.emit_enum_variant(~\"some\", 1u, 1u) {\n+                s.emit_enum_variant_arg(0u, || v.encode(s))\n+              }\n+            }\n+        }\n+    }\n+}\n+\n+pub impl<D: Decoder, T: Decodable<D>> Option<T>: Decodable<D> {\n+    static fn decode(&self, d: &D) -> Option<T> {\n+        do d.read_enum(~\"option\") {\n+            do d.read_enum_variant |i| {\n+                match i {\n+                  0 => None,\n+                  1 => Some(d.read_enum_variant_arg(0u, || decode(d))),\n+                  _ => fail(fmt!(\"Bad variant for option: %u\", i))\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+pub impl<\n+    S: Encoder,\n+    T0: Encodable<S>,\n+    T1: Encodable<S>\n+> (T0, T1): Encodable<S> {\n+    fn encode(&self, s: &S) {\n+        match *self {\n+            (ref t0, ref t1) => {\n+                do s.emit_tup(2) {\n+                    s.emit_tup_elt(0, || t0.encode(s));\n+                    s.emit_tup_elt(1, || t1.encode(s));\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+pub impl<\n+    D: Decoder,\n+    T0: Decodable<D>,\n+    T1: Decodable<D>\n+> (T0, T1): Decodable<D> {\n+    static fn decode(&self, d: &D) -> (T0, T1) {\n+        do d.read_tup(2) {\n+            (\n+                d.read_tup_elt(0, || decode(d)),\n+                d.read_tup_elt(1, || decode(d))\n+            )\n+        }\n+    }\n+}\n+\n+pub impl<\n+    S: Encoder,\n+    T0: Encodable<S>,\n+    T1: Encodable<S>,\n+    T2: Encodable<S>\n+> (T0, T1, T2): Encodable<S> {\n+    fn encode(&self, s: &S) {\n+        match *self {\n+            (ref t0, ref t1, ref t2) => {\n+                do s.emit_tup(3) {\n+                    s.emit_tup_elt(0, || t0.encode(s));\n+                    s.emit_tup_elt(1, || t1.encode(s));\n+                    s.emit_tup_elt(2, || t2.encode(s));\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+pub impl<\n+    D: Decoder,\n+    T0: Decodable<D>,\n+    T1: Decodable<D>,\n+    T2: Decodable<D>\n+> (T0, T1, T2): Decodable<D> {\n+    static fn decode(&self, d: &D) -> (T0, T1, T2) {\n+        do d.read_tup(3) {\n+            (\n+                d.read_tup_elt(0, || decode(d)),\n+                d.read_tup_elt(1, || decode(d)),\n+                d.read_tup_elt(2, || decode(d))\n+            )\n+        }\n+    }\n+}\n+\n+pub impl<\n+    S: Encoder,\n+    T0: Encodable<S>,\n+    T1: Encodable<S>,\n+    T2: Encodable<S>,\n+    T3: Encodable<S>\n+> (T0, T1, T2, T3): Encodable<S> {\n+    fn encode(&self, s: &S) {\n+        match *self {\n+            (ref t0, ref t1, ref t2, ref t3) => {\n+                do s.emit_tup(4) {\n+                    s.emit_tup_elt(0, || t0.encode(s));\n+                    s.emit_tup_elt(1, || t1.encode(s));\n+                    s.emit_tup_elt(2, || t2.encode(s));\n+                    s.emit_tup_elt(3, || t3.encode(s));\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+pub impl<\n+    D: Decoder,\n+    T0: Decodable<D>,\n+    T1: Decodable<D>,\n+    T2: Decodable<D>,\n+    T3: Decodable<D>\n+> (T0, T1, T2, T3): Decodable<D> {\n+    static fn decode(&self, d: &D) -> (T0, T1, T2, T3) {\n+        do d.read_tup(4) {\n+            (\n+                d.read_tup_elt(0, || decode(d)),\n+                d.read_tup_elt(1, || decode(d)),\n+                d.read_tup_elt(2, || decode(d)),\n+                d.read_tup_elt(3, || decode(d))\n+            )\n+        }\n+    }\n+}\n+\n+pub impl<\n+    S: Encoder,\n+    T0: Encodable<S>,\n+    T1: Encodable<S>,\n+    T2: Encodable<S>,\n+    T3: Encodable<S>,\n+    T4: Encodable<S>\n+> (T0, T1, T2, T3, T4): Encodable<S> {\n+    fn encode(&self, s: &S) {\n+        match *self {\n+            (ref t0, ref t1, ref t2, ref t3, ref t4) => {\n+                do s.emit_tup(5) {\n+                    s.emit_tup_elt(0, || t0.encode(s));\n+                    s.emit_tup_elt(1, || t1.encode(s));\n+                    s.emit_tup_elt(2, || t2.encode(s));\n+                    s.emit_tup_elt(3, || t3.encode(s));\n+                    s.emit_tup_elt(4, || t4.encode(s));\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+pub impl<\n+    D: Decoder,\n+    T0: Decodable<D>,\n+    T1: Decodable<D>,\n+    T2: Decodable<D>,\n+    T3: Decodable<D>,\n+    T4: Decodable<D>\n+> (T0, T1, T2, T3, T4): Decodable<D> {\n+    static fn decode(&self, d: &D)\n+      -> (T0, T1, T2, T3, T4) {\n+        do d.read_tup(5) {\n+            (\n+                d.read_tup_elt(0, || decode(d)),\n+                d.read_tup_elt(1, || decode(d)),\n+                d.read_tup_elt(2, || decode(d)),\n+                d.read_tup_elt(3, || decode(d)),\n+                d.read_tup_elt(4, || decode(d))\n+            )\n+        }\n+    }\n+}\n+\n+// ___________________________________________________________________________\n+// Helper routines\n+//\n+// In some cases, these should eventually be coded as traits.\n+\n+pub trait EncoderHelpers {\n+    fn emit_from_vec<T>(&self, v: ~[T], f: fn(v: &T));\n+}\n+\n+pub impl<S: Encoder> S: EncoderHelpers {\n+    fn emit_from_vec<T>(&self, v: ~[T], f: fn(v: &T)) {\n+        do self.emit_owned_vec(v.len()) {\n+            for v.eachi |i, e| {\n+                do self.emit_vec_elt(i) {\n+                    f(e)\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+pub trait DecoderHelpers {\n+    fn read_to_vec<T>(&self, f: fn() -> T) -> ~[T];\n+}\n+\n+pub impl<D: Decoder> D: DecoderHelpers {\n+    fn read_to_vec<T>(&self, f: fn() -> T) -> ~[T] {\n+        do self.read_owned_vec |len| {\n+            do vec::from_fn(len) |i| {\n+                self.read_vec_elt(i, || f())\n+            }\n+        }\n+    }\n+}\n+}\n+\n+pub use serialize::traits::*;"}, {"sha": "65916aa59927432f9082133c9ceb7cb8eb54da5a", "filename": "src/libstd/std.rc", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/786c143a70ac40e5e028eed6b8efaa54076ce41f/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/786c143a70ac40e5e028eed6b8efaa54076ce41f/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=786c143a70ac40e5e028eed6b8efaa54076ce41f", "patch": "@@ -104,13 +104,15 @@ mod unicode;\n // Compiler support modules\n \n pub mod test;\n+pub mod serialize;\n pub mod serialization;\n \n // A curious inner-module that's not exported that contains the binding\n-// 'std' so that macro-expanded references to std::serialization and such\n+// 'std' so that macro-expanded references to std::code and such\n // can be resolved within libcore.\n #[doc(hidden)] // FIXME #3538\n mod std {\n+    pub use serialize;\n     pub use serialization;\n }\n "}, {"sha": "0ff3dbe150613afab24d4ce90d2becc7b69aa2a5", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "added", "additions": 1161, "deletions": 0, "changes": 1161, "blob_url": "https://github.com/rust-lang/rust/blob/786c143a70ac40e5e028eed6b8efaa54076ce41f/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786c143a70ac40e5e028eed6b8efaa54076ce41f/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=786c143a70ac40e5e028eed6b8efaa54076ce41f", "patch": "@@ -0,0 +1,1161 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*\n+\n+The compiler code necessary to implement the #[auto_encode] and\n+#[auto_decode] extension.  The idea here is that type-defining items may\n+be tagged with #[auto_encode] and #[auto_decode], which will cause\n+us to generate a little companion module with the same name as the item.\n+\n+For example, a type like:\n+\n+    #[auto_encode]\n+    #[auto_decode]\n+    struct Node {id: uint}\n+\n+would generate two implementations like:\n+\n+    impl<S: Encoder> node_id: Encodable<S> {\n+        fn encode(s: &S) {\n+            do s.emit_struct(\"Node\") {\n+                s.emit_field(\"id\", 0, || s.emit_uint(self))\n+            }\n+        }\n+    }\n+\n+    impl<D: Decoder> node_id: Decodable {\n+        static fn decode(d: &D) -> Node {\n+            do d.read_struct(\"Node\") {\n+                Node {\n+                    id: d.read_field(~\"x\", 0, || decode(d))\n+                }\n+            }\n+        }\n+    }\n+\n+Other interesting scenarios are whe the item has type parameters or\n+references other non-built-in types.  A type definition like:\n+\n+    #[auto_encode]\n+    #[auto_decode]\n+    type spanned<T> = {node: T, span: span};\n+\n+would yield functions like:\n+\n+    impl<\n+        S: Encoder,\n+        T: Encodable<S>\n+    > spanned<T>: Encodable<S> {\n+        fn encode<S: Encoder>(s: &S) {\n+            do s.emit_rec {\n+                s.emit_field(\"node\", 0, || self.node.encode(s));\n+                s.emit_field(\"span\", 1, || self.span.encode(s));\n+            }\n+        }\n+    }\n+\n+    impl<\n+        D: Decoder,\n+        T: Decodable<D>\n+    > spanned<T>: Decodable<D> {\n+        static fn decode(d: &D) -> spanned<T> {\n+            do d.read_rec {\n+                {\n+                    node: d.read_field(~\"node\", 0, || decode(d)),\n+                    span: d.read_field(~\"span\", 1, || decode(d)),\n+                }\n+            }\n+        }\n+    }\n+\n+FIXME (#2810)--Hygiene. Search for \"__\" strings.  We also assume \"std\" is the\n+standard library.\n+\n+Misc notes:\n+-----------\n+\n+I use move mode arguments for ast nodes that will get inserted as is\n+into the tree.  This is intended to prevent us from inserting the same\n+node twice.\n+\n+*/\n+\n+use ext::base::*;\n+use codemap::span;\n+use std::map;\n+use std::map::HashMap;\n+\n+export expand_auto_encode;\n+export expand_auto_decode;\n+\n+// Transitional reexports so qquote can find the paths it is looking for\n+mod syntax {\n+    pub use ext;\n+    pub use parse;\n+}\n+\n+fn expand_auto_encode(\n+    cx: ext_ctxt,\n+    span: span,\n+    _mitem: ast::meta_item,\n+    in_items: ~[@ast::item]\n+) -> ~[@ast::item] {\n+    fn is_auto_encode(a: &ast::attribute) -> bool {\n+        attr::get_attr_name(*a) == ~\"auto_encode\"\n+    }\n+\n+    fn filter_attrs(item: @ast::item) -> @ast::item {\n+        @{attrs: vec::filter(item.attrs, |a| !is_auto_encode(a)),\n+          .. *item}\n+    }\n+\n+    do vec::flat_map(in_items) |item| {\n+        if item.attrs.any(is_auto_encode) {\n+            match item.node {\n+                ast::item_ty(@{node: ast::ty_rec(ref fields), _}, tps) => {\n+                    let ser_impl = mk_rec_ser_impl(\n+                        cx,\n+                        item.span,\n+                        item.ident,\n+                        (*fields),\n+                        tps\n+                    );\n+\n+                    ~[filter_attrs(*item), ser_impl]\n+                },\n+                ast::item_struct(@{ fields, _}, tps) => {\n+                    let ser_impl = mk_struct_ser_impl(\n+                        cx,\n+                        item.span,\n+                        item.ident,\n+                        fields,\n+                        tps\n+                    );\n+\n+                    ~[filter_attrs(*item), ser_impl]\n+                },\n+                ast::item_enum(ref enum_def, tps) => {\n+                    let ser_impl = mk_enum_ser_impl(\n+                        cx,\n+                        item.span,\n+                        item.ident,\n+                        (*enum_def),\n+                        tps\n+                    );\n+\n+                    ~[filter_attrs(*item), ser_impl]\n+                },\n+                _ => {\n+                    cx.span_err(span, ~\"#[auto_encode] can only be \\\n+                                        applied to structs, record types, \\\n+                                        and enum definitions\");\n+                    ~[*item]\n+                }\n+            }\n+        } else {\n+            ~[*item]\n+        }\n+    }\n+}\n+\n+fn expand_auto_decode(\n+    cx: ext_ctxt,\n+    span: span,\n+    _mitem: ast::meta_item,\n+    in_items: ~[@ast::item]\n+) -> ~[@ast::item] {\n+    fn is_auto_decode(a: &ast::attribute) -> bool {\n+        attr::get_attr_name(*a) == ~\"auto_decode\"\n+    }\n+\n+    fn filter_attrs(item: @ast::item) -> @ast::item {\n+        @{attrs: vec::filter(item.attrs, |a| !is_auto_decode(a)),\n+          .. *item}\n+    }\n+\n+    do vec::flat_map(in_items) |item| {\n+        if item.attrs.any(is_auto_decode) {\n+            match item.node {\n+                ast::item_ty(@{node: ast::ty_rec(ref fields), _}, tps) => {\n+                    let deser_impl = mk_rec_deser_impl(\n+                        cx,\n+                        item.span,\n+                        item.ident,\n+                        (*fields),\n+                        tps\n+                    );\n+\n+                    ~[filter_attrs(*item), deser_impl]\n+                },\n+                ast::item_struct(@{ fields, _}, tps) => {\n+                    let deser_impl = mk_struct_deser_impl(\n+                        cx,\n+                        item.span,\n+                        item.ident,\n+                        fields,\n+                        tps\n+                    );\n+\n+                    ~[filter_attrs(*item), deser_impl]\n+                },\n+                ast::item_enum(ref enum_def, tps) => {\n+                    let deser_impl = mk_enum_deser_impl(\n+                        cx,\n+                        item.span,\n+                        item.ident,\n+                        (*enum_def),\n+                        tps\n+                    );\n+\n+                    ~[filter_attrs(*item), deser_impl]\n+                },\n+                _ => {\n+                    cx.span_err(span, ~\"#[auto_decode] can only be \\\n+                                        applied to structs, record types, \\\n+                                        and enum definitions\");\n+                    ~[*item]\n+                }\n+            }\n+        } else {\n+            ~[*item]\n+        }\n+    }\n+}\n+\n+priv impl ext_ctxt {\n+    fn bind_path(\n+        span: span,\n+        ident: ast::ident,\n+        path: @ast::path,\n+        bounds: @~[ast::ty_param_bound]\n+    ) -> ast::ty_param {\n+        let bound = ast::ty_param_bound(@{\n+            id: self.next_id(),\n+            node: ast::ty_path(path, self.next_id()),\n+            span: span,\n+        });\n+\n+        {\n+            ident: ident,\n+            id: self.next_id(),\n+            bounds: @vec::append(~[bound], *bounds)\n+        }\n+    }\n+\n+    fn expr(span: span, node: ast::expr_) -> @ast::expr {\n+        @{id: self.next_id(), callee_id: self.next_id(),\n+          node: node, span: span}\n+    }\n+\n+    fn path(span: span, strs: ~[ast::ident]) -> @ast::path {\n+        @{span: span, global: false, idents: strs, rp: None, types: ~[]}\n+    }\n+\n+    fn path_tps(span: span, strs: ~[ast::ident],\n+                tps: ~[@ast::Ty]) -> @ast::path {\n+        @{span: span, global: false, idents: strs, rp: None, types: tps}\n+    }\n+\n+    fn ty_path(span: span, strs: ~[ast::ident],\n+               tps: ~[@ast::Ty]) -> @ast::Ty {\n+        @{id: self.next_id(),\n+          node: ast::ty_path(self.path_tps(span, strs, tps), self.next_id()),\n+          span: span}\n+    }\n+\n+    fn binder_pat(span: span, nm: ast::ident) -> @ast::pat {\n+        let path = @{span: span, global: false, idents: ~[nm],\n+                     rp: None, types: ~[]};\n+        @{id: self.next_id(),\n+          node: ast::pat_ident(ast::bind_by_ref(ast::m_imm),\n+                               path,\n+                               None),\n+          span: span}\n+    }\n+\n+    fn stmt(expr: @ast::expr) -> @ast::stmt {\n+        @{node: ast::stmt_semi(expr, self.next_id()),\n+          span: expr.span}\n+    }\n+\n+    fn lit_str(span: span, s: @~str) -> @ast::expr {\n+        self.expr(\n+            span,\n+            ast::expr_vstore(\n+                self.expr(\n+                    span,\n+                    ast::expr_lit(\n+                        @{node: ast::lit_str(s),\n+                          span: span})),\n+                ast::expr_vstore_uniq))\n+    }\n+\n+    fn lit_uint(span: span, i: uint) -> @ast::expr {\n+        self.expr(\n+            span,\n+            ast::expr_lit(\n+                @{node: ast::lit_uint(i as u64, ast::ty_u),\n+                  span: span}))\n+    }\n+\n+    fn lambda(blk: ast::blk) -> @ast::expr {\n+        let ext_cx = self;\n+        let blk_e = self.expr(blk.span, ast::expr_block(blk));\n+        quote_expr!( || $blk_e )\n+    }\n+\n+    fn blk(span: span, stmts: ~[@ast::stmt]) -> ast::blk {\n+        {node: {view_items: ~[],\n+                stmts: stmts,\n+                expr: None,\n+                id: self.next_id(),\n+                rules: ast::default_blk},\n+         span: span}\n+    }\n+\n+    fn expr_blk(expr: @ast::expr) -> ast::blk {\n+        {node: {view_items: ~[],\n+                stmts: ~[],\n+                expr: Some(expr),\n+                id: self.next_id(),\n+                rules: ast::default_blk},\n+         span: expr.span}\n+    }\n+\n+    fn expr_path(span: span, strs: ~[ast::ident]) -> @ast::expr {\n+        self.expr(span, ast::expr_path(self.path(span, strs)))\n+    }\n+\n+    fn expr_var(span: span, var: ~str) -> @ast::expr {\n+        self.expr_path(span, ~[self.ident_of(var)])\n+    }\n+\n+    fn expr_field(\n+        span: span,\n+        expr: @ast::expr,\n+        ident: ast::ident\n+    ) -> @ast::expr {\n+        self.expr(span, ast::expr_field(expr, ident, ~[]))\n+    }\n+\n+    fn expr_call(\n+        span: span,\n+        expr: @ast::expr,\n+        args: ~[@ast::expr]\n+    ) -> @ast::expr {\n+        self.expr(span, ast::expr_call(expr, args, false))\n+    }\n+\n+    fn lambda_expr(expr: @ast::expr) -> @ast::expr {\n+        self.lambda(self.expr_blk(expr))\n+    }\n+\n+    fn lambda_stmts(span: span, stmts: ~[@ast::stmt]) -> @ast::expr {\n+        self.lambda(self.blk(span, stmts))\n+    }\n+}\n+\n+fn mk_impl(\n+    cx: ext_ctxt,\n+    span: span,\n+    ident: ast::ident,\n+    ty_param: ast::ty_param,\n+    path: @ast::path,\n+    tps: ~[ast::ty_param],\n+    f: fn(@ast::Ty) -> @ast::method\n+) -> @ast::item {\n+    // All the type parameters need to bound to the trait.\n+    let mut trait_tps = vec::append(\n+        ~[ty_param],\n+         do tps.map |tp| {\n+            let t_bound = ast::ty_param_bound(@{\n+                id: cx.next_id(),\n+                node: ast::ty_path(path, cx.next_id()),\n+                span: span,\n+            });\n+\n+            {\n+                ident: tp.ident,\n+                id: cx.next_id(),\n+                bounds: @vec::append(~[t_bound], *tp.bounds)\n+            }\n+        }\n+    );\n+\n+    let opt_trait = Some(@{\n+        path: path,\n+        ref_id: cx.next_id(),\n+    });\n+\n+    let ty = cx.ty_path(\n+        span,\n+        ~[ident],\n+        tps.map(|tp| cx.ty_path(span, ~[tp.ident], ~[]))\n+    );\n+\n+    @{\n+        // This is a new-style impl declaration.\n+        // XXX: clownshoes\n+        ident: ast::token::special_idents::clownshoes_extensions,\n+        attrs: ~[],\n+        id: cx.next_id(),\n+        node: ast::item_impl(trait_tps, opt_trait, ty, ~[f(ty)]),\n+        vis: ast::public,\n+        span: span,\n+    }\n+}\n+\n+fn mk_ser_impl(\n+    cx: ext_ctxt,\n+    span: span,\n+    ident: ast::ident,\n+    tps: ~[ast::ty_param],\n+    body: @ast::expr\n+) -> @ast::item {\n+    // Make a path to the std::serialize::Encodable typaram.\n+    let ty_param = cx.bind_path(\n+        span,\n+        cx.ident_of(~\"__S\"),\n+        cx.path(\n+            span,\n+            ~[\n+                cx.ident_of(~\"std\"),\n+                cx.ident_of(~\"serialize\"),\n+                cx.ident_of(~\"Encoder\"),\n+            ]\n+        ),\n+        @~[]\n+    );\n+\n+    // Make a path to the std::serialize::Encodable trait.\n+    let path = cx.path_tps(\n+        span,\n+        ~[\n+            cx.ident_of(~\"std\"),\n+            cx.ident_of(~\"serialize\"),\n+            cx.ident_of(~\"Encodable\"),\n+        ],\n+        ~[cx.ty_path(span, ~[cx.ident_of(~\"__S\")], ~[])]\n+    );\n+\n+    mk_impl(\n+        cx,\n+        span,\n+        ident,\n+        ty_param,\n+        path,\n+        tps,\n+        |_ty| mk_ser_method(cx, span, cx.expr_blk(body))\n+    )\n+}\n+\n+fn mk_deser_impl(\n+    cx: ext_ctxt,\n+    span: span,\n+    ident: ast::ident,\n+    tps: ~[ast::ty_param],\n+    body: @ast::expr\n+) -> @ast::item {\n+    // Make a path to the std::serialize::Decodable typaram.\n+    let ty_param = cx.bind_path(\n+        span,\n+        cx.ident_of(~\"__D\"),\n+        cx.path(\n+            span,\n+            ~[\n+                cx.ident_of(~\"std\"),\n+                cx.ident_of(~\"serialize\"),\n+                cx.ident_of(~\"Decoder\"),\n+            ]\n+        ),\n+        @~[]\n+    );\n+\n+    // Make a path to the std::serialize::Decodable trait.\n+    let path = cx.path_tps(\n+        span,\n+        ~[\n+            cx.ident_of(~\"std\"),\n+            cx.ident_of(~\"serialize\"),\n+            cx.ident_of(~\"Decodable\"),\n+        ],\n+        ~[cx.ty_path(span, ~[cx.ident_of(~\"__D\")], ~[])]\n+    );\n+\n+    mk_impl(\n+        cx,\n+        span,\n+        ident,\n+        ty_param,\n+        path,\n+        tps,\n+        |ty| mk_deser_method(cx, span, ty, cx.expr_blk(body))\n+    )\n+}\n+\n+fn mk_ser_method(\n+    cx: ext_ctxt,\n+    span: span,\n+    ser_body: ast::blk\n+) -> @ast::method {\n+    let ty_s = @{\n+        id: cx.next_id(),\n+        node: ast::ty_rptr(\n+            @{\n+                id: cx.next_id(),\n+                node: ast::re_anon,\n+            },\n+            {\n+                ty: cx.ty_path(span, ~[cx.ident_of(~\"__S\")], ~[]),\n+                mutbl: ast::m_imm\n+            }\n+        ),\n+        span: span,\n+    };\n+\n+    let ser_inputs = ~[{\n+        mode: ast::infer(cx.next_id()),\n+        ty: ty_s,\n+        pat: @{id: cx.next_id(),\n+               node: ast::pat_ident(\n+                    ast::bind_by_value,\n+                    ast_util::ident_to_path(span, cx.ident_of(~\"__s\")),\n+                    None),\n+               span: span},\n+        id: cx.next_id(),\n+    }];\n+\n+    let ser_output = @{\n+        id: cx.next_id(),\n+        node: ast::ty_nil,\n+        span: span,\n+    };\n+\n+    let ser_decl = {\n+        inputs: ser_inputs,\n+        output: ser_output,\n+        cf: ast::return_val,\n+    };\n+\n+    @{\n+        ident: cx.ident_of(~\"encode\"),\n+        attrs: ~[],\n+        tps: ~[],\n+        self_ty: { node: ast::sty_region(ast::m_imm), span: span },\n+        purity: ast::impure_fn,\n+        decl: ser_decl,\n+        body: ser_body,\n+        id: cx.next_id(),\n+        span: span,\n+        self_id: cx.next_id(),\n+        vis: ast::public,\n+    }\n+}\n+\n+fn mk_deser_method(\n+    cx: ext_ctxt,\n+    span: span,\n+    ty: @ast::Ty,\n+    deser_body: ast::blk\n+) -> @ast::method {\n+    let ty_d = @{\n+        id: cx.next_id(),\n+        node: ast::ty_rptr(\n+            @{\n+                id: cx.next_id(),\n+                node: ast::re_anon,\n+            },\n+            {\n+                ty: cx.ty_path(span, ~[cx.ident_of(~\"__D\")], ~[]),\n+                mutbl: ast::m_imm\n+            }\n+        ),\n+        span: span,\n+    };\n+\n+    let deser_inputs = ~[{\n+        mode: ast::infer(cx.next_id()),\n+        ty: ty_d,\n+        pat: @{id: cx.next_id(),\n+               node: ast::pat_ident(\n+                    ast::bind_by_value,\n+                    ast_util::ident_to_path(span, cx.ident_of(~\"__d\")),\n+                    None),\n+               span: span},\n+        id: cx.next_id(),\n+    }];\n+\n+    let deser_decl = {\n+        inputs: deser_inputs,\n+        output: ty,\n+        cf: ast::return_val,\n+    };\n+\n+    @{\n+        ident: cx.ident_of(~\"decode\"),\n+        attrs: ~[],\n+        tps: ~[],\n+        self_ty: { node: ast::sty_static, span: span },\n+        purity: ast::impure_fn,\n+        decl: deser_decl,\n+        body: deser_body,\n+        id: cx.next_id(),\n+        span: span,\n+        self_id: cx.next_id(),\n+        vis: ast::public,\n+    }\n+}\n+\n+fn mk_rec_ser_impl(\n+    cx: ext_ctxt,\n+    span: span,\n+    ident: ast::ident,\n+    fields: ~[ast::ty_field],\n+    tps: ~[ast::ty_param]\n+) -> @ast::item {\n+    let fields = mk_ser_fields(cx, span, mk_rec_fields(fields));\n+\n+    // ast for `__s.emit_rec(|| $(fields))`\n+    let body = cx.expr_call(\n+        span,\n+        cx.expr_field(\n+            span,\n+            cx.expr_var(span, ~\"__s\"),\n+            cx.ident_of(~\"emit_rec\")\n+        ),\n+        ~[cx.lambda_stmts(span, fields)]\n+    );\n+\n+    mk_ser_impl(cx, span, ident, tps, body)\n+}\n+\n+fn mk_rec_deser_impl(\n+    cx: ext_ctxt,\n+    span: span,\n+    ident: ast::ident,\n+    fields: ~[ast::ty_field],\n+    tps: ~[ast::ty_param]\n+) -> @ast::item {\n+    let fields = mk_deser_fields(cx, span, mk_rec_fields(fields));\n+\n+    // ast for `read_rec(|| $(fields))`\n+    let body = cx.expr_call(\n+        span,\n+        cx.expr_field(\n+            span,\n+            cx.expr_var(span, ~\"__d\"),\n+            cx.ident_of(~\"read_rec\")\n+        ),\n+        ~[\n+            cx.lambda_expr(\n+                cx.expr(\n+                    span,\n+                    ast::expr_rec(fields, None)\n+                )\n+            )\n+        ]\n+    );\n+\n+    mk_deser_impl(cx, span, ident, tps, body)\n+}\n+\n+fn mk_struct_ser_impl(\n+    cx: ext_ctxt,\n+    span: span,\n+    ident: ast::ident,\n+    fields: ~[@ast::struct_field],\n+    tps: ~[ast::ty_param]\n+) -> @ast::item {\n+    let fields = mk_ser_fields(cx, span, mk_struct_fields(fields));\n+\n+    // ast for `__s.emit_struct($(name), || $(fields))`\n+    let ser_body = cx.expr_call(\n+        span,\n+        cx.expr_field(\n+            span,\n+            cx.expr_var(span, ~\"__s\"),\n+            cx.ident_of(~\"emit_struct\")\n+        ),\n+        ~[\n+            cx.lit_str(span, @cx.str_of(ident)),\n+            cx.lambda_stmts(span, fields),\n+        ]\n+    );\n+\n+    mk_ser_impl(cx, span, ident, tps, ser_body)\n+}\n+\n+fn mk_struct_deser_impl(\n+    cx: ext_ctxt,\n+    span: span,\n+    ident: ast::ident,\n+    fields: ~[@ast::struct_field],\n+    tps: ~[ast::ty_param]\n+) -> @ast::item {\n+    let fields = mk_deser_fields(cx, span, mk_struct_fields(fields));\n+\n+    // ast for `read_struct($(name), || $(fields))`\n+    let body = cx.expr_call(\n+        span,\n+        cx.expr_field(\n+            span,\n+            cx.expr_var(span, ~\"__d\"),\n+            cx.ident_of(~\"read_struct\")\n+        ),\n+        ~[\n+            cx.lit_str(span, @cx.str_of(ident)),\n+            cx.lambda_expr(\n+                cx.expr(\n+                    span,\n+                    ast::expr_struct(\n+                        cx.path(span, ~[ident]),\n+                        fields,\n+                        None\n+                    )\n+                )\n+            ),\n+        ]\n+    );\n+\n+    mk_deser_impl(cx, span, ident, tps, body)\n+}\n+\n+// Records and structs don't have the same fields types, but they share enough\n+// that if we extract the right subfields out we can share the code\n+// generator code.\n+type field = { span: span, ident: ast::ident, mutbl: ast::mutability };\n+\n+fn mk_rec_fields(fields: ~[ast::ty_field]) -> ~[field] {\n+    do fields.map |field| {\n+        {\n+            span: field.span,\n+            ident: field.node.ident,\n+            mutbl: field.node.mt.mutbl,\n+        }\n+    }\n+}\n+\n+fn mk_struct_fields(fields: ~[@ast::struct_field]) -> ~[field] {\n+    do fields.map |field| {\n+        let (ident, mutbl) = match field.node.kind {\n+            ast::named_field(ident, mutbl, _) => (ident, mutbl),\n+            _ => fail ~\"[auto_encode] does not support \\\n+                        unnamed fields\",\n+        };\n+\n+        {\n+            span: field.span,\n+            ident: ident,\n+            mutbl: match mutbl {\n+                ast::struct_mutable => ast::m_mutbl,\n+                ast::struct_immutable => ast::m_imm,\n+            },\n+        }\n+    }\n+}\n+\n+fn mk_ser_fields(\n+    cx: ext_ctxt,\n+    span: span,\n+    fields: ~[field]\n+) -> ~[@ast::stmt] {\n+    do fields.mapi |idx, field| {\n+        // ast for `|| self.$(name).encode(__s)`\n+        let expr_lambda = cx.lambda_expr(\n+            cx.expr_call(\n+                span,\n+                cx.expr_field(\n+                    span,\n+                    cx.expr_field(\n+                        span,\n+                        cx.expr_var(span, ~\"self\"),\n+                        field.ident\n+                    ),\n+                    cx.ident_of(~\"encode\")\n+                ),\n+                ~[cx.expr_var(span, ~\"__s\")]\n+            )\n+        );\n+\n+        // ast for `__s.emit_field($(name), $(idx), $(expr_lambda))`\n+        cx.stmt(\n+            cx.expr_call(\n+                span,\n+                cx.expr_field(\n+                    span,\n+                    cx.expr_var(span, ~\"__s\"),\n+                    cx.ident_of(~\"emit_field\")\n+                ),\n+                ~[\n+                    cx.lit_str(span, @cx.str_of(field.ident)),\n+                    cx.lit_uint(span, idx),\n+                    expr_lambda,\n+                ]\n+            )\n+        )\n+    }\n+}\n+\n+fn mk_deser_fields(\n+    cx: ext_ctxt,\n+    span: span,\n+    fields: ~[{ span: span, ident: ast::ident, mutbl: ast::mutability }]\n+) -> ~[ast::field] {\n+    do fields.mapi |idx, field| {\n+        // ast for `|| std::serialize::decode(__d)`\n+        let expr_lambda = cx.lambda(\n+            cx.expr_blk(\n+                cx.expr_call(\n+                    span,\n+                    cx.expr_path(span, ~[\n+                        cx.ident_of(~\"std\"),\n+                        cx.ident_of(~\"serialize\"),\n+                        cx.ident_of(~\"decode\"),\n+                    ]),\n+                    ~[cx.expr_var(span, ~\"__d\")]\n+                )\n+            )\n+        );\n+\n+        // ast for `__d.read_field($(name), $(idx), $(expr_lambda))`\n+        let expr: @ast::expr = cx.expr_call(\n+            span,\n+            cx.expr_field(\n+                span,\n+                cx.expr_var(span, ~\"__d\"),\n+                cx.ident_of(~\"read_field\")\n+            ),\n+            ~[\n+                cx.lit_str(span, @cx.str_of(field.ident)),\n+                cx.lit_uint(span, idx),\n+                expr_lambda,\n+            ]\n+        );\n+\n+        {\n+            node: { mutbl: field.mutbl, ident: field.ident, expr: expr },\n+            span: span,\n+        }\n+    }\n+}\n+\n+fn mk_enum_ser_impl(\n+    cx: ext_ctxt,\n+    span: span,\n+    ident: ast::ident,\n+    enum_def: ast::enum_def,\n+    tps: ~[ast::ty_param]\n+) -> @ast::item {\n+    let body = mk_enum_ser_body(\n+        cx,\n+        span,\n+        ident,\n+        enum_def.variants\n+    );\n+\n+    mk_ser_impl(cx, span, ident, tps, body)\n+}\n+\n+fn mk_enum_deser_impl(\n+    cx: ext_ctxt,\n+    span: span,\n+    ident: ast::ident,\n+    enum_def: ast::enum_def,\n+    tps: ~[ast::ty_param]\n+) -> @ast::item {\n+    let body = mk_enum_deser_body(\n+        cx,\n+        span,\n+        ident,\n+        enum_def.variants\n+    );\n+\n+    mk_deser_impl(cx, span, ident, tps, body)\n+}\n+\n+fn ser_variant(\n+    cx: ext_ctxt,\n+    span: span,\n+    v_name: ast::ident,\n+    v_idx: uint,\n+    args: ~[ast::variant_arg]\n+) -> ast::arm {\n+    // Name the variant arguments.\n+    let names = args.mapi(|i, _arg| cx.ident_of(fmt!(\"__v%u\", i)));\n+\n+    // Bind the names to the variant argument type.\n+    let pats = args.mapi(|i, arg| cx.binder_pat(arg.ty.span, names[i]));\n+\n+    let pat_node = if pats.is_empty() {\n+        ast::pat_ident(\n+            ast::bind_by_ref(ast::m_imm),\n+            cx.path(span, ~[v_name]),\n+            None\n+        )\n+    } else {\n+        ast::pat_enum(\n+            cx.path(span, ~[v_name]),\n+            Some(pats)\n+        )\n+    };\n+\n+    let pat = @{\n+        id: cx.next_id(),\n+        node: pat_node,\n+        span: span,\n+    };\n+\n+    let stmts = do args.mapi |a_idx, _arg| {\n+        // ast for `__s.emit_enum_variant_arg`\n+        let expr_emit = cx.expr_field(\n+            span,\n+            cx.expr_var(span, ~\"__s\"),\n+            cx.ident_of(~\"emit_enum_variant_arg\")\n+        );\n+\n+        // ast for `|| $(v).encode(__s)`\n+        let expr_encode = cx.lambda_expr(\n+             cx.expr_call(\n+                span,\n+                cx.expr_field(\n+                    span,\n+                    cx.expr_path(span, ~[names[a_idx]]),\n+                    cx.ident_of(~\"encode\")\n+                ),\n+                ~[cx.expr_var(span, ~\"__s\")]\n+            )\n+        );\n+\n+        // ast for `$(expr_emit)($(a_idx), $(expr_encode))`\n+        cx.stmt(\n+            cx.expr_call(\n+                span,\n+                expr_emit,\n+                ~[cx.lit_uint(span, a_idx), expr_encode]\n+            )\n+        )\n+    };\n+\n+    // ast for `__s.emit_enum_variant($(name), $(idx), $(sz), $(lambda))`\n+    let body = cx.expr_call(\n+        span,\n+        cx.expr_field(\n+            span,\n+            cx.expr_var(span, ~\"__s\"),\n+            cx.ident_of(~\"emit_enum_variant\")\n+        ),\n+        ~[\n+            cx.lit_str(span, @cx.str_of(v_name)),\n+            cx.lit_uint(span, v_idx),\n+            cx.lit_uint(span, stmts.len()),\n+            cx.lambda_stmts(span, stmts),\n+        ]\n+    );\n+\n+    { pats: ~[pat], guard: None, body: cx.expr_blk(body) }\n+}\n+\n+fn mk_enum_ser_body(\n+    cx: ext_ctxt,\n+    span: span,\n+    name: ast::ident,\n+    variants: ~[ast::variant]\n+) -> @ast::expr {\n+    let arms = do variants.mapi |v_idx, variant| {\n+        match variant.node.kind {\n+            ast::tuple_variant_kind(args) =>\n+                ser_variant(cx, span, variant.node.name, v_idx, args),\n+            ast::struct_variant_kind(*) =>\n+                fail ~\"struct variants unimplemented\",\n+            ast::enum_variant_kind(*) =>\n+                fail ~\"enum variants unimplemented\",\n+        }\n+    };\n+\n+    // ast for `match *self { $(arms) }`\n+    let match_expr = cx.expr(\n+        span,\n+        ast::expr_match(\n+            cx.expr(\n+                span,\n+                ast::expr_unary(ast::deref, cx.expr_var(span, ~\"self\"))\n+            ),\n+            arms\n+        )\n+    );\n+\n+    // ast for `__s.emit_enum($(name), || $(match_expr))`\n+    cx.expr_call(\n+        span,\n+        cx.expr_field(\n+            span,\n+            cx.expr_var(span, ~\"__s\"),\n+            cx.ident_of(~\"emit_enum\")\n+        ),\n+        ~[\n+            cx.lit_str(span, @cx.str_of(name)),\n+            cx.lambda_expr(match_expr),\n+        ]\n+    )\n+}\n+\n+fn mk_enum_deser_variant_nary(\n+    cx: ext_ctxt,\n+    span: span,\n+    name: ast::ident,\n+    args: ~[ast::variant_arg]\n+) -> @ast::expr {\n+    let args = do args.mapi |idx, _arg| {\n+        // ast for `|| std::serialize::decode(__d)`\n+        let expr_lambda = cx.lambda_expr(\n+            cx.expr_call(\n+                span,\n+                cx.expr_path(span, ~[\n+                    cx.ident_of(~\"std\"),\n+                    cx.ident_of(~\"serialize\"),\n+                    cx.ident_of(~\"decode\"),\n+                ]),\n+                ~[cx.expr_var(span, ~\"__d\")]\n+            )\n+        );\n+\n+        // ast for `__d.read_enum_variant_arg($(a_idx), $(expr_lambda))`\n+        cx.expr_call(\n+            span,\n+            cx.expr_field(\n+                span,\n+                cx.expr_var(span, ~\"__d\"),\n+                cx.ident_of(~\"read_enum_variant_arg\")\n+            ),\n+            ~[cx.lit_uint(span, idx), expr_lambda]\n+        )\n+    };\n+\n+    // ast for `$(name)($(args))`\n+    cx.expr_call(span, cx.expr_path(span, ~[name]), args)\n+}\n+\n+fn mk_enum_deser_body(\n+    cx: ext_ctxt,\n+    span: span,\n+    name: ast::ident,\n+    variants: ~[ast::variant]\n+) -> @ast::expr {\n+    let mut arms = do variants.mapi |v_idx, variant| {\n+        let body = match variant.node.kind {\n+            ast::tuple_variant_kind(args) => {\n+                if args.is_empty() {\n+                    // for a nullary variant v, do \"v\"\n+                    cx.expr_path(span, ~[variant.node.name])\n+                } else {\n+                    // for an n-ary variant v, do \"v(a_1, ..., a_n)\"\n+                    mk_enum_deser_variant_nary(\n+                        cx,\n+                        span,\n+                        variant.node.name,\n+                        args\n+                    )\n+                }\n+            },\n+            ast::struct_variant_kind(*) =>\n+                fail ~\"struct variants unimplemented\",\n+            ast::enum_variant_kind(*) =>\n+                fail ~\"enum variants unimplemented\",\n+        };\n+\n+        let pat = @{\n+            id: cx.next_id(),\n+            node: ast::pat_lit(cx.lit_uint(span, v_idx)),\n+            span: span,\n+        };\n+\n+        {\n+            pats: ~[pat],\n+            guard: None,\n+            body: cx.expr_blk(body),\n+        }\n+    };\n+\n+    let impossible_case = {\n+        pats: ~[@{ id: cx.next_id(), node: ast::pat_wild, span: span}],\n+        guard: None,\n+\n+        // FIXME(#3198): proper error message\n+        body: cx.expr_blk(cx.expr(span, ast::expr_fail(None))),\n+    };\n+\n+    arms.push(impossible_case);\n+\n+    // ast for `|i| { match i { $(arms) } }`\n+    let expr_lambda = cx.expr(\n+        span,\n+        ast::expr_fn_block(\n+            {\n+                inputs: ~[{\n+                    mode: ast::infer(cx.next_id()),\n+                    ty: @{\n+                        id: cx.next_id(),\n+                        node: ast::ty_infer,\n+                        span: span\n+                    },\n+                    pat: @{id: cx.next_id(),\n+                           node: ast::pat_ident(\n+                                ast::bind_by_value,\n+                                ast_util::ident_to_path(span,\n+                                                        cx.ident_of(~\"i\")),\n+                                None),\n+                           span: span},\n+                    id: cx.next_id(),\n+                }],\n+                output: @{\n+                    id: cx.next_id(),\n+                    node: ast::ty_infer,\n+                    span: span,\n+                },\n+                cf: ast::return_val,\n+            },\n+            cx.expr_blk(\n+                cx.expr(\n+                    span,\n+                    ast::expr_match(cx.expr_var(span, ~\"i\"), arms)\n+                )\n+            ),\n+            @~[]\n+        )\n+    );\n+\n+    // ast for `__d.read_enum_variant($(expr_lambda))`\n+    let expr_lambda = cx.lambda_expr(\n+        cx.expr_call(\n+            span,\n+            cx.expr_field(\n+                span,\n+                cx.expr_var(span, ~\"__d\"),\n+                cx.ident_of(~\"read_enum_variant\")\n+            ),\n+            ~[expr_lambda]\n+        )\n+    );\n+\n+    // ast for `__d.read_enum($(e_name), $(expr_lambda))`\n+    cx.expr_call(\n+        span,\n+        cx.expr_field(\n+            span,\n+            cx.expr_var(span, ~\"__d\"),\n+            cx.ident_of(~\"read_enum\")\n+        ),\n+        ~[\n+            cx.lit_str(span, @cx.str_of(name)),\n+            expr_lambda\n+        ]\n+    )\n+}"}, {"sha": "4c1725b10000c6acaa343369a1c7eb03d449f4db", "filename": "src/libsyntax/ext/auto_serialize.rs", "status": "modified", "additions": 0, "deletions": 133, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/786c143a70ac40e5e028eed6b8efaa54076ce41f/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786c143a70ac40e5e028eed6b8efaa54076ce41f/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_serialize.rs?ref=786c143a70ac40e5e028eed6b8efaa54076ce41f", "patch": "@@ -230,139 +230,6 @@ fn expand_auto_deserialize(\n     }\n }\n \n-priv impl ext_ctxt {\n-    fn bind_path(\n-        span: span,\n-        ident: ast::ident,\n-        path: @ast::path,\n-        bounds: @~[ast::ty_param_bound]\n-    ) -> ast::ty_param {\n-        let bound = ast::ty_param_bound(@{\n-            id: self.next_id(),\n-            node: ast::ty_path(path, self.next_id()),\n-            span: span,\n-        });\n-\n-        {\n-            ident: ident,\n-            id: self.next_id(),\n-            bounds: @vec::append(~[bound], *bounds)\n-        }\n-    }\n-\n-    fn expr(span: span, node: ast::expr_) -> @ast::expr {\n-        @{id: self.next_id(), callee_id: self.next_id(),\n-          node: node, span: span}\n-    }\n-\n-    fn path(span: span, strs: ~[ast::ident]) -> @ast::path {\n-        @{span: span, global: false, idents: strs, rp: None, types: ~[]}\n-    }\n-\n-    fn path_tps(span: span, strs: ~[ast::ident],\n-                tps: ~[@ast::Ty]) -> @ast::path {\n-        @{span: span, global: false, idents: strs, rp: None, types: tps}\n-    }\n-\n-    fn ty_path(span: span, strs: ~[ast::ident],\n-               tps: ~[@ast::Ty]) -> @ast::Ty {\n-        @{id: self.next_id(),\n-          node: ast::ty_path(self.path_tps(span, strs, tps), self.next_id()),\n-          span: span}\n-    }\n-\n-    fn binder_pat(span: span, nm: ast::ident) -> @ast::pat {\n-        let path = @{span: span, global: false, idents: ~[nm],\n-                     rp: None, types: ~[]};\n-        @{id: self.next_id(),\n-          node: ast::pat_ident(ast::bind_by_ref(ast::m_imm),\n-                               path,\n-                               None),\n-          span: span}\n-    }\n-\n-    fn stmt(expr: @ast::expr) -> @ast::stmt {\n-        @{node: ast::stmt_semi(expr, self.next_id()),\n-          span: expr.span}\n-    }\n-\n-    fn lit_str(span: span, s: @~str) -> @ast::expr {\n-        self.expr(\n-            span,\n-            ast::expr_vstore(\n-                self.expr(\n-                    span,\n-                    ast::expr_lit(\n-                        @{node: ast::lit_str(s),\n-                          span: span})),\n-                ast::expr_vstore_uniq))\n-    }\n-\n-    fn lit_uint(span: span, i: uint) -> @ast::expr {\n-        self.expr(\n-            span,\n-            ast::expr_lit(\n-                @{node: ast::lit_uint(i as u64, ast::ty_u),\n-                  span: span}))\n-    }\n-\n-    fn lambda(blk: ast::blk) -> @ast::expr {\n-        let ext_cx = self;\n-        let blk_e = self.expr(blk.span, ast::expr_block(blk));\n-        quote_expr!( || $blk_e )\n-    }\n-\n-    fn blk(span: span, stmts: ~[@ast::stmt]) -> ast::blk {\n-        {node: {view_items: ~[],\n-                stmts: stmts,\n-                expr: None,\n-                id: self.next_id(),\n-                rules: ast::default_blk},\n-         span: span}\n-    }\n-\n-    fn expr_blk(expr: @ast::expr) -> ast::blk {\n-        {node: {view_items: ~[],\n-                stmts: ~[],\n-                expr: Some(expr),\n-                id: self.next_id(),\n-                rules: ast::default_blk},\n-         span: expr.span}\n-    }\n-\n-    fn expr_path(span: span, strs: ~[ast::ident]) -> @ast::expr {\n-        self.expr(span, ast::expr_path(self.path(span, strs)))\n-    }\n-\n-    fn expr_var(span: span, var: ~str) -> @ast::expr {\n-        self.expr_path(span, ~[self.ident_of(var)])\n-    }\n-\n-    fn expr_field(\n-        span: span,\n-        expr: @ast::expr,\n-        ident: ast::ident\n-    ) -> @ast::expr {\n-        self.expr(span, ast::expr_field(expr, ident, ~[]))\n-    }\n-\n-    fn expr_call(\n-        span: span,\n-        expr: @ast::expr,\n-        args: ~[@ast::expr]\n-    ) -> @ast::expr {\n-        self.expr(span, ast::expr_call(expr, args, false))\n-    }\n-\n-    fn lambda_expr(expr: @ast::expr) -> @ast::expr {\n-        self.lambda(self.expr_blk(expr))\n-    }\n-\n-    fn lambda_stmts(span: span, stmts: ~[@ast::stmt]) -> @ast::expr {\n-        self.lambda(self.blk(span, stmts))\n-    }\n-}\n-\n fn mk_impl(\n     cx: ext_ctxt,\n     span: span,"}, {"sha": "d245aa1c050c4c1681908b5956fda670df5731e7", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/786c143a70ac40e5e028eed6b8efaa54076ce41f/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786c143a70ac40e5e028eed6b8efaa54076ce41f/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=786c143a70ac40e5e028eed6b8efaa54076ce41f", "patch": "@@ -47,7 +47,7 @@ enum mac_result {\n \n enum syntax_extension {\n \n-    // #[auto_serialize] and such\n+    // #[auto_encode] and such\n     item_decorator(item_decorator),\n \n     // Token-tree expanders\n@@ -79,6 +79,12 @@ fn syntax_expander_table() -> HashMap<~str, syntax_extension> {\n     syntax_expanders.insert(\n         ~\"auto_deserialize\",\n         item_decorator(ext::auto_serialize::expand_auto_deserialize));\n+    syntax_expanders.insert(\n+        ~\"auto_encode\",\n+        item_decorator(ext::auto_encode::expand_auto_encode));\n+    syntax_expanders.insert(\n+        ~\"auto_decode\",\n+        item_decorator(ext::auto_encode::expand_auto_decode));\n     syntax_expanders.insert(~\"env\",\n                             builtin_normal_tt(ext::env::expand_syntax_ext));\n     syntax_expanders.insert(~\"concat_idents\","}, {"sha": "6013178c5eea9e4f9d0e7fd412322d88d5b0f8a7", "filename": "src/libsyntax/syntax.rc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/786c143a70ac40e5e028eed6b8efaa54076ce41f/src%2Flibsyntax%2Fsyntax.rc", "raw_url": "https://github.com/rust-lang/rust/raw/786c143a70ac40e5e028eed6b8efaa54076ce41f/src%2Flibsyntax%2Fsyntax.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsyntax.rc?ref=786c143a70ac40e5e028eed6b8efaa54076ce41f", "patch": "@@ -117,6 +117,9 @@ mod ext {\n     #[path = \"ext/log_syntax.rs\"]\n     mod log_syntax;\n     #[legacy_exports]\n+    #[path = \"ext/auto_encode.rs\"]\n+    mod auto_encode;\n+    #[legacy_exports]\n     #[path = \"ext/auto_serialize.rs\"]\n     mod auto_serialize;\n     #[legacy_exports]"}]}