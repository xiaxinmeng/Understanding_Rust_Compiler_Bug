{"sha": "ab24ffe21a742287ee12d5992d4c90e83abb374d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiMjRmZmUyMWE3NDIyODdlZTEyZDU5OTJkNGM5MGU4M2FiYjM3NGQ=", "commit": {"author": {"name": "Ignacio Corderi", "email": "icorderi@msn.com", "date": "2014-11-27T00:52:36Z"}, "committer": {"name": "Ignacio Corderi", "email": "icorderi@msn.com", "date": "2014-11-27T00:52:36Z"}, "message": "Copied all the grammar productions from reference.md to grammar.md", "tree": {"sha": "996c5e9b2937fc39d47aff8bb9d866b1d6be2278", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/996c5e9b2937fc39d47aff8bb9d866b1d6be2278"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab24ffe21a742287ee12d5992d4c90e83abb374d", "comment_count": 33, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab24ffe21a742287ee12d5992d4c90e83abb374d", "html_url": "https://github.com/rust-lang/rust/commit/ab24ffe21a742287ee12d5992d4c90e83abb374d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab24ffe21a742287ee12d5992d4c90e83abb374d/comments", "author": {"login": "icorderi", "id": 2915919, "node_id": "MDQ6VXNlcjI5MTU5MTk=", "avatar_url": "https://avatars.githubusercontent.com/u/2915919?v=4", "gravatar_id": "", "url": "https://api.github.com/users/icorderi", "html_url": "https://github.com/icorderi", "followers_url": "https://api.github.com/users/icorderi/followers", "following_url": "https://api.github.com/users/icorderi/following{/other_user}", "gists_url": "https://api.github.com/users/icorderi/gists{/gist_id}", "starred_url": "https://api.github.com/users/icorderi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/icorderi/subscriptions", "organizations_url": "https://api.github.com/users/icorderi/orgs", "repos_url": "https://api.github.com/users/icorderi/repos", "events_url": "https://api.github.com/users/icorderi/events{/privacy}", "received_events_url": "https://api.github.com/users/icorderi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "icorderi", "id": 2915919, "node_id": "MDQ6VXNlcjI5MTU5MTk=", "avatar_url": "https://avatars.githubusercontent.com/u/2915919?v=4", "gravatar_id": "", "url": "https://api.github.com/users/icorderi", "html_url": "https://github.com/icorderi", "followers_url": "https://api.github.com/users/icorderi/followers", "following_url": "https://api.github.com/users/icorderi/following{/other_user}", "gists_url": "https://api.github.com/users/icorderi/gists{/gist_id}", "starred_url": "https://api.github.com/users/icorderi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/icorderi/subscriptions", "organizations_url": "https://api.github.com/users/icorderi/orgs", "repos_url": "https://api.github.com/users/icorderi/repos", "events_url": "https://api.github.com/users/icorderi/events{/privacy}", "received_events_url": "https://api.github.com/users/icorderi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ffc5f1ccd8b0c7ca07414c324729ecac97f47e6a", "url": "https://api.github.com/repos/rust-lang/rust/commits/ffc5f1ccd8b0c7ca07414c324729ecac97f47e6a", "html_url": "https://github.com/rust-lang/rust/commit/ffc5f1ccd8b0c7ca07414c324729ecac97f47e6a"}], "stats": {"total": 773, "additions": 18, "deletions": 755}, "files": [{"sha": "c2cbb3ae3fb2f8c03d45dd86c1b9368ccc77ce25", "filename": "src/doc/grammar.md", "status": "modified", "additions": 18, "deletions": 755, "changes": 773, "blob_url": "https://github.com/rust-lang/rust/blob/ab24ffe21a742287ee12d5992d4c90e83abb374d/src%2Fdoc%2Fgrammar.md", "raw_url": "https://github.com/rust-lang/rust/raw/ab24ffe21a742287ee12d5992d4c90e83abb374d/src%2Fdoc%2Fgrammar.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fgrammar.md?ref=ab24ffe21a742287ee12d5992d4c90e83abb374d", "patch": "@@ -683,254 +683,53 @@ return_expr : \"return\" expr ? ;\n \n # Type system\n \n-## Types\n-\n-Every slot, item and value in a Rust program has a type. The _type_ of a\n-*value* defines the interpretation of the memory holding it.\n+**FIXME:** is this entire chapter relevant here? Or should it all have been covered by some production already? \n \n-Built-in types and type-constructors are tightly integrated into the language,\n-in nontrivial ways that are not possible to emulate in user-defined types.\n-User-defined types have limited capabilities.\n+## Types\n \n ### Primitive types\n \n-The primitive types are the following:\n-\n-* The \"unit\" type `()`, having the single \"unit\" value `()` (occasionally called\n-  \"nil\"). [^unittype]\n-* The boolean type `bool` with values `true` and `false`.\n-* The machine types.\n-* The machine-dependent integer and floating-point types.\n-\n-[^unittype]: The \"unit\" value `()` is *not* a sentinel \"null pointer\" value for\n-    reference slots; the \"unit\" type is the implicit return type from functions\n-    otherwise lacking a return type, and can be used in other contexts (such as\n-    message-sending or type-parametric code) as a zero-size type.]\n+**FIXME:** grammar? \n \n #### Machine types\n \n-The machine types are the following:\n-\n-* The unsigned word types `u8`, `u16`, `u32` and `u64`, with values drawn from\n-  the integer intervals [0, 2^8 - 1], [0, 2^16 - 1], [0, 2^32 - 1] and\n-  [0, 2^64 - 1] respectively.\n-\n-* The signed two's complement word types `i8`, `i16`, `i32` and `i64`, with\n-  values drawn from the integer intervals [-(2^(7)), 2^7 - 1],\n-  [-(2^(15)), 2^15 - 1], [-(2^(31)), 2^31 - 1], [-(2^(63)), 2^63 - 1]\n-  respectively.\n-\n-* The IEEE 754-2008 `binary32` and `binary64` floating-point types: `f32` and\n-  `f64`, respectively.\n+**FIXME:** grammar? \n \n #### Machine-dependent integer types\n \n-The `uint` type is an unsigned integer type with the same number of bits as the\n-platform's pointer type. It can represent every memory address in the process.\n-\n-The `int` type is a signed integer type with the same number of bits as the\n-platform's pointer type. The theoretical upper bound on object and array size\n-is the maximum `int` value. This ensures that `int` can be used to calculate\n-differences between pointers into an object or array and can address every byte\n-within an object along with one byte past the end.\n+**FIXME:** grammar? \n \n ### Textual types\n \n-The types `char` and `str` hold textual data.\n-\n-A value of type `char` is a [Unicode scalar value](\n-http://www.unicode.org/glossary/#unicode_scalar_value) (ie. a code point that\n-is not a surrogate), represented as a 32-bit unsigned word in the 0x0000 to\n-0xD7FF or 0xE000 to 0x10FFFF range. A `[char]` array is effectively an UCS-4 /\n-UTF-32 string.\n-\n-A value of type `str` is a Unicode string, represented as an array of 8-bit\n-unsigned bytes holding a sequence of UTF-8 codepoints. Since `str` is of\n-unknown size, it is not a _first class_ type, but can only be instantiated\n-through a pointer type, such as `&str` or `String`.\n+**FIXME:** grammar? \n \n ### Tuple types\n \n-A tuple *type* is a heterogeneous product of other types, called the *elements*\n-of the tuple. It has no nominal name and is instead structurally typed.\n-\n-Tuple types and values are denoted by listing the types or values of their\n-elements, respectively, in a parenthesized, comma-separated list.\n-\n-Because tuple elements don't have a name, they can only be accessed by\n-pattern-matching.\n-\n-The members of a tuple are laid out in memory contiguously, in order specified\n-by the tuple type.\n-\n-An example of a tuple type and its use:\n-\n-```\n-type Pair<'a> = (int, &'a str);\n-let p: Pair<'static> = (10, \"hello\");\n-let (a, b) = p;\n-assert!(b != \"world\");\n-```\n+**FIXME:** grammar? \n \n ### Array, and Slice types\n \n-Rust has two different types for a list of items:\n-\n-* `[T ..N]`, an 'array'\n-* `&[T]`, a 'slice'.\n-\n-An array has a fixed size, and can be allocated on either the stack or the\n-heap.\n-\n-A slice is a 'view' into an array. It doesn't own the data it points\n-to, it borrows it.\n-\n-An example of each kind:\n-\n-```{rust}\n-let vec: Vec<int>  = vec![1, 2, 3];\n-let arr: [int, ..3] = [1, 2, 3];\n-let s: &[int]      = vec.as_slice();\n-```\n-\n-As you can see, the `vec!` macro allows you to create a `Vec<T>` easily. The\n-`vec!` macro is also part of the standard library, rather than the language.\n-\n-All in-bounds elements of arrays, and slices are always initialized, and access\n-to an array or slice is always bounds-checked.\n+**FIXME:** grammar? \n \n ### Structure types\n \n-A `struct` *type* is a heterogeneous product of other types, called the\n-*fields* of the type.[^structtype]\n-\n-[^structtype]: `struct` types are analogous `struct` types in C,\n-    the *record* types of the ML family,\n-    or the *structure* types of the Lisp family.\n-\n-New instances of a `struct` can be constructed with a [struct\n-expression](#structure-expressions).\n-\n-The memory layout of a `struct` is undefined by default to allow for compiler\n-optimizations like field reordering, but it can be fixed with the\n-`#[repr(...)]` attribute. In either case, fields may be given in any order in\n-a corresponding struct *expression*; the resulting `struct` value will always\n-have the same memory layout.\n-\n-The fields of a `struct` may be qualified by [visibility\n-modifiers](#re-exporting-and-visibility), to allow access to data in a\n-structure outside a module.\n-\n-A _tuple struct_ type is just like a structure type, except that the fields are\n-anonymous.\n-\n-A _unit-like struct_ type is like a structure type, except that it has no\n-fields. The one value constructed by the associated [structure\n-expression](#structure-expressions) is the only value that inhabits such a\n-type.\n+**FIXME:** grammar? \n \n ### Enumerated types\n \n-An *enumerated type* is a nominal, heterogeneous disjoint union type, denoted\n-by the name of an [`enum` item](#enumerations). [^enumtype]\n-\n-[^enumtype]: The `enum` type is analogous to a `data` constructor declaration in\n-             ML, or a *pick ADT* in Limbo.\n-\n-An [`enum` item](#enumerations) declares both the type and a number of *variant\n-constructors*, each of which is independently named and takes an optional tuple\n-of arguments.\n-\n-New instances of an `enum` can be constructed by calling one of the variant\n-constructors, in a [call expression](#call-expressions).\n-\n-Any `enum` value consumes as much memory as the largest variant constructor for\n-its corresponding `enum` type.\n-\n-Enum types cannot be denoted *structurally* as types, but must be denoted by\n-named reference to an [`enum` item](#enumerations).\n-\n-### Recursive types\n-\n-Nominal types &mdash; [enumerations](#enumerated-types) and\n-[structures](#structure-types) &mdash; may be recursive. That is, each `enum`\n-constructor or `struct` field may refer, directly or indirectly, to the\n-enclosing `enum` or `struct` type itself. Such recursion has restrictions:\n-\n-* Recursive types must include a nominal type in the recursion\n-  (not mere [type definitions](#type-definitions),\n-   or other structural types such as [arrays](#array,-and-slice-types) or [tuples](#tuple-types)).\n-* A recursive `enum` item must have at least one non-recursive constructor\n-  (in order to give the recursion a basis case).\n-* The size of a recursive type must be finite;\n-  in other words the recursive fields of the type must be [pointer types](#pointer-types).\n-* Recursive type definitions can cross module boundaries, but not module *visibility* boundaries,\n-  or crate boundaries (in order to simplify the module system and type checker).\n-\n-An example of a *recursive* type and its use:\n-\n-```\n-enum List<T> {\n-  Nil,\n-  Cons(T, Box<List<T>>)\n-}\n-\n-let a: List<int> = List::Cons(7, box List::Cons(13, box List::Nil));\n-```\n+**FIXME:** grammar? \n \n ### Pointer types\n \n-All pointers in Rust are explicit first-class values. They can be copied,\n-stored into data structures, and returned from functions. There are two\n-varieties of pointer in Rust:\n-\n-* References (`&`)\n-  : These point to memory _owned by some other value_.\n-    A reference type is written `&type` for some lifetime-variable `f`,\n-    or just `&'a type` when you need an explicit lifetime.\n-    Copying a reference is a \"shallow\" operation:\n-    it involves only copying the pointer itself.\n-    Releasing a reference typically has no effect on the value it points to,\n-    with the exception of temporary values, which are released when the last\n-    reference to them is released.\n-\n-* Raw pointers (`*`)\n-  : Raw pointers are pointers without safety or liveness guarantees.\n-    Raw pointers are written as `*const T` or `*mut T`,\n-    for example `*const int` means a raw pointer to an integer.\n-    Copying or dropping a raw pointer has no effect on the lifecycle of any\n-    other value. Dereferencing a raw pointer or converting it to any other\n-    pointer type is an [`unsafe` operation](#unsafe-functions).\n-    Raw pointers are generally discouraged in Rust code;\n-    they exist to support interoperability with foreign code,\n-    and writing performance-critical or low-level functions.\n-\n-The standard library contains additional 'smart pointer' types beyond references\n-and raw pointers.\n+**FIXME:** grammar? \n \n ### Function types\n \n-The function type constructor `fn` forms new function types. A function type\n-consists of a possibly-empty set of function-type modifiers (such as `unsafe`\n-or `extern`), a sequence of input types and an output type.\n-\n-An example of a `fn` type:\n-\n-```\n-fn add(x: int, y: int) -> int {\n-  return x + y;\n-}\n-\n-let mut x = add(5,7);\n-\n-type Binop<'a> = |int,int|: 'a -> int;\n-let bo: Binop = add;\n-x = bo(5,7);\n-```\n+**FIXME:** grammar? \n \n ### Closure types\n \n-```{.ebnf .notation}\n+```antlr\n closure_type := [ 'unsafe' ] [ '<' lifetime-list '>' ] '|' arg-list '|'\n                 [ ':' bound-list ] [ '->' type ]\n procedure_type := 'proc' [ '<' lifetime-list '>' ] '(' arg-list ')'\n@@ -941,574 +740,38 @@ bound-list := bound | bound '+' bound-list\n bound := path | lifetime\n ```\n \n-The type of a closure mapping an input of type `A` to an output of type `B` is\n-`|A| -> B`. A closure with no arguments or return values has type `||`.\n-Similarly, a procedure mapping `A` to `B` is `proc(A) -> B` and a no-argument\n-and no-return value closure has type `proc()`.\n-\n-An example of creating and calling a closure:\n-\n-```rust\n-let captured_var = 10i;\n-\n-let closure_no_args = || println!(\"captured_var={}\", captured_var);\n-\n-let closure_args = |arg: int| -> int {\n-  println!(\"captured_var={}, arg={}\", captured_var, arg);\n-  arg // Note lack of semicolon after 'arg'\n-};\n-\n-fn call_closure(c1: ||, c2: |int| -> int) {\n-  c1();\n-  c2(2);\n-}\n-\n-call_closure(closure_no_args, closure_args);\n-\n-```\n-\n-Unlike closures, procedures may only be invoked once, but own their\n-environment, and are allowed to move out of their environment. Procedures are\n-allocated on the heap (unlike closures). An example of creating and calling a\n-procedure:\n-\n-```rust\n-let string = \"Hello\".to_string();\n-\n-// Creates a new procedure, passing it to the `spawn` function.\n-spawn(proc() {\n-  println!(\"{} world!\", string);\n-});\n-\n-// the variable `string` has been moved into the previous procedure, so it is\n-// no longer usable.\n-\n-\n-// Create an invoke a procedure. Note that the procedure is *moved* when\n-// invoked, so it cannot be invoked again.\n-let f = proc(n: int) { n + 22 };\n-println!(\"answer: {}\", f(20));\n-\n-```\n-\n ### Object types\n \n-Every trait item (see [traits](#traits)) defines a type with the same name as\n-the trait. This type is called the _object type_ of the trait. Object types\n-permit \"late binding\" of methods, dispatched using _virtual method tables_\n-(\"vtables\"). Whereas most calls to trait methods are \"early bound\" (statically\n-resolved) to specific implementations at compile time, a call to a method on an\n-object type is only resolved to a vtable entry at compile time. The actual\n-implementation for each vtable entry can vary on an object-by-object basis.\n-\n-Given a pointer-typed expression `E` of type `&T` or `Box<T>`, where `T`\n-implements trait `R`, casting `E` to the corresponding pointer type `&R` or\n-`Box<R>` results in a value of the _object type_ `R`. This result is\n-represented as a pair of pointers: the vtable pointer for the `T`\n-implementation of `R`, and the pointer value of `E`.\n-\n-An example of an object type:\n-\n-```\n-trait Printable {\n-  fn stringify(&self) -> String;\n-}\n-\n-impl Printable for int {\n-  fn stringify(&self) -> String { self.to_string() }\n-}\n-\n-fn print(a: Box<Printable>) {\n-   println!(\"{}\", a.stringify());\n-}\n-\n-fn main() {\n-   print(box 10i as Box<Printable>);\n-}\n-```\n-\n-In this example, the trait `Printable` occurs as an object type in both the\n-type signature of `print`, and the cast expression in `main`.\n+**FIXME:** grammar? \n \n ### Type parameters\n \n-Within the body of an item that has type parameter declarations, the names of\n-its type parameters are types:\n-\n-```ignore\n-fn map<A: Clone, B: Clone>(f: |A| -> B, xs: &[A]) -> Vec<B> {\n-    if xs.len() == 0 {\n-       return vec![];\n-    }\n-    let first: B = f(xs[0].clone());\n-    let mut rest: Vec<B> = map(f, xs.slice(1, xs.len()));\n-    rest.insert(0, first);\n-    return rest;\n-}\n-```\n-\n-Here, `first` has type `B`, referring to `map`'s `B` type parameter; and `rest`\n-has type `Vec<B>`, a vector type with element type `B`.\n+**FIXME:** grammar? \n \n ### Self types\n \n-The special type `self` has a meaning within methods inside an impl item. It\n-refers to the type of the implicit `self` argument. For example, in:\n-\n-```\n-trait Printable {\n-  fn make_string(&self) -> String;\n-}\n-\n-impl Printable for String {\n-    fn make_string(&self) -> String {\n-        (*self).clone()\n-    }\n-}\n-```\n-\n-`self` refers to the value of type `String` that is the receiver for a call to\n-the method `make_string`.\n+**FIXME:** grammar? \n \n ## Type kinds\n \n-Types in Rust are categorized into kinds, based on various properties of the\n-components of the type. The kinds are:\n-\n-* `Send`\n-  : Types of this kind can be safely sent between tasks.\n-    This kind includes scalars, boxes, procs, and\n-    structural types containing only other owned types.\n-    All `Send` types are `'static`.\n-* `Copy`\n-  : Types of this kind consist of \"Plain Old Data\"\n-    which can be copied by simply moving bits.\n-    All values of this kind can be implicitly copied.\n-    This kind includes scalars and immutable references,\n-    as well as structural types containing other `Copy` types.\n-* `'static`\n-  : Types of this kind do not contain any references (except for\n-    references with the `static` lifetime, which are allowed).\n-    This can be a useful guarantee for code\n-    that breaks borrowing assumptions\n-    using [`unsafe` operations](#unsafe-functions).\n-* `Drop`\n-  : This is not strictly a kind,\n-    but its presence interacts with kinds:\n-    the `Drop` trait provides a single method `drop`\n-    that takes no parameters,\n-    and is run when values of the type are dropped.\n-    Such a method is called a \"destructor\",\n-    and are always executed in \"top-down\" order:\n-    a value is completely destroyed\n-    before any of the values it owns run their destructors.\n-    Only `Send` types can implement `Drop`.\n-\n-* _Default_\n-  : Types with destructors, closure environments,\n-    and various other _non-first-class_ types,\n-    are not copyable at all.\n-    Such types can usually only be accessed through pointers,\n-    or in some cases, moved between mutable locations.\n-\n-Kinds can be supplied as _bounds_ on type parameters, like traits, in which\n-case the parameter is constrained to types satisfying that kind.\n-\n-By default, type parameters do not carry any assumed kind-bounds at all. When\n-instantiating a type parameter, the kind bounds on the parameter are checked to\n-be the same or narrower than the kind of the type that it is instantiated with.\n-\n-Sending operations are not part of the Rust language, but are implemented in\n-the library. Generic functions that send values bound the kind of these values\n-to sendable.\n+**FIXME:** this this probably not relevant to the grammar...\n \n # Memory and concurrency models\n \n-Rust has a memory model centered around concurrently-executing _tasks_. Thus\n-its memory model and its concurrency model are best discussed simultaneously,\n-as parts of each only make sense when considered from the perspective of the\n-other.\n-\n-When reading about the memory model, keep in mind that it is partitioned in\n-order to support tasks; and when reading about tasks, keep in mind that their\n-isolation and communication mechanisms are only possible due to the ownership\n-and lifetime semantics of the memory model.\n+**FIXME:** is this entire chapter relevant here? Or should it all have been covered by some production already? \n \n ## Memory model\n \n-A Rust program's memory consists of a static set of *items*, a set of\n-[tasks](#tasks) each with its own *stack*, and a *heap*. Immutable portions of\n-the heap may be shared between tasks, mutable portions may not.\n-\n-Allocations in the stack consist of *slots*, and allocations in the heap\n-consist of *boxes*.\n-\n ### Memory allocation and lifetime\n \n-The _items_ of a program are those functions, modules and types that have their\n-value calculated at compile-time and stored uniquely in the memory image of the\n-rust process. Items are neither dynamically allocated nor freed.\n-\n-A task's _stack_ consists of activation frames automatically allocated on entry\n-to each function as the task executes. A stack allocation is reclaimed when\n-control leaves the frame containing it.\n-\n-The _heap_ is a general term that describes boxes.  The lifetime of an\n-allocation in the heap depends on the lifetime of the box values pointing to\n-it. Since box values may themselves be passed in and out of frames, or stored\n-in the heap, heap allocations may outlive the frame they are allocated within.\n-\n ### Memory ownership\n \n-A task owns all memory it can *safely* reach through local variables, as well\n-as boxes and references.\n-\n-When a task sends a value that has the `Send` trait to another task, it loses\n-ownership of the value sent and can no longer refer to it. This is statically\n-guaranteed by the combined use of \"move semantics\", and the compiler-checked\n-_meaning_ of the `Send` trait: it is only instantiated for (transitively)\n-sendable kinds of data constructor and pointers, never including references.\n-\n-When a stack frame is exited, its local allocations are all released, and its\n-references to boxes are dropped.\n-\n-When a task finishes, its stack is necessarily empty and it therefore has no\n-references to any boxes; the remainder of its heap is immediately freed.\n-\n ### Memory slots\n \n-A task's stack contains slots.\n-\n-A _slot_ is a component of a stack frame, either a function parameter, a\n-[temporary](#lvalues,-rvalues-and-temporaries), or a local variable.\n-\n-A _local variable_ (or *stack-local* allocation) holds a value directly,\n-allocated within the stack's memory. The value is a part of the stack frame.\n-\n-Local variables are immutable unless declared otherwise like: `let mut x = ...`.\n-\n-Function parameters are immutable unless declared with `mut`. The `mut` keyword\n-applies only to the following parameter (so `|mut x, y|` and `fn f(mut x:\n-Box<int>, y: Box<int>)` declare one mutable variable `x` and one immutable\n-variable `y`).\n-\n-Methods that take either `self` or `Box<Self>` can optionally place them in a\n-mutable slot by prefixing them with `mut` (similar to regular arguments):\n-\n-```\n-trait Changer {\n-    fn change(mut self) -> Self;\n-    fn modify(mut self: Box<Self>) -> Box<Self>;\n-}\n-```\n-\n-Local variables are not initialized when allocated; the entire frame worth of\n-local variables are allocated at once, on frame-entry, in an uninitialized\n-state. Subsequent statements within a function may or may not initialize the\n-local variables. Local variables can be used only after they have been\n-initialized; this is enforced by the compiler.\n-\n ### Boxes\n \n-A _box_ is a reference to a heap allocation holding another value, which is\n-constructed by the prefix operator `box`. When the standard library is in use,\n-the type of a box is `std::owned::Box<T>`.\n-\n-An example of a box type and value:\n-\n-```\n-let x: Box<int> = box 10;\n-```\n-\n-Box values exist in 1:1 correspondence with their heap allocation, copying a\n-box value makes a shallow copy of the pointer. Rust will consider a shallow\n-copy of a box to move ownership of the value. After a value has been moved,\n-the source location cannot be used unless it is reinitialized.\n-\n-```\n-let x: Box<int> = box 10;\n-let y = x;\n-// attempting to use `x` will result in an error here\n-```\n-\n ## Tasks\n \n-An executing Rust program consists of a tree of tasks. A Rust _task_ consists\n-of an entry function, a stack, a set of outgoing communication channels and\n-incoming communication ports, and ownership of some portion of the heap of a\n-single operating-system process.\n-\n ### Communication between tasks\n \n-Rust tasks are isolated and generally unable to interfere with one another's\n-memory directly, except through [`unsafe` code](#unsafe-functions).  All\n-contact between tasks is mediated by safe forms of ownership transfer, and data\n-races on memory are prohibited by the type system.\n-\n-When you wish to send data between tasks, the values are restricted to the\n-[`Send` type-kind](#type-kinds). Restricting communication interfaces to this\n-kind ensures that no references move between tasks. Thus access to an entire\n-data structure can be mediated through its owning \"root\" value; no further\n-locking or copying is required to avoid data races within the substructure of\n-such a value.\n-\n ### Task lifecycle\n-\n-The _lifecycle_ of a task consists of a finite set of states and events that\n-cause transitions between the states. The lifecycle states of a task are:\n-\n-* running\n-* blocked\n-* panicked\n-* dead\n-\n-A task begins its lifecycle &mdash; once it has been spawned &mdash; in the\n-*running* state. In this state it executes the statements of its entry\n-function, and any functions called by the entry function.\n-\n-A task may transition from the *running* state to the *blocked* state any time\n-it makes a blocking communication call. When the call can be completed &mdash;\n-when a message arrives at a sender, or a buffer opens to receive a message\n-&mdash; then the blocked task will unblock and transition back to *running*.\n-\n-A task may transition to the *panicked* state at any time, due being killed by\n-some external event or internally, from the evaluation of a `panic!()` macro.\n-Once *panicking*, a task unwinds its stack and transitions to the *dead* state.\n-Unwinding the stack of a task is done by the task itself, on its own control\n-stack. If a value with a destructor is freed during unwinding, the code for the\n-destructor is run, also on the task's control stack. Running the destructor\n-code causes a temporary transition to a *running* state, and allows the\n-destructor code to cause any subsequent state transitions. The original task\n-of unwinding and panicking thereby may suspend temporarily, and may involve\n-(recursive) unwinding of the stack of a failed destructor. Nonetheless, the\n-outermost unwinding activity will continue until the stack is unwound and the\n-task transitions to the *dead* state. There is no way to \"recover\" from task\n-panics. Once a task has temporarily suspended its unwinding in the *panicking*\n-state, a panic occurring from within this destructor results in *hard* panic.\n-A hard panic currently results in the process aborting.\n-\n-A task in the *dead* state cannot transition to other states; it exists only to\n-have its termination status inspected by other tasks, and/or to await\n-reclamation when the last reference to it drops.\n-\n-# Runtime services, linkage and debugging\n-\n-The Rust _runtime_ is a relatively compact collection of Rust code that\n-provides fundamental services and datatypes to all Rust tasks at run-time. It\n-is smaller and simpler than many modern language runtimes. It is tightly\n-integrated into the language's execution model of memory, tasks, communication\n-and logging.\n-\n-### Memory allocation\n-\n-The runtime memory-management system is based on a _service-provider\n-interface_, through which the runtime requests blocks of memory from its\n-environment and releases them back to its environment when they are no longer\n-needed. The default implementation of the service-provider interface consists\n-of the C runtime functions `malloc` and `free`.\n-\n-The runtime memory-management system, in turn, supplies Rust tasks with\n-facilities for allocating releasing stacks, as well as allocating and freeing\n-heap data.\n-\n-### Built in types\n-\n-The runtime provides C and Rust code to assist with various built-in types,\n-such as arrays, strings, and the low level communication system (ports,\n-channels, tasks).\n-\n-Support for other built-in types such as simple types, tuples and enums is\n-open-coded by the Rust compiler.\n-\n-### Task scheduling and communication\n-\n-The runtime provides code to manage inter-task communication. This includes\n-the system of task-lifecycle state transitions depending on the contents of\n-queues, as well as code to copy values between queues and their recipients and\n-to serialize values for transmission over operating-system inter-process\n-communication facilities.\n-\n-### Linkage\n-\n-The Rust compiler supports various methods to link crates together both\n-statically and dynamically. This section will explore the various methods to\n-link Rust crates together, and more information about native libraries can be\n-found in the [ffi guide][ffi].\n-\n-In one session of compilation, the compiler can generate multiple artifacts\n-through the usage of either command line flags or the `crate_type` attribute.\n-If one or more command line flag is specified, all `crate_type` attributes will\n-be ignored in favor of only building the artifacts specified by command line.\n-\n-* `--crate-type=bin`, `#[crate_type = \"bin\"]` - A runnable executable will be\n-  produced. This requires that there is a `main` function in the crate which\n-  will be run when the program begins executing. This will link in all Rust and\n-  native dependencies, producing a distributable binary.\n-\n-* `--crate-type=lib`, `#[crate_type = \"lib\"]` - A Rust library will be produced.\n-  This is an ambiguous concept as to what exactly is produced because a library\n-  can manifest itself in several forms. The purpose of this generic `lib` option\n-  is to generate the \"compiler recommended\" style of library. The output library\n-  will always be usable by rustc, but the actual type of library may change from\n-  time-to-time. The remaining output types are all different flavors of\n-  libraries, and the `lib` type can be seen as an alias for one of them (but the\n-  actual one is compiler-defined).\n-\n-* `--crate-type=dylib`, `#[crate_type = \"dylib\"]` - A dynamic Rust library will\n-  be produced. This is different from the `lib` output type in that this forces\n-  dynamic library generation. The resulting dynamic library can be used as a\n-  dependency for other libraries and/or executables. This output type will\n-  create `*.so` files on linux, `*.dylib` files on osx, and `*.dll` files on\n-  windows.\n-\n-* `--crate-type=staticlib`, `#[crate_type = \"staticlib\"]` - A static system\n-  library will be produced. This is different from other library outputs in that\n-  the Rust compiler will never attempt to link to `staticlib` outputs. The\n-  purpose of this output type is to create a static library containing all of\n-  the local crate's code along with all upstream dependencies. The static\n-  library is actually a `*.a` archive on linux and osx and a `*.lib` file on\n-  windows. This format is recommended for use in situations such as linking\n-  Rust code into an existing non-Rust application because it will not have\n-  dynamic dependencies on other Rust code.\n-\n-* `--crate-type=rlib`, `#[crate_type = \"rlib\"]` - A \"Rust library\" file will be\n-  produced. This is used as an intermediate artifact and can be thought of as a\n-  \"static Rust library\". These `rlib` files, unlike `staticlib` files, are\n-  interpreted by the Rust compiler in future linkage. This essentially means\n-  that `rustc` will look for metadata in `rlib` files like it looks for metadata\n-  in dynamic libraries. This form of output is used to produce statically linked\n-  executables as well as `staticlib` outputs.\n-\n-Note that these outputs are stackable in the sense that if multiple are\n-specified, then the compiler will produce each form of output at once without\n-having to recompile. However, this only applies for outputs specified by the\n-same method. If only `crate_type` attributes are specified, then they will all\n-be built, but if one or more `--crate-type` command line flag is specified,\n-then only those outputs will be built.\n-\n-With all these different kinds of outputs, if crate A depends on crate B, then\n-the compiler could find B in various different forms throughout the system. The\n-only forms looked for by the compiler, however, are the `rlib` format and the\n-dynamic library format. With these two options for a dependent library, the\n-compiler must at some point make a choice between these two formats. With this\n-in mind, the compiler follows these rules when determining what format of\n-dependencies will be used:\n-\n-1. If a static library is being produced, all upstream dependencies are\n-   required to be available in `rlib` formats. This requirement stems from the\n-   reason that a dynamic library cannot be converted into a static format.\n-\n-   Note that it is impossible to link in native dynamic dependencies to a static\n-   library, and in this case warnings will be printed about all unlinked native\n-   dynamic dependencies.\n-\n-2. If an `rlib` file is being produced, then there are no restrictions on what\n-   format the upstream dependencies are available in. It is simply required that\n-   all upstream dependencies be available for reading metadata from.\n-\n-   The reason for this is that `rlib` files do not contain any of their upstream\n-   dependencies. It wouldn't be very efficient for all `rlib` files to contain a\n-   copy of `libstd.rlib`!\n-\n-3. If an executable is being produced and the `-C prefer-dynamic` flag is not\n-   specified, then dependencies are first attempted to be found in the `rlib`\n-   format. If some dependencies are not available in an rlib format, then\n-   dynamic linking is attempted (see below).\n-\n-4. If a dynamic library or an executable that is being dynamically linked is\n-   being produced, then the compiler will attempt to reconcile the available\n-   dependencies in either the rlib or dylib format to create a final product.\n-\n-   A major goal of the compiler is to ensure that a library never appears more\n-   than once in any artifact. For example, if dynamic libraries B and C were\n-   each statically linked to library A, then a crate could not link to B and C\n-   together because there would be two copies of A. The compiler allows mixing\n-   the rlib and dylib formats, but this restriction must be satisfied.\n-\n-   The compiler currently implements no method of hinting what format a library\n-   should be linked with. When dynamically linking, the compiler will attempt to\n-   maximize dynamic dependencies while still allowing some dependencies to be\n-   linked in via an rlib.\n-\n-   For most situations, having all libraries available as a dylib is recommended\n-   if dynamically linking. For other situations, the compiler will emit a\n-   warning if it is unable to determine which formats to link each library with.\n-\n-In general, `--crate-type=bin` or `--crate-type=lib` should be sufficient for\n-all compilation needs, and the other options are just available if more\n-fine-grained control is desired over the output format of a Rust crate.\n-\n-# Appendix: Rationales and design tradeoffs\n-\n-*TODO*.\n-\n-# Appendix: Influences and further references\n-\n-## Influences\n-\n->  The essential problem that must be solved in making a fault-tolerant\n->  software system is therefore that of fault-isolation. Different programmers\n->  will write different modules, some modules will be correct, others will have\n->  errors. We do not want the errors in one module to adversely affect the\n->  behaviour of a module which does not have any errors.\n->\n->  &mdash; Joe Armstrong\n-\n->  In our approach, all data is private to some process, and processes can\n->  only communicate through communications channels. *Security*, as used\n->  in this paper, is the property which guarantees that processes in a system\n->  cannot affect each other except by explicit communication.\n->\n->  When security is absent, nothing which can be proven about a single module\n->  in isolation can be guaranteed to hold when that module is embedded in a\n->  system [...]\n->\n->  &mdash; Robert Strom and Shaula Yemini\n-\n->  Concurrent and applicative programming complement each other. The\n->  ability to send messages on channels provides I/O without side effects,\n->  while the avoidance of shared data helps keep concurrent processes from\n->  colliding.\n->\n->  &mdash; Rob Pike\n-\n-Rust is not a particularly original language. It may however appear unusual by\n-contemporary standards, as its design elements are drawn from a number of\n-\"historical\" languages that have, with a few exceptions, fallen out of favour.\n-Five prominent lineages contribute the most, though their influences have come\n-and gone during the course of Rust's development:\n-\n-* The NIL (1981) and Hermes (1990) family. These languages were developed by\n-  Robert Strom, Shaula Yemini, David Bacon and others in their group at IBM\n-  Watson Research Center (Yorktown Heights, NY, USA).\n-\n-* The Erlang (1987) language, developed by Joe Armstrong, Robert Virding, Claes\n-  Wikstr&ouml;m, Mike Williams and others in their group at the Ericsson Computer\n-  Science Laboratory (&Auml;lvsj&ouml;, Stockholm, Sweden) .\n-\n-* The Sather (1990) language, developed by Stephen Omohundro, Chu-Cheow Lim,\n-  Heinz Schmidt and others in their group at The International Computer\n-  Science Institute of the University of California, Berkeley (Berkeley, CA,\n-  USA).\n-\n-* The Newsqueak (1988), Alef (1995), and Limbo (1996) family. These\n-  languages were developed by Rob Pike, Phil Winterbottom, Sean Dorward and\n-  others in their group at Bell Labs Computing Sciences Research Center\n-  (Murray Hill, NJ, USA).\n-\n-* The Napier (1985) and Napier88 (1988) family. These languages were\n-  developed by Malcolm Atkinson, Ron Morrison and others in their group at\n-  the University of St. Andrews (St. Andrews, Fife, UK).\n-\n-Additional specific influences can be seen from the following languages:\n-\n-* The structural algebraic types and compilation manager of SML.\n-* The attribute and assembly systems of C#.\n-* The references and deterministic destructor system of C++.\n-* The memory region systems of the ML Kit and Cyclone.\n-* The typeclass system of Haskell.\n-* The lexical identifier rule of Python.\n-* The block syntax of Ruby.\n-\n-[ffi]: guide-ffi.html\n-[plugin]: guide-plugin.html"}]}