{"sha": "f9aecdb22ad95c7be37c6e2e45dce2242f6a59d9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5YWVjZGIyMmFkOTVjN2JlMzdjNmUyZTQ1ZGNlMjI0MmY2YTU5ZDk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-06T05:26:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-06T05:26:19Z"}, "message": "auto merge of #10758 : alexcrichton/rust/upgrade-llvm, r=alexcrichton\n\nThis upgrades LLVM in order to make progress on #10708, and it's also been awhile since we last upgraded!\r\n\r\nThe contentious point of this upgrade is that all JIT support has been removed because LLVM is changing it and we're not keeping up with it.", "tree": {"sha": "58f9ea25ec4b9e3e44c045a117a7256ffcdc9790", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/58f9ea25ec4b9e3e44c045a117a7256ffcdc9790"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f9aecdb22ad95c7be37c6e2e45dce2242f6a59d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f9aecdb22ad95c7be37c6e2e45dce2242f6a59d9", "html_url": "https://github.com/rust-lang/rust/commit/f9aecdb22ad95c7be37c6e2e45dce2242f6a59d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f9aecdb22ad95c7be37c6e2e45dce2242f6a59d9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9fc48061d7ffa6a0839daf6577091b2455f785ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/9fc48061d7ffa6a0839daf6577091b2455f785ec", "html_url": "https://github.com/rust-lang/rust/commit/9fc48061d7ffa6a0839daf6577091b2455f785ec"}, {"sha": "17a951c7bf8c302a964a611c6ee1d46c461c50a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/17a951c7bf8c302a964a611c6ee1d46c461c50a3", "html_url": "https://github.com/rust-lang/rust/commit/17a951c7bf8c302a964a611c6ee1d46c461c50a3"}], "stats": {"total": 657, "additions": 75, "deletions": 582}, "files": [{"sha": "42b1a551805aff93816a3e76b94d20e74f68f1b7", "filename": "mk/llvm.mk", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9aecdb22ad95c7be37c6e2e45dce2242f6a59d9/mk%2Fllvm.mk", "raw_url": "https://github.com/rust-lang/rust/raw/f9aecdb22ad95c7be37c6e2e45dce2242f6a59d9/mk%2Fllvm.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fllvm.mk?ref=f9aecdb22ad95c7be37c6e2e45dce2242f6a59d9", "patch": "@@ -37,7 +37,9 @@ endif\n # dependencies. In these cases, commit a change that touches\n # the stamp in the source dir.\n $$(LLVM_STAMP_$(1)): $(S)src/rustllvm/llvm-auto-clean-trigger\n+\t@$$(call E, make: cleaning llvm)\n \t$(Q)$(MAKE) clean-llvm\n+\t@$$(call E, make: done cleaning llvm)\n \ttouch $$@\n \n endef"}, {"sha": "1cb10d59e59c9f35f25136697bf24f69b3be5648", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 30, "deletions": 143, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/f9aecdb22ad95c7be37c6e2e45dce2242f6a59d9/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9aecdb22ad95c7be37c6e2e45dce2242f6a59d9/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=f9aecdb22ad95c7be37c6e2e45dce2242f6a59d9", "patch": "@@ -82,111 +82,8 @@ pub fn WriteOutputFile(\n     }\n }\n \n-pub mod jit {\n-\n-    use back::link::llvm_err;\n-    use driver::session::Session;\n-    use lib::llvm::llvm;\n-    use lib::llvm::{ModuleRef, ContextRef, ExecutionEngineRef};\n-\n-    use std::c_str::ToCStr;\n-    use std::cast;\n-    use std::local_data;\n-    use std::unstable::intrinsics;\n-\n-    struct LLVMJITData {\n-        ee: ExecutionEngineRef,\n-        llcx: ContextRef\n-    }\n-\n-    pub trait Engine {}\n-    impl Engine for LLVMJITData {}\n-\n-    impl Drop for LLVMJITData {\n-        fn drop(&mut self) {\n-            unsafe {\n-                llvm::LLVMDisposeExecutionEngine(self.ee);\n-                llvm::LLVMContextDispose(self.llcx);\n-            }\n-        }\n-    }\n-\n-    pub fn exec(sess: Session,\n-                c: ContextRef,\n-                m: ModuleRef,\n-                stacks: bool) {\n-        unsafe {\n-            let manager = llvm::LLVMRustPrepareJIT(intrinsics::morestack_addr());\n-\n-            // We need to tell JIT where to resolve all linked\n-            // symbols from. The equivalent of -lstd, -lcore, etc.\n-            // By default the JIT will resolve symbols from the extra and\n-            // core linked into rustc. We don't want that,\n-            // incase the user wants to use an older extra library.\n-\n-            // We custom-build a JIT execution engine via some rust wrappers\n-            // first. This wrappers takes ownership of the module passed in.\n-            let ee = llvm::LLVMRustBuildJIT(manager, m, stacks);\n-            if ee.is_null() {\n-                llvm::LLVMContextDispose(c);\n-                llvm_err(sess, ~\"Could not create the JIT\");\n-            }\n-\n-            // Next, we need to get a handle on the _rust_main function by\n-            // looking up it's corresponding ValueRef and then requesting that\n-            // the execution engine compiles the function.\n-            let fun = \"_rust_main\".with_c_str(|entry| {\n-                llvm::LLVMGetNamedFunction(m, entry)\n-            });\n-            if fun.is_null() {\n-                llvm::LLVMDisposeExecutionEngine(ee);\n-                llvm::LLVMContextDispose(c);\n-                llvm_err(sess, ~\"Could not find _rust_main in the JIT\");\n-            }\n-\n-            // Finally, once we have the pointer to the code, we can do some\n-            // closure magic here to turn it straight into a callable rust\n-            // closure\n-            let code = llvm::LLVMGetPointerToGlobal(ee, fun);\n-            assert!(!code.is_null());\n-            let func: extern \"Rust\" fn() = cast::transmute(code);\n-            func();\n-\n-            // Currently there is no method of re-using the executing engine\n-            // from LLVM in another call to the JIT. While this kinda defeats\n-            // the purpose of having a JIT in the first place, there isn't\n-            // actually much code currently which would re-use data between\n-            // different invocations of this. Additionally, the compilation\n-            // model currently isn't designed to support this scenario.\n-            //\n-            // We can't destroy the engine/context immediately here, however,\n-            // because of annihilation. The JIT code contains drop glue for any\n-            // types defined in the crate we just ran, and if any of those boxes\n-            // are going to be dropped during annihilation, the drop glue must\n-            // be run. Hence, we need to transfer ownership of this jit engine\n-            // to the caller of this function. To be convenient for now, we\n-            // shove it into TLS and have someone else remove it later on.\n-            let data = ~LLVMJITData { ee: ee, llcx: c };\n-            set_engine(data as ~Engine);\n-        }\n-    }\n-\n-    // The stage1 compiler won't work, but that doesn't really matter. TLS\n-    // changed only very recently to allow storage of owned values.\n-    local_data_key!(engine_key: ~Engine)\n-\n-    fn set_engine(engine: ~Engine) {\n-        local_data::set(engine_key, engine)\n-    }\n-\n-    pub fn consume_engine() -> Option<~Engine> {\n-        local_data::pop(engine_key)\n-    }\n-}\n-\n pub mod write {\n \n-    use back::link::jit;\n     use back::link::{WriteOutputFile, output_type};\n     use back::link::{output_type_assembly, output_type_bitcode};\n     use back::link::{output_type_exe, output_type_llvm_assembly};\n@@ -307,48 +204,38 @@ pub mod write {\n                 })\n             }\n \n-            if sess.opts.jit {\n-                // If we are using JIT, go ahead and create and execute the\n-                // engine now. JIT execution takes ownership of the module and\n-                // context, so don't dispose\n-                jit::exec(sess, llcx, llmod, true);\n-            } else {\n-                // Create a codegen-specific pass manager to emit the actual\n-                // assembly or object files. This may not end up getting used,\n-                // but we make it anyway for good measure.\n-                let cpm = llvm::LLVMCreatePassManager();\n-                llvm::LLVMRustAddAnalysisPasses(tm, cpm, llmod);\n-                llvm::LLVMRustAddLibraryInfo(cpm, llmod);\n-\n-                match output_type {\n-                    output_type_none => {}\n-                    output_type_bitcode => {\n-                        output.with_c_str(|buf| {\n-                            llvm::LLVMWriteBitcodeToFile(llmod, buf);\n-                        })\n-                    }\n-                    output_type_llvm_assembly => {\n-                        output.with_c_str(|output| {\n-                            llvm::LLVMRustPrintModule(cpm, llmod, output)\n-                        })\n-                    }\n-                    output_type_assembly => {\n-                        WriteOutputFile(sess, tm, cpm, llmod, output, lib::llvm::AssemblyFile);\n-                    }\n-                    output_type_exe | output_type_object => {\n-                        WriteOutputFile(sess, tm, cpm, llmod, output, lib::llvm::ObjectFile);\n-                    }\n+            // Create a codegen-specific pass manager to emit the actual\n+            // assembly or object files. This may not end up getting used,\n+            // but we make it anyway for good measure.\n+            let cpm = llvm::LLVMCreatePassManager();\n+            llvm::LLVMRustAddAnalysisPasses(tm, cpm, llmod);\n+            llvm::LLVMRustAddLibraryInfo(cpm, llmod);\n+\n+            match output_type {\n+                output_type_none => {}\n+                output_type_bitcode => {\n+                    output.with_c_str(|buf| {\n+                        llvm::LLVMWriteBitcodeToFile(llmod, buf);\n+                    })\n+                }\n+                output_type_llvm_assembly => {\n+                    output.with_c_str(|output| {\n+                        llvm::LLVMRustPrintModule(cpm, llmod, output)\n+                    })\n+                }\n+                output_type_assembly => {\n+                    WriteOutputFile(sess, tm, cpm, llmod, output, lib::llvm::AssemblyFile);\n+                }\n+                output_type_exe | output_type_object => {\n+                    WriteOutputFile(sess, tm, cpm, llmod, output, lib::llvm::ObjectFile);\n                 }\n-\n-                llvm::LLVMDisposePassManager(cpm);\n             }\n \n+            llvm::LLVMDisposePassManager(cpm);\n+\n             llvm::LLVMRustDisposeTargetMachine(tm);\n-            // the jit takes ownership of these two items\n-            if !sess.opts.jit {\n-                llvm::LLVMDisposeModule(llmod);\n-                llvm::LLVMContextDispose(llcx);\n-            }\n+            llvm::LLVMDisposeModule(llmod);\n+            llvm::LLVMContextDispose(llcx);\n             if sess.time_llvm_passes() { llvm::LLVMRustPrintPassTimings(); }\n         }\n     }\n@@ -711,8 +598,8 @@ pub fn sanitize(s: &str) -> ~str {\n             ',' => result.push_str(\"$C$\"),\n \n             // '.' doesn't occur in types and functions, so reuse it\n-            // for ':'\n-            ':' => result.push_char('.'),\n+            // for ':' and '-'\n+            '-' | ':' => result.push_char('.'),\n \n             // These are legal symbols\n             'a' .. 'z'"}, {"sha": "730ceba12c786808231c70224556247abfcd1056", "filename": "src/librustc/back/upcall.rs", "status": "modified", "additions": 2, "deletions": 18, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f9aecdb22ad95c7be37c6e2e45dce2242f6a59d9/src%2Flibrustc%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9aecdb22ad95c7be37c6e2e45dce2242f6a59d9/src%2Flibrustc%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fupcall.rs?ref=f9aecdb22ad95c7be37c6e2e45dce2242f6a59d9", "patch": "@@ -15,22 +15,10 @@ use middle::trans::type_::Type;\n use lib::llvm::{ModuleRef, ValueRef};\n \n pub struct Upcalls {\n-    trace: ValueRef,\n     rust_personality: ValueRef,\n-    reset_stack_limit: ValueRef\n }\n \n macro_rules! upcall (\n-    (fn $name:ident($($arg:expr),+) -> $ret:expr) => ({\n-        let fn_ty = Type::func([ $($arg),* ], &$ret);\n-        base::decl_cdecl_fn(llmod, ~\"upcall_\" + stringify!($name), fn_ty)\n-    });\n-    (nothrow fn $name:ident($($arg:expr),+) -> $ret:expr) => ({\n-        let fn_ty = Type::func([ $($arg),* ], &$ret);\n-        let decl = base::decl_cdecl_fn(llmod, ~\"upcall_\" + stringify!($name), fn_ty);\n-        base::set_no_unwind(decl);\n-        decl\n-    });\n     (nothrow fn $name:ident -> $ret:expr) => ({\n         let fn_ty = Type::func([], &$ret);\n         let decl = base::decl_cdecl_fn(llmod, ~\"upcall_\" + stringify!($name), fn_ty);\n@@ -39,13 +27,9 @@ macro_rules! upcall (\n     })\n )\n \n-pub fn declare_upcalls(targ_cfg: @session::config, llmod: ModuleRef) -> @Upcalls {\n-    let opaque_ptr = Type::i8().ptr_to();\n-    let int_ty = Type::int(targ_cfg.arch);\n-\n+pub fn declare_upcalls(_targ_cfg: @session::config,\n+                       llmod: ModuleRef) -> @Upcalls {\n     @Upcalls {\n-        trace: upcall!(fn trace(opaque_ptr, opaque_ptr, int_ty) -> Type::void()),\n         rust_personality: upcall!(nothrow fn rust_personality -> Type::i32()),\n-        reset_stack_limit: upcall!(nothrow fn reset_stack_limit -> Type::void())\n     }\n }"}, {"sha": "63d6c60d2698d07fae13ef37818960d58c6e668c", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f9aecdb22ad95c7be37c6e2e45dce2242f6a59d9/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9aecdb22ad95c7be37c6e2e45dce2242f6a59d9/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=f9aecdb22ad95c7be37c6e2e45dce2242f6a59d9", "patch": "@@ -419,11 +419,6 @@ pub fn stop_after_phase_5(sess: Session) -> bool {\n         debug!(\"not building executable, returning early from compile_input\");\n         return true;\n     }\n-\n-    if sess.opts.jit {\n-        debug!(\"running JIT, returning early from compile_input\");\n-        return true;\n-    }\n     return false;\n }\n \n@@ -751,7 +746,6 @@ pub fn build_session_options(binary: @str,\n         } else { No }\n     };\n     let gc = debugging_opts & session::gc != 0;\n-    let jit = debugging_opts & session::jit != 0;\n     let extra_debuginfo = debugging_opts & session::extra_debug_info != 0;\n     let debuginfo = debugging_opts & session::debug_info != 0 ||\n         extra_debuginfo;\n@@ -802,7 +796,6 @@ pub fn build_session_options(binary: @str,\n         extra_debuginfo: extra_debuginfo,\n         lint_opts: lint_opts,\n         save_temps: save_temps,\n-        jit: jit,\n         output_type: output_type,\n         addl_lib_search_paths: @mut addl_lib_search_paths,\n         ar: ar,"}, {"sha": "6a4755344eff45241c2d49c6c1296256aecca0ef", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 22, "deletions": 29, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/f9aecdb22ad95c7be37c6e2e45dce2242f6a59d9/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9aecdb22ad95c7be37c6e2e45dce2242f6a59d9/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=f9aecdb22ad95c7be37c6e2e45dce2242f6a59d9", "patch": "@@ -44,30 +44,28 @@ pub static time_llvm_passes:        uint = 1 <<  3;\n pub static trans_stats:             uint = 1 <<  4;\n pub static asm_comments:            uint = 1 <<  5;\n pub static no_verify:               uint = 1 <<  6;\n-pub static trace:                   uint = 1 <<  7;\n-pub static coherence:               uint = 1 <<  8;\n-pub static borrowck_stats:          uint = 1 <<  9;\n-pub static borrowck_note_pure:      uint = 1 << 10;\n-pub static borrowck_note_loan:      uint = 1 << 11;\n-pub static no_landing_pads:         uint = 1 << 12;\n-pub static debug_llvm:              uint = 1 << 13;\n-pub static count_type_sizes:        uint = 1 << 14;\n-pub static meta_stats:              uint = 1 << 15;\n-pub static no_opt:                  uint = 1 << 16;\n-pub static gc:                      uint = 1 << 17;\n-pub static jit:                     uint = 1 << 18;\n-pub static debug_info:              uint = 1 << 19;\n-pub static extra_debug_info:        uint = 1 << 20;\n-pub static print_link_args:         uint = 1 << 21;\n-pub static no_debug_borrows:        uint = 1 << 22;\n-pub static lint_llvm:               uint = 1 << 23;\n-pub static print_llvm_passes:       uint = 1 << 24;\n-pub static no_vectorize_loops:      uint = 1 << 25;\n-pub static no_vectorize_slp:        uint = 1 << 26;\n-pub static no_prepopulate_passes:   uint = 1 << 27;\n-pub static use_softfp:              uint = 1 << 28;\n-pub static gen_crate_map:           uint = 1 << 29;\n-pub static prefer_dynamic:          uint = 1 << 30;\n+pub static coherence:               uint = 1 <<  7;\n+pub static borrowck_stats:          uint = 1 <<  8;\n+pub static borrowck_note_pure:      uint = 1 <<  9;\n+pub static borrowck_note_loan:      uint = 1 << 10;\n+pub static no_landing_pads:         uint = 1 << 11;\n+pub static debug_llvm:              uint = 1 << 12;\n+pub static count_type_sizes:        uint = 1 << 13;\n+pub static meta_stats:              uint = 1 << 14;\n+pub static no_opt:                  uint = 1 << 15;\n+pub static gc:                      uint = 1 << 16;\n+pub static debug_info:              uint = 1 << 17;\n+pub static extra_debug_info:        uint = 1 << 18;\n+pub static print_link_args:         uint = 1 << 19;\n+pub static no_debug_borrows:        uint = 1 << 20;\n+pub static lint_llvm:               uint = 1 << 21;\n+pub static print_llvm_passes:       uint = 1 << 22;\n+pub static no_vectorize_loops:      uint = 1 << 23;\n+pub static no_vectorize_slp:        uint = 1 << 24;\n+pub static no_prepopulate_passes:   uint = 1 << 25;\n+pub static use_softfp:              uint = 1 << 26;\n+pub static gen_crate_map:           uint = 1 << 27;\n+pub static prefer_dynamic:          uint = 1 << 28;\n \n pub fn debugging_opts_map() -> ~[(&'static str, &'static str, uint)] {\n     ~[(\"verbose\", \"in general, enable more debug printouts\", verbose),\n@@ -79,7 +77,6 @@ pub fn debugging_opts_map() -> ~[(&'static str, &'static str, uint)] {\n      (\"trans-stats\", \"gather trans statistics\", trans_stats),\n      (\"asm-comments\", \"generate comments into the assembly (may change behavior)\", asm_comments),\n      (\"no-verify\", \"skip LLVM verification\", no_verify),\n-     (\"trace\", \"emit trace logs\", trace),\n      (\"coherence\", \"perform coherence checking\", coherence),\n      (\"borrowck-stats\", \"gather borrowck statistics\",  borrowck_stats),\n      (\"borrowck-note-pure\", \"note where purity is req'd\",\n@@ -95,7 +92,6 @@ pub fn debugging_opts_map() -> ~[(&'static str, &'static str, uint)] {\n      (\"no-opt\", \"do not optimize, even if -O is passed\", no_opt),\n      (\"print-link-args\", \"Print the arguments passed to the linker\", print_link_args),\n      (\"gc\", \"Garbage collect shared data (experimental)\", gc),\n-     (\"jit\", \"Execute using JIT (experimental)\", jit),\n      (\"extra-debug-info\", \"Extra debugging info (experimental)\",\n       extra_debug_info),\n      (\"debug-info\", \"Produce debug info (experimental)\", debug_info),\n@@ -146,7 +142,6 @@ pub struct options {\n     extra_debuginfo: bool,\n     lint_opts: ~[(lint::lint, lint::level)],\n     save_temps: bool,\n-    jit: bool,\n     output_type: back::link::output_type,\n     addl_lib_search_paths: @mut HashSet<Path>, // This is mutable for rustpkg, which\n                                                // updates search paths based on the\n@@ -311,7 +306,6 @@ impl Session_ {\n     pub fn asm_comments(&self) -> bool { self.debugging_opt(asm_comments) }\n     pub fn no_verify(&self) -> bool { self.debugging_opt(no_verify) }\n     pub fn lint_llvm(&self) -> bool { self.debugging_opt(lint_llvm) }\n-    pub fn trace(&self) -> bool { self.debugging_opt(trace) }\n     pub fn coherence(&self) -> bool { self.debugging_opt(coherence) }\n     pub fn borrowck_stats(&self) -> bool { self.debugging_opt(borrowck_stats) }\n     pub fn borrowck_note_pure(&self) -> bool {\n@@ -370,7 +364,6 @@ pub fn basic_options() -> @options {\n         extra_debuginfo: false,\n         lint_opts: ~[],\n         save_temps: false,\n-        jit: false,\n         output_type: link::output_type_exe,\n         addl_lib_search_paths: @mut HashSet::new(),\n         ar: None,"}, {"sha": "166e1414f6ea24b69f07b6102f9594e4bcff3a3b", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9aecdb22ad95c7be37c6e2e45dce2242f6a59d9/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9aecdb22ad95c7be37c6e2e45dce2242f6a59d9/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=f9aecdb22ad95c7be37c6e2e45dce2242f6a59d9", "patch": "@@ -363,10 +363,6 @@ pub fn monitor(f: proc(@diagnostic::Emitter)) {\n         let _finally = finally { ch: ch };\n \n         f(demitter);\n-\n-        // Due reasons explain in #7732, if there was a jit execution context it\n-        // must be consumed and passed along to our parent task.\n-        back::link::jit::consume_engine()\n     }) {\n         result::Ok(_) => { /* fallthrough */ }\n         result::Err(_) => {"}, {"sha": "1e1444babf232007e70edca6cf6b3dd950ba1960", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f9aecdb22ad95c7be37c6e2e45dce2242f6a59d9/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9aecdb22ad95c7be37c6e2e45dce2242f6a59d9/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=f9aecdb22ad95c7be37c6e2e45dce2242f6a59d9", "patch": "@@ -1441,18 +1441,6 @@ pub mod llvm {\n             call. */\n         pub fn LLVMRustGetLastError() -> *c_char;\n \n-        /** Prepare the JIT. Returns a memory manager that can load crates. */\n-        pub fn LLVMRustPrepareJIT(__morestack: *()) -> *();\n-\n-        /** Load a crate into the memory manager. */\n-        pub fn LLVMRustLoadCrate(MM: *(), Filename: *c_char) -> bool;\n-\n-        /** Execute the JIT engine. */\n-        pub fn LLVMRustBuildJIT(MM: *(),\n-                                M: ModuleRef,\n-                                EnableSegmentedStacks: bool)\n-                                -> ExecutionEngineRef;\n-\n         /// Print the pass timings since static dtors aren't picking them up.\n         pub fn LLVMRustPrintPassTimings();\n "}, {"sha": "72b9fc83c4ab881fa8ee23db287b3451abff79fa", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 14, "deletions": 48, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/f9aecdb22ad95c7be37c6e2e45dce2242f6a59d9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9aecdb22ad95c7be37c6e2e45dce2242f6a59d9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=f9aecdb22ad95c7be37c6e2e45dce2242f6a59d9", "patch": "@@ -1018,11 +1018,6 @@ pub fn get_landing_pad(bcx: @mut Block) -> BasicBlockRef {\n     // The landing pad block is a cleanup\n     SetCleanup(pad_bcx, llretval);\n \n-    // Because we may have unwound across a stack boundary, we must call into\n-    // the runtime to figure out which stack segment we are on and place the\n-    // stack limit back into the TLS.\n-    Call(pad_bcx, bcx.ccx().upcalls.reset_stack_limit, [], []);\n-\n     // We store the retval in a function-central alloca, so that calls to\n     // Resume can find it.\n     match bcx.fcx.personality {\n@@ -1097,28 +1092,6 @@ pub fn load_if_immediate(cx: @mut Block, v: ValueRef, t: ty::t) -> ValueRef {\n     return v;\n }\n \n-pub fn trans_trace(bcx: @mut Block, sp_opt: Option<Span>, trace_str: @str) {\n-    if !bcx.sess().trace() { return; }\n-    let _icx = push_ctxt(\"trans_trace\");\n-    add_comment(bcx, trace_str);\n-    let V_trace_str = C_cstr(bcx.ccx(), trace_str);\n-    let (V_filename, V_line) = match sp_opt {\n-      Some(sp) => {\n-        let sess = bcx.sess();\n-        let loc = sess.parse_sess.cm.lookup_char_pos(sp.lo);\n-        (C_cstr(bcx.ccx(), loc.file.name), loc.line as int)\n-      }\n-      None => {\n-        (C_cstr(bcx.ccx(), @\"<runtime>\"), 0)\n-      }\n-    };\n-    let ccx = bcx.ccx();\n-    let V_trace_str = PointerCast(bcx, V_trace_str, Type::i8p());\n-    let V_filename = PointerCast(bcx, V_filename, Type::i8p());\n-    let args = ~[V_trace_str, V_filename, C_int(ccx, V_line)];\n-    Call(bcx, ccx.upcalls.trace, args, []);\n-}\n-\n pub fn ignore_lhs(_bcx: @mut Block, local: &ast::Local) -> bool {\n     match local.pat.node {\n         ast::PatWild => true, _ => false\n@@ -1313,12 +1286,6 @@ pub fn cleanup_and_leave(bcx: @mut Block,\n     loop {\n         debug!(\"cleanup_and_leave: leaving {}\", cur.to_str());\n \n-        if bcx.sess().trace() {\n-            trans_trace(\n-                bcx, None,\n-                (format!(\"cleanup_and_leave({})\", cur.to_str())).to_managed());\n-        }\n-\n         let mut cur_scope = cur.scope;\n         loop {\n             cur_scope = match cur_scope {\n@@ -1387,12 +1354,6 @@ pub fn cleanup_block(bcx: @mut Block, upto: Option<BasicBlockRef>) -> @mut Block\n     loop {\n         debug!(\"cleanup_block: {}\", cur.to_str());\n \n-        if bcx.sess().trace() {\n-            trans_trace(\n-                bcx, None,\n-                (format!(\"cleanup_block({})\", cur.to_str())).to_managed());\n-        }\n-\n         let mut cur_scope = cur.scope;\n         loop {\n             cur_scope = match cur_scope {\n@@ -2961,6 +2922,11 @@ pub fn create_module_map(ccx: &mut CrateContext) -> (ValueRef, uint) {\n     return (map, keys.len())\n }\n \n+pub fn symname(sess: session::Session, name: &str,\n+               hash: &str, vers: &str) -> ~str {\n+    let elt = path_name(sess.ident_of(name));\n+    link::exported_name(sess, ~[elt], hash, vers)\n+}\n \n pub fn decl_crate_map(sess: session::Session, mapmeta: LinkMeta,\n                       llmod: ModuleRef) -> ValueRef {\n@@ -2969,13 +2935,14 @@ pub fn decl_crate_map(sess: session::Session, mapmeta: LinkMeta,\n     let mut n_subcrates = 1;\n     let cstore = sess.cstore;\n     while cstore::have_crate_data(cstore, n_subcrates) { n_subcrates += 1; }\n-    let mapname = if *sess.building_library && !sess.gen_crate_map() {\n-        format!(\"{}_{}_{}\", mapmeta.name, mapmeta.vers, mapmeta.extras_hash)\n+    let is_top = !*sess.building_library || sess.gen_crate_map();\n+    let sym_name = if is_top {\n+        ~\"_rust_crate_map_toplevel\"\n     } else {\n-        ~\"toplevel\"\n+        symname(sess, \"_rust_crate_map_\" + mapmeta.name, mapmeta.extras_hash,\n+                mapmeta.vers)\n     };\n \n-    let sym_name = ~\"_rust_crate_map_\" + mapname;\n     let slicetype = Type::struct_([int_type, int_type], false);\n     let maptype = Type::struct_([\n         Type::i32(),        // version\n@@ -2990,7 +2957,7 @@ pub fn decl_crate_map(sess: session::Session, mapmeta: LinkMeta,\n     });\n     // On windows we'd like to export the toplevel cratemap\n     // such that we can find it from libstd.\n-    if targ_cfg.os == OsWin32 && \"toplevel\" == mapname {\n+    if targ_cfg.os == OsWin32 && is_top {\n         lib::llvm::SetLinkage(map, lib::llvm::DLLExportLinkage);\n     } else {\n         lib::llvm::SetLinkage(map, lib::llvm::ExternalLinkage);\n@@ -3005,10 +2972,9 @@ pub fn fill_crate_map(ccx: @mut CrateContext, map: ValueRef) {\n     let cstore = ccx.sess.cstore;\n     while cstore::have_crate_data(cstore, i) {\n         let cdata = cstore::get_crate_data(cstore, i);\n-        let nm = format!(\"_rust_crate_map_{}_{}_{}\",\n-                      cdata.name,\n-                      cstore::get_crate_vers(cstore, i),\n-                      cstore::get_crate_hash(cstore, i));\n+        let nm = symname(ccx.sess, format!(\"_rust_crate_map_{}\", cdata.name),\n+                         cstore::get_crate_hash(cstore, i),\n+                         cstore::get_crate_vers(cstore, i));\n         let cr = nm.with_c_str(|buf| {\n             unsafe {\n                 llvm::LLVMAddGlobal(ccx.llmod, ccx.int_type.to_ref(), buf)"}, {"sha": "2c3a9e040c95949846c2cb3ec15b3e4349f8b577", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f9aecdb22ad95c7be37c6e2e45dce2242f6a59d9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9aecdb22ad95c7be37c6e2e45dce2242f6a59d9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=f9aecdb22ad95c7be37c6e2e45dce2242f6a59d9", "patch": "@@ -567,8 +567,6 @@ fn trans_to_datum_unadjusted(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n fn trans_rvalue_datum_unadjusted(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n     let _icx = push_ctxt(\"trans_rvalue_datum_unadjusted\");\n \n-    trace_span!(bcx, expr.span, shorten(bcx.expr_to_str(expr)));\n-\n     match expr.node {\n         ast::ExprPath(_) | ast::ExprSelf => {\n             return trans_def_datum_unadjusted(bcx, expr, bcx.def(expr.id));\n@@ -625,8 +623,6 @@ fn trans_rvalue_stmt_unadjusted(bcx: @mut Block, expr: &ast::Expr) -> @mut Block\n         return bcx;\n     }\n \n-    trace_span!(bcx, expr.span, shorten(bcx.expr_to_str(expr)));\n-\n     match expr.node {\n         ast::ExprBreak(label_opt) => {\n             return controlflow::trans_break(bcx, label_opt);\n@@ -676,8 +672,6 @@ fn trans_rvalue_dps_unadjusted(bcx: @mut Block, expr: &ast::Expr,\n     let _icx = push_ctxt(\"trans_rvalue_dps_unadjusted\");\n     let tcx = bcx.tcx();\n \n-    trace_span!(bcx, expr.span, shorten(bcx.expr_to_str(expr)));\n-\n     match expr.node {\n         ast::ExprParen(e) => {\n             return trans_rvalue_dps_unadjusted(bcx, e, dest);\n@@ -895,8 +889,6 @@ fn trans_lvalue_unadjusted(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n     debug!(\"trans_lvalue(expr={})\", bcx.expr_to_str(expr));\n     let _indenter = indenter();\n \n-    trace_span!(bcx, expr.span, shorten(bcx.expr_to_str(expr)));\n-\n     return match expr.node {\n         ast::ExprParen(e) => {\n             trans_lvalue_unadjusted(bcx, e)"}, {"sha": "938484fd44cebfb3cf925086efabc4a8d5fcb25b", "filename": "src/librustc/middle/trans/macros.rs", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f9aecdb22ad95c7be37c6e2e45dce2242f6a59d9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9aecdb22ad95c7be37c6e2e45dce2242f6a59d9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmacros.rs?ref=f9aecdb22ad95c7be37c6e2e45dce2242f6a59d9", "patch": "@@ -29,25 +29,3 @@ macro_rules! unpack_result(\n         }\n     )\n )\n-\n-macro_rules! trace_span(\n-    ($bcx: ident, $sp: expr, $str: expr) => (\n-        {\n-            let bcx = $bcx;\n-            if bcx.sess().trace() {\n-                trans_trace(bcx, Some($sp), $str);\n-            }\n-        }\n-    )\n-)\n-\n-macro_rules! trace(\n-    ($bcx: ident, $str: expr) => (\n-        {\n-            let bcx = $bcx;\n-            if bcx.sess().trace() {\n-                trans_trace(bcx, None, $str);\n-            }\n-        }\n-    )\n-)"}, {"sha": "2da2da80fdd6a9a144f69514dc852dbca0cd9a94", "filename": "src/librustc/middle/trans/write_guard.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f9aecdb22ad95c7be37c6e2e45dce2242f6a59d9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9aecdb22ad95c7be37c6e2e45dce2242f6a59d9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs?ref=f9aecdb22ad95c7be37c6e2e45dce2242f6a59d9", "patch": "@@ -114,13 +114,6 @@ fn root(datum: &Datum,\n     debug!(\"write_guard::root(root_key={:?}, root_info={:?}, datum={:?})\",\n            root_key, root_info, datum.to_str(bcx.ccx()));\n \n-    if bcx.sess().trace() {\n-        trans_trace(\n-            bcx, None,\n-            (format!(\"preserving until end of scope {}\",\n-                  root_info.scope)).to_managed());\n-    }\n-\n     // First, root the datum. Note that we must zero this value,\n     // because sometimes we root on one path but not another.\n     // See e.g. #4904."}, {"sha": "eac6ff795c40778683e42b0c6ab6f6adaceb391d", "filename": "src/llvm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm?ref=f9aecdb22ad95c7be37c6e2e45dce2242f6a59d9", "patch": "@@ -1 +1 @@\n-Subproject commit c9ffab392a39eb85f2f15ffc8d41e8c4f4397b8e\n+Subproject commit eac6ff795c40778683e42b0c6ab6f6adaceb391d"}, {"sha": "18b71fbb1790812b0110244dbf36a66881174b19", "filename": "src/rt/rust_upcall.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f9aecdb22ad95c7be37c6e2e45dce2242f6a59d9/src%2Frt%2Frust_upcall.c", "raw_url": "https://github.com/rust-lang/rust/raw/f9aecdb22ad95c7be37c6e2e45dce2242f6a59d9/src%2Frt%2Frust_upcall.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.c?ref=f9aecdb22ad95c7be37c6e2e45dce2242f6a59d9", "patch": "@@ -51,7 +51,7 @@ struct s_rust_personality_args {\n     struct _Unwind_Context *context;\n };\n \n-void\n+static void\n upcall_s_rust_personality(struct s_rust_personality_args *args) {\n     args->retval = PERSONALITY_FUNC(args->version,\n                                     args->actions,\n@@ -78,6 +78,7 @@ upcall_rust_personality(int version,\n     return args.retval;\n }\n \n+// NOTE: remove after stage0\n // Landing pads need to call this to insert the\n // correct limit into TLS.\n // NB: This must run on the Rust stack because it"}, {"sha": "0ae8991b2e7402091a781939fbebf9e60d390b6a", "filename": "src/rustllvm/PassWrapper.cpp", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f9aecdb22ad95c7be37c6e2e45dce2242f6a59d9/src%2Frustllvm%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f9aecdb22ad95c7be37c6e2e45dce2242f6a59d9/src%2Frustllvm%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FPassWrapper.cpp?ref=f9aecdb22ad95c7be37c6e2e45dce2242f6a59d9", "patch": "@@ -81,7 +81,6 @@ LLVMRustCreateTargetMachine(const char *triple,\n     TargetOptions Options;\n     Options.NoFramePointerElim = true;\n     Options.EnableSegmentedStacks = EnableSegmentedStacks;\n-    Options.FixedStackSegmentSize = 2 * 1024 * 1024; // XXX: This is too big.\n     Options.FloatABIType =\n          (Trip.getEnvironment() == Triple::GNUEABIHF) ? FloatABI::Hard :\n                                                         FloatABI::Default;"}, {"sha": "484cded314710ce6caba992349b805ff6f94b4f2", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 1, "deletions": 277, "changes": 278, "blob_url": "https://github.com/rust-lang/rust/blob/f9aecdb22ad95c7be37c6e2e45dce2242f6a59d9/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f9aecdb22ad95c7be37c6e2e45dce2242f6a59d9/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=f9aecdb22ad95c7be37c6e2e45dce2242f6a59d9", "patch": "@@ -34,282 +34,6 @@ extern \"C\" const char *LLVMRustGetLastError(void) {\n   return LLVMRustError;\n }\n \n-// Custom memory manager for MCJITting. It needs special features\n-// that the generic JIT memory manager doesn't entail. Based on\n-// code from LLI, change where needed for Rust.\n-class RustMCJITMemoryManager : public JITMemoryManager {\n-public:\n-  SmallVector<sys::MemoryBlock, 16> AllocatedDataMem;\n-  SmallVector<sys::MemoryBlock, 16> AllocatedCodeMem;\n-  SmallVector<sys::MemoryBlock, 16> FreeCodeMem;\n-  void* __morestack;\n-  DenseSet<DynamicLibrary*> crates;\n-\n-  RustMCJITMemoryManager(void* sym) : __morestack(sym) { }\n-  ~RustMCJITMemoryManager();\n-\n-  bool loadCrate(const char*, std::string*);\n-\n-  virtual uint8_t *allocateCodeSection(uintptr_t Size, unsigned Alignment,\n-                                       unsigned SectionID);\n-\n-  virtual uint8_t *allocateDataSection(uintptr_t Size, unsigned Alignment,\n-                                       unsigned SectionID, bool isReadOnly);\n-  bool finalizeMemory(std::string *ErrMsg) { return false; }\n-\n-  virtual bool applyPermissions(std::string *Str);\n-\n-  virtual void *getPointerToNamedFunction(const std::string &Name,\n-                                          bool AbortOnFailure = true);\n-\n-  // Invalidate instruction cache for code sections. Some platforms with\n-  // separate data cache and instruction cache require explicit cache flush,\n-  // otherwise JIT code manipulations (like resolved relocations) will get to\n-  // the data cache but not to the instruction cache.\n-  virtual void invalidateInstructionCache();\n-\n-  // The MCJITMemoryManager doesn't use the following functions, so we don't\n-  // need implement them.\n-  virtual void setMemoryWritable() {\n-    llvm_unreachable(\"Unimplemented call\");\n-  }\n-  virtual void setMemoryExecutable() {\n-    llvm_unreachable(\"Unimplemented call\");\n-  }\n-  virtual void setPoisonMemory(bool poison) {\n-    llvm_unreachable(\"Unimplemented call\");\n-  }\n-  virtual void AllocateGOT() {\n-    llvm_unreachable(\"Unimplemented call\");\n-  }\n-  virtual uint8_t *getGOTBase() const {\n-    llvm_unreachable(\"Unimplemented call\");\n-    return 0;\n-  }\n-  virtual uint8_t *startFunctionBody(const Function *F,\n-                                     uintptr_t &ActualSize){\n-    llvm_unreachable(\"Unimplemented call\");\n-    return 0;\n-  }\n-  virtual uint8_t *allocateStub(const GlobalValue* F, unsigned StubSize,\n-                                unsigned Alignment) {\n-    llvm_unreachable(\"Unimplemented call\");\n-    return 0;\n-  }\n-  virtual void endFunctionBody(const Function *F, uint8_t *FunctionStart,\n-                               uint8_t *FunctionEnd) {\n-    llvm_unreachable(\"Unimplemented call\");\n-  }\n-  virtual uint8_t *allocateSpace(intptr_t Size, unsigned Alignment) {\n-    llvm_unreachable(\"Unimplemented call\");\n-    return 0;\n-  }\n-  virtual uint8_t *allocateGlobal(uintptr_t Size, unsigned Alignment) {\n-    llvm_unreachable(\"Unimplemented call\");\n-    return 0;\n-  }\n-  virtual void deallocateFunctionBody(void *Body) {\n-    llvm_unreachable(\"Unimplemented call\");\n-  }\n-  virtual uint8_t* startExceptionTable(const Function* F,\n-                                       uintptr_t &ActualSize) {\n-    llvm_unreachable(\"Unimplemented call\");\n-    return 0;\n-  }\n-  virtual void endExceptionTable(const Function *F, uint8_t *TableStart,\n-                                 uint8_t *TableEnd, uint8_t* FrameRegister) {\n-    llvm_unreachable(\"Unimplemented call\");\n-  }\n-  virtual void deallocateExceptionTable(void *ET) {\n-    llvm_unreachable(\"Unimplemented call\");\n-  }\n-};\n-\n-bool RustMCJITMemoryManager::loadCrate(const char* file, std::string* err) {\n-  DynamicLibrary crate = DynamicLibrary::getPermanentLibrary(file,\n-                                                             err);\n-\n-  if(crate.isValid()) {\n-    crates.insert(&crate);\n-\n-    return true;\n-  }\n-\n-  return false;\n-}\n-\n-uint8_t *RustMCJITMemoryManager::allocateDataSection(uintptr_t Size,\n-                                                     unsigned Alignment,\n-                                                     unsigned SectionID,\n-                                                     bool isReadOnly) {\n-  if (!Alignment)\n-    Alignment = 16;\n-  uint8_t *Addr = (uint8_t*)calloc((Size + Alignment - 1)/Alignment, Alignment);\n-  AllocatedDataMem.push_back(sys::MemoryBlock(Addr, Size));\n-  return Addr;\n-}\n-\n-bool RustMCJITMemoryManager::applyPermissions(std::string *Str) {\n-    // Empty.\n-    return true;\n-}\n-\n-uint8_t *RustMCJITMemoryManager::allocateCodeSection(uintptr_t Size,\n-                                                     unsigned Alignment,\n-                                                     unsigned SectionID) {\n-  if (!Alignment)\n-    Alignment = 16;\n-  unsigned NeedAllocate = Alignment * ((Size + Alignment - 1)/Alignment + 1);\n-  uintptr_t Addr = 0;\n-  // Look in the list of free code memory regions and use a block there if one\n-  // is available.\n-  for (int i = 0, e = FreeCodeMem.size(); i != e; ++i) {\n-    sys::MemoryBlock &MB = FreeCodeMem[i];\n-    if (MB.size() >= NeedAllocate) {\n-      Addr = (uintptr_t)MB.base();\n-      uintptr_t EndOfBlock = Addr + MB.size();\n-      // Align the address.\n-      Addr = (Addr + Alignment - 1) & ~(uintptr_t)(Alignment - 1);\n-      // Store cutted free memory block.\n-      FreeCodeMem[i] = sys::MemoryBlock((void*)(Addr + Size),\n-                                        EndOfBlock - Addr - Size);\n-      return (uint8_t*)Addr;\n-    }\n-  }\n-\n-  // No pre-allocated free block was large enough. Allocate a new memory region.\n-  sys::MemoryBlock MB = sys::Memory::AllocateRWX(NeedAllocate, 0, 0);\n-\n-  AllocatedCodeMem.push_back(MB);\n-  Addr = (uintptr_t)MB.base();\n-  uintptr_t EndOfBlock = Addr + MB.size();\n-  // Align the address.\n-  Addr = (Addr + Alignment - 1) & ~(uintptr_t)(Alignment - 1);\n-  // The AllocateRWX may allocate much more memory than we need. In this case,\n-  // we store the unused memory as a free memory block.\n-  unsigned FreeSize = EndOfBlock-Addr-Size;\n-  if (FreeSize > 16)\n-    FreeCodeMem.push_back(sys::MemoryBlock((void*)(Addr + Size), FreeSize));\n-\n-  // Return aligned address\n-  return (uint8_t*)Addr;\n-}\n-\n-void RustMCJITMemoryManager::invalidateInstructionCache() {\n-  for (int i = 0, e = AllocatedCodeMem.size(); i != e; ++i)\n-    sys::Memory::InvalidateInstructionCache(AllocatedCodeMem[i].base(),\n-                                            AllocatedCodeMem[i].size());\n-}\n-\n-void *RustMCJITMemoryManager::getPointerToNamedFunction(const std::string &Name,\n-                                                       bool AbortOnFailure) {\n-#ifdef __linux__\n-  // Force the following functions to be linked in to anything that uses the\n-  // JIT. This is a hack designed to work around the all-too-clever Glibc\n-  // strategy of making these functions work differently when inlined vs. when\n-  // not inlined, and hiding their real definitions in a separate archive file\n-  // that the dynamic linker can't see. For more info, search for\n-  // 'libc_nonshared.a' on Google, or read http://llvm.org/PR274.\n-  if (Name == \"stat\") return (void*)(intptr_t)&stat;\n-  if (Name == \"fstat\") return (void*)(intptr_t)&fstat;\n-  if (Name == \"lstat\") return (void*)(intptr_t)&lstat;\n-  if (Name == \"stat64\") return (void*)(intptr_t)&stat64;\n-  if (Name == \"fstat64\") return (void*)(intptr_t)&fstat64;\n-  if (Name == \"lstat64\") return (void*)(intptr_t)&lstat64;\n-  if (Name == \"atexit\") return (void*)(intptr_t)&atexit;\n-  if (Name == \"mknod\") return (void*)(intptr_t)&mknod;\n-#endif\n-\n-  if (Name == \"__morestack\" || Name == \"___morestack\") return &__morestack;\n-\n-  const char *NameStr = Name.c_str();\n-\n-  // Look through loaded crates and main for symbols.\n-\n-  void *Ptr = sys::DynamicLibrary::SearchForAddressOfSymbol(NameStr);\n-  if (Ptr) return Ptr;\n-\n-  // If it wasn't found and if it starts with an underscore ('_') character,\n-  // try again without the underscore.\n-  if (NameStr[0] == '_') {\n-    Ptr = sys::DynamicLibrary::SearchForAddressOfSymbol(NameStr+1);\n-    if (Ptr) return Ptr;\n-  }\n-\n-  if (AbortOnFailure)\n-    report_fatal_error(\"Program used external function '\" + Name +\n-                      \"' which could not be resolved!\");\n-  return 0;\n-}\n-\n-RustMCJITMemoryManager::~RustMCJITMemoryManager() {\n-  for (unsigned i = 0, e = AllocatedCodeMem.size(); i != e; ++i)\n-    sys::Memory::ReleaseRWX(AllocatedCodeMem[i]);\n-  for (unsigned i = 0, e = AllocatedDataMem.size(); i != e; ++i)\n-    free(AllocatedDataMem[i].base());\n-}\n-\n-extern \"C\" void*\n-LLVMRustPrepareJIT(void* __morestack) {\n-  // An execution engine will take ownership of this later\n-  // and clean it up for us.\n-\n-  return (void*) new RustMCJITMemoryManager(__morestack);\n-}\n-\n-extern \"C\" bool\n-LLVMRustLoadCrate(void* mem, const char* crate) {\n-  RustMCJITMemoryManager* manager = (RustMCJITMemoryManager*) mem;\n-  std::string Err;\n-\n-  assert(manager);\n-\n-  if(!manager->loadCrate(crate, &Err)) {\n-    LLVMRustError = Err.c_str();\n-    return false;\n-  }\n-\n-  return true;\n-}\n-\n-extern \"C\" LLVMExecutionEngineRef\n-LLVMRustBuildJIT(void* mem,\n-                 LLVMModuleRef M,\n-                 bool EnableSegmentedStacks) {\n-\n-  InitializeNativeTarget();\n-  InitializeNativeTargetAsmPrinter();\n-  InitializeNativeTargetAsmParser();\n-\n-  std::string Err;\n-  TargetOptions Options;\n-  Options.JITEmitDebugInfo = true;\n-  Options.NoFramePointerElim = true;\n-  Options.EnableSegmentedStacks = EnableSegmentedStacks;\n-  RustMCJITMemoryManager* MM = (RustMCJITMemoryManager*) mem;\n-  assert(MM);\n-\n-  ExecutionEngine* EE = EngineBuilder(unwrap(M))\n-    .setErrorStr(&Err)\n-    .setTargetOptions(Options)\n-    .setJITMemoryManager(MM)\n-    .setUseMCJIT(true)\n-    .setAllocateGVsWithCode(false)\n-    .create();\n-\n-  if(!EE || Err != \"\") {\n-    LLVMRustError = Err.c_str();\n-    // The EngineBuilder only takes ownership of these two structures if the\n-    // create() call is successful, but here it wasn't successful.\n-    LLVMDisposeModule(M);\n-    delete MM;\n-    return NULL;\n-  }\n-\n-  MM->invalidateInstructionCache();\n-  return wrap(EE);\n-}\n-\n extern \"C\" void\n LLVMRustSetNormalizedTarget(LLVMModuleRef M, const char *triple) {\n     unwrap(M)->setTargetTriple(Triple::normalize(triple));\n@@ -566,7 +290,7 @@ extern \"C\" LLVMValueRef LLVMDIBuilderCreateStructType(\n         unwrapDI<DIType>(DerivedFrom),\n         unwrapDI<DIArray>(Elements),\n         RunTimeLang,\n-        unwrapDI<MDNode*>(VTableHolder),\n+        unwrapDI<DIType>(VTableHolder),\n         UniqueId));\n }\n "}, {"sha": "bae0ad8fbc6c198e1e5ba0e426d9d317d70acf38", "filename": "src/rustllvm/llvm-auto-clean-trigger", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9aecdb22ad95c7be37c6e2e45dce2242f6a59d9/src%2Frustllvm%2Fllvm-auto-clean-trigger", "raw_url": "https://github.com/rust-lang/rust/raw/f9aecdb22ad95c7be37c6e2e45dce2242f6a59d9/src%2Frustllvm%2Fllvm-auto-clean-trigger", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Fllvm-auto-clean-trigger?ref=f9aecdb22ad95c7be37c6e2e45dce2242f6a59d9", "patch": "@@ -1,4 +1,4 @@\n # If this file is modified, then llvm will be forcibly cleaned and then rebuilt.\n # The actual contents of this file do not matter, but to trigger a change on the\n # build bots then the contents should be changed so git updates the mtime.\n-2013-09-23\n+2013-12-05"}, {"sha": "d8ec1c868408d0738b2a9dfbd4301e75d6a67afd", "filename": "src/rustllvm/rustllvm.def.in", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f9aecdb22ad95c7be37c6e2e45dce2242f6a59d9/src%2Frustllvm%2Frustllvm.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/f9aecdb22ad95c7be37c6e2e45dce2242f6a59d9/src%2Frustllvm%2Frustllvm.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Frustllvm.def.in?ref=f9aecdb22ad95c7be37c6e2e45dce2242f6a59d9", "patch": "@@ -3,9 +3,6 @@ LLVMRustWriteOutputFile\n LLVMRustGetLastError\n LLVMRustConstSmallInt\n LLVMRustConstInt\n-LLVMRustLoadCrate\n-LLVMRustPrepareJIT\n-LLVMRustBuildJIT\n LLVMRustPrintPassTimings\n LLVMRustStartMultithreading\n LLVMCreateObjectFile"}]}