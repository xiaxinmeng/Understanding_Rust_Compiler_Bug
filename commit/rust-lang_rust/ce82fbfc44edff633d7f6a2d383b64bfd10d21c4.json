{"sha": "ce82fbfc44edff633d7f6a2d383b64bfd10d21c4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlODJmYmZjNDRlZGZmNjMzZDdmNmEyZDM4M2I2NGJmZDEwZDIxYzQ=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-05-23T18:08:10Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-05-23T18:08:10Z"}, "message": "remove more references", "tree": {"sha": "4e3565e01612f30043b11222459ff485bb2f319e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e3565e01612f30043b11222459ff485bb2f319e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce82fbfc44edff633d7f6a2d383b64bfd10d21c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce82fbfc44edff633d7f6a2d383b64bfd10d21c4", "html_url": "https://github.com/rust-lang/rust/commit/ce82fbfc44edff633d7f6a2d383b64bfd10d21c4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce82fbfc44edff633d7f6a2d383b64bfd10d21c4/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bde9cab66ec04b185679a39ded69d0ab857aec33", "url": "https://api.github.com/repos/rust-lang/rust/commits/bde9cab66ec04b185679a39ded69d0ab857aec33", "html_url": "https://github.com/rust-lang/rust/commit/bde9cab66ec04b185679a39ded69d0ab857aec33"}], "stats": {"total": 112, "additions": 56, "deletions": 56}, "files": [{"sha": "b6834bc2580ace24b58820c5d9dc6384892ea75f", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 56, "deletions": 56, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/ce82fbfc44edff633d7f6a2d383b64bfd10d21c4/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce82fbfc44edff633d7f6a2d383b64bfd10d21c4/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=ce82fbfc44edff633d7f6a2d383b64bfd10d21c4", "patch": "@@ -533,16 +533,16 @@ pub enum DefWithBody {\n impl_froms!(DefWithBody: Function, Const, Static);\n \n impl DefWithBody {\n-    pub fn infer(&self, db: &impl HirDatabase) -> Arc<InferenceResult> {\n-        db.infer(*self)\n+    pub fn infer(self, db: &impl HirDatabase) -> Arc<InferenceResult> {\n+        db.infer(self)\n     }\n \n-    pub fn body(&self, db: &impl HirDatabase) -> Arc<Body> {\n-        db.body_hir(*self)\n+    pub fn body(self, db: &impl HirDatabase) -> Arc<Body> {\n+        db.body_hir(self)\n     }\n \n-    pub fn body_source_map(&self, db: &impl HirDatabase) -> Arc<BodySourceMap> {\n-        db.body_with_source_map(*self).1\n+    pub fn body_source_map(self, db: &impl HirDatabase) -> Arc<BodySourceMap> {\n+        db.body_with_source_map(self).1\n     }\n \n     /// Builds a resolver for code inside this item.\n@@ -592,50 +592,50 @@ impl FnSignature {\n }\n \n impl Function {\n-    pub fn source(&self, db: &impl DefDatabase) -> (HirFileId, TreeArc<ast::FnDef>) {\n+    pub fn source(self, db: &impl DefDatabase) -> (HirFileId, TreeArc<ast::FnDef>) {\n         self.id.source(db)\n     }\n \n-    pub fn module(&self, db: &impl DefDatabase) -> Module {\n+    pub fn module(self, db: &impl DefDatabase) -> Module {\n         self.id.module(db)\n     }\n \n-    pub fn name(&self, db: &impl HirDatabase) -> Name {\n+    pub fn name(self, db: &impl HirDatabase) -> Name {\n         self.signature(db).name.clone()\n     }\n \n-    pub(crate) fn body_source_map(&self, db: &impl HirDatabase) -> Arc<BodySourceMap> {\n-        db.body_with_source_map((*self).into()).1\n+    pub(crate) fn body_source_map(self, db: &impl HirDatabase) -> Arc<BodySourceMap> {\n+        db.body_with_source_map(self.into()).1\n     }\n \n-    pub fn body(&self, db: &impl HirDatabase) -> Arc<Body> {\n-        db.body_hir((*self).into())\n+    pub fn body(self, db: &impl HirDatabase) -> Arc<Body> {\n+        db.body_hir(self.into())\n     }\n \n-    pub fn ty(&self, db: &impl HirDatabase) -> Ty {\n-        db.type_for_def((*self).into(), Namespace::Values)\n+    pub fn ty(self, db: &impl HirDatabase) -> Ty {\n+        db.type_for_def(self.into(), Namespace::Values)\n     }\n \n-    pub fn signature(&self, db: &impl HirDatabase) -> Arc<FnSignature> {\n-        db.fn_signature(*self)\n+    pub fn signature(self, db: &impl HirDatabase) -> Arc<FnSignature> {\n+        db.fn_signature(self)\n     }\n \n-    pub fn infer(&self, db: &impl HirDatabase) -> Arc<InferenceResult> {\n-        db.infer((*self).into())\n+    pub fn infer(self, db: &impl HirDatabase) -> Arc<InferenceResult> {\n+        db.infer(self.into())\n     }\n \n     /// The containing impl block, if this is a method.\n-    pub fn impl_block(&self, db: &impl DefDatabase) -> Option<ImplBlock> {\n+    pub fn impl_block(self, db: &impl DefDatabase) -> Option<ImplBlock> {\n         let module_impls = db.impls_in_module(self.module(db));\n-        ImplBlock::containing(module_impls, (*self).into())\n+        ImplBlock::containing(module_impls, self.into())\n     }\n \n     /// The containing trait, if this is a trait method definition.\n-    pub fn parent_trait(&self, db: &impl DefDatabase) -> Option<Trait> {\n-        db.trait_items_index(self.module(db)).get_parent_trait((*self).into())\n+    pub fn parent_trait(self, db: &impl DefDatabase) -> Option<Trait> {\n+        db.trait_items_index(self.module(db)).get_parent_trait(self.into())\n     }\n \n-    pub fn container(&self, db: &impl DefDatabase) -> Option<Container> {\n+    pub fn container(self, db: &impl DefDatabase) -> Option<Container> {\n         if let Some(impl_block) = self.impl_block(db) {\n             Some(impl_block.into())\n         } else if let Some(trait_) = self.parent_trait(db) {\n@@ -647,7 +647,7 @@ impl Function {\n \n     // FIXME: move to a more general type for 'body-having' items\n     /// Builds a resolver for code inside this item.\n-    pub(crate) fn resolver(&self, db: &impl HirDatabase) -> Resolver {\n+    pub(crate) fn resolver(self, db: &impl HirDatabase) -> Resolver {\n         // take the outer scope...\n         let r = self.container(db).map_or_else(|| self.module(db).resolver(db), |c| c.resolver(db));\n         // ...and add generic params, if present\n@@ -656,10 +656,10 @@ impl Function {\n         r\n     }\n \n-    pub fn diagnostics(&self, db: &impl HirDatabase, sink: &mut DiagnosticSink) {\n+    pub fn diagnostics(self, db: &impl HirDatabase, sink: &mut DiagnosticSink) {\n         let infer = self.infer(db);\n-        infer.add_diagnostics(db, *self, sink);\n-        let mut validator = ExprValidator::new(*self, infer, sink);\n+        infer.add_diagnostics(db, self, sink);\n+        let mut validator = ExprValidator::new(self, infer, sink);\n         validator.validate_body(db);\n     }\n }\n@@ -676,31 +676,31 @@ pub struct Const {\n }\n \n impl Const {\n-    pub fn source(&self, db: &impl DefDatabase) -> (HirFileId, TreeArc<ast::ConstDef>) {\n+    pub fn source(self, db: &impl DefDatabase) -> (HirFileId, TreeArc<ast::ConstDef>) {\n         self.id.source(db)\n     }\n \n-    pub fn module(&self, db: &impl DefDatabase) -> Module {\n+    pub fn module(self, db: &impl DefDatabase) -> Module {\n         self.id.module(db)\n     }\n \n-    pub fn signature(&self, db: &impl HirDatabase) -> Arc<ConstSignature> {\n-        db.const_signature(*self)\n+    pub fn signature(self, db: &impl HirDatabase) -> Arc<ConstSignature> {\n+        db.const_signature(self)\n     }\n \n-    pub fn infer(&self, db: &impl HirDatabase) -> Arc<InferenceResult> {\n-        db.infer((*self).into())\n+    pub fn infer(self, db: &impl HirDatabase) -> Arc<InferenceResult> {\n+        db.infer(self.into())\n     }\n \n     /// The containing impl block, if this is a method.\n-    pub fn impl_block(&self, db: &impl DefDatabase) -> Option<ImplBlock> {\n+    pub fn impl_block(self, db: &impl DefDatabase) -> Option<ImplBlock> {\n         let module_impls = db.impls_in_module(self.module(db));\n-        ImplBlock::containing(module_impls, (*self).into())\n+        ImplBlock::containing(module_impls, self.into())\n     }\n \n     // FIXME: move to a more general type for 'body-having' items\n     /// Builds a resolver for code inside this item.\n-    pub(crate) fn resolver(&self, db: &impl HirDatabase) -> Resolver {\n+    pub(crate) fn resolver(self, db: &impl HirDatabase) -> Resolver {\n         // take the outer scope...\n         let r = self\n             .impl_block(db)\n@@ -739,26 +739,26 @@ pub struct Static {\n }\n \n impl Static {\n-    pub fn source(&self, db: &impl DefDatabase) -> (HirFileId, TreeArc<ast::StaticDef>) {\n+    pub fn source(self, db: &impl DefDatabase) -> (HirFileId, TreeArc<ast::StaticDef>) {\n         self.id.source(db)\n     }\n \n-    pub fn module(&self, db: &impl DefDatabase) -> Module {\n+    pub fn module(self, db: &impl DefDatabase) -> Module {\n         self.id.module(db)\n     }\n \n-    pub fn signature(&self, db: &impl HirDatabase) -> Arc<ConstSignature> {\n-        db.static_signature(*self)\n+    pub fn signature(self, db: &impl HirDatabase) -> Arc<ConstSignature> {\n+        db.static_signature(self)\n     }\n \n     /// Builds a resolver for code inside this item.\n-    pub(crate) fn resolver(&self, db: &impl HirDatabase) -> Resolver {\n+    pub(crate) fn resolver(self, db: &impl HirDatabase) -> Resolver {\n         // take the outer scope...\n         self.module(db).resolver(db)\n     }\n \n-    pub fn infer(&self, db: &impl HirDatabase) -> Arc<InferenceResult> {\n-        db.infer((*self).into())\n+    pub fn infer(self, db: &impl HirDatabase) -> Arc<InferenceResult> {\n+        db.infer(self.into())\n     }\n }\n \n@@ -774,11 +774,11 @@ pub struct Trait {\n }\n \n impl Trait {\n-    pub fn source(&self, db: &impl DefDatabase) -> (HirFileId, TreeArc<ast::TraitDef>) {\n+    pub fn source(self, db: &impl DefDatabase) -> (HirFileId, TreeArc<ast::TraitDef>) {\n         self.id.source(db)\n     }\n \n-    pub fn module(&self, db: &impl DefDatabase) -> Module {\n+    pub fn module(self, db: &impl DefDatabase) -> Module {\n         self.id.module(db)\n     }\n \n@@ -802,7 +802,7 @@ impl Trait {\n         self.trait_data(db).is_auto()\n     }\n \n-    pub(crate) fn resolver(&self, db: &impl DefDatabase) -> Resolver {\n+    pub(crate) fn resolver(self, db: &impl DefDatabase) -> Resolver {\n         let r = self.module(db).resolver(db);\n         // add generic params, if present\n         let p = self.generic_params(db);\n@@ -823,26 +823,26 @@ pub struct TypeAlias {\n }\n \n impl TypeAlias {\n-    pub fn source(&self, db: &impl DefDatabase) -> (HirFileId, TreeArc<ast::TypeAliasDef>) {\n+    pub fn source(self, db: &impl DefDatabase) -> (HirFileId, TreeArc<ast::TypeAliasDef>) {\n         self.id.source(db)\n     }\n \n-    pub fn module(&self, db: &impl DefDatabase) -> Module {\n+    pub fn module(self, db: &impl DefDatabase) -> Module {\n         self.id.module(db)\n     }\n \n     /// The containing impl block, if this is a method.\n-    pub fn impl_block(&self, db: &impl DefDatabase) -> Option<ImplBlock> {\n+    pub fn impl_block(self, db: &impl DefDatabase) -> Option<ImplBlock> {\n         let module_impls = db.impls_in_module(self.module(db));\n-        ImplBlock::containing(module_impls, (*self).into())\n+        ImplBlock::containing(module_impls, self.into())\n     }\n \n     /// The containing trait, if this is a trait method definition.\n-    pub fn parent_trait(&self, db: &impl DefDatabase) -> Option<Trait> {\n-        db.trait_items_index(self.module(db)).get_parent_trait((*self).into())\n+    pub fn parent_trait(self, db: &impl DefDatabase) -> Option<Trait> {\n+        db.trait_items_index(self.module(db)).get_parent_trait(self.into())\n     }\n \n-    pub fn container(&self, db: &impl DefDatabase) -> Option<Container> {\n+    pub fn container(self, db: &impl DefDatabase) -> Option<Container> {\n         if let Some(impl_block) = self.impl_block(db) {\n             Some(impl_block.into())\n         } else if let Some(trait_) = self.parent_trait(db) {\n@@ -857,7 +857,7 @@ impl TypeAlias {\n     }\n \n     /// Builds a resolver for the type references in this type alias.\n-    pub(crate) fn resolver(&self, db: &impl HirDatabase) -> Resolver {\n+    pub(crate) fn resolver(self, db: &impl HirDatabase) -> Resolver {\n         // take the outer scope...\n         let r = self\n             .impl_block(db)\n@@ -883,7 +883,7 @@ pub enum Container {\n impl_froms!(Container: Trait, ImplBlock);\n \n impl Container {\n-    pub(crate) fn resolver(&self, db: &impl DefDatabase) -> Resolver {\n+    pub(crate) fn resolver(self, db: &impl DefDatabase) -> Resolver {\n         match self {\n             Container::Trait(trait_) => trait_.resolver(db),\n             Container::ImplBlock(impl_block) => impl_block.resolver(db),"}]}