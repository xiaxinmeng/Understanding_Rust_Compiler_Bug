{"sha": "81b8e20f31dbc5b2e985ba4109bf86fe6e06f2e2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxYjhlMjBmMzFkYmM1YjJlOTg1YmE0MTA5YmY4NmZlNmUwNmYyZTI=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-05-25T06:42:12Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-05-25T18:03:29Z"}, "message": "std: Rename uv::hl to uv::iotask. Additional cleanup", "tree": {"sha": "1afaadbaffc5a56a596db88cbd3464eaa38e7254", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1afaadbaffc5a56a596db88cbd3464eaa38e7254"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/81b8e20f31dbc5b2e985ba4109bf86fe6e06f2e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/81b8e20f31dbc5b2e985ba4109bf86fe6e06f2e2", "html_url": "https://github.com/rust-lang/rust/commit/81b8e20f31dbc5b2e985ba4109bf86fe6e06f2e2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/81b8e20f31dbc5b2e985ba4109bf86fe6e06f2e2/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "59262dfc6280b81f56129aaa6deaf2f74c63efa6", "url": "https://api.github.com/repos/rust-lang/rust/commits/59262dfc6280b81f56129aaa6deaf2f74c63efa6", "html_url": "https://github.com/rust-lang/rust/commit/59262dfc6280b81f56129aaa6deaf2f74c63efa6"}], "stats": {"total": 314, "additions": 156, "deletions": 158}, "files": [{"sha": "b59217fcea3903bd2f8b7a21f87f11d99681e238", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 39, "deletions": 37, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/81b8e20f31dbc5b2e985ba4109bf86fe6e06f2e2/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81b8e20f31dbc5b2e985ba4109bf86fe6e06f2e2/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=81b8e20f31dbc5b2e985ba4109bf86fe6e06f2e2", "patch": "@@ -4,6 +4,8 @@ High-level interface to libuv's TCP functionality\n \n // FIXME: Fewer import *'s\n import ip = net_ip;\n+import uv::iotask;\n+import uv::iotask::iotask;\n import comm::*;\n import result::*;\n import str::*;\n@@ -44,7 +46,7 @@ resource tcp_socket(socket_data: @tcp_socket_data)\n     };\n     let close_data_ptr = ptr::addr_of(close_data);\n     let stream_handle_ptr = (*socket_data).stream_handle_ptr;\n-    uv::hl::interact((*socket_data).hl_loop) {|loop_ptr|\n+    iotask::interact((*socket_data).iotask) {|loop_ptr|\n         log(debug, #fmt(\"interact dtor for tcp_socket stream %? loop %?\",\n             stream_handle_ptr, loop_ptr));\n         uv::ll::set_data_for_uv_handle(stream_handle_ptr,\n@@ -62,8 +64,8 @@ resource tcp_conn_port(conn_data: @tcp_conn_port_data) unsafe {\n     let conn_data_ptr = ptr::addr_of(*conn_data);\n     let server_stream_ptr = ptr::addr_of((*conn_data_ptr).server_stream);\n     let stream_closed_po = (*conn_data).stream_closed_po;\n-    let hl_loop = (*conn_data_ptr).hl_loop;\n-    uv::hl::interact(hl_loop) {|loop_ptr|\n+    let iotask = (*conn_data_ptr).iotask;\n+    iotask::interact(iotask) {|loop_ptr|\n         log(debug, #fmt(\"dtor for tcp_conn_port loop: %?\",\n                        loop_ptr));\n         uv::ll::close(server_stream_ptr, tcp_nl_close_cb);\n@@ -86,7 +88,7 @@ Initiate a client connection over TCP/IP\n \n * `ip` - The IP address (versions 4 or 6) of the remote host\n * `port` - the unsigned integer of the desired remote host port\n-* `hl_loop` - a `uv::hl::high_level_loop` that the tcp request will run on\n+* `iotask` - a `uv::iotask` that the tcp request will run on\n \n # Returns\n \n@@ -95,7 +97,7 @@ can be used to send and receive data to/from the remote host. In the event\n of failure, a `tcp_err_data` will be returned\n \"]\n fn connect(input_ip: ip::ip_addr, port: uint,\n-           hl_loop: uv::hl::high_level_loop)\n+           iotask: iotask)\n     -> result::result<tcp_socket, tcp_err_data> unsafe {\n     let result_po = comm::port::<conn_attempt>();\n     let closed_signal_po = comm::port::<()>();\n@@ -113,15 +115,15 @@ fn connect(input_ip: ip::ip_addr, port: uint,\n         stream_handle_ptr: stream_handle_ptr,\n         connect_req: uv::ll::connect_t(),\n         write_req: uv::ll::write_t(),\n-        hl_loop: hl_loop\n+        iotask: iotask\n     };\n     let socket_data_ptr = ptr::addr_of(*socket_data);\n     log(debug, #fmt(\"tcp_connect result_ch %?\", conn_data.result_ch));\n     // get an unsafe representation of our stream_handle_ptr that\n     // we can send into the interact cb to be handled in libuv..\n     log(debug, #fmt(\"stream_handle_ptr outside interact %?\",\n         stream_handle_ptr));\n-    uv::hl::interact(hl_loop) {|loop_ptr|\n+    iotask::interact(iotask) {|loop_ptr|\n         log(debug, \"in interact cb for tcp client connect..\");\n         log(debug, #fmt(\"stream_handle_ptr in interact %?\",\n             stream_handle_ptr));\n@@ -354,7 +356,7 @@ to listen for, and accept, new connections, or a `tcp_err_data` if\n failure to create the tcp listener occurs\n \"]\n fn new_listener(host_ip: ip::ip_addr, port: uint, backlog: uint,\n-                hl_loop: uv::hl::high_level_loop)\n+                iotask: iotask)\n     -> result::result<tcp_conn_port, tcp_err_data> unsafe {\n     let stream_closed_po = comm::port::<()>();\n     let stream_closed_ch = comm::chan(stream_closed_po);\n@@ -367,7 +369,7 @@ fn new_listener(host_ip: ip::ip_addr, port: uint, backlog: uint,\n         server_stream: uv::ll::tcp_t(),\n         stream_closed_po: stream_closed_po,\n         stream_closed_ch: stream_closed_ch,\n-        hl_loop: hl_loop,\n+        iotask: iotask,\n         new_conn_po: new_conn_po,\n         new_conn_ch: new_conn_ch\n     };\n@@ -377,7 +379,7 @@ fn new_listener(host_ip: ip::ip_addr, port: uint, backlog: uint,\n \n     let setup_po = comm::port::<option<tcp_err_data>>();\n     let setup_ch = comm::chan(setup_po);\n-    uv::hl::interact(hl_loop) {|loop_ptr|\n+    iotask::interact(iotask) {|loop_ptr|\n         let tcp_addr = ipv4_ip_addr_to_sockaddr_in(host_ip,\n                                                    port);\n         alt uv::ll::tcp_init(loop_ptr, server_stream_ptr) {\n@@ -445,11 +447,11 @@ variant\n fn conn_recv(server_port: tcp_conn_port)\n     -> result::result<tcp_socket, tcp_err_data> {\n     let new_conn_po = (**server_port).new_conn_po;\n-    let hl_loop = (**server_port).hl_loop;\n+    let iotask = (**server_port).iotask;\n     let new_conn_result = comm::recv(new_conn_po);\n     alt new_conn_result {\n       ok(client_stream_ptr) {\n-        conn_port_new_tcp_socket(client_stream_ptr, hl_loop)\n+        conn_port_new_tcp_socket(client_stream_ptr, iotask)\n       }\n       err(err_data) {\n         result::err(err_data)\n@@ -476,12 +478,12 @@ once a new connection is recv'd. Its parameter:\n fn conn_recv_spawn(server_port: tcp_conn_port,\n                    cb: fn~(result::result<tcp_socket, tcp_err_data>)) {\n     let new_conn_po = (**server_port).new_conn_po;\n-    let hl_loop = (**server_port).hl_loop;\n+    let iotask = (**server_port).iotask;\n     let new_conn_result = comm::recv(new_conn_po);\n     task::spawn {||\n         let sock_create_result = alt new_conn_result {\n           ok(client_stream_ptr) {\n-            conn_port_new_tcp_socket(client_stream_ptr, hl_loop)\n+            conn_port_new_tcp_socket(client_stream_ptr, iotask)\n           }\n           err(err_data) {\n             result::err(err_data)\n@@ -582,7 +584,7 @@ fn accept(new_conn: tcp_new_connection)\n         let server_data_ptr = uv::ll::get_data_for_uv_handle(\n             server_handle_ptr) as *tcp_listen_fc_data;\n         let reader_po = comm::port::<result::result<[u8], tcp_err_data>>();\n-        let hl_loop = (*server_data_ptr).hl_loop;\n+        let iotask = (*server_data_ptr).iotask;\n         let stream_handle_ptr = malloc_uv_tcp_t();\n         *(stream_handle_ptr as *mut uv::ll::uv_tcp_t) = uv::ll::tcp_t();\n         let client_socket_data = @{\n@@ -591,7 +593,7 @@ fn accept(new_conn: tcp_new_connection)\n             stream_handle_ptr : stream_handle_ptr,\n             connect_req : uv::ll::connect_t(),\n             write_req : uv::ll::write_t(),\n-            hl_loop: hl_loop\n+            iotask : iotask\n         };\n         let client_socket_data_ptr = ptr::addr_of(*client_socket_data);\n         let client_stream_handle_ptr =\n@@ -677,7 +679,7 @@ successful/normal shutdown, and a `tcp_err_data` record in the event\n of listen exiting because of an error\n \"]\n fn listen_for_conn(host_ip: ip::ip_addr, port: uint, backlog: uint,\n-          hl_loop: uv::hl::high_level_loop,\n+          iotask: iotask,\n           on_establish_cb: fn~(comm::chan<option<tcp_err_data>>),\n           new_connect_cb: fn~(tcp_new_connection,\n                               comm::chan<option<tcp_err_data>>))\n@@ -692,14 +694,14 @@ fn listen_for_conn(host_ip: ip::ip_addr, port: uint, backlog: uint,\n         stream_closed_ch: comm::chan(stream_closed_po),\n         kill_ch: kill_ch,\n         new_connect_cb: new_connect_cb,\n-        hl_loop: hl_loop,\n+        iotask: iotask,\n         mut active: true\n     };\n     let server_data_ptr = ptr::addr_of(server_data);\n \n     let setup_po = comm::port::<option<tcp_err_data>>();\n     let setup_ch = comm::chan(setup_po);\n-    uv::hl::interact(hl_loop) {|loop_ptr|\n+    iotask::interact(iotask) {|loop_ptr|\n         let tcp_addr = ipv4_ip_addr_to_sockaddr_in(host_ip,\n                                                    port);\n         alt uv::ll::tcp_init(loop_ptr, server_stream_ptr) {\n@@ -745,7 +747,7 @@ fn listen_for_conn(host_ip: ip::ip_addr, port: uint, backlog: uint,\n       none {\n         on_establish_cb(kill_ch);\n         let kill_result = comm::recv(kill_po);\n-        uv::hl::interact(hl_loop) {|loop_ptr|\n+        iotask::interact(iotask) {|loop_ptr|\n             log(debug, #fmt(\"tcp::listen post-kill recv hl interact %?\",\n                             loop_ptr));\n             (*server_data_ptr).active = false;\n@@ -811,7 +813,7 @@ impl sock_methods for tcp_socket {\n fn read_common_impl(socket_data: *tcp_socket_data, timeout_msecs: uint)\n     -> result::result<[u8],tcp_err_data> unsafe {\n     log(debug, \"starting tcp::read\");\n-    let hl_loop = (*socket_data).hl_loop;\n+    let iotask = (*socket_data).iotask;\n     let rs_result = read_start_common_impl(socket_data);\n     if result::is_failure(rs_result) {\n         let err_data = result::get_err(rs_result);\n@@ -821,7 +823,7 @@ fn read_common_impl(socket_data: *tcp_socket_data, timeout_msecs: uint)\n         log(debug, \"tcp::read before recv_timeout\");\n         let read_result = if timeout_msecs > 0u {\n             timer::recv_timeout(\n-                hl_loop, timeout_msecs, result::get(rs_result))\n+               iotask, timeout_msecs, result::get(rs_result))\n         } else {\n             some(comm::recv(result::get(rs_result)))\n         };\n@@ -851,7 +853,7 @@ fn read_stop_common_impl(socket_data: *tcp_socket_data) ->\n     let stream_handle_ptr = (*socket_data).stream_handle_ptr;\n     let stop_po = comm::port::<option<tcp_err_data>>();\n     let stop_ch = comm::chan(stop_po);\n-    uv::hl::interact((*socket_data).hl_loop) {|loop_ptr|\n+    iotask::interact((*socket_data).iotask) {|loop_ptr|\n         log(debug, \"in interact cb for tcp::read_stop\");\n         alt uv::ll::read_stop(stream_handle_ptr as *uv::ll::uv_stream_t) {\n           0i32 {\n@@ -883,7 +885,7 @@ fn read_start_common_impl(socket_data: *tcp_socket_data)\n     let start_po = comm::port::<option<uv::ll::uv_err_data>>();\n     let start_ch = comm::chan(start_po);\n     log(debug, \"in tcp::read_start before interact loop\");\n-    uv::hl::interact((*socket_data).hl_loop) {|loop_ptr|\n+    iotask::interact((*socket_data).iotask) {|loop_ptr|\n         log(debug, #fmt(\"in tcp::read_start interact cb %?\", loop_ptr));\n         alt uv::ll::read_start(stream_handle_ptr as *uv::ll::uv_stream_t,\n                                on_alloc_cb,\n@@ -925,7 +927,7 @@ fn write_common_impl(socket_data_ptr: *tcp_socket_data,\n         result_ch: comm::chan(result_po)\n     };\n     let write_data_ptr = ptr::addr_of(write_data);\n-    uv::hl::interact((*socket_data_ptr).hl_loop) {|loop_ptr|\n+    iotask::interact((*socket_data_ptr).iotask) {|loop_ptr|\n         log(debug, #fmt(\"in interact cb for tcp::write %?\", loop_ptr));\n         alt uv::ll::write(write_req_ptr,\n                           stream_handle_ptr,\n@@ -956,7 +958,7 @@ fn write_common_impl(socket_data_ptr: *tcp_socket_data,\n // various recv_* can use a tcp_conn_port can re-use this..\n fn conn_port_new_tcp_socket(\n     stream_handle_ptr: *uv::ll::uv_tcp_t,\n-    hl_loop: uv::hl::high_level_loop)\n+    iotask: iotask)\n     -> result::result<tcp_socket,tcp_err_data> unsafe {\n     // tcp_nl_on_connection_cb\n     let reader_po = comm::port::<result::result<[u8], tcp_err_data>>();\n@@ -966,11 +968,11 @@ fn conn_port_new_tcp_socket(\n         stream_handle_ptr : stream_handle_ptr,\n         connect_req : uv::ll::connect_t(),\n         write_req : uv::ll::write_t(),\n-        hl_loop : hl_loop\n+        iotask : iotask\n     };\n     let client_socket_data_ptr = ptr::addr_of(*client_socket_data);\n     comm::listen {|cont_ch|\n-        uv::hl::interact(hl_loop) {|loop_ptr|\n+        iotask::interact(iotask) {|loop_ptr|\n             log(debug, #fmt(\"in interact cb 4 conn_port_new_tcp.. loop %?\",\n                 loop_ptr));\n             uv::ll::set_data_for_uv_handle(stream_handle_ptr,\n@@ -990,7 +992,7 @@ type tcp_conn_port_data = {\n     server_stream: uv::ll::uv_tcp_t,\n     stream_closed_po: comm::port<()>,\n     stream_closed_ch: comm::chan<()>,\n-    hl_loop: uv::hl::high_level_loop,\n+    iotask: iotask,\n     new_conn_po: comm::port<result::result<*uv::ll::uv_tcp_t,\n                                             tcp_err_data>>,\n     new_conn_ch: comm::chan<result::result<*uv::ll::uv_tcp_t,\n@@ -1003,7 +1005,7 @@ type tcp_listen_fc_data = {\n     kill_ch: comm::chan<option<tcp_err_data>>,\n     new_connect_cb: fn~(tcp_new_connection,\n                         comm::chan<option<tcp_err_data>>),\n-    hl_loop: uv::hl::high_level_loop,\n+    iotask: iotask,\n     mut active: bool\n };\n \n@@ -1264,7 +1266,7 @@ type tcp_socket_data = {\n     stream_handle_ptr: *uv::ll::uv_tcp_t,\n     connect_req: uv::ll::uv_connect_t,\n     write_req: uv::ll::uv_write_t,\n-    hl_loop: uv::hl::high_level_loop\n+    iotask: iotask\n };\n \n // convert rust ip_addr to libuv's native representation\n@@ -1405,13 +1407,13 @@ mod test {\n     fn run_tcp_test_server(server_ip: str, server_port: uint, resp: str,\n                           server_ch: comm::chan<str>,\n                           cont_ch: comm::chan<()>,\n-                          hl_loop: uv::hl::high_level_loop) -> str {\n+                          iotask: iotask) -> str {\n \n         task::spawn_sched(task::manual_threads(1u)) {||\n             let server_ip_addr = ip::v4::parse_addr(server_ip);\n             let listen_result =\n                 listen_for_conn(server_ip_addr, server_port, 128u,\n-                hl_loop,\n+                iotask,\n                 // on_establish_cb -- called when listener is set up\n                 {|kill_ch|\n                     log(debug, #fmt(\"establish_cb %?\",\n@@ -1484,12 +1486,12 @@ mod test {\n                                     server_port: uint, resp: str,\n                                     server_ch: comm::chan<str>,\n                                     cont_ch: comm::chan<()>,\n-                                    hl_loop: uv::hl::high_level_loop) -> str {\n+                                    iotask: iotask) -> str {\n \n         task::spawn_sched(task::manual_threads(1u)) {||\n             let server_ip_addr = ip::v4::parse_addr(server_ip);\n             let new_listener_result =\n-                new_listener(server_ip_addr, server_port, 128u, hl_loop);\n+                new_listener(server_ip_addr, server_port, 128u, iotask);\n             if result::is_failure(new_listener_result) {\n                 let err_data = result::get_err(new_listener_result);\n                 log(debug, #fmt(\"SERVER: exited abnormally name %s msg %s\",\n@@ -1533,12 +1535,12 @@ mod test {\n \n     fn run_tcp_test_client(server_ip: str, server_port: uint, resp: str,\n                           client_ch: comm::chan<str>,\n-                          hl_loop: uv::hl::high_level_loop) -> str {\n+                          iotask: iotask) -> str {\n \n         let server_ip_addr = ip::v4::parse_addr(server_ip);\n \n         log(debug, \"CLIENT: starting..\");\n-        let connect_result = connect(server_ip_addr, server_port, hl_loop);\n+        let connect_result = connect(server_ip_addr, server_port, iotask);\n         if result::is_failure(connect_result) {\n             log(debug, \"CLIENT: failed to connect\");\n             let err_data = result::get_err(connect_result);"}, {"sha": "c8355548598b527b408271837990c6f6a9a51aa4", "filename": "src/libstd/std.rc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/81b8e20f31dbc5b2e985ba4109bf86fe6e06f2e2/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/81b8e20f31dbc5b2e985ba4109bf86fe6e06f2e2/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=81b8e20f31dbc5b2e985ba4109bf86fe6e06f2e2", "patch": "@@ -14,7 +14,7 @@ use core(vers = \"0.2\");\n import core::*;\n \n export net, net_tcp;\n-export uv, uv_ll, uv_hl, uv_global_loop;\n+export uv, uv_ll, uv_iotask, uv_global_loop;\n export c_vec, util, timer;\n export bitv, deque, fun_treemap, list, map, smallintmap, sort, treemap;\n export rope, arena, arc;\n@@ -30,7 +30,7 @@ mod net_tcp;\n // libuv modules\n mod uv;\n mod uv_ll;\n-mod uv_hl;\n+mod uv_iotask;\n mod uv_global_loop;\n \n "}, {"sha": "9fdf6c8550ab4c4e32ab05685129817e106d81d4", "filename": "src/libstd/timer.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/81b8e20f31dbc5b2e985ba4109bf86fe6e06f2e2/src%2Flibstd%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81b8e20f31dbc5b2e985ba4109bf86fe6e06f2e2/src%2Flibstd%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftimer.rs?ref=81b8e20f31dbc5b2e985ba4109bf86fe6e06f2e2", "patch": "@@ -3,6 +3,8 @@ Utilities that leverage libuv's `uv_timer_*` API\n \"];\n \n import uv = uv;\n+import uv::iotask;\n+import iotask::iotask;\n export delayed_send, sleep, recv_timeout;\n \n #[doc = \"\n@@ -21,7 +23,7 @@ for *at least* that period of time.\n * ch - a channel of type T to send a `val` on\n * val - a value of type T to send over the provided `ch`\n \"]\n-fn delayed_send<T: copy send>(hl_loop: uv::hl::high_level_loop,\n+fn delayed_send<T: copy send>(iotask: iotask,\n                               msecs: uint, ch: comm::chan<T>, val: T) {\n     // FIME: Looks like we don't need to spawn here\n     task::spawn() {||\n@@ -31,7 +33,7 @@ fn delayed_send<T: copy send>(hl_loop: uv::hl::high_level_loop,\n             let timer_done_ch_ptr = ptr::addr_of(timer_done_ch);\n             let timer = uv::ll::timer_t();\n             let timer_ptr = ptr::addr_of(timer);\n-            uv::hl::interact(hl_loop) {|loop_ptr|\n+            iotask::interact(iotask) {|loop_ptr|\n                 let init_result = uv::ll::timer_init(loop_ptr, timer_ptr);\n                 if (init_result == 0i32) {\n                     let start_result = uv::ll::timer_start(\n@@ -69,13 +71,13 @@ for *at least* that period of time.\n \n # Arguments\n \n-* `hl_loop` - a `uv::hl::high_level_loop` that the tcp request will run on\n+* `iotask` - a `uv::iotask` that the tcp request will run on\n * msecs - an amount of time, in milliseconds, for the current task to block\n \"]\n-fn sleep(hl_loop: uv::hl::high_level_loop, msecs: uint) {\n+fn sleep(iotask: iotask, msecs: uint) {\n     let exit_po = comm::port::<()>();\n     let exit_ch = comm::chan(exit_po);\n-    delayed_send(hl_loop, msecs, exit_ch, ());\n+    delayed_send(iotask, msecs, exit_ch, ());\n     comm::recv(exit_po);\n }\n \n@@ -88,7 +90,7 @@ timeout. Depending on whether the provided port receives in that time period,\n \n # Arguments\n \n-* `hl_loop` - a `uv::hl::high_level_loop` that the tcp request will run on\n+* `iotask' - `uv::iotask` that the tcp request will run on\n * msecs - an mount of time, in milliseconds, to wait to receive\n * wait_port - a `comm::port<T>` to receive on\n \n@@ -98,12 +100,12 @@ An `option<T>` representing the outcome of the call. If the call `recv`'d on\n the provided port in the allotted timeout period, then the result will be a\n `some(T)`. If not, then `none` will be returned.\n \"]\n-fn recv_timeout<T: copy send>(hl_loop: uv::hl::high_level_loop,\n+fn recv_timeout<T: copy send>(iotask: iotask,\n                               msecs: uint,\n                               wait_po: comm::port<T>) -> option<T> {\n     let timeout_po = comm::port::<()>();\n     let timeout_ch = comm::chan(timeout_po);\n-    delayed_send(hl_loop, msecs, timeout_ch, ());\n+    delayed_send(iotask, msecs, timeout_ch, ());\n     // FIXME: This could be written clearer\n     either::either(\n         {|left_val|"}, {"sha": "c2e4c55d61eeaae91b237d1f070f9b89d62d75c1", "filename": "src/libstd/uv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/81b8e20f31dbc5b2e985ba4109bf86fe6e06f2e2/src%2Flibstd%2Fuv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81b8e20f31dbc5b2e985ba4109bf86fe6e06f2e2/src%2Flibstd%2Fuv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv.rs?ref=81b8e20f31dbc5b2e985ba4109bf86fe6e06f2e2", "patch": "@@ -26,8 +26,8 @@ facilities.\n import ll = uv_ll;\n export ll;\n \n-import hl = uv_hl;\n-export hl;\n+import iotask = uv_iotask;\n+export iotask;\n \n import global_loop = uv_global_loop;\n export global_loop;"}, {"sha": "806b14c717de7a5072ef184e77e273600f048672", "filename": "src/libstd/uv_global_loop.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/81b8e20f31dbc5b2e985ba4109bf86fe6e06f2e2/src%2Flibstd%2Fuv_global_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81b8e20f31dbc5b2e985ba4109bf86fe6e06f2e2/src%2Flibstd%2Fuv_global_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_global_loop.rs?ref=81b8e20f31dbc5b2e985ba4109bf86fe6e06f2e2", "patch": "@@ -5,8 +5,9 @@ A process-wide libuv event loop for library use.\n export get, get_monitor_task_gl;\n \n import ll = uv_ll;\n-import hl = uv_hl;\n+import iotask = uv_iotask;\n import get_gl = get;\n+import iotask::{iotask, spawn_iotask};\n import priv::{chan_from_global_ptr, weaken_task};\n import comm::{port, chan, methods, select2, listen};\n import either::{left, right};\n@@ -27,12 +28,12 @@ loop that this function returns.\n * A `hl::high_level_loop` that encapsulates communication with the global\n loop.\n \"]\n-fn get() -> hl::high_level_loop {\n+fn get() -> iotask {\n     ret get_monitor_task_gl();\n }\n \n #[doc(hidden)]\n-fn get_monitor_task_gl() -> hl::high_level_loop unsafe {\n+fn get_monitor_task_gl() -> iotask unsafe {\n \n     let monitor_loop_chan_ptr = rustrt::rust_uv_get_kernel_global_chan_ptr();\n \n@@ -53,7 +54,7 @@ fn get_monitor_task_gl() -> hl::high_level_loop unsafe {\n     };\n \n     #debug(\"before priv::chan_from_global_ptr\");\n-    type monchan = chan<hl::high_level_loop>;\n+    type monchan = chan<iotask>;\n \n     let monitor_ch = chan_from_global_ptr::<monchan>(monitor_loop_chan_ptr,\n                                                      builder_fn) {|msg_po|\n@@ -70,7 +71,7 @@ fn get_monitor_task_gl() -> hl::high_level_loop unsafe {\n                     // all normal tasks have ended, tell the\n                     // libuv loop to tear_down, then exit\n                     #debug(\"weak_exit_po recv'd msg: %?\", weak_exit);\n-                    hl::exit(hl_loop);\n+                    iotask::exit(hl_loop);\n                     break;\n                   }\n                   right(fetch_ch) {\n@@ -92,7 +93,7 @@ fn get_monitor_task_gl() -> hl::high_level_loop unsafe {\n     }\n }\n \n-fn spawn_loop() -> hl::high_level_loop unsafe {\n+fn spawn_loop() -> iotask unsafe {\n     let builder = task::builder();\n     task::add_wrapper(builder) {|task_body|\n         fn~(move task_body) {\n@@ -110,7 +111,7 @@ fn spawn_loop() -> hl::high_level_loop unsafe {\n             }\n         }\n     }\n-    hl::spawn_high_level_loop(builder)\n+    spawn_iotask(builder)\n }\n \n #[cfg(test)]\n@@ -128,7 +129,7 @@ mod test {\n         log(debug, \"in simple timer cb\");\n         ll::timer_stop(timer_ptr);\n         let hl_loop = get_gl();\n-        hl::interact(hl_loop) {|_loop_ptr|\n+        iotask::interact(hl_loop) {|_loop_ptr|\n             log(debug, \"closing timer\");\n             ll::close(timer_ptr, simple_timer_close_cb);\n             log(debug, \"about to deref exit_ch_ptr\");\n@@ -137,15 +138,15 @@ mod test {\n         log(debug, \"exiting simple timer cb\");\n     }\n \n-    fn impl_uv_hl_simple_timer(hl_loop: hl::high_level_loop) unsafe {\n+    fn impl_uv_hl_simple_timer(iotask: iotask) unsafe {\n         let exit_po = comm::port::<bool>();\n         let exit_ch = comm::chan(exit_po);\n         let exit_ch_ptr = ptr::addr_of(exit_ch);\n         log(debug, #fmt(\"EXIT_CH_PTR newly created exit_ch_ptr: %?\",\n                        exit_ch_ptr));\n         let timer_handle = ll::timer_t();\n         let timer_ptr = ptr::addr_of(timer_handle);\n-        hl::interact(hl_loop) {|loop_ptr|\n+        iotask::interact(iotask) {|loop_ptr|\n             log(debug, \"user code inside interact loop!!!\");\n             let init_status = ll::timer_init(loop_ptr, timer_ptr);\n             if(init_status == 0i32) {"}, {"sha": "df27f325494092a900a7fc999c70496f7a97f477", "filename": "src/libstd/uv_iotask.rs", "status": "renamed", "additions": 92, "deletions": 99, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/81b8e20f31dbc5b2e985ba4109bf86fe6e06f2e2/src%2Flibstd%2Fuv_iotask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81b8e20f31dbc5b2e985ba4109bf86fe6e06f2e2/src%2Flibstd%2Fuv_iotask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_iotask.rs?ref=81b8e20f31dbc5b2e985ba4109bf86fe6e06f2e2", "patch": "@@ -1,13 +1,14 @@\n #[doc = \"\n-High-level bindings to work with the libuv library.\n \n-This module is geared towards library developers who want to\n-provide a high-level, abstracted interface to some set of\n-libuv functionality.\n+A task-based interface to the uv loop\n+\n+The I/O task runs in its own single-threaded scheduler.  By using the\n+`interact` function you can execute code in a uv callback.\n+\n \"];\n \n-export high_level_loop;\n-export spawn_high_level_loop;\n+export iotask::{};\n+export spawn_iotask;\n export interact;\n export exit;\n \n@@ -19,18 +20,19 @@ import ll = uv_ll;\n #[doc = \"\n Used to abstract-away direct interaction with a libuv loop.\n \"]\n-enum high_level_loop = {\n-    async_handle: *ll::uv_async_t,\n-    op_chan: chan<high_level_msg>\n-};\n+enum iotask {\n+    iotask_({\n+        async_handle: *ll::uv_async_t,\n+        op_chan: chan<iotask_msg>\n+    })\n+}\n \n-fn spawn_high_level_loop(-builder: task::builder\n-                        ) -> high_level_loop unsafe {\n+fn spawn_iotask(-builder: task::builder) -> iotask {\n \n     import task::{set_opts, get_opts, single_threaded, run};\n \n-    let hll_po = port::<high_level_loop>();\n-    let hll_ch = hll_po.chan();\n+    let iotask_po = port::<iotask>();\n+    let iotask_ch = iotask_po.chan();\n \n     set_opts(builder, {\n         sched: some({\n@@ -42,45 +44,75 @@ fn spawn_high_level_loop(-builder: task::builder\n \n     run(builder) {||\n         #debug(\"entering libuv task\");\n-        run_high_level_loop(hll_ch);\n+        run_loop(iotask_ch);\n         #debug(\"libuv task exiting\");\n     };\n \n-    hll_po.recv()\n+    iotask_po.recv()\n }\n \n-#[doc=\"\n-Represents the range of interactions with a `high_level_loop`\n+\n+#[doc = \"\n+Provide a callback to be processed by `iotask`\n+\n+The primary way to do operations again a running `iotask` that\n+doesn't involve creating a uv handle via `safe_handle`\n+\n+# Warning\n+\n+This function is the only safe way to interact with _any_ `iotask`.\n+Using functions in the `uv::ll` module outside of the `cb` passed into\n+this function is _very dangerous_.\n+\n+# Arguments\n+\n+* iotask - a uv I/O task that you want to do operations against\n+* cb - a function callback to be processed on the running loop's\n+thread. The only parameter passed in is an opaque pointer representing the\n+running `uv_loop_t*`. In the context of this callback, it is safe to use\n+this pointer to do various uv_* API calls contained within the `uv::ll`\n+module. It is not safe to send the `loop_ptr` param to this callback out\n+via ports/chans.\n \"]\n-enum high_level_msg {\n-    interaction (fn~(*libc::c_void)),\n-    #[doc=\"\n-For use in libraries that roll their own `high_level_loop` (like\n-`std::uv::global_loop`)\n+unsafe fn interact(iotask: iotask,\n+                   -cb: fn~(*c_void)) {\n+    send_msg(iotask, interaction(cb));\n+}\n+\n+#[doc=\"\n+Shut down the I/O task\n \n Is used to signal to the loop that it should close the internally-held\n async handle and do a sanity check to make sure that all other handles are\n-closed, causing a failure otherwise. This should not be sent/used from\n-'normal' user code.\n-    \"]\n+closed, causing a failure otherwise.\n+\"]\n+fn exit(iotask: iotask) unsafe {\n+    send_msg(iotask, teardown_loop);\n+}\n+\n+\n+// INTERNAL API\n+\n+enum iotask_msg {\n+    interaction (fn~(*libc::c_void)),\n     teardown_loop\n }\n \n #[doc = \"\n-Useful for anyone who wants to roll their own `high_level_loop`.\n+Run the loop and begin handling messages\n \"]\n-unsafe fn run_high_level_loop(hll_ch: chan<high_level_loop>) {\n-    let msg_po = port::<high_level_msg>();\n+fn run_loop(iotask_ch: chan<iotask>) unsafe {\n+    let msg_po = port::<iotask_msg>();\n     let loop_ptr = ll::loop_new();\n     // set up the special async handle we'll use to allow multi-task\n     // communication with this loop\n     let async = ll::async_t();\n     let async_handle = addr_of(async);\n     // associate the async handle with the loop\n-    ll::async_init(loop_ptr, async_handle, high_level_wake_up_cb);\n+    ll::async_init(loop_ptr, async_handle, wake_up_cb);\n \n     // initialize our loop data and store it in the loop\n-    let data: hl_loop_data = {\n+    let data: iotask_loop_data = {\n         async_handle: async_handle,\n         mut active: true,\n         msg_po_ptr: addr_of(msg_po)\n@@ -89,76 +121,43 @@ unsafe fn run_high_level_loop(hll_ch: chan<high_level_loop>) {\n \n     // Send out a handle through which folks can talk to us\n     // while we dwell in the I/O loop\n-    let hll = high_level_loop({\n+    let iotask = iotask_({\n         async_handle: async_handle,\n         op_chan: msg_po.chan()\n     });\n-    hll_ch.send(hll);\n+    iotask_ch.send(iotask);\n \n-    log(debug, \"about to run high level loop\");\n+    log(debug, \"about to run uv loop\");\n     // enter the loop... this blocks until the loop is done..\n     ll::run(loop_ptr);\n-    log(debug, \"high-level loop ended\");\n+    log(debug, \"uv loop ended\");\n     ll::loop_delete(loop_ptr);\n }\n \n-#[doc = \"\n-Provide a callback to be processed by `a_loop`\n-\n-The primary way to do operations again a running `high_level_loop` that\n-doesn't involve creating a uv handle via `safe_handle`\n-\n-# Warning\n-\n-This function is the only safe way to interact with _any_ `high_level_loop`.\n-Using functions in the `uv::ll` module outside of the `cb` passed into\n-this function is _very dangerous_.\n-\n-# Arguments\n-\n-* hl_loop - a `uv::hl::high_level_loop` that you want to do operations against\n-* cb - a function callback to be processed on the running loop's\n-thread. The only parameter passed in is an opaque pointer representing the\n-running `uv_loop_t*`. In the context of this callback, it is safe to use\n-this pointer to do various uv_* API calls contained within the `uv::ll`\n-module. It is not safe to send the `loop_ptr` param to this callback out\n-via ports/chans.\n-\"]\n-unsafe fn interact(hl_loop: high_level_loop,\n-                   -cb: fn~(*c_void)) {\n-    send_high_level_msg(hl_loop, interaction(cb));\n-}\n-\n-fn exit(hl_loop: high_level_loop) unsafe {\n-    send_high_level_msg(hl_loop, teardown_loop);\n-}\n-\n-// INTERNAL API\n-\n // data that lives for the lifetime of the high-evel oo\n-type hl_loop_data = {\n+type iotask_loop_data = {\n     async_handle: *ll::uv_async_t,\n     mut active: bool,\n-    msg_po_ptr: *port<high_level_msg>\n+    msg_po_ptr: *port<iotask_msg>\n };\n \n-unsafe fn send_high_level_msg(hl_loop: high_level_loop,\n-                              -msg: high_level_msg) {\n-    comm::send(hl_loop.op_chan, msg);\n-    ll::async_send(hl_loop.async_handle);\n+fn send_msg(iotask: iotask,\n+            -msg: iotask_msg) unsafe {\n+    iotask.op_chan.send(msg);\n+    ll::async_send(iotask.async_handle);\n }\n \n // this will be invoked by a call to uv::hl::interact() with\n // the high_level_loop corresponding to this async_handle. We\n // simply check if the loop is active and, if so, invoke the\n // user-supplied on_wake callback that is stored in the loop's\n // data member\n-crust fn high_level_wake_up_cb(async_handle: *ll::uv_async_t,\n-                               status: int) unsafe {\n-    log(debug, #fmt(\"high_level_wake_up_cb crust.. handle: %? status: %?\",\n+crust fn wake_up_cb(async_handle: *ll::uv_async_t,\n+                    status: int) unsafe {\n+    log(debug, #fmt(\"wake_up_cb crust.. handle: %? status: %?\",\n                      async_handle, status));\n     let loop_ptr = ll::get_loop_for_uv_handle(async_handle);\n-    let data = ll::get_data_for_uv_handle(async_handle) as *hl_loop_data;\n+    let data = ll::get_data_for_uv_handle(async_handle) as *iotask_loop_data;\n     // FIXME: What is this checking?\n     if (*data).active {\n         let msg_po = *((*data).msg_po_ptr);\n@@ -190,8 +189,8 @@ crust fn tear_down_close_cb(handle: *ll::uv_async_t) unsafe {\n     assert loop_refs == 1i32;\n }\n \n-fn begin_teardown(data: *hl_loop_data) unsafe {\n-    log(debug, \"high_level_tear_down() called, close async_handle\");\n+fn begin_teardown(data: *iotask_loop_data) unsafe {\n+    log(debug, \"iotask begin_teardown() called, close async_handle\");\n     // call user-suppled before_tear_down cb\n     let async_handle = (*data).async_handle;\n     ll::close(async_handle as *c_void, tear_down_close_cb);\n@@ -211,20 +210,20 @@ mod test {\n         ll::close(handle, async_close_cb);\n     }\n     type ah_data = {\n-        hl_loop: high_level_loop,\n+        iotask: iotask,\n         exit_ch: comm::chan<()>\n     };\n-    fn impl_uv_hl_async(hl_loop: high_level_loop) unsafe {\n+    fn impl_uv_iotask_async(iotask: iotask) unsafe {\n         let async_handle = ll::async_t();\n         let ah_ptr = ptr::addr_of(async_handle);\n         let exit_po = comm::port::<()>();\n         let exit_ch = comm::chan(exit_po);\n         let ah_data = {\n-            hl_loop: hl_loop,\n+            iotask: iotask,\n             exit_ch: exit_ch\n         };\n         let ah_data_ptr = ptr::addr_of(ah_data);\n-        interact(hl_loop) {|loop_ptr|\n+        interact(iotask) {|loop_ptr|\n             ll::async_init(loop_ptr, ah_ptr, async_handle_cb);\n             ll::set_data_for_uv_handle(ah_ptr, ah_data_ptr as *libc::c_void);\n             ll::async_send(ah_ptr);\n@@ -234,14 +233,14 @@ mod test {\n \n     // this fn documents the bear minimum neccesary to roll your own\n     // high_level_loop\n-    unsafe fn spawn_test_loop(exit_ch: comm::chan<()>) -> high_level_loop {\n-        let hl_loop_port = comm::port::<high_level_loop>();\n-        let hl_loop_ch = comm::chan(hl_loop_port);\n+    unsafe fn spawn_test_loop(exit_ch: comm::chan<()>) -> iotask {\n+        let iotask_port = comm::port::<iotask>();\n+        let iotask_ch = comm::chan(iotask_port);\n         task::spawn_sched(task::manual_threads(1u)) {||\n-            run_high_level_loop(hl_loop_ch);\n+            run_loop(iotask_ch);\n             exit_ch.send(());\n         };\n-        ret comm::recv(hl_loop_port);\n+        ret comm::recv(iotask_port);\n     }\n \n     crust fn lifetime_handle_close(handle: *libc::c_void) unsafe {\n@@ -255,10 +254,10 @@ mod test {\n     }\n \n     #[test]\n-    fn test_uv_hl_async() unsafe {\n+    fn test_uv_iotask_async() unsafe {\n         let exit_po = comm::port::<()>();\n         let exit_ch = comm::chan(exit_po);\n-        let hl_loop = spawn_test_loop(exit_ch);\n+        let iotask = spawn_test_loop(exit_ch);\n \n         // using this handle to manage the lifetime of the high_level_loop,\n         // as it will exit the first time one of the impl_uv_hl_async() is\n@@ -270,21 +269,15 @@ mod test {\n         let work_exit_ch = comm::chan(work_exit_po);\n         iter::repeat(7u) {||\n             task::spawn_sched(task::manual_threads(1u), {||\n-                impl_uv_hl_async(hl_loop);\n+                impl_uv_iotask_async(iotask);\n                 comm::send(work_exit_ch, ());\n             });\n         };\n         iter::repeat(7u) {||\n             comm::recv(work_exit_po);\n         };\n         log(debug, \"sending teardown_loop msg..\");\n-        // the teardown msg usually comes, in the case of the global loop,\n-        // as a result of receiving a msg on the weaken_task port. but,\n-        // anyone rolling their own high_level_loop can decide when to\n-        // send the msg. it's assert and barf, though, if all of your\n-        // handles aren't uv_close'd first\n-        comm::send(hl_loop.op_chan, teardown_loop);\n-        ll::async_send(hl_loop.async_handle);\n+        exit(iotask);\n         comm::recv(exit_po);\n         log(debug, \"after recv on exit_po.. exiting..\");\n     }", "previous_filename": "src/libstd/uv_hl.rs"}]}