{"sha": "568dc38b7b6474e225533ae63718c24b0561f48d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2OGRjMzhiN2I2NDc0ZTIyNTUzM2FlNjM3MThjMjRiMDU2MWY0OGQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-09-11T14:01:20Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-09-11T14:01:20Z"}, "message": "Merge #5955\n\n5955: Remove merge import code duplication r=jonas-schievink a=Veykril\n\nThis removes the code duplication caused by #5935, this also allows the assist to merge imports that have equal visibility and prevents merges of unequal visibility. This PR also fixes an iteration mistake in the mentioned PR:\r\n\r\nTurns out I made a mistake when writing the `segment_iter` function, I was assuming that the `children` of a path will just be the segments, which is obviously not the case. This also brings insertion order of shorter paths in line with how `rustfmt` orders them.\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "8cacf0d45fa3d33e48a1f8126d54f29eadb168ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8cacf0d45fa3d33e48a1f8126d54f29eadb168ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/568dc38b7b6474e225533ae63718c24b0561f48d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfW4MwCRBK7hj4Ov3rIwAAdHIIAF8+5w3uStxvrfrJM6ZJ/koo\n4YycjphSFp5KzcOFKYpu5vYdV3qKk4qau1kzxr5IxalOIPMjs/ABC+AjcJmU8ABB\nN2U2Uh6soU9W+Yt5Glq+a8u7OILj0Lu/f2/eCJH++UjLQXbH3wXcadnWeS/dpMas\nIf3m33ofm8IQkPpI4bu6T1xRwgEGmagV7zlzoHbSLE9v2MoeRqAU67wOo4bIb9YA\nemtcnuLO3tNLItRr/utLXl2wa7Mns8nWr+52yrGcMz6oGyy4BNy7okkMk+5le/g0\n1ouwuaYuOtSBZcE0gkmIGePlfOAeAdsqoTZBuTPynrIi5nmGBEF4X//A68IsMEQ=\n=IQlT\n-----END PGP SIGNATURE-----\n", "payload": "tree 8cacf0d45fa3d33e48a1f8126d54f29eadb168ee\nparent 96e988fcc3be11acc89dc2c1957bc14e8f39c911\nparent 74b755d23366bcfa5437df25b023f5a2451e1ea6\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1599832880 +0000\ncommitter GitHub <noreply@github.com> 1599832880 +0000\n\nMerge #5955\n\n5955: Remove merge import code duplication r=jonas-schievink a=Veykril\n\nThis removes the code duplication caused by #5935, this also allows the assist to merge imports that have equal visibility and prevents merges of unequal visibility. This PR also fixes an iteration mistake in the mentioned PR:\r\n\r\nTurns out I made a mistake when writing the `segment_iter` function, I was assuming that the `children` of a path will just be the segments, which is obviously not the case. This also brings insertion order of shorter paths in line with how `rustfmt` orders them.\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/568dc38b7b6474e225533ae63718c24b0561f48d", "html_url": "https://github.com/rust-lang/rust/commit/568dc38b7b6474e225533ae63718c24b0561f48d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/568dc38b7b6474e225533ae63718c24b0561f48d/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "96e988fcc3be11acc89dc2c1957bc14e8f39c911", "url": "https://api.github.com/repos/rust-lang/rust/commits/96e988fcc3be11acc89dc2c1957bc14e8f39c911", "html_url": "https://github.com/rust-lang/rust/commit/96e988fcc3be11acc89dc2c1957bc14e8f39c911"}, {"sha": "74b755d23366bcfa5437df25b023f5a2451e1ea6", "url": "https://api.github.com/repos/rust-lang/rust/commits/74b755d23366bcfa5437df25b023f5a2451e1ea6", "html_url": "https://github.com/rust-lang/rust/commit/74b755d23366bcfa5437df25b023f5a2451e1ea6"}], "stats": {"total": 196, "additions": 114, "deletions": 82}, "files": [{"sha": "0bd6792605392210cd0c8980e321f199059324aa", "filename": "crates/assists/src/handlers/merge_imports.rs", "status": "modified", "additions": 86, "deletions": 75, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/568dc38b7b6474e225533ae63718c24b0561f48d/crates%2Fassists%2Fsrc%2Fhandlers%2Fmerge_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/568dc38b7b6474e225533ae63718c24b0561f48d/crates%2Fassists%2Fsrc%2Fhandlers%2Fmerge_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fmerge_imports.rs?ref=568dc38b7b6474e225533ae63718c24b0561f48d", "patch": "@@ -1,14 +1,14 @@\n-use std::iter::successors;\n-\n use syntax::{\n-    algo::{neighbor, skip_trivia_token, SyntaxRewriter},\n-    ast::{self, edit::AstNodeEdit, make},\n-    AstNode, Direction, InsertPosition, SyntaxElement, T,\n+    algo::{neighbor, SyntaxRewriter},\n+    ast, AstNode,\n };\n \n use crate::{\n     assist_context::{AssistContext, Assists},\n-    utils::next_prev,\n+    utils::{\n+        insert_use::{try_merge_imports, try_merge_trees},\n+        next_prev, MergeBehaviour,\n+    },\n     AssistId, AssistKind,\n };\n \n@@ -30,23 +30,22 @@ pub(crate) fn merge_imports(acc: &mut Assists, ctx: &AssistContext) -> Option<()\n     let mut offset = ctx.offset();\n \n     if let Some(use_item) = tree.syntax().parent().and_then(ast::Use::cast) {\n-        let (merged, to_delete) = next_prev()\n-            .filter_map(|dir| neighbor(&use_item, dir))\n-            .filter_map(|it| Some((it.clone(), it.use_tree()?)))\n-            .find_map(|(use_item, use_tree)| {\n-                Some((try_merge_trees(&tree, &use_tree)?, use_item))\n+        let (merged, to_delete) =\n+            next_prev().filter_map(|dir| neighbor(&use_item, dir)).find_map(|use_item2| {\n+                try_merge_imports(&use_item, &use_item2, MergeBehaviour::Full).zip(Some(use_item2))\n             })?;\n \n-        rewriter.replace_ast(&tree, &merged);\n+        rewriter.replace_ast(&use_item, &merged);\n         rewriter += to_delete.remove();\n \n         if to_delete.syntax().text_range().end() < offset {\n             offset -= to_delete.syntax().text_range().len();\n         }\n     } else {\n-        let (merged, to_delete) = next_prev()\n-            .filter_map(|dir| neighbor(&tree, dir))\n-            .find_map(|use_tree| Some((try_merge_trees(&tree, &use_tree)?, use_tree.clone())))?;\n+        let (merged, to_delete) =\n+            next_prev().filter_map(|dir| neighbor(&tree, dir)).find_map(|use_tree| {\n+                try_merge_trees(&tree, &use_tree, MergeBehaviour::Full).zip(Some(use_tree))\n+            })?;\n \n         rewriter.replace_ast(&tree, &merged);\n         rewriter += to_delete.remove();\n@@ -67,66 +66,6 @@ pub(crate) fn merge_imports(acc: &mut Assists, ctx: &AssistContext) -> Option<()\n     )\n }\n \n-fn try_merge_trees(old: &ast::UseTree, new: &ast::UseTree) -> Option<ast::UseTree> {\n-    let lhs_path = old.path()?;\n-    let rhs_path = new.path()?;\n-\n-    let (lhs_prefix, rhs_prefix) = common_prefix(&lhs_path, &rhs_path)?;\n-\n-    let lhs = old.split_prefix(&lhs_prefix);\n-    let rhs = new.split_prefix(&rhs_prefix);\n-\n-    let should_insert_comma = lhs\n-        .use_tree_list()?\n-        .r_curly_token()\n-        .and_then(|it| skip_trivia_token(it.prev_token()?, Direction::Prev))\n-        .map(|it| it.kind() != T![,])\n-        .unwrap_or(true);\n-\n-    let mut to_insert: Vec<SyntaxElement> = Vec::new();\n-    if should_insert_comma {\n-        to_insert.push(make::token(T![,]).into());\n-        to_insert.push(make::tokens::single_space().into());\n-    }\n-    to_insert.extend(\n-        rhs.use_tree_list()?\n-            .syntax()\n-            .children_with_tokens()\n-            .filter(|it| it.kind() != T!['{'] && it.kind() != T!['}']),\n-    );\n-    let use_tree_list = lhs.use_tree_list()?;\n-    let pos = InsertPosition::Before(use_tree_list.r_curly_token()?.into());\n-    let use_tree_list = use_tree_list.insert_children(pos, to_insert);\n-    Some(lhs.with_use_tree_list(use_tree_list))\n-}\n-\n-fn common_prefix(lhs: &ast::Path, rhs: &ast::Path) -> Option<(ast::Path, ast::Path)> {\n-    let mut res = None;\n-    let mut lhs_curr = first_path(&lhs);\n-    let mut rhs_curr = first_path(&rhs);\n-    loop {\n-        match (lhs_curr.segment(), rhs_curr.segment()) {\n-            (Some(lhs), Some(rhs)) if lhs.syntax().text() == rhs.syntax().text() => (),\n-            _ => break,\n-        }\n-        res = Some((lhs_curr.clone(), rhs_curr.clone()));\n-\n-        match (lhs_curr.parent_path(), rhs_curr.parent_path()) {\n-            (Some(lhs), Some(rhs)) => {\n-                lhs_curr = lhs;\n-                rhs_curr = rhs;\n-            }\n-            _ => break,\n-        }\n-    }\n-\n-    res\n-}\n-\n-fn first_path(path: &ast::Path) -> ast::Path {\n-    successors(Some(path.clone()), |it| it.qualifier()).last().unwrap()\n-}\n-\n #[cfg(test)]\n mod tests {\n     use crate::tests::{check_assist, check_assist_not_applicable};\n@@ -188,6 +127,78 @@ use std::{fmt::{Display, self}};\n         );\n     }\n \n+    #[test]\n+    fn skip_pub1() {\n+        check_assist_not_applicable(\n+            merge_imports,\n+            r\"\n+pub use std::fmt<|>::Debug;\n+use std::fmt::Display;\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn skip_pub_last() {\n+        check_assist_not_applicable(\n+            merge_imports,\n+            r\"\n+use std::fmt<|>::Debug;\n+pub use std::fmt::Display;\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn skip_pub_crate_pub() {\n+        check_assist_not_applicable(\n+            merge_imports,\n+            r\"\n+pub(crate) use std::fmt<|>::Debug;\n+pub use std::fmt::Display;\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn skip_pub_pub_crate() {\n+        check_assist_not_applicable(\n+            merge_imports,\n+            r\"\n+pub use std::fmt<|>::Debug;\n+pub(crate) use std::fmt::Display;\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn merge_pub() {\n+        check_assist(\n+            merge_imports,\n+            r\"\n+pub use std::fmt<|>::Debug;\n+pub use std::fmt::Display;\n+\",\n+            r\"\n+pub use std::fmt::{Debug, Display};\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn merge_pub_crate() {\n+        check_assist(\n+            merge_imports,\n+            r\"\n+pub(crate) use std::fmt<|>::Debug;\n+pub(crate) use std::fmt::Display;\n+\",\n+            r\"\n+pub(crate) use std::fmt::{Debug, Display};\n+\",\n+        )\n+    }\n+\n     #[test]\n     fn test_merge_nested() {\n         check_assist("}, {"sha": "98553b2e0866a67de4ba14fdbaa0d781c79d8ce6", "filename": "crates/assists/src/utils/insert_use.rs", "status": "modified", "additions": 28, "deletions": 7, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/568dc38b7b6474e225533ae63718c24b0561f48d/crates%2Fassists%2Fsrc%2Futils%2Finsert_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/568dc38b7b6474e225533ae63718c24b0561f48d/crates%2Fassists%2Fsrc%2Futils%2Finsert_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Futils%2Finsert_use.rs?ref=568dc38b7b6474e225533ae63718c24b0561f48d", "patch": "@@ -138,13 +138,23 @@ pub(crate) fn insert_use(\n     algo::insert_children(scope.as_syntax_node(), insert_position, to_insert)\n }\n \n-fn try_merge_imports(\n+fn eq_visibility(vis0: Option<ast::Visibility>, vis1: Option<ast::Visibility>) -> bool {\n+    match (vis0, vis1) {\n+        (None, None) => true,\n+        // FIXME: Don't use the string representation to check for equality\n+        // spaces inside of the node would break this comparison\n+        (Some(vis0), Some(vis1)) => vis0.to_string() == vis1.to_string(),\n+        _ => false,\n+    }\n+}\n+\n+pub(crate) fn try_merge_imports(\n     old: &ast::Use,\n     new: &ast::Use,\n     merge_behaviour: MergeBehaviour,\n ) -> Option<ast::Use> {\n-    // don't merge into re-exports\n-    if old.visibility().and_then(|vis| vis.pub_token()).is_some() {\n+    // don't merge imports with different visibilities\n+    if !eq_visibility(old.visibility(), new.visibility()) {\n         return None;\n     }\n     let old_tree = old.use_tree()?;\n@@ -161,7 +171,7 @@ fn use_tree_list_is_nested(tl: &ast::UseTreeList) -> bool {\n }\n \n // FIXME: currently this merely prepends the new tree into old, ideally it would insert the items in a sorted fashion\n-pub fn try_merge_trees(\n+pub(crate) fn try_merge_trees(\n     old: &ast::UseTree,\n     new: &ast::UseTree,\n     merge_behaviour: MergeBehaviour,\n@@ -278,7 +288,8 @@ fn first_path(path: &ast::Path) -> ast::Path {\n }\n \n fn segment_iter(path: &ast::Path) -> impl Iterator<Item = ast::PathSegment> + Clone {\n-    path.syntax().children().flat_map(ast::PathSegment::cast)\n+    // cant make use of SyntaxNode::siblings, because the returned Iterator is not clone\n+    successors(first_segment(path), |p| p.parent_path().parent_path().and_then(|p| p.segment()))\n }\n \n #[derive(PartialEq, Eq)]\n@@ -684,8 +695,18 @@ use std::io;\",\n         check_last(\n             \"foo::bar\",\n             r\"use foo::bar::baz::Qux;\",\n-            r\"use foo::bar::baz::Qux;\n-use foo::bar;\",\n+            r\"use foo::bar;\n+use foo::bar::baz::Qux;\",\n+        );\n+    }\n+\n+    #[test]\n+    fn insert_short_before_long() {\n+        check_none(\n+            \"foo::bar\",\n+            r\"use foo::bar::baz::Qux;\",\n+            r\"use foo::bar;\n+use foo::bar::baz::Qux;\",\n         );\n     }\n "}]}