{"sha": "e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9", "node_id": "C_kwDOAAsO6NoAKGUwZWI2M2E3M2NjZmI5YWE3YjA5YjM5YjNjOWZlMjMyODdmNWNhYzk", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-01-14T17:45:29Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-01-14T17:45:29Z"}, "message": "Rollup merge of #106860 - anden3:doc-double-spaces, r=Dylan-DPC\n\nRemove various double spaces in the libraries.\n\nI was just pretty bothered by this when reading the source for a function, and was suggested to check if this happened elsewhere.", "tree": {"sha": "319b79aaccee0d1fb8dea8cb8166a94bc1219a5f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/319b79aaccee0d1fb8dea8cb8166a94bc1219a5f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjwuo5CRBK7hj4Ov3rIwAAEPMIAETbUySV2Cqcp8gQ7R3INTVa\nRKp4T8K5MRYro7bEUvRdZCoIdCWo65GAZzjn4q7k+TSZZ+X+ssrpJdccE50roXnH\nrOT20fhJiIUIOua5ZymWy1y9uo9WzizJxQtakXkGtzFRecMW4ccgqiE4SRwedh91\n9BSk2BtvJmG0a3gSxys1b+HeCzTctx+sGPSfgzMRCt5OoiJos+SBmqAWmCqza2FJ\nSwu8EBp7e6ATPnn/iLybAuKeNsUQONows86fEr9tgGYfBPMURH2YyyEyuJoNPu7/\npOsTlNtynWUBhgoAehgV1te3EtvdpLfBoHkd4kzrEOeLw2hiNckyjuQa0SYGjcc=\n=/OjS\n-----END PGP SIGNATURE-----\n", "payload": "tree 319b79aaccee0d1fb8dea8cb8166a94bc1219a5f\nparent bc0c816410fd4015a2bcb74cbd6084da46753df9\nparent 2fea03f5e69481606257a1d4dfeae2c717991e48\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1673718329 +0100\ncommitter GitHub <noreply@github.com> 1673718329 +0100\n\nRollup merge of #106860 - anden3:doc-double-spaces, r=Dylan-DPC\n\nRemove various double spaces in the libraries.\n\nI was just pretty bothered by this when reading the source for a function, and was suggested to check if this happened elsewhere.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9", "html_url": "https://github.com/rust-lang/rust/commit/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc0c816410fd4015a2bcb74cbd6084da46753df9", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc0c816410fd4015a2bcb74cbd6084da46753df9", "html_url": "https://github.com/rust-lang/rust/commit/bc0c816410fd4015a2bcb74cbd6084da46753df9"}, {"sha": "2fea03f5e69481606257a1d4dfeae2c717991e48", "url": "https://api.github.com/repos/rust-lang/rust/commits/2fea03f5e69481606257a1d4dfeae2c717991e48", "html_url": "https://github.com/rust-lang/rust/commit/2fea03f5e69481606257a1d4dfeae2c717991e48"}], "stats": {"total": 142, "additions": 71, "deletions": 71}, "files": [{"sha": "3a797bd5ecaa8ea84e8d90f8a47dab4f5b6c94b9", "filename": "library/alloc/src/alloc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Falloc%2Fsrc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Falloc%2Fsrc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Falloc.rs?ref=e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9", "patch": "@@ -20,7 +20,7 @@ use core::marker::Destruct;\n mod tests;\n \n extern \"Rust\" {\n-    // These are the magic symbols to call the global allocator.  rustc generates\n+    // These are the magic symbols to call the global allocator. rustc generates\n     // them to call `__rg_alloc` etc. if there is a `#[global_allocator]` attribute\n     // (the code expanding that attribute macro generates those functions), or to call\n     // the default implementations in std (`__rdl_alloc` etc. in `library/std/src/alloc.rs`)\n@@ -353,7 +353,7 @@ pub(crate) const unsafe fn box_free<T: ?Sized, A: ~const Allocator + ~const Dest\n \n #[cfg(not(no_global_oom_handling))]\n extern \"Rust\" {\n-    // This is the magic symbol to call the global alloc error handler.  rustc generates\n+    // This is the magic symbol to call the global alloc error handler. rustc generates\n     // it to call `__rg_oom` if there is a `#[alloc_error_handler]`, or to call the\n     // default implementations below (`__rdl_oom`) otherwise.\n     fn __rust_alloc_error_handler(size: usize, align: usize) -> !;"}, {"sha": "c9aa23fc4af1f275e98ff6352e4e34480d6044cb", "filename": "library/alloc/src/rc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Falloc%2Fsrc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Falloc%2Fsrc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Frc.rs?ref=e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9", "patch": "@@ -2179,7 +2179,7 @@ pub struct Weak<T: ?Sized> {\n     // This is a `NonNull` to allow optimizing the size of this type in enums,\n     // but it is not necessarily a valid pointer.\n     // `Weak::new` sets this to `usize::MAX` so that it doesn\u2019t need\n-    // to allocate space on the heap.  That's not a value a real pointer\n+    // to allocate space on the heap. That's not a value a real pointer\n     // will ever have because RcBox has alignment at least 2.\n     // This is only possible when `T: Sized`; unsized `T` never dangle.\n     ptr: NonNull<RcBox<T>>,"}, {"sha": "bab7f5f53657a58cfa55f9614684a6a8b4978700", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9", "patch": "@@ -295,7 +295,7 @@ pub struct Weak<T: ?Sized> {\n     // This is a `NonNull` to allow optimizing the size of this type in enums,\n     // but it is not necessarily a valid pointer.\n     // `Weak::new` sets this to `usize::MAX` so that it doesn\u2019t need\n-    // to allocate space on the heap.  That's not a value a real pointer\n+    // to allocate space on the heap. That's not a value a real pointer\n     // will ever have because RcBox has alignment at least 2.\n     // This is only possible when `T: Sized`; unsized `T` never dangle.\n     ptr: NonNull<ArcInner<T>>,\n@@ -1656,7 +1656,7 @@ impl<T: ?Sized> Arc<T> {\n         //\n         // The acquire label here ensures a happens-before relationship with any\n         // writes to `strong` (in particular in `Weak::upgrade`) prior to decrements\n-        // of the `weak` count (via `Weak::drop`, which uses release).  If the upgraded\n+        // of the `weak` count (via `Weak::drop`, which uses release). If the upgraded\n         // weak ref was never dropped, the CAS here will fail so we do not care to synchronize.\n         if self.inner().weak.compare_exchange(1, usize::MAX, Acquire, Relaxed).is_ok() {\n             // This needs to be an `Acquire` to synchronize with the decrement of the `strong`\n@@ -1712,7 +1712,7 @@ unsafe impl<#[may_dangle] T: ?Sized> Drop for Arc<T> {\n         }\n \n         // This fence is needed to prevent reordering of use of the data and\n-        // deletion of the data.  Because it is marked `Release`, the decreasing\n+        // deletion of the data. Because it is marked `Release`, the decreasing\n         // of the reference count synchronizes with this `Acquire` fence. This\n         // means that use of the data happens before decreasing the reference\n         // count, which happens before this fence, which happens before the\n@@ -2172,7 +2172,7 @@ impl<T: ?Sized> Clone for Weak<T> {\n         } else {\n             return Weak { ptr: self.ptr };\n         };\n-        // See comments in Arc::clone() for why this is relaxed.  This can use a\n+        // See comments in Arc::clone() for why this is relaxed. This can use a\n         // fetch_add (ignoring the lock) because the weak count is only locked\n         // where are *no other* weak pointers in existence. (So we can't be\n         // running this code in that case)."}, {"sha": "37966007eb7e43eb1fb661d8925567b303f905ba", "filename": "library/alloc/src/vec/into_iter.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs?ref=e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9", "patch": "@@ -40,7 +40,7 @@ pub struct IntoIter<\n     // to avoid dropping the allocator twice we need to wrap it into ManuallyDrop\n     pub(super) alloc: ManuallyDrop<A>,\n     pub(super) ptr: *const T,\n-    pub(super) end: *const T, // If T is a ZST, this is actually ptr+len.  This encoding is picked so that\n+    pub(super) end: *const T, // If T is a ZST, this is actually ptr+len. This encoding is picked so that\n                               // ptr == end is a quick test for the Iterator being empty, that works\n                               // for both ZST and non-ZST.\n }\n@@ -146,9 +146,9 @@ impl<T, A: Allocator> IntoIter<T, A> {\n         let mut this = ManuallyDrop::new(self);\n \n         // SAFETY: This allocation originally came from a `Vec`, so it passes\n-        // all those checks.  We have `this.buf` \u2264 `this.ptr` \u2264 `this.end`,\n+        // all those checks. We have `this.buf` \u2264 `this.ptr` \u2264 `this.end`,\n         // so the `sub_ptr`s below cannot wrap, and will produce a well-formed\n-        // range.  `end` \u2264 `buf + cap`, so the range will be in-bounds.\n+        // range. `end` \u2264 `buf + cap`, so the range will be in-bounds.\n         // Taking `alloc` is ok because nothing else is going to look at it,\n         // since our `Drop` impl isn't going to run so there's no more code.\n         unsafe {"}, {"sha": "26120270c0cb0da8402a60b346e0999acf2873f8", "filename": "library/alloc/src/vec/is_zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Falloc%2Fsrc%2Fvec%2Fis_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Falloc%2Fsrc%2Fvec%2Fis_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fis_zero.rs?ref=e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9", "patch": "@@ -57,7 +57,7 @@ unsafe impl<T: IsZero, const N: usize> IsZero for [T; N] {\n     #[inline]\n     fn is_zero(&self) -> bool {\n         // Because this is generated as a runtime check, it's not obvious that\n-        // it's worth doing if the array is really long.  The threshold here\n+        // it's worth doing if the array is really long. The threshold here\n         // is largely arbitrary, but was picked because as of 2022-07-01 LLVM\n         // fails to const-fold the check in `vec![[1; 32]; n]`\n         // See https://github.com/rust-lang/rust/pull/97581#issuecomment-1166628022"}, {"sha": "36b0b3c9e7cc072aca6f39d2f165d277d52cbdc3", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9", "patch": "@@ -2429,7 +2429,7 @@ impl<T: Clone, A: Allocator> Vec<T, A> {\n         self.reserve(range.len());\n \n         // SAFETY:\n-        // - `slice::range` guarantees  that the given range is valid for indexing self\n+        // - `slice::range` guarantees that the given range is valid for indexing self\n         unsafe {\n             self.spec_extend_from_within(range);\n         }\n@@ -2686,7 +2686,7 @@ impl<T: Clone, A: Allocator + Clone> Clone for Vec<T, A> {\n \n     // HACK(japaric): with cfg(test) the inherent `[T]::to_vec` method, which is\n     // required for this method definition, is not available. Instead use the\n-    // `slice::to_vec`  function which is only available with cfg(test)\n+    // `slice::to_vec` function which is only available with cfg(test)\n     // NB see the slice::hack module in slice.rs for more information\n     #[cfg(test)]\n     fn clone(&self) -> Self {"}, {"sha": "2f07c2911a50264aee57ab1a67b966a869045ef3", "filename": "library/alloc/tests/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Falloc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Falloc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fvec.rs?ref=e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9", "patch": "@@ -1849,7 +1849,7 @@ fn test_stable_pointers() {\n     }\n \n     // Test that, if we reserved enough space, adding and removing elements does not\n-    // invalidate references into the vector (such as `v0`).  This test also\n+    // invalidate references into the vector (such as `v0`). This test also\n     // runs in Miri, which would detect such problems.\n     // Note that this test does *not* constitute a stable guarantee that all these functions do not\n     // reallocate! Only what is explicitly documented at"}, {"sha": "8259c087d22e4ff13cce9566ed8a828a169f0977", "filename": "library/core/src/array/iter.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Fcore%2Fsrc%2Farray%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Fcore%2Fsrc%2Farray%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fiter.rs?ref=e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9", "patch": "@@ -109,8 +109,8 @@ impl<T, const N: usize> IntoIter<T, N> {\n     /// use std::array::IntoIter;\n     /// use std::mem::MaybeUninit;\n     ///\n-    /// # // Hi!  Thanks for reading the code.  This is restricted to `Copy` because\n-    /// # // otherwise it could leak.  A fully-general version this would need a drop\n+    /// # // Hi!  Thanks for reading the code. This is restricted to `Copy` because\n+    /// # // otherwise it could leak. A fully-general version this would need a drop\n     /// # // guard to handle panics from the iterator, but this works for an example.\n     /// fn next_chunk<T: Copy, const N: usize>(\n     ///     it: &mut impl Iterator<Item = T>,\n@@ -211,7 +211,7 @@ impl<T, const N: usize> IntoIter<T, N> {\n         let initialized = 0..0;\n \n         // SAFETY: We're telling it that none of the elements are initialized,\n-        // which is trivially true.  And \u2200N: usize, 0 <= N.\n+        // which is trivially true. And \u2200N: usize, 0 <= N.\n         unsafe { Self::new_unchecked(buffer, initialized) }\n     }\n "}, {"sha": "b5739f2f3c0b057d286ecff2095d80f861c5ca18", "filename": "library/core/src/iter/range.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Fcore%2Fsrc%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Fcore%2Fsrc%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Frange.rs?ref=e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9", "patch": "@@ -756,7 +756,7 @@ impl<A: Step> Iterator for ops::Range<A> {\n     where\n         Self: TrustedRandomAccessNoCoerce,\n     {\n-        // SAFETY: The TrustedRandomAccess contract requires that callers only  pass an index\n+        // SAFETY: The TrustedRandomAccess contract requires that callers only pass an index\n         // that is in bounds.\n         // Additionally Self: TrustedRandomAccess is only implemented for Copy types\n         // which means even repeated reads of the same index would be safe."}, {"sha": "3806977f70ee4598d6a78aa88483b10086460b36", "filename": "library/core/src/num/dec2flt/fpu.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Ffpu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Ffpu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Ffpu.rs?ref=e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9", "patch": "@@ -26,7 +26,7 @@ mod fpu_precision {\n     /// Developer's Manual (Volume 1).\n     ///\n     /// The only field which is relevant for the following code is PC, Precision Control. This\n-    /// field determines the precision of the operations performed by the  FPU. It can be set to:\n+    /// field determines the precision of the operations performed by the FPU. It can be set to:\n     ///  - 0b00, single precision i.e., 32-bits\n     ///  - 0b10, double precision i.e., 64-bits\n     ///  - 0b11, double extended precision i.e., 80-bits (default state)"}, {"sha": "7071a656d613d59e772255946a2003a845f61729", "filename": "library/core/src/num/int_macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs?ref=e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9", "patch": "@@ -1538,7 +1538,7 @@ macro_rules! int_impl {\n         ///\n         /// ```\n         /// #![feature(bigint_helper_methods)]\n-        /// // Only the  most significant word is signed.\n+        /// // Only the most significant word is signed.\n         /// //\n         #[doc = concat!(\"//   10  MAX    (a = 10 \u00d7 2^\", stringify!($BITS), \" + 2^\", stringify!($BITS), \" - 1)\")]\n         #[doc = concat!(\"// + -5    9    (b = -5 \u00d7 2^\", stringify!($BITS), \" + 9)\")]\n@@ -1646,7 +1646,7 @@ macro_rules! int_impl {\n         ///\n         /// ```\n         /// #![feature(bigint_helper_methods)]\n-        /// // Only the  most significant word is signed.\n+        /// // Only the most significant word is signed.\n         /// //\n         #[doc = concat!(\"//    6    8    (a = 6 \u00d7 2^\", stringify!($BITS), \" + 8)\")]\n         #[doc = concat!(\"// - -5    9    (b = -5 \u00d7 2^\", stringify!($BITS), \" + 9)\")]"}, {"sha": "ec0c9984841e68089536f9836cfe70e5bb7dcd81", "filename": "library/core/src/pin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Fcore%2Fsrc%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Fcore%2Fsrc%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpin.rs?ref=e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9", "patch": "@@ -753,7 +753,7 @@ impl<P: DerefMut> Pin<P> {\n impl<'a, T: ?Sized> Pin<&'a T> {\n     /// Constructs a new pin by mapping the interior value.\n     ///\n-    /// For example, if you  wanted to get a `Pin` of a field of something,\n+    /// For example, if you wanted to get a `Pin` of a field of something,\n     /// you could use this to get access to that field in one line of code.\n     /// However, there are several gotchas with these \"pinning projections\";\n     /// see the [`pin` module] documentation for further details on that topic.\n@@ -856,7 +856,7 @@ impl<'a, T: ?Sized> Pin<&'a mut T> {\n \n     /// Construct a new pin by mapping the interior value.\n     ///\n-    /// For example, if you  wanted to get a `Pin` of a field of something,\n+    /// For example, if you wanted to get a `Pin` of a field of something,\n     /// you could use this to get access to that field in one line of code.\n     /// However, there are several gotchas with these \"pinning projections\";\n     /// see the [`pin` module] documentation for further details on that topic."}, {"sha": "1ad9af1549a47fcdf12e46b391e12891c2fba0bd", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9", "patch": "@@ -1701,7 +1701,7 @@ pub(crate) const unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usiz\n         // offset is not a multiple of `stride`, the input pointer was misaligned and no pointer\n         // offset will be able to produce a `p` aligned to the specified `a`.\n         //\n-        // The naive `-p (mod a)` equation  inhibits LLVM's ability to select instructions\n+        // The naive `-p (mod a)` equation inhibits LLVM's ability to select instructions\n         // like `lea`. We compute `(round_up_to_next_alignment(p, a) - p)` instead. This\n         // redistributes operations around the load-bearing, but pessimizing `and` instruction\n         // sufficiently for LLVM to be able to utilize the various optimizations it knows about."}, {"sha": "c3e7f2eb302ca38102f4dad1bd55d35105f10036", "filename": "library/core/src/slice/iter.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs?ref=e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9", "patch": "@@ -65,7 +65,7 @@ fn size_from_ptr<T>(_: *const T) -> usize {\n #[must_use = \"iterators are lazy and do nothing unless consumed\"]\n pub struct Iter<'a, T: 'a> {\n     ptr: NonNull<T>,\n-    end: *const T, // If T is a ZST, this is actually ptr+len.  This encoding is picked so that\n+    end: *const T, // If T is a ZST, this is actually ptr+len. This encoding is picked so that\n     // ptr == end is a quick test for the Iterator being empty, that works\n     // for both ZST and non-ZST.\n     _marker: PhantomData<&'a T>,\n@@ -186,7 +186,7 @@ impl<T> AsRef<[T]> for Iter<'_, T> {\n #[must_use = \"iterators are lazy and do nothing unless consumed\"]\n pub struct IterMut<'a, T: 'a> {\n     ptr: NonNull<T>,\n-    end: *mut T, // If T is a ZST, this is actually ptr+len.  This encoding is picked so that\n+    end: *mut T, // If T is a ZST, this is actually ptr+len. This encoding is picked so that\n     // ptr == end is a quick test for the Iterator being empty, that works\n     // for both ZST and non-ZST.\n     _marker: PhantomData<&'a mut T>,"}, {"sha": "55af4cb61dcc09383f4a23603f5d843767648896", "filename": "library/core/src/slice/iter/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Fcore%2Fsrc%2Fslice%2Fiter%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Fcore%2Fsrc%2Fslice%2Fiter%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fiter%2Fmacros.rs?ref=e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9", "patch": "@@ -23,7 +23,7 @@ macro_rules! len {\n             $self.end.addr().wrapping_sub(start.as_ptr().addr())\n         } else {\n             // We know that `start <= end`, so can do better than `offset_from`,\n-            // which needs to deal in signed.  By setting appropriate flags here\n+            // which needs to deal in signed. By setting appropriate flags here\n             // we can tell LLVM this, which helps it remove bounds checks.\n             // SAFETY: By the type invariant, `start <= end`\n             let diff = unsafe { unchecked_sub($self.end.addr(), start.as_ptr().addr()) };"}, {"sha": "df7fe2bf76dcda7568976ec874956de7aa6eb3f1", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9", "patch": "@@ -703,7 +703,7 @@ impl<T> [T] {\n \n             // Because this function is first compiled in isolation,\n             // this check tells LLVM that the indexing below is\n-            // in-bounds.  Then after inlining -- once the actual\n+            // in-bounds. Then after inlining -- once the actual\n             // lengths of the slices are known -- it's removed.\n             let (a, b) = (&mut a[..n], &mut b[..n]);\n \n@@ -1248,7 +1248,7 @@ impl<T> [T] {\n         ArrayChunksMut::new(self)\n     }\n \n-    /// Returns an iterator over overlapping windows of `N` elements of  a slice,\n+    /// Returns an iterator over overlapping windows of `N` elements of a slice,\n     /// starting at the beginning of the slice.\n     ///\n     /// This is the const generic equivalent of [`windows`].\n@@ -2476,7 +2476,7 @@ impl<T> [T] {\n             let mid = left + size / 2;\n \n             // SAFETY: the while condition means `size` is strictly positive, so\n-            // `size/2 < size`.  Thus `left + size/2 < left + size`, which\n+            // `size/2 < size`. Thus `left + size/2 < left + size`, which\n             // coupled with the `left + size <= self.len()` invariant means\n             // we have `left + size/2 < self.len()`, and this is in-bounds.\n             let cmp = f(unsafe { self.get_unchecked(mid) });"}, {"sha": "4d2fcd917849caf5378a0c04f70a2a0dbf593fd4", "filename": "library/core/src/slice/sort.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs?ref=e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9", "patch": "@@ -18,9 +18,9 @@ struct CopyOnDrop<T> {\n \n impl<T> Drop for CopyOnDrop<T> {\n     fn drop(&mut self) {\n-        // SAFETY:  This is a helper class.\n-        //          Please refer to its usage for correctness.\n-        //          Namely, one must be sure that `src` and `dst` does not overlap as required by `ptr::copy_nonoverlapping`.\n+        // SAFETY: This is a helper class.\n+        //         Please refer to its usage for correctness.\n+        //         Namely, one must be sure that `src` and `dst` does not overlap as required by `ptr::copy_nonoverlapping`.\n         unsafe {\n             ptr::copy_nonoverlapping(self.src, self.dest, 1);\n         }"}, {"sha": "39559cdbb5ea9c275b9b3db5b1db08291ec90c64", "filename": "library/core/tests/slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Fcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Fcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fslice.rs?ref=e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9", "patch": "@@ -1488,7 +1488,7 @@ mod slice_index {\n                 // optional:\n                 //\n                 // one or more similar inputs for which data[input] succeeds,\n-                // and the corresponding output as an array.  This helps validate\n+                // and the corresponding output as an array. This helps validate\n                 // \"critical points\" where an input range straddles the boundary\n                 // between valid and invalid.\n                 // (such as the input `len..len`, which is just barely valid)"}, {"sha": "286ad68fd13e8fdf70efab2fb31cb122ec23286d", "filename": "library/std/src/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Fstd%2Fsrc%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Fstd%2Fsrc%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ffs.rs?ref=e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9", "patch": "@@ -1512,7 +1512,7 @@ impl FileType {\n     }\n \n     /// Tests whether this file type represents a regular file.\n-    /// The result is  mutually exclusive to the results of\n+    /// The result is mutually exclusive to the results of\n     /// [`is_dir`] and [`is_symlink`]; only zero or one of these\n     /// tests may pass.\n     ///"}, {"sha": "4c1b7d57684ddcf01b890b8742bc4732588248e8", "filename": "library/std/src/io/buffered/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Ftests.rs?ref=e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9", "patch": "@@ -288,8 +288,8 @@ fn test_buffered_reader_seek_underflow_discard_buffer_between_seeks() {\n     let mut reader = BufReader::with_capacity(5, ErrAfterFirstSeekReader { first_seek: true });\n     assert_eq!(reader.fill_buf().ok(), Some(&[0, 0, 0, 0, 0][..]));\n \n-    // The following seek will require two underlying seeks.  The first will\n-    // succeed but the second will fail.  This should still invalidate the\n+    // The following seek will require two underlying seeks. The first will\n+    // succeed but the second will fail. This should still invalidate the\n     // buffer.\n     assert!(reader.seek(SeekFrom::Current(i64::MIN)).is_err());\n     assert_eq!(reader.buffer().len(), 0);"}, {"sha": "c41e093a7e5c6442f7022cd09d7f587f680af185", "filename": "library/std/src/os/fd/owned.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fowned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fowned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fowned.rs?ref=e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9", "patch": "@@ -100,7 +100,7 @@ impl BorrowedFd<'_> {\n \n         // For ESP-IDF, F_DUPFD is used instead, because the CLOEXEC semantics\n         // will never be supported, as this is a bare metal framework with\n-        // no capabilities for multi-process execution.  While F_DUPFD is also\n+        // no capabilities for multi-process execution. While F_DUPFD is also\n         // not supported yet, it might be (currently it returns ENOSYS).\n         #[cfg(target_os = \"espidf\")]\n         let cmd = libc::F_DUPFD;"}, {"sha": "b0db3112e22fd34470d06fa910b73ef4d118f4a7", "filename": "library/std/src/panicking.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Fstd%2Fsrc%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Fstd%2Fsrc%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpanicking.rs?ref=e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9", "patch": "@@ -306,11 +306,11 @@ pub mod panic_count {\n     // and after increase and decrease, but not necessarily during their execution.\n     //\n     // Additionally, the top bit of GLOBAL_PANIC_COUNT (GLOBAL_ALWAYS_ABORT_FLAG)\n-    // records whether panic::always_abort() has been called.  This can only be\n+    // records whether panic::always_abort() has been called. This can only be\n     // set, never cleared.\n     // panic::always_abort() is usually called to prevent memory allocations done by\n     // the panic handling in the child created by `libc::fork`.\n-    // Memory allocations performed in  a child created with `libc::fork` are undefined\n+    // Memory allocations performed in a child created with `libc::fork` are undefined\n     // behavior in most operating systems.\n     // Accessing LOCAL_PANIC_COUNT in a child created by `libc::fork` would lead to a memory\n     // allocation. Only GLOBAL_PANIC_COUNT can be accessed in this situation. This is"}, {"sha": "c3593264e520b3243f98c01cbf80f12e9fa0b44c", "filename": "library/std/src/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Fstd%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Fstd%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpath.rs?ref=e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9", "patch": "@@ -607,7 +607,7 @@ pub struct Components<'a> {\n \n     // true if path *physically* has a root separator; for most Windows\n     // prefixes, it may have a \"logical\" root separator for the purposes of\n-    // normalization, e.g.,  \\\\server\\share == \\\\server\\share\\.\n+    // normalization, e.g., \\\\server\\share == \\\\server\\share\\.\n     has_physical_root: bool,\n \n     // The iterator is double-ended, and these two states keep track of what has"}, {"sha": "19350b83fab884d8cf3ebd0efdabb7b9de30d4a3", "filename": "library/std/src/sys/itron/thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fthread.rs?ref=e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9", "patch": "@@ -294,7 +294,7 @@ impl Drop for Thread {\n                 // Terminate and delete the task\n                 // Safety: `self.task` still represents a task we own (because\n                 //         this method or `join_inner` is called only once for\n-                //         each `Thread`). The task  indicated that it's safe to\n+                //         each `Thread`). The task indicated that it's safe to\n                 //         delete by entering the `FINISHED` state.\n                 unsafe { terminate_and_delete_task(self.task) };\n "}, {"sha": "8e1f35d6cc92011cac5704c196d5384390e3de3c", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9", "patch": "@@ -614,13 +614,13 @@ impl Iterator for ReadDir {\n             loop {\n                 // As of POSIX.1-2017, readdir() is not required to be thread safe; only\n                 // readdir_r() is. However, readdir_r() cannot correctly handle platforms\n-                // with unlimited or variable NAME_MAX.  Many modern platforms guarantee\n+                // with unlimited or variable NAME_MAX. Many modern platforms guarantee\n                 // thread safety for readdir() as long an individual DIR* is not accessed\n                 // concurrently, which is sufficient for Rust.\n                 super::os::set_errno(0);\n                 let entry_ptr = readdir64(self.inner.dirp.0);\n                 if entry_ptr.is_null() {\n-                    // We either encountered an error, or reached the end.  Either way,\n+                    // We either encountered an error, or reached the end. Either way,\n                     // the next call to next() should return None.\n                     self.end_of_stream = true;\n "}, {"sha": "73b9bef7e2ac9b68b3b8480d27a2e288a7c4cd24", "filename": "library/std/src/sys/unix/kernel_copy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy.rs?ref=e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9", "patch": "@@ -587,7 +587,7 @@ pub(super) fn copy_regular_files(reader: RawFd, writer: RawFd, max_len: u64) ->\n                         // - copy_file_range file is immutable or syscall is blocked by seccomp\u00b9 (EPERM)\n                         // - copy_file_range cannot be used with pipes or device nodes (EINVAL)\n                         // - the writer fd was opened with O_APPEND (EBADF\u00b2)\n-                        // and no bytes were written successfully yet.  (All these errnos should\n+                        // and no bytes were written successfully yet. (All these errnos should\n                         // not be returned if something was already written, but they happen in\n                         // the wild, see #91152.)\n                         //"}, {"sha": "d4c7e58b34d2ef85c2d5864962928745d6eebd14", "filename": "library/std/src/sys/unix/process/process_fuchsia.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_fuchsia.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_fuchsia.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_fuchsia.rs?ref=e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9", "patch": "@@ -262,7 +262,7 @@ impl ExitStatus {\n     // available on Fuchsia.\n     //\n     // It does not appear that Fuchsia is Unix-like enough to implement ExitStatus (or indeed many\n-    // other things from std::os::unix) properly.  This veneer is always going to be a bodge.  So\n+    // other things from std::os::unix) properly. This veneer is always going to be a bodge. So\n     // while I don't know if these implementations are actually correct, I think they will do for\n     // now at least.\n     pub fn core_dumped(&self) -> bool {\n@@ -277,24 +277,24 @@ impl ExitStatus {\n \n     pub fn into_raw(&self) -> c_int {\n         // We don't know what someone who calls into_raw() will do with this value, but it should\n-        // have the conventional Unix representation.  Despite the fact that this is not\n+        // have the conventional Unix representation. Despite the fact that this is not\n         // standardised in SuS or POSIX, all Unix systems encode the signal and exit status the\n-        // same way.  (Ie the WIFEXITED, WEXITSTATUS etc. macros have identical behaviour on every\n+        // same way. (Ie the WIFEXITED, WEXITSTATUS etc. macros have identical behaviour on every\n         // Unix.)\n         //\n         // The caller of `std::os::unix::into_raw` is probably wanting a Unix exit status, and may\n         // do their own shifting and masking, or even pass the status to another computer running a\n         // different Unix variant.\n         //\n         // The other view would be to say that the caller on Fuchsia ought to know that `into_raw`\n-        // will give a raw Fuchsia status (whatever that is - I don't know, personally).  That is\n+        // will give a raw Fuchsia status (whatever that is - I don't know, personally). That is\n         // not possible here because we must return a c_int because that's what Unix (including\n         // SuS and POSIX) say a wait status is, but Fuchsia apparently uses a u64, so it won't\n         // necessarily fit.\n         //\n         // It seems to me that the right answer would be to provide std::os::fuchsia with its\n         // own ExitStatusExt, rather that trying to provide a not very convincing imitation of\n-        // Unix.  Ie, std::os::unix::process:ExitStatusExt ought not to exist on Fuchsia.  But\n+        // Unix. Ie, std::os::unix::process:ExitStatusExt ought not to exist on Fuchsia. But\n         // fixing this up that is beyond the scope of my efforts now.\n         let exit_status_as_if_unix: u8 = self.0.try_into().expect(\"Fuchsia process return code bigger than 8 bits, but std::os::unix::ExitStatusExt::into_raw() was called to try to convert the value into a traditional Unix-style wait status, which cannot represent values greater than 255.\");\n         let wait_status_as_if_unix = (exit_status_as_if_unix as c_int) << 8;"}, {"sha": "c2c4aa1c9dfceff80d98f79999e772fd324c28de", "filename": "library/std/src/sys/unix/process/process_unix.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs?ref=e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9", "patch": "@@ -666,11 +666,11 @@ impl ExitStatus {\n     }\n \n     pub fn exit_ok(&self) -> Result<(), ExitStatusError> {\n-        // This assumes that WIFEXITED(status) && WEXITSTATUS==0 corresponds to status==0.  This is\n+        // This assumes that WIFEXITED(status) && WEXITSTATUS==0 corresponds to status==0. This is\n         // true on all actual versions of Unix, is widely assumed, and is specified in SuS\n-        // https://pubs.opengroup.org/onlinepubs/9699919799/functions/wait.html .  If it is not\n+        // https://pubs.opengroup.org/onlinepubs/9699919799/functions/wait.html. If it is not\n         // true for a platform pretending to be Unix, the tests (our doctests, and also\n-        // procsss_unix/tests.rs) will spot it.  `ExitStatusError::code` assumes this too.\n+        // procsss_unix/tests.rs) will spot it. `ExitStatusError::code` assumes this too.\n         match NonZero_c_int::try_from(self.0) {\n             /* was nonzero */ Ok(failure) => Err(ExitStatusError(failure)),\n             /* was zero, couldn't convert */ Err(_) => Ok(()),"}, {"sha": "e5e1f956bc351e43c16878ea2d37b6b65d876025", "filename": "library/std/src/sys/unix/process/process_unix/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix%2Ftests.rs?ref=e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9", "patch": "@@ -19,17 +19,17 @@ fn exitstatus_display_tests() {\n     t(0x00000, \"exit status: 0\");\n     t(0x0ff00, \"exit status: 255\");\n \n-    // On MacOS, 0x0137f is WIFCONTINUED, not WIFSTOPPED.  Probably *BSD is similar.\n+    // On MacOS, 0x0137f is WIFCONTINUED, not WIFSTOPPED. Probably *BSD is similar.\n     //   https://github.com/rust-lang/rust/pull/82749#issuecomment-790525956\n     // The purpose of this test is to test our string formatting, not our understanding of the wait\n-    // status magic numbers.  So restrict these to Linux.\n+    // status magic numbers. So restrict these to Linux.\n     if cfg!(target_os = \"linux\") {\n         t(0x0137f, \"stopped (not terminated) by signal: 19 (SIGSTOP)\");\n         t(0x0ffff, \"continued (WIFCONTINUED)\");\n     }\n \n     // Testing \"unrecognised wait status\" is hard because the wait.h macros typically\n-    // assume that the value came from wait and isn't mad.  With the glibc I have here\n+    // assume that the value came from wait and isn't mad. With the glibc I have here\n     // this works:\n     if cfg!(all(target_os = \"linux\", target_env = \"gnu\")) {\n         t(0x000ff, \"unrecognised wait status: 255 0xff\");"}, {"sha": "569a4b149125d618bd8847691b7b4434d8ab0cb7", "filename": "library/std/src/sys/unix/process/process_vxworks.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_vxworks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_vxworks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_vxworks.rs?ref=e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9", "patch": "@@ -195,11 +195,11 @@ impl ExitStatus {\n     }\n \n     pub fn exit_ok(&self) -> Result<(), ExitStatusError> {\n-        // This assumes that WIFEXITED(status) && WEXITSTATUS==0 corresponds to status==0.  This is\n+        // This assumes that WIFEXITED(status) && WEXITSTATUS==0 corresponds to status==0. This is\n         // true on all actual versions of Unix, is widely assumed, and is specified in SuS\n-        // https://pubs.opengroup.org/onlinepubs/9699919799/functions/wait.html .  If it is not\n+        // https://pubs.opengroup.org/onlinepubs/9699919799/functions/wait.html. If it is not\n         // true for a platform pretending to be Unix, the tests (our doctests, and also\n-        // procsss_unix/tests.rs) will spot it.  `ExitStatusError::code` assumes this too.\n+        // procsss_unix/tests.rs) will spot it. `ExitStatusError::code` assumes this too.\n         match NonZero_c_int::try_from(self.0) {\n             Ok(failure) => Err(ExitStatusError(failure)),\n             Err(_) => Ok(()),"}, {"sha": "2a1830d060edc5cb934998bd1cac294e3512d281", "filename": "library/std/src/sys/unix/thread.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs?ref=e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9", "patch": "@@ -73,7 +73,7 @@ impl Thread {\n                 n => {\n                     assert_eq!(n, libc::EINVAL);\n                     // EINVAL means |stack_size| is either too small or not a\n-                    // multiple of the system page size.  Because it's definitely\n+                    // multiple of the system page size. Because it's definitely\n                     // >= PTHREAD_STACK_MIN, it must be an alignment issue.\n                     // Round up to the nearest page and try again.\n                     let page_size = os::page_size();\n@@ -755,10 +755,10 @@ pub mod guard {\n         if cfg!(all(target_os = \"linux\", not(target_env = \"musl\"))) {\n             // Linux doesn't allocate the whole stack right away, and\n             // the kernel has its own stack-guard mechanism to fault\n-            // when growing too close to an existing mapping.  If we map\n+            // when growing too close to an existing mapping. If we map\n             // our own guard, then the kernel starts enforcing a rather\n             // large gap above that, rendering much of the possible\n-            // stack space useless.  See #43052.\n+            // stack space useless. See #43052.\n             //\n             // Instead, we'll just note where we expect rlimit to start\n             // faulting, so our handler can report \"stack overflow\", and\n@@ -774,14 +774,14 @@ pub mod guard {\n             None\n         } else if cfg!(target_os = \"freebsd\") {\n             // FreeBSD's stack autogrows, and optionally includes a guard page\n-            // at the bottom.  If we try to remap the bottom of the stack\n-            // ourselves, FreeBSD's guard page moves upwards.  So we'll just use\n+            // at the bottom. If we try to remap the bottom of the stack\n+            // ourselves, FreeBSD's guard page moves upwards. So we'll just use\n             // the builtin guard page.\n             let stackptr = get_stack_start_aligned()?;\n             let guardaddr = stackptr.addr();\n             // Technically the number of guard pages is tunable and controlled\n             // by the security.bsd.stack_guard_page sysctl, but there are\n-            // few reasons to change it from the default.  The default value has\n+            // few reasons to change it from the default. The default value has\n             // been 1 ever since FreeBSD 11.1 and 10.4.\n             const GUARD_PAGES: usize = 1;\n             let guard = guardaddr..guardaddr + GUARD_PAGES * page_size;\n@@ -877,9 +877,9 @@ pub mod guard {\n             } else if cfg!(all(target_os = \"linux\", any(target_env = \"gnu\", target_env = \"uclibc\")))\n             {\n                 // glibc used to include the guard area within the stack, as noted in the BUGS\n-                // section of `man pthread_attr_getguardsize`.  This has been corrected starting\n+                // section of `man pthread_attr_getguardsize`. This has been corrected starting\n                 // with glibc 2.27, and in some distro backports, so the guard is now placed at the\n-                // end (below) the stack.  There's no easy way for us to know which we have at\n+                // end (below) the stack. There's no easy way for us to know which we have at\n                 // runtime, so we'll just match any fault in the range right above or below the\n                 // stack base to call that fault a stack overflow.\n                 Some(stackaddr - guardsize..stackaddr + guardsize)"}, {"sha": "d7adeb266ed93f30918a8fab50137fec6852be98", "filename": "library/std/src/sys/windows/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fos.rs?ref=e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9", "patch": "@@ -157,7 +157,7 @@ impl<'a> Iterator for SplitPaths<'a> {\n         // Double quotes are used as a way of introducing literal semicolons\n         // (since c:\\some;dir is a valid Windows path). Double quotes are not\n         // themselves permitted in path names, so there is no way to escape a\n-        // double quote.  Quoted regions can appear in arbitrary locations, so\n+        // double quote. Quoted regions can appear in arbitrary locations, so\n         //\n         //   c:\\foo;c:\\som\"e;di\"r;c:\\bar\n         //"}, {"sha": "1cb576c95947a5aeddde2a708fd0665ec9c49a56", "filename": "library/std/src/sys/windows/thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread.rs?ref=e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9", "patch": "@@ -26,7 +26,7 @@ impl Thread {\n \n         // FIXME On UNIX, we guard against stack sizes that are too small but\n         // that's because pthreads enforces that stacks are at least\n-        // PTHREAD_STACK_MIN bytes big.  Windows has no such lower limit, it's\n+        // PTHREAD_STACK_MIN bytes big. Windows has no such lower limit, it's\n         // just that below a certain threshold you can't do anything useful.\n         // That threshold is application and architecture-specific, however.\n         let ret = c::CreateThread("}, {"sha": "69fb529d7f563b56e310bb85cf6b7a1f8282b6f6", "filename": "library/test/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Ftest%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Ftest%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Flib.rs?ref=e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9", "patch": "@@ -116,7 +116,7 @@ pub fn test_main(args: &[String], tests: Vec<TestDescAndFn>, options: Option<Opt\n     } else {\n         if !opts.nocapture {\n             // If we encounter a non-unwinding panic, flush any captured output from the current test,\n-            // and stop  capturing output to ensure that the non-unwinding panic message is visible.\n+            // and stop capturing output to ensure that the non-unwinding panic message is visible.\n             // We also acquire the locks for both output streams to prevent output from other threads\n             // from interleaving with the panic message or appearing after it.\n             let builtin_panic_hook = panic::take_hook();"}, {"sha": "3e8ccc91ab0517fd8ef676174a3e1d56c5ef9d59", "filename": "library/test/src/term/terminfo/searcher.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Ftest%2Fsrc%2Fterm%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9/library%2Ftest%2Fsrc%2Fterm%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fterm%2Fterminfo%2Fsearcher.rs?ref=e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9", "patch": "@@ -30,7 +30,7 @@ pub(crate) fn get_dbpath_for_term(term: &str) -> Option<PathBuf> {\n         }\n     } else {\n         // Found nothing in TERMINFO_DIRS, use the default paths:\n-        // According to  /etc/terminfo/README, after looking at\n+        // According to /etc/terminfo/README, after looking at\n         // ~/.terminfo, ncurses will search /etc/terminfo, then\n         // /lib/terminfo, and eventually /usr/share/terminfo.\n         // On Haiku the database can be found at /boot/system/data/terminfo"}]}