{"sha": "654b4d6987223752155b58804255a373d3410a96", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1NGI0ZDY5ODcyMjM3NTIxNTViNTg4MDQyNTVhMzczZDM0MTBhOTY=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-10-03T20:37:51Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-10-03T20:38:00Z"}, "message": "De-export std::{json, getopts}. Part of #3583.", "tree": {"sha": "04040de3a7608561cd927757274bd73eef83af58", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/04040de3a7608561cd927757274bd73eef83af58"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/654b4d6987223752155b58804255a373d3410a96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/654b4d6987223752155b58804255a373d3410a96", "html_url": "https://github.com/rust-lang/rust/commit/654b4d6987223752155b58804255a373d3410a96", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/654b4d6987223752155b58804255a373d3410a96/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fb83b401749a08d77d11b5865fbd1d15a1b9ffd0", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb83b401749a08d77d11b5865fbd1d15a1b9ffd0", "html_url": "https://github.com/rust-lang/rust/commit/fb83b401749a08d77d11b5865fbd1d15a1b9ffd0"}], "stats": {"total": 56, "additions": 18, "deletions": 38}, "files": [{"sha": "9d127f5db476cea9feb12aab3fb3e02002a05cdf", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 18, "deletions": 36, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/654b4d6987223752155b58804255a373d3410a96/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/654b4d6987223752155b58804255a373d3410a96/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=654b4d6987223752155b58804255a373d3410a96", "patch": "@@ -68,24 +68,6 @@ use core::cmp::Eq;\n use core::result::{Err, Ok};\n use core::option;\n use core::option::{Some, None};\n-export Opt;\n-export reqopt;\n-export optopt;\n-export optflag;\n-export optflagopt;\n-export optmulti;\n-export getopts;\n-export Matches;\n-export Fail_;\n-export fail_str;\n-export opt_present;\n-export opts_present;\n-export opt_str;\n-export opts_str;\n-export opt_strs;\n-export opt_maybe_str;\n-export opt_default;\n-export Result; //NDM\n \n enum Name {\n     Long(~str),\n@@ -97,7 +79,7 @@ enum HasArg { Yes, No, Maybe, }\n enum Occur { Req, Optional, Multi, }\n \n /// A description of a possible option\n-type Opt = {name: Name, hasarg: HasArg, occur: Occur};\n+pub type Opt = {name: Name, hasarg: HasArg, occur: Occur};\n \n fn mkname(nm: &str) -> Name {\n     let unm = str::from_slice(nm);\n@@ -134,30 +116,30 @@ impl Occur : Eq {\n }\n \n /// Create an option that is required and takes an argument\n-fn reqopt(name: &str) -> Opt {\n+pub fn reqopt(name: &str) -> Opt {\n     return {name: mkname(name), hasarg: Yes, occur: Req};\n }\n \n /// Create an option that is optional and takes an argument\n-fn optopt(name: &str) -> Opt {\n+pub fn optopt(name: &str) -> Opt {\n     return {name: mkname(name), hasarg: Yes, occur: Optional};\n }\n \n /// Create an option that is optional and does not take an argument\n-fn optflag(name: &str) -> Opt {\n+pub fn optflag(name: &str) -> Opt {\n     return {name: mkname(name), hasarg: No, occur: Optional};\n }\n \n /// Create an option that is optional and takes an optional argument\n-fn optflagopt(name: &str) -> Opt {\n+pub fn optflagopt(name: &str) -> Opt {\n     return {name: mkname(name), hasarg: Maybe, occur: Optional};\n }\n \n /**\n  * Create an option that is optional, takes an argument, and may occur\n  * multiple times\n  */\n-fn optmulti(name: &str) -> Opt {\n+pub fn optmulti(name: &str) -> Opt {\n     return {name: mkname(name), hasarg: Yes, occur: Multi};\n }\n \n@@ -167,7 +149,7 @@ enum Optval { Val(~str), Given, }\n  * The result of checking command line arguments. Contains a vector\n  * of matches and a vector of free strings.\n  */\n-type Matches = {opts: ~[Opt], vals: ~[~[Optval]], free: ~[~str]};\n+pub type Matches = {opts: ~[Opt], vals: ~[~[Optval]], free: ~[~str]};\n \n fn is_arg(arg: &str) -> bool {\n     return str::len(arg) > 1u && arg[0] == '-' as u8;\n@@ -188,7 +170,7 @@ fn find_opt(opts: &[Opt], +nm: Name) -> Option<uint> {\n  * The type returned when the command line does not conform to the\n  * expected format. Pass this value to <fail_str> to get an error message.\n  */\n-enum Fail_ {\n+pub enum Fail_ {\n     ArgumentMissing(~str),\n     UnrecognizedOption(~str),\n     OptionMissing(~str),\n@@ -197,7 +179,7 @@ enum Fail_ {\n }\n \n /// Convert a `fail_` enum into an error string\n-fn fail_str(+f: Fail_) -> ~str {\n+pub fn fail_str(+f: Fail_) -> ~str {\n     return match f {\n         ArgumentMissing(ref nm) => {\n             ~\"Argument to option '\" + *nm + ~\"' missing.\"\n@@ -221,7 +203,7 @@ fn fail_str(+f: Fail_) -> ~str {\n  * The result of parsing a command line with a set of options\n  * (result::t<Matches, Fail_>)\n  */\n-type Result = result::Result<Matches, Fail_>;\n+pub type Result = result::Result<Matches, Fail_>;\n \n /**\n  * Parse command line arguments according to the provided options\n@@ -230,7 +212,7 @@ type Result = result::Result<Matches, Fail_>;\n  * `opt_str`, etc. to interrogate results.  Returns `err(Fail_)` on failure.\n  * Use <fail_str> to get an error message.\n  */\n-fn getopts(args: &[~str], opts: &[Opt]) -> Result unsafe {\n+pub fn getopts(args: &[~str], opts: &[Opt]) -> Result unsafe {\n     let n_opts = vec::len::<Opt>(opts);\n     fn f(+_x: uint) -> ~[Optval] { return ~[]; }\n     let vals = vec::to_mut(vec::from_fn(n_opts, f));\n@@ -366,12 +348,12 @@ fn opt_vals(+mm: Matches, nm: &str) -> ~[Optval] {\n fn opt_val(+mm: Matches, nm: &str) -> Optval { return opt_vals(mm, nm)[0]; }\n \n /// Returns true if an option was matched\n-fn opt_present(+mm: Matches, nm: &str) -> bool {\n+pub fn opt_present(+mm: Matches, nm: &str) -> bool {\n     return vec::len::<Optval>(opt_vals(mm, nm)) > 0u;\n }\n \n /// Returns true if any of several options were matched\n-fn opts_present(+mm: Matches, names: &[~str]) -> bool {\n+pub fn opts_present(+mm: Matches, names: &[~str]) -> bool {\n     for vec::each(names) |nm| {\n         match find_opt(mm.opts, mkname(*nm)) {\n           Some(_) => return true,\n@@ -388,7 +370,7 @@ fn opts_present(+mm: Matches, names: &[~str]) -> bool {\n  * Fails if the option was not matched or if the match did not take an\n  * argument\n  */\n-fn opt_str(+mm: Matches, nm: &str) -> ~str {\n+pub fn opt_str(+mm: Matches, nm: &str) -> ~str {\n     return match opt_val(mm, nm) { Val(copy s) => s, _ => fail };\n }\n \n@@ -398,7 +380,7 @@ fn opt_str(+mm: Matches, nm: &str) -> ~str {\n  * Fails if the no option was provided from the given list, or if the no such\n  * option took an argument\n  */\n-fn opts_str(+mm: Matches, names: &[~str]) -> ~str {\n+pub fn opts_str(+mm: Matches, names: &[~str]) -> ~str {\n     for vec::each(names) |nm| {\n         match opt_val(mm, *nm) {\n           Val(copy s) => return s,\n@@ -415,7 +397,7 @@ fn opts_str(+mm: Matches, names: &[~str]) -> ~str {\n  *\n  * Used when an option accepts multiple values.\n  */\n-fn opt_strs(+mm: Matches, nm: &str) -> ~[~str] {\n+pub fn opt_strs(+mm: Matches, nm: &str) -> ~[~str] {\n     let mut acc: ~[~str] = ~[];\n     for vec::each(opt_vals(mm, nm)) |v| {\n         match *v { Val(copy s) => acc.push(s), _ => () }\n@@ -424,7 +406,7 @@ fn opt_strs(+mm: Matches, nm: &str) -> ~[~str] {\n }\n \n /// Returns the string argument supplied to a matching option or none\n-fn opt_maybe_str(+mm: Matches, nm: &str) -> Option<~str> {\n+pub fn opt_maybe_str(+mm: Matches, nm: &str) -> Option<~str> {\n     let vals = opt_vals(mm, nm);\n     if vec::len::<Optval>(vals) == 0u { return None::<~str>; }\n     return match vals[0] {\n@@ -441,7 +423,7 @@ fn opt_maybe_str(+mm: Matches, nm: &str) -> Option<~str> {\n  * present but no argument was provided, and the argument if the option was\n  * present and an argument was provided.\n  */\n-fn opt_default(+mm: Matches, nm: &str, def: &str) -> Option<~str> {\n+pub fn opt_default(+mm: Matches, nm: &str, def: &str) -> Option<~str> {\n     let vals = opt_vals(mm, nm);\n     if vec::len::<Optval>(vals) == 0u { return None::<~str>; }\n     return match vals[0] { Val(copy s) => Some::<~str>(s),"}, {"sha": "202cb4932db4ab4fabc14d63455f78e4c55b41ba", "filename": "src/libstd/std.rc", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/654b4d6987223752155b58804255a373d3410a96/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/654b4d6987223752155b58804255a373d3410a96/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=654b4d6987223752155b58804255a373d3410a96", "patch": "@@ -92,9 +92,7 @@ mod treemap;\n mod ebml;\n mod ebml2;\n mod dbg;\n-#[legacy_exports]\n mod getopts;\n-#[legacy_exports]\n mod json;\n mod sha1;\n mod md4;"}]}