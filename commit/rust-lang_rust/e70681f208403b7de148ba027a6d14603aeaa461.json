{"sha": "e70681f208403b7de148ba027a6d14603aeaa461", "node_id": "C_kwDOAAsO6NoAKGU3MDY4MWYyMDg0MDNiN2RlMTQ4YmEwMjdhNmQxNDYwM2FlYWE0NjE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-10T11:05:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-10T11:05:02Z"}, "message": "Auto merge of #12992 - lowr:fix/type-inference-for-byte-string-pat, r=Veykril\n\nfix: infer byte string pattern as `&[u8]` when matched against slices\n\nFixes #12630\n\nc.f. [rustc_typeck](https://github.com/rust-lang/rust/blob/1603a70f82240ba2d27f72f964e36614d7620ad3/compiler/rustc_typeck/src/check/pat.rs#L388-L404)", "tree": {"sha": "57fa3f07261e37b84c40b04d985de1b123a0f99f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/57fa3f07261e37b84c40b04d985de1b123a0f99f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e70681f208403b7de148ba027a6d14603aeaa461", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e70681f208403b7de148ba027a6d14603aeaa461", "html_url": "https://github.com/rust-lang/rust/commit/e70681f208403b7de148ba027a6d14603aeaa461", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e70681f208403b7de148ba027a6d14603aeaa461/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d79d9e1a2e0a15f821e15c07c57046b395ddea9c", "url": "https://api.github.com/repos/rust-lang/rust/commits/d79d9e1a2e0a15f821e15c07c57046b395ddea9c", "html_url": "https://github.com/rust-lang/rust/commit/d79d9e1a2e0a15f821e15c07c57046b395ddea9c"}, {"sha": "ffc6b42901fc1f64c812df571110e665de75da45", "url": "https://api.github.com/repos/rust-lang/rust/commits/ffc6b42901fc1f64c812df571110e665de75da45", "html_url": "https://github.com/rust-lang/rust/commit/ffc6b42901fc1f64c812df571110e665de75da45"}], "stats": {"total": 78, "additions": 74, "deletions": 4}, "files": [{"sha": "53259d66dec640f91e023674a94e2e8e2e3dedc8", "filename": "crates/hir-ty/src/infer/pat.rs", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e70681f208403b7de148ba027a6d14603aeaa461/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e70681f208403b7de148ba027a6d14603aeaa461/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs?ref=e70681f208403b7de148ba027a6d14603aeaa461", "patch": "@@ -14,8 +14,9 @@ use crate::{\n     consteval::intern_const_scalar,\n     infer::{BindingMode, Expectation, InferenceContext, TypeMismatch},\n     lower::lower_to_chalk_mutability,\n-    static_lifetime, ConcreteConst, ConstValue, Interner, Substitution, Ty, TyBuilder, TyExt,\n-    TyKind,\n+    primitive::UintTy,\n+    static_lifetime, ConcreteConst, ConstValue, Interner, Scalar, Substitution, Ty, TyBuilder,\n+    TyExt, TyKind,\n };\n \n use super::PatLike;\n@@ -294,7 +295,29 @@ impl<'a> InferenceContext<'a> {\n                 let start_ty = self.infer_expr(*start, &Expectation::has_type(expected.clone()));\n                 self.infer_expr(*end, &Expectation::has_type(start_ty))\n             }\n-            Pat::Lit(expr) => self.infer_expr(*expr, &Expectation::has_type(expected.clone())),\n+            &Pat::Lit(expr) => {\n+                // FIXME: using `Option` here is a workaround until we can use if-let chains in stable.\n+                let mut pat_ty = None;\n+\n+                // Like slice patterns, byte string patterns can denote both `&[u8; N]` and `&[u8]`.\n+                if let Expr::Literal(Literal::ByteString(_)) = self.body[expr] {\n+                    if let Some((inner, ..)) = expected.as_reference() {\n+                        let inner = self.resolve_ty_shallow(inner);\n+                        if matches!(inner.kind(Interner), TyKind::Slice(_)) {\n+                            let elem_ty = TyKind::Scalar(Scalar::Uint(UintTy::U8)).intern(Interner);\n+                            let slice_ty = TyKind::Slice(elem_ty).intern(Interner);\n+                            let ty = TyKind::Ref(Mutability::Not, static_lifetime(), slice_ty)\n+                                .intern(Interner);\n+                            self.write_expr_ty(expr, ty.clone());\n+                            pat_ty = Some(ty);\n+                        }\n+                    }\n+                }\n+\n+                pat_ty.unwrap_or_else(|| {\n+                    self.infer_expr(expr, &Expectation::has_type(expected.clone()))\n+                })\n+            }\n             Pat::Box { inner } => match self.resolve_boxed_box() {\n                 Some(box_adt) => {\n                     let (inner_ty, alloc_ty) = match expected.as_adt() {\n@@ -343,7 +366,9 @@ fn is_non_ref_pat(body: &hir_def::body::Body, pat: PatId) -> bool {\n         // FIXME: ConstBlock/Path/Lit might actually evaluate to ref, but inference is unimplemented.\n         Pat::Path(..) => true,\n         Pat::ConstBlock(..) => true,\n-        Pat::Lit(expr) => !matches!(body[*expr], Expr::Literal(Literal::String(..))),\n+        Pat::Lit(expr) => {\n+            !matches!(body[*expr], Expr::Literal(Literal::String(..) | Literal::ByteString(..)))\n+        }\n         Pat::Bind {\n             mode: BindingAnnotation::Mutable | BindingAnnotation::Unannotated,\n             subpat: Some(subpat),"}, {"sha": "94efe7bc11a8be577ee80081540ed8123683c558", "filename": "crates/hir-ty/src/tests/patterns.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/e70681f208403b7de148ba027a6d14603aeaa461/crates%2Fhir-ty%2Fsrc%2Ftests%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e70681f208403b7de148ba027a6d14603aeaa461/crates%2Fhir-ty%2Fsrc%2Ftests%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fpatterns.rs?ref=e70681f208403b7de148ba027a6d14603aeaa461", "patch": "@@ -315,6 +315,51 @@ fn infer_pattern_match_string_literal() {\n     );\n }\n \n+#[test]\n+fn infer_pattern_match_byte_string_literal() {\n+    check_infer_with_mismatches(\n+        r#\"\n+        //- minicore: index\n+        struct S;\n+        impl<T, const N: usize> core::ops::Index<S> for [T; N] {\n+            type Output = [u8];\n+            fn index(&self, index: core::ops::RangeFull) -> &Self::Output {\n+                loop {}\n+            }\n+        }\n+        fn test(v: [u8; 3]) {\n+            if let b\"foo\" = &v[S] {}\n+            if let b\"foo\" = &v {}\n+        }\n+        \"#,\n+        expect![[r#\"\n+            105..109 'self': &[T; N]\n+            111..116 'index': {unknown}\n+            157..180 '{     ...     }': &[u8]\n+            167..174 'loop {}': !\n+            172..174 '{}': ()\n+            191..192 'v': [u8; 3]\n+            203..261 '{     ...v {} }': ()\n+            209..233 'if let...[S] {}': ()\n+            212..230 'let b\"... &v[S]': bool\n+            216..222 'b\"foo\"': &[u8]\n+            216..222 'b\"foo\"': &[u8]\n+            225..230 '&v[S]': &[u8]\n+            226..227 'v': [u8; 3]\n+            226..230 'v[S]': [u8]\n+            228..229 'S': S\n+            231..233 '{}': ()\n+            238..259 'if let... &v {}': ()\n+            241..256 'let b\"foo\" = &v': bool\n+            245..251 'b\"foo\"': &[u8; 3]\n+            245..251 'b\"foo\"': &[u8; 3]\n+            254..256 '&v': &[u8; 3]\n+            255..256 'v': [u8; 3]\n+            257..259 '{}': ()\n+        \"#]],\n+    );\n+}\n+\n #[test]\n fn infer_pattern_match_or() {\n     check_infer_with_mismatches("}]}