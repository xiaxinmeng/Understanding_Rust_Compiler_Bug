{"sha": "6cfdfdecbaed38534397f16e1ea1cda38b0b9395", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjZmRmZGVjYmFlZDM4NTM0Mzk3ZjE2ZTFlYTFjZGEzOGIwYjkzOTU=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-08-05T19:13:34Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-08-12T19:43:00Z"}, "message": "Add representations of associated types\n\nThis adds three different representations, copied from the Chalk model:\n - `Ty::Projection` is an associated type projection written somewhere in the\n   code, like `<Foo as Trait>::Bar`.\n - `Ty::UnselectedProjection` is similar, but we don't know the trait\n   yet (`Foo::Bar`).\n - The above representations are normalized to their actual types during type\n   inference. When that isn't possible, for example for `T::Item` inside an `fn\n   foo<T: Iterator>`, the type is normalized to an application type with\n   `TypeCtor::AssociatedType`.", "tree": {"sha": "44366b5104b57969a3e337acbeb30209ad709087", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/44366b5104b57969a3e337acbeb30209ad709087"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6cfdfdecbaed38534397f16e1ea1cda38b0b9395", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6cfdfdecbaed38534397f16e1ea1cda38b0b9395", "html_url": "https://github.com/rust-lang/rust/commit/6cfdfdecbaed38534397f16e1ea1cda38b0b9395", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6cfdfdecbaed38534397f16e1ea1cda38b0b9395/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a9a0bc968d9bb97c80f18b4323b3ad75cc8bbad", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a9a0bc968d9bb97c80f18b4323b3ad75cc8bbad", "html_url": "https://github.com/rust-lang/rust/commit/3a9a0bc968d9bb97c80f18b4323b3ad75cc8bbad"}], "stats": {"total": 113, "additions": 113, "deletions": 0}, "files": [{"sha": "89fc1d1a1cec668fe1764d584d569015e7b37cf2", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6cfdfdecbaed38534397f16e1ea1cda38b0b9395/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cfdfdecbaed38534397f16e1ea1cda38b0b9395/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=6cfdfdecbaed38534397f16e1ea1cda38b0b9395", "patch": "@@ -838,6 +838,10 @@ impl TypeAlias {\n         self.id.module(db)\n     }\n \n+    pub fn krate(self, db: &impl DefDatabase) -> Option<Crate> {\n+        self.module(db).krate(db)\n+    }\n+\n     /// The containing impl block, if this is a method.\n     pub fn impl_block(self, db: &impl DefDatabase) -> Option<ImplBlock> {\n         let module_impls = db.impls_in_module(self.module(db));"}, {"sha": "f9cf3ec729866a9bf908fa7cf16c8cd66557e879", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/6cfdfdecbaed38534397f16e1ea1cda38b0b9395/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cfdfdecbaed38534397f16e1ea1cda38b0b9395/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=6cfdfdecbaed38534397f16e1ea1cda38b0b9395", "patch": "@@ -94,6 +94,12 @@ pub enum TypeCtor {\n \n     /// A tuple type.  For example, `(i32, bool)`.\n     Tuple { cardinality: u16 },\n+\n+    /// Represents an associated item like `Iterator::Item`.  This is used\n+    /// when we have tried to normalize a projection like `T::Item` but\n+    /// couldn't find a better representation.  In that case, we generate\n+    /// an **application type** like `(Iterator::Item)<T>`.\n+    AssociatedType(TypeAlias),\n }\n \n /// A nominal type with (maybe 0) type parameters. This might be a primitive\n@@ -114,6 +120,12 @@ pub struct ProjectionTy {\n     pub parameters: Substs,\n }\n \n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub struct UnselectedProjectionTy {\n+    pub type_name: Name,\n+    pub parameters: Substs,\n+}\n+\n /// A type.\n ///\n /// See also the `TyKind` enum in rustc (librustc/ty/sty.rs), which represents\n@@ -127,6 +139,18 @@ pub enum Ty {\n     /// several other things.\n     Apply(ApplicationTy),\n \n+    /// A \"projection\" type corresponds to an (unnormalized)\n+    /// projection like `<P0 as Trait<P1..Pn>>::Foo`. Note that the\n+    /// trait and all its parameters are fully known.\n+    Projection(ProjectionTy),\n+\n+    /// This is a variant of a projection in which the trait is\n+    /// **not** known.  It corresponds to a case where people write\n+    /// `T::Item` without specifying the trait. We would then try to\n+    /// figure out the trait by looking at all the traits that are in\n+    /// scope.\n+    UnselectedProjection(UnselectedProjectionTy),\n+\n     /// A type parameter; for example, `T` in `fn f<T>(x: T) {}\n     Param {\n         /// The index of the parameter (starting with parameters from the\n@@ -352,6 +376,16 @@ impl Ty {\n                     t.walk(f);\n                 }\n             }\n+            Ty::Projection(p_ty) => {\n+                for t in p_ty.parameters.iter() {\n+                    t.walk(f);\n+                }\n+            }\n+            Ty::UnselectedProjection(p_ty) => {\n+                for t in p_ty.parameters.iter() {\n+                    t.walk(f);\n+                }\n+            }\n             Ty::Param { .. } | Ty::Bound(_) | Ty::Infer(_) | Ty::Unknown => {}\n         }\n         f(self);\n@@ -362,6 +396,12 @@ impl Ty {\n             Ty::Apply(a_ty) => {\n                 a_ty.parameters.walk_mut(f);\n             }\n+            Ty::Projection(p_ty) => {\n+                p_ty.parameters.walk_mut(f);\n+            }\n+            Ty::UnselectedProjection(p_ty) => {\n+                p_ty.parameters.walk_mut(f);\n+            }\n             Ty::Param { .. } | Ty::Bound(_) | Ty::Infer(_) | Ty::Unknown => {}\n         }\n         f(self);\n@@ -572,7 +612,51 @@ impl HirDisplay for ApplicationTy {\n                     write!(f, \">\")?;\n                 }\n             }\n+            TypeCtor::AssociatedType(type_alias) => {\n+                let trait_name = type_alias\n+                    .parent_trait(f.db)\n+                    .and_then(|t| t.name(f.db))\n+                    .unwrap_or_else(Name::missing);\n+                let name = type_alias.name(f.db);\n+                write!(f, \"{}::{}\", trait_name, name)?;\n+                if self.parameters.len() > 0 {\n+                    write!(f, \"<\")?;\n+                    f.write_joined(&*self.parameters.0, \", \")?;\n+                    write!(f, \">\")?;\n+                }\n+            }\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl HirDisplay for ProjectionTy {\n+    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n+        let trait_name = self\n+            .associated_ty\n+            .parent_trait(f.db)\n+            .and_then(|t| t.name(f.db))\n+            .unwrap_or_else(Name::missing);\n+        write!(f, \"<{} as {}\", self.parameters[0].display(f.db), trait_name,)?;\n+        if self.parameters.len() > 1 {\n+            write!(f, \"<\")?;\n+            f.write_joined(&self.parameters[1..], \", \")?;\n+            write!(f, \">\")?;\n+        }\n+        write!(f, \">::{}\", self.associated_ty.name(f.db))?;\n+        Ok(())\n+    }\n+}\n+\n+impl HirDisplay for UnselectedProjectionTy {\n+    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n+        write!(f, \"{}\", self.parameters[0].display(f.db))?;\n+        if self.parameters.len() > 1 {\n+            write!(f, \"<\")?;\n+            f.write_joined(&self.parameters[1..], \", \")?;\n+            write!(f, \">\")?;\n         }\n+        write!(f, \"::{}\", self.type_name)?;\n         Ok(())\n     }\n }\n@@ -581,6 +665,8 @@ impl HirDisplay for Ty {\n     fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n         match self {\n             Ty::Apply(a_ty) => a_ty.hir_fmt(f)?,\n+            Ty::Projection(p_ty) => p_ty.hir_fmt(f)?,\n+            Ty::UnselectedProjection(p_ty) => p_ty.hir_fmt(f)?,\n             Ty::Param { name, .. } => write!(f, \"{}\", name)?,\n             Ty::Bound(idx) => write!(f, \"?{}\", idx)?,\n             Ty::Unknown => write!(f, \"{{unknown}}\")?,"}, {"sha": "21055dcfd99ad64027aa67abec05b12f6602fc96", "filename": "crates/ra_hir/src/ty/traits/chalk.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6cfdfdecbaed38534397f16e1ea1cda38b0b9395/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cfdfdecbaed38534397f16e1ea1cda38b0b9395/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs?ref=6cfdfdecbaed38534397f16e1ea1cda38b0b9395", "patch": "@@ -50,6 +50,19 @@ impl ToChalk for Ty {\n                 let parameters = apply_ty.parameters.to_chalk(db);\n                 chalk_ir::ApplicationTy { name, parameters }.cast()\n             }\n+            Ty::Projection(proj_ty) => {\n+                let associated_ty_id = proj_ty.associated_ty.to_chalk(db);\n+                let parameters = proj_ty.parameters.to_chalk(db);\n+                chalk_ir::ProjectionTy { associated_ty_id, parameters }.cast()\n+            }\n+            Ty::UnselectedProjection(proj_ty) => {\n+                let type_name = lalrpop_intern::intern(&proj_ty.type_name.to_string());\n+                let parameters = proj_ty.parameters.to_chalk(db);\n+                chalk_ir::Ty::UnselectedProjection(chalk_ir::UnselectedProjectionTy {\n+                    type_name,\n+                    parameters,\n+                })\n+            }\n             Ty::Param { idx, .. } => {\n                 PlaceholderIndex { ui: UniverseIndex::ROOT, idx: idx as usize }.to_ty()\n             }\n@@ -529,6 +542,16 @@ pub(crate) fn struct_datum_query(\n                 adt.krate(db) != Some(krate),\n             )\n         }\n+        TypeCtor::AssociatedType(type_alias) => {\n+            let generic_params = type_alias.generic_params(db);\n+            let bound_vars = Substs::bound_vars(&generic_params);\n+            let where_clauses = convert_where_clauses(db, type_alias.into(), &bound_vars);\n+            (\n+                generic_params.count_params_including_parent(),\n+                where_clauses,\n+                type_alias.krate(db) != Some(krate),\n+            )\n+        }\n     };\n     let flags = chalk_rust_ir::StructFlags {\n         upstream,"}]}