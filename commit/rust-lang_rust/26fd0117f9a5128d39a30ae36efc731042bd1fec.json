{"sha": "26fd0117f9a5128d39a30ae36efc731042bd1fec", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2ZmQwMTE3ZjlhNTEyOGQzOWEzMGFlMzZlZmM3MzEwNDJiZDFmZWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-07-12T22:15:56Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-07-12T22:15:56Z"}, "message": "Auto merge of #34705 - alexcrichton:clean-deprecated, r=brson\n\nstd: Clean out deprecated APIs\n\nThis primarily removes a lot of `sync::Static*` APIs and rejiggers the\nassociated implementations. While doing this it was discovered that the\n`is_poisoned` method can actually result in a data race for the Mutex/RwLock\nprimitives, so the inner `Cell<bool>` was changed to an `AtomicBool` to prevent\nthe associated data race. Otherwise the usage/gurantees should be the same\nthey were before.", "tree": {"sha": "defbc041a06bfb6350663170856c62a6694b7d48", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/defbc041a06bfb6350663170856c62a6694b7d48"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/26fd0117f9a5128d39a30ae36efc731042bd1fec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/26fd0117f9a5128d39a30ae36efc731042bd1fec", "html_url": "https://github.com/rust-lang/rust/commit/26fd0117f9a5128d39a30ae36efc731042bd1fec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/26fd0117f9a5128d39a30ae36efc731042bd1fec/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3085ec78487712ed77a506d9cba8d69cd3a44684", "url": "https://api.github.com/repos/rust-lang/rust/commits/3085ec78487712ed77a506d9cba8d69cd3a44684", "html_url": "https://github.com/rust-lang/rust/commit/3085ec78487712ed77a506d9cba8d69cd3a44684"}, {"sha": "a7220d9046e292869dded2c478544850c220c7de", "url": "https://api.github.com/repos/rust-lang/rust/commits/a7220d9046e292869dded2c478544850c220c7de", "html_url": "https://github.com/rust-lang/rust/commit/a7220d9046e292869dded2c478544850c220c7de"}], "stats": {"total": 1004, "additions": 234, "deletions": 770}, "files": [{"sha": "d2de0d46d746ba452c7d3aab0f8d0383b3109f22", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/26fd0117f9a5128d39a30ae36efc731042bd1fec/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26fd0117f9a5128d39a30ae36efc731042bd1fec/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=26fd0117f9a5128d39a30ae36efc731042bd1fec", "patch": "@@ -1244,39 +1244,6 @@ impl<I: Iterator> Peekable<I> {\n             None => None,\n         }\n     }\n-\n-    /// Checks if the iterator has finished iterating.\n-    ///\n-    /// Returns `true` if there are no more elements in the iterator, and\n-    /// `false` if there are.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// #![feature(peekable_is_empty)]\n-    ///\n-    /// let xs = [1, 2, 3];\n-    ///\n-    /// let mut iter = xs.iter().peekable();\n-    ///\n-    /// // There are still elements to iterate over\n-    /// assert_eq!(iter.is_empty(), false);\n-    ///\n-    /// // Let's consume the iterator\n-    /// iter.next();\n-    /// iter.next();\n-    /// iter.next();\n-    ///\n-    /// assert_eq!(iter.is_empty(), true);\n-    /// ```\n-    #[unstable(feature = \"peekable_is_empty\", issue = \"32111\")]\n-    #[inline]\n-    #[rustc_deprecated(since = \"1.10.0\", reason = \"replaced by .peek().is_none()\")]\n-    pub fn is_empty(&mut self) -> bool {\n-        self.peek().is_none()\n-    }\n }\n \n /// An iterator that rejects elements while `predicate` is true."}, {"sha": "3c52ebc72f2cb279f187dbfdd1a1c15af580eebe", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 72, "deletions": 296, "changes": 368, "blob_url": "https://github.com/rust-lang/rust/blob/26fd0117f9a5128d39a30ae36efc731042bd1fec/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26fd0117f9a5128d39a30ae36efc731042bd1fec/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=26fd0117f9a5128d39a30ae36efc731042bd1fec", "patch": "@@ -15,7 +15,7 @@ use sync::{mutex, MutexGuard, PoisonError};\n use sys_common::condvar as sys;\n use sys_common::mutex as sys_mutex;\n use sys_common::poison::{self, LockResult};\n-use time::{Instant, Duration};\n+use time::Duration;\n \n /// A type indicating whether a timed wait on a condition variable returned\n /// due to a time out or not.\n@@ -72,59 +72,19 @@ impl WaitTimeoutResult {\n /// }\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated)]\n-pub struct Condvar { inner: Box<StaticCondvar> }\n-\n-/// Statically allocated condition variables.\n-///\n-/// This structure is identical to `Condvar` except that it is suitable for use\n-/// in static initializers for other structures.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// #![feature(static_condvar)]\n-///\n-/// use std::sync::{StaticCondvar, CONDVAR_INIT};\n-///\n-/// static CVAR: StaticCondvar = CONDVAR_INIT;\n-/// ```\n-#[unstable(feature = \"static_condvar\",\n-           reason = \"may be merged with Condvar in the future\",\n-           issue = \"27717\")]\n-#[rustc_deprecated(since = \"1.10.0\",\n-                   reason = \"the lazy-static crate suffices for static sync \\\n-                             primitives and eventually this type shouldn't \\\n-                             be necessary as `Condvar::new` in a static should \\\n-                             suffice\")]\n-pub struct StaticCondvar {\n-    inner: sys::Condvar,\n+pub struct Condvar {\n+    inner: Box<sys::Condvar>,\n     mutex: AtomicUsize,\n }\n \n-/// Constant initializer for a statically allocated condition variable.\n-#[unstable(feature = \"static_condvar\",\n-           reason = \"may be merged with Condvar in the future\",\n-           issue = \"27717\")]\n-#[rustc_deprecated(since = \"1.10.0\",\n-                   reason = \"the lazy-static crate suffices for static sync \\\n-                             primitives and eventually this type shouldn't \\\n-                             be necessary as `Condvar::new` in a static should \\\n-                             suffice\")]\n-#[allow(deprecated)]\n-pub const CONDVAR_INIT: StaticCondvar = StaticCondvar::new();\n-\n-#[allow(deprecated)]\n impl Condvar {\n     /// Creates a new condition variable which is ready to be waited on and\n     /// notified.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> Condvar {\n         Condvar {\n-            inner: box StaticCondvar {\n-                inner: sys::Condvar::new(),\n-                mutex: AtomicUsize::new(0),\n-            }\n+            inner: box sys::Condvar::new(),\n+            mutex: AtomicUsize::new(0),\n         }\n     }\n \n@@ -157,9 +117,16 @@ impl Condvar {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn wait<'a, T>(&self, guard: MutexGuard<'a, T>)\n                        -> LockResult<MutexGuard<'a, T>> {\n-        unsafe {\n-            let me: &'static Condvar = &*(self as *const _);\n-            me.inner.wait(guard)\n+        let poisoned = unsafe {\n+            let lock = mutex::guard_lock(&guard);\n+            self.verify(lock);\n+            self.inner.wait(lock);\n+            mutex::guard_poison(&guard).get()\n+        };\n+        if poisoned {\n+            Err(PoisonError::new(guard))\n+        } else {\n+            Ok(guard)\n         }\n     }\n \n@@ -206,9 +173,16 @@ impl Condvar {\n     pub fn wait_timeout<'a, T>(&self, guard: MutexGuard<'a, T>,\n                                dur: Duration)\n                                -> LockResult<(MutexGuard<'a, T>, WaitTimeoutResult)> {\n-        unsafe {\n-            let me: &'static Condvar = &*(self as *const _);\n-            me.inner.wait_timeout(guard, dur)\n+        let (poisoned, result) = unsafe {\n+            let lock = mutex::guard_lock(&guard);\n+            self.verify(lock);\n+            let success = self.inner.wait_timeout(lock, dur);\n+            (mutex::guard_poison(&guard).get(), WaitTimeoutResult(!success))\n+        };\n+        if poisoned {\n+            Err(PoisonError::new((guard, result)))\n+        } else {\n+            Ok((guard, result))\n         }\n     }\n \n@@ -220,7 +194,9 @@ impl Condvar {\n     ///\n     /// To wake up all threads, see `notify_all()`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn notify_one(&self) { unsafe { self.inner.inner.notify_one() } }\n+    pub fn notify_one(&self) {\n+        unsafe { self.inner.notify_one() }\n+    }\n \n     /// Wakes up all blocked threads on this condvar.\n     ///\n@@ -230,169 +206,8 @@ impl Condvar {\n     ///\n     /// To wake up only one thread, see `notify_one()`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn notify_all(&self) { unsafe { self.inner.inner.notify_all() } }\n-}\n-\n-#[stable(feature = \"condvar_default\", since = \"1.9.0\")]\n-impl Default for Condvar {\n-    fn default() -> Condvar {\n-        Condvar::new()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated)]\n-impl Drop for Condvar {\n-    fn drop(&mut self) {\n-        unsafe { self.inner.inner.destroy() }\n-    }\n-}\n-\n-#[rustc_deprecated(since = \"1.10.0\",\n-                   reason = \"the lazy-static crate suffices for static sync \\\n-                             primitives and eventually this type shouldn't \\\n-                             be necessary as `Condvar::new` in a static should \\\n-                             suffice\")]\n-#[unstable(feature = \"static_condvar\",\n-           reason = \"may be merged with Condvar in the future\",\n-           issue = \"27717\")]\n-#[allow(deprecated)]\n-impl StaticCondvar {\n-    /// Creates a new condition variable\n-    #[unstable(feature = \"static_condvar\",\n-               reason = \"may be merged with Condvar in the future\",\n-               issue = \"27717\")]\n-    pub const fn new() -> StaticCondvar {\n-        StaticCondvar {\n-            inner: sys::Condvar::new(),\n-            mutex: AtomicUsize::new(0),\n-        }\n-    }\n-\n-    /// Blocks the current thread until this condition variable receives a\n-    /// notification.\n-    ///\n-    /// See `Condvar::wait`.\n-    #[unstable(feature = \"static_condvar\",\n-               reason = \"may be merged with Condvar in the future\",\n-               issue = \"27717\")]\n-    pub fn wait<'a, T>(&'static self, guard: MutexGuard<'a, T>)\n-                       -> LockResult<MutexGuard<'a, T>> {\n-        let poisoned = unsafe {\n-            let lock = mutex::guard_lock(&guard);\n-            self.verify(lock);\n-            self.inner.wait(lock);\n-            mutex::guard_poison(&guard).get()\n-        };\n-        if poisoned {\n-            Err(PoisonError::new(guard))\n-        } else {\n-            Ok(guard)\n-        }\n-    }\n-\n-    /// Waits on this condition variable for a notification, timing out after a\n-    /// specified duration.\n-    ///\n-    /// See `Condvar::wait_timeout`.\n-    #[unstable(feature = \"static_condvar\",\n-               reason = \"may be merged with Condvar in the future\",\n-               issue = \"27717\")]\n-    pub fn wait_timeout<'a, T>(&'static self,\n-                               guard: MutexGuard<'a, T>,\n-                               timeout: Duration)\n-                               -> LockResult<(MutexGuard<'a, T>, WaitTimeoutResult)> {\n-        let (poisoned, result) = unsafe {\n-            let lock = mutex::guard_lock(&guard);\n-            self.verify(lock);\n-            let success = self.inner.wait_timeout(lock, timeout);\n-            (mutex::guard_poison(&guard).get(), WaitTimeoutResult(!success))\n-        };\n-        if poisoned {\n-            Err(PoisonError::new((guard, result)))\n-        } else {\n-            Ok((guard, result))\n-        }\n-    }\n-\n-    /// Waits on this condition variable for a notification, timing out after a\n-    /// specified duration.\n-    ///\n-    /// The implementation will repeatedly wait while the duration has not\n-    /// passed and the function returns `false`.\n-    ///\n-    /// See `Condvar::wait_timeout_with`.\n-    #[unstable(feature = \"static_condvar\",\n-               reason = \"may be merged with Condvar in the future\",\n-               issue = \"27717\")]\n-    pub fn wait_timeout_with<'a, T, F>(&'static self,\n-                                       guard: MutexGuard<'a, T>,\n-                                       dur: Duration,\n-                                       mut f: F)\n-                                       -> LockResult<(MutexGuard<'a, T>, WaitTimeoutResult)>\n-            where F: FnMut(LockResult<&mut T>) -> bool {\n-        // This could be made more efficient by pushing the implementation into\n-        // sys::condvar\n-        let start = Instant::now();\n-        let mut guard_result: LockResult<MutexGuard<'a, T>> = Ok(guard);\n-        while !f(guard_result\n-                    .as_mut()\n-                    .map(|g| &mut **g)\n-                    .map_err(|e| PoisonError::new(&mut **e.get_mut()))) {\n-            let consumed = start.elapsed();\n-            let guard = guard_result.unwrap_or_else(|e| e.into_inner());\n-            let (new_guard_result, timed_out) = if consumed > dur {\n-                (Ok(guard), WaitTimeoutResult(true))\n-            } else {\n-                match self.wait_timeout(guard, dur - consumed) {\n-                    Ok((new_guard, timed_out)) => (Ok(new_guard), timed_out),\n-                    Err(err) => {\n-                        let (new_guard, no_timeout) = err.into_inner();\n-                        (Err(PoisonError::new(new_guard)), no_timeout)\n-                    }\n-                }\n-            };\n-            guard_result = new_guard_result;\n-            if timed_out.timed_out() {\n-                let result = f(guard_result\n-                                    .as_mut()\n-                                    .map(|g| &mut **g)\n-                                    .map_err(|e| PoisonError::new(&mut **e.get_mut())));\n-                let result = WaitTimeoutResult(!result);\n-                return poison::map_result(guard_result, |g| (g, result));\n-            }\n-        }\n-\n-        poison::map_result(guard_result, |g| (g, WaitTimeoutResult(false)))\n-    }\n-\n-    /// Wakes up one blocked thread on this condvar.\n-    ///\n-    /// See `Condvar::notify_one`.\n-    #[unstable(feature = \"static_condvar\",\n-               reason = \"may be merged with Condvar in the future\",\n-               issue = \"27717\")]\n-    pub fn notify_one(&'static self) { unsafe { self.inner.notify_one() } }\n-\n-    /// Wakes up all blocked threads on this condvar.\n-    ///\n-    /// See `Condvar::notify_all`.\n-    #[unstable(feature = \"static_condvar\",\n-               reason = \"may be merged with Condvar in the future\",\n-               issue = \"27717\")]\n-    pub fn notify_all(&'static self) { unsafe { self.inner.notify_all() } }\n-\n-    /// Deallocates all resources associated with this static condvar.\n-    ///\n-    /// This method is unsafe to call as there is no guarantee that there are no\n-    /// active users of the condvar, and this also doesn't prevent any future\n-    /// users of the condvar. This method is required to be called to not leak\n-    /// memory on all platforms.\n-    #[unstable(feature = \"static_condvar\",\n-               reason = \"may be merged with Condvar in the future\",\n-               issue = \"27717\")]\n-    pub unsafe fn destroy(&'static self) {\n-        self.inner.destroy()\n+    pub fn notify_all(&self) {\n+        unsafe { self.inner.notify_all() }\n     }\n \n     fn verify(&self, mutex: &sys_mutex::Mutex) {\n@@ -414,15 +229,26 @@ impl StaticCondvar {\n     }\n }\n \n+#[stable(feature = \"condvar_default\", since = \"1.9.0\")]\n+impl Default for Condvar {\n+    fn default() -> Condvar {\n+        Condvar::new()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Drop for Condvar {\n+    fn drop(&mut self) {\n+        unsafe { self.inner.destroy() }\n+    }\n+}\n+\n #[cfg(test)]\n-#[allow(deprecated)]\n mod tests {\n     use prelude::v1::*;\n \n-    use super::StaticCondvar;\n     use sync::mpsc::channel;\n-    use sync::{StaticMutex, Condvar, Mutex, Arc};\n-    use sync::atomic::{AtomicUsize, Ordering};\n+    use sync::{Condvar, Mutex, Arc};\n     use thread;\n     use time::Duration;\n     use u32;\n@@ -434,27 +260,20 @@ mod tests {\n         c.notify_all();\n     }\n \n-    #[test]\n-    fn static_smoke() {\n-        static C: StaticCondvar = StaticCondvar::new();\n-        C.notify_one();\n-        C.notify_all();\n-        unsafe { C.destroy(); }\n-    }\n-\n     #[test]\n     fn notify_one() {\n-        static C: StaticCondvar = StaticCondvar::new();\n-        static M: StaticMutex = StaticMutex::new();\n+        let m = Arc::new(Mutex::new(()));\n+        let m2 = m.clone();\n+        let c = Arc::new(Condvar::new());\n+        let c2 = c.clone();\n \n-        let g = M.lock().unwrap();\n+        let g = m.lock().unwrap();\n         let _t = thread::spawn(move|| {\n-            let _g = M.lock().unwrap();\n-            C.notify_one();\n+            let _g = m2.lock().unwrap();\n+            c2.notify_one();\n         });\n-        let g = C.wait(g).unwrap();\n+        let g = c.wait(g).unwrap();\n         drop(g);\n-        unsafe { C.destroy(); M.destroy(); }\n     }\n \n     #[test]\n@@ -495,84 +314,41 @@ mod tests {\n \n     #[test]\n     fn wait_timeout_ms() {\n-        static C: StaticCondvar = StaticCondvar::new();\n-        static M: StaticMutex = StaticMutex::new();\n+        let m = Arc::new(Mutex::new(()));\n+        let m2 = m.clone();\n+        let c = Arc::new(Condvar::new());\n+        let c2 = c.clone();\n \n-        let g = M.lock().unwrap();\n-        let (g, _no_timeout) = C.wait_timeout(g, Duration::from_millis(1)).unwrap();\n+        let g = m.lock().unwrap();\n+        let (g, _no_timeout) = c.wait_timeout(g, Duration::from_millis(1)).unwrap();\n         // spurious wakeups mean this isn't necessarily true\n         // assert!(!no_timeout);\n         let _t = thread::spawn(move || {\n-            let _g = M.lock().unwrap();\n-            C.notify_one();\n+            let _g = m2.lock().unwrap();\n+            c2.notify_one();\n         });\n-        let (g, timeout_res) = C.wait_timeout(g, Duration::from_millis(u32::MAX as u64)).unwrap();\n+        let (g, timeout_res) = c.wait_timeout(g, Duration::from_millis(u32::MAX as u64)).unwrap();\n         assert!(!timeout_res.timed_out());\n         drop(g);\n-        unsafe { C.destroy(); M.destroy(); }\n-    }\n-\n-    #[test]\n-    fn wait_timeout_with() {\n-        static C: StaticCondvar = StaticCondvar::new();\n-        static M: StaticMutex = StaticMutex::new();\n-        static S: AtomicUsize = AtomicUsize::new(0);\n-\n-        let g = M.lock().unwrap();\n-        let (g, timed_out) = C.wait_timeout_with(g, Duration::new(0, 1000), |_| {\n-            false\n-        }).unwrap();\n-        assert!(timed_out.timed_out());\n-\n-        let (tx, rx) = channel();\n-        let _t = thread::spawn(move || {\n-            rx.recv().unwrap();\n-            let g = M.lock().unwrap();\n-            S.store(1, Ordering::SeqCst);\n-            C.notify_one();\n-            drop(g);\n-\n-            rx.recv().unwrap();\n-            let g = M.lock().unwrap();\n-            S.store(2, Ordering::SeqCst);\n-            C.notify_one();\n-            drop(g);\n-\n-            rx.recv().unwrap();\n-            let _g = M.lock().unwrap();\n-            S.store(3, Ordering::SeqCst);\n-            C.notify_one();\n-        });\n-\n-        let mut state = 0;\n-        let day = 24 * 60 * 60;\n-        let (_g, timed_out) = C.wait_timeout_with(g, Duration::new(day, 0), |_| {\n-            assert_eq!(state, S.load(Ordering::SeqCst));\n-            tx.send(()).unwrap();\n-            state += 1;\n-            match state {\n-                1|2 => false,\n-                _ => true,\n-            }\n-        }).unwrap();\n-        assert!(!timed_out.timed_out());\n     }\n \n     #[test]\n     #[should_panic]\n     fn two_mutexes() {\n-        static M1: StaticMutex = StaticMutex::new();\n-        static M2: StaticMutex = StaticMutex::new();\n-        static C: StaticCondvar = StaticCondvar::new();\n+        let m = Arc::new(Mutex::new(()));\n+        let m2 = m.clone();\n+        let c = Arc::new(Condvar::new());\n+        let c2 = c.clone();\n \n-        let mut g = M1.lock().unwrap();\n+        let mut g = m.lock().unwrap();\n         let _t = thread::spawn(move|| {\n-            let _g = M1.lock().unwrap();\n-            C.notify_one();\n+            let _g = m2.lock().unwrap();\n+            c2.notify_one();\n         });\n-        g = C.wait(g).unwrap();\n+        g = c.wait(g).unwrap();\n         drop(g);\n \n-        let _ = C.wait(M2.lock().unwrap()).unwrap();\n+        let m = Mutex::new(());\n+        let _ = c.wait(m.lock().unwrap()).unwrap();\n     }\n }"}, {"sha": "289b47b34847fbd16a08ae080683e5f605e836a7", "filename": "src/libstd/sync/mod.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/26fd0117f9a5128d39a30ae36efc731042bd1fec/src%2Flibstd%2Fsync%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26fd0117f9a5128d39a30ae36efc731042bd1fec/src%2Flibstd%2Fsync%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmod.rs?ref=26fd0117f9a5128d39a30ae36efc731042bd1fec", "patch": "@@ -25,23 +25,15 @@ pub use core::sync::atomic;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::barrier::{Barrier, BarrierWaitResult};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated)]\n-pub use self::condvar::{Condvar, StaticCondvar, WaitTimeoutResult, CONDVAR_INIT};\n+pub use self::condvar::{Condvar, WaitTimeoutResult};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated)]\n-pub use self::mutex::MUTEX_INIT;\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated)]\n-pub use self::mutex::{Mutex, MutexGuard, StaticMutex};\n+pub use self::mutex::{Mutex, MutexGuard};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::once::{Once, OnceState, ONCE_INIT};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use sys_common::poison::{PoisonError, TryLockError, TryLockResult, LockResult};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::rwlock::{RwLockReadGuard, RwLockWriteGuard};\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated)]\n-pub use self::rwlock::{RwLock, StaticRwLock, RW_LOCK_INIT};\n+pub use self::rwlock::{RwLock, RwLockReadGuard, RwLockWriteGuard};\n \n pub mod mpsc;\n "}, {"sha": "6bc458397f1632282a8946cff69c45d1214e31de", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 46, "deletions": 173, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/26fd0117f9a5128d39a30ae36efc731042bd1fec/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26fd0117f9a5128d39a30ae36efc731042bd1fec/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=26fd0117f9a5128d39a30ae36efc731042bd1fec", "patch": "@@ -113,14 +113,14 @@ use sys_common::poison::{self, TryLockError, TryLockResult, LockResult};\n /// *guard += 1;\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated)]\n pub struct Mutex<T: ?Sized> {\n-    // Note that this static mutex is in a *box*, not inlined into the struct\n-    // itself. Once a native mutex has been used once, its address can never\n-    // change (it can't be moved). This mutex type can be safely moved at any\n-    // time, so to ensure that the native mutex is used correctly we box the\n-    // inner lock to give it a constant address.\n-    inner: Box<StaticMutex>,\n+    // Note that this mutex is in a *box*, not inlined into the struct itself.\n+    // Once a native mutex has been used once, its address can never change (it\n+    // can't be moved). This mutex type can be safely moved at any time, so to\n+    // ensure that the native mutex is used correctly we box the inner lock to\n+    // give it a constant address.\n+    inner: Box<sys::Mutex>,\n+    poison: poison::Flag,\n     data: UnsafeCell<T>,\n }\n \n@@ -131,91 +131,39 @@ unsafe impl<T: ?Sized + Send> Send for Mutex<T> { }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl<T: ?Sized + Send> Sync for Mutex<T> { }\n \n-/// The static mutex type is provided to allow for static allocation of mutexes.\n-///\n-/// Note that this is a separate type because using a Mutex correctly means that\n-/// it needs to have a destructor run. In Rust, statics are not allowed to have\n-/// destructors. As a result, a `StaticMutex` has one extra method when compared\n-/// to a `Mutex`, a `destroy` method. This method is unsafe to call, and\n-/// documentation can be found directly on the method.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// #![feature(static_mutex)]\n-///\n-/// use std::sync::{StaticMutex, MUTEX_INIT};\n-///\n-/// static LOCK: StaticMutex = MUTEX_INIT;\n-///\n-/// {\n-///     let _g = LOCK.lock().unwrap();\n-///     // do some productive work\n-/// }\n-/// // lock is unlocked here.\n-/// ```\n-#[unstable(feature = \"static_mutex\",\n-           reason = \"may be merged with Mutex in the future\",\n-           issue = \"27717\")]\n-#[rustc_deprecated(since = \"1.10.0\",\n-                   reason = \"the lazy-static crate suffices for static sync \\\n-                             primitives and eventually this type shouldn't \\\n-                             be necessary as `Mutex::new` in a static should \\\n-                             suffice\")]\n-pub struct StaticMutex {\n-    lock: sys::Mutex,\n-    poison: poison::Flag,\n-}\n-\n /// An RAII implementation of a \"scoped lock\" of a mutex. When this structure is\n /// dropped (falls out of scope), the lock will be unlocked.\n ///\n /// The data protected by the mutex can be access through this guard via its\n /// `Deref` and `DerefMut` implementations\n #[must_use]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated)]\n pub struct MutexGuard<'a, T: ?Sized + 'a> {\n     // funny underscores due to how Deref/DerefMut currently work (they\n     // disregard field privacy).\n-    __lock: &'a StaticMutex,\n-    __data: &'a mut T,\n+    __lock: &'a Mutex<T>,\n     __poison: poison::Guard,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: ?Sized> !marker::Send for MutexGuard<'a, T> {}\n \n-/// Static initialization of a mutex. This constant can be used to initialize\n-/// other mutex constants.\n-#[unstable(feature = \"static_mutex\",\n-           reason = \"may be merged with Mutex in the future\",\n-           issue = \"27717\")]\n-#[rustc_deprecated(since = \"1.10.0\",\n-                   reason = \"the lazy-static crate suffices for static sync \\\n-                             primitives and eventually this type shouldn't \\\n-                             be necessary as `Mutex::new` in a static should \\\n-                             suffice\")]\n-#[allow(deprecated)]\n-pub const MUTEX_INIT: StaticMutex = StaticMutex::new();\n-\n-#[allow(deprecated)]\n impl<T> Mutex<T> {\n     /// Creates a new mutex in an unlocked state ready for use.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(t: T) -> Mutex<T> {\n         let mut m = Mutex {\n-            inner: box StaticMutex::new(),\n+            inner: box sys::Mutex::new(),\n+            poison: poison::Flag::new(),\n             data: UnsafeCell::new(t),\n         };\n         unsafe {\n-            m.inner.lock.init();\n+            m.inner.init();\n         }\n         m\n     }\n }\n \n-#[allow(deprecated)]\n impl<T: ?Sized> Mutex<T> {\n     /// Acquires a mutex, blocking the current thread until it is able to do so.\n     ///\n@@ -240,8 +188,8 @@ impl<T: ?Sized> Mutex<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn lock(&self) -> LockResult<MutexGuard<T>> {\n         unsafe {\n-            self.inner.lock.lock();\n-            MutexGuard::new(&*self.inner, &self.data)\n+            self.inner.lock();\n+            MutexGuard::new(self)\n         }\n     }\n \n@@ -261,8 +209,8 @@ impl<T: ?Sized> Mutex<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn try_lock(&self) -> TryLockResult<MutexGuard<T>> {\n         unsafe {\n-            if self.inner.lock.try_lock() {\n-                Ok(MutexGuard::new(&*self.inner, &self.data)?)\n+            if self.inner.try_lock() {\n+                Ok(MutexGuard::new(self)?)\n             } else {\n                 Err(TryLockError::WouldBlock)\n             }\n@@ -277,7 +225,7 @@ impl<T: ?Sized> Mutex<T> {\n     #[inline]\n     #[stable(feature = \"sync_poison\", since = \"1.2.0\")]\n     pub fn is_poisoned(&self) -> bool {\n-        self.inner.poison.get()\n+        self.poison.get()\n     }\n \n     /// Consumes this mutex, returning the underlying data.\n@@ -289,21 +237,22 @@ impl<T: ?Sized> Mutex<T> {\n     #[stable(feature = \"mutex_into_inner\", since = \"1.6.0\")]\n     pub fn into_inner(self) -> LockResult<T> where T: Sized {\n         // We know statically that there are no outstanding references to\n-        // `self` so there's no need to lock the inner StaticMutex.\n+        // `self` so there's no need to lock the inner lock.\n         //\n         // To get the inner value, we'd like to call `data.into_inner()`,\n         // but because `Mutex` impl-s `Drop`, we can't move out of it, so\n         // we'll have to destructure it manually instead.\n         unsafe {\n-            // Like `let Mutex { inner, data } = self`.\n-            let (inner, data) = {\n-                let Mutex { ref inner, ref data } = self;\n-                (ptr::read(inner), ptr::read(data))\n+            // Like `let Mutex { inner, poison, data } = self`.\n+            let (inner, poison, data) = {\n+                let Mutex { ref inner, ref poison, ref data } = self;\n+                (ptr::read(inner), ptr::read(poison), ptr::read(data))\n             };\n             mem::forget(self);\n-            inner.lock.destroy();  // Keep in sync with the `Drop` impl.\n+            inner.destroy();  // Keep in sync with the `Drop` impl.\n+            drop(inner);\n \n-            poison::map_result(inner.poison.borrow(), |_| data.into_inner())\n+            poison::map_result(poison.borrow(), |_| data.into_inner())\n         }\n     }\n \n@@ -319,14 +268,13 @@ impl<T: ?Sized> Mutex<T> {\n     #[stable(feature = \"mutex_get_mut\", since = \"1.6.0\")]\n     pub fn get_mut(&mut self) -> LockResult<&mut T> {\n         // We know statically that there are no other references to `self`, so\n-        // there's no need to lock the inner StaticMutex.\n+        // there's no need to lock the inner lock.\n         let data = unsafe { &mut *self.data.get() };\n-        poison::map_result(self.inner.poison.borrow(), |_| data )\n+        poison::map_result(self.poison.borrow(), |_| data )\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated)]\n impl<T: ?Sized> Drop for Mutex<T> {\n     #[unsafe_destructor_blind_to_params]\n     fn drop(&mut self) {\n@@ -335,7 +283,7 @@ impl<T: ?Sized> Drop for Mutex<T> {\n         // dropped, that's not our job)\n         //\n         // IMPORTANT: This code must be kept in sync with `Mutex::into_inner`.\n-        unsafe { self.inner.lock.destroy() }\n+        unsafe { self.inner.destroy() }\n     }\n }\n \n@@ -359,72 +307,11 @@ impl<T: ?Sized + fmt::Debug> fmt::Debug for Mutex<T> {\n     }\n }\n \n-struct Dummy(UnsafeCell<()>);\n-unsafe impl Sync for Dummy {}\n-static DUMMY: Dummy = Dummy(UnsafeCell::new(()));\n-\n-#[unstable(feature = \"static_mutex\",\n-           reason = \"may be merged with Mutex in the future\",\n-           issue = \"27717\")]\n-#[rustc_deprecated(since = \"1.10.0\",\n-                   reason = \"the lazy-static crate suffices for static sync \\\n-                             primitives and eventually this type shouldn't \\\n-                             be necessary as `Mutex::new` in a static should \\\n-                             suffice\")]\n-#[allow(deprecated)]\n-impl StaticMutex {\n-    /// Creates a new mutex in an unlocked state ready for use.\n-    pub const fn new() -> StaticMutex {\n-        StaticMutex {\n-            lock: sys::Mutex::new(),\n-            poison: poison::Flag::new(),\n-        }\n-    }\n-\n-    /// Acquires this lock, see `Mutex::lock`\n-    #[inline]\n-    pub fn lock(&'static self) -> LockResult<MutexGuard<()>> {\n-        unsafe {\n-            self.lock.lock();\n-            MutexGuard::new(self, &DUMMY.0)\n-        }\n-    }\n-\n-    /// Attempts to grab this lock, see `Mutex::try_lock`\n-    #[inline]\n-    pub fn try_lock(&'static self) -> TryLockResult<MutexGuard<()>> {\n-        unsafe {\n-            if self.lock.try_lock() {\n-                Ok(MutexGuard::new(self, &DUMMY.0)?)\n-            } else {\n-                Err(TryLockError::WouldBlock)\n-            }\n-        }\n-    }\n-\n-    /// Deallocates resources associated with this static mutex.\n-    ///\n-    /// This method is unsafe because it provides no guarantees that there are\n-    /// no active users of this mutex, and safety is not guaranteed if there are\n-    /// active users of this mutex.\n-    ///\n-    /// This method is required to ensure that there are no memory leaks on\n-    /// *all* platforms. It may be the case that some platforms do not leak\n-    /// memory if this method is not called, but this is not guaranteed to be\n-    /// true on all platforms.\n-    pub unsafe fn destroy(&'static self) {\n-        self.lock.destroy()\n-    }\n-}\n-\n-#[allow(deprecated)]\n impl<'mutex, T: ?Sized> MutexGuard<'mutex, T> {\n-    unsafe fn new(lock: &'mutex StaticMutex, data: &'mutex UnsafeCell<T>)\n-           -> LockResult<MutexGuard<'mutex, T>> {\n+    unsafe fn new(lock: &'mutex Mutex<T>) -> LockResult<MutexGuard<'mutex, T>> {\n         poison::map_result(lock.poison.borrow(), |guard| {\n             MutexGuard {\n                 __lock: lock,\n-                __data: &mut *data.get(),\n                 __poison: guard,\n             }\n         })\n@@ -435,43 +322,43 @@ impl<'mutex, T: ?Sized> MutexGuard<'mutex, T> {\n impl<'mutex, T: ?Sized> Deref for MutexGuard<'mutex, T> {\n     type Target = T;\n \n-    fn deref(&self) -> &T {self.__data }\n+    fn deref(&self) -> &T {\n+        unsafe { &*self.__lock.data.get() }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'mutex, T: ?Sized> DerefMut for MutexGuard<'mutex, T> {\n-    fn deref_mut(&mut self) -> &mut T { self.__data }\n+    fn deref_mut(&mut self) -> &mut T {\n+        unsafe { &mut *self.__lock.data.get() }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated)]\n impl<'a, T: ?Sized> Drop for MutexGuard<'a, T> {\n     #[inline]\n     fn drop(&mut self) {\n         unsafe {\n             self.__lock.poison.done(&self.__poison);\n-            self.__lock.lock.unlock();\n+            self.__lock.inner.unlock();\n         }\n     }\n }\n \n-#[allow(deprecated)]\n pub fn guard_lock<'a, T: ?Sized>(guard: &MutexGuard<'a, T>) -> &'a sys::Mutex {\n-    &guard.__lock.lock\n+    &guard.__lock.inner\n }\n \n-#[allow(deprecated)]\n pub fn guard_poison<'a, T: ?Sized>(guard: &MutexGuard<'a, T>) -> &'a poison::Flag {\n     &guard.__lock.poison\n }\n \n #[cfg(test)]\n-#[allow(deprecated)]\n mod tests {\n     use prelude::v1::*;\n \n     use sync::mpsc::channel;\n-    use sync::{Arc, Mutex, StaticMutex, Condvar};\n+    use sync::{Arc, Mutex, Condvar};\n     use sync::atomic::{AtomicUsize, Ordering};\n     use thread;\n \n@@ -490,48 +377,34 @@ mod tests {\n         drop(m.lock().unwrap());\n     }\n \n-    #[test]\n-    fn smoke_static() {\n-        static M: StaticMutex = StaticMutex::new();\n-        unsafe {\n-            drop(M.lock().unwrap());\n-            drop(M.lock().unwrap());\n-            M.destroy();\n-        }\n-    }\n-\n     #[test]\n     fn lots_and_lots() {\n-        static M: StaticMutex = StaticMutex::new();\n-        static mut CNT: u32 = 0;\n         const J: u32 = 1000;\n         const K: u32 = 3;\n \n-        fn inc() {\n+        let m = Arc::new(Mutex::new(0));\n+\n+        fn inc(m: &Mutex<u32>) {\n             for _ in 0..J {\n-                unsafe {\n-                    let _g = M.lock().unwrap();\n-                    CNT += 1;\n-                }\n+                *m.lock().unwrap() += 1;\n             }\n         }\n \n         let (tx, rx) = channel();\n         for _ in 0..K {\n             let tx2 = tx.clone();\n-            thread::spawn(move|| { inc(); tx2.send(()).unwrap(); });\n+            let m2 = m.clone();\n+            thread::spawn(move|| { inc(&m2); tx2.send(()).unwrap(); });\n             let tx2 = tx.clone();\n-            thread::spawn(move|| { inc(); tx2.send(()).unwrap(); });\n+            let m2 = m.clone();\n+            thread::spawn(move|| { inc(&m2); tx2.send(()).unwrap(); });\n         }\n \n         drop(tx);\n         for _ in 0..2 * K {\n             rx.recv().unwrap();\n         }\n-        assert_eq!(unsafe {CNT}, J * K * 2);\n-        unsafe {\n-            M.destroy();\n-        }\n+        assert_eq!(*m.lock().unwrap(), J * K * 2);\n     }\n \n     #[test]"}, {"sha": "65b5686de869ca7fb05f9369a3435753612d5a35", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 49, "deletions": 200, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/26fd0117f9a5128d39a30ae36efc731042bd1fec/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26fd0117f9a5128d39a30ae36efc731042bd1fec/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=26fd0117f9a5128d39a30ae36efc731042bd1fec", "patch": "@@ -66,9 +66,9 @@ use sys_common::rwlock as sys;\n /// } // write lock is dropped here\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated)]\n pub struct RwLock<T: ?Sized> {\n-    inner: Box<StaticRwLock>,\n+    inner: Box<sys::RWLock>,\n+    poison: poison::Flag,\n     data: UnsafeCell<T>,\n }\n \n@@ -77,64 +77,12 @@ unsafe impl<T: ?Sized + Send + Sync> Send for RwLock<T> {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl<T: ?Sized + Send + Sync> Sync for RwLock<T> {}\n \n-/// Structure representing a statically allocated RwLock.\n-///\n-/// This structure is intended to be used inside of a `static` and will provide\n-/// automatic global access as well as lazy initialization. The internal\n-/// resources of this RwLock, however, must be manually deallocated.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// #![feature(static_rwlock)]\n-///\n-/// use std::sync::{StaticRwLock, RW_LOCK_INIT};\n-///\n-/// static LOCK: StaticRwLock = RW_LOCK_INIT;\n-///\n-/// {\n-///     let _g = LOCK.read().unwrap();\n-///     // ... shared read access\n-/// }\n-/// {\n-///     let _g = LOCK.write().unwrap();\n-///     // ... exclusive write access\n-/// }\n-/// unsafe { LOCK.destroy() } // free all resources\n-/// ```\n-#[unstable(feature = \"static_rwlock\",\n-           reason = \"may be merged with RwLock in the future\",\n-           issue = \"27717\")]\n-#[rustc_deprecated(since = \"1.10.0\",\n-                   reason = \"the lazy-static crate suffices for static sync \\\n-                             primitives and eventually this type shouldn't \\\n-                             be necessary as `RwLock::new` in a static should \\\n-                             suffice\")]\n-pub struct StaticRwLock {\n-    lock: sys::RWLock,\n-    poison: poison::Flag,\n-}\n-\n-/// Constant initialization for a statically-initialized rwlock.\n-#[unstable(feature = \"static_rwlock\",\n-           reason = \"may be merged with RwLock in the future\",\n-           issue = \"27717\")]\n-#[rustc_deprecated(since = \"1.10.0\",\n-                   reason = \"the lazy-static crate suffices for static sync \\\n-                             primitives and eventually this type shouldn't \\\n-                             be necessary as `RwLock::new` in a static should \\\n-                             suffice\")]\n-#[allow(deprecated)]\n-pub const RW_LOCK_INIT: StaticRwLock = StaticRwLock::new();\n-\n /// RAII structure used to release the shared read access of a lock when\n /// dropped.\n #[must_use]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated)]\n pub struct RwLockReadGuard<'a, T: ?Sized + 'a> {\n-    __lock: &'a StaticRwLock,\n-    __data: &'a T,\n+    __lock: &'a RwLock<T>,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -144,17 +92,14 @@ impl<'a, T: ?Sized> !marker::Send for RwLockReadGuard<'a, T> {}\n /// dropped.\n #[must_use]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated)]\n pub struct RwLockWriteGuard<'a, T: ?Sized + 'a> {\n-    __lock: &'a StaticRwLock,\n-    __data: &'a mut T,\n+    __lock: &'a RwLock<T>,\n     __poison: poison::Guard,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: ?Sized> !marker::Send for RwLockWriteGuard<'a, T> {}\n \n-#[allow(deprecated)]\n impl<T> RwLock<T> {\n     /// Creates a new instance of an `RwLock<T>` which is unlocked.\n     ///\n@@ -167,11 +112,14 @@ impl<T> RwLock<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(t: T) -> RwLock<T> {\n-        RwLock { inner: box StaticRwLock::new(), data: UnsafeCell::new(t) }\n+        RwLock {\n+            inner: box sys::RWLock::new(),\n+            poison: poison::Flag::new(),\n+            data: UnsafeCell::new(t),\n+        }\n     }\n }\n \n-#[allow(deprecated)]\n impl<T: ?Sized> RwLock<T> {\n     /// Locks this rwlock with shared read access, blocking the current thread\n     /// until it can be acquired.\n@@ -194,8 +142,8 @@ impl<T: ?Sized> RwLock<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn read(&self) -> LockResult<RwLockReadGuard<T>> {\n         unsafe {\n-            self.inner.lock.read();\n-            RwLockReadGuard::new(&*self.inner, &self.data)\n+            self.inner.read();\n+            RwLockReadGuard::new(self)\n         }\n     }\n \n@@ -220,8 +168,8 @@ impl<T: ?Sized> RwLock<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn try_read(&self) -> TryLockResult<RwLockReadGuard<T>> {\n         unsafe {\n-            if self.inner.lock.try_read() {\n-                Ok(RwLockReadGuard::new(&*self.inner, &self.data)?)\n+            if self.inner.try_read() {\n+                Ok(RwLockReadGuard::new(self)?)\n             } else {\n                 Err(TryLockError::WouldBlock)\n             }\n@@ -246,8 +194,8 @@ impl<T: ?Sized> RwLock<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn write(&self) -> LockResult<RwLockWriteGuard<T>> {\n         unsafe {\n-            self.inner.lock.write();\n-            RwLockWriteGuard::new(&*self.inner, &self.data)\n+            self.inner.write();\n+            RwLockWriteGuard::new(self)\n         }\n     }\n \n@@ -272,8 +220,8 @@ impl<T: ?Sized> RwLock<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn try_write(&self) -> TryLockResult<RwLockWriteGuard<T>> {\n         unsafe {\n-            if self.inner.lock.try_write() {\n-                Ok(RwLockWriteGuard::new(&*self.inner, &self.data)?)\n+            if self.inner.try_write() {\n+                Ok(RwLockWriteGuard::new(self)?)\n             } else {\n                 Err(TryLockError::WouldBlock)\n             }\n@@ -288,7 +236,7 @@ impl<T: ?Sized> RwLock<T> {\n     #[inline]\n     #[stable(feature = \"sync_poison\", since = \"1.2.0\")]\n     pub fn is_poisoned(&self) -> bool {\n-        self.inner.poison.get()\n+        self.poison.get()\n     }\n \n     /// Consumes this `RwLock`, returning the underlying data.\n@@ -302,21 +250,22 @@ impl<T: ?Sized> RwLock<T> {\n     #[stable(feature = \"rwlock_into_inner\", since = \"1.6.0\")]\n     pub fn into_inner(self) -> LockResult<T> where T: Sized {\n         // We know statically that there are no outstanding references to\n-        // `self` so there's no need to lock the inner StaticRwLock.\n+        // `self` so there's no need to lock the inner lock.\n         //\n         // To get the inner value, we'd like to call `data.into_inner()`,\n         // but because `RwLock` impl-s `Drop`, we can't move out of it, so\n         // we'll have to destructure it manually instead.\n         unsafe {\n-            // Like `let RwLock { inner, data } = self`.\n-            let (inner, data) = {\n-                let RwLock { ref inner, ref data } = self;\n-                (ptr::read(inner), ptr::read(data))\n+            // Like `let RwLock { inner, poison, data } = self`.\n+            let (inner, poison, data) = {\n+                let RwLock { ref inner, ref poison, ref data } = self;\n+                (ptr::read(inner), ptr::read(poison), ptr::read(data))\n             };\n             mem::forget(self);\n-            inner.lock.destroy();  // Keep in sync with the `Drop` impl.\n+            inner.destroy();  // Keep in sync with the `Drop` impl.\n+            drop(inner);\n \n-            poison::map_result(inner.poison.borrow(), |_| data.into_inner())\n+            poison::map_result(poison.borrow(), |_| data.into_inner())\n         }\n     }\n \n@@ -334,19 +283,18 @@ impl<T: ?Sized> RwLock<T> {\n     #[stable(feature = \"rwlock_get_mut\", since = \"1.6.0\")]\n     pub fn get_mut(&mut self) -> LockResult<&mut T> {\n         // We know statically that there are no other references to `self`, so\n-        // there's no need to lock the inner StaticRwLock.\n+        // there's no need to lock the inner lock.\n         let data = unsafe { &mut *self.data.get() };\n-        poison::map_result(self.inner.poison.borrow(), |_| data )\n+        poison::map_result(self.poison.borrow(), |_| data)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated)]\n impl<T: ?Sized> Drop for RwLock<T> {\n     #[unsafe_destructor_blind_to_params]\n     fn drop(&mut self) {\n         // IMPORTANT: This code needs to be kept in sync with `RwLock::into_inner`.\n-        unsafe { self.inner.lock.destroy() }\n+        unsafe { self.inner.destroy() }\n     }\n }\n \n@@ -370,114 +318,23 @@ impl<T: Default> Default for RwLock<T> {\n     }\n }\n \n-struct Dummy(UnsafeCell<()>);\n-unsafe impl Sync for Dummy {}\n-static DUMMY: Dummy = Dummy(UnsafeCell::new(()));\n-\n-#[unstable(feature = \"static_rwlock\",\n-           reason = \"may be merged with RwLock in the future\",\n-           issue = \"27717\")]\n-#[rustc_deprecated(since = \"1.10.0\",\n-                   reason = \"the lazy-static crate suffices for static sync \\\n-                             primitives and eventually this type shouldn't \\\n-                             be necessary as `RwLock::new` in a static should \\\n-                             suffice\")]\n-#[allow(deprecated)]\n-impl StaticRwLock {\n-    /// Creates a new rwlock.\n-    pub const fn new() -> StaticRwLock {\n-        StaticRwLock {\n-            lock: sys::RWLock::new(),\n-            poison: poison::Flag::new(),\n-        }\n-    }\n-\n-    /// Locks this rwlock with shared read access, blocking the current thread\n-    /// until it can be acquired.\n-    ///\n-    /// See `RwLock::read`.\n-    #[inline]\n-    pub fn read(&'static self) -> LockResult<RwLockReadGuard<'static, ()>> {\n-        unsafe {\n-            self.lock.read();\n-            RwLockReadGuard::new(self, &DUMMY.0)\n-        }\n-    }\n-\n-    /// Attempts to acquire this lock with shared read access.\n-    ///\n-    /// See `RwLock::try_read`.\n-    #[inline]\n-    pub fn try_read(&'static self)\n-                    -> TryLockResult<RwLockReadGuard<'static, ()>> {\n-        unsafe {\n-            if self.lock.try_read(){\n-                Ok(RwLockReadGuard::new(self, &DUMMY.0)?)\n-            } else {\n-                Err(TryLockError::WouldBlock)\n-            }\n-        }\n-    }\n-\n-    /// Locks this rwlock with exclusive write access, blocking the current\n-    /// thread until it can be acquired.\n-    ///\n-    /// See `RwLock::write`.\n-    #[inline]\n-    pub fn write(&'static self) -> LockResult<RwLockWriteGuard<'static, ()>> {\n-        unsafe {\n-            self.lock.write();\n-            RwLockWriteGuard::new(self, &DUMMY.0)\n-        }\n-    }\n-\n-    /// Attempts to lock this rwlock with exclusive write access.\n-    ///\n-    /// See `RwLock::try_write`.\n-    #[inline]\n-    pub fn try_write(&'static self)\n-                     -> TryLockResult<RwLockWriteGuard<'static, ()>> {\n-        unsafe {\n-            if self.lock.try_write() {\n-                Ok(RwLockWriteGuard::new(self, &DUMMY.0)?)\n-            } else {\n-                Err(TryLockError::WouldBlock)\n-            }\n-        }\n-    }\n-\n-    /// Deallocates all resources associated with this static lock.\n-    ///\n-    /// This method is unsafe to call as there is no guarantee that there are no\n-    /// active users of the lock, and this also doesn't prevent any future users\n-    /// of this lock. This method is required to be called to not leak memory on\n-    /// all platforms.\n-    pub unsafe fn destroy(&'static self) {\n-        self.lock.destroy()\n-    }\n-}\n-\n-#[allow(deprecated)]\n impl<'rwlock, T: ?Sized> RwLockReadGuard<'rwlock, T> {\n-    unsafe fn new(lock: &'rwlock StaticRwLock, data: &'rwlock UnsafeCell<T>)\n-           -> LockResult<RwLockReadGuard<'rwlock, T>> {\n+    unsafe fn new(lock: &'rwlock RwLock<T>)\n+                  -> LockResult<RwLockReadGuard<'rwlock, T>> {\n         poison::map_result(lock.poison.borrow(), |_| {\n             RwLockReadGuard {\n                 __lock: lock,\n-                __data: &*data.get(),\n             }\n         })\n     }\n }\n \n-#[allow(deprecated)]\n impl<'rwlock, T: ?Sized> RwLockWriteGuard<'rwlock, T> {\n-    unsafe fn new(lock: &'rwlock StaticRwLock, data: &'rwlock UnsafeCell<T>)\n-           -> LockResult<RwLockWriteGuard<'rwlock, T>> {\n+    unsafe fn new(lock: &'rwlock RwLock<T>)\n+                  -> LockResult<RwLockWriteGuard<'rwlock, T>> {\n         poison::map_result(lock.poison.borrow(), |guard| {\n             RwLockWriteGuard {\n                 __lock: lock,\n-                __data: &mut *data.get(),\n                 __poison: guard,\n             }\n         })\n@@ -488,42 +345,43 @@ impl<'rwlock, T: ?Sized> RwLockWriteGuard<'rwlock, T> {\n impl<'rwlock, T: ?Sized> Deref for RwLockReadGuard<'rwlock, T> {\n     type Target = T;\n \n-    fn deref(&self) -> &T { self.__data }\n+    fn deref(&self) -> &T {\n+        unsafe { &*self.__lock.data.get() }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'rwlock, T: ?Sized> Deref for RwLockWriteGuard<'rwlock, T> {\n     type Target = T;\n \n-    fn deref(&self) -> &T { self.__data }\n+    fn deref(&self) -> &T {\n+        unsafe { &*self.__lock.data.get() }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'rwlock, T: ?Sized> DerefMut for RwLockWriteGuard<'rwlock, T> {\n     fn deref_mut(&mut self) -> &mut T {\n-        self.__data\n+        unsafe { &mut *self.__lock.data.get() }\n     }\n }\n \n-#[allow(deprecated)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: ?Sized> Drop for RwLockReadGuard<'a, T> {\n     fn drop(&mut self) {\n-        unsafe { self.__lock.lock.read_unlock(); }\n+        unsafe { self.__lock.inner.read_unlock(); }\n     }\n }\n \n-#[allow(deprecated)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: ?Sized> Drop for RwLockWriteGuard<'a, T> {\n     fn drop(&mut self) {\n         self.__lock.poison.done(&self.__poison);\n-        unsafe { self.__lock.lock.write_unlock(); }\n+        unsafe { self.__lock.inner.write_unlock(); }\n     }\n }\n \n #[cfg(test)]\n-#[allow(deprecated)]\n mod tests {\n     #![allow(deprecated)] // rand\n \n@@ -532,7 +390,7 @@ mod tests {\n     use rand::{self, Rng};\n     use sync::mpsc::channel;\n     use thread;\n-    use sync::{Arc, RwLock, StaticRwLock, TryLockError};\n+    use sync::{Arc, RwLock, TryLockError};\n     use sync::atomic::{AtomicUsize, Ordering};\n \n     #[derive(Eq, PartialEq, Debug)]\n@@ -547,40 +405,31 @@ mod tests {\n         drop(l.write().unwrap());\n     }\n \n-    #[test]\n-    fn static_smoke() {\n-        static R: StaticRwLock = StaticRwLock::new();\n-        drop(R.read().unwrap());\n-        drop(R.write().unwrap());\n-        drop((R.read().unwrap(), R.read().unwrap()));\n-        drop(R.write().unwrap());\n-        unsafe { R.destroy(); }\n-    }\n-\n     #[test]\n     fn frob() {\n-        static R: StaticRwLock = StaticRwLock::new();\n         const N: usize = 10;\n         const M: usize = 1000;\n \n+        let r = Arc::new(RwLock::new(()));\n+\n         let (tx, rx) = channel::<()>();\n         for _ in 0..N {\n             let tx = tx.clone();\n-            thread::spawn(move|| {\n+            let r = r.clone();\n+            thread::spawn(move || {\n                 let mut rng = rand::thread_rng();\n                 for _ in 0..M {\n                     if rng.gen_weighted_bool(N) {\n-                        drop(R.write().unwrap());\n+                        drop(r.write().unwrap());\n                     } else {\n-                        drop(R.read().unwrap());\n+                        drop(r.read().unwrap());\n                     }\n                 }\n                 drop(tx);\n             });\n         }\n         drop(tx);\n         let _ = rx.recv();\n-        unsafe { R.destroy(); }\n     }\n \n     #[test]"}, {"sha": "55212bf35d698656df80e8d0a55cb767411a0b3a", "filename": "src/libstd/sys/common/poison.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/26fd0117f9a5128d39a30ae36efc731042bd1fec/src%2Flibstd%2Fsys%2Fcommon%2Fpoison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26fd0117f9a5128d39a30ae36efc731042bd1fec/src%2Flibstd%2Fsys%2Fcommon%2Fpoison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fpoison.rs?ref=26fd0117f9a5128d39a30ae36efc731042bd1fec", "patch": "@@ -8,22 +8,28 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use cell::Cell;\n use error::{Error};\n use fmt;\n use marker::Reflect;\n+use sync::atomic::{AtomicBool, Ordering};\n use thread;\n \n-pub struct Flag { failed: Cell<bool> }\n+pub struct Flag { failed: AtomicBool }\n \n-// This flag is only ever accessed with a lock previously held. Note that this\n-// a totally private structure.\n-unsafe impl Send for Flag {}\n-unsafe impl Sync for Flag {}\n+// Note that the Ordering uses to access the `failed` field of `Flag` below is\n+// always `Relaxed`, and that's because this isn't actually protecting any data,\n+// it's just a flag whether we've panicked or not.\n+//\n+// The actual location that this matters is when a mutex is **locked** which is\n+// where we have external synchronization ensuring that we see memory\n+// reads/writes to this flag.\n+//\n+// As a result, if it matters, we should see the correct value for `failed` in\n+// all cases.\n \n impl Flag {\n     pub const fn new() -> Flag {\n-        Flag { failed: Cell::new(false) }\n+        Flag { failed: AtomicBool::new(false) }\n     }\n \n     #[inline]\n@@ -39,13 +45,13 @@ impl Flag {\n     #[inline]\n     pub fn done(&self, guard: &Guard) {\n         if !guard.panicking && thread::panicking() {\n-            self.failed.set(true);\n+            self.failed.store(true, Ordering::Relaxed);\n         }\n     }\n \n     #[inline]\n     pub fn get(&self) -> bool {\n-        self.failed.get()\n+        self.failed.load(Ordering::Relaxed)\n     }\n }\n "}, {"sha": "82a44c1c1103b4aa7935a5889e11072c0ef05eae", "filename": "src/libstd/sys/windows/backtrace.rs", "status": "modified", "additions": 49, "deletions": 43, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/26fd0117f9a5128d39a30ae36efc731042bd1fec/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26fd0117f9a5128d39a30ae36efc731042bd1fec/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs?ref=26fd0117f9a5128d39a30ae36efc731042bd1fec", "patch": "@@ -30,9 +30,9 @@ use io;\n use libc::c_void;\n use mem;\n use ptr;\n-use sync::StaticMutex;\n use sys::c;\n use sys::dynamic_lib::DynamicLibrary;\n+use sys::mutex::Mutex;\n \n macro_rules! sym {\n     ($lib:expr, $e:expr, $t:ident) => (\n@@ -101,53 +101,59 @@ impl Drop for Cleanup {\n pub fn write(w: &mut Write) -> io::Result<()> {\n     // According to windows documentation, all dbghelp functions are\n     // single-threaded.\n-    static LOCK: StaticMutex = StaticMutex::new();\n-    let _g = LOCK.lock();\n+    static LOCK: Mutex = Mutex::new();\n+    unsafe {\n+        LOCK.lock();\n+        let res = _write(w);\n+        LOCK.unlock();\n+        return res\n+    }\n+}\n \n+unsafe fn _write(w: &mut Write) -> io::Result<()> {\n     let dbghelp = match DynamicLibrary::open(\"dbghelp.dll\") {\n         Ok(lib) => lib,\n         Err(..) => return Ok(()),\n     };\n-    unsafe {\n-        // Fetch the symbols necessary from dbghelp.dll\n-        let SymInitialize = sym!(dbghelp, \"SymInitialize\", SymInitializeFn);\n-        let SymCleanup = sym!(dbghelp, \"SymCleanup\", SymCleanupFn);\n-        let StackWalk64 = sym!(dbghelp, \"StackWalk64\", StackWalk64Fn);\n-\n-        // Allocate necessary structures for doing the stack walk\n-        let process = c::GetCurrentProcess();\n-        let thread = c::GetCurrentThread();\n-        let mut context: c::CONTEXT = mem::zeroed();\n-        c::RtlCaptureContext(&mut context);\n-        let mut frame: c::STACKFRAME64 = mem::zeroed();\n-        let image = init_frame(&mut frame, &context);\n-\n-        // Initialize this process's symbols\n-        let ret = SymInitialize(process, ptr::null_mut(), c::TRUE);\n-        if ret != c::TRUE { return Ok(()) }\n-        let _c = Cleanup { handle: process, SymCleanup: SymCleanup };\n-\n-        // And now that we're done with all the setup, do the stack walking!\n-        // Start from -1 to avoid printing this stack frame, which will\n-        // always be exactly the same.\n-        let mut i = -1;\n-        write!(w, \"stack backtrace:\\n\")?;\n-        while StackWalk64(image, process, thread, &mut frame, &mut context,\n-                          ptr::null_mut(),\n-                          ptr::null_mut(),\n-                          ptr::null_mut(),\n-                          ptr::null_mut()) == c::TRUE {\n-            let addr = frame.AddrPC.Offset;\n-            if addr == frame.AddrReturn.Offset || addr == 0 ||\n-               frame.AddrReturn.Offset == 0 { break }\n-\n-            i += 1;\n-\n-            if i >= 0 {\n-                printing::print(w, i, addr - 1, process, &dbghelp)?;\n-            }\n-        }\n \n-        Ok(())\n+    // Fetch the symbols necessary from dbghelp.dll\n+    let SymInitialize = sym!(dbghelp, \"SymInitialize\", SymInitializeFn);\n+    let SymCleanup = sym!(dbghelp, \"SymCleanup\", SymCleanupFn);\n+    let StackWalk64 = sym!(dbghelp, \"StackWalk64\", StackWalk64Fn);\n+\n+    // Allocate necessary structures for doing the stack walk\n+    let process = c::GetCurrentProcess();\n+    let thread = c::GetCurrentThread();\n+    let mut context: c::CONTEXT = mem::zeroed();\n+    c::RtlCaptureContext(&mut context);\n+    let mut frame: c::STACKFRAME64 = mem::zeroed();\n+    let image = init_frame(&mut frame, &context);\n+\n+    // Initialize this process's symbols\n+    let ret = SymInitialize(process, ptr::null_mut(), c::TRUE);\n+    if ret != c::TRUE { return Ok(()) }\n+    let _c = Cleanup { handle: process, SymCleanup: SymCleanup };\n+\n+    // And now that we're done with all the setup, do the stack walking!\n+    // Start from -1 to avoid printing this stack frame, which will\n+    // always be exactly the same.\n+    let mut i = -1;\n+    write!(w, \"stack backtrace:\\n\")?;\n+    while StackWalk64(image, process, thread, &mut frame, &mut context,\n+                      ptr::null_mut(),\n+                      ptr::null_mut(),\n+                      ptr::null_mut(),\n+                      ptr::null_mut()) == c::TRUE {\n+        let addr = frame.AddrPC.Offset;\n+        if addr == frame.AddrReturn.Offset || addr == 0 ||\n+           frame.AddrReturn.Offset == 0 { break }\n+\n+        i += 1;\n+\n+        if i >= 0 {\n+            printing::print(w, i, addr - 1, process, &dbghelp)?;\n+        }\n     }\n+\n+    Ok(())\n }"}, {"sha": "7b7bda302250fd8a30c62432d9a588567c320c11", "filename": "src/test/debuginfo/constant-debug-locs.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26fd0117f9a5128d39a30ae36efc731042bd1fec/src%2Ftest%2Fdebuginfo%2Fconstant-debug-locs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26fd0117f9a5128d39a30ae36efc731042bd1fec/src%2Ftest%2Fdebuginfo%2Fconstant-debug-locs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fconstant-debug-locs.rs?ref=26fd0117f9a5128d39a30ae36efc731042bd1fec", "patch": "@@ -21,7 +21,6 @@\n // This test makes sure that the compiler doesn't crash when trying to assign\n // debug locations to const-expressions.\n \n-use std::sync::StaticMutex;\n use std::cell::UnsafeCell;\n \n const CONSTANT: u64 = 3 + 4;\n@@ -63,6 +62,5 @@ fn main() {\n     let mut _string = STRING;\n     let mut _vec = VEC;\n     let mut _nested = NESTED;\n-    let mut _extern = StaticMutex::new();\n     let mut _unsafe_cell = UNSAFE_CELL;\n }"}, {"sha": "03884e8205bd27a866e5e8cf647c03f5364eb4b7", "filename": "src/test/run-pass/std-sync-right-kind-impls.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/26fd0117f9a5128d39a30ae36efc731042bd1fec/src%2Ftest%2Frun-pass%2Fstd-sync-right-kind-impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26fd0117f9a5128d39a30ae36efc731042bd1fec/src%2Ftest%2Frun-pass%2Fstd-sync-right-kind-impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstd-sync-right-kind-impls.rs?ref=26fd0117f9a5128d39a30ae36efc731042bd1fec", "patch": "@@ -18,9 +18,6 @@ use std::sync;\n fn assert_both<T: Sync + Send>() {}\n \n fn main() {\n-    assert_both::<sync::StaticMutex>();\n-    assert_both::<sync::StaticCondvar>();\n-    assert_both::<sync::StaticRwLock>();\n     assert_both::<sync::Mutex<()>>();\n     assert_both::<sync::Condvar>();\n     assert_both::<sync::RwLock<()>>();"}]}