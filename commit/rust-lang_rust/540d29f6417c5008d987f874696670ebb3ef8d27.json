{"sha": "540d29f6417c5008d987f874696670ebb3ef8d27", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0MGQyOWY2NDE3YzUwMDhkOTg3Zjg3NDY5NjY3MGViYjNlZjhkMjc=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-03-29T01:04:52Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-03-29T01:07:29Z"}, "message": "Move all allocas to dedicated basic block at top of function, to keep frames finite. Un-comment next size in nbody.rs.", "tree": {"sha": "fb5469533084454044b768752e43a436f7af9112", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fb5469533084454044b768752e43a436f7af9112"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/540d29f6417c5008d987f874696670ebb3ef8d27", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/540d29f6417c5008d987f874696670ebb3ef8d27", "html_url": "https://github.com/rust-lang/rust/commit/540d29f6417c5008d987f874696670ebb3ef8d27", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/540d29f6417c5008d987f874696670ebb3ef8d27/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2809e30d1dfae75b88a7cea87eb287da09455515", "url": "https://api.github.com/repos/rust-lang/rust/commits/2809e30d1dfae75b88a7cea87eb287da09455515", "html_url": "https://github.com/rust-lang/rust/commit/2809e30d1dfae75b88a7cea87eb287da09455515"}], "stats": {"total": 212, "additions": 151, "deletions": 61}, "files": [{"sha": "28f79dbbd66a92ec1760d83c42e9e44144273b66", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 141, "deletions": 56, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/540d29f6417c5008d987f874696670ebb3ef8d27/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/540d29f6417c5008d987f874696670ebb3ef8d27/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=540d29f6417c5008d987f874696670ebb3ef8d27", "patch": "@@ -114,6 +114,7 @@ state type fn_ctxt = rec(ValueRef llfn,\n                          ValueRef lltaskptr,\n                          ValueRef llenv,\n                          ValueRef llretptr,\n+                         mutable BasicBlockRef llallocas,\n                          mutable option.t[ValueRef] llself,\n                          mutable option.t[ValueRef] lliterbody,\n                          hashmap[ast.def_id, ValueRef] llargs,\n@@ -1047,6 +1048,15 @@ fn align_of(@block_ctxt cx, @ty.t t) -> result {\n     ret dynamic_align_of(cx, t);\n }\n \n+fn alloca(@block_ctxt cx, TypeRef t) -> ValueRef {\n+    ret new_builder(cx.fcx.llallocas).Alloca(t);\n+}\n+\n+fn array_alloca(@block_ctxt cx, TypeRef t, ValueRef n) -> ValueRef {\n+    ret new_builder(cx.fcx.llallocas).ArrayAlloca(t, n);\n+}\n+\n+\n // Computes the size of the data part of a non-dynamically-sized tag.\n fn static_size_of_tag(@crate_ctxt cx, @ty.t t) -> uint {\n     if (ty.type_has_dynamic_size(t)) {\n@@ -1144,7 +1154,7 @@ fn dynamic_size_of(@block_ctxt cx, @ty.t t) -> result {\n             auto bcx = cx;\n \n             // Compute max(variant sizes).\n-            let ValueRef max_size = bcx.build.Alloca(T_int());\n+            let ValueRef max_size = alloca(bcx, T_int());\n             bcx.build.Store(C_int(0), max_size);\n \n             auto ty_params = tag_ty_params(bcx.fcx.ccx, tid);\n@@ -1466,8 +1476,8 @@ fn get_tydesc(&@block_ctxt cx, @ty.t t) -> result {\n \n         auto root = cx.fcx.ccx.tydescs.get(t).tydesc;\n \n-        auto tydescs = cx.build.Alloca(T_array(T_ptr(T_tydesc(cx.fcx.ccx.tn)),\n-                                               1u /* for root*/ + n_params));\n+        auto tydescs = alloca(cx, T_array(T_ptr(T_tydesc(cx.fcx.ccx.tn)),\n+                                          1u /* for root*/ + n_params));\n \n         auto i = 0;\n         auto tdp = cx.build.GEP(tydescs, vec(C_int(0), C_int(i)));\n@@ -1593,6 +1603,7 @@ fn make_generic_glue(@crate_ctxt cx, @ty.t t, ValueRef llfn,\n                      vec[ast.def_id] typaram_defs) -> ValueRef {\n     auto fcx = new_fn_ctxt(cx, llfn);\n     auto bcx = new_top_block_ctxt(fcx);\n+    auto lltop = bcx.llbb;\n \n     auto re;\n     if (!ty.type_is_scalar(t)) {\n@@ -1623,6 +1634,10 @@ fn make_generic_glue(@crate_ctxt cx, @ty.t t, ValueRef llfn,\n     }\n \n     re.bcx.build.RetVoid();\n+\n+    // Tie up the llallocas -> lltop edge.\n+    new_builder(fcx.llallocas).Br(lltop);\n+\n     ret llfn;\n }\n \n@@ -2597,7 +2612,7 @@ fn trans_compare(@block_ctxt cx0, ast.binop op, @ty.t t0,\n          * optimize combinations like that, at this level.\n          */\n \n-        auto flag = scx.build.Alloca(T_i1());\n+        auto flag = alloca(scx, T_i1());\n \n         if (ty.type_is_sequence(t)) {\n \n@@ -3204,7 +3219,7 @@ fn trans_for_each(@block_ctxt cx,\n         }\n \n         // Create an array of bindings and copy in aliases to the upvars.\n-        llbindingsptr = cx.build.Alloca(T_struct(llbindingtys));\n+        llbindingsptr = alloca(cx, T_struct(llbindingtys));\n         auto i = 0u;\n         while (i < upvar_count) {\n             auto llbindingptr = cx.build.GEP(llbindingsptr,\n@@ -3220,7 +3235,7 @@ fn trans_for_each(@block_ctxt cx,\n     // Create an environment and populate it with the bindings.\n     auto llenvptrty = T_closure_ptr(cx.fcx.ccx.tn, T_ptr(T_nil()),\n                                     val_ty(llbindingsptr), 0u);\n-    auto llenvptr = cx.build.Alloca(llvm.LLVMGetElementType(llenvptrty));\n+    auto llenvptr = alloca(cx, llvm.LLVMGetElementType(llenvptrty));\n \n     auto llbindingsptrptr = cx.build.GEP(llenvptr,\n                                          vec(C_int(0),\n@@ -3251,6 +3266,7 @@ fn trans_for_each(@block_ctxt cx,\n \n     auto fcx = new_fn_ctxt(cx.fcx.ccx, lliterbody);\n     auto bcx = new_top_block_ctxt(fcx);\n+    auto lltop = bcx.llbb;\n \n     // Populate the upvars from the environment.\n     auto llremoteenvptr = bcx.build.PointerCast(fcx.llenv, llenvptrty);\n@@ -3272,11 +3288,15 @@ fn trans_for_each(@block_ctxt cx,\n     // Treat the loop variable as an upvar as well. We copy it to an alloca\n     // as usual.\n     auto lllvar = llvm.LLVMGetParam(fcx.llfn, 3u);\n-    auto lllvarptr = bcx.build.Alloca(val_ty(lllvar));\n+    auto lllvarptr = alloca(bcx, val_ty(lllvar));\n     bcx.build.Store(lllvar, lllvarptr);\n     fcx.llupvars.insert(decl_id, lllvarptr);\n \n     auto res = trans_block(bcx, body);\n+\n+    // Tie up the llallocas -> lltop edge.\n+    new_builder(fcx.llallocas).Br(lltop);\n+\n     res.bcx.build.RetVoid();\n \n \n@@ -3286,8 +3306,8 @@ fn trans_for_each(@block_ctxt cx,\n \n         case (ast.expr_call(?f, ?args, ?ann)) {\n \n-            auto pair = cx.build.Alloca(T_fn_pair(cx.fcx.ccx.tn,\n-                                                  iter_body_llty));\n+            auto pair = alloca(cx, T_fn_pair(cx.fcx.ccx.tn,\n+                                             iter_body_llty));\n             auto code_cell = cx.build.GEP(pair,\n                                           vec(C_int(0),\n                                               C_int(abi.fn_field_code)));\n@@ -3831,6 +3851,7 @@ fn trans_bind_thunk(@crate_ctxt cx,\n \n     auto fcx = new_fn_ctxt(cx, llthunk);\n     auto bcx = new_top_block_ctxt(fcx);\n+    auto lltop = bcx.llbb;\n \n     auto llclosure_ptr_ty = type_of(cx, ty.plain_box_ty(closure_ty));\n     auto llclosure = bcx.build.PointerCast(fcx.llenv, llclosure_ptr_ty);\n@@ -3944,6 +3965,9 @@ fn trans_bind_thunk(@crate_ctxt cx,\n     auto r = bcx.build.FastCall(lltargetfn, llargs);\n     bcx.build.RetVoid();\n \n+    // Tie up the llallocas -> lltop edge.\n+    new_builder(fcx.llallocas).Br(lltop);\n+\n     ret llthunk;\n }\n \n@@ -3987,7 +4011,7 @@ fn trans_bind(@block_ctxt cx, @ast.expr f,\n         } else {\n             auto bcx = f_res.res.bcx;\n             auto pair_t = node_type(cx.fcx.ccx, ann);\n-            auto pair_v = bcx.build.Alloca(pair_t);\n+            auto pair_v = alloca(bcx, pair_t);\n \n             // Translate the bound expressions.\n             let vec[@ty.t] bound_tys = vec();\n@@ -4245,7 +4269,7 @@ fn trans_args(@block_ctxt cx,\n                 // Non-mem but we're trying to alias; synthesize an\n                 // alloca, spill to it and pass its address.\n                 auto llty = val_ty(lv.res.val);\n-                auto llptr = lv.res.bcx.build.Alloca(llty);\n+                auto llptr = alloca(lv.res.bcx, llty);\n                 lv.res.bcx.build.Store(lv.res.val, llptr);\n                 val = llptr;\n             }\n@@ -4695,7 +4719,7 @@ fn trans_log(@block_ctxt cx, @ast.expr e) -> result {\n                              \"upcall_log_float\",\n                              vec(sub.val));\n         } else {\n-            auto tmp = sub.bcx.build.Alloca(tr);\n+            auto tmp = alloca(sub.bcx, tr);\n             sub.bcx.build.Store(sub.val, tmp);\n             auto v = vp2i(sub.bcx, tmp);\n             ret trans_upcall(sub.bcx,\n@@ -4751,7 +4775,7 @@ fn trans_put(@block_ctxt cx, &option.t[@ast.expr] e) -> result {\n \n     alt (cx.fcx.lliterbody) {\n         case (some[ValueRef](?lli)) {\n-            auto slot = cx.build.Alloca(val_ty(lli));\n+            auto slot = alloca(cx, val_ty(lli));\n             cx.build.Store(lli, slot);\n \n             llcallee = cx.build.GEP(slot, vec(C_int(0),\n@@ -4764,7 +4788,7 @@ fn trans_put(@block_ctxt cx, &option.t[@ast.expr] e) -> result {\n         }\n     }\n     auto bcx = cx;\n-    auto dummy_retslot = bcx.build.Alloca(T_nil());\n+    auto dummy_retslot = alloca(bcx, T_nil());\n     let vec[ValueRef] llargs = vec(dummy_retslot, cx.fcx.lltaskptr, llenv);\n     alt (e) {\n         case (none[@ast.expr]) { }\n@@ -5136,17 +5160,38 @@ iter block_locals(&ast.block b) -> @ast.local {\n     }\n }\n \n+fn llallocas_block_ctxt(@fn_ctxt fcx) -> @block_ctxt {\n+    let vec[cleanup] cleanups = vec();\n+    ret @rec(llbb=fcx.llallocas,\n+             build=new_builder(fcx.llallocas),\n+             parent=parent_none,\n+             kind=SCOPE_BLOCK,\n+             mutable cleanups=cleanups,\n+             fcx=fcx);\n+}\n+\n fn alloc_ty(@block_ctxt cx, @ty.t t) -> result {\n     auto val = C_int(0);\n-    auto bcx = cx;\n     if (ty.type_has_dynamic_size(t)) {\n-        auto n = size_of(bcx, t);\n-        bcx = n.bcx;\n-        val = bcx.build.ArrayAlloca(T_i8(), n.val);\n+\n+        // NB: we have to run this particular 'size_of' in a\n+        // block_ctxt built on the llallocas block for the fn,\n+        // so that the size dominates the array_alloca that\n+        // comes next.\n+\n+        auto n = size_of(llallocas_block_ctxt(cx.fcx), t);\n+        cx.fcx.llallocas = n.bcx.llbb;\n+        val = array_alloca(cx, T_i8(), n.val);\n     } else {\n-        val = bcx.build.Alloca(type_of(cx.fcx.ccx, t));\n+        val = alloca(cx, type_of(cx.fcx.ccx, t));\n     }\n-    ret res(bcx, val);\n+    // NB: since we've pushed all size calculations in this\n+    // function up to the alloca block, we actually return the\n+    // block passed into us unmodified; it doesn't really\n+    // have to be passed-and-returned here, but it fits\n+    // past caller conventions and may well make sense again,\n+    // so we leave it as-is.\n+    ret res(cx, val);\n }\n \n fn alloc_local(@block_ctxt cx, @ast.local local) -> result {\n@@ -5211,10 +5256,14 @@ fn new_fn_ctxt(@crate_ctxt cx,\n     let hashmap[ast.def_id, ValueRef] llupvars = new_def_hash[ValueRef]();\n     let hashmap[ast.def_id, ValueRef] lltydescs = new_def_hash[ValueRef]();\n \n+    let BasicBlockRef llallocas =\n+        llvm.LLVMAppendBasicBlock(llfndecl, _str.buf(\"allocas\"));\n+\n     ret @rec(llfn=llfndecl,\n              lltaskptr=lltaskptr,\n              llenv=llenv,\n              llretptr=llretptr,\n+             mutable llallocas = llallocas,\n              mutable llself=none[ValueRef],\n              mutable lliterbody=none[ValueRef],\n              llargs=llargs,\n@@ -5277,39 +5326,49 @@ fn create_llargs_for_fn_args(&@fn_ctxt cx,\n // allocas immediately upon entry; this permits us to GEP into structures we\n // were passed and whatnot. Apparently mem2reg will mop up.\n \n-fn copy_args_to_allocas(@block_ctxt cx,\n-                        option.t[TypeRef] ty_self,\n-                        vec[ast.arg] args,\n-                        vec[ty.arg] arg_tys) {\n+fn copy_any_self_to_alloca(@fn_ctxt fcx,\n+                           option.t[TypeRef] ty_self) {\n \n-    let uint arg_n = 0u;\n+    auto bcx = llallocas_block_ctxt(fcx);\n \n-    alt (cx.fcx.llself) {\n+    alt (fcx.llself) {\n         case (some[ValueRef](?self_v)) {\n             alt (ty_self) {\n                 case (some[TypeRef](?self_t)) {\n-                    auto alloca = cx.build.Alloca(self_t);\n-                    cx.build.Store(self_v, alloca);\n-                    cx.fcx.llself = some[ValueRef](alloca);\n+                    auto a = alloca(bcx, self_t);\n+                    bcx.build.Store(self_v, a);\n+                    fcx.llself = some[ValueRef](a);\n                 }\n             }\n         }\n         case (_) {\n         }\n     }\n+}\n+\n+\n+fn copy_args_to_allocas(@fn_ctxt fcx,\n+                        vec[ast.arg] args,\n+                        vec[ty.arg] arg_tys) {\n+\n+    auto bcx = llallocas_block_ctxt(fcx);\n+\n+    let uint arg_n = 0u;\n \n     for (ast.arg aarg in args) {\n         if (aarg.mode != ast.alias) {\n-            auto arg_t = type_of_arg(cx.fcx.ccx, arg_tys.(arg_n));\n-            auto alloca = cx.build.Alloca(arg_t);\n-            auto argval = cx.fcx.llargs.get(aarg.id);\n-            cx.build.Store(argval, alloca);\n+            auto arg_t = type_of_arg(fcx.ccx, arg_tys.(arg_n));\n+            auto a = alloca(bcx, arg_t);\n+            auto argval = fcx.llargs.get(aarg.id);\n+            bcx.build.Store(argval, a);\n             // Overwrite the llargs entry for this arg with its alloca.\n-            cx.fcx.llargs.insert(aarg.id, alloca);\n+            fcx.llargs.insert(aarg.id, a);\n         }\n \n         arg_n += 1u;\n     }\n+\n+    fcx.llallocas = bcx.llbb;\n }\n \n fn is_terminated(@block_ctxt cx) -> bool {\n@@ -5340,8 +5399,8 @@ fn ret_ty_of_fn(ast.ann ann) -> @ty.t {\n     ret ret_ty_of_fn_ty(ty.ann_to_type(ann));\n }\n \n-fn populate_fn_ctxt_from_llself(@block_ctxt cx, ValueRef llself) -> result {\n-    auto bcx = cx;\n+fn populate_fn_ctxt_from_llself(@fn_ctxt fcx, ValueRef llself) {\n+    auto bcx = llallocas_block_ctxt(fcx);\n \n     let vec[@ty.t] field_tys = vec();\n \n@@ -5379,7 +5438,7 @@ fn populate_fn_ctxt_from_llself(@block_ctxt cx, ValueRef llself) -> result {\n     // fields pointer to the appropriate LLVM type. If not, just leave it as\n     // i8 *.\n     if (!ty.type_has_dynamic_size(fields_tup_ty)) {\n-        auto llfields_ty = type_of(bcx.fcx.ccx, fields_tup_ty);\n+        auto llfields_ty = type_of(fcx.ccx, fields_tup_ty);\n         obj_fields = vi2p(bcx, obj_fields, T_ptr(llfields_ty));\n     } else {\n         obj_fields = vi2p(bcx, obj_fields, T_ptr(T_i8()));\n@@ -5388,25 +5447,25 @@ fn populate_fn_ctxt_from_llself(@block_ctxt cx, ValueRef llself) -> result {\n \n     let int i = 0;\n \n-    for (ast.ty_param p in bcx.fcx.ccx.obj_typarams) {\n+    for (ast.ty_param p in fcx.ccx.obj_typarams) {\n         let ValueRef lltyparam = bcx.build.GEP(obj_typarams,\n                                                vec(C_int(0),\n                                                    C_int(i)));\n         lltyparam = bcx.build.Load(lltyparam);\n-        bcx.fcx.lltydescs.insert(p.id, lltyparam);\n+        fcx.lltydescs.insert(p.id, lltyparam);\n         i += 1;\n     }\n \n     i = 0;\n-    for (ast.obj_field f in bcx.fcx.ccx.obj_fields) {\n+    for (ast.obj_field f in fcx.ccx.obj_fields) {\n         auto rslt = GEP_tup_like(bcx, fields_tup_ty, obj_fields, vec(0, i));\n-        bcx = rslt.bcx;\n+        bcx = llallocas_block_ctxt(fcx);\n         auto llfield = rslt.val;\n-        cx.fcx.llobjfields.insert(f.id, llfield);\n+        fcx.llobjfields.insert(f.id, llfield);\n         i += 1;\n     }\n \n-    ret res(bcx, C_nil());\n+    fcx.llallocas = bcx.llbb;\n }\n \n fn trans_fn(@crate_ctxt cx, &ast._fn f, ast.def_id fid,\n@@ -5419,25 +5478,31 @@ fn trans_fn(@crate_ctxt cx, &ast._fn f, ast.def_id fid,\n     create_llargs_for_fn_args(fcx, f.proto,\n                               ty_self, ret_ty_of_fn(ann),\n                               f.decl.inputs, ty_params);\n-    auto bcx = new_top_block_ctxt(fcx);\n \n-    copy_args_to_allocas(bcx, ty_self, f.decl.inputs,\n-                         arg_tys_of_fn(ann));\n+    copy_any_self_to_alloca(fcx, ty_self);\n \n     alt (fcx.llself) {\n         case (some[ValueRef](?llself)) {\n-            bcx = populate_fn_ctxt_from_llself(bcx, llself).bcx;\n+            populate_fn_ctxt_from_llself(fcx, llself);\n         }\n         case (_) {\n         }\n     }\n \n+    copy_args_to_allocas(fcx, f.decl.inputs, arg_tys_of_fn(ann));\n+\n+    auto bcx = new_top_block_ctxt(fcx);\n+    auto lltop = bcx.llbb;\n+\n     auto res = trans_block(bcx, f.body);\n     if (!is_terminated(res.bcx)) {\n         // FIXME: until LLVM has a unit type, we are moving around\n         // C_nil values rather than their void type.\n         res.bcx.build.RetVoid();\n     }\n+\n+    // Tie up the llallocas -> lltop edge.\n+    new_builder(fcx.llallocas).Br(lltop);\n }\n \n fn trans_vtbl(@crate_ctxt cx, TypeRef self_ty,\n@@ -5504,10 +5569,11 @@ fn trans_obj(@crate_ctxt cx, &ast._obj ob, ast.def_id oid,\n                               none[TypeRef], ret_ty_of_fn(ann),\n                               fn_args, ty_params);\n \n-    auto bcx = new_top_block_ctxt(fcx);\n-\n     let vec[ty.arg] arg_tys = arg_tys_of_fn(ann);\n-    copy_args_to_allocas(bcx, none[TypeRef], fn_args, arg_tys);\n+    copy_args_to_allocas(fcx, fn_args, arg_tys);\n+\n+    auto bcx = new_top_block_ctxt(fcx);\n+    auto lltop = bcx.llbb;\n \n     auto llself_ty = type_of(cx, ret_ty_of_fn(ann));\n     auto pair = bcx.fcx.llretptr;\n@@ -5604,6 +5670,9 @@ fn trans_obj(@crate_ctxt cx, &ast._obj ob, ast.def_id oid,\n         bcx.build.Store(p, pair_box);\n     }\n     bcx.build.RetVoid();\n+\n+    // Tie up the llallocas -> lltop edge.\n+    new_builder(fcx.llallocas).Br(lltop);\n }\n \n fn trans_tag_variant(@crate_ctxt cx, ast.def_id tag_id,\n@@ -5627,6 +5696,7 @@ fn trans_tag_variant(@crate_ctxt cx, ast.def_id tag_id,\n     let ValueRef llfndecl = cx.item_ids.get(variant.id);\n \n     auto fcx = new_fn_ctxt(cx, llfndecl);\n+\n     create_llargs_for_fn_args(fcx, ast.proto_fn,\n                               none[TypeRef], ret_ty_of_fn(variant.ann),\n                               fn_args, ty_params);\n@@ -5636,10 +5706,11 @@ fn trans_tag_variant(@crate_ctxt cx, ast.def_id tag_id,\n         ty_param_substs += vec(plain_ty(ty.ty_param(tp.id)));\n     }\n \n-    auto bcx = new_top_block_ctxt(fcx);\n-\n     auto arg_tys = arg_tys_of_fn(variant.ann);\n-    copy_args_to_allocas(bcx, none[TypeRef], fn_args, arg_tys);\n+    copy_args_to_allocas(fcx, fn_args, arg_tys);\n+\n+    auto bcx = new_top_block_ctxt(fcx);\n+    auto lltop = bcx.llbb;\n \n     // Cast the tag to a type we can GEP into.\n     auto lltagptr = bcx.build.PointerCast(fcx.llretptr,\n@@ -5682,6 +5753,9 @@ fn trans_tag_variant(@crate_ctxt cx, ast.def_id tag_id,\n \n     bcx = trans_block_cleanups(bcx, find_scope_cx(bcx));\n     bcx.build.RetVoid();\n+\n+    // Tie up the llallocas -> lltop edge.\n+    new_builder(fcx.llallocas).Br(lltop);\n }\n \n // FIXME: this should do some structural hash-consing to avoid\n@@ -5851,6 +5925,7 @@ fn decl_native_fn_and_pair(@crate_ctxt cx,\n     // Build the wrapper.\n     auto fcx = new_fn_ctxt(cx, wrapper_fn);\n     auto bcx = new_top_block_ctxt(fcx);\n+    auto lltop = bcx.llbb;\n \n     // Declare the function itself.\n     auto item = cx.native_items.get(id);\n@@ -5919,6 +5994,9 @@ fn decl_native_fn_and_pair(@crate_ctxt cx,\n \n     bcx.build.Store(r, rptr);\n     bcx.build.RetVoid();\n+\n+    // Tie up the llallocas -> lltop edge.\n+    new_builder(fcx.llallocas).Br(lltop);\n }\n \n fn collect_native_item(&@crate_ctxt cx, @ast.native_item i) -> @crate_ctxt {\n@@ -6471,10 +6549,14 @@ fn trans_vec_append_glue(@crate_ctxt cx) {\n     let ValueRef llsrc_vec = llvm.LLVMGetParam(llfn, 4u);\n     let ValueRef llskipnull = llvm.LLVMGetParam(llfn, 5u);\n \n+    let BasicBlockRef llallocas =\n+        llvm.LLVMAppendBasicBlock(llfn, _str.buf(\"allocas\"));\n+\n     auto fcx = @rec(llfn=llfn,\n                     lltaskptr=lltaskptr,\n                     llenv=C_null(T_ptr(T_nil())),\n                     llretptr=C_null(T_ptr(T_nil())),\n+                    mutable llallocas = llallocas,\n                     mutable llself=none[ValueRef],\n                     mutable lliterbody=none[ValueRef],\n                     llargs=new_def_hash[ValueRef](),\n@@ -6485,13 +6567,14 @@ fn trans_vec_append_glue(@crate_ctxt cx) {\n                     ccx=cx);\n \n     auto bcx = new_top_block_ctxt(fcx);\n+    auto lltop = bcx.llbb;\n \n     auto lldst_vec = bcx.build.Load(lldst_vec_ptr);\n \n     // First the dst vec needs to grow to accommodate the src vec.\n     // To do this we have to figure out how many bytes to add.\n \n-    auto llcopy_dst_ptr = bcx.build.Alloca(T_int());\n+    auto llcopy_dst_ptr = alloca(bcx, T_int());\n     auto llnew_vec_res =\n         trans_upcall(bcx, \"upcall_vec_grow\",\n                      vec(vp2i(bcx, lldst_vec),\n@@ -6508,7 +6591,7 @@ fn trans_vec_append_glue(@crate_ctxt cx) {\n     auto copy_dst_cx = new_sub_block_ctxt(bcx, \"copy new <- dst\");\n     auto copy_src_cx = new_sub_block_ctxt(bcx, \"copy new <- src\");\n \n-    auto pp0 = bcx.build.Alloca(T_ptr(T_i8()));\n+    auto pp0 = alloca(bcx, T_ptr(T_i8()));\n     bcx.build.Store(vec_p0(bcx, llnew_vec), pp0);\n \n     bcx.build.CondBr(bcx.build.TruncOrBitCast\n@@ -6576,6 +6659,9 @@ fn trans_vec_append_glue(@crate_ctxt cx) {\n     // Write new_vec back through the alias we were given.\n     copy_src_cx.build.Store(llnew_vec, lldst_vec_ptr);\n     copy_src_cx.build.RetVoid();\n+\n+    // Tie up the llallocas -> lltop edge.\n+    new_builder(fcx.llallocas).Br(lltop);\n }\n \n \n@@ -6640,7 +6726,6 @@ fn make_common_glue(str output) {\n     trans_exit_task_glue(glues, new_str_hash[ValueRef](), tn, llmod);\n \n     check_module(llmod);\n-\n     llvm.LLVMWriteBitcodeToFile(llmod, _str.buf(output));\n     llvm.LLVMDisposeModule(llmod);\n }"}, {"sha": "174fdcfaf3bbe9b63b9ba2021592c75de517ffda", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/540d29f6417c5008d987f874696670ebb3ef8d27/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/540d29f6417c5008d987f874696670ebb3ef8d27/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=540d29f6417c5008d987f874696670ebb3ef8d27", "patch": "@@ -48,8 +48,10 @@ auth front.creader.get_type = impure;\n auth front.creader.impure_no_op = impure;\n auth middle.metadata = unsafe;\n auth middle.trans = unsafe;\n+auth middle.trans.copy_any_self_to_alloca = impure;\n auth middle.trans.copy_args_to_allocas = impure;\n auth middle.trans.trans_block = impure;\n+auth middle.trans.alloc_ty = impure;\n auth lib.llvm = unsafe;\n auth pretty.pprust = impure;\n "}, {"sha": "f6f14f97794f042d0544f2893a22d7bb7b54517d", "filename": "src/test/bench/shootout/nbody.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/540d29f6417c5008d987f874696670ebb3ef8d27/src%2Ftest%2Fbench%2Fshootout%2Fnbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/540d29f6417c5008d987f874696670ebb3ef8d27/src%2Ftest%2Fbench%2Fshootout%2Fnbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout%2Fnbody.rs?ref=540d29f6417c5008d987f874696670ebb3ef8d27", "patch": "@@ -9,11 +9,14 @@ native \"llvm\" mod llvm {\n fn main() {\n \n     let vec[int] inputs = vec(\n-        50000\n-        //these segfault :(\n-        //500000,\n-        //5000000,\n-        //50000000\n+                              50000,\n+                              500000\n+                              //\n+                              // Leave these commented out to\n+                              // finish in a reasonable time\n+                              // during 'make check' under valgrind\n+                              // 5000000\n+                              // 50000000\n         );\n \n     let vec[Body.props] bodies = NBodySystem.MakeNBodySystem();"}]}