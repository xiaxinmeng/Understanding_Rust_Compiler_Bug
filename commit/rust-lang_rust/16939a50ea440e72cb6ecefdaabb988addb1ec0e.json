{"sha": "16939a50ea440e72cb6ecefdaabb988addb1ec0e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2OTM5YTUwZWE0NDBlNzJjYjZlY2VmZGFhYmI5ODhhZGRiMWVjMGU=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-05-01T23:09:29Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-05-01T23:09:29Z"}, "message": "Rollup merge of #60437 - davidtwco:issue-60236, r=nikomatsakis\n\nEnsure that drop order of `async fn` matches `fn` and that users cannot refer to generated arguments.\n\nFixes #60236 and fixes #60438.\n\nThis PR modifies the lowering of `async fn` arguments so that the\ndrop order matches the equivalent `fn`.\n\nPreviously, async function arguments were lowered as shown below:\n\n    async fn foo(<pattern>: <ty>) {\n      async move {\n      }\n    } // <-- dropped as you \"exit\" the fn\n\n    // ...becomes...\n    fn foo(__arg0: <ty>) {\n      async move {\n        let <pattern> = __arg0;\n      } // <-- dropped as you \"exit\" the async block\n    }\n\nAfter this PR, async function arguments will be lowered as:\n\n    async fn foo(<pattern>: <ty>, <pattern>: <ty>, <pattern>: <ty>) {\n      async move {\n      }\n    } // <-- dropped as you \"exit\" the fn\n\n    // ...becomes...\n    fn foo(__arg0: <ty>, __arg1: <ty>, __arg2: <ty>) {\n      async move {\n        let __arg2 = __arg2;\n        let <pattern> = __arg2;\n        let __arg1 = __arg1;\n        let <pattern> = __arg1;\n        let __arg0 = __arg0;\n        let <pattern> = __arg0;\n      } // <-- dropped as you \"exit\" the async block\n    }\n\nIf `<pattern>` is a simple ident, then it is lowered to a single\n`let <pattern> = <pattern>;` statement as an optimization.\n\nThis PR also stops users from referring to the generated `__argN`\nidentifiers.\n\nr? @nikomatsakis", "tree": {"sha": "e9b880050e2903aee0d12b7b7f4156772bdab0d3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e9b880050e2903aee0d12b7b7f4156772bdab0d3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/16939a50ea440e72cb6ecefdaabb988addb1ec0e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcyicpCRBK7hj4Ov3rIwAAdHIIADgbMdK2V7wAGHcCS5wvlAc9\n6wCiw0VTY9+zcjoAs++7yG3dZYFvdjjA19ru/9zP09B/ZpWJIsHX6XbQTa+2iMhj\nzYk73SidFS1C9j72elW92P5SJBxVxRpPzg3Jqz1xkql3cdoyFVvR1Jp2abQD1+lw\n9hclgCaEhuPLAzqNzHD5I5s4beDc2YUun2frX1KL/7tktepewIQ0rCC5Rt8XOLYu\niyX6G8YyZ8P1+rDWDGYECaPtQ8Fm7B+R1ZjkRS6bVywGpTvfFwiMmiNEzafrSajm\n7E6QwAkisja0Vofp0qe88Tbv/b3rdsIzuMyYYFEdDD98erDhVF+a/hHknEBE3A4=\n=unOd\n-----END PGP SIGNATURE-----\n", "payload": "tree e9b880050e2903aee0d12b7b7f4156772bdab0d3\nparent 12bf98155249783583a91863c5dccf9e346f1226\nparent 1fedb0a20bfe03e1bf7d5c2576806c761b4e3963\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1556752169 +0200\ncommitter GitHub <noreply@github.com> 1556752169 +0200\n\nRollup merge of #60437 - davidtwco:issue-60236, r=nikomatsakis\n\nEnsure that drop order of `async fn` matches `fn` and that users cannot refer to generated arguments.\n\nFixes #60236 and fixes #60438.\n\nThis PR modifies the lowering of `async fn` arguments so that the\ndrop order matches the equivalent `fn`.\n\nPreviously, async function arguments were lowered as shown below:\n\n    async fn foo(<pattern>: <ty>) {\n      async move {\n      }\n    } // <-- dropped as you \"exit\" the fn\n\n    // ...becomes...\n    fn foo(__arg0: <ty>) {\n      async move {\n        let <pattern> = __arg0;\n      } // <-- dropped as you \"exit\" the async block\n    }\n\nAfter this PR, async function arguments will be lowered as:\n\n    async fn foo(<pattern>: <ty>, <pattern>: <ty>, <pattern>: <ty>) {\n      async move {\n      }\n    } // <-- dropped as you \"exit\" the fn\n\n    // ...becomes...\n    fn foo(__arg0: <ty>, __arg1: <ty>, __arg2: <ty>) {\n      async move {\n        let __arg2 = __arg2;\n        let <pattern> = __arg2;\n        let __arg1 = __arg1;\n        let <pattern> = __arg1;\n        let __arg0 = __arg0;\n        let <pattern> = __arg0;\n      } // <-- dropped as you \"exit\" the async block\n    }\n\nIf `<pattern>` is a simple ident, then it is lowered to a single\n`let <pattern> = <pattern>;` statement as an optimization.\n\nThis PR also stops users from referring to the generated `__argN`\nidentifiers.\n\nr? @nikomatsakis\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/16939a50ea440e72cb6ecefdaabb988addb1ec0e", "html_url": "https://github.com/rust-lang/rust/commit/16939a50ea440e72cb6ecefdaabb988addb1ec0e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/16939a50ea440e72cb6ecefdaabb988addb1ec0e/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "12bf98155249783583a91863c5dccf9e346f1226", "url": "https://api.github.com/repos/rust-lang/rust/commits/12bf98155249783583a91863c5dccf9e346f1226", "html_url": "https://github.com/rust-lang/rust/commit/12bf98155249783583a91863c5dccf9e346f1226"}, {"sha": "1fedb0a20bfe03e1bf7d5c2576806c761b4e3963", "url": "https://api.github.com/repos/rust-lang/rust/commits/1fedb0a20bfe03e1bf7d5c2576806c761b4e3963", "html_url": "https://github.com/rust-lang/rust/commit/1fedb0a20bfe03e1bf7d5c2576806c761b4e3963"}], "stats": {"total": 737, "additions": 505, "deletions": 232}, "files": [{"sha": "6d57882976e11dbd3e37b5e0211dd3372f88f761", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 36, "deletions": 3, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/16939a50ea440e72cb6ecefdaabb988addb1ec0e/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16939a50ea440e72cb6ecefdaabb988addb1ec0e/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=16939a50ea440e72cb6ecefdaabb988addb1ec0e", "patch": "@@ -2996,8 +2996,33 @@ impl<'a> LoweringContext<'a> {\n             if let IsAsync::Async { closure_id, ref arguments, .. } = asyncness {\n                 let mut body = body.clone();\n \n+                // Async function arguments are lowered into the closure body so that they are\n+                // captured and so that the drop order matches the equivalent non-async functions.\n+                //\n+                //     async fn foo(<pattern>: <ty>, <pattern>: <ty>, <pattern>: <ty>) {\n+                //       async move {\n+                //       }\n+                //     }\n+                //\n+                //     // ...becomes...\n+                //     fn foo(__arg0: <ty>, __arg1: <ty>, __arg2: <ty>) {\n+                //       async move {\n+                //         let __arg2 = __arg2;\n+                //         let <pattern> = __arg2;\n+                //         let __arg1 = __arg1;\n+                //         let <pattern> = __arg1;\n+                //         let __arg0 = __arg0;\n+                //         let <pattern> = __arg0;\n+                //       }\n+                //     }\n+                //\n+                // If `<pattern>` is a simple ident, then it is lowered to a single\n+                // `let <pattern> = <pattern>;` statement as an optimization.\n                 for a in arguments.iter().rev() {\n-                    body.stmts.insert(0, a.stmt.clone());\n+                    if let Some(pat_stmt) = a.pat_stmt.clone() {\n+                        body.stmts.insert(0, pat_stmt);\n+                    }\n+                    body.stmts.insert(0, a.move_stmt.clone());\n                 }\n \n                 let async_expr = this.make_async_expr(\n@@ -3093,7 +3118,11 @@ impl<'a> LoweringContext<'a> {\n                         let mut decl = decl.clone();\n                         // Replace the arguments of this async function with the generated\n                         // arguments that will be moved into the closure.\n-                        decl.inputs = arguments.clone().drain(..).map(|a| a.arg).collect();\n+                        for (i, a) in arguments.clone().drain(..).enumerate() {\n+                            if let Some(arg) = a.arg {\n+                                decl.inputs[i] = arg;\n+                            }\n+                        }\n                         lower_fn(&decl)\n                     } else {\n                         lower_fn(decl)\n@@ -3590,7 +3619,11 @@ impl<'a> LoweringContext<'a> {\n                     let mut sig = sig.clone();\n                     // Replace the arguments of this async function with the generated\n                     // arguments that will be moved into the closure.\n-                    sig.decl.inputs = arguments.clone().drain(..).map(|a| a.arg).collect();\n+                    for (i, a) in arguments.clone().drain(..).enumerate() {\n+                        if let Some(arg) = a.arg {\n+                            sig.decl.inputs[i] = arg;\n+                        }\n+                    }\n                     lower_method(&sig)\n                 } else {\n                     lower_method(sig)"}, {"sha": "78de85398594efb747920b0816d3415aaae4a278", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/16939a50ea440e72cb6ecefdaabb988addb1ec0e/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16939a50ea440e72cb6ecefdaabb988addb1ec0e/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=16939a50ea440e72cb6ecefdaabb988addb1ec0e", "patch": "@@ -94,7 +94,9 @@ impl<'a> DefCollector<'a> {\n             // Walk the generated arguments for the `async fn`.\n             for a in arguments {\n                 use visit::Visitor;\n-                this.visit_ty(&a.arg.ty);\n+                if let Some(arg) = &a.arg {\n+                    this.visit_ty(&arg.ty);\n+                }\n             }\n \n             // We do not invoke `walk_fn_decl` as this will walk the arguments that are being\n@@ -105,10 +107,13 @@ impl<'a> DefCollector<'a> {\n                 *closure_id, DefPathData::ClosureExpr, REGULAR_SPACE, span,\n             );\n             this.with_parent(closure_def, |this| {\n+                use visit::Visitor;\n+                // Walk each of the generated statements before the regular block body.\n                 for a in arguments {\n-                    use visit::Visitor;\n-                    // Walk each of the generated statements before the regular block body.\n-                    this.visit_stmt(&a.stmt);\n+                    this.visit_stmt(&a.move_stmt);\n+                    if let Some(pat_stmt) = &a.pat_stmt {\n+                        this.visit_stmt(&pat_stmt);\n+                    }\n                 }\n \n                 visit::walk_block(this, &body);"}, {"sha": "8d5c1798e0fa4a5c0ef82d076419d45fb351795c", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/16939a50ea440e72cb6ecefdaabb988addb1ec0e/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16939a50ea440e72cb6ecefdaabb988addb1ec0e/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=16939a50ea440e72cb6ecefdaabb988addb1ec0e", "patch": "@@ -1334,14 +1334,19 @@ impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T>\n         if let ast::IsAsync::Async { ref arguments, .. } = header.asyncness.node {\n             for a in arguments {\n                 // Visit the argument..\n-                self.visit_pat(&a.arg.pat);\n-                if let ast::ArgSource::AsyncFn(pat) = &a.arg.source {\n-                    self.visit_pat(pat);\n+                if let Some(arg) = &a.arg {\n+                    self.visit_pat(&arg.pat);\n+                    if let ast::ArgSource::AsyncFn(pat) = &arg.source {\n+                        self.visit_pat(pat);\n+                    }\n+                    self.visit_ty(&arg.ty);\n                 }\n-                self.visit_ty(&a.arg.ty);\n \n                 // ..and the statement.\n-                self.visit_stmt(&a.stmt);\n+                self.visit_stmt(&a.move_stmt);\n+                if let Some(pat_stmt) = &a.pat_stmt {\n+                    self.visit_stmt(&pat_stmt);\n+                }\n             }\n         }\n     }"}, {"sha": "dcfe00069c5bd263b0497ce81dc0b562b36124ff", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 25, "deletions": 13, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/16939a50ea440e72cb6ecefdaabb988addb1ec0e/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16939a50ea440e72cb6ecefdaabb988addb1ec0e/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=16939a50ea440e72cb6ecefdaabb988addb1ec0e", "patch": "@@ -862,7 +862,13 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n         // Walk the generated async arguments if this is an `async fn`, otherwise walk the\n         // normal arguments.\n         if let IsAsync::Async { ref arguments, .. } = asyncness {\n-            for a in arguments { add_argument(&a.arg); }\n+            for (i, a) in arguments.iter().enumerate() {\n+                if let Some(arg) = &a.arg {\n+                    add_argument(&arg);\n+                } else {\n+                    add_argument(&declaration.inputs[i]);\n+                }\n+            }\n         } else {\n             for a in &declaration.inputs { add_argument(a); }\n         }\n@@ -882,8 +888,11 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n                     let mut body = body.clone();\n                     // Insert the generated statements into the body before attempting to\n                     // resolve names.\n-                    for a in arguments {\n-                        body.stmts.insert(0, a.stmt.clone());\n+                    for a in arguments.iter().rev() {\n+                        if let Some(pat_stmt) = a.pat_stmt.clone() {\n+                            body.stmts.insert(0, pat_stmt);\n+                        }\n+                        body.stmts.insert(0, a.move_stmt.clone());\n                     }\n                     self.visit_block(&body);\n                 } else {\n@@ -4174,7 +4183,7 @@ impl<'a> Resolver<'a> {\n         let add_module_candidates = |module: Module<'_>, names: &mut Vec<TypoSuggestion>| {\n             for (&(ident, _), resolution) in module.resolutions.borrow().iter() {\n                 if let Some(binding) = resolution.borrow().binding {\n-                    if filter_fn(binding.def()) {\n+                    if !ident.name.is_gensymed() && filter_fn(binding.def()) {\n                         names.push(TypoSuggestion {\n                             candidate: ident.name,\n                             article: binding.def().article(),\n@@ -4192,7 +4201,7 @@ impl<'a> Resolver<'a> {\n             for rib in self.ribs[ns].iter().rev() {\n                 // Locals and type parameters\n                 for (ident, def) in &rib.bindings {\n-                    if filter_fn(*def) {\n+                    if !ident.name.is_gensymed() && filter_fn(*def) {\n                         names.push(TypoSuggestion {\n                             candidate: ident.name,\n                             article: def.article(),\n@@ -4219,7 +4228,7 @@ impl<'a> Resolver<'a> {\n                                             index: CRATE_DEF_INDEX,\n                                         });\n \n-                                        if filter_fn(crate_mod) {\n+                                        if !ident.name.is_gensymed() && filter_fn(crate_mod) {\n                                             Some(TypoSuggestion {\n                                                 candidate: ident.name,\n                                                 article: \"a\",\n@@ -4242,13 +4251,16 @@ impl<'a> Resolver<'a> {\n             // Add primitive types to the mix\n             if filter_fn(Def::PrimTy(Bool)) {\n                 names.extend(\n-                    self.primitive_type_table.primitive_types.iter().map(|(name, _)| {\n-                        TypoSuggestion {\n-                            candidate: *name,\n-                            article: \"a\",\n-                            kind: \"primitive type\",\n-                        }\n-                    })\n+                    self.primitive_type_table.primitive_types\n+                        .iter()\n+                        .filter(|(name, _)| !name.is_gensymed())\n+                        .map(|(name, _)| {\n+                            TypoSuggestion {\n+                                candidate: *name,\n+                                article: \"a\",\n+                                kind: \"primitive type\",\n+                            }\n+                        })\n                 )\n             }\n         } else {"}, {"sha": "33b8c76bb531a2a6fc9219eb373bec20d0fad763", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/16939a50ea440e72cb6ecefdaabb988addb1ec0e/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16939a50ea440e72cb6ecefdaabb988addb1ec0e/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=16939a50ea440e72cb6ecefdaabb988addb1ec0e", "patch": "@@ -1865,10 +1865,14 @@ pub enum Unsafety {\n pub struct AsyncArgument {\n     /// `__arg0`\n     pub ident: Ident,\n-    /// `__arg0: <ty>` argument to replace existing function argument `<pat>: <ty>`.\n-    pub arg: Arg,\n-    /// `let <pat>: <ty> = __arg0;` statement to be inserted at the start of the block.\n-    pub stmt: Stmt,\n+    /// `__arg0: <ty>` argument to replace existing function argument `<pat>: <ty>`. Only if\n+    /// argument is not a simple binding.\n+    pub arg: Option<Arg>,\n+    /// `let __arg0 = __arg0;` statement to be inserted at the start of the block.\n+    pub move_stmt: Stmt,\n+    /// `let <pat> = __arg0;` statement to be inserted at the start of the block, after matching\n+    /// move statement. Only if argument is not a simple binding.\n+    pub pat_stmt: Option<Stmt>,\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]"}, {"sha": "f5e18e98436e6e1b222ca0eabca59fb3e3074afb", "filename": "src/libsyntax/ext/placeholders.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/16939a50ea440e72cb6ecefdaabb988addb1ec0e/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16939a50ea440e72cb6ecefdaabb988addb1ec0e/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fplaceholders.rs?ref=16939a50ea440e72cb6ecefdaabb988addb1ec0e", "patch": "@@ -199,7 +199,10 @@ impl<'a, 'b> MutVisitor for PlaceholderExpander<'a, 'b> {\n \n         if let ast::IsAsync::Async { ref mut arguments, .. } = a {\n             for argument in arguments.iter_mut() {\n-                self.next_id(&mut argument.stmt.id);\n+                self.next_id(&mut argument.move_stmt.id);\n+                if let Some(ref mut pat_stmt) = &mut argument.pat_stmt {\n+                    self.next_id(&mut pat_stmt.id);\n+                }\n             }\n         }\n     }"}, {"sha": "2e09235ca77b0a72bbcb1463778789e73e747164", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/16939a50ea440e72cb6ecefdaabb988addb1ec0e/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16939a50ea440e72cb6ecefdaabb988addb1ec0e/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=16939a50ea440e72cb6ecefdaabb988addb1ec0e", "patch": "@@ -694,13 +694,21 @@ pub fn noop_visit_asyncness<T: MutVisitor>(asyncness: &mut IsAsync, vis: &mut T)\n         IsAsync::Async { closure_id, return_impl_trait_id, ref mut arguments } => {\n             vis.visit_id(closure_id);\n             vis.visit_id(return_impl_trait_id);\n-            for AsyncArgument { ident, arg, stmt } in arguments.iter_mut() {\n+            for AsyncArgument { ident, arg, pat_stmt, move_stmt } in arguments.iter_mut() {\n                 vis.visit_ident(ident);\n-                vis.visit_arg(arg);\n-                visit_clobber(stmt, |stmt| {\n+                if let Some(arg) = arg {\n+                    vis.visit_arg(arg);\n+                }\n+                visit_clobber(move_stmt, |stmt| {\n                     vis.flat_map_stmt(stmt)\n                         .expect_one(\"expected visitor to produce exactly one item\")\n                 });\n+                visit_opt(pat_stmt, |stmt| {\n+                    visit_clobber(stmt, |stmt| {\n+                        vis.flat_map_stmt(stmt)\n+                            .expect_one(\"expected visitor to produce exactly one item\")\n+                    })\n+                });\n             }\n         }\n         IsAsync::NotAsync => {}"}, {"sha": "f70acb3e7da9a3cfc0a6eff34c4bf0725df494d1", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 49, "deletions": 15, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/16939a50ea440e72cb6ecefdaabb988addb1ec0e/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16939a50ea440e72cb6ecefdaabb988addb1ec0e/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=16939a50ea440e72cb6ecefdaabb988addb1ec0e", "patch": "@@ -8720,27 +8720,46 @@ impl<'a> Parser<'a> {\n \n                 // Construct a name for our temporary argument.\n                 let name = format!(\"__arg{}\", index);\n-                let ident = Ident::from_str(&name);\n+                let ident = Ident::from_str(&name).gensym();\n+\n+                // Check if this is a ident pattern, if so, we can optimize and avoid adding a\n+                // `let <pat> = __argN;` statement, instead just adding a `let <pat> = <pat>;`\n+                // statement.\n+                let (ident, is_simple_pattern) = match input.pat.node {\n+                    PatKind::Ident(_, ident, _) => (ident, true),\n+                    _ => (ident, false),\n+                };\n \n                 // Construct an argument representing `__argN: <ty>` to replace the argument of the\n-                // async function.\n-                let arg = Arg {\n-                    ty: input.ty.clone(),\n-                    id,\n+                // async function if it isn't a simple pattern.\n+                let arg = if is_simple_pattern {\n+                    None\n+                } else {\n+                    Some(Arg {\n+                        ty: input.ty.clone(),\n+                        id,\n+                        pat: P(Pat {\n+                            id,\n+                            node: PatKind::Ident(\n+                                BindingMode::ByValue(Mutability::Immutable), ident, None,\n+                            ),\n+                            span,\n+                        }),\n+                        source: ArgSource::AsyncFn(input.pat.clone()),\n+                    })\n+                };\n+\n+                // Construct a `let __argN = __argN;` statement to insert at the top of the\n+                // async closure. This makes sure that the argument is captured by the closure and\n+                // that the drop order is correct.\n+                let move_local = Local {\n                     pat: P(Pat {\n                         id,\n                         node: PatKind::Ident(\n                             BindingMode::ByValue(Mutability::Immutable), ident, None,\n                         ),\n                         span,\n                     }),\n-                    source: ArgSource::AsyncFn(input.pat.clone()),\n-                };\n-\n-                // Construct a `let <pat> = __argN;` statement to insert at the top of the\n-                // async closure.\n-                let local = P(Local {\n-                    pat: input.pat.clone(),\n                     // We explicitly do not specify the type for this statement. When the user's\n                     // argument type is `impl Trait` then this would require the\n                     // `impl_trait_in_bindings` feature to also be present for that same type to\n@@ -8760,10 +8779,25 @@ impl<'a> Parser<'a> {\n                     span,\n                     attrs: ThinVec::new(),\n                     source: LocalSource::AsyncFn,\n-                });\n-                let stmt = Stmt { id, node: StmtKind::Local(local), span, };\n+                };\n+\n+                // Construct a `let <pat> = __argN;` statement to insert at the top of the\n+                // async closure if this isn't a simple pattern.\n+                let pat_stmt = if is_simple_pattern {\n+                    None\n+                } else {\n+                    Some(Stmt {\n+                        id,\n+                        node: StmtKind::Local(P(Local {\n+                            pat: input.pat.clone(),\n+                            ..move_local.clone()\n+                        })),\n+                        span,\n+                    })\n+                };\n \n-                arguments.push(AsyncArgument { ident, arg, stmt });\n+                let move_stmt = Stmt { id, node: StmtKind::Local(P(move_local)), span };\n+                arguments.push(AsyncArgument { ident, arg, pat_stmt, move_stmt });\n             }\n         }\n     }"}, {"sha": "961c412f5ecb2751bf86551d087beb84becbf77a", "filename": "src/test/run-pass/issue-54716.rs", "status": "removed", "additions": 0, "deletions": 184, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/12bf98155249783583a91863c5dccf9e346f1226/src%2Ftest%2Frun-pass%2Fissue-54716.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12bf98155249783583a91863c5dccf9e346f1226/src%2Ftest%2Frun-pass%2Fissue-54716.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-54716.rs?ref=12bf98155249783583a91863c5dccf9e346f1226", "patch": "@@ -1,184 +0,0 @@\n-// aux-build:arc_wake.rs\n-// edition:2018\n-// run-pass\n-\n-#![allow(unused_variables)]\n-#![feature(async_await, await_macro)]\n-\n-extern crate arc_wake;\n-\n-use arc_wake::ArcWake;\n-use std::cell::RefCell;\n-use std::future::Future;\n-use std::marker::PhantomData;\n-use std::sync::Arc;\n-use std::rc::Rc;\n-use std::task::Context;\n-\n-struct EmptyWaker;\n-\n-impl ArcWake for EmptyWaker {\n-    fn wake(self: Arc<Self>) {}\n-}\n-\n-#[derive(Debug, Eq, PartialEq)]\n-enum DropOrder {\n-    Function,\n-    Val(&'static str),\n-}\n-\n-type DropOrderListPtr = Rc<RefCell<Vec<DropOrder>>>;\n-\n-struct D(&'static str, DropOrderListPtr);\n-\n-impl Drop for D {\n-    fn drop(&mut self) {\n-        self.1.borrow_mut().push(DropOrder::Val(self.0));\n-    }\n-}\n-\n-/// Check that unused bindings are dropped after the function is polled.\n-async fn foo(x: D, _y: D) {\n-    x.1.borrow_mut().push(DropOrder::Function);\n-}\n-\n-/// Check that underscore patterns are dropped after the function is polled.\n-async fn bar(x: D, _: D) {\n-    x.1.borrow_mut().push(DropOrder::Function);\n-}\n-\n-/// Check that underscore patterns within more complex patterns are dropped after the function\n-/// is polled.\n-async fn baz((x, _): (D, D)) {\n-    x.1.borrow_mut().push(DropOrder::Function);\n-}\n-\n-/// Check that underscore and unused bindings within and outwith more complex patterns are dropped\n-/// after the function is polled.\n-async fn foobar(x: D, (a, _, _c): (D, D, D), _: D, _y: D) {\n-    x.1.borrow_mut().push(DropOrder::Function);\n-}\n-\n-struct Foo;\n-\n-impl Foo {\n-    /// Check that unused bindings are dropped after the method is polled.\n-    async fn foo(x: D, _y: D) {\n-        x.1.borrow_mut().push(DropOrder::Function);\n-    }\n-\n-    /// Check that underscore patterns are dropped after the method is polled.\n-    async fn bar(x: D, _: D) {\n-        x.1.borrow_mut().push(DropOrder::Function);\n-    }\n-\n-    /// Check that underscore patterns within more complex patterns are dropped after the method\n-    /// is polled.\n-    async fn baz((x, _): (D, D)) {\n-        x.1.borrow_mut().push(DropOrder::Function);\n-    }\n-\n-    /// Check that underscore and unused bindings within and outwith more complex patterns are\n-    /// dropped after the method is polled.\n-    async fn foobar(x: D, (a, _, _c): (D, D, D), _: D, _y: D) {\n-        x.1.borrow_mut().push(DropOrder::Function);\n-    }\n-}\n-\n-struct Bar<'a>(PhantomData<&'a ()>);\n-\n-impl<'a> Bar<'a> {\n-    /// Check that unused bindings are dropped after the method with self is polled.\n-    async fn foo(&'a self, x: D, _y: D) {\n-        x.1.borrow_mut().push(DropOrder::Function);\n-    }\n-\n-    /// Check that underscore patterns are dropped after the method with self is polled.\n-    async fn bar(&'a self, x: D, _: D) {\n-        x.1.borrow_mut().push(DropOrder::Function);\n-    }\n-\n-    /// Check that underscore patterns within more complex patterns are dropped after the method\n-    /// with self is polled.\n-    async fn baz(&'a self, (x, _): (D, D)) {\n-        x.1.borrow_mut().push(DropOrder::Function);\n-    }\n-\n-    /// Check that underscore and unused bindings within and outwith more complex patterns are\n-    /// dropped after the method with self is polled.\n-    async fn foobar(&'a self, x: D, (a, _, _c): (D, D, D), _: D, _y: D) {\n-        x.1.borrow_mut().push(DropOrder::Function);\n-    }\n-}\n-\n-fn assert_drop_order_after_poll<Fut: Future<Output = ()>>(\n-    f: impl FnOnce(DropOrderListPtr) -> Fut,\n-    expected_order: &[DropOrder],\n-) {\n-    let empty = Arc::new(EmptyWaker);\n-    let waker = ArcWake::into_waker(empty);\n-    let mut cx = Context::from_waker(&waker);\n-\n-    let actual_order = Rc::new(RefCell::new(Vec::new()));\n-    let mut fut = Box::pin(f(actual_order.clone()));\n-    let _ = fut.as_mut().poll(&mut cx);\n-\n-    assert_eq!(*actual_order.borrow(), expected_order);\n-}\n-\n-fn main() {\n-    use DropOrder::*;\n-\n-    // At time of writing (23/04/19), the `bar` and `foobar` tests do not output the same order as\n-    // the equivalent non-async functions. This is because the drop order of captured variables\n-    // doesn't match the drop order of arguments in a function.\n-\n-    // Free functions (see doc comment on function for what it tests).\n-    assert_drop_order_after_poll(|l| foo(D(\"x\", l.clone()), D(\"_y\", l.clone())),\n-                                 &[Function, Val(\"_y\"), Val(\"x\")]);\n-    assert_drop_order_after_poll(|l| bar(D(\"x\", l.clone()), D(\"_\", l.clone())),\n-                                 &[Function, Val(\"x\"), Val(\"_\")]);\n-    assert_drop_order_after_poll(|l| baz((D(\"x\", l.clone()), D(\"_\", l.clone()))),\n-                                 &[Function, Val(\"x\"), Val(\"_\")]);\n-    assert_drop_order_after_poll(|l| {\n-        foobar(\n-            D(\"x\", l.clone()),\n-            (D(\"a\", l.clone()), D(\"_\", l.clone()), D(\"_c\", l.clone())),\n-            D(\"_\", l.clone()),\n-            D(\"_y\", l.clone()),\n-        )\n-    }, &[Function, Val(\"_y\"), Val(\"_c\"), Val(\"a\"), Val(\"x\"), Val(\"_\"), Val(\"_\")]);\n-\n-    // Methods w/out self (see doc comment on function for what it tests).\n-    assert_drop_order_after_poll(|l| Foo::foo(D(\"x\", l.clone()), D(\"_y\", l.clone())),\n-                                 &[Function, Val(\"_y\"), Val(\"x\")]);\n-    assert_drop_order_after_poll(|l| Foo::bar(D(\"x\", l.clone()), D(\"_\", l.clone())),\n-                                 &[Function, Val(\"x\"), Val(\"_\")]);\n-    assert_drop_order_after_poll(|l| Foo::baz((D(\"x\", l.clone()), D(\"_\", l.clone()))),\n-                                 &[Function, Val(\"x\"), Val(\"_\")]);\n-    assert_drop_order_after_poll(|l| {\n-        Foo::foobar(\n-            D(\"x\", l.clone()),\n-            (D(\"a\", l.clone()), D(\"_\", l.clone()), D(\"_c\", l.clone())),\n-            D(\"_\", l.clone()),\n-            D(\"_y\", l.clone()),\n-        )\n-    }, &[Function, Val(\"_y\"), Val(\"_c\"), Val(\"a\"), Val(\"x\"), Val(\"_\"), Val(\"_\")]);\n-\n-    // Methods (see doc comment on function for what it tests).\n-    let b = Bar(Default::default());\n-    assert_drop_order_after_poll(|l| b.foo(D(\"x\", l.clone()), D(\"_y\", l.clone())),\n-                                 &[Function, Val(\"_y\"), Val(\"x\")]);\n-    assert_drop_order_after_poll(|l| b.bar(D(\"x\", l.clone()), D(\"_\", l.clone())),\n-                                 &[Function, Val(\"x\"), Val(\"_\")]);\n-    assert_drop_order_after_poll(|l| b.baz((D(\"x\", l.clone()), D(\"_\", l.clone()))),\n-                                 &[Function, Val(\"x\"), Val(\"_\")]);\n-    assert_drop_order_after_poll(|l| {\n-        b.foobar(\n-            D(\"x\", l.clone()),\n-            (D(\"a\", l.clone()), D(\"_\", l.clone()), D(\"_c\", l.clone())),\n-            D(\"_\", l.clone()),\n-            D(\"_y\", l.clone()),\n-        )\n-    }, &[Function, Val(\"_y\"), Val(\"_c\"), Val(\"a\"), Val(\"x\"), Val(\"_\"), Val(\"_\")]);\n-}"}, {"sha": "c21886f26f467e2176460fc166f95d0d9ee3cc6c", "filename": "src/test/ui/async-await/auxiliary/arc_wake.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/16939a50ea440e72cb6ecefdaabb988addb1ec0e/src%2Ftest%2Fui%2Fasync-await%2Fauxiliary%2Farc_wake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16939a50ea440e72cb6ecefdaabb988addb1ec0e/src%2Ftest%2Fui%2Fasync-await%2Fauxiliary%2Farc_wake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fauxiliary%2Farc_wake.rs?ref=16939a50ea440e72cb6ecefdaabb988addb1ec0e", "patch": "@@ -0,0 +1,64 @@\n+// edition:2018\n+\n+use std::sync::Arc;\n+use std::task::{\n+    Waker, RawWaker, RawWakerVTable,\n+};\n+\n+macro_rules! waker_vtable {\n+    ($ty:ident) => {\n+        &RawWakerVTable::new(\n+            clone_arc_raw::<$ty>,\n+            wake_arc_raw::<$ty>,\n+            wake_by_ref_arc_raw::<$ty>,\n+            drop_arc_raw::<$ty>,\n+        )\n+    };\n+}\n+\n+pub trait ArcWake {\n+    fn wake(self: Arc<Self>);\n+\n+    fn wake_by_ref(arc_self: &Arc<Self>) {\n+        arc_self.clone().wake()\n+    }\n+\n+    fn into_waker(wake: Arc<Self>) -> Waker where Self: Sized\n+    {\n+        let ptr = Arc::into_raw(wake) as *const ();\n+\n+        unsafe {\n+            Waker::from_raw(RawWaker::new(ptr, waker_vtable!(Self)))\n+        }\n+    }\n+}\n+\n+unsafe fn increase_refcount<T: ArcWake>(data: *const ()) {\n+    // Retain Arc by creating a copy\n+    let arc: Arc<T> = Arc::from_raw(data as *const T);\n+    let arc_clone = arc.clone();\n+    // Forget the Arcs again, so that the refcount isn't decrased\n+    let _ = Arc::into_raw(arc);\n+    let _ = Arc::into_raw(arc_clone);\n+}\n+\n+unsafe fn clone_arc_raw<T: ArcWake>(data: *const ()) -> RawWaker {\n+    increase_refcount::<T>(data);\n+    RawWaker::new(data, waker_vtable!(T))\n+}\n+\n+unsafe fn drop_arc_raw<T: ArcWake>(data: *const ()) {\n+    // Drop Arc\n+    let _: Arc<T> = Arc::from_raw(data as *const T);\n+}\n+\n+unsafe fn wake_arc_raw<T: ArcWake>(data: *const ()) {\n+    let arc: Arc<T> = Arc::from_raw(data as *const T);\n+    ArcWake::wake(arc);\n+}\n+\n+unsafe fn wake_by_ref_arc_raw<T: ArcWake>(data: *const ()) {\n+    let arc: Arc<T> = Arc::from_raw(data as *const T);\n+    ArcWake::wake_by_ref(&arc);\n+    let _ = Arc::into_raw(arc);\n+}"}, {"sha": "708c570498460147de3cac9a1f6a884452d7966b", "filename": "src/test/ui/async-await/drop-order-for-async-fn-parameters.rs", "status": "added", "additions": 263, "deletions": 0, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/16939a50ea440e72cb6ecefdaabb988addb1ec0e/src%2Ftest%2Fui%2Fasync-await%2Fdrop-order-for-async-fn-parameters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16939a50ea440e72cb6ecefdaabb988addb1ec0e/src%2Ftest%2Fui%2Fasync-await%2Fdrop-order-for-async-fn-parameters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fdrop-order-for-async-fn-parameters.rs?ref=16939a50ea440e72cb6ecefdaabb988addb1ec0e", "patch": "@@ -0,0 +1,263 @@\n+// aux-build:arc_wake.rs\n+// edition:2018\n+// run-pass\n+\n+#![allow(unused_variables)]\n+#![feature(async_await, await_macro)]\n+\n+// Test that the drop order for parameters in a fn and async fn matches up. Also test that\n+// parameters (used or unused) are not dropped until the async fn completes execution.\n+// See also #54716.\n+\n+extern crate arc_wake;\n+\n+use arc_wake::ArcWake;\n+use std::cell::RefCell;\n+use std::future::Future;\n+use std::marker::PhantomData;\n+use std::sync::Arc;\n+use std::rc::Rc;\n+use std::task::Context;\n+\n+struct EmptyWaker;\n+\n+impl ArcWake for EmptyWaker {\n+    fn wake(self: Arc<Self>) {}\n+}\n+\n+#[derive(Debug, Eq, PartialEq)]\n+enum DropOrder {\n+    Function,\n+    Val(&'static str),\n+}\n+\n+type DropOrderListPtr = Rc<RefCell<Vec<DropOrder>>>;\n+\n+struct D(&'static str, DropOrderListPtr);\n+\n+impl Drop for D {\n+    fn drop(&mut self) {\n+        self.1.borrow_mut().push(DropOrder::Val(self.0));\n+    }\n+}\n+\n+/// Check that unused bindings are dropped after the function is polled.\n+async fn foo_async(x: D, _y: D) {\n+    x.1.borrow_mut().push(DropOrder::Function);\n+}\n+\n+fn foo_sync(x: D, _y: D) {\n+    x.1.borrow_mut().push(DropOrder::Function);\n+}\n+\n+/// Check that underscore patterns are dropped after the function is polled.\n+async fn bar_async(x: D, _: D) {\n+    x.1.borrow_mut().push(DropOrder::Function);\n+}\n+\n+fn bar_sync(x: D, _: D) {\n+    x.1.borrow_mut().push(DropOrder::Function);\n+}\n+\n+/// Check that underscore patterns within more complex patterns are dropped after the function\n+/// is polled.\n+async fn baz_async((x, _): (D, D)) {\n+    x.1.borrow_mut().push(DropOrder::Function);\n+}\n+\n+fn baz_sync((x, _): (D, D)) {\n+    x.1.borrow_mut().push(DropOrder::Function);\n+}\n+\n+/// Check that underscore and unused bindings within and outwith more complex patterns are dropped\n+/// after the function is polled.\n+async fn foobar_async(x: D, (a, _, _c): (D, D, D), _: D, _y: D) {\n+    x.1.borrow_mut().push(DropOrder::Function);\n+}\n+\n+fn foobar_sync(x: D, (a, _, _c): (D, D, D), _: D, _y: D) {\n+    x.1.borrow_mut().push(DropOrder::Function);\n+}\n+\n+struct Foo;\n+\n+impl Foo {\n+    /// Check that unused bindings are dropped after the method is polled.\n+    async fn foo_async(x: D, _y: D) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+    }\n+\n+    fn foo_sync(x: D, _y: D) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+    }\n+\n+    /// Check that underscore patterns are dropped after the method is polled.\n+    async fn bar_async(x: D, _: D) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+    }\n+\n+    fn bar_sync(x: D, _: D) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+    }\n+\n+    /// Check that underscore patterns within more complex patterns are dropped after the method\n+    /// is polled.\n+    async fn baz_async((x, _): (D, D)) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+    }\n+\n+    fn baz_sync((x, _): (D, D)) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+    }\n+\n+    /// Check that underscore and unused bindings within and outwith more complex patterns are\n+    /// dropped after the method is polled.\n+    async fn foobar_async(x: D, (a, _, _c): (D, D, D), _: D, _y: D) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+    }\n+\n+    fn foobar_sync(x: D, (a, _, _c): (D, D, D), _: D, _y: D) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+    }\n+}\n+\n+struct Bar<'a>(PhantomData<&'a ()>);\n+\n+impl<'a> Bar<'a> {\n+    /// Check that unused bindings are dropped after the method with self is polled.\n+    async fn foo_async(&'a self, x: D, _y: D) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+    }\n+\n+    fn foo_sync(&'a self, x: D, _y: D) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+    }\n+\n+    /// Check that underscore patterns are dropped after the method with self is polled.\n+    async fn bar_async(&'a self, x: D, _: D) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+    }\n+\n+    fn bar_sync(&'a self, x: D, _: D) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+    }\n+\n+    /// Check that underscore patterns within more complex patterns are dropped after the method\n+    /// with self is polled.\n+    async fn baz_async(&'a self, (x, _): (D, D)) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+    }\n+\n+    fn baz_sync(&'a self, (x, _): (D, D)) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+    }\n+\n+    /// Check that underscore and unused bindings within and outwith more complex patterns are\n+    /// dropped after the method with self is polled.\n+    async fn foobar_async(&'a self, x: D, (a, _, _c): (D, D, D), _: D, _y: D) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+    }\n+\n+    fn foobar_sync(&'a self, x: D, (a, _, _c): (D, D, D), _: D, _y: D) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+    }\n+}\n+\n+fn assert_drop_order_after_poll<Fut: Future<Output = ()>>(\n+    f: impl FnOnce(DropOrderListPtr) -> Fut,\n+    g: impl FnOnce(DropOrderListPtr),\n+) {\n+    let empty = Arc::new(EmptyWaker);\n+    let waker = ArcWake::into_waker(empty);\n+    let mut cx = Context::from_waker(&waker);\n+\n+    let actual_order = Rc::new(RefCell::new(Vec::new()));\n+    let mut fut = Box::pin(f(actual_order.clone()));\n+    let _ = fut.as_mut().poll(&mut cx);\n+\n+    let expected_order = Rc::new(RefCell::new(Vec::new()));\n+    g(expected_order.clone());\n+\n+    assert_eq!(*actual_order.borrow(), *expected_order.borrow());\n+}\n+\n+fn main() {\n+    // Free functions (see doc comment on function for what it tests).\n+    assert_drop_order_after_poll(|l| foo_async(D(\"x\", l.clone()), D(\"_y\", l.clone())),\n+                                 |l| foo_sync(D(\"x\", l.clone()), D(\"_y\", l.clone())));\n+    assert_drop_order_after_poll(|l| bar_async(D(\"x\", l.clone()), D(\"_\", l.clone())),\n+                                 |l| bar_sync(D(\"x\", l.clone()), D(\"_\", l.clone())));\n+    assert_drop_order_after_poll(|l| baz_async((D(\"x\", l.clone()), D(\"_\", l.clone()))),\n+                                 |l| baz_sync((D(\"x\", l.clone()), D(\"_\", l.clone()))));\n+    assert_drop_order_after_poll(\n+        |l| {\n+            foobar_async(\n+                D(\"x\", l.clone()),\n+                (D(\"a\", l.clone()), D(\"_\", l.clone()), D(\"_c\", l.clone())),\n+                D(\"_\", l.clone()),\n+                D(\"_y\", l.clone()),\n+            )\n+        },\n+        |l| {\n+            foobar_sync(\n+                D(\"x\", l.clone()),\n+                (D(\"a\", l.clone()), D(\"_\", l.clone()), D(\"_c\", l.clone())),\n+                D(\"_\", l.clone()),\n+                D(\"_y\", l.clone()),\n+            )\n+        },\n+    );\n+\n+    // Methods w/out self (see doc comment on function for what it tests).\n+    assert_drop_order_after_poll(|l| Foo::foo_async(D(\"x\", l.clone()), D(\"_y\", l.clone())),\n+                                 |l| Foo::foo_sync(D(\"x\", l.clone()), D(\"_y\", l.clone())));\n+    assert_drop_order_after_poll(|l| Foo::bar_async(D(\"x\", l.clone()), D(\"_\", l.clone())),\n+                                 |l| Foo::bar_sync(D(\"x\", l.clone()), D(\"_\", l.clone())));\n+    assert_drop_order_after_poll(|l| Foo::baz_async((D(\"x\", l.clone()), D(\"_\", l.clone()))),\n+                                 |l| Foo::baz_sync((D(\"x\", l.clone()), D(\"_\", l.clone()))));\n+    assert_drop_order_after_poll(\n+        |l| {\n+            Foo::foobar_async(\n+                D(\"x\", l.clone()),\n+                (D(\"a\", l.clone()), D(\"_\", l.clone()), D(\"_c\", l.clone())),\n+                D(\"_\", l.clone()),\n+                D(\"_y\", l.clone()),\n+            )\n+        },\n+        |l| {\n+            Foo::foobar_sync(\n+                D(\"x\", l.clone()),\n+                (D(\"a\", l.clone()), D(\"_\", l.clone()), D(\"_c\", l.clone())),\n+                D(\"_\", l.clone()),\n+                D(\"_y\", l.clone()),\n+            )\n+        },\n+    );\n+\n+    // Methods (see doc comment on function for what it tests).\n+    let b = Bar(Default::default());\n+    assert_drop_order_after_poll(|l| b.foo_async(D(\"x\", l.clone()), D(\"_y\", l.clone())),\n+                                 |l| b.foo_sync(D(\"x\", l.clone()), D(\"_y\", l.clone())));\n+    assert_drop_order_after_poll(|l| b.bar_async(D(\"x\", l.clone()), D(\"_\", l.clone())),\n+                                 |l| b.bar_sync(D(\"x\", l.clone()), D(\"_\", l.clone())));\n+    assert_drop_order_after_poll(|l| b.baz_async((D(\"x\", l.clone()), D(\"_\", l.clone()))),\n+                                 |l| b.baz_sync((D(\"x\", l.clone()), D(\"_\", l.clone()))));\n+    assert_drop_order_after_poll(\n+        |l| {\n+            b.foobar_async(\n+                D(\"x\", l.clone()),\n+                (D(\"a\", l.clone()), D(\"_\", l.clone()), D(\"_c\", l.clone())),\n+                D(\"_\", l.clone()),\n+                D(\"_y\", l.clone()),\n+            )\n+        },\n+        |l| {\n+            b.foobar_sync(\n+                D(\"x\", l.clone()),\n+                (D(\"a\", l.clone()), D(\"_\", l.clone()), D(\"_c\", l.clone())),\n+                D(\"_\", l.clone()),\n+                D(\"_y\", l.clone()),\n+            )\n+        },\n+    );\n+}"}, {"sha": "10dc5e27f6f9f26763d31fd723d64cc16a20a4fe", "filename": "src/test/ui/async-await/drop-order-locals-are-hidden.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/16939a50ea440e72cb6ecefdaabb988addb1ec0e/src%2Ftest%2Fui%2Fasync-await%2Fdrop-order-locals-are-hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16939a50ea440e72cb6ecefdaabb988addb1ec0e/src%2Ftest%2Fui%2Fasync-await%2Fdrop-order-locals-are-hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fdrop-order-locals-are-hidden.rs?ref=16939a50ea440e72cb6ecefdaabb988addb1ec0e", "patch": "@@ -0,0 +1,11 @@\n+// edition:2018\n+\n+#![allow(unused_variables)]\n+#![feature(async_await)]\n+\n+async fn foobar_async(x: u32, (a, _, _c): (u32, u32, u32), _: u32, _y: u32) {\n+    assert_eq!(__arg1, (1, 2, 3)); //~ ERROR cannot find value `__arg1` in this scope [E0425]\n+    assert_eq!(__arg2, 4); //~ ERROR cannot find value `__arg2` in this scope [E0425]\n+}\n+\n+fn main() {}"}, {"sha": "ca0da6b7c962add94c48989232011b95477ca0b0", "filename": "src/test/ui/async-await/drop-order-locals-are-hidden.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/16939a50ea440e72cb6ecefdaabb988addb1ec0e/src%2Ftest%2Fui%2Fasync-await%2Fdrop-order-locals-are-hidden.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/16939a50ea440e72cb6ecefdaabb988addb1ec0e/src%2Ftest%2Fui%2Fasync-await%2Fdrop-order-locals-are-hidden.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fdrop-order-locals-are-hidden.stderr?ref=16939a50ea440e72cb6ecefdaabb988addb1ec0e", "patch": "@@ -0,0 +1,15 @@\n+error[E0425]: cannot find value `__arg1` in this scope\n+  --> $DIR/drop-order-locals-are-hidden.rs:7:16\n+   |\n+LL |     assert_eq!(__arg1, (1, 2, 3));\n+   |                ^^^^^^ not found in this scope\n+\n+error[E0425]: cannot find value `__arg2` in this scope\n+  --> $DIR/drop-order-locals-are-hidden.rs:8:16\n+   |\n+LL |     assert_eq!(__arg2, 4);\n+   |                ^^^^^^ not found in this scope\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0425`."}]}