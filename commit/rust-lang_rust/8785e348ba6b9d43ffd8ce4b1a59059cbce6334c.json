{"sha": "8785e348ba6b9d43ffd8ce4b1a59059cbce6334c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3ODVlMzQ4YmE2YjlkNDNmZmQ4Y2U0YjFhNTkwNTljYmNlNjMzNGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-27T14:44:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-27T14:44:13Z"}, "message": "Auto merge of #53580 - nikomatsakis:nll-issue-53568, r=pnkfelix\n\nfix NLL ICEs\n\nCustom type-ops reuse some of the query machinery -- but while query results are canonicalized after they are constructed, custom type ops are not, and hence we have to resolve the type variables to avoid an ICE here.\n\nAlso, use the type-op machinery for implied outlives bounds.\n\nFixes #53568\nFixes #52992\nFixes #53680", "tree": {"sha": "6f7716d4a72b185c9b8c28bebf7b4f354a79428b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f7716d4a72b185c9b8c28bebf7b4f354a79428b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8785e348ba6b9d43ffd8ce4b1a59059cbce6334c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8785e348ba6b9d43ffd8ce4b1a59059cbce6334c", "html_url": "https://github.com/rust-lang/rust/commit/8785e348ba6b9d43ffd8ce4b1a59059cbce6334c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8785e348ba6b9d43ffd8ce4b1a59059cbce6334c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b638d8c75f4e38c75c5caa52b10b18a350431687", "url": "https://api.github.com/repos/rust-lang/rust/commits/b638d8c75f4e38c75c5caa52b10b18a350431687", "html_url": "https://github.com/rust-lang/rust/commit/b638d8c75f4e38c75c5caa52b10b18a350431687"}, {"sha": "a59584a6ff381ad701e80723db743ed0771ddad8", "url": "https://api.github.com/repos/rust-lang/rust/commits/a59584a6ff381ad701e80723db743ed0771ddad8", "html_url": "https://github.com/rust-lang/rust/commit/a59584a6ff381ad701e80723db743ed0771ddad8"}], "stats": {"total": 238, "additions": 211, "deletions": 27}, "files": [{"sha": "65d42c0888d5d85ce08056353b4054498fcdc4a5", "filename": "src/librustc/infer/canonical/query_result.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8785e348ba6b9d43ffd8ce4b1a59059cbce6334c/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8785e348ba6b9d43ffd8ce4b1a59059cbce6334c/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_result.rs?ref=8785e348ba6b9d43ffd8ce4b1a59059cbce6334c", "patch": "@@ -24,19 +24,18 @@ use infer::canonical::{\n };\n use infer::region_constraints::{Constraint, RegionConstraintData};\n use infer::InferCtxtBuilder;\n-use infer::{InferCtxt, InferOk, InferResult, RegionObligation};\n+use infer::{InferCtxt, InferOk, InferResult};\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::sync::Lrc;\n use std::fmt::Debug;\n-use syntax::ast;\n use syntax_pos::DUMMY_SP;\n use traits::query::{Fallible, NoSolution};\n use traits::{FulfillmentContext, TraitEngine};\n use traits::{Obligation, ObligationCause, PredicateObligation};\n use ty::fold::TypeFoldable;\n use ty::subst::{Kind, UnpackedKind};\n-use ty::{self, CanonicalVar, Lift, TyCtxt};\n+use ty::{self, CanonicalVar, Lift, Ty, TyCtxt};\n \n impl<'cx, 'gcx, 'tcx> InferCtxtBuilder<'cx, 'gcx, 'tcx> {\n     /// The \"main method\" for a canonicalized trait query. Given the\n@@ -157,7 +156,12 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n \n         let region_obligations = self.take_registered_region_obligations();\n         let region_constraints = self.with_region_constraints(|region_constraints| {\n-            make_query_outlives(tcx, region_obligations, region_constraints)\n+            make_query_outlives(\n+                tcx,\n+                region_obligations\n+                    .iter()\n+                    .map(|(_, r_o)| (r_o.sup_type, r_o.sub_region)),\n+                region_constraints)\n         });\n \n         let certainty = if ambig_errors.is_empty() {\n@@ -567,7 +571,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n /// creates query region constraints.\n pub fn make_query_outlives<'tcx>(\n     tcx: TyCtxt<'_, '_, 'tcx>,\n-    region_obligations: Vec<(ast::NodeId, RegionObligation<'tcx>)>,\n+    outlives_obligations: impl Iterator<Item = (Ty<'tcx>, ty::Region<'tcx>)>,\n     region_constraints: &RegionConstraintData<'tcx>,\n ) -> Vec<QueryRegionConstraint<'tcx>> {\n     let RegionConstraintData {\n@@ -600,9 +604,8 @@ pub fn make_query_outlives<'tcx>(\n             .collect();\n \n     outlives.extend(\n-        region_obligations\n-            .into_iter()\n-            .map(|(_, r_o)| ty::OutlivesPredicate(r_o.sup_type.into(), r_o.sub_region))\n+        outlives_obligations\n+            .map(|(ty, r)| ty::OutlivesPredicate(ty.into(), r))\n             .map(ty::Binder::dummy), // no bound regions in the code above\n     );\n "}, {"sha": "6a5ef75a660ba454027c9b9c8749039e6cd7d944", "filename": "src/librustc/traits/query/type_op/custom.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8785e348ba6b9d43ffd8ce4b1a59059cbce6334c/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8785e348ba6b9d43ffd8ce4b1a59059cbce6334c/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs?ref=8785e348ba6b9d43ffd8ce4b1a59059cbce6334c", "patch": "@@ -102,8 +102,14 @@ fn scrape_region_constraints<'gcx, 'tcx, R>(\n \n     let region_constraint_data = infcx.take_and_reset_region_constraints();\n \n-    let outlives =\n-        query_result::make_query_outlives(infcx.tcx, region_obligations, &region_constraint_data);\n+    let outlives = query_result::make_query_outlives(\n+        infcx.tcx,\n+        region_obligations\n+            .iter()\n+            .map(|(_, r_o)| (r_o.sup_type, r_o.sub_region))\n+            .map(|(ty, r)| (infcx.resolve_type_vars_if_possible(&ty), r)),\n+        &region_constraint_data,\n+    );\n \n     if outlives.is_empty() {\n         Ok((value, None))"}, {"sha": "27534bc8c3cf70242d8fe09b67a1589dd377168e", "filename": "src/librustc/traits/query/type_op/implied_outlives_bounds.rs", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/8785e348ba6b9d43ffd8ce4b1a59059cbce6334c/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8785e348ba6b9d43ffd8ce4b1a59059cbce6334c/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs?ref=8785e348ba6b9d43ffd8ce4b1a59059cbce6334c", "patch": "@@ -0,0 +1,80 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use infer::canonical::{Canonical, Canonicalized, CanonicalizedQueryResult, QueryResult};\n+use traits::query::outlives_bounds::OutlivesBound;\n+use traits::query::Fallible;\n+use ty::{ParamEnvAnd, Ty, TyCtxt};\n+\n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+pub struct ImpliedOutlivesBounds<'tcx> {\n+    pub ty: Ty<'tcx>,\n+}\n+\n+impl<'tcx> ImpliedOutlivesBounds<'tcx> {\n+    pub fn new(ty: Ty<'tcx>) -> Self {\n+        ImpliedOutlivesBounds { ty }\n+    }\n+}\n+\n+impl<'gcx: 'tcx, 'tcx> super::QueryTypeOp<'gcx, 'tcx> for ImpliedOutlivesBounds<'tcx> {\n+    type QueryResult = Vec<OutlivesBound<'tcx>>;\n+\n+    fn try_fast_path(\n+        _tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        _key: &ParamEnvAnd<'tcx, Self>,\n+    ) -> Option<Self::QueryResult> {\n+        None\n+    }\n+\n+    fn perform_query(\n+        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Self>>,\n+    ) -> Fallible<CanonicalizedQueryResult<'gcx, Self::QueryResult>> {\n+        // FIXME the query should take a `ImpliedOutlivesBounds`\n+        let Canonical {\n+            variables,\n+            value:\n+                ParamEnvAnd {\n+                    param_env,\n+                    value: ImpliedOutlivesBounds { ty },\n+                },\n+        } = canonicalized;\n+        let canonicalized = Canonical {\n+            variables,\n+            value: param_env.and(ty),\n+        };\n+\n+        tcx.implied_outlives_bounds(canonicalized)\n+    }\n+\n+    fn shrink_to_tcx_lifetime(\n+        v: &'a CanonicalizedQueryResult<'gcx, Self::QueryResult>,\n+    ) -> &'a Canonical<'tcx, QueryResult<'tcx, Self::QueryResult>> {\n+        v\n+    }\n+}\n+\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for ImpliedOutlivesBounds<'tcx> {\n+        ty,\n+    }\n+}\n+\n+BraceStructLiftImpl! {\n+    impl<'a, 'tcx> Lift<'tcx> for ImpliedOutlivesBounds<'a> {\n+        type Lifted = ImpliedOutlivesBounds<'tcx>;\n+        ty,\n+    }\n+}\n+\n+impl_stable_hash_for! {\n+    struct ImpliedOutlivesBounds<'tcx> { ty }\n+}"}, {"sha": "8e4236d1754c2d820109f3a0128b13e77481ca65", "filename": "src/librustc/traits/query/type_op/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8785e348ba6b9d43ffd8ce4b1a59059cbce6334c/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8785e348ba6b9d43ffd8ce4b1a59059cbce6334c/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs?ref=8785e348ba6b9d43ffd8ce4b1a59059cbce6334c", "patch": "@@ -21,6 +21,7 @@ use ty::{Lift, ParamEnvAnd, TyCtxt};\n \n pub mod custom;\n pub mod eq;\n+pub mod implied_outlives_bounds;\n pub mod normalize;\n pub mod outlives;\n pub mod prove_predicate;"}, {"sha": "e21c490622c089638b71eab8e2d63abb14ce4744", "filename": "src/librustc_mir/borrow_check/nll/type_check/free_region_relations.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/8785e348ba6b9d43ffd8ce4b1a59059cbce6334c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8785e348ba6b9d43ffd8ce4b1a59059cbce6334c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ffree_region_relations.rs?ref=8785e348ba6b9d43ffd8ce4b1a59059cbce6334c", "patch": "@@ -14,7 +14,7 @@ use borrow_check::nll::type_check::constraint_conversion;\n use borrow_check::nll::type_check::{Locations, MirTypeckRegionConstraints};\n use borrow_check::nll::universal_regions::UniversalRegions;\n use borrow_check::nll::ToRegionVid;\n-use rustc::hir::def_id::DefId;\n+use rustc::infer::canonical::QueryRegionConstraint;\n use rustc::infer::outlives::free_region_map::FreeRegionRelations;\n use rustc::infer::region_constraints::GenericKind;\n use rustc::infer::InferCtxt;\n@@ -23,7 +23,6 @@ use rustc::traits::query::type_op::{self, TypeOp};\n use rustc::ty::{self, RegionVid, Ty};\n use rustc_data_structures::transitive_relation::TransitiveRelation;\n use std::rc::Rc;\n-use syntax::ast;\n \n #[derive(Debug)]\n crate struct UniversalRegionRelations<'tcx> {\n@@ -67,19 +66,15 @@ crate struct CreateResult<'tcx> {\n \n crate fn create(\n     infcx: &InferCtxt<'_, '_, 'tcx>,\n-    mir_def_id: DefId,\n     param_env: ty::ParamEnv<'tcx>,\n     location_table: &LocationTable,\n     implicit_region_bound: Option<ty::Region<'tcx>>,\n     universal_regions: &Rc<UniversalRegions<'tcx>>,\n     constraints: &mut MirTypeckRegionConstraints<'tcx>,\n     all_facts: &mut Option<AllFacts>,\n ) -> CreateResult<'tcx> {\n-    let mir_node_id = infcx.tcx.hir.as_local_node_id(mir_def_id).unwrap();\n     UniversalRegionRelationsBuilder {\n         infcx,\n-        mir_def_id,\n-        mir_node_id,\n         param_env,\n         implicit_region_bound,\n         constraints,\n@@ -212,8 +207,6 @@ impl UniversalRegionRelations<'tcx> {\n \n struct UniversalRegionRelationsBuilder<'this, 'gcx: 'tcx, 'tcx: 'this> {\n     infcx: &'this InferCtxt<'this, 'gcx, 'tcx>,\n-    mir_def_id: DefId,\n-    mir_node_id: ast::NodeId,\n     param_env: ty::ParamEnv<'tcx>,\n     location_table: &'this LocationTable,\n     universal_regions: Rc<UniversalRegions<'tcx>>,\n@@ -248,14 +241,16 @@ impl UniversalRegionRelationsBuilder<'cx, 'gcx, 'tcx> {\n         let constraint_sets: Vec<_> = unnormalized_input_output_tys\n             .flat_map(|ty| {\n                 debug!(\"build: input_or_output={:?}\", ty);\n-                let (ty, constraints) = self\n+                let (ty, constraints1) = self\n                     .param_env\n                     .and(type_op::normalize::Normalize::new(ty))\n                     .fully_perform(self.infcx)\n                     .unwrap_or_else(|_| bug!(\"failed to normalize {:?}\", ty));\n-                self.add_implied_bounds(ty);\n+                let constraints2 = self.add_implied_bounds(ty);\n                 normalized_inputs_and_output.push(ty);\n-                constraints\n+                constraints1\n+                    .into_iter()\n+                    .chain(constraints2)\n             })\n             .collect();\n \n@@ -306,13 +301,15 @@ impl UniversalRegionRelationsBuilder<'cx, 'gcx, 'tcx> {\n     /// either the return type of the MIR or one of its arguments. At\n     /// the same time, compute and add any implied bounds that come\n     /// from this local.\n-    fn add_implied_bounds(&mut self, ty: Ty<'tcx>) {\n+    fn add_implied_bounds(&mut self, ty: Ty<'tcx>) -> Option<Rc<Vec<QueryRegionConstraint<'tcx>>>> {\n         debug!(\"add_implied_bounds(ty={:?})\", ty);\n-        let span = self.infcx.tcx.def_span(self.mir_def_id);\n-        let bounds = self\n-            .infcx\n-            .implied_outlives_bounds(self.param_env, self.mir_node_id, ty, span);\n+        let (bounds, constraints) =\n+            self.param_env\n+            .and(type_op::implied_outlives_bounds::ImpliedOutlivesBounds { ty })\n+            .fully_perform(self.infcx)\n+            .unwrap_or_else(|_| bug!(\"failed to compute implied bounds {:?}\", ty));\n         self.add_outlives_bounds(bounds);\n+        constraints\n     }\n \n     /// Registers the `OutlivesBound` items from `outlives_bounds` in"}, {"sha": "27417466c68c809ad4bd6b5c4ae91a6b7451e6c3", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8785e348ba6b9d43ffd8ce4b1a59059cbce6334c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8785e348ba6b9d43ffd8ce4b1a59059cbce6334c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=8785e348ba6b9d43ffd8ce4b1a59059cbce6334c", "patch": "@@ -135,7 +135,6 @@ pub(crate) fn type_check<'gcx, 'tcx>(\n         normalized_inputs_and_output,\n     } = free_region_relations::create(\n         infcx,\n-        mir_def_id,\n         param_env,\n         location_table,\n         Some(implicit_region_bound),"}, {"sha": "2ece0ee9feeaf942b926b10dfeb0480db8f5c818", "filename": "src/test/ui/issue-52992.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8785e348ba6b9d43ffd8ce4b1a59059cbce6334c/src%2Ftest%2Fui%2Fissue-52992.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8785e348ba6b9d43ffd8ce4b1a59059cbce6334c/src%2Ftest%2Fui%2Fissue-52992.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-52992.rs?ref=8785e348ba6b9d43ffd8ce4b1a59059cbce6334c", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for an NLL-related ICE (#52992) -- computing\n+// implied bounds was causing outlives relations that were not\n+// properly handled.\n+//\n+// compile-pass\n+\n+#![feature(nll)]\n+\n+fn main() {}\n+\n+fn fail<'a>() -> Struct<'a, Generic<()>> {\n+    Struct(&Generic(()))\n+}\n+\n+struct Struct<'a, T>(&'a T) where\n+    T: Trait + 'a,\n+    T::AT: 'a; // only fails with this bound\n+\n+struct Generic<T>(T);\n+\n+trait Trait {\n+    type AT;\n+}\n+\n+impl<T> Trait for Generic<T> {\n+    type AT = T; // only fails with a generic AT\n+}"}, {"sha": "6b479f7517244d7de62da6b28e86cc79220e4962", "filename": "src/test/ui/issue-53568.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/8785e348ba6b9d43ffd8ce4b1a59059cbce6334c/src%2Ftest%2Fui%2Fissue-53568.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8785e348ba6b9d43ffd8ce4b1a59059cbce6334c/src%2Ftest%2Fui%2Fissue-53568.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-53568.rs?ref=8785e348ba6b9d43ffd8ce4b1a59059cbce6334c", "patch": "@@ -0,0 +1,61 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for an NLL-related ICE (#53568) -- we failed to\n+// resolve inference variables in \"custom type-ops\".\n+//\n+// compile-pass\n+\n+#![feature(nll)]\n+#![allow(dead_code)]\n+\n+trait Future {\n+    type Item;\n+}\n+\n+impl<F, T> Future for F\n+where F: Fn() -> T\n+{\n+    type Item = T;\n+}\n+\n+trait Connect {}\n+\n+struct Connector<H> {\n+    handler: H,\n+}\n+\n+impl<H, T> Connect for Connector<H>\n+where\n+    T: 'static,\n+    H: Future<Item = T>\n+{\n+}\n+\n+struct Client<C> {\n+    connector: C,\n+}\n+\n+fn build<C>(_connector: C) -> Client<C> {\n+    unimplemented!()\n+}\n+\n+fn client<H>(handler: H) -> Client<impl Connect>\n+where H: Fn() + Copy\n+{\n+    let connector = Connector {\n+        handler,\n+    };\n+    let client = build(connector);\n+    client\n+}\n+\n+fn main() { }\n+"}]}