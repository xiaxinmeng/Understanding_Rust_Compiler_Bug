{"sha": "abf0548b5caaa389a5b29813132d2cf4c8b0f1ed", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiZjA1NDhiNWNhYWEzODlhNWIyOTgxMzEzMmQyY2Y0YzhiMGYxZWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-15T23:09:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-15T23:09:02Z"}, "message": "Auto merge of #24481 - steveklabnik:rollup, r=steveklabnik\n\n- Successful merges: #24425, #24435, #24438, #24440, #24449, #24457, #24460, #24465, #24467, #24468, #24471, #24476, #24480\n- Failed merges:", "tree": {"sha": "cd34c53e5dcbf9329333642a91d41b5cfda07e26", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cd34c53e5dcbf9329333642a91d41b5cfda07e26"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/abf0548b5caaa389a5b29813132d2cf4c8b0f1ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/abf0548b5caaa389a5b29813132d2cf4c8b0f1ed", "html_url": "https://github.com/rust-lang/rust/commit/abf0548b5caaa389a5b29813132d2cf4c8b0f1ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/abf0548b5caaa389a5b29813132d2cf4c8b0f1ed/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "07f807d01f191ced1d7f4857c73fc57fbe31f421", "url": "https://api.github.com/repos/rust-lang/rust/commits/07f807d01f191ced1d7f4857c73fc57fbe31f421", "html_url": "https://github.com/rust-lang/rust/commit/07f807d01f191ced1d7f4857c73fc57fbe31f421"}, {"sha": "7644ef8c2b165eb7ca247a212ad988401881a734", "url": "https://api.github.com/repos/rust-lang/rust/commits/7644ef8c2b165eb7ca247a212ad988401881a734", "html_url": "https://github.com/rust-lang/rust/commit/7644ef8c2b165eb7ca247a212ad988401881a734"}], "stats": {"total": 610, "additions": 327, "deletions": 283}, "files": [{"sha": "5a437e959b7fb74f1213a4427251ff46a5c8f8cc", "filename": "src/doc/index.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/abf0548b5caaa389a5b29813132d2cf4c8b0f1ed/src%2Fdoc%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/abf0548b5caaa389a5b29813132d2cf4c8b0f1ed/src%2Fdoc%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Findex.md?ref=abf0548b5caaa389a5b29813132d2cf4c8b0f1ed", "patch": "@@ -19,7 +19,7 @@ ideas behind Rust.\n donated to the Rust project. As the name implies, it teaches you Rust through a\n series of small examples.\n \n-[rbe]: rustbyexample.com\n+[rbe]: http://rustbyexample.com/\n \n # Community & Getting Help\n "}, {"sha": "2c5e6b2e5fc7c1af042149bd6452ed34aed3eb0a", "filename": "src/doc/trpl/ffi.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/abf0548b5caaa389a5b29813132d2cf4c8b0f1ed/src%2Fdoc%2Ftrpl%2Fffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/abf0548b5caaa389a5b29813132d2cf4c8b0f1ed/src%2Fdoc%2Ftrpl%2Fffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fffi.md?ref=abf0548b5caaa389a5b29813132d2cf4c8b0f1ed", "patch": "@@ -166,7 +166,7 @@ pub fn uncompress(src: &[u8]) -> Option<Vec<u8>> {\n }\n ```\n \n-For reference, the examples used here are also available as an [library on\n+For reference, the examples used here are also available as a [library on\n GitHub](https://github.com/thestinger/rust-snappy).\n \n # Destructors"}, {"sha": "e58bac656d0c54fdba492181f1b3ef3dd48b1f7f", "filename": "src/doc/trpl/hello-world.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/abf0548b5caaa389a5b29813132d2cf4c8b0f1ed/src%2Fdoc%2Ftrpl%2Fhello-world.md", "raw_url": "https://github.com/rust-lang/rust/raw/abf0548b5caaa389a5b29813132d2cf4c8b0f1ed/src%2Fdoc%2Ftrpl%2Fhello-world.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fhello-world.md?ref=abf0548b5caaa389a5b29813132d2cf4c8b0f1ed", "patch": "@@ -104,10 +104,10 @@ We\u2019ll get to the details eventually, you\u2019ll just have to trust us for now.\n \n Next, `\"Hello, world!\"` is a \u2018string\u2019. Strings are a surprisingly complicated\n topic in a systems programming language, and this is a \u2018statically allocated\u2019\n-string. If you want to read further about allocation, check out [the stack and\n-the heap], but you don\u2019t need to right now if you don\u2019t want to. We pass this\n-string as an argument to `println!`, which prints the string to the screen.\n-Easy enough!\n+string. If you want to read further about allocation, check out\n+[the stack and the heap][allocation], but you don\u2019t need to right now if you\n+don\u2019t want to. We pass this string as an argument to `println!`, which prints the\n+string to the screen. Easy enough!\n \n [allocation]: the-stack-and-the-heap.html\n "}, {"sha": "09b4495ffe990956666923737dc70cc9b082aff3", "filename": "src/doc/trpl/installing-rust.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/abf0548b5caaa389a5b29813132d2cf4c8b0f1ed/src%2Fdoc%2Ftrpl%2Finstalling-rust.md", "raw_url": "https://github.com/rust-lang/rust/raw/abf0548b5caaa389a5b29813132d2cf4c8b0f1ed/src%2Fdoc%2Ftrpl%2Finstalling-rust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Finstalling-rust.md?ref=abf0548b5caaa389a5b29813132d2cf4c8b0f1ed", "patch": "@@ -90,8 +90,8 @@ If not, there are a number of places where you can get help. The easiest is\n [the #rust IRC channel on irc.mozilla.org][irc], which you can access through\n [Mibbit][mibbit]. Click that link, and you'll be chatting with other Rustaceans\n (a silly nickname we call ourselves), and we can help you out. Other great\n-resources include [the user\u2019s forum][users], and [Stack Overflow][stack\n-overflow].\n+resources include [the user\u2019s forum][users], and\n+[Stack Overflow][stack overflow].\n \n [irc]: irc://irc.mozilla.org/#rust\n [mibbit]: http://chat.mibbit.com/?server=irc.mozilla.org&channel=%23rust"}, {"sha": "67db919c59f45a0f9cdf6b0ed9c872ceb3e5f13f", "filename": "src/doc/trpl/no-stdlib.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/abf0548b5caaa389a5b29813132d2cf4c8b0f1ed/src%2Fdoc%2Ftrpl%2Fno-stdlib.md", "raw_url": "https://github.com/rust-lang/rust/raw/abf0548b5caaa389a5b29813132d2cf4c8b0f1ed/src%2Fdoc%2Ftrpl%2Fno-stdlib.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fno-stdlib.md?ref=abf0548b5caaa389a5b29813132d2cf4c8b0f1ed", "patch": "@@ -103,7 +103,7 @@ necessary functionality for writing idiomatic and effective Rust code.\n As an example, here is a program that will calculate the dot product of two\n vectors provided from C, using idiomatic Rust practices.\n \n-```\n+```ignore\n #![feature(lang_items, start, no_std, core, libc)]\n #![no_std]\n "}, {"sha": "0cfdcd2413fd9f8b57bdee9ecb6006b3e050b62b", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/abf0548b5caaa389a5b29813132d2cf4c8b0f1ed/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf0548b5caaa389a5b29813132d2cf4c8b0f1ed/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=abf0548b5caaa389a5b29813132d2cf4c8b0f1ed", "patch": "@@ -274,7 +274,7 @@ pub fn get_mut<T>(this: &mut Arc<T>) -> Option<&mut T> {\n         // reference to the inner data.\n         let inner = unsafe { &mut **this._ptr };\n         Some(&mut inner.data)\n-    }else {\n+    } else {\n         None\n     }\n }"}, {"sha": "e44b0d1147cbcb86d5ec18877e9b2059442606b1", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/abf0548b5caaa389a5b29813132d2cf4c8b0f1ed/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf0548b5caaa389a5b29813132d2cf4c8b0f1ed/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=abf0548b5caaa389a5b29813132d2cf4c8b0f1ed", "patch": "@@ -273,8 +273,9 @@ pub trait Iterator {\n         FilterMap { iter: self, f: f }\n     }\n \n-    /// Creates an iterator that yields a pair of the value returned by this\n-    /// iterator plus the current index of iteration.\n+    /// Creates an iterator that yields pairs `(i, val)` where `i` is the\n+    /// current index of iteration and `val` is the value returned by the\n+    /// iterator.\n     ///\n     /// `enumerate` keeps its count as a `usize`. If you want to count by a\n     /// different sized integer, the `zip` function provides similar\n@@ -1129,7 +1130,7 @@ pub trait FromIterator<A> {\n /// Conversion into an `Iterator`\n ///\n /// Implementing this trait allows you to use your type with Rust's `for` loop. See\n-/// the [module level documentation](../index.html) for more details.\n+/// the [module level documentation](index.html) for more details.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait IntoIterator {\n     /// The type of the elements being iterated"}, {"sha": "0e9570df09d55cf19ac0495e0d670f93cb5aadea", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/abf0548b5caaa389a5b29813132d2cf4c8b0f1ed/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf0548b5caaa389a5b29813132d2cf4c8b0f1ed/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=abf0548b5caaa389a5b29813132d2cf4c8b0f1ed", "patch": "@@ -15,9 +15,9 @@\n //! Working with unsafe pointers in Rust is uncommon,\n //! typically limited to a few patterns.\n //!\n-//! Use the [`null` function](fn.null.html) to create null pointers, and\n-//! the `is_null` method of the `*const T` type  to check for null.\n-//! The `*const T` type also defines the `offset` method, for pointer math.\n+//! Use the `null` function to create null pointers, and the `is_null` method\n+//! of the `*const T` type  to check for null. The `*const T` type also defines\n+//! the `offset` method, for pointer math.\n //!\n //! # Common ways to create unsafe pointers\n //!"}, {"sha": "4a77f80d3b8466dee1c99920b89f386cc2f5c7f4", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/abf0548b5caaa389a5b29813132d2cf4c8b0f1ed/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf0548b5caaa389a5b29813132d2cf4c8b0f1ed/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=abf0548b5caaa389a5b29813132d2cf4c8b0f1ed", "patch": "@@ -129,7 +129,7 @@\n //! > Dear rustc,\n //! >\n //! > When you are attempting to load the immediate dependency `crate-name`, I\n-//! > would like you too assume that the library is located at\n+//! > would like you to assume that the library is located at\n //! > `path/to/the/crate.rlib`, and look nowhere else. Also, please do not\n //! > assume that the path I specified has the name `crate-name`.\n //!"}, {"sha": "04513e9d048bedfd5ec312119a9941c051fc780c", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/abf0548b5caaa389a5b29813132d2cf4c8b0f1ed/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf0548b5caaa389a5b29813132d2cf4c8b0f1ed/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=abf0548b5caaa389a5b29813132d2cf4c8b0f1ed", "patch": "@@ -172,7 +172,7 @@ impl CString {\n     ///\n     /// This method is equivalent to `new` except that no runtime assertion\n     /// is made that `v` contains no 0 bytes, and it requires an actual\n-    /// byte vector, not anyhting that can be converted to one with Into.\n+    /// byte vector, not anything that can be converted to one with Into.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub unsafe fn from_vec_unchecked(mut v: Vec<u8>) -> CString {\n         v.push(0);"}, {"sha": "d30d44a04d336c9091da04f50fd0dc580afb44e5", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/abf0548b5caaa389a5b29813132d2cf4c8b0f1ed/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf0548b5caaa389a5b29813132d2cf4c8b0f1ed/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=abf0548b5caaa389a5b29813132d2cf4c8b0f1ed", "patch": "@@ -1099,8 +1099,8 @@ impl PathExt for Path {\n /// Changes the timestamps for a file's last modification and access time.\n ///\n /// The file at the path specified will have its last access time set to\n-/// `atime` and its modification time set to `mtime`. The times specified should\n-/// be in milliseconds.\n+/// `accessed` and its modification time set to `modified`. The times specified\n+/// should be in milliseconds.\n #[unstable(feature = \"fs_time\",\n            reason = \"the argument type of u64 is not quite appropriate for \\\n                      this function and may change if the standard library \\"}, {"sha": "93c6deac6e59ae39ae0506b12658930fd373ba57", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/abf0548b5caaa389a5b29813132d2cf4c8b0f1ed/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf0548b5caaa389a5b29813132d2cf4c8b0f1ed/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=abf0548b5caaa389a5b29813132d2cf4c8b0f1ed", "patch": "@@ -148,7 +148,7 @@ pub trait Read {\n     ///\n     /// If the return value of this method is `Ok(n)`, then it must be\n     /// guaranteed that `0 <= n <= buf.len()`. A nonzero `n` value indicates\n-    /// that the buffer `buf` has ben filled in with `n` bytes of data from this\n+    /// that the buffer `buf` has been filled in with `n` bytes of data from this\n     /// source. If `n` is `0`, then it can indicate one of two scenarios:\n     ///\n     /// 1. This reader has reached its \"end of file\" and will likely no longer"}, {"sha": "2e34e46726fb27b84240ce2d3b10d983856137c2", "filename": "src/libstd/net/addr.rs", "status": "modified", "additions": 1, "deletions": 258, "changes": 259, "blob_url": "https://github.com/rust-lang/rust/blob/abf0548b5caaa389a5b29813132d2cf4c8b0f1ed/src%2Flibstd%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf0548b5caaa389a5b29813132d2cf4c8b0f1ed/src%2Flibstd%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Faddr.rs?ref=abf0548b5caaa389a5b29813132d2cf4c8b0f1ed", "patch": "@@ -461,264 +461,7 @@ mod tests {\n     use io;\n     use net::*;\n     use net::Ipv6MulticastScope::*;\n-\n-    #[test]\n-    fn test_from_str_ipv4() {\n-        assert_eq!(Ok(Ipv4Addr::new(127, 0, 0, 1)), \"127.0.0.1\".parse());\n-        assert_eq!(Ok(Ipv4Addr::new(255, 255, 255, 255)), \"255.255.255.255\".parse());\n-        assert_eq!(Ok(Ipv4Addr::new(0, 0, 0, 0)), \"0.0.0.0\".parse());\n-\n-        // out of range\n-        let none: Option<Ipv4Addr> = \"256.0.0.1\".parse().ok();\n-        assert_eq!(None, none);\n-        // too short\n-        let none: Option<Ipv4Addr> = \"255.0.0\".parse().ok();\n-        assert_eq!(None, none);\n-        // too long\n-        let none: Option<Ipv4Addr> = \"255.0.0.1.2\".parse().ok();\n-        assert_eq!(None, none);\n-        // no number between dots\n-        let none: Option<Ipv4Addr> = \"255.0..1\".parse().ok();\n-        assert_eq!(None, none);\n-    }\n-\n-    #[test]\n-    fn test_from_str_ipv6() {\n-        assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0)), \"0:0:0:0:0:0:0:0\".parse());\n-        assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1)), \"0:0:0:0:0:0:0:1\".parse());\n-\n-        assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1)), \"::1\".parse());\n-        assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0)), \"::\".parse());\n-\n-        assert_eq!(Ok(Ipv6Addr::new(0x2a02, 0x6b8, 0, 0, 0, 0, 0x11, 0x11)),\n-                \"2a02:6b8::11:11\".parse());\n-\n-        // too long group\n-        let none: Option<Ipv6Addr> = \"::00000\".parse().ok();\n-        assert_eq!(None, none);\n-        // too short\n-        let none: Option<Ipv6Addr> = \"1:2:3:4:5:6:7\".parse().ok();\n-        assert_eq!(None, none);\n-        // too long\n-        let none: Option<Ipv6Addr> = \"1:2:3:4:5:6:7:8:9\".parse().ok();\n-        assert_eq!(None, none);\n-        // triple colon\n-        let none: Option<Ipv6Addr> = \"1:2:::6:7:8\".parse().ok();\n-        assert_eq!(None, none);\n-        // two double colons\n-        let none: Option<Ipv6Addr> = \"1:2::6::8\".parse().ok();\n-        assert_eq!(None, none);\n-    }\n-\n-    #[test]\n-    fn test_from_str_ipv4_in_ipv6() {\n-        assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 49152, 545)),\n-                \"::192.0.2.33\".parse());\n-        assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0xFFFF, 49152, 545)),\n-                \"::FFFF:192.0.2.33\".parse());\n-        assert_eq!(Ok(Ipv6Addr::new(0x64, 0xff9b, 0, 0, 0, 0, 49152, 545)),\n-                \"64:ff9b::192.0.2.33\".parse());\n-        assert_eq!(Ok(Ipv6Addr::new(0x2001, 0xdb8, 0x122, 0xc000, 0x2, 0x2100, 49152, 545)),\n-                \"2001:db8:122:c000:2:2100:192.0.2.33\".parse());\n-\n-        // colon after v4\n-        let none: Option<Ipv4Addr> = \"::127.0.0.1:\".parse().ok();\n-        assert_eq!(None, none);\n-        // not enough groups\n-        let none: Option<Ipv6Addr> = \"1.2.3.4.5:127.0.0.1\".parse().ok();\n-        assert_eq!(None, none);\n-        // too many groups\n-        let none: Option<Ipv6Addr> = \"1.2.3.4.5:6:7:127.0.0.1\".parse().ok();\n-        assert_eq!(None, none);\n-    }\n-\n-    #[test]\n-    fn test_from_str_socket_addr() {\n-        assert_eq!(Ok(sa4(Ipv4Addr::new(77, 88, 21, 11), 80)),\n-                   \"77.88.21.11:80\".parse());\n-        assert_eq!(Ok(sa6(Ipv6Addr::new(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), 53)),\n-                   \"[2a02:6b8:0:1::1]:53\".parse());\n-        assert_eq!(Ok(sa6(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0x7F00, 1), 22)),\n-                   \"[::127.0.0.1]:22\".parse());\n-\n-        // without port\n-        let none: Option<SocketAddr> = \"127.0.0.1\".parse().ok();\n-        assert_eq!(None, none);\n-        // without port\n-        let none: Option<SocketAddr> = \"127.0.0.1:\".parse().ok();\n-        assert_eq!(None, none);\n-        // wrong brackets around v4\n-        let none: Option<SocketAddr> = \"[127.0.0.1]:22\".parse().ok();\n-        assert_eq!(None, none);\n-        // port out of range\n-        let none: Option<SocketAddr> = \"127.0.0.1:123456\".parse().ok();\n-        assert_eq!(None, none);\n-    }\n-\n-    #[test]\n-    fn ipv6_addr_to_string() {\n-        // ipv4-mapped address\n-        let a1 = Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc000, 0x280);\n-        assert_eq!(a1.to_string(), \"::ffff:192.0.2.128\");\n-\n-        // ipv4-compatible address\n-        let a1 = Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0xc000, 0x280);\n-        assert_eq!(a1.to_string(), \"::192.0.2.128\");\n-\n-        // v6 address with no zero segments\n-        assert_eq!(Ipv6Addr::new(8, 9, 10, 11, 12, 13, 14, 15).to_string(),\n-                   \"8:9:a:b:c:d:e:f\");\n-\n-        // reduce a single run of zeros\n-        assert_eq!(\"ae::ffff:102:304\",\n-                   Ipv6Addr::new(0xae, 0, 0, 0, 0, 0xffff, 0x0102, 0x0304).to_string());\n-\n-        // don't reduce just a single zero segment\n-        assert_eq!(\"1:2:3:4:5:6:0:8\",\n-                   Ipv6Addr::new(1, 2, 3, 4, 5, 6, 0, 8).to_string());\n-\n-        // 'any' address\n-        assert_eq!(\"::\", Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0).to_string());\n-\n-        // loopback address\n-        assert_eq!(\"::1\", Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1).to_string());\n-\n-        // ends in zeros\n-        assert_eq!(\"1::\", Ipv6Addr::new(1, 0, 0, 0, 0, 0, 0, 0).to_string());\n-\n-        // two runs of zeros, second one is longer\n-        assert_eq!(\"1:0:0:4::8\", Ipv6Addr::new(1, 0, 0, 4, 0, 0, 0, 8).to_string());\n-\n-        // two runs of zeros, equal length\n-        assert_eq!(\"1::4:5:0:0:8\", Ipv6Addr::new(1, 0, 0, 4, 5, 0, 0, 8).to_string());\n-    }\n-\n-    #[test]\n-    fn ipv4_to_ipv6() {\n-        assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0x1234, 0x5678),\n-                   Ipv4Addr::new(0x12, 0x34, 0x56, 0x78).to_ipv6_mapped());\n-        assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0x1234, 0x5678),\n-                   Ipv4Addr::new(0x12, 0x34, 0x56, 0x78).to_ipv6_compatible());\n-    }\n-\n-    #[test]\n-    fn ipv6_to_ipv4() {\n-        assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0x1234, 0x5678).to_ipv4(),\n-                   Some(Ipv4Addr::new(0x12, 0x34, 0x56, 0x78)));\n-        assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0x1234, 0x5678).to_ipv4(),\n-                   Some(Ipv4Addr::new(0x12, 0x34, 0x56, 0x78)));\n-        assert_eq!(Ipv6Addr::new(0, 0, 1, 0, 0, 0, 0x1234, 0x5678).to_ipv4(),\n-                   None);\n-    }\n-\n-    #[test]\n-    fn ipv4_properties() {\n-        fn check(octets: &[u8; 4], unspec: bool, loopback: bool,\n-                 private: bool, link_local: bool, global: bool,\n-                 multicast: bool, broadcast: bool, documentation: bool) {\n-            let ip = Ipv4Addr::new(octets[0], octets[1], octets[2], octets[3]);\n-            assert_eq!(octets, &ip.octets());\n-\n-            assert_eq!(ip.is_unspecified(), unspec);\n-            assert_eq!(ip.is_loopback(), loopback);\n-            assert_eq!(ip.is_private(), private);\n-            assert_eq!(ip.is_link_local(), link_local);\n-            assert_eq!(ip.is_global(), global);\n-            assert_eq!(ip.is_multicast(), multicast);\n-            assert_eq!(ip.is_broadcast(), broadcast);\n-            assert_eq!(ip.is_documentation(), documentation);\n-        }\n-\n-        //    address                unspec loopbk privt  linloc global multicast brdcast doc\n-        check(&[0, 0, 0, 0],         true,  false, false, false, true,  false,    false,  false);\n-        check(&[0, 0, 0, 1],         false, false, false, false, true,  false,    false,  false);\n-        check(&[1, 0, 0, 0],         false, false, false, false, true,  false,    false,  false);\n-        check(&[10, 9, 8, 7],        false, false, true,  false, false, false,    false,  false);\n-        check(&[127, 1, 2, 3],       false, true,  false, false, false, false,    false,  false);\n-        check(&[172, 31, 254, 253],  false, false, true,  false, false, false,    false,  false);\n-        check(&[169, 254, 253, 242], false, false, false, true,  false, false,    false,  false);\n-        check(&[192, 168, 254, 253], false, false, true,  false, false, false,    false,  false);\n-        check(&[224, 0, 0, 0],       false, false, false, false, true,  true,     false,  false);\n-        check(&[239, 255, 255, 255], false, false, false, false, true,  true,     false,  false);\n-        check(&[255, 255, 255, 255], false, false, false, false, false, false,    true,  false);\n-        check(&[198, 51, 100, 0],    false, false, false, false, false, false,    false,  true);\n-    }\n-\n-    #[test]\n-    fn ipv6_properties() {\n-        fn check(str_addr: &str, unspec: bool, loopback: bool,\n-                 unique_local: bool, global: bool,\n-                 u_link_local: bool, u_site_local: bool, u_global: bool,\n-                 m_scope: Option<Ipv6MulticastScope>) {\n-            let ip: Ipv6Addr = str_addr.parse().unwrap();\n-            assert_eq!(str_addr, ip.to_string());\n-\n-            assert_eq!(ip.is_unspecified(), unspec);\n-            assert_eq!(ip.is_loopback(), loopback);\n-            assert_eq!(ip.is_unique_local(), unique_local);\n-            assert_eq!(ip.is_global(), global);\n-            assert_eq!(ip.is_unicast_link_local(), u_link_local);\n-            assert_eq!(ip.is_unicast_site_local(), u_site_local);\n-            assert_eq!(ip.is_unicast_global(), u_global);\n-            assert_eq!(ip.multicast_scope(), m_scope);\n-            assert_eq!(ip.is_multicast(), m_scope.is_some());\n-        }\n-\n-        //    unspec loopbk uniqlo global unill  unisl  uniglo mscope\n-        check(\"::\",\n-              true,  false, false, true,  false, false, true,  None);\n-        check(\"::1\",\n-              false, true,  false, false, false, false, false, None);\n-        check(\"::0.0.0.2\",\n-              false, false, false, true,  false, false, true,  None);\n-        check(\"1::\",\n-              false, false, false, true,  false, false, true,  None);\n-        check(\"fc00::\",\n-              false, false, true,  false, false, false, false, None);\n-        check(\"fdff:ffff::\",\n-              false, false, true,  false, false, false, false, None);\n-        check(\"fe80:ffff::\",\n-              false, false, false, false, true,  false, false, None);\n-        check(\"febf:ffff::\",\n-              false, false, false, false, true,  false, false, None);\n-        check(\"fec0::\",\n-              false, false, false, false, false, true,  false, None);\n-        check(\"ff01::\",\n-              false, false, false, false, false, false, false, Some(InterfaceLocal));\n-        check(\"ff02::\",\n-              false, false, false, false, false, false, false, Some(LinkLocal));\n-        check(\"ff03::\",\n-              false, false, false, false, false, false, false, Some(RealmLocal));\n-        check(\"ff04::\",\n-              false, false, false, false, false, false, false, Some(AdminLocal));\n-        check(\"ff05::\",\n-              false, false, false, false, false, false, false, Some(SiteLocal));\n-        check(\"ff08::\",\n-              false, false, false, false, false, false, false, Some(OrganizationLocal));\n-        check(\"ff0e::\",\n-              false, false, false, true,  false, false, false, Some(Global));\n-    }\n-\n-    fn tsa<A: ToSocketAddrs>(a: A) -> Result<Vec<SocketAddr>, String> {\n-        match a.to_socket_addrs() {\n-            Ok(a) => Ok(a.collect()),\n-            Err(e) => Err(e.to_string()),\n-        }\n-    }\n-\n-    #[test]\n-    fn to_socket_addr_socketaddr() {\n-        let a = sa4(Ipv4Addr::new(77, 88, 21, 11), 12345);\n-        assert_eq!(Ok(vec![a]), tsa(a));\n-    }\n-\n-    fn sa4(a: Ipv4Addr, p: u16) -> SocketAddr {\n-        SocketAddr::V4(SocketAddrV4::new(a, p))\n-    }\n-\n-    fn sa6(a: Ipv6Addr, p: u16) -> SocketAddr {\n-        SocketAddr::V6(SocketAddrV6::new(a, p, 0, 0))\n-    }\n+    use net::test::{tsa, sa6, sa4};\n \n     #[test]\n     fn to_socket_addr_ipaddr_u16() {"}, {"sha": "065126c6fdbb564ea0fa30d338f895d2917754f8", "filename": "src/libstd/net/ip.rs", "status": "modified", "additions": 253, "deletions": 0, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/abf0548b5caaa389a5b29813132d2cf4c8b0f1ed/src%2Flibstd%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf0548b5caaa389a5b29813132d2cf4c8b0f1ed/src%2Flibstd%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fip.rs?ref=abf0548b5caaa389a5b29813132d2cf4c8b0f1ed", "patch": "@@ -486,3 +486,256 @@ impl FromInner<libc::in6_addr> for Ipv6Addr {\n         Ipv6Addr { inner: addr }\n     }\n }\n+\n+// Tests for this module\n+#[cfg(test)]\n+mod tests {\n+    use prelude::v1::*;\n+    use io;\n+    use net::*;\n+    use net::Ipv6MulticastScope::*;\n+    use net::test::{tsa, sa6, sa4};\n+\n+    #[test]\n+    fn test_from_str_ipv4() {\n+        assert_eq!(Ok(Ipv4Addr::new(127, 0, 0, 1)), \"127.0.0.1\".parse());\n+        assert_eq!(Ok(Ipv4Addr::new(255, 255, 255, 255)), \"255.255.255.255\".parse());\n+        assert_eq!(Ok(Ipv4Addr::new(0, 0, 0, 0)), \"0.0.0.0\".parse());\n+\n+        // out of range\n+        let none: Option<Ipv4Addr> = \"256.0.0.1\".parse().ok();\n+        assert_eq!(None, none);\n+        // too short\n+        let none: Option<Ipv4Addr> = \"255.0.0\".parse().ok();\n+        assert_eq!(None, none);\n+        // too long\n+        let none: Option<Ipv4Addr> = \"255.0.0.1.2\".parse().ok();\n+        assert_eq!(None, none);\n+        // no number between dots\n+        let none: Option<Ipv4Addr> = \"255.0..1\".parse().ok();\n+        assert_eq!(None, none);\n+    }\n+\n+    #[test]\n+    fn test_from_str_ipv6() {\n+        assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0)), \"0:0:0:0:0:0:0:0\".parse());\n+        assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1)), \"0:0:0:0:0:0:0:1\".parse());\n+\n+        assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1)), \"::1\".parse());\n+        assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0)), \"::\".parse());\n+\n+        assert_eq!(Ok(Ipv6Addr::new(0x2a02, 0x6b8, 0, 0, 0, 0, 0x11, 0x11)),\n+                \"2a02:6b8::11:11\".parse());\n+\n+        // too long group\n+        let none: Option<Ipv6Addr> = \"::00000\".parse().ok();\n+        assert_eq!(None, none);\n+        // too short\n+        let none: Option<Ipv6Addr> = \"1:2:3:4:5:6:7\".parse().ok();\n+        assert_eq!(None, none);\n+        // too long\n+        let none: Option<Ipv6Addr> = \"1:2:3:4:5:6:7:8:9\".parse().ok();\n+        assert_eq!(None, none);\n+        // triple colon\n+        let none: Option<Ipv6Addr> = \"1:2:::6:7:8\".parse().ok();\n+        assert_eq!(None, none);\n+        // two double colons\n+        let none: Option<Ipv6Addr> = \"1:2::6::8\".parse().ok();\n+        assert_eq!(None, none);\n+    }\n+\n+    #[test]\n+    fn test_from_str_ipv4_in_ipv6() {\n+        assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 49152, 545)),\n+                \"::192.0.2.33\".parse());\n+        assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0xFFFF, 49152, 545)),\n+                \"::FFFF:192.0.2.33\".parse());\n+        assert_eq!(Ok(Ipv6Addr::new(0x64, 0xff9b, 0, 0, 0, 0, 49152, 545)),\n+                \"64:ff9b::192.0.2.33\".parse());\n+        assert_eq!(Ok(Ipv6Addr::new(0x2001, 0xdb8, 0x122, 0xc000, 0x2, 0x2100, 49152, 545)),\n+                \"2001:db8:122:c000:2:2100:192.0.2.33\".parse());\n+\n+        // colon after v4\n+        let none: Option<Ipv4Addr> = \"::127.0.0.1:\".parse().ok();\n+        assert_eq!(None, none);\n+        // not enough groups\n+        let none: Option<Ipv6Addr> = \"1.2.3.4.5:127.0.0.1\".parse().ok();\n+        assert_eq!(None, none);\n+        // too many groups\n+        let none: Option<Ipv6Addr> = \"1.2.3.4.5:6:7:127.0.0.1\".parse().ok();\n+        assert_eq!(None, none);\n+    }\n+\n+    #[test]\n+    fn test_from_str_socket_addr() {\n+        assert_eq!(Ok(sa4(Ipv4Addr::new(77, 88, 21, 11), 80)),\n+                   \"77.88.21.11:80\".parse());\n+        assert_eq!(Ok(sa6(Ipv6Addr::new(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), 53)),\n+                   \"[2a02:6b8:0:1::1]:53\".parse());\n+        assert_eq!(Ok(sa6(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0x7F00, 1), 22)),\n+                   \"[::127.0.0.1]:22\".parse());\n+\n+        // without port\n+        let none: Option<SocketAddr> = \"127.0.0.1\".parse().ok();\n+        assert_eq!(None, none);\n+        // without port\n+        let none: Option<SocketAddr> = \"127.0.0.1:\".parse().ok();\n+        assert_eq!(None, none);\n+        // wrong brackets around v4\n+        let none: Option<SocketAddr> = \"[127.0.0.1]:22\".parse().ok();\n+        assert_eq!(None, none);\n+        // port out of range\n+        let none: Option<SocketAddr> = \"127.0.0.1:123456\".parse().ok();\n+        assert_eq!(None, none);\n+    }\n+\n+    #[test]\n+    fn ipv6_addr_to_string() {\n+        // ipv4-mapped address\n+        let a1 = Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc000, 0x280);\n+        assert_eq!(a1.to_string(), \"::ffff:192.0.2.128\");\n+\n+        // ipv4-compatible address\n+        let a1 = Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0xc000, 0x280);\n+        assert_eq!(a1.to_string(), \"::192.0.2.128\");\n+\n+        // v6 address with no zero segments\n+        assert_eq!(Ipv6Addr::new(8, 9, 10, 11, 12, 13, 14, 15).to_string(),\n+                   \"8:9:a:b:c:d:e:f\");\n+\n+        // reduce a single run of zeros\n+        assert_eq!(\"ae::ffff:102:304\",\n+                   Ipv6Addr::new(0xae, 0, 0, 0, 0, 0xffff, 0x0102, 0x0304).to_string());\n+\n+        // don't reduce just a single zero segment\n+        assert_eq!(\"1:2:3:4:5:6:0:8\",\n+                   Ipv6Addr::new(1, 2, 3, 4, 5, 6, 0, 8).to_string());\n+\n+        // 'any' address\n+        assert_eq!(\"::\", Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0).to_string());\n+\n+        // loopback address\n+        assert_eq!(\"::1\", Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1).to_string());\n+\n+        // ends in zeros\n+        assert_eq!(\"1::\", Ipv6Addr::new(1, 0, 0, 0, 0, 0, 0, 0).to_string());\n+\n+        // two runs of zeros, second one is longer\n+        assert_eq!(\"1:0:0:4::8\", Ipv6Addr::new(1, 0, 0, 4, 0, 0, 0, 8).to_string());\n+\n+        // two runs of zeros, equal length\n+        assert_eq!(\"1::4:5:0:0:8\", Ipv6Addr::new(1, 0, 0, 4, 5, 0, 0, 8).to_string());\n+    }\n+\n+    #[test]\n+    fn ipv4_to_ipv6() {\n+        assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0x1234, 0x5678),\n+                   Ipv4Addr::new(0x12, 0x34, 0x56, 0x78).to_ipv6_mapped());\n+        assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0x1234, 0x5678),\n+                   Ipv4Addr::new(0x12, 0x34, 0x56, 0x78).to_ipv6_compatible());\n+    }\n+\n+    #[test]\n+    fn ipv6_to_ipv4() {\n+        assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0x1234, 0x5678).to_ipv4(),\n+                   Some(Ipv4Addr::new(0x12, 0x34, 0x56, 0x78)));\n+        assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0x1234, 0x5678).to_ipv4(),\n+                   Some(Ipv4Addr::new(0x12, 0x34, 0x56, 0x78)));\n+        assert_eq!(Ipv6Addr::new(0, 0, 1, 0, 0, 0, 0x1234, 0x5678).to_ipv4(),\n+                   None);\n+    }\n+\n+    #[test]\n+    fn ipv4_properties() {\n+        fn check(octets: &[u8; 4], unspec: bool, loopback: bool,\n+                 private: bool, link_local: bool, global: bool,\n+                 multicast: bool, broadcast: bool, documentation: bool) {\n+            let ip = Ipv4Addr::new(octets[0], octets[1], octets[2], octets[3]);\n+            assert_eq!(octets, &ip.octets());\n+\n+            assert_eq!(ip.is_unspecified(), unspec);\n+            assert_eq!(ip.is_loopback(), loopback);\n+            assert_eq!(ip.is_private(), private);\n+            assert_eq!(ip.is_link_local(), link_local);\n+            assert_eq!(ip.is_global(), global);\n+            assert_eq!(ip.is_multicast(), multicast);\n+            assert_eq!(ip.is_broadcast(), broadcast);\n+            assert_eq!(ip.is_documentation(), documentation);\n+        }\n+\n+        //    address                unspec loopbk privt  linloc global multicast brdcast doc\n+        check(&[0, 0, 0, 0],         true,  false, false, false, true,  false,    false,  false);\n+        check(&[0, 0, 0, 1],         false, false, false, false, true,  false,    false,  false);\n+        check(&[1, 0, 0, 0],         false, false, false, false, true,  false,    false,  false);\n+        check(&[10, 9, 8, 7],        false, false, true,  false, false, false,    false,  false);\n+        check(&[127, 1, 2, 3],       false, true,  false, false, false, false,    false,  false);\n+        check(&[172, 31, 254, 253],  false, false, true,  false, false, false,    false,  false);\n+        check(&[169, 254, 253, 242], false, false, false, true,  false, false,    false,  false);\n+        check(&[192, 168, 254, 253], false, false, true,  false, false, false,    false,  false);\n+        check(&[224, 0, 0, 0],       false, false, false, false, true,  true,     false,  false);\n+        check(&[239, 255, 255, 255], false, false, false, false, true,  true,     false,  false);\n+        check(&[255, 255, 255, 255], false, false, false, false, false, false,    true,  false);\n+        check(&[198, 51, 100, 0],    false, false, false, false, false, false,    false,  true);\n+    }\n+\n+    #[test]\n+    fn ipv6_properties() {\n+        fn check(str_addr: &str, unspec: bool, loopback: bool,\n+                 unique_local: bool, global: bool,\n+                 u_link_local: bool, u_site_local: bool, u_global: bool,\n+                 m_scope: Option<Ipv6MulticastScope>) {\n+            let ip: Ipv6Addr = str_addr.parse().unwrap();\n+            assert_eq!(str_addr, ip.to_string());\n+\n+            assert_eq!(ip.is_unspecified(), unspec);\n+            assert_eq!(ip.is_loopback(), loopback);\n+            assert_eq!(ip.is_unique_local(), unique_local);\n+            assert_eq!(ip.is_global(), global);\n+            assert_eq!(ip.is_unicast_link_local(), u_link_local);\n+            assert_eq!(ip.is_unicast_site_local(), u_site_local);\n+            assert_eq!(ip.is_unicast_global(), u_global);\n+            assert_eq!(ip.multicast_scope(), m_scope);\n+            assert_eq!(ip.is_multicast(), m_scope.is_some());\n+        }\n+\n+        //    unspec loopbk uniqlo global unill  unisl  uniglo mscope\n+        check(\"::\",\n+              true,  false, false, true,  false, false, true,  None);\n+        check(\"::1\",\n+              false, true,  false, false, false, false, false, None);\n+        check(\"::0.0.0.2\",\n+              false, false, false, true,  false, false, true,  None);\n+        check(\"1::\",\n+              false, false, false, true,  false, false, true,  None);\n+        check(\"fc00::\",\n+              false, false, true,  false, false, false, false, None);\n+        check(\"fdff:ffff::\",\n+              false, false, true,  false, false, false, false, None);\n+        check(\"fe80:ffff::\",\n+              false, false, false, false, true,  false, false, None);\n+        check(\"febf:ffff::\",\n+              false, false, false, false, true,  false, false, None);\n+        check(\"fec0::\",\n+              false, false, false, false, false, true,  false, None);\n+        check(\"ff01::\",\n+              false, false, false, false, false, false, false, Some(InterfaceLocal));\n+        check(\"ff02::\",\n+              false, false, false, false, false, false, false, Some(LinkLocal));\n+        check(\"ff03::\",\n+              false, false, false, false, false, false, false, Some(RealmLocal));\n+        check(\"ff04::\",\n+              false, false, false, false, false, false, false, Some(AdminLocal));\n+        check(\"ff05::\",\n+              false, false, false, false, false, false, false, Some(SiteLocal));\n+        check(\"ff08::\",\n+              false, false, false, false, false, false, false, Some(OrganizationLocal));\n+        check(\"ff0e::\",\n+              false, false, false, true,  false, false, false, Some(Global));\n+    }\n+\n+    #[test]\n+    fn to_socket_addr_socketaddr() {\n+        let a = sa4(Ipv4Addr::new(77, 88, 21, 11), 12345);\n+        assert_eq!(Ok(vec![a]), tsa(a));\n+    }\n+}"}, {"sha": "e48d0e6008b87f4ab0837b7c112127c293276a96", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/abf0548b5caaa389a5b29813132d2cf4c8b0f1ed/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf0548b5caaa389a5b29813132d2cf4c8b0f1ed/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=abf0548b5caaa389a5b29813132d2cf4c8b0f1ed", "patch": "@@ -213,7 +213,7 @@ impl TcpListener {\n     /// Returns an iterator over the connections being received on this\n     /// listener.\n     ///\n-    /// The returned iterator will never returned `None` and will also not yield\n+    /// The returned iterator will never return `None` and will also not yield\n     /// the peer's `SocketAddr` structure.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn incoming(&self) -> Incoming {"}, {"sha": "d77d6f1d6de1e2d3fdd177cdf02e62710096b7f9", "filename": "src/libstd/net/test.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/abf0548b5caaa389a5b29813132d2cf4c8b0f1ed/src%2Flibstd%2Fnet%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf0548b5caaa389a5b29813132d2cf4c8b0f1ed/src%2Flibstd%2Fnet%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftest.rs?ref=abf0548b5caaa389a5b29813132d2cf4c8b0f1ed", "patch": "@@ -11,7 +11,7 @@\n use prelude::v1::*;\n \n use env;\n-use net::{SocketAddr, SocketAddrV4, SocketAddrV6, Ipv4Addr, Ipv6Addr};\n+use net::{SocketAddr, SocketAddrV4, SocketAddrV6, Ipv4Addr, Ipv6Addr, ToSocketAddrs};\n use sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n \n static PORT: AtomicUsize = ATOMIC_USIZE_INIT;\n@@ -27,6 +27,21 @@ pub fn next_test_ip6() -> SocketAddr {\n                                      port, 0, 0))\n }\n \n+pub fn sa4(a: Ipv4Addr, p: u16) -> SocketAddr {\n+    SocketAddr::V4(SocketAddrV4::new(a, p))\n+}\n+\n+pub fn sa6(a: Ipv6Addr, p: u16) -> SocketAddr {\n+    SocketAddr::V6(SocketAddrV6::new(a, p, 0, 0))\n+}\n+\n+pub fn tsa<A: ToSocketAddrs>(a: A) -> Result<Vec<SocketAddr>, String> {\n+    match a.to_socket_addrs() {\n+        Ok(a) => Ok(a.collect()),\n+        Err(e) => Err(e.to_string()),\n+    }\n+}\n+\n // The bots run multiple builds at the same time, and these builds\n // all want to use ports. This function figures out which workspace\n // it is running in and assigns a port range based on it."}, {"sha": "bef2068f0ddcb0abfbd0206f12a73f20d87b6ae3", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/abf0548b5caaa389a5b29813132d2cf4c8b0f1ed/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf0548b5caaa389a5b29813132d2cf4c8b0f1ed/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=abf0548b5caaa389a5b29813132d2cf4c8b0f1ed", "patch": "@@ -1972,7 +1972,7 @@ impl<'a> Parser<'a> {\n                 }\n                 try!(self.bump());\n \n-                hi = self.span.hi;\n+                hi = self.last_span.hi;\n                 return if es.len() == 1 && !trailing_comma {\n                     Ok(self.mk_expr(lo, hi, ExprParen(es.into_iter().nth(0).unwrap())))\n                 } else {"}, {"sha": "37d62182612346c422fcf86c4d30fcae9b73b958", "filename": "src/test/parse-fail/issue-24197.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/abf0548b5caaa389a5b29813132d2cf4c8b0f1ed/src%2Ftest%2Fparse-fail%2Fissue-24197.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf0548b5caaa389a5b29813132d2cf4c8b0f1ed/src%2Ftest%2Fparse-fail%2Fissue-24197.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fissue-24197.rs?ref=abf0548b5caaa389a5b29813132d2cf4c8b0f1ed", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let buf[0] = 0; //~ ERROR expected one of `:`, `;`, `=`, or `@`, found `[`\n+}"}, {"sha": "8723423325c198ae4ed997cb352e0a285da2087e", "filename": "src/test/parse-fail/issue-24375.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/abf0548b5caaa389a5b29813132d2cf4c8b0f1ed/src%2Ftest%2Fparse-fail%2Fissue-24375.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf0548b5caaa389a5b29813132d2cf4c8b0f1ed/src%2Ftest%2Fparse-fail%2Fissue-24375.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fissue-24375.rs?ref=abf0548b5caaa389a5b29813132d2cf4c8b0f1ed", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+static tmp : [&'static str; 2]  = [\"hello\", \"he\"];\n+\n+fn main() {\n+    let z = \"hello\";\n+    match z {\n+        tmp[0] => {} //~ ERROR expected one of `=>`, `@`, `if`, or `|`, found `[`\n+        _ => {}\n+    }\n+}"}, {"sha": "cf9bc9bb56a897e7e35cea1cf970a6beef11a2ba", "filename": "src/test/run-pass/method-two-trait-defer-resolution-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/abf0548b5caaa389a5b29813132d2cf4c8b0f1ed/src%2Ftest%2Frun-pass%2Fmethod-two-trait-defer-resolution-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf0548b5caaa389a5b29813132d2cf4c8b0f1ed/src%2Ftest%2Frun-pass%2Fmethod-two-trait-defer-resolution-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmethod-two-trait-defer-resolution-2.rs?ref=abf0548b5caaa389a5b29813132d2cf4c8b0f1ed", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Test that when we write `x.foo()`, we do nothave to know the\n+// Test that when we write `x.foo()`, we do not have to know the\n // complete type of `x` in order to type-check the method call. In\n // this case, we know that `x: Vec<_1>`, but we don't know what type\n // `_1` is (because the call to `push` comes later). To pick between"}]}