{"sha": "8b8091d370fa31844d6ed55f4ccdd32e5dbd20f9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiODA5MWQzNzBmYTMxODQ0ZDZlZDU1ZjRjY2RkMzJlNWRiZDIwZjk=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2018-04-06T07:34:45Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2018-04-07T22:11:41Z"}, "message": "Rewrite docs for `std::ptr`\n\n- Add links to the GNU libc docs for `memmove`, `memcpy`, and\n  `memset`, as well as internally linking to other functions in `std::ptr`\n- List sources of UB for all functions.\n- Add example to `ptr::drop_in_place` and compares it to `ptr::read`.\n- Add examples which more closely mirror real world uses for the\n  functions in `std::ptr`. Also, move the reimplementation of `mem::swap`\n  to the examples of `ptr::read` and use a more interesting example for\n  `copy_nonoverlapping`.\n- Change module level description", "tree": {"sha": "57798c6f313fe12d861da36d6bc6502f2946d2fc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/57798c6f313fe12d861da36d6bc6502f2946d2fc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8b8091d370fa31844d6ed55f4ccdd32e5dbd20f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8b8091d370fa31844d6ed55f4ccdd32e5dbd20f9", "html_url": "https://github.com/rust-lang/rust/commit/8b8091d370fa31844d6ed55f4ccdd32e5dbd20f9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8b8091d370fa31844d6ed55f4ccdd32e5dbd20f9/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "780707490f2b6c3e71a1418e08ef80a6730bce13", "url": "https://api.github.com/repos/rust-lang/rust/commits/780707490f2b6c3e71a1418e08ef80a6730bce13", "html_url": "https://github.com/rust-lang/rust/commit/780707490f2b6c3e71a1418e08ef80a6730bce13"}], "stats": {"total": 598, "additions": 496, "deletions": 102}, "files": [{"sha": "d6bd2b868554c03bddd99218bd522b07484eb130", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 146, "deletions": 31, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/8b8091d370fa31844d6ed55f4ccdd32e5dbd20f9/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b8091d370fa31844d6ed55f4ccdd32e5dbd20f9/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=8b8091d370fa31844d6ed55f4ccdd32e5dbd20f9", "patch": "@@ -959,59 +959,134 @@ extern \"rust-intrinsic\" {\n     /// value is not necessarily valid to be used to actually access memory.\n     pub fn arith_offset<T>(dst: *const T, offset: isize) -> *const T;\n \n-    /// Copies `count * size_of<T>` bytes from `src` to `dst`. The source\n-    /// and destination may *not* overlap.\n+    /// Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n+    /// and destination must *not* overlap.\n     ///\n-    /// `copy_nonoverlapping` is semantically equivalent to C's `memcpy`.\n+    /// For regions of memory which might overlap, use [`copy`] instead.\n+    ///\n+    /// `copy_nonoverlapping` is semantically equivalent to C's [`memcpy`].\n+    ///\n+    /// [`copy`]: ./fn.copy.html\n+    /// [`memcpy`]: https://www.gnu.org/software/libc/manual/html_node/Copying-Strings-and-Arrays.html#index-memcpy\n     ///\n     /// # Safety\n     ///\n-    /// Beyond requiring that the program must be allowed to access both regions\n-    /// of memory, it is Undefined Behavior for source and destination to\n-    /// overlap. Care must also be taken with the ownership of `src` and\n-    /// `dst`. This method semantically moves the values of `src` into `dst`.\n-    /// However it does not drop the contents of `dst`, or prevent the contents\n-    /// of `src` from being dropped or used.\n+    /// `copy_nonoverlapping` is unsafe because it dereferences a raw pointer.\n+    /// The caller must ensure that `src` points to a valid sequence of type\n+    /// `T`.\n+    ///\n+    /// # [Undefined Behavior]\n+    ///\n+    /// Behavior is undefined if any of the following conditions are violated:\n+    ///\n+    /// * The region of memory which begins at `src` and has a length of\n+    ///   `count * size_of::<T>()` bytes must be *both* valid and initialized.\n+    ///\n+    /// * The region of memory which begins at `dst` and has a length of\n+    ///   `count * size_of::<T>()` bytes must be valid (but may or may not be\n+    ///   initialized).\n+    ///\n+    /// * `src` must be properly aligned.\n+    ///\n+    /// * `dst` must be properly aligned.\n+    ///\n+    /// * The two regions of memory must *not* overlap.\n+    ///\n+    /// Additionally, if `T` is not [`Copy`](../marker/trait.Copy), only the region at `src` *or* the\n+    /// region at `dst` can be used or dropped after calling\n+    /// `copy_nonoverlapping`. `copy_nonoverlapping` creates bitwise copies of\n+    /// `T`, regardless of whether `T: Copy`, which can result in undefined\n+    /// behavior if both copies are used.\n+    ///\n+    /// [Undefined Behavior]: ../../reference/behavior-considered-undefined.html\n     ///\n     /// # Examples\n     ///\n-    /// A safe swap function:\n+    /// Manually implement [`Vec::append`]:\n     ///\n     /// ```\n-    /// use std::mem;\n     /// use std::ptr;\n     ///\n-    /// # #[allow(dead_code)]\n-    /// fn swap<T>(x: &mut T, y: &mut T) {\n+    /// /// Moves all the elements of `src` into `dst`, leaving `src` empty.\n+    /// fn append<T>(dst: &mut Vec<T>, src: &mut Vec<T>) {\n+    ///     let src_len = src.len();\n+    ///     let dst_len = dst.len();\n+    ///\n+    ///     // Ensure that `dst` has enough capacity to hold all of `src`.\n+    ///     dst.reserve(src_len);\n+    ///\n     ///     unsafe {\n-    ///         // Give ourselves some scratch space to work with\n-    ///         let mut t: T = mem::uninitialized();\n+    ///         // The call to offset is always safe because `Vec` will never\n+    ///         // allocate more than `isize::MAX` bytes.\n+    ///         let dst = dst.as_mut_ptr().offset(dst_len as isize);\n+    ///         let src = src.as_ptr();\n+    ///\n+    ///         // The two regions cannot overlap becuase mutable references do\n+    ///         // not alias, and two different vectors cannot own the same\n+    ///         // memory.\n+    ///         ptr::copy_nonoverlapping(src, dst, src_len);\n+    ///     }\n     ///\n-    ///         // Perform the swap, `&mut` pointers never alias\n-    ///         ptr::copy_nonoverlapping(x, &mut t, 1);\n-    ///         ptr::copy_nonoverlapping(y, x, 1);\n-    ///         ptr::copy_nonoverlapping(&t, y, 1);\n+    ///     unsafe {\n+    ///         // Truncate `src` without dropping its contents.\n+    ///         src.set_len(0);\n     ///\n-    ///         // y and t now point to the same thing, but we need to completely forget `t`\n-    ///         // because it's no longer relevant.\n-    ///         mem::forget(t);\n+    ///         // Notify `dst` that it now holds the contents of `src`.\n+    ///         dst.set_len(dst_len + src_len);\n     ///     }\n     /// }\n+    ///\n+    /// let mut a = vec!['r'];\n+    /// let mut b = vec!['u', 's', 't'];\n+    ///\n+    /// append(&mut a, &mut b);\n+    ///\n+    /// assert_eq!(a, &['r', 'u', 's', 't']);\n+    /// assert!(b.is_empty());\n     /// ```\n+    ///\n+    /// [`Vec::append()`]: ../vec/struct.Vec.html#method.append\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize);\n \n-    /// Copies `count * size_of<T>` bytes from `src` to `dst`. The source\n+    /// Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n     /// and destination may overlap.\n     ///\n-    /// `copy` is semantically equivalent to C's `memmove`.\n+    /// If the source and destination will *never* overlap,\n+    /// [`copy_nonoverlapping`] can be used instead.\n+    ///\n+    /// `copy` is semantically equivalent to C's [`memmove`].\n+    ///\n+    /// [`copy_nonoverlapping`]: ./fn.copy_nonoverlapping.html\n+    /// [`memmove`]: https://www.gnu.org/software/libc/manual/html_node/Copying-Strings-and-Arrays.html#index-memmove\n     ///\n     /// # Safety\n     ///\n-    /// Care must be taken with the ownership of `src` and `dst`.\n-    /// This method semantically moves the values of `src` into `dst`.\n-    /// However it does not drop the contents of `dst`, or prevent the contents of `src`\n-    /// from being dropped or used.\n+    /// `copy` is unsafe because it dereferences a raw pointer. The caller must\n+    /// ensure that `src` points to a valid sequence of type `T`.\n+    ///\n+    /// # [Undefined Behavior]\n+    ///\n+    /// Behavior is undefined if any of the following conditions are violated:\n+    ///\n+    /// * The region of memory which begins at `src` and has a length of\n+    ///   `count * size_of::<T>()` bytes must be *both* valid and initialized.\n+    ///\n+    /// * The region of memory which begins at `dst` and has a length of\n+    ///   `count * size_of::<T>()` bytes must be valid (but may or may not be\n+    ///   initialized).\n+    ///\n+    /// * `src` must be properly aligned.\n+    ///\n+    /// * `dst` must be properly aligned.\n+    ///\n+    /// Additionally, if `T` is not [`Copy`], only the region at `src` *or* the\n+    /// region at `dst` can be used or dropped after calling `copy`. `copy`\n+    /// creates bitwise copies of `T`, regardless of whether `T: Copy`, which\n+    /// can result in undefined behavior if both copies are used.\n+    ///\n+    /// [`Copy`]: ../marker/trait.Copy.html\n+    /// [Undefined Behavior]: ../../reference/behavior-considered-undefined.html\n     ///\n     /// # Examples\n     ///\n@@ -1028,15 +1103,39 @@ extern \"rust-intrinsic\" {\n     ///     dst\n     /// }\n     /// ```\n-    ///\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn copy<T>(src: *const T, dst: *mut T, count: usize);\n \n-    /// Invokes memset on the specified pointer, setting `count * size_of::<T>()`\n-    /// bytes of memory starting at `dst` to `val`.\n+    /// Sets `count * size_of::<T>()` bytes of memory starting at `dst` to\n+    /// `val`.\n+    ///\n+    /// `write_bytes` is semantically equivalent to C's [`memset`].\n+    ///\n+    /// [`memset`]: https://www.gnu.org/software/libc/manual/html_node/Copying-Strings-and-Arrays.html#index-memset\n+    ///\n+    /// # Safety\n+    ///\n+    /// `write_bytes` is unsafe because it dereferences a raw pointer. The\n+    /// caller must ensure that the poiinter points to a valid value of type `T`.\n+    ///\n+    /// # [Undefined Behavior]\n+    ///\n+    /// Behavior is undefined if any of the following conditions are violated:\n+    ///\n+    /// * The region of memory which begins at `dst` and has a length of\n+    ///   `count` bytes must be valid.\n+    ///\n+    /// * `dst` must be properly aligned.\n+    ///\n+    /// Additionally, the caller must ensure that writing `count` bytes to the\n+    /// given region of memory results in a valid value of `T`. Creating an\n+    /// invalid value of `T` can result in undefined behavior. An example is\n+    /// provided below.\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// use std::ptr;\n     ///\n@@ -1047,6 +1146,22 @@ extern \"rust-intrinsic\" {\n     /// }\n     /// assert_eq!(vec, [b'a', b'a', 0, 0]);\n     /// ```\n+    ///\n+    /// Creating an invalid value:\n+    ///\n+    /// ```ignore\n+    /// use std::{mem, ptr};\n+    ///\n+    /// let mut v = Box::new(0i32);\n+    ///\n+    /// unsafe {\n+    ///     // Leaks the previously held value by overwriting the `Box<T>` with\n+    ///     // a null pointer.\n+    ///     ptr::write_bytes(&mut v, 0, mem::size_of::<Box<i32>>());\n+    /// }\n+    ///\n+    /// // At this point, using or dropping `v` results in undefined behavior.\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn write_bytes<T>(dst: *mut T, val: u8, count: usize);\n "}, {"sha": "98d5030477b51814d119a1cd4f4d72a8b9c9a801", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 350, "deletions": 71, "changes": 421, "blob_url": "https://github.com/rust-lang/rust/blob/8b8091d370fa31844d6ed55f4ccdd32e5dbd20f9/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b8091d370fa31844d6ed55f4ccdd32e5dbd20f9/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=8b8091d370fa31844d6ed55f4ccdd32e5dbd20f9", "patch": "@@ -10,7 +10,7 @@\n \n // FIXME: talk about offset, copy_memory, copy_nonoverlapping_memory\n \n-//! Raw, unsafe pointers, `*const T`, and `*mut T`.\n+//! Manually manage memory through raw, unsafe pointers.\n //!\n //! *[See also the pointer primitive types](../../std/primitive.pointer.html).*\n \n@@ -38,21 +38,68 @@ pub use intrinsics::write_bytes;\n \n /// Executes the destructor (if any) of the pointed-to value.\n ///\n-/// This has two use cases:\n+/// This is semantically equivalent to calling [`ptr::read`] and discarding\n+/// the result, but has the following advantages:\n ///\n /// * It is *required* to use `drop_in_place` to drop unsized types like\n ///   trait objects, because they can't be read out onto the stack and\n ///   dropped normally.\n ///\n-/// * It is friendlier to the optimizer to do this over `ptr::read` when\n+/// * It is friendlier to the optimizer to do this over [`ptr::read`] when\n ///   dropping manually allocated memory (e.g. when writing Box/Rc/Vec),\n ///   as the compiler doesn't need to prove that it's sound to elide the\n ///   copy.\n ///\n+/// [`ptr::read`]: ./fn.read.html\n+///\n /// # Safety\n ///\n-/// This has all the same safety problems as `ptr::read` with respect to\n-/// invalid pointers, types, and double drops.\n+/// `drop_in_place` is unsafe because it dereferences a raw pointer. The caller\n+/// must ensure that the pointer points to a valid value of type `T`.\n+///\n+/// # [Undefined Behavior]\n+///\n+/// Behavior is undefined if any of the following conditions are violated:\n+///\n+/// * `to_drop` must point to valid memory.\n+///\n+/// * `to_drop` must be properly aligned.\n+///\n+/// Additionally, if `T` is not [`Copy`], using the pointed-to value after\n+/// calling `drop_in_place` can cause undefined behavior. Note that `*to_drop =\n+/// foo` counts as a use because it will cause the the value to be dropped\n+/// again. [`write`] can be used to overwrite data without causing it to be\n+/// dropped.\n+///\n+/// [`Copy`]: ../marker/trait.Copy.html\n+/// [`write`]: ./fn.write.html\n+/// [Undefined Behavior]: ../../reference/behavior-considered-undefined.html\n+///\n+/// # Examples\n+///\n+/// Manually remove the last item from a vector:\n+///\n+/// ```\n+/// use std::ptr;\n+/// use std::rc::Rc;\n+///\n+/// let last = Rc::new(1);\n+/// let weak = Rc::downgrade(&last);\n+///\n+/// let mut v = vec![Rc::new(0), last];\n+///\n+/// unsafe {\n+///     // Without a call `drop_in_place`, the last item would never be dropped,\n+///     // and the memory it manages would be leaked.\n+///     ptr::drop_in_place(&mut v[1]);\n+///     v.set_len(1);\n+/// }\n+///\n+/// assert_eq!(v, &[0.into()]);\n+///\n+/// // Ensure that the last item was dropped.\n+/// assert!(weak.upgrade().is_none());\n+/// ```\n #[stable(feature = \"drop_in_place\", since = \"1.8.0\")]\n #[lang = \"drop_in_place\"]\n #[allow(unconditional_recursion)]\n@@ -93,17 +140,32 @@ pub const fn null_mut<T>() -> *mut T { 0 as *mut T }\n /// Swaps the values at two mutable locations of the same type, without\n /// deinitializing either.\n ///\n-/// The values pointed at by `x` and `y` may overlap, unlike `mem::swap` which\n-/// is otherwise equivalent. If the values do overlap, then the overlapping\n-/// region of memory from `x` will be used. This is demonstrated in the\n-/// examples section below.\n+/// But for the following two exceptions, this function is semantically\n+/// equivalent to [`mem::swap`]:\n+///\n+/// * It operates on raw pointers instead of references. When references are\n+///   available, [`mem::swap`] should be preferred.\n+///\n+/// * The two pointed-to values may overlap. If the values do overlap, then the\n+///   overlapping region of memory from `x` will be used. This is demonstrated\n+///   in the examples below.\n+///\n+/// [`mem::swap`]: ../mem/fn.swap.html\n ///\n /// # Safety\n ///\n-/// This function copies the memory through the raw pointers passed to it\n-/// as arguments.\n+/// `swap` is unsafe because it dereferences a raw pointer. The caller must\n+/// ensure that both pointers point to valid values of type `T`.\n+///\n+/// # [Undefined Behavior]\n+///\n+/// Behavior is undefined if any of the following conditions are violated:\n+///\n+/// * `x` and `y` must point to valid, initialized memory.\n ///\n-/// Ensure that these pointers are valid before calling `swap`.\n+/// * `x` and `y` must be properly aligned.\n+///\n+/// [Undefined Behavior]: ../../reference/behavior-considered-undefined.html\n ///\n /// # Examples\n ///\n@@ -241,13 +303,46 @@ unsafe fn swap_nonoverlapping_bytes(x: *mut u8, y: *mut u8, len: usize) {\n     }\n }\n \n-/// Replaces the value at `dest` with `src`, returning the old\n-/// value, without dropping either.\n+/// Replaces the value at `dest` with `src`, returning the old value, without\n+/// dropping either.\n+///\n+/// This function is semantically equivalent to [`mem::replace`] except that it\n+/// operates on raw pointers instead of references. When references are\n+/// available, [`mem::replace`] should be preferred.\n ///\n /// # Safety\n ///\n-/// This is only unsafe because it accepts a raw pointer.\n-/// Otherwise, this operation is identical to `mem::replace`.\n+/// `replace` is unsafe because it dereferences a raw pointer. The caller\n+/// must ensure that the pointer points to a valid value of type `T`.\n+///\n+/// [`mem::replace`]: ../mem/fn.replace.html\n+///\n+/// # [Undefined Behavior]\n+///\n+/// Behavior is undefined if any of the following conditions are violated:\n+///\n+/// * `dest` must point to valid, initialized memory.\n+///\n+/// * `dest` must be properly aligned.\n+///\n+/// [Undefined Behavior]: ../../reference/behavior-considered-undefined.html\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::ptr;\n+///\n+/// let mut rust = vec!['b', 'u', 's', 't'];\n+///\n+/// // `mem::replace` would have the same effect without requiring the unsafe\n+/// // block.\n+/// let b = unsafe {\n+///     ptr::replace(&mut a[0], 'r')\n+/// };\n+///\n+/// assert_eq!(b, 'b');\n+/// assert_eq!(rust, &['r', 'u', 's', 't']);\n+/// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn replace<T>(dest: *mut T, mut src: T) -> T {\n@@ -260,14 +355,29 @@ pub unsafe fn replace<T>(dest: *mut T, mut src: T) -> T {\n ///\n /// # Safety\n ///\n-/// Beyond accepting a raw pointer, this is unsafe because it semantically\n-/// moves the value out of `src` without preventing further usage of `src`.\n-/// If `T` is not `Copy`, then care must be taken to ensure that the value at\n-/// `src` is not used before the data is overwritten again (e.g. with `write`,\n-/// `write_bytes`, or `copy`). Note that `*src = foo` counts as a use\n-/// because it will attempt to drop the value previously at `*src`.\n+/// `read` is unsafe because it dereferences a raw pointer. The caller\n+/// must ensure that the pointer points to a valid value of type `T`.\n+///\n+/// # [Undefined Behavior]\n ///\n-/// The pointer must be aligned; use `read_unaligned` if that is not the case.\n+/// Behavior is undefined if any of the following conditions are violated:\n+///\n+/// * `src` must point to valid, initialized memory.\n+///\n+/// * `src` must be properly aligned. Use [`read_unaligned`] if this is not the\n+///   case.\n+///\n+/// Additionally, if `T` is not [`Copy`], only the returned value *or* the\n+/// pointed-to value can be used or dropped after calling `read`. `read` creates\n+/// a bitwise copy of `T`, regardless of whether `T: Copy`, which can result\n+/// in undefined behavior if both copies are used. Note that `*src = foo` counts\n+/// as a use because it will attempt to drop the value previously at `*src`.\n+/// [`write`] can be used to overwrite data without causing it to be dropped.\n+///\n+/// [`Copy`]: ../marker/trait.Copy.html\n+/// [`read_unaligned`]: ./fn.read_unaligned.html\n+/// [`write`]: ./fn.write.html\n+/// [Undefined Behavior]: ../../reference/behavior-considered-undefined.html\n ///\n /// # Examples\n ///\n@@ -281,6 +391,44 @@ pub unsafe fn replace<T>(dest: *mut T, mut src: T) -> T {\n ///     assert_eq!(std::ptr::read(y), 12);\n /// }\n /// ```\n+///\n+/// Manually implement [`mem::swap`]:\n+///\n+/// ```\n+/// use std::ptr;\n+///\n+/// fn swap<T>(a: &mut T, b: &mut T) {\n+///     unsafe {\n+///         // Create a bitwise copy of the value at `a` in `tmp`.\n+///         let tmp = ptr::read(a);\n+///\n+///         // Exiting at this point (either by explicitly returning or by\n+///         // calling a function which panics) would cause the value in `tmp` to\n+///         // be dropped while the same value is still referenced by `a`. This\n+///         // could trigger undefined behavior if `T` is not `Copy`.\n+///\n+///         // Create a bitwise copy of the value at `b` in `a`.\n+///         // This is safe because mutable references cannot alias.\n+///         ptr::copy_nonoverlapping(b, a, 1);\n+///\n+///         // As above, exiting here could trigger undefined behavior because\n+///         // the same value is referenced by `a` and `b`.\n+///\n+///         // Move `tmp` into `b`.\n+///         ptr::write(b, tmp);\n+///     }\n+/// }\n+///\n+/// let mut foo = \"foo\".to_owned();\n+/// let mut bar = \"bar\".to_owned();\n+///\n+/// swap(&mut foo, &mut bar);\n+///\n+/// assert_eq!(foo, \"bar\");\n+/// assert_eq!(bar, \"foo\");\n+/// ```\n+///\n+/// [`mem::swap`]: ../mem/fn.swap.html\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn read<T>(src: *const T) -> T {\n@@ -292,28 +440,66 @@ pub unsafe fn read<T>(src: *const T) -> T {\n /// Reads the value from `src` without moving it. This leaves the\n /// memory in `src` unchanged.\n ///\n-/// Unlike `read`, the pointer may be unaligned.\n+/// Unlike [`read`], `read_unaligned` works with unaligned pointers.\n ///\n-/// # Safety\n+/// [`read`]: ./fn.read.html\n+///\n+/// `read_unaligned` is unsafe because it dereferences a raw pointer. The caller\n+/// must ensure that the pointer points to a valid value of type `T`.\n+///\n+/// # [Undefined Behavior]\n+///\n+/// Behavior is undefined if any of the following conditions are violated:\n ///\n-/// Beyond accepting a raw pointer, this is unsafe because it semantically\n-/// moves the value out of `src` without preventing further usage of `src`.\n-/// If `T` is not `Copy`, then care must be taken to ensure that the value at\n-/// `src` is not used before the data is overwritten again (e.g. with `write`,\n-/// `write_bytes`, or `copy`). Note that `*src = foo` counts as a use\n-/// because it will attempt to drop the value previously at `*src`.\n+/// * `src` must point to valid, initialized memory.\n+///\n+/// Additionally, if `T` is not [`Copy`], only the returned value *or* the\n+/// pointed-to value can be used or dropped after calling `read_unaligned`.\n+/// `read_unaligned` creates a bitwise copy of `T`, regardless of whether `T:\n+/// Copy`, and this can result in undefined behavior if both copies are used.\n+/// Note that `*src = foo` counts as a use because it will attempt to drop the\n+/// value previously at `*src`.  [`write_unaligned`] can be used to overwrite\n+/// data without causing it to be dropped.\n+///\n+/// [`Copy`]: ../marker/trait.Copy.html\n+/// [`write_unaligned`]: ./fn.write_unaligned.html\n+/// [Undefined Behavior]: ../../reference/behavior-considered-undefined.html\n ///\n /// # Examples\n ///\n-/// Basic usage:\n+/// Access members of a packed struct by reference:\n ///\n /// ```\n-/// let x = 12;\n-/// let y = &x as *const i32;\n+/// use std::ptr;\n ///\n-/// unsafe {\n-///     assert_eq!(std::ptr::read_unaligned(y), 12);\n+/// #[repr(packed, C)]\n+/// #[derive(Default)]\n+/// struct Packed {\n+///     _padding: u8,\n+///     unaligned: u32,\n /// }\n+///\n+/// let x = Packed {\n+///     _padding: 0x00,\n+///     unaligned: 0x01020304,\n+/// };\n+///\n+/// let v = unsafe {\n+///     // Take a reference to a 32-bit integer which is not aligned.\n+///     let unaligned = &x.unaligned;\n+///\n+///     // Dereferencing normally will emit an unaligned load instruction,\n+///     // causing undefined behavior.\n+///     // let v = *unaligned; // ERROR\n+///\n+///     // Instead, use `read_unaligned` to read improperly aligned values.\n+///     let v = ptr::read_unaligned(unaligned);\n+///\n+///     v\n+/// };\n+///\n+/// // Accessing unaligned values directly is safe.\n+/// assert!(x.unaligned == v);\n /// ```\n #[inline]\n #[stable(feature = \"ptr_unaligned\", since = \"1.17.0\")]\n@@ -328,21 +514,34 @@ pub unsafe fn read_unaligned<T>(src: *const T) -> T {\n /// Overwrites a memory location with the given value without reading or\n /// dropping the old value.\n ///\n-/// # Safety\n-///\n-/// This operation is marked unsafe because it accepts a raw pointer.\n-///\n-/// It does not drop the contents of `dst`. This is safe, but it could leak\n+/// `write` does not drop the contents of `dst`. This is safe, but it could leak\n /// allocations or resources, so care must be taken not to overwrite an object\n /// that should be dropped.\n ///\n /// Additionally, it does not drop `src`. Semantically, `src` is moved into the\n /// location pointed to by `dst`.\n ///\n /// This is appropriate for initializing uninitialized memory, or overwriting\n-/// memory that has previously been `read` from.\n+/// memory that has previously been [`read`] from.\n+///\n+/// [`read`]: ./fn.read.html\n+///\n+/// # Safety\n+///\n+/// `write` is unsafe because it dereferences a raw pointer.\n+///\n+/// # [Undefined Behavior]\n+///\n+/// `write` can trigger undefined behavior if any of the following conditions\n+/// are violated:\n ///\n-/// The pointer must be aligned; use `write_unaligned` if that is not the case.\n+/// * `dst` must point to valid memory.\n+///\n+/// * `dst` must be properly aligned. Use [`write_unaligned`] if this is not the\n+///   case.\n+///\n+/// [Undefined Behavior]: ../../reference/behavior-considered-undefined.html\n+/// [`write_unaligned`]: ./fn.write_unaligned.html\n ///\n /// # Examples\n ///\n@@ -358,6 +557,30 @@ pub unsafe fn read_unaligned<T>(src: *const T) -> T {\n ///     assert_eq!(std::ptr::read(y), 12);\n /// }\n /// ```\n+///\n+/// Manually implement [`mem::swap`]:\n+///\n+/// ```\n+/// use std::ptr;\n+///\n+/// fn swap<T>(a: &mut T, b: &mut T) {\n+///     unsafe {\n+///         let tmp = ptr::read(a);\n+///         ptr::copy_nonoverlapping(b, a, 1);\n+///         ptr::write(b, tmp);\n+///     }\n+/// }\n+///\n+/// let mut foo = \"foo\".to_owned();\n+/// let mut bar = \"bar\".to_owned();\n+///\n+/// swap(&mut foo, &mut bar);\n+///\n+/// assert_eq!(foo, \"bar\");\n+/// assert_eq!(bar, \"foo\");\n+/// ```\n+///\n+/// [`mem::swap`]: ../mem/fn.swap.html\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn write<T>(dst: *mut T, src: T) {\n@@ -367,36 +590,65 @@ pub unsafe fn write<T>(dst: *mut T, src: T) {\n /// Overwrites a memory location with the given value without reading or\n /// dropping the old value.\n ///\n-/// Unlike `write`, the pointer may be unaligned.\n+/// Unlike [`write`], the pointer may be unaligned.\n ///\n-/// # Safety\n-///\n-/// This operation is marked unsafe because it accepts a raw pointer.\n-///\n-/// It does not drop the contents of `dst`. This is safe, but it could leak\n-/// allocations or resources, so care must be taken not to overwrite an object\n-/// that should be dropped.\n+/// `write_unaligned` does not drop the contents of `dst`. This is safe, but it\n+/// could leak allocations or resources, so care must be taken not to overwrite\n+/// an object that should be dropped.\n ///\n /// Additionally, it does not drop `src`. Semantically, `src` is moved into the\n /// location pointed to by `dst`.\n ///\n /// This is appropriate for initializing uninitialized memory, or overwriting\n-/// memory that has previously been `read` from.\n+/// memory that has previously been [`read`] from.\n+///\n+/// [`write`]: ./fn.write.html\n+/// [`read_unaligned`]: ./fn.read_unaligned.html\n+///\n+/// # Safety\n+///\n+/// `write_unaligned` is unsafe because it dereferences a raw pointer.\n+///\n+/// # [Undefined Behavior]\n+///\n+/// `write_unaligned` can trigger undefined behavior if any of the following\n+/// conditions are violated:\n+///\n+/// * `dst` must point to valid memory.\n+///\n+/// [Undefined Behavior]: ../../reference/behavior-considered-undefined.html\n ///\n /// # Examples\n ///\n-/// Basic usage:\n+/// Access fields in a packed struct:\n ///\n /// ```\n-/// let mut x = 0;\n-/// let y = &mut x as *mut i32;\n-/// let z = 12;\n+/// use std::{mem, ptr};\n+///\n+/// #[repr(packed, C)]\n+/// #[derive(Default)]\n+/// struct Packed {\n+///     _padding: u8,\n+///     unaligned: u32,\n+/// }\n+///\n+/// let v = 0x01020304;\n+/// let mut x: Packed = unsafe { mem::zeroed() };\n ///\n /// unsafe {\n-///     std::ptr::write_unaligned(y, z);\n-///     assert_eq!(std::ptr::read_unaligned(y), 12);\n+///     // Take a reference to a 32-bit integer which is not aligned.\n+///     let unaligned = &mut x.unaligned;\n+///\n+///     // Dereferencing normally will emit an unaligned store instruction,\n+///     // causing undefined behavior.\n+///     // *unaligned = v; // ERROR\n+///\n+///     // Instead, use `write_unaligned` to write improperly aligned values.\n+///     ptr::write_unaligned(unaligned, v);\n /// }\n-/// ```\n+///\n+/// // Accessing unaligned values directly is safe.\n+/// assert!(x.unaligned == v);\n #[inline]\n #[stable(feature = \"ptr_unaligned\", since = \"1.17.0\")]\n pub unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n@@ -429,12 +681,28 @@ pub unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n ///\n /// # Safety\n ///\n-/// Beyond accepting a raw pointer, this is unsafe because it semantically\n-/// moves the value out of `src` without preventing further usage of `src`.\n-/// If `T` is not `Copy`, then care must be taken to ensure that the value at\n-/// `src` is not used before the data is overwritten again (e.g. with `write`,\n-/// `write_bytes`, or `copy`). Note that `*src = foo` counts as a use\n-/// because it will attempt to drop the value previously at `*src`.\n+/// `read_volatile` is unsafe because it dereferences a raw pointer. The caller\n+/// must ensure that the pointer points to a valid value of type `T`.\n+///\n+/// # [Undefined Behavior]\n+///\n+/// Behavior is undefined if any of the following conditions are violated:\n+///\n+/// * `src` must point to valid, initialized memory.\n+///\n+/// * `src` must be properly aligned.\n+///\n+/// Additionally, if `T` is not [`Copy`], only the returned value *or* the\n+/// pointed-to value can be used or dropped after calling `read_volatile`.\n+/// `read_volatile` creates a bitwise copy of `T`, regardless of whether `T:\n+/// Copy`, which can result in undefined behavior if both copies are used.\n+/// Note that `*src = foo` counts as a use because it will attempt to drop the\n+/// value previously at `*src`. [`write_volatile`] can be used to overwrite\n+/// data without causing it to be dropped.\n+///\n+/// [`Copy`]: ../marker/trait.Copy.html\n+/// [`write_volatile`]: ./fn.write_volatile.html\n+/// [Undefined Behavior]: ../../reference/behavior-considered-undefined.html\n ///\n /// # Examples\n ///\n@@ -461,6 +729,13 @@ pub unsafe fn read_volatile<T>(src: *const T) -> T {\n /// to not be elided or reordered by the compiler across other volatile\n /// operations.\n ///\n+/// `write_volatile` does not drop the contents of `dst`. This is safe, but it\n+/// could leak allocations or resources, so care must be taken not to overwrite\n+/// an object that should be dropped.\n+///\n+/// Additionally, it does not drop `src`. Semantically, `src` is moved into the\n+/// location pointed to by `dst`.\n+///\n /// # Notes\n ///\n /// Rust does not currently have a rigorously and formally defined memory model,\n@@ -477,14 +752,18 @@ pub unsafe fn read_volatile<T>(src: *const T) -> T {\n ///\n /// # Safety\n ///\n-/// This operation is marked unsafe because it accepts a raw pointer.\n+/// `write_volatile` is unsafe because it dereferences a raw pointer.\n ///\n-/// It does not drop the contents of `dst`. This is safe, but it could leak\n-/// allocations or resources, so care must be taken not to overwrite an object\n-/// that should be dropped.\n+/// # [Undefined Behavior]\n ///\n-/// This is appropriate for initializing uninitialized memory, or overwriting\n-/// memory that has previously been `read` from.\n+/// `write_volatile` can trigger undefined behavior if any of the following\n+/// conditions are violated:\n+///\n+/// * `dst` must point to valid memory.\n+///\n+/// * `dst` must be properly aligned.\n+///\n+/// [Undefined Behavior]: ../../reference/behavior-considered-undefined.html\n ///\n /// # Examples\n ///"}]}