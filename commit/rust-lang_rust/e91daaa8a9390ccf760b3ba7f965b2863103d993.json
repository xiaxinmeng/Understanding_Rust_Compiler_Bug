{"sha": "e91daaa8a9390ccf760b3ba7f965b2863103d993", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5MWRhYWE4YTkzOTBjY2Y3NjBiM2JhN2Y5NjViMjg2MzEwM2Q5OTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-18T07:34:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-18T07:34:24Z"}, "message": "auto merge of #6586 : bjz/rust/formatting-and-conditionals, r=thestinger", "tree": {"sha": "20d6c2af3206bfa8347c175624aea75d47aa078a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/20d6c2af3206bfa8347c175624aea75d47aa078a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e91daaa8a9390ccf760b3ba7f965b2863103d993", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e91daaa8a9390ccf760b3ba7f965b2863103d993", "html_url": "https://github.com/rust-lang/rust/commit/e91daaa8a9390ccf760b3ba7f965b2863103d993", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e91daaa8a9390ccf760b3ba7f965b2863103d993/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac74bbec9327ef393041feb544d2468131e1759e", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac74bbec9327ef393041feb544d2468131e1759e", "html_url": "https://github.com/rust-lang/rust/commit/ac74bbec9327ef393041feb544d2468131e1759e"}, {"sha": "ad6ee5f4e5f779d987ac7a35ce6f149039a45b15", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad6ee5f4e5f779d987ac7a35ce6f149039a45b15", "html_url": "https://github.com/rust-lang/rust/commit/ad6ee5f4e5f779d987ac7a35ce6f149039a45b15"}], "stats": {"total": 538, "additions": 284, "deletions": 254}, "files": [{"sha": "b3c0b8cad7a4e4ba9d8aaa4d780e6cc89231442f", "filename": "src/libcore/bool.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e91daaa8a9390ccf760b3ba7f965b2863103d993/src%2Flibcore%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e91daaa8a9390ccf760b3ba7f965b2863103d993/src%2Flibcore%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbool.rs?ref=e91daaa8a9390ccf760b3ba7f965b2863103d993", "patch": "@@ -49,12 +49,10 @@ pub fn is_false(v: bool) -> bool { !v }\n /// Parse logic value from `s`\n impl FromStr for bool {\n     fn from_str(s: &str) -> Option<bool> {\n-        if s == \"true\" {\n-            Some(true)\n-        } else if s == \"false\" {\n-            Some(false)\n-        } else {\n-            None\n+        match s {\n+            \"true\"  => Some(true),\n+            \"false\" => Some(false),\n+            _       => None,\n         }\n     }\n }"}, {"sha": "ca9c49b2c0682a90c3baa3ca28b9d33e44a0b619", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e91daaa8a9390ccf760b3ba7f965b2863103d993/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e91daaa8a9390ccf760b3ba7f965b2863103d993/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=e91daaa8a9390ccf760b3ba7f965b2863103d993", "patch": "@@ -127,12 +127,11 @@ totalord_impl!(uint)\n \n totalord_impl!(char)\n \n+/// Compares (a1, b1) against (a2, b2), where the a values are more significant.\n pub fn cmp2<A:TotalOrd,B:TotalOrd>(\n     a1: &A, b1: &B,\n     a2: &A, b2: &B) -> Ordering\n {\n-    //! Compares (a1, b1) against (a2, b2), where the a values are more significant.\n-\n     match a1.cmp(a2) {\n         Less => Less,\n         Greater => Greater,"}, {"sha": "f89bb3b2f90646c993d6e40ce9fb690d7c873a4a", "filename": "src/libcore/either.rs", "status": "modified", "additions": 38, "deletions": 50, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/e91daaa8a9390ccf760b3ba7f965b2863103d993/src%2Flibcore%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e91daaa8a9390ccf760b3ba7f965b2863103d993/src%2Flibcore%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Feither.rs?ref=e91daaa8a9390ccf760b3ba7f965b2863103d993", "patch": "@@ -26,26 +26,22 @@ pub enum Either<T, U> {\n     Right(U)\n }\n \n+/// Applies a function based on the given either value\n+///\n+/// If `value` is left(T) then `f_left` is applied to its contents, if\n+/// `value` is right(U) then `f_right` is applied to its contents, and the\n+/// result is returned.\n #[inline(always)]\n pub fn either<T, U, V>(f_left: &fn(&T) -> V,\n                        f_right: &fn(&U) -> V, value: &Either<T, U>) -> V {\n-    /*!\n-     * Applies a function based on the given either value\n-     *\n-     * If `value` is left(T) then `f_left` is applied to its contents, if\n-     * `value` is right(U) then `f_right` is applied to its contents, and the\n-     * result is returned.\n-     */\n-\n     match *value {\n-      Left(ref l) => f_left(l),\n-      Right(ref r) => f_right(r)\n+        Left(ref l) => f_left(l),\n+        Right(ref r) => f_right(r)\n     }\n }\n \n+/// Extracts from a vector of either all the left values\n pub fn lefts<T:Copy,U>(eithers: &[Either<T, U>]) -> ~[T] {\n-    //! Extracts from a vector of either all the left values\n-\n     do vec::build_sized(eithers.len()) |push| {\n         for eithers.each |elt| {\n             match *elt {\n@@ -56,9 +52,8 @@ pub fn lefts<T:Copy,U>(eithers: &[Either<T, U>]) -> ~[T] {\n     }\n }\n \n+/// Extracts from a vector of either all the right values\n pub fn rights<T, U: Copy>(eithers: &[Either<T, U>]) -> ~[U] {\n-    //! Extracts from a vector of either all the right values\n-\n     do vec::build_sized(eithers.len()) |push| {\n         for eithers.each |elt| {\n             match *elt {\n@@ -69,80 +64,73 @@ pub fn rights<T, U: Copy>(eithers: &[Either<T, U>]) -> ~[U] {\n     }\n }\n \n-pub fn partition<T, U>(eithers: ~[Either<T, U>])\n-    -> (~[T], ~[U]) {\n-    /*!\n-     * Extracts from a vector of either all the left values and right values\n-     *\n-     * Returns a structure containing a vector of left values and a vector of\n-     * right values.\n-     */\n-\n+/// Extracts from a vector of either all the left values and right values\n+///\n+/// Returns a structure containing a vector of left values and a vector of\n+/// right values.\n+pub fn partition<T, U>(eithers: ~[Either<T, U>]) -> (~[T], ~[U]) {\n     let mut lefts: ~[T] = ~[];\n     let mut rights: ~[U] = ~[];\n     do vec::consume(eithers) |_i, elt| {\n         match elt {\n-          Left(l) => lefts.push(l),\n-          Right(r) => rights.push(r)\n+            Left(l) => lefts.push(l),\n+            Right(r) => rights.push(r)\n         }\n     }\n     return (lefts, rights);\n }\n \n+/// Flips between left and right of a given either\n #[inline(always)]\n pub fn flip<T, U>(eith: Either<T, U>) -> Either<U, T> {\n-    //! Flips between left and right of a given either\n-\n     match eith {\n-      Right(r) => Left(r),\n-      Left(l) => Right(l)\n+        Right(r) => Left(r),\n+        Left(l) => Right(l)\n     }\n }\n \n+/// Converts either::t to a result::t\n+///\n+/// Converts an `either` type to a `result` type, making the \"right\" choice\n+/// an ok result, and the \"left\" choice a fail\n #[inline(always)]\n-pub fn to_result<T, U>(eith: Either<T, U>)\n-    -> Result<U, T> {\n-    /*!\n-     * Converts either::t to a result::t\n-     *\n-     * Converts an `either` type to a `result` type, making the \"right\" choice\n-     * an ok result, and the \"left\" choice a fail\n-     */\n-\n+pub fn to_result<T, U>(eith: Either<T, U>) -> Result<U, T> {\n     match eith {\n-      Right(r) => result::Ok(r),\n-      Left(l) => result::Err(l)\n+        Right(r) => result::Ok(r),\n+        Left(l) => result::Err(l)\n     }\n }\n \n+/// Checks whether the given value is a left\n #[inline(always)]\n pub fn is_left<T, U>(eith: &Either<T, U>) -> bool {\n-    //! Checks whether the given value is a left\n-\n-    match *eith { Left(_) => true, _ => false }\n+    match *eith {\n+        Left(_) => true,\n+        _ => false\n+    }\n }\n \n+/// Checks whether the given value is a right\n #[inline(always)]\n pub fn is_right<T, U>(eith: &Either<T, U>) -> bool {\n-    //! Checks whether the given value is a right\n-\n-    match *eith { Right(_) => true, _ => false }\n+    match *eith {\n+        Right(_) => true,\n+        _ => false\n+    }\n }\n \n+/// Retrieves the value in the left branch. Fails if the either is Right.\n #[inline(always)]\n pub fn unwrap_left<T,U>(eith: Either<T,U>) -> T {\n-    //! Retrieves the value in the left branch. Fails if the either is Right.\n-\n     match eith {\n         Left(x) => x,\n         Right(_) => fail!(\"either::unwrap_left Right\")\n     }\n }\n \n+/// Retrieves the value in the right branch. Fails if the either is Left.\n #[inline(always)]\n pub fn unwrap_right<T,U>(eith: Either<T,U>) -> U {\n-    //! Retrieves the value in the right branch. Fails if the either is Left.\n-\n     match eith {\n         Right(x) => x,\n         Left(_) => fail!(\"either::unwrap_right Left\")"}, {"sha": "ecde1eb19179d3f0a03652a2786837f6ba282698", "filename": "src/libcore/managed.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e91daaa8a9390ccf760b3ba7f965b2863103d993/src%2Flibcore%2Fmanaged.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e91daaa8a9390ccf760b3ba7f965b2863103d993/src%2Flibcore%2Fmanaged.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmanaged.rs?ref=e91daaa8a9390ccf760b3ba7f965b2863103d993", "patch": "@@ -35,16 +35,16 @@ pub mod raw {\n \n }\n \n+/// Determine if two shared boxes point to the same object\n #[inline(always)]\n pub fn ptr_eq<T>(a: @T, b: @T) -> bool {\n-    //! Determine if two shared boxes point to the same object\n     let a_ptr: *T = to_unsafe_ptr(&*a), b_ptr: *T = to_unsafe_ptr(&*b);\n     a_ptr == b_ptr\n }\n \n+/// Determine if two mutable shared boxes point to the same object\n #[inline(always)]\n pub fn mut_ptr_eq<T>(a: @mut T, b: @mut T) -> bool {\n-    //! Determine if two mutable shared boxes point to the same object\n     let a_ptr: *T = to_unsafe_ptr(&*a), b_ptr: *T = to_unsafe_ptr(&*b);\n     a_ptr == b_ptr\n }"}, {"sha": "d580f7aa26c99bc4bc12d9ee579c8f8f0e9ca2d8", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e91daaa8a9390ccf760b3ba7f965b2863103d993/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e91daaa8a9390ccf760b3ba7f965b2863103d993/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=e91daaa8a9390ccf760b3ba7f965b2863103d993", "patch": "@@ -248,15 +248,27 @@ impl Orderable for f32 {\n         if self.is_NaN() || other.is_NaN() { Float::NaN() } else { fmax(*self, *other) }\n     }\n \n-    /// Returns the number constrained within the range `mn <= self <= mx`.\n-    /// If any of the numbers are `NaN` then `NaN` is returned.\n+    #[cfg(stage0)]\n     #[inline(always)]\n     fn clamp(&self, mn: &f32, mx: &f32) -> f32 {\n         if self.is_NaN() { *self }\n         else if !(*self <= *mx) { *mx }\n         else if !(*self >= *mn) { *mn }\n         else { *self }\n     }\n+\n+    /// Returns the number constrained within the range `mn <= self <= mx`.\n+    /// If any of the numbers are `NaN` then `NaN` is returned.\n+    #[cfg(not(stage0))]\n+    #[inline(always)]\n+    fn clamp(&self, mn: &f32, mx: &f32) -> f32 {\n+        cond!(\n+            (self.is_NaN())   { *self }\n+            (!(*self <= *mx)) { *mx   }\n+            (!(*self >= *mn)) { *mn   }\n+            _                 { *self }\n+        )\n+    }\n }\n \n impl Zero for f32 {"}, {"sha": "d140df30c4273c1448b5469e905a40b0abb34ee8", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e91daaa8a9390ccf760b3ba7f965b2863103d993/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e91daaa8a9390ccf760b3ba7f965b2863103d993/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=e91daaa8a9390ccf760b3ba7f965b2863103d993", "patch": "@@ -270,15 +270,27 @@ impl Orderable for f64 {\n         if self.is_NaN() || other.is_NaN() { Float::NaN() } else { fmax(*self, *other) }\n     }\n \n-    /// Returns the number constrained within the range `mn <= self <= mx`.\n-    /// If any of the numbers are `NaN` then `NaN` is returned.\n+    #[cfg(stage0)]\n     #[inline(always)]\n     fn clamp(&self, mn: &f64, mx: &f64) -> f64 {\n         if self.is_NaN() { *self }\n         else if !(*self <= *mx) { *mx }\n         else if !(*self >= *mn) { *mn }\n         else { *self }\n     }\n+\n+    /// Returns the number constrained within the range `mn <= self <= mx`.\n+    /// If any of the numbers are `NaN` then `NaN` is returned.\n+    #[cfg(not(stage0))]\n+    #[inline(always)]\n+    fn clamp(&self, mn: &f64, mx: &f64) -> f64 {\n+        cond!(\n+            (self.is_NaN())   { *self }\n+            (!(*self <= *mx)) { *mx   }\n+            (!(*self >= *mn)) { *mn   }\n+            _                 { *self }\n+        )\n+    }\n }\n \n impl Zero for f64 {"}, {"sha": "d0e6174ec637d75828117d6726c61d7a4de287d7", "filename": "src/libcore/num/int-template.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e91daaa8a9390ccf760b3ba7f965b2863103d993/src%2Flibcore%2Fnum%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e91daaa8a9390ccf760b3ba7f965b2863103d993/src%2Flibcore%2Fnum%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template.rs?ref=e91daaa8a9390ccf760b3ba7f965b2863103d993", "patch": "@@ -187,11 +187,23 @@ impl Orderable for T {\n         if *self > *other { *self } else { *other }\n     }\n \n+    #[cfg(stage0)]\n     #[inline(always)]\n     fn clamp(&self, mn: &T, mx: &T) -> T {\n         if *self > *mx { *mx } else\n         if *self < *mn { *mn } else { *self }\n     }\n+\n+    /// Returns the number constrained within the range `mn <= self <= mx`.\n+    #[cfg(not(stage0))]\n+    #[inline(always)]\n+    fn clamp(&self, mn: &T, mx: &T) -> T {\n+        cond!(\n+            (*self > *mx) { *mx   }\n+            (*self < *mn) { *mn   }\n+            _             { *self }\n+        )\n+    }\n }\n \n impl Zero for T {"}, {"sha": "f3e140945057cc630725c93dc287062d2e0e199f", "filename": "src/libcore/num/uint-template.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e91daaa8a9390ccf760b3ba7f965b2863103d993/src%2Flibcore%2Fnum%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e91daaa8a9390ccf760b3ba7f965b2863103d993/src%2Flibcore%2Fnum%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template.rs?ref=e91daaa8a9390ccf760b3ba7f965b2863103d993", "patch": "@@ -153,11 +153,23 @@ impl Orderable for T {\n         if *self > *other { *self } else { *other }\n     }\n \n+    #[cfg(stage0)]\n     #[inline(always)]\n     fn clamp(&self, mn: &T, mx: &T) -> T {\n         if *self > *mx { *mx } else\n         if *self < *mn { *mn } else { *self }\n     }\n+\n+    /// Returns the number constrained within the range `mn <= self <= mx`.\n+    #[cfg(not(stage0))]\n+    #[inline(always)]\n+    fn clamp(&self, mn: &T, mx: &T) -> T {\n+        cond!(\n+            (*self > *mx) { *mx   }\n+            (*self < *mn) { *mn   }\n+            _             { *self }\n+        )\n+    }\n }\n \n impl Zero for T {"}, {"sha": "0212d4abd29d6955b0a67e9c0bcf64ff2684d24f", "filename": "src/libcore/option.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e91daaa8a9390ccf760b3ba7f965b2863103d993/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e91daaa8a9390ccf760b3ba7f965b2863103d993/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=e91daaa8a9390ccf760b3ba7f965b2863103d993", "patch": "@@ -89,11 +89,11 @@ impl<T:Ord> Ord for Option<T> {\n     }\n \n     fn ge(&self, other: &Option<T>) -> bool {\n-        ! (self < other)\n+        !(self < other)\n     }\n \n     fn gt(&self, other: &Option<T>) -> bool {\n-        ! (self <= other)\n+        !(self <= other)\n     }\n }\n \n@@ -182,34 +182,28 @@ pub impl<T> Option<T> {\n     #[inline(always)]\n     fn is_some(&const self) -> bool { !self.is_none() }\n \n+    /// Update an optional value by optionally running its content through a\n+    /// function that returns an option.\n     #[inline(always)]\n     fn chain<U>(self, f: &fn(t: T) -> Option<U>) -> Option<U> {\n-        /*!\n-         * Update an optional value by optionally running its content through a\n-         * function that returns an option.\n-         */\n \n         match self {\n             Some(t) => f(t),\n             None => None\n         }\n     }\n \n+    /// Returns the leftmost Some() value, or None if both are None.\n     #[inline(always)]\n     fn or(self, optb: Option<T>) -> Option<T> {\n-        /*!\n-         * Returns the leftmost Some() value, or None if both are None.\n-         */\n         match self {\n             Some(opta) => Some(opta),\n             _ => optb\n         }\n     }\n \n-    /**\n-     * Update an optional value by optionally running its content by reference\n-     * through a function that returns an option.\n-     */\n+    /// Update an optional value by optionally running its content by reference\n+    /// through a function that returns an option.\n     #[inline(always)]\n     fn chain_ref<'a, U>(&'a self, f: &fn(x: &'a T) -> Option<U>) -> Option<U> {\n         match *self { Some(ref x) => f(x), None => None }"}, {"sha": "8a5d9c0416d07d4f4ff060885f284425ecccbe7f", "filename": "src/libcore/path.rs", "status": "modified", "additions": 119, "deletions": 126, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/e91daaa8a9390ccf760b3ba7f965b2863103d993/src%2Flibcore%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e91daaa8a9390ccf760b3ba7f965b2863103d993/src%2Flibcore%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpath.rs?ref=e91daaa8a9390ccf760b3ba7f965b2863103d993", "patch": "@@ -311,9 +311,10 @@ pub impl Path {\n         unsafe {\n              do str::as_c_str(self.to_str()) |buf| {\n                 let mut st = stat::arch::default_stat();\n-                let r = libc::stat(buf, &mut st);\n-\n-                if r == 0 { Some(st) } else { None }\n+                match libc::stat(buf, &mut st) {\n+                    0 => Some(st),\n+                    _ => None,\n+                }\n             }\n         }\n     }\n@@ -323,9 +324,10 @@ pub impl Path {\n         unsafe {\n             do str::as_c_str(self.to_str()) |buf| {\n                 let mut st = stat::arch::default_stat();\n-                let r = libc::lstat(buf, &mut st);\n-\n-                if r == 0 { Some(st) } else { None }\n+                match libc::lstat(buf, &mut st) {\n+                    0 => Some(st),\n+                    _ => None,\n+                }\n             }\n         }\n     }\n@@ -450,55 +452,56 @@ impl GenericPath for PosixPath {\n             components.push(s.to_owned())\n         }\n         let is_absolute = (s.len() != 0 && s[0] == '/' as u8);\n-        return PosixPath { is_absolute: is_absolute,\n-                           components: components }\n+        PosixPath {\n+            is_absolute: is_absolute,\n+            components: components,\n+        }\n     }\n \n     fn dirname(&self) -> ~str {\n         let s = self.dir_path().to_str();\n-        if s.len() == 0 {\n-            ~\".\"\n-        } else {\n-            s\n+        match s.len() {\n+            0 => ~\".\",\n+            _ => s,\n         }\n     }\n \n     fn filename(&self) -> Option<~str> {\n         match self.components.len() {\n-          0 => None,\n-          n => Some(copy self.components[n - 1])\n+            0 => None,\n+            n => Some(copy self.components[n - 1]),\n         }\n     }\n \n     fn filestem(&self) -> Option<~str> {\n         match self.filename() {\n-          None => None,\n-          Some(ref f) => {\n-            match str::rfind_char(*f, '.') {\n-              Some(p) => Some(f.slice(0, p).to_owned()),\n-              None => Some(copy *f)\n+            None => None,\n+            Some(ref f) => {\n+                match str::rfind_char(*f, '.') {\n+                    Some(p) => Some(f.slice(0, p).to_owned()),\n+                    None => Some(copy *f),\n+                }\n             }\n-          }\n         }\n     }\n \n     fn filetype(&self) -> Option<~str> {\n         match self.filename() {\n-          None => None,\n-          Some(ref f) => {\n-            match str::rfind_char(*f, '.') {\n-              Some(p) if p < f.len() => Some(f.slice(p, f.len()).to_owned()),\n-              _ => None\n+            None => None,\n+            Some(ref f) => {\n+                match str::rfind_char(*f, '.') {\n+                    Some(p) if p < f.len() => Some(f.slice(p, f.len()).to_owned()),\n+                    _ => None,\n+                }\n             }\n-          }\n         }\n     }\n \n     fn with_dirname(&self, d: &str) -> PosixPath {\n         let dpath = PosixPath(d);\n         match self.filename() {\n-          Some(ref f) => dpath.push(*f),\n-          None => dpath\n+            Some(ref f) => dpath.push(*f),\n+            None => dpath,\n         }\n     }\n \n@@ -509,31 +512,24 @@ impl GenericPath for PosixPath {\n \n     fn with_filestem(&self, s: &str) -> PosixPath {\n         match self.filetype() {\n-          None => self.with_filename(s),\n-          Some(ref t) => self.with_filename(str::to_owned(s) + *t)\n+            None => self.with_filename(s),\n+            Some(ref t) => self.with_filename(str::to_owned(s) + *t),\n         }\n     }\n \n     fn with_filetype(&self, t: &str) -> PosixPath {\n-        if t.len() == 0 {\n-            match self.filestem() {\n-              None => copy *self,\n-              Some(ref s) => self.with_filename(*s)\n-            }\n-        } else {\n-            let t = ~\".\" + str::to_owned(t);\n-            match self.filestem() {\n-              None => self.with_filename(t),\n-              Some(ref s) => self.with_filename(*s + t)\n-            }\n+        match (t.len(), self.filestem()) {\n+            (0, None)        => copy *self,\n+            (0, Some(ref s)) => self.with_filename(*s),\n+            (_, None)        => self.with_filename(fmt!(\".%s\", t)),\n+            (_, Some(ref s)) => self.with_filename(fmt!(\"%s.%s\", *s, t)),\n         }\n     }\n \n     fn dir_path(&self) -> PosixPath {\n-        if self.components.len() != 0 {\n-            self.pop()\n-        } else {\n-            copy *self\n+        match self.components.len() {\n+            0 => copy *self,\n+            _ => self.pop(),\n         }\n     }\n \n@@ -542,8 +538,10 @@ impl GenericPath for PosixPath {\n           None => ~[],\n           Some(ref f) => ~[copy *f]\n         };\n-        return PosixPath { is_absolute: false,\n-                           components: cs }\n+        PosixPath {\n+            is_absolute: false,\n+            components: cs,\n+        }\n     }\n \n     fn push_rel(&self, other: &PosixPath) -> PosixPath {\n@@ -553,8 +551,10 @@ impl GenericPath for PosixPath {\n \n     fn unsafe_join(&self, other: &PosixPath) -> PosixPath {\n         if other.is_absolute {\n-            PosixPath { is_absolute: true,\n-                        components: copy other.components }\n+            PosixPath {\n+                is_absolute: true,\n+                components: copy other.components,\n+            }\n         } else {\n             self.push_rel(other)\n         }\n@@ -573,8 +573,10 @@ impl GenericPath for PosixPath {\n             }\n             v.push_all_move(ss);\n         }\n-        PosixPath { is_absolute: self.is_absolute,\n-                    components: v }\n+        PosixPath {\n+            is_absolute: self.is_absolute,\n+            components: v,\n+        }\n     }\n \n     fn push(&self, s: &str) -> PosixPath {\n@@ -592,19 +594,17 @@ impl GenericPath for PosixPath {\n         if cs.len() != 0 {\n             cs.pop();\n         }\n-        return PosixPath {\n+        PosixPath {\n             is_absolute: self.is_absolute,\n-            components: cs\n-        }\n-                          //..self }\n+            components: cs,\n+        } //..self }\n     }\n \n     fn normalize(&self) -> PosixPath {\n-        return PosixPath {\n+        PosixPath {\n             is_absolute: self.is_absolute,\n-            components: normalize(self.components)\n-          //  ..self\n-        }\n+            components: normalize(self.components),\n+        } // ..self }\n     }\n \n     fn is_absolute(&self) -> bool {\n@@ -638,64 +638,64 @@ impl GenericPath for WindowsPath {\n         let device;\n         let rest;\n \n-        match windows::extract_drive_prefix(s) {\n-          Some((ref d, ref r)) => {\n-            host = None;\n-            device = Some(copy *d);\n-            rest = copy *r;\n-          }\n-          None => {\n-            match windows::extract_unc_prefix(s) {\n-              Some((ref h, ref r)) => {\n+        match (\n+            windows::extract_drive_prefix(s),\n+            windows::extract_unc_prefix(s),\n+        ) {\n+            (Some((ref d, ref r)), _) => {\n+                host = None;\n+                device = Some(copy *d);\n+                rest = copy *r;\n+            }\n+            (None, Some((ref h, ref r))) => {\n                 host = Some(copy *h);\n                 device = None;\n                 rest = copy *r;\n-              }\n-              None => {\n+            }\n+            (None, None) => {\n                 host = None;\n                 device = None;\n                 rest = str::to_owned(s);\n-              }\n             }\n-          }\n         }\n \n         let mut components = ~[];\n         for str::each_split_nonempty(rest, |c| windows::is_sep(c as u8)) |s| {\n             components.push(s.to_owned())\n         }\n         let is_absolute = (rest.len() != 0 && windows::is_sep(rest[0]));\n-        return WindowsPath { host: host,\n-                             device: device,\n-                             is_absolute: is_absolute,\n-                             components: components }\n+        WindowsPath {\n+            host: host,\n+            device: device,\n+            is_absolute: is_absolute,\n+            components: components,\n+        }\n     }\n \n     fn dirname(&self) -> ~str {\n         let s = self.dir_path().to_str();\n-        if s.len() == 0 {\n-            ~\".\"\n-        } else {\n-            s\n+        match s.len() {\n+            0 => ~\".\",\n+            _ => s,\n         }\n     }\n \n     fn filename(&self) -> Option<~str> {\n         match self.components.len() {\n-          0 => None,\n-          n => Some(copy self.components[n - 1])\n+            0 => None,\n+            n => Some(copy self.components[n - 1]),\n         }\n     }\n \n     fn filestem(&self) -> Option<~str> {\n         match self.filename() {\n-          None => None,\n-          Some(ref f) => {\n-            match str::rfind_char(*f, '.') {\n-              Some(p) => Some(f.slice(0, p).to_owned()),\n-              None => Some(copy *f)\n+            None => None,\n+            Some(ref f) => {\n+                match str::rfind_char(*f, '.') {\n+                    Some(p) => Some(f.slice(0, p).to_owned()),\n+                    None => Some(copy *f),\n+                }\n             }\n-          }\n         }\n     }\n \n@@ -704,8 +704,8 @@ impl GenericPath for WindowsPath {\n           None => None,\n           Some(ref f) => {\n             match str::rfind_char(*f, '.') {\n-              Some(p) if p < f.len() => Some(f.slice(p, f.len()).to_owned()),\n-              _ => None\n+                Some(p) if p < f.len() => Some(f.slice(p, f.len()).to_owned()),\n+                _ => None,\n             }\n           }\n         }\n@@ -714,8 +714,8 @@ impl GenericPath for WindowsPath {\n     fn with_dirname(&self, d: &str) -> WindowsPath {\n         let dpath = WindowsPath(d);\n         match self.filename() {\n-          Some(ref f) => dpath.push(*f),\n-          None => dpath\n+            Some(ref f) => dpath.push(*f),\n+            None => dpath,\n         }\n     }\n \n@@ -726,44 +726,37 @@ impl GenericPath for WindowsPath {\n \n     fn with_filestem(&self, s: &str) -> WindowsPath {\n         match self.filetype() {\n-          None => self.with_filename(s),\n-          Some(ref t) => self.with_filename(str::to_owned(s) + *t)\n+            None => self.with_filename(s),\n+            Some(ref t) => self.with_filename(str::to_owned(s) + *t),\n         }\n     }\n \n     fn with_filetype(&self, t: &str) -> WindowsPath {\n-        if t.len() == 0 {\n-            match self.filestem() {\n-              None => copy *self,\n-              Some(ref s) => self.with_filename(*s)\n-            }\n-        } else {\n-            let t = ~\".\" + str::to_owned(t);\n-            match self.filestem() {\n-              None => self.with_filename(t),\n-              Some(ref s) =>\n-              self.with_filename(*s + t)\n-            }\n+        match (t.len(), self.filestem()) {\n+            (0, None)        => copy *self,\n+            (0, Some(ref s)) => self.with_filename(*s),\n+            (_, None)        => self.with_filename(fmt!(\".%s\", t)),\n+            (_, Some(ref s)) => self.with_filename(fmt!(\"%s.%s\", *s, t)),\n         }\n     }\n \n     fn dir_path(&self) -> WindowsPath {\n-        if self.components.len() != 0 {\n-            self.pop()\n-        } else {\n-            copy *self\n+        match self.components.len() {\n+            0 => copy *self,\n+            _ => self.pop(),\n         }\n     }\n \n     fn file_path(&self) -> WindowsPath {\n-        let cs = match self.filename() {\n-          None => ~[],\n-          Some(ref f) => ~[copy *f]\n-        };\n-        return WindowsPath { host: None,\n-                             device: None,\n-                             is_absolute: false,\n-                             components: cs }\n+        WindowsPath {\n+            host: None,\n+            device: None,\n+            is_absolute: false,\n+            components: match self.filename() {\n+                None => ~[],\n+                Some(ref f) => ~[copy *f],\n+            }\n+        }\n     }\n \n     fn push_rel(&self, other: &WindowsPath) -> WindowsPath {\n@@ -784,7 +777,7 @@ impl GenericPath for WindowsPath {\n                     host: Some(host),\n                     device: copy other.device,\n                     is_absolute: true,\n-                    components: copy other.components\n+                    components: copy other.components,\n                 };\n             }\n             _ => {}\n@@ -797,7 +790,7 @@ impl GenericPath for WindowsPath {\n                     host: None,\n                     device: Some(device),\n                     is_absolute: true,\n-                    components: copy other.components\n+                    components: copy other.components,\n                 };\n             }\n             _ => {}\n@@ -809,7 +802,7 @@ impl GenericPath for WindowsPath {\n             host: copy self.host,\n             device: copy self.device,\n             is_absolute: self.is_absolute || other.is_absolute,\n-            components: copy other.components\n+            components: copy other.components,\n         }\n     }\n \n@@ -838,7 +831,7 @@ impl GenericPath for WindowsPath {\n             v.push_all_move(ss);\n         }\n         // tedious, but as-is, we can't use ..self\n-        return WindowsPath {\n+        WindowsPath {\n             host: copy self.host,\n             device: copy self.device,\n             is_absolute: self.is_absolute,\n@@ -853,24 +846,24 @@ impl GenericPath for WindowsPath {\n             ss.push(s.to_owned())\n         }\n         v.push_all_move(ss);\n-        return WindowsPath { components: v, ..copy *self }\n+        WindowsPath { components: v, ..copy *self }\n     }\n \n     fn pop(&self) -> WindowsPath {\n         let mut cs = copy self.components;\n         if cs.len() != 0 {\n             cs.pop();\n         }\n-        return WindowsPath {\n+        WindowsPath {\n             host: copy self.host,\n             device: copy self.device,\n             is_absolute: self.is_absolute,\n-            components: cs\n+            components: cs,\n         }\n     }\n \n     fn normalize(&self) -> WindowsPath {\n-        return WindowsPath {\n+        WindowsPath {\n             host: copy self.host,\n             device: match self.device {\n                 None => None,"}, {"sha": "59f769fd92d42e0de142dc9d3e61bab3a6f539f8", "filename": "src/libcore/str.rs", "status": "modified", "additions": 35, "deletions": 49, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/e91daaa8a9390ccf760b3ba7f965b2863103d993/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e91daaa8a9390ccf760b3ba7f965b2863103d993/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=e91daaa8a9390ccf760b3ba7f965b2863103d993", "patch": "@@ -128,57 +128,43 @@ pub fn push_char(s: &mut ~str, ch: char) {\n         let off = len;\n         do as_buf(*s) |buf, _len| {\n             let buf: *mut u8 = ::cast::transmute(buf);\n-            if nb == 1u {\n-                *ptr::mut_offset(buf, off) =\n-                    code as u8;\n-            } else if nb == 2u {\n-                *ptr::mut_offset(buf, off) =\n-                    (code >> 6u & 31u | tag_two_b) as u8;\n-                *ptr::mut_offset(buf, off + 1u) =\n-                    (code & 63u | tag_cont) as u8;\n-            } else if nb == 3u {\n-                *ptr::mut_offset(buf, off) =\n-                    (code >> 12u & 15u | tag_three_b) as u8;\n-                *ptr::mut_offset(buf, off + 1u) =\n-                    (code >> 6u & 63u | tag_cont) as u8;\n-                *ptr::mut_offset(buf, off + 2u) =\n-                    (code & 63u | tag_cont) as u8;\n-            } else if nb == 4u {\n-                *ptr::mut_offset(buf, off) =\n-                    (code >> 18u & 7u | tag_four_b) as u8;\n-                *ptr::mut_offset(buf, off + 1u) =\n-                    (code >> 12u & 63u | tag_cont) as u8;\n-                *ptr::mut_offset(buf, off + 2u) =\n-                    (code >> 6u & 63u | tag_cont) as u8;\n-                *ptr::mut_offset(buf, off + 3u) =\n-                    (code & 63u | tag_cont) as u8;\n-            } else if nb == 5u {\n-                *ptr::mut_offset(buf, off) =\n-                    (code >> 24u & 3u | tag_five_b) as u8;\n-                *ptr::mut_offset(buf, off + 1u) =\n-                    (code >> 18u & 63u | tag_cont) as u8;\n-                *ptr::mut_offset(buf, off + 2u) =\n-                    (code >> 12u & 63u | tag_cont) as u8;\n-                *ptr::mut_offset(buf, off + 3u) =\n-                    (code >> 6u & 63u | tag_cont) as u8;\n-                *ptr::mut_offset(buf, off + 4u) =\n-                    (code & 63u | tag_cont) as u8;\n-            } else if nb == 6u {\n-                *ptr::mut_offset(buf, off) =\n-                    (code >> 30u & 1u | tag_six_b) as u8;\n-                *ptr::mut_offset(buf, off + 1u) =\n-                    (code >> 24u & 63u | tag_cont) as u8;\n-                *ptr::mut_offset(buf, off + 2u) =\n-                    (code >> 18u & 63u | tag_cont) as u8;\n-                *ptr::mut_offset(buf, off + 3u) =\n-                    (code >> 12u & 63u | tag_cont) as u8;\n-                *ptr::mut_offset(buf, off + 4u) =\n-                    (code >> 6u & 63u | tag_cont) as u8;\n-                *ptr::mut_offset(buf, off + 5u) =\n-                    (code & 63u | tag_cont) as u8;\n+            match nb {\n+                1u => {\n+                    *ptr::mut_offset(buf, off) = code as u8;\n+                }\n+                2u => {\n+                    *ptr::mut_offset(buf, off) = (code >> 6u & 31u | tag_two_b) as u8;\n+                    *ptr::mut_offset(buf, off + 1u) = (code & 63u | tag_cont) as u8;\n+                }\n+                3u => {\n+                    *ptr::mut_offset(buf, off) = (code >> 12u & 15u | tag_three_b) as u8;\n+                    *ptr::mut_offset(buf, off + 1u) = (code >> 6u & 63u | tag_cont) as u8;\n+                    *ptr::mut_offset(buf, off + 2u) = (code & 63u | tag_cont) as u8;\n+                }\n+                4u => {\n+                    *ptr::mut_offset(buf, off) = (code >> 18u & 7u | tag_four_b) as u8;\n+                    *ptr::mut_offset(buf, off + 1u) = (code >> 12u & 63u | tag_cont) as u8;\n+                    *ptr::mut_offset(buf, off + 2u) = (code >> 6u & 63u | tag_cont) as u8;\n+                    *ptr::mut_offset(buf, off + 3u) = (code & 63u | tag_cont) as u8;\n+                }\n+                5u => {\n+                    *ptr::mut_offset(buf, off) = (code >> 24u & 3u | tag_five_b) as u8;\n+                    *ptr::mut_offset(buf, off + 1u) = (code >> 18u & 63u | tag_cont) as u8;\n+                    *ptr::mut_offset(buf, off + 2u) = (code >> 12u & 63u | tag_cont) as u8;\n+                    *ptr::mut_offset(buf, off + 3u) = (code >> 6u & 63u | tag_cont) as u8;\n+                    *ptr::mut_offset(buf, off + 4u) = (code & 63u | tag_cont) as u8;\n+                }\n+                6u => {\n+                    *ptr::mut_offset(buf, off) = (code >> 30u & 1u | tag_six_b) as u8;\n+                    *ptr::mut_offset(buf, off + 1u) = (code >> 24u & 63u | tag_cont) as u8;\n+                    *ptr::mut_offset(buf, off + 2u) = (code >> 18u & 63u | tag_cont) as u8;\n+                    *ptr::mut_offset(buf, off + 3u) = (code >> 12u & 63u | tag_cont) as u8;\n+                    *ptr::mut_offset(buf, off + 4u) = (code >> 6u & 63u | tag_cont) as u8;\n+                    *ptr::mut_offset(buf, off + 5u) = (code & 63u | tag_cont) as u8;\n+                }\n+                _ => {}\n             }\n         }\n-\n         raw::set_len(s, new_len);\n     }\n }"}, {"sha": "3b7fdcc85be2f38425eb293715a0b17521315d27", "filename": "src/libcore/unicode.rs", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e91daaa8a9390ccf760b3ba7f965b2863103d993/src%2Flibcore%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e91daaa8a9390ccf760b3ba7f965b2863103d993/src%2Flibcore%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode.rs?ref=e91daaa8a9390ccf760b3ba7f965b2863103d993", "patch": "@@ -14,6 +14,7 @@\n \n pub mod general_category {\n \n+    #[cfg(stage0)]\n     fn bsearch_range_table(c: char, r: &'static [(char,char)]) -> bool {\n         use cmp::{Equal, Less, Greater};\n         use vec::bsearch;\n@@ -25,6 +26,18 @@ pub mod general_category {\n         }) != None\n     }\n \n+    #[cfg(not(stage0))]\n+    fn bsearch_range_table(c: char, r: &'static [(char,char)]) -> bool {\n+        use cmp::{Equal, Less, Greater};\n+        use vec::bsearch;\n+        use option::None;\n+        (do bsearch(r) |&(lo,hi)| { cond!(\n+            (lo <= c && c <= hi) { Equal   }\n+            (hi < c)             { Less    }\n+            _                    { Greater }\n+        )}) != None\n+    }\n+\n \n     static Cc_table : &'static [(char,char)] = &[\n         ('\\x00', '\\x1f'), ('\\x7f', '\\x9f')\n@@ -1449,8 +1462,7 @@ pub mod general_category {\n }\n \n pub mod derived_property {\n-\n-\n+    #[cfg(stage0)]\n     fn bsearch_range_table(c: char, r: &'static [(char,char)]) -> bool {\n         use cmp::{Equal, Less, Greater};\n         use vec::bsearch;\n@@ -1462,6 +1474,18 @@ pub mod derived_property {\n         }) != None\n     }\n \n+    #[cfg(not(stage0))]\n+    fn bsearch_range_table(c: char, r: &'static [(char,char)]) -> bool {\n+        use cmp::{Equal, Less, Greater};\n+        use vec::bsearch;\n+        use option::None;\n+        (do bsearch(r) |&(lo,hi)| { cond!(\n+            (lo <= c && c <= hi) { Equal   }\n+            (hi < c)             { Less    }\n+            _                    { Greater }\n+        )}) != None\n+    }\n+\n \n     static Alphabetic_table : &'static [(char,char)] = &[\n         ('\\x41', '\\x5a'), ('\\x61', '\\x7a'),"}]}