{"sha": "9940ed08057bbee0b681beee02025169020c7519", "node_id": "C_kwDOAAsO6NoAKDk5NDBlZDA4MDU3YmJlZTBiNjgxYmVlZTAyMDI1MTY5MDIwYzc1MTk", "commit": {"author": {"name": "Michael Howell", "email": "michael@notriddle.com", "date": "2022-06-07T18:23:06Z"}, "committer": {"name": "Michael Howell", "email": "michael@notriddle.com", "date": "2022-06-07T18:24:57Z"}, "message": "docs: clean up trait docs for tuples", "tree": {"sha": "45b70384a46d1c72e6193865ccbdbe18d8f644f1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/45b70384a46d1c72e6193865ccbdbe18d8f644f1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9940ed08057bbee0b681beee02025169020c7519", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9940ed08057bbee0b681beee02025169020c7519", "html_url": "https://github.com/rust-lang/rust/commit/9940ed08057bbee0b681beee02025169020c7519", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9940ed08057bbee0b681beee02025169020c7519/comments", "author": {"login": "notriddle", "id": 1593513, "node_id": "MDQ6VXNlcjE1OTM1MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1593513?v=4", "gravatar_id": "", "url": "https://api.github.com/users/notriddle", "html_url": "https://github.com/notriddle", "followers_url": "https://api.github.com/users/notriddle/followers", "following_url": "https://api.github.com/users/notriddle/following{/other_user}", "gists_url": "https://api.github.com/users/notriddle/gists{/gist_id}", "starred_url": "https://api.github.com/users/notriddle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/notriddle/subscriptions", "organizations_url": "https://api.github.com/users/notriddle/orgs", "repos_url": "https://api.github.com/users/notriddle/repos", "events_url": "https://api.github.com/users/notriddle/events{/privacy}", "received_events_url": "https://api.github.com/users/notriddle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "notriddle", "id": 1593513, "node_id": "MDQ6VXNlcjE1OTM1MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1593513?v=4", "gravatar_id": "", "url": "https://api.github.com/users/notriddle", "html_url": "https://github.com/notriddle", "followers_url": "https://api.github.com/users/notriddle/followers", "following_url": "https://api.github.com/users/notriddle/following{/other_user}", "gists_url": "https://api.github.com/users/notriddle/gists{/gist_id}", "starred_url": "https://api.github.com/users/notriddle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/notriddle/subscriptions", "organizations_url": "https://api.github.com/users/notriddle/orgs", "repos_url": "https://api.github.com/users/notriddle/repos", "events_url": "https://api.github.com/users/notriddle/events{/privacy}", "received_events_url": "https://api.github.com/users/notriddle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7fe2c4b00dfbc33643e1af4b293eb057306a8339", "url": "https://api.github.com/repos/rust-lang/rust/commits/7fe2c4b00dfbc33643e1af4b293eb057306a8339", "html_url": "https://github.com/rust-lang/rust/commit/7fe2c4b00dfbc33643e1af4b293eb057306a8339"}], "stats": {"total": 204, "additions": 132, "deletions": 72}, "files": [{"sha": "46b2b0c92bf7a5a8ae639cf28d701e4eca318cdb", "filename": "library/core/src/fmt/mod.rs", "status": "modified", "additions": 27, "deletions": 11, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/9940ed08057bbee0b681beee02025169020c7519/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9940ed08057bbee0b681beee02025169020c7519/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs?ref=9940ed08057bbee0b681beee02025169020c7519", "patch": "@@ -2313,23 +2313,39 @@ macro_rules! peel {\n macro_rules! tuple {\n     () => ();\n     ( $($name:ident,)+ ) => (\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl<$($name:Debug),+> Debug for ($($name,)+) where last_type!($($name,)+): ?Sized {\n-            #[allow(non_snake_case, unused_assignments)]\n-            fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n-                let mut builder = f.debug_tuple(\"\");\n-                let ($(ref $name,)+) = *self;\n-                $(\n-                    builder.field(&$name);\n-                )+\n-\n-                builder.finish()\n+        maybe_tuple_doc! {\n+            $($name)+ @\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            impl<$($name:Debug),+> Debug for ($($name,)+) where last_type!($($name,)+): ?Sized {\n+                #[allow(non_snake_case, unused_assignments)]\n+                fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n+                    let mut builder = f.debug_tuple(\"\");\n+                    let ($(ref $name,)+) = *self;\n+                    $(\n+                        builder.field(&$name);\n+                    )+\n+\n+                    builder.finish()\n+                }\n             }\n         }\n         peel! { $($name,)+ }\n     )\n }\n \n+macro_rules! maybe_tuple_doc {\n+    ($a:ident @ #[$meta:meta] $item:item) => {\n+        #[doc = \"This trait is implemented for tuples up to twelve items long.\"]\n+        #[$meta]\n+        $item\n+    };\n+    ($a:ident $($rest_a:ident)+ @ #[$meta:meta] $item:item) => {\n+        #[doc(hidden)]\n+        #[$meta]\n+        $item\n+    };\n+}\n+\n macro_rules! last_type {\n     ($a:ident,) => { $a };\n     ($a:ident, $($rest_a:ident,)+) => { last_type!($($rest_a,)+) };"}, {"sha": "ae3799d2a963cacd0b3509473d8f639a3bca4ad1", "filename": "library/core/src/hash/mod.rs", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9940ed08057bbee0b681beee02025169020c7519/library%2Fcore%2Fsrc%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9940ed08057bbee0b681beee02025169020c7519/library%2Fcore%2Fsrc%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fhash%2Fmod.rs?ref=9940ed08057bbee0b681beee02025169020c7519", "patch": "@@ -883,18 +883,34 @@ mod impls {\n         );\n \n         ( $($name:ident)+) => (\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl<$($name: Hash),+> Hash for ($($name,)+) where last_type!($($name,)+): ?Sized {\n-                #[allow(non_snake_case)]\n-                #[inline]\n-                fn hash<S: Hasher>(&self, state: &mut S) {\n-                    let ($(ref $name,)+) = *self;\n-                    $($name.hash(state);)+\n+            maybe_tuple_doc! {\n+                $($name)+ @\n+                #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+                impl<$($name: Hash),+> Hash for ($($name,)+) where last_type!($($name,)+): ?Sized {\n+                    #[allow(non_snake_case)]\n+                    #[inline]\n+                    fn hash<S: Hasher>(&self, state: &mut S) {\n+                        let ($(ref $name,)+) = *self;\n+                        $($name.hash(state);)+\n+                    }\n                 }\n             }\n         );\n     }\n \n+    macro_rules! maybe_tuple_doc {\n+        ($a:ident @ #[$meta:meta] $item:item) => {\n+            #[doc = \"This trait is implemented for tuples up to twelve items long.\"]\n+            #[$meta]\n+            $item\n+        };\n+        ($a:ident $($rest_a:ident)+ @ #[$meta:meta] $item:item) => {\n+            #[doc(hidden)]\n+            #[$meta]\n+            $item\n+        };\n+    }\n+\n     macro_rules! last_type {\n         ($a:ident,) => { $a };\n         ($a:ident, $($rest_a:ident,)+) => { last_type!($($rest_a,)+) };"}, {"sha": "61fa0eea78a731629ada3350c7443a79e589aafd", "filename": "library/core/src/tuple.rs", "status": "modified", "additions": 82, "deletions": 54, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/9940ed08057bbee0b681beee02025169020c7519/library%2Fcore%2Fsrc%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9940ed08057bbee0b681beee02025169020c7519/library%2Fcore%2Fsrc%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftuple.rs?ref=9940ed08057bbee0b681beee02025169020c7519", "patch": "@@ -19,75 +19,103 @@ macro_rules! tuple_impls {\n     };\n     // \"Private\" internal implementation\n     (@impl $( $T:ident )+) => {\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl<$($T:PartialEq),+> PartialEq for ($($T,)+)\n-        where\n-            last_type!($($T,)+): ?Sized\n-        {\n-            #[inline]\n-            fn eq(&self, other: &($($T,)+)) -> bool {\n-                $( ${ignore(T)} self.${index()} == other.${index()} )&&+\n-            }\n-            #[inline]\n-            fn ne(&self, other: &($($T,)+)) -> bool {\n-                $( ${ignore(T)} self.${index()} != other.${index()} )||+\n+        maybe_tuple_doc! {\n+            $($T)+ @\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            impl<$($T:PartialEq),+> PartialEq for ($($T,)+)\n+            where\n+                last_type!($($T,)+): ?Sized\n+            {\n+                #[inline]\n+                fn eq(&self, other: &($($T,)+)) -> bool {\n+                    $( ${ignore(T)} self.${index()} == other.${index()} )&&+\n+                }\n+                #[inline]\n+                fn ne(&self, other: &($($T,)+)) -> bool {\n+                    $( ${ignore(T)} self.${index()} != other.${index()} )||+\n+                }\n             }\n         }\n \n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl<$($T:Eq),+> Eq for ($($T,)+)\n-        where\n-            last_type!($($T,)+): ?Sized\n-        {}\n+        maybe_tuple_doc! {\n+            $($T)+ @\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            impl<$($T:Eq),+> Eq for ($($T,)+)\n+            where\n+                last_type!($($T,)+): ?Sized\n+            {}\n+        }\n \n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl<$($T:PartialOrd + PartialEq),+> PartialOrd for ($($T,)+)\n-        where\n-            last_type!($($T,)+): ?Sized\n-        {\n-            #[inline]\n-            fn partial_cmp(&self, other: &($($T,)+)) -> Option<Ordering> {\n-                lexical_partial_cmp!($( ${ignore(T)} self.${index()}, other.${index()} ),+)\n-            }\n-            #[inline]\n-            fn lt(&self, other: &($($T,)+)) -> bool {\n-                lexical_ord!(lt, $( ${ignore(T)} self.${index()}, other.${index()} ),+)\n-            }\n-            #[inline]\n-            fn le(&self, other: &($($T,)+)) -> bool {\n-                lexical_ord!(le, $( ${ignore(T)} self.${index()}, other.${index()} ),+)\n-            }\n-            #[inline]\n-            fn ge(&self, other: &($($T,)+)) -> bool {\n-                lexical_ord!(ge, $( ${ignore(T)} self.${index()}, other.${index()} ),+)\n-            }\n-            #[inline]\n-            fn gt(&self, other: &($($T,)+)) -> bool {\n-                lexical_ord!(gt, $( ${ignore(T)} self.${index()}, other.${index()} ),+)\n+        maybe_tuple_doc! {\n+            $($T)+ @\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            impl<$($T:PartialOrd + PartialEq),+> PartialOrd for ($($T,)+)\n+            where\n+                last_type!($($T,)+): ?Sized\n+            {\n+                #[inline]\n+                fn partial_cmp(&self, other: &($($T,)+)) -> Option<Ordering> {\n+                    lexical_partial_cmp!($( ${ignore(T)} self.${index()}, other.${index()} ),+)\n+                }\n+                #[inline]\n+                fn lt(&self, other: &($($T,)+)) -> bool {\n+                    lexical_ord!(lt, $( ${ignore(T)} self.${index()}, other.${index()} ),+)\n+                }\n+                #[inline]\n+                fn le(&self, other: &($($T,)+)) -> bool {\n+                    lexical_ord!(le, $( ${ignore(T)} self.${index()}, other.${index()} ),+)\n+                }\n+                #[inline]\n+                fn ge(&self, other: &($($T,)+)) -> bool {\n+                    lexical_ord!(ge, $( ${ignore(T)} self.${index()}, other.${index()} ),+)\n+                }\n+                #[inline]\n+                fn gt(&self, other: &($($T,)+)) -> bool {\n+                    lexical_ord!(gt, $( ${ignore(T)} self.${index()}, other.${index()} ),+)\n+                }\n             }\n         }\n \n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl<$($T:Ord),+> Ord for ($($T,)+)\n-        where\n-            last_type!($($T,)+): ?Sized\n-        {\n-            #[inline]\n-            fn cmp(&self, other: &($($T,)+)) -> Ordering {\n-                lexical_cmp!($( ${ignore(T)} self.${index()}, other.${index()} ),+)\n+        maybe_tuple_doc! {\n+            $($T)+ @\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            impl<$($T:Ord),+> Ord for ($($T,)+)\n+            where\n+                last_type!($($T,)+): ?Sized\n+            {\n+                #[inline]\n+                fn cmp(&self, other: &($($T,)+)) -> Ordering {\n+                    lexical_cmp!($( ${ignore(T)} self.${index()}, other.${index()} ),+)\n+                }\n             }\n         }\n \n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl<$($T:Default),+> Default for ($($T,)+) {\n-            #[inline]\n-            fn default() -> ($($T,)+) {\n-                ($({ let x: $T = Default::default(); x},)+)\n+        maybe_tuple_doc! {\n+            $($T)+ @\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            impl<$($T:Default),+> Default for ($($T,)+) {\n+                #[inline]\n+                fn default() -> ($($T,)+) {\n+                    ($({ let x: $T = Default::default(); x},)+)\n+                }\n             }\n         }\n     }\n }\n \n+macro_rules! maybe_tuple_doc {\n+    ($a:ident @ #[$meta:meta] $item:item) => {\n+        #[doc = \"This trait is implemented for tuples up to twelve items long.\"]\n+        #[$meta]\n+        $item\n+    };\n+    ($a:ident $($rest_a:ident)+ @ #[$meta:meta] $item:item) => {\n+        #[doc(hidden)]\n+        #[$meta]\n+        $item\n+    };\n+}\n+\n // Constructs an expression that performs a lexical ordering using method $rel.\n // The values are interleaved, so the macro invocation for\n // `(a1, a2, a3) < (b1, b2, b3)` would be `lexical_ord!(lt, a1, b1, a2, b2,"}]}