{"sha": "90f5cfdfbd3c9e39f897fd2271c7b1c7fdaae58e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkwZjVjZmRmYmQzYzllMzlmODk3ZmQyMjcxYzdiMWM3ZmRhYWU1OGU=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2017-11-19T14:05:29Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2017-11-20T21:21:24Z"}, "message": "Report special messages for path segment keywords in wrong positions", "tree": {"sha": "377d63555a472a48dfe9229d8da3c472bb591c5d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/377d63555a472a48dfe9229d8da3c472bb591c5d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/90f5cfdfbd3c9e39f897fd2271c7b1c7fdaae58e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/90f5cfdfbd3c9e39f897fd2271c7b1c7fdaae58e", "html_url": "https://github.com/rust-lang/rust/commit/90f5cfdfbd3c9e39f897fd2271c7b1c7fdaae58e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/90f5cfdfbd3c9e39f897fd2271c7b1c7fdaae58e/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2e9b89ddc50f0409290a9f906cae8817c2473f9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e9b89ddc50f0409290a9f906cae8817c2473f9e", "html_url": "https://github.com/rust-lang/rust/commit/2e9b89ddc50f0409290a9f906cae8817c2473f9e"}], "stats": {"total": 65, "additions": 47, "deletions": 18}, "files": [{"sha": "42c31a6e47eaa714dbf5796318632382dc0c8d86", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 30, "deletions": 6, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/90f5cfdfbd3c9e39f897fd2271c7b1c7fdaae58e/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90f5cfdfbd3c9e39f897fd2271c7b1c7fdaae58e/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=90f5cfdfbd3c9e39f897fd2271c7b1c7fdaae58e", "patch": "@@ -2865,12 +2865,13 @@ impl<'a> Resolver<'a> {\n             debug!(\"resolve_path ident {} {:?}\", i, ident);\n             let is_last = i == path.len() - 1;\n             let ns = if is_last { opt_ns.unwrap_or(TypeNS) } else { TypeNS };\n+            let name = ident.node.name;\n \n-            if i == 0 && ns == TypeNS && ident.node.name == keywords::SelfValue.name() {\n+            if i == 0 && ns == TypeNS && name == keywords::SelfValue.name() {\n                 let mut ctxt = ident.node.ctxt.modern();\n                 module = Some(self.resolve_self(&mut ctxt, self.current_module));\n                 continue\n-            } else if allow_super && ns == TypeNS && ident.node.name == keywords::Super.name() {\n+            } else if allow_super && ns == TypeNS && name == keywords::Super.name() {\n                 let mut ctxt = ident.node.ctxt.modern();\n                 let self_module = match i {\n                     0 => self.resolve_self(&mut ctxt, self.current_module),\n@@ -2887,19 +2888,42 @@ impl<'a> Resolver<'a> {\n             allow_super = false;\n \n             if ns == TypeNS {\n-                if (i == 0 && ident.node.name == keywords::CrateRoot.name()) ||\n-                   (i == 1 && ident.node.name == keywords::Crate.name() &&\n+                if (i == 0 && name == keywords::CrateRoot.name()) ||\n+                   (i == 1 && name == keywords::Crate.name() &&\n                               path[0].node.name == keywords::CrateRoot.name()) {\n                     // `::a::b` or `::crate::a::b`\n                     module = Some(self.resolve_crate_root(ident.node.ctxt.modern()));\n                     continue\n-                } else if i == 0 && ident.node.name == keywords::DollarCrate.name() {\n+                } else if i == 0 && name == keywords::DollarCrate.name() {\n                     // `$crate::a::b`\n                     module = Some(self.resolve_crate_root(ident.node.ctxt));\n                     continue\n                 }\n             }\n \n+            // Report special messages for path segment keywords in wrong positions.\n+            if name == keywords::CrateRoot.name() && i != 0 ||\n+               name == keywords::DollarCrate.name() && i != 0 ||\n+               name == keywords::SelfValue.name() && i != 0 ||\n+               name == keywords::SelfType.name() && i != 0 ||\n+               name == keywords::Super.name() && i != 0 ||\n+               name == keywords::Crate.name() && i != 1 &&\n+                    path[0].node.name != keywords::CrateRoot.name() {\n+                let name_str = if name == keywords::CrateRoot.name() {\n+                    format!(\"crate root\")\n+                } else {\n+                    format!(\"`{}`\", name)\n+                };\n+                let msg = if i == 1 && path[0].node.name == keywords::CrateRoot.name() {\n+                    format!(\"global paths cannot start with {}\", name_str)\n+                } else if i == 0 && name == keywords::Crate.name() {\n+                    format!(\"{} can only be used in absolute paths\", name_str)\n+                } else {\n+                    format!(\"{} in paths can only be used in start position\", name_str)\n+                };\n+                return PathResult::Failed(ident.span, msg, false);\n+            }\n+\n             let binding = if let Some(module) = module {\n                 self.resolve_ident_in_module(module, ident.node, ns, false, record_used, path_span)\n             } else if opt_ns == Some(MacroNS) {\n@@ -2948,7 +2972,7 @@ impl<'a> Resolver<'a> {\n                     let msg = if module.and_then(ModuleData::def) == self.graph_root.def() {\n                         let is_mod = |def| match def { Def::Mod(..) => true, _ => false };\n                         let mut candidates =\n-                            self.lookup_import_candidates(ident.node.name, TypeNS, is_mod);\n+                            self.lookup_import_candidates(name, TypeNS, is_mod);\n                         candidates.sort_by_key(|c| (c.path.segments.len(), c.path.to_string()));\n                         if let Some(candidate) = candidates.get(0) {\n                             format!(\"Did you mean `{}`?\", candidate.path)"}, {"sha": "d72253e5a8a48fc432108f2675c837b278cdaa87", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/90f5cfdfbd3c9e39f897fd2271c7b1c7fdaae58e/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90f5cfdfbd3c9e39f897fd2271c7b1c7fdaae58e/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=90f5cfdfbd3c9e39f897fd2271c7b1c7fdaae58e", "patch": "@@ -606,10 +606,16 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         let module_result = self.resolve_path(&module_path, None, true, span);\n         let module = match module_result {\n             PathResult::Module(module) => module,\n-            PathResult::Failed(span, msg, _) => {\n+            PathResult::Failed(span, msg, false) => {\n+                resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n+                return None;\n+            }\n+            PathResult::Failed(span, msg, true) => {\n                 let (mut self_path, mut self_result) = (module_path.clone(), None);\n                 if !self_path.is_empty() &&\n-                    !token::Ident(self_path[0].node).is_path_segment_keyword()\n+                    !token::Ident(self_path[0].node).is_path_segment_keyword() &&\n+                    !(self_path.len() > 1 &&\n+                      token::Ident(self_path[1].node).is_path_segment_keyword())\n                 {\n                     self_path[0].node.name = keywords::SelfValue.name();\n                     self_result = Some(self.resolve_path(&self_path, None, false, span));"}, {"sha": "87a29038035815b7934827045e9a2eb81dc8a96f", "filename": "src/test/compile-fail/dollar-crate-is-keyword-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/90f5cfdfbd3c9e39f897fd2271c7b1c7fdaae58e/src%2Ftest%2Fcompile-fail%2Fdollar-crate-is-keyword-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90f5cfdfbd3c9e39f897fd2271c7b1c7fdaae58e/src%2Ftest%2Fcompile-fail%2Fdollar-crate-is-keyword-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdollar-crate-is-keyword-2.rs?ref=90f5cfdfbd3c9e39f897fd2271c7b1c7fdaae58e", "patch": "@@ -13,8 +13,8 @@ mod a {}\n macro_rules! m {\n     () => {\n         use a::$crate; //~ ERROR unresolved import `a::$crate`\n-        use a::$crate::b; //~ ERROR unresolved import `a::$crate`\n-        type A = a::$crate; //~ ERROR cannot find type `$crate` in module `a`\n+        use a::$crate::b; //~ ERROR `$crate` in paths can only be used in start position\n+        type A = a::$crate; //~ ERROR `$crate` in paths can only be used in start position\n     }\n }\n "}, {"sha": "75c2a5f5bc4776cf463cb346ae56bfb624413af7", "filename": "src/test/compile-fail/rfc-2126-crate-paths/crate-path-non-absolute.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90f5cfdfbd3c9e39f897fd2271c7b1c7fdaae58e/src%2Ftest%2Fcompile-fail%2Frfc-2126-crate-paths%2Fcrate-path-non-absolute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90f5cfdfbd3c9e39f897fd2271c7b1c7fdaae58e/src%2Ftest%2Fcompile-fail%2Frfc-2126-crate-paths%2Fcrate-path-non-absolute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frfc-2126-crate-paths%2Fcrate-path-non-absolute.rs?ref=90f5cfdfbd3c9e39f897fd2271c7b1c7fdaae58e", "patch": "@@ -14,7 +14,7 @@ struct S;\n \n mod m {\n     fn f() {\n-        let s = crate::S; //~ ERROR undeclared type or module `crate`\n+        let s = crate::S; //~ ERROR `crate` can only be used in absolute paths\n     }\n }\n "}, {"sha": "8c5a971c2f756b3e32c7dad30b8581167d22d1fa", "filename": "src/test/compile-fail/rfc-2126-crate-paths/crate-visibility-ambiguity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90f5cfdfbd3c9e39f897fd2271c7b1c7fdaae58e/src%2Ftest%2Fcompile-fail%2Frfc-2126-crate-paths%2Fcrate-visibility-ambiguity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90f5cfdfbd3c9e39f897fd2271c7b1c7fdaae58e/src%2Ftest%2Fcompile-fail%2Frfc-2126-crate-paths%2Fcrate-visibility-ambiguity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frfc-2126-crate-paths%2Fcrate-visibility-ambiguity.rs?ref=90f5cfdfbd3c9e39f897fd2271c7b1c7fdaae58e", "patch": "@@ -15,7 +15,7 @@ mod m {\n     pub struct Z;\n     pub struct S1(crate (::m::Z)); // OK\n     pub struct S2(::crate ::m::Z); // OK\n-    pub struct S3(crate ::m::Z); //~ ERROR undeclared type or module `crate`\n+    pub struct S3(crate ::m::Z); //~ ERROR `crate` can only be used in absolute paths\n }\n \n fn main() {"}, {"sha": "2c94f7b0f59df0e28e7e44d701f1d2471f7e165f", "filename": "src/test/compile-fail/rfc-2126-crate-paths/keyword-crate-as-identifier.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90f5cfdfbd3c9e39f897fd2271c7b1c7fdaae58e/src%2Ftest%2Fcompile-fail%2Frfc-2126-crate-paths%2Fkeyword-crate-as-identifier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90f5cfdfbd3c9e39f897fd2271c7b1c7fdaae58e/src%2Ftest%2Fcompile-fail%2Frfc-2126-crate-paths%2Fkeyword-crate-as-identifier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frfc-2126-crate-paths%2Fkeyword-crate-as-identifier.rs?ref=90f5cfdfbd3c9e39f897fd2271c7b1c7fdaae58e", "patch": "@@ -11,5 +11,5 @@\n #![feature(crate_in_paths)]\n \n fn main() {\n-    let crate = 0; //~ ERROR cannot find unit struct/variant or constant `crate` in this scope\n+    let crate = 0; //~ ERROR `crate` can only be used in absolute paths\n }"}, {"sha": "c607711c44f37ba035d16905a71ddd41f9b59a0d", "filename": "src/test/compile-fail/super-at-top-level.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/90f5cfdfbd3c9e39f897fd2271c7b1c7fdaae58e/src%2Ftest%2Fcompile-fail%2Fsuper-at-top-level.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90f5cfdfbd3c9e39f897fd2271c7b1c7fdaae58e/src%2Ftest%2Fcompile-fail%2Fsuper-at-top-level.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsuper-at-top-level.rs?ref=90f5cfdfbd3c9e39f897fd2271c7b1c7fdaae58e", "patch": "@@ -8,8 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::f; //~ ERROR unresolved import `super` [E0432]\n-              //~^ There are too many initial `super`s.\n+use super::f; //~ ERROR There are too many initial `super`s\n \n fn main() {\n }"}, {"sha": "fc1a72f6f2b90ea9b0d0fc611ba61d2ed6f6c1df", "filename": "src/test/compile-fail/use-super-global-path.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/90f5cfdfbd3c9e39f897fd2271c7b1c7fdaae58e/src%2Ftest%2Fcompile-fail%2Fuse-super-global-path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90f5cfdfbd3c9e39f897fd2271c7b1c7fdaae58e/src%2Ftest%2Fcompile-fail%2Fuse-super-global-path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-super-global-path.rs?ref=90f5cfdfbd3c9e39f897fd2271c7b1c7fdaae58e", "patch": "@@ -14,11 +14,11 @@ struct S;\n struct Z;\n \n mod foo {\n-    use ::super::{S, Z}; //~ ERROR unresolved import `super`\n+    use ::super::{S, Z}; //~ ERROR global paths cannot start with `super`\n \n     pub fn g() {\n-        use ::super::main; //~ ERROR unresolved import `super`\n-        main();\n+        use ::super::main; //~ ERROR global paths cannot start with `super`\n+        main(); //~ ERROR cannot find function `main` in this scope\n     }\n }\n "}]}