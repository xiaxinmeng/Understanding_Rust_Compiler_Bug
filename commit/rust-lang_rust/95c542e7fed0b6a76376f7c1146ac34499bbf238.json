{"sha": "95c542e7fed0b6a76376f7c1146ac34499bbf238", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1YzU0MmU3ZmVkMGI2YTc2Mzc2ZjdjMTE0NmFjMzQ0OTliYmYyMzg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-23T01:36:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-23T01:36:28Z"}, "message": "auto merge of #8655 : olsonjeffery/rust/newrt_file_io, r=pcwalton,brson\n\nThis PR includes the addition of the essential CRUD functionality exposed as a part of the `uv_fs_*` api. There's a lot more to be done, but the essential abstractions are in place and can be easily expanded.\r\n\r\nA summary:\r\n\r\n* `rt::io::file::FileStream` is fleshed out and behaves as a *non-positional* file stream (that is, it has a cursor that can be viewed/changed via `tell` and `seek`\r\n* The underlying abstraction in `RtioFileStream` exposes pairs of `read(), write()` and `pread(), pwrite()`. The latter two take explicit `offset` params and don't respect the current cursor location in a file afaik. They both use the same underlying libuv impl\r\n* Because libuv explicitly does *not* support `seek`/`tell` operations, these are impl'd in `UvFileStream` by using `lseek(2)` on the raw file descriptor.\r\n* I did my best to flesh out and adhere to the stubbing that was already present in `rt::io::file` and the tests should back that up. There may be things missing.\r\n* All of the work to test `seek`/`tell` is done in `rt::io::file`, even though the actual impl is down in `rt::uv::uvio`.\r\n* We have the ability to spin up an `~RtioFileStream` from a raw file descriptor. This would be useful for interacting with stdin and stdout via newrt.\r\n* The lowest level abstractions (in `rt::uv::file`) support fully synchronous/blocking interactions with the uv API and there is a CRUD test using it. This may also be useful for blocking printf, if desired (the default would be non-blocking and uses libuv's io threadpool)\r\n\r\nThere are a few polish things I need to do still (the foremost that I know of is undefined behavior when seek'ing beyond the file's boundary).\r\n\r\nAfter this lands, I want to move on to mapping more of the `uv_fs_*` API (especially `uv_fs_stat`). Also a few people have mentioned interest in `uv_pipe_t` support. I'm open to suggestions.", "tree": {"sha": "fb1ffddf92c55e42a6ce164022d008c1cc52aa8f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fb1ffddf92c55e42a6ce164022d008c1cc52aa8f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/95c542e7fed0b6a76376f7c1146ac34499bbf238", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/95c542e7fed0b6a76376f7c1146ac34499bbf238", "html_url": "https://github.com/rust-lang/rust/commit/95c542e7fed0b6a76376f7c1146ac34499bbf238", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/95c542e7fed0b6a76376f7c1146ac34499bbf238/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "23bfa600a0f91f1ea62ea3f3783c358a7cb7da45", "url": "https://api.github.com/repos/rust-lang/rust/commits/23bfa600a0f91f1ea62ea3f3783c358a7cb7da45", "html_url": "https://github.com/rust-lang/rust/commit/23bfa600a0f91f1ea62ea3f3783c358a7cb7da45"}, {"sha": "b7cbd8a8fd69d7a2b540e3b4f9e808810fc1ddc0", "url": "https://api.github.com/repos/rust-lang/rust/commits/b7cbd8a8fd69d7a2b540e3b4f9e808810fc1ddc0", "html_url": "https://github.com/rust-lang/rust/commit/b7cbd8a8fd69d7a2b540e3b4f9e808810fc1ddc0"}], "stats": {"total": 1211, "additions": 1156, "deletions": 55}, "files": [{"sha": "65db76d5ef768d1a1c17cb6f4db05270dce8e91b", "filename": "src/libstd/rt/io/file.rs", "status": "modified", "additions": 303, "deletions": 40, "changes": 343, "blob_url": "https://github.com/rust-lang/rust/blob/95c542e7fed0b6a76376f7c1146ac34499bbf238/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95c542e7fed0b6a76376f7c1146ac34499bbf238/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Ffile.rs?ref=95c542e7fed0b6a76376f7c1146ac34499bbf238", "patch": "@@ -11,69 +11,332 @@\n use prelude::*;\n use super::support::PathLike;\n use super::{Reader, Writer, Seek};\n-use super::SeekStyle;\n+use super::{SeekSet, SeekCur, SeekEnd, SeekStyle};\n+use rt::rtio::{RtioFileStream, IoFactory, IoFactoryObject};\n+use rt::io::{io_error, read_error, EndOfFile,\n+             FileMode, FileAccess, Open, Read, Create, ReadWrite};\n+use rt::local::Local;\n+use rt::test::*;\n \n-/// # FIXME #7785\n-/// * Ugh, this is ridiculous. What is the best way to represent these options?\n-enum FileMode {\n-    /// Opens an existing file. IoError if file does not exist.\n-    Open,\n-    /// Creates a file. IoError if file exists.\n-    Create,\n-    /// Opens an existing file or creates a new one.\n-    OpenOrCreate,\n-    /// Opens an existing file or creates a new one, positioned at EOF.\n-    Append,\n-    /// Opens an existing file, truncating it to 0 bytes.\n-    Truncate,\n-    /// Opens an existing file or creates a new one, truncating it to 0 bytes.\n-    CreateOrTruncate,\n+/// Open a file for reading/writing, as indicated by `path`.\n+pub fn open<P: PathLike>(path: &P,\n+                         mode: FileMode,\n+                         access: FileAccess\n+                        ) -> Option<FileStream> {\n+    let open_result = unsafe {\n+        let io = Local::unsafe_borrow::<IoFactoryObject>();\n+        (*io).fs_open(path, mode, access)\n+    };\n+    match open_result {\n+        Ok(fd) => Some(FileStream {\n+            fd: fd,\n+            last_nread: -1\n+        }),\n+        Err(ioerr) => {\n+            io_error::cond.raise(ioerr);\n+            None\n+        }\n+    }\n }\n \n-enum FileAccess {\n-    Read,\n-    Write,\n-    ReadWrite\n+/// Unlink (remove) a file from the filesystem, as indicated\n+/// by `path`.\n+pub fn unlink<P: PathLike>(path: &P) {\n+    let unlink_result = unsafe {\n+        let io = Local::unsafe_borrow::<IoFactoryObject>();\n+        (*io).fs_unlink(path)\n+    };\n+    match unlink_result {\n+        Ok(_) => (),\n+        Err(ioerr) => {\n+            io_error::cond.raise(ioerr);\n+        }\n+    }\n }\n \n-pub struct FileStream;\n+/// Abstraction representing *positional* access to a file. In this case,\n+/// *positional* refers to it keeping an encounter *cursor* of where in the\n+/// file a subsequent `read` or `write` will begin from. Users of a `FileStream`\n+/// can `seek` to move the cursor to a given location *within the bounds of the\n+/// file* and can ask to have the `FileStream` `tell` them the location, in\n+/// bytes, of the cursor.\n+///\n+/// This abstraction is roughly modeled on the access workflow as represented\n+/// by `open(2)`, `read(2)`, `write(2)` and friends.\n+///\n+/// The `open` and `unlink` static methods are provided to manage creation/removal\n+/// of files. All other methods operatin on an instance of `FileStream`.\n+pub struct FileStream {\n+    fd: ~RtioFileStream,\n+    last_nread: int,\n+}\n \n impl FileStream {\n-    pub fn open<P: PathLike>(_path: &P,\n-                             _mode: FileMode,\n-                             _access: FileAccess\n-                            ) -> Option<FileStream> {\n-        fail!()\n-    }\n }\n \n impl Reader for FileStream {\n-    fn read(&mut self, _buf: &mut [u8]) -> Option<uint> {\n-        fail!()\n+    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+        match self.fd.read(buf) {\n+            Ok(read) => {\n+                self.last_nread = read;\n+                match read {\n+                    0 => None,\n+                    _ => Some(read as uint)\n+                }\n+            },\n+            Err(ioerr) => {\n+                // EOF is indicated by returning None\n+                if ioerr.kind != EndOfFile {\n+                    read_error::cond.raise(ioerr);\n+                }\n+                return None;\n+            }\n+        }\n     }\n \n     fn eof(&mut self) -> bool {\n-        fail!()\n+        self.last_nread == 0\n     }\n }\n \n impl Writer for FileStream {\n-    fn write(&mut self, _v: &[u8]) { fail!() }\n+    fn write(&mut self, buf: &[u8]) {\n+        match self.fd.write(buf) {\n+            Ok(_) => (),\n+            Err(ioerr) => {\n+                io_error::cond.raise(ioerr);\n+            }\n+        }\n+    }\n \n-    fn flush(&mut self) { fail!() }\n+    fn flush(&mut self) {\n+        match self.fd.flush() {\n+            Ok(_) => (),\n+            Err(ioerr) => {\n+                read_error::cond.raise(ioerr);\n+            }\n+        }\n+    }\n }\n \n impl Seek for FileStream {\n-    fn tell(&self) -> u64 { fail!() }\n+    fn tell(&self) -> u64 {\n+        let res = self.fd.tell();\n+        match res {\n+            Ok(cursor) => cursor,\n+            Err(ioerr) => {\n+                read_error::cond.raise(ioerr);\n+                return -1;\n+            }\n+        }\n+    }\n+\n+    fn seek(&mut self, pos: i64, style: SeekStyle) {\n+        match self.fd.seek(pos, style) {\n+            Ok(_) => {\n+                // successful seek resets EOF indicator\n+                self.last_nread = -1;\n+                ()\n+            },\n+            Err(ioerr) => {\n+                read_error::cond.raise(ioerr);\n+            }\n+        }\n+    }\n+}\n \n-    fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail!() }\n+fn file_test_smoke_test_impl() {\n+    do run_in_newsched_task {\n+        let message = \"it's alright. have a good time\";\n+        let filename = &Path(\"./tmp/file_rt_io_file_test.txt\");\n+        {\n+            let mut write_stream = open(filename, Create, ReadWrite).unwrap();\n+            write_stream.write(message.as_bytes());\n+        }\n+        {\n+            use str;\n+            let mut read_stream = open(filename, Open, Read).unwrap();\n+            let mut read_buf = [0, .. 1028];\n+            let read_str = match read_stream.read(read_buf).unwrap() {\n+                -1|0 => fail!(\"shouldn't happen\"),\n+                n => str::from_bytes(read_buf.slice_to(n))\n+            };\n+            assert!(read_str == message.to_owned());\n+        }\n+        unlink(filename);\n+    }\n }\n \n #[test]\n-#[ignore]\n-fn super_simple_smoke_test_lets_go_read_some_files_and_have_a_good_time() {\n-    let message = \"it's alright. have a good time\";\n-    let filename = &Path(\"test.txt\");\n-    let mut outstream = FileStream::open(filename, Create, Read).unwrap();\n-    outstream.write(message.as_bytes());\n+fn file_test_io_smoke_test() {\n+    file_test_smoke_test_impl();\n+}\n+\n+fn file_test_invalid_path_opened_without_create_should_raise_condition_impl() {\n+    do run_in_newsched_task {\n+        let filename = &Path(\"./tmp/file_that_does_not_exist.txt\");\n+        let mut called = false;\n+        do io_error::cond.trap(|_| {\n+            called = true;\n+        }).inside {\n+            let result = open(filename, Open, Read);\n+            assert!(result.is_none());\n+        }\n+        assert!(called);\n+    }\n+}\n+#[test]\n+fn file_test_io_invalid_path_opened_without_create_should_raise_condition() {\n+    file_test_invalid_path_opened_without_create_should_raise_condition_impl();\n+}\n+\n+fn file_test_unlinking_invalid_path_should_raise_condition_impl() {\n+    do run_in_newsched_task {\n+        let filename = &Path(\"./tmp/file_another_file_that_does_not_exist.txt\");\n+        let mut called = false;\n+        do io_error::cond.trap(|_| {\n+            called = true;\n+        }).inside {\n+            unlink(filename);\n+        }\n+        assert!(called);\n+    }\n+}\n+#[test]\n+fn file_test_iounlinking_invalid_path_should_raise_condition() {\n+    file_test_unlinking_invalid_path_should_raise_condition_impl();\n+}\n+\n+fn file_test_io_non_positional_read_impl() {\n+    do run_in_newsched_task {\n+        use str;\n+        let message = \"ten-four\";\n+        let mut read_mem = [0, .. 8];\n+        let filename = &Path(\"./tmp/file_rt_io_file_test_positional.txt\");\n+        {\n+            let mut rw_stream = open(filename, Create, ReadWrite).unwrap();\n+            rw_stream.write(message.as_bytes());\n+        }\n+        {\n+            let mut read_stream = open(filename, Open, Read).unwrap();\n+            {\n+                let read_buf = read_mem.mut_slice(0, 4);\n+                read_stream.read(read_buf);\n+            }\n+            {\n+                let read_buf = read_mem.mut_slice(4, 8);\n+                read_stream.read(read_buf);\n+            }\n+        }\n+        unlink(filename);\n+        let read_str = str::from_bytes(read_mem);\n+        assert!(read_str == message.to_owned());\n+    }\n+}\n+\n+#[test]\n+fn file_test_io_non_positional_read() {\n+    file_test_io_non_positional_read_impl();\n+}\n+\n+fn file_test_io_seeking_impl() {\n+    do run_in_newsched_task {\n+        use str;\n+        let message = \"ten-four\";\n+        let mut read_mem = [0, .. 4];\n+        let set_cursor = 4 as u64;\n+        let mut tell_pos_pre_read;\n+        let mut tell_pos_post_read;\n+        let filename = &Path(\"./tmp/file_rt_io_file_test_seeking.txt\");\n+        {\n+            let mut rw_stream = open(filename, Create, ReadWrite).unwrap();\n+            rw_stream.write(message.as_bytes());\n+        }\n+        {\n+            let mut read_stream = open(filename, Open, Read).unwrap();\n+            read_stream.seek(set_cursor as i64, SeekSet);\n+            tell_pos_pre_read = read_stream.tell();\n+            read_stream.read(read_mem);\n+            tell_pos_post_read = read_stream.tell();\n+        }\n+        unlink(filename);\n+        let read_str = str::from_bytes(read_mem);\n+        assert!(read_str == message.slice(4, 8).to_owned());\n+        assert!(tell_pos_pre_read == set_cursor);\n+        assert!(tell_pos_post_read == message.len() as u64);\n+    }\n+}\n+#[test]\n+fn file_test_io_seek_and_tell_smoke_test() {\n+    file_test_io_seeking_impl();\n+}\n+\n+fn file_test_io_seek_and_write_impl() {\n+    use io;\n+    do run_in_newsched_task {\n+        use str;\n+        let initial_msg =   \"food-is-yummy\";\n+        let overwrite_msg =    \"-the-bar!!\";\n+        let final_msg =     \"foo-the-bar!!\";\n+        let seek_idx = 3;\n+        let mut read_mem = [0, .. 13];\n+        let filename = &Path(\"./tmp/file_rt_io_file_test_seek_and_write.txt\");\n+        {\n+            let mut rw_stream = open(filename, Create, ReadWrite).unwrap();\n+            rw_stream.write(initial_msg.as_bytes());\n+            rw_stream.seek(seek_idx as i64, SeekSet);\n+            rw_stream.write(overwrite_msg.as_bytes());\n+        }\n+        {\n+            let mut read_stream = open(filename, Open, Read).unwrap();\n+            read_stream.read(read_mem);\n+        }\n+        unlink(filename);\n+        let read_str = str::from_bytes(read_mem);\n+        io::println(fmt!(\"read_str: '%?' final_msg: '%?'\", read_str, final_msg));\n+        assert!(read_str == final_msg.to_owned());\n+    }\n+}\n+#[test]\n+fn file_test_io_seek_and_write() {\n+    file_test_io_seek_and_write_impl();\n+}\n+\n+fn file_test_io_seek_shakedown_impl() {\n+    do run_in_newsched_task {\n+        use str;          // 01234567890123\n+        let initial_msg =   \"qwer-asdf-zxcv\";\n+        let chunk_one = \"qwer\";\n+        let chunk_two = \"asdf\";\n+        let chunk_three = \"zxcv\";\n+        let mut read_mem = [0, .. 4];\n+        let filename = &Path(\"./tmp/file_rt_io_file_test_seek_shakedown.txt\");\n+        {\n+            let mut rw_stream = open(filename, Create, ReadWrite).unwrap();\n+            rw_stream.write(initial_msg.as_bytes());\n+        }\n+        {\n+            let mut read_stream = open(filename, Open, Read).unwrap();\n+\n+            read_stream.seek(-4, SeekEnd);\n+            read_stream.read(read_mem);\n+            let read_str = str::from_bytes(read_mem);\n+            assert!(read_str == chunk_three.to_owned());\n+\n+            read_stream.seek(-9, SeekCur);\n+            read_stream.read(read_mem);\n+            let read_str = str::from_bytes(read_mem);\n+            assert!(read_str == chunk_two.to_owned());\n+\n+            read_stream.seek(0, SeekSet);\n+            read_stream.read(read_mem);\n+            let read_str = str::from_bytes(read_mem);\n+            assert!(read_str == chunk_one.to_owned());\n+        }\n+        unlink(filename);\n+    }\n+}\n+#[test]\n+fn file_test_io_seek_shakedown() {\n+    file_test_io_seek_shakedown_impl();\n }"}, {"sha": "116d240308a36c9cabf988df7d4bfe93c6762f53", "filename": "src/libstd/rt/io/mod.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/95c542e7fed0b6a76376f7c1146ac34499bbf238/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95c542e7fed0b6a76376f7c1146ac34499bbf238/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fmod.rs?ref=95c542e7fed0b6a76376f7c1146ac34499bbf238", "patch": "@@ -461,6 +461,7 @@ pub enum SeekStyle {\n /// # XXX\n /// * Are `u64` and `i64` the right choices?\n pub trait Seek {\n+    /// Return position of file cursor in the stream\n     fn tell(&self) -> u64;\n \n     /// Seek to an offset in a stream\n@@ -539,3 +540,27 @@ pub fn placeholder_error() -> IoError {\n         detail: None\n     }\n }\n+\n+/// Instructions on how to open a file and return a `FileStream`.\n+pub enum FileMode {\n+    /// Opens an existing file. IoError if file does not exist.\n+    Open,\n+    /// Creates a file. IoError if file exists.\n+    Create,\n+    /// Opens an existing file or creates a new one.\n+    OpenOrCreate,\n+    /// Opens an existing file or creates a new one, positioned at EOF.\n+    Append,\n+    /// Opens an existing file, truncating it to 0 bytes.\n+    Truncate,\n+    /// Opens an existing file or creates a new one, truncating it to 0 bytes.\n+    CreateOrTruncate,\n+}\n+\n+/// Access permissions with which the file should be opened.\n+/// `FileStream`s opened with `Read` will raise an `io_error` condition if written to.\n+pub enum FileAccess {\n+    Read,\n+    Write,\n+    ReadWrite\n+}"}, {"sha": "1788b7a04e33446c3e8c04b77671481eed5bea29", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/95c542e7fed0b6a76376f7c1146ac34499bbf238/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95c542e7fed0b6a76376f7c1146ac34499bbf238/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=95c542e7fed0b6a76376f7c1146ac34499bbf238", "patch": "@@ -10,10 +10,15 @@\n \n use option::*;\n use result::*;\n+use libc::c_int;\n \n use rt::io::IoError;\n use super::io::net::ip::{IpAddr, SocketAddr};\n use rt::uv::uvio;\n+use path::Path;\n+use super::io::support::PathLike;\n+use super::io::{SeekStyle};\n+use super::io::{FileMode, FileAccess};\n \n // XXX: ~object doesn't work currently so these are some placeholder\n // types to use instead\n@@ -46,11 +51,27 @@ pub trait RemoteCallback {\n     fn fire(&mut self);\n }\n \n+/// Data needed to make a successful open(2) call\n+/// Using unix flag conventions for now, which happens to also be what's supported\n+/// libuv (it does translation to windows under the hood).\n+pub struct FileOpenConfig {\n+    /// Path to file to be opened\n+    path: Path,\n+    /// Flags for file access mode (as per open(2))\n+    flags: int,\n+    /// File creation mode, ignored unless O_CREAT is passed as part of flags\n+    mode: int\n+}\n+\n pub trait IoFactory {\n     fn tcp_connect(&mut self, addr: SocketAddr) -> Result<~RtioTcpStreamObject, IoError>;\n     fn tcp_bind(&mut self, addr: SocketAddr) -> Result<~RtioTcpListenerObject, IoError>;\n     fn udp_bind(&mut self, addr: SocketAddr) -> Result<~RtioUdpSocketObject, IoError>;\n     fn timer_init(&mut self) -> Result<~RtioTimerObject, IoError>;\n+    fn fs_from_raw_fd(&mut self, fd: c_int, close_on_drop: bool) -> ~RtioFileStream;\n+    fn fs_open<P: PathLike>(&mut self, path: &P, fm: FileMode, fa: FileAccess)\n+        -> Result<~RtioFileStream, IoError>;\n+    fn fs_unlink<P: PathLike>(&mut self, path: &P) -> Result<(), IoError>;\n }\n \n pub trait RtioTcpListener : RtioSocket {\n@@ -93,3 +114,13 @@ pub trait RtioUdpSocket : RtioSocket {\n pub trait RtioTimer {\n     fn sleep(&mut self, msecs: u64);\n }\n+\n+pub trait RtioFileStream {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<int, IoError>;\n+    fn write(&mut self, buf: &[u8]) -> Result<(), IoError>;\n+    fn pread(&mut self, buf: &mut [u8], offset: u64) -> Result<int, IoError>;\n+    fn pwrite(&mut self, buf: &[u8], offset: u64) -> Result<(), IoError>;\n+    fn seek(&mut self, pos: i64, whence: SeekStyle) -> Result<u64, IoError>;\n+    fn tell(&self) -> Result<u64, IoError>;\n+    fn flush(&mut self) -> Result<(), IoError>;\n+}"}, {"sha": "405dfe0a7f099b6606a08c4a9f9d2897255b2f69", "filename": "src/libstd/rt/uv/file.rs", "status": "modified", "additions": 397, "deletions": 9, "changes": 406, "blob_url": "https://github.com/rust-lang/rust/blob/95c542e7fed0b6a76376f7c1146ac34499bbf238/src%2Flibstd%2Frt%2Fuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95c542e7fed0b6a76376f7c1146ac34499bbf238/src%2Flibstd%2Frt%2Fuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Ffile.rs?ref=95c542e7fed0b6a76376f7c1146ac34499bbf238", "patch": "@@ -11,30 +11,123 @@\n use prelude::*;\n use ptr::null;\n use libc::c_void;\n-use rt::uv::{Request, NativeHandle, Loop, FsCallback};\n+use rt::uv::{Request, NativeHandle, Loop, FsCallback, Buf,\n+             status_to_maybe_uv_error_with_loop, UvError};\n use rt::uv::uvll;\n use rt::uv::uvll::*;\n+use super::super::io::support::PathLike;\n+use cast::transmute;\n+use libc::{c_int};\n+use option::{None, Some, Option};\n \n pub struct FsRequest(*uvll::uv_fs_t);\n impl Request for FsRequest;\n \n+pub struct RequestData {\n+    complete_cb: Option<FsCallback>,\n+    raw_fd: Option<c_int>\n+}\n+\n impl FsRequest {\n-    fn new() -> FsRequest {\n+    pub fn new(cb: Option<FsCallback>) -> FsRequest {\n         let fs_req = unsafe { malloc_req(UV_FS) };\n         assert!(fs_req.is_not_null());\n-        let fs_req = fs_req as *uvll::uv_write_t;\n-        unsafe { uvll::set_data_for_req(fs_req, null::<()>()); }\n-        NativeHandle::from_native_handle(fs_req)\n+        let fs_req: FsRequest = NativeHandle::from_native_handle(fs_req);\n+        fs_req.install_req_data(cb);\n+        fs_req\n+    }\n+\n+    fn open_common<P: PathLike>(loop_: &Loop, path: &P, flags: int, mode: int,\n+               cb: Option<FsCallback>) -> int {\n+        let complete_cb_ptr = match cb {\n+            Some(_) => compl_cb as *u8,\n+            None => 0 as *u8\n+        };\n+        let is_sync = cb.is_none();\n+        let req = FsRequest::new(cb);\n+        let result = path.path_as_str(|p| {\n+            p.to_c_str().with_ref(|p| unsafe {\n+            uvll::fs_open(loop_.native_handle(),\n+                          req.native_handle(), p, flags, mode, complete_cb_ptr) as int\n+            })\n+        });\n+        if is_sync { req.cleanup_and_delete(); }\n+        result\n+    }\n+    pub fn open<P: PathLike>(loop_: &Loop, path: &P, flags: int, mode: int,\n+               cb: FsCallback) {\n+        FsRequest::open_common(loop_, path, flags, mode, Some(cb));\n+    }\n+\n+    pub fn open_sync<P: PathLike>(loop_: &Loop, path: &P, flags: int, mode: int)\n+          -> Result<int, UvError> {\n+        let result = FsRequest::open_common(loop_, path, flags, mode, None);\n+        sync_cleanup(loop_, result)\n+    }\n+\n+    fn unlink_common<P: PathLike>(loop_: &Loop, path: &P, cb: Option<FsCallback>) -> int {\n+        let complete_cb_ptr = match cb {\n+            Some(_) => compl_cb as *u8,\n+            None => 0 as *u8\n+        };\n+        let is_sync = cb.is_none();\n+        let req = FsRequest::new(cb);\n+        let result = path.path_as_str(|p| {\n+            p.to_c_str().with_ref(|p| unsafe {\n+                uvll::fs_unlink(loop_.native_handle(),\n+                              req.native_handle(), p, complete_cb_ptr) as int\n+            })\n+        });\n+        if is_sync { req.cleanup_and_delete(); }\n+        result\n+    }\n+    pub fn unlink<P: PathLike>(loop_: &Loop, path: &P, cb: FsCallback) {\n+        let result = FsRequest::unlink_common(loop_, path, Some(cb));\n+        sync_cleanup(loop_, result);\n+    }\n+    pub fn unlink_sync<P: PathLike>(loop_: &Loop, path: &P) -> Result<int, UvError> {\n+        let result = FsRequest::unlink_common(loop_, path, None);\n+        sync_cleanup(loop_, result)\n+    }\n+\n+    pub fn install_req_data(&self, cb: Option<FsCallback>) {\n+        let fs_req = (self.native_handle()) as *uvll::uv_write_t;\n+        let data = ~RequestData {\n+            complete_cb: cb,\n+            raw_fd: None\n+        };\n+        unsafe {\n+            let data = transmute::<~RequestData, *c_void>(data);\n+            uvll::set_data_for_req(fs_req, data);\n+        }\n     }\n \n-    fn delete(self) {\n-        unsafe { free_req(self.native_handle() as *c_void) }\n+    fn get_req_data<'r>(&'r mut self) -> &'r mut RequestData {\n+        unsafe {\n+            let data = uvll::get_data_for_req((self.native_handle()));\n+            let data = transmute::<&*c_void, &mut ~RequestData>(&data);\n+            return &mut **data;\n+        }\n     }\n \n-    fn open(&mut self, _loop_: &Loop, _cb: FsCallback) {\n+    pub fn get_result(&mut self) -> c_int {\n+        unsafe {\n+            uvll::get_result_from_fs_req(self.native_handle())\n+        }\n     }\n \n-    fn close(&mut self, _loop_: &Loop, _cb: FsCallback) {\n+    pub fn get_loop(&self) -> Loop {\n+        unsafe { Loop{handle:uvll::get_loop_from_fs_req(self.native_handle())} }\n+    }\n+\n+    fn cleanup_and_delete(self) {\n+        unsafe {\n+            let data = uvll::get_data_for_req(self.native_handle());\n+            let _data = transmute::<*c_void, ~RequestData>(data);\n+            uvll::set_data_for_req(self.native_handle(), null::<()>());\n+            uvll::fs_req_cleanup(self.native_handle());\n+            free_req(self.native_handle() as *c_void)\n+        }\n     }\n }\n \n@@ -45,4 +138,299 @@ impl NativeHandle<*uvll::uv_fs_t> for FsRequest {\n     fn native_handle(&self) -> *uvll::uv_fs_t {\n         match self { &FsRequest(ptr) => ptr }\n     }\n+}\n+    fn sync_cleanup(loop_: &Loop, result: int)\n+          -> Result<int, UvError> {\n+        match status_to_maybe_uv_error_with_loop(loop_.native_handle(), result as i32) {\n+            Some(err) => Err(err),\n+            None => Ok(result)\n+        }\n+    }\n+\n+pub struct FileDescriptor(c_int);\n+impl FileDescriptor {\n+    fn new(fd: c_int) -> FileDescriptor {\n+        FileDescriptor(fd)\n+    }\n+\n+\n+    pub fn from_open_req(req: &mut FsRequest) -> FileDescriptor {\n+        FileDescriptor::new(req.get_result())\n+    }\n+\n+    // as per bnoordhuis in #libuv: offset >= 0 uses prwrite instead of write\n+    fn write_common(&mut self, loop_: &Loop, buf: Buf, offset: i64, cb: Option<FsCallback>)\n+          -> int {\n+        let complete_cb_ptr = match cb {\n+            Some(_) => compl_cb as *u8,\n+            None => 0 as *u8\n+        };\n+        let is_sync = cb.is_none();\n+        let mut req = FsRequest::new(cb);\n+        let base_ptr = buf.base as *c_void;\n+        let len = buf.len as uint;\n+        req.get_req_data().raw_fd = Some(self.native_handle());\n+        let result = unsafe {\n+            uvll::fs_write(loop_.native_handle(), req.native_handle(),\n+                           self.native_handle(), base_ptr,\n+                           len, offset, complete_cb_ptr) as int\n+        };\n+        if is_sync { req.cleanup_and_delete(); }\n+        result\n+    }\n+    pub fn write(&mut self, loop_: &Loop, buf: Buf, offset: i64, cb: FsCallback) {\n+        self.write_common(loop_, buf, offset, Some(cb));\n+    }\n+    pub fn write_sync(&mut self, loop_: &Loop, buf: Buf, offset: i64)\n+          -> Result<int, UvError> {\n+        let result = self.write_common(loop_, buf, offset, None);\n+        sync_cleanup(loop_, result)\n+    }\n+\n+    fn read_common(&mut self, loop_: &Loop, buf: Buf,\n+                   offset: i64, cb: Option<FsCallback>)\n+          -> int {\n+        let complete_cb_ptr = match cb {\n+            Some(_) => compl_cb as *u8,\n+            None => 0 as *u8\n+        };\n+        let is_sync = cb.is_none();\n+        let mut req = FsRequest::new(cb);\n+        req.get_req_data().raw_fd = Some(self.native_handle());\n+        let buf_ptr = buf.base as *c_void;\n+        let result = unsafe {\n+            uvll::fs_read(loop_.native_handle(), req.native_handle(),\n+                           self.native_handle(), buf_ptr,\n+                           buf.len as uint, offset, complete_cb_ptr) as int\n+        };\n+        if is_sync { req.cleanup_and_delete(); }\n+        result\n+    }\n+    pub fn read(&mut self, loop_: &Loop, buf: Buf, offset: i64, cb: FsCallback) {\n+        self.read_common(loop_, buf, offset, Some(cb));\n+    }\n+    pub fn read_sync(&mut self, loop_: &Loop, buf: Buf, offset: i64)\n+          -> Result<int, UvError> {\n+        let result = self.read_common(loop_, buf, offset, None);\n+        sync_cleanup(loop_, result)\n+    }\n+\n+    fn close_common(self, loop_: &Loop, cb: Option<FsCallback>) -> int {\n+        let complete_cb_ptr = match cb {\n+            Some(_) => compl_cb as *u8,\n+            None => 0 as *u8\n+        };\n+        let is_sync = cb.is_none();\n+        let req = FsRequest::new(cb);\n+        let result = unsafe {\n+            uvll::fs_close(loop_.native_handle(), req.native_handle(),\n+                           self.native_handle(), complete_cb_ptr) as int\n+        };\n+        if is_sync { req.cleanup_and_delete(); }\n+        result\n+    }\n+    pub fn close(self, loop_: &Loop, cb: FsCallback) {\n+        self.close_common(loop_, Some(cb));\n+    }\n+    pub fn close_sync(self, loop_: &Loop) -> Result<int, UvError> {\n+        let result = self.close_common(loop_, None);\n+        sync_cleanup(loop_, result)\n+    }\n+}\n+extern fn compl_cb(req: *uv_fs_t) {\n+    let mut req: FsRequest = NativeHandle::from_native_handle(req);\n+    let loop_ = req.get_loop();\n+    // pull the user cb out of the req data\n+    let cb = {\n+        let data = req.get_req_data();\n+        assert!(data.complete_cb.is_some());\n+        // option dance, option dance. oooooh yeah.\n+        data.complete_cb.take_unwrap()\n+    };\n+    // in uv_fs_open calls, the result will be the fd in the\n+    // case of success, otherwise it's -1 indicating an error\n+    let result = req.get_result();\n+    let status = status_to_maybe_uv_error_with_loop(\n+        loop_.native_handle(), result);\n+    // we have a req and status, call the user cb..\n+    // only giving the user a ref to the FsRequest, as we\n+    // have to clean it up, afterwards (and they aren't really\n+    // reusable, anyways\n+    cb(&mut req, status);\n+    // clean up the req (and its data!) after calling the user cb\n+    req.cleanup_and_delete();\n+}\n+\n+impl NativeHandle<c_int> for FileDescriptor {\n+    fn from_native_handle(handle: c_int) -> FileDescriptor {\n+        FileDescriptor(handle)\n+    }\n+    fn native_handle(&self) -> c_int {\n+        match self { &FileDescriptor(ptr) => ptr }\n+    }\n+}\n+\n+mod test {\n+    use super::*;\n+    //use rt::test::*;\n+    use libc::{STDOUT_FILENO};\n+    use vec;\n+    use str;\n+    use unstable::run_in_bare_thread;\n+    use path::Path;\n+    use rt::uv::{Loop, Buf, slice_to_uv_buf};\n+    use libc::{O_CREAT, O_RDWR, O_RDONLY,\n+               S_IWUSR, S_IRUSR}; //NOTE: need defs for S_**GRP|S_**OTH in libc:: ...\n+               //S_IRGRP, S_IROTH};\n+\n+    fn file_test_full_simple_impl() {\n+        do run_in_bare_thread {\n+            let mut loop_ = Loop::new();\n+            let create_flags = O_RDWR | O_CREAT;\n+            let read_flags = O_RDONLY;\n+            // 0644 BZZT! WRONG! 0600! See below.\n+            let mode = S_IWUSR |S_IRUSR;\n+                // these aren't defined in std::libc :(\n+                //map_mode(S_IRGRP) |\n+                //map_mode(S_IROTH);\n+            let path_str = \"./tmp/file_full_simple.txt\";\n+            let write_val = \"hello\".as_bytes().to_owned();\n+            let write_buf  = slice_to_uv_buf(write_val);\n+            let write_buf_ptr: *Buf = &write_buf;\n+            let read_buf_len = 1028;\n+            let read_mem = vec::from_elem(read_buf_len, 0u8);\n+            let read_buf = slice_to_uv_buf(read_mem);\n+            let read_buf_ptr: *Buf = &read_buf;\n+            let p = Path(path_str);\n+            do FsRequest::open(&loop_, &p, create_flags as int, mode as int)\n+            |req, uverr| {\n+                assert!(uverr.is_none());\n+                let mut fd = FileDescriptor::from_open_req(req);\n+                let raw_fd = fd.native_handle();\n+                let buf = unsafe { *write_buf_ptr };\n+                do fd.write(&req.get_loop(), buf, -1) |req, uverr| {\n+                    let fd = FileDescriptor(raw_fd);\n+                    do fd.close(&req.get_loop()) |req, _| {\n+                        let loop_ = req.get_loop();\n+                        assert!(uverr.is_none());\n+                        do FsRequest::open(&loop_, &Path(path_str), read_flags as int,0)\n+                            |req, uverr| {\n+                            assert!(uverr.is_none());\n+                            let loop_ = req.get_loop();\n+                            let mut fd = FileDescriptor::from_open_req(req);\n+                            let raw_fd = fd.native_handle();\n+                            let read_buf = unsafe { *read_buf_ptr };\n+                            do fd.read(&loop_, read_buf, 0) |req, uverr| {\n+                                assert!(uverr.is_none());\n+                                let loop_ = req.get_loop();\n+                                // we know nread >=0 because uverr is none..\n+                                let nread = req.get_result() as uint;\n+                                // nread == 0 would be EOF\n+                                if nread > 0 {\n+                                    let read_str = unsafe {\n+                                        let read_buf = *read_buf_ptr;\n+                                        str::from_bytes(\n+                                            vec::from_buf(\n+                                                read_buf.base, nread))\n+                                    };\n+                                    assert!(read_str == ~\"hello\");\n+                                    do FileDescriptor(raw_fd).close(&loop_) |req,uverr| {\n+                                        assert!(uverr.is_none());\n+                                        let loop_ = &req.get_loop();\n+                                        do FsRequest::unlink(loop_, &Path(path_str))\n+                                        |_,uverr| {\n+                                            assert!(uverr.is_none());\n+                                        };\n+                                    };\n+                                }\n+                            };\n+                        };\n+                    };\n+                };\n+            };\n+            loop_.run();\n+            loop_.close();\n+        }\n+    }\n+    fn file_test_full_simple_impl_sync() {\n+        do run_in_bare_thread {\n+            // setup\n+            let mut loop_ = Loop::new();\n+            let create_flags = O_RDWR |\n+                O_CREAT;\n+            let read_flags = O_RDONLY;\n+            // 0644\n+            let mode = S_IWUSR |\n+                S_IRUSR;\n+                //S_IRGRP |\n+                //S_IROTH;\n+            let path_str = \"./tmp/file_full_simple_sync.txt\";\n+            let write_val = \"hello\".as_bytes().to_owned();\n+            let write_buf = slice_to_uv_buf(write_val);\n+            // open/create\n+            let result = FsRequest::open_sync(&loop_, &Path(path_str),\n+                                                   create_flags as int, mode as int);\n+            assert!(result.is_ok());\n+            let mut fd = FileDescriptor(result.unwrap() as i32);\n+            // write\n+            let result = fd.write_sync(&loop_, write_buf, -1);\n+            assert!(result.is_ok());\n+            // close\n+            let result = fd.close_sync(&loop_);\n+            assert!(result.is_ok());\n+            // re-open\n+            let result = FsRequest::open_sync(&loop_, &Path(path_str),\n+                                                   read_flags as int,0);\n+            assert!(result.is_ok());\n+            let len = 1028;\n+            let mut fd = FileDescriptor(result.unwrap() as i32);\n+            // read\n+            let read_mem: ~[u8] = vec::from_elem(len, 0u8);\n+            let buf = slice_to_uv_buf(read_mem);\n+            let result = fd.read_sync(&loop_, buf, 0);\n+            assert!(result.is_ok());\n+            let nread = result.unwrap();\n+            // nread == 0 would be EOF.. we know it's >= zero because otherwise\n+            // the above assert would fail\n+            if nread > 0 {\n+                let read_str = str::from_bytes(\n+                    read_mem.slice(0, nread as uint));\n+                assert!(read_str == ~\"hello\");\n+                // close\n+                let result = fd.close_sync(&loop_);\n+                assert!(result.is_ok());\n+                // unlink\n+                let result = FsRequest::unlink_sync(&loop_, &Path(path_str));\n+                assert!(result.is_ok());\n+            } else { fail!(\"nread was 0.. wudn't expectin' that.\"); }\n+            loop_.close();\n+        }\n+    }\n+\n+    #[test]\n+    fn file_test_full_simple() {\n+        file_test_full_simple_impl();\n+    }\n+\n+    #[test]\n+    fn file_test_full_simple_sync() {\n+        file_test_full_simple_impl_sync();\n+    }\n+\n+    fn naive_print(loop_: &Loop, input: &str) {\n+        let mut stdout = FileDescriptor(STDOUT_FILENO);\n+        let write_val = input.as_bytes();\n+        let write_buf = slice_to_uv_buf(write_val);\n+        stdout.write_sync(loop_, write_buf, -1);\n+    }\n+\n+    #[test]\n+    fn file_test_write_to_stdout() {\n+        do run_in_bare_thread {\n+            let mut loop_ = Loop::new();\n+            naive_print(&loop_, \"zanzibar!\\n\");\n+            loop_.run();\n+            loop_.close();\n+        };\n+    }\n }"}, {"sha": "75b9a5ac553e8eff77d5d096730081f2e12cd902", "filename": "src/libstd/rt/uv/mod.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/95c542e7fed0b6a76376f7c1146ac34499bbf238/src%2Flibstd%2Frt%2Fuv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95c542e7fed0b6a76376f7c1146ac34499bbf238/src%2Flibstd%2Frt%2Fuv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fmod.rs?ref=95c542e7fed0b6a76376f7c1146ac34499bbf238", "patch": "@@ -53,7 +53,7 @@ use rt::io::IoError;\n \n //#[cfg(test)] use unstable::run_in_bare_thread;\n \n-pub use self::file::FsRequest;\n+pub use self::file::{FsRequest};\n pub use self::net::{StreamWatcher, TcpWatcher, UdpWatcher};\n pub use self::idle::IdleWatcher;\n pub use self::timer::TimerWatcher;\n@@ -125,7 +125,7 @@ pub type ReadCallback = ~fn(StreamWatcher, int, Buf, Option<UvError>);\n pub type NullCallback = ~fn();\n pub type IdleCallback = ~fn(IdleWatcher, Option<UvError>);\n pub type ConnectionCallback = ~fn(StreamWatcher, Option<UvError>);\n-pub type FsCallback = ~fn(FsRequest, Option<UvError>);\n+pub type FsCallback = ~fn(&mut FsRequest, Option<UvError>);\n pub type TimerCallback = ~fn(TimerWatcher, Option<UvError>);\n pub type AsyncCallback = ~fn(AsyncWatcher, Option<UvError>);\n pub type UdpReceiveCallback = ~fn(UdpWatcher, int, Buf, SocketAddr, uint, Option<UvError>);\n@@ -281,6 +281,20 @@ pub fn uv_error_to_io_error(uverr: UvError) -> IoError {\n     }\n }\n \n+/// Given a uv handle, convert a callback status to a UvError\n+pub fn status_to_maybe_uv_error_with_loop(\n+    loop_: *uvll::uv_loop_t,\n+    status: c_int) -> Option<UvError> {\n+    if status != -1 {\n+        None\n+    } else {\n+        unsafe {\n+            rtdebug!(\"loop: %x\", loop_ as uint);\n+            let err = uvll::last_error(loop_);\n+            Some(UvError(err))\n+        }\n+    }\n+}\n /// Given a uv handle, convert a callback status to a UvError\n pub fn status_to_maybe_uv_error<T, U: Watcher + NativeHandle<*T>>(handle: U,\n                                                                  status: c_int) -> Option<UvError> {\n@@ -290,9 +304,7 @@ pub fn status_to_maybe_uv_error<T, U: Watcher + NativeHandle<*T>>(handle: U,\n         unsafe {\n             rtdebug!(\"handle: %x\", handle.native_handle() as uint);\n             let loop_ = uvll::get_loop_for_uv_handle(handle.native_handle());\n-            rtdebug!(\"loop: %x\", loop_ as uint);\n-            let err = uvll::last_error(loop_);\n-            Some(UvError(err))\n+            status_to_maybe_uv_error_with_loop(loop_, status)\n         }\n     }\n }"}, {"sha": "f794c0a2bec5ff84e955972824add2b279a3bd44", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 279, "deletions": 1, "changes": 280, "blob_url": "https://github.com/rust-lang/rust/blob/95c542e7fed0b6a76376f7c1146ac34499bbf238/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95c542e7fed0b6a76376f7c1146ac34499bbf238/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=95c542e7fed0b6a76376f7c1146ac34499bbf238", "patch": "@@ -17,10 +17,11 @@ use libc::{c_int, c_uint, c_void};\n use ops::Drop;\n use option::*;\n use ptr;\n+use str;\n use result::*;\n use rt::io::IoError;\n use rt::io::net::ip::{SocketAddr, IpAddr};\n-use rt::io::{standard_error, OtherIoError};\n+use rt::io::{standard_error, OtherIoError, SeekStyle, SeekSet, SeekCur, SeekEnd};\n use rt::local::Local;\n use rt::rtio::*;\n use rt::sched::{Scheduler, SchedHandle};\n@@ -29,6 +30,11 @@ use rt::uv::*;\n use rt::uv::idle::IdleWatcher;\n use rt::uv::net::{UvIpv4SocketAddr, UvIpv6SocketAddr};\n use unstable::sync::Exclusive;\n+use super::super::io::support::PathLike;\n+use libc::{lseek, off_t, O_CREAT, O_APPEND, O_TRUNC, O_RDWR, O_RDONLY, O_WRONLY,\n+          S_IRUSR, S_IWUSR};\n+use rt::io::{FileMode, FileAccess, OpenOrCreate, Open, Create,\n+            CreateOrTruncate, Append, Truncate, Read, Write, ReadWrite};\n \n #[cfg(test)] use container::Container;\n #[cfg(test)] use unstable::run_in_bare_thread;\n@@ -455,6 +461,87 @@ impl IoFactory for UvIoFactory {\n         let home = get_handle_to_current_scheduler!();\n         Ok(~UvTimer::new(watcher, home))\n     }\n+\n+    fn fs_from_raw_fd(&mut self, fd: c_int, close_on_drop: bool) -> ~RtioFileStream {\n+        let loop_ = Loop {handle: self.uv_loop().native_handle()};\n+        let fd = file::FileDescriptor(fd);\n+        let home = get_handle_to_current_scheduler!();\n+        ~UvFileStream::new(loop_, fd, close_on_drop, home) as ~RtioFileStream\n+    }\n+\n+    fn fs_open<P: PathLike>(&mut self, path: &P, fm: FileMode, fa: FileAccess)\n+        -> Result<~RtioFileStream, IoError> {\n+        let mut flags = match fm {\n+            Open => 0,\n+            Create => O_CREAT,\n+            OpenOrCreate => O_CREAT,\n+            Append => O_APPEND,\n+            Truncate => O_TRUNC,\n+            CreateOrTruncate => O_TRUNC | O_CREAT\n+        };\n+        flags = match fa {\n+            Read => flags | O_RDONLY,\n+            Write => flags | O_WRONLY,\n+            ReadWrite => flags | O_RDWR\n+        };\n+        let create_mode = match fm {\n+            Create|OpenOrCreate|CreateOrTruncate =>\n+                S_IRUSR | S_IWUSR,\n+            _ => 0\n+        };\n+        let result_cell = Cell::new_empty();\n+        let result_cell_ptr: *Cell<Result<~RtioFileStream,\n+                                           IoError>> = &result_cell;\n+        let path_cell = Cell::new(path);\n+        let scheduler = Local::take::<Scheduler>();\n+        do scheduler.deschedule_running_task_and_then |_, task| {\n+            let task_cell = Cell::new(task);\n+            let path = path_cell.take();\n+            do file::FsRequest::open(self.uv_loop(), path, flags as int, create_mode as int)\n+                  |req,err| {\n+                if err.is_none() {\n+                    let loop_ = Loop {handle: req.get_loop().native_handle()};\n+                    let home = get_handle_to_current_scheduler!();\n+                    let fd = file::FileDescriptor(req.get_result());\n+                    let fs = ~UvFileStream::new(\n+                        loop_, fd, true, home) as ~RtioFileStream;\n+                    let res = Ok(fs);\n+                    unsafe { (*result_cell_ptr).put_back(res); }\n+                    let scheduler = Local::take::<Scheduler>();\n+                    scheduler.resume_blocked_task_immediately(task_cell.take());\n+                } else {\n+                    let res = Err(uv_error_to_io_error(err.unwrap()));\n+                    unsafe { (*result_cell_ptr).put_back(res); }\n+                    let scheduler = Local::take::<Scheduler>();\n+                    scheduler.resume_blocked_task_immediately(task_cell.take());\n+                }\n+            };\n+        };\n+        assert!(!result_cell.is_empty());\n+        return result_cell.take();\n+    }\n+\n+    fn fs_unlink<P: PathLike>(&mut self, path: &P) -> Result<(), IoError> {\n+        let result_cell = Cell::new_empty();\n+        let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n+        let path_cell = Cell::new(path);\n+        let scheduler = Local::take::<Scheduler>();\n+        do scheduler.deschedule_running_task_and_then |_, task| {\n+            let task_cell = Cell::new(task);\n+            let path = path_cell.take();\n+            do file::FsRequest::unlink(self.uv_loop(), path) |_, err| {\n+                let res = match err {\n+                    None => Ok(()),\n+                    Some(err) => Err(uv_error_to_io_error(err))\n+                };\n+                unsafe { (*result_cell_ptr).put_back(res); }\n+                let scheduler = Local::take::<Scheduler>();\n+                scheduler.resume_blocked_task_immediately(task_cell.take());\n+            };\n+        };\n+        assert!(!result_cell.is_empty());\n+        return result_cell.take();\n+    }\n }\n \n pub struct UvTcpListener {\n@@ -992,6 +1079,140 @@ impl RtioTimer for UvTimer {\n     }\n }\n \n+pub struct UvFileStream {\n+    loop_: Loop,\n+    fd: file::FileDescriptor,\n+    close_on_drop: bool,\n+    home: SchedHandle\n+}\n+\n+impl HomingIO for UvFileStream {\n+    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n+}\n+\n+impl UvFileStream {\n+    fn new(loop_: Loop, fd: file::FileDescriptor, close_on_drop: bool,\n+           home: SchedHandle) -> UvFileStream {\n+        UvFileStream {\n+            loop_: loop_,\n+            fd: fd,\n+            close_on_drop: close_on_drop,\n+            home: home\n+        }\n+    }\n+    fn base_read(&mut self, buf: &mut [u8], offset: i64) -> Result<int, IoError> {\n+        let result_cell = Cell::new_empty();\n+        let result_cell_ptr: *Cell<Result<int, IoError>> = &result_cell;\n+        let buf_ptr: *&mut [u8] = &buf;\n+        do self.home_for_io |self_| {\n+            let scheduler = Local::take::<Scheduler>();\n+            do scheduler.deschedule_running_task_and_then |_, task| {\n+                let buf = unsafe { slice_to_uv_buf(*buf_ptr) };\n+                let task_cell = Cell::new(task);\n+                do self_.fd.read(&self_.loop_, buf, offset) |req, uverr| {\n+                    let res = match uverr  {\n+                        None => Ok(req.get_result() as int),\n+                        Some(err) => Err(uv_error_to_io_error(err))\n+                    };\n+                    unsafe { (*result_cell_ptr).put_back(res); }\n+                    let scheduler = Local::take::<Scheduler>();\n+                    scheduler.resume_blocked_task_immediately(task_cell.take());\n+                };\n+            };\n+        };\n+        result_cell.take()\n+    }\n+    fn base_write(&mut self, buf: &[u8], offset: i64) -> Result<(), IoError> {\n+        let result_cell = Cell::new_empty();\n+        let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n+        let buf_ptr: *&[u8] = &buf;\n+        do self.home_for_io |self_| {\n+            let scheduler = Local::take::<Scheduler>();\n+            do scheduler.deschedule_running_task_and_then |_, task| {\n+                let buf = unsafe { slice_to_uv_buf(*buf_ptr) };\n+                let task_cell = Cell::new(task);\n+                do self_.fd.write(&self_.loop_, buf, offset) |_, uverr| {\n+                    let res = match uverr  {\n+                        None => Ok(()),\n+                        Some(err) => Err(uv_error_to_io_error(err))\n+                    };\n+                    unsafe { (*result_cell_ptr).put_back(res); }\n+                    let scheduler = Local::take::<Scheduler>();\n+                    scheduler.resume_blocked_task_immediately(task_cell.take());\n+                };\n+            };\n+        };\n+        result_cell.take()\n+    }\n+    fn seek_common(&mut self, pos: i64, whence: c_int) ->\n+        Result<u64, IoError>{\n+        #[fixed_stack_segment]; #[inline(never)];\n+        unsafe {\n+            match lseek((*self.fd), pos as off_t, whence) {\n+                -1 => {\n+                    Err(IoError {\n+                        kind: OtherIoError,\n+                        desc: \"Failed to lseek.\",\n+                        detail: None\n+                    })\n+                },\n+                n => Ok(n as u64)\n+            }\n+        }\n+    }\n+}\n+\n+impl Drop for UvFileStream {\n+    fn drop(&self) {\n+        let self_ = unsafe { transmute::<&UvFileStream, &mut UvFileStream>(self) };\n+        if self.close_on_drop {\n+            do self_.home_for_io |self_| {\n+                let scheduler = Local::take::<Scheduler>();\n+                do scheduler.deschedule_running_task_and_then |_, task| {\n+                    let task_cell = Cell::new(task);\n+                    do self_.fd.close(&self.loop_) |_,_| {\n+                        let scheduler = Local::take::<Scheduler>();\n+                        scheduler.resume_blocked_task_immediately(task_cell.take());\n+                    };\n+                };\n+            }\n+        }\n+    }\n+}\n+\n+impl RtioFileStream for UvFileStream {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<int, IoError> {\n+        self.base_read(buf, -1)\n+    }\n+    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n+        self.base_write(buf, -1)\n+    }\n+    fn pread(&mut self, buf: &mut [u8], offset: u64) -> Result<int, IoError> {\n+        self.base_read(buf, offset as i64)\n+    }\n+    fn pwrite(&mut self, buf: &[u8], offset: u64) -> Result<(), IoError> {\n+        self.base_write(buf, offset as i64)\n+    }\n+    fn seek(&mut self, pos: i64, whence: SeekStyle) -> Result<u64, IoError> {\n+        use libc::{SEEK_SET, SEEK_CUR, SEEK_END};\n+        let whence = match whence {\n+            SeekSet => SEEK_SET,\n+            SeekCur => SEEK_CUR,\n+            SeekEnd => SEEK_END\n+        };\n+        self.seek_common(pos, whence)\n+    }\n+    fn tell(&self) -> Result<u64, IoError> {\n+        use libc::SEEK_CUR;\n+        // this is temporary\n+        let self_ = unsafe { cast::transmute::<&UvFileStream, &mut UvFileStream>(self) };\n+        self_.seek_common(0, SEEK_CUR)\n+    }\n+    fn flush(&mut self) -> Result<(), IoError> {\n+        Ok(())\n+    }\n+}\n+\n #[test]\n fn test_simple_io_no_connect() {\n     do run_in_newsched_task {\n@@ -1498,3 +1719,60 @@ fn test_timer_sleep_simple() {\n         }\n     }\n }\n+\n+fn file_test_uvio_full_simple_impl() {\n+    use str::StrSlice; // why does this have to be explicitly imported to work?\n+                       // compiler was complaining about no trait for str that\n+                       // does .as_bytes() ..\n+    use path::Path;\n+    use rt::io::{Open, Create, ReadWrite, Read};\n+    unsafe {\n+        let io = Local::unsafe_borrow::<IoFactoryObject>();\n+        let write_val = \"hello uvio!\";\n+        let path = \"./tmp/file_test_uvio_full.txt\";\n+        {\n+            let create_fm = Create;\n+            let create_fa = ReadWrite;\n+            let mut fd = (*io).fs_open(&Path(path), create_fm, create_fa).unwrap();\n+            let write_buf = write_val.as_bytes();\n+            fd.write(write_buf);\n+        }\n+        {\n+            let ro_fm = Open;\n+            let ro_fa = Read;\n+            let mut fd = (*io).fs_open(&Path(path), ro_fm, ro_fa).unwrap();\n+            let mut read_vec = [0, .. 1028];\n+            let nread = fd.read(read_vec).unwrap();\n+            let read_val = str::from_bytes(read_vec.slice(0, nread as uint));\n+            assert!(read_val == write_val.to_owned());\n+        }\n+        (*io).fs_unlink(&Path(path));\n+    }\n+}\n+\n+#[test]\n+fn file_test_uvio_full_simple() {\n+    do run_in_newsched_task {\n+        file_test_uvio_full_simple_impl();\n+    }\n+}\n+\n+fn uvio_naive_print(input: &str) {\n+    use str::StrSlice;\n+    unsafe {\n+        use libc::{STDOUT_FILENO};\n+        let io = Local::unsafe_borrow::<IoFactoryObject>();\n+        {\n+            let mut fd = (*io).fs_from_raw_fd(STDOUT_FILENO, false);\n+            let write_buf = input.as_bytes();\n+            fd.write(write_buf);\n+        }\n+    }\n+}\n+\n+#[test]\n+fn file_test_uvio_write_to_stdout() {\n+    do run_in_newsched_task {\n+        uvio_naive_print(\"jubilation\\n\");\n+    }\n+}"}, {"sha": "1e189e90885501b981f635e81576b3f8ed77e95e", "filename": "src/libstd/rt/uv/uvll.rs", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/95c542e7fed0b6a76376f7c1146ac34499bbf238/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95c542e7fed0b6a76376f7c1146ac34499bbf238/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs?ref=95c542e7fed0b6a76376f7c1146ac34499bbf238", "patch": "@@ -617,7 +617,54 @@ pub unsafe fn ip6_port(addr: *sockaddr_in6) -> c_uint {\n     return rust_uv_ip6_port(addr);\n }\n \n+pub unsafe fn fs_open(loop_ptr: *uv_loop_t, req: *uv_fs_t, path: *c_char, flags: int, mode: int,\n+                cb: *u8) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    rust_uv_fs_open(loop_ptr, req, path, flags as c_int, mode as c_int, cb)\n+}\n+\n+pub unsafe fn fs_unlink(loop_ptr: *uv_loop_t, req: *uv_fs_t, path: *c_char,\n+                cb: *u8) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    rust_uv_fs_unlink(loop_ptr, req, path, cb)\n+}\n+pub unsafe fn fs_write(loop_ptr: *uv_loop_t, req: *uv_fs_t, fd: c_int, buf: *c_void,\n+                       len: uint, offset: i64, cb: *u8) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    rust_uv_fs_write(loop_ptr, req, fd, buf, len as c_uint, offset, cb)\n+}\n+pub unsafe fn fs_read(loop_ptr: *uv_loop_t, req: *uv_fs_t, fd: c_int, buf: *c_void,\n+                       len: uint, offset: i64, cb: *u8) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    rust_uv_fs_read(loop_ptr, req, fd, buf, len as c_uint, offset, cb)\n+}\n+pub unsafe fn fs_close(loop_ptr: *uv_loop_t, req: *uv_fs_t, fd: c_int,\n+                cb: *u8) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    rust_uv_fs_close(loop_ptr, req, fd, cb)\n+}\n+pub unsafe fn fs_req_cleanup(req: *uv_fs_t) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    rust_uv_fs_req_cleanup(req);\n+}\n+\n // data access helpers\n+pub unsafe fn get_result_from_fs_req(req: *uv_fs_t) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    rust_uv_get_result_from_fs_req(req)\n+}\n+pub unsafe fn get_loop_from_fs_req(req: *uv_fs_t) -> *uv_loop_t {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    rust_uv_get_loop_from_fs_req(req)\n+}\n pub unsafe fn get_loop_for_uv_handle<T>(handle: *T) -> *c_void {\n     #[fixed_stack_segment]; #[inline(never)];\n \n@@ -784,6 +831,19 @@ extern {\n     fn rust_uv_timer_start(timer_handle: *uv_timer_t, cb: uv_timer_cb, timeout: libc::uint64_t,\n                            repeat: libc::uint64_t) -> c_int;\n     fn rust_uv_timer_stop(handle: *uv_timer_t) -> c_int;\n+    fn rust_uv_fs_open(loop_ptr: *c_void, req: *uv_fs_t, path: *c_char,\n+                       flags: c_int, mode: c_int, cb: *u8) -> c_int;\n+    fn rust_uv_fs_unlink(loop_ptr: *c_void, req: *uv_fs_t, path: *c_char,\n+                       cb: *u8) -> c_int;\n+    fn rust_uv_fs_write(loop_ptr: *c_void, req: *uv_fs_t, fd: c_int,\n+                       buf: *c_void, len: c_uint, offset: i64, cb: *u8) -> c_int;\n+    fn rust_uv_fs_read(loop_ptr: *c_void, req: *uv_fs_t, fd: c_int,\n+                       buf: *c_void, len: c_uint, offset: i64, cb: *u8) -> c_int;\n+    fn rust_uv_fs_close(loop_ptr: *c_void, req: *uv_fs_t, fd: c_int,\n+                        cb: *u8) -> c_int;\n+    fn rust_uv_fs_req_cleanup(req: *uv_fs_t);\n+    fn rust_uv_get_result_from_fs_req(req: *uv_fs_t) -> c_int;\n+    fn rust_uv_get_loop_from_fs_req(req: *uv_fs_t) -> *uv_loop_t;\n \n     fn rust_uv_get_stream_handle_from_connect_req(connect_req: *uv_connect_t) -> *uv_stream_t;\n     fn rust_uv_get_stream_handle_from_write_req(write_req: *uv_write_t) -> *uv_stream_t;"}, {"sha": "8ef4572f8108f0170b577359475da5cde9fbad4b", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/95c542e7fed0b6a76376f7c1146ac34499bbf238/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/95c542e7fed0b6a76376f7c1146ac34499bbf238/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=95c542e7fed0b6a76376f7c1146ac34499bbf238", "patch": "@@ -517,3 +517,39 @@ extern \"C\" uintptr_t\n rust_uv_req_type_max() {\n   return UV_REQ_TYPE_MAX;\n }\n+\n+extern \"C\" int\n+rust_uv_fs_open(uv_loop_t* loop, uv_fs_t* req, const char* path, int flags,\n+                int mode, uv_fs_cb cb) {\n+  return uv_fs_open(loop, req, path, flags, mode, cb);\n+}\n+extern \"C\" int\n+rust_uv_fs_unlink(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb) {\n+  return uv_fs_unlink(loop, req, path, cb);\n+}\n+extern \"C\" int\n+rust_uv_fs_write(uv_loop_t* loop, uv_fs_t* req, uv_file fd, void* buf,\n+                 size_t len, int64_t offset, uv_fs_cb cb) {\n+  return uv_fs_write(loop, req, fd, buf, len, offset, cb);\n+}\n+extern \"C\" int\n+rust_uv_fs_read(uv_loop_t* loop, uv_fs_t* req, uv_file fd, void* buf,\n+                 size_t len, int64_t offset, uv_fs_cb cb) {\n+  return uv_fs_read(loop, req, fd, buf, len, offset, cb);\n+}\n+extern \"C\" int\n+rust_uv_fs_close(uv_loop_t* loop, uv_fs_t* req, uv_file fd, uv_fs_cb cb) {\n+  return uv_fs_close(loop, req, fd, cb);\n+}\n+extern \"C\" void\n+rust_uv_fs_req_cleanup(uv_fs_t* req) {\n+  uv_fs_req_cleanup(req);\n+}\n+extern \"C\" int\n+rust_uv_get_result_from_fs_req(uv_fs_t* req) {\n+  return req->result;\n+}\n+extern \"C\" uv_loop_t*\n+rust_uv_get_loop_from_fs_req(uv_fs_t* req) {\n+  return req->loop;\n+}"}, {"sha": "5100e732308f2dbeb39d38460a751ff44e3e5c31", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/95c542e7fed0b6a76376f7c1146ac34499bbf238/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/95c542e7fed0b6a76376f7c1146ac34499bbf238/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=95c542e7fed0b6a76376f7c1146ac34499bbf238", "patch": "@@ -108,6 +108,14 @@ rust_uv_idle_delete\n rust_uv_idle_init\n rust_uv_idle_start\n rust_uv_idle_stop\n+rust_uv_fs_open\n+rust_uv_fs_unlink\n+rust_uv_fs_write\n+rust_uv_fs_read\n+rust_uv_fs_close\n+rust_uv_get_result_from_fs_req\n+rust_uv_get_loop_from_fs_req\n+rust_uv_fs_req_cleanup\n rust_dbg_lock_create\n rust_dbg_lock_destroy\n rust_dbg_lock_lock"}]}