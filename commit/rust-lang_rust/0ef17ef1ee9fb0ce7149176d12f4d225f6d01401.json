{"sha": "0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlZjE3ZWYxZWU5ZmIwY2U3MTQ5MTc2ZDEyZjRkMjI1ZjZkMDE0MDE=", "commit": {"author": {"name": "vsrs", "email": "vit@conrlab.com", "date": "2020-05-08T16:34:34Z"}, "committer": {"name": "vsrs", "email": "vit@conrlab.com", "date": "2020-05-08T16:34:34Z"}, "message": "Merge remote-tracking branch 'upstream/master' into uniformed_debug_lens\n\n# Conflicts:\n#\teditors/code/src/commands/runnables.ts", "tree": {"sha": "fa2f168120f36f8dbef5dc1e85fea0c0071639c2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa2f168120f36f8dbef5dc1e85fea0c0071639c2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "html_url": "https://github.com/rust-lang/rust/commit/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/comments", "author": {"login": "vsrs", "id": 62505555, "node_id": "MDQ6VXNlcjYyNTA1NTU1", "avatar_url": "https://avatars.githubusercontent.com/u/62505555?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vsrs", "html_url": "https://github.com/vsrs", "followers_url": "https://api.github.com/users/vsrs/followers", "following_url": "https://api.github.com/users/vsrs/following{/other_user}", "gists_url": "https://api.github.com/users/vsrs/gists{/gist_id}", "starred_url": "https://api.github.com/users/vsrs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vsrs/subscriptions", "organizations_url": "https://api.github.com/users/vsrs/orgs", "repos_url": "https://api.github.com/users/vsrs/repos", "events_url": "https://api.github.com/users/vsrs/events{/privacy}", "received_events_url": "https://api.github.com/users/vsrs/received_events", "type": "User", "site_admin": false}, "committer": {"login": "vsrs", "id": 62505555, "node_id": "MDQ6VXNlcjYyNTA1NTU1", "avatar_url": "https://avatars.githubusercontent.com/u/62505555?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vsrs", "html_url": "https://github.com/vsrs", "followers_url": "https://api.github.com/users/vsrs/followers", "following_url": "https://api.github.com/users/vsrs/following{/other_user}", "gists_url": "https://api.github.com/users/vsrs/gists{/gist_id}", "starred_url": "https://api.github.com/users/vsrs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vsrs/subscriptions", "organizations_url": "https://api.github.com/users/vsrs/orgs", "repos_url": "https://api.github.com/users/vsrs/repos", "events_url": "https://api.github.com/users/vsrs/events{/privacy}", "received_events_url": "https://api.github.com/users/vsrs/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1be6320ea6cf7830195f80681fa0f43cc340da7e", "url": "https://api.github.com/repos/rust-lang/rust/commits/1be6320ea6cf7830195f80681fa0f43cc340da7e", "html_url": "https://github.com/rust-lang/rust/commit/1be6320ea6cf7830195f80681fa0f43cc340da7e"}, {"sha": "d3eb9d8eafbebca7da95fa8a4813b92eb5080500", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3eb9d8eafbebca7da95fa8a4813b92eb5080500", "html_url": "https://github.com/rust-lang/rust/commit/d3eb9d8eafbebca7da95fa8a4813b92eb5080500"}], "stats": {"total": 3434, "additions": 2406, "deletions": 1028}, "files": [{"sha": "41855f22e85d62d6d8c8d282262e6d84c68f16be", "filename": "Cargo.lock", "status": "modified", "additions": 34, "deletions": 16, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -68,9 +68,9 @@ dependencies = [\n \n [[package]]\n name = \"base64\"\n-version = \"0.12.0\"\n+version = \"0.12.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7d5ca2cd0adc3f48f9e9ea5a6bbdf9ccc0bfade884847e484d452414c7ccffb3\"\n+checksum = \"53d1ccbaf7d9ec9537465a97bf19edc1a4e158ecb49fc16178202238c569cc42\"\n \n [[package]]\n name = \"bitflags\"\n@@ -342,9 +342,9 @@ dependencies = [\n \n [[package]]\n name = \"filetime\"\n-version = \"0.2.9\"\n+version = \"0.2.10\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f59efc38004c988e4201d11d263b8171f49a2e7ec0bdbb71773433f271504a5e\"\n+checksum = \"affc17579b132fc2461adf7c575cc6e8b134ebca52c51f5411388965227dc695\"\n dependencies = [\n  \"cfg-if\",\n  \"libc\",\n@@ -464,6 +464,15 @@ dependencies = [\n  \"libc\",\n ]\n \n+[[package]]\n+name = \"home\"\n+version = \"0.5.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"2456aef2e6b6a9784192ae780c0f15bc57df0e918585282325e8c8ac27737654\"\n+dependencies = [\n+ \"winapi 0.3.8\",\n+]\n+\n [[package]]\n name = \"idna\"\n version = \"0.2.0\"\n@@ -610,18 +619,18 @@ checksum = \"99e85c08494b21a9054e7fe1374a732aeadaff3980b6990b94bfd3a70f690005\"\n \n [[package]]\n name = \"libloading\"\n-version = \"0.6.1\"\n+version = \"0.6.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3c4f51b790f5bdb65acb4cc94bb81d7b2ee60348a5431ac1467d390b017600b0\"\n+checksum = \"2cadb8e769f070c45df05c78c7520eb4cd17061d4ab262e43cfc68b4d00ac71c\"\n dependencies = [\n  \"winapi 0.3.8\",\n ]\n \n [[package]]\n name = \"linked-hash-map\"\n-version = \"0.5.2\"\n+version = \"0.5.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ae91b68aebc4ddb91978b11a1b02ddd8602a05ec19002801c5666000e05e0f83\"\n+checksum = \"8dd5a6d5999d9907cda8ed67bbd137d3af8085216c2ac62de5be860bd41f304a\"\n \n [[package]]\n name = \"lock_api\"\n@@ -824,19 +833,19 @@ dependencies = [\n \n [[package]]\n name = \"paste\"\n-version = \"0.1.11\"\n+version = \"0.1.12\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a3c897744f63f34f7ae3a024d9162bb5001f4ad661dd24bea0dc9f075d2de1c6\"\n+checksum = \"0a229b1c58c692edcaa5b9b0948084f130f55d2dcc15b02fcc5340b2b4521476\"\n dependencies = [\n  \"paste-impl\",\n  \"proc-macro-hack\",\n ]\n \n [[package]]\n name = \"paste-impl\"\n-version = \"0.1.11\"\n+version = \"0.1.12\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"66fd6f92e3594f2dd7b3fc23e42d82e292f7bcda6d8e5dcd167072327234ab89\"\n+checksum = \"2e0bf239e447e67ff6d16a8bb5e4d4bd2343acf5066061c0e8e06ac5ba8ca68c\"\n dependencies = [\n  \"proc-macro-hack\",\n  \"proc-macro2\",\n@@ -886,9 +895,9 @@ checksum = \"0d659fe7c6d27f25e9d80a1a094c223f5246f6a6596453e09d7229bf42750b63\"\n \n [[package]]\n name = \"proc-macro2\"\n-version = \"1.0.10\"\n+version = \"1.0.12\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"df246d292ff63439fea9bc8c0a270bed0e390d5ebd4db4ba15aba81111b5abe3\"\n+checksum = \"8872cf6f48eee44265156c111456a700ab3483686b3f96df4cf5481c89157319\"\n dependencies = [\n  \"unicode-xid\",\n ]\n@@ -958,6 +967,7 @@ dependencies = [\n  \"jod-thread\",\n  \"log\",\n  \"lsp-types\",\n+ \"ra_toolchain\",\n  \"serde_json\",\n ]\n \n@@ -1163,6 +1173,7 @@ dependencies = [\n  \"ra_cfg\",\n  \"ra_db\",\n  \"ra_proc_macro\",\n+ \"ra_toolchain\",\n  \"rustc-hash\",\n  \"serde\",\n  \"serde_json\",\n@@ -1194,6 +1205,13 @@ dependencies = [\n  \"text-size\",\n ]\n \n+[[package]]\n+name = \"ra_toolchain\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"home\",\n+]\n+\n [[package]]\n name = \"ra_tt\"\n version = \"0.1.0\"\n@@ -1581,9 +1599,9 @@ checksum = \"ab16ced94dbd8a46c82fd81e3ed9a8727dac2977ea869d217bcc4ea1f122e81f\"\n \n [[package]]\n name = \"syn\"\n-version = \"1.0.18\"\n+version = \"1.0.19\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"410a7488c0a728c7ceb4ad59b9567eb4053d02e8cc7f5c0e0eeeb39518369213\"\n+checksum = \"e8e5aa70697bb26ee62214ae3288465ecec0000f05182f039b477001f08f5ae7\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\","}, {"sha": "3085c4330c313af32b06b68fbc880fe34538037c", "filename": "crates/ra_assists/src/assist_context.rs", "status": "added", "additions": 233, "deletions": 0, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fassist_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fassist_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassist_context.rs?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -0,0 +1,233 @@\n+//! See `AssistContext`\n+\n+use algo::find_covering_element;\n+use hir::Semantics;\n+use ra_db::{FileId, FileRange};\n+use ra_fmt::{leading_indent, reindent};\n+use ra_ide_db::{\n+    source_change::{SingleFileChange, SourceChange},\n+    RootDatabase,\n+};\n+use ra_syntax::{\n+    algo::{self, find_node_at_offset, SyntaxRewriter},\n+    AstNode, SourceFile, SyntaxElement, SyntaxKind, SyntaxNode, SyntaxToken, TextRange, TextSize,\n+    TokenAtOffset,\n+};\n+use ra_text_edit::TextEditBuilder;\n+\n+use crate::{Assist, AssistId, GroupLabel, ResolvedAssist};\n+\n+/// `AssistContext` allows to apply an assist or check if it could be applied.\n+///\n+/// Assists use a somewhat over-engineered approach, given the current needs.\n+/// The assists workflow consists of two phases. In the first phase, a user asks\n+/// for the list of available assists. In the second phase, the user picks a\n+/// particular assist and it gets applied.\n+///\n+/// There are two peculiarities here:\n+///\n+/// * first, we ideally avoid computing more things then necessary to answer \"is\n+///   assist applicable\" in the first phase.\n+/// * second, when we are applying assist, we don't have a guarantee that there\n+///   weren't any changes between the point when user asked for assists and when\n+///   they applied a particular assist. So, when applying assist, we need to do\n+///   all the checks from scratch.\n+///\n+/// To avoid repeating the same code twice for both \"check\" and \"apply\"\n+/// functions, we use an approach reminiscent of that of Django's function based\n+/// views dealing with forms. Each assist receives a runtime parameter,\n+/// `resolve`. It first check if an edit is applicable (potentially computing\n+/// info required to compute the actual edit). If it is applicable, and\n+/// `resolve` is `true`, it then computes the actual edit.\n+///\n+/// So, to implement the original assists workflow, we can first apply each edit\n+/// with `resolve = false`, and then applying the selected edit again, with\n+/// `resolve = true` this time.\n+///\n+/// Note, however, that we don't actually use such two-phase logic at the\n+/// moment, because the LSP API is pretty awkward in this place, and it's much\n+/// easier to just compute the edit eagerly :-)\n+pub(crate) struct AssistContext<'a> {\n+    pub(crate) sema: Semantics<'a, RootDatabase>,\n+    pub(super) db: &'a RootDatabase,\n+    pub(crate) frange: FileRange,\n+    source_file: SourceFile,\n+}\n+\n+impl<'a> AssistContext<'a> {\n+    pub fn new(sema: Semantics<'a, RootDatabase>, frange: FileRange) -> AssistContext<'a> {\n+        let source_file = sema.parse(frange.file_id);\n+        let db = sema.db;\n+        AssistContext { sema, db, frange, source_file }\n+    }\n+\n+    // NB, this ignores active selection.\n+    pub(crate) fn offset(&self) -> TextSize {\n+        self.frange.range.start()\n+    }\n+\n+    pub(crate) fn token_at_offset(&self) -> TokenAtOffset<SyntaxToken> {\n+        self.source_file.syntax().token_at_offset(self.offset())\n+    }\n+    pub(crate) fn find_token_at_offset(&self, kind: SyntaxKind) -> Option<SyntaxToken> {\n+        self.token_at_offset().find(|it| it.kind() == kind)\n+    }\n+    pub(crate) fn find_node_at_offset<N: AstNode>(&self) -> Option<N> {\n+        find_node_at_offset(self.source_file.syntax(), self.offset())\n+    }\n+    pub(crate) fn find_node_at_offset_with_descend<N: AstNode>(&self) -> Option<N> {\n+        self.sema.find_node_at_offset_with_descend(self.source_file.syntax(), self.offset())\n+    }\n+    pub(crate) fn covering_element(&self) -> SyntaxElement {\n+        find_covering_element(self.source_file.syntax(), self.frange.range)\n+    }\n+    // FIXME: remove\n+    pub(crate) fn covering_node_for_range(&self, range: TextRange) -> SyntaxElement {\n+        find_covering_element(self.source_file.syntax(), range)\n+    }\n+}\n+\n+pub(crate) struct Assists {\n+    resolve: bool,\n+    file: FileId,\n+    buf: Vec<(Assist, Option<SourceChange>)>,\n+}\n+\n+impl Assists {\n+    pub(crate) fn new_resolved(ctx: &AssistContext) -> Assists {\n+        Assists { resolve: true, file: ctx.frange.file_id, buf: Vec::new() }\n+    }\n+    pub(crate) fn new_unresolved(ctx: &AssistContext) -> Assists {\n+        Assists { resolve: false, file: ctx.frange.file_id, buf: Vec::new() }\n+    }\n+\n+    pub(crate) fn finish_unresolved(self) -> Vec<Assist> {\n+        assert!(!self.resolve);\n+        self.finish()\n+            .into_iter()\n+            .map(|(label, edit)| {\n+                assert!(edit.is_none());\n+                label\n+            })\n+            .collect()\n+    }\n+\n+    pub(crate) fn finish_resolved(self) -> Vec<ResolvedAssist> {\n+        assert!(self.resolve);\n+        self.finish()\n+            .into_iter()\n+            .map(|(label, edit)| ResolvedAssist { assist: label, source_change: edit.unwrap() })\n+            .collect()\n+    }\n+\n+    pub(crate) fn add(\n+        &mut self,\n+        id: AssistId,\n+        label: impl Into<String>,\n+        target: TextRange,\n+        f: impl FnOnce(&mut AssistBuilder),\n+    ) -> Option<()> {\n+        let label = Assist::new(id, label.into(), None, target);\n+        self.add_impl(label, f)\n+    }\n+    pub(crate) fn add_group(\n+        &mut self,\n+        group: &GroupLabel,\n+        id: AssistId,\n+        label: impl Into<String>,\n+        target: TextRange,\n+        f: impl FnOnce(&mut AssistBuilder),\n+    ) -> Option<()> {\n+        let label = Assist::new(id, label.into(), Some(group.clone()), target);\n+        self.add_impl(label, f)\n+    }\n+    fn add_impl(&mut self, label: Assist, f: impl FnOnce(&mut AssistBuilder)) -> Option<()> {\n+        let change_label = label.label.clone();\n+        let source_change = if self.resolve {\n+            let mut builder = AssistBuilder::new(self.file);\n+            f(&mut builder);\n+            Some(builder.finish(change_label))\n+        } else {\n+            None\n+        };\n+\n+        self.buf.push((label, source_change));\n+        Some(())\n+    }\n+\n+    fn finish(mut self) -> Vec<(Assist, Option<SourceChange>)> {\n+        self.buf.sort_by_key(|(label, _edit)| label.target.len());\n+        self.buf\n+    }\n+}\n+\n+pub(crate) struct AssistBuilder {\n+    edit: TextEditBuilder,\n+    cursor_position: Option<TextSize>,\n+    file: FileId,\n+}\n+\n+impl AssistBuilder {\n+    pub(crate) fn new(file: FileId) -> AssistBuilder {\n+        AssistBuilder { edit: TextEditBuilder::default(), cursor_position: None, file }\n+    }\n+\n+    /// Remove specified `range` of text.\n+    pub(crate) fn delete(&mut self, range: TextRange) {\n+        self.edit.delete(range)\n+    }\n+    /// Append specified `text` at the given `offset`\n+    pub(crate) fn insert(&mut self, offset: TextSize, text: impl Into<String>) {\n+        self.edit.insert(offset, text.into())\n+    }\n+    /// Replaces specified `range` of text with a given string.\n+    pub(crate) fn replace(&mut self, range: TextRange, replace_with: impl Into<String>) {\n+        self.edit.replace(range, replace_with.into())\n+    }\n+    pub(crate) fn replace_ast<N: AstNode>(&mut self, old: N, new: N) {\n+        algo::diff(old.syntax(), new.syntax()).into_text_edit(&mut self.edit)\n+    }\n+    /// Replaces specified `node` of text with a given string, reindenting the\n+    /// string to maintain `node`'s existing indent.\n+    // FIXME: remove in favor of ra_syntax::edit::IndentLevel::increase_indent\n+    pub(crate) fn replace_node_and_indent(\n+        &mut self,\n+        node: &SyntaxNode,\n+        replace_with: impl Into<String>,\n+    ) {\n+        let mut replace_with = replace_with.into();\n+        if let Some(indent) = leading_indent(node) {\n+            replace_with = reindent(&replace_with, &indent)\n+        }\n+        self.replace(node.text_range(), replace_with)\n+    }\n+    pub(crate) fn rewrite(&mut self, rewriter: SyntaxRewriter) {\n+        let node = rewriter.rewrite_root().unwrap();\n+        let new = rewriter.rewrite(&node);\n+        algo::diff(&node, &new).into_text_edit(&mut self.edit)\n+    }\n+\n+    /// Specify desired position of the cursor after the assist is applied.\n+    pub(crate) fn set_cursor(&mut self, offset: TextSize) {\n+        self.cursor_position = Some(offset)\n+    }\n+    // FIXME: better API\n+    pub(crate) fn set_file(&mut self, assist_file: FileId) {\n+        self.file = assist_file;\n+    }\n+\n+    // FIXME: kill this API\n+    /// Get access to the raw `TextEditBuilder`.\n+    pub(crate) fn text_edit_builder(&mut self) -> &mut TextEditBuilder {\n+        &mut self.edit\n+    }\n+\n+    fn finish(self, change_label: String) -> SourceChange {\n+        let edit = self.edit.finish();\n+        if edit.is_empty() && self.cursor_position.is_none() {\n+            panic!(\"Only call `add_assist` if the assist can be applied\")\n+        }\n+        SingleFileChange { label: change_label, edit, cursor_position: self.cursor_position }\n+            .into_source_change(self.file)\n+    }\n+}"}, {"sha": "cbf1963b7213ae6eacf652968801171c9c0bb68b", "filename": "crates/ra_assists/src/assist_ctx.rs", "status": "removed", "additions": 0, "deletions": 265, "changes": 265, "blob_url": "https://github.com/rust-lang/rust/blob/1be6320ea6cf7830195f80681fa0f43cc340da7e/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be6320ea6cf7830195f80681fa0f43cc340da7e/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs?ref=1be6320ea6cf7830195f80681fa0f43cc340da7e", "patch": "@@ -1,265 +0,0 @@\n-//! This module defines `AssistCtx` -- the API surface that is exposed to assists.\n-use hir::Semantics;\n-use ra_db::FileRange;\n-use ra_fmt::{leading_indent, reindent};\n-use ra_ide_db::RootDatabase;\n-use ra_syntax::{\n-    algo::{self, find_covering_element, find_node_at_offset, SyntaxRewriter},\n-    AstNode, SourceFile, SyntaxElement, SyntaxKind, SyntaxNode, SyntaxToken, TextRange, TextSize,\n-    TokenAtOffset,\n-};\n-use ra_text_edit::TextEditBuilder;\n-\n-use crate::{AssistAction, AssistFile, AssistId, AssistLabel, GroupLabel, ResolvedAssist};\n-\n-#[derive(Clone, Debug)]\n-pub(crate) struct Assist(pub(crate) Vec<AssistInfo>);\n-\n-#[derive(Clone, Debug)]\n-pub(crate) struct AssistInfo {\n-    pub(crate) label: AssistLabel,\n-    pub(crate) group_label: Option<GroupLabel>,\n-    pub(crate) action: Option<AssistAction>,\n-}\n-\n-impl AssistInfo {\n-    fn new(label: AssistLabel) -> AssistInfo {\n-        AssistInfo { label, group_label: None, action: None }\n-    }\n-\n-    fn resolved(self, action: AssistAction) -> AssistInfo {\n-        AssistInfo { action: Some(action), ..self }\n-    }\n-\n-    fn with_group(self, group_label: GroupLabel) -> AssistInfo {\n-        AssistInfo { group_label: Some(group_label), ..self }\n-    }\n-\n-    pub(crate) fn into_resolved(self) -> Option<ResolvedAssist> {\n-        let label = self.label;\n-        self.action.map(|action| ResolvedAssist { label, action })\n-    }\n-}\n-\n-/// `AssistCtx` allows to apply an assist or check if it could be applied.\n-///\n-/// Assists use a somewhat over-engineered approach, given the current needs. The\n-/// assists workflow consists of two phases. In the first phase, a user asks for\n-/// the list of available assists. In the second phase, the user picks a\n-/// particular assist and it gets applied.\n-///\n-/// There are two peculiarities here:\n-///\n-/// * first, we ideally avoid computing more things then necessary to answer\n-///   \"is assist applicable\" in the first phase.\n-/// * second, when we are applying assist, we don't have a guarantee that there\n-///   weren't any changes between the point when user asked for assists and when\n-///   they applied a particular assist. So, when applying assist, we need to do\n-///   all the checks from scratch.\n-///\n-/// To avoid repeating the same code twice for both \"check\" and \"apply\"\n-/// functions, we use an approach reminiscent of that of Django's function based\n-/// views dealing with forms. Each assist receives a runtime parameter,\n-/// `should_compute_edit`. It first check if an edit is applicable (potentially\n-/// computing info required to compute the actual edit). If it is applicable,\n-/// and `should_compute_edit` is `true`, it then computes the actual edit.\n-///\n-/// So, to implement the original assists workflow, we can first apply each edit\n-/// with `should_compute_edit = false`, and then applying the selected edit\n-/// again, with `should_compute_edit = true` this time.\n-///\n-/// Note, however, that we don't actually use such two-phase logic at the\n-/// moment, because the LSP API is pretty awkward in this place, and it's much\n-/// easier to just compute the edit eagerly :-)\n-#[derive(Clone)]\n-pub(crate) struct AssistCtx<'a> {\n-    pub(crate) sema: &'a Semantics<'a, RootDatabase>,\n-    pub(crate) db: &'a RootDatabase,\n-    pub(crate) frange: FileRange,\n-    source_file: SourceFile,\n-    should_compute_edit: bool,\n-}\n-\n-impl<'a> AssistCtx<'a> {\n-    pub fn new(\n-        sema: &'a Semantics<'a, RootDatabase>,\n-        frange: FileRange,\n-        should_compute_edit: bool,\n-    ) -> AssistCtx<'a> {\n-        let source_file = sema.parse(frange.file_id);\n-        AssistCtx { sema, db: sema.db, frange, source_file, should_compute_edit }\n-    }\n-\n-    pub(crate) fn add_assist(\n-        self,\n-        id: AssistId,\n-        label: impl Into<String>,\n-        target: TextRange,\n-        f: impl FnOnce(&mut ActionBuilder),\n-    ) -> Option<Assist> {\n-        let label = AssistLabel::new(id, label.into(), None, target);\n-\n-        let mut info = AssistInfo::new(label);\n-        if self.should_compute_edit {\n-            let action = {\n-                let mut edit = ActionBuilder::new(&self);\n-                f(&mut edit);\n-                edit.build()\n-            };\n-            info = info.resolved(action)\n-        };\n-\n-        Some(Assist(vec![info]))\n-    }\n-\n-    pub(crate) fn add_assist_group(self, group_name: impl Into<String>) -> AssistGroup<'a> {\n-        let group = GroupLabel(group_name.into());\n-        AssistGroup { ctx: self, group, assists: Vec::new() }\n-    }\n-\n-    pub(crate) fn token_at_offset(&self) -> TokenAtOffset<SyntaxToken> {\n-        self.source_file.syntax().token_at_offset(self.frange.range.start())\n-    }\n-\n-    pub(crate) fn find_token_at_offset(&self, kind: SyntaxKind) -> Option<SyntaxToken> {\n-        self.token_at_offset().find(|it| it.kind() == kind)\n-    }\n-\n-    pub(crate) fn find_node_at_offset<N: AstNode>(&self) -> Option<N> {\n-        find_node_at_offset(self.source_file.syntax(), self.frange.range.start())\n-    }\n-\n-    pub(crate) fn find_node_at_offset_with_descend<N: AstNode>(&self) -> Option<N> {\n-        self.sema\n-            .find_node_at_offset_with_descend(self.source_file.syntax(), self.frange.range.start())\n-    }\n-\n-    pub(crate) fn covering_element(&self) -> SyntaxElement {\n-        find_covering_element(self.source_file.syntax(), self.frange.range)\n-    }\n-    pub(crate) fn covering_node_for_range(&self, range: TextRange) -> SyntaxElement {\n-        find_covering_element(self.source_file.syntax(), range)\n-    }\n-}\n-\n-pub(crate) struct AssistGroup<'a> {\n-    ctx: AssistCtx<'a>,\n-    group: GroupLabel,\n-    assists: Vec<AssistInfo>,\n-}\n-\n-impl<'a> AssistGroup<'a> {\n-    pub(crate) fn add_assist(\n-        &mut self,\n-        id: AssistId,\n-        label: impl Into<String>,\n-        target: TextRange,\n-        f: impl FnOnce(&mut ActionBuilder),\n-    ) {\n-        let label = AssistLabel::new(id, label.into(), Some(self.group.clone()), target);\n-\n-        let mut info = AssistInfo::new(label).with_group(self.group.clone());\n-        if self.ctx.should_compute_edit {\n-            let action = {\n-                let mut edit = ActionBuilder::new(&self.ctx);\n-                f(&mut edit);\n-                edit.build()\n-            };\n-            info = info.resolved(action)\n-        };\n-\n-        self.assists.push(info)\n-    }\n-\n-    pub(crate) fn finish(self) -> Option<Assist> {\n-        if self.assists.is_empty() {\n-            None\n-        } else {\n-            Some(Assist(self.assists))\n-        }\n-    }\n-}\n-\n-pub(crate) struct ActionBuilder<'a, 'b> {\n-    edit: TextEditBuilder,\n-    cursor_position: Option<TextSize>,\n-    file: AssistFile,\n-    ctx: &'a AssistCtx<'b>,\n-}\n-\n-impl<'a, 'b> ActionBuilder<'a, 'b> {\n-    fn new(ctx: &'a AssistCtx<'b>) -> Self {\n-        Self {\n-            edit: TextEditBuilder::default(),\n-            cursor_position: None,\n-            file: AssistFile::default(),\n-            ctx,\n-        }\n-    }\n-\n-    pub(crate) fn ctx(&self) -> &AssistCtx<'b> {\n-        &self.ctx\n-    }\n-\n-    /// Replaces specified `range` of text with a given string.\n-    pub(crate) fn replace(&mut self, range: TextRange, replace_with: impl Into<String>) {\n-        self.edit.replace(range, replace_with.into())\n-    }\n-\n-    /// Replaces specified `node` of text with a given string, reindenting the\n-    /// string to maintain `node`'s existing indent.\n-    // FIXME: remove in favor of ra_syntax::edit::IndentLevel::increase_indent\n-    pub(crate) fn replace_node_and_indent(\n-        &mut self,\n-        node: &SyntaxNode,\n-        replace_with: impl Into<String>,\n-    ) {\n-        let mut replace_with = replace_with.into();\n-        if let Some(indent) = leading_indent(node) {\n-            replace_with = reindent(&replace_with, &indent)\n-        }\n-        self.replace(node.text_range(), replace_with)\n-    }\n-\n-    /// Remove specified `range` of text.\n-    #[allow(unused)]\n-    pub(crate) fn delete(&mut self, range: TextRange) {\n-        self.edit.delete(range)\n-    }\n-\n-    /// Append specified `text` at the given `offset`\n-    pub(crate) fn insert(&mut self, offset: TextSize, text: impl Into<String>) {\n-        self.edit.insert(offset, text.into())\n-    }\n-\n-    /// Specify desired position of the cursor after the assist is applied.\n-    pub(crate) fn set_cursor(&mut self, offset: TextSize) {\n-        self.cursor_position = Some(offset)\n-    }\n-\n-    /// Get access to the raw `TextEditBuilder`.\n-    pub(crate) fn text_edit_builder(&mut self) -> &mut TextEditBuilder {\n-        &mut self.edit\n-    }\n-\n-    pub(crate) fn replace_ast<N: AstNode>(&mut self, old: N, new: N) {\n-        algo::diff(old.syntax(), new.syntax()).into_text_edit(&mut self.edit)\n-    }\n-    pub(crate) fn rewrite(&mut self, rewriter: SyntaxRewriter) {\n-        let node = rewriter.rewrite_root().unwrap();\n-        let new = rewriter.rewrite(&node);\n-        algo::diff(&node, &new).into_text_edit(&mut self.edit)\n-    }\n-\n-    pub(crate) fn set_file(&mut self, assist_file: AssistFile) {\n-        self.file = assist_file\n-    }\n-\n-    fn build(self) -> AssistAction {\n-        let edit = self.edit.finish();\n-        if edit.is_empty() && self.cursor_position.is_none() {\n-            panic!(\"Only call `add_assist` if the assist can be applied\")\n-        }\n-        AssistAction { edit, cursor_position: self.cursor_position, file: self.file }\n-    }\n-}"}, {"sha": "795a225a4d8fc43ab12043c7ad40207a4ce370bf", "filename": "crates/ra_assists/src/handlers/add_custom_impl.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_custom_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_custom_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_custom_impl.rs?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -6,7 +6,10 @@ use ra_syntax::{\n };\n use stdx::SepBy;\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{\n+    assist_context::{AssistContext, Assists},\n+    AssistId,\n+};\n \n // Assist: add_custom_impl\n //\n@@ -25,7 +28,7 @@ use crate::{Assist, AssistCtx, AssistId};\n //\n // }\n // ```\n-pub(crate) fn add_custom_impl(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn add_custom_impl(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let input = ctx.find_node_at_offset::<ast::AttrInput>()?;\n     let attr = input.syntax().parent().and_then(ast::Attr::cast)?;\n \n@@ -49,7 +52,7 @@ pub(crate) fn add_custom_impl(ctx: AssistCtx) -> Option<Assist> {\n         format!(\"Add custom impl '{}' for '{}'\", trait_token.text().as_str(), annotated_name);\n \n     let target = attr.syntax().text_range();\n-    ctx.add_assist(AssistId(\"add_custom_impl\"), label, target, |edit| {\n+    acc.add(AssistId(\"add_custom_impl\"), label, target, |edit| {\n         let new_attr_input = input\n             .syntax()\n             .descendants_with_tokens()"}, {"sha": "fb08c19e936145203eeb5955848434ce96d2a4bb", "filename": "crates/ra_assists/src/handlers/add_derive.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_derive.rs?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -4,7 +4,7 @@ use ra_syntax::{\n     TextSize,\n };\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: add_derive\n //\n@@ -24,11 +24,11 @@ use crate::{Assist, AssistCtx, AssistId};\n //     y: u32,\n // }\n // ```\n-pub(crate) fn add_derive(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn add_derive(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let nominal = ctx.find_node_at_offset::<ast::NominalDef>()?;\n     let node_start = derive_insertion_offset(&nominal)?;\n     let target = nominal.syntax().text_range();\n-    ctx.add_assist(AssistId(\"add_derive\"), \"Add `#[derive]`\", target, |edit| {\n+    acc.add(AssistId(\"add_derive\"), \"Add `#[derive]`\", target, |edit| {\n         let derive_attr = nominal\n             .attrs()\n             .filter_map(|x| x.as_simple_call())\n@@ -57,9 +57,10 @@ fn derive_insertion_offset(nominal: &ast::NominalDef) -> Option<TextSize> {\n \n #[cfg(test)]\n mod tests {\n-    use super::*;\n     use crate::tests::{check_assist, check_assist_target};\n \n+    use super::*;\n+\n     #[test]\n     fn add_derive_new() {\n         check_assist("}, {"sha": "55409e5013c6300c04740449caae2223d0d24c22", "filename": "crates/ra_assists/src/handlers/add_explicit_type.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -4,7 +4,7 @@ use ra_syntax::{\n     TextRange,\n };\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: add_explicit_type\n //\n@@ -21,7 +21,7 @@ use crate::{Assist, AssistCtx, AssistId};\n //     let x: i32 = 92;\n // }\n // ```\n-pub(crate) fn add_explicit_type(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn add_explicit_type(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let stmt = ctx.find_node_at_offset::<LetStmt>()?;\n     let expr = stmt.initializer()?;\n     let pat = stmt.pat()?;\n@@ -59,7 +59,7 @@ pub(crate) fn add_explicit_type(ctx: AssistCtx) -> Option<Assist> {\n \n     let db = ctx.db;\n     let new_type_string = ty.display_truncated(db, None).to_string();\n-    ctx.add_assist(\n+    acc.add(\n         AssistId(\"add_explicit_type\"),\n         format!(\"Insert explicit type '{}'\", new_type_string),\n         pat_range,"}, {"sha": "275184e2466ca0db33f98bc1a6aa024fad83b1fb", "filename": "crates/ra_assists/src/handlers/add_from_impl_for_enum.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_from_impl_for_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_from_impl_for_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_from_impl_for_enum.rs?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -4,10 +4,10 @@ use ra_syntax::{\n     TextSize,\n };\n use stdx::format_to;\n-\n-use crate::{utils::FamousDefs, Assist, AssistCtx, AssistId};\n use test_utils::tested_by;\n \n+use crate::{utils::FamousDefs, AssistContext, AssistId, Assists};\n+\n // Assist add_from_impl_for_enum\n //\n // Adds a From impl for an enum variant with one tuple field\n@@ -25,7 +25,7 @@ use test_utils::tested_by;\n //     }\n // }\n // ```\n-pub(crate) fn add_from_impl_for_enum(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn add_from_impl_for_enum(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let variant = ctx.find_node_at_offset::<ast::EnumVariant>()?;\n     let variant_name = variant.name()?;\n     let enum_name = variant.parent_enum().name()?;\n@@ -42,13 +42,13 @@ pub(crate) fn add_from_impl_for_enum(ctx: AssistCtx) -> Option<Assist> {\n         _ => return None,\n     };\n \n-    if existing_from_impl(ctx.sema, &variant).is_some() {\n+    if existing_from_impl(&ctx.sema, &variant).is_some() {\n         tested_by!(test_add_from_impl_already_exists);\n         return None;\n     }\n \n     let target = variant.syntax().text_range();\n-    ctx.add_assist(\n+    acc.add(\n         AssistId(\"add_from_impl_for_enum\"),\n         \"Add From impl for this enum variant\",\n         target,"}, {"sha": "6b5616aa9c8d7816e6f07d9e095cc961ec744a74", "filename": "crates/ra_assists/src/handlers/add_function.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_function.rs?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -1,13 +1,13 @@\n+use hir::HirDisplay;\n+use ra_db::FileId;\n use ra_syntax::{\n-    ast::{self, AstNode},\n+    ast::{self, edit::IndentLevel, ArgListOwner, AstNode, ModuleItemOwner},\n     SyntaxKind, SyntaxNode, TextSize,\n };\n-\n-use crate::{Assist, AssistCtx, AssistFile, AssistId};\n-use ast::{edit::IndentLevel, ArgListOwner, ModuleItemOwner};\n-use hir::HirDisplay;\n use rustc_hash::{FxHashMap, FxHashSet};\n \n+use crate::{AssistContext, AssistId, Assists};\n+\n // Assist: add_function\n //\n // Adds a stub function with a signature matching the function under the cursor.\n@@ -33,7 +33,7 @@ use rustc_hash::{FxHashMap, FxHashSet};\n // }\n //\n // ```\n-pub(crate) fn add_function(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn add_function(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let path_expr: ast::PathExpr = ctx.find_node_at_offset()?;\n     let call = path_expr.syntax().parent().and_then(ast::CallExpr::cast)?;\n     let path = path_expr.path()?;\n@@ -58,7 +58,7 @@ pub(crate) fn add_function(ctx: AssistCtx) -> Option<Assist> {\n     let function_builder = FunctionBuilder::from_call(&ctx, &call, &path, target_module)?;\n \n     let target = call.syntax().text_range();\n-    ctx.add_assist(AssistId(\"add_function\"), \"Add function\", target, |edit| {\n+    acc.add(AssistId(\"add_function\"), \"Add function\", target, |edit| {\n         let function_template = function_builder.render();\n         edit.set_file(function_template.file);\n         edit.set_cursor(function_template.cursor_offset);\n@@ -70,29 +70,29 @@ struct FunctionTemplate {\n     insert_offset: TextSize,\n     cursor_offset: TextSize,\n     fn_def: ast::SourceFile,\n-    file: AssistFile,\n+    file: FileId,\n }\n \n struct FunctionBuilder {\n     target: GeneratedFunctionTarget,\n     fn_name: ast::Name,\n     type_params: Option<ast::TypeParamList>,\n     params: ast::ParamList,\n-    file: AssistFile,\n+    file: FileId,\n     needs_pub: bool,\n }\n \n impl FunctionBuilder {\n     /// Prepares a generated function that matches `call` in `generate_in`\n     /// (or as close to `call` as possible, if `generate_in` is `None`)\n     fn from_call(\n-        ctx: &AssistCtx,\n+        ctx: &AssistContext,\n         call: &ast::CallExpr,\n         path: &ast::Path,\n         target_module: Option<hir::InFile<hir::ModuleSource>>,\n     ) -> Option<Self> {\n         let needs_pub = target_module.is_some();\n-        let mut file = AssistFile::default();\n+        let mut file = ctx.frange.file_id;\n         let target = if let Some(target_module) = target_module {\n             let (in_file, target) = next_space_for_fn_in_module(ctx.sema.db, target_module)?;\n             file = in_file;\n@@ -151,7 +151,7 @@ fn fn_name(call: &ast::Path) -> Option<ast::Name> {\n \n /// Computes the type variables and arguments required for the generated function\n fn fn_args(\n-    ctx: &AssistCtx,\n+    ctx: &AssistContext,\n     call: &ast::CallExpr,\n ) -> Option<(Option<ast::TypeParamList>, ast::ParamList)> {\n     let mut arg_names = Vec::new();\n@@ -218,7 +218,7 @@ fn fn_arg_name(fn_arg: &ast::Expr) -> Option<String> {\n     }\n }\n \n-fn fn_arg_type(ctx: &AssistCtx, fn_arg: &ast::Expr) -> Option<String> {\n+fn fn_arg_type(ctx: &AssistContext, fn_arg: &ast::Expr) -> Option<String> {\n     let ty = ctx.sema.type_of_expr(fn_arg)?;\n     if ty.is_unknown() {\n         return None;\n@@ -253,9 +253,8 @@ fn next_space_for_fn_after_call_site(expr: &ast::CallExpr) -> Option<GeneratedFu\n fn next_space_for_fn_in_module(\n     db: &dyn hir::db::AstDatabase,\n     module: hir::InFile<hir::ModuleSource>,\n-) -> Option<(AssistFile, GeneratedFunctionTarget)> {\n+) -> Option<(FileId, GeneratedFunctionTarget)> {\n     let file = module.file_id.original_file(db);\n-    let assist_file = AssistFile::TargetFile(file);\n     let assist_item = match module.value {\n         hir::ModuleSource::SourceFile(it) => {\n             if let Some(last_item) = it.items().last() {\n@@ -272,7 +271,7 @@ fn next_space_for_fn_in_module(\n             }\n         }\n     };\n-    Some((assist_file, assist_item))\n+    Some((file, assist_item))\n }\n \n #[cfg(test)]"}, {"sha": "df114a0d84dd40cfc9791ca3c5760834e6fc7e81", "filename": "crates/ra_assists/src/handlers/add_impl.rs", "status": "modified", "additions": 27, "deletions": 34, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_impl.rs?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -4,7 +4,7 @@ use ra_syntax::{\n };\n use stdx::{format_to, SepBy};\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: add_impl\n //\n@@ -25,43 +25,36 @@ use crate::{Assist, AssistCtx, AssistId};\n //\n // }\n // ```\n-pub(crate) fn add_impl(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn add_impl(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let nominal = ctx.find_node_at_offset::<ast::NominalDef>()?;\n     let name = nominal.name()?;\n     let target = nominal.syntax().text_range();\n-    ctx.add_assist(\n-        AssistId(\"add_impl\"),\n-        format!(\"Implement {}\", name.text().as_str()),\n-        target,\n-        |edit| {\n-            let type_params = nominal.type_param_list();\n-            let start_offset = nominal.syntax().text_range().end();\n-            let mut buf = String::new();\n-            buf.push_str(\"\\n\\nimpl\");\n-            if let Some(type_params) = &type_params {\n-                format_to!(buf, \"{}\", type_params.syntax());\n-            }\n-            buf.push_str(\" \");\n-            buf.push_str(name.text().as_str());\n-            if let Some(type_params) = type_params {\n-                let lifetime_params = type_params\n-                    .lifetime_params()\n-                    .filter_map(|it| it.lifetime_token())\n-                    .map(|it| it.text().clone());\n-                let type_params = type_params\n-                    .type_params()\n-                    .filter_map(|it| it.name())\n-                    .map(|it| it.text().clone());\n+    acc.add(AssistId(\"add_impl\"), format!(\"Implement {}\", name.text().as_str()), target, |edit| {\n+        let type_params = nominal.type_param_list();\n+        let start_offset = nominal.syntax().text_range().end();\n+        let mut buf = String::new();\n+        buf.push_str(\"\\n\\nimpl\");\n+        if let Some(type_params) = &type_params {\n+            format_to!(buf, \"{}\", type_params.syntax());\n+        }\n+        buf.push_str(\" \");\n+        buf.push_str(name.text().as_str());\n+        if let Some(type_params) = type_params {\n+            let lifetime_params = type_params\n+                .lifetime_params()\n+                .filter_map(|it| it.lifetime_token())\n+                .map(|it| it.text().clone());\n+            let type_params =\n+                type_params.type_params().filter_map(|it| it.name()).map(|it| it.text().clone());\n \n-                let generic_params = lifetime_params.chain(type_params).sep_by(\", \");\n-                format_to!(buf, \"<{}>\", generic_params)\n-            }\n-            buf.push_str(\" {\\n\");\n-            edit.set_cursor(start_offset + TextSize::of(&buf));\n-            buf.push_str(\"\\n}\");\n-            edit.insert(start_offset, buf);\n-        },\n-    )\n+            let generic_params = lifetime_params.chain(type_params).sep_by(\", \");\n+            format_to!(buf, \"<{}>\", generic_params)\n+        }\n+        buf.push_str(\" {\\n\");\n+        edit.set_cursor(start_offset + TextSize::of(&buf));\n+        buf.push_str(\"\\n}\");\n+        edit.insert(start_offset, buf);\n+    })\n }\n \n #[cfg(test)]"}, {"sha": "3482a75bfcfb2299f313bf6eb01e346a98953888", "filename": "crates/ra_assists/src/handlers/add_missing_impl_members.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -9,9 +9,10 @@ use ra_syntax::{\n };\n \n use crate::{\n+    assist_context::{AssistContext, Assists},\n     ast_transform::{self, AstTransform, QualifyPaths, SubstituteTypeParams},\n     utils::{get_missing_assoc_items, resolve_target_trait},\n-    Assist, AssistCtx, AssistId,\n+    AssistId,\n };\n \n #[derive(PartialEq)]\n@@ -50,8 +51,9 @@ enum AddMissingImplMembersMode {\n //\n // }\n // ```\n-pub(crate) fn add_missing_impl_members(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn add_missing_impl_members(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     add_missing_impl_members_inner(\n+        acc,\n         ctx,\n         AddMissingImplMembersMode::NoDefaultMethods,\n         \"add_impl_missing_members\",\n@@ -91,8 +93,9 @@ pub(crate) fn add_missing_impl_members(ctx: AssistCtx) -> Option<Assist> {\n //\n // }\n // ```\n-pub(crate) fn add_missing_default_members(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn add_missing_default_members(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     add_missing_impl_members_inner(\n+        acc,\n         ctx,\n         AddMissingImplMembersMode::DefaultMethodsOnly,\n         \"add_impl_default_members\",\n@@ -101,11 +104,12 @@ pub(crate) fn add_missing_default_members(ctx: AssistCtx) -> Option<Assist> {\n }\n \n fn add_missing_impl_members_inner(\n-    ctx: AssistCtx,\n+    acc: &mut Assists,\n+    ctx: &AssistContext,\n     mode: AddMissingImplMembersMode,\n     assist_id: &'static str,\n     label: &'static str,\n-) -> Option<Assist> {\n+) -> Option<()> {\n     let _p = ra_prof::profile(\"add_missing_impl_members_inner\");\n     let impl_def = ctx.find_node_at_offset::<ast::ImplDef>()?;\n     let impl_item_list = impl_def.item_list()?;\n@@ -142,12 +146,11 @@ fn add_missing_impl_members_inner(\n         return None;\n     }\n \n-    let sema = ctx.sema;\n     let target = impl_def.syntax().text_range();\n-    ctx.add_assist(AssistId(assist_id), label, target, |edit| {\n+    acc.add(AssistId(assist_id), label, target, |edit| {\n         let n_existing_items = impl_item_list.assoc_items().count();\n-        let source_scope = sema.scope_for_def(trait_);\n-        let target_scope = sema.scope(impl_item_list.syntax());\n+        let source_scope = ctx.sema.scope_for_def(trait_);\n+        let target_scope = ctx.sema.scope(impl_item_list.syntax());\n         let ast_transform = QualifyPaths::new(&target_scope, &source_scope)\n             .or(SubstituteTypeParams::for_trait_impl(&source_scope, trait_, impl_def));\n         let items = missing_items\n@@ -170,13 +173,12 @@ fn add_missing_impl_members_inner(\n }\n \n fn add_body(fn_def: ast::FnDef) -> ast::FnDef {\n-    if fn_def.body().is_none() {\n-        let body = make::block_expr(None, Some(make::expr_todo()));\n-        let body = IndentLevel(1).increase_indent(body);\n-        fn_def.with_body(body)\n-    } else {\n-        fn_def\n+    if fn_def.body().is_some() {\n+        return fn_def;\n     }\n+    let body = make::block_expr(None, Some(make::expr_todo()));\n+    let body = IndentLevel(1).increase_indent(body);\n+    fn_def.with_body(body)\n }\n \n #[cfg(test)]"}, {"sha": "fe7451dcfdf4186835cb677902e5cae522ba340c", "filename": "crates/ra_assists/src/handlers/add_new.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_new.rs?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -7,7 +7,7 @@ use ra_syntax::{\n };\n use stdx::{format_to, SepBy};\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: add_new\n //\n@@ -29,7 +29,7 @@ use crate::{Assist, AssistCtx, AssistId};\n // }\n //\n // ```\n-pub(crate) fn add_new(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn add_new(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let strukt = ctx.find_node_at_offset::<ast::StructDef>()?;\n \n     // We want to only apply this to non-union structs with named fields\n@@ -42,7 +42,7 @@ pub(crate) fn add_new(ctx: AssistCtx) -> Option<Assist> {\n     let impl_def = find_struct_impl(&ctx, &strukt)?;\n \n     let target = strukt.syntax().text_range();\n-    ctx.add_assist(AssistId(\"add_new\"), \"Add default constructor\", target, |edit| {\n+    acc.add(AssistId(\"add_new\"), \"Add default constructor\", target, |edit| {\n         let mut buf = String::with_capacity(512);\n \n         if impl_def.is_some() {\n@@ -123,7 +123,7 @@ fn generate_impl_text(strukt: &ast::StructDef, code: &str) -> String {\n //\n // FIXME: change the new fn checking to a more semantic approach when that's more\n // viable (e.g. we process proc macros, etc)\n-fn find_struct_impl(ctx: &AssistCtx, strukt: &ast::StructDef) -> Option<Option<ast::ImplDef>> {\n+fn find_struct_impl(ctx: &AssistContext, strukt: &ast::StructDef) -> Option<Option<ast::ImplDef>> {\n     let db = ctx.db;\n     let module = strukt.syntax().ancestors().find(|node| {\n         ast::Module::can_cast(node.kind()) || ast::SourceFile::can_cast(node.kind())"}, {"sha": "0feba5e11f6510a7dd7e78c9530899fb35b17a2c", "filename": "crates/ra_assists/src/handlers/apply_demorgan.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fapply_demorgan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fapply_demorgan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fapply_demorgan.rs?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -1,6 +1,6 @@\n use ra_syntax::ast::{self, AstNode};\n \n-use crate::{utils::invert_boolean_expression, Assist, AssistCtx, AssistId};\n+use crate::{utils::invert_boolean_expression, AssistContext, AssistId, Assists};\n \n // Assist: apply_demorgan\n //\n@@ -21,7 +21,7 @@ use crate::{utils::invert_boolean_expression, Assist, AssistCtx, AssistId};\n //     if !(x == 4 && y) {}\n // }\n // ```\n-pub(crate) fn apply_demorgan(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn apply_demorgan(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let expr = ctx.find_node_at_offset::<ast::BinExpr>()?;\n     let op = expr.op_kind()?;\n     let op_range = expr.op_token()?.text_range();\n@@ -39,7 +39,7 @@ pub(crate) fn apply_demorgan(ctx: AssistCtx) -> Option<Assist> {\n     let rhs_range = rhs.syntax().text_range();\n     let not_rhs = invert_boolean_expression(rhs);\n \n-    ctx.add_assist(AssistId(\"apply_demorgan\"), \"Apply De Morgan's law\", op_range, |edit| {\n+    acc.add(AssistId(\"apply_demorgan\"), \"Apply De Morgan's law\", op_range, |edit| {\n         edit.replace(op_range, opposite_op);\n         edit.replace(lhs_range, format!(\"!({}\", not_lhs.syntax().text()));\n         edit.replace(rhs_range, format!(\"{})\", not_rhs.syntax().text()));"}, {"sha": "78d23150d385be1ddc4581da32725da056ea3ef6", "filename": "crates/ra_assists/src/handlers/auto_import.rs", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fauto_import.rs?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -1,5 +1,6 @@\n use std::collections::BTreeSet;\n \n+use either::Either;\n use hir::{\n     AsAssocItem, AssocItemContainer, ModPath, Module, ModuleDef, PathResolution, Semantics, Trait,\n     Type,\n@@ -12,12 +13,7 @@ use ra_syntax::{\n };\n use rustc_hash::FxHashSet;\n \n-use crate::{\n-    assist_ctx::{Assist, AssistCtx},\n-    utils::insert_use_statement,\n-    AssistId,\n-};\n-use either::Either;\n+use crate::{utils::insert_use_statement, AssistContext, AssistId, Assists, GroupLabel};\n \n // Assist: auto_import\n //\n@@ -38,21 +34,27 @@ use either::Either;\n // }\n // # pub mod std { pub mod collections { pub struct HashMap { } } }\n // ```\n-pub(crate) fn auto_import(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn auto_import(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let auto_import_assets = AutoImportAssets::new(&ctx)?;\n     let proposed_imports = auto_import_assets.search_for_imports(ctx.db);\n     if proposed_imports.is_empty() {\n         return None;\n     }\n \n     let range = ctx.sema.original_range(&auto_import_assets.syntax_under_caret).range;\n-    let mut group = ctx.add_assist_group(auto_import_assets.get_import_group_message());\n+    let group = auto_import_assets.get_import_group_message();\n     for import in proposed_imports {\n-        group.add_assist(AssistId(\"auto_import\"), format!(\"Import `{}`\", &import), range, |edit| {\n-            insert_use_statement(&auto_import_assets.syntax_under_caret, &import, edit);\n-        });\n+        acc.add_group(\n+            &group,\n+            AssistId(\"auto_import\"),\n+            format!(\"Import `{}`\", &import),\n+            range,\n+            |builder| {\n+                insert_use_statement(&auto_import_assets.syntax_under_caret, &import, ctx, builder);\n+            },\n+        );\n     }\n-    group.finish()\n+    Some(())\n }\n \n #[derive(Debug)]\n@@ -63,15 +65,15 @@ struct AutoImportAssets {\n }\n \n impl AutoImportAssets {\n-    fn new(ctx: &AssistCtx) -> Option<Self> {\n+    fn new(ctx: &AssistContext) -> Option<Self> {\n         if let Some(path_under_caret) = ctx.find_node_at_offset_with_descend::<ast::Path>() {\n             Self::for_regular_path(path_under_caret, &ctx)\n         } else {\n             Self::for_method_call(ctx.find_node_at_offset_with_descend()?, &ctx)\n         }\n     }\n \n-    fn for_method_call(method_call: ast::MethodCallExpr, ctx: &AssistCtx) -> Option<Self> {\n+    fn for_method_call(method_call: ast::MethodCallExpr, ctx: &AssistContext) -> Option<Self> {\n         let syntax_under_caret = method_call.syntax().to_owned();\n         let module_with_name_to_import = ctx.sema.scope(&syntax_under_caret).module()?;\n         Some(Self {\n@@ -81,7 +83,7 @@ impl AutoImportAssets {\n         })\n     }\n \n-    fn for_regular_path(path_under_caret: ast::Path, ctx: &AssistCtx) -> Option<Self> {\n+    fn for_regular_path(path_under_caret: ast::Path, ctx: &AssistContext) -> Option<Self> {\n         let syntax_under_caret = path_under_caret.syntax().to_owned();\n         if syntax_under_caret.ancestors().find_map(ast::UseItem::cast).is_some() {\n             return None;\n@@ -104,8 +106,8 @@ impl AutoImportAssets {\n         }\n     }\n \n-    fn get_import_group_message(&self) -> String {\n-        match &self.import_candidate {\n+    fn get_import_group_message(&self) -> GroupLabel {\n+        let name = match &self.import_candidate {\n             ImportCandidate::UnqualifiedName(name) => format!(\"Import {}\", name),\n             ImportCandidate::QualifierStart(qualifier_start) => {\n                 format!(\"Import {}\", qualifier_start)\n@@ -116,7 +118,8 @@ impl AutoImportAssets {\n             ImportCandidate::TraitMethod(_, trait_method_name) => {\n                 format!(\"Import a trait for method {}\", trait_method_name)\n             }\n-        }\n+        };\n+        GroupLabel(name)\n     }\n \n     fn search_for_imports(&self, db: &RootDatabase) -> BTreeSet<ModPath> {\n@@ -383,7 +386,7 @@ mod tests {\n             }\n             \",\n             r\"\n-            use PubMod1::PubStruct;\n+            use PubMod3::PubStruct;\n \n             PubSt<|>ruct\n "}, {"sha": "5c907097e556a8ba8dbcc757db178a6f1c563632", "filename": "crates/ra_assists/src/handlers/change_return_type_to_result.rs", "status": "added", "additions": 971, "deletions": 0, "changes": 971, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fchange_return_type_to_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fchange_return_type_to_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fchange_return_type_to_result.rs?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -0,0 +1,971 @@\n+use ra_syntax::{\n+    ast::{self, BlockExpr, Expr, LoopBodyOwner},\n+    AstNode,\n+    SyntaxKind::{COMMENT, WHITESPACE},\n+    SyntaxNode, TextSize,\n+};\n+\n+use crate::{AssistContext, AssistId, Assists};\n+\n+// Assist: change_return_type_to_result\n+//\n+// Change the function's return type to Result.\n+//\n+// ```\n+// fn foo() -> i32<|> { 42i32 }\n+// ```\n+// ->\n+// ```\n+// fn foo() -> Result<i32, > { Ok(42i32) }\n+// ```\n+pub(crate) fn change_return_type_to_result(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    let fn_def = ctx.find_node_at_offset::<ast::FnDef>();\n+    let fn_def = &mut fn_def?;\n+    let ret_type = &fn_def.ret_type()?.type_ref()?;\n+    if ret_type.syntax().text().to_string().starts_with(\"Result<\") {\n+        return None;\n+    }\n+\n+    let block_expr = &fn_def.body()?;\n+    let cursor_in_ret_type =\n+        fn_def.ret_type()?.syntax().text_range().contains_range(ctx.frange.range);\n+    if !cursor_in_ret_type {\n+        return None;\n+    }\n+\n+    acc.add(\n+        AssistId(\"change_return_type_to_result\"),\n+        \"Change return type to Result\",\n+        ret_type.syntax().text_range(),\n+        |edit| {\n+            let mut tail_return_expr_collector = TailReturnCollector::new();\n+            tail_return_expr_collector.collect_jump_exprs(block_expr, false);\n+            tail_return_expr_collector.collect_tail_exprs(block_expr);\n+\n+            for ret_expr_arg in tail_return_expr_collector.exprs_to_wrap {\n+                edit.replace_node_and_indent(&ret_expr_arg, format!(\"Ok({})\", ret_expr_arg));\n+            }\n+            edit.replace_node_and_indent(ret_type.syntax(), format!(\"Result<{}, >\", ret_type));\n+\n+            if let Some(node_start) = result_insertion_offset(&ret_type) {\n+                edit.set_cursor(node_start + TextSize::of(&format!(\"Result<{}, \", ret_type)));\n+            }\n+        },\n+    )\n+}\n+\n+struct TailReturnCollector {\n+    exprs_to_wrap: Vec<SyntaxNode>,\n+}\n+\n+impl TailReturnCollector {\n+    fn new() -> Self {\n+        Self { exprs_to_wrap: vec![] }\n+    }\n+    /// Collect all`return` expression\n+    fn collect_jump_exprs(&mut self, block_expr: &BlockExpr, collect_break: bool) {\n+        let statements = block_expr.statements();\n+        for stmt in statements {\n+            let expr = match &stmt {\n+                ast::Stmt::ExprStmt(stmt) => stmt.expr(),\n+                ast::Stmt::LetStmt(stmt) => stmt.initializer(),\n+            };\n+            if let Some(expr) = &expr {\n+                self.handle_exprs(expr, collect_break);\n+            }\n+        }\n+\n+        // Browse tail expressions for each block\n+        if let Some(expr) = block_expr.expr() {\n+            if let Some(last_exprs) = get_tail_expr_from_block(&expr) {\n+                for last_expr in last_exprs {\n+                    let last_expr = match last_expr {\n+                        NodeType::Node(expr) | NodeType::Leaf(expr) => expr,\n+                    };\n+\n+                    if let Some(last_expr) = Expr::cast(last_expr.clone()) {\n+                        self.handle_exprs(&last_expr, collect_break);\n+                    } else if let Some(expr_stmt) = ast::Stmt::cast(last_expr) {\n+                        let expr_stmt = match &expr_stmt {\n+                            ast::Stmt::ExprStmt(stmt) => stmt.expr(),\n+                            ast::Stmt::LetStmt(stmt) => stmt.initializer(),\n+                        };\n+                        if let Some(expr) = &expr_stmt {\n+                            self.handle_exprs(expr, collect_break);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn handle_exprs(&mut self, expr: &Expr, collect_break: bool) {\n+        match expr {\n+            Expr::BlockExpr(block_expr) => {\n+                self.collect_jump_exprs(&block_expr, collect_break);\n+            }\n+            Expr::ReturnExpr(ret_expr) => {\n+                if let Some(ret_expr_arg) = &ret_expr.expr() {\n+                    self.exprs_to_wrap.push(ret_expr_arg.syntax().clone());\n+                }\n+            }\n+            Expr::BreakExpr(break_expr) if collect_break => {\n+                if let Some(break_expr_arg) = &break_expr.expr() {\n+                    self.exprs_to_wrap.push(break_expr_arg.syntax().clone());\n+                }\n+            }\n+            Expr::IfExpr(if_expr) => {\n+                for block in if_expr.blocks() {\n+                    self.collect_jump_exprs(&block, collect_break);\n+                }\n+            }\n+            Expr::LoopExpr(loop_expr) => {\n+                if let Some(block_expr) = loop_expr.loop_body() {\n+                    self.collect_jump_exprs(&block_expr, collect_break);\n+                }\n+            }\n+            Expr::ForExpr(for_expr) => {\n+                if let Some(block_expr) = for_expr.loop_body() {\n+                    self.collect_jump_exprs(&block_expr, collect_break);\n+                }\n+            }\n+            Expr::WhileExpr(while_expr) => {\n+                if let Some(block_expr) = while_expr.loop_body() {\n+                    self.collect_jump_exprs(&block_expr, collect_break);\n+                }\n+            }\n+            Expr::MatchExpr(match_expr) => {\n+                if let Some(arm_list) = match_expr.match_arm_list() {\n+                    arm_list.arms().filter_map(|match_arm| match_arm.expr()).for_each(|expr| {\n+                        self.handle_exprs(&expr, collect_break);\n+                    });\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    fn collect_tail_exprs(&mut self, block: &BlockExpr) {\n+        if let Some(expr) = block.expr() {\n+            self.handle_exprs(&expr, true);\n+            self.fetch_tail_exprs(&expr);\n+        }\n+    }\n+\n+    fn fetch_tail_exprs(&mut self, expr: &Expr) {\n+        if let Some(exprs) = get_tail_expr_from_block(expr) {\n+            for node_type in &exprs {\n+                match node_type {\n+                    NodeType::Leaf(expr) => {\n+                        self.exprs_to_wrap.push(expr.clone());\n+                    }\n+                    NodeType::Node(expr) => match &Expr::cast(expr.clone()) {\n+                        Some(last_expr) => {\n+                            self.fetch_tail_exprs(last_expr);\n+                        }\n+                        None => {\n+                            self.exprs_to_wrap.push(expr.clone());\n+                        }\n+                    },\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+enum NodeType {\n+    Leaf(SyntaxNode),\n+    Node(SyntaxNode),\n+}\n+\n+/// Get a tail expression inside a block\n+fn get_tail_expr_from_block(expr: &Expr) -> Option<Vec<NodeType>> {\n+    match expr {\n+        Expr::IfExpr(if_expr) => {\n+            let mut nodes = vec![];\n+            for block in if_expr.blocks() {\n+                if let Some(block_expr) = block.expr() {\n+                    if let Some(tail_exprs) = get_tail_expr_from_block(&block_expr) {\n+                        nodes.extend(tail_exprs);\n+                    }\n+                } else if let Some(last_expr) = block.syntax().last_child() {\n+                    nodes.push(NodeType::Node(last_expr));\n+                } else {\n+                    nodes.push(NodeType::Node(block.syntax().clone()));\n+                }\n+            }\n+            Some(nodes)\n+        }\n+        Expr::LoopExpr(loop_expr) => {\n+            loop_expr.syntax().last_child().map(|lc| vec![NodeType::Node(lc)])\n+        }\n+        Expr::ForExpr(for_expr) => {\n+            for_expr.syntax().last_child().map(|lc| vec![NodeType::Node(lc)])\n+        }\n+        Expr::WhileExpr(while_expr) => {\n+            while_expr.syntax().last_child().map(|lc| vec![NodeType::Node(lc)])\n+        }\n+        Expr::BlockExpr(block_expr) => {\n+            block_expr.expr().map(|lc| vec![NodeType::Node(lc.syntax().clone())])\n+        }\n+        Expr::MatchExpr(match_expr) => {\n+            let arm_list = match_expr.match_arm_list()?;\n+            let arms: Vec<NodeType> = arm_list\n+                .arms()\n+                .filter_map(|match_arm| match_arm.expr())\n+                .map(|expr| match expr {\n+                    Expr::ReturnExpr(ret_expr) => NodeType::Node(ret_expr.syntax().clone()),\n+                    Expr::BreakExpr(break_expr) => NodeType::Node(break_expr.syntax().clone()),\n+                    _ => match expr.syntax().last_child() {\n+                        Some(last_expr) => NodeType::Node(last_expr),\n+                        None => NodeType::Node(expr.syntax().clone()),\n+                    },\n+                })\n+                .collect();\n+\n+            Some(arms)\n+        }\n+        Expr::BreakExpr(expr) => expr.expr().map(|e| vec![NodeType::Leaf(e.syntax().clone())]),\n+        Expr::ReturnExpr(ret_expr) => Some(vec![NodeType::Node(ret_expr.syntax().clone())]),\n+        Expr::CallExpr(call_expr) => Some(vec![NodeType::Leaf(call_expr.syntax().clone())]),\n+        Expr::Literal(lit_expr) => Some(vec![NodeType::Leaf(lit_expr.syntax().clone())]),\n+        Expr::TupleExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n+        Expr::ArrayExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n+        Expr::ParenExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n+        Expr::PathExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n+        Expr::Label(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n+        Expr::RecordLit(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n+        Expr::IndexExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n+        Expr::MethodCallExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n+        Expr::AwaitExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n+        Expr::CastExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n+        Expr::RefExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n+        Expr::PrefixExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n+        Expr::RangeExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n+        Expr::BinExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n+        Expr::MacroCall(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n+        Expr::BoxExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n+        _ => None,\n+    }\n+}\n+\n+fn result_insertion_offset(ret_type: &ast::TypeRef) -> Option<TextSize> {\n+    let non_ws_child = ret_type\n+        .syntax()\n+        .children_with_tokens()\n+        .find(|it| it.kind() != COMMENT && it.kind() != WHITESPACE)?;\n+    Some(non_ws_child.text_range().start())\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n+\n+    use super::*;\n+\n+    #[test]\n+    fn change_return_type_to_result_simple() {\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo() -> i3<|>2 {\n+                let test = \"test\";\n+                return 42i32;\n+            }\"#,\n+            r#\"fn foo() -> Result<i32, <|>> {\n+                let test = \"test\";\n+                return Ok(42i32);\n+            }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn change_return_type_to_result_simple_return_type() {\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo() -> i32<|> {\n+                let test = \"test\";\n+                return 42i32;\n+            }\"#,\n+            r#\"fn foo() -> Result<i32, <|>> {\n+                let test = \"test\";\n+                return Ok(42i32);\n+            }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn change_return_type_to_result_simple_return_type_bad_cursor() {\n+        check_assist_not_applicable(\n+            change_return_type_to_result,\n+            r#\"fn foo() -> i32 {\n+                let test = \"test\";<|>\n+                return 42i32;\n+            }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn change_return_type_to_result_simple_with_cursor() {\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo() -> <|>i32 {\n+                let test = \"test\";\n+                return 42i32;\n+            }\"#,\n+            r#\"fn foo() -> Result<i32, <|>> {\n+                let test = \"test\";\n+                return Ok(42i32);\n+            }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn change_return_type_to_result_simple_with_tail() {\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo() -><|> i32 {\n+                let test = \"test\";\n+                42i32\n+            }\"#,\n+            r#\"fn foo() -> Result<i32, <|>> {\n+                let test = \"test\";\n+                Ok(42i32)\n+            }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn change_return_type_to_result_simple_with_tail_only() {\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo() -> i32<|> {\n+                42i32\n+            }\"#,\n+            r#\"fn foo() -> Result<i32, <|>> {\n+                Ok(42i32)\n+            }\"#,\n+        );\n+    }\n+    #[test]\n+    fn change_return_type_to_result_simple_with_tail_block_like() {\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo() -> i32<|> {\n+                if true {\n+                    42i32\n+                } else {\n+                    24i32\n+                }\n+            }\"#,\n+            r#\"fn foo() -> Result<i32, <|>> {\n+                if true {\n+                    Ok(42i32)\n+                } else {\n+                    Ok(24i32)\n+                }\n+            }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn change_return_type_to_result_simple_with_nested_if() {\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo() -> i32<|> {\n+                if true {\n+                    if false {\n+                        1\n+                    } else {\n+                        2\n+                    }\n+                } else {\n+                    24i32\n+                }\n+            }\"#,\n+            r#\"fn foo() -> Result<i32, <|>> {\n+                if true {\n+                    if false {\n+                        Ok(1)\n+                    } else {\n+                        Ok(2)\n+                    }\n+                } else {\n+                    Ok(24i32)\n+                }\n+            }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn change_return_type_to_result_simple_with_await() {\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"async fn foo() -> i<|>32 {\n+                if true {\n+                    if false {\n+                        1.await\n+                    } else {\n+                        2.await\n+                    }\n+                } else {\n+                    24i32.await\n+                }\n+            }\"#,\n+            r#\"async fn foo() -> Result<i32, <|>> {\n+                if true {\n+                    if false {\n+                        Ok(1.await)\n+                    } else {\n+                        Ok(2.await)\n+                    }\n+                } else {\n+                    Ok(24i32.await)\n+                }\n+            }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn change_return_type_to_result_simple_with_array() {\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo() -> [i32;<|> 3] {\n+                [1, 2, 3]\n+            }\"#,\n+            r#\"fn foo() -> Result<[i32; 3], <|>> {\n+                Ok([1, 2, 3])\n+            }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn change_return_type_to_result_simple_with_cast() {\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo() -<|>> i32 {\n+                if true {\n+                    if false {\n+                        1 as i32\n+                    } else {\n+                        2 as i32\n+                    }\n+                } else {\n+                    24 as i32\n+                }\n+            }\"#,\n+            r#\"fn foo() -> Result<i32, <|>> {\n+                if true {\n+                    if false {\n+                        Ok(1 as i32)\n+                    } else {\n+                        Ok(2 as i32)\n+                    }\n+                } else {\n+                    Ok(24 as i32)\n+                }\n+            }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn change_return_type_to_result_simple_with_tail_block_like_match() {\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo() -> i32<|> {\n+                let my_var = 5;\n+                match my_var {\n+                    5 => 42i32,\n+                    _ => 24i32,\n+                }\n+            }\"#,\n+            r#\"fn foo() -> Result<i32, <|>> {\n+                let my_var = 5;\n+                match my_var {\n+                    5 => Ok(42i32),\n+                    _ => Ok(24i32),\n+                }\n+            }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn change_return_type_to_result_simple_with_loop_with_tail() {\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo() -> i32<|> {\n+                let my_var = 5;\n+                loop {\n+                    println!(\"test\");\n+                    5\n+                }\n+\n+                my_var\n+            }\"#,\n+            r#\"fn foo() -> Result<i32, <|>> {\n+                let my_var = 5;\n+                loop {\n+                    println!(\"test\");\n+                    5\n+                }\n+\n+                Ok(my_var)\n+            }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn change_return_type_to_result_simple_with_loop_in_let_stmt() {\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo() -> i32<|> {\n+                let my_var = let x = loop {\n+                    break 1;\n+                };\n+\n+                my_var\n+            }\"#,\n+            r#\"fn foo() -> Result<i32, <|>> {\n+                let my_var = let x = loop {\n+                    break 1;\n+                };\n+\n+                Ok(my_var)\n+            }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn change_return_type_to_result_simple_with_tail_block_like_match_return_expr() {\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo() -> i32<|> {\n+                let my_var = 5;\n+                let res = match my_var {\n+                    5 => 42i32,\n+                    _ => return 24i32,\n+                };\n+\n+                res\n+            }\"#,\n+            r#\"fn foo() -> Result<i32, <|>> {\n+                let my_var = 5;\n+                let res = match my_var {\n+                    5 => 42i32,\n+                    _ => return Ok(24i32),\n+                };\n+\n+                Ok(res)\n+            }\"#,\n+        );\n+\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo() -> i32<|> {\n+                let my_var = 5;\n+                let res = if my_var == 5 {\n+                    42i32\n+                } else {\n+                    return 24i32;\n+                };\n+\n+                res\n+            }\"#,\n+            r#\"fn foo() -> Result<i32, <|>> {\n+                let my_var = 5;\n+                let res = if my_var == 5 {\n+                    42i32\n+                } else {\n+                    return Ok(24i32);\n+                };\n+\n+                Ok(res)\n+            }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn change_return_type_to_result_simple_with_tail_block_like_match_deeper() {\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo() -> i32<|> {\n+                let my_var = 5;\n+                match my_var {\n+                    5 => {\n+                        if true {\n+                            42i32\n+                        } else {\n+                            25i32\n+                        }\n+                    },\n+                    _ => {\n+                        let test = \"test\";\n+                        if test == \"test\" {\n+                            return bar();\n+                        }\n+                        53i32\n+                    },\n+                }\n+            }\"#,\n+            r#\"fn foo() -> Result<i32, <|>> {\n+                let my_var = 5;\n+                match my_var {\n+                    5 => {\n+                        if true {\n+                            Ok(42i32)\n+                        } else {\n+                            Ok(25i32)\n+                        }\n+                    },\n+                    _ => {\n+                        let test = \"test\";\n+                        if test == \"test\" {\n+                            return Ok(bar());\n+                        }\n+                        Ok(53i32)\n+                    },\n+                }\n+            }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn change_return_type_to_result_simple_with_tail_block_like_early_return() {\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo() -> i<|>32 {\n+                let test = \"test\";\n+                if test == \"test\" {\n+                    return 24i32;\n+                }\n+                53i32\n+            }\"#,\n+            r#\"fn foo() -> Result<i32, <|>> {\n+                let test = \"test\";\n+                if test == \"test\" {\n+                    return Ok(24i32);\n+                }\n+                Ok(53i32)\n+            }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn change_return_type_to_result_simple_with_closure() {\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo(the_field: u32) -><|> u32 {\n+                let true_closure = || {\n+                    return true;\n+                };\n+                if the_field < 5 {\n+                    let mut i = 0;\n+\n+\n+                    if true_closure() {\n+                        return 99;\n+                    } else {\n+                        return 0;\n+                    }\n+                }\n+\n+                the_field\n+            }\"#,\n+            r#\"fn foo(the_field: u32) -> Result<u32, <|>> {\n+                let true_closure = || {\n+                    return true;\n+                };\n+                if the_field < 5 {\n+                    let mut i = 0;\n+\n+\n+                    if true_closure() {\n+                        return Ok(99);\n+                    } else {\n+                        return Ok(0);\n+                    }\n+                }\n+\n+                Ok(the_field)\n+            }\"#,\n+        );\n+\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo(the_field: u32) -> u32<|> {\n+                let true_closure = || {\n+                    return true;\n+                };\n+                if the_field < 5 {\n+                    let mut i = 0;\n+\n+\n+                    if true_closure() {\n+                        return 99;\n+                    } else {\n+                        return 0;\n+                    }\n+                }\n+                let t = None;\n+\n+                t.unwrap_or_else(|| the_field)\n+            }\"#,\n+            r#\"fn foo(the_field: u32) -> Result<u32, <|>> {\n+                let true_closure = || {\n+                    return true;\n+                };\n+                if the_field < 5 {\n+                    let mut i = 0;\n+\n+\n+                    if true_closure() {\n+                        return Ok(99);\n+                    } else {\n+                        return Ok(0);\n+                    }\n+                }\n+                let t = None;\n+\n+                Ok(t.unwrap_or_else(|| the_field))\n+            }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn change_return_type_to_result_simple_with_weird_forms() {\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo() -> i32<|> {\n+                let test = \"test\";\n+                if test == \"test\" {\n+                    return 24i32;\n+                }\n+                let mut i = 0;\n+                loop {\n+                    if i == 1 {\n+                        break 55;\n+                    }\n+                    i += 1;\n+                }\n+            }\"#,\n+            r#\"fn foo() -> Result<i32, <|>> {\n+                let test = \"test\";\n+                if test == \"test\" {\n+                    return Ok(24i32);\n+                }\n+                let mut i = 0;\n+                loop {\n+                    if i == 1 {\n+                        break Ok(55);\n+                    }\n+                    i += 1;\n+                }\n+            }\"#,\n+        );\n+\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo() -> i32<|> {\n+                let test = \"test\";\n+                if test == \"test\" {\n+                    return 24i32;\n+                }\n+                let mut i = 0;\n+                loop {\n+                    loop {\n+                        if i == 1 {\n+                            break 55;\n+                        }\n+                        i += 1;\n+                    }\n+                }\n+            }\"#,\n+            r#\"fn foo() -> Result<i32, <|>> {\n+                let test = \"test\";\n+                if test == \"test\" {\n+                    return Ok(24i32);\n+                }\n+                let mut i = 0;\n+                loop {\n+                    loop {\n+                        if i == 1 {\n+                            break Ok(55);\n+                        }\n+                        i += 1;\n+                    }\n+                }\n+            }\"#,\n+        );\n+\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo() -> i3<|>2 {\n+                let test = \"test\";\n+                let other = 5;\n+                if test == \"test\" {\n+                    let res = match other {\n+                        5 => 43,\n+                        _ => return 56,\n+                    };\n+                }\n+                let mut i = 0;\n+                loop {\n+                    loop {\n+                        if i == 1 {\n+                            break 55;\n+                        }\n+                        i += 1;\n+                    }\n+                }\n+            }\"#,\n+            r#\"fn foo() -> Result<i32, <|>> {\n+                let test = \"test\";\n+                let other = 5;\n+                if test == \"test\" {\n+                    let res = match other {\n+                        5 => 43,\n+                        _ => return Ok(56),\n+                    };\n+                }\n+                let mut i = 0;\n+                loop {\n+                    loop {\n+                        if i == 1 {\n+                            break Ok(55);\n+                        }\n+                        i += 1;\n+                    }\n+                }\n+            }\"#,\n+        );\n+\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo(the_field: u32) -> u32<|> {\n+                if the_field < 5 {\n+                    let mut i = 0;\n+                    loop {\n+                        if i > 5 {\n+                            return 55u32;\n+                        }\n+                        i += 3;\n+                    }\n+\n+                    match i {\n+                        5 => return 99,\n+                        _ => return 0,\n+                    };\n+                }\n+\n+                the_field\n+            }\"#,\n+            r#\"fn foo(the_field: u32) -> Result<u32, <|>> {\n+                if the_field < 5 {\n+                    let mut i = 0;\n+                    loop {\n+                        if i > 5 {\n+                            return Ok(55u32);\n+                        }\n+                        i += 3;\n+                    }\n+\n+                    match i {\n+                        5 => return Ok(99),\n+                        _ => return Ok(0),\n+                    };\n+                }\n+\n+                Ok(the_field)\n+            }\"#,\n+        );\n+\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo(the_field: u32) -> u3<|>2 {\n+                if the_field < 5 {\n+                    let mut i = 0;\n+\n+                    match i {\n+                        5 => return 99,\n+                        _ => return 0,\n+                    }\n+                }\n+\n+                the_field\n+            }\"#,\n+            r#\"fn foo(the_field: u32) -> Result<u32, <|>> {\n+                if the_field < 5 {\n+                    let mut i = 0;\n+\n+                    match i {\n+                        5 => return Ok(99),\n+                        _ => return Ok(0),\n+                    }\n+                }\n+\n+                Ok(the_field)\n+            }\"#,\n+        );\n+\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo(the_field: u32) -> u32<|> {\n+                if the_field < 5 {\n+                    let mut i = 0;\n+\n+                    if i == 5 {\n+                        return 99\n+                    } else {\n+                        return 0\n+                    }\n+                }\n+\n+                the_field\n+            }\"#,\n+            r#\"fn foo(the_field: u32) -> Result<u32, <|>> {\n+                if the_field < 5 {\n+                    let mut i = 0;\n+\n+                    if i == 5 {\n+                        return Ok(99)\n+                    } else {\n+                        return Ok(0)\n+                    }\n+                }\n+\n+                Ok(the_field)\n+            }\"#,\n+        );\n+\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo(the_field: u32) -> <|>u32 {\n+                if the_field < 5 {\n+                    let mut i = 0;\n+\n+                    if i == 5 {\n+                        return 99;\n+                    } else {\n+                        return 0;\n+                    }\n+                }\n+\n+                the_field\n+            }\"#,\n+            r#\"fn foo(the_field: u32) -> Result<u32, <|>> {\n+                if the_field < 5 {\n+                    let mut i = 0;\n+\n+                    if i == 5 {\n+                        return Ok(99);\n+                    } else {\n+                        return Ok(0);\n+                    }\n+                }\n+\n+                Ok(the_field)\n+            }\"#,\n+        );\n+    }\n+}"}, {"sha": "e631766eff14ab6ae6ca2720ac033ef423b3026d", "filename": "crates/ra_assists/src/handlers/change_visibility.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fchange_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fchange_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fchange_visibility.rs?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -7,10 +7,10 @@ use ra_syntax::{\n     },\n     SyntaxNode, TextSize, T,\n };\n-\n-use crate::{Assist, AssistCtx, AssistId};\n use test_utils::tested_by;\n \n+use crate::{AssistContext, AssistId, Assists};\n+\n // Assist: change_visibility\n //\n // Adds or changes existing visibility specifier.\n@@ -22,14 +22,14 @@ use test_utils::tested_by;\n // ```\n // pub(crate) fn frobnicate() {}\n // ```\n-pub(crate) fn change_visibility(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn change_visibility(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     if let Some(vis) = ctx.find_node_at_offset::<ast::Visibility>() {\n-        return change_vis(ctx, vis);\n+        return change_vis(acc, vis);\n     }\n-    add_vis(ctx)\n+    add_vis(acc, ctx)\n }\n \n-fn add_vis(ctx: AssistCtx) -> Option<Assist> {\n+fn add_vis(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let item_keyword = ctx.token_at_offset().find(|leaf| match leaf.kind() {\n         T![const] | T![fn] | T![mod] | T![struct] | T![enum] | T![trait] => true,\n         _ => false,\n@@ -66,15 +66,10 @@ fn add_vis(ctx: AssistCtx) -> Option<Assist> {\n         return None;\n     };\n \n-    ctx.add_assist(\n-        AssistId(\"change_visibility\"),\n-        \"Change visibility to pub(crate)\",\n-        target,\n-        |edit| {\n-            edit.insert(offset, \"pub(crate) \");\n-            edit.set_cursor(offset);\n-        },\n-    )\n+    acc.add(AssistId(\"change_visibility\"), \"Change visibility to pub(crate)\", target, |edit| {\n+        edit.insert(offset, \"pub(crate) \");\n+        edit.set_cursor(offset);\n+    })\n }\n \n fn vis_offset(node: &SyntaxNode) -> TextSize {\n@@ -88,10 +83,10 @@ fn vis_offset(node: &SyntaxNode) -> TextSize {\n         .unwrap_or_else(|| node.text_range().start())\n }\n \n-fn change_vis(ctx: AssistCtx, vis: ast::Visibility) -> Option<Assist> {\n+fn change_vis(acc: &mut Assists, vis: ast::Visibility) -> Option<()> {\n     if vis.syntax().text() == \"pub\" {\n         let target = vis.syntax().text_range();\n-        return ctx.add_assist(\n+        return acc.add(\n             AssistId(\"change_visibility\"),\n             \"Change Visibility to pub(crate)\",\n             target,\n@@ -103,7 +98,7 @@ fn change_vis(ctx: AssistCtx, vis: ast::Visibility) -> Option<Assist> {\n     }\n     if vis.syntax().text() == \"pub(crate)\" {\n         let target = vis.syntax().text_range();\n-        return ctx.add_assist(\n+        return acc.add(\n             AssistId(\"change_visibility\"),\n             \"Change visibility to pub\",\n             target,"}, {"sha": "810784ad57535a6d0eb3840d50b435632e2aa168", "filename": "crates/ra_assists/src/handlers/early_return.rs", "status": "modified", "additions": 79, "deletions": 84, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fearly_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fearly_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fearly_return.rs?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -9,7 +9,7 @@ use ra_syntax::{\n };\n \n use crate::{\n-    assist_ctx::{Assist, AssistCtx},\n+    assist_context::{AssistContext, Assists},\n     utils::invert_boolean_expression,\n     AssistId,\n };\n@@ -36,7 +36,7 @@ use crate::{\n //     bar();\n // }\n // ```\n-pub(crate) fn convert_to_guarded_return(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn convert_to_guarded_return(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let if_expr: ast::IfExpr = ctx.find_node_at_offset()?;\n     if if_expr.else_branch().is_some() {\n         return None;\n@@ -93,96 +93,91 @@ pub(crate) fn convert_to_guarded_return(ctx: AssistCtx) -> Option<Assist> {\n     }\n \n     then_block.syntax().last_child_or_token().filter(|t| t.kind() == R_CURLY)?;\n-    let cursor_position = ctx.frange.range.start();\n+    let cursor_position = ctx.offset();\n \n     let target = if_expr.syntax().text_range();\n-    ctx.add_assist(\n-        AssistId(\"convert_to_guarded_return\"),\n-        \"Convert to guarded return\",\n-        target,\n-        |edit| {\n-            let if_indent_level = IndentLevel::from_node(&if_expr.syntax());\n-            let new_block = match if_let_pat {\n-                None => {\n-                    // If.\n-                    let new_expr = {\n-                        let then_branch =\n-                            make::block_expr(once(make::expr_stmt(early_expression).into()), None);\n-                        let cond = invert_boolean_expression(cond_expr);\n-                        let e = make::expr_if(make::condition(cond, None), then_branch);\n-                        if_indent_level.increase_indent(e)\n-                    };\n-                    replace(new_expr.syntax(), &then_block, &parent_block, &if_expr)\n-                }\n-                Some((path, bound_ident)) => {\n-                    // If-let.\n-                    let match_expr = {\n-                        let happy_arm = {\n-                            let pat = make::tuple_struct_pat(\n-                                path,\n-                                once(make::bind_pat(make::name(\"it\")).into()),\n-                            );\n-                            let expr = {\n-                                let name_ref = make::name_ref(\"it\");\n-                                let segment = make::path_segment(name_ref);\n-                                let path = make::path_unqualified(segment);\n-                                make::expr_path(path)\n-                            };\n-                            make::match_arm(once(pat.into()), expr)\n-                        };\n-\n-                        let sad_arm = make::match_arm(\n-                            // FIXME: would be cool to use `None` or `Err(_)` if appropriate\n-                            once(make::placeholder_pat().into()),\n-                            early_expression,\n+    acc.add(AssistId(\"convert_to_guarded_return\"), \"Convert to guarded return\", target, |edit| {\n+        let if_indent_level = IndentLevel::from_node(&if_expr.syntax());\n+        let new_block = match if_let_pat {\n+            None => {\n+                // If.\n+                let new_expr = {\n+                    let then_branch =\n+                        make::block_expr(once(make::expr_stmt(early_expression).into()), None);\n+                    let cond = invert_boolean_expression(cond_expr);\n+                    let e = make::expr_if(make::condition(cond, None), then_branch);\n+                    if_indent_level.increase_indent(e)\n+                };\n+                replace(new_expr.syntax(), &then_block, &parent_block, &if_expr)\n+            }\n+            Some((path, bound_ident)) => {\n+                // If-let.\n+                let match_expr = {\n+                    let happy_arm = {\n+                        let pat = make::tuple_struct_pat(\n+                            path,\n+                            once(make::bind_pat(make::name(\"it\")).into()),\n                         );\n-\n-                        make::expr_match(cond_expr, make::match_arm_list(vec![happy_arm, sad_arm]))\n+                        let expr = {\n+                            let name_ref = make::name_ref(\"it\");\n+                            let segment = make::path_segment(name_ref);\n+                            let path = make::path_unqualified(segment);\n+                            make::expr_path(path)\n+                        };\n+                        make::match_arm(once(pat.into()), expr)\n                     };\n \n-                    let let_stmt = make::let_stmt(\n-                        make::bind_pat(make::name(&bound_ident.syntax().to_string())).into(),\n-                        Some(match_expr),\n+                    let sad_arm = make::match_arm(\n+                        // FIXME: would be cool to use `None` or `Err(_)` if appropriate\n+                        once(make::placeholder_pat().into()),\n+                        early_expression,\n                     );\n-                    let let_stmt = if_indent_level.increase_indent(let_stmt);\n-                    replace(let_stmt.syntax(), &then_block, &parent_block, &if_expr)\n-                }\n-            };\n-            edit.replace_ast(parent_block, ast::BlockExpr::cast(new_block).unwrap());\n-            edit.set_cursor(cursor_position);\n-\n-            fn replace(\n-                new_expr: &SyntaxNode,\n-                then_block: &ast::BlockExpr,\n-                parent_block: &ast::BlockExpr,\n-                if_expr: &ast::IfExpr,\n-            ) -> SyntaxNode {\n-                let then_block_items = IndentLevel::from(1).decrease_indent(then_block.clone());\n-                let end_of_then = then_block_items.syntax().last_child_or_token().unwrap();\n-                let end_of_then =\n-                    if end_of_then.prev_sibling_or_token().map(|n| n.kind()) == Some(WHITESPACE) {\n-                        end_of_then.prev_sibling_or_token().unwrap()\n-                    } else {\n-                        end_of_then\n-                    };\n-                let mut then_statements = new_expr.children_with_tokens().chain(\n-                    then_block_items\n-                        .syntax()\n-                        .children_with_tokens()\n-                        .skip(1)\n-                        .take_while(|i| *i != end_of_then),\n+\n+                    make::expr_match(cond_expr, make::match_arm_list(vec![happy_arm, sad_arm]))\n+                };\n+\n+                let let_stmt = make::let_stmt(\n+                    make::bind_pat(make::name(&bound_ident.syntax().to_string())).into(),\n+                    Some(match_expr),\n                 );\n-                replace_children(\n-                    &parent_block.syntax(),\n-                    RangeInclusive::new(\n-                        if_expr.clone().syntax().clone().into(),\n-                        if_expr.syntax().clone().into(),\n-                    ),\n-                    &mut then_statements,\n-                )\n+                let let_stmt = if_indent_level.increase_indent(let_stmt);\n+                replace(let_stmt.syntax(), &then_block, &parent_block, &if_expr)\n             }\n-        },\n-    )\n+        };\n+        edit.replace_ast(parent_block, ast::BlockExpr::cast(new_block).unwrap());\n+        edit.set_cursor(cursor_position);\n+\n+        fn replace(\n+            new_expr: &SyntaxNode,\n+            then_block: &ast::BlockExpr,\n+            parent_block: &ast::BlockExpr,\n+            if_expr: &ast::IfExpr,\n+        ) -> SyntaxNode {\n+            let then_block_items = IndentLevel::from(1).decrease_indent(then_block.clone());\n+            let end_of_then = then_block_items.syntax().last_child_or_token().unwrap();\n+            let end_of_then =\n+                if end_of_then.prev_sibling_or_token().map(|n| n.kind()) == Some(WHITESPACE) {\n+                    end_of_then.prev_sibling_or_token().unwrap()\n+                } else {\n+                    end_of_then\n+                };\n+            let mut then_statements = new_expr.children_with_tokens().chain(\n+                then_block_items\n+                    .syntax()\n+                    .children_with_tokens()\n+                    .skip(1)\n+                    .take_while(|i| *i != end_of_then),\n+            );\n+            replace_children(\n+                &parent_block.syntax(),\n+                RangeInclusive::new(\n+                    if_expr.clone().syntax().clone().into(),\n+                    if_expr.syntax().clone().into(),\n+                ),\n+                &mut then_statements,\n+            )\n+        }\n+    })\n }\n \n #[cfg(test)]"}, {"sha": "13c1e7e8014b1317aeebc4992a44a4261943b784", "filename": "crates/ra_assists/src/handlers/fill_match_arms.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -5,7 +5,7 @@ use itertools::Itertools;\n use ra_ide_db::RootDatabase;\n use ra_syntax::ast::{self, make, AstNode, MatchArm, NameOwner, Pat};\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: fill_match_arms\n //\n@@ -31,7 +31,7 @@ use crate::{Assist, AssistCtx, AssistId};\n //     }\n // }\n // ```\n-pub(crate) fn fill_match_arms(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn fill_match_arms(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let match_expr = ctx.find_node_at_offset::<ast::MatchExpr>()?;\n     let match_arm_list = match_expr.match_arm_list()?;\n \n@@ -93,7 +93,7 @@ pub(crate) fn fill_match_arms(ctx: AssistCtx) -> Option<Assist> {\n     }\n \n     let target = match_expr.syntax().text_range();\n-    ctx.add_assist(AssistId(\"fill_match_arms\"), \"Fill match arms\", target, |edit| {\n+    acc.add(AssistId(\"fill_match_arms\"), \"Fill match arms\", target, |edit| {\n         let new_arm_list = match_arm_list.remove_placeholder().append_arms(missing_arms);\n         edit.set_cursor(expr.syntax().text_range().start());\n         edit.replace_ast(match_arm_list, new_arm_list);"}, {"sha": "692ba4895cb2e917e428fc1e7355dc65da6cab8c", "filename": "crates/ra_assists/src/handlers/flip_binexpr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_binexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_binexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_binexpr.rs?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -1,6 +1,6 @@\n use ra_syntax::ast::{AstNode, BinExpr, BinOp};\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: flip_binexpr\n //\n@@ -17,7 +17,7 @@ use crate::{Assist, AssistCtx, AssistId};\n //     let _ = 2 + 90;\n // }\n // ```\n-pub(crate) fn flip_binexpr(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn flip_binexpr(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let expr = ctx.find_node_at_offset::<BinExpr>()?;\n     let lhs = expr.lhs()?.syntax().clone();\n     let rhs = expr.rhs()?.syntax().clone();\n@@ -33,7 +33,7 @@ pub(crate) fn flip_binexpr(ctx: AssistCtx) -> Option<Assist> {\n         return None;\n     }\n \n-    ctx.add_assist(AssistId(\"flip_binexpr\"), \"Flip binary expression\", op_range, |edit| {\n+    acc.add(AssistId(\"flip_binexpr\"), \"Flip binary expression\", op_range, |edit| {\n         if let FlipAction::FlipAndReplaceOp(new_op) = action {\n             edit.replace(op_range, new_op);\n         }"}, {"sha": "dfe2a7fedc0576a5a7adfa6176f9154abc68b95b", "filename": "crates/ra_assists/src/handlers/flip_comma.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_comma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_comma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_comma.rs?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -1,6 +1,6 @@\n use ra_syntax::{algo::non_trivia_sibling, Direction, T};\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: flip_comma\n //\n@@ -17,7 +17,7 @@ use crate::{Assist, AssistCtx, AssistId};\n //     ((3, 4), (1, 2));\n // }\n // ```\n-pub(crate) fn flip_comma(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn flip_comma(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let comma = ctx.find_token_at_offset(T![,])?;\n     let prev = non_trivia_sibling(comma.clone().into(), Direction::Prev)?;\n     let next = non_trivia_sibling(comma.clone().into(), Direction::Next)?;\n@@ -28,7 +28,7 @@ pub(crate) fn flip_comma(ctx: AssistCtx) -> Option<Assist> {\n         return None;\n     }\n \n-    ctx.add_assist(AssistId(\"flip_comma\"), \"Flip comma\", comma.text_range(), |edit| {\n+    acc.add(AssistId(\"flip_comma\"), \"Flip comma\", comma.text_range(), |edit| {\n         edit.replace(prev.text_range(), next.to_string());\n         edit.replace(next.text_range(), prev.to_string());\n     })"}, {"sha": "8a08702ab29caf6694f46ebabccde4bf81c2189c", "filename": "crates/ra_assists/src/handlers/flip_trait_bound.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_trait_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_trait_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_trait_bound.rs?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -4,7 +4,7 @@ use ra_syntax::{\n     Direction, T,\n };\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: flip_trait_bound\n //\n@@ -17,7 +17,7 @@ use crate::{Assist, AssistCtx, AssistId};\n // ```\n // fn foo<T: Copy + Clone>() { }\n // ```\n-pub(crate) fn flip_trait_bound(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn flip_trait_bound(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     // We want to replicate the behavior of `flip_binexpr` by only suggesting\n     // the assist when the cursor is on a `+`\n     let plus = ctx.find_token_at_offset(T![+])?;\n@@ -33,7 +33,7 @@ pub(crate) fn flip_trait_bound(ctx: AssistCtx) -> Option<Assist> {\n     );\n \n     let target = plus.text_range();\n-    ctx.add_assist(AssistId(\"flip_trait_bound\"), \"Flip trait bounds\", target, |edit| {\n+    acc.add(AssistId(\"flip_trait_bound\"), \"Flip trait bounds\", target, |edit| {\n         edit.replace(before.text_range(), after.to_string());\n         edit.replace(after.text_range(), before.to_string());\n     })"}, {"sha": "5b26814d30ad3d66ef847abe5b79fb0e555b1ac6", "filename": "crates/ra_assists/src/handlers/inline_local_variable.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -5,7 +5,10 @@ use ra_syntax::{\n };\n use test_utils::tested_by;\n \n-use crate::{assist_ctx::ActionBuilder, Assist, AssistCtx, AssistId};\n+use crate::{\n+    assist_context::{AssistContext, Assists},\n+    AssistId,\n+};\n \n // Assist: inline_local_variable\n //\n@@ -23,7 +26,7 @@ use crate::{assist_ctx::ActionBuilder, Assist, AssistCtx, AssistId};\n //     (1 + 2) * 4;\n // }\n // ```\n-pub(crate) fn inline_local_variable(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn inline_local_variable(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let let_stmt = ctx.find_node_at_offset::<ast::LetStmt>()?;\n     let bind_pat = match let_stmt.pat()? {\n         ast::Pat::BindPat(pat) => pat,\n@@ -33,7 +36,7 @@ pub(crate) fn inline_local_variable(ctx: AssistCtx) -> Option<Assist> {\n         tested_by!(test_not_inline_mut_variable);\n         return None;\n     }\n-    if !bind_pat.syntax().text_range().contains_inclusive(ctx.frange.range.start()) {\n+    if !bind_pat.syntax().text_range().contains_inclusive(ctx.offset()) {\n         tested_by!(not_applicable_outside_of_bind_pat);\n         return None;\n     }\n@@ -107,20 +110,14 @@ pub(crate) fn inline_local_variable(ctx: AssistCtx) -> Option<Assist> {\n     let init_in_paren = format!(\"({})\", &init_str);\n \n     let target = bind_pat.syntax().text_range();\n-    ctx.add_assist(\n-        AssistId(\"inline_local_variable\"),\n-        \"Inline variable\",\n-        target,\n-        move |edit: &mut ActionBuilder| {\n-            edit.delete(delete_range);\n-            for (desc, should_wrap) in refs.iter().zip(wrap_in_parens) {\n-                let replacement =\n-                    if should_wrap { init_in_paren.clone() } else { init_str.clone() };\n-                edit.replace(desc.file_range.range, replacement)\n-            }\n-            edit.set_cursor(delete_range.start())\n-        },\n-    )\n+    acc.add(AssistId(\"inline_local_variable\"), \"Inline variable\", target, move |builder| {\n+        builder.delete(delete_range);\n+        for (desc, should_wrap) in refs.iter().zip(wrap_in_parens) {\n+            let replacement = if should_wrap { init_in_paren.clone() } else { init_str.clone() };\n+            builder.replace(desc.file_range.range, replacement)\n+        }\n+        builder.set_cursor(delete_range.start())\n+    })\n }\n \n #[cfg(test)]"}, {"sha": "fdf3ada0d794a8638eeff6ed0f4e9ef92b2401cc", "filename": "crates/ra_assists/src/handlers/introduce_variable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fintroduce_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fintroduce_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fintroduce_variable.rs?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -9,7 +9,7 @@ use ra_syntax::{\n use stdx::format_to;\n use test_utils::tested_by;\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: introduce_variable\n //\n@@ -27,7 +27,7 @@ use crate::{Assist, AssistCtx, AssistId};\n //     var_name * 4;\n // }\n // ```\n-pub(crate) fn introduce_variable(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn introduce_variable(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     if ctx.frange.range.is_empty() {\n         return None;\n     }\n@@ -43,7 +43,7 @@ pub(crate) fn introduce_variable(ctx: AssistCtx) -> Option<Assist> {\n         return None;\n     }\n     let target = expr.syntax().text_range();\n-    ctx.add_assist(AssistId(\"introduce_variable\"), \"Extract into variable\", target, move |edit| {\n+    acc.add(AssistId(\"introduce_variable\"), \"Extract into variable\", target, move |edit| {\n         let mut buf = String::new();\n \n         let cursor_offset = if wrap_in_block {"}, {"sha": "527c7caef1a3bf2c068c17588c4148816b51fa5a", "filename": "crates/ra_assists/src/handlers/invert_if.rs", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Finvert_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Finvert_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Finvert_if.rs?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -3,7 +3,11 @@ use ra_syntax::{\n     T,\n };\n \n-use crate::{utils::invert_boolean_expression, Assist, AssistCtx, AssistId};\n+use crate::{\n+    assist_context::{AssistContext, Assists},\n+    utils::invert_boolean_expression,\n+    AssistId,\n+};\n \n // Assist: invert_if\n //\n@@ -24,7 +28,7 @@ use crate::{utils::invert_boolean_expression, Assist, AssistCtx, AssistId};\n // }\n // ```\n \n-pub(crate) fn invert_if(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn invert_if(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let if_keyword = ctx.find_token_at_offset(T![if])?;\n     let expr = ast::IfExpr::cast(if_keyword.parent())?;\n     let if_range = if_keyword.text_range();\n@@ -40,21 +44,21 @@ pub(crate) fn invert_if(ctx: AssistCtx) -> Option<Assist> {\n \n     let cond = expr.condition()?.expr()?;\n     let then_node = expr.then_branch()?.syntax().clone();\n+    let else_block = match expr.else_branch()? {\n+        ast::ElseBranch::Block(it) => it,\n+        ast::ElseBranch::IfExpr(_) => return None,\n+    };\n \n-    if let ast::ElseBranch::Block(else_block) = expr.else_branch()? {\n-        let cond_range = cond.syntax().text_range();\n-        let flip_cond = invert_boolean_expression(cond);\n-        let else_node = else_block.syntax();\n-        let else_range = else_node.text_range();\n-        let then_range = then_node.text_range();\n-        return ctx.add_assist(AssistId(\"invert_if\"), \"Invert if\", if_range, |edit| {\n-            edit.replace(cond_range, flip_cond.syntax().text());\n-            edit.replace(else_range, then_node.text());\n-            edit.replace(then_range, else_node.text());\n-        });\n-    }\n-\n-    None\n+    let cond_range = cond.syntax().text_range();\n+    let flip_cond = invert_boolean_expression(cond);\n+    let else_node = else_block.syntax();\n+    let else_range = else_node.text_range();\n+    let then_range = then_node.text_range();\n+    acc.add(AssistId(\"invert_if\"), \"Invert if\", if_range, |edit| {\n+        edit.replace(cond_range, flip_cond.syntax().text());\n+        edit.replace(else_range, then_node.text());\n+        edit.replace(then_range, else_node.text());\n+    })\n }\n \n #[cfg(test)]"}, {"sha": "ac3e53c2734a9f05bb2e604e03d36a6a85507911", "filename": "crates/ra_assists/src/handlers/merge_imports.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_imports.rs?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -6,7 +6,10 @@ use ra_syntax::{\n     AstNode, Direction, InsertPosition, SyntaxElement, T,\n };\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{\n+    assist_context::{AssistContext, Assists},\n+    AssistId,\n+};\n \n // Assist: merge_imports\n //\n@@ -20,10 +23,10 @@ use crate::{Assist, AssistCtx, AssistId};\n // ```\n // use std::{fmt::Formatter, io};\n // ```\n-pub(crate) fn merge_imports(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn merge_imports(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let tree: ast::UseTree = ctx.find_node_at_offset()?;\n     let mut rewriter = SyntaxRewriter::default();\n-    let mut offset = ctx.frange.range.start();\n+    let mut offset = ctx.offset();\n \n     if let Some(use_item) = tree.syntax().parent().and_then(ast::UseItem::cast) {\n         let (merged, to_delete) = next_prev()\n@@ -53,10 +56,10 @@ pub(crate) fn merge_imports(ctx: AssistCtx) -> Option<Assist> {\n     };\n \n     let target = tree.syntax().text_range();\n-    ctx.add_assist(AssistId(\"merge_imports\"), \"Merge imports\", target, |edit| {\n-        edit.rewrite(rewriter);\n+    acc.add(AssistId(\"merge_imports\"), \"Merge imports\", target, |builder| {\n+        builder.rewrite(rewriter);\n         // FIXME: we only need because our diff is imprecise\n-        edit.set_cursor(offset);\n+        builder.set_cursor(offset);\n     })\n }\n "}, {"sha": "d4e38aa6a592c162bbf4ad1cf20a371ddb9922be", "filename": "crates/ra_assists/src/handlers/merge_match_arms.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_match_arms.rs?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -6,7 +6,7 @@ use ra_syntax::{\n     Direction, TextSize,\n };\n \n-use crate::{Assist, AssistCtx, AssistId, TextRange};\n+use crate::{AssistContext, AssistId, Assists, TextRange};\n \n // Assist: merge_match_arms\n //\n@@ -32,7 +32,7 @@ use crate::{Assist, AssistCtx, AssistId, TextRange};\n //     }\n // }\n // ```\n-pub(crate) fn merge_match_arms(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn merge_match_arms(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let current_arm = ctx.find_node_at_offset::<ast::MatchArm>()?;\n     // Don't try to handle arms with guards for now - can add support for this later\n     if current_arm.guard().is_some() {\n@@ -45,7 +45,7 @@ pub(crate) fn merge_match_arms(ctx: AssistCtx) -> Option<Assist> {\n         InExpr(TextSize),\n         InPat(TextSize),\n     }\n-    let cursor_pos = ctx.frange.range.start();\n+    let cursor_pos = ctx.offset();\n     let cursor_pos = if current_expr.syntax().text_range().contains(cursor_pos) {\n         CursorPos::InExpr(current_text_range.end() - cursor_pos)\n     } else {\n@@ -70,7 +70,7 @@ pub(crate) fn merge_match_arms(ctx: AssistCtx) -> Option<Assist> {\n         return None;\n     }\n \n-    ctx.add_assist(AssistId(\"merge_match_arms\"), \"Merge match arms\", current_text_range, |edit| {\n+    acc.add(AssistId(\"merge_match_arms\"), \"Merge match arms\", current_text_range, |edit| {\n         let pats = if arms_to_merge.iter().any(contains_placeholder) {\n             \"_\".into()\n         } else {"}, {"sha": "a41aacfc3dc39605282f5dd392692481d14e9ad5", "filename": "crates/ra_assists/src/handlers/move_bounds.rs", "status": "modified", "additions": 25, "deletions": 32, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmove_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmove_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmove_bounds.rs?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -5,7 +5,7 @@ use ra_syntax::{\n     T,\n };\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: move_bounds_to_where_clause\n //\n@@ -22,7 +22,7 @@ use crate::{Assist, AssistCtx, AssistId};\n //     f(x)\n // }\n // ```\n-pub(crate) fn move_bounds_to_where_clause(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn move_bounds_to_where_clause(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let type_param_list = ctx.find_node_at_offset::<ast::TypeParamList>()?;\n \n     let mut type_params = type_param_list.type_params();\n@@ -50,36 +50,29 @@ pub(crate) fn move_bounds_to_where_clause(ctx: AssistCtx) -> Option<Assist> {\n     };\n \n     let target = type_param_list.syntax().text_range();\n-    ctx.add_assist(\n-        AssistId(\"move_bounds_to_where_clause\"),\n-        \"Move to where clause\",\n-        target,\n-        |edit| {\n-            let new_params = type_param_list\n-                .type_params()\n-                .filter(|it| it.type_bound_list().is_some())\n-                .map(|type_param| {\n-                    let without_bounds = type_param.remove_bounds();\n-                    (type_param, without_bounds)\n-                });\n-\n-            let new_type_param_list = type_param_list.replace_descendants(new_params);\n-            edit.replace_ast(type_param_list.clone(), new_type_param_list);\n-\n-            let where_clause = {\n-                let predicates = type_param_list.type_params().filter_map(build_predicate);\n-                make::where_clause(predicates)\n-            };\n-\n-            let to_insert = match anchor.prev_sibling_or_token() {\n-                Some(ref elem) if elem.kind() == WHITESPACE => {\n-                    format!(\"{} \", where_clause.syntax())\n-                }\n-                _ => format!(\" {}\", where_clause.syntax()),\n-            };\n-            edit.insert(anchor.text_range().start(), to_insert);\n-        },\n-    )\n+    acc.add(AssistId(\"move_bounds_to_where_clause\"), \"Move to where clause\", target, |edit| {\n+        let new_params = type_param_list\n+            .type_params()\n+            .filter(|it| it.type_bound_list().is_some())\n+            .map(|type_param| {\n+                let without_bounds = type_param.remove_bounds();\n+                (type_param, without_bounds)\n+            });\n+\n+        let new_type_param_list = type_param_list.replace_descendants(new_params);\n+        edit.replace_ast(type_param_list.clone(), new_type_param_list);\n+\n+        let where_clause = {\n+            let predicates = type_param_list.type_params().filter_map(build_predicate);\n+            make::where_clause(predicates)\n+        };\n+\n+        let to_insert = match anchor.prev_sibling_or_token() {\n+            Some(ref elem) if elem.kind() == WHITESPACE => format!(\"{} \", where_clause.syntax()),\n+            _ => format!(\" {}\", where_clause.syntax()),\n+        };\n+        edit.insert(anchor.text_range().start(), to_insert);\n+    })\n }\n \n fn build_predicate(param: ast::TypeParam) -> Option<ast::WherePred> {"}, {"sha": "fc0335b5785d909179f9a6fdb2b4876c76521bee", "filename": "crates/ra_assists/src/handlers/move_guard.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmove_guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmove_guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmove_guard.rs?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -4,7 +4,7 @@ use ra_syntax::{\n     TextSize,\n };\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: move_guard_to_arm_body\n //\n@@ -31,7 +31,7 @@ use crate::{Assist, AssistCtx, AssistId};\n //     }\n // }\n // ```\n-pub(crate) fn move_guard_to_arm_body(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn move_guard_to_arm_body(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let match_arm = ctx.find_node_at_offset::<MatchArm>()?;\n     let guard = match_arm.guard()?;\n     let space_before_guard = guard.syntax().prev_sibling_or_token();\n@@ -41,7 +41,7 @@ pub(crate) fn move_guard_to_arm_body(ctx: AssistCtx) -> Option<Assist> {\n     let buf = format!(\"if {} {{ {} }}\", guard_conditions.syntax().text(), arm_expr.syntax().text());\n \n     let target = guard.syntax().text_range();\n-    ctx.add_assist(AssistId(\"move_guard_to_arm_body\"), \"Move guard to arm body\", target, |edit| {\n+    acc.add(AssistId(\"move_guard_to_arm_body\"), \"Move guard to arm body\", target, |edit| {\n         let offseting_amount = match space_before_guard.and_then(|it| it.into_token()) {\n             Some(tok) => {\n                 if ast::Whitespace::cast(tok.clone()).is_some() {\n@@ -88,7 +88,7 @@ pub(crate) fn move_guard_to_arm_body(ctx: AssistCtx) -> Option<Assist> {\n //     }\n // }\n // ```\n-pub(crate) fn move_arm_cond_to_match_guard(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn move_arm_cond_to_match_guard(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let match_arm: MatchArm = ctx.find_node_at_offset::<MatchArm>()?;\n     let match_pat = match_arm.pat()?;\n \n@@ -109,7 +109,7 @@ pub(crate) fn move_arm_cond_to_match_guard(ctx: AssistCtx) -> Option<Assist> {\n     let buf = format!(\" if {}\", cond.syntax().text());\n \n     let target = if_expr.syntax().text_range();\n-    ctx.add_assist(\n+    acc.add(\n         AssistId(\"move_arm_cond_to_match_guard\"),\n         \"Move condition to match guard\",\n         target,"}, {"sha": "c20ffe0b30aba765e97876eb08c18710f0a4fa49", "filename": "crates/ra_assists/src/handlers/raw_string.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fraw_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fraw_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fraw_string.rs?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -5,7 +5,7 @@ use ra_syntax::{\n     TextSize,\n };\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: make_raw_string\n //\n@@ -22,11 +22,11 @@ use crate::{Assist, AssistCtx, AssistId};\n //     r#\"Hello, World!\"#;\n // }\n // ```\n-pub(crate) fn make_raw_string(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn make_raw_string(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let token = ctx.find_token_at_offset(STRING).and_then(ast::String::cast)?;\n     let value = token.value()?;\n     let target = token.syntax().text_range();\n-    ctx.add_assist(AssistId(\"make_raw_string\"), \"Rewrite as raw string\", target, |edit| {\n+    acc.add(AssistId(\"make_raw_string\"), \"Rewrite as raw string\", target, |edit| {\n         let max_hash_streak = count_hashes(&value);\n         let mut hashes = String::with_capacity(max_hash_streak + 1);\n         for _ in 0..hashes.capacity() {\n@@ -51,11 +51,11 @@ pub(crate) fn make_raw_string(ctx: AssistCtx) -> Option<Assist> {\n //     \"Hello, \\\"World!\\\"\";\n // }\n // ```\n-pub(crate) fn make_usual_string(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn make_usual_string(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let token = ctx.find_token_at_offset(RAW_STRING).and_then(ast::RawString::cast)?;\n     let value = token.value()?;\n     let target = token.syntax().text_range();\n-    ctx.add_assist(AssistId(\"make_usual_string\"), \"Rewrite as regular string\", target, |edit| {\n+    acc.add(AssistId(\"make_usual_string\"), \"Rewrite as regular string\", target, |edit| {\n         // parse inside string to escape `\"`\n         let escaped = value.escape_default().to_string();\n         edit.replace(token.syntax().text_range(), format!(\"\\\"{}\\\"\", escaped));\n@@ -77,10 +77,10 @@ pub(crate) fn make_usual_string(ctx: AssistCtx) -> Option<Assist> {\n //     r##\"Hello, World!\"##;\n // }\n // ```\n-pub(crate) fn add_hash(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn add_hash(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let token = ctx.find_token_at_offset(RAW_STRING)?;\n     let target = token.text_range();\n-    ctx.add_assist(AssistId(\"add_hash\"), \"Add # to raw string\", target, |edit| {\n+    acc.add(AssistId(\"add_hash\"), \"Add # to raw string\", target, |edit| {\n         edit.insert(token.text_range().start() + TextSize::of('r'), \"#\");\n         edit.insert(token.text_range().end(), \"#\");\n     })\n@@ -101,15 +101,15 @@ pub(crate) fn add_hash(ctx: AssistCtx) -> Option<Assist> {\n //     r\"Hello, World!\";\n // }\n // ```\n-pub(crate) fn remove_hash(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn remove_hash(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let token = ctx.find_token_at_offset(RAW_STRING)?;\n     let text = token.text().as_str();\n     if text.starts_with(\"r\\\"\") {\n         // no hash to remove\n         return None;\n     }\n     let target = token.text_range();\n-    ctx.add_assist(AssistId(\"remove_hash\"), \"Remove hash from raw string\", target, |edit| {\n+    acc.add(AssistId(\"remove_hash\"), \"Remove hash from raw string\", target, |edit| {\n         let result = &text[2..text.len() - 1];\n         let result = if result.starts_with('\\\"') {\n             // FIXME: this logic is wrong, not only the last has has to handled specially"}, {"sha": "8eef578cf40128ae2fafc658c451ac30150bbe44", "filename": "crates/ra_assists/src/handlers/remove_dbg.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fremove_dbg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fremove_dbg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fremove_dbg.rs?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -3,7 +3,7 @@ use ra_syntax::{\n     TextSize, T,\n };\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: remove_dbg\n //\n@@ -20,7 +20,7 @@ use crate::{Assist, AssistCtx, AssistId};\n //     92;\n // }\n // ```\n-pub(crate) fn remove_dbg(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn remove_dbg(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let macro_call = ctx.find_node_at_offset::<ast::MacroCall>()?;\n \n     if !is_valid_macrocall(&macro_call, \"dbg\")? {\n@@ -58,7 +58,7 @@ pub(crate) fn remove_dbg(ctx: AssistCtx) -> Option<Assist> {\n     };\n \n     let target = macro_call.syntax().text_range();\n-    ctx.add_assist(AssistId(\"remove_dbg\"), \"Remove dbg!()\", target, |edit| {\n+    acc.add(AssistId(\"remove_dbg\"), \"Remove dbg!()\", target, |edit| {\n         edit.replace(macro_range, macro_content);\n         edit.set_cursor(cursor_pos);\n     })"}, {"sha": "dce546db79d5607eb7cc1c9d3edf8ef15c98b6f9", "filename": "crates/ra_assists/src/handlers/remove_mut.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fremove_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fremove_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fremove_mut.rs?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -1,6 +1,6 @@\n use ra_syntax::{SyntaxKind, TextRange, T};\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: remove_mut\n //\n@@ -17,7 +17,7 @@ use crate::{Assist, AssistCtx, AssistId};\n //     fn feed(&self, amount: u32) {}\n // }\n // ```\n-pub(crate) fn remove_mut(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn remove_mut(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let mut_token = ctx.find_token_at_offset(T![mut])?;\n     let delete_from = mut_token.text_range().start();\n     let delete_to = match mut_token.next_token() {\n@@ -26,7 +26,7 @@ pub(crate) fn remove_mut(ctx: AssistCtx) -> Option<Assist> {\n     };\n \n     let target = mut_token.text_range();\n-    ctx.add_assist(AssistId(\"remove_mut\"), \"Remove `mut` keyword\", target, |edit| {\n+    acc.add(AssistId(\"remove_mut\"), \"Remove `mut` keyword\", target, |edit| {\n         edit.set_cursor(delete_from);\n         edit.delete(TextRange::new(delete_from, delete_to));\n     })"}, {"sha": "757f6406e9185e7f7c05d4963ae536076fd4b293", "filename": "crates/ra_assists/src/handlers/reorder_fields.rs", "status": "modified", "additions": 10, "deletions": 19, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freorder_fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freorder_fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freorder_fields.rs?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -3,18 +3,9 @@ use std::collections::HashMap;\n use hir::{Adt, ModuleDef, PathResolution, Semantics, Struct};\n use itertools::Itertools;\n use ra_ide_db::RootDatabase;\n-use ra_syntax::{\n-    algo,\n-    ast::{self, Path, RecordLit, RecordPat},\n-    match_ast, AstNode, SyntaxKind,\n-    SyntaxKind::*,\n-    SyntaxNode,\n-};\n-\n-use crate::{\n-    assist_ctx::{Assist, AssistCtx},\n-    AssistId,\n-};\n+use ra_syntax::{algo, ast, match_ast, AstNode, SyntaxKind, SyntaxKind::*, SyntaxNode};\n+\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: reorder_fields\n //\n@@ -31,13 +22,13 @@ use crate::{\n // const test: Foo = Foo {foo: 1, bar: 0}\n // ```\n //\n-pub(crate) fn reorder_fields(ctx: AssistCtx) -> Option<Assist> {\n-    reorder::<RecordLit>(ctx.clone()).or_else(|| reorder::<RecordPat>(ctx))\n+pub(crate) fn reorder_fields(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    reorder::<ast::RecordLit>(acc, ctx.clone()).or_else(|| reorder::<ast::RecordPat>(acc, ctx))\n }\n \n-fn reorder<R: AstNode>(ctx: AssistCtx) -> Option<Assist> {\n+fn reorder<R: AstNode>(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let record = ctx.find_node_at_offset::<R>()?;\n-    let path = record.syntax().children().find_map(Path::cast)?;\n+    let path = record.syntax().children().find_map(ast::Path::cast)?;\n \n     let ranks = compute_fields_ranks(&path, &ctx)?;\n \n@@ -51,7 +42,7 @@ fn reorder<R: AstNode>(ctx: AssistCtx) -> Option<Assist> {\n     }\n \n     let target = record.syntax().text_range();\n-    ctx.add_assist(AssistId(\"reorder_fields\"), \"Reorder record fields\", target, |edit| {\n+    acc.add(AssistId(\"reorder_fields\"), \"Reorder record fields\", target, |edit| {\n         for (old, new) in fields.iter().zip(&sorted_fields) {\n             algo::diff(old, new).into_text_edit(edit.text_edit_builder());\n         }\n@@ -96,9 +87,9 @@ fn struct_definition(path: &ast::Path, sema: &Semantics<RootDatabase>) -> Option\n     }\n }\n \n-fn compute_fields_ranks(path: &Path, ctx: &AssistCtx) -> Option<HashMap<String, usize>> {\n+fn compute_fields_ranks(path: &ast::Path, ctx: &AssistContext) -> Option<HashMap<String, usize>> {\n     Some(\n-        struct_definition(path, ctx.sema)?\n+        struct_definition(path, &ctx.sema)?\n             .fields(ctx.db)\n             .iter()\n             .enumerate()"}, {"sha": "a59a06efa545abdbbf7c2f4493c0dc2c1c9985ad", "filename": "crates/ra_assists/src/handlers/replace_if_let_with_match.rs", "status": "modified", "additions": 23, "deletions": 28, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -4,7 +4,7 @@ use ra_syntax::{\n     AstNode,\n };\n \n-use crate::{utils::TryEnum, Assist, AssistCtx, AssistId};\n+use crate::{utils::TryEnum, AssistContext, AssistId, Assists};\n \n // Assist: replace_if_let_with_match\n //\n@@ -32,7 +32,7 @@ use crate::{utils::TryEnum, Assist, AssistCtx, AssistId};\n //     }\n // }\n // ```\n-pub(crate) fn replace_if_let_with_match(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn replace_if_let_with_match(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let if_expr: ast::IfExpr = ctx.find_node_at_offset()?;\n     let cond = if_expr.condition()?;\n     let pat = cond.pat()?;\n@@ -43,36 +43,31 @@ pub(crate) fn replace_if_let_with_match(ctx: AssistCtx) -> Option<Assist> {\n         ast::ElseBranch::IfExpr(_) => return None,\n     };\n \n-    let sema = ctx.sema;\n     let target = if_expr.syntax().text_range();\n-    ctx.add_assist(\n-        AssistId(\"replace_if_let_with_match\"),\n-        \"Replace with match\",\n-        target,\n-        move |edit| {\n-            let match_expr = {\n-                let then_arm = {\n-                    let then_expr = unwrap_trivial_block(then_block);\n-                    make::match_arm(vec![pat.clone()], then_expr)\n-                };\n-                let else_arm = {\n-                    let pattern = sema\n-                        .type_of_pat(&pat)\n-                        .and_then(|ty| TryEnum::from_ty(sema, &ty))\n-                        .map(|it| it.sad_pattern())\n-                        .unwrap_or_else(|| make::placeholder_pat().into());\n-                    let else_expr = unwrap_trivial_block(else_block);\n-                    make::match_arm(vec![pattern], else_expr)\n-                };\n-                make::expr_match(expr, make::match_arm_list(vec![then_arm, else_arm]))\n+    acc.add(AssistId(\"replace_if_let_with_match\"), \"Replace with match\", target, move |edit| {\n+        let match_expr = {\n+            let then_arm = {\n+                let then_expr = unwrap_trivial_block(then_block);\n+                make::match_arm(vec![pat.clone()], then_expr)\n             };\n+            let else_arm = {\n+                let pattern = ctx\n+                    .sema\n+                    .type_of_pat(&pat)\n+                    .and_then(|ty| TryEnum::from_ty(&ctx.sema, &ty))\n+                    .map(|it| it.sad_pattern())\n+                    .unwrap_or_else(|| make::placeholder_pat().into());\n+                let else_expr = unwrap_trivial_block(else_block);\n+                make::match_arm(vec![pattern], else_expr)\n+            };\n+            make::expr_match(expr, make::match_arm_list(vec![then_arm, else_arm]))\n+        };\n \n-            let match_expr = IndentLevel::from_node(if_expr.syntax()).increase_indent(match_expr);\n+        let match_expr = IndentLevel::from_node(if_expr.syntax()).increase_indent(match_expr);\n \n-            edit.set_cursor(if_expr.syntax().text_range().start());\n-            edit.replace_ast::<ast::Expr>(if_expr.into(), match_expr);\n-        },\n-    )\n+        edit.set_cursor(if_expr.syntax().text_range().start());\n+        edit.replace_ast::<ast::Expr>(if_expr.into(), match_expr);\n+    })\n }\n \n #[cfg(test)]"}, {"sha": "d3f214591af058404a1ec60d482a8276da060cef", "filename": "crates/ra_assists/src/handlers/replace_let_with_if_let.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_let_with_if_let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_let_with_if_let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_let_with_if_let.rs?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -9,11 +9,7 @@ use ra_syntax::{\n     AstNode, T,\n };\n \n-use crate::{\n-    assist_ctx::{Assist, AssistCtx},\n-    utils::TryEnum,\n-    AssistId,\n-};\n+use crate::{utils::TryEnum, AssistContext, AssistId, Assists};\n \n // Assist: replace_let_with_if_let\n //\n@@ -39,16 +35,16 @@ use crate::{\n //\n // fn compute() -> Option<i32> { None }\n // ```\n-pub(crate) fn replace_let_with_if_let(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn replace_let_with_if_let(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let let_kw = ctx.find_token_at_offset(T![let])?;\n     let let_stmt = let_kw.ancestors().find_map(ast::LetStmt::cast)?;\n     let init = let_stmt.initializer()?;\n     let original_pat = let_stmt.pat()?;\n     let ty = ctx.sema.type_of_expr(&init)?;\n-    let happy_variant = TryEnum::from_ty(ctx.sema, &ty).map(|it| it.happy_case());\n+    let happy_variant = TryEnum::from_ty(&ctx.sema, &ty).map(|it| it.happy_case());\n \n     let target = let_kw.text_range();\n-    ctx.add_assist(AssistId(\"replace_let_with_if_let\"), \"Replace with if-let\", target, |edit| {\n+    acc.add(AssistId(\"replace_let_with_if_let\"), \"Replace with if-let\", target, |edit| {\n         let with_placeholder: ast::Pat = match happy_variant {\n             None => make::placeholder_pat().into(),\n             Some(var_name) => make::tuple_struct_pat("}, {"sha": "1a81d8a0e0215ce3881642e44c21b5709e707dd8", "filename": "crates/ra_assists/src/handlers/replace_qualified_name_with_use.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -1,11 +1,7 @@\n use hir;\n use ra_syntax::{ast, AstNode, SmolStr, TextRange};\n \n-use crate::{\n-    assist_ctx::{Assist, AssistCtx},\n-    utils::insert_use_statement,\n-    AssistId,\n-};\n+use crate::{utils::insert_use_statement, AssistContext, AssistId, Assists};\n \n // Assist: replace_qualified_name_with_use\n //\n@@ -20,7 +16,10 @@ use crate::{\n //\n // fn process(map: HashMap<String, String>) {}\n // ```\n-pub(crate) fn replace_qualified_name_with_use(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn replace_qualified_name_with_use(\n+    acc: &mut Assists,\n+    ctx: &AssistContext,\n+) -> Option<()> {\n     let path: ast::Path = ctx.find_node_at_offset()?;\n     // We don't want to mess with use statements\n     if path.syntax().ancestors().find_map(ast::UseItem::cast).is_some() {\n@@ -34,18 +33,18 @@ pub(crate) fn replace_qualified_name_with_use(ctx: AssistCtx) -> Option<Assist>\n     }\n \n     let target = path.syntax().text_range();\n-    ctx.add_assist(\n+    acc.add(\n         AssistId(\"replace_qualified_name_with_use\"),\n         \"Replace qualified path with use\",\n         target,\n-        |edit| {\n+        |builder| {\n             let path_to_import = hir_path.mod_path().clone();\n-            insert_use_statement(path.syntax(), &path_to_import, edit);\n+            insert_use_statement(path.syntax(), &path_to_import, ctx, builder);\n \n             if let Some(last) = path.segment() {\n                 // Here we are assuming the assist will provide a correct use statement\n                 // so we can delete the path qualifier\n-                edit.delete(TextRange::new(\n+                builder.delete(TextRange::new(\n                     path.syntax().text_range().start(),\n                     last.syntax().text_range().start(),\n                 ));"}, {"sha": "a46998b8eb09f11e154b3e53c4639c10052b0f2e", "filename": "crates/ra_assists/src/handlers/replace_unwrap_with_match.rs", "status": "modified", "additions": 17, "deletions": 24, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_unwrap_with_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_unwrap_with_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_unwrap_with_match.rs?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -5,7 +5,7 @@ use ra_syntax::{\n     AstNode,\n };\n \n-use crate::{utils::TryEnum, Assist, AssistCtx, AssistId};\n+use crate::{utils::TryEnum, AssistContext, AssistId, Assists};\n \n // Assist: replace_unwrap_with_match\n //\n@@ -29,41 +29,34 @@ use crate::{utils::TryEnum, Assist, AssistCtx, AssistId};\n //     };\n // }\n // ```\n-pub(crate) fn replace_unwrap_with_match(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn replace_unwrap_with_match(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let method_call: ast::MethodCallExpr = ctx.find_node_at_offset()?;\n     let name = method_call.name_ref()?;\n     if name.text() != \"unwrap\" {\n         return None;\n     }\n     let caller = method_call.expr()?;\n     let ty = ctx.sema.type_of_expr(&caller)?;\n-    let happy_variant = TryEnum::from_ty(ctx.sema, &ty)?.happy_case();\n+    let happy_variant = TryEnum::from_ty(&ctx.sema, &ty)?.happy_case();\n     let target = method_call.syntax().text_range();\n-    ctx.add_assist(\n-        AssistId(\"replace_unwrap_with_match\"),\n-        \"Replace unwrap with match\",\n-        target,\n-        |edit| {\n-            let ok_path = make::path_unqualified(make::path_segment(make::name_ref(happy_variant)));\n-            let it = make::bind_pat(make::name(\"a\")).into();\n-            let ok_tuple = make::tuple_struct_pat(ok_path, iter::once(it)).into();\n+    acc.add(AssistId(\"replace_unwrap_with_match\"), \"Replace unwrap with match\", target, |edit| {\n+        let ok_path = make::path_unqualified(make::path_segment(make::name_ref(happy_variant)));\n+        let it = make::bind_pat(make::name(\"a\")).into();\n+        let ok_tuple = make::tuple_struct_pat(ok_path, iter::once(it)).into();\n \n-            let bind_path = make::path_unqualified(make::path_segment(make::name_ref(\"a\")));\n-            let ok_arm = make::match_arm(iter::once(ok_tuple), make::expr_path(bind_path));\n+        let bind_path = make::path_unqualified(make::path_segment(make::name_ref(\"a\")));\n+        let ok_arm = make::match_arm(iter::once(ok_tuple), make::expr_path(bind_path));\n \n-            let unreachable_call = make::unreachable_macro_call().into();\n-            let err_arm =\n-                make::match_arm(iter::once(make::placeholder_pat().into()), unreachable_call);\n+        let unreachable_call = make::unreachable_macro_call().into();\n+        let err_arm = make::match_arm(iter::once(make::placeholder_pat().into()), unreachable_call);\n \n-            let match_arm_list = make::match_arm_list(vec![ok_arm, err_arm]);\n-            let match_expr = make::expr_match(caller.clone(), match_arm_list);\n-            let match_expr =\n-                IndentLevel::from_node(method_call.syntax()).increase_indent(match_expr);\n+        let match_arm_list = make::match_arm_list(vec![ok_arm, err_arm]);\n+        let match_expr = make::expr_match(caller.clone(), match_arm_list);\n+        let match_expr = IndentLevel::from_node(method_call.syntax()).increase_indent(match_expr);\n \n-            edit.set_cursor(caller.syntax().text_range().start());\n-            edit.replace_ast::<ast::Expr>(method_call.into(), match_expr);\n-        },\n-    )\n+        edit.set_cursor(caller.syntax().text_range().start());\n+        edit.replace_ast::<ast::Expr>(method_call.into(), match_expr);\n+    })\n }\n \n #[cfg(test)]"}, {"sha": "b2757e50ce709ebe042ccf870eacd5300c43764e", "filename": "crates/ra_assists/src/handlers/split_import.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fsplit_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fsplit_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fsplit_import.rs?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -2,7 +2,7 @@ use std::iter::successors;\n \n use ra_syntax::{ast, AstNode, T};\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: split_import\n //\n@@ -15,7 +15,7 @@ use crate::{Assist, AssistCtx, AssistId};\n // ```\n // use std::{collections::HashMap};\n // ```\n-pub(crate) fn split_import(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn split_import(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let colon_colon = ctx.find_token_at_offset(T![::])?;\n     let path = ast::Path::cast(colon_colon.parent())?.qualifier()?;\n     let top_path = successors(Some(path.clone()), |it| it.parent_path()).last()?;\n@@ -26,10 +26,10 @@ pub(crate) fn split_import(ctx: AssistCtx) -> Option<Assist> {\n     if new_tree == use_tree {\n         return None;\n     }\n-    let cursor = ctx.frange.range.start();\n+    let cursor = ctx.offset();\n \n     let target = colon_colon.text_range();\n-    ctx.add_assist(AssistId(\"split_import\"), \"Split import\", target, |edit| {\n+    acc.add(AssistId(\"split_import\"), \"Split import\", target, |edit| {\n         edit.replace_ast(use_tree, new_tree);\n         edit.set_cursor(cursor);\n     })"}, {"sha": "eba0631a4c242c9a0d9544162a79774f60e49ef6", "filename": "crates/ra_assists/src/handlers/unwrap_block.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Funwrap_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Fhandlers%2Funwrap_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Funwrap_block.rs?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -1,4 +1,4 @@\n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{AssistContext, AssistId, Assists};\n \n use ast::LoopBodyOwner;\n use ra_fmt::unwrap_trivial_block;\n@@ -21,7 +21,7 @@ use ra_syntax::{ast, match_ast, AstNode, TextRange, T};\n //     println!(\"foo\");\n // }\n // ```\n-pub(crate) fn unwrap_block(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn unwrap_block(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let l_curly_token = ctx.find_token_at_offset(T!['{'])?;\n     let block = ast::BlockExpr::cast(l_curly_token.parent())?;\n     let parent = block.syntax().parent()?;\n@@ -58,7 +58,7 @@ pub(crate) fn unwrap_block(ctx: AssistCtx) -> Option<Assist> {\n     };\n \n     let target = expr_to_unwrap.syntax().text_range();\n-    ctx.add_assist(AssistId(\"unwrap_block\"), \"Unwrap block\", target, |edit| {\n+    acc.add(AssistId(\"unwrap_block\"), \"Unwrap block\", target, |edit| {\n         edit.set_cursor(expr.syntax().text_range().start());\n \n         let pat_start: &[_] = &[' ', '{', '\\n'];"}, {"sha": "b6dc7cb1bfc10166be3900ddfbd4ac9757409d2f", "filename": "crates/ra_assists/src/lib.rs", "status": "modified", "additions": 51, "deletions": 73, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Flib.rs?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -10,28 +10,30 @@ macro_rules! eprintln {\n     ($($tt:tt)*) => { stdx::eprintln!($($tt)*) };\n }\n \n-mod assist_ctx;\n+mod assist_context;\n mod marks;\n #[cfg(test)]\n mod tests;\n pub mod utils;\n pub mod ast_transform;\n \n use hir::Semantics;\n-use ra_db::{FileId, FileRange};\n-use ra_ide_db::RootDatabase;\n-use ra_syntax::{TextRange, TextSize};\n-use ra_text_edit::TextEdit;\n+use ra_db::FileRange;\n+use ra_ide_db::{source_change::SourceChange, RootDatabase};\n+use ra_syntax::TextRange;\n \n-pub(crate) use crate::assist_ctx::{Assist, AssistCtx};\n+pub(crate) use crate::assist_context::{AssistContext, Assists};\n \n /// Unique identifier of the assist, should not be shown to the user\n /// directly.\n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n pub struct AssistId(pub &'static str);\n \n+#[derive(Clone, Debug)]\n+pub struct GroupLabel(pub String);\n+\n #[derive(Debug, Clone)]\n-pub struct AssistLabel {\n+pub struct Assist {\n     pub id: AssistId,\n     /// Short description of the assist, as shown in the UI.\n     pub label: String,\n@@ -41,93 +43,69 @@ pub struct AssistLabel {\n     pub target: TextRange,\n }\n \n-#[derive(Clone, Debug)]\n-pub struct GroupLabel(pub String);\n+#[derive(Debug, Clone)]\n+pub struct ResolvedAssist {\n+    pub assist: Assist,\n+    pub source_change: SourceChange,\n+}\n+\n+impl Assist {\n+    /// Return all the assists applicable at the given position.\n+    ///\n+    /// Assists are returned in the \"unresolved\" state, that is only labels are\n+    /// returned, without actual edits.\n+    pub fn unresolved(db: &RootDatabase, range: FileRange) -> Vec<Assist> {\n+        let sema = Semantics::new(db);\n+        let ctx = AssistContext::new(sema, range);\n+        let mut acc = Assists::new_unresolved(&ctx);\n+        handlers::all().iter().for_each(|handler| {\n+            handler(&mut acc, &ctx);\n+        });\n+        acc.finish_unresolved()\n+    }\n+\n+    /// Return all the assists applicable at the given position.\n+    ///\n+    /// Assists are returned in the \"resolved\" state, that is with edit fully\n+    /// computed.\n+    pub fn resolved(db: &RootDatabase, range: FileRange) -> Vec<ResolvedAssist> {\n+        let sema = Semantics::new(db);\n+        let ctx = AssistContext::new(sema, range);\n+        let mut acc = Assists::new_resolved(&ctx);\n+        handlers::all().iter().for_each(|handler| {\n+            handler(&mut acc, &ctx);\n+        });\n+        acc.finish_resolved()\n+    }\n \n-impl AssistLabel {\n     pub(crate) fn new(\n         id: AssistId,\n         label: String,\n         group: Option<GroupLabel>,\n         target: TextRange,\n-    ) -> AssistLabel {\n+    ) -> Assist {\n         // FIXME: make fields private, so that this invariant can't be broken\n         assert!(label.starts_with(|c: char| c.is_uppercase()));\n-        AssistLabel { id, label, group, target }\n-    }\n-}\n-\n-#[derive(Debug, Clone)]\n-pub struct AssistAction {\n-    pub edit: TextEdit,\n-    pub cursor_position: Option<TextSize>,\n-    pub file: AssistFile,\n-}\n-\n-#[derive(Debug, Clone)]\n-pub struct ResolvedAssist {\n-    pub label: AssistLabel,\n-    pub action: AssistAction,\n-}\n-\n-#[derive(Debug, Clone, Copy)]\n-pub enum AssistFile {\n-    CurrentFile,\n-    TargetFile(FileId),\n-}\n-\n-impl Default for AssistFile {\n-    fn default() -> Self {\n-        Self::CurrentFile\n+        Assist { id, label, group, target }\n     }\n }\n \n-/// Return all the assists applicable at the given position.\n-///\n-/// Assists are returned in the \"unresolved\" state, that is only labels are\n-/// returned, without actual edits.\n-pub fn unresolved_assists(db: &RootDatabase, range: FileRange) -> Vec<AssistLabel> {\n-    let sema = Semantics::new(db);\n-    let ctx = AssistCtx::new(&sema, range, false);\n-    handlers::all()\n-        .iter()\n-        .filter_map(|f| f(ctx.clone()))\n-        .flat_map(|it| it.0)\n-        .map(|a| a.label)\n-        .collect()\n-}\n-\n-/// Return all the assists applicable at the given position.\n-///\n-/// Assists are returned in the \"resolved\" state, that is with edit fully\n-/// computed.\n-pub fn resolved_assists(db: &RootDatabase, range: FileRange) -> Vec<ResolvedAssist> {\n-    let sema = Semantics::new(db);\n-    let ctx = AssistCtx::new(&sema, range, true);\n-    let mut a = handlers::all()\n-        .iter()\n-        .filter_map(|f| f(ctx.clone()))\n-        .flat_map(|it| it.0)\n-        .map(|it| it.into_resolved().unwrap())\n-        .collect::<Vec<_>>();\n-    a.sort_by_key(|it| it.label.target.len());\n-    a\n-}\n-\n mod handlers {\n-    use crate::{Assist, AssistCtx};\n+    use crate::{AssistContext, Assists};\n \n-    pub(crate) type Handler = fn(AssistCtx) -> Option<Assist>;\n+    pub(crate) type Handler = fn(&mut Assists, &AssistContext) -> Option<()>;\n \n     mod add_custom_impl;\n     mod add_derive;\n     mod add_explicit_type;\n+    mod add_from_impl_for_enum;\n     mod add_function;\n     mod add_impl;\n     mod add_missing_impl_members;\n     mod add_new;\n     mod apply_demorgan;\n     mod auto_import;\n+    mod change_return_type_to_result;\n     mod change_visibility;\n     mod early_return;\n     mod fill_match_arms;\n@@ -144,13 +122,12 @@ mod handlers {\n     mod raw_string;\n     mod remove_dbg;\n     mod remove_mut;\n+    mod reorder_fields;\n     mod replace_if_let_with_match;\n     mod replace_let_with_if_let;\n     mod replace_qualified_name_with_use;\n     mod replace_unwrap_with_match;\n     mod split_import;\n-    mod add_from_impl_for_enum;\n-    mod reorder_fields;\n     mod unwrap_block;\n \n     pub(crate) fn all() -> &'static [Handler] {\n@@ -165,6 +142,7 @@ mod handlers {\n             add_new::add_new,\n             apply_demorgan::apply_demorgan,\n             auto_import::auto_import,\n+            change_return_type_to_result::change_return_type_to_result,\n             change_visibility::change_visibility,\n             early_return::convert_to_guarded_return,\n             fill_match_arms::fill_match_arms,"}, {"sha": "a3eacb8f11540897e8cda3208325b25710059408", "filename": "crates/ra_assists/src/tests.rs", "status": "modified", "additions": 28, "deletions": 27, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Ftests.rs?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -11,7 +11,7 @@ use test_utils::{\n     RangeOrOffset,\n };\n \n-use crate::{handlers::Handler, resolved_assists, AssistCtx, AssistFile};\n+use crate::{handlers::Handler, Assist, AssistContext, Assists};\n \n pub(crate) fn with_single_file(text: &str) -> (RootDatabase, FileId) {\n     let (mut db, file_id) = RootDatabase::with_single_file(text);\n@@ -41,24 +41,25 @@ fn check_doc_test(assist_id: &str, before: &str, after: &str) {\n     let (db, file_id) = crate::tests::with_single_file(&before);\n     let frange = FileRange { file_id, range: selection.into() };\n \n-    let assist = resolved_assists(&db, frange)\n+    let mut assist = Assist::resolved(&db, frange)\n         .into_iter()\n-        .find(|assist| assist.label.id.0 == assist_id)\n+        .find(|assist| assist.assist.id.0 == assist_id)\n         .unwrap_or_else(|| {\n             panic!(\n                 \"\\n\\nAssist is not applicable: {}\\nAvailable assists: {}\",\n                 assist_id,\n-                resolved_assists(&db, frange)\n+                Assist::resolved(&db, frange)\n                     .into_iter()\n-                    .map(|assist| assist.label.id.0)\n+                    .map(|assist| assist.assist.id.0)\n                     .collect::<Vec<_>>()\n                     .join(\", \")\n             )\n         });\n \n     let actual = {\n+        let change = assist.source_change.source_file_edits.pop().unwrap();\n         let mut actual = before.clone();\n-        assist.action.edit.apply(&mut actual);\n+        change.edit.apply(&mut actual);\n         actual\n     };\n     assert_eq_text!(after, &actual);\n@@ -70,7 +71,7 @@ enum ExpectedResult<'a> {\n     Target(&'a str),\n }\n \n-fn check(assist: Handler, before: &str, expected: ExpectedResult) {\n+fn check(handler: Handler, before: &str, expected: ExpectedResult) {\n     let (text_without_caret, file_with_caret_id, range_or_offset, db) = if before.contains(\"//-\") {\n         let (mut db, position) = RootDatabase::with_position(before);\n         db.set_local_roots(Arc::new(vec![db.file_source_root(position.file_id)]));\n@@ -89,36 +90,36 @@ fn check(assist: Handler, before: &str, expected: ExpectedResult) {\n     let frange = FileRange { file_id: file_with_caret_id, range: range_or_offset.into() };\n \n     let sema = Semantics::new(&db);\n-    let assist_ctx = AssistCtx::new(&sema, frange, true);\n-\n-    match (assist(assist_ctx), expected) {\n+    let ctx = AssistContext::new(sema, frange);\n+    let mut acc = Assists::new_resolved(&ctx);\n+    handler(&mut acc, &ctx);\n+    let mut res = acc.finish_resolved();\n+    let assist = res.pop();\n+    match (assist, expected) {\n         (Some(assist), ExpectedResult::After(after)) => {\n-            let action = assist.0[0].action.clone().unwrap();\n+            let mut source_change = assist.source_change;\n+            let change = source_change.source_file_edits.pop().unwrap();\n \n-            let mut actual = if let AssistFile::TargetFile(file_id) = action.file {\n-                db.file_text(file_id).as_ref().to_owned()\n-            } else {\n-                text_without_caret\n-            };\n-            action.edit.apply(&mut actual);\n+            let mut actual = db.file_text(change.file_id).as_ref().to_owned();\n+            change.edit.apply(&mut actual);\n \n-            match action.cursor_position {\n+            match source_change.cursor_position {\n                 None => {\n                     if let RangeOrOffset::Offset(before_cursor_pos) = range_or_offset {\n-                        let off = action\n+                        let off = change\n                             .edit\n                             .apply_to_offset(before_cursor_pos)\n                             .expect(\"cursor position is affected by the edit\");\n                         actual = add_cursor(&actual, off)\n                     }\n                 }\n-                Some(off) => actual = add_cursor(&actual, off),\n+                Some(off) => actual = add_cursor(&actual, off.offset),\n             };\n \n             assert_eq_text!(after, &actual);\n         }\n         (Some(assist), ExpectedResult::Target(target)) => {\n-            let range = assist.0[0].label.target;\n+            let range = assist.assist.target;\n             assert_eq_text!(&text_without_caret[range], target);\n         }\n         (Some(_), ExpectedResult::NotApplicable) => panic!(\"assist should not be applicable!\"),\n@@ -135,14 +136,14 @@ fn assist_order_field_struct() {\n     let (before_cursor_pos, before) = extract_offset(before);\n     let (db, file_id) = with_single_file(&before);\n     let frange = FileRange { file_id, range: TextRange::empty(before_cursor_pos) };\n-    let assists = resolved_assists(&db, frange);\n+    let assists = Assist::resolved(&db, frange);\n     let mut assists = assists.iter();\n \n     assert_eq!(\n-        assists.next().expect(\"expected assist\").label.label,\n+        assists.next().expect(\"expected assist\").assist.label,\n         \"Change visibility to pub(crate)\"\n     );\n-    assert_eq!(assists.next().expect(\"expected assist\").label.label, \"Add `#[derive]`\");\n+    assert_eq!(assists.next().expect(\"expected assist\").assist.label, \"Add `#[derive]`\");\n }\n \n #[test]\n@@ -158,9 +159,9 @@ fn assist_order_if_expr() {\n     let (range, before) = extract_range(before);\n     let (db, file_id) = with_single_file(&before);\n     let frange = FileRange { file_id, range };\n-    let assists = resolved_assists(&db, frange);\n+    let assists = Assist::resolved(&db, frange);\n     let mut assists = assists.iter();\n \n-    assert_eq!(assists.next().expect(\"expected assist\").label.label, \"Extract into variable\");\n-    assert_eq!(assists.next().expect(\"expected assist\").label.label, \"Replace with match\");\n+    assert_eq!(assists.next().expect(\"expected assist\").assist.label, \"Extract into variable\");\n+    assert_eq!(assists.next().expect(\"expected assist\").assist.label, \"Replace with match\");\n }"}, {"sha": "972dbd251d6a8ebb05071f26b38799cb28ca028a", "filename": "crates/ra_assists/src/tests/generated.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -249,6 +249,19 @@ pub mod std { pub mod collections { pub struct HashMap { } } }\n     )\n }\n \n+#[test]\n+fn doctest_change_return_type_to_result() {\n+    check_doc_test(\n+        \"change_return_type_to_result\",\n+        r#####\"\n+fn foo() -> i32<|> { 42i32 }\n+\"#####,\n+        r#####\"\n+fn foo() -> Result<i32, > { Ok(42i32) }\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_change_visibility() {\n     check_doc_test("}, {"sha": "1214e3cd47a66492234e0ad9fc1572612f807b37", "filename": "crates/ra_assists/src/utils/insert_use.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Futils%2Finsert_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_assists%2Fsrc%2Futils%2Finsert_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Futils%2Finsert_use.rs?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -2,7 +2,6 @@\n // FIXME: rewrite according to the plan, outlined in\n // https://github.com/rust-analyzer/rust-analyzer/issues/3301#issuecomment-592931553\n \n-use crate::assist_ctx::ActionBuilder;\n use hir::{self, ModPath};\n use ra_syntax::{\n     ast::{self, NameOwner},\n@@ -12,17 +11,20 @@ use ra_syntax::{\n };\n use ra_text_edit::TextEditBuilder;\n \n+use crate::assist_context::{AssistBuilder, AssistContext};\n+\n /// Creates and inserts a use statement for the given path to import.\n /// The use statement is inserted in the scope most appropriate to the\n /// the cursor position given, additionally merged with the existing use imports.\n pub(crate) fn insert_use_statement(\n     // Ideally the position of the cursor, used to\n     position: &SyntaxNode,\n     path_to_import: &ModPath,\n-    edit: &mut ActionBuilder,\n+    ctx: &AssistContext,\n+    builder: &mut AssistBuilder,\n ) {\n     let target = path_to_import.to_string().split(\"::\").map(SmolStr::new).collect::<Vec<_>>();\n-    let container = edit.ctx().sema.ancestors_with_macros(position.clone()).find_map(|n| {\n+    let container = ctx.sema.ancestors_with_macros(position.clone()).find_map(|n| {\n         if let Some(module) = ast::Module::cast(n.clone()) {\n             return module.item_list().map(|it| it.syntax().clone());\n         }\n@@ -31,7 +33,7 @@ pub(crate) fn insert_use_statement(\n \n     if let Some(container) = container {\n         let action = best_action_for_target(container, position.clone(), &target);\n-        make_assist(&action, &target, edit.text_edit_builder());\n+        make_assist(&action, &target, builder.text_edit_builder());\n     }\n }\n "}, {"sha": "57feabcb27cb57e981aa2898113716ff94cdb971", "filename": "crates/ra_cfg/src/lib.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_cfg%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_cfg%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cfg%2Fsrc%2Flib.rs?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -2,8 +2,6 @@\n \n mod cfg_expr;\n \n-use std::iter::IntoIterator;\n-\n use ra_syntax::SmolStr;\n use rustc_hash::FxHashSet;\n \n@@ -48,9 +46,4 @@ impl CfgOptions {\n     pub fn insert_key_value(&mut self, key: SmolStr, value: SmolStr) {\n         self.key_values.insert((key, value));\n     }\n-\n-    /// Shortcut to set features\n-    pub fn insert_features(&mut self, iter: impl IntoIterator<Item = SmolStr>) {\n-        iter.into_iter().for_each(|feat| self.insert_key_value(\"feature\".into(), feat));\n-    }\n }"}, {"sha": "51d4c493e3ed9b76e0071aac49d23a317b6b13d1", "filename": "crates/ra_db/src/fixture.rs", "status": "modified", "additions": 45, "deletions": 1, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_db%2Fsrc%2Ffixture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_db%2Fsrc%2Ffixture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Ffixture.rs?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -1,4 +1,48 @@\n-//! FIXME: write short doc here\n+//! Fixtures are strings containing rust source code with optional metadata.\n+//! A fixture without metadata is parsed into a single source file.\n+//! Use this to test functionality local to one file.\n+//!\n+//! Example:\n+//! ```\n+//! r#\"\n+//! fn main() {\n+//!     println!(\"Hello World\")\n+//! }\n+//! \"#\n+//! ```\n+//!\n+//! Metadata can be added to a fixture after a `//-` comment.\n+//! The basic form is specifying filenames,\n+//! which is also how to define multiple files in a single test fixture\n+//!\n+//! Example:\n+//! ```\n+//! \"\n+//! //- /main.rs\n+//! mod foo;\n+//! fn main() {\n+//!     foo::bar();\n+//! }\n+//!\n+//! //- /foo.rs\n+//! pub fn bar() {}\n+//! \"\n+//! ```\n+//!\n+//! Metadata allows specifying all settings and variables\n+//! that are available in a real rust project:\n+//! - crate names via `crate:cratename`\n+//! - dependencies via `deps:dep1,dep2`\n+//! - configuration settings via `cfg:dbg=false,opt_level=2`\n+//! - environment variables via `env:PATH=/bin,RUST_LOG=debug`\n+//!\n+//! Example:\n+//! ```\n+//! \"\n+//! //- /lib.rs crate:foo deps:bar,baz cfg:foo=a,bar=b env:OUTDIR=path/to,OTHER=foo\n+//! fn insert_source_code_here() {}\n+//! \"\n+//! ```\n \n use std::str::FromStr;\n use std::sync::Arc;"}, {"sha": "03e55714844b1bacc82da7a37c7c80633e3367e4", "filename": "crates/ra_flycheck/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_flycheck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_flycheck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_flycheck%2FCargo.toml?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -14,6 +14,7 @@ log = \"0.4.8\"\n cargo_metadata = \"0.9.1\"\n serde_json = \"1.0.48\"\n jod-thread = \"0.1.1\"\n+ra_toolchain = { path = \"../ra_toolchain\" }\n \n [dev-dependencies]\n insta = \"0.16.0\""}, {"sha": "68dcee2851d3191d08ddac39b0eb365f4f946a50", "filename": "crates/ra_flycheck/src/lib.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_flycheck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_flycheck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_flycheck%2Fsrc%2Flib.rs?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -4,7 +4,6 @@\n mod conv;\n \n use std::{\n-    env,\n     io::{self, BufRead, BufReader},\n     path::PathBuf,\n     process::{Command, Stdio},\n@@ -216,10 +215,10 @@ impl FlycheckThread {\n \n         let mut cmd = match &self.config {\n             FlycheckConfig::CargoCommand { command, all_targets, all_features, extra_args } => {\n-                let mut cmd = Command::new(cargo_binary());\n+                let mut cmd = Command::new(ra_toolchain::cargo());\n                 cmd.arg(command);\n-                cmd.args(&[\"--workspace\", \"--message-format=json\", \"--manifest-path\"]);\n-                cmd.arg(self.workspace_root.join(\"Cargo.toml\"));\n+                cmd.args(&[\"--workspace\", \"--message-format=json\", \"--manifest-path\"])\n+                    .arg(self.workspace_root.join(\"Cargo.toml\"));\n                 if *all_targets {\n                     cmd.arg(\"--all-targets\");\n                 }\n@@ -337,7 +336,3 @@ fn run_cargo(\n \n     Ok(())\n }\n-\n-fn cargo_binary() -> String {\n-    env::var(\"CARGO\").unwrap_or_else(|_| \"cargo\".to_string())\n-}"}, {"sha": "149f6504241e4a4f502cfca61544199b611783b7", "filename": "crates/ra_hir_ty/src/_match.rs", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_hir_ty%2Fsrc%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_hir_ty%2Fsrc%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2F_match.rs?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -573,14 +573,20 @@ pub(crate) fn is_useful(\n     matrix: &Matrix,\n     v: &PatStack,\n ) -> MatchCheckResult<Usefulness> {\n-    // Handle the special case of enums with no variants. In that case, no match\n-    // arm is useful.\n-    if let Ty::Apply(ApplicationTy { ctor: TypeCtor::Adt(AdtId::EnumId(enum_id)), .. }) =\n-        cx.infer[cx.match_expr].strip_references()\n-    {\n-        if cx.db.enum_data(*enum_id).variants.is_empty() {\n+    // Handle two special cases:\n+    // - enum with no variants\n+    // - `!` type\n+    // In those cases, no match arm is useful.\n+    match cx.infer[cx.match_expr].strip_references() {\n+        Ty::Apply(ApplicationTy { ctor: TypeCtor::Adt(AdtId::EnumId(enum_id)), .. }) => {\n+            if cx.db.enum_data(*enum_id).variants.is_empty() {\n+                return Ok(Usefulness::NotUseful);\n+            }\n+        }\n+        Ty::Apply(ApplicationTy { ctor: TypeCtor::Never, .. }) => {\n             return Ok(Usefulness::NotUseful);\n         }\n+        _ => (),\n     }\n \n     if v.is_empty() {\n@@ -1917,6 +1923,17 @@ mod tests {\n         check_no_diagnostic(content);\n     }\n \n+    #[test]\n+    fn type_never() {\n+        let content = r\"\n+            fn test_fn(never: !) {\n+                match never {}\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n     #[test]\n     fn enum_never_ref() {\n         let content = r\""}, {"sha": "614c352a0c3623f87346fd005c196647a48d7d27", "filename": "crates/ra_hir_ty/src/infer/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -501,8 +501,8 @@ impl<'a> InferenceContext<'a> {\n                 }\n                 Literal::ByteString(..) => {\n                     let byte_type = Ty::simple(TypeCtor::Int(Uncertain::Known(IntTy::u8())));\n-                    let slice_type = Ty::apply_one(TypeCtor::Slice, byte_type);\n-                    Ty::apply_one(TypeCtor::Ref(Mutability::Shared), slice_type)\n+                    let array_type = Ty::apply_one(TypeCtor::Array, byte_type);\n+                    Ty::apply_one(TypeCtor::Ref(Mutability::Shared), array_type)\n                 }\n                 Literal::Char(..) => Ty::simple(TypeCtor::Char),\n                 Literal::Int(_v, ty) => Ty::simple(TypeCtor::Int((*ty).into())),"}, {"sha": "67f964ab5d7ac5a32b72eace4bff90be286ff039", "filename": "crates/ra_hir_ty/src/tests/method_resolution.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -17,19 +17,20 @@ impl<T> [T] {\n #[lang = \"slice_alloc\"]\n impl<T> [T] {}\n \n-fn test() {\n-    <[_]>::foo(b\"foo\");\n+fn test(x: &[u8]) {\n+    <[_]>::foo(x);\n }\n \"#),\n         @r###\"\n     45..49 'self': &[T]\n     56..79 '{     ...     }': T\n     66..73 'loop {}': !\n     71..73 '{}': ()\n-    133..160 '{     ...o\"); }': ()\n-    139..149 '<[_]>::foo': fn foo<u8>(&[u8]) -> u8\n-    139..157 '<[_]>:...\"foo\")': u8\n-    150..156 'b\"foo\"': &[u8]\n+    131..132 'x': &[u8]\n+    141..163 '{     ...(x); }': ()\n+    147..157 '<[_]>::foo': fn foo<u8>(&[u8]) -> u8\n+    147..160 '<[_]>::foo(x)': u8\n+    158..159 'x': &[u8]\n     \"###\n     );\n }"}, {"sha": "e17a179004cd334b8044e717f720351521ccad05", "filename": "crates/ra_hir_ty/src/tests/simple.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fsimple.rs?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -414,15 +414,15 @@ fn test() {\n     27..31 '5f32': f32\n     37..41 '5f64': f64\n     47..54 '\"hello\"': &str\n-    60..68 'b\"bytes\"': &[u8]\n+    60..68 'b\"bytes\"': &[u8; _]\n     74..77 ''c'': char\n     83..87 'b'b'': u8\n     93..97 '3.14': f64\n     103..107 '5000': i32\n     113..118 'false': bool\n     124..128 'true': bool\n     134..202 'r#\"   ...    \"#': &str\n-    208..218 'br#\"yolo\"#': &[u8]\n+    208..218 'br#\"yolo\"#': &[u8; _]\n     \"###\n     );\n }"}, {"sha": "389339a03446d0da16a4bb940373c6f186e22673", "filename": "crates/ra_ide/src/assists.rs", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/1be6320ea6cf7830195f80681fa0f43cc340da7e/crates%2Fra_ide%2Fsrc%2Fassists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be6320ea6cf7830195f80681fa0f43cc340da7e/crates%2Fra_ide%2Fsrc%2Fassists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fassists.rs?ref=1be6320ea6cf7830195f80681fa0f43cc340da7e", "patch": "@@ -1,42 +0,0 @@\n-//! FIXME: write short doc here\n-\n-use ra_assists::{resolved_assists, AssistAction};\n-use ra_db::{FilePosition, FileRange};\n-use ra_ide_db::RootDatabase;\n-\n-use crate::{FileId, SourceChange, SourceFileEdit};\n-\n-pub use ra_assists::AssistId;\n-\n-#[derive(Debug)]\n-pub struct Assist {\n-    pub id: AssistId,\n-    pub label: String,\n-    pub group_label: Option<String>,\n-    pub source_change: SourceChange,\n-}\n-\n-pub(crate) fn assists(db: &RootDatabase, frange: FileRange) -> Vec<Assist> {\n-    resolved_assists(db, frange)\n-        .into_iter()\n-        .map(|assist| {\n-            let file_id = frange.file_id;\n-            Assist {\n-                id: assist.label.id,\n-                label: assist.label.label.clone(),\n-                group_label: assist.label.group.map(|it| it.0),\n-                source_change: action_to_edit(assist.action, file_id, assist.label.label.clone()),\n-            }\n-        })\n-        .collect()\n-}\n-\n-fn action_to_edit(action: AssistAction, file_id: FileId, label: String) -> SourceChange {\n-    let file_id = match action.file {\n-        ra_assists::AssistFile::TargetFile(it) => it,\n-        _ => file_id,\n-    };\n-    let file_edit = SourceFileEdit { file_id, edit: action.edit };\n-    SourceChange::source_file_edit(label, file_edit)\n-        .with_cursor_opt(action.cursor_position.map(|offset| FilePosition { offset, file_id }))\n-}"}, {"sha": "6021f7279f63ba45b0696a6610c9d02f7d535d53", "filename": "crates/ra_ide/src/completion/completion_item.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_item.rs?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -2,11 +2,12 @@\n \n use std::fmt;\n \n-use super::completion_config::SnippetCap;\n use hir::Documentation;\n use ra_syntax::TextRange;\n use ra_text_edit::TextEdit;\n \n+use crate::completion::completion_config::SnippetCap;\n+\n /// `CompletionItem` describes a single completion variant in the editor pop-up.\n /// It is basically a POD with various properties. To construct a\n /// `CompletionItem`, use `new` method and the `Builder` struct."}, {"sha": "f16d42276482f3e0ba181655d43f6206fa58f3ba", "filename": "crates/ra_ide/src/display/function_signature.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_ide%2Fsrc%2Fdisplay%2Ffunction_signature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_ide%2Fsrc%2Fdisplay%2Ffunction_signature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdisplay%2Ffunction_signature.rs?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -1,5 +1,7 @@\n //! FIXME: write short doc here\n \n+// FIXME: this modules relies on strings and AST way too much, and it should be\n+// rewritten (matklad 2020-05-07)\n use std::{\n     convert::From,\n     fmt::{self, Display},\n@@ -202,7 +204,11 @@ impl From<&'_ ast::FnDef> for FunctionSignature {\n \n                 res.extend(param_list.params().map(|param| param.syntax().text().to_string()));\n                 res_types.extend(param_list.params().map(|param| {\n-                    param.syntax().text().to_string().split(':').nth(1).unwrap()[1..].to_string()\n+                    let param_text = param.syntax().text().to_string();\n+                    match param_text.split(':').nth(1) {\n+                        Some(it) => it[1..].to_string(),\n+                        None => param_text,\n+                    }\n                 }));\n             }\n             (has_self_param, res, res_types)"}, {"sha": "06d4f1c6395dde57931a3b8c022f4d45bdcaf317", "filename": "crates/ra_ide/src/hover.rs", "status": "modified", "additions": 45, "deletions": 4, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_ide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_ide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fhover.rs?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -143,7 +143,7 @@ fn hover_text_from_name_kind(db: &RootDatabase, def: Definition) -> Option<Strin\n             ModuleDef::TypeAlias(it) => from_def_source(db, it, mod_path),\n             ModuleDef::BuiltinType(it) => Some(it.to_string()),\n         },\n-        Definition::Local(it) => Some(rust_code_markup(&it.ty(db).display_truncated(db, None))),\n+        Definition::Local(it) => Some(rust_code_markup(&it.ty(db).display(db))),\n         Definition::TypeParam(_) | Definition::SelfType(_) => {\n             // FIXME: Hover for generic param\n             None\n@@ -208,7 +208,7 @@ pub(crate) fn hover(db: &RootDatabase, position: FilePosition) -> Option<RangeIn\n         }\n     }?;\n \n-    res.extend(Some(rust_code_markup(&ty.display_truncated(db, None))));\n+    res.extend(Some(rust_code_markup(&ty.display(db))));\n     let range = sema.original_range(&node).range;\n     Some(RangeInfo::new(range, res))\n }\n@@ -279,6 +279,47 @@ mod tests {\n         assert_eq!(trim_markup_opt(hover.info.first()), Some(\"u32\"));\n     }\n \n+    #[test]\n+    fn hover_shows_long_type_of_an_expression() {\n+        check_hover_result(\n+            r#\"\n+            //- /main.rs\n+            struct Scan<A, B, C> {\n+                a: A,\n+                b: B,\n+                c: C,\n+            }\n+\n+            struct FakeIter<I> {\n+                inner: I,\n+            }\n+\n+            struct OtherStruct<T> {\n+                i: T,\n+            }\n+\n+            enum FakeOption<T> {\n+                Some(T),\n+                None,\n+            }\n+\n+            fn scan<A, B, C>(a: A, b: B, c: C) -> FakeIter<Scan<OtherStruct<A>, B, C>> {\n+                FakeIter { inner: Scan { a, b, c } }\n+            }\n+\n+            fn main() {\n+                let num: i32 = 55;\n+                let closure = |memo: &mut u32, value: &u32, _another: &mut u32| -> FakeOption<u32> {\n+                    FakeOption::Some(*memo + value)\n+                };\n+                let number = 5u32;\n+                let mut iter<|> = scan(OtherStruct { i: num }, closure, number);\n+            }\n+            \"#,\n+            &[\"FakeIter<Scan<OtherStruct<OtherStruct<i32>>, |&mut u32, &u32, &mut u32| -> FakeOption<u32>, u32>>\"],\n+        );\n+    }\n+\n     #[test]\n     fn hover_shows_fn_signature() {\n         // Single file with result\n@@ -405,7 +446,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn hover_omits_default_generic_types() {\n+    fn hover_default_generic_types() {\n         check_hover_result(\n             r#\"\n //- /main.rs\n@@ -417,7 +458,7 @@ struct Test<K, T = u8> {\n fn main() {\n     let zz<|> = Test { t: 23, k: 33 };\n }\"#,\n-            &[\"Test<i32>\"],\n+            &[\"Test<i32, u8>\"],\n         );\n     }\n "}, {"sha": "915199bd878ac07e5565036657f9b3c1cfea8e07", "filename": "crates/ra_ide/src/lib.rs", "status": "modified", "additions": 24, "deletions": 7, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_ide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_ide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Flib.rs?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -31,7 +31,6 @@ mod syntax_highlighting;\n mod parent_module;\n mod references;\n mod impls;\n-mod assists;\n mod diagnostics;\n mod syntax_tree;\n mod folding_ranges;\n@@ -64,7 +63,6 @@ use ra_syntax::{SourceFile, TextRange, TextSize};\n use crate::display::ToNav;\n \n pub use crate::{\n-    assists::{Assist, AssistId},\n     call_hierarchy::CallItem,\n     completion::{\n         CompletionConfig, CompletionItem, CompletionItemKind, CompletionScore, InsertTextFormat,\n@@ -84,6 +82,7 @@ pub use crate::{\n };\n \n pub use hir::Documentation;\n+pub use ra_assists::AssistId;\n pub use ra_db::{\n     Canceled, CrateGraph, CrateId, Edition, FileId, FilePosition, FileRange, SourceRootId,\n };\n@@ -134,10 +133,12 @@ pub struct AnalysisHost {\n     db: RootDatabase,\n }\n \n-impl Default for AnalysisHost {\n-    fn default() -> AnalysisHost {\n-        AnalysisHost::new(None)\n-    }\n+#[derive(Debug)]\n+pub struct Assist {\n+    pub id: AssistId,\n+    pub label: String,\n+    pub group_label: Option<String>,\n+    pub source_change: SourceChange,\n }\n \n impl AnalysisHost {\n@@ -187,6 +188,12 @@ impl AnalysisHost {\n     }\n }\n \n+impl Default for AnalysisHost {\n+    fn default() -> AnalysisHost {\n+        AnalysisHost::new(None)\n+    }\n+}\n+\n /// Analysis is a snapshot of a world state at a moment in time. It is the main\n /// entry point for asking semantic information about the world. When the world\n /// state is advanced using `AnalysisHost::apply_change` method, all existing\n@@ -464,7 +471,17 @@ impl Analysis {\n     /// Computes assists (aka code actions aka intentions) for the given\n     /// position.\n     pub fn assists(&self, frange: FileRange) -> Cancelable<Vec<Assist>> {\n-        self.with_db(|db| assists::assists(db, frange))\n+        self.with_db(|db| {\n+            ra_assists::Assist::resolved(db, frange)\n+                .into_iter()\n+                .map(|assist| Assist {\n+                    id: assist.assist.id,\n+                    label: assist.assist.label,\n+                    group_label: assist.assist.group.map(|it| it.0),\n+                    source_change: assist.source_change,\n+                })\n+                .collect()\n+        })\n     }\n \n     /// Computes the set of diagnostics for the given file."}, {"sha": "2cbb82c1a494b5362b21ef8b7bc757925715bda5", "filename": "crates/ra_ide/src/references/rename.rs", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_ide%2Fsrc%2Freferences%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_ide%2Fsrc%2Freferences%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences%2Frename.rs?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -712,6 +712,68 @@ mod tests {\n         \"###);\n     }\n \n+    #[test]\n+    fn test_enum_variant_from_module_1() {\n+        test_rename(\n+            r#\"\n+    mod foo {\n+        pub enum Foo {\n+            Bar<|>,\n+        }\n+    }\n+\n+    fn func(f: foo::Foo) {\n+        match f {\n+            foo::Foo::Bar => {}\n+        }\n+    }\n+    \"#,\n+            \"Baz\",\n+            r#\"\n+    mod foo {\n+        pub enum Foo {\n+            Baz,\n+        }\n+    }\n+\n+    fn func(f: foo::Foo) {\n+        match f {\n+            foo::Foo::Baz => {}\n+        }\n+    }\n+    \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_enum_variant_from_module_2() {\n+        test_rename(\n+            r#\"\n+    mod foo {\n+        pub struct Foo {\n+            pub bar<|>: uint,\n+        }\n+    }\n+\n+    fn foo(f: foo::Foo) {\n+        let _ = f.bar;\n+    }\n+    \"#,\n+            \"baz\",\n+            r#\"\n+    mod foo {\n+        pub struct Foo {\n+            pub baz: uint,\n+        }\n+    }\n+\n+    fn foo(f: foo::Foo) {\n+        let _ = f.baz;\n+    }\n+    \"#,\n+        );\n+    }\n+\n     fn test_rename(text: &str, new_name: &str, expected: &str) {\n         let (analysis, position) = single_file_with_position(text);\n         let source_change = analysis.rename(position, new_name).unwrap();"}, {"sha": "f990e3bb97da08482d556e252a41276445cc5417", "filename": "crates/ra_ide_db/src/defs.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_ide_db%2Fsrc%2Fdefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_ide_db%2Fsrc%2Fdefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fdefs.rs?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -6,7 +6,7 @@\n // FIXME: this badly needs rename/rewrite (matklad, 2020-02-06).\n \n use hir::{\n-    Field, HasVisibility, ImplDef, Local, MacroDef, Module, ModuleDef, Name, PathResolution,\n+    Adt, Field, HasVisibility, ImplDef, Local, MacroDef, Module, ModuleDef, Name, PathResolution,\n     Semantics, TypeParam, Visibility,\n };\n use ra_prof::profile;\n@@ -47,7 +47,13 @@ impl Definition {\n         match self {\n             Definition::Macro(_) => None,\n             Definition::Field(sf) => Some(sf.visibility(db)),\n-            Definition::ModuleDef(def) => module?.visibility_of(db, def),\n+            Definition::ModuleDef(def) => match def {\n+                ModuleDef::EnumVariant(id) => {\n+                    let parent = id.parent_enum(db);\n+                    module?.visibility_of(db, &ModuleDef::Adt(Adt::Enum(parent)))\n+                }\n+                _ => module?.visibility_of(db, def),\n+            },\n             Definition::SelfType(_) => None,\n             Definition::Local(_) => None,\n             Definition::TypeParam(_) => None,"}, {"sha": "af81a91a4a5bfdf52a1c81656c9e1d34ec0e4563", "filename": "crates/ra_ide_db/src/source_change.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_ide_db%2Fsrc%2Fsource_change.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_ide_db%2Fsrc%2Fsource_change.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fsource_change.rs?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -6,7 +6,7 @@\n use ra_db::{FileId, FilePosition, RelativePathBuf, SourceRootId};\n use ra_text_edit::{TextEdit, TextSize};\n \n-#[derive(Debug)]\n+#[derive(Debug, Clone)]\n pub struct SourceChange {\n     /// For display in the undo log in the editor\n     pub label: String,\n@@ -90,13 +90,13 @@ impl SourceChange {\n     }\n }\n \n-#[derive(Debug)]\n+#[derive(Debug, Clone)]\n pub struct SourceFileEdit {\n     pub file_id: FileId,\n     pub edit: TextEdit,\n }\n \n-#[derive(Debug)]\n+#[derive(Debug, Clone)]\n pub enum FileSystemEdit {\n     CreateFile { source_root: SourceRootId, path: RelativePathBuf },\n     MoveFile { src: FileId, dst_source_root: SourceRootId, dst_path: RelativePathBuf },"}, {"sha": "a32a5daabde3ee180ce7c1e065e577b03b188013", "filename": "crates/ra_project_model/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_project_model%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_project_model%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2FCargo.toml?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -14,8 +14,9 @@ rustc-hash = \"1.1.0\"\n cargo_metadata = \"0.9.1\"\n \n ra_arena = { path = \"../ra_arena\" }\n-ra_db = { path = \"../ra_db\" }\n ra_cfg = { path = \"../ra_cfg\" }\n+ra_db = { path = \"../ra_db\" }\n+ra_toolchain = { path = \"../ra_toolchain\" }\n ra_proc_macro =  { path = \"../ra_proc_macro\" }\n \n serde = { version = \"1.0.106\", features = [\"derive\"] }"}, {"sha": "082af4f9699d06b5ec86c9d50d9a191b0d25d7fe", "filename": "crates/ra_project_model/src/cargo_workspace.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -1,7 +1,6 @@\n //! FIXME: write short doc here\n \n use std::{\n-    env,\n     ffi::OsStr,\n     ops,\n     path::{Path, PathBuf},\n@@ -87,6 +86,7 @@ pub struct PackageData {\n     pub dependencies: Vec<PackageDependency>,\n     pub edition: Edition,\n     pub features: Vec<String>,\n+    pub cfgs: Vec<String>,\n     pub out_dir: Option<PathBuf>,\n     pub proc_macro_dylib_path: Option<PathBuf>,\n }\n@@ -145,12 +145,8 @@ impl CargoWorkspace {\n         cargo_toml: &Path,\n         cargo_features: &CargoConfig,\n     ) -> Result<CargoWorkspace> {\n-        let _ = Command::new(cargo_binary())\n-            .arg(\"--version\")\n-            .output()\n-            .context(\"failed to run `cargo --version`, is `cargo` in PATH?\")?;\n-\n         let mut meta = MetadataCommand::new();\n+        meta.cargo_path(ra_toolchain::cargo());\n         meta.manifest_path(cargo_toml);\n         if cargo_features.all_features {\n             meta.features(CargoOpt::AllFeatures);\n@@ -172,10 +168,12 @@ impl CargoWorkspace {\n         })?;\n \n         let mut out_dir_by_id = FxHashMap::default();\n+        let mut cfgs = FxHashMap::default();\n         let mut proc_macro_dylib_paths = FxHashMap::default();\n         if cargo_features.load_out_dirs_from_check {\n             let resources = load_extern_resources(cargo_toml, cargo_features)?;\n             out_dir_by_id = resources.out_dirs;\n+            cfgs = resources.cfgs;\n             proc_macro_dylib_paths = resources.proc_dylib_paths;\n         }\n \n@@ -201,6 +199,7 @@ impl CargoWorkspace {\n                 edition,\n                 dependencies: Vec::new(),\n                 features: Vec::new(),\n+                cfgs: cfgs.get(&id).cloned().unwrap_or_default(),\n                 out_dir: out_dir_by_id.get(&id).cloned(),\n                 proc_macro_dylib_path: proc_macro_dylib_paths.get(&id).cloned(),\n             });\n@@ -282,13 +281,14 @@ impl CargoWorkspace {\n pub struct ExternResources {\n     out_dirs: FxHashMap<PackageId, PathBuf>,\n     proc_dylib_paths: FxHashMap<PackageId, PathBuf>,\n+    cfgs: FxHashMap<PackageId, Vec<String>>,\n }\n \n pub fn load_extern_resources(\n     cargo_toml: &Path,\n     cargo_features: &CargoConfig,\n ) -> Result<ExternResources> {\n-    let mut cmd = Command::new(cargo_binary());\n+    let mut cmd = Command::new(ra_toolchain::cargo());\n     cmd.args(&[\"check\", \"--message-format=json\", \"--manifest-path\"]).arg(cargo_toml);\n     if cargo_features.all_features {\n         cmd.arg(\"--all-features\");\n@@ -307,8 +307,14 @@ pub fn load_extern_resources(\n     for message in cargo_metadata::parse_messages(output.stdout.as_slice()) {\n         if let Ok(message) = message {\n             match message {\n-                Message::BuildScriptExecuted(BuildScript { package_id, out_dir, .. }) => {\n-                    res.out_dirs.insert(package_id, out_dir);\n+                Message::BuildScriptExecuted(BuildScript { package_id, out_dir, cfgs, .. }) => {\n+                    res.out_dirs.insert(package_id.clone(), out_dir);\n+                    res.cfgs.insert(\n+                        package_id,\n+                        // FIXME: Current `cargo_metadata` uses `PathBuf` instead of `String`,\n+                        // change when https://github.com/oli-obk/cargo_metadata/pulls/112 reaches crates.io\n+                        cfgs.iter().filter_map(|c| c.to_str().map(|s| s.to_owned())).collect(),\n+                    );\n                 }\n \n                 Message::CompilerArtifact(message) => {\n@@ -336,7 +342,3 @@ fn is_dylib(path: &Path) -> bool {\n         Some(ext) => matches!(ext.as_str(), \"dll\" | \"dylib\" | \"so\"),\n     }\n }\n-\n-fn cargo_binary() -> String {\n-    env::var(\"CARGO\").unwrap_or_else(|_| \"cargo\".to_string())\n-}"}, {"sha": "5a0a87ed7d44428df5655d23ba62427534e8b670", "filename": "crates/ra_project_model/src/lib.rs", "status": "modified", "additions": 28, "deletions": 16, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_project_model%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_project_model%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Flib.rs?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -8,7 +8,7 @@ use std::{\n     fs::{read_dir, File, ReadDir},\n     io::{self, BufReader},\n     path::{Path, PathBuf},\n-    process::Command,\n+    process::{Command, Output},\n };\n \n use anyhow::{bail, Context, Result};\n@@ -398,7 +398,18 @@ impl ProjectWorkspace {\n                             let edition = cargo[pkg].edition;\n                             let cfg_options = {\n                                 let mut opts = default_cfg_options.clone();\n-                                opts.insert_features(cargo[pkg].features.iter().map(Into::into));\n+                                for feature in cargo[pkg].features.iter() {\n+                                    opts.insert_key_value(\"feature\".into(), feature.into());\n+                                }\n+                                for cfg in cargo[pkg].cfgs.iter() {\n+                                    match cfg.find('=') {\n+                                        Some(split) => opts.insert_key_value(\n+                                            cfg[..split].into(),\n+                                            cfg[split + 1..].trim_matches('\"').into(),\n+                                        ),\n+                                        None => opts.insert_atom(cfg.into()),\n+                                    };\n+                                }\n                                 opts\n                             };\n                             let mut env = Env::default();\n@@ -556,25 +567,18 @@ pub fn get_rustc_cfg_options(target: Option<&String>) -> CfgOptions {\n         }\n     }\n \n-    match (|| -> Result<String> {\n+    let rustc_cfgs = || -> Result<String> {\n         // `cfg(test)` and `cfg(debug_assertion)` are handled outside, so we suppress them here.\n-        let mut cmd = Command::new(\"rustc\");\n+        let mut cmd = Command::new(ra_toolchain::rustc());\n         cmd.args(&[\"--print\", \"cfg\", \"-O\"]);\n         if let Some(target) = target {\n             cmd.args(&[\"--target\", target.as_str()]);\n         }\n-        let output = cmd.output().context(\"Failed to get output from rustc --print cfg -O\")?;\n-        if !output.status.success() {\n-            bail!(\n-                \"rustc --print cfg -O exited with exit code ({})\",\n-                output\n-                    .status\n-                    .code()\n-                    .map_or(String::from(\"no exit code\"), |code| format!(\"{}\", code))\n-            );\n-        }\n+        let output = output(cmd)?;\n         Ok(String::from_utf8(output.stdout)?)\n-    })() {\n+    }();\n+\n+    match rustc_cfgs {\n         Ok(rustc_cfgs) => {\n             for line in rustc_cfgs.lines() {\n                 match line.find('=') {\n@@ -587,8 +591,16 @@ pub fn get_rustc_cfg_options(target: Option<&String>) -> CfgOptions {\n                 }\n             }\n         }\n-        Err(e) => log::error!(\"failed to get rustc cfgs: {}\", e),\n+        Err(e) => log::error!(\"failed to get rustc cfgs: {:#}\", e),\n     }\n \n     cfg_options\n }\n+\n+fn output(mut cmd: Command) -> Result<Output> {\n+    let output = cmd.output().with_context(|| format!(\"{:?} failed\", cmd))?;\n+    if !output.status.success() {\n+        bail!(\"{:?} failed, {}\", cmd, output.status)\n+    }\n+    Ok(output)\n+}"}, {"sha": "a8a196e64c963f68435babe2ec8d703f9b292032", "filename": "crates/ra_project_model/src/sysroot.rs", "status": "modified", "additions": 11, "deletions": 30, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_project_model%2Fsrc%2Fsysroot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_project_model%2Fsrc%2Fsysroot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Fsysroot.rs?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -1,14 +1,16 @@\n //! FIXME: write short doc here\n \n-use anyhow::{bail, Context, Result};\n use std::{\n     env, ops,\n     path::{Path, PathBuf},\n-    process::{Command, Output},\n+    process::Command,\n };\n \n+use anyhow::{bail, Result};\n use ra_arena::{Arena, Idx};\n \n+use crate::output;\n+\n #[derive(Default, Debug, Clone)]\n pub struct Sysroot {\n     crates: Arena<SysrootCrateData>,\n@@ -84,43 +86,22 @@ impl Sysroot {\n     }\n }\n \n-fn create_command_text(program: &str, args: &[&str]) -> String {\n-    format!(\"{} {}\", program, args.join(\" \"))\n-}\n-\n-fn run_command_in_cargo_dir(cargo_toml: &Path, program: &str, args: &[&str]) -> Result<Output> {\n-    let output = Command::new(program)\n-        .current_dir(cargo_toml.parent().unwrap())\n-        .args(args)\n-        .output()\n-        .context(format!(\"{} failed\", create_command_text(program, args)))?;\n-    if !output.status.success() {\n-        match output.status.code() {\n-            Some(code) => bail!(\n-                \"failed to run the command: '{}' exited with code {}\",\n-                create_command_text(program, args),\n-                code\n-            ),\n-            None => bail!(\n-                \"failed to run the command: '{}' terminated by signal\",\n-                create_command_text(program, args)\n-            ),\n-        };\n-    }\n-    Ok(output)\n-}\n-\n fn get_or_install_rust_src(cargo_toml: &Path) -> Result<PathBuf> {\n     if let Ok(path) = env::var(\"RUST_SRC_PATH\") {\n         return Ok(path.into());\n     }\n-    let rustc_output = run_command_in_cargo_dir(cargo_toml, \"rustc\", &[\"--print\", \"sysroot\"])?;\n+    let current_dir = cargo_toml.parent().unwrap();\n+    let mut rustc = Command::new(ra_toolchain::rustc());\n+    rustc.current_dir(current_dir).args(&[\"--print\", \"sysroot\"]);\n+    let rustc_output = output(rustc)?;\n     let stdout = String::from_utf8(rustc_output.stdout)?;\n     let sysroot_path = Path::new(stdout.trim());\n     let src_path = sysroot_path.join(\"lib/rustlib/src/rust/src\");\n \n     if !src_path.exists() {\n-        run_command_in_cargo_dir(cargo_toml, \"rustup\", &[\"component\", \"add\", \"rust-src\"])?;\n+        let mut rustup = Command::new(ra_toolchain::rustup());\n+        rustup.current_dir(current_dir).args(&[\"component\", \"add\", \"rust-src\"]);\n+        let _output = output(rustup)?;\n     }\n     if !src_path.exists() {\n         bail!("}, {"sha": "1873fbe16783f8d33523f6d32399137c72e89e01", "filename": "crates/ra_toolchain/Cargo.toml", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_toolchain%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_toolchain%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_toolchain%2FCargo.toml?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -0,0 +1,8 @@\n+[package]\n+edition = \"2018\"\n+name = \"ra_toolchain\"\n+version = \"0.1.0\"\n+authors = [\"rust-analyzer developers\"]\n+\n+[dependencies]\n+home = \"0.5.3\""}, {"sha": "3c307a0eace45e4be22bdb2b2eb8de6a91f2695c", "filename": "crates/ra_toolchain/src/lib.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_toolchain%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Fra_toolchain%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_toolchain%2Fsrc%2Flib.rs?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -0,0 +1,64 @@\n+//! This crate contains a single public function\n+//! [`get_path_for_executable`](fn.get_path_for_executable.html).\n+//! See docs there for more information.\n+use std::{env, iter, path::PathBuf};\n+\n+pub fn cargo() -> PathBuf {\n+    get_path_for_executable(\"cargo\")\n+}\n+\n+pub fn rustc() -> PathBuf {\n+    get_path_for_executable(\"rustc\")\n+}\n+\n+pub fn rustup() -> PathBuf {\n+    get_path_for_executable(\"rustup\")\n+}\n+\n+/// Return a `PathBuf` to use for the given executable.\n+///\n+/// E.g., `get_path_for_executable(\"cargo\")` may return just `cargo` if that\n+/// gives a valid Cargo executable; or it may return a full path to a valid\n+/// Cargo.\n+fn get_path_for_executable(executable_name: &'static str) -> PathBuf {\n+    // The current implementation checks three places for an executable to use:\n+    // 1) Appropriate environment variable (erroring if this is set but not a usable executable)\n+    //      example: for cargo, this checks $CARGO environment variable; for rustc, $RUSTC; etc\n+    // 2) `<executable_name>`\n+    //      example: for cargo, this tries just `cargo`, which will succeed if `cargo` is on the $PATH\n+    // 3) `~/.cargo/bin/<executable_name>`\n+    //      example: for cargo, this tries ~/.cargo/bin/cargo\n+    //      It seems that this is a reasonable place to try for cargo, rustc, and rustup\n+    let env_var = executable_name.to_ascii_uppercase();\n+    if let Some(path) = env::var_os(&env_var) {\n+        return path.into();\n+    }\n+\n+    if lookup_in_path(executable_name) {\n+        return executable_name.into();\n+    }\n+\n+    if let Some(mut path) = home::home_dir() {\n+        path.push(\".cargo\");\n+        path.push(\"bin\");\n+        path.push(executable_name);\n+        if path.is_file() {\n+            return path;\n+        }\n+    }\n+    executable_name.into()\n+}\n+\n+fn lookup_in_path(exec: &str) -> bool {\n+    let paths = env::var_os(\"PATH\").unwrap_or_default();\n+    let mut candidates = env::split_paths(&paths).flat_map(|path| {\n+        let candidate = path.join(&exec);\n+        let with_exe = if env::consts::EXE_EXTENSION == \"\" {\n+            None\n+        } else {\n+            Some(candidate.with_extension(env::consts::EXE_EXTENSION))\n+        };\n+        iter::once(candidate).chain(with_exe)\n+    });\n+    candidates.any(|it| it.is_file())\n+}"}, {"sha": "f4353af64703d1f7154714a4397156677729d4f4", "filename": "crates/rust-analyzer/src/main_loop/handlers.rs", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -42,6 +42,7 @@ use crate::{\n     world::WorldSnapshot,\n     LspError, Result,\n };\n+use ra_project_model::TargetKind;\n \n pub fn handle_analyzer_status(world: WorldSnapshot, _: ()) -> Result<String> {\n     let _p = profile(\"handle_analyzer_status\");\n@@ -384,16 +385,27 @@ pub fn handle_runnables(\n     let offset = params.position.map(|it| it.conv_with(&line_index));\n     let mut res = Vec::new();\n     let workspace_root = world.workspace_root_for(file_id);\n+    let cargo_spec = CargoTargetSpec::for_file(&world, file_id)?;\n     for runnable in world.analysis().runnables(file_id)? {\n         if let Some(offset) = offset {\n             if !runnable.range.contains_inclusive(offset) {\n                 continue;\n             }\n         }\n+        // Do not suggest binary run on other target than binary\n+        if let RunnableKind::Bin = runnable.kind {\n+            if let Some(spec) = &cargo_spec {\n+                match spec.target_kind {\n+                    TargetKind::Bin => {}\n+                    _ => continue,\n+                }\n+            }\n+        }\n         res.push(to_lsp_runnable(&world, file_id, runnable)?);\n     }\n+\n     // Add `cargo check` and `cargo test` for the whole package\n-    match CargoTargetSpec::for_file(&world, file_id)? {\n+    match cargo_spec {\n         Some(spec) => {\n             for &cmd in [\"check\", \"test\"].iter() {\n                 res.push(req::Runnable {\n@@ -831,13 +843,23 @@ pub fn handle_code_lens(\n \n     let mut lenses: Vec<CodeLens> = Default::default();\n \n+    let cargo_spec = CargoTargetSpec::for_file(&world, file_id)?;\n     // Gather runnables\n     for runnable in world.analysis().runnables(file_id)? {\n         let title = match &runnable.kind {\n             RunnableKind::Test { .. } | RunnableKind::TestMod { .. } => \"\u25b6\ufe0f\\u{fe0e}Run Test\",\n             RunnableKind::DocTest { .. } => \"\u25b6\ufe0f\\u{fe0e}Run Doctest\",\n             RunnableKind::Bench { .. } => \"Run Bench\",\n-            RunnableKind::Bin => \"Run\",\n+            RunnableKind::Bin => {\n+                // Do not suggest binary run on other target than binary\n+                match &cargo_spec {\n+                    Some(spec) => match spec.target_kind {\n+                        TargetKind::Bin => \"Run\",\n+                        _ => continue,\n+                    },\n+                    None => continue,\n+                }\n+            }\n         }\n         .to_string();\n         let mut r = to_lsp_runnable(&world, file_id, runnable)?;"}, {"sha": "e459e3a3cec776d1652af9d6e4651a08f6ce0f80", "filename": "crates/rust-analyzer/tests/heavy_tests/main.rs", "status": "modified", "additions": 107, "deletions": 3, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fmain.rs?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -9,7 +9,8 @@ use lsp_types::{\n };\n use rust_analyzer::req::{\n     CodeActionParams, CodeActionRequest, Completion, CompletionParams, DidOpenTextDocument,\n-    Formatting, GotoDefinition, HoverRequest, OnEnter, Runnables, RunnablesParams,\n+    Formatting, GotoDefinition, GotoTypeDefinition, HoverRequest, OnEnter, Runnables,\n+    RunnablesParams,\n };\n use serde_json::json;\n use tempfile::TempDir;\n@@ -574,7 +575,7 @@ version = \\\"0.0.0\\\"\n }\n \n #[test]\n-fn resolve_include_concat_env() {\n+fn out_dirs_check() {\n     if skip_slow_tests() {\n         return;\n     }\n@@ -597,11 +598,28 @@ fn main() {\n         r#\"pub fn message() -> &'static str { \"Hello, World!\" }\"#,\n     )\n     .unwrap();\n+    println!(\"cargo:rustc-cfg=atom_cfg\");\n+    println!(\"cargo:rustc-cfg=featlike=\\\"set\\\"\");\n     println!(\"cargo:rerun-if-changed=build.rs\");\n }\n //- src/main.rs\n include!(concat!(env!(\"OUT_DIR\"), \"/hello.rs\"));\n \n+#[cfg(atom_cfg)]\n+struct A;\n+#[cfg(bad_atom_cfg)]\n+struct A;\n+#[cfg(featlike = \"set\")]\n+struct B;\n+#[cfg(featlike = \"not_set\")]\n+struct B;\n+\n+fn main() {\n+    let va = A;\n+    let vb = B;\n+    message();\n+}\n+\n fn main() { message(); }\n \"###,\n     )\n@@ -613,12 +631,98 @@ fn main() { message(); }\n     let res = server.send_request::<GotoDefinition>(GotoDefinitionParams {\n         text_document_position_params: TextDocumentPositionParams::new(\n             server.doc_id(\"src/main.rs\"),\n-            Position::new(2, 15),\n+            Position::new(14, 8),\n         ),\n         work_done_progress_params: Default::default(),\n         partial_result_params: Default::default(),\n     });\n     assert!(format!(\"{}\", res).contains(\"hello.rs\"));\n+    server.request::<GotoTypeDefinition>(\n+        GotoDefinitionParams {\n+            text_document_position_params: TextDocumentPositionParams::new(\n+                server.doc_id(\"src/main.rs\"),\n+                Position::new(12, 9),\n+            ),\n+            work_done_progress_params: Default::default(),\n+            partial_result_params: Default::default(),\n+        },\n+        json!([{\n+            \"originSelectionRange\": {\n+                \"end\": {\n+                    \"character\": 10,\n+                    \"line\": 12\n+                },\n+                \"start\": {\n+                    \"character\": 8,\n+                    \"line\": 12\n+                }\n+            },\n+            \"targetRange\": {\n+                \"end\": {\n+                    \"character\": 9,\n+                    \"line\": 3\n+                },\n+                \"start\": {\n+                    \"character\": 0,\n+                    \"line\": 2\n+                }\n+            },\n+            \"targetSelectionRange\": {\n+                \"end\": {\n+                    \"character\": 8,\n+                    \"line\": 3\n+                },\n+                \"start\": {\n+                    \"character\": 7,\n+                    \"line\": 3\n+                }\n+            },\n+            \"targetUri\": \"file:///[..]src/main.rs\"\n+        }]),\n+    );\n+    server.request::<GotoTypeDefinition>(\n+        GotoDefinitionParams {\n+            text_document_position_params: TextDocumentPositionParams::new(\n+                server.doc_id(\"src/main.rs\"),\n+                Position::new(13, 9),\n+            ),\n+            work_done_progress_params: Default::default(),\n+            partial_result_params: Default::default(),\n+        },\n+        json!([{\n+            \"originSelectionRange\": {\n+                \"end\": {\n+                    \"character\": 10,\n+                    \"line\": 13\n+                },\n+                \"start\": {\n+                    \"character\": 8,\n+                    \"line\":13\n+                }\n+            },\n+            \"targetRange\": {\n+                \"end\": {\n+                    \"character\": 9,\n+                    \"line\": 7\n+                },\n+                \"start\": {\n+                    \"character\": 0,\n+                    \"line\":6\n+                }\n+            },\n+            \"targetSelectionRange\": {\n+                \"end\": {\n+                    \"character\": 8,\n+                    \"line\": 7\n+                },\n+                \"start\": {\n+                    \"character\": 7,\n+                    \"line\": 7\n+                }\n+            },\n+            \"targetUri\": \"file:///[..]src/main.rs\"\n+        }]),\n+    );\n }\n \n #[test]"}, {"sha": "b13e13af2aab4803ddf153f3fa7279a3a02536ae", "filename": "crates/test_utils/src/lib.rs", "status": "modified", "additions": 95, "deletions": 9, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Ftest_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/crates%2Ftest_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Flib.rs?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -155,7 +155,7 @@ pub fn add_cursor(text: &str, offset: TextSize) -> String {\n     res\n }\n \n-#[derive(Debug)]\n+#[derive(Debug, Eq, PartialEq)]\n pub struct FixtureEntry {\n     pub meta: String,\n     pub text: String,\n@@ -170,19 +170,26 @@ pub struct FixtureEntry {\n ///  // - other meta\n ///  ```\n pub fn parse_fixture(fixture: &str) -> Vec<FixtureEntry> {\n-    let margin = fixture\n-        .lines()\n-        .filter(|it| it.trim_start().starts_with(\"//-\"))\n-        .map(|it| it.len() - it.trim_start().len())\n-        .next()\n-        .expect(\"empty fixture\");\n+    let fixture = indent_first_line(fixture);\n+    let margin = fixture_margin(&fixture);\n \n     let mut lines = fixture\n         .split('\\n') // don't use `.lines` to not drop `\\r\\n`\n-        .filter_map(|line| {\n+        .enumerate()\n+        .filter_map(|(ix, line)| {\n             if line.len() >= margin {\n                 assert!(line[..margin].trim().is_empty());\n-                Some(&line[margin..])\n+                let line_content = &line[margin..];\n+                if !line_content.starts_with(\"//-\") {\n+                    assert!(\n+                        !line_content.contains(\"//-\"),\n+                        r#\"Metadata line {} has invalid indentation. All metadata lines need to have the same indentation.\n+The offending line: {:?}\"#,\n+                        ix,\n+                        line\n+                    );\n+                }\n+                Some(line_content)\n             } else {\n                 assert!(line.trim().is_empty());\n                 None\n@@ -202,6 +209,85 @@ pub fn parse_fixture(fixture: &str) -> Vec<FixtureEntry> {\n     res\n }\n \n+/// Adjusts the indentation of the first line to the minimum indentation of the rest of the lines.\n+/// This allows fixtures to start off in a different indentation, e.g. to align the first line with\n+/// the other lines visually:\n+/// ```\n+/// let fixture = \"//- /lib.rs\n+///                mod foo;\n+///                //- /foo.rs\n+///                fn bar() {}\n+/// \";\n+/// assert_eq!(fixture_margin(fixture),\n+/// \"               //- /lib.rs\n+///                mod foo;\n+///                //- /foo.rs\n+///                fn bar() {}\n+/// \")\n+/// ```\n+fn indent_first_line(fixture: &str) -> String {\n+    if fixture.is_empty() {\n+        return String::new();\n+    }\n+    let mut lines = fixture.lines();\n+    let first_line = lines.next().unwrap();\n+    if first_line.contains(\"//-\") {\n+        let rest = lines.collect::<Vec<_>>().join(\"\\n\");\n+        let fixed_margin = fixture_margin(&rest);\n+        let fixed_indent = fixed_margin - indent_len(first_line);\n+        format!(\"\\n{}{}\\n{}\", \" \".repeat(fixed_indent), first_line, rest)\n+    } else {\n+        fixture.to_owned()\n+    }\n+}\n+\n+fn fixture_margin(fixture: &str) -> usize {\n+    fixture\n+        .lines()\n+        .filter(|it| it.trim_start().starts_with(\"//-\"))\n+        .map(indent_len)\n+        .next()\n+        .expect(\"empty fixture\")\n+}\n+\n+fn indent_len(s: &str) -> usize {\n+    s.len() - s.trim_start().len()\n+}\n+\n+#[test]\n+#[should_panic]\n+fn parse_fixture_checks_further_indented_metadata() {\n+    parse_fixture(\n+        r\"\n+        //- /lib.rs\n+          mod bar;\n+\n+          fn foo() {}\n+          //- /bar.rs\n+          pub fn baz() {}\n+          \",\n+    );\n+}\n+\n+#[test]\n+fn parse_fixture_can_handle_unindented_first_line() {\n+    let fixture = \"//- /lib.rs\n+                   mod foo;\n+                   //- /foo.rs\n+                   struct Bar;\n+\";\n+    assert_eq!(\n+        parse_fixture(fixture),\n+        parse_fixture(\n+            \"//- /lib.rs\n+mod foo;\n+//- /foo.rs\n+struct Bar;\n+\"\n+        )\n+    )\n+}\n+\n /// Same as `parse_fixture`, except it allow empty fixture\n pub fn parse_single_fixture(fixture: &str) -> Option<FixtureEntry> {\n     if !fixture.lines().any(|it| it.trim_start().starts_with(\"//-\")) {"}, {"sha": "692fd4f52bacfabe4917646214565a8952053af4", "filename": "docs/user/assists.md", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/docs%2Fuser%2Fassists.md", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/docs%2Fuser%2Fassists.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Fassists.md?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -241,6 +241,18 @@ fn main() {\n }\n ```\n \n+## `change_return_type_to_result`\n+\n+Change the function's return type to Result.\n+\n+```rust\n+// BEFORE\n+fn foo() -> i32\u2503 { 42i32 }\n+\n+// AFTER\n+fn foo() -> Result<i32, > { Ok(42i32) }\n+```\n+\n ## `change_visibility`\n \n Adds or changes existing visibility specifier."}, {"sha": "f6ce0accf32c70a59ac109b42ce687b41ef96694", "filename": "docs/user/readme.adoc", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/docs%2Fuser%2Freadme.adoc", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/docs%2Fuser%2Freadme.adoc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Freadme.adoc?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -61,7 +61,7 @@ The server binary is stored in:\n \n * Linux: `~/.config/Code/User/globalStorage/matklad.rust-analyzer`\n * macOS: `~/Library/Application Support/Code/User/globalStorage/matklad.rust-analyzer`\n-* Windows: `%APPDATA%\\Code\\User\\globalStorage`\n+* Windows: `%APPDATA%\\Code\\User\\globalStorage\\matklad.rust-analyzer`\n \n Note that we only support the latest version of VS Code.\n \n@@ -139,17 +139,16 @@ If your editor can't find the binary even though the binary is on your `$PATH`,\n \n ==== Arch Linux\n \n-The `rust-analyzer` binary can be installed from AUR (Arch User Repository):\n+The `rust-analyzer` binary can be installed from the repos or AUR (Arch User Repository):\n \n-- https://aur.archlinux.org/packages/rust-analyzer-bin[`rust-analyzer-bin`] (binary from GitHub releases)\n-- https://aur.archlinux.org/packages/rust-analyzer[`rust-analyzer`] (built from latest tagged source)\n-- https://aur.archlinux.org/packages/rust-analyzer-git[`rust-analyzer-git`] (latest git version)\n+- https://www.archlinux.org/packages/community/x86_64/rust-analyzer/[`rust-analyzer`] (built from latest tagged source)\n+- https://aur.archlinux.org/packages/rust-analyzer-git[`rust-analyzer-git`] (latest Git version)\n \n-Install it with AUR helper of your choice, for example:\n+Install it with pacman, for example:\n \n [source,bash]\n ----\n-$ yay -S rust-analyzer-bin\n+$ pacman -S rust-analyzer\n ----\n \n === Emacs\n@@ -187,7 +186,7 @@ The are several LSP client implementations for vim or neovim:\n \n 1. Install LanguageClient-neovim by following the instructions\n    https://github.com/autozimu/LanguageClient-neovim[here]\n-   * The github project wiki has extra tips on configuration\n+   * The GitHub project wiki has extra tips on configuration\n \n 2. Configure by adding this to your vim/neovim config file (replacing the existing Rust-specific line if it exists):\n +\n@@ -220,17 +219,11 @@ let g:ycm_language_server =\n \n ==== ALE\n \n-To add the LSP server to https://github.com/dense-analysis/ale[ale]:\n+To use the LSP server in https://github.com/dense-analysis/ale[ale]:\n \n [source,vim]\n ----\n-call ale#linter#Define('rust', {\n-\\   'name': 'rust-analyzer',\n-\\   'lsp': 'stdio',\n-\\   'executable': 'rust-analyzer',\n-\\   'command': '%e',\n-\\   'project_root': '.',\n-\\})\n+let g:ale_linters = {'rust': ['analyzer']}\n ----\n \n ==== nvim-lsp"}, {"sha": "c6fc13519e062b0fa9189ea663a9394acc1b6933", "filename": "editors/code/package.json", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/editors%2Fcode%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/editors%2Fcode%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fpackage.json?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -300,6 +300,11 @@\n                     \"default\": true,\n                     \"markdownDescription\": \"Check with all features (will be passed as `--all-features`)\"\n                 },\n+                \"rust-analyzer.inlayHints.enable\": {\n+                    \"type\": \"boolean\",\n+                    \"default\": true,\n+                    \"description\": \"Disable all inlay hints\"\n+                },\n                 \"rust-analyzer.inlayHints.typeHints\": {\n                     \"type\": \"boolean\",\n                     \"default\": true,\n@@ -405,7 +410,7 @@\n                         \"ms-vscode.cpptools\"\n                     ],\n                     \"default\": \"auto\",\n-                    \"description\": \"Preffered debug engine.\",\n+                    \"description\": \"Preferred debug engine.\",\n                     \"markdownEnumDescriptions\": [\n                         \"First try to use [CodeLLDB](https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb), if it's not installed try to use [MS C++ tools](https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools).\",\n                         \"Use [CodeLLDB](https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb)\",\n@@ -599,9 +604,18 @@\n                     \"union\": [\n                         \"entity.name.union\"\n                     ],\n+                    \"struct\": [\n+                        \"entity.name.type.struct\"\n+                    ],\n                     \"keyword.unsafe\": [\n                         \"keyword.other.unsafe\"\n                     ],\n+                    \"keyword\": [\n+                        \"keyword\"\n+                    ],\n+                    \"keyword.controlFlow\": [\n+                        \"keyword.control\"\n+                    ],\n                     \"variable.constant\": [\n                         \"entity.name.constant\"\n                     ]"}, {"sha": "2a2c2e0e1bb8fc7ebc7824e7490221c43e188c08", "filename": "editors/code/src/cargo.ts", "status": "modified", "additions": 49, "deletions": 32, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/editors%2Fcode%2Fsrc%2Fcargo.ts", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/editors%2Fcode%2Fsrc%2Fcargo.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fcargo.ts?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -1,6 +1,9 @@\n import * as cp from 'child_process';\n+import * as os from 'os';\n+import * as path from 'path';\n import * as readline from 'readline';\n import { OutputChannel } from 'vscode';\n+import { isValidExecutable } from './util';\n \n interface CompilationArtifact {\n     fileName: string;\n@@ -10,17 +13,9 @@ interface CompilationArtifact {\n }\n \n export class Cargo {\n-    rootFolder: string;\n-    env?: Record<string, string>;\n-    output: OutputChannel;\n-\n-    public constructor(cargoTomlFolder: string, output: OutputChannel, env: Record<string, string> | undefined = undefined) {\n-        this.rootFolder = cargoTomlFolder;\n-        this.output = output;\n-        this.env = env;\n-    }\n+    constructor(readonly rootFolder: string, readonly output: OutputChannel) { }\n \n-    public async artifactsFromArgs(cargoArgs: string[]): Promise<CompilationArtifact[]> {\n+    private async artifactsFromArgs(cargoArgs: string[]): Promise<CompilationArtifact[]> {\n         const artifacts: CompilationArtifact[] = [];\n \n         try {\n@@ -37,27 +32,22 @@ export class Cargo {\n                                 isTest: message.profile.test\n                             });\n                         }\n-                    }\n-                    else if (message.reason === 'compiler-message') {\n+                    } else if (message.reason === 'compiler-message') {\n                         this.output.append(message.message.rendered);\n                     }\n                 },\n-                stderr => {\n-                    this.output.append(stderr);\n-                }\n+                stderr => this.output.append(stderr),\n             );\n-        }\n-        catch (err) {\n+        } catch (err) {\n             this.output.show(true);\n             throw new Error(`Cargo invocation has failed: ${err}`);\n         }\n \n         return artifacts;\n     }\n \n-    public async executableFromArgs(args: string[]): Promise<string> {\n-        const cargoArgs = [...args]; // to remain  args unchanged\n-        cargoArgs.push(\"--message-format=json\");\n+    async executableFromArgs(args: readonly string[]): Promise<string> {\n+        const cargoArgs = [...args, \"--message-format=json\"];\n \n         const artifacts = await this.artifactsFromArgs(cargoArgs);\n \n@@ -70,24 +60,27 @@ export class Cargo {\n         return artifacts[0].fileName;\n     }\n \n-    runCargo(\n+    private runCargo(\n         cargoArgs: string[],\n         onStdoutJson: (obj: any) => void,\n         onStderrString: (data: string) => void\n     ): Promise<number> {\n-        return new Promise<number>((resolve, reject) => {\n-            const cargo = cp.spawn('cargo', cargoArgs, {\n+        return new Promise((resolve, reject) => {\n+            let cargoPath;\n+            try {\n+                cargoPath = getCargoPathOrFail();\n+            } catch (err) {\n+                return reject(err);\n+            }\n+\n+            const cargo = cp.spawn(cargoPath, cargoArgs, {\n                 stdio: ['ignore', 'pipe', 'pipe'],\n-                cwd: this.rootFolder,\n-                env: this.env,\n+                cwd: this.rootFolder\n             });\n \n-            cargo.on('error', err => {\n-                reject(new Error(`could not launch cargo: ${err}`));\n-            });\n-            cargo.stderr.on('data', chunk => {\n-                onStderrString(chunk.toString());\n-            });\n+            cargo.on('error', err => reject(new Error(`could not launch cargo: ${err}`)));\n+\n+            cargo.stderr.on('data', chunk => onStderrString(chunk.toString()));\n \n             const rl = readline.createInterface({ input: cargo.stdout });\n             rl.on('line', line => {\n@@ -103,4 +96,28 @@ export class Cargo {\n             });\n         });\n     }\n-}\n\\ No newline at end of file\n+}\n+\n+// Mirrors `ra_env::get_path_for_executable` implementation\n+function getCargoPathOrFail(): string {\n+    const envVar = process.env.CARGO;\n+    const executableName = \"cargo\";\n+\n+    if (envVar) {\n+        if (isValidExecutable(envVar)) return envVar;\n+\n+        throw new Error(`\\`${envVar}\\` environment variable points to something that's not a valid executable`);\n+    }\n+\n+    if (isValidExecutable(executableName)) return executableName;\n+\n+    const standardLocation = path.join(os.homedir(), '.cargo', 'bin', executableName);\n+\n+    if (isValidExecutable(standardLocation)) return standardLocation;\n+\n+    throw new Error(\n+        `Failed to find \\`${executableName}\\` executable. ` +\n+        `Make sure \\`${executableName}\\` is in \\`$PATH\\`, ` +\n+        `or set \\`${envVar}\\` to point to a valid executable.`\n+    );\n+}"}, {"sha": "be2e27aeccaa9a67051e88ca5ac9be8abd054498", "filename": "editors/code/src/config.ts", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/editors%2Fcode%2Fsrc%2Fconfig.ts", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/editors%2Fcode%2Fsrc%2Fconfig.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fconfig.ts?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -94,6 +94,7 @@ export class Config {\n \n     get inlayHints() {\n         return {\n+            enable: this.get<boolean>(\"inlayHints.enable\"),\n             typeHints: this.get<boolean>(\"inlayHints.typeHints\"),\n             parameterHints: this.get<boolean>(\"inlayHints.parameterHints\"),\n             chainingHints: this.get<boolean>(\"inlayHints.chainingHints\"),"}, {"sha": "a2b07d003788d77fd797049298c9060bef2910e7", "filename": "editors/code/src/inlay_hints.ts", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/editors%2Fcode%2Fsrc%2Finlay_hints.ts", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/editors%2Fcode%2Fsrc%2Finlay_hints.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Finlay_hints.ts?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -10,13 +10,13 @@ export function activateInlayHints(ctx: Ctx) {\n     const maybeUpdater = {\n         updater: null as null | HintsUpdater,\n         async onConfigChange() {\n-            if (\n-                !ctx.config.inlayHints.typeHints &&\n-                !ctx.config.inlayHints.parameterHints &&\n-                !ctx.config.inlayHints.chainingHints\n-            ) {\n-                return this.dispose();\n-            }\n+            const anyEnabled = ctx.config.inlayHints.typeHints\n+                || ctx.config.inlayHints.parameterHints\n+                || ctx.config.inlayHints.chainingHints;\n+            const enabled = ctx.config.inlayHints.enable && anyEnabled;\n+\n+            if (!enabled) return this.dispose();\n+\n             await sleep(100);\n             if (this.updater) {\n                 this.updater.syncCacheAndRenderHints();"}, {"sha": "9b020d0019a3b49fb5fd18e51d51e8ef8b04fb71", "filename": "editors/code/src/main.ts", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/editors%2Fcode%2Fsrc%2Fmain.ts", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/editors%2Fcode%2Fsrc%2Fmain.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fmain.ts?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -8,10 +8,9 @@ import { activateInlayHints } from './inlay_hints';\n import { activateStatusDisplay } from './status_display';\n import { Ctx } from './ctx';\n import { Config, NIGHTLY_TAG } from './config';\n-import { log, assert } from './util';\n+import { log, assert, isValidExecutable } from './util';\n import { PersistentState } from './persistent_state';\n import { fetchRelease, download } from './net';\n-import { spawnSync } from 'child_process';\n import { activateTaskProvider } from './tasks';\n \n let ctx: Ctx | undefined;\n@@ -179,10 +178,7 @@ async function bootstrapServer(config: Config, state: PersistentState): Promise<\n \n     log.debug(\"Using server binary at\", path);\n \n-    const res = spawnSync(path, [\"--version\"], { encoding: 'utf8' });\n-    log.debug(\"Checked binary availability via --version\", res);\n-    log.debug(res, \"--version output:\", res.output);\n-    if (res.status !== 0) {\n+    if (!isValidExecutable(path)) {\n         throw new Error(`Failed to execute ${path} --version`);\n     }\n "}, {"sha": "127a9e9112499ab357df4b483cb205cea40f83fe", "filename": "editors/code/src/util.ts", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/editors%2Fcode%2Fsrc%2Futil.ts", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/editors%2Fcode%2Fsrc%2Futil.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Futil.ts?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -1,6 +1,7 @@\n import * as lc from \"vscode-languageclient\";\n import * as vscode from \"vscode\";\n import { strict as nativeAssert } from \"assert\";\n+import { spawnSync } from \"child_process\";\n \n export function assert(condition: boolean, explanation: string): asserts condition {\n     try {\n@@ -82,3 +83,13 @@ export function isRustDocument(document: vscode.TextDocument): document is RustD\n export function isRustEditor(editor: vscode.TextEditor): editor is RustEditor {\n     return isRustDocument(editor.document);\n }\n+\n+export function isValidExecutable(path: string): boolean {\n+    log.debug(\"Checking availability of a binary at\", path);\n+\n+    const res = spawnSync(path, [\"--version\"], { encoding: 'utf8' });\n+\n+    log.debug(res, \"--version output:\", res.output);\n+\n+    return res.status === 0;\n+}"}, {"sha": "b8e8860ba1e1d4cc5b5c819da252fc164936e5a3", "filename": "xtask/tests/tidy.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/xtask%2Ftests%2Ftidy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef17ef1ee9fb0ce7149176d12f4d225f6d01401/xtask%2Ftests%2Ftidy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Ftests%2Ftidy.rs?ref=0ef17ef1ee9fb0ce7149176d12f4d225f6d01401", "patch": "@@ -136,7 +136,6 @@ impl TidyDocs {\n         }\n \n         let whitelist = [\n-            \"ra_db\",\n             \"ra_hir\",\n             \"ra_hir_expand\",\n             \"ra_ide\","}]}