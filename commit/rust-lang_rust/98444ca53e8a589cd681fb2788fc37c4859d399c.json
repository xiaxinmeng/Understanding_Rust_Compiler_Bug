{"sha": "98444ca53e8a589cd681fb2788fc37c4859d399c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4NDQ0Y2E1M2U4YTU4OWNkNjgxZmIyNzg4ZmMzN2M0ODU5ZDM5OWM=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-02-10T19:26:24Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-03-14T13:14:13Z"}, "message": "Move opaque_types::unexpected_hidden_region_diagnostic to error_reporting.", "tree": {"sha": "d799f5dc9463a66fa931a38198d56136b6c01ac2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d799f5dc9463a66fa931a38198d56136b6c01ac2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/98444ca53e8a589cd681fb2788fc37c4859d399c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/98444ca53e8a589cd681fb2788fc37c4859d399c", "html_url": "https://github.com/rust-lang/rust/commit/98444ca53e8a589cd681fb2788fc37c4859d399c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/98444ca53e8a589cd681fb2788fc37c4859d399c/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e5259d3eb727244f4196e4a4c835ab0792a1606", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e5259d3eb727244f4196e4a4c835ab0792a1606", "html_url": "https://github.com/rust-lang/rust/commit/3e5259d3eb727244f4196e4a4c835ab0792a1606"}], "stats": {"total": 172, "additions": 85, "deletions": 87}, "files": [{"sha": "85c9e32a195125888bc8d1bb94ad776c745fb3c7", "filename": "src/librustc_infer/infer/error_reporting/mod.rs", "status": "modified", "additions": 81, "deletions": 2, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/98444ca53e8a589cd681fb2788fc37c4859d399c/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98444ca53e8a589cd681fb2788fc37c4859d399c/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs?ref=98444ca53e8a589cd681fb2788fc37c4859d399c", "patch": "@@ -49,7 +49,6 @@ use super::lexical_region_resolve::RegionResolutionError;\n use super::region_constraints::GenericKind;\n use super::{InferCtxt, RegionVariableOrigin, SubregionOrigin, TypeTrace, ValuePairs};\n \n-use crate::infer::opaque_types;\n use crate::infer::{self, SuppressRegionErrors};\n use crate::traits::error_reporting::report_object_safety_error;\n use crate::traits::{\n@@ -288,6 +287,86 @@ fn explain_span(tcx: TyCtxt<'tcx>, heading: &str, span: Span) -> (String, Option\n     (format!(\"the {} at {}:{}\", heading, lo.line, lo.col.to_usize() + 1), Some(span))\n }\n \n+pub fn unexpected_hidden_region_diagnostic(\n+    tcx: TyCtxt<'tcx>,\n+    region_scope_tree: Option<&region::ScopeTree>,\n+    span: Span,\n+    hidden_ty: Ty<'tcx>,\n+    hidden_region: ty::Region<'tcx>,\n+) -> DiagnosticBuilder<'tcx> {\n+    let mut err = struct_span_err!(\n+        tcx.sess,\n+        span,\n+        E0700,\n+        \"hidden type for `impl Trait` captures lifetime that does not appear in bounds\",\n+    );\n+\n+    // Explain the region we are capturing.\n+    if let ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReStatic | ty::ReEmpty(_) = hidden_region {\n+        // Assuming regionck succeeded (*), we ought to always be\n+        // capturing *some* region from the fn header, and hence it\n+        // ought to be free. So under normal circumstances, we will go\n+        // down this path which gives a decent human readable\n+        // explanation.\n+        //\n+        // (*) if not, the `tainted_by_errors` flag would be set to\n+        // true in any case, so we wouldn't be here at all.\n+        note_and_explain_free_region(\n+            tcx,\n+            &mut err,\n+            &format!(\"hidden type `{}` captures \", hidden_ty),\n+            hidden_region,\n+            \"\",\n+        );\n+    } else {\n+        // Ugh. This is a painful case: the hidden region is not one\n+        // that we can easily summarize or explain. This can happen\n+        // in a case like\n+        // `src/test/ui/multiple-lifetimes/ordinary-bounds-unsuited.rs`:\n+        //\n+        // ```\n+        // fn upper_bounds<'a, 'b>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'a, 'b> {\n+        //   if condition() { a } else { b }\n+        // }\n+        // ```\n+        //\n+        // Here the captured lifetime is the intersection of `'a` and\n+        // `'b`, which we can't quite express.\n+\n+        if let Some(region_scope_tree) = region_scope_tree {\n+            // If the `region_scope_tree` is available, this is being\n+            // invoked from the \"region inferencer error\". We can at\n+            // least report a really cryptic error for now.\n+            note_and_explain_region(\n+                tcx,\n+                region_scope_tree,\n+                &mut err,\n+                &format!(\"hidden type `{}` captures \", hidden_ty),\n+                hidden_region,\n+                \"\",\n+            );\n+        } else {\n+            // If the `region_scope_tree` is *unavailable*, this is\n+            // being invoked by the code that comes *after* region\n+            // inferencing. This is a bug, as the region inferencer\n+            // ought to have noticed the failed constraint and invoked\n+            // error reporting, which in turn should have prevented us\n+            // from getting trying to infer the hidden type\n+            // completely.\n+            tcx.sess.delay_span_bug(\n+                span,\n+                &format!(\n+                    \"hidden type captures unexpected lifetime `{:?}` \\\n+                     but no region inference failure\",\n+                    hidden_region,\n+                ),\n+            );\n+        }\n+    }\n+\n+    err\n+}\n+\n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn report_region_errors(\n         &self,\n@@ -410,7 +489,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         span,\n                     } => {\n                         let hidden_ty = self.resolve_vars_if_possible(&hidden_ty);\n-                        opaque_types::unexpected_hidden_region_diagnostic(\n+                        unexpected_hidden_region_diagnostic(\n                             self.tcx,\n                             Some(region_scope_tree),\n                             span,"}, {"sha": "c18c27552813384e0533b31511a2d3710594393f", "filename": "src/librustc_infer/infer/opaque_types/mod.rs", "status": "modified", "additions": 1, "deletions": 83, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/98444ca53e8a589cd681fb2788fc37c4859d399c/src%2Flibrustc_infer%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98444ca53e8a589cd681fb2788fc37c4859d399c/src%2Flibrustc_infer%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fopaque_types%2Fmod.rs?ref=98444ca53e8a589cd681fb2788fc37c4859d399c", "patch": "@@ -1,15 +1,13 @@\n-use crate::infer::error_reporting::{note_and_explain_free_region, note_and_explain_region};\n+use crate::infer::error_reporting::unexpected_hidden_region_diagnostic;\n use crate::infer::{self, InferCtxt, InferOk, TypeVariableOrigin, TypeVariableOriginKind};\n use crate::traits::{self, PredicateObligation};\n-use rustc::middle::region;\n use rustc::session::config::nightly_options;\n use rustc::ty::fold::{BottomUpFolder, TypeFoldable, TypeFolder, TypeVisitor};\n use rustc::ty::free_region_map::FreeRegionRelations;\n use rustc::ty::subst::{GenericArg, GenericArgKind, InternalSubsts, SubstsRef};\n use rustc::ty::{self, GenericParamDefKind, Ty, TyCtxt};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n-use rustc_errors::{struct_span_err, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, DefIdMap};\n use rustc_hir::Node;\n@@ -618,86 +616,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n }\n \n-pub fn unexpected_hidden_region_diagnostic(\n-    tcx: TyCtxt<'tcx>,\n-    region_scope_tree: Option<&region::ScopeTree>,\n-    span: Span,\n-    hidden_ty: Ty<'tcx>,\n-    hidden_region: ty::Region<'tcx>,\n-) -> DiagnosticBuilder<'tcx> {\n-    let mut err = struct_span_err!(\n-        tcx.sess,\n-        span,\n-        E0700,\n-        \"hidden type for `impl Trait` captures lifetime that does not appear in bounds\",\n-    );\n-\n-    // Explain the region we are capturing.\n-    if let ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReStatic | ty::ReEmpty(_) = hidden_region {\n-        // Assuming regionck succeeded (*), we ought to always be\n-        // capturing *some* region from the fn header, and hence it\n-        // ought to be free. So under normal circumstances, we will go\n-        // down this path which gives a decent human readable\n-        // explanation.\n-        //\n-        // (*) if not, the `tainted_by_errors` flag would be set to\n-        // true in any case, so we wouldn't be here at all.\n-        note_and_explain_free_region(\n-            tcx,\n-            &mut err,\n-            &format!(\"hidden type `{}` captures \", hidden_ty),\n-            hidden_region,\n-            \"\",\n-        );\n-    } else {\n-        // Ugh. This is a painful case: the hidden region is not one\n-        // that we can easily summarize or explain. This can happen\n-        // in a case like\n-        // `src/test/ui/multiple-lifetimes/ordinary-bounds-unsuited.rs`:\n-        //\n-        // ```\n-        // fn upper_bounds<'a, 'b>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'a, 'b> {\n-        //   if condition() { a } else { b }\n-        // }\n-        // ```\n-        //\n-        // Here the captured lifetime is the intersection of `'a` and\n-        // `'b`, which we can't quite express.\n-\n-        if let Some(region_scope_tree) = region_scope_tree {\n-            // If the `region_scope_tree` is available, this is being\n-            // invoked from the \"region inferencer error\". We can at\n-            // least report a really cryptic error for now.\n-            note_and_explain_region(\n-                tcx,\n-                region_scope_tree,\n-                &mut err,\n-                &format!(\"hidden type `{}` captures \", hidden_ty),\n-                hidden_region,\n-                \"\",\n-            );\n-        } else {\n-            // If the `region_scope_tree` is *unavailable*, this is\n-            // being invoked by the code that comes *after* region\n-            // inferencing. This is a bug, as the region inferencer\n-            // ought to have noticed the failed constraint and invoked\n-            // error reporting, which in turn should have prevented us\n-            // from getting trying to infer the hidden type\n-            // completely.\n-            tcx.sess.delay_span_bug(\n-                span,\n-                &format!(\n-                    \"hidden type captures unexpected lifetime `{:?}` \\\n-                     but no region inference failure\",\n-                    hidden_region,\n-                ),\n-            );\n-        }\n-    }\n-\n-    err\n-}\n-\n // Visitor that requires that (almost) all regions in the type visited outlive\n // `least_region`. We cannot use `push_outlives_components` because regions in\n // closure signatures are not included in their outlives components. We need to"}, {"sha": "f751a16cfce7c7c53aabe95a9eb076c359d827b7", "filename": "src/librustc_mir/borrow_check/diagnostics/region_errors.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/98444ca53e8a589cd681fb2788fc37c4859d399c/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98444ca53e8a589cd681fb2788fc37c4859d399c/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs?ref=98444ca53e8a589cd681fb2788fc37c4859d399c", "patch": "@@ -4,7 +4,8 @@ use rustc::mir::ConstraintCategory;\n use rustc::ty::{self, RegionVid, Ty};\n use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_infer::infer::{\n-    error_reporting::nice_region_error::NiceRegionError, opaque_types, NLLRegionVariableOrigin,\n+    error_reporting::nice_region_error::NiceRegionError,\n+    error_reporting::unexpected_hidden_region_diagnostic, NLLRegionVariableOrigin,\n };\n use rustc_span::symbol::kw;\n use rustc_span::Span;\n@@ -197,7 +198,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     let region_scope_tree = &self.infcx.tcx.region_scope_tree(self.mir_def_id);\n                     let named_ty = self.regioncx.name_regions(self.infcx.tcx, hidden_ty);\n                     let named_region = self.regioncx.name_regions(self.infcx.tcx, member_region);\n-                    opaque_types::unexpected_hidden_region_diagnostic(\n+                    unexpected_hidden_region_diagnostic(\n                         self.infcx.tcx,\n                         Some(region_scope_tree),\n                         span,"}]}