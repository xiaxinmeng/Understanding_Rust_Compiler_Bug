{"sha": "c186f7c07912064c352f12d8b0aa9d5e5975450e", "node_id": "C_kwDOAAsO6NoAKGMxODZmN2MwNzkxMjA2NGMzNTJmMTJkOGIwYWE5ZDVlNTk3NTQ1MGU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-23T02:50:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-23T02:50:50Z"}, "message": "Auto merge of #96455 - dtolnay:writetmp, r=m-ou-se\n\nMake write/print macros eagerly drop temporaries\n\nThis PR fixes the 2 regressions in #96434 (`println` and `eprintln`) and changes all the other similar macros (`write`, `writeln`, `print`, `eprint`) to match the old pre-#94868 behavior of `println` and `eprintln`.\n\nargument position | before #94868 | after #94868 | after this PR\n--- |:---:|:---:|:---:\n`write!($tmp, \"\u2026\", \u2026)` | :rage: | :rage: | :smiley_cat:\n`write!(\u2026, \"\u2026\", $tmp)` | :rage: | :rage: | :smiley_cat:\n`writeln!($tmp, \"\u2026\", \u2026)` | :rage: | :rage: | :smiley_cat:\n`writeln!(\u2026, \"\u2026\", $tmp)` | :rage: | :rage: | :smiley_cat:\n`print!(\"\u2026\", $tmp)` | :rage: | :rage: | :smiley_cat:\n`println!(\"\u2026\", $tmp)` | :smiley_cat: | :rage: | :smiley_cat:\n`eprint!(\"\u2026\", $tmp)` | :rage: | :rage: | :smiley_cat:\n`eprintln!(\"\u2026\", $tmp)` | :smiley_cat: | :rage: | :smiley_cat:\n`panic!(\"\u2026\", $tmp)` | :smiley_cat: | :smiley_cat: | :smiley_cat:\n\nExample of code that is affected by this change:\n\n```rust\nuse std::sync::Mutex;\n\nfn main() {\n    let mutex = Mutex::new(0);\n    print!(\"{}\", mutex.lock().unwrap()) /* no semicolon */\n}\n```\n\nYou can see several real-world examples like this in the Crater links at the top of #96434. This code failed to compile prior to this PR as follows, but works after this PR.\n\n```console\nerror[E0597]: `mutex` does not live long enough\n --> src/main.rs:5:18\n  |\n5 |     print!(\"{}\", mutex.lock().unwrap()) /* no semicolon */\n  |                  ^^^^^^^^^^^^---------\n  |                  |\n  |                  borrowed value does not live long enough\n  |                  a temporary with access to the borrow is created here ...\n6 | }\n  | -\n  | |\n  | `mutex` dropped here while still borrowed\n  | ... and the borrow might be used here, when that temporary is dropped and runs the `Drop` code for type `MutexGuard`\n```", "tree": {"sha": "f791b663b1429bba82b47a855006617c551a6805", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f791b663b1429bba82b47a855006617c551a6805"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c186f7c07912064c352f12d8b0aa9d5e5975450e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c186f7c07912064c352f12d8b0aa9d5e5975450e", "html_url": "https://github.com/rust-lang/rust/commit/c186f7c07912064c352f12d8b0aa9d5e5975450e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c186f7c07912064c352f12d8b0aa9d5e5975450e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d12557407c7c34f1599cfba79666954291810859", "url": "https://api.github.com/repos/rust-lang/rust/commits/d12557407c7c34f1599cfba79666954291810859", "html_url": "https://github.com/rust-lang/rust/commit/d12557407c7c34f1599cfba79666954291810859"}, {"sha": "a6100988ff63ff9e2f9a0693f51cb8aa06f5cf9f", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6100988ff63ff9e2f9a0693f51cb8aa06f5cf9f", "html_url": "https://github.com/rust-lang/rust/commit/a6100988ff63ff9e2f9a0693f51cb8aa06f5cf9f"}], "stats": {"total": 132, "additions": 118, "deletions": 14}, "files": [{"sha": "dbc3d2923ed59b93cf9f7a7f95dba0947f4dd57c", "filename": "library/core/src/macros/mod.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c186f7c07912064c352f12d8b0aa9d5e5975450e/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c186f7c07912064c352f12d8b0aa9d5e5975450e/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs?ref=c186f7c07912064c352f12d8b0aa9d5e5975450e", "patch": "@@ -496,9 +496,10 @@ macro_rules! r#try {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"write_macro\")]\n macro_rules! write {\n-    ($dst:expr, $($arg:tt)*) => {\n-        $dst.write_fmt($crate::format_args!($($arg)*))\n-    };\n+    ($dst:expr, $($arg:tt)*) => {{\n+        let result = $dst.write_fmt($crate::format_args!($($arg)*));\n+        result\n+    }};\n }\n \n /// Write formatted data into a buffer, with a newline appended.\n@@ -553,9 +554,10 @@ macro_rules! writeln {\n     ($dst:expr $(,)?) => {\n         $crate::write!($dst, \"\\n\")\n     };\n-    ($dst:expr, $($arg:tt)*) => {\n-        $dst.write_fmt($crate::format_args_nl!($($arg)*))\n-    };\n+    ($dst:expr, $($arg:tt)*) => {{\n+        let result = $dst.write_fmt($crate::format_args_nl!($($arg)*));\n+        result\n+    }};\n }\n \n /// Indicates unreachable code."}, {"sha": "0cb21ef53b1ebae876d6d3d72f6d7ea9e21c804d", "filename": "library/std/src/macros.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c186f7c07912064c352f12d8b0aa9d5e5975450e/library%2Fstd%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c186f7c07912064c352f12d8b0aa9d5e5975450e/library%2Fstd%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fmacros.rs?ref=c186f7c07912064c352f12d8b0aa9d5e5975450e", "patch": "@@ -62,9 +62,9 @@ macro_rules! panic {\n #[cfg_attr(not(test), rustc_diagnostic_item = \"print_macro\")]\n #[allow_internal_unstable(print_internals)]\n macro_rules! print {\n-    ($($arg:tt)*) => {\n-        $crate::io::_print($crate::format_args!($($arg)*))\n-    };\n+    ($($arg:tt)*) => {{\n+        $crate::io::_print($crate::format_args!($($arg)*));\n+    }};\n }\n \n /// Prints to the standard output, with a newline.\n@@ -133,9 +133,9 @@ macro_rules! println {\n #[cfg_attr(not(test), rustc_diagnostic_item = \"eprint_macro\")]\n #[allow_internal_unstable(print_internals)]\n macro_rules! eprint {\n-    ($($arg:tt)*) => {\n-        $crate::io::_eprint($crate::format_args!($($arg)*))\n-    };\n+    ($($arg:tt)*) => {{\n+        $crate::io::_eprint($crate::format_args!($($arg)*));\n+    }};\n }\n \n /// Prints to the standard error, with a newline."}, {"sha": "ddd4c9754bfa44e2205b33a2792ed02312ba2da0", "filename": "src/test/ui/macros/format-args-temporaries.rs", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/c186f7c07912064c352f12d8b0aa9d5e5975450e/src%2Ftest%2Fui%2Fmacros%2Fformat-args-temporaries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c186f7c07912064c352f12d8b0aa9d5e5975450e/src%2Ftest%2Fui%2Fmacros%2Fformat-args-temporaries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fformat-args-temporaries.rs?ref=c186f7c07912064c352f12d8b0aa9d5e5975450e", "patch": "@@ -0,0 +1,70 @@\n+// check-pass\n+\n+use std::fmt::{self, Display};\n+\n+struct Mutex;\n+\n+impl Mutex {\n+    fn lock(&self) -> MutexGuard {\n+        MutexGuard(self)\n+    }\n+}\n+\n+struct MutexGuard<'a>(&'a Mutex);\n+\n+impl<'a> Drop for MutexGuard<'a> {\n+    fn drop(&mut self) {\n+        // Empty but this is a necessary part of the repro. Otherwise borrow\n+        // checker is fine with 'a dangling at the time that MutexGuard goes out\n+        // of scope.\n+    }\n+}\n+\n+impl<'a> MutexGuard<'a> {\n+    fn write_fmt(&self, _args: fmt::Arguments) {}\n+}\n+\n+impl<'a> Display for MutexGuard<'a> {\n+    fn fmt(&self, _formatter: &mut fmt::Formatter) -> fmt::Result {\n+        Ok(())\n+    }\n+}\n+\n+fn main() {\n+    let _write = {\n+        let out = Mutex;\n+        let mutex = Mutex;\n+        write!(out.lock(), \"{}\", mutex.lock()) /* no semicolon */\n+    };\n+\n+    let _writeln = {\n+        let out = Mutex;\n+        let mutex = Mutex;\n+        writeln!(out.lock(), \"{}\", mutex.lock()) /* no semicolon */\n+    };\n+\n+    let _print = {\n+        let mutex = Mutex;\n+        print!(\"{}\", mutex.lock()) /* no semicolon */\n+    };\n+\n+    let _println = {\n+        let mutex = Mutex;\n+        println!(\"{}\", mutex.lock()) /* no semicolon */\n+    };\n+\n+    let _eprint = {\n+        let mutex = Mutex;\n+        eprint!(\"{}\", mutex.lock()) /* no semicolon */\n+    };\n+\n+    let _eprintln = {\n+        let mutex = Mutex;\n+        eprintln!(\"{}\", mutex.lock()) /* no semicolon */\n+    };\n+\n+    let _panic = {\n+        let mutex = Mutex;\n+        panic!(\"{}\", mutex.lock()) /* no semicolon */\n+    };\n+}"}, {"sha": "d8f765b288a6c20a624ee4a980b4615e2ddad85b", "filename": "src/tools/clippy/clippy_lints/src/explicit_write.rs", "status": "modified", "additions": 34, "deletions": 2, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c186f7c07912064c352f12d8b0aa9d5e5975450e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexplicit_write.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c186f7c07912064c352f12d8b0aa9d5e5975450e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexplicit_write.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexplicit_write.rs?ref=c186f7c07912064c352f12d8b0aa9d5e5975450e", "patch": "@@ -4,7 +4,8 @@ use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::{is_expn_of, match_function_call, paths};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{Expr, ExprKind};\n+use rustc_hir::def::Res;\n+use rustc_hir::{BindingAnnotation, Block, BlockCheckMode, Expr, ExprKind, Node, PatKind, QPath, Stmt, StmtKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::sym;\n@@ -39,7 +40,7 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitWrite {\n             if let ExprKind::MethodCall(unwrap_fun, [write_call], _) = expr.kind;\n             if unwrap_fun.ident.name == sym::unwrap;\n             // match call to write_fmt\n-            if let ExprKind::MethodCall(write_fun, [write_recv, write_arg], _) = write_call.kind;\n+            if let ExprKind::MethodCall(write_fun, [write_recv, write_arg], _) = look_in_block(cx, &write_call.kind);\n             if write_fun.ident.name == sym!(write_fmt);\n             // match calls to std::io::stdout() / std::io::stderr ()\n             if let Some(dest_name) = if match_function_call(cx, write_recv, &paths::STDOUT).is_some() {\n@@ -100,3 +101,34 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitWrite {\n         }\n     }\n }\n+\n+/// If `kind` is a block that looks like `{ let result = $expr; result }` then\n+/// returns $expr. Otherwise returns `kind`.\n+fn look_in_block<'tcx, 'hir>(cx: &LateContext<'tcx>, kind: &'tcx ExprKind<'hir>) -> &'tcx ExprKind<'hir> {\n+    if_chain! {\n+        if let ExprKind::Block(block, _label @ None) = kind;\n+        if let Block {\n+            stmts: [Stmt { kind: StmtKind::Local(local), .. }],\n+            expr: Some(expr_end_of_block),\n+            rules: BlockCheckMode::DefaultBlock,\n+            ..\n+        } = block;\n+\n+        // Find id of the local that expr_end_of_block resolves to\n+        if let ExprKind::Path(QPath::Resolved(None, expr_path)) = expr_end_of_block.kind;\n+        if let Res::Local(expr_res) = expr_path.res;\n+        if let Some(Node::Binding(res_pat)) = cx.tcx.hir().find(expr_res);\n+\n+        // Find id of the local we found in the block\n+        if let PatKind::Binding(BindingAnnotation::Unannotated, local_hir_id, _ident, None) = local.pat.kind;\n+\n+        // If those two are the same hir id\n+        if res_pat.hir_id == local_hir_id;\n+\n+        if let Some(init) = local.init;\n+        then {\n+            return &init.kind;\n+        }\n+    }\n+    kind\n+}"}]}