{"sha": "c9188c83015e25978b9c6c4864040dd958bc54b1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5MTg4YzgzMDE1ZTI1OTc4YjljNmM0ODY0MDQwZGQ5NThiYzU0YjE=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-03-27T00:34:49Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-03-27T14:04:10Z"}, "message": "std: fix json PrettyEncoder and add tests", "tree": {"sha": "847f66417a729388544a5bb9b7917f9c15d2cfab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/847f66417a729388544a5bb9b7917f9c15d2cfab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c9188c83015e25978b9c6c4864040dd958bc54b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c9188c83015e25978b9c6c4864040dd958bc54b1", "html_url": "https://github.com/rust-lang/rust/commit/c9188c83015e25978b9c6c4864040dd958bc54b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c9188c83015e25978b9c6c4864040dd958bc54b1/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6cf99fa54a51c728abf75f899f4f947673835268", "url": "https://api.github.com/repos/rust-lang/rust/commits/6cf99fa54a51c728abf75f899f4f947673835268", "html_url": "https://github.com/rust-lang/rust/commit/6cf99fa54a51c728abf75f899f4f947673835268"}], "stats": {"total": 253, "additions": 220, "deletions": 33}, "files": [{"sha": "bbca4805d48e9cb7b43d506e4c2de5af2cea29d2", "filename": "src/libstd/json.rs", "status": "modified", "additions": 220, "deletions": 33, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/c9188c83015e25978b9c6c4864040dd958bc54b1/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9188c83015e25978b9c6c4864040dd958bc54b1/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=c9188c83015e25978b9c6c4864040dd958bc54b1", "patch": "@@ -140,9 +140,9 @@ impl serialize::Encoder for Encoder {\n         // we'd have to change the expansion of auto-encode to pass\n         // those along.\n \n-        if (name == ~\"Some\") {\n+        if name == ~\"Some\" {\n             f();\n-        } else if (name == ~\"None\") {\n+        } else if name == ~\"None\" {\n             self.wr.write_str(~\"null\");\n         } else {\n             self.wr.write_char('[');\n@@ -250,27 +250,57 @@ impl serialize::Encoder for PrettyEncoder {\n     fn emit_owned(&self, f: &fn()) { f() }\n     fn emit_managed(&self, f: &fn()) { f() }\n \n-    fn emit_enum(&self, name: &str, f: &fn()) {\n-        if name != \"option\" { fail!(~\"only supports option enum\") }\n-        f()\n-    }\n-    fn emit_enum_variant(&self, _name: &str, id: uint, _cnt: uint, f: &fn()) {\n-        if id == 0 {\n+    fn emit_enum(&self, _name: &str, f: &fn()) { f() }\n+    fn emit_enum_variant(&self, name: &str, _id: uint, cnt: uint, f: &fn()) {\n+        if name == ~\"Some\" {\n+            f();\n+        } else if name == ~\"None\" {\n             self.emit_nil();\n         } else {\n-            f()\n+            self.wr.write_char('[');\n+            self.indent += 2;\n+            self.wr.write_char('\\n');\n+            self.wr.write_str(spaces(self.indent));\n+            self.wr.write_str(escape_str(name));\n+            if cnt == 0 {\n+                self.wr.write_str(\",\\n\");\n+                self.wr.write_str(spaces(self.indent));\n+                self.wr.write_str(\"[]\\n\");\n+            } else {\n+                self.wr.write_str(\",\\n\");\n+                self.wr.write_str(spaces(self.indent));\n+                self.wr.write_str(\"[\\n\");\n+                self.indent += 2;\n+                f();\n+                self.wr.write_char('\\n');\n+                self.indent -= 2;\n+                self.wr.write_str(spaces(self.indent));\n+                self.wr.write_str(\"]\\n\");\n+            }\n+            self.indent -= 2;\n+            self.wr.write_char(']');\n         }\n     }\n-    fn emit_enum_variant_arg(&self, _idx: uint, f: &fn()) {\n+    fn emit_enum_variant_arg(&self, idx: uint, f: &fn()) {\n+        if idx != 0 {\n+            self.wr.write_str(\",\\n\");\n+        }\n+        self.wr.write_str(spaces(self.indent));\n         f()\n     }\n \n-    fn emit_borrowed_vec(&self, _len: uint, f: &fn()) {\n-        self.wr.write_char('[');\n-        self.indent += 2;\n-        f();\n-        self.indent -= 2;\n-        self.wr.write_char(']');\n+    fn emit_borrowed_vec(&self, len: uint, f: &fn()) {\n+        if len == 0 {\n+            self.wr.write_str(\"[]\");\n+        } else {\n+            self.wr.write_char('[');\n+            self.indent += 2;\n+            f();\n+            self.wr.write_char('\\n');\n+            self.indent -= 2;\n+            self.wr.write_str(spaces(self.indent));\n+            self.wr.write_char(']');\n+        }\n     }\n     fn emit_owned_vec(&self, len: uint, f: &fn()) {\n         self.emit_borrowed_vec(len, f)\n@@ -292,11 +322,17 @@ impl serialize::Encoder for PrettyEncoder {\n         self.wr.write_char('{');\n         self.indent += 2;\n         f();\n+        self.wr.write_char('\\n');\n         self.indent -= 2;\n+        self.wr.write_str(spaces(self.indent));\n         self.wr.write_char('}');\n     }\n-    fn emit_struct(&self, _name: &str, _len: uint, f: &fn()) {\n-        self.emit_rec(f)\n+    fn emit_struct(&self, _name: &str, len: uint, f: &fn()) {\n+        if len == 0 {\n+            self.wr.write_str(\"{}\");\n+        } else {\n+            self.emit_rec(f)\n+        }\n     }\n     fn emit_field(&self, name: &str, idx: uint, f: &fn()) {\n         if idx == 0 {\n@@ -1248,13 +1284,97 @@ mod tests {\n         ])), ~\"[false,null,[\\\"foo\\\\nbar\\\",3.5]]\");\n     }\n \n+    #[test]\n+    fn test_write_list_pretty() {\n+        assert_eq!(to_pretty_str(&List(~[])), ~\"[]\");\n+        assert_eq!(\n+            to_pretty_str(&List(~[Boolean(true)])),\n+            ~\"\\\n+            [\\n  \\\n+                true\\n\\\n+            ]\"\n+        );\n+        assert_eq!(\n+            to_pretty_str(&List(~[\n+                Boolean(false),\n+                Null,\n+                List(~[String(~\"foo\\nbar\"), Number(3.5f)])\n+            ])),\n+            ~\"\\\n+            [\\n  \\\n+                false,\\n  \\\n+                null,\\n  \\\n+                [\\n    \\\n+                    \\\"foo\\\\nbar\\\",\\n    \\\n+                    3.5\\n  \\\n+                ]\\n\\\n+            ]\"\n+        );\n+    }\n+\n     #[test]\n     fn test_write_object() {\n         assert_eq!(to_str(&mk_object(~[])), ~\"{}\");\n         assert_eq!(\n             to_str(&mk_object(~[(~\"a\", Boolean(true))])),\n             ~\"{\\\"a\\\":true}\"\n         );\n+        assert_eq!(\n+            to_str(&mk_object(~[\n+                (~\"b\", List(~[\n+                    mk_object(~[(~\"c\", String(~\"\\x0c\\r\"))]),\n+                    mk_object(~[(~\"d\", String(~\"\"))])\n+                ]))\n+            ])),\n+            ~\"{\\\n+                \\\"b\\\":[\\\n+                    {\\\"c\\\":\\\"\\\\f\\\\r\\\"},\\\n+                    {\\\"d\\\":\\\"\\\"}\\\n+                ]\\\n+            }\"\n+        );\n+        let a = mk_object(~[\n+            (~\"a\", Boolean(true)),\n+            (~\"b\", List(~[\n+                mk_object(~[(~\"c\", String(~\"\\x0c\\r\"))]),\n+                mk_object(~[(~\"d\", String(~\"\"))])\n+            ]))\n+        ]);\n+        // We can't compare the strings directly because the object fields be\n+        // printed in a different order.\n+        let b = from_str(to_str(&a)).unwrap();\n+        assert_eq!(a, b);\n+    }\n+\n+    #[test]\n+    fn test_write_object_pretty() {\n+        assert_eq!(to_pretty_str(&mk_object(~[])), ~\"{\\n}\");\n+        assert_eq!(\n+            to_pretty_str(&mk_object(~[(~\"a\", Boolean(true))])),\n+            ~\"\\\n+            {\\n  \\\n+                \\\"a\\\": true\\n\\\n+            }\"\n+        );\n+        assert_eq!(\n+            to_pretty_str(&mk_object(~[\n+                (~\"b\", List(~[\n+                    mk_object(~[(~\"c\", String(~\"\\x0c\\r\"))]),\n+                    mk_object(~[(~\"d\", String(~\"\"))])\n+                ]))\n+            ])),\n+            ~\"\\\n+            {\\n  \\\n+                \\\"b\\\": [\\n    \\\n+                    {\\n      \\\n+                        \\\"c\\\": \\\"\\\\f\\\\r\\\"\\n    \\\n+                    },\\n    \\\n+                    {\\n      \\\n+                        \\\"d\\\": \\\"\\\"\\n    \\\n+                    }\\n  \\\n+                ]\\n\\\n+            }\"\n+        );\n         let a = mk_object(~[\n             (~\"a\", Boolean(true)),\n             (~\"b\", List(~[\n@@ -1268,24 +1388,71 @@ mod tests {\n         assert_eq!(a, b);\n     }\n \n+    #[auto_encode]\n+    enum Animal {\n+        Dog,\n+        Frog(~str, int)\n+    }\n+\n     #[test]\n-    fn test_write_enum () {\n+    fn test_write_enum_no_args() {\n+        let animal = Dog;\n+\n         let s = do io::with_str_writer |wr| {\n-            let encoder = &Encoder(wr) as &serialize::Encoder;\n-            do encoder.emit_enum(~\"animal\") {\n-                do encoder.emit_enum_variant(~\"frog\",37,1242) {\n-                    // name of frog:\n-                    do encoder.emit_enum_variant_arg(0) {\n-                        encoder.emit_owned_str(~\"Henry\")\n-                    }\n-                    // mass of frog in grams:\n-                    do encoder.emit_enum_variant_arg(1) {\n-                        encoder.emit_int(349);\n-                    }\n-                }\n-            }\n+            let encoder = Encoder(wr);\n+            animal.encode(&encoder);\n+        };\n+        assert_eq!(s, ~\"[\\\"Dog\\\",[]]\");\n+    }\n+\n+    #[test]\n+    fn test_write_enum_no_args_pretty() {\n+        let animal = Dog;\n+\n+        let s = do io::with_str_writer |wr| {\n+            let encoder = PrettyEncoder(wr);\n+            animal.encode(&encoder);\n+        };\n+        assert_eq!(\n+            s,\n+            ~\"\\\n+            [\\n  \\\n+                \\\"Dog\\\",\\n  \\\n+                []\\n\\\n+            ]\"\n+        );\n+    }\n+\n+    #[test]\n+    fn test_write_enum_multiple_args() {\n+        let animal = Frog(~\"Henry\", 349);\n+\n+        let s = do io::with_str_writer |wr| {\n+            let encoder = Encoder(wr);\n+            animal.encode(&encoder);\n         };\n-        assert_eq!(s, ~\"[\\\"frog\\\",[\\\"Henry\\\",349]]\");\n+        assert_eq!(s, ~\"[\\\"Frog\\\",[\\\"Henry\\\",349]]\");\n+    }\n+\n+    #[test]\n+    fn test_write_enum_multiple_args_pretty() {\n+        let animal = Frog(~\"Henry\", 349);\n+\n+        let s = do io::with_str_writer |wr| {\n+            let encoder = PrettyEncoder(wr);\n+            animal.encode(&encoder);\n+        };\n+        assert_eq!(\n+            s,\n+            ~\"\\\n+            [\\n  \\\n+                \\\"Frog\\\",\\n  \\\n+                [\\n    \\\n+                    \\\"Henry\\\",\\n    \\\n+                    349\\n  \\\n+                ]\\n\\\n+            ]\"\n+        );\n     }\n \n     #[test]\n@@ -1298,6 +1465,16 @@ mod tests {\n         assert_eq!(s, ~\"\\\"jodhpurs\\\"\");\n     }\n \n+    #[test]\n+    fn test_write_some_pretty() {\n+        let value = Some(~\"jodhpurs\");\n+        let s = do io::with_str_writer |wr| {\n+            let encoder = PrettyEncoder(wr);\n+            value.encode(&encoder);\n+        };\n+        assert_eq!(s, ~\"\\\"jodhpurs\\\"\");\n+    }\n+\n     #[test]\n     fn test_write_none() {\n         let value: Option<~str> = None;\n@@ -1308,6 +1485,16 @@ mod tests {\n         assert_eq!(s, ~\"null\");\n     }\n \n+    #[test]\n+    fn test_write_none_pretty() {\n+        let value: Option<~str> = None;\n+        let s = do io::with_str_writer |wr| {\n+            let encoder = Encoder(wr);\n+            value.encode(&encoder);\n+        };\n+        assert_eq!(s, ~\"null\");\n+    }\n+\n     #[test]\n     fn test_trailing_characters() {\n         assert_eq!(from_str(~\"nulla\"),"}]}