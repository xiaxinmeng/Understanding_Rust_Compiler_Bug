{"sha": "511743c438c4cb1511b97fb851585d57492d7642", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxMTc0M2M0MzhjNGNiMTUxMWI5N2ZiODUxNTg1ZDU3NDkyZDc2NDI=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-12-01T12:31:47Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-12-01T16:47:36Z"}, "message": "MIR: s/Lvalue/Place in type names.", "tree": {"sha": "a945cd96e0ddae15ee179171fe0185ebc893278b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a945cd96e0ddae15ee179171fe0185ebc893278b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/511743c438c4cb1511b97fb851585d57492d7642", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/511743c438c4cb1511b97fb851585d57492d7642", "html_url": "https://github.com/rust-lang/rust/commit/511743c438c4cb1511b97fb851585d57492d7642", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/511743c438c4cb1511b97fb851585d57492d7642/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e3ed21272d5f50c37c09f2a7f06c40f56b6ac298", "url": "https://api.github.com/repos/rust-lang/rust/commits/e3ed21272d5f50c37c09f2a7f06c40f56b6ac298", "html_url": "https://github.com/rust-lang/rust/commit/e3ed21272d5f50c37c09f2a7f06c40f56b6ac298"}], "stats": {"total": 1438, "additions": 719, "deletions": 719}, "files": [{"sha": "8ea60cf442c66e6cdfe96ac98be767022fc82501", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -318,19 +318,19 @@ impl<'gcx, T> HashStable<StableHashingContext<'gcx>>\n \n impl_stable_hash_for!(enum mir::ValidationOp { Acquire, Release, Suspend(region_scope) });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Lvalue<'gcx> {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Place<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n-            mir::Lvalue::Local(ref local) => {\n+            mir::Place::Local(ref local) => {\n                 local.hash_stable(hcx, hasher);\n             }\n-            mir::Lvalue::Static(ref statik) => {\n+            mir::Place::Static(ref statik) => {\n                 statik.hash_stable(hcx, hasher);\n             }\n-            mir::Lvalue::Projection(ref lvalue_projection) => {\n+            mir::Place::Projection(ref lvalue_projection) => {\n                 lvalue_projection.hash_stable(hcx, hasher);\n             }\n         }"}, {"sha": "05b131dc355c2f14c28d603fe549624662013f56", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -21,7 +21,7 @@ use hir::def_id::DefId;\n use middle::free_region::{FreeRegionMap, RegionRelations};\n use middle::region;\n use middle::lang_items;\n-use mir::tcx::LvalueTy;\n+use mir::tcx::PlaceTy;\n use ty::subst::{Kind, Subst, Substs};\n use ty::{TyVid, IntVid, FloatVid};\n use ty::{self, Ty, TyCtxt};\n@@ -518,15 +518,15 @@ impl_trans_normalize!('gcx,\n     ty::ExistentialTraitRef<'gcx>\n );\n \n-impl<'gcx> TransNormalize<'gcx> for LvalueTy<'gcx> {\n+impl<'gcx> TransNormalize<'gcx> for PlaceTy<'gcx> {\n     fn trans_normalize<'a, 'tcx>(&self,\n                                  infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                  param_env: ty::ParamEnv<'tcx>)\n                                  -> Self {\n         match *self {\n-            LvalueTy::Ty { ty } => LvalueTy::Ty { ty: ty.trans_normalize(infcx, param_env) },\n-            LvalueTy::Downcast { adt_def, substs, variant_index } => {\n-                LvalueTy::Downcast {\n+            PlaceTy::Ty { ty } => PlaceTy::Ty { ty: ty.trans_normalize(infcx, param_env) },\n+            PlaceTy::Downcast { adt_def, substs, variant_index } => {\n+                PlaceTy::Downcast {\n                     adt_def,\n                     substs: substs.trans_normalize(infcx, param_env),\n                     variant_index,"}, {"sha": "0123ff7c5298985c10dd75118cebcaaf4999adc5", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -641,14 +641,14 @@ pub enum TerminatorKind<'tcx> {\n     /// Indicates a terminator that can never be reached.\n     Unreachable,\n \n-    /// Drop the Lvalue\n+    /// Drop the Place\n     Drop {\n-        location: Lvalue<'tcx>,\n+        location: Place<'tcx>,\n         target: BasicBlock,\n         unwind: Option<BasicBlock>\n     },\n \n-    /// Drop the Lvalue and assign the new value over it. This ensures\n+    /// Drop the Place and assign the new value over it. This ensures\n     /// that the assignment to LV occurs *even if* the destructor for\n     /// lvalue unwinds. Its semantics are best explained by by the\n     /// elaboration:\n@@ -675,7 +675,7 @@ pub enum TerminatorKind<'tcx> {\n     /// }\n     /// ```\n     DropAndReplace {\n-        location: Lvalue<'tcx>,\n+        location: Place<'tcx>,\n         value: Operand<'tcx>,\n         target: BasicBlock,\n         unwind: Option<BasicBlock>,\n@@ -691,7 +691,7 @@ pub enum TerminatorKind<'tcx> {\n         /// reused across function calls without duplicating the contents.\n         args: Vec<Operand<'tcx>>,\n         /// Destination for the return value. If some, the call is converging.\n-        destination: Option<(Lvalue<'tcx>, BasicBlock)>,\n+        destination: Option<(Place<'tcx>, BasicBlock)>,\n         /// Cleanups to be done if the call unwinds.\n         cleanup: Option<BasicBlock>\n     },\n@@ -1002,11 +1002,11 @@ impl<'tcx> Statement<'tcx> {\n \n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub enum StatementKind<'tcx> {\n-    /// Write the RHS Rvalue to the LHS Lvalue.\n-    Assign(Lvalue<'tcx>, Rvalue<'tcx>),\n+    /// Write the RHS Rvalue to the LHS Place.\n+    Assign(Place<'tcx>, Rvalue<'tcx>),\n \n-    /// Write the discriminant for a variant to the enum Lvalue.\n-    SetDiscriminant { lvalue: Lvalue<'tcx>, variant_index: usize },\n+    /// Write the discriminant for a variant to the enum Place.\n+    SetDiscriminant { lvalue: Place<'tcx>, variant_index: usize },\n \n     /// Start a live range for the storage of the local.\n     StorageLive(Local),\n@@ -1017,14 +1017,14 @@ pub enum StatementKind<'tcx> {\n     /// Execute a piece of inline Assembly.\n     InlineAsm {\n         asm: Box<InlineAsm>,\n-        outputs: Vec<Lvalue<'tcx>>,\n+        outputs: Vec<Place<'tcx>>,\n         inputs: Vec<Operand<'tcx>>\n     },\n \n     /// Assert the given lvalues to be valid inhabitants of their type.  These statements are\n     /// currently only interpreted by miri and only generated when \"-Z mir-emit-validate\" is passed.\n     /// See <https://internals.rust-lang.org/t/types-as-contracts/5562/73> for more details.\n-    Validate(ValidationOp, Vec<ValidationOperand<'tcx, Lvalue<'tcx>>>),\n+    Validate(ValidationOp, Vec<ValidationOperand<'tcx, Place<'tcx>>>),\n \n     /// Mark one terminating point of a region scope (i.e. static region).\n     /// (The starting point(s) arise implicitly from borrows.)\n@@ -1107,20 +1107,20 @@ impl<'tcx> Debug for Statement<'tcx> {\n }\n \n ///////////////////////////////////////////////////////////////////////////\n-// Lvalues\n+// Places\n \n /// A path to a value; something that can be evaluated without\n /// changing or disturbing program state.\n #[derive(Clone, PartialEq, RustcEncodable, RustcDecodable)]\n-pub enum Lvalue<'tcx> {\n+pub enum Place<'tcx> {\n     /// local variable\n     Local(Local),\n \n     /// static or static mut variable\n     Static(Box<Static<'tcx>>),\n \n     /// projection out of an lvalue (access a field, deref a pointer, etc)\n-    Projection(Box<LvalueProjection<'tcx>>),\n+    Projection(Box<PlaceProjection<'tcx>>),\n }\n \n /// The def-id of a static, along with its normalized type (which is\n@@ -1138,8 +1138,8 @@ impl_stable_hash_for!(struct Static<'tcx> {\n \n /// The `Projection` data structure defines things of the form `B.x`\n /// or `*B` or `B[index]`. Note that it is parameterized because it is\n-/// shared between `Constant` and `Lvalue`. See the aliases\n-/// `LvalueProjection` etc below.\n+/// shared between `Constant` and `Place`. See the aliases\n+/// `PlaceProjection` etc below.\n #[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct Projection<'tcx, B, V, T> {\n     pub base: B,\n@@ -1186,42 +1186,42 @@ pub enum ProjectionElem<'tcx, V, T> {\n \n /// Alias for projections as they appear in lvalues, where the base is an lvalue\n /// and the index is a local.\n-pub type LvalueProjection<'tcx> = Projection<'tcx, Lvalue<'tcx>, Local, Ty<'tcx>>;\n+pub type PlaceProjection<'tcx> = Projection<'tcx, Place<'tcx>, Local, Ty<'tcx>>;\n \n /// Alias for projections as they appear in lvalues, where the base is an lvalue\n /// and the index is a local.\n-pub type LvalueElem<'tcx> = ProjectionElem<'tcx, Local, Ty<'tcx>>;\n+pub type PlaceElem<'tcx> = ProjectionElem<'tcx, Local, Ty<'tcx>>;\n \n newtype_index!(Field { DEBUG_FORMAT = \"field[{}]\" });\n \n-impl<'tcx> Lvalue<'tcx> {\n-    pub fn field(self, f: Field, ty: Ty<'tcx>) -> Lvalue<'tcx> {\n+impl<'tcx> Place<'tcx> {\n+    pub fn field(self, f: Field, ty: Ty<'tcx>) -> Place<'tcx> {\n         self.elem(ProjectionElem::Field(f, ty))\n     }\n \n-    pub fn deref(self) -> Lvalue<'tcx> {\n+    pub fn deref(self) -> Place<'tcx> {\n         self.elem(ProjectionElem::Deref)\n     }\n \n-    pub fn downcast(self, adt_def: &'tcx AdtDef, variant_index: usize) -> Lvalue<'tcx> {\n+    pub fn downcast(self, adt_def: &'tcx AdtDef, variant_index: usize) -> Place<'tcx> {\n         self.elem(ProjectionElem::Downcast(adt_def, variant_index))\n     }\n \n-    pub fn index(self, index: Local) -> Lvalue<'tcx> {\n+    pub fn index(self, index: Local) -> Place<'tcx> {\n         self.elem(ProjectionElem::Index(index))\n     }\n \n-    pub fn elem(self, elem: LvalueElem<'tcx>) -> Lvalue<'tcx> {\n-        Lvalue::Projection(Box::new(LvalueProjection {\n+    pub fn elem(self, elem: PlaceElem<'tcx>) -> Place<'tcx> {\n+        Place::Projection(Box::new(PlaceProjection {\n             base: self,\n             elem,\n         }))\n     }\n }\n \n-impl<'tcx> Debug for Lvalue<'tcx> {\n+impl<'tcx> Debug for Place<'tcx> {\n     fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {\n-        use self::Lvalue::*;\n+        use self::Place::*;\n \n         match *self {\n             Local(id) => write!(fmt, \"{:?}\", id),\n@@ -1281,13 +1281,13 @@ pub enum Operand<'tcx> {\n     ///\n     /// This implies that the type of the lvalue must be `Copy`; this is true\n     /// by construction during build, but also checked by the MIR type checker.\n-    Copy(Lvalue<'tcx>),\n+    Copy(Place<'tcx>),\n     /// Move: The value (including old borrows of it) will not be used again.\n     ///\n     /// Safe for values of all types (modulo future developments towards `?Move`).\n     /// Correct usage patterns are enforced by the borrow checker for safe code.\n     /// `Copy` may be converted to `Move` to enable \"last-use\" optimizations.\n-    Move(Lvalue<'tcx>),\n+    Move(Place<'tcx>),\n     Constant(Box<Constant<'tcx>>),\n }\n \n@@ -1336,10 +1336,10 @@ pub enum Rvalue<'tcx> {\n     Repeat(Operand<'tcx>, ConstUsize),\n \n     /// &x or &mut x\n-    Ref(Region<'tcx>, BorrowKind, Lvalue<'tcx>),\n+    Ref(Region<'tcx>, BorrowKind, Place<'tcx>),\n \n     /// length of a [X] or [X;n] value\n-    Len(Lvalue<'tcx>),\n+    Len(Place<'tcx>),\n \n     Cast(CastKind, Operand<'tcx>, Ty<'tcx>),\n \n@@ -1353,7 +1353,7 @@ pub enum Rvalue<'tcx> {\n     ///\n     /// Undefined (i.e. no effort is made to make it defined, but there\u2019s no reason why it cannot\n     /// be defined to return, say, a 0) if ADT is not an enum.\n-    Discriminant(Lvalue<'tcx>),\n+    Discriminant(Place<'tcx>),\n \n     /// Create an aggregate value, like a tuple or struct.  This is\n     /// only needed because we want to distinguish `dest = Foo { x:\n@@ -1828,7 +1828,7 @@ impl<'tcx> TypeFoldable<'tcx> for BasicBlockData<'tcx> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ValidationOperand<'tcx, Lvalue<'tcx>> {\n+impl<'tcx> TypeFoldable<'tcx> for ValidationOperand<'tcx, Place<'tcx>> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ValidationOperand {\n             lval: self.lval.fold_with(folder),\n@@ -2012,16 +2012,16 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for Lvalue<'tcx> {\n+impl<'tcx> TypeFoldable<'tcx> for Place<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         match self {\n-            &Lvalue::Projection(ref p) => Lvalue::Projection(p.fold_with(folder)),\n+            &Place::Projection(ref p) => Place::Projection(p.fold_with(folder)),\n             _ => self.clone()\n         }\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        if let &Lvalue::Projection(ref p) = self {\n+        if let &Place::Projection(ref p) = self {\n             p.visit_with(visitor)\n         } else {\n             false"}, {"sha": "6f4c156d54158df1d7b2b5cc2b95ee2a57780c7b", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -21,7 +21,7 @@ use hir;\n use ty::util::IntTypeExt;\n \n #[derive(Copy, Clone, Debug)]\n-pub enum LvalueTy<'tcx> {\n+pub enum PlaceTy<'tcx> {\n     /// Normal type.\n     Ty { ty: Ty<'tcx> },\n \n@@ -31,23 +31,23 @@ pub enum LvalueTy<'tcx> {\n                variant_index: usize },\n }\n \n-impl<'a, 'gcx, 'tcx> LvalueTy<'tcx> {\n-    pub fn from_ty(ty: Ty<'tcx>) -> LvalueTy<'tcx> {\n-        LvalueTy::Ty { ty: ty }\n+impl<'a, 'gcx, 'tcx> PlaceTy<'tcx> {\n+    pub fn from_ty(ty: Ty<'tcx>) -> PlaceTy<'tcx> {\n+        PlaceTy::Ty { ty: ty }\n     }\n \n     pub fn to_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n         match *self {\n-            LvalueTy::Ty { ty } =>\n+            PlaceTy::Ty { ty } =>\n                 ty,\n-            LvalueTy::Downcast { adt_def, substs, variant_index: _ } =>\n+            PlaceTy::Downcast { adt_def, substs, variant_index: _ } =>\n                 tcx.mk_adt(adt_def, substs),\n         }\n     }\n \n     pub fn projection_ty(self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                         elem: &LvalueElem<'tcx>)\n-                         -> LvalueTy<'tcx>\n+                         elem: &PlaceElem<'tcx>)\n+                         -> PlaceTy<'tcx>\n     {\n         match *elem {\n             ProjectionElem::Deref => {\n@@ -57,17 +57,17 @@ impl<'a, 'gcx, 'tcx> LvalueTy<'tcx> {\n                                  bug!(\"deref projection of non-dereferencable ty {:?}\", self)\n                              })\n                              .ty;\n-                LvalueTy::Ty {\n+                PlaceTy::Ty {\n                     ty,\n                 }\n             }\n             ProjectionElem::Index(_) | ProjectionElem::ConstantIndex { .. } =>\n-                LvalueTy::Ty {\n+                PlaceTy::Ty {\n                     ty: self.to_ty(tcx).builtin_index().unwrap()\n                 },\n             ProjectionElem::Subslice { from, to } => {\n                 let ty = self.to_ty(tcx);\n-                LvalueTy::Ty {\n+                PlaceTy::Ty {\n                     ty: match ty.sty {\n                         ty::TyArray(inner, size) => {\n                             let size = size.val.to_const_int().unwrap().to_u64().unwrap();\n@@ -87,25 +87,25 @@ impl<'a, 'gcx, 'tcx> LvalueTy<'tcx> {\n                         assert!(adt_def.is_enum());\n                         assert!(index < adt_def.variants.len());\n                         assert_eq!(adt_def, adt_def1);\n-                        LvalueTy::Downcast { adt_def,\n+                        PlaceTy::Downcast { adt_def,\n                                              substs,\n                                              variant_index: index }\n                     }\n                     _ => {\n                         bug!(\"cannot downcast non-ADT type: `{:?}`\", self)\n                     }\n                 },\n-            ProjectionElem::Field(_, fty) => LvalueTy::Ty { ty: fty }\n+            ProjectionElem::Field(_, fty) => PlaceTy::Ty { ty: fty }\n         }\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for LvalueTy<'tcx> {\n+impl<'tcx> TypeFoldable<'tcx> for PlaceTy<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         match *self {\n-            LvalueTy::Ty { ty } => LvalueTy::Ty { ty: ty.fold_with(folder) },\n-            LvalueTy::Downcast { adt_def, substs, variant_index } => {\n-                LvalueTy::Downcast {\n+            PlaceTy::Ty { ty } => PlaceTy::Ty { ty: ty.fold_with(folder) },\n+            PlaceTy::Downcast { adt_def, substs, variant_index } => {\n+                PlaceTy::Downcast {\n                     adt_def,\n                     substs: substs.fold_with(folder),\n                     variant_index,\n@@ -116,22 +116,22 @@ impl<'tcx> TypeFoldable<'tcx> for LvalueTy<'tcx> {\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n         match *self {\n-            LvalueTy::Ty { ty } => ty.visit_with(visitor),\n-            LvalueTy::Downcast { substs, .. } => substs.visit_with(visitor)\n+            PlaceTy::Ty { ty } => ty.visit_with(visitor),\n+            PlaceTy::Downcast { substs, .. } => substs.visit_with(visitor)\n         }\n     }\n }\n \n-impl<'tcx> Lvalue<'tcx> {\n-    pub fn ty<'a, 'gcx, D>(&self, local_decls: &D, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> LvalueTy<'tcx>\n+impl<'tcx> Place<'tcx> {\n+    pub fn ty<'a, 'gcx, D>(&self, local_decls: &D, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> PlaceTy<'tcx>\n         where D: HasLocalDecls<'tcx>\n     {\n         match *self {\n-            Lvalue::Local(index) =>\n-                LvalueTy::Ty { ty: local_decls.local_decls()[index].ty },\n-            Lvalue::Static(ref data) =>\n-                LvalueTy::Ty { ty: data.ty },\n-            Lvalue::Projection(ref proj) =>\n+            Place::Local(index) =>\n+                PlaceTy::Ty { ty: local_decls.local_decls()[index].ty },\n+            Place::Static(ref data) =>\n+                PlaceTy::Ty { ty: data.ty },\n+            Place::Projection(ref proj) =>\n                 proj.base.ty(local_decls, tcx).projection_ty(tcx, &proj.elem),\n         }\n     }\n@@ -184,7 +184,7 @@ impl<'tcx> Rvalue<'tcx> {\n                 } else {\n                     // Undefined behaviour, bug for now; may want to return something for\n                     // the `discriminant` intrinsic later.\n-                    bug!(\"Rvalue::Discriminant on Lvalue of type {:?}\", ty);\n+                    bug!(\"Rvalue::Discriminant on Place of type {:?}\", ty);\n                 }\n             }\n             Rvalue::NullaryOp(NullOp::Box, t) => tcx.mk_box(t),"}, {"sha": "1a542cd1d615880429ba75162d45e4f2da0bbf35", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 62, "deletions": 62, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -107,7 +107,7 @@ macro_rules! make_mir_visitor {\n \n             fn visit_assign(&mut self,\n                             block: BasicBlock,\n-                            lvalue: & $($mutability)* Lvalue<'tcx>,\n+                            lvalue: & $($mutability)* Place<'tcx>,\n                             rvalue: & $($mutability)* Rvalue<'tcx>,\n                             location: Location) {\n                 self.super_assign(block, lvalue, rvalue, location);\n@@ -146,29 +146,29 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn visit_lvalue(&mut self,\n-                            lvalue: & $($mutability)* Lvalue<'tcx>,\n-                            context: LvalueContext<'tcx>,\n+                            lvalue: & $($mutability)* Place<'tcx>,\n+                            context: PlaceContext<'tcx>,\n                             location: Location) {\n                 self.super_lvalue(lvalue, context, location);\n             }\n \n             fn visit_static(&mut self,\n                             static_: & $($mutability)* Static<'tcx>,\n-                            context: LvalueContext<'tcx>,\n+                            context: PlaceContext<'tcx>,\n                             location: Location) {\n                 self.super_static(static_, context, location);\n             }\n \n             fn visit_projection(&mut self,\n-                                lvalue: & $($mutability)* LvalueProjection<'tcx>,\n-                                context: LvalueContext<'tcx>,\n+                                lvalue: & $($mutability)* PlaceProjection<'tcx>,\n+                                context: PlaceContext<'tcx>,\n                                 location: Location) {\n                 self.super_projection(lvalue, context, location);\n             }\n \n             fn visit_projection_elem(&mut self,\n-                                     lvalue: & $($mutability)* LvalueElem<'tcx>,\n-                                     context: LvalueContext<'tcx>,\n+                                     lvalue: & $($mutability)* PlaceElem<'tcx>,\n+                                     context: PlaceContext<'tcx>,\n                                      location: Location) {\n                 self.super_projection_elem(lvalue, context, location);\n             }\n@@ -263,7 +263,7 @@ macro_rules! make_mir_visitor {\n \n             fn visit_local(&mut self,\n                             _local: & $($mutability)* Local,\n-                            _context: LvalueContext<'tcx>,\n+                            _context: PlaceContext<'tcx>,\n                             _location: Location) {\n             }\n \n@@ -358,25 +358,25 @@ macro_rules! make_mir_visitor {\n                     StatementKind::Validate(_, ref $($mutability)* lvalues) => {\n                         for operand in lvalues {\n                             self.visit_lvalue(& $($mutability)* operand.lval,\n-                                              LvalueContext::Validate, location);\n+                                              PlaceContext::Validate, location);\n                             self.visit_ty(& $($mutability)* operand.ty,\n                                           TyContext::Location(location));\n                         }\n                     }\n                     StatementKind::SetDiscriminant{ ref $($mutability)* lvalue, .. } => {\n-                        self.visit_lvalue(lvalue, LvalueContext::Store, location);\n+                        self.visit_lvalue(lvalue, PlaceContext::Store, location);\n                     }\n                     StatementKind::StorageLive(ref $($mutability)* local) => {\n-                        self.visit_local(local, LvalueContext::StorageLive, location);\n+                        self.visit_local(local, PlaceContext::StorageLive, location);\n                     }\n                     StatementKind::StorageDead(ref $($mutability)* local) => {\n-                        self.visit_local(local, LvalueContext::StorageDead, location);\n+                        self.visit_local(local, PlaceContext::StorageDead, location);\n                     }\n                     StatementKind::InlineAsm { ref $($mutability)* outputs,\n                                                ref $($mutability)* inputs,\n                                                asm: _ } => {\n                         for output in & $($mutability)* outputs[..] {\n-                            self.visit_lvalue(output, LvalueContext::Store, location);\n+                            self.visit_lvalue(output, PlaceContext::Store, location);\n                         }\n                         for input in & $($mutability)* inputs[..] {\n                             self.visit_operand(input, location);\n@@ -388,10 +388,10 @@ macro_rules! make_mir_visitor {\n \n             fn super_assign(&mut self,\n                             _block: BasicBlock,\n-                            lvalue: &$($mutability)* Lvalue<'tcx>,\n+                            lvalue: &$($mutability)* Place<'tcx>,\n                             rvalue: &$($mutability)* Rvalue<'tcx>,\n                             location: Location) {\n-                self.visit_lvalue(lvalue, LvalueContext::Store, location);\n+                self.visit_lvalue(lvalue, PlaceContext::Store, location);\n                 self.visit_rvalue(rvalue, location);\n             }\n \n@@ -440,7 +440,7 @@ macro_rules! make_mir_visitor {\n                     TerminatorKind::Drop { ref $($mutability)* location,\n                                            target,\n                                            unwind } => {\n-                        self.visit_lvalue(location, LvalueContext::Drop, source_location);\n+                        self.visit_lvalue(location, PlaceContext::Drop, source_location);\n                         self.visit_branch(block, target);\n                         unwind.map(|t| self.visit_branch(block, t));\n                     }\n@@ -449,7 +449,7 @@ macro_rules! make_mir_visitor {\n                                                      ref $($mutability)* value,\n                                                      target,\n                                                      unwind } => {\n-                        self.visit_lvalue(location, LvalueContext::Drop, source_location);\n+                        self.visit_lvalue(location, PlaceContext::Drop, source_location);\n                         self.visit_operand(value, source_location);\n                         self.visit_branch(block, target);\n                         unwind.map(|t| self.visit_branch(block, t));\n@@ -464,7 +464,7 @@ macro_rules! make_mir_visitor {\n                             self.visit_operand(arg, source_location);\n                         }\n                         if let Some((ref $($mutability)* destination, target)) = *destination {\n-                            self.visit_lvalue(destination, LvalueContext::Call, source_location);\n+                            self.visit_lvalue(destination, PlaceContext::Call, source_location);\n                             self.visit_branch(block, target);\n                         }\n                         cleanup.map(|t| self.visit_branch(block, t));\n@@ -532,14 +532,14 @@ macro_rules! make_mir_visitor {\n \n                     Rvalue::Ref(ref $($mutability)* r, bk, ref $($mutability)* path) => {\n                         self.visit_region(r, location);\n-                        self.visit_lvalue(path, LvalueContext::Borrow {\n+                        self.visit_lvalue(path, PlaceContext::Borrow {\n                             region: *r,\n                             kind: bk\n                         }, location);\n                     }\n \n                     Rvalue::Len(ref $($mutability)* path) => {\n-                        self.visit_lvalue(path, LvalueContext::Inspect, location);\n+                        self.visit_lvalue(path, PlaceContext::Inspect, location);\n                     }\n \n                     Rvalue::Cast(_cast_kind,\n@@ -564,7 +564,7 @@ macro_rules! make_mir_visitor {\n                     }\n \n                     Rvalue::Discriminant(ref $($mutability)* lvalue) => {\n-                        self.visit_lvalue(lvalue, LvalueContext::Inspect, location);\n+                        self.visit_lvalue(lvalue, PlaceContext::Inspect, location);\n                     }\n \n                     Rvalue::NullaryOp(_op, ref $($mutability)* ty) => {\n@@ -612,10 +612,10 @@ macro_rules! make_mir_visitor {\n                              location: Location) {\n                 match *operand {\n                     Operand::Copy(ref $($mutability)* lvalue) => {\n-                        self.visit_lvalue(lvalue, LvalueContext::Copy, location);\n+                        self.visit_lvalue(lvalue, PlaceContext::Copy, location);\n                     }\n                     Operand::Move(ref $($mutability)* lvalue) => {\n-                        self.visit_lvalue(lvalue, LvalueContext::Move, location);\n+                        self.visit_lvalue(lvalue, PlaceContext::Move, location);\n                     }\n                     Operand::Constant(ref $($mutability)* constant) => {\n                         self.visit_constant(constant, location);\n@@ -624,25 +624,25 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn super_lvalue(&mut self,\n-                            lvalue: & $($mutability)* Lvalue<'tcx>,\n-                            context: LvalueContext<'tcx>,\n+                            lvalue: & $($mutability)* Place<'tcx>,\n+                            context: PlaceContext<'tcx>,\n                             location: Location) {\n                 match *lvalue {\n-                    Lvalue::Local(ref $($mutability)* local) => {\n+                    Place::Local(ref $($mutability)* local) => {\n                         self.visit_local(local, context, location);\n                     }\n-                    Lvalue::Static(ref $($mutability)* static_) => {\n+                    Place::Static(ref $($mutability)* static_) => {\n                         self.visit_static(static_, context, location);\n                     }\n-                    Lvalue::Projection(ref $($mutability)* proj) => {\n+                    Place::Projection(ref $($mutability)* proj) => {\n                         self.visit_projection(proj, context, location);\n                     }\n                 }\n             }\n \n             fn super_static(&mut self,\n                             static_: & $($mutability)* Static<'tcx>,\n-                            _context: LvalueContext<'tcx>,\n+                            _context: PlaceContext<'tcx>,\n                             location: Location) {\n                 let Static {\n                     ref $($mutability)* def_id,\n@@ -653,25 +653,25 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn super_projection(&mut self,\n-                                proj: & $($mutability)* LvalueProjection<'tcx>,\n-                                context: LvalueContext<'tcx>,\n+                                proj: & $($mutability)* PlaceProjection<'tcx>,\n+                                context: PlaceContext<'tcx>,\n                                 location: Location) {\n                 let Projection {\n                     ref $($mutability)* base,\n                     ref $($mutability)* elem,\n                 } = *proj;\n                 let context = if context.is_mutating_use() {\n-                    LvalueContext::Projection(Mutability::Mut)\n+                    PlaceContext::Projection(Mutability::Mut)\n                 } else {\n-                    LvalueContext::Projection(Mutability::Not)\n+                    PlaceContext::Projection(Mutability::Not)\n                 };\n                 self.visit_lvalue(base, context, location);\n                 self.visit_projection_elem(elem, context, location);\n             }\n \n             fn super_projection_elem(&mut self,\n-                                     proj: & $($mutability)* LvalueElem<'tcx>,\n-                                     _context: LvalueContext<'tcx>,\n+                                     proj: & $($mutability)* PlaceElem<'tcx>,\n+                                     _context: PlaceContext<'tcx>,\n                                      location: Location) {\n                 match *proj {\n                     ProjectionElem::Deref => {\n@@ -682,7 +682,7 @@ macro_rules! make_mir_visitor {\n                         self.visit_ty(ty, TyContext::Location(location));\n                     }\n                     ProjectionElem::Index(ref $($mutability)* local) => {\n-                        self.visit_local(local, LvalueContext::Copy, location);\n+                        self.visit_local(local, PlaceContext::Copy, location);\n                     }\n                     ProjectionElem::ConstantIndex { offset: _,\n                                                     min_length: _,\n@@ -831,7 +831,7 @@ pub enum TyContext {\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-pub enum LvalueContext<'tcx> {\n+pub enum PlaceContext<'tcx> {\n     // Appears as LHS of an assignment\n     Store,\n \n@@ -874,67 +874,67 @@ pub enum LvalueContext<'tcx> {\n     Validate,\n }\n \n-impl<'tcx> LvalueContext<'tcx> {\n+impl<'tcx> PlaceContext<'tcx> {\n     /// Returns true if this lvalue context represents a drop.\n     pub fn is_drop(&self) -> bool {\n         match *self {\n-            LvalueContext::Drop => true,\n+            PlaceContext::Drop => true,\n             _ => false,\n         }\n     }\n \n     /// Returns true if this lvalue context represents a storage live or storage dead marker.\n     pub fn is_storage_marker(&self) -> bool {\n         match *self {\n-            LvalueContext::StorageLive | LvalueContext::StorageDead => true,\n+            PlaceContext::StorageLive | PlaceContext::StorageDead => true,\n             _ => false,\n         }\n     }\n \n     /// Returns true if this lvalue context represents a storage live marker.\n     pub fn is_storage_live_marker(&self) -> bool {\n         match *self {\n-            LvalueContext::StorageLive => true,\n+            PlaceContext::StorageLive => true,\n             _ => false,\n         }\n     }\n \n     /// Returns true if this lvalue context represents a storage dead marker.\n     pub fn is_storage_dead_marker(&self) -> bool {\n         match *self {\n-            LvalueContext::StorageDead => true,\n+            PlaceContext::StorageDead => true,\n             _ => false,\n         }\n     }\n \n     /// Returns true if this lvalue context represents a use that potentially changes the value.\n     pub fn is_mutating_use(&self) -> bool {\n         match *self {\n-            LvalueContext::Store | LvalueContext::Call |\n-            LvalueContext::Borrow { kind: BorrowKind::Mut, .. } |\n-            LvalueContext::Projection(Mutability::Mut) |\n-            LvalueContext::Drop => true,\n-            LvalueContext::Inspect |\n-            LvalueContext::Borrow { kind: BorrowKind::Shared, .. } |\n-            LvalueContext::Borrow { kind: BorrowKind::Unique, .. } |\n-            LvalueContext::Projection(Mutability::Not) |\n-            LvalueContext::Copy | LvalueContext::Move |\n-            LvalueContext::StorageLive | LvalueContext::StorageDead |\n-            LvalueContext::Validate => false,\n+            PlaceContext::Store | PlaceContext::Call |\n+            PlaceContext::Borrow { kind: BorrowKind::Mut, .. } |\n+            PlaceContext::Projection(Mutability::Mut) |\n+            PlaceContext::Drop => true,\n+            PlaceContext::Inspect |\n+            PlaceContext::Borrow { kind: BorrowKind::Shared, .. } |\n+            PlaceContext::Borrow { kind: BorrowKind::Unique, .. } |\n+            PlaceContext::Projection(Mutability::Not) |\n+            PlaceContext::Copy | PlaceContext::Move |\n+            PlaceContext::StorageLive | PlaceContext::StorageDead |\n+            PlaceContext::Validate => false,\n         }\n     }\n \n     /// Returns true if this lvalue context represents a use that does not change the value.\n     pub fn is_nonmutating_use(&self) -> bool {\n         match *self {\n-            LvalueContext::Inspect | LvalueContext::Borrow { kind: BorrowKind::Shared, .. } |\n-            LvalueContext::Borrow { kind: BorrowKind::Unique, .. } |\n-            LvalueContext::Projection(Mutability::Not) |\n-            LvalueContext::Copy | LvalueContext::Move => true,\n-            LvalueContext::Borrow { kind: BorrowKind::Mut, .. } | LvalueContext::Store |\n-            LvalueContext::Call | LvalueContext::Projection(Mutability::Mut) |\n-            LvalueContext::Drop | LvalueContext::StorageLive | LvalueContext::StorageDead |\n-            LvalueContext::Validate => false,\n+            PlaceContext::Inspect | PlaceContext::Borrow { kind: BorrowKind::Shared, .. } |\n+            PlaceContext::Borrow { kind: BorrowKind::Unique, .. } |\n+            PlaceContext::Projection(Mutability::Not) |\n+            PlaceContext::Copy | PlaceContext::Move => true,\n+            PlaceContext::Borrow { kind: BorrowKind::Mut, .. } | PlaceContext::Store |\n+            PlaceContext::Call | PlaceContext::Projection(Mutability::Mut) |\n+            PlaceContext::Drop | PlaceContext::StorageLive | PlaceContext::StorageDead |\n+            PlaceContext::Validate => false,\n         }\n     }\n "}, {"sha": "0edc486a1625d1106b7ec2cba32ac619ae152132", "filename": "src/librustc_mir/borrow_check.rs", "status": "modified", "additions": 69, "deletions": 69, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Fborrow_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Fborrow_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -15,7 +15,7 @@ use rustc::hir::def_id::{DefId};\n use rustc::infer::{InferCtxt};\n use rustc::ty::{self, TyCtxt, ParamEnv};\n use rustc::ty::maps::Providers;\n-use rustc::mir::{AssertMessage, BasicBlock, BorrowKind, Location, Lvalue, Local};\n+use rustc::mir::{AssertMessage, BasicBlock, BorrowKind, Location, Place, Local};\n use rustc::mir::{Mir, Mutability, Operand, Projection, ProjectionElem, Rvalue};\n use rustc::mir::{Field, Statement, StatementKind, Terminator, TerminatorKind};\n use transform::nll;\n@@ -300,7 +300,7 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n \n             StatementKind::StorageDead(local) => {\n                 self.access_lvalue(ContextKind::StorageDead.new(location),\n-                    (&Lvalue::Local(local), span),\n+                    (&Place::Local(local), span),\n                     (Shallow(None), Write(WriteKind::StorageDeadOrDrop)),\n                     LocalMutationIsAllowed::Yes,\n                     flow_state);\n@@ -390,7 +390,7 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                         PrefixSet::All\n                     ).last().unwrap();\n                     match root_lvalue {\n-                        Lvalue::Static(_) => {\n+                        Place::Static(_) => {\n                             self.access_lvalue(\n                                 ContextKind::StorageDead.new(loc),\n                                 (&root_lvalue, self.mir.source_info(borrow.location).span),\n@@ -399,7 +399,7 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                                 flow_state\n                             );\n                         }\n-                        Lvalue::Local(_) => {\n+                        Place::Local(_) => {\n                             self.access_lvalue(\n                                 ContextKind::StorageDead.new(loc),\n                                 (&root_lvalue, self.mir.source_info(borrow.location).span),\n@@ -408,7 +408,7 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                                 flow_state\n                             );\n                         }\n-                        Lvalue::Projection(_) => ()\n+                        Place::Projection(_) => ()\n                     }\n                 }\n             }\n@@ -534,14 +534,14 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     /// Returns true if an error is reported, false otherwise.\n     fn access_lvalue(&mut self,\n                      context: Context,\n-                     lvalue_span: (&Lvalue<'tcx>, Span),\n+                     lvalue_span: (&Place<'tcx>, Span),\n                      kind: (ShallowOrDeep, ReadOrWrite),\n                      is_local_mutation_allowed: LocalMutationIsAllowed,\n                      flow_state: &InProgress<'cx, 'gcx, 'tcx>) {\n         let (sd, rw) = kind;\n \n         let storage_dead_or_drop_local = match (lvalue_span.0, rw) {\n-            (&Lvalue::Local(local), Write(WriteKind::StorageDeadOrDrop)) => Some(local),\n+            (&Place::Local(local), Write(WriteKind::StorageDeadOrDrop)) => Some(local),\n             _ => None\n         };\n \n@@ -627,7 +627,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n     fn mutate_lvalue(&mut self,\n                      context: Context,\n-                     lvalue_span: (&Lvalue<'tcx>, Span),\n+                     lvalue_span: (&Place<'tcx>, Span),\n                      kind: ShallowOrDeep,\n                      mode: MutateMode,\n                      flow_state: &InProgress<'cx, 'gcx, 'tcx>) {\n@@ -756,7 +756,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     fn check_if_reassignment_to_immutable_state(&mut self,\n                                                 context: Context,\n-                                                (lvalue, span): (&Lvalue<'tcx>, Span),\n+                                                (lvalue, span): (&Place<'tcx>, Span),\n                                                 flow_state: &InProgress<'cx, 'gcx, 'tcx>) {\n         let move_data = self.move_data;\n \n@@ -795,7 +795,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     fn check_if_path_is_moved(&mut self,\n                               context: Context,\n                               desired_action: InitializationRequiringAction,\n-                              lvalue_span: (&Lvalue<'tcx>, Span),\n+                              lvalue_span: (&Place<'tcx>, Span),\n                               flow_state: &InProgress<'cx, 'gcx, 'tcx>) {\n         // FIXME: analogous code in check_loans first maps `lvalue` to\n         // its base_path ... but is that what we want here?\n@@ -890,7 +890,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     /// An Err result includes a tag indicated why the search failed.\n     /// Currenly this can only occur if the lvalue is built off of a\n     /// static variable, as we do not track those in the MoveData.\n-    fn move_path_closest_to(&mut self, lvalue: &Lvalue<'tcx>)\n+    fn move_path_closest_to(&mut self, lvalue: &Place<'tcx>)\n                             -> Result<MovePathIndex, NoMovePathFound>\n     {\n         let mut last_prefix = lvalue;\n@@ -901,14 +901,14 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             last_prefix = prefix;\n         }\n         match *last_prefix {\n-            Lvalue::Local(_) => panic!(\"should have move path for every Local\"),\n-            Lvalue::Projection(_) => panic!(\"PrefixSet::All meant dont stop for Projection\"),\n-            Lvalue::Static(_) => return Err(NoMovePathFound::ReachedStatic),\n+            Place::Local(_) => panic!(\"should have move path for every Local\"),\n+            Place::Projection(_) => panic!(\"PrefixSet::All meant dont stop for Projection\"),\n+            Place::Static(_) => return Err(NoMovePathFound::ReachedStatic),\n         }\n     }\n \n     fn move_path_for_lvalue(&mut self,\n-                            lvalue: &Lvalue<'tcx>)\n+                            lvalue: &Place<'tcx>)\n                             -> Option<MovePathIndex>\n     {\n         // If returns None, then there is no move path corresponding\n@@ -923,17 +923,17 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n     fn check_if_assigned_path_is_moved(&mut self,\n                                        context: Context,\n-                                       (lvalue, span): (&Lvalue<'tcx>, Span),\n+                                       (lvalue, span): (&Place<'tcx>, Span),\n                                        flow_state: &InProgress<'cx, 'gcx, 'tcx>) {\n         // recur down lvalue; dispatch to check_if_path_is_moved when necessary\n         let mut lvalue = lvalue;\n         loop {\n             match *lvalue {\n-                Lvalue::Local(_) | Lvalue::Static(_) => {\n+                Place::Local(_) | Place::Static(_) => {\n                     // assigning to `x` does not require `x` be initialized.\n                     break;\n                 }\n-                Lvalue::Projection(ref proj) => {\n+                Place::Projection(ref proj) => {\n                     let Projection { ref base, ref elem } = **proj;\n                     match *elem {\n                         ProjectionElem::Deref |\n@@ -988,7 +988,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     ///\n     /// Returns true if an error is reported, false otherwise.\n     fn check_access_permissions(&self,\n-                                (lvalue, span): (&Lvalue<'tcx>, Span),\n+                                (lvalue, span): (&Place<'tcx>, Span),\n                                 kind: ReadOrWrite,\n                                 is_local_mutation_allowed: LocalMutationIsAllowed)\n                                 -> bool {\n@@ -1068,11 +1068,11 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n     /// Can this value be written or borrowed mutably\n     fn is_mutable<'d>(&self,\n-                      lvalue: &'d Lvalue<'tcx>,\n+                      lvalue: &'d Place<'tcx>,\n                       is_local_mutation_allowed: LocalMutationIsAllowed)\n-                      -> Result<(), &'d Lvalue<'tcx>> {\n+                      -> Result<(), &'d Place<'tcx>> {\n         match *lvalue {\n-            Lvalue::Local(local) => {\n+            Place::Local(local) => {\n                 let local = &self.mir.local_decls[local];\n                 match local.mutability {\n                     Mutability::Not =>\n@@ -1083,14 +1083,14 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     Mutability::Mut => Ok(())\n                 }\n             },\n-            Lvalue::Static(ref static_) => {\n+            Place::Static(ref static_) => {\n                 if !self.tcx.is_static_mut(static_.def_id) {\n                     Err(lvalue)\n                 } else {\n                     Ok(())\n                 }\n             },\n-            Lvalue::Projection(ref proj) => {\n+            Place::Projection(ref proj) => {\n                 match proj.elem {\n                     ProjectionElem::Deref => {\n                         let base_ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n@@ -1154,17 +1154,17 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     }\n \n     /// Does this lvalue have a unique path\n-    fn is_unique<'d>(&self, lvalue: &'d Lvalue<'tcx>) -> Result<(), &'d Lvalue<'tcx>> {\n+    fn is_unique<'d>(&self, lvalue: &'d Place<'tcx>) -> Result<(), &'d Place<'tcx>> {\n         match *lvalue {\n-            Lvalue::Local(..) => {\n+            Place::Local(..) => {\n                 // Local variables are unique\n                 Ok(())\n             },\n-            Lvalue::Static(..) => {\n+            Place::Static(..) => {\n                 // Static variables are not\n                 Err(lvalue)\n             },\n-            Lvalue::Projection(ref proj) => {\n+            Place::Projection(ref proj) => {\n                 match proj.elem {\n                     ProjectionElem::Deref => {\n                         let base_ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n@@ -1217,10 +1217,10 @@ enum NoMovePathFound {\n impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     fn each_borrow_involving_path<F>(&mut self,\n                                      _context: Context,\n-                                     access_lvalue: (ShallowOrDeep, &Lvalue<'tcx>),\n+                                     access_lvalue: (ShallowOrDeep, &Place<'tcx>),\n                                      flow_state: &InProgress<'cx, 'gcx, 'tcx>,\n                                      mut op: F)\n-        where F: FnMut(&mut Self, BorrowIndex, &BorrowData<'tcx>, &Lvalue<'tcx>) -> Control\n+        where F: FnMut(&mut Self, BorrowIndex, &BorrowData<'tcx>, &Place<'tcx>) -> Control\n     {\n         let (access, lvalue) = access_lvalue;\n \n@@ -1292,24 +1292,24 @@ mod prefixes {\n \n     use rustc::hir;\n     use rustc::ty::{self, TyCtxt};\n-    use rustc::mir::{Lvalue, Mir, ProjectionElem};\n+    use rustc::mir::{Place, Mir, ProjectionElem};\n \n     pub trait IsPrefixOf<'tcx> {\n-        fn is_prefix_of(&self, other: &Lvalue<'tcx>) -> bool;\n+        fn is_prefix_of(&self, other: &Place<'tcx>) -> bool;\n     }\n \n-    impl<'tcx> IsPrefixOf<'tcx> for Lvalue<'tcx> {\n-        fn is_prefix_of(&self, other: &Lvalue<'tcx>) -> bool {\n+    impl<'tcx> IsPrefixOf<'tcx> for Place<'tcx> {\n+        fn is_prefix_of(&self, other: &Place<'tcx>) -> bool {\n             let mut cursor = other;\n             loop {\n                 if self == cursor {\n                     return true;\n                 }\n \n                 match *cursor {\n-                    Lvalue::Local(_) |\n-                    Lvalue::Static(_) => return false,\n-                    Lvalue::Projection(ref proj) => {\n+                    Place::Local(_) |\n+                    Place::Static(_) => return false,\n+                    Place::Projection(ref proj) => {\n                         cursor = &proj.base;\n                     }\n                 }\n@@ -1322,7 +1322,7 @@ mod prefixes {\n         mir: &'cx Mir<'tcx>,\n         tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n         kind: PrefixSet,\n-        next: Option<&'cx Lvalue<'tcx>>,\n+        next: Option<&'cx Place<'tcx>>,\n     }\n \n     #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n@@ -1341,7 +1341,7 @@ mod prefixes {\n         /// (inclusive) from longest to smallest, potentially\n         /// terminating the iteration early based on `kind`.\n         pub(super) fn prefixes(&self,\n-                               lvalue: &'cx Lvalue<'tcx>,\n+                               lvalue: &'cx Place<'tcx>,\n                                kind: PrefixSet)\n                                -> Prefixes<'cx, 'gcx, 'tcx>\n         {\n@@ -1350,7 +1350,7 @@ mod prefixes {\n     }\n \n     impl<'cx, 'gcx, 'tcx> Iterator for Prefixes<'cx, 'gcx, 'tcx> {\n-        type Item = &'cx Lvalue<'tcx>;\n+        type Item = &'cx Place<'tcx>;\n         fn next(&mut self) -> Option<Self::Item> {\n             let mut cursor = match self.next {\n                 None => return None,\n@@ -1364,13 +1364,13 @@ mod prefixes {\n \n             'cursor: loop {\n                 let proj = match *cursor {\n-                    Lvalue::Local(_) | // search yielded this leaf\n-                    Lvalue::Static(_) => {\n+                    Place::Local(_) | // search yielded this leaf\n+                    Place::Static(_) => {\n                         self.next = None;\n                         return Some(cursor);\n                     }\n \n-                    Lvalue::Projection(ref proj) => proj,\n+                    Place::Projection(ref proj) => proj,\n                 };\n \n                 match proj.elem {\n@@ -1447,7 +1447,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     fn report_use_of_moved_or_uninitialized(&mut self,\n                            _context: Context,\n                            desired_action: InitializationRequiringAction,\n-                           (lvalue, span): (&Lvalue<'tcx>, Span),\n+                           (lvalue, span): (&Place<'tcx>, Span),\n                            mpi: MovePathIndex,\n                            curr_move_out: &IdxSetBuf<MoveOutIndex>) {\n \n@@ -1496,7 +1496,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n     fn report_move_out_while_borrowed(&mut self,\n                                       _context: Context,\n-                                      (lvalue, span): (&Lvalue<'tcx>, Span),\n+                                      (lvalue, span): (&Place<'tcx>, Span),\n                                       borrow: &BorrowData<'tcx>) {\n         let value_msg = match self.describe_lvalue(lvalue) {\n             Some(name) => format!(\"`{}`\", name),\n@@ -1517,7 +1517,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n     fn report_use_while_mutably_borrowed(&mut self,\n                                          _context: Context,\n-                                         (lvalue, span): (&Lvalue<'tcx>, Span),\n+                                         (lvalue, span): (&Place<'tcx>, Span),\n                                          borrow : &BorrowData<'tcx>) {\n \n         let mut err = self.tcx.cannot_use_when_mutably_borrowed(\n@@ -1542,7 +1542,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         use rustc::hir::ExprClosure;\n         use rustc::mir::AggregateKind;\n \n-        let local = if let StatementKind::Assign(Lvalue::Local(local), _) =\n+        let local = if let StatementKind::Assign(Place::Local(local), _) =\n             self.mir[location.block].statements[location.statement_index].kind\n         {\n             local\n@@ -1571,8 +1571,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         self.tcx.with_freevars(node_id, |freevars| {\n                             for (v, lv) in freevars.iter().zip(lvs) {\n                                 match *lv {\n-                                    Operand::Copy(Lvalue::Local(l)) |\n-                                    Operand::Move(Lvalue::Local(l)) if local == l => {\n+                                    Operand::Copy(Place::Local(l)) |\n+                                    Operand::Move(Place::Local(l)) if local == l => {\n                                         debug!(\n                                             \"find_closure_span: found captured local {:?}\",\n                                             l\n@@ -1596,8 +1596,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n     fn report_conflicting_borrow(&mut self,\n                                  context: Context,\n-                                 common_prefix: &Lvalue<'tcx>,\n-                                 (lvalue, span): (&Lvalue<'tcx>, Span),\n+                                 common_prefix: &Place<'tcx>,\n+                                 (lvalue, span): (&Place<'tcx>, Span),\n                                  gen_borrow_kind: BorrowKind,\n                                  issued_borrow: &BorrowData,\n                                  end_issued_loan_span: Option<Span>) {\n@@ -1667,10 +1667,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n     fn report_borrowed_value_does_not_live_long_enough(&mut self,\n                                                        _: Context,\n-                                                       (lvalue, span): (&Lvalue, Span),\n+                                                       (lvalue, span): (&Place, Span),\n                                                        end_span: Option<Span>) {\n         let proper_span = match *lvalue {\n-            Lvalue::Local(local) => self.mir.local_decls[local].source_info.span,\n+            Place::Local(local) => self.mir.local_decls[local].source_info.span,\n             _ => span\n         };\n \n@@ -1688,7 +1688,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n     fn report_illegal_mutation_of_borrowed(&mut self,\n                                            _: Context,\n-                                           (lvalue, span): (&Lvalue<'tcx>, Span),\n+                                           (lvalue, span): (&Place<'tcx>, Span),\n                                            loan: &BorrowData) {\n         let mut err = self.tcx.cannot_assign_to_borrowed(\n             span,\n@@ -1701,7 +1701,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n     fn report_illegal_reassignment(&mut self,\n                                    _context: Context,\n-                                   (lvalue, span): (&Lvalue<'tcx>, Span),\n+                                   (lvalue, span): (&Place<'tcx>, Span),\n                                    assigned_span: Span) {\n         let mut err = self.tcx.cannot_reassign_immutable(span,\n                                            &self.describe_lvalue(lvalue).unwrap_or(\"_\".to_owned()),\n@@ -1721,7 +1721,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     // End-user visible description of `lvalue` if one can be found. If the\n     // lvalue is a temporary for instance, None will be returned.\n-    fn describe_lvalue(&self, lvalue: &Lvalue<'tcx>) -> Option<String> {\n+    fn describe_lvalue(&self, lvalue: &Place<'tcx>) -> Option<String> {\n         let mut buf = String::new();\n         match self.append_lvalue_to_string(lvalue, &mut buf, false) {\n             Ok(()) => Some(buf),\n@@ -1733,9 +1733,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     /// then returns the index of the field being projected. Note that this closure will always\n     /// be `self` in the current MIR, because that is the only time we directly access the fields\n     /// of a closure type.\n-    fn is_upvar_field_projection(&self, lvalue: &Lvalue<'tcx>) -> Option<Field> {\n+    fn is_upvar_field_projection(&self, lvalue: &Place<'tcx>) -> Option<Field> {\n         match *lvalue {\n-            Lvalue::Projection(ref proj) => {\n+            Place::Projection(ref proj) => {\n                 match proj.elem {\n                     ProjectionElem::Field(field, _ty) => {\n                         let is_projection_from_ty_closure = proj.base.ty(self.mir, self.tcx)\n@@ -1756,17 +1756,17 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n     // Appends end-user visible description of `lvalue` to `buf`.\n     fn append_lvalue_to_string(&self,\n-                               lvalue: &Lvalue<'tcx>,\n+                               lvalue: &Place<'tcx>,\n                                buf: &mut String,\n                                mut autoderef: bool) -> Result<(), ()> {\n         match *lvalue {\n-            Lvalue::Local(local) => {\n+            Place::Local(local) => {\n                 self.append_local_to_string(local, buf,)?;\n             }\n-            Lvalue::Static(ref static_) => {\n+            Place::Static(ref static_) => {\n                 buf.push_str(&format!(\"{}\", &self.tcx.item_name(static_.def_id)));\n             }\n-            Lvalue::Projection(ref proj) => {\n+            Place::Projection(ref proj) => {\n                 match proj.elem {\n                     ProjectionElem::Deref => {\n                         if let Some(field) = self.is_upvar_field_projection(&proj.base) {\n@@ -1841,16 +1841,16 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     }\n \n     // End-user visible description of the `field`nth field of `base`\n-    fn describe_field(&self, base: &Lvalue, field: Field) -> String {\n+    fn describe_field(&self, base: &Place, field: Field) -> String {\n         match *base {\n-            Lvalue::Local(local) => {\n+            Place::Local(local) => {\n                 let local = &self.mir.local_decls[local];\n                 self.describe_field_from_ty(&local.ty, field)\n             },\n-            Lvalue::Static(ref static_) => {\n+            Place::Static(ref static_) => {\n                 self.describe_field_from_ty(&static_.ty, field)\n             },\n-            Lvalue::Projection(ref proj) => {\n+            Place::Projection(ref proj) => {\n                 match proj.elem {\n                     ProjectionElem::Deref =>\n                         self.describe_field(&proj.base, field),\n@@ -1923,7 +1923,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     // moves out of a Box. They should be removed when/if we stop\n     // treating Box specially (e.g. when/if DerefMove is added...)\n \n-    fn base_path<'d>(&self, lvalue: &'d Lvalue<'tcx>) -> &'d Lvalue<'tcx> {\n+    fn base_path<'d>(&self, lvalue: &'d Place<'tcx>) -> &'d Place<'tcx> {\n         //! Returns the base of the leftmost (deepest) dereference of an\n         //! Box in `lvalue`. If there is no dereference of an Box\n         //! in `lvalue`, then it just returns `lvalue` itself.\n@@ -1932,8 +1932,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let mut deepest = lvalue;\n         loop {\n             let proj = match *cursor {\n-                Lvalue::Local(..) | Lvalue::Static(..) => return deepest,\n-                Lvalue::Projection(ref proj) => proj,\n+                Place::Local(..) | Place::Static(..) => return deepest,\n+                Place::Projection(ref proj) => proj,\n             };\n             if proj.elem == ProjectionElem::Deref &&\n                 lvalue.ty(self.mir, self.tcx).to_ty(self.tcx).is_box()"}, {"sha": "b2b615d29a5b8ceb7ed72c83d22724c64e1a2fac", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -16,7 +16,7 @@ use syntax_pos::Span;\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn ast_block(&mut self,\n-                     destination: &Lvalue<'tcx>,\n+                     destination: &Place<'tcx>,\n                      block: BasicBlock,\n                      ast_block: &'tcx hir::Block,\n                      source_info: SourceInfo)\n@@ -53,7 +53,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     }\n \n     fn ast_block_stmts(&mut self,\n-                       destination: &Lvalue<'tcx>,\n+                       destination: &Place<'tcx>,\n                        mut block: BasicBlock,\n                        span: Span,\n                        stmts: Vec<StmtRef<'tcx>>,"}, {"sha": "242eea8cb934464cccaeb88442d11481ee3d9be4", "filename": "src/librustc_mir/build/cfg.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -61,7 +61,7 @@ impl<'tcx> CFG<'tcx> {\n     pub fn push_assign(&mut self,\n                        block: BasicBlock,\n                        source_info: SourceInfo,\n-                       lvalue: &Lvalue<'tcx>,\n+                       lvalue: &Place<'tcx>,\n                        rvalue: Rvalue<'tcx>) {\n         self.push(block, Statement {\n             source_info,\n@@ -72,7 +72,7 @@ impl<'tcx> CFG<'tcx> {\n     pub fn push_assign_constant(&mut self,\n                                 block: BasicBlock,\n                                 source_info: SourceInfo,\n-                                temp: &Lvalue<'tcx>,\n+                                temp: &Place<'tcx>,\n                                 constant: Constant<'tcx>) {\n         self.push_assign(block, source_info, temp,\n                          Rvalue::Use(Operand::Constant(box constant)));\n@@ -81,7 +81,7 @@ impl<'tcx> CFG<'tcx> {\n     pub fn push_assign_unit(&mut self,\n                             block: BasicBlock,\n                             source_info: SourceInfo,\n-                            lvalue: &Lvalue<'tcx>) {\n+                            lvalue: &Place<'tcx>) {\n         self.push_assign(block, source_info, lvalue, Rvalue::Aggregate(\n             box AggregateKind::Tuple, vec![]\n         ));"}, {"sha": "c59005ba7428d652075fb414464c70f66d758b9e", "filename": "src/librustc_mir/build/expr/as_lvalue.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -22,7 +22,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn as_lvalue<M>(&mut self,\n                         block: BasicBlock,\n                         expr: M)\n-                        -> BlockAnd<Lvalue<'tcx>>\n+                        -> BlockAnd<Place<'tcx>>\n         where M: Mirror<'tcx, Output=Expr<'tcx>>\n     {\n         let expr = self.hir.mirror(expr);\n@@ -32,7 +32,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     fn expr_as_lvalue(&mut self,\n                       mut block: BasicBlock,\n                       expr: Expr<'tcx>)\n-                      -> BlockAnd<Lvalue<'tcx>> {\n+                      -> BlockAnd<Place<'tcx>> {\n         debug!(\"expr_as_lvalue(block={:?}, expr={:?})\", block, expr);\n \n         let this = self;\n@@ -70,26 +70,26 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                      &len, Rvalue::Len(slice.clone()));\n                 this.cfg.push_assign(block, source_info, // lt = idx < len\n                                      &lt, Rvalue::BinaryOp(BinOp::Lt,\n-                                                           Operand::Copy(Lvalue::Local(idx)),\n+                                                           Operand::Copy(Place::Local(idx)),\n                                                            Operand::Copy(len.clone())));\n \n                 let msg = AssertMessage::BoundsCheck {\n                     len: Operand::Move(len),\n-                    index: Operand::Copy(Lvalue::Local(idx))\n+                    index: Operand::Copy(Place::Local(idx))\n                 };\n                 let success = this.assert(block, Operand::Move(lt), true,\n                                           msg, expr_span);\n                 success.and(slice.index(idx))\n             }\n             ExprKind::SelfRef => {\n-                block.and(Lvalue::Local(Local::new(1)))\n+                block.and(Place::Local(Local::new(1)))\n             }\n             ExprKind::VarRef { id } => {\n                 let index = this.var_indices[&id];\n-                block.and(Lvalue::Local(index))\n+                block.and(Place::Local(index))\n             }\n             ExprKind::StaticRef { id } => {\n-                block.and(Lvalue::Static(Box::new(Static { def_id: id, ty: expr.ty })))\n+                block.and(Place::Static(Box::new(Static { def_id: id, ty: expr.ty })))\n             }\n \n             ExprKind::Array { .. } |\n@@ -124,11 +124,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             ExprKind::Call { .. } => {\n                 // these are not lvalues, so we need to make a temporary.\n                 debug_assert!(match Category::of(&expr.kind) {\n-                    Some(Category::Lvalue) => false,\n+                    Some(Category::Place) => false,\n                     _ => true,\n                 });\n                 let temp = unpack!(block = this.as_temp(block, expr.temp_lifetime, expr));\n-                block.and(Lvalue::Local(temp))\n+                block.and(Place::Local(temp))\n             }\n         }\n     }"}, {"sha": "15fada248ee0be9f87275a3b66fdccaf3aedce19", "filename": "src/librustc_mir/build/expr/as_operand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -70,11 +70,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 let constant = this.as_constant(expr);\n                 block.and(Operand::Constant(box constant))\n             }\n-            Category::Lvalue |\n+            Category::Place |\n             Category::Rvalue(..) => {\n                 let operand =\n                     unpack!(block = this.as_temp(block, scope, expr));\n-                block.and(Operand::Move(Lvalue::Local(operand)))\n+                block.and(Operand::Move(Place::Local(operand)))\n             }\n         }\n     }"}, {"sha": "e23cd7822b76c1a90c2f1b36939322e32327f196", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -108,16 +108,16 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 });\n                 if let Some(scope) = scope {\n                     // schedule a shallow free of that memory, lest we unwind:\n-                    this.schedule_drop(expr_span, scope, &Lvalue::Local(result), value.ty);\n+                    this.schedule_drop(expr_span, scope, &Place::Local(result), value.ty);\n                 }\n \n                 // malloc some memory of suitable type (thus far, uninitialized):\n                 let box_ = Rvalue::NullaryOp(NullOp::Box, value.ty);\n-                this.cfg.push_assign(block, source_info, &Lvalue::Local(result), box_);\n+                this.cfg.push_assign(block, source_info, &Place::Local(result), box_);\n \n                 // initialize the box contents:\n-                unpack!(block = this.into(&Lvalue::Local(result).deref(), block, value));\n-                block.and(Rvalue::Use(Operand::Move(Lvalue::Local(result))))\n+                unpack!(block = this.into(&Place::Local(result).deref(), block, value));\n+                block.and(Rvalue::Use(Operand::Move(Place::Local(result))))\n             }\n             ExprKind::Cast { source } => {\n                 let source = this.hir.mirror(source);"}, {"sha": "9576a6d70f16350539c63ad80491b7e8b13966d7", "filename": "src/librustc_mir/build/expr/as_temp.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -65,21 +65,21 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         // semantics of `into`, `as_operand`, `as_rvalue`, and (of\n         // course) `as_temp`.\n         match Category::of(&expr.kind).unwrap() {\n-            Category::Lvalue => {\n+            Category::Place => {\n                 let lvalue = unpack!(block = this.as_lvalue(block, expr));\n                 let rvalue = Rvalue::Use(this.consume_by_copy_or_move(lvalue));\n-                this.cfg.push_assign(block, source_info, &Lvalue::Local(temp), rvalue);\n+                this.cfg.push_assign(block, source_info, &Place::Local(temp), rvalue);\n             }\n             _ => {\n-                unpack!(block = this.into(&Lvalue::Local(temp), block, expr));\n+                unpack!(block = this.into(&Place::Local(temp), block, expr));\n             }\n         }\n \n         // In constants, temp_lifetime is None. We should not need to drop\n         // anything because no values with a destructor can be created in\n         // a constant at this time, even if the type may need dropping.\n         if let Some(temp_lifetime) = temp_lifetime {\n-            this.schedule_drop(expr_span, temp_lifetime, &Lvalue::Local(temp), expr_ty);\n+            this.schedule_drop(expr_span, temp_lifetime, &Place::Local(temp), expr_ty);\n         }\n \n         block.and(temp)"}, {"sha": "bce8e97d481f165baf40c1b2718faf8f641ca7a2", "filename": "src/librustc_mir/build/expr/category.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fcategory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fcategory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fcategory.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -15,7 +15,7 @@ pub enum Category {\n     // An assignable memory location like `x`, `x.f`, `foo()[3]`, that\n     // sort of thing. Something that could appear on the LHS of an `=`\n     // sign.\n-    Lvalue,\n+    Place,\n \n     // A literal like `23` or `\"foo\"`. Does not include constant\n     // expressions like `3 + 5`.\n@@ -51,7 +51,7 @@ impl Category {\n             ExprKind::SelfRef |\n             ExprKind::VarRef { .. } |\n             ExprKind::StaticRef { .. } =>\n-                Some(Category::Lvalue),\n+                Some(Category::Place),\n \n             ExprKind::LogicalOp { .. } |\n             ExprKind::If { .. } |"}, {"sha": "0cdac04b810514289841e8973520ae2f47a8a8fc", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -22,7 +22,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// Compile `expr`, storing the result into `destination`, which\n     /// is assumed to be uninitialized.\n     pub fn into_expr(&mut self,\n-                     destination: &Lvalue<'tcx>,\n+                     destination: &Place<'tcx>,\n                      mut block: BasicBlock,\n                      expr: Expr<'tcx>)\n                      -> BlockAnd<()>\n@@ -241,7 +241,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         internal: true,\n                         is_user_variable: false\n                     });\n-                    let ptr_temp = Lvalue::Local(ptr_temp);\n+                    let ptr_temp = Place::Local(ptr_temp);\n                     let block = unpack!(this.into(&ptr_temp, block, ptr));\n                     this.into(&ptr_temp.deref(), block, val)\n                 } else {"}, {"sha": "3a3d65327f2d740691f9b0a73978f2f2a107e36c", "filename": "src/librustc_mir/build/expr/stmt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -107,12 +107,12 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             ExprKind::Return { value } => {\n                 block = match value {\n                     Some(value) => {\n-                        unpack!(this.into(&Lvalue::Local(RETURN_POINTER), block, value))\n+                        unpack!(this.into(&Place::Local(RETURN_POINTER), block, value))\n                     }\n                     None => {\n                         this.cfg.push_assign_unit(block,\n                                                   source_info,\n-                                                  &Lvalue::Local(RETURN_POINTER));\n+                                                  &Place::Local(RETURN_POINTER));\n                         block\n                     }\n                 };"}, {"sha": "9c8d0b2aeb911e5621849b1fae7c53f6d5c31066", "filename": "src/librustc_mir/build/into.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Fbuild%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Fbuild%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Finto.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -21,14 +21,14 @@ use rustc::mir::*;\n pub(in build) trait EvalInto<'tcx> {\n     fn eval_into<'a, 'gcx>(self,\n                            builder: &mut Builder<'a, 'gcx, 'tcx>,\n-                           destination: &Lvalue<'tcx>,\n+                           destination: &Place<'tcx>,\n                            block: BasicBlock)\n                            -> BlockAnd<()>;\n }\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn into<E>(&mut self,\n-                   destination: &Lvalue<'tcx>,\n+                   destination: &Place<'tcx>,\n                    block: BasicBlock,\n                    expr: E)\n                    -> BlockAnd<()>\n@@ -41,7 +41,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n impl<'tcx> EvalInto<'tcx> for ExprRef<'tcx> {\n     fn eval_into<'a, 'gcx>(self,\n                            builder: &mut Builder<'a, 'gcx, 'tcx>,\n-                           destination: &Lvalue<'tcx>,\n+                           destination: &Place<'tcx>,\n                            block: BasicBlock)\n                            -> BlockAnd<()> {\n         let expr = builder.hir.mirror(self);\n@@ -52,7 +52,7 @@ impl<'tcx> EvalInto<'tcx> for ExprRef<'tcx> {\n impl<'tcx> EvalInto<'tcx> for Expr<'tcx> {\n     fn eval_into<'a, 'gcx>(self,\n                            builder: &mut Builder<'a, 'gcx, 'tcx>,\n-                           destination: &Lvalue<'tcx>,\n+                           destination: &Place<'tcx>,\n                            block: BasicBlock)\n                            -> BlockAnd<()> {\n         builder.into_expr(destination, block, self)"}, {"sha": "e748c35f4bdce43935c29a92be2a2504ff6db059", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -30,7 +30,7 @@ mod util;\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn match_expr(&mut self,\n-                      destination: &Lvalue<'tcx>,\n+                      destination: &Place<'tcx>,\n                       span: Span,\n                       mut block: BasicBlock,\n                       discriminant: ExprRef<'tcx>,\n@@ -154,7 +154,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn lvalue_into_pattern(&mut self,\n                                mut block: BasicBlock,\n                                irrefutable_pat: Pattern<'tcx>,\n-                               initializer: &Lvalue<'tcx>)\n+                               initializer: &Place<'tcx>)\n                                -> BlockAnd<()> {\n         // create a dummy candidate\n         let mut candidate = Candidate {\n@@ -223,23 +223,23 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn storage_live_binding(&mut self, block: BasicBlock, var: NodeId, span: Span)\n-                            -> Lvalue<'tcx>\n+                            -> Place<'tcx>\n     {\n         let local_id = self.var_indices[&var];\n         let source_info = self.source_info(span);\n         self.cfg.push(block, Statement {\n             source_info,\n             kind: StatementKind::StorageLive(local_id)\n         });\n-        Lvalue::Local(local_id)\n+        Place::Local(local_id)\n     }\n \n     pub fn schedule_drop_for_binding(&mut self, var: NodeId, span: Span) {\n         let local_id = self.var_indices[&var];\n         let var_ty = self.local_decls[local_id].ty;\n         let hir_id = self.hir.tcx().hir.node_to_hir_id(var);\n         let region_scope = self.hir.region_scope_tree.var_scope(hir_id.local_id);\n-        self.schedule_drop(span, region_scope, &Lvalue::Local(local_id), var_ty);\n+        self.schedule_drop(span, region_scope, &Place::Local(local_id), var_ty);\n     }\n \n     pub fn visit_bindings<F>(&mut self, pattern: &Pattern<'tcx>, f: &mut F)\n@@ -305,7 +305,7 @@ pub struct Candidate<'pat, 'tcx:'pat> {\n #[derive(Clone, Debug)]\n struct Binding<'tcx> {\n     span: Span,\n-    source: Lvalue<'tcx>,\n+    source: Place<'tcx>,\n     name: Name,\n     var_id: NodeId,\n     var_ty: Ty<'tcx>,\n@@ -316,7 +316,7 @@ struct Binding<'tcx> {\n #[derive(Clone, Debug)]\n pub struct MatchPair<'pat, 'tcx:'pat> {\n     // this lvalue...\n-    lvalue: Lvalue<'tcx>,\n+    lvalue: Place<'tcx>,\n \n     // ... must match this pattern.\n     pattern: &'pat Pattern<'tcx>,"}, {"sha": "2e866013fd33924a0c5f9e6a676b172866efa6a7", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -109,7 +109,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn add_cases_to_switch<'pat>(&mut self,\n-                                     test_lvalue: &Lvalue<'tcx>,\n+                                     test_lvalue: &Place<'tcx>,\n                                      candidate: &Candidate<'pat, 'tcx>,\n                                      switch_ty: Ty<'tcx>,\n                                      options: &mut Vec<&'tcx ty::Const<'tcx>>,\n@@ -150,7 +150,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn add_variants_to_switch<'pat>(&mut self,\n-                                        test_lvalue: &Lvalue<'tcx>,\n+                                        test_lvalue: &Place<'tcx>,\n                                         candidate: &Candidate<'pat, 'tcx>,\n                                         variants: &mut BitVector)\n                                         -> bool\n@@ -177,7 +177,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// Generates the code to perform a test.\n     pub fn perform_test(&mut self,\n                         block: BasicBlock,\n-                        lvalue: &Lvalue<'tcx>,\n+                        lvalue: &Place<'tcx>,\n                         test: &Test<'tcx>)\n                         -> Vec<BasicBlock> {\n         let source_info = self.source_info(test.span);\n@@ -430,7 +430,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// not apply to this candidate, but it might be we can get\n     /// tighter match code if we do something a bit different.\n     pub fn sort_candidate<'pat>(&mut self,\n-                                test_lvalue: &Lvalue<'tcx>,\n+                                test_lvalue: &Place<'tcx>,\n                                 test: &Test<'tcx>,\n                                 candidate: &Candidate<'pat, 'tcx>,\n                                 resulting_candidates: &mut [Vec<Candidate<'pat, 'tcx>>])"}, {"sha": "cf8e4fd167c5e8338eb36417737513b2dae9d0ab", "filename": "src/librustc_mir/build/matches/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -16,7 +16,7 @@ use std::u32;\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn field_match_pairs<'pat>(&mut self,\n-                                   lvalue: Lvalue<'tcx>,\n+                                   lvalue: Place<'tcx>,\n                                    subpatterns: &'pat [FieldPattern<'tcx>])\n                                    -> Vec<MatchPair<'pat, 'tcx>> {\n         subpatterns.iter()\n@@ -30,7 +30,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n     pub fn prefix_slice_suffix<'pat>(&mut self,\n                                      match_pairs: &mut Vec<MatchPair<'pat, 'tcx>>,\n-                                     lvalue: &Lvalue<'tcx>,\n+                                     lvalue: &Place<'tcx>,\n                                      prefix: &'pat [Pattern<'tcx>],\n                                      opt_slice: Option<&'pat Pattern<'tcx>>,\n                                      suffix: &'pat [Pattern<'tcx>]) {\n@@ -78,7 +78,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n }\n \n impl<'pat, 'tcx> MatchPair<'pat, 'tcx> {\n-    pub fn new(lvalue: Lvalue<'tcx>, pattern: &'pat Pattern<'tcx>) -> MatchPair<'pat, 'tcx> {\n+    pub fn new(lvalue: Place<'tcx>, pattern: &'pat Pattern<'tcx>) -> MatchPair<'pat, 'tcx> {\n         MatchPair {\n             lvalue,\n             pattern,"}, {"sha": "d24ee4bf153f15824a85ade1ffea9c6d72513902", "filename": "src/librustc_mir/build/misc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -27,9 +27,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     ///\n     /// NB: **No cleanup is scheduled for this temporary.** You should\n     /// call `schedule_drop` once the temporary is initialized.\n-    pub fn temp(&mut self, ty: Ty<'tcx>, span: Span) -> Lvalue<'tcx> {\n+    pub fn temp(&mut self, ty: Ty<'tcx>, span: Span) -> Place<'tcx> {\n         let temp = self.local_decls.push(LocalDecl::new_temp(ty, span));\n-        let lvalue = Lvalue::Local(temp);\n+        let lvalue = Place::Local(temp);\n         debug!(\"temp: created temp {:?} with type {:?}\",\n                lvalue, self.local_decls[temp].ty);\n         lvalue\n@@ -121,7 +121,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                       block: BasicBlock,\n                       source_info: SourceInfo,\n                       value: u64)\n-                      -> Lvalue<'tcx> {\n+                      -> Place<'tcx> {\n         let usize_ty = self.hir.usize_ty();\n         let temp = self.temp(usize_ty, source_info.span);\n         self.cfg.push_assign_constant(\n@@ -134,7 +134,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         temp\n     }\n \n-    pub fn consume_by_copy_or_move(&self, lvalue: Lvalue<'tcx>) -> Operand<'tcx> {\n+    pub fn consume_by_copy_or_move(&self, lvalue: Place<'tcx>) -> Operand<'tcx> {\n         let tcx = self.hir.tcx();\n         let ty = lvalue.ty(&self.local_decls, tcx).to_ty(tcx);\n         if self.hir.type_moves_by_default(ty, DUMMY_SP) {"}, {"sha": "b65c1036eb8d9a27e2aad72b1a9040cc3172616f", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -309,7 +309,7 @@ struct Builder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     /// Maps node ids of variable bindings to the `Local`s created for them.\n     var_indices: NodeMap<Local>,\n     local_decls: IndexVec<Local, LocalDecl<'tcx>>,\n-    unit_temp: Option<Lvalue<'tcx>>,\n+    unit_temp: Option<Place<'tcx>>,\n \n     /// cached block with the RESUME terminator; this is created\n     /// when first set of cleanups are built.\n@@ -480,7 +480,7 @@ fn construct_const<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n \n     let mut block = START_BLOCK;\n     let expr = builder.hir.mirror(ast_expr);\n-    unpack!(block = builder.into_expr(&Lvalue::Local(RETURN_POINTER), block, expr));\n+    unpack!(block = builder.into_expr(&Place::Local(RETURN_POINTER), block, expr));\n \n     let source_info = builder.source_info(span);\n     builder.cfg.terminate(block, source_info, TerminatorKind::Return);\n@@ -599,7 +599,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         for (index, &(ty, pattern)) in arguments.iter().enumerate() {\n             // Function arguments always get the first Local indices after the return pointer\n             let local = Local::new(index + 1);\n-            let lvalue = Lvalue::Local(local);\n+            let lvalue = Place::Local(local);\n \n             if let Some(pattern) = pattern {\n                 let pattern = self.hir.pattern_from_hir(pattern);\n@@ -630,10 +630,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         }\n \n         let body = self.hir.mirror(ast_body);\n-        self.into(&Lvalue::Local(RETURN_POINTER), block, body)\n+        self.into(&Place::Local(RETURN_POINTER), block, body)\n     }\n \n-    fn get_unit_temp(&mut self) -> Lvalue<'tcx> {\n+    fn get_unit_temp(&mut self) -> Place<'tcx> {\n         match self.unit_temp {\n             Some(ref tmp) => tmp.clone(),\n             None => {"}, {"sha": "aeda34a7a574d10c080c2babd77bd4368aa17fae", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -142,7 +142,7 @@ struct DropData<'tcx> {\n     span: Span,\n \n     /// lvalue to drop\n-    location: Lvalue<'tcx>,\n+    location: Place<'tcx>,\n \n     /// Whether this is a full value Drop, or just a StorageDead.\n     kind: DropKind\n@@ -184,7 +184,7 @@ pub struct BreakableScope<'tcx> {\n     pub break_block: BasicBlock,\n     /// The destination of the loop/block expression itself (i.e. where to put the result of a\n     /// `break` expression)\n-    pub break_destination: Lvalue<'tcx>,\n+    pub break_destination: Place<'tcx>,\n }\n \n impl CachedBlock {\n@@ -270,7 +270,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn in_breakable_scope<F, R>(&mut self,\n                                     loop_block: Option<BasicBlock>,\n                                     break_block: BasicBlock,\n-                                    break_destination: Lvalue<'tcx>,\n+                                    break_destination: Place<'tcx>,\n                                     f: F) -> R\n         where F: FnOnce(&mut Builder<'a, 'gcx, 'tcx>) -> R\n     {\n@@ -613,15 +613,15 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn schedule_drop(&mut self,\n                          span: Span,\n                          region_scope: region::Scope,\n-                         lvalue: &Lvalue<'tcx>,\n+                         lvalue: &Place<'tcx>,\n                          lvalue_ty: Ty<'tcx>) {\n         let needs_drop = self.hir.needs_drop(lvalue_ty);\n         let drop_kind = if needs_drop {\n             DropKind::Value { cached_block: CachedBlock::default() }\n         } else {\n             // Only temps and vars need their storage dead.\n             match *lvalue {\n-                Lvalue::Local(index) if index.index() > self.arg_count => DropKind::Storage,\n+                Place::Local(index) if index.index() > self.arg_count => DropKind::Storage,\n                 _ => return\n             }\n         };\n@@ -748,7 +748,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn build_drop(&mut self,\n                       block: BasicBlock,\n                       span: Span,\n-                      location: Lvalue<'tcx>,\n+                      location: Place<'tcx>,\n                       ty: Ty<'tcx>) -> BlockAnd<()> {\n         if !self.hir.needs_drop(ty) {\n             return block.unit();\n@@ -769,7 +769,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn build_drop_and_replace(&mut self,\n                                   block: BasicBlock,\n                                   span: Span,\n-                                  location: Lvalue<'tcx>,\n+                                  location: Place<'tcx>,\n                                   value: Operand<'tcx>) -> BlockAnd<()> {\n         let source_info = self.source_info(span);\n         let next_target = self.cfg.start_new_block();\n@@ -883,7 +883,7 @@ fn build_scope_drops<'tcx>(cfg: &mut CFG<'tcx>,\n         // Drop the storage for both value and storage drops.\n         // Only temps and vars need their storage dead.\n         match drop_data.location {\n-            Lvalue::Local(index) if index.index() > arg_count => {\n+            Place::Local(index) if index.index() > arg_count => {\n                 cfg.push(block, Statement {\n                     source_info,\n                     kind: StatementKind::StorageDead(index)"}, {"sha": "981d0b9f0d978d7cc5641b6296ebb2d9469b9d9a", "filename": "src/librustc_mir/dataflow/drop_flag_effects.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -20,12 +20,12 @@ pub fn move_path_children_matching<'tcx, F>(move_data: &MoveData<'tcx>,\n                                         path: MovePathIndex,\n                                         mut cond: F)\n                                         -> Option<MovePathIndex>\n-    where F: FnMut(&mir::LvalueProjection<'tcx>) -> bool\n+    where F: FnMut(&mir::PlaceProjection<'tcx>) -> bool\n {\n     let mut next_child = move_data.move_paths[path].first_child;\n     while let Some(child_index) = next_child {\n         match move_data.move_paths[child_index].lvalue {\n-            mir::Lvalue::Projection(ref proj) => {\n+            mir::Place::Projection(ref proj) => {\n                 if cond(proj) {\n                     return Some(child_index)\n                 }\n@@ -42,12 +42,12 @@ pub fn move_path_children_matching<'tcx, F>(move_data: &MoveData<'tcx>,\n /// paths (1.) past arrays, slices, and pointers, nor (2.) into a type\n /// that implements `Drop`.\n ///\n-/// Lvalues behind references or arrays are not tracked by elaboration\n+/// Places behind references or arrays are not tracked by elaboration\n /// and are always assumed to be initialized when accessible. As\n /// references and indexes can be reseated, trying to track them can\n /// only lead to trouble.\n ///\n-/// Lvalues behind ADT's with a Drop impl are not tracked by\n+/// Places behind ADT's with a Drop impl are not tracked by\n /// elaboration since they can never have a drop-flag state that\n /// differs from that of the parent with the Drop impl.\n ///\n@@ -58,7 +58,7 @@ pub fn move_path_children_matching<'tcx, F>(move_data: &MoveData<'tcx>,\n /// FIXME: we have to do something for moving slice patterns.\n fn lvalue_contents_drop_state_cannot_differ<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                                             mir: &Mir<'tcx>,\n-                                                            lv: &mir::Lvalue<'tcx>) -> bool {\n+                                                            lv: &mir::Place<'tcx>) -> bool {\n     let ty = lv.ty(mir, tcx).to_ty(tcx);\n     match ty.sty {\n         ty::TyArray(..) | ty::TySlice(..) | ty::TyRef(..) | ty::TyRawPtr(..) => {\n@@ -168,7 +168,7 @@ pub(crate) fn drop_flag_effects_for_function_entry<'a, 'gcx, 'tcx, F>(\n {\n     let move_data = &ctxt.move_data;\n     for arg in mir.args_iter() {\n-        let lvalue = mir::Lvalue::Local(arg);\n+        let lvalue = mir::Place::Local(arg);\n         let lookup_result = move_data.rev_lookup.find(&lvalue);\n         on_lookup_result_bits(tcx, mir, move_data,\n                               lookup_result,"}, {"sha": "83a988760c4d1fed72bb8770ba6076a8a02d9b3b", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -50,7 +50,7 @@ pub struct BorrowData<'tcx> {\n     pub(crate) location: Location,\n     pub(crate) kind: mir::BorrowKind,\n     pub(crate) region: Region<'tcx>,\n-    pub(crate) lvalue: mir::Lvalue<'tcx>,\n+    pub(crate) lvalue: mir::Place<'tcx>,\n }\n \n impl<'tcx> fmt::Display for BorrowData<'tcx> {\n@@ -269,7 +269,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n                              _in_out: &mut IdxSet<BorrowIndex>,\n                              _call_bb: mir::BasicBlock,\n                              _dest_bb: mir::BasicBlock,\n-                             _dest_lval: &mir::Lvalue) {\n+                             _dest_lval: &mir::Place) {\n         // there are no effects on the region scopes from method calls.\n     }\n }\n@@ -291,9 +291,9 @@ impl<'a, 'gcx, 'tcx> DataflowOperator for Borrows<'a, 'gcx, 'tcx> {\n fn is_unsafe_lvalue<'a, 'gcx: 'tcx, 'tcx: 'a>(\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     mir: &'a Mir<'tcx>,\n-    lvalue: &mir::Lvalue<'tcx>\n+    lvalue: &mir::Place<'tcx>\n ) -> bool {\n-    use self::mir::Lvalue::*;\n+    use self::mir::Place::*;\n     use self::mir::ProjectionElem;\n \n     match *lvalue {"}, {"sha": "94c928f5565dac489f3aaed051fd94fd8d1b9758", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -368,7 +368,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for MaybeInitializedLvals<'a, 'gcx, 'tcx> {\n                              in_out: &mut IdxSet<MovePathIndex>,\n                              _call_bb: mir::BasicBlock,\n                              _dest_bb: mir::BasicBlock,\n-                             dest_lval: &mir::Lvalue) {\n+                             dest_lval: &mir::Place) {\n         // when a call returns successfully, that means we need to set\n         // the bits for that dest_lval to 1 (initialized).\n         on_lookup_result_bits(self.tcx, self.mir, self.move_data(),\n@@ -423,7 +423,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for MaybeUninitializedLvals<'a, 'gcx, 'tcx> {\n                              in_out: &mut IdxSet<MovePathIndex>,\n                              _call_bb: mir::BasicBlock,\n                              _dest_bb: mir::BasicBlock,\n-                             dest_lval: &mir::Lvalue) {\n+                             dest_lval: &mir::Place) {\n         // when a call returns successfully, that means we need to set\n         // the bits for that dest_lval to 0 (initialized).\n         on_lookup_result_bits(self.tcx, self.mir, self.move_data(),\n@@ -477,7 +477,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for DefinitelyInitializedLvals<'a, 'gcx, 'tcx\n                              in_out: &mut IdxSet<MovePathIndex>,\n                              _call_bb: mir::BasicBlock,\n                              _dest_bb: mir::BasicBlock,\n-                             dest_lval: &mir::Lvalue) {\n+                             dest_lval: &mir::Place) {\n         // when a call returns successfully, that means we need to set\n         // the bits for that dest_lval to 1 (initialized).\n         on_lookup_result_bits(self.tcx, self.mir, self.move_data(),\n@@ -561,7 +561,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for MovingOutStatements<'a, 'gcx, 'tcx> {\n                              in_out: &mut IdxSet<MoveOutIndex>,\n                              _call_bb: mir::BasicBlock,\n                              _dest_bb: mir::BasicBlock,\n-                             dest_lval: &mir::Lvalue) {\n+                             dest_lval: &mir::Place) {\n         let move_data = self.move_data();\n         let bits_per_block = self.bits_per_block();\n \n@@ -612,7 +612,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for EverInitializedLvals<'a, 'gcx, 'tcx> {\n             mir::StatementKind::StorageDead(local) => {\n                 // End inits for StorageDead, so that an immutable variable can\n                 // be reinitialized on the next iteration of the loop.\n-                if let LookupResult::Exact(mpi) = rev_lookup.find(&mir::Lvalue::Local(local)) {\n+                if let LookupResult::Exact(mpi) = rev_lookup.find(&mir::Place::Local(local)) {\n                     debug!(\"stmt {:?} at loc {:?} clears the ever initialized status of {:?}\",\n                         stmt, location, &init_path_map[mpi]);\n                     for ii in &init_path_map[mpi] {\n@@ -647,7 +647,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for EverInitializedLvals<'a, 'gcx, 'tcx> {\n                              in_out: &mut IdxSet<InitIndex>,\n                              call_bb: mir::BasicBlock,\n                              _dest_bb: mir::BasicBlock,\n-                             _dest_lval: &mir::Lvalue) {\n+                             _dest_lval: &mir::Place) {\n         let move_data = self.move_data();\n         let bits_per_block = self.bits_per_block();\n         let init_loc_map = &move_data.init_loc_map;"}, {"sha": "484dcf99a9b6c3b225209e37633e7ebd92cd8da1", "filename": "src/librustc_mir/dataflow/impls/storage_liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -62,7 +62,7 @@ impl<'a, 'tcx> BitDenotation for MaybeStorageLive<'a, 'tcx> {\n                              _in_out: &mut IdxSet<Local>,\n                              _call_bb: mir::BasicBlock,\n                              _dest_bb: mir::BasicBlock,\n-                             _dest_lval: &mir::Lvalue) {\n+                             _dest_lval: &mir::Place) {\n         // Nothing to do when a call returns successfully\n     }\n }"}, {"sha": "4851f5c96683addcb2f30acd612dbed7870dd93b", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -610,7 +610,7 @@ pub trait BitDenotation: DataflowOperator {\n                              in_out: &mut IdxSet<Self::Idx>,\n                              call_bb: mir::BasicBlock,\n                              dest_bb: mir::BasicBlock,\n-                             dest_lval: &mir::Lvalue);\n+                             dest_lval: &mir::Place);\n }\n \n impl<'a, 'gcx, 'tcx: 'a, D> DataflowAnalysis<'a, 'tcx, D> where D: BitDenotation"}, {"sha": "4d20857bc2ec80ebb70a1ead79ffa485dc99c6cb", "filename": "src/librustc_mir/dataflow/move_paths/abs_domain.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fabs_domain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fabs_domain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fabs_domain.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n //! The move-analysis portion of borrowck needs to work in an abstract\n-//! domain of lifted Lvalues.  Most of the Lvalue variants fall into a\n+//! domain of lifted Places.  Most of the Place variants fall into a\n //! one-to-one mapping between the concrete and abstract (e.g. a\n //! field-deref on a local-variable, `x.field`, has the same meaning\n //! in both domains). Indexed-Projections are the exception: `a[x]`\n@@ -21,7 +21,7 @@\n //! `a[x]` would still overlap them both. But that is not this\n //! representation does today.)\n \n-use rustc::mir::{Local, LvalueElem, Operand, ProjectionElem};\n+use rustc::mir::{Local, PlaceElem, Operand, ProjectionElem};\n use rustc::ty::Ty;\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n@@ -47,7 +47,7 @@ impl<'tcx> Lift for Ty<'tcx> {\n     type Abstract = AbstractType;\n     fn lift(&self) -> Self::Abstract { AbstractType }\n }\n-impl<'tcx> Lift for LvalueElem<'tcx> {\n+impl<'tcx> Lift for PlaceElem<'tcx> {\n     type Abstract = AbstractElem<'tcx>;\n     fn lift(&self) -> Self::Abstract {\n         match *self {"}, {"sha": "3d623acb415ce13370ebf2938d90fcdacdeef87c", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -44,7 +44,7 @@ impl<'a, 'gcx, 'tcx> MoveDataBuilder<'a, 'gcx, 'tcx> {\n                 moves: IndexVec::new(),\n                 loc_map: LocationMap::new(mir),\n                 rev_lookup: MovePathLookup {\n-                    locals: mir.local_decls.indices().map(Lvalue::Local).map(|v| {\n+                    locals: mir.local_decls.indices().map(Place::Local).map(|v| {\n                         Self::new_move_path(\n                             &mut move_paths,\n                             &mut path_map,\n@@ -68,7 +68,7 @@ impl<'a, 'gcx, 'tcx> MoveDataBuilder<'a, 'gcx, 'tcx> {\n                      path_map: &mut IndexVec<MovePathIndex, Vec<MoveOutIndex>>,\n                      init_path_map: &mut IndexVec<MovePathIndex, Vec<InitIndex>>,\n                      parent: Option<MovePathIndex>,\n-                     lvalue: Lvalue<'tcx>)\n+                     lvalue: Place<'tcx>)\n                      -> MovePathIndex\n     {\n         let move_path = move_paths.push(MovePath {\n@@ -102,31 +102,31 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n     /// problematic for borrowck.\n     ///\n     /// Maybe we should have separate \"borrowck\" and \"moveck\" modes.\n-    fn move_path_for(&mut self, lval: &Lvalue<'tcx>)\n+    fn move_path_for(&mut self, lval: &Place<'tcx>)\n                      -> Result<MovePathIndex, MoveError<'tcx>>\n     {\n         debug!(\"lookup({:?})\", lval);\n         match *lval {\n-            Lvalue::Local(local) => Ok(self.builder.data.rev_lookup.locals[local]),\n-            Lvalue::Static(..) => {\n+            Place::Local(local) => Ok(self.builder.data.rev_lookup.locals[local]),\n+            Place::Static(..) => {\n                 let span = self.builder.mir.source_info(self.loc).span;\n                 Err(MoveError::cannot_move_out_of(span, Static))\n             }\n-            Lvalue::Projection(ref proj) => {\n+            Place::Projection(ref proj) => {\n                 self.move_path_for_projection(lval, proj)\n             }\n         }\n     }\n \n-    fn create_move_path(&mut self, lval: &Lvalue<'tcx>) {\n+    fn create_move_path(&mut self, lval: &Place<'tcx>) {\n         // This is an assignment, not a move, so this not being a valid\n         // move path is OK.\n         let _ = self.move_path_for(lval);\n     }\n \n     fn move_path_for_projection(&mut self,\n-                                lval: &Lvalue<'tcx>,\n-                                proj: &LvalueProjection<'tcx>)\n+                                lval: &Place<'tcx>,\n+                                proj: &PlaceProjection<'tcx>)\n                                 -> Result<MovePathIndex, MoveError<'tcx>>\n     {\n         let base = try!(self.move_path_for(&proj.base));\n@@ -280,7 +280,7 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n             }\n             StatementKind::StorageLive(_) => {}\n             StatementKind::StorageDead(local) => {\n-                self.gather_move(&Lvalue::Local(local));\n+                self.gather_move(&Place::Local(local));\n             }\n             StatementKind::SetDiscriminant{ .. } => {\n                 span_bug!(stmt.source_info.span,\n@@ -339,7 +339,7 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n             TerminatorKind::Unreachable => { }\n \n             TerminatorKind::Return => {\n-                self.gather_move(&Lvalue::Local(RETURN_POINTER));\n+                self.gather_move(&Place::Local(RETURN_POINTER));\n             }\n \n             TerminatorKind::Assert { .. } |\n@@ -382,7 +382,7 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn gather_move(&mut self, lval: &Lvalue<'tcx>) {\n+    fn gather_move(&mut self, lval: &Place<'tcx>) {\n         debug!(\"gather_move({:?}, {:?})\", self.loc, lval);\n \n         let path = match self.move_path_for(lval) {\n@@ -401,7 +401,7 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n         self.builder.data.loc_map[self.loc].push(move_out);\n     }\n \n-    fn gather_init(&mut self, lval: &Lvalue<'tcx>, kind: InitKind) {\n+    fn gather_init(&mut self, lval: &Place<'tcx>, kind: InitKind) {\n         debug!(\"gather_init({:?}, {:?})\", self.loc, lval);\n \n         if let LookupResult::Exact(path) = self.builder.data.rev_lookup.find(lval) {"}, {"sha": "5e20d9dafd1f7e6be1e9c0bac7be298996d626e1", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -94,7 +94,7 @@ pub struct MovePath<'tcx> {\n     pub next_sibling: Option<MovePathIndex>,\n     pub first_child: Option<MovePathIndex>,\n     pub parent: Option<MovePathIndex>,\n-    pub lvalue: Lvalue<'tcx>,\n+    pub lvalue: Place<'tcx>,\n }\n \n impl<'tcx> fmt::Debug for MovePath<'tcx> {\n@@ -246,11 +246,11 @@ impl<'tcx> MovePathLookup<'tcx> {\n     // alternative will *not* create a MovePath on the fly for an\n     // unknown l-value, but will rather return the nearest available\n     // parent.\n-    pub fn find(&self, lval: &Lvalue<'tcx>) -> LookupResult {\n+    pub fn find(&self, lval: &Place<'tcx>) -> LookupResult {\n         match *lval {\n-            Lvalue::Local(local) => LookupResult::Exact(self.locals[local]),\n-            Lvalue::Static(..) => LookupResult::Parent(None),\n-            Lvalue::Projection(ref proj) => {\n+            Place::Local(local) => LookupResult::Exact(self.locals[local]),\n+            Place::Static(..) => LookupResult::Parent(None),\n+            Place::Projection(ref proj) => {\n                 match self.find(&proj.base) {\n                     LookupResult::Exact(base_path) => {\n                         match self.projections.get(&(base_path, proj.elem.lift())) {"}, {"sha": "767ccda67416af215836b1c9ec5d8b34333255a0", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -216,7 +216,7 @@ fn build_drop_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 tcx,\n                 param_env\n             };\n-            let dropee = Lvalue::Local(Local::new(1+0)).deref();\n+            let dropee = Place::Local(Local::new(1+0)).deref();\n             let resume_block = elaborator.patch.resume_block();\n             elaborate_drops::elaborate_drop(\n                 &mut elaborator,\n@@ -381,30 +381,30 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n     }\n \n     fn copy_shim(&mut self) {\n-        let rcvr = Lvalue::Local(Local::new(1+0)).deref();\n+        let rcvr = Place::Local(Local::new(1+0)).deref();\n         let ret_statement = self.make_statement(\n             StatementKind::Assign(\n-                Lvalue::Local(RETURN_POINTER),\n+                Place::Local(RETURN_POINTER),\n                 Rvalue::Use(Operand::Copy(rcvr))\n             )\n         );\n         self.block(vec![ret_statement], TerminatorKind::Return, false);\n     }\n \n-    fn make_lvalue(&mut self, mutability: Mutability, ty: Ty<'tcx>) -> Lvalue<'tcx> {\n+    fn make_lvalue(&mut self, mutability: Mutability, ty: Ty<'tcx>) -> Place<'tcx> {\n         let span = self.span;\n-        Lvalue::Local(\n+        Place::Local(\n             self.local_decls.push(temp_decl(mutability, ty, span))\n         )\n     }\n \n     fn make_clone_call(\n         &mut self,\n         ty: Ty<'tcx>,\n-        rcvr_field: Lvalue<'tcx>,\n+        rcvr_field: Place<'tcx>,\n         next: BasicBlock,\n         cleanup: BasicBlock\n-    ) -> Lvalue<'tcx> {\n+    ) -> Place<'tcx> {\n         let tcx = self.tcx;\n \n         let substs = Substs::for_item(\n@@ -458,8 +458,8 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n \n     fn loop_header(\n         &mut self,\n-        beg: Lvalue<'tcx>,\n-        end: Lvalue<'tcx>,\n+        beg: Place<'tcx>,\n+        end: Place<'tcx>,\n         loop_body: BasicBlock,\n         loop_end: BasicBlock,\n         is_cleanup: bool\n@@ -499,7 +499,7 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n     fn array_shim(&mut self, ty: Ty<'tcx>, len: u64) {\n         let tcx = self.tcx;\n         let span = self.span;\n-        let rcvr = Lvalue::Local(Local::new(1+0)).deref();\n+        let rcvr = Place::Local(Local::new(1+0)).deref();\n \n         let beg = self.local_decls.push(temp_decl(Mutability::Mut, tcx.types.usize, span));\n         let end = self.make_lvalue(Mutability::Not, tcx.types.usize);\n@@ -512,7 +512,7 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n         let inits = vec![\n             self.make_statement(\n                 StatementKind::Assign(\n-                    Lvalue::Local(beg),\n+                    Place::Local(beg),\n                     Rvalue::Use(Operand::Constant(self.make_usize(0)))\n                 )\n             ),\n@@ -530,7 +530,7 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n         //     BB #3;\n         // }\n         // BB #4;\n-        self.loop_header(Lvalue::Local(beg), end, BasicBlock::new(2), BasicBlock::new(4), false);\n+        self.loop_header(Place::Local(beg), end, BasicBlock::new(2), BasicBlock::new(4), false);\n \n         // BB #2\n         // `let cloned = Clone::clone(rcvr[beg])`;\n@@ -552,10 +552,10 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n             ),\n             self.make_statement(\n                 StatementKind::Assign(\n-                    Lvalue::Local(beg),\n+                    Place::Local(beg),\n                     Rvalue::BinaryOp(\n                         BinOp::Add,\n-                        Operand::Copy(Lvalue::Local(beg)),\n+                        Operand::Copy(Place::Local(beg)),\n                         Operand::Constant(self.make_usize(1))\n                     )\n                 )\n@@ -567,7 +567,7 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n         // `return ret;`\n         let ret_statement = self.make_statement(\n             StatementKind::Assign(\n-                Lvalue::Local(RETURN_POINTER),\n+                Place::Local(RETURN_POINTER),\n                 Rvalue::Use(Operand::Move(ret.clone())),\n             )\n         );\n@@ -581,7 +581,7 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n         let beg = self.local_decls.push(temp_decl(Mutability::Mut, tcx.types.usize, span));\n         let init = self.make_statement(\n             StatementKind::Assign(\n-                Lvalue::Local(beg),\n+                Place::Local(beg),\n                 Rvalue::Use(Operand::Constant(self.make_usize(0)))\n             )\n         );\n@@ -592,7 +592,7 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n         //     BB #8;\n         // }\n         // BB #9;\n-        self.loop_header(Lvalue::Local(beg), Lvalue::Local(end),\n+        self.loop_header(Place::Local(beg), Place::Local(end),\n                          BasicBlock::new(7), BasicBlock::new(9), true);\n \n         // BB #7 (cleanup)\n@@ -608,10 +608,10 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n         // `goto #6;`\n         let statement = self.make_statement(\n             StatementKind::Assign(\n-                Lvalue::Local(beg),\n+                Place::Local(beg),\n                 Rvalue::BinaryOp(\n                     BinOp::Add,\n-                    Operand::Copy(Lvalue::Local(beg)),\n+                    Operand::Copy(Place::Local(beg)),\n                     Operand::Constant(self.make_usize(1))\n                 )\n             )\n@@ -628,7 +628,7 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n             _ => bug!(\"only tuples and closures are accepted\"),\n         };\n \n-        let rcvr = Lvalue::Local(Local::new(1+0)).deref();\n+        let rcvr = Place::Local(Local::new(1+0)).deref();\n \n         let mut returns = Vec::new();\n         for (i, ity) in tys.iter().enumerate() {\n@@ -663,7 +663,7 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n         // `return kind(returns[0], returns[1], ..., returns[tys.len() - 1]);`\n         let ret_statement = self.make_statement(\n             StatementKind::Assign(\n-                Lvalue::Local(RETURN_POINTER),\n+                Place::Local(RETURN_POINTER),\n                 Rvalue::Aggregate(\n                     box kind,\n                     returns.into_iter().map(Operand::Move).collect()\n@@ -701,7 +701,7 @@ fn build_call_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let source_info = SourceInfo { span, scope: ARGUMENT_VISIBILITY_SCOPE };\n \n     let rcvr_arg = Local::new(1+0);\n-    let rcvr_l = Lvalue::Local(rcvr_arg);\n+    let rcvr_l = Place::Local(rcvr_arg);\n     let mut statements = vec![];\n \n     let rcvr = match rcvr_adjustment {\n@@ -720,11 +720,11 @@ fn build_call_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             statements.push(Statement {\n                 source_info,\n                 kind: StatementKind::Assign(\n-                    Lvalue::Local(ref_rcvr),\n+                    Place::Local(ref_rcvr),\n                     Rvalue::Ref(tcx.types.re_erased, BorrowKind::Mut, rcvr_l)\n                 )\n             });\n-            Operand::Move(Lvalue::Local(ref_rcvr))\n+            Operand::Move(Place::Local(ref_rcvr))\n         }\n     };\n \n@@ -749,12 +749,12 @@ fn build_call_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     if let Some(untuple_args) = untuple_args {\n         args.extend(untuple_args.iter().enumerate().map(|(i, ity)| {\n-            let arg_lv = Lvalue::Local(Local::new(1+1));\n+            let arg_lv = Place::Local(Local::new(1+1));\n             Operand::Move(arg_lv.field(Field::new(i), *ity))\n         }));\n     } else {\n         args.extend((1..sig.inputs().len()).map(|i| {\n-            Operand::Move(Lvalue::Local(Local::new(1+i)))\n+            Operand::Move(Place::Local(Local::new(1+i)))\n         }));\n     }\n \n@@ -771,7 +771,7 @@ fn build_call_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     block(&mut blocks, statements, TerminatorKind::Call {\n         func: callee,\n         args,\n-        destination: Some((Lvalue::Local(RETURN_POINTER),\n+        destination: Some((Place::Local(RETURN_POINTER),\n                            BasicBlock::new(1))),\n         cleanup: if let Adjustment::RefMut = rcvr_adjustment {\n             Some(BasicBlock::new(3))\n@@ -783,7 +783,7 @@ fn build_call_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     if let Adjustment::RefMut = rcvr_adjustment {\n         // BB #1 - drop for Self\n         block(&mut blocks, vec![], TerminatorKind::Drop {\n-            location: Lvalue::Local(rcvr_arg),\n+            location: Place::Local(rcvr_arg),\n             target: BasicBlock::new(2),\n             unwind: None\n         }, false);\n@@ -793,7 +793,7 @@ fn build_call_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     if let Adjustment::RefMut = rcvr_adjustment {\n         // BB #3 - drop if closure panics\n         block(&mut blocks, vec![], TerminatorKind::Drop {\n-            location: Lvalue::Local(rcvr_arg),\n+            location: Place::Local(rcvr_arg),\n             target: BasicBlock::new(4),\n             unwind: None\n         }, true);\n@@ -864,11 +864,11 @@ pub fn build_adt_ctor<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a, 'gcx, 'tcx>,\n         statements: vec![Statement {\n             source_info,\n             kind: StatementKind::Assign(\n-                Lvalue::Local(RETURN_POINTER),\n+                Place::Local(RETURN_POINTER),\n                 Rvalue::Aggregate(\n                     box AggregateKind::Adt(adt_def, variant_no, substs, None),\n                     (1..sig.inputs().len()+1).map(|i| {\n-                        Operand::Move(Lvalue::Local(Local::new(i)))\n+                        Operand::Move(Place::Local(Local::new(i)))\n                     }).collect()\n                 )\n             )"}, {"sha": "203669c61baddb9fab33e492b33b2bd2f75917b5", "filename": "src/librustc_mir/transform/add_moves_for_packed_drops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -131,10 +131,10 @@ fn add_move_for_packed_drop<'a, 'tcx>(\n \n     patch.add_statement(\n         loc, StatementKind::StorageLive(temp));\n-    patch.add_assign(loc, Lvalue::Local(temp),\n+    patch.add_assign(loc, Place::Local(temp),\n                      Rvalue::Use(Operand::Move(location.clone())));\n     patch.patch_terminator(loc.block, TerminatorKind::Drop {\n-        location: Lvalue::Local(temp),\n+        location: Place::Local(temp),\n         target: storage_dead_block,\n         unwind\n     });"}, {"sha": "fa90d511d943a9cc7a54972df8ef4eabc1c4e962", "filename": "src/librustc_mir/transform/add_validation.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -24,13 +24,13 @@ pub struct AddValidation;\n \n /// Determine the \"context\" of the lval: Mutability and region.\n fn lval_context<'a, 'tcx, D>(\n-    lval: &Lvalue<'tcx>,\n+    lval: &Place<'tcx>,\n     local_decls: &D,\n     tcx: TyCtxt<'a, 'tcx, 'tcx>\n ) -> (Option<region::Scope>, hir::Mutability)\n     where D: HasLocalDecls<'tcx>\n {\n-    use rustc::mir::Lvalue::*;\n+    use rustc::mir::Place::*;\n \n     match *lval {\n         Local { .. } => (None, hir::MutMutable),\n@@ -199,7 +199,7 @@ impl MirPass for AddValidation {\n         let local_decls = mir.local_decls.clone(); // FIXME: Find a way to get rid of this clone.\n \n         // Convert an lvalue to a validation operand.\n-        let lval_to_operand = |lval: Lvalue<'tcx>| -> ValidationOperand<'tcx, Lvalue<'tcx>> {\n+        let lval_to_operand = |lval: Place<'tcx>| -> ValidationOperand<'tcx, Place<'tcx>> {\n             let (re, mutbl) = lval_context(&lval, &local_decls, tcx);\n             let ty = lval.ty(&local_decls, tcx).to_ty(tcx);\n             ValidationOperand { lval, ty, re, mutbl }\n@@ -237,14 +237,14 @@ impl MirPass for AddValidation {\n             };\n             // Gather all arguments, skip return value.\n             let operands = mir.local_decls.iter_enumerated().skip(1).take(mir.arg_count)\n-                    .map(|(local, _)| lval_to_operand(Lvalue::Local(local))).collect();\n+                    .map(|(local, _)| lval_to_operand(Place::Local(local))).collect();\n             emit_acquire(&mut mir.basic_blocks_mut()[START_BLOCK], source_info, operands);\n         }\n \n         // PART 2\n         // Add ReleaseValid/AcquireValid around function call terminators.  We don't use a visitor\n         // because we need to access the block that a Call jumps to.\n-        let mut returns : Vec<(SourceInfo, Lvalue<'tcx>, BasicBlock)> = Vec::new();\n+        let mut returns : Vec<(SourceInfo, Place<'tcx>, BasicBlock)> = Vec::new();\n         for block_data in mir.basic_blocks_mut() {\n             match block_data.terminator {\n                 Some(Terminator { kind: TerminatorKind::Call { ref args, ref destination, .. },\n@@ -332,7 +332,7 @@ impl MirPass for AddValidation {\n                         // Do an acquire of the result -- but only what it points to, so add a Deref\n                         // projection.\n                         let dest_lval = Projection { base: dest_lval, elem: ProjectionElem::Deref };\n-                        let dest_lval = Lvalue::Projection(Box::new(dest_lval));\n+                        let dest_lval = Place::Projection(Box::new(dest_lval));\n                         let acquire_stmt = Statement {\n                             source_info: block_data.statements[i].source_info,\n                             kind: StatementKind::Validate(ValidationOp::Acquire,"}, {"sha": "c1baf537ff92325a5801f6134a0aa83e257d4c15", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -17,7 +17,7 @@ use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::lint::builtin::{SAFE_EXTERN_STATICS, SAFE_PACKED_BORROWS, UNUSED_UNSAFE};\n use rustc::mir::*;\n-use rustc::mir::visit::{LvalueContext, Visitor};\n+use rustc::mir::visit::{PlaceContext, Visitor};\n \n use syntax::ast;\n use syntax::symbol::Symbol;\n@@ -136,10 +136,10 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n     }\n \n     fn visit_lvalue(&mut self,\n-                    lvalue: &Lvalue<'tcx>,\n-                    context: LvalueContext<'tcx>,\n+                    lvalue: &Place<'tcx>,\n+                    context: PlaceContext<'tcx>,\n                     location: Location) {\n-        if let LvalueContext::Borrow { .. } = context {\n+        if let PlaceContext::Borrow { .. } = context {\n             if util::is_disaligned(self.tcx, self.mir, self.param_env, lvalue) {\n                 let source_info = self.source_info;\n                 let lint_root =\n@@ -153,11 +153,11 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n         }\n \n         match lvalue {\n-            &Lvalue::Projection(box Projection {\n+            &Place::Projection(box Projection {\n                 ref base, ref elem\n             }) => {\n                 let old_source_info = self.source_info;\n-                if let &Lvalue::Local(local) = base {\n+                if let &Place::Local(local) = base {\n                     if self.mir.local_decls[local].internal {\n                         // Internal locals are used in the `move_val_init` desugaring.\n                         // We want to check unsafety against the source info of the\n@@ -172,8 +172,8 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                     }\n                     ty::TyAdt(adt, _) => {\n                         if adt.is_union() {\n-                            if context == LvalueContext::Store ||\n-                                context == LvalueContext::Drop\n+                            if context == PlaceContext::Store ||\n+                                context == PlaceContext::Drop\n                             {\n                                 let elem_ty = match elem {\n                                     &ProjectionElem::Field(_, ty) => ty,\n@@ -198,10 +198,10 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                 }\n                 self.source_info = old_source_info;\n             }\n-            &Lvalue::Local(..) => {\n+            &Place::Local(..) => {\n                 // locals are safe\n             }\n-            &Lvalue::Static(box Static { def_id, ty: _ }) => {\n+            &Place::Static(box Static { def_id, ty: _ }) => {\n                 if self.tcx.is_static_mut(def_id) {\n                     self.require_unsafe(\"use of mutable static\");\n                 } else if self.tcx.is_foreign_item(def_id) {"}, {"sha": "2371cbff08c1833382265d3745768dc34194f613", "filename": "src/librustc_mir/transform/copy_prop.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -30,7 +30,7 @@\n //! future.\n \n use rustc::hir;\n-use rustc::mir::{Constant, Local, LocalKind, Location, Lvalue, Mir, Operand, Rvalue, StatementKind};\n+use rustc::mir::{Constant, Local, LocalKind, Location, Place, Mir, Operand, Rvalue, StatementKind};\n use rustc::mir::visit::MutVisitor;\n use rustc::ty::TyCtxt;\n use transform::{MirPass, MirSource};\n@@ -123,7 +123,7 @@ impl MirPass for CopyPropagation {\n \n                     // That use of the source must be an assignment.\n                     match statement.kind {\n-                        StatementKind::Assign(Lvalue::Local(local), Rvalue::Use(ref operand)) if\n+                        StatementKind::Assign(Place::Local(local), Rvalue::Use(ref operand)) if\n                                 local == dest_local => {\n                             let maybe_action = match *operand {\n                                 Operand::Copy(ref src_lvalue) |\n@@ -173,12 +173,12 @@ fn eliminate_self_assignments<'tcx>(\n             if let Some(stmt) = mir[location.block].statements.get(location.statement_index) {\n                 match stmt.kind {\n                     StatementKind::Assign(\n-                        Lvalue::Local(local),\n-                        Rvalue::Use(Operand::Copy(Lvalue::Local(src_local))),\n+                        Place::Local(local),\n+                        Rvalue::Use(Operand::Copy(Place::Local(src_local))),\n                     ) |\n                     StatementKind::Assign(\n-                        Lvalue::Local(local),\n-                        Rvalue::Use(Operand::Move(Lvalue::Local(src_local))),\n+                        Place::Local(local),\n+                        Rvalue::Use(Operand::Move(Place::Local(src_local))),\n                     ) if local == dest_local && dest_local == src_local => {}\n                     _ => {\n                         continue;\n@@ -202,10 +202,10 @@ enum Action<'tcx> {\n }\n \n impl<'tcx> Action<'tcx> {\n-    fn local_copy(mir: &Mir<'tcx>, def_use_analysis: &DefUseAnalysis, src_lvalue: &Lvalue<'tcx>)\n+    fn local_copy(mir: &Mir<'tcx>, def_use_analysis: &DefUseAnalysis, src_lvalue: &Place<'tcx>)\n                   -> Option<Action<'tcx>> {\n         // The source must be a local.\n-        let src_local = if let Lvalue::Local(local) = *src_lvalue {\n+        let src_local = if let Place::Local(local) = *src_lvalue {\n             local\n         } else {\n             debug!(\"  Can't copy-propagate local: source is not a local\");\n@@ -356,8 +356,8 @@ impl<'tcx> MutVisitor<'tcx> for ConstantPropagationVisitor<'tcx> {\n         self.super_operand(operand, location);\n \n         match *operand {\n-            Operand::Copy(Lvalue::Local(local)) |\n-            Operand::Move(Lvalue::Local(local)) if local == self.dest_local => {}\n+            Operand::Copy(Place::Local(local)) |\n+            Operand::Move(Place::Local(local)) if local == self.dest_local => {}\n             _ => return,\n         }\n "}, {"sha": "74e03c2dce8236f644fdcbc4b8a096a9f9f16d35", "filename": "src/librustc_mir/transform/deaggregator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -68,15 +68,15 @@ impl MirPass for Deaggregator {\n                     let rhs = Rvalue::Use(op.clone());\n \n                     let lhs_cast = if adt_def.is_enum() {\n-                        Lvalue::Projection(Box::new(LvalueProjection {\n+                        Place::Projection(Box::new(PlaceProjection {\n                             base: lhs.clone(),\n                             elem: ProjectionElem::Downcast(adt_def, variant),\n                         }))\n                     } else {\n                         lhs.clone()\n                     };\n \n-                    let lhs_proj = Lvalue::Projection(Box::new(LvalueProjection {\n+                    let lhs_proj = Place::Projection(Box::new(PlaceProjection {\n                         base: lhs_cast,\n                         elem: ProjectionElem::Field(Field::new(i), ty),\n                     }));"}, {"sha": "8cf3929db6a69b5499698152d4d96724c0d2e7a1", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -322,8 +322,8 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         });\n     }\n \n-    fn drop_flag(&mut self, index: MovePathIndex) -> Option<Lvalue<'tcx>> {\n-        self.drop_flags.get(&index).map(|t| Lvalue::Local(*t))\n+    fn drop_flag(&mut self, index: MovePathIndex) -> Option<Place<'tcx>> {\n+        self.drop_flags.get(&index).map(|t| Place::Local(*t))\n     }\n \n     /// create a patch that elaborates all drops in the input\n@@ -451,7 +451,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n     fn elaborate_replace(\n         &mut self,\n         loc: Location,\n-        location: &Lvalue<'tcx>,\n+        location: &Place<'tcx>,\n         value: &Operand<'tcx>,\n         target: BasicBlock,\n         unwind: Option<BasicBlock>)\n@@ -538,7 +538,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         if let Some(&flag) = self.drop_flags.get(&path) {\n             let span = self.patch.source_info_for_location(self.mir, loc).span;\n             let val = self.constant_bool(span, val.value());\n-            self.patch.add_assign(loc, Lvalue::Local(flag), val);\n+            self.patch.add_assign(loc, Place::Local(flag), val);\n         }\n     }\n \n@@ -547,7 +547,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         let span = self.patch.source_info_for_location(self.mir, loc).span;\n         let false_ = self.constant_bool(span, false);\n         for flag in self.drop_flags.values() {\n-            self.patch.add_assign(loc, Lvalue::Local(*flag), false_.clone());\n+            self.patch.add_assign(loc, Place::Local(*flag), false_.clone());\n         }\n     }\n "}, {"sha": "470ce847e021a385b46ee2b7ebc7565984aa86c2", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -63,7 +63,7 @@ use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::middle::const_val::ConstVal;\n use rustc::mir::*;\n-use rustc::mir::visit::{LvalueContext, Visitor, MutVisitor};\n+use rustc::mir::visit::{PlaceContext, Visitor, MutVisitor};\n use rustc::ty::{self, TyCtxt, AdtDef, Ty, GeneratorInterior};\n use rustc::ty::subst::{Kind, Substs};\n use util::dump_mir;\n@@ -90,7 +90,7 @@ struct RenameLocalVisitor {\n impl<'tcx> MutVisitor<'tcx> for RenameLocalVisitor {\n     fn visit_local(&mut self,\n                    local: &mut Local,\n-                   _: LvalueContext<'tcx>,\n+                   _: PlaceContext<'tcx>,\n                    _: Location) {\n         if *local == self.from {\n             *local = self.to;\n@@ -103,17 +103,17 @@ struct DerefArgVisitor;\n impl<'tcx> MutVisitor<'tcx> for DerefArgVisitor {\n     fn visit_local(&mut self,\n                    local: &mut Local,\n-                   _: LvalueContext<'tcx>,\n+                   _: PlaceContext<'tcx>,\n                    _: Location) {\n         assert_ne!(*local, self_arg());\n     }\n \n     fn visit_lvalue(&mut self,\n-                    lvalue: &mut Lvalue<'tcx>,\n-                    context: LvalueContext<'tcx>,\n+                    lvalue: &mut Place<'tcx>,\n+                    context: PlaceContext<'tcx>,\n                     location: Location) {\n-        if *lvalue == Lvalue::Local(self_arg()) {\n-            *lvalue = Lvalue::Projection(Box::new(Projection {\n+        if *lvalue == Place::Local(self_arg()) {\n+            *lvalue = Place::Projection(Box::new(Projection {\n                 base: lvalue.clone(),\n                 elem: ProjectionElem::Deref,\n             }));\n@@ -162,14 +162,14 @@ impl<'a, 'tcx> TransformVisitor<'a, 'tcx> {\n         Rvalue::Aggregate(box adt, vec![val])\n     }\n \n-    // Create a Lvalue referencing a generator struct field\n-    fn make_field(&self, idx: usize, ty: Ty<'tcx>) -> Lvalue<'tcx> {\n-        let base = Lvalue::Local(self_arg());\n+    // Create a Place referencing a generator struct field\n+    fn make_field(&self, idx: usize, ty: Ty<'tcx>) -> Place<'tcx> {\n+        let base = Place::Local(self_arg());\n         let field = Projection {\n             base: base,\n             elem: ProjectionElem::Field(Field::new(idx), ty),\n         };\n-        Lvalue::Projection(Box::new(field))\n+        Place::Projection(Box::new(field))\n     }\n \n     // Create a statement which changes the generator state\n@@ -195,16 +195,16 @@ impl<'a, 'tcx> TransformVisitor<'a, 'tcx> {\n impl<'a, 'tcx> MutVisitor<'tcx> for TransformVisitor<'a, 'tcx> {\n     fn visit_local(&mut self,\n                    local: &mut Local,\n-                   _: LvalueContext<'tcx>,\n+                   _: PlaceContext<'tcx>,\n                    _: Location) {\n         assert_eq!(self.remap.get(local), None);\n     }\n \n     fn visit_lvalue(&mut self,\n-                    lvalue: &mut Lvalue<'tcx>,\n-                    context: LvalueContext<'tcx>,\n+                    lvalue: &mut Place<'tcx>,\n+                    context: PlaceContext<'tcx>,\n                     location: Location) {\n-        if let Lvalue::Local(l) = *lvalue {\n+        if let Place::Local(l) = *lvalue {\n             // Replace an Local in the remap with a generator struct access\n             if let Some(&(ty, idx)) = self.remap.get(&l) {\n                 *lvalue = self.make_field(idx, ty);\n@@ -230,7 +230,7 @@ impl<'a, 'tcx> MutVisitor<'tcx> for TransformVisitor<'a, 'tcx> {\n         let ret_val = match data.terminator().kind {\n             TerminatorKind::Return => Some((1,\n                 None,\n-                Operand::Move(Lvalue::Local(self.new_ret_local)),\n+                Operand::Move(Place::Local(self.new_ret_local)),\n                 None)),\n             TerminatorKind::Yield { ref value, resume, drop } => Some((0,\n                 Some(resume),\n@@ -244,7 +244,7 @@ impl<'a, 'tcx> MutVisitor<'tcx> for TransformVisitor<'a, 'tcx> {\n             // We must assign the value first in case it gets declared dead below\n             data.statements.push(Statement {\n                 source_info,\n-                kind: StatementKind::Assign(Lvalue::Local(RETURN_POINTER),\n+                kind: StatementKind::Assign(Place::Local(RETURN_POINTER),\n                     self.make_state(state_idx, v)),\n             });\n             let state = if let Some(resume) = resume { // Yield\n@@ -494,7 +494,7 @@ fn elaborate_generator_drops<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             &Terminator {\n                 source_info,\n                 kind: TerminatorKind::Drop {\n-                    location: Lvalue::Local(local),\n+                    location: Place::Local(local),\n                     target,\n                     unwind\n                 }\n@@ -516,7 +516,7 @@ fn elaborate_generator_drops<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             elaborate_drop(\n                 &mut elaborator,\n                 source_info,\n-                &Lvalue::Local(gen),\n+                &Place::Local(gen),\n                 (),\n                 target,\n                 unwind,\n@@ -691,7 +691,7 @@ fn insert_clean_drop<'a, 'tcx>(mir: &mut Mir<'tcx>) -> BasicBlock {\n     // Create a block to destroy an unresumed generators. This can only destroy upvars.\n     let drop_clean = BasicBlock::new(mir.basic_blocks().len());\n     let term = TerminatorKind::Drop {\n-        location: Lvalue::Local(self_arg()),\n+        location: Place::Local(self_arg()),\n         target: return_block,\n         unwind: None,\n     };\n@@ -794,7 +794,7 @@ impl MirPass for StateTransform {\n \n         let state_field = mir.upvar_decls.len();\n \n-        // Run the transformation which converts Lvalues from Local to generator struct\n+        // Run the transformation which converts Places from Local to generator struct\n         // accesses for locals in `remap`.\n         // It also rewrites `return x` and `yield y` as writing a new generator state and returning\n         // GeneratorState::Complete(x) and GeneratorState::Yielded(y) respectively."}, {"sha": "f6e4e9538b378eef5955a60113e0e5739de91e3f", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -404,12 +404,12 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n \n                 // If the call is something like `a[*i] = f(i)`, where\n                 // `i : &mut usize`, then just duplicating the `a[*i]`\n-                // Lvalue could result in two different locations if `f`\n+                // Place could result in two different locations if `f`\n                 // writes to `i`. To prevent this we need to create a temporary\n                 // borrow of the lvalue and pass the destination as `*temp` instead.\n-                fn dest_needs_borrow(lval: &Lvalue) -> bool {\n+                fn dest_needs_borrow(lval: &Place) -> bool {\n                     match *lval {\n-                        Lvalue::Projection(ref p) => {\n+                        Place::Projection(ref p) => {\n                             match p.elem {\n                                 ProjectionElem::Deref |\n                                 ProjectionElem::Index(_) => true,\n@@ -418,7 +418,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n                         }\n                         // Static variables need a borrow because the callee\n                         // might modify the same static.\n-                        Lvalue::Static(_) => true,\n+                        Place::Static(_) => true,\n                         _ => false\n                     }\n                 }\n@@ -435,7 +435,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n                     let temp = LocalDecl::new_temp(ty, callsite.location.span);\n \n                     let tmp = caller_mir.local_decls.push(temp);\n-                    let tmp = Lvalue::Local(tmp);\n+                    let tmp = Place::Local(tmp);\n \n                     let stmt = Statement {\n                         source_info: callsite.location,\n@@ -508,7 +508,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n         }\n     }\n \n-    fn cast_box_free_arg(&self, arg: Lvalue<'tcx>, ptr_ty: Ty<'tcx>,\n+    fn cast_box_free_arg(&self, arg: Place<'tcx>, ptr_ty: Ty<'tcx>,\n                          callsite: &CallSite<'tcx>, caller_mir: &mut Mir<'tcx>) -> Local {\n         let arg = Rvalue::Ref(\n             self.tcx.types.re_erased,\n@@ -518,7 +518,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n         let ty = arg.ty(caller_mir, self.tcx);\n         let ref_tmp = LocalDecl::new_temp(ty, callsite.location.span);\n         let ref_tmp = caller_mir.local_decls.push(ref_tmp);\n-        let ref_tmp = Lvalue::Local(ref_tmp);\n+        let ref_tmp = Place::Local(ref_tmp);\n \n         let ref_stmt = Statement {\n             source_info: callsite.location,\n@@ -542,7 +542,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n \n         let cast_stmt = Statement {\n             source_info: callsite.location,\n-            kind: StatementKind::Assign(Lvalue::Local(cast_tmp), raw_ptr)\n+            kind: StatementKind::Assign(Place::Local(cast_tmp), raw_ptr)\n         };\n \n         caller_mir[callsite.bb]\n@@ -588,7 +588,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n             let tuple = self.create_temp_if_necessary(args.next().unwrap(), callsite, caller_mir);\n             assert!(args.next().is_none());\n \n-            let tuple = Lvalue::Local(tuple);\n+            let tuple = Place::Local(tuple);\n             let tuple_tys = if let ty::TyTuple(s, _) = tuple.ty(caller_mir, tcx).to_ty(tcx).sty {\n                 s\n             } else {\n@@ -627,7 +627,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n         // FIXME: Analysis of the usage of the arguments to avoid\n         // unnecessary temporaries.\n \n-        if let Operand::Move(Lvalue::Local(local)) = arg {\n+        if let Operand::Move(Place::Local(local)) = arg {\n             if caller_mir.local_kind(local) == LocalKind::Temp {\n                 // Reuse the operand if it's a temporary already\n                 return local;\n@@ -645,7 +645,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n \n         let stmt = Statement {\n             source_info: callsite.location,\n-            kind: StatementKind::Assign(Lvalue::Local(arg_tmp), arg),\n+            kind: StatementKind::Assign(Place::Local(arg_tmp), arg),\n         };\n         caller_mir[callsite.bb].statements.push(stmt);\n         arg_tmp\n@@ -696,7 +696,7 @@ struct Integrator<'a, 'tcx: 'a> {\n     scope_map: IndexVec<VisibilityScope, VisibilityScope>,\n     promoted_map: IndexVec<Promoted, Promoted>,\n     _callsite: CallSite<'tcx>,\n-    destination: Lvalue<'tcx>,\n+    destination: Place<'tcx>,\n     return_block: BasicBlock,\n     cleanup_block: Option<BasicBlock>,\n     in_cleanup_block: bool,\n@@ -713,11 +713,11 @@ impl<'a, 'tcx> Integrator<'a, 'tcx> {\n impl<'a, 'tcx> MutVisitor<'tcx> for Integrator<'a, 'tcx> {\n     fn visit_local(&mut self,\n                    local: &mut Local,\n-                   _ctxt: LvalueContext<'tcx>,\n+                   _ctxt: PlaceContext<'tcx>,\n                    _location: Location) {\n         if *local == RETURN_POINTER {\n             match self.destination {\n-                Lvalue::Local(l) => {\n+                Place::Local(l) => {\n                     *local = l;\n                     return;\n                 },\n@@ -733,10 +733,10 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Integrator<'a, 'tcx> {\n     }\n \n     fn visit_lvalue(&mut self,\n-                    lvalue: &mut Lvalue<'tcx>,\n-                    _ctxt: LvalueContext<'tcx>,\n+                    lvalue: &mut Place<'tcx>,\n+                    _ctxt: PlaceContext<'tcx>,\n                     _location: Location) {\n-        if let Lvalue::Local(RETURN_POINTER) = *lvalue {\n+        if let Place::Local(RETURN_POINTER) = *lvalue {\n             // Return pointer; update the lvalue itself\n             *lvalue = self.destination.clone();\n         } else {"}, {"sha": "5fb66edf9441bd9d8c27605d12f76d2581babc51", "filename": "src/librustc_mir/transform/instcombine.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -10,7 +10,7 @@\n \n //! Performs various peephole optimizations.\n \n-use rustc::mir::{Constant, Literal, Location, Lvalue, Mir, Operand, ProjectionElem, Rvalue, Local};\n+use rustc::mir::{Constant, Literal, Location, Place, Mir, Operand, ProjectionElem, Rvalue, Local};\n use rustc::mir::visit::{MutVisitor, Visitor};\n use rustc::ty::{TyCtxt, TypeVariants};\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n@@ -32,7 +32,7 @@ impl MirPass for InstCombine {\n \n         // First, find optimization opportunities. This is done in a pre-pass to keep the MIR\n         // read-only so that we can do global analyses on the MIR in the process (e.g.\n-        // `Lvalue::ty()`).\n+        // `Place::ty()`).\n         let optimizations = {\n             let mut optimization_finder = OptimizationFinder::new(mir, tcx);\n             optimization_finder.visit_mir(mir);\n@@ -53,9 +53,9 @@ impl<'tcx> MutVisitor<'tcx> for InstCombineVisitor<'tcx> {\n         if self.optimizations.and_stars.remove(&location) {\n             debug!(\"Replacing `&*`: {:?}\", rvalue);\n             let new_lvalue = match *rvalue {\n-                Rvalue::Ref(_, _, Lvalue::Projection(ref mut projection)) => {\n+                Rvalue::Ref(_, _, Place::Projection(ref mut projection)) => {\n                     // Replace with dummy\n-                    mem::replace(&mut projection.base, Lvalue::Local(Local::new(0)))\n+                    mem::replace(&mut projection.base, Place::Local(Local::new(0)))\n                 }\n                 _ => bug!(\"Detected `&*` but didn't find `&*`!\"),\n             };\n@@ -90,7 +90,7 @@ impl<'b, 'a, 'tcx:'b> OptimizationFinder<'b, 'a, 'tcx> {\n \n impl<'b, 'a, 'tcx> Visitor<'tcx> for OptimizationFinder<'b, 'a, 'tcx> {\n     fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n-        if let Rvalue::Ref(_, _, Lvalue::Projection(ref projection)) = *rvalue {\n+        if let Rvalue::Ref(_, _, Place::Projection(ref projection)) = *rvalue {\n             if let ProjectionElem::Deref = projection.elem {\n                 if projection.base.ty(self.mir, self.tcx).to_ty(self.tcx).is_region_ptr() {\n                     self.optimizations.and_stars.insert(location);"}, {"sha": "85109b43602eea399ac9c26930ee9241073c0e9f", "filename": "src/librustc_mir/transform/lower_128bit.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -99,13 +99,13 @@ impl Lower128Bit {\n                     block.statements.push(Statement {\n                         source_info: source_info,\n                         kind: StatementKind::Assign(\n-                            Lvalue::Local(local),\n+                            Place::Local(local),\n                             Rvalue::Cast(\n                                 CastKind::Misc,\n                                 rhs,\n                                 rhs_override_ty.unwrap())),\n                     });\n-                    rhs = Operand::Move(Lvalue::Local(local));\n+                    rhs = Operand::Move(Place::Local(local));\n                 }\n \n                 let call_did = check_lang_item_type(\n@@ -134,7 +134,7 @@ impl Lower128Bit {\n \n fn check_lang_item_type<'a, 'tcx, D>(\n     lang_item: LangItem,\n-    lvalue: &Lvalue<'tcx>,\n+    lvalue: &Place<'tcx>,\n     lhs: &Operand<'tcx>,\n     rhs: &Operand<'tcx>,\n     local_decls: &D,"}, {"sha": "2986d99a2232083d7b5312578931bc343c661284", "filename": "src/librustc_mir/transform/nll/constraint_generation.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fconstraint_generation.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -9,10 +9,10 @@\n // except according to those terms.\n \n use rustc::hir;\n-use rustc::mir::{Location, Lvalue, Mir, Rvalue};\n+use rustc::mir::{Location, Place, Mir, Rvalue};\n use rustc::mir::visit::Visitor;\n-use rustc::mir::Lvalue::Projection;\n-use rustc::mir::{LvalueProjection, ProjectionElem};\n+use rustc::mir::Place::Projection;\n+use rustc::mir::{PlaceProjection, ProjectionElem};\n use rustc::infer::InferCtxt;\n use rustc::traits::{self, ObligationCause};\n use rustc::ty::{self, Ty};\n@@ -189,10 +189,10 @@ impl<'cx, 'gcx, 'tcx> ConstraintGeneration<'cx, 'gcx, 'tcx> {\n         &mut self,\n         location: Location,\n         borrow_region: ty::Region<'tcx>,\n-        borrowed_lv: &Lvalue<'tcx>,\n+        borrowed_lv: &Place<'tcx>,\n     ) {\n         if let Projection(ref proj) = *borrowed_lv {\n-            let LvalueProjection { ref base, ref elem } = **proj;\n+            let PlaceProjection { ref base, ref elem } = **proj;\n \n             if let ProjectionElem::Deref = *elem {\n                 let tcx = self.infcx.tcx;"}, {"sha": "57e8de05d479077852aaac122ded7f6833b82a8d", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -23,7 +23,7 @@\n //! move analysis runs after promotion on broken MIR.\n \n use rustc::mir::*;\n-use rustc::mir::visit::{LvalueContext, MutVisitor, Visitor};\n+use rustc::mir::visit::{PlaceContext, MutVisitor, Visitor};\n use rustc::mir::traversal::ReversePostorder;\n use rustc::ty::TyCtxt;\n use syntax_pos::Span;\n@@ -85,7 +85,7 @@ struct TempCollector<'tcx> {\n impl<'tcx> Visitor<'tcx> for TempCollector<'tcx> {\n     fn visit_local(&mut self,\n                    &index: &Local,\n-                   context: LvalueContext<'tcx>,\n+                   context: PlaceContext<'tcx>,\n                    location: Location) {\n         // We're only interested in temporaries\n         if self.mir.local_kind(index) != LocalKind::Temp {\n@@ -102,8 +102,8 @@ impl<'tcx> Visitor<'tcx> for TempCollector<'tcx> {\n         let temp = &mut self.temps[index];\n         if *temp == TempState::Undefined {\n             match context {\n-                LvalueContext::Store |\n-                LvalueContext::Call => {\n+                PlaceContext::Store |\n+                PlaceContext::Call => {\n                     *temp = TempState::Defined {\n                         location,\n                         uses: 0\n@@ -116,7 +116,7 @@ impl<'tcx> Visitor<'tcx> for TempCollector<'tcx> {\n             // We always allow borrows, even mutable ones, as we need\n             // to promote mutable borrows of some ZSTs e.g. `&mut []`.\n             let allowed_use = match context {\n-                LvalueContext::Borrow {..} => true,\n+                PlaceContext::Borrow {..} => true,\n                 _ => context.is_nonmutating_use()\n             };\n             if allowed_use {\n@@ -179,7 +179,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                 span,\n                 scope: ARGUMENT_VISIBILITY_SCOPE\n             },\n-            kind: StatementKind::Assign(Lvalue::Local(dest), rvalue)\n+            kind: StatementKind::Assign(Place::Local(dest), rvalue)\n         });\n     }\n \n@@ -268,7 +268,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                             func,\n                             args,\n                             cleanup: None,\n-                            destination: Some((Lvalue::Local(new_temp), new_target))\n+                            destination: Some((Place::Local(new_temp), new_target))\n                         },\n                         ..terminator\n                     };\n@@ -325,7 +325,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n impl<'a, 'tcx> MutVisitor<'tcx> for Promoter<'a, 'tcx> {\n     fn visit_local(&mut self,\n                    local: &mut Local,\n-                   _: LvalueContext<'tcx>,\n+                   _: PlaceContext<'tcx>,\n                    _: Location) {\n         if self.source.local_kind(*local) == LocalKind::Temp {\n             *local = self.promote_temp(*local);\n@@ -350,7 +350,7 @@ pub fn promote_candidates<'a, 'tcx>(mir: &mut Mir<'tcx>,\n                                   \"expected assignment to promote\");\n                     }\n                 };\n-                if let Lvalue::Local(index) = *dest {\n+                if let Place::Local(index) = *dest {\n                     if temps[index] == TempState::PromotedOut {\n                         // Already promoted.\n                         continue;\n@@ -404,7 +404,7 @@ pub fn promote_candidates<'a, 'tcx>(mir: &mut Mir<'tcx>,\n     for block in mir.basic_blocks_mut() {\n         block.statements.retain(|statement| {\n             match statement.kind {\n-                StatementKind::Assign(Lvalue::Local(index), _) |\n+                StatementKind::Assign(Place::Local(index), _) |\n                 StatementKind::StorageLive(index) |\n                 StatementKind::StorageDead(index) => {\n                     !promoted(index)\n@@ -414,7 +414,7 @@ pub fn promote_candidates<'a, 'tcx>(mir: &mut Mir<'tcx>,\n         });\n         let terminator = block.terminator_mut();\n         match terminator.kind {\n-            TerminatorKind::Drop { location: Lvalue::Local(index), target, .. } => {\n+            TerminatorKind::Drop { location: Place::Local(index), target, .. } => {\n                 if promoted(index) {\n                     terminator.kind = TerminatorKind::Goto {\n                         target,"}, {"sha": "6aa44d64e5b80f7082a37b69a1bb6a7dd9ec97c5", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -26,7 +26,7 @@ use rustc::ty::cast::CastTy;\n use rustc::ty::maps::Providers;\n use rustc::mir::*;\n use rustc::mir::traversal::ReversePostorder;\n-use rustc::mir::visit::{LvalueContext, Visitor};\n+use rustc::mir::visit::{PlaceContext, Visitor};\n use rustc::middle::lang_items;\n use syntax::abi::Abi;\n use syntax::attr;\n@@ -197,7 +197,7 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n         self.add(original);\n     }\n \n-    /// Check if an Lvalue with the current qualifications could\n+    /// Check if an Place with the current qualifications could\n     /// be consumed, by either an operand or a Deref projection.\n     fn try_consume(&mut self) -> bool {\n         if self.qualif.intersects(Qualif::STATIC) && self.mode != Mode::Fn {\n@@ -224,7 +224,7 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n     }\n \n     /// Assign the current qualification to the given destination.\n-    fn assign(&mut self, dest: &Lvalue<'tcx>, location: Location) {\n+    fn assign(&mut self, dest: &Place<'tcx>, location: Location) {\n         let qualif = self.qualif;\n         let span = self.span;\n         let store = |slot: &mut Option<Qualif>| {\n@@ -236,7 +236,7 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n \n         // Only handle promotable temps in non-const functions.\n         if self.mode == Mode::Fn {\n-            if let Lvalue::Local(index) = *dest {\n+            if let Place::Local(index) = *dest {\n                 if self.mir.local_kind(index) == LocalKind::Temp\n                 && self.temp_promotion_state[index].is_promotable() {\n                     debug!(\"store to promotable temp {:?}\", index);\n@@ -249,24 +249,24 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n         // When initializing a local, record whether the *value* being\n         // stored in it needs dropping, which it may not, even if its\n         // type does, e.g. `None::<String>`.\n-        if let Lvalue::Local(local) = *dest {\n+        if let Place::Local(local) = *dest {\n             if qualif.intersects(Qualif::NEEDS_DROP) {\n                 self.local_needs_drop[local] = Some(self.span);\n             }\n         }\n \n         match *dest {\n-            Lvalue::Local(index) if self.mir.local_kind(index) == LocalKind::Temp => {\n+            Place::Local(index) if self.mir.local_kind(index) == LocalKind::Temp => {\n                 debug!(\"store to temp {:?}\", index);\n                 store(&mut self.temp_qualif[index])\n             }\n-            Lvalue::Local(index) if self.mir.local_kind(index) == LocalKind::ReturnPointer => {\n+            Place::Local(index) if self.mir.local_kind(index) == LocalKind::ReturnPointer => {\n                 debug!(\"store to return pointer {:?}\", index);\n                 store(&mut self.return_qualif)\n             }\n \n-            Lvalue::Projection(box Projection {\n-                base: Lvalue::Local(index),\n+            Place::Projection(box Projection {\n+                base: Place::Local(index),\n                 elem: ProjectionElem::Deref\n             }) if self.mir.local_kind(index) == LocalKind::Temp\n                && self.mir.local_decls[index].ty.is_box()\n@@ -280,7 +280,7 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n             // This must be an explicit assignment.\n             _ => {\n                 // Catch more errors in the destination.\n-                self.visit_lvalue(dest, LvalueContext::Store, location);\n+                self.visit_lvalue(dest, PlaceContext::Store, location);\n                 self.statement_like();\n             }\n         }\n@@ -351,7 +351,7 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n                     for index in mir.vars_iter() {\n                         if !self.const_fn_arg_vars.contains(index.index()) {\n                             debug!(\"unassigned variable {:?}\", index);\n-                            self.assign(&Lvalue::Local(index), Location {\n+                            self.assign(&Place::Local(index), Location {\n                                 block: bb,\n                                 statement_index: usize::MAX,\n                             });\n@@ -392,7 +392,7 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n             match *candidate {\n                 Candidate::Ref(Location { block: bb, statement_index: stmt_idx }) => {\n                     match self.mir[bb].statements[stmt_idx].kind {\n-                        StatementKind::Assign(_, Rvalue::Ref(_, _, Lvalue::Local(index))) => {\n+                        StatementKind::Assign(_, Rvalue::Ref(_, _, Place::Local(index))) => {\n                             promoted_temps.add(&index);\n                         }\n                         _ => {}\n@@ -412,7 +412,7 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n     fn visit_local(&mut self,\n                    &local: &Local,\n-                   _: LvalueContext<'tcx>,\n+                   _: PlaceContext<'tcx>,\n                    _: Location) {\n         match self.mir.local_kind(local) {\n             LocalKind::ReturnPointer => {\n@@ -439,12 +439,12 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n     }\n \n     fn visit_lvalue(&mut self,\n-                    lvalue: &Lvalue<'tcx>,\n-                    context: LvalueContext<'tcx>,\n+                    lvalue: &Place<'tcx>,\n+                    context: PlaceContext<'tcx>,\n                     location: Location) {\n         match *lvalue {\n-            Lvalue::Local(ref local) => self.visit_local(local, context, location),\n-            Lvalue::Static(ref global) => {\n+            Place::Local(ref local) => self.visit_local(local, context, location),\n+            Place::Static(ref global) => {\n                 self.add(Qualif::STATIC);\n \n                 if self.mode != Mode::Fn {\n@@ -465,7 +465,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                                a constant instead\", self.mode);\n                 }\n             }\n-            Lvalue::Projection(ref proj) => {\n+            Place::Projection(ref proj) => {\n                 self.nest(|this| {\n                     this.super_lvalue(lvalue, context, location);\n                     match proj.elem {\n@@ -527,7 +527,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                 });\n \n                 // Mark the consumed locals to indicate later drops are noops.\n-                if let Lvalue::Local(local) = *lvalue {\n+                if let Place::Local(local) = *lvalue {\n                     self.local_needs_drop[local] = None;\n                 }\n             }\n@@ -635,7 +635,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                 let candidate = Candidate::Ref(location);\n                 if !self.qualif.intersects(Qualif::NEVER_PROMOTE) {\n                     // We can only promote direct borrows of temps.\n-                    if let Lvalue::Local(local) = *lvalue {\n+                    if let Place::Local(local) = *lvalue {\n                         if self.mir.local_kind(local) == LocalKind::Temp {\n                             self.promotion_candidates.push(candidate);\n                         }\n@@ -836,7 +836,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n             if self.mode != Mode::Fn {\n                 // HACK(eddyb) Emulate a bit of dataflow analysis,\n                 // conservatively, that drop elaboration will do.\n-                let needs_drop = if let Lvalue::Local(local) = *lvalue {\n+                let needs_drop = if let Place::Local(local) = *lvalue {\n                     self.local_needs_drop[local]\n                 } else {\n                     None\n@@ -862,20 +862,20 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n \n     fn visit_assign(&mut self,\n                     _: BasicBlock,\n-                    dest: &Lvalue<'tcx>,\n+                    dest: &Place<'tcx>,\n                     rvalue: &Rvalue<'tcx>,\n                     location: Location) {\n         self.visit_rvalue(rvalue, location);\n \n         // Check the allowed const fn argument forms.\n-        if let (Mode::ConstFn, &Lvalue::Local(index)) = (self.mode, dest) {\n+        if let (Mode::ConstFn, &Place::Local(index)) = (self.mode, dest) {\n             if self.mir.local_kind(index) == LocalKind::Var &&\n                self.const_fn_arg_vars.insert(index.index()) {\n \n                 // Direct use of an argument is permitted.\n                 match *rvalue {\n-                    Rvalue::Use(Operand::Copy(Lvalue::Local(local))) |\n-                    Rvalue::Use(Operand::Move(Lvalue::Local(local))) => {\n+                    Rvalue::Use(Operand::Copy(Place::Local(local))) |\n+                    Rvalue::Use(Operand::Move(Place::Local(local))) => {\n                         if self.mir.local_kind(local) == LocalKind::Arg {\n                             return;\n                         }\n@@ -1030,7 +1030,7 @@ impl MirPass for QualifyAndPromoteConstants {\n                 });\n                 let terminator = block.terminator_mut();\n                 match terminator.kind {\n-                    TerminatorKind::Drop { location: Lvalue::Local(index), target, .. } => {\n+                    TerminatorKind::Drop { location: Place::Local(index), target, .. } => {\n                         if promoted_temps.contains(&index) {\n                             terminator.kind = TerminatorKind::Goto {\n                                 target,"}, {"sha": "b42fa4262704f9c281c1536f7ef06ba21a4c5a97", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -124,8 +124,8 @@ fn each_block<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     };\n     assert!(args.len() == 1);\n     let peek_arg_lval = match args[0] {\n-        mir::Operand::Copy(ref lval @ mir::Lvalue::Local(_)) |\n-        mir::Operand::Move(ref lval @ mir::Lvalue::Local(_)) => Some(lval),\n+        mir::Operand::Copy(ref lval @ mir::Place::Local(_)) |\n+        mir::Operand::Move(ref lval @ mir::Place::Local(_)) => Some(lval),\n         _ => None,\n     };\n "}, {"sha": "2e7c3714ffe12d62ebec06ea93c2d7faf8d9301b", "filename": "src/librustc_mir/transform/simplify.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -41,7 +41,7 @@ use rustc_data_structures::bitvec::BitVector;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc::ty::TyCtxt;\n use rustc::mir::*;\n-use rustc::mir::visit::{MutVisitor, Visitor, LvalueContext};\n+use rustc::mir::visit::{MutVisitor, Visitor, PlaceContext};\n use std::borrow::Cow;\n use transform::{MirPass, MirSource};\n \n@@ -352,9 +352,9 @@ struct DeclMarker {\n }\n \n impl<'tcx> Visitor<'tcx> for DeclMarker {\n-    fn visit_local(&mut self, local: &Local, ctx: LvalueContext<'tcx>, _: Location) {\n+    fn visit_local(&mut self, local: &Local, ctx: PlaceContext<'tcx>, _: Location) {\n         // ignore these altogether, they get removed along with their otherwise unused decls.\n-        if ctx != LvalueContext::StorageLive && ctx != LvalueContext::StorageDead {\n+        if ctx != PlaceContext::StorageLive && ctx != PlaceContext::StorageDead {\n             self.locals.insert(local.index());\n         }\n     }\n@@ -377,7 +377,7 @@ impl<'tcx> MutVisitor<'tcx> for LocalUpdater {\n         });\n         self.super_basic_block_data(block, data);\n     }\n-    fn visit_local(&mut self, l: &mut Local, _: LvalueContext<'tcx>, _: Location) {\n+    fn visit_local(&mut self, l: &mut Local, _: PlaceContext<'tcx>, _: Location) {\n         *l = Local::new(self.map[l.index()]);\n     }\n }"}, {"sha": "319bc3db52701e00d0010bc0b2df06473bc6ae2f", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -19,8 +19,8 @@ use rustc::ty::fold::TypeFoldable;\n use rustc::ty::{self, Ty, TyCtxt, TypeVariants};\n use rustc::middle::const_val::ConstVal;\n use rustc::mir::*;\n-use rustc::mir::tcx::LvalueTy;\n-use rustc::mir::visit::{LvalueContext, Visitor};\n+use rustc::mir::tcx::PlaceTy;\n+use rustc::mir::visit::{PlaceContext, Visitor};\n use std::fmt;\n use syntax::ast;\n use syntax_pos::{Span, DUMMY_SP};\n@@ -106,8 +106,8 @@ impl<'a, 'b, 'gcx, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n \n     fn visit_lvalue(\n         &mut self,\n-        lvalue: &Lvalue<'tcx>,\n-        context: LvalueContext,\n+        lvalue: &Place<'tcx>,\n+        context: PlaceContext,\n         location: Location,\n     ) {\n         self.sanitize_lvalue(lvalue, location, context);\n@@ -165,16 +165,16 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n     }\n \n     fn sanitize_lvalue(&mut self,\n-                       lvalue: &Lvalue<'tcx>,\n+                       lvalue: &Place<'tcx>,\n                        location: Location,\n-                       context: LvalueContext)\n-                       -> LvalueTy<'tcx> {\n+                       context: PlaceContext)\n+                       -> PlaceTy<'tcx> {\n         debug!(\"sanitize_lvalue: {:?}\", lvalue);\n         let lvalue_ty = match *lvalue {\n-            Lvalue::Local(index) => LvalueTy::Ty {\n+            Place::Local(index) => PlaceTy::Ty {\n                 ty: self.mir.local_decls[index].ty,\n             },\n-            Lvalue::Static(box Static { def_id, ty: sty }) => {\n+            Place::Static(box Static { def_id, ty: sty }) => {\n                 let sty = self.sanitize_type(lvalue, sty);\n                 let ty = self.tcx().type_of(def_id);\n                 let ty = self.cx.normalize(&ty, location);\n@@ -190,27 +190,27 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                         terr\n                     );\n                 }\n-                LvalueTy::Ty { ty: sty }\n+                PlaceTy::Ty { ty: sty }\n             }\n-            Lvalue::Projection(ref proj) => {\n+            Place::Projection(ref proj) => {\n                 let base_context = if context.is_mutating_use() {\n-                    LvalueContext::Projection(Mutability::Mut)\n+                    PlaceContext::Projection(Mutability::Mut)\n                 } else {\n-                    LvalueContext::Projection(Mutability::Not)\n+                    PlaceContext::Projection(Mutability::Not)\n                 };\n                 let base_ty = self.sanitize_lvalue(&proj.base, location, base_context);\n-                if let LvalueTy::Ty { ty } = base_ty {\n+                if let PlaceTy::Ty { ty } = base_ty {\n                     if ty.references_error() {\n                         assert!(self.errors_reported);\n-                        return LvalueTy::Ty {\n+                        return PlaceTy::Ty {\n                             ty: self.tcx().types.err,\n                         };\n                     }\n                 }\n                 self.sanitize_projection(base_ty, &proj.elem, lvalue, location)\n             }\n         };\n-        if let LvalueContext::Copy = context {\n+        if let PlaceContext::Copy = context {\n             let ty = lvalue_ty.to_ty(self.tcx());\n             if self.cx.infcx.type_moves_by_default(self.cx.param_env, ty, DUMMY_SP) {\n                 span_mirbug!(self, lvalue,\n@@ -222,32 +222,32 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n \n     fn sanitize_projection(\n         &mut self,\n-        base: LvalueTy<'tcx>,\n-        pi: &LvalueElem<'tcx>,\n-        lvalue: &Lvalue<'tcx>,\n+        base: PlaceTy<'tcx>,\n+        pi: &PlaceElem<'tcx>,\n+        lvalue: &Place<'tcx>,\n         location: Location,\n-    ) -> LvalueTy<'tcx> {\n+    ) -> PlaceTy<'tcx> {\n         debug!(\"sanitize_projection: {:?} {:?} {:?}\", base, pi, lvalue);\n         let tcx = self.tcx();\n         let base_ty = base.to_ty(tcx);\n         let span = self.last_span;\n         match *pi {\n             ProjectionElem::Deref => {\n                 let deref_ty = base_ty.builtin_deref(true, ty::LvaluePreference::NoPreference);\n-                LvalueTy::Ty {\n+                PlaceTy::Ty {\n                     ty: deref_ty.map(|t| t.ty).unwrap_or_else(|| {\n                         span_mirbug_and_err!(self, lvalue, \"deref of non-pointer {:?}\", base_ty)\n                     }),\n                 }\n             }\n             ProjectionElem::Index(i) => {\n-                let index_ty = Lvalue::Local(i).ty(self.mir, tcx).to_ty(tcx);\n+                let index_ty = Place::Local(i).ty(self.mir, tcx).to_ty(tcx);\n                 if index_ty != tcx.types.usize {\n-                    LvalueTy::Ty {\n+                    PlaceTy::Ty {\n                         ty: span_mirbug_and_err!(self, i, \"index by non-usize {:?}\", i),\n                     }\n                 } else {\n-                    LvalueTy::Ty {\n+                    PlaceTy::Ty {\n                         ty: base_ty.builtin_index().unwrap_or_else(|| {\n                             span_mirbug_and_err!(self, lvalue, \"index of non-array {:?}\", base_ty)\n                         }),\n@@ -256,13 +256,13 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n             }\n             ProjectionElem::ConstantIndex { .. } => {\n                 // consider verifying in-bounds\n-                LvalueTy::Ty {\n+                PlaceTy::Ty {\n                     ty: base_ty.builtin_index().unwrap_or_else(|| {\n                         span_mirbug_and_err!(self, lvalue, \"index of non-array {:?}\", base_ty)\n                     }),\n                 }\n             }\n-            ProjectionElem::Subslice { from, to } => LvalueTy::Ty {\n+            ProjectionElem::Subslice { from, to } => PlaceTy::Ty {\n                 ty: match base_ty.sty {\n                     ty::TyArray(inner, size) => {\n                         let size = size.val.to_const_int().unwrap().to_u64().unwrap();\n@@ -285,7 +285,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n             ProjectionElem::Downcast(adt_def1, index) => match base_ty.sty {\n                 ty::TyAdt(adt_def, substs) if adt_def.is_enum() && adt_def == adt_def1 => {\n                     if index >= adt_def.variants.len() {\n-                        LvalueTy::Ty {\n+                        PlaceTy::Ty {\n                             ty: span_mirbug_and_err!(\n                                 self,\n                                 lvalue,\n@@ -295,14 +295,14 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                             ),\n                         }\n                     } else {\n-                        LvalueTy::Downcast {\n+                        PlaceTy::Downcast {\n                             adt_def,\n                             substs,\n                             variant_index: index,\n                         }\n                     }\n                 }\n-                _ => LvalueTy::Ty {\n+                _ => PlaceTy::Ty {\n                     ty: span_mirbug_and_err!(\n                         self,\n                         lvalue,\n@@ -335,7 +335,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                         field_count\n                     ),\n                 }\n-                LvalueTy::Ty { ty: fty }\n+                PlaceTy::Ty { ty: fty }\n             }\n         }\n     }\n@@ -348,19 +348,19 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n     fn field_ty(\n         &mut self,\n         parent: &fmt::Debug,\n-        base_ty: LvalueTy<'tcx>,\n+        base_ty: PlaceTy<'tcx>,\n         field: Field,\n         location: Location,\n     ) -> Result<Ty<'tcx>, FieldAccessError> {\n         let tcx = self.tcx();\n \n         let (variant, substs) = match base_ty {\n-            LvalueTy::Downcast {\n+            PlaceTy::Downcast {\n                 adt_def,\n                 substs,\n                 variant_index,\n             } => (&adt_def.variants[variant_index], substs),\n-            LvalueTy::Ty { ty } => match ty.sty {\n+            PlaceTy::Ty { ty } => match ty.sty {\n                 ty::TyAdt(adt_def, substs) if !adt_def.is_enum() => {\n                     (&adt_def.variants[0], substs)\n                 }\n@@ -771,7 +771,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         mir: &Mir<'tcx>,\n         term: &Terminator<'tcx>,\n         sig: &ty::FnSig<'tcx>,\n-        destination: &Option<(Lvalue<'tcx>, BasicBlock)>,\n+        destination: &Option<(Place<'tcx>, BasicBlock)>,\n         term_location: Location,\n     ) {\n         let tcx = self.tcx();"}, {"sha": "02792bb2f500395c2e6b6431de73560bbef86c43", "filename": "src/librustc_mir/util/alignment.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Futil%2Falignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Futil%2Falignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Falignment.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -18,7 +18,7 @@ use rustc::mir::*;\n pub fn is_disaligned<'a, 'tcx, L>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                   local_decls: &L,\n                                   param_env: ty::ParamEnv<'tcx>,\n-                                  lvalue: &Lvalue<'tcx>)\n+                                  lvalue: &Place<'tcx>)\n                                   -> bool\n     where L: HasLocalDecls<'tcx>\n {\n@@ -45,12 +45,12 @@ pub fn is_disaligned<'a, 'tcx, L>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n fn is_within_packed<'a, 'tcx, L>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                  local_decls: &L,\n-                                 lvalue: &Lvalue<'tcx>)\n+                                 lvalue: &Place<'tcx>)\n                                  -> bool\n     where L: HasLocalDecls<'tcx>\n {\n     let mut lvalue = lvalue;\n-    while let &Lvalue::Projection(box Projection {\n+    while let &Place::Projection(box Projection {\n         ref base, ref elem\n     }) = lvalue {\n         match *elem {"}, {"sha": "16c418617fc699bc604a4e5bf15cfd9bab27ed05", "filename": "src/librustc_mir/util/def_use.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Futil%2Fdef_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Futil%2Fdef_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fdef_use.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -11,7 +11,7 @@\n //! Def-use analysis.\n \n use rustc::mir::{Local, Location, Mir};\n-use rustc::mir::visit::{LvalueContext, MutVisitor, Visitor};\n+use rustc::mir::visit::{PlaceContext, MutVisitor, Visitor};\n use rustc_data_structures::indexed_vec::IndexVec;\n use std::marker::PhantomData;\n use std::mem;\n@@ -29,7 +29,7 @@ pub struct Info<'tcx> {\n \n #[derive(Clone)]\n pub struct Use<'tcx> {\n-    pub context: LvalueContext<'tcx>,\n+    pub context: PlaceContext<'tcx>,\n     pub location: Location,\n }\n \n@@ -62,7 +62,7 @@ impl<'tcx> DefUseAnalysis<'tcx> {\n \n     fn mutate_defs_and_uses<F>(&self, local: Local, mir: &mut Mir<'tcx>, mut callback: F)\n                                where F: for<'a> FnMut(&'a mut Local,\n-                                                      LvalueContext<'tcx>,\n+                                                      PlaceContext<'tcx>,\n                                                       Location) {\n         for lvalue_use in &self.info[local].defs_and_uses {\n             MutateUseVisitor::new(local,\n@@ -87,7 +87,7 @@ struct DefUseFinder<'tcx> {\n impl<'tcx> Visitor<'tcx> for DefUseFinder<'tcx> {\n     fn visit_local(&mut self,\n                    &local: &Local,\n-                   context: LvalueContext<'tcx>,\n+                   context: PlaceContext<'tcx>,\n                    location: Location) {\n         self.info[local].defs_and_uses.push(Use {\n             context,\n@@ -139,7 +139,7 @@ struct MutateUseVisitor<'tcx, F> {\n impl<'tcx, F> MutateUseVisitor<'tcx, F> {\n     fn new(query: Local, callback: F, _: &Mir<'tcx>)\n            -> MutateUseVisitor<'tcx, F>\n-           where F: for<'a> FnMut(&'a mut Local, LvalueContext<'tcx>, Location) {\n+           where F: for<'a> FnMut(&'a mut Local, PlaceContext<'tcx>, Location) {\n         MutateUseVisitor {\n             query,\n             callback,\n@@ -149,10 +149,10 @@ impl<'tcx, F> MutateUseVisitor<'tcx, F> {\n }\n \n impl<'tcx, F> MutVisitor<'tcx> for MutateUseVisitor<'tcx, F>\n-              where F: for<'a> FnMut(&'a mut Local, LvalueContext<'tcx>, Location) {\n+              where F: for<'a> FnMut(&'a mut Local, PlaceContext<'tcx>, Location) {\n     fn visit_local(&mut self,\n                     local: &mut Local,\n-                    context: LvalueContext<'tcx>,\n+                    context: PlaceContext<'tcx>,\n                     location: Location) {\n         if *local == self.query {\n             (self.callback)(local, context, location)"}, {"sha": "fc40682c9b6e63d4065999f66d3102be4fc6d8bf", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -105,7 +105,7 @@ struct DropCtxt<'l, 'b: 'l, 'tcx: 'b, D>\n \n     source_info: SourceInfo,\n \n-    lvalue: &'l Lvalue<'tcx>,\n+    lvalue: &'l Place<'tcx>,\n     path: D::Path,\n     succ: BasicBlock,\n     unwind: Unwind,\n@@ -114,7 +114,7 @@ struct DropCtxt<'l, 'b: 'l, 'tcx: 'b, D>\n pub fn elaborate_drop<'b, 'tcx, D>(\n     elaborator: &mut D,\n     source_info: SourceInfo,\n-    lvalue: &Lvalue<'tcx>,\n+    lvalue: &Place<'tcx>,\n     path: D::Path,\n     succ: BasicBlock,\n     unwind: Unwind,\n@@ -129,7 +129,7 @@ pub fn elaborate_drop<'b, 'tcx, D>(\n impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n     where D: DropElaborator<'b, 'tcx>\n {\n-    fn lvalue_ty(&self, lvalue: &Lvalue<'tcx>) -> Ty<'tcx> {\n+    fn lvalue_ty(&self, lvalue: &Place<'tcx>) -> Ty<'tcx> {\n         lvalue.ty(self.elaborator.mir(), self.tcx()).to_ty(self.tcx())\n     }\n \n@@ -194,11 +194,11 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n     /// Return the lvalue and move path for each field of `variant`,\n     /// (the move path is `None` if the field is a rest field).\n     fn move_paths_for_fields(&self,\n-                             base_lv: &Lvalue<'tcx>,\n+                             base_lv: &Place<'tcx>,\n                              variant_path: D::Path,\n                              variant: &'tcx ty::VariantDef,\n                              substs: &'tcx Substs<'tcx>)\n-                             -> Vec<(Lvalue<'tcx>, Option<D::Path>)>\n+                             -> Vec<(Place<'tcx>, Option<D::Path>)>\n     {\n         variant.fields.iter().enumerate().map(|(i, f)| {\n             let field = Field::new(i);\n@@ -214,7 +214,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n     }\n \n     fn drop_subpath(&mut self,\n-                    lvalue: &Lvalue<'tcx>,\n+                    lvalue: &Place<'tcx>,\n                     path: Option<D::Path>,\n                     succ: BasicBlock,\n                     unwind: Unwind)\n@@ -251,7 +251,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n     fn drop_halfladder(&mut self,\n                        unwind_ladder: &[Unwind],\n                        mut succ: BasicBlock,\n-                       fields: &[(Lvalue<'tcx>, Option<D::Path>)])\n+                       fields: &[(Place<'tcx>, Option<D::Path>)])\n                        -> Vec<BasicBlock>\n     {\n         Some(succ).into_iter().chain(\n@@ -294,7 +294,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n     /// NOTE: this does not clear the master drop flag, so you need\n     /// to point succ/unwind on a `drop_ladder_bottom`.\n     fn drop_ladder<'a>(&mut self,\n-                       fields: Vec<(Lvalue<'tcx>, Option<D::Path>)>,\n+                       fields: Vec<(Place<'tcx>, Option<D::Path>)>,\n                        succ: BasicBlock,\n                        unwind: Unwind)\n                        -> (BasicBlock, Unwind)\n@@ -491,7 +491,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         // discriminant after it is free-ed, because that\n         // way lies only trouble.\n         let discr_ty = adt.repr.discr_type().to_ty(self.tcx());\n-        let discr = Lvalue::Local(self.new_temp(discr_ty));\n+        let discr = Place::Local(self.new_temp(discr_ty));\n         let discr_rv = Rvalue::Discriminant(self.lvalue.clone());\n         let switch_block = BasicBlockData {\n             statements: vec![self.assign(&discr, discr_rv)],\n@@ -525,18 +525,18 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n             mutbl: hir::Mutability::MutMutable\n         });\n         let ref_lvalue = self.new_temp(ref_ty);\n-        let unit_temp = Lvalue::Local(self.new_temp(tcx.mk_nil()));\n+        let unit_temp = Place::Local(self.new_temp(tcx.mk_nil()));\n \n         let result = BasicBlockData {\n             statements: vec![self.assign(\n-                &Lvalue::Local(ref_lvalue),\n+                &Place::Local(ref_lvalue),\n                 Rvalue::Ref(tcx.types.re_erased, BorrowKind::Mut, self.lvalue.clone())\n             )],\n             terminator: Some(Terminator {\n                 kind: TerminatorKind::Call {\n                     func: Operand::function_handle(tcx, drop_fn.def_id, substs,\n                                                    self.source_info.span),\n-                    args: vec![Operand::Move(Lvalue::Local(ref_lvalue))],\n+                    args: vec![Operand::Move(Place::Local(ref_lvalue))],\n                     destination: Some((unit_temp, succ)),\n                     cleanup: unwind.into_option(),\n                 },\n@@ -566,39 +566,39 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n     fn drop_loop(&mut self,\n                  succ: BasicBlock,\n                  cur: Local,\n-                 length_or_end: &Lvalue<'tcx>,\n+                 length_or_end: &Place<'tcx>,\n                  ety: Ty<'tcx>,\n                  unwind: Unwind,\n                  ptr_based: bool)\n                  -> BasicBlock\n     {\n-        let copy = |lv: &Lvalue<'tcx>| Operand::Copy(lv.clone());\n-        let move_ = |lv: &Lvalue<'tcx>| Operand::Move(lv.clone());\n+        let copy = |lv: &Place<'tcx>| Operand::Copy(lv.clone());\n+        let move_ = |lv: &Place<'tcx>| Operand::Move(lv.clone());\n         let tcx = self.tcx();\n \n         let ref_ty = tcx.mk_ref(tcx.types.re_erased, ty::TypeAndMut {\n             ty: ety,\n             mutbl: hir::Mutability::MutMutable\n         });\n-        let ptr = &Lvalue::Local(self.new_temp(ref_ty));\n-        let can_go = &Lvalue::Local(self.new_temp(tcx.types.bool));\n+        let ptr = &Place::Local(self.new_temp(ref_ty));\n+        let can_go = &Place::Local(self.new_temp(tcx.types.bool));\n \n         let one = self.constant_usize(1);\n         let (ptr_next, cur_next) = if ptr_based {\n-            (Rvalue::Use(copy(&Lvalue::Local(cur))),\n-             Rvalue::BinaryOp(BinOp::Offset, copy(&Lvalue::Local(cur)), one))\n+            (Rvalue::Use(copy(&Place::Local(cur))),\n+             Rvalue::BinaryOp(BinOp::Offset, copy(&Place::Local(cur)), one))\n         } else {\n             (Rvalue::Ref(\n                  tcx.types.re_erased,\n                  BorrowKind::Mut,\n                  self.lvalue.clone().index(cur)),\n-             Rvalue::BinaryOp(BinOp::Add, copy(&Lvalue::Local(cur)), one))\n+             Rvalue::BinaryOp(BinOp::Add, copy(&Place::Local(cur)), one))\n         };\n \n         let drop_block = BasicBlockData {\n             statements: vec![\n                 self.assign(ptr, ptr_next),\n-                self.assign(&Lvalue::Local(cur), cur_next)\n+                self.assign(&Place::Local(cur), cur_next)\n             ],\n             is_cleanup: unwind.is_cleanup(),\n             terminator: Some(Terminator {\n@@ -612,7 +612,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         let loop_block = BasicBlockData {\n             statements: vec![\n                 self.assign(can_go, Rvalue::BinaryOp(BinOp::Eq,\n-                                                     copy(&Lvalue::Local(cur)),\n+                                                     copy(&Place::Local(cur)),\n                                                      copy(length_or_end)))\n             ],\n             is_cleanup: unwind.is_cleanup(),\n@@ -643,9 +643,9 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n \n         let tcx = self.tcx();\n \n-        let move_ = |lv: &Lvalue<'tcx>| Operand::Move(lv.clone());\n-        let size = &Lvalue::Local(self.new_temp(tcx.types.usize));\n-        let size_is_zero = &Lvalue::Local(self.new_temp(tcx.types.bool));\n+        let move_ = |lv: &Place<'tcx>| Operand::Move(lv.clone());\n+        let size = &Place::Local(self.new_temp(tcx.types.usize));\n+        let size_is_zero = &Place::Local(self.new_temp(tcx.types.bool));\n         let base_block = BasicBlockData {\n             statements: vec![\n                 self.assign(size, Rvalue::NullaryOp(NullOp::SizeOf, ety)),\n@@ -680,9 +680,9 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         };\n \n         let cur = self.new_temp(iter_ty);\n-        let length = Lvalue::Local(self.new_temp(tcx.types.usize));\n+        let length = Place::Local(self.new_temp(tcx.types.usize));\n         let length_or_end = if ptr_based {\n-            Lvalue::Local(self.new_temp(iter_ty))\n+            Place::Local(self.new_temp(iter_ty))\n         } else {\n             length.clone()\n         };\n@@ -705,13 +705,13 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n             unwind,\n             ptr_based);\n \n-        let cur = Lvalue::Local(cur);\n+        let cur = Place::Local(cur);\n         let zero = self.constant_usize(0);\n         let mut drop_block_stmts = vec![];\n         drop_block_stmts.push(self.assign(&length, Rvalue::Len(self.lvalue.clone())));\n         if ptr_based {\n             let tmp_ty = tcx.mk_mut_ptr(self.lvalue_ty(self.lvalue));\n-            let tmp = Lvalue::Local(self.new_temp(tmp_ty));\n+            let tmp = Place::Local(self.new_temp(tmp_ty));\n             // tmp = &LV;\n             // cur = tmp as *mut T;\n             // end = Offset(cur, len);\n@@ -849,7 +849,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         unwind: Unwind\n     ) -> BasicBlock {\n         let tcx = self.tcx();\n-        let unit_temp = Lvalue::Local(self.new_temp(tcx.mk_nil()));\n+        let unit_temp = Place::Local(self.new_temp(tcx.mk_nil()));\n         let free_func = tcx.require_lang_item(lang_items::BoxFreeFnLangItem);\n         let substs = tcx.mk_substs(iter::once(Kind::from(ty)));\n \n@@ -932,7 +932,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         })\n     }\n \n-    fn assign(&self, lhs: &Lvalue<'tcx>, rhs: Rvalue<'tcx>) -> Statement<'tcx> {\n+    fn assign(&self, lhs: &Place<'tcx>, rhs: Rvalue<'tcx>) -> Statement<'tcx> {\n         Statement {\n             source_info: self.source_info,\n             kind: StatementKind::Assign(lhs.clone(), rhs)"}, {"sha": "85b66c29be1ad99721c08302ca4c6325996b64c4", "filename": "src/librustc_mir/util/graphviz.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -147,7 +147,7 @@ fn write_graph_label<'a, 'gcx, 'tcx, W: Write>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         if i > 0 {\n             write!(w, \", \")?;\n         }\n-        write!(w, \"{:?}: {}\", Lvalue::Local(arg), escape(&mir.local_decls[arg].ty))?;\n+        write!(w, \"{:?}: {}\", Place::Local(arg), escape(&mir.local_decls[arg].ty))?;\n     }\n \n     write!(w, \") -&gt; {}\", escape(mir.return_ty()))?;\n@@ -163,10 +163,10 @@ fn write_graph_label<'a, 'gcx, 'tcx, W: Write>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n \n         if let Some(name) = decl.name {\n             write!(w, r#\"{:?}: {}; // {}<br align=\"left\"/>\"#,\n-                   Lvalue::Local(local), escape(&decl.ty), name)?;\n+                   Place::Local(local), escape(&decl.ty), name)?;\n         } else {\n             write!(w, r#\"let mut {:?}: {};<br align=\"left\"/>\"#,\n-                   Lvalue::Local(local), escape(&decl.ty))?;\n+                   Place::Local(local), escape(&decl.ty))?;\n         }\n     }\n "}, {"sha": "45c3fcd8a615dbd86f809261347776696686e571", "filename": "src/librustc_mir/util/liveness.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fliveness.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -34,7 +34,7 @@\n //! doesn't matter).\n \n use rustc::mir::*;\n-use rustc::mir::visit::{LvalueContext, Visitor};\n+use rustc::mir::visit::{PlaceContext, Visitor};\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc_data_structures::indexed_set::IdxSetBuf;\n use util::pretty::{dump_enabled, write_basic_block, write_mir_intro};\n@@ -233,12 +233,12 @@ impl DefsUses {\n }\n \n impl<'tcx> Visitor<'tcx> for DefsUsesVisitor {\n-    fn visit_local(&mut self, &local: &Local, context: LvalueContext<'tcx>, _: Location) {\n+    fn visit_local(&mut self, &local: &Local, context: PlaceContext<'tcx>, _: Location) {\n         match context {\n             ///////////////////////////////////////////////////////////////////////////\n             // DEFS\n \n-            LvalueContext::Store |\n+            PlaceContext::Store |\n \n             // We let Call define the result in both the success and\n             // unwind cases. This is not really correct, however it\n@@ -248,12 +248,12 @@ impl<'tcx> Visitor<'tcx> for DefsUsesVisitor {\n             // properly, we would apply the def in call only to the\n             // input from the success path and not the unwind\n             // path. -nmatsakis\n-            LvalueContext::Call |\n+            PlaceContext::Call |\n \n             // Storage live and storage dead aren't proper defines, but we can ignore\n             // values that come before them.\n-            LvalueContext::StorageLive |\n-            LvalueContext::StorageDead => {\n+            PlaceContext::StorageLive |\n+            PlaceContext::StorageDead => {\n                 self.defs_uses.add_def(local);\n             }\n \n@@ -264,18 +264,18 @@ impl<'tcx> Visitor<'tcx> for DefsUsesVisitor {\n             // purposes of NLL, these are special in that **all** the\n             // lifetimes appearing in the variable must be live for each regular use.\n \n-            LvalueContext::Projection(..) |\n+            PlaceContext::Projection(..) |\n \n             // Borrows only consider their local used at the point of the borrow.\n             // This won't affect the results since we use this analysis for generators\n             // and we only care about the result at suspension points. Borrows cannot\n             // cross suspension points so this behavior is unproblematic.\n-            LvalueContext::Borrow { .. } |\n+            PlaceContext::Borrow { .. } |\n \n-            LvalueContext::Inspect |\n-            LvalueContext::Copy |\n-            LvalueContext::Move |\n-            LvalueContext::Validate => {\n+            PlaceContext::Inspect |\n+            PlaceContext::Copy |\n+            PlaceContext::Move |\n+            PlaceContext::Validate => {\n                 if self.mode.include_regular_use {\n                     self.defs_uses.add_use(local);\n                 }\n@@ -289,7 +289,7 @@ impl<'tcx> Visitor<'tcx> for DefsUsesVisitor {\n             // uses in drop are special because `#[may_dangle]`\n             // attributes can affect whether lifetimes must be live.\n \n-            LvalueContext::Drop => {\n+            PlaceContext::Drop => {\n                 if self.mode.include_drops {\n                     self.defs_uses.add_use(local);\n                 }"}, {"sha": "ed85cc36b05809cecb1b49cc18f5ece200208f65", "filename": "src/librustc_mir/util/patch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Futil%2Fpatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Futil%2Fpatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpatch.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -127,7 +127,7 @@ impl<'tcx> MirPatch<'tcx> {\n         self.new_statements.push((loc, stmt));\n     }\n \n-    pub fn add_assign(&mut self, loc: Location, lv: Lvalue<'tcx>, rv: Rvalue<'tcx>) {\n+    pub fn add_assign(&mut self, loc: Location, lv: Place<'tcx>, rv: Rvalue<'tcx>) {\n         self.add_statement(loc, StatementKind::Assign(lv, rv));\n     }\n "}, {"sha": "5f392e4592630ea7bca0e14465edc420bd7ab59a", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -389,7 +389,7 @@ fn write_mir_sig(tcx: TyCtxt, src: MirSource, mir: &Mir, w: &mut Write)\n                 if i != 0 {\n                     write!(w, \", \")?;\n                 }\n-                write!(w, \"{:?}: {}\", Lvalue::Local(arg), mir.local_decls[arg].ty)?;\n+                write!(w, \"{:?}: {}\", Place::Local(arg), mir.local_decls[arg].ty)?;\n             }\n \n             write!(w, \") -> {}\", mir.return_ty())"}, {"sha": "4bd5ce0a4afd8f727e5458286d12a53aca25362b", "filename": "src/librustc_passes/mir_stats.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_passes%2Fmir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_passes%2Fmir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fmir_stats.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -15,7 +15,7 @@\n use rustc_const_math::{ConstUsize};\n use rustc::mir::{AggregateKind, AssertMessage, BasicBlock, BasicBlockData};\n use rustc::mir::{Constant, Literal, Location, Local, LocalDecl};\n-use rustc::mir::{Lvalue, LvalueElem, LvalueProjection};\n+use rustc::mir::{Place, PlaceElem, PlaceProjection};\n use rustc::mir::{Mir, Operand, ProjectionElem};\n use rustc::mir::{Rvalue, SourceInfo, Statement, StatementKind};\n use rustc::mir::{Terminator, TerminatorKind, VisibilityScope, VisibilityScopeData};\n@@ -189,38 +189,38 @@ impl<'a, 'tcx> mir_visit::Visitor<'tcx> for StatCollector<'a, 'tcx> {\n     }\n \n     fn visit_lvalue(&mut self,\n-                    lvalue: &Lvalue<'tcx>,\n-                    context: mir_visit::LvalueContext<'tcx>,\n+                    lvalue: &Place<'tcx>,\n+                    context: mir_visit::PlaceContext<'tcx>,\n                     location: Location) {\n-        self.record(\"Lvalue\", lvalue);\n+        self.record(\"Place\", lvalue);\n         self.record(match *lvalue {\n-            Lvalue::Local(..) => \"Lvalue::Local\",\n-            Lvalue::Static(..) => \"Lvalue::Static\",\n-            Lvalue::Projection(..) => \"Lvalue::Projection\",\n+            Place::Local(..) => \"Place::Local\",\n+            Place::Static(..) => \"Place::Static\",\n+            Place::Projection(..) => \"Place::Projection\",\n         }, lvalue);\n         self.super_lvalue(lvalue, context, location);\n     }\n \n     fn visit_projection(&mut self,\n-                        lvalue: &LvalueProjection<'tcx>,\n-                        context: mir_visit::LvalueContext<'tcx>,\n+                        lvalue: &PlaceProjection<'tcx>,\n+                        context: mir_visit::PlaceContext<'tcx>,\n                         location: Location) {\n-        self.record(\"LvalueProjection\", lvalue);\n+        self.record(\"PlaceProjection\", lvalue);\n         self.super_projection(lvalue, context, location);\n     }\n \n     fn visit_projection_elem(&mut self,\n-                             lvalue: &LvalueElem<'tcx>,\n-                             context: mir_visit::LvalueContext<'tcx>,\n+                             lvalue: &PlaceElem<'tcx>,\n+                             context: mir_visit::PlaceContext<'tcx>,\n                              location: Location) {\n-        self.record(\"LvalueElem\", lvalue);\n+        self.record(\"PlaceElem\", lvalue);\n         self.record(match *lvalue {\n-            ProjectionElem::Deref => \"LvalueElem::Deref\",\n-            ProjectionElem::Subslice { .. } => \"LvalueElem::Subslice\",\n-            ProjectionElem::Field(..) => \"LvalueElem::Field\",\n-            ProjectionElem::Index(..) => \"LvalueElem::Index\",\n-            ProjectionElem::ConstantIndex { .. } => \"LvalueElem::ConstantIndex\",\n-            ProjectionElem::Downcast(..) => \"LvalueElem::Downcast\",\n+            ProjectionElem::Deref => \"PlaceElem::Deref\",\n+            ProjectionElem::Subslice { .. } => \"PlaceElem::Subslice\",\n+            ProjectionElem::Field(..) => \"PlaceElem::Field\",\n+            ProjectionElem::Index(..) => \"PlaceElem::Index\",\n+            ProjectionElem::ConstantIndex { .. } => \"PlaceElem::ConstantIndex\",\n+            ProjectionElem::Downcast(..) => \"PlaceElem::Downcast\",\n         }, lvalue);\n         self.super_projection_elem(lvalue, context, location);\n     }"}, {"sha": "9c23ffec6c06509552633c7fc5c2ff131cbfdd0c", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -30,7 +30,7 @@ use cabi_sparc64;\n use cabi_nvptx;\n use cabi_nvptx64;\n use cabi_hexagon;\n-use mir::lvalue::{Alignment, LvalueRef};\n+use mir::lvalue::{Alignment, PlaceRef};\n use mir::operand::OperandValue;\n use type_::Type;\n use type_of::{LayoutLlvmExt, PointerKind};\n@@ -555,7 +555,7 @@ impl<'a, 'tcx> ArgType<'tcx> {\n     /// lvalue for the original Rust type of this argument/return.\n     /// Can be used for both storing formal arguments into Rust variables\n     /// or results of call/invoke instructions into their destinations.\n-    pub fn store(&self, bcx: &Builder<'a, 'tcx>, val: ValueRef, dst: LvalueRef<'tcx>) {\n+    pub fn store(&self, bcx: &Builder<'a, 'tcx>, val: ValueRef, dst: PlaceRef<'tcx>) {\n         if self.is_ignore() {\n             return;\n         }\n@@ -606,7 +606,7 @@ impl<'a, 'tcx> ArgType<'tcx> {\n         }\n     }\n \n-    pub fn store_fn_arg(&self, bcx: &Builder<'a, 'tcx>, idx: &mut usize, dst: LvalueRef<'tcx>) {\n+    pub fn store_fn_arg(&self, bcx: &Builder<'a, 'tcx>, idx: &mut usize, dst: PlaceRef<'tcx>) {\n         if self.pad.is_some() {\n             *idx += 1;\n         }"}, {"sha": "5e6dfabc18873a097595bf41e067d94ed98e54a1", "filename": "src/librustc_trans/asm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_trans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_trans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fasm.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -18,7 +18,7 @@ use builder::Builder;\n \n use rustc::hir;\n \n-use mir::lvalue::LvalueRef;\n+use mir::lvalue::PlaceRef;\n use mir::operand::OperandValue;\n \n use std::ffi::CString;\n@@ -29,7 +29,7 @@ use libc::{c_uint, c_char};\n pub fn trans_inline_asm<'a, 'tcx>(\n     bcx: &Builder<'a, 'tcx>,\n     ia: &hir::InlineAsm,\n-    outputs: Vec<LvalueRef<'tcx>>,\n+    outputs: Vec<PlaceRef<'tcx>>,\n     mut inputs: Vec<ValueRef>\n ) {\n     let mut ext_constraints = vec![];"}, {"sha": "ec9ed402ac62299c66b18bea293b0dc380d1e9d6", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -50,7 +50,7 @@ use rustc::session::config::{self, NoDebugInfo};\n use rustc::session::Session;\n use rustc_incremental;\n use allocator;\n-use mir::lvalue::LvalueRef;\n+use mir::lvalue::PlaceRef;\n use attributes;\n use builder::Builder;\n use callee;\n@@ -272,8 +272,8 @@ pub fn unsize_thin_ptr<'a, 'tcx>(\n /// Coerce `src`, which is a reference to a value of type `src_ty`,\n /// to a value of type `dst_ty` and store the result in `dst`\n pub fn coerce_unsized_into<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n-                                     src: LvalueRef<'tcx>,\n-                                     dst: LvalueRef<'tcx>) {\n+                                     src: PlaceRef<'tcx>,\n+                                     dst: PlaceRef<'tcx>) {\n     let src_ty = src.layout.ty;\n     let dst_ty = dst.layout.ty;\n     let coerce_ptr = || {"}, {"sha": "cfa312606175e9e674f9501ef39fed88c954afb7", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -14,7 +14,7 @@ use intrinsics::{self, Intrinsic};\n use llvm;\n use llvm::{ValueRef};\n use abi::{Abi, FnType, PassMode};\n-use mir::lvalue::{LvalueRef, Alignment};\n+use mir::lvalue::{PlaceRef, Alignment};\n use mir::operand::{OperandRef, OperandValue};\n use base::*;\n use common::*;\n@@ -106,7 +106,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n     let name = &*tcx.item_name(def_id);\n \n     let llret_ty = ccx.layout_of(ret_ty).llvm_type(ccx);\n-    let result = LvalueRef::new_sized(llresult, fn_ty.ret.layout, Alignment::AbiAligned);\n+    let result = PlaceRef::new_sized(llresult, fn_ty.ret.layout, Alignment::AbiAligned);\n \n     let simple = get_simple_intrinsic(ccx, name);\n     let llval = match name {\n@@ -625,7 +625,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                             OperandValue::Ref(ptr, align) => (ptr, align),\n                             _ => bug!()\n                         };\n-                        let arg = LvalueRef::new_sized(ptr, arg.layout, align);\n+                        let arg = PlaceRef::new_sized(ptr, arg.layout, align);\n                         (0..contents.len()).map(|i| {\n                             arg.project_field(bcx, i).load(bcx).immediate()\n                         }).collect()"}, {"sha": "6feb056a83cacfca5edd02800bb446c10af33bba", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -15,7 +15,7 @@ use rustc_data_structures::bitvec::BitVector;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc::middle::const_val::ConstVal;\n use rustc::mir::{self, Location, TerminatorKind, Literal};\n-use rustc::mir::visit::{Visitor, LvalueContext};\n+use rustc::mir::visit::{Visitor, PlaceContext};\n use rustc::mir::traversal;\n use rustc::ty;\n use rustc::ty::layout::LayoutOf;\n@@ -88,18 +88,18 @@ impl<'mir, 'a, 'tcx> LocalAnalyzer<'mir, 'a, 'tcx> {\n impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n     fn visit_assign(&mut self,\n                     block: mir::BasicBlock,\n-                    lvalue: &mir::Lvalue<'tcx>,\n+                    lvalue: &mir::Place<'tcx>,\n                     rvalue: &mir::Rvalue<'tcx>,\n                     location: Location) {\n         debug!(\"visit_assign(block={:?}, lvalue={:?}, rvalue={:?})\", block, lvalue, rvalue);\n \n-        if let mir::Lvalue::Local(index) = *lvalue {\n+        if let mir::Place::Local(index) = *lvalue {\n             self.mark_assigned(index);\n             if !self.cx.rvalue_creates_operand(rvalue) {\n                 self.mark_as_lvalue(index);\n             }\n         } else {\n-            self.visit_lvalue(lvalue, LvalueContext::Store, location);\n+            self.visit_lvalue(lvalue, PlaceContext::Store, location);\n         }\n \n         self.visit_rvalue(rvalue, location);\n@@ -122,7 +122,7 @@ impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n                 // is not guaranteed to be statically dominated by the\n                 // definition of x, so x must always be in an alloca.\n                 if let mir::Operand::Move(ref lvalue) = args[0] {\n-                    self.visit_lvalue(lvalue, LvalueContext::Drop, location);\n+                    self.visit_lvalue(lvalue, PlaceContext::Drop, location);\n                 }\n             }\n             _ => {}\n@@ -132,16 +132,16 @@ impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n     }\n \n     fn visit_lvalue(&mut self,\n-                    lvalue: &mir::Lvalue<'tcx>,\n-                    context: LvalueContext<'tcx>,\n+                    lvalue: &mir::Place<'tcx>,\n+                    context: PlaceContext<'tcx>,\n                     location: Location) {\n         debug!(\"visit_lvalue(lvalue={:?}, context={:?})\", lvalue, context);\n         let ccx = self.cx.ccx;\n \n-        if let mir::Lvalue::Projection(ref proj) = *lvalue {\n+        if let mir::Place::Projection(ref proj) = *lvalue {\n             // Allow uses of projections that are ZSTs or from scalar fields.\n             let is_consume = match context {\n-                LvalueContext::Copy | LvalueContext::Move => true,\n+                PlaceContext::Copy | PlaceContext::Move => true,\n                 _ => false\n             };\n             if is_consume {\n@@ -169,7 +169,7 @@ impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n \n             // A deref projection only reads the pointer, never needs the lvalue.\n             if let mir::ProjectionElem::Deref = proj.elem {\n-                return self.visit_lvalue(&proj.base, LvalueContext::Copy, location);\n+                return self.visit_lvalue(&proj.base, PlaceContext::Copy, location);\n             }\n         }\n \n@@ -178,28 +178,28 @@ impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n \n     fn visit_local(&mut self,\n                    &index: &mir::Local,\n-                   context: LvalueContext<'tcx>,\n+                   context: PlaceContext<'tcx>,\n                    _: Location) {\n         match context {\n-            LvalueContext::Call => {\n+            PlaceContext::Call => {\n                 self.mark_assigned(index);\n             }\n \n-            LvalueContext::StorageLive |\n-            LvalueContext::StorageDead |\n-            LvalueContext::Validate |\n-            LvalueContext::Copy |\n-            LvalueContext::Move => {}\n+            PlaceContext::StorageLive |\n+            PlaceContext::StorageDead |\n+            PlaceContext::Validate |\n+            PlaceContext::Copy |\n+            PlaceContext::Move => {}\n \n-            LvalueContext::Inspect |\n-            LvalueContext::Store |\n-            LvalueContext::Borrow { .. } |\n-            LvalueContext::Projection(..) => {\n+            PlaceContext::Inspect |\n+            PlaceContext::Store |\n+            PlaceContext::Borrow { .. } |\n+            PlaceContext::Projection(..) => {\n                 self.mark_as_lvalue(index);\n             }\n \n-            LvalueContext::Drop => {\n-                let ty = mir::Lvalue::Local(index).ty(self.cx.mir, self.cx.ccx.tcx());\n+            PlaceContext::Drop => {\n+                let ty = mir::Place::Local(index).ty(self.cx.mir, self.cx.ccx.tcx());\n                 let ty = self.cx.monomorphize(&ty.to_ty(self.cx.ccx.tcx()));\n \n                 // Only need the lvalue if we're actually dropping it."}, {"sha": "94a8df0a35bfa2f21f3c6c76a14a572030cc1b37", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -31,7 +31,7 @@ use syntax_pos::Pos;\n \n use super::{MirContext, LocalRef};\n use super::constant::Const;\n-use super::lvalue::{Alignment, LvalueRef};\n+use super::lvalue::{Alignment, PlaceRef};\n use super::operand::OperandRef;\n use super::operand::OperandValue::{Pair, Ref, Immediate};\n \n@@ -214,7 +214,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     }\n \n                     PassMode::Direct(_) | PassMode::Pair(..) => {\n-                        let op = self.trans_consume(&bcx, &mir::Lvalue::Local(mir::RETURN_POINTER));\n+                        let op = self.trans_consume(&bcx, &mir::Place::Local(mir::RETURN_POINTER));\n                         if let Ref(llval, align) = op.val {\n                             bcx.load(llval, align.non_abi())\n                         } else {\n@@ -226,7 +226,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         let op = match self.locals[mir::RETURN_POINTER] {\n                             LocalRef::Operand(Some(op)) => op,\n                             LocalRef::Operand(None) => bug!(\"use of return before def\"),\n-                            LocalRef::Lvalue(tr_lvalue) => {\n+                            LocalRef::Place(tr_lvalue) => {\n                                 OperandRef {\n                                     val: Ref(tr_lvalue.llval, tr_lvalue.alignment),\n                                     layout: tr_lvalue.layout\n@@ -235,7 +235,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         };\n                         let llslot = match op.val {\n                             Immediate(_) | Pair(..) => {\n-                                let scratch = LvalueRef::alloca(&bcx, self.fn_ty.ret.layout, \"ret\");\n+                                let scratch = PlaceRef::alloca(&bcx, self.fn_ty.ret.layout, \"ret\");\n                                 op.val.store(&bcx, scratch);\n                                 scratch.llval\n                             }\n@@ -577,7 +577,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     match (arg, op.val) {\n                         (&mir::Operand::Copy(_), Ref(..)) |\n                         (&mir::Operand::Constant(_), Ref(..)) => {\n-                            let tmp = LvalueRef::alloca(&bcx, op.layout, \"const\");\n+                            let tmp = PlaceRef::alloca(&bcx, op.layout, \"const\");\n                             op.val.store(&bcx, tmp);\n                             op.val = Ref(tmp.llval, tmp.alignment);\n                         }\n@@ -637,7 +637,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             Immediate(_) | Pair(..) => {\n                 match arg.mode {\n                     PassMode::Indirect(_) | PassMode::Cast(_) => {\n-                        let scratch = LvalueRef::alloca(bcx, arg.layout, \"arg\");\n+                        let scratch = PlaceRef::alloca(bcx, arg.layout, \"arg\");\n                         op.val.store(bcx, scratch);\n                         (scratch.llval, Alignment::AbiAligned, true)\n                     }\n@@ -651,7 +651,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 // think that ATM (Rust 1.16) we only pass temporaries, but we shouldn't\n                 // have scary latent bugs around.\n \n-                let scratch = LvalueRef::alloca(bcx, arg.layout, \"arg\");\n+                let scratch = PlaceRef::alloca(bcx, arg.layout, \"arg\");\n                 base::memcpy_ty(bcx, scratch.llval, llval, op.layout, align.non_abi());\n                 (scratch.llval, Alignment::AbiAligned, true)\n             }\n@@ -665,7 +665,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                                  (align | Alignment::Packed(arg.layout.align))\n                                     .non_abi());\n             } else {\n-                // We can't use `LvalueRef::load` here because the argument\n+                // We can't use `PlaceRef::load` here because the argument\n                 // may have a type we don't treat as immediate, but the ABI\n                 // used for this call is passing it by-value. In that case,\n                 // the load would just produce `OperandValue::Ref` instead\n@@ -693,7 +693,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n         // Handle both by-ref and immediate tuples.\n         if let Ref(llval, align) = tuple.val {\n-            let tuple_ptr = LvalueRef::new_sized(llval, tuple.layout, align);\n+            let tuple_ptr = PlaceRef::new_sized(llval, tuple.layout, align);\n             for i in 0..tuple.layout.fields.count() {\n                 let field_ptr = tuple_ptr.project_field(bcx, i);\n                 self.trans_argument(bcx, field_ptr.load(bcx), llargs, &args[i]);\n@@ -707,7 +707,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         }\n     }\n \n-    fn get_personality_slot(&mut self, bcx: &Builder<'a, 'tcx>) -> LvalueRef<'tcx> {\n+    fn get_personality_slot(&mut self, bcx: &Builder<'a, 'tcx>) -> PlaceRef<'tcx> {\n         let ccx = bcx.ccx;\n         if let Some(slot) = self.personality_slot {\n             slot\n@@ -716,7 +716,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 ccx.tcx().mk_mut_ptr(ccx.tcx().types.u8),\n                 ccx.tcx().types.i32\n             ], false));\n-            let slot = LvalueRef::alloca(bcx, layout, \"personalityslot\");\n+            let slot = PlaceRef::alloca(bcx, layout, \"personalityslot\");\n             self.personality_slot = Some(slot);\n             slot\n         }\n@@ -781,31 +781,31 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     }\n \n     fn make_return_dest(&mut self, bcx: &Builder<'a, 'tcx>,\n-                        dest: &mir::Lvalue<'tcx>, fn_ret: &ArgType<'tcx>,\n+                        dest: &mir::Place<'tcx>, fn_ret: &ArgType<'tcx>,\n                         llargs: &mut Vec<ValueRef>, is_intrinsic: bool)\n                         -> ReturnDest<'tcx> {\n         // If the return is ignored, we can just return a do-nothing ReturnDest\n         if fn_ret.is_ignore() {\n             return ReturnDest::Nothing;\n         }\n-        let dest = if let mir::Lvalue::Local(index) = *dest {\n+        let dest = if let mir::Place::Local(index) = *dest {\n             match self.locals[index] {\n-                LocalRef::Lvalue(dest) => dest,\n+                LocalRef::Place(dest) => dest,\n                 LocalRef::Operand(None) => {\n                     // Handle temporary lvalues, specifically Operand ones, as\n                     // they don't have allocas\n                     return if fn_ret.is_indirect() {\n                         // Odd, but possible, case, we have an operand temporary,\n                         // but the calling convention has an indirect return.\n-                        let tmp = LvalueRef::alloca(bcx, fn_ret.layout, \"tmp_ret\");\n+                        let tmp = PlaceRef::alloca(bcx, fn_ret.layout, \"tmp_ret\");\n                         tmp.storage_live(bcx);\n                         llargs.push(tmp.llval);\n                         ReturnDest::IndirectOperand(tmp, index)\n                     } else if is_intrinsic {\n                         // Currently, intrinsics always need a location to store\n                         // the result. so we create a temporary alloca for the\n                         // result\n-                        let tmp = LvalueRef::alloca(bcx, fn_ret.layout, \"tmp_ret\");\n+                        let tmp = PlaceRef::alloca(bcx, fn_ret.layout, \"tmp_ret\");\n                         tmp.storage_live(bcx);\n                         ReturnDest::IndirectOperand(tmp, index)\n                     } else {\n@@ -842,14 +842,14 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n     fn trans_transmute(&mut self, bcx: &Builder<'a, 'tcx>,\n                        src: &mir::Operand<'tcx>,\n-                       dst: &mir::Lvalue<'tcx>) {\n-        if let mir::Lvalue::Local(index) = *dst {\n+                       dst: &mir::Place<'tcx>) {\n+        if let mir::Place::Local(index) = *dst {\n             match self.locals[index] {\n-                LocalRef::Lvalue(lvalue) => self.trans_transmute_into(bcx, src, lvalue),\n+                LocalRef::Place(lvalue) => self.trans_transmute_into(bcx, src, lvalue),\n                 LocalRef::Operand(None) => {\n                     let dst_layout = bcx.ccx.layout_of(self.monomorphized_lvalue_ty(dst));\n                     assert!(!dst_layout.ty.has_erasable_regions());\n-                    let lvalue = LvalueRef::alloca(bcx, dst_layout, \"transmute_temp\");\n+                    let lvalue = PlaceRef::alloca(bcx, dst_layout, \"transmute_temp\");\n                     lvalue.storage_live(bcx);\n                     self.trans_transmute_into(bcx, src, lvalue);\n                     let op = lvalue.load(bcx);\n@@ -869,13 +869,13 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n     fn trans_transmute_into(&mut self, bcx: &Builder<'a, 'tcx>,\n                             src: &mir::Operand<'tcx>,\n-                            dst: LvalueRef<'tcx>) {\n+                            dst: PlaceRef<'tcx>) {\n         let src = self.trans_operand(bcx, src);\n         let llty = src.layout.llvm_type(bcx.ccx);\n         let cast_ptr = bcx.pointercast(dst.llval, llty.ptr_to());\n         let align = src.layout.align.min(dst.layout.align);\n         src.val.store(bcx,\n-            LvalueRef::new_sized(cast_ptr, src.layout, Alignment::Packed(align)));\n+            PlaceRef::new_sized(cast_ptr, src.layout, Alignment::Packed(align)));\n     }\n \n \n@@ -898,7 +898,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             DirectOperand(index) => {\n                 // If there is a cast, we have to store and reload.\n                 let op = if let PassMode::Cast(_) = ret_ty.mode {\n-                    let tmp = LvalueRef::alloca(bcx, ret_ty.layout, \"tmp_ret\");\n+                    let tmp = PlaceRef::alloca(bcx, ret_ty.layout, \"tmp_ret\");\n                     tmp.storage_live(bcx);\n                     ret_ty.store(bcx, llval, tmp);\n                     let op = tmp.load(bcx);\n@@ -917,9 +917,9 @@ enum ReturnDest<'tcx> {\n     // Do nothing, the return value is indirect or ignored\n     Nothing,\n     // Store the return value to the pointer\n-    Store(LvalueRef<'tcx>),\n+    Store(PlaceRef<'tcx>),\n     // Stores an indirect return value to an operand local lvalue\n-    IndirectOperand(LvalueRef<'tcx>, mir::Local),\n+    IndirectOperand(PlaceRef<'tcx>, mir::Local),\n     // Stores a direct return value to an operand local lvalue\n     DirectOperand(mir::Local)\n }"}, {"sha": "75fb95ed6e8daa7ad2bae762e696d2686392bf89", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -16,7 +16,7 @@ use rustc::hir::def_id::DefId;\n use rustc::infer::TransNormalize;\n use rustc::traits;\n use rustc::mir;\n-use rustc::mir::tcx::LvalueTy;\n+use rustc::mir::tcx::PlaceTy;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::layout::{self, LayoutOf, Size};\n use rustc::ty::cast::{CastTy, IntTy};\n@@ -156,8 +156,8 @@ impl<'a, 'tcx> Const<'tcx> {\n         self.get_pair(ccx)\n     }\n \n-    fn as_lvalue(&self) -> ConstLvalue<'tcx> {\n-        ConstLvalue {\n+    fn as_lvalue(&self) -> ConstPlace<'tcx> {\n+        ConstPlace {\n             base: Base::Value(self.llval),\n             llextra: ptr::null_mut(),\n             ty: self.ty\n@@ -212,13 +212,13 @@ enum Base {\n \n /// An lvalue as seen from a constant.\n #[derive(Copy, Clone)]\n-struct ConstLvalue<'tcx> {\n+struct ConstPlace<'tcx> {\n     base: Base,\n     llextra: ValueRef,\n     ty: Ty<'tcx>\n }\n \n-impl<'tcx> ConstLvalue<'tcx> {\n+impl<'tcx> ConstPlace<'tcx> {\n     fn to_const(&self, span: Span) -> Const<'tcx> {\n         match self.base {\n             Base::Value(val) => Const::new(val, self.ty),\n@@ -242,7 +242,7 @@ impl<'tcx> ConstLvalue<'tcx> {\n                 assert!(self.llextra != ptr::null_mut());\n                 self.llextra\n             }\n-            _ => bug!(\"unexpected type `{}` in ConstLvalue::len\", self.ty)\n+            _ => bug!(\"unexpected type `{}` in ConstPlace::len\", self.ty)\n         }\n     }\n }\n@@ -427,38 +427,38 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n     }\n \n     fn store(&mut self,\n-             dest: &mir::Lvalue<'tcx>,\n+             dest: &mir::Place<'tcx>,\n              value: Result<Const<'tcx>, ConstEvalErr<'tcx>>,\n              span: Span) {\n-        if let mir::Lvalue::Local(index) = *dest {\n+        if let mir::Place::Local(index) = *dest {\n             self.locals[index] = Some(value);\n         } else {\n             span_bug!(span, \"assignment to {:?} in constant\", dest);\n         }\n     }\n \n-    fn const_lvalue(&self, lvalue: &mir::Lvalue<'tcx>, span: Span)\n-                    -> Result<ConstLvalue<'tcx>, ConstEvalErr<'tcx>> {\n+    fn const_lvalue(&self, lvalue: &mir::Place<'tcx>, span: Span)\n+                    -> Result<ConstPlace<'tcx>, ConstEvalErr<'tcx>> {\n         let tcx = self.ccx.tcx();\n \n-        if let mir::Lvalue::Local(index) = *lvalue {\n+        if let mir::Place::Local(index) = *lvalue {\n             return self.locals[index].clone().unwrap_or_else(|| {\n                 span_bug!(span, \"{:?} not initialized\", lvalue)\n             }).map(|v| v.as_lvalue());\n         }\n \n         let lvalue = match *lvalue {\n-            mir::Lvalue::Local(_)  => bug!(), // handled above\n-            mir::Lvalue::Static(box mir::Static { def_id, ty }) => {\n-                ConstLvalue {\n+            mir::Place::Local(_)  => bug!(), // handled above\n+            mir::Place::Static(box mir::Static { def_id, ty }) => {\n+                ConstPlace {\n                     base: Base::Static(consts::get_static(self.ccx, def_id)),\n                     llextra: ptr::null_mut(),\n                     ty: self.monomorphize(&ty),\n                 }\n             }\n-            mir::Lvalue::Projection(ref projection) => {\n+            mir::Place::Projection(ref projection) => {\n                 let tr_base = self.const_lvalue(&projection.base, span)?;\n-                let projected_ty = LvalueTy::Ty { ty: tr_base.ty }\n+                let projected_ty = PlaceTy::Ty { ty: tr_base.ty }\n                     .projection_ty(tcx, &projection.elem);\n                 let base = tr_base.to_const(span);\n                 let projected_ty = self.monomorphize(&projected_ty).to_ty(tcx);\n@@ -505,7 +505,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                         (Base::Value(llprojected), llextra)\n                     }\n                     mir::ProjectionElem::Index(index) => {\n-                        let index = &mir::Operand::Copy(mir::Lvalue::Local(index));\n+                        let index = &mir::Operand::Copy(mir::Place::Local(index));\n                         let llindex = self.const_operand(index, span)?.llval;\n \n                         let iv = if let Some(iv) = common::const_to_opt_u128(llindex, false) {\n@@ -526,7 +526,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                     }\n                     _ => span_bug!(span, \"{:?} in constant\", projection.elem)\n                 };\n-                ConstLvalue {\n+                ConstPlace {\n                     base: projected,\n                     llextra,\n                     ty: projected_ty"}, {"sha": "88689540f95e28fd4ebeedd4452eb363a4332b96", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -12,7 +12,7 @@ use llvm::{self, ValueRef};\n use rustc::ty::{self, Ty};\n use rustc::ty::layout::{self, Align, TyLayout, LayoutOf};\n use rustc::mir;\n-use rustc::mir::tcx::LvalueTy;\n+use rustc::mir::tcx::PlaceTy;\n use rustc_data_structures::indexed_vec::Idx;\n use base;\n use builder::Builder;\n@@ -73,7 +73,7 @@ impl Alignment {\n }\n \n #[derive(Copy, Clone, Debug)]\n-pub struct LvalueRef<'tcx> {\n+pub struct PlaceRef<'tcx> {\n     /// Pointer to the contents of the lvalue\n     pub llval: ValueRef,\n \n@@ -87,12 +87,12 @@ pub struct LvalueRef<'tcx> {\n     pub alignment: Alignment,\n }\n \n-impl<'a, 'tcx> LvalueRef<'tcx> {\n+impl<'a, 'tcx> PlaceRef<'tcx> {\n     pub fn new_sized(llval: ValueRef,\n                      layout: TyLayout<'tcx>,\n                      alignment: Alignment)\n-                     -> LvalueRef<'tcx> {\n-        LvalueRef {\n+                     -> PlaceRef<'tcx> {\n+        PlaceRef {\n             llval,\n             llextra: ptr::null_mut(),\n             layout,\n@@ -101,7 +101,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n     }\n \n     pub fn alloca(bcx: &Builder<'a, 'tcx>, layout: TyLayout<'tcx>, name: &str)\n-                  -> LvalueRef<'tcx> {\n+                  -> PlaceRef<'tcx> {\n         debug!(\"alloca({:?}: {:?})\", name, layout);\n         let tmp = bcx.alloca(layout.llvm_type(bcx.ccx), name, layout.align);\n         Self::new_sized(tmp, layout, Alignment::AbiAligned)\n@@ -117,7 +117,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n                 C_usize(ccx, count)\n             }\n         } else {\n-            bug!(\"unexpected layout `{:#?}` in LvalueRef::len\", self.layout)\n+            bug!(\"unexpected layout `{:#?}` in PlaceRef::len\", self.layout)\n         }\n     }\n \n@@ -126,7 +126,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n     }\n \n     pub fn load(&self, bcx: &Builder<'a, 'tcx>) -> OperandRef<'tcx> {\n-        debug!(\"LvalueRef::load: {:?}\", self);\n+        debug!(\"PlaceRef::load: {:?}\", self);\n \n         assert!(!self.has_extra());\n \n@@ -202,7 +202,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n     }\n \n     /// Access a field, at a point when the value's case is known.\n-    pub fn project_field(self, bcx: &Builder<'a, 'tcx>, ix: usize) -> LvalueRef<'tcx> {\n+    pub fn project_field(self, bcx: &Builder<'a, 'tcx>, ix: usize) -> PlaceRef<'tcx> {\n         let ccx = bcx.ccx;\n         let field = self.layout.field(ccx, ix);\n         let offset = self.layout.fields.offset(ix);\n@@ -219,7 +219,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n             } else {\n                 bcx.struct_gep(self.llval, self.layout.llvm_field_index(ix))\n             };\n-            LvalueRef {\n+            PlaceRef {\n                 // HACK(eddyb) have to bitcast pointers until LLVM removes pointee types.\n                 llval: bcx.pointercast(llval, field.llvm_type(ccx).ptr_to()),\n                 llextra: if ccx.shared().type_has_metadata(field.ty) {\n@@ -295,7 +295,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n         let ll_fty = field.llvm_type(ccx);\n         debug!(\"struct_field_ptr: Field type is {:?}\", ll_fty);\n \n-        LvalueRef {\n+        PlaceRef {\n             llval: bcx.pointercast(byte_ptr, ll_fty.ptr_to()),\n             llextra: self.llextra,\n             layout: field,\n@@ -413,8 +413,8 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n     }\n \n     pub fn project_index(&self, bcx: &Builder<'a, 'tcx>, llindex: ValueRef)\n-                         -> LvalueRef<'tcx> {\n-        LvalueRef {\n+                         -> PlaceRef<'tcx> {\n+        PlaceRef {\n             llval: bcx.inbounds_gep(self.llval, &[C_usize(bcx.ccx, 0), llindex]),\n             llextra: ptr::null_mut(),\n             layout: self.layout.field(bcx.ccx, 0),\n@@ -423,7 +423,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n     }\n \n     pub fn project_downcast(&self, bcx: &Builder<'a, 'tcx>, variant_index: usize)\n-                            -> LvalueRef<'tcx> {\n+                            -> PlaceRef<'tcx> {\n         let mut downcast = *self;\n         downcast.layout = self.layout.for_variant(bcx.ccx, variant_index);\n \n@@ -446,16 +446,16 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     pub fn trans_lvalue(&mut self,\n                         bcx: &Builder<'a, 'tcx>,\n-                        lvalue: &mir::Lvalue<'tcx>)\n-                        -> LvalueRef<'tcx> {\n+                        lvalue: &mir::Place<'tcx>)\n+                        -> PlaceRef<'tcx> {\n         debug!(\"trans_lvalue(lvalue={:?})\", lvalue);\n \n         let ccx = bcx.ccx;\n         let tcx = ccx.tcx();\n \n-        if let mir::Lvalue::Local(index) = *lvalue {\n+        if let mir::Place::Local(index) = *lvalue {\n             match self.locals[index] {\n-                LocalRef::Lvalue(lvalue) => {\n+                LocalRef::Place(lvalue) => {\n                     return lvalue;\n                 }\n                 LocalRef::Operand(..) => {\n@@ -465,20 +465,20 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         }\n \n         let result = match *lvalue {\n-            mir::Lvalue::Local(_) => bug!(), // handled above\n-            mir::Lvalue::Static(box mir::Static { def_id, ty }) => {\n-                LvalueRef::new_sized(consts::get_static(ccx, def_id),\n+            mir::Place::Local(_) => bug!(), // handled above\n+            mir::Place::Static(box mir::Static { def_id, ty }) => {\n+                PlaceRef::new_sized(consts::get_static(ccx, def_id),\n                                      ccx.layout_of(self.monomorphize(&ty)),\n                                      Alignment::AbiAligned)\n             },\n-            mir::Lvalue::Projection(box mir::Projection {\n+            mir::Place::Projection(box mir::Projection {\n                 ref base,\n                 elem: mir::ProjectionElem::Deref\n             }) => {\n                 // Load the pointer from its location.\n                 self.trans_consume(bcx, base).deref(bcx.ccx)\n             }\n-            mir::Lvalue::Projection(ref projection) => {\n+            mir::Place::Projection(ref projection) => {\n                 let tr_base = self.trans_lvalue(bcx, &projection.base);\n \n                 match projection.elem {\n@@ -487,7 +487,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         tr_base.project_field(bcx, field.index())\n                     }\n                     mir::ProjectionElem::Index(index) => {\n-                        let index = &mir::Operand::Copy(mir::Lvalue::Local(index));\n+                        let index = &mir::Operand::Copy(mir::Place::Local(index));\n                         let index = self.trans_operand(bcx, index);\n                         let llindex = index.immediate();\n                         tr_base.project_index(bcx, llindex)\n@@ -509,7 +509,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     mir::ProjectionElem::Subslice { from, to } => {\n                         let mut subslice = tr_base.project_index(bcx,\n                             C_usize(bcx.ccx, from as u64));\n-                        let projected_ty = LvalueTy::Ty { ty: tr_base.layout.ty }\n+                        let projected_ty = PlaceTy::Ty { ty: tr_base.layout.ty }\n                             .projection_ty(tcx, &projection.elem).to_ty(bcx.tcx());\n                         subslice.layout = bcx.ccx.layout_of(self.monomorphize(&projected_ty));\n \n@@ -536,7 +536,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         result\n     }\n \n-    pub fn monomorphized_lvalue_ty(&self, lvalue: &mir::Lvalue<'tcx>) -> Ty<'tcx> {\n+    pub fn monomorphized_lvalue_ty(&self, lvalue: &mir::Place<'tcx>) -> Ty<'tcx> {\n         let tcx = self.ccx.tcx();\n         let lvalue_ty = lvalue.ty(self.mir, tcx);\n         self.monomorphize(&lvalue_ty.to_ty(tcx))"}, {"sha": "de57b0239e16e034cf24ca3140e612c985187e1e", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -35,7 +35,7 @@ use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n pub use self::constant::trans_static_initializer;\n \n use self::analyze::CleanupKind;\n-use self::lvalue::{Alignment, LvalueRef};\n+use self::lvalue::{Alignment, PlaceRef};\n use rustc::mir::traversal;\n \n use self::operand::{OperandRef, OperandValue};\n@@ -59,7 +59,7 @@ pub struct MirContext<'a, 'tcx:'a> {\n     /// don't really care about it very much. Anyway, this value\n     /// contains an alloca into which the personality is stored and\n     /// then later loaded when generating the DIVERGE_BLOCK.\n-    personality_slot: Option<LvalueRef<'tcx>>,\n+    personality_slot: Option<PlaceRef<'tcx>>,\n \n     /// A `Block` for each MIR `BasicBlock`\n     blocks: IndexVec<mir::BasicBlock, BasicBlockRef>,\n@@ -79,7 +79,7 @@ pub struct MirContext<'a, 'tcx:'a> {\n     unreachable_block: Option<BasicBlockRef>,\n \n     /// The location where each MIR arg/var/tmp/ret is stored. This is\n-    /// usually an `LvalueRef` representing an alloca, but not always:\n+    /// usually an `PlaceRef` representing an alloca, but not always:\n     /// sometimes we can skip the alloca and just store the value\n     /// directly using an `OperandRef`, which makes for tighter LLVM\n     /// IR. The conditions for using an `OperandRef` are as follows:\n@@ -171,7 +171,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n }\n \n enum LocalRef<'tcx> {\n-    Lvalue(LvalueRef<'tcx>),\n+    Place(PlaceRef<'tcx>),\n     Operand(Option<OperandRef<'tcx>>),\n }\n \n@@ -266,25 +266,25 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n                 }\n \n                 debug!(\"alloc: {:?} ({}) -> lvalue\", local, name);\n-                let lvalue = LvalueRef::alloca(&bcx, layout, &name.as_str());\n+                let lvalue = PlaceRef::alloca(&bcx, layout, &name.as_str());\n                 if dbg {\n                     let (scope, span) = mircx.debug_loc(decl.source_info);\n                     declare_local(&bcx, &mircx.debug_context, name, layout.ty, scope,\n                         VariableAccess::DirectVariable { alloca: lvalue.llval },\n                         VariableKind::LocalVariable, span);\n                 }\n-                LocalRef::Lvalue(lvalue)\n+                LocalRef::Place(lvalue)\n             } else {\n                 // Temporary or return pointer\n                 if local == mir::RETURN_POINTER && mircx.fn_ty.ret.is_indirect() {\n                     debug!(\"alloc: {:?} (return pointer) -> lvalue\", local);\n                     let llretptr = llvm::get_param(llfn, 0);\n-                    LocalRef::Lvalue(LvalueRef::new_sized(llretptr,\n+                    LocalRef::Place(PlaceRef::new_sized(llretptr,\n                                                           layout,\n                                                           Alignment::AbiAligned))\n                 } else if lvalue_locals.contains(local.index()) {\n                     debug!(\"alloc: {:?} -> lvalue\", local);\n-                    LocalRef::Lvalue(LvalueRef::alloca(&bcx, layout, &format!(\"{:?}\", local)))\n+                    LocalRef::Place(PlaceRef::alloca(&bcx, layout, &format!(\"{:?}\", local)))\n                 } else {\n                     // If this is an immediate local, we do not create an\n                     // alloca in advance. Instead we wait until we see the\n@@ -400,7 +400,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                 _ => bug!(\"spread argument isn't a tuple?!\")\n             };\n \n-            let lvalue = LvalueRef::alloca(bcx, bcx.ccx.layout_of(arg_ty), &name);\n+            let lvalue = PlaceRef::alloca(bcx, bcx.ccx.layout_of(arg_ty), &name);\n             for i in 0..tupled_arg_tys.len() {\n                 let arg = &mircx.fn_ty.args[idx];\n                 idx += 1;\n@@ -424,7 +424,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                 );\n             });\n \n-            return LocalRef::Lvalue(lvalue);\n+            return LocalRef::Place(lvalue);\n         }\n \n         let arg = &mircx.fn_ty.args[idx];\n@@ -474,9 +474,9 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             let llarg = llvm::get_param(bcx.llfn(), llarg_idx as c_uint);\n             bcx.set_value_name(llarg, &name);\n             llarg_idx += 1;\n-            LvalueRef::new_sized(llarg, arg.layout, Alignment::AbiAligned)\n+            PlaceRef::new_sized(llarg, arg.layout, Alignment::AbiAligned)\n         } else {\n-            let tmp = LvalueRef::alloca(bcx, arg.layout, &name);\n+            let tmp = PlaceRef::alloca(bcx, arg.layout, &name);\n             arg.store_fn_arg(bcx, &mut llarg_idx, tmp);\n             tmp\n         };\n@@ -532,7 +532,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             // doesn't actually strip the offset when splitting the closure\n             // environment into its components so it ends up out of bounds.\n             let env_ptr = if !env_ref {\n-                let alloc = LvalueRef::alloca(bcx,\n+                let alloc = PlaceRef::alloca(bcx,\n                     bcx.ccx.layout_of(tcx.mk_mut_ptr(arg.layout.ty)),\n                     \"__debuginfo_env_ptr\");\n                 bcx.store(lvalue.llval, alloc.llval, None);\n@@ -580,7 +580,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                 );\n             }\n         });\n-        LocalRef::Lvalue(lvalue)\n+        LocalRef::Place(lvalue)\n     }).collect()\n }\n "}, {"sha": "876b5e7477949300a98c15296578814548ae63a1", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -25,7 +25,7 @@ use std::fmt;\n use std::ptr;\n \n use super::{MirContext, LocalRef};\n-use super::lvalue::{Alignment, LvalueRef};\n+use super::lvalue::{Alignment, PlaceRef};\n \n /// The representation of a Rust value. The enum variant is in fact\n /// uniquely determined by the value's type, but is kept as a\n@@ -99,15 +99,15 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n         }\n     }\n \n-    pub fn deref(self, ccx: &CrateContext<'a, 'tcx>) -> LvalueRef<'tcx> {\n+    pub fn deref(self, ccx: &CrateContext<'a, 'tcx>) -> PlaceRef<'tcx> {\n         let projected_ty = self.layout.ty.builtin_deref(true, ty::NoPreference)\n             .unwrap_or_else(|| bug!(\"deref of non-pointer {:?}\", self)).ty;\n         let (llptr, llextra) = match self.val {\n             OperandValue::Immediate(llptr) => (llptr, ptr::null_mut()),\n             OperandValue::Pair(llptr, llextra) => (llptr, llextra),\n             OperandValue::Ref(..) => bug!(\"Deref of by-Ref operand {:?}\", self)\n         };\n-        LvalueRef {\n+        PlaceRef {\n             llval: llptr,\n             llextra,\n             layout: ccx.layout_of(projected_ty),\n@@ -212,7 +212,7 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n }\n \n impl<'a, 'tcx> OperandValue {\n-    pub fn store(self, bcx: &Builder<'a, 'tcx>, dest: LvalueRef<'tcx>) {\n+    pub fn store(self, bcx: &Builder<'a, 'tcx>, dest: PlaceRef<'tcx>) {\n         debug!(\"OperandRef::store: operand={:?}, dest={:?}\", self, dest);\n         // Avoid generating stores of zero-sized values, because the only way to have a zero-sized\n         // value is through `undef`, and store itself is useless.\n@@ -243,29 +243,29 @@ impl<'a, 'tcx> OperandValue {\n impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     fn maybe_trans_consume_direct(&mut self,\n                                   bcx: &Builder<'a, 'tcx>,\n-                                  lvalue: &mir::Lvalue<'tcx>)\n+                                  lvalue: &mir::Place<'tcx>)\n                                    -> Option<OperandRef<'tcx>>\n     {\n         debug!(\"maybe_trans_consume_direct(lvalue={:?})\", lvalue);\n \n         // watch out for locals that do not have an\n         // alloca; they are handled somewhat differently\n-        if let mir::Lvalue::Local(index) = *lvalue {\n+        if let mir::Place::Local(index) = *lvalue {\n             match self.locals[index] {\n                 LocalRef::Operand(Some(o)) => {\n                     return Some(o);\n                 }\n                 LocalRef::Operand(None) => {\n                     bug!(\"use of {:?} before def\", lvalue);\n                 }\n-                LocalRef::Lvalue(..) => {\n+                LocalRef::Place(..) => {\n                     // use path below\n                 }\n             }\n         }\n \n         // Moves out of scalar and scalar pair fields are trivial.\n-        if let &mir::Lvalue::Projection(ref proj) = lvalue {\n+        if let &mir::Place::Projection(ref proj) = lvalue {\n             if let mir::ProjectionElem::Field(ref f, _) = proj.elem {\n                 if let Some(o) = self.maybe_trans_consume_direct(bcx, &proj.base) {\n                     return Some(o.extract_field(bcx, f.index()));\n@@ -278,7 +278,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n     pub fn trans_consume(&mut self,\n                          bcx: &Builder<'a, 'tcx>,\n-                         lvalue: &mir::Lvalue<'tcx>)\n+                         lvalue: &mir::Place<'tcx>)\n                          -> OperandRef<'tcx>\n     {\n         debug!(\"trans_consume(lvalue={:?})\", lvalue);\n@@ -318,7 +318,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let operand = val.to_operand(bcx.ccx);\n                 if let OperandValue::Ref(ptr, align) = operand.val {\n                     // If this is a OperandValue::Ref to an immediate constant, load it.\n-                    LvalueRef::new_sized(ptr, operand.layout, align).load(bcx)\n+                    PlaceRef::new_sized(ptr, operand.layout, align).load(bcx)\n                 } else {\n                     operand\n                 }"}, {"sha": "431c34eb9e677a371ae550449927202e7e689a42", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -32,12 +32,12 @@ use value::Value;\n use super::{MirContext, LocalRef};\n use super::constant::const_scalar_checked_binop;\n use super::operand::{OperandRef, OperandValue};\n-use super::lvalue::LvalueRef;\n+use super::lvalue::PlaceRef;\n \n impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     pub fn trans_rvalue(&mut self,\n                         bcx: Builder<'a, 'tcx>,\n-                        dest: LvalueRef<'tcx>,\n+                        dest: PlaceRef<'tcx>,\n                         rvalue: &mir::Rvalue<'tcx>)\n                         -> Builder<'a, 'tcx>\n     {\n@@ -79,14 +79,14 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         // index into the struct, and this case isn't\n                         // important enough for it.\n                         debug!(\"trans_rvalue: creating ugly alloca\");\n-                        let scratch = LvalueRef::alloca(&bcx, operand.layout, \"__unsize_temp\");\n+                        let scratch = PlaceRef::alloca(&bcx, operand.layout, \"__unsize_temp\");\n                         scratch.storage_live(&bcx);\n                         operand.val.store(&bcx, scratch);\n                         base::coerce_unsized_into(&bcx, scratch, dest);\n                         scratch.storage_dead(&bcx);\n                     }\n                     OperandValue::Ref(llref, align) => {\n-                        let source = LvalueRef::new_sized(llref, operand.layout, align);\n+                        let source = PlaceRef::new_sized(llref, operand.layout, align);\n                         base::coerce_unsized_into(&bcx, source, dest);\n                     }\n                 }\n@@ -139,7 +139,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 header_bcx.cond_br(keep_going, body_bcx.llbb(), next_bcx.llbb());\n \n                 tr_elem.val.store(&body_bcx,\n-                    LvalueRef::new_sized(current, tr_elem.layout, dest.alignment));\n+                    PlaceRef::new_sized(current, tr_elem.layout, dest.alignment));\n \n                 let next = body_bcx.inbounds_gep(current, &[C_usize(bcx.ccx, 1)]);\n                 body_bcx.br(header_bcx.llbb());\n@@ -486,11 +486,11 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n     fn evaluate_array_len(&mut self,\n                           bcx: &Builder<'a, 'tcx>,\n-                          lvalue: &mir::Lvalue<'tcx>) -> ValueRef\n+                          lvalue: &mir::Place<'tcx>) -> ValueRef\n     {\n         // ZST are passed as operands and require special handling\n         // because trans_lvalue() panics if Local is operand.\n-        if let mir::Lvalue::Local(index) = *lvalue {\n+        if let mir::Place::Local(index) = *lvalue {\n             if let LocalRef::Operand(Some(op)) = self.locals[index] {\n                 if let ty::TyArray(_, n) = op.layout.ty.sty {\n                     let n = n.val.to_const_int().unwrap().to_u64().unwrap();"}, {"sha": "20843db2e6451e085472612879cadf33472450f4", "filename": "src/librustc_trans/mir/statement.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fstatement.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -26,9 +26,9 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         self.set_debug_loc(&bcx, statement.source_info);\n         match statement.kind {\n             mir::StatementKind::Assign(ref lvalue, ref rvalue) => {\n-                if let mir::Lvalue::Local(index) = *lvalue {\n+                if let mir::Place::Local(index) = *lvalue {\n                     match self.locals[index] {\n-                        LocalRef::Lvalue(tr_dest) => {\n+                        LocalRef::Place(tr_dest) => {\n                             self.trans_rvalue(bcx, tr_dest, rvalue)\n                         }\n                         LocalRef::Operand(None) => {\n@@ -59,13 +59,13 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 bcx\n             }\n             mir::StatementKind::StorageLive(local) => {\n-                if let LocalRef::Lvalue(tr_lval) = self.locals[local] {\n+                if let LocalRef::Place(tr_lval) = self.locals[local] {\n                     tr_lval.storage_live(&bcx);\n                 }\n                 bcx\n             }\n             mir::StatementKind::StorageDead(local) => {\n-                if let LocalRef::Lvalue(tr_lval) = self.locals[local] {\n+                if let LocalRef::Place(tr_lval) = self.locals[local] {\n                     tr_lval.storage_dead(&bcx);\n                 }\n                 bcx"}, {"sha": "9ee4e7d4922e27d8f1b558c179fbecbec99ce64e", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -227,7 +227,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n     }\n \n     /// Get the LLVM type corresponding to a Rust type, i.e. `rustc::ty::Ty`.\n-    /// The pointee type of the pointer in `LvalueRef` is always this type.\n+    /// The pointee type of the pointer in `PlaceRef` is always this type.\n     /// For sized types, it is also the right LLVM type for an `alloca`\n     /// containing a value of that type, and most immediates (except `bool`).\n     /// Unsized types, however, are represented by a \"minimal unit\", e.g."}, {"sha": "e5a97966723d2d906c61ab362ec3cd5b9b1fdc63", "filename": "src/librustc_trans_utils/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_trans_utils%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511743c438c4cb1511b97fb851585d57492d7642/src%2Flibrustc_trans_utils%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Fcollector.rs?ref=511743c438c4cb1511b97fb851585d57492d7642", "patch": "@@ -639,7 +639,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n \n     fn visit_static(&mut self,\n                     static_: &mir::Static<'tcx>,\n-                    context: mir::visit::LvalueContext<'tcx>,\n+                    context: mir::visit::PlaceContext<'tcx>,\n                     location: Location) {\n         debug!(\"visiting static {:?} @ {:?}\", static_.def_id, location);\n "}]}