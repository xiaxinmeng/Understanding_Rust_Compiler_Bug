{"sha": "b3e9f3d143b0fae970449b7c49a2daf6f966a068", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzZTlmM2QxNDNiMGZhZTk3MDQ0OWI3YzQ5YTJkYWY2Zjk2NmEwNjg=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-04-25T13:02:09Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-04-25T17:30:00Z"}, "message": "Move hprof to a separate file", "tree": {"sha": "441e77b7fd9aeb5a7ecc4cfae421177fd019e83e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/441e77b7fd9aeb5a7ecc4cfae421177fd019e83e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b3e9f3d143b0fae970449b7c49a2daf6f966a068", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b3e9f3d143b0fae970449b7c49a2daf6f966a068", "html_url": "https://github.com/rust-lang/rust/commit/b3e9f3d143b0fae970449b7c49a2daf6f966a068", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b3e9f3d143b0fae970449b7c49a2daf6f966a068/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7623db11061f70dd654405a0da91bc3ad1abc53a", "url": "https://api.github.com/repos/rust-lang/rust/commits/7623db11061f70dd654405a0da91bc3ad1abc53a", "html_url": "https://github.com/rust-lang/rust/commit/7623db11061f70dd654405a0da91bc3ad1abc53a"}], "stats": {"total": 791, "additions": 398, "deletions": 393}, "files": [{"sha": "79268513d8aef82e4902f3fe9661c8aaf0e9fa11", "filename": "crates/ra_prof/src/hprof.rs", "status": "added", "additions": 391, "deletions": 0, "changes": 391, "blob_url": "https://github.com/rust-lang/rust/blob/b3e9f3d143b0fae970449b7c49a2daf6f966a068/crates%2Fra_prof%2Fsrc%2Fhprof.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3e9f3d143b0fae970449b7c49a2daf6f966a068/crates%2Fra_prof%2Fsrc%2Fhprof.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_prof%2Fsrc%2Fhprof.rs?ref=b3e9f3d143b0fae970449b7c49a2daf6f966a068", "patch": "@@ -0,0 +1,391 @@\n+//! Simple hierarchical profiler\n+use std::{\n+    cell::RefCell,\n+    collections::{BTreeMap, HashSet},\n+    io::{stderr, Write},\n+    sync::{\n+        atomic::{AtomicBool, Ordering},\n+        RwLock,\n+    },\n+    time::{Duration, Instant},\n+};\n+\n+use once_cell::sync::Lazy;\n+\n+/// Filtering syntax\n+/// env RA_PROFILE=*             // dump everything\n+/// env RA_PROFILE=foo|bar|baz   // enabled only selected entries\n+/// env RA_PROFILE=*@3>10        // dump everything, up to depth 3, if it takes more than 10 ms\n+pub fn init() {\n+    let spec = std::env::var(\"RA_PROFILE\").unwrap_or_default();\n+    init_from(&spec);\n+}\n+\n+pub fn init_from(spec: &str) {\n+    let filter = if spec.is_empty() { Filter::disabled() } else { Filter::from_spec(spec) };\n+    set_filter(filter);\n+}\n+\n+pub type Label = &'static str;\n+\n+/// This function starts a profiling scope in the current execution stack with a given description.\n+/// It returns a Profile structure and measure elapsed time between this method invocation and Profile structure drop.\n+/// It supports nested profiling scopes in case when this function invoked multiple times at the execution stack. In this case the profiling information will be nested at the output.\n+/// Profiling information is being printed in the stderr.\n+///\n+/// # Example\n+/// ```\n+/// use ra_prof::{profile, set_filter, Filter};\n+///\n+/// let f = Filter::from_spec(\"profile1|profile2@2\");\n+/// set_filter(f);\n+/// profiling_function1();\n+///\n+/// fn profiling_function1() {\n+///     let _p = profile(\"profile1\");\n+///     profiling_function2();\n+/// }\n+///\n+/// fn profiling_function2() {\n+///     let _p = profile(\"profile2\");\n+/// }\n+/// ```\n+/// This will print in the stderr the following:\n+/// ```text\n+///  0ms - profile\n+///      0ms - profile2\n+/// ```\n+pub fn profile(label: Label) -> Profiler {\n+    assert!(!label.is_empty());\n+    if !PROFILING_ENABLED.load(Ordering::Relaxed) {\n+        return Profiler { label: None, detail: None };\n+    }\n+\n+    PROFILE_STACK.with(|stack| {\n+        let mut stack = stack.borrow_mut();\n+        if stack.starts.is_empty() {\n+            if let Ok(f) = FILTER.try_read() {\n+                if f.version > stack.filter_data.version {\n+                    stack.filter_data = f.clone();\n+                }\n+            };\n+        }\n+        if stack.starts.len() > stack.filter_data.depth {\n+            return Profiler { label: None, detail: None };\n+        }\n+        let allowed = &stack.filter_data.allowed;\n+        if stack.starts.is_empty() && !allowed.is_empty() && !allowed.contains(label) {\n+            return Profiler { label: None, detail: None };\n+        }\n+\n+        stack.starts.push(Instant::now());\n+        Profiler { label: Some(label), detail: None }\n+    })\n+}\n+\n+pub struct Profiler {\n+    label: Option<Label>,\n+    detail: Option<String>,\n+}\n+\n+impl Profiler {\n+    pub fn detail(mut self, detail: impl FnOnce() -> String) -> Profiler {\n+        if self.label.is_some() {\n+            self.detail = Some(detail())\n+        }\n+        self\n+    }\n+}\n+\n+/// Set profiling filter. It specifies descriptions allowed to profile.\n+/// This is helpful when call stack has too many nested profiling scopes.\n+/// Additionally filter can specify maximum depth of profiling scopes nesting.\n+///\n+/// #Example\n+/// ```\n+/// use ra_prof::{set_filter, Filter};\n+/// let f = Filter::from_spec(\"profile1|profile2@2\");\n+/// set_filter(f);\n+/// ```\n+fn set_filter(f: Filter) {\n+    PROFILING_ENABLED.store(f.depth > 0, Ordering::SeqCst);\n+    let set: HashSet<_> = f.allowed.iter().cloned().collect();\n+    let mut old = FILTER.write().unwrap();\n+    let filter_data = FilterData {\n+        depth: f.depth,\n+        allowed: set,\n+        longer_than: f.longer_than,\n+        version: old.version + 1,\n+    };\n+    *old = filter_data;\n+}\n+\n+struct Filter {\n+    depth: usize,\n+    allowed: Vec<String>,\n+    longer_than: Duration,\n+}\n+\n+impl Filter {\n+    fn from_spec(mut spec: &str) -> Filter {\n+        let longer_than = if let Some(idx) = spec.rfind('>') {\n+            let longer_than = spec[idx + 1..].parse().expect(\"invalid profile longer_than\");\n+            spec = &spec[..idx];\n+            Duration::from_millis(longer_than)\n+        } else {\n+            Duration::new(0, 0)\n+        };\n+\n+        let depth = if let Some(idx) = spec.rfind('@') {\n+            let depth: usize = spec[idx + 1..].parse().expect(\"invalid profile depth\");\n+            spec = &spec[..idx];\n+            depth\n+        } else {\n+            999\n+        };\n+        let allowed =\n+            if spec == \"*\" { Vec::new() } else { spec.split('|').map(String::from).collect() };\n+        Filter::new(depth, allowed, longer_than)\n+    }\n+\n+    pub fn disabled() -> Filter {\n+        Filter::new(0, Vec::new(), Duration::new(0, 0))\n+    }\n+\n+    pub fn new(depth: usize, allowed: Vec<String>, longer_than: Duration) -> Filter {\n+        Filter { depth, allowed, longer_than }\n+    }\n+}\n+\n+struct ProfileStack {\n+    starts: Vec<Instant>,\n+    messages: Vec<Message>,\n+    filter_data: FilterData,\n+}\n+\n+struct Message {\n+    level: usize,\n+    duration: Duration,\n+    label: Label,\n+    detail: Option<String>,\n+}\n+\n+impl ProfileStack {\n+    fn new() -> ProfileStack {\n+        ProfileStack { starts: Vec::new(), messages: Vec::new(), filter_data: Default::default() }\n+    }\n+}\n+\n+#[derive(Default, Clone)]\n+struct FilterData {\n+    depth: usize,\n+    version: usize,\n+    allowed: HashSet<String>,\n+    longer_than: Duration,\n+}\n+\n+static PROFILING_ENABLED: AtomicBool = AtomicBool::new(false);\n+\n+static FILTER: Lazy<RwLock<FilterData>> = Lazy::new(Default::default);\n+\n+thread_local!(static PROFILE_STACK: RefCell<ProfileStack> = RefCell::new(ProfileStack::new()));\n+\n+impl Drop for Profiler {\n+    fn drop(&mut self) {\n+        match self {\n+            Profiler { label: Some(label), detail } => {\n+                PROFILE_STACK.with(|stack| {\n+                    let mut stack = stack.borrow_mut();\n+                    let start = stack.starts.pop().unwrap();\n+                    let duration = start.elapsed();\n+                    let level = stack.starts.len();\n+                    stack.messages.push(Message { level, duration, label, detail: detail.take() });\n+                    if level == 0 {\n+                        let stdout = stderr();\n+                        let longer_than = stack.filter_data.longer_than;\n+                        // Convert to millis for comparison to avoid problems with rounding\n+                        // (otherwise we could print `0ms` despite user's `>0` filter when\n+                        // `duration` is just a few nanos).\n+                        if duration.as_millis() > longer_than.as_millis() {\n+                            print(&stack.messages, longer_than, &mut stdout.lock());\n+                        }\n+                        stack.messages.clear();\n+                    }\n+                });\n+            }\n+            Profiler { label: None, .. } => (),\n+        }\n+    }\n+}\n+\n+fn print(msgs: &[Message], longer_than: Duration, out: &mut impl Write) {\n+    if msgs.is_empty() {\n+        return;\n+    }\n+    let children_map = idx_to_children(msgs);\n+    let root_idx = msgs.len() - 1;\n+    print_for_idx(root_idx, &children_map, msgs, longer_than, out);\n+}\n+\n+fn print_for_idx(\n+    current_idx: usize,\n+    children_map: &[Vec<usize>],\n+    msgs: &[Message],\n+    longer_than: Duration,\n+    out: &mut impl Write,\n+) {\n+    let current = &msgs[current_idx];\n+    let current_indent = \"    \".repeat(current.level);\n+    let detail = current.detail.as_ref().map(|it| format!(\" @ {}\", it)).unwrap_or_default();\n+    writeln!(\n+        out,\n+        \"{}{:5}ms - {}{}\",\n+        current_indent,\n+        current.duration.as_millis(),\n+        current.label,\n+        detail,\n+    )\n+    .expect(\"printing profiling info\");\n+\n+    let longer_than_millis = longer_than.as_millis();\n+    let children_indices = &children_map[current_idx];\n+    let mut accounted_for = Duration::default();\n+    let mut short_children = BTreeMap::new(); // Use `BTreeMap` to get deterministic output.\n+\n+    for child_idx in children_indices.iter() {\n+        let child = &msgs[*child_idx];\n+        if child.duration.as_millis() > longer_than_millis {\n+            print_for_idx(*child_idx, children_map, msgs, longer_than, out);\n+        } else {\n+            let pair = short_children.entry(child.label).or_insert((Duration::default(), 0));\n+            pair.0 += child.duration;\n+            pair.1 += 1;\n+        }\n+        accounted_for += child.duration;\n+    }\n+\n+    for (child_msg, (duration, count)) in short_children.iter() {\n+        let millis = duration.as_millis();\n+        writeln!(out, \"    {}{:5}ms - {} ({} calls)\", current_indent, millis, child_msg, count)\n+            .expect(\"printing profiling info\");\n+    }\n+\n+    let unaccounted_millis = (current.duration - accounted_for).as_millis();\n+    if !children_indices.is_empty()\n+        && unaccounted_millis > 0\n+        && unaccounted_millis > longer_than_millis\n+    {\n+        writeln!(out, \"    {}{:5}ms - ???\", current_indent, unaccounted_millis)\n+            .expect(\"printing profiling info\");\n+    }\n+}\n+\n+/// Returns a mapping from an index in the `msgs` to the vector with the indices of its children.\n+///\n+/// This assumes that the entries in `msgs` are in the order of when the calls to `profile` finish.\n+/// In other words, a postorder of the call graph. In particular, the root is the last element of\n+/// `msgs`.\n+fn idx_to_children(msgs: &[Message]) -> Vec<Vec<usize>> {\n+    // Initialize with the index of the root; `msgs` and `ancestors` should be never empty.\n+    assert!(!msgs.is_empty());\n+    let mut ancestors = vec![msgs.len() - 1];\n+    let mut result: Vec<Vec<usize>> = vec![vec![]; msgs.len()];\n+    for (idx, msg) in msgs[..msgs.len() - 1].iter().enumerate().rev() {\n+        // We need to find the parent of the current message, i.e., the last ancestor that has a\n+        // level lower than the current message.\n+        while msgs[*ancestors.last().unwrap()].level >= msg.level {\n+            ancestors.pop();\n+        }\n+        result[*ancestors.last().unwrap()].push(idx);\n+        ancestors.push(idx);\n+    }\n+    // Note that above we visited all children from the last to the first one. Let's reverse vectors\n+    // to get the more natural order where the first element is the first child.\n+    for vec in result.iter_mut() {\n+        vec.reverse();\n+    }\n+    result\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn test_basic_profile() {\n+        let s = vec![\"profile1\".to_string(), \"profile2\".to_string()];\n+        let f = Filter::new(2, s, Duration::new(0, 0));\n+        set_filter(f);\n+        profiling_function1();\n+    }\n+\n+    fn profiling_function1() {\n+        let _p = profile(\"profile1\");\n+        profiling_function2();\n+    }\n+\n+    fn profiling_function2() {\n+        let _p = profile(\"profile2\");\n+    }\n+\n+    #[test]\n+    fn test_longer_than() {\n+        let mut result = vec![];\n+        let msgs = vec![\n+            Message { level: 1, duration: Duration::from_nanos(3), label: \"bar\", detail: None },\n+            Message { level: 1, duration: Duration::from_nanos(2), label: \"bar\", detail: None },\n+            Message { level: 0, duration: Duration::from_millis(1), label: \"foo\", detail: None },\n+        ];\n+        print(&msgs, Duration::from_millis(0), &mut result);\n+        // The calls to `bar` are so short that they'll be rounded to 0ms and should get collapsed\n+        // when printing.\n+        assert_eq!(\n+            std::str::from_utf8(&result).unwrap(),\n+            \"    1ms - foo\\n        0ms - bar (2 calls)\\n\"\n+        );\n+    }\n+\n+    #[test]\n+    fn test_unaccounted_for_topmost() {\n+        let mut result = vec![];\n+        let msgs = vec![\n+            Message { level: 1, duration: Duration::from_millis(2), label: \"bar\", detail: None },\n+            Message { level: 0, duration: Duration::from_millis(5), label: \"foo\", detail: None },\n+        ];\n+        print(&msgs, Duration::from_millis(0), &mut result);\n+        assert_eq!(\n+            std::str::from_utf8(&result).unwrap().lines().collect::<Vec<_>>(),\n+            vec![\n+                \"    5ms - foo\",\n+                \"        2ms - bar\",\n+                \"        3ms - ???\",\n+                // Dummy comment to improve formatting\n+            ]\n+        );\n+    }\n+\n+    #[test]\n+    fn test_unaccounted_for_multiple_levels() {\n+        let mut result = vec![];\n+        let msgs = vec![\n+            Message { level: 2, duration: Duration::from_millis(3), label: \"baz\", detail: None },\n+            Message { level: 1, duration: Duration::from_millis(5), label: \"bar\", detail: None },\n+            Message { level: 2, duration: Duration::from_millis(2), label: \"baz\", detail: None },\n+            Message { level: 1, duration: Duration::from_millis(4), label: \"bar\", detail: None },\n+            Message { level: 0, duration: Duration::from_millis(9), label: \"foo\", detail: None },\n+        ];\n+        print(&msgs, Duration::from_millis(0), &mut result);\n+        assert_eq!(\n+            std::str::from_utf8(&result).unwrap().lines().collect::<Vec<_>>(),\n+            vec![\n+                \"    9ms - foo\",\n+                \"        5ms - bar\",\n+                \"            3ms - baz\",\n+                \"            2ms - ???\",\n+                \"        4ms - bar\",\n+                \"            2ms - baz\",\n+                \"            2ms - ???\",\n+            ]\n+        );\n+    }\n+}"}, {"sha": "e6d672ef558fc1cd34c5f05b9a57d0ca309c6127", "filename": "crates/ra_prof/src/lib.rs", "status": "modified", "additions": 7, "deletions": 393, "changes": 400, "blob_url": "https://github.com/rust-lang/rust/blob/b3e9f3d143b0fae970449b7c49a2daf6f966a068/crates%2Fra_prof%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3e9f3d143b0fae970449b7c49a2daf6f966a068/crates%2Fra_prof%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_prof%2Fsrc%2Flib.rs?ref=b3e9f3d143b0fae970449b7c49a2daf6f966a068", "patch": "@@ -1,326 +1,23 @@\n-//! FIXME: write short doc here\n+//! A collection of tools for profiling rust-analyzer.\n \n mod memory_usage;\n #[cfg(feature = \"cpu_profiler\")]\n mod google_cpu_profiler;\n+mod hprof;\n \n-use std::{\n-    cell::RefCell,\n-    collections::BTreeMap,\n-    collections::HashSet,\n-    io::{stderr, Write},\n-    sync::{\n-        atomic::{AtomicBool, Ordering},\n-        RwLock,\n-    },\n-    time::{Duration, Instant},\n-};\n-\n-use once_cell::sync::Lazy;\n+use std::cell::RefCell;\n \n-pub use crate::memory_usage::{Bytes, MemoryUsage};\n+pub use crate::{\n+    hprof::{init, init_from, profile},\n+    memory_usage::{Bytes, MemoryUsage},\n+};\n \n // We use jemalloc mainly to get heap usage statistics, actual performance\n // difference is not measures.\n #[cfg(all(feature = \"jemalloc\", not(target_env = \"msvc\")))]\n #[global_allocator]\n static ALLOC: jemallocator::Jemalloc = jemallocator::Jemalloc;\n \n-/// Filtering syntax\n-/// env RA_PROFILE=*             // dump everything\n-/// env RA_PROFILE=foo|bar|baz   // enabled only selected entries\n-/// env RA_PROFILE=*@3>10        // dump everything, up to depth 3, if it takes more than 10 ms\n-pub fn init() {\n-    let spec = std::env::var(\"RA_PROFILE\").unwrap_or_default();\n-    init_from(&spec);\n-}\n-\n-pub fn init_from(spec: &str) {\n-    let filter = if spec.is_empty() { Filter::disabled() } else { Filter::from_spec(spec) };\n-    set_filter(filter);\n-}\n-\n-/// Set profiling filter. It specifies descriptions allowed to profile.\n-/// This is helpful when call stack has too many nested profiling scopes.\n-/// Additionally filter can specify maximum depth of profiling scopes nesting.\n-///\n-/// #Example\n-/// ```\n-/// use ra_prof::{set_filter, Filter};\n-/// let f = Filter::from_spec(\"profile1|profile2@2\");\n-/// set_filter(f);\n-/// ```\n-fn set_filter(f: Filter) {\n-    PROFILING_ENABLED.store(f.depth > 0, Ordering::SeqCst);\n-    let set: HashSet<_> = f.allowed.iter().cloned().collect();\n-    let mut old = FILTER.write().unwrap();\n-    let filter_data = FilterData {\n-        depth: f.depth,\n-        allowed: set,\n-        longer_than: f.longer_than,\n-        version: old.version + 1,\n-    };\n-    *old = filter_data;\n-}\n-\n-pub type Label = &'static str;\n-\n-/// This function starts a profiling scope in the current execution stack with a given description.\n-/// It returns a Profile structure and measure elapsed time between this method invocation and Profile structure drop.\n-/// It supports nested profiling scopes in case when this function invoked multiple times at the execution stack. In this case the profiling information will be nested at the output.\n-/// Profiling information is being printed in the stderr.\n-///\n-/// # Example\n-/// ```\n-/// use ra_prof::{profile, set_filter, Filter};\n-///\n-/// let f = Filter::from_spec(\"profile1|profile2@2\");\n-/// set_filter(f);\n-/// profiling_function1();\n-///\n-/// fn profiling_function1() {\n-///     let _p = profile(\"profile1\");\n-///     profiling_function2();\n-/// }\n-///\n-/// fn profiling_function2() {\n-///     let _p = profile(\"profile2\");\n-/// }\n-/// ```\n-/// This will print in the stderr the following:\n-/// ```text\n-///  0ms - profile\n-///      0ms - profile2\n-/// ```\n-pub fn profile(label: Label) -> Profiler {\n-    assert!(!label.is_empty());\n-    if !PROFILING_ENABLED.load(Ordering::Relaxed) {\n-        return Profiler { label: None, detail: None };\n-    }\n-\n-    PROFILE_STACK.with(|stack| {\n-        let mut stack = stack.borrow_mut();\n-        if stack.starts.is_empty() {\n-            if let Ok(f) = FILTER.try_read() {\n-                if f.version > stack.filter_data.version {\n-                    stack.filter_data = f.clone();\n-                }\n-            };\n-        }\n-        if stack.starts.len() > stack.filter_data.depth {\n-            return Profiler { label: None, detail: None };\n-        }\n-        let allowed = &stack.filter_data.allowed;\n-        if stack.starts.is_empty() && !allowed.is_empty() && !allowed.contains(label) {\n-            return Profiler { label: None, detail: None };\n-        }\n-\n-        stack.starts.push(Instant::now());\n-        Profiler { label: Some(label), detail: None }\n-    })\n-}\n-\n-pub struct Profiler {\n-    label: Option<Label>,\n-    detail: Option<String>,\n-}\n-\n-impl Profiler {\n-    pub fn detail(mut self, detail: impl FnOnce() -> String) -> Profiler {\n-        if self.label.is_some() {\n-            self.detail = Some(detail())\n-        }\n-        self\n-    }\n-}\n-\n-struct Filter {\n-    depth: usize,\n-    allowed: Vec<String>,\n-    longer_than: Duration,\n-}\n-\n-impl Filter {\n-    fn from_spec(mut spec: &str) -> Filter {\n-        let longer_than = if let Some(idx) = spec.rfind('>') {\n-            let longer_than = spec[idx + 1..].parse().expect(\"invalid profile longer_than\");\n-            spec = &spec[..idx];\n-            Duration::from_millis(longer_than)\n-        } else {\n-            Duration::new(0, 0)\n-        };\n-\n-        let depth = if let Some(idx) = spec.rfind('@') {\n-            let depth: usize = spec[idx + 1..].parse().expect(\"invalid profile depth\");\n-            spec = &spec[..idx];\n-            depth\n-        } else {\n-            999\n-        };\n-        let allowed =\n-            if spec == \"*\" { Vec::new() } else { spec.split('|').map(String::from).collect() };\n-        Filter::new(depth, allowed, longer_than)\n-    }\n-\n-    pub fn disabled() -> Filter {\n-        Filter::new(0, Vec::new(), Duration::new(0, 0))\n-    }\n-\n-    pub fn new(depth: usize, allowed: Vec<String>, longer_than: Duration) -> Filter {\n-        Filter { depth, allowed, longer_than }\n-    }\n-}\n-\n-struct ProfileStack {\n-    starts: Vec<Instant>,\n-    messages: Vec<Message>,\n-    filter_data: FilterData,\n-}\n-\n-struct Message {\n-    level: usize,\n-    duration: Duration,\n-    label: Label,\n-    detail: Option<String>,\n-}\n-\n-impl ProfileStack {\n-    fn new() -> ProfileStack {\n-        ProfileStack { starts: Vec::new(), messages: Vec::new(), filter_data: Default::default() }\n-    }\n-}\n-\n-#[derive(Default, Clone)]\n-struct FilterData {\n-    depth: usize,\n-    version: usize,\n-    allowed: HashSet<String>,\n-    longer_than: Duration,\n-}\n-\n-static PROFILING_ENABLED: AtomicBool = AtomicBool::new(false);\n-\n-static FILTER: Lazy<RwLock<FilterData>> = Lazy::new(Default::default);\n-\n-thread_local!(static PROFILE_STACK: RefCell<ProfileStack> = RefCell::new(ProfileStack::new()));\n-\n-impl Drop for Profiler {\n-    fn drop(&mut self) {\n-        match self {\n-            Profiler { label: Some(label), detail } => {\n-                PROFILE_STACK.with(|stack| {\n-                    let mut stack = stack.borrow_mut();\n-                    let start = stack.starts.pop().unwrap();\n-                    let duration = start.elapsed();\n-                    let level = stack.starts.len();\n-                    stack.messages.push(Message { level, duration, label, detail: detail.take() });\n-                    if level == 0 {\n-                        let stdout = stderr();\n-                        let longer_than = stack.filter_data.longer_than;\n-                        // Convert to millis for comparison to avoid problems with rounding\n-                        // (otherwise we could print `0ms` despite user's `>0` filter when\n-                        // `duration` is just a few nanos).\n-                        if duration.as_millis() > longer_than.as_millis() {\n-                            print(&stack.messages, longer_than, &mut stdout.lock());\n-                        }\n-                        stack.messages.clear();\n-                    }\n-                });\n-            }\n-            Profiler { label: None, .. } => (),\n-        }\n-    }\n-}\n-\n-fn print(msgs: &[Message], longer_than: Duration, out: &mut impl Write) {\n-    if msgs.is_empty() {\n-        return;\n-    }\n-    let children_map = idx_to_children(msgs);\n-    let root_idx = msgs.len() - 1;\n-    print_for_idx(root_idx, &children_map, msgs, longer_than, out);\n-}\n-\n-fn print_for_idx(\n-    current_idx: usize,\n-    children_map: &[Vec<usize>],\n-    msgs: &[Message],\n-    longer_than: Duration,\n-    out: &mut impl Write,\n-) {\n-    let current = &msgs[current_idx];\n-    let current_indent = \"    \".repeat(current.level);\n-    let detail = current.detail.as_ref().map(|it| format!(\" @ {}\", it)).unwrap_or_default();\n-    writeln!(\n-        out,\n-        \"{}{:5}ms - {}{}\",\n-        current_indent,\n-        current.duration.as_millis(),\n-        current.label,\n-        detail,\n-    )\n-    .expect(\"printing profiling info\");\n-\n-    let longer_than_millis = longer_than.as_millis();\n-    let children_indices = &children_map[current_idx];\n-    let mut accounted_for = Duration::default();\n-    let mut short_children = BTreeMap::new(); // Use `BTreeMap` to get deterministic output.\n-\n-    for child_idx in children_indices.iter() {\n-        let child = &msgs[*child_idx];\n-        if child.duration.as_millis() > longer_than_millis {\n-            print_for_idx(*child_idx, children_map, msgs, longer_than, out);\n-        } else {\n-            let pair = short_children.entry(child.label).or_insert((Duration::default(), 0));\n-            pair.0 += child.duration;\n-            pair.1 += 1;\n-        }\n-        accounted_for += child.duration;\n-    }\n-\n-    for (child_msg, (duration, count)) in short_children.iter() {\n-        let millis = duration.as_millis();\n-        writeln!(out, \"    {}{:5}ms - {} ({} calls)\", current_indent, millis, child_msg, count)\n-            .expect(\"printing profiling info\");\n-    }\n-\n-    let unaccounted_millis = (current.duration - accounted_for).as_millis();\n-    if !children_indices.is_empty()\n-        && unaccounted_millis > 0\n-        && unaccounted_millis > longer_than_millis\n-    {\n-        writeln!(out, \"    {}{:5}ms - ???\", current_indent, unaccounted_millis)\n-            .expect(\"printing profiling info\");\n-    }\n-}\n-\n-/// Returns a mapping from an index in the `msgs` to the vector with the indices of its children.\n-///\n-/// This assumes that the entries in `msgs` are in the order of when the calls to `profile` finish.\n-/// In other words, a postorder of the call graph. In particular, the root is the last element of\n-/// `msgs`.\n-fn idx_to_children(msgs: &[Message]) -> Vec<Vec<usize>> {\n-    // Initialize with the index of the root; `msgs` and `ancestors` should be never empty.\n-    assert!(!msgs.is_empty());\n-    let mut ancestors = vec![msgs.len() - 1];\n-    let mut result: Vec<Vec<usize>> = vec![vec![]; msgs.len()];\n-    for (idx, msg) in msgs[..msgs.len() - 1].iter().enumerate().rev() {\n-        // We need to find the parent of the current message, i.e., the last ancestor that has a\n-        // level lower than the current message.\n-        while msgs[*ancestors.last().unwrap()].level >= msg.level {\n-            ancestors.pop();\n-        }\n-        result[*ancestors.last().unwrap()].push(idx);\n-        ancestors.push(idx);\n-    }\n-    // Note that above we visited all children from the last to the first one. Let's reverse vectors\n-    // to get the more natural order where the first element is the first child.\n-    for vec in result.iter_mut() {\n-        vec.reverse();\n-    }\n-    result\n-}\n-\n /// Prints backtrace to stderr, useful for debugging.\n #[cfg(feature = \"backtrace\")]\n pub fn print_backtrace() {\n@@ -406,86 +103,3 @@ impl Drop for CpuProfiler {\n pub fn memory_usage() -> MemoryUsage {\n     MemoryUsage::current()\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-\n-    #[test]\n-    fn test_basic_profile() {\n-        let s = vec![\"profile1\".to_string(), \"profile2\".to_string()];\n-        let f = Filter::new(2, s, Duration::new(0, 0));\n-        set_filter(f);\n-        profiling_function1();\n-    }\n-\n-    fn profiling_function1() {\n-        let _p = profile(\"profile1\");\n-        profiling_function2();\n-    }\n-\n-    fn profiling_function2() {\n-        let _p = profile(\"profile2\");\n-    }\n-\n-    #[test]\n-    fn test_longer_than() {\n-        let mut result = vec![];\n-        let msgs = vec![\n-            Message { level: 1, duration: Duration::from_nanos(3), label: \"bar\", detail: None },\n-            Message { level: 1, duration: Duration::from_nanos(2), label: \"bar\", detail: None },\n-            Message { level: 0, duration: Duration::from_millis(1), label: \"foo\", detail: None },\n-        ];\n-        print(&msgs, Duration::from_millis(0), &mut result);\n-        // The calls to `bar` are so short that they'll be rounded to 0ms and should get collapsed\n-        // when printing.\n-        assert_eq!(\n-            std::str::from_utf8(&result).unwrap(),\n-            \"    1ms - foo\\n        0ms - bar (2 calls)\\n\"\n-        );\n-    }\n-\n-    #[test]\n-    fn test_unaccounted_for_topmost() {\n-        let mut result = vec![];\n-        let msgs = vec![\n-            Message { level: 1, duration: Duration::from_millis(2), label: \"bar\", detail: None },\n-            Message { level: 0, duration: Duration::from_millis(5), label: \"foo\", detail: None },\n-        ];\n-        print(&msgs, Duration::from_millis(0), &mut result);\n-        assert_eq!(\n-            std::str::from_utf8(&result).unwrap().lines().collect::<Vec<_>>(),\n-            vec![\n-                \"    5ms - foo\",\n-                \"        2ms - bar\",\n-                \"        3ms - ???\",\n-                // Dummy comment to improve formatting\n-            ]\n-        );\n-    }\n-\n-    #[test]\n-    fn test_unaccounted_for_multiple_levels() {\n-        let mut result = vec![];\n-        let msgs = vec![\n-            Message { level: 2, duration: Duration::from_millis(3), label: \"baz\", detail: None },\n-            Message { level: 1, duration: Duration::from_millis(5), label: \"bar\", detail: None },\n-            Message { level: 2, duration: Duration::from_millis(2), label: \"baz\", detail: None },\n-            Message { level: 1, duration: Duration::from_millis(4), label: \"bar\", detail: None },\n-            Message { level: 0, duration: Duration::from_millis(9), label: \"foo\", detail: None },\n-        ];\n-        print(&msgs, Duration::from_millis(0), &mut result);\n-        assert_eq!(\n-            std::str::from_utf8(&result).unwrap().lines().collect::<Vec<_>>(),\n-            vec![\n-                \"    9ms - foo\",\n-                \"        5ms - bar\",\n-                \"            3ms - baz\",\n-                \"            2ms - ???\",\n-                \"        4ms - bar\",\n-                \"            2ms - baz\",\n-                \"            2ms - ???\",\n-            ]\n-        );\n-    }\n-}"}]}