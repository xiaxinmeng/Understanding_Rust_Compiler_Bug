{"sha": "ce31f68f9e5886959350a85aaad92bc4374c81ab", "node_id": "C_kwDOAAsO6NoAKGNlMzFmNjhmOWU1ODg2OTU5MzUwYTg1YWFhZDkyYmM0Mzc0YzgxYWI", "commit": {"author": {"name": "Jack Huey", "email": "31162821+jackh726@users.noreply.github.com", "date": "2022-01-20T15:18:23Z"}, "committer": {"name": "Jack Huey", "email": "31162821+jackh726@users.noreply.github.com", "date": "2022-01-22T04:13:00Z"}, "message": "Move param count error emission to near end of check_argument_types", "tree": {"sha": "2cf3d127897709e3cea10482750136e9ef8f3e9a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2cf3d127897709e3cea10482750136e9ef8f3e9a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce31f68f9e5886959350a85aaad92bc4374c81ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce31f68f9e5886959350a85aaad92bc4374c81ab", "html_url": "https://github.com/rust-lang/rust/commit/ce31f68f9e5886959350a85aaad92bc4374c81ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce31f68f9e5886959350a85aaad92bc4374c81ab/comments", "author": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "762bdbfce72e2c3b3f81f457f77cd12736ba8a7f", "url": "https://api.github.com/repos/rust-lang/rust/commits/762bdbfce72e2c3b3f81f457f77cd12736ba8a7f", "html_url": "https://github.com/rust-lang/rust/commit/762bdbfce72e2c3b3f81f457f77cd12736ba8a7f"}], "stats": {"total": 270, "additions": 140, "deletions": 130}, "files": [{"sha": "c39199f84b527d210dc90de342cabbe9ba4ed1ab", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 132, "deletions": 129, "changes": 261, "blob_url": "https://github.com/rust-lang/rust/blob/ce31f68f9e5886959350a85aaad92bc4374c81ab/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce31f68f9e5886959350a85aaad92bc4374c81ab/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=ce31f68f9e5886959350a85aaad92bc4374c81ab", "patch": "@@ -127,136 +127,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let expected_arg_count = formal_input_tys.len();\n \n-        let param_count_error = |expected_count: usize,\n-                                 arg_count: usize,\n-                                 error_code: &str,\n-                                 c_variadic: bool,\n-                                 sugg_unit: bool| {\n-            let (span, start_span, args, ctor_of) = match &call_expr.kind {\n-                hir::ExprKind::Call(\n-                    hir::Expr {\n-                        span,\n-                        kind:\n-                            hir::ExprKind::Path(hir::QPath::Resolved(\n-                                _,\n-                                hir::Path { res: Res::Def(DefKind::Ctor(of, _), _), .. },\n-                            )),\n-                        ..\n-                    },\n-                    args,\n-                ) => (*span, *span, &args[..], Some(of)),\n-                hir::ExprKind::Call(hir::Expr { span, .. }, args) => {\n-                    (*span, *span, &args[..], None)\n-                }\n-                hir::ExprKind::MethodCall(path_segment, args, _) => (\n-                    path_segment.ident.span,\n-                    // `sp` doesn't point at the whole `foo.bar()`, only at `bar`.\n-                    path_segment\n-                        .args\n-                        .and_then(|args| args.args.iter().last())\n-                        // Account for `foo.bar::<T>()`.\n-                        .map(|arg| {\n-                            // Skip the closing `>`.\n-                            tcx.sess\n-                                .source_map()\n-                                .next_point(tcx.sess.source_map().next_point(arg.span()))\n-                        })\n-                        .unwrap_or(path_segment.ident.span),\n-                    &args[1..], // Skip the receiver.\n-                    None,       // methods are never ctors\n-                ),\n-                k => span_bug!(call_span, \"checking argument types on a non-call: `{:?}`\", k),\n-            };\n-            let arg_spans = if provided_args.is_empty() {\n-                // foo()\n-                // ^^^-- supplied 0 arguments\n-                // |\n-                // expected 2 arguments\n-                vec![tcx.sess.source_map().next_point(start_span).with_hi(call_span.hi())]\n-            } else {\n-                // foo(1, 2, 3)\n-                // ^^^ -  -  - supplied 3 arguments\n-                // |\n-                // expected 2 arguments\n-                args.iter().map(|arg| arg.span).collect::<Vec<Span>>()\n-            };\n-\n-            let mut err = tcx.sess.struct_span_err_with_code(\n-                span,\n-                &format!(\n-                    \"this {} takes {}{} but {} {} supplied\",\n-                    match ctor_of {\n-                        Some(CtorOf::Struct) => \"struct\",\n-                        Some(CtorOf::Variant) => \"enum variant\",\n-                        None => \"function\",\n-                    },\n-                    if c_variadic { \"at least \" } else { \"\" },\n-                    potentially_plural_count(expected_count, \"argument\"),\n-                    potentially_plural_count(arg_count, \"argument\"),\n-                    if arg_count == 1 { \"was\" } else { \"were\" }\n-                ),\n-                DiagnosticId::Error(error_code.to_owned()),\n-            );\n-            let label = format!(\"supplied {}\", potentially_plural_count(arg_count, \"argument\"));\n-            for (i, span) in arg_spans.into_iter().enumerate() {\n-                err.span_label(\n-                    span,\n-                    if arg_count == 0 || i + 1 == arg_count { &label } else { \"\" },\n-                );\n-            }\n-\n-            if let Some(def_id) = fn_def_id {\n-                if let Some(def_span) = tcx.def_ident_span(def_id) {\n-                    let mut spans: MultiSpan = def_span.into();\n-\n-                    let params = tcx\n-                        .hir()\n-                        .get_if_local(def_id)\n-                        .and_then(|node| node.body_id())\n-                        .into_iter()\n-                        .map(|id| tcx.hir().body(id).params)\n-                        .flatten();\n-\n-                    for param in params {\n-                        spans.push_span_label(param.span, String::new());\n-                    }\n-\n-                    let def_kind = tcx.def_kind(def_id);\n-                    err.span_note(spans, &format!(\"{} defined here\", def_kind.descr(def_id)));\n-                }\n-            }\n-\n-            if sugg_unit {\n-                let sugg_span = tcx.sess.source_map().end_point(call_expr.span);\n-                // remove closing `)` from the span\n-                let sugg_span = sugg_span.shrink_to_lo();\n-                err.span_suggestion(\n-                    sugg_span,\n-                    \"expected the unit value `()`; create it with empty parentheses\",\n-                    String::from(\"()\"),\n-                    Applicability::MachineApplicable,\n-                );\n-            } else {\n-                err.span_label(\n-                    span,\n-                    format!(\n-                        \"expected {}{}\",\n-                        if c_variadic { \"at least \" } else { \"\" },\n-                        potentially_plural_count(expected_count, \"argument\")\n-                    ),\n-                );\n-            }\n-            err.emit();\n-        };\n+        // expected_count, arg_count, error_code, sugg_unit\n+        let mut error: Option<(usize, usize, &str, bool)> = None;\n \n+        // If the arguments should be wrapped in a tuple (ex: closures), unwrap them here\n         let (formal_input_tys, expected_input_tys) = if tuple_arguments == TupleArguments {\n             let tuple_type = self.structurally_resolved_type(call_span, formal_input_tys[0]);\n             match tuple_type.kind() {\n-                ty::Tuple(arg_types) if arg_types.len() != provided_args.len() => {\n-                    param_count_error(arg_types.len(), provided_args.len(), \"E0057\", false, false);\n-                    (self.err_args(provided_args.len()), vec![])\n-                }\n+                // We expected a tuple and got a tuple\n                 ty::Tuple(arg_types) => {\n+                    // Argument length differs\n+                    if arg_types.len() != provided_args.len() {\n+                        error = Some((arg_types.len(), provided_args.len(), \"E0057\", false));\n+                    }\n                     let expected_input_tys = match expected_input_tys.get(0) {\n                         Some(&ty) => match ty.kind() {\n                             ty::Tuple(ref tys) => tys.iter().map(|k| k.expect_ty()).collect(),\n@@ -267,6 +150,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     (arg_types.iter().map(|k| k.expect_ty()).collect(), expected_input_tys)\n                 }\n                 _ => {\n+                    // Otherwise, there's a mismatch, so clear out what we're expecting, and set\n+                    // our input typs to err_args so we don't blow up the error messages\n                     struct_span_err!(\n                         tcx.sess,\n                         call_span,\n@@ -284,7 +169,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             if supplied_arg_count >= expected_arg_count {\n                 (formal_input_tys.to_vec(), expected_input_tys)\n             } else {\n-                param_count_error(expected_arg_count, supplied_arg_count, \"E0060\", true, false);\n+                error = Some((expected_arg_count, supplied_arg_count, \"E0060\", false));\n                 (self.err_args(supplied_arg_count), vec![])\n             }\n         } else {\n@@ -296,8 +181,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             } else {\n                 false\n             };\n-            param_count_error(expected_arg_count, supplied_arg_count, \"E0061\", false, sugg_unit);\n-\n+            error = Some((expected_arg_count, supplied_arg_count, \"E0061\", sugg_unit));\n             (self.err_args(supplied_arg_count), vec![])\n         };\n \n@@ -348,7 +232,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // argument and not the call. This is otherwise redundant with the `demand_coerce`\n             // call immediately after, but it lets us customize the span pointed to in the\n             // fulfillment error to be more accurate.\n-            let _ =\n+            let coerced_ty =\n                 self.resolve_vars_with_obligations_and_mutate_fulfillment(coerced_ty, |errors| {\n                     self.point_at_type_arg_instead_of_call_if_possible(errors, call_expr);\n                     self.point_at_arg_instead_of_call_if_possible(\n@@ -360,6 +244,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     );\n                 });\n \n+            final_arg_types[idx] = Some((checked_ty, coerced_ty));\n+\n             // We're processing function arguments so we definitely want to use\n             // two-phase borrows.\n             self.demand_coerce(&provided_arg, checked_ty, coerced_ty, None, AllowTwoPhase::Yes);\n@@ -418,6 +304,123 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         }\n \n+        // If there was an error in parameter count, emit that here\n+        if let Some((expected_count, arg_count, err_code, sugg_unit)) = error {\n+            let (span, start_span, args, ctor_of) = match &call_expr.kind {\n+                hir::ExprKind::Call(\n+                    hir::Expr {\n+                        span,\n+                        kind:\n+                            hir::ExprKind::Path(hir::QPath::Resolved(\n+                                _,\n+                                hir::Path { res: Res::Def(DefKind::Ctor(of, _), _), .. },\n+                            )),\n+                        ..\n+                    },\n+                    args,\n+                ) => (*span, *span, &args[..], Some(of)),\n+                hir::ExprKind::Call(hir::Expr { span, .. }, args) => {\n+                    (*span, *span, &args[..], None)\n+                }\n+                hir::ExprKind::MethodCall(path_segment, args, _) => (\n+                    path_segment.ident.span,\n+                    // `sp` doesn't point at the whole `foo.bar()`, only at `bar`.\n+                    path_segment\n+                        .args\n+                        .and_then(|args| args.args.iter().last())\n+                        // Account for `foo.bar::<T>()`.\n+                        .map(|arg| {\n+                            // Skip the closing `>`.\n+                            tcx.sess\n+                                .source_map()\n+                                .next_point(tcx.sess.source_map().next_point(arg.span()))\n+                        })\n+                        .unwrap_or(path_segment.ident.span),\n+                    &args[1..], // Skip the receiver.\n+                    None,       // methods are never ctors\n+                ),\n+                k => span_bug!(call_span, \"checking argument types on a non-call: `{:?}`\", k),\n+            };\n+            let arg_spans = if provided_args.is_empty() {\n+                // foo()\n+                // ^^^-- supplied 0 arguments\n+                // |\n+                // expected 2 arguments\n+                vec![tcx.sess.source_map().next_point(start_span).with_hi(call_span.hi())]\n+            } else {\n+                // foo(1, 2, 3)\n+                // ^^^ -  -  - supplied 3 arguments\n+                // |\n+                // expected 2 arguments\n+                args.iter().map(|arg| arg.span).collect::<Vec<Span>>()\n+            };\n+            let call_name = match ctor_of {\n+                Some(CtorOf::Struct) => \"struct\",\n+                Some(CtorOf::Variant) => \"enum variant\",\n+                None => \"function\",\n+            };\n+            let mut err = tcx.sess.struct_span_err_with_code(\n+                span,\n+                &format!(\n+                    \"this {} takes {}{} but {} {} supplied\",\n+                    call_name,\n+                    if c_variadic { \"at least \" } else { \"\" },\n+                    potentially_plural_count(expected_count, \"argument\"),\n+                    potentially_plural_count(arg_count, \"argument\"),\n+                    if arg_count == 1 { \"was\" } else { \"were\" }\n+                ),\n+                DiagnosticId::Error(err_code.to_owned()),\n+            );\n+            let label = format!(\"supplied {}\", potentially_plural_count(arg_count, \"argument\"));\n+            for (i, span) in arg_spans.into_iter().enumerate() {\n+                err.span_label(\n+                    span,\n+                    if arg_count == 0 || i + 1 == arg_count { &label } else { \"\" },\n+                );\n+            }\n+            if let Some(def_id) = fn_def_id {\n+                if let Some(def_span) = tcx.def_ident_span(def_id) {\n+                    let mut spans: MultiSpan = def_span.into();\n+\n+                    let params = tcx\n+                        .hir()\n+                        .get_if_local(def_id)\n+                        .and_then(|node| node.body_id())\n+                        .into_iter()\n+                        .map(|id| tcx.hir().body(id).params)\n+                        .flatten();\n+\n+                    for param in params {\n+                        spans.push_span_label(param.span, String::new());\n+                    }\n+\n+                    let def_kind = tcx.def_kind(def_id);\n+                    err.span_note(spans, &format!(\"{} defined here\", def_kind.descr(def_id)));\n+                }\n+            }\n+            if sugg_unit {\n+                let sugg_span = tcx.sess.source_map().end_point(call_expr.span);\n+                // remove closing `)` from the span\n+                let sugg_span = sugg_span.shrink_to_lo();\n+                err.span_suggestion(\n+                    sugg_span,\n+                    \"expected the unit value `()`; create it with empty parentheses\",\n+                    String::from(\"()\"),\n+                    Applicability::MachineApplicable,\n+                );\n+            } else {\n+                err.span_label(\n+                    span,\n+                    format!(\n+                        \"expected {}{}\",\n+                        if c_variadic { \"at least \" } else { \"\" },\n+                        potentially_plural_count(expected_count, \"argument\")\n+                    ),\n+                );\n+            }\n+            err.emit();\n+        }\n+\n         // We also need to make sure we at least write the ty of the other\n         // arguments which we skipped above.\n         if c_variadic {"}, {"sha": "d62625faaaa083b1bf6a907ecfb645c72768c263", "filename": "src/test/ui/mismatched_types/overloaded-calls-bad.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ce31f68f9e5886959350a85aaad92bc4374c81ab/src%2Ftest%2Fui%2Fmismatched_types%2Foverloaded-calls-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce31f68f9e5886959350a85aaad92bc4374c81ab/src%2Ftest%2Fui%2Fmismatched_types%2Foverloaded-calls-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Foverloaded-calls-bad.rs?ref=ce31f68f9e5886959350a85aaad92bc4374c81ab", "patch": "@@ -30,4 +30,5 @@ fn main() {\n     //~^ ERROR this function takes 1 argument but 0 arguments were supplied\n     let ans = s(\"burma\", \"shave\");\n     //~^ ERROR this function takes 1 argument but 2 arguments were supplied\n+    //~| ERROR mismatched types\n }"}, {"sha": "9ae9c474162d94c4c221b4b312260253a781af40", "filename": "src/test/ui/mismatched_types/overloaded-calls-bad.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ce31f68f9e5886959350a85aaad92bc4374c81ab/src%2Ftest%2Fui%2Fmismatched_types%2Foverloaded-calls-bad.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ce31f68f9e5886959350a85aaad92bc4374c81ab/src%2Ftest%2Fui%2Fmismatched_types%2Foverloaded-calls-bad.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Foverloaded-calls-bad.stderr?ref=ce31f68f9e5886959350a85aaad92bc4374c81ab", "patch": "@@ -18,6 +18,12 @@ note: associated function defined here\n LL |     extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n    |                           ^^^^^^^^\n \n+error[E0308]: mismatched types\n+  --> $DIR/overloaded-calls-bad.rs:31:17\n+   |\n+LL |     let ans = s(\"burma\", \"shave\");\n+   |                 ^^^^^^^ expected `isize`, found `&str`\n+\n error[E0057]: this function takes 1 argument but 2 arguments were supplied\n   --> $DIR/overloaded-calls-bad.rs:31:15\n    |\n@@ -32,7 +38,7 @@ note: associated function defined here\n LL |     extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n    |                           ^^^^^^^^\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 4 previous errors\n \n Some errors have detailed explanations: E0057, E0308.\n For more information about an error, try `rustc --explain E0057`."}]}