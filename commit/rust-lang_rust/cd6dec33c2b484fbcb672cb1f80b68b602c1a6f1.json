{"sha": "cd6dec33c2b484fbcb672cb1f80b68b602c1a6f1", "node_id": "C_kwDOAAsO6NoAKGNkNmRlYzMzYzJiNDg0ZmJjYjY3MmNiMWY4MGI2OGI2MDJjMWE2ZjE", "commit": {"author": {"name": "Le\u00f3n Orell Valerian Liehr", "email": "me@fmease.dev", "date": "2023-04-21T20:02:41Z"}, "committer": {"name": "Le\u00f3n Orell Valerian Liehr", "email": "me@fmease.dev", "date": "2023-05-04T15:00:33Z"}, "message": "IAT: Proper WF computation", "tree": {"sha": "9889fbdc3d84f96d16afbf3bca11d4f145a214c9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9889fbdc3d84f96d16afbf3bca11d4f145a214c9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cd6dec33c2b484fbcb672cb1f80b68b602c1a6f1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEXSQFaHGAjVoD5I3F0XoHIV9o5xMFAmRTyJIACgkQ0XoHIV9o\n5xN54Q//RTcPhbeDY+CchqtQmHPwASVobP1A82RU9B4kOls2wFYC0pUwao+ea033\nPDpNRiWJ+/eHLJV6z11R4qczHp6nZ/uDJm0cKNEbr3bVOHY6crtXvdo6kNLa+Oni\nqjsyj02QisimPANwjhcszNsiQhLGDrI8ezqVIYvCqgQBMv1ka45YQPZCw+NE5fWd\n83VXbjrZj6k/IC/mWGposzLuNI0lExh4qWULXoWuel6ZrPuFf7aHbH6CA3EwXq7J\nSjqaVUSgvmx1TsNBpukExAvTzbg/sUoryS/CBh+fQsrxVQXe48ediV4sloN5qY5T\n9NMFTnTdChTNOMl/KFTA7wEcoHexrfTmcz4vH6tD4zlbJXebzLIIgpGaeudbwZDc\nwpjUhwWoluPv56iKM8p9YGMRsv6woF3U2Av0wStKVSmr4Q2x2EONlRfQ94PYB+xR\nbGiI7rXzdd6ZS9zOT3uynZ5maD6VrQelD50RNYhylBkuJu8fzxXZ08gk23djnstc\n++vpvm/HntpfFocMNxzrwQzMQSFhGBWhwwPro3gIuuagryVgtRZjyJqHKx3SELYY\nREjIefKpgoqF4T+d/g2hYb0TMawve5Fk1JHe7kFdCwvIQyfekUtMjTxxGfrGMynR\nv1dhPe05hPMBtUIN0yc0Comb7SLdO55L8hxFKoNlq58MJpLEUN4=\n=+t4o\n-----END PGP SIGNATURE-----", "payload": "tree 9889fbdc3d84f96d16afbf3bca11d4f145a214c9\nparent 61e1eda6db042413cf1794407fd10b7edc90059d\nauthor Le\u00f3n Orell Valerian Liehr <me@fmease.dev> 1682107361 +0200\ncommitter Le\u00f3n Orell Valerian Liehr <me@fmease.dev> 1683212433 +0200\n\nIAT: Proper WF computation\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cd6dec33c2b484fbcb672cb1f80b68b602c1a6f1", "html_url": "https://github.com/rust-lang/rust/commit/cd6dec33c2b484fbcb672cb1f80b68b602c1a6f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cd6dec33c2b484fbcb672cb1f80b68b602c1a6f1/comments", "author": {"login": "fmease", "id": 14913065, "node_id": "MDQ6VXNlcjE0OTEzMDY1", "avatar_url": "https://avatars.githubusercontent.com/u/14913065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fmease", "html_url": "https://github.com/fmease", "followers_url": "https://api.github.com/users/fmease/followers", "following_url": "https://api.github.com/users/fmease/following{/other_user}", "gists_url": "https://api.github.com/users/fmease/gists{/gist_id}", "starred_url": "https://api.github.com/users/fmease/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fmease/subscriptions", "organizations_url": "https://api.github.com/users/fmease/orgs", "repos_url": "https://api.github.com/users/fmease/repos", "events_url": "https://api.github.com/users/fmease/events{/privacy}", "received_events_url": "https://api.github.com/users/fmease/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fmease", "id": 14913065, "node_id": "MDQ6VXNlcjE0OTEzMDY1", "avatar_url": "https://avatars.githubusercontent.com/u/14913065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fmease", "html_url": "https://github.com/fmease", "followers_url": "https://api.github.com/users/fmease/followers", "following_url": "https://api.github.com/users/fmease/following{/other_user}", "gists_url": "https://api.github.com/users/fmease/gists{/gist_id}", "starred_url": "https://api.github.com/users/fmease/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fmease/subscriptions", "organizations_url": "https://api.github.com/users/fmease/orgs", "repos_url": "https://api.github.com/users/fmease/repos", "events_url": "https://api.github.com/users/fmease/events{/privacy}", "received_events_url": "https://api.github.com/users/fmease/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "61e1eda6db042413cf1794407fd10b7edc90059d", "url": "https://api.github.com/repos/rust-lang/rust/commits/61e1eda6db042413cf1794407fd10b7edc90059d", "html_url": "https://github.com/rust-lang/rust/commit/61e1eda6db042413cf1794407fd10b7edc90059d"}], "stats": {"total": 153, "additions": 99, "deletions": 54}, "files": [{"sha": "8e684b7ac239b38ee3697a474ba605254af8e906", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 43, "deletions": 23, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/cd6dec33c2b484fbcb672cb1f80b68b602c1a6f1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6dec33c2b484fbcb672cb1f80b68b602c1a6f1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=cd6dec33c2b484fbcb672cb1f80b68b602c1a6f1", "patch": "@@ -1274,29 +1274,14 @@ pub fn normalize_inherent_projection<'a, 'b, 'tcx>(\n         });\n     }\n \n-    let impl_def_id = tcx.parent(alias_ty.def_id);\n-    let impl_substs = selcx.infcx.fresh_substs_for_item(cause.span, impl_def_id);\n-\n-    let impl_ty = tcx.type_of(impl_def_id).subst(tcx, impl_substs);\n-    let impl_ty =\n-        normalize_with_depth_to(selcx, param_env, cause.clone(), depth + 1, impl_ty, obligations);\n-\n-    // Infer the generic parameters of the impl by unifying the\n-    // impl type with the self type of the projection.\n-    let self_ty = alias_ty.self_ty();\n-    match selcx.infcx.at(&cause, param_env).eq(DefineOpaqueTypes::No, impl_ty, self_ty) {\n-        Ok(mut ok) => obligations.append(&mut ok.obligations),\n-        Err(_) => {\n-            tcx.sess.delay_span_bug(\n-                cause.span,\n-                format!(\n-                    \"{self_ty:?} was a subtype of {impl_ty:?} during selection but now it is not\"\n-                ),\n-            );\n-        }\n-    }\n-\n-    let substs = alias_ty.rebase_substs_onto_impl(impl_substs, tcx);\n+    let substs = compute_inherent_assoc_ty_substs(\n+        selcx,\n+        param_env,\n+        alias_ty,\n+        cause.clone(),\n+        depth,\n+        obligations,\n+    );\n \n     // Register the obligations arising from the impl and from the associated type itself.\n     let predicates = tcx.predicates_of(alias_ty.def_id).instantiate(tcx, substs);\n@@ -1343,6 +1328,41 @@ pub fn normalize_inherent_projection<'a, 'b, 'tcx>(\n     ty\n }\n \n+pub fn compute_inherent_assoc_ty_substs<'a, 'b, 'tcx>(\n+    selcx: &'a mut SelectionContext<'b, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    alias_ty: ty::AliasTy<'tcx>,\n+    cause: ObligationCause<'tcx>,\n+    depth: usize,\n+    obligations: &mut Vec<PredicateObligation<'tcx>>,\n+) -> ty::SubstsRef<'tcx> {\n+    let tcx = selcx.tcx();\n+\n+    let impl_def_id = tcx.parent(alias_ty.def_id);\n+    let impl_substs = selcx.infcx.fresh_substs_for_item(cause.span, impl_def_id);\n+\n+    let impl_ty = tcx.type_of(impl_def_id).subst(tcx, impl_substs);\n+    let impl_ty =\n+        normalize_with_depth_to(selcx, param_env, cause.clone(), depth + 1, impl_ty, obligations);\n+\n+    // Infer the generic parameters of the impl by unifying the\n+    // impl type with the self type of the projection.\n+    let self_ty = alias_ty.self_ty();\n+    match selcx.infcx.at(&cause, param_env).eq(DefineOpaqueTypes::No, impl_ty, self_ty) {\n+        Ok(mut ok) => obligations.append(&mut ok.obligations),\n+        Err(_) => {\n+            tcx.sess.delay_span_bug(\n+                cause.span,\n+                format!(\n+                    \"{self_ty:?} was a subtype of {impl_ty:?} during selection but now it is not\"\n+                ),\n+            );\n+        }\n+    }\n+\n+    alias_ty.rebase_substs_onto_impl(impl_substs, tcx)\n+}\n+\n enum Projected<'tcx> {\n     Progress(Progress<'tcx>),\n     NoProgress(ty::Term<'tcx>),"}, {"sha": "086ab32b520076946de1e1efcd46cff83e66f8d8", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 56, "deletions": 31, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/cd6dec33c2b484fbcb672cb1f80b68b602c1a6f1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6dec33c2b484fbcb672cb1f80b68b602c1a6f1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=cd6dec33c2b484fbcb672cb1f80b68b602c1a6f1", "patch": "@@ -58,15 +58,8 @@ pub fn obligations<'tcx>(\n         GenericArgKind::Lifetime(..) => return Some(Vec::new()),\n     };\n \n-    let mut wf = WfPredicates {\n-        tcx: infcx.tcx,\n-        param_env,\n-        body_id,\n-        span,\n-        out: vec![],\n-        recursion_depth,\n-        item: None,\n-    };\n+    let mut wf =\n+        WfPredicates { infcx, param_env, body_id, span, out: vec![], recursion_depth, item: None };\n     wf.compute(arg);\n     debug!(\"wf::obligations({:?}, body_id={:?}) = {:?}\", arg, body_id, wf.out);\n \n@@ -91,7 +84,7 @@ pub fn unnormalized_obligations<'tcx>(\n     debug_assert_eq!(arg, infcx.resolve_vars_if_possible(arg));\n \n     let mut wf = WfPredicates {\n-        tcx: infcx.tcx,\n+        infcx,\n         param_env,\n         body_id: CRATE_DEF_ID,\n         span: DUMMY_SP,\n@@ -116,7 +109,7 @@ pub fn trait_obligations<'tcx>(\n     item: &'tcx hir::Item<'tcx>,\n ) -> Vec<traits::PredicateObligation<'tcx>> {\n     let mut wf = WfPredicates {\n-        tcx: infcx.tcx,\n+        infcx,\n         param_env,\n         body_id,\n         span,\n@@ -138,7 +131,7 @@ pub fn predicate_obligations<'tcx>(\n     span: Span,\n ) -> Vec<traits::PredicateObligation<'tcx>> {\n     let mut wf = WfPredicates {\n-        tcx: infcx.tcx,\n+        infcx,\n         param_env,\n         body_id,\n         span,\n@@ -190,8 +183,8 @@ pub fn predicate_obligations<'tcx>(\n     wf.normalize(infcx)\n }\n \n-struct WfPredicates<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n+struct WfPredicates<'a, 'tcx> {\n+    infcx: &'a InferCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     body_id: LocalDefId,\n     span: Span,\n@@ -290,9 +283,9 @@ fn extend_cause_with_original_assoc_item_obligation<'tcx>(\n     }\n }\n \n-impl<'tcx> WfPredicates<'tcx> {\n+impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n     fn tcx(&self) -> TyCtxt<'tcx> {\n-        self.tcx\n+        self.infcx.tcx\n     }\n \n     fn cause(&self, code: traits::ObligationCauseCode<'tcx>) -> traits::ObligationCause<'tcx> {\n@@ -325,7 +318,7 @@ impl<'tcx> WfPredicates<'tcx> {\n \n     /// Pushes the obligations required for `trait_ref` to be WF into `self.out`.\n     fn compute_trait_pred(&mut self, trait_pred: &ty::TraitPredicate<'tcx>, elaborate: Elaborate) {\n-        let tcx = self.tcx;\n+        let tcx = self.tcx();\n         let trait_ref = &trait_pred.trait_ref;\n \n         // Negative trait predicates don't require supertraits to hold, just\n@@ -369,7 +362,6 @@ impl<'tcx> WfPredicates<'tcx> {\n             self.out.extend(obligations);\n         }\n \n-        let tcx = self.tcx();\n         self.out.extend(\n             trait_ref\n                 .substs\n@@ -436,13 +428,45 @@ impl<'tcx> WfPredicates<'tcx> {\n         let obligations = self.nominal_obligations_without_const(data.def_id, data.substs);\n         self.out.extend(obligations);\n \n+        self.compute_projection_substs(data.substs);\n+    }\n+\n+    fn compute_inherent_projection(&mut self, data: ty::AliasTy<'tcx>) {\n+        // An inherent projection is well-formed if\n+        //\n+        // (a) its predicates hold (*)\n+        // (b) its substs are wf\n+        //\n+        // (*) The predicates of an inherent associated type include the\n+        //     predicates of the impl that it's contained in.\n+\n+        if !data.self_ty().has_escaping_bound_vars() {\n+            // FIXME(inherent_associated_types): Should this happen inside of a snapshot?\n+            // FIXME(inherent_associated_types): This is incompatible with the new solver and lazy norm!\n+            let substs = traits::project::compute_inherent_assoc_ty_substs(\n+                &mut traits::SelectionContext::new(self.infcx),\n+                self.param_env,\n+                data,\n+                self.cause(traits::WellFormed(None)),\n+                self.recursion_depth,\n+                &mut self.out,\n+            );\n+            // Inherent projection types do not require const predicates.\n+            let obligations = self.nominal_obligations_without_const(data.def_id, substs);\n+            self.out.extend(obligations);\n+        }\n+\n+        self.compute_projection_substs(data.substs);\n+    }\n+\n+    fn compute_projection_substs(&mut self, substs: SubstsRef<'tcx>) {\n         let tcx = self.tcx();\n         let cause = self.cause(traits::WellFormed(None));\n         let param_env = self.param_env;\n         let depth = self.recursion_depth;\n \n         self.out.extend(\n-            data.substs\n+            substs\n                 .iter()\n                 .filter(|arg| {\n                     matches!(arg.unpack(), GenericArgKind::Type(..) | GenericArgKind::Const(..))\n@@ -464,9 +488,9 @@ impl<'tcx> WfPredicates<'tcx> {\n         if !subty.has_escaping_bound_vars() {\n             let cause = self.cause(cause);\n             let trait_ref =\n-                ty::TraitRef::from_lang_item(self.tcx, LangItem::Sized, cause.span, [subty]);\n+                ty::TraitRef::from_lang_item(self.tcx(), LangItem::Sized, cause.span, [subty]);\n             self.out.push(traits::Obligation::with_depth(\n-                self.tcx,\n+                self.tcx(),\n                 cause,\n                 self.recursion_depth,\n                 self.param_env,\n@@ -605,8 +629,9 @@ impl<'tcx> WfPredicates<'tcx> {\n                     walker.skip_current_subtree(); // Subtree handled by compute_projection.\n                     self.compute_projection(data);\n                 }\n-                ty::Alias(ty::Inherent, _) => {\n-                    // WF if their substs are WF.\n+                ty::Alias(ty::Inherent, data) => {\n+                    walker.skip_current_subtree(); // Subtree handled by compute_inherent_projection.\n+                    self.compute_inherent_projection(data);\n                 }\n \n                 ty::Adt(def, substs) => {\n@@ -700,7 +725,7 @@ impl<'tcx> WfPredicates<'tcx> {\n                     // All of the requirements on type parameters\n                     // have already been checked for `impl Trait` in\n                     // return position. We do need to check type-alias-impl-trait though.\n-                    if self.tcx.is_type_alias_impl_trait(def_id) {\n+                    if self.tcx().is_type_alias_impl_trait(def_id) {\n                         let obligations = self.nominal_obligations(def_id, substs);\n                         self.out.extend(obligations);\n                     }\n@@ -770,15 +795,15 @@ impl<'tcx> WfPredicates<'tcx> {\n         substs: SubstsRef<'tcx>,\n         remap_constness: bool,\n     ) -> Vec<traits::PredicateObligation<'tcx>> {\n-        let predicates = self.tcx.predicates_of(def_id);\n+        let predicates = self.tcx().predicates_of(def_id);\n         let mut origins = vec![def_id; predicates.predicates.len()];\n         let mut head = predicates;\n         while let Some(parent) = head.parent {\n-            head = self.tcx.predicates_of(parent);\n+            head = self.tcx().predicates_of(parent);\n             origins.extend(iter::repeat(parent).take(head.predicates.len()));\n         }\n \n-        let predicates = predicates.instantiate(self.tcx, substs);\n+        let predicates = predicates.instantiate(self.tcx(), substs);\n         trace!(\"{:#?}\", predicates);\n         debug_assert_eq!(predicates.predicates.len(), origins.len());\n \n@@ -791,10 +816,10 @@ impl<'tcx> WfPredicates<'tcx> {\n                 };\n                 let cause = self.cause(code);\n                 if remap_constness {\n-                    pred = pred.without_const(self.tcx);\n+                    pred = pred.without_const(self.tcx());\n                 }\n                 traits::Obligation::with_depth(\n-                    self.tcx,\n+                    self.tcx(),\n                     cause,\n                     self.recursion_depth,\n                     self.param_env,\n@@ -859,7 +884,7 @@ impl<'tcx> WfPredicates<'tcx> {\n         // Note: in fact we only permit builtin traits, not `Bar<'d>`, I\n         // am looking forward to the future here.\n         if !data.has_escaping_bound_vars() && !region.has_escaping_bound_vars() {\n-            let implicit_bounds = object_region_bounds(self.tcx, data);\n+            let implicit_bounds = object_region_bounds(self.tcx(), data);\n \n             let explicit_bound = region;\n \n@@ -869,7 +894,7 @@ impl<'tcx> WfPredicates<'tcx> {\n                 let outlives =\n                     ty::Binder::dummy(ty::OutlivesPredicate(explicit_bound, implicit_bound));\n                 self.out.push(traits::Obligation::with_depth(\n-                    self.tcx,\n+                    self.tcx(),\n                     cause,\n                     self.recursion_depth,\n                     self.param_env,"}]}