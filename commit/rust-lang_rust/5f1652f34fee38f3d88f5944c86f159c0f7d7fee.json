{"sha": "5f1652f34fee38f3d88f5944c86f159c0f7d7fee", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmMTY1MmYzNGZlZTM4ZjNkODhmNTk0NGM4NmYxNTljMGY3ZDdmZWU=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-02-26T15:43:53Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-02-27T04:48:11Z"}, "message": "libsyntax: remove vecs_implicitly_copyable from the printer", "tree": {"sha": "8fc2b31a43f7f7bdd9f837ddebece5de1f9f2850", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8fc2b31a43f7f7bdd9f837ddebece5de1f9f2850"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f1652f34fee38f3d88f5944c86f159c0f7d7fee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f1652f34fee38f3d88f5944c86f159c0f7d7fee", "html_url": "https://github.com/rust-lang/rust/commit/5f1652f34fee38f3d88f5944c86f159c0f7d7fee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f1652f34fee38f3d88f5944c86f159c0f7d7fee/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4ae91e2961ac7be50a346a6b0d724601878a9cd0", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ae91e2961ac7be50a346a6b0d724601878a9cd0", "html_url": "https://github.com/rust-lang/rust/commit/4ae91e2961ac7be50a346a6b0d724601878a9cd0"}], "stats": {"total": 51, "additions": 26, "deletions": 25}, "files": [{"sha": "1dc45b1a4bd9a9573aa8164fbe2b2f0d1cd498a3", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5f1652f34fee38f3d88f5944c86f159c0f7d7fee/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f1652f34fee38f3d88f5944c86f159c0f7d7fee/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=5f1652f34fee38f3d88f5944c86f159c0f7d7fee", "patch": "@@ -568,15 +568,15 @@ pub fn end(p: @mut Printer) { p.pretty_print(END); }\n pub fn eof(p: @mut Printer) { p.pretty_print(EOF); }\n \n pub fn word(p: @mut Printer, wrd: ~str) {\n-    p.pretty_print(STRING(@wrd, str::len(wrd) as int));\n+    p.pretty_print(STRING(@/*bad*/ copy wrd, wrd.len() as int));\n }\n \n pub fn huge_word(p: @mut Printer, wrd: ~str) {\n-    p.pretty_print(STRING(@wrd, size_infinity));\n+    p.pretty_print(STRING(@/*bad*/ copy wrd, size_infinity));\n }\n \n pub fn zero_word(p: @mut Printer, wrd: ~str) {\n-    p.pretty_print(STRING(@wrd, 0));\n+    p.pretty_print(STRING(@/*bad*/ copy wrd, 0));\n }\n \n pub fn spaces(p: @mut Printer, n: uint) { break_offset(p, n, 0); }"}, {"sha": "e98629a46a528a8a6655a9dff7cb221ea0c8b739", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/5f1652f34fee38f3d88f5944c86f159c0f7d7fee/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f1652f34fee38f3d88f5944c86f159c0f7d7fee/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=5f1652f34fee38f3d88f5944c86f159c0f7d7fee", "patch": "@@ -108,18 +108,20 @@ pub fn print_crate(cm: @CodeMap, intr: @ident_interner,\n                    span_diagnostic: diagnostic::span_handler,\n                    crate: @ast::crate, filename: ~str, in: io::Reader,\n                    out: io::Writer, ann: pp_ann, is_expanded: bool) {\n-    let (cmnts, lits) =\n-        comments::gather_comments_and_literals(span_diagnostic,\n-                                               filename, in);\n+    let (cmnts, lits) = comments::gather_comments_and_literals(\n+        span_diagnostic,\n+        copy filename,\n+        in\n+    );\n     let s = @ps {\n         s: pp::mk_printer(out, default_columns),\n         cm: Some(cm),\n         intr: intr,\n-        comments: Some(cmnts),\n+        comments: Some(copy cmnts),\n         // If the code is post expansion, don't use the table of\n         // literals, since it doesn't correspond with the literals\n         // in the AST anymore.\n-        literals: if is_expanded { None } else { Some(lits) },\n+        literals: if is_expanded { None } else { Some(copy lits) },\n         cur_cmnt_and_lit: @mut CurrentCommentAndLiteral {\n             cur_cmnt: 0,\n             cur_lit: 0\n@@ -378,7 +380,7 @@ pub fn print_type(s: @ps, &&ty: @ast::Ty) {\n pub fn print_type_ex(s: @ps, &&ty: @ast::Ty, print_colons: bool) {\n     maybe_print_comment(s, ty.span.lo);\n     ibox(s, 0u);\n-    match ty.node {\n+    match /*bad*/ copy ty.node {\n       ast::ty_nil => word(s.s, ~\"()\"),\n       ast::ty_bot => word(s.s, ~\"!\"),\n       ast::ty_box(mt) => { word(s.s, ~\"@\"); print_mt(s, mt); }\n@@ -458,7 +460,7 @@ pub fn print_foreign_item(s: @ps, item: @ast::foreign_item) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, item.span.lo);\n     print_outer_attributes(s, item.attrs);\n-    match item.node {\n+    match /*bad*/ copy item.node {\n       ast::foreign_item_fn(decl, purity, typarams) => {\n         print_fn(s, decl, Some(purity), item.ident, typarams, None,\n                  ast::inherited);\n@@ -484,7 +486,7 @@ pub fn print_item(s: @ps, &&item: @ast::item) {\n     print_outer_attributes(s, item.attrs);\n     let ann_node = node_item(s, item);\n     (s.ann.pre)(ann_node);\n-    match item.node {\n+    match /*bad*/ copy item.node {\n       ast::item_const(ty, expr) => {\n         head(s, visibility_qualified(item.vis, ~\"const\"));\n         print_ident(s, item.ident);\n@@ -652,7 +654,7 @@ pub fn print_enum_def(s: @ps, enum_definition: ast::enum_def,\n     space(s.s);\n     if newtype {\n         word_space(s, ~\"=\");\n-        match enum_definition.variants[0].node.kind {\n+        match /*bad*/ copy enum_definition.variants[0].node.kind {\n             ast::tuple_variant_kind(args) => print_type(s, args[0].ty),\n             _ => fail!(~\"newtype syntax with struct?\")\n         }\n@@ -690,9 +692,8 @@ pub fn visibility_to_str(vis: ast::visibility) -> ~str {\n \n pub fn visibility_qualified(vis: ast::visibility, s: ~str) -> ~str {\n     match vis {\n-        ast::private | ast::public =>\n-        visibility_to_str(vis) + \" \" + s,\n-        ast::inherited => s\n+        ast::private | ast::public => visibility_to_str(vis) + \" \" + s,\n+        ast::inherited => copy s\n     }\n }\n \n@@ -809,7 +810,7 @@ pub fn print_tts(s: @ps, &&tts: &[ast::token_tree]) {\n \n pub fn print_variant(s: @ps, v: ast::variant) {\n     print_visibility(s, v.node.vis);\n-    match v.node.kind {\n+    match /*bad*/ copy v.node.kind {\n         ast::tuple_variant_kind(args) => {\n             print_ident(s, v.node.name);\n             if !args.is_empty() {\n@@ -844,8 +845,8 @@ pub fn print_ty_method(s: @ps, m: &ast::ty_method) {\n     maybe_print_comment(s, m.span.lo);\n     print_outer_attributes(s, m.attrs);\n     print_ty_fn(s, None, None, None, m.purity, ast::Many,\n-                m.decl, Some(m.ident), Some(m.tps),\n-                Some(m.self_ty.node));\n+                m.decl, Some(m.ident), Some(/*bad*/ copy m.tps),\n+                Some(/*bad*/ copy m.self_ty.node));\n     word(s.s, ~\";\");\n }\n \n@@ -1141,7 +1142,7 @@ pub fn print_expr(s: @ps, &&expr: @ast::expr) {\n     ibox(s, indent_unit);\n     let ann_node = node_expr(s, expr);\n     (s.ann.pre)(ann_node);\n-    match expr.node {\n+    match /*bad*/ copy expr.node {\n         ast::expr_vstore(e, v) => match v {\n             ast::expr_vstore_fixed(_) => {\n                 print_expr(s, e);\n@@ -1490,7 +1491,7 @@ pub fn print_local_decl(s: @ps, loc: @ast::local) {\n \n pub fn print_decl(s: @ps, decl: @ast::decl) {\n     maybe_print_comment(s, decl.span.lo);\n-    match decl.node {\n+    match /*bad*/ copy decl.node {\n       ast::decl_local(locs) => {\n         space_if_not_bol(s);\n         ibox(s, indent_unit);\n@@ -1574,7 +1575,7 @@ pub fn print_pat(s: @ps, &&pat: @ast::pat, refutable: bool) {\n     (s.ann.pre)(ann_node);\n     /* Pat isn't normalized, but the beauty of it\n      is that it doesn't matter */\n-    match pat.node {\n+    match /*bad*/ copy pat.node {\n       ast::pat_wild => word(s.s, ~\"_\"),\n       ast::pat_ident(binding_mode, path, sub) => {\n           if refutable {\n@@ -1886,7 +1887,7 @@ pub fn print_view_item(s: @ps, item: @ast::view_item) {\n     maybe_print_comment(s, item.span.lo);\n     print_outer_attributes(s, item.attrs);\n     print_visibility(s, item.vis);\n-    match item.node {\n+    match /*bad*/ copy item.node {\n         ast::view_item_extern_mod(id, mta, _) => {\n             head(s, ~\"extern mod\");\n             print_ident(s, id);\n@@ -1968,7 +1969,7 @@ pub fn print_ty_fn(s: @ps,\n     print_onceness(s, onceness);\n     word(s.s, ~\"fn\");\n     match id { Some(id) => { word(s.s, ~\" \"); print_ident(s, id); } _ => () }\n-    match tps { Some(tps) => print_type_params(s, tps), _ => () }\n+    match /*bad*/ copy tps { Some(tps) => print_type_params(s, tps), _ => () }\n     zerobreak(s.s);\n \n     popen(s);\n@@ -2095,7 +2096,7 @@ pub fn next_lit(s: @ps, pos: BytePos) -> Option<comments::lit> {\n     match s.literals {\n       Some(ref lits) => {\n         while s.cur_cmnt_and_lit.cur_lit < vec::len((*lits)) {\n-            let ltrl = (*lits)[s.cur_cmnt_and_lit.cur_lit];\n+            let ltrl = /*bad*/ copy (*lits)[s.cur_cmnt_and_lit.cur_lit];\n             if ltrl.pos > pos { return None; }\n             s.cur_cmnt_and_lit.cur_lit += 1u;\n             if ltrl.pos == pos { return Some(ltrl); }\n@@ -2182,7 +2183,7 @@ pub fn next_comment(s: @ps) -> Option<comments::cmnt> {\n     match s.comments {\n       Some(ref cmnts) => {\n         if s.cur_cmnt_and_lit.cur_cmnt < vec::len((*cmnts)) {\n-            return Some((*cmnts)[s.cur_cmnt_and_lit.cur_cmnt]);\n+            return Some(copy cmnts[s.cur_cmnt_and_lit.cur_cmnt]);\n         } else { return None::<comments::cmnt>; }\n       }\n       _ => return None::<comments::cmnt>"}]}