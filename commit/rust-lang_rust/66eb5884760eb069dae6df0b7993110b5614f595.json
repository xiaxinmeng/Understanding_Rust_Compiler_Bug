{"sha": "66eb5884760eb069dae6df0b7993110b5614f595", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2ZWI1ODg0NzYwZWIwNjlkYWU2ZGYwYjc5OTMxMTBiNTYxNGY1OTU=", "commit": {"author": {"name": "Ryan Thomas", "email": "ryan@ryant.org", "date": "2016-02-01T23:54:05Z"}, "committer": {"name": "Ryan Thomas", "email": "ryan@ryant.org", "date": "2016-02-01T23:54:05Z"}, "message": "Merge branch 'master' of https://github.com/rust-lang/rust into doc", "tree": {"sha": "a5c4156d240a760a8499b1f7bece374761d699e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a5c4156d240a760a8499b1f7bece374761d699e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/66eb5884760eb069dae6df0b7993110b5614f595", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/66eb5884760eb069dae6df0b7993110b5614f595", "html_url": "https://github.com/rust-lang/rust/commit/66eb5884760eb069dae6df0b7993110b5614f595", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/66eb5884760eb069dae6df0b7993110b5614f595/comments", "author": {"login": "rthomas", "id": 564080, "node_id": "MDQ6VXNlcjU2NDA4MA==", "avatar_url": "https://avatars.githubusercontent.com/u/564080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rthomas", "html_url": "https://github.com/rthomas", "followers_url": "https://api.github.com/users/rthomas/followers", "following_url": "https://api.github.com/users/rthomas/following{/other_user}", "gists_url": "https://api.github.com/users/rthomas/gists{/gist_id}", "starred_url": "https://api.github.com/users/rthomas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rthomas/subscriptions", "organizations_url": "https://api.github.com/users/rthomas/orgs", "repos_url": "https://api.github.com/users/rthomas/repos", "events_url": "https://api.github.com/users/rthomas/events{/privacy}", "received_events_url": "https://api.github.com/users/rthomas/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rthomas", "id": 564080, "node_id": "MDQ6VXNlcjU2NDA4MA==", "avatar_url": "https://avatars.githubusercontent.com/u/564080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rthomas", "html_url": "https://github.com/rthomas", "followers_url": "https://api.github.com/users/rthomas/followers", "following_url": "https://api.github.com/users/rthomas/following{/other_user}", "gists_url": "https://api.github.com/users/rthomas/gists{/gist_id}", "starred_url": "https://api.github.com/users/rthomas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rthomas/subscriptions", "organizations_url": "https://api.github.com/users/rthomas/orgs", "repos_url": "https://api.github.com/users/rthomas/repos", "events_url": "https://api.github.com/users/rthomas/events{/privacy}", "received_events_url": "https://api.github.com/users/rthomas/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a58d3303f29c245899cd6549661606ff37763309", "url": "https://api.github.com/repos/rust-lang/rust/commits/a58d3303f29c245899cd6549661606ff37763309", "html_url": "https://github.com/rust-lang/rust/commit/a58d3303f29c245899cd6549661606ff37763309"}, {"sha": "7cae6b59b41d69773a0e02bce5da6d8d4313a9c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/7cae6b59b41d69773a0e02bce5da6d8d4313a9c4", "html_url": "https://github.com/rust-lang/rust/commit/7cae6b59b41d69773a0e02bce5da6d8d4313a9c4"}], "stats": {"total": 500, "additions": 284, "deletions": 216}, "files": [{"sha": "140c4af8297dd10af9e9d2ed20e04fccf56d8ceb", "filename": "mk/cfg/aarch64-linux-android.mk", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/66eb5884760eb069dae6df0b7993110b5614f595/mk%2Fcfg%2Faarch64-linux-android.mk", "raw_url": "https://github.com/rust-lang/rust/raw/66eb5884760eb069dae6df0b7993110b5614f595/mk%2Fcfg%2Faarch64-linux-android.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Faarch64-linux-android.mk?ref=66eb5884760eb069dae6df0b7993110b5614f595", "patch": "@@ -1,5 +1,4 @@\n # aarch64-linux-android configuration\n-# CROSS_PREFIX_aarch64-linux-android-\n CC_aarch64-linux-android=$(CFG_AARCH64_LINUX_ANDROID_NDK)/bin/aarch64-linux-android-gcc\n CXX_aarch64-linux-android=$(CFG_AARCH64_LINUX_ANDROID_NDK)/bin/aarch64-linux-android-g++\n CPP_aarch64-linux-android=$(CFG_AARCH64_LINUX_ANDROID_NDK)/bin/aarch64-linux-android-gcc -E"}, {"sha": "9e7042befa975b0e013623162e8b48297fed2f49", "filename": "mk/cfg/mips-unknown-linux-gnu.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66eb5884760eb069dae6df0b7993110b5614f595/mk%2Fcfg%2Fmips-unknown-linux-gnu.mk", "raw_url": "https://github.com/rust-lang/rust/raw/66eb5884760eb069dae6df0b7993110b5614f595/mk%2Fcfg%2Fmips-unknown-linux-gnu.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fmips-unknown-linux-gnu.mk?ref=66eb5884760eb069dae6df0b7993110b5614f595", "patch": "@@ -20,5 +20,5 @@ CFG_UNIXY_mips-unknown-linux-gnu := 1\n CFG_LDPATH_mips-unknown-linux-gnu :=\n CFG_RUN_mips-unknown-linux-gnu=\n CFG_RUN_TARG_mips-unknown-linux-gnu=\n-RUSTC_FLAGS_mips-unknown-linux-gnu := -C target-cpu=mips32r2 -C target-feature=\"+mips32r2\" -C soft-float\n+RUSTC_FLAGS_mips-unknown-linux-gnu :=\n CFG_GNU_TRIPLE_mips-unknown-linux-gnu := mips-unknown-linux-gnu"}, {"sha": "f15a086b64e8892550a976a120baf031e8d81723", "filename": "mk/cfg/mipsel-unknown-linux-gnu.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66eb5884760eb069dae6df0b7993110b5614f595/mk%2Fcfg%2Fmipsel-unknown-linux-gnu.mk", "raw_url": "https://github.com/rust-lang/rust/raw/66eb5884760eb069dae6df0b7993110b5614f595/mk%2Fcfg%2Fmipsel-unknown-linux-gnu.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fmipsel-unknown-linux-gnu.mk?ref=66eb5884760eb069dae6df0b7993110b5614f595", "patch": "@@ -20,5 +20,5 @@ CFG_UNIXY_mipsel-unknown-linux-gnu := 1\n CFG_LDPATH_mipsel-unknown-linux-gnu :=\n CFG_RUN_mipsel-unknown-linux-gnu=\n CFG_RUN_TARG_mipsel-unknown-linux-gnu=\n-RUSTC_FLAGS_mipsel-unknown-linux-gnu := -C target-cpu=mips32 -C target-feature=\"+mips32\"\n+RUSTC_FLAGS_mipsel-unknown-linux-gnu :=\n CFG_GNU_TRIPLE_mipsel-unknown-linux-gnu := mipsel-unknown-linux-gnu"}, {"sha": "3faf0c6a3f2d7908131c4af727308f370df4392b", "filename": "mk/cfg/x86_64-apple-ios.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66eb5884760eb069dae6df0b7993110b5614f595/mk%2Fcfg%2Fx86_64-apple-ios.mk", "raw_url": "https://github.com/rust-lang/rust/raw/66eb5884760eb069dae6df0b7993110b5614f595/mk%2Fcfg%2Fx86_64-apple-ios.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fx86_64-apple-ios.mk?ref=66eb5884760eb069dae6df0b7993110b5614f595", "patch": "@@ -29,4 +29,4 @@ CFG_UNIXY_x86_64-apple-ios := 1\n CFG_LDPATH_x86_64-apple-ios :=\n CFG_RUN_x86_64-apple-ios = $(2)\n CFG_RUN_TARG_x86_64-apple-ios = $(call CFG_RUN_x86_64-apple-ios,,$(2))\n-CFG_GNU_TRIPLE_i386-apple-ios := x86_64-apple-ios\n+CFG_GNU_TRIPLE_x86_64-apple-ios := x86_64-apple-ios"}, {"sha": "3ed94011c486edfdcd4315ef483c8c3e737350fc", "filename": "mk/cfg/x86_64-unknown-bitrig.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66eb5884760eb069dae6df0b7993110b5614f595/mk%2Fcfg%2Fx86_64-unknown-bitrig.mk", "raw_url": "https://github.com/rust-lang/rust/raw/66eb5884760eb069dae6df0b7993110b5614f595/mk%2Fcfg%2Fx86_64-unknown-bitrig.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fx86_64-unknown-bitrig.mk?ref=66eb5884760eb069dae6df0b7993110b5614f595", "patch": "@@ -9,7 +9,7 @@ CFG_LIB_GLOB_x86_64-unknown-bitrig=lib$(1)-*.so\n CFG_LIB_DSYM_GLOB_x86_64-unknown-bitrig=$(1)-*.dylib.dSYM\n CFG_JEMALLOC_CFLAGS_x86_64-unknown-bitrig := -m64 -I/usr/include $(CFLAGS)\n CFG_GCCISH_CFLAGS_x86_64-unknown-bitrig := -Wall -Werror -fPIE -fPIC -m64 -I/usr/include $(CFLAGS)\n-CFG_GCCISH_LINK_FLAGS_x86_64-unknown-bitrig := -shared -pic -pthread -m64 $(LDFLAGS)\n+CFG_GCCISH_LINK_FLAGS_x86_64-unknown-bitrig := -shared -pic -pthread -m64\n CFG_GCCISH_DEF_FLAG_x86_64-unknown-bitrig := -Wl,--export-dynamic,--dynamic-list=\n CFG_LLC_FLAGS_x86_64-unknown-bitrig :=\n CFG_INSTALL_NAME_x86_64-unknown-bitrig ="}, {"sha": "4db8f32bb16f66077adb43e844489abc1052b9bd", "filename": "mk/crates.mk", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/66eb5884760eb069dae6df0b7993110b5614f595/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/66eb5884760eb069dae6df0b7993110b5614f595/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=66eb5884760eb069dae6df0b7993110b5614f595", "patch": "@@ -139,13 +139,13 @@ ONLY_RLIB_alloc_system := 1\n # Documented-by-default crates\n DOC_CRATES := std alloc collections core libc rustc_unicode\n \n-ifeq ($(CFG_DISABLE_JEMALLOC),)\n+ifdef CFG_DISABLE_JEMALLOC\n+RUSTFLAGS_rustc_back := --cfg disable_jemalloc\n+else\n TARGET_CRATES += alloc_jemalloc\n DEPS_std += alloc_jemalloc\n DEPS_alloc_jemalloc := core libc native:jemalloc\n ONLY_RLIB_alloc_jemalloc := 1\n-else\n-RUSTFLAGS_rustc_back := --cfg disable_jemalloc\n endif\n \n ################################################################################"}, {"sha": "81aabe60ff3cb98eb09d5ba7bb1eb83b4cc43897", "filename": "mk/docs.mk", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66eb5884760eb069dae6df0b7993110b5614f595/mk%2Fdocs.mk", "raw_url": "https://github.com/rust-lang/rust/raw/66eb5884760eb069dae6df0b7993110b5614f595/mk%2Fdocs.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdocs.mk?ref=66eb5884760eb069dae6df0b7993110b5614f595", "patch": "@@ -71,7 +71,7 @@ DOC_L10N_TARGETS :=\n \n # If NO_REBUILD is set then break the dependencies on rustdoc so we\n # build the documentation without having to rebuild rustdoc.\n-ifeq ($(NO_REBUILD),)\n+ifndef NO_REBUILD\n HTML_DEPS := $(RUSTDOC_EXE)\n else\n HTML_DEPS :=\n@@ -152,7 +152,7 @@ define DEF_LIB_DOC\n \n # If NO_REBUILD is set then break the dependencies on rustdoc so we\n # build crate documentation without having to rebuild rustdoc.\n-ifeq ($(NO_REBUILD),)\n+ifndef NO_REBUILD\n LIB_DOC_DEP_$(1) = \\\n \t$$(CRATEFILE_$(1)) \\\n \t$$(RSINPUTS_$(1)) \\"}, {"sha": "8956983e3bee86712f6259ae564460f3ea3582da", "filename": "mk/grammar.mk", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66eb5884760eb069dae6df0b7993110b5614f595/mk%2Fgrammar.mk", "raw_url": "https://github.com/rust-lang/rust/raw/66eb5884760eb069dae6df0b7993110b5614f595/mk%2Fgrammar.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fgrammar.mk?ref=66eb5884760eb069dae6df0b7993110b5614f595", "patch": "@@ -41,8 +41,8 @@ $(BG)RustLexer.class: $(BG) $(SG)RustLexer.g4\n \n check-build-lexer-verifier: $(BG)verify\n \n-ifeq ($(NO_REBUILD),)\n-VERIFY_DEPS :=  rustc-stage2-H-$(CFG_BUILD) $(LD)stamp.rustc\n+ifndef NO_REBUILD\n+VERIFY_DEPS := rustc-stage2-H-$(CFG_BUILD) $(LD)stamp.rustc\n else\n VERIFY_DEPS :=\n endif"}, {"sha": "2faed75ac07efb197fd41d84bc6dc762699d57d6", "filename": "mk/host.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66eb5884760eb069dae6df0b7993110b5614f595/mk%2Fhost.mk", "raw_url": "https://github.com/rust-lang/rust/raw/66eb5884760eb069dae6df0b7993110b5614f595/mk%2Fhost.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fhost.mk?ref=66eb5884760eb069dae6df0b7993110b5614f595", "patch": "@@ -18,7 +18,7 @@\n # $(5) - the name of the crate being processed\n define CP_HOST_STAGE_N_CRATE\n \n-ifeq ($$(ONLY_RLIB_$(5)),)\n+ifndef ONLY_RLIB_$(5)\n $$(HLIB$(2)_H_$(4))/stamp.$(5): \\\n \t$$(TLIB$(1)_T_$(3)_H_$(4))/stamp.$(5) \\\n \t$$(RUST_DEPS_$(5):%=$$(HLIB$(2)_H_$(4))/stamp.%) \\"}, {"sha": "6d9d86c3eb8bc2e080e885165cfb1bb5682c36c3", "filename": "mk/install.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66eb5884760eb069dae6df0b7993110b5614f595/mk%2Finstall.mk", "raw_url": "https://github.com/rust-lang/rust/raw/66eb5884760eb069dae6df0b7993110b5614f595/mk%2Finstall.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Finstall.mk?ref=66eb5884760eb069dae6df0b7993110b5614f595", "patch": "@@ -121,7 +121,7 @@ install-runtime-target-$(1)-cleanup:\n endef\n \n $(foreach target,$(CFG_TARGET), \\\n- $(if $(findstring $(CFG_ADB_DEVICE_STATUS),\"true\"), \\\n+ $(if $(findstring $(CFG_ADB_DEVICE_STATUS),true), \\\n   $(eval $(call INSTALL_RUNTIME_TARGET_N,$(taget),$(CFG_BUILD))) \\\n   $(eval $(call INSTALL_RUNTIME_TARGET_CLEANUP_N,$(target))) \\\n   ))"}, {"sha": "d250ede995873c55454e2f7262cc815facdb568a", "filename": "mk/llvm.mk", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/66eb5884760eb069dae6df0b7993110b5614f595/mk%2Fllvm.mk", "raw_url": "https://github.com/rust-lang/rust/raw/66eb5884760eb069dae6df0b7993110b5614f595/mk%2Fllvm.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fllvm.mk?ref=66eb5884760eb069dae6df0b7993110b5614f595", "patch": "@@ -71,7 +71,7 @@ $$(LLVM_STAMP_$(1)): $$(S)src/rustllvm/llvm-auto-clean-trigger\n \t@$$(call E, make: done cleaning llvm)\n \ttouch -r $$@.start_time $$@ && rm $$@.start_time\n \n-ifeq ($$(CFG_ENABLE_LLVM_STATIC_STDCPP),1)\n+ifdef CFG_ENABLE_LLVM_STATIC_STDCPP\n LLVM_STDCPP_RUSTFLAGS_$(1) = -L \"$$(dir $$(shell $$(CC_$(1)) $$(CFG_GCCISH_CFLAGS_$(1)) \\\n \t\t\t\t\t-print-file-name=lib$(CFG_STDCPP_NAME).a))\"\n else\n@@ -95,9 +95,6 @@ endef\n $(foreach host,$(CFG_HOST), \\\n  $(eval $(call DEF_LLVM_RULES,$(host))))\n \n-$(foreach host,$(CFG_HOST), \\\n- $(eval LLVM_CONFIGS := $(LLVM_CONFIGS) $(LLVM_CONFIG_$(host))))\n-\n # This can't be done in target.mk because it's included before this file.\n define LLVM_LINKAGE_DEPS\n $$(TLIB$(1)_T_$(2)_H_$(3))/stamp.rustc_llvm: $$(LLVM_LINKAGE_PATH_$(2))"}, {"sha": "b272a80eaf786d01a243b9a2a19c11efe00be802", "filename": "mk/main.mk", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/66eb5884760eb069dae6df0b7993110b5614f595/mk%2Fmain.mk", "raw_url": "https://github.com/rust-lang/rust/raw/66eb5884760eb069dae6df0b7993110b5614f595/mk%2Fmain.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fmain.mk?ref=66eb5884760eb069dae6df0b7993110b5614f595", "patch": "@@ -86,13 +86,13 @@ CFG_INFO := $(info cfg: version $(CFG_VERSION))\n \n MKFILE_DEPS := config.stamp $(call rwildcard,$(CFG_SRC_DIR)mk/,*)\n MKFILES_FOR_TARBALL:=$(MKFILE_DEPS)\n-ifneq ($(NO_MKFILE_DEPS),)\n+ifdef NO_MKFILE_DEPS\n MKFILE_DEPS :=\n endif\n NON_BUILD_HOST = $(filter-out $(CFG_BUILD),$(CFG_HOST))\n NON_BUILD_TARGET = $(filter-out $(CFG_BUILD),$(CFG_TARGET))\n \n-ifneq ($(MAKE_RESTARTS),)\n+ifdef MAKE_RESTARTS\n CFG_INFO := $(info cfg: make restarts: $(MAKE_RESTARTS))\n endif\n \n@@ -107,28 +107,40 @@ ifneq ($(wildcard $(NON_BUILD_TARGET)),)\n CFG_INFO := $(info cfg: non-build target triples $(NON_BUILD_TARGET))\n endif\n \n-CFG_RUSTC_FLAGS := $(RUSTFLAGS)\n+CFG_RUSTC_FLAGS :=\n+ifdef RUSTFLAGS\n+  CFG_RUSTC_FLAGS += $(RUSTFLAGS)\n+endif\n CFG_GCCISH_CFLAGS :=\n CFG_GCCISH_LINK_FLAGS :=\n \n CFG_JEMALLOC_FLAGS :=\n+ifdef JEMALLOC_FLAGS\n+  CFG_JEMALLOC_FLAGS += $(JEMALLOC_FLAGS)\n+endif\n \n ifdef CFG_DISABLE_OPTIMIZE\n   $(info cfg: disabling rustc optimization (CFG_DISABLE_OPTIMIZE))\n-  CFG_RUSTC_FLAGS +=\n   CFG_JEMALLOC_FLAGS += --enable-debug\n else\n   # The rtopt cfg turns off runtime sanity checks\n   CFG_RUSTC_FLAGS += -O --cfg rtopt\n endif\n \n-CFG_JEMALLOC_FLAGS += $(JEMALLOC_FLAGS)\n-\n ifdef CFG_ENABLE_DEBUG_ASSERTIONS\n   $(info cfg: enabling debug assertions (CFG_ENABLE_DEBUG_ASSERTIONS))\n   CFG_RUSTC_FLAGS += -C debug-assertions=on\n endif\n \n+define DEF_RUSTFLAGS_STAGE\n+RUSTFLAGS_STAGE$(1) :=\n+endef\n+\n+STAGES = 0 1 2 3\n+\n+$(foreach stage,$(STAGES), \\\n+  $(eval $(call DEF_RUSTFLAGS_STAGE,$(stage))))\n+\n ifdef CFG_ENABLE_DEBUGINFO\n   $(info cfg: enabling debuginfo (CFG_ENABLE_DEBUGINFO))\n   CFG_RUSTC_FLAGS += -g\n@@ -186,9 +198,9 @@ endif\n \n \n ifndef CFG_DISABLE_VALGRIND_RPASS\n-  $(info cfg: enabling valgrind run-pass tests (CFG_ENABLE_VALGRIND_RPASS))\n+  $(info cfg: enabling valgrind run-pass tests)\n   $(info cfg: valgrind-rpass command set to $(CFG_VALGRIND))\n-  CFG_VALGRIND_RPASS :=$(CFG_VALGRIND)\n+  CFG_VALGRIND_RPASS := $(CFG_VALGRIND)\n else\n   $(info cfg: disabling valgrind run-pass tests)\n   CFG_VALGRIND_RPASS :=\n@@ -372,8 +384,6 @@ export CFG_BOOTSTRAP_KEY\n TRIPLE_TO_DEBUGGER_SCRIPT_SETTING=\\\n  $(if $(findstring windows,$(1)),none,$(if $(findstring darwin,$(1)),lldb,gdb))\n \n-STAGES = 0 1 2 3\n-\n define SREQ\n # $(1) is the stage number\n # $(2) is the target triple"}, {"sha": "d702cca209def0c14c920e4fcd28744d57532809", "filename": "mk/platform.mk", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/66eb5884760eb069dae6df0b7993110b5614f595/mk%2Fplatform.mk", "raw_url": "https://github.com/rust-lang/rust/raw/66eb5884760eb069dae6df0b7993110b5614f595/mk%2Fplatform.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fplatform.mk?ref=66eb5884760eb069dae6df0b7993110b5614f595", "patch": "@@ -82,12 +82,11 @@ AR := ar\n define SET_FROM_CFG\n   ifdef CFG_$(1)\n     ifeq ($(origin $(1)),undefined)\n-      $$(info cfg: using $(1)=$(CFG_$(1)) (CFG_$(1)))\n-      $(1)=$(CFG_$(1))\n-    endif\n-    ifeq ($(origin $(1)),default)\n-      $$(info cfg: using $(1)=$(CFG_$(1)) (CFG_$(1)))\n-      $(1)=$(CFG_$(1))\n+      $$(info cfg: using $(1)=$$(CFG_$(1)) (CFG_$(1)))\n+      $(1)=$$(CFG_$(1))\n+    else ifeq ($(origin $(1)),default)\n+      $$(info cfg: using $(1)=$$(CFG_$(1)) (CFG_$(1)))\n+      $(1)=$$(CFG_$(1))\n     endif\n   endif\n endef\n@@ -101,7 +100,9 @@ include $(wildcard $(CFG_SRC_DIR)mk/cfg/*.mk)\n \n define ADD_INSTALLED_OBJECTS\n   INSTALLED_OBJECTS_$(1) += $$(CFG_INSTALLED_OBJECTS_$(1))\n-  REQUIRED_OBJECTS_$(1) += $$(CFG_THIRD_PARTY_OBJECTS_$(1))\n+  ifdef CFG_THIRD_PARTY_OBJECTS_$(1)\n+    REQUIRED_OBJECTS_$(1) += $$(CFG_THIRD_PARTY_OBJECTS_$(1))\n+  endif\n   INSTALLED_OBJECTS_$(1) += $$(call CFG_STATIC_LIB_NAME_$(1),compiler-rt)\n   REQUIRED_OBJECTS_$(1) += $$(call CFG_STATIC_LIB_NAME_$(1),compiler-rt)\n endef\n@@ -163,15 +164,15 @@ define CFG_MAKE_TOOLCHAIN\n   # Prepend the tools with their prefix if cross compiling\n   ifneq ($(CFG_BUILD),$(1))\n     ifneq ($$(findstring msvc,$(1)),msvc)\n-       CC_$(1)=$(CROSS_PREFIX_$(1))$(CC_$(1))\n-       CXX_$(1)=$(CROSS_PREFIX_$(1))$(CXX_$(1))\n-       CPP_$(1)=$(CROSS_PREFIX_$(1))$(CPP_$(1))\n-       AR_$(1)=$(CROSS_PREFIX_$(1))$(AR_$(1))\n-       LINK_$(1)=$(CROSS_PREFIX_$(1))$(LINK_$(1))\n-       RUSTC_CROSS_FLAGS_$(1)=-C linker=$$(call FIND_COMPILER,$$(LINK_$(1))) \\\n-           -C ar=$$(call FIND_COMPILER,$$(AR_$(1))) $(RUSTC_CROSS_FLAGS_$(1))\n-\n-       RUSTC_FLAGS_$(1)=$$(RUSTC_CROSS_FLAGS_$(1)) $(RUSTC_FLAGS_$(1))\n+      CC_$(1)=$(CROSS_PREFIX_$(1))$(CC_$(1))\n+      CXX_$(1)=$(CROSS_PREFIX_$(1))$(CXX_$(1))\n+      CPP_$(1)=$(CROSS_PREFIX_$(1))$(CPP_$(1))\n+      AR_$(1)=$(CROSS_PREFIX_$(1))$(AR_$(1))\n+      LINK_$(1)=$(CROSS_PREFIX_$(1))$(LINK_$(1))\n+      RUSTC_CROSS_FLAGS_$(1)=-C linker=$$(call FIND_COMPILER,$$(LINK_$(1))) \\\n+        -C ar=$$(call FIND_COMPILER,$$(AR_$(1))) $(RUSTC_CROSS_FLAGS_$(1))\n+\n+      RUSTC_FLAGS_$(1)=$$(RUSTC_CROSS_FLAGS_$(1)) $(RUSTC_FLAGS_$(1))\n     endif\n   endif\n "}, {"sha": "394fbe1ba0f7184147cc0d5c470ad5db550c2f8e", "filename": "mk/rt.mk", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66eb5884760eb069dae6df0b7993110b5614f595/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/66eb5884760eb069dae6df0b7993110b5614f595/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=66eb5884760eb069dae6df0b7993110b5614f595", "patch": "@@ -107,8 +107,6 @@ $$(RT_OUTPUT_DIR_$(1))/$$(NATIVE_$(2)_$(1)): $$(OBJS_$(2)_$(1))\n \n endef\n \n-$(foreach target,$(CFG_TARGET), \\\n- $(eval $(call RUNTIME_RULES,$(target))))\n $(foreach lib,$(NATIVE_LIBS), \\\n  $(foreach target,$(CFG_TARGET), \\\n   $(eval $(call THIRD_PARTY_LIB,$(target),$(lib)))))\n@@ -171,7 +169,7 @@ endif\n \n # See #17183 for details, this file is touched during the build process so we\n # don't want to consider it as a dependency.\n-JEMALLOC_DEPS := $(filter-out $(S)src/jemalloc/VERSION,$(JEMALLOC_DEPS))\n+JEMALLOC_DEPS := $(filter-out $(S)src/jemalloc/VERSION,$$(JEMALLOC_DEPS))\n \n JEMALLOC_NAME_$(1) := $$(call CFG_STATIC_LIB_NAME_$(1),jemalloc)\n ifeq ($$(CFG_WINDOWSY_$(1)),1)"}, {"sha": "1fcc87f0c35fc6dc893bf4002592eb808b5a5785", "filename": "mk/target.mk", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66eb5884760eb069dae6df0b7993110b5614f595/mk%2Ftarget.mk", "raw_url": "https://github.com/rust-lang/rust/raw/66eb5884760eb069dae6df0b7993110b5614f595/mk%2Ftarget.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftarget.mk?ref=66eb5884760eb069dae6df0b7993110b5614f595", "patch": "@@ -138,12 +138,12 @@ define TARGET_RUSTRT_STARTUP_OBJ\n $$(TLIB$(1)_T_$(2)_H_$(3))/$(4).o: \\\n \t\t$(S)src/rtstartup/$(4).rs \\\n \t\t$$(TLIB$(1)_T_$(2)_H_$(3))/stamp.core \\\n-\t\t$$(HSREQ$(1)_T_$(2)_H_$(3)) \\\n+\t\t$$(HSREQ$(1)_H_$(3)) \\\n \t\t| $$(TBIN$(1)_T_$(2)_H_$(3))/\n \t@$$(call E, rustc: $$@)\n \t$$(STAGE$(1)_T_$(2)_H_$(3)) --emit=obj -o $$@ $$<\n \n-ifeq ($$(CFG_RUSTRT_HAS_STARTUP_OBJS_$(2)), 1)\n+ifdef CFG_RUSTRT_HAS_STARTUP_OBJS_$(2)\n # Add dependencies on Rust startup objects to all crates that depend on core.\n # This ensures that they are built after core (since they depend on it),\n # but before everything else (since they are needed for linking dylib crates)."}, {"sha": "bce5a52118bd89455cb740860d58613d99952c0b", "filename": "mk/tests.mk", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/66eb5884760eb069dae6df0b7993110b5614f595/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/66eb5884760eb069dae6df0b7993110b5614f595/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=66eb5884760eb069dae6df0b7993110b5614f595", "patch": "@@ -36,6 +36,8 @@ TEST_CRATES = $(TEST_TARGET_CRATES) $(TEST_HOST_CRATES)\n # Environment configuration\n ######################################################################\n \n+TESTARGS :=\n+\n # The arguments to all test runners\n ifdef TESTNAME\n   TESTARGS += $(TESTNAME)\n@@ -48,6 +50,8 @@ endif\n # Arguments to the cfail/rfail/rpass tests\n ifdef CFG_VALGRIND\n   CTEST_RUNTOOL = --runtool \"$(CFG_VALGRIND)\"\n+else\n+  CTEST_RUNTOOL =\n endif\n \n CTEST_TESTARGS := $(TESTARGS)\n@@ -143,10 +147,11 @@ else\n CFG_ADB_TEST_DIR=\n endif\n \n+DOC_NAMES :=\n # $(1) - name of doc test\n # $(2) - file of the test\n define DOCTEST\n-DOC_NAMES := $$(DOC_NAMES) $(1)\n+DOC_NAMES += $(1)\n DOCFILE_$(1) := $(2)\n endef\n \n@@ -362,7 +367,7 @@ define TEST_RUNNER\n # If NO_REBUILD is set then break the dependencies on everything but\n # the source files so we can test crates without rebuilding any of the\n # parent crates.\n-ifeq ($(NO_REBUILD),)\n+ifndef NO_REBUILD\n TESTDEP_$(1)_$(2)_$(3)_$(4) = $$(SREQ$(1)_T_$(2)_H_$(3)) \\\n \t\t\t    $$(foreach crate,$$(TARGET_CRATES), \\\n \t\t\t\t$$(TLIB$(1)_T_$(2)_H_$(3))/stamp.$$(crate)) \\\n@@ -447,7 +452,7 @@ $(foreach host,$(CFG_HOST), \\\n     $(if $(findstring $(target),$(CFG_BUILD)), \\\n      $(eval $(call DEF_TEST_CRATE_RULES,$(stage),$(target),$(host),$(crate))), \\\n      $(if $(findstring android, $(target)), \\\n-      $(if $(findstring $(CFG_ADB_DEVICE_STATUS),\"true\"), \\\n+      $(if $(findstring $(CFG_ADB_DEVICE_STATUS),true), \\\n        $(eval $(call DEF_TEST_CRATE_RULES_android,$(stage),$(target),$(host),$(crate))), \\\n        $(eval $(call DEF_TEST_CRATE_RULES_null,$(stage),$(target),$(host),$(crate))) \\\n       ), \\\n@@ -700,22 +705,22 @@ check-stage$(1)-T-$(2)-H-$(3)-$(4)-exec: $$(call TEST_OK_FILE,$(1),$(2),$(3),$(4\n # (Encoded as a separate variable because GNU make does not have a\n # good way to express OR on ifeq commands)\n \n-ifneq ($$(CTEST_DISABLE_$(4)),)\n+ifdef CTEST_DISABLE_$(4)\n # Test suite is disabled for all configured targets.\n CTEST_DONT_RUN_$(1)-T-$(2)-H-$(3)-$(4) := $$(CTEST_DISABLE_$(4))\n else\n # else, check if non-self-hosted target (i.e. target not-in hosts) ...\n ifeq ($$(findstring $(2),$$(CFG_HOST)),)\n # ... if so, then check if this test suite is disabled for non-selfhosts.\n-ifneq ($$(CTEST_DISABLE_NONSELFHOST_$(4)),)\n+ifdef CTEST_DISABLE_NONSELFHOST_$(4)\n # Test suite is disabled for this target.\n CTEST_DONT_RUN_$(1)-T-$(2)-H-$(3)-$(4) := $$(CTEST_DISABLE_NONSELFHOST_$(4))\n endif\n endif\n # Neither DISABLE nor DISABLE_NONSELFHOST is set ==> okay, run the test.\n endif\n \n-ifeq ($$(CTEST_DONT_RUN_$(1)-T-$(2)-H-$(3)-$(4)),)\n+ifndef CTEST_DONT_RUN_$(1)-T-$(2)-H-$(3)-$(4)\n $$(call TEST_OK_FILE,$(1),$(2),$(3),$(4)): \\\n \t\t$$(TEST_SREQ$(1)_T_$(2)_H_$(3)) \\\n                 $$(CTEST_DEPS_$(4)_$(1)-T-$(2)-H-$(3))\n@@ -824,7 +829,7 @@ check-stage$(1)-T-$(2)-H-$(3)-doc-$(4)-exec: $$(call TEST_OK_FILE,$(1),$(2),$(3)\n # If NO_REBUILD is set then break the dependencies on everything but\n # the source files so we can test documentation without rebuilding\n # rustdoc etc.\n-ifeq ($(NO_REBUILD),)\n+ifndef NO_REBUILD\n DOCTESTDEP_$(1)_$(2)_$(3)_$(4) = \\\n \t$$(DOCFILE_$(4)) \\\n \t$$(TEST_SREQ$(1)_T_$(2)_H_$(3)) \\\n@@ -859,7 +864,7 @@ define DEF_CRATE_DOC_TEST\n # If NO_REBUILD is set then break the dependencies on everything but\n # the source files so we can test crate documentation without\n # rebuilding any of the parent crates.\n-ifeq ($(NO_REBUILD),)\n+ifndef NO_REBUILD\n CRATEDOCTESTDEP_$(1)_$(2)_$(3)_$(4) = \\\n \t$$(TEST_SREQ$(1)_T_$(2)_H_$(3)) \\\n \t$$(CRATE_FULLDEPS_$(1)_T_$(2)_H_$(3)_$(4)) \\\n@@ -922,8 +927,7 @@ TEST_GROUPS = \\\n \tpretty-rpass-full \\\n \tpretty-rfail-full \\\n \tpretty-rfail \\\n-\tpretty-pretty \\\n-\t$(NULL)\n+\tpretty-pretty\n \n define DEF_CHECK_FOR_STAGE_AND_TARGET_AND_HOST\n check-stage$(1)-T-$(2)-H-$(3): check-stage$(1)-T-$(2)-H-$(3)-exec"}, {"sha": "c207ad16595d199b77ac1a5ac73cda365fc7f2d8", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/66eb5884760eb069dae6df0b7993110b5614f595/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66eb5884760eb069dae6df0b7993110b5614f595/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=66eb5884760eb069dae6df0b7993110b5614f595", "patch": "@@ -17,6 +17,24 @@\n //! Like many traits, these are often used as bounds for generic functions, to\n //! support arguments of multiple types.\n //!\n+//! - Impl the `As*` traits for reference-to-reference conversions\n+//! - Impl the `Into` trait when you want to consume the value in the conversion\n+//! - The `From` trait is the most flexible, usefull for values _and_ references conversions\n+//!\n+//! As a library writer, you should prefer implementing `From<T>` rather than\n+//! `Into<U>`, as `From` provides greater flexibility and offer the equivalent `Into`\n+//! implementation for free, thanks to a blanket implementation in the standard library.\n+//!\n+//! **Note: these traits must not fail**. If the conversion can fail, you must use a dedicated\n+//! method which return an `Option<T>` or a `Result<T, E>`.\n+//!\n+//! # Generic impl\n+//!\n+//! - `AsRef` and `AsMut` auto-dereference if the inner type is a reference\n+//! - `From<U> for T` implies `Into<T> for U`\n+//! - `From` and `Into` are reflexive, which means that all types can `into()`\n+//!   themselves and `from()` themselves\n+//!\n //! See each trait for usage examples.\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -30,6 +48,9 @@ use marker::Sized;\n ///\n /// [book]: ../../book/borrow-and-asref.html\n ///\n+/// **Note: this trait must not fail**. If the conversion can fail, use a dedicated method which\n+/// return an `Option<T>` or a `Result<T, E>`.\n+///\n /// # Examples\n ///\n /// Both `String` and `&str` implement `AsRef<str>`:\n@@ -45,6 +66,12 @@ use marker::Sized;\n /// let s = \"hello\".to_string();\n /// is_hello(s);\n /// ```\n+///\n+/// # Generic Impls\n+///\n+/// - `AsRef` auto-dereference if the inner type is a reference or a mutable\n+/// reference (eg: `foo.as_ref()` will work the same if `foo` has type `&mut Foo` or `&&mut Foo`)\n+///\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait AsRef<T: ?Sized> {\n     /// Performs the conversion.\n@@ -53,6 +80,15 @@ pub trait AsRef<T: ?Sized> {\n }\n \n /// A cheap, mutable reference-to-mutable reference conversion.\n+///\n+/// **Note: this trait must not fail**. If the conversion can fail, use a dedicated method which\n+/// return an `Option<T>` or a `Result<T, E>`.\n+///\n+/// # Generic Impls\n+///\n+/// - `AsMut` auto-dereference if the inner type is a reference or a mutable\n+/// reference (eg: `foo.as_ref()` will work the same if `foo` has type `&mut Foo` or `&&mut Foo`)\n+///\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait AsMut<T: ?Sized> {\n     /// Performs the conversion.\n@@ -62,6 +98,13 @@ pub trait AsMut<T: ?Sized> {\n \n /// A conversion that consumes `self`, which may or may not be expensive.\n ///\n+/// **Note: this trait must not fail**. If the conversion can fail, use a dedicated method which\n+/// return an `Option<T>` or a `Result<T, E>`.\n+///\n+/// Library writer should not implement directly this trait, but should prefer the implementation\n+/// of the `From` trait, which offer greater flexibility and provide the equivalent `Into`\n+/// implementation for free, thanks to a blanket implementation in the standard library.\n+///\n /// # Examples\n ///\n /// `String` implements `Into<Vec<u8>>`:\n@@ -75,6 +118,12 @@ pub trait AsMut<T: ?Sized> {\n /// let s = \"hello\".to_string();\n /// is_hello(s);\n /// ```\n+///\n+/// # Generic Impls\n+///\n+/// - `From<T> for U` implies `Into<U> for T`\n+/// - `into()` is reflexive, which means that `Into<T> for T` is implemented\n+///\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Into<T>: Sized {\n     /// Performs the conversion.\n@@ -84,6 +133,9 @@ pub trait Into<T>: Sized {\n \n /// Construct `Self` via a conversion.\n ///\n+/// **Note: this trait must not fail**. If the conversion can fail, use a dedicated method which\n+/// return an `Option<T>` or a `Result<T, E>`.\n+///\n /// # Examples\n ///\n /// `String` implements `From<&str>`:\n@@ -94,6 +146,11 @@ pub trait Into<T>: Sized {\n ///\n /// assert_eq!(string, other_string);\n /// ```\n+/// # Generic impls\n+///\n+/// - `From<T> for U` implies `Into<U> for T`\n+/// - `from()` is reflexive, which means that `From<T> for T` is implemented\n+///\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait From<T>: Sized {\n     /// Performs the conversion."}, {"sha": "01f2de4a2694a0d535745c4956420789761ef751", "filename": "src/librustc_back/target/mips_unknown_linux_gnu.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/66eb5884760eb069dae6df0b7993110b5614f595/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66eb5884760eb069dae6df0b7993110b5614f595/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_gnu.rs?ref=66eb5884760eb069dae6df0b7993110b5614f595", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use target::Target;\n+use target::{Target, TargetOptions};\n \n pub fn target() -> Target {\n     Target {\n@@ -19,6 +19,10 @@ pub fn target() -> Target {\n         target_os: \"linux\".to_string(),\n         target_env: \"gnu\".to_string(),\n         target_vendor: \"unknown\".to_string(),\n-        options: super::linux_base::opts()\n+        options: TargetOptions {\n+            cpu: \"mips32r2\".to_string(),\n+            features: \"+mips32r2,+soft-float\".to_string(),\n+            ..super::linux_base::opts()\n+        },\n     }\n }"}, {"sha": "e9eef72e8c39313cb774a956cbf72bbd547495a2", "filename": "src/librustc_back/target/mipsel_unknown_linux_gnu.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/66eb5884760eb069dae6df0b7993110b5614f595/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66eb5884760eb069dae6df0b7993110b5614f595/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_gnu.rs?ref=66eb5884760eb069dae6df0b7993110b5614f595", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use target::Target;\n+use target::{Target, TargetOptions};\n \n pub fn target() -> Target {\n     Target {\n@@ -20,6 +20,10 @@ pub fn target() -> Target {\n         target_env: \"gnu\".to_string(),\n         target_vendor: \"unknown\".to_string(),\n \n-        options: super::linux_base::opts()\n+        options: TargetOptions {\n+            cpu: \"mips32\".to_string(),\n+            features: \"+mips32\".to_string(),\n+            ..super::linux_base::opts()\n+        },\n     }\n }"}, {"sha": "8f4913f04205e7310a45eeb47de33f03990a7f47", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 25, "deletions": 13, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/66eb5884760eb069dae6df0b7993110b5614f595/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66eb5884760eb069dae6df0b7993110b5614f595/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=66eb5884760eb069dae6df0b7993110b5614f595", "patch": "@@ -107,20 +107,37 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n     /// Defines `name` in namespace `ns` of module `parent` to be `def` if it is not yet defined;\n     /// otherwise, reports an error.\n     fn define<T: ToNameBinding<'b>>(&self, parent: Module<'b>, name: Name, ns: Namespace, def: T) {\n-        let name_binding = def.to_name_binding();\n-        let span = name_binding.span.unwrap_or(DUMMY_SP);\n-        self.check_for_conflicts_between_external_crates_and_items(&parent, name, span);\n-        if !parent.try_define_child(name, ns, name_binding) {\n+        let binding = def.to_name_binding();\n+        let old_binding = match parent.try_define_child(name, ns, binding.clone()) {\n+            Some(old_binding) => old_binding,\n+            None => return,\n+        };\n+\n+        let span = binding.span.unwrap_or(DUMMY_SP);\n+        if !old_binding.is_extern_crate() && !binding.is_extern_crate() {\n             // Record an error here by looking up the namespace that had the duplicate\n             let ns_str = match ns { TypeNS => \"type or module\", ValueNS => \"value\" };\n             let resolution_error = ResolutionError::DuplicateDefinition(ns_str, name);\n             let mut err = resolve_struct_error(self, span, resolution_error);\n \n-            if let Some(sp) = parent.children.borrow().get(&(name, ns)).unwrap().span {\n+            if let Some(sp) = old_binding.span {\n                 let note = format!(\"first definition of {} `{}` here\", ns_str, name);\n                 err.span_note(sp, &note);\n             }\n             err.emit();\n+        } else if old_binding.is_extern_crate() && binding.is_extern_crate() {\n+            span_err!(self.session,\n+                      span,\n+                      E0259,\n+                      \"an external crate named `{}` has already been imported into this module\",\n+                      name);\n+        } else {\n+            span_err!(self.session,\n+                      span,\n+                      E0260,\n+                      \"the name `{}` conflicts with an external crate \\\n+                      that has been imported into this module\",\n+                      name);\n         }\n     }\n \n@@ -289,14 +306,9 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                     self.external_exports.insert(def_id);\n                     let parent_link = ModuleParentLink(parent, name);\n                     let def = Def::Mod(def_id);\n-                    let external_module = self.new_module(parent_link, Some(def), false, true);\n-\n-                    debug!(\"(build reduced graph for item) found extern `{}`\",\n-                           module_to_string(&*external_module));\n-                    self.check_for_conflicts_for_external_crate(parent, name, sp);\n-                    parent.external_module_children\n-                          .borrow_mut()\n-                          .insert(name, external_module);\n+                    let external_module = self.new_extern_crate_module(parent_link, def);\n+                    self.define(parent, name, TypeNS, (external_module, sp));\n+\n                     self.build_reduced_graph_for_external_crate(&external_module);\n                 }\n                 parent"}, {"sha": "178e2a4d1bc7882d816188cebf605b148cb579d2", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66eb5884760eb069dae6df0b7993110b5614f595/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66eb5884760eb069dae6df0b7993110b5614f595/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=66eb5884760eb069dae6df0b7993110b5614f595", "patch": "@@ -117,7 +117,7 @@ impl<'a, 'b, 'v, 'tcx> Visitor<'v> for UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n         // whether they're used or not. Also ignore imports with a dummy span\n         // because this means that they were generated in some fashion by the\n         // compiler and we don't need to consider them.\n-        if item.vis == hir::Public || item.span == DUMMY_SP {\n+        if item.vis == hir::Public || item.span.source_equal(&DUMMY_SP) {\n             return;\n         }\n "}, {"sha": "6f35d10c994204969e3dbf70cae1edb65d881aa2", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 32, "deletions": 72, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/66eb5884760eb069dae6df0b7993110b5614f595/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66eb5884760eb069dae6df0b7993110b5614f595/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=66eb5884760eb069dae6df0b7993110b5614f595", "patch": "@@ -120,8 +120,6 @@ enum SuggestionType {\n }\n \n pub enum ResolutionError<'a> {\n-    /// error E0260: name conflicts with an extern crate\n-    NameConflictsWithExternCrate(Name),\n     /// error E0401: can't use type parameters from outer function\n     TypeParametersFromOuterFunction,\n     /// error E0402: cannot use an outer type parameter in this context\n@@ -228,14 +226,6 @@ fn resolve_struct_error<'b, 'a: 'b, 'tcx: 'a>(resolver: &'b Resolver<'a, 'tcx>,\n     }\n \n     match resolution_error {\n-        ResolutionError::NameConflictsWithExternCrate(name) => {\n-            struct_span_err!(resolver.session,\n-                             span,\n-                             E0260,\n-                             \"the name `{}` conflicts with an external crate \\\n-                             that has been imported into this module\",\n-                             name)\n-        }\n         ResolutionError::TypeParametersFromOuterFunction => {\n             struct_span_err!(resolver.session,\n                              span,\n@@ -801,14 +791,11 @@ pub struct ModuleS<'a> {\n     parent_link: ParentLink<'a>,\n     def: Cell<Option<Def>>,\n     is_public: bool,\n+    is_extern_crate: bool,\n \n     children: RefCell<HashMap<(Name, Namespace), NameBinding<'a>>>,\n     imports: RefCell<Vec<ImportDirective>>,\n \n-    // The external module children of this node that were declared with\n-    // `extern crate`.\n-    external_module_children: RefCell<HashMap<Name, Module<'a>>>,\n-\n     // The anonymous children of this node. Anonymous children are pseudo-\n     // modules that are implicitly created around items contained within\n     // blocks.\n@@ -854,9 +841,9 @@ impl<'a> ModuleS<'a> {\n             parent_link: parent_link,\n             def: Cell::new(def),\n             is_public: is_public,\n+            is_extern_crate: false,\n             children: RefCell::new(HashMap::new()),\n             imports: RefCell::new(Vec::new()),\n-            external_module_children: RefCell::new(HashMap::new()),\n             anonymous_children: RefCell::new(NodeMap()),\n             import_resolutions: RefCell::new(HashMap::new()),\n             glob_count: Cell::new(0),\n@@ -871,10 +858,21 @@ impl<'a> ModuleS<'a> {\n         self.children.borrow().get(&(name, ns)).cloned()\n     }\n \n-    fn try_define_child(&self, name: Name, ns: Namespace, binding: NameBinding<'a>) -> bool {\n+    // If the name is not yet defined, define the name and return None.\n+    // Otherwise, return the existing definition.\n+    fn try_define_child(&self, name: Name, ns: Namespace, binding: NameBinding<'a>)\n+                        -> Option<NameBinding<'a>> {\n         match self.children.borrow_mut().entry((name, ns)) {\n-            hash_map::Entry::Vacant(entry) => { entry.insert(binding); true }\n-            hash_map::Entry::Occupied(_) => false,\n+            hash_map::Entry::Vacant(entry) => { entry.insert(binding); None }\n+            hash_map::Entry::Occupied(entry) => { Some(entry.get().clone()) },\n+        }\n+    }\n+\n+    fn for_each_local_child<F: FnMut(Name, Namespace, &NameBinding<'a>)>(&self, mut f: F) {\n+        for (&(name, ns), name_binding) in self.children.borrow().iter() {\n+            if !name_binding.is_extern_crate() {\n+                f(name, ns, name_binding)\n+            }\n         }\n     }\n \n@@ -1005,6 +1003,10 @@ impl<'a> NameBinding<'a> {\n         let def = self.def().unwrap();\n         (def, LastMod(if self.is_public() { AllPublic } else { DependsOn(def.def_id()) }))\n     }\n+\n+    fn is_extern_crate(&self) -> bool {\n+        self.module().map(|module| module.is_extern_crate).unwrap_or(false)\n+    }\n }\n \n /// Interns the names of the primitive types.\n@@ -1184,6 +1186,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         self.arenas.modules.alloc(ModuleS::new(parent_link, def, external, is_public))\n     }\n \n+    fn new_extern_crate_module(&self, parent_link: ParentLink<'a>, def: Def) -> Module<'a> {\n+        let mut module = ModuleS::new(parent_link, Some(def), false, true);\n+        module.is_extern_crate = true;\n+        self.arenas.modules.alloc(module)\n+    }\n+\n     fn get_ribs<'b>(&'b mut self, ns: Namespace) -> &'b mut Vec<Rib<'a>> {\n         match ns { ValueNS => &mut self.value_ribs, TypeNS => &mut self.type_ribs }\n     }\n@@ -1211,32 +1219,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n     }\n \n-    /// Check that an external crate doesn't collide with items or other external crates.\n-    fn check_for_conflicts_for_external_crate(&self, module: Module<'a>, name: Name, span: Span) {\n-        if module.external_module_children.borrow().contains_key(&name) {\n-            span_err!(self.session,\n-                      span,\n-                      E0259,\n-                      \"an external crate named `{}` has already been imported into this module\",\n-                      name);\n-        }\n-        if let Some(name_binding) = module.get_child(name, TypeNS) {\n-            resolve_error(self,\n-                          name_binding.span.unwrap_or(codemap::DUMMY_SP),\n-                          ResolutionError::NameConflictsWithExternCrate(name));\n-        }\n-    }\n-\n-    /// Checks that the names of items don't collide with external crates.\n-    fn check_for_conflicts_between_external_crates_and_items(&self,\n-                                                             module: Module<'a>,\n-                                                             name: Name,\n-                                                             span: Span) {\n-        if module.external_module_children.borrow().contains_key(&name) {\n-            resolve_error(self, span, ResolutionError::NameConflictsWithExternCrate(name));\n-        }\n-    }\n-\n     /// Resolves the given module path from the given root `module_`.\n     fn resolve_module_path_from_root(&mut self,\n                                      module_: Module<'a>,\n@@ -1245,11 +1227,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                      span: Span,\n                                      lp: LastPrivate)\n                                      -> ResolveResult<(Module<'a>, LastPrivate)> {\n-        fn search_parent_externals<'a>(needle: Name, module: Module<'a>)\n-                                       -> Option<Module<'a>> {\n-            match module.external_module_children.borrow().get(&needle) {\n-                Some(_) => Some(module),\n-                None => match module.parent_link {\n+        fn search_parent_externals<'a>(needle: Name, module: Module<'a>) -> Option<Module<'a>> {\n+            match module.get_child(needle, TypeNS) {\n+                Some(ref binding) if binding.is_extern_crate() => Some(module),\n+                _ => match module.parent_link {\n                     ModuleParentLink(ref parent, _) => {\n                         search_parent_externals(needle, parent)\n                     }\n@@ -1480,17 +1461,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n         }\n \n-        // Search for external modules.\n-        if namespace == TypeNS {\n-            let children = module_.external_module_children.borrow();\n-            if let Some(module) = children.get(&name) {\n-                let name_binding = NameBinding::create_from_module(module, None);\n-                debug!(\"lower name bindings succeeded\");\n-                return Success((Target::new(module_, name_binding, Shadowable::Never),\n-                                false));\n-            }\n-        }\n-\n         // Finally, proceed up the scope chain looking for parent modules.\n         let mut search_module = module_;\n         loop {\n@@ -1684,16 +1654,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             Some(..) | None => {} // Continue.\n         }\n \n-        // Finally, search through external children.\n-        if namespace == TypeNS {\n-            let children = module_.external_module_children.borrow();\n-            if let Some(module) = children.get(&name) {\n-                let name_binding = NameBinding::create_from_module(module, None);\n-                return Success((Target::new(module_, name_binding, Shadowable::Never),\n-                                false));\n-            }\n-        }\n-\n         // We're out of luck.\n         debug!(\"(resolving name in module) failed to resolve `{}`\", name);\n         return Failed(None);\n@@ -1712,7 +1672,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         // Descend into children and anonymous children.\n         build_reduced_graph::populate_module_if_necessary(self, &module_);\n \n-        for (_, child_node) in module_.children.borrow().iter() {\n+        module_.for_each_local_child(|_, _, child_node| {\n             match child_node.module() {\n                 None => {\n                     // Continue.\n@@ -1721,7 +1681,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     self.report_unresolved_imports(child_module);\n                 }\n             }\n-        }\n+        });\n \n         for (_, module_) in module_.anonymous_children.borrow().iter() {\n             self.report_unresolved_imports(module_);"}, {"sha": "47b91ccb9d6f9497c8ec0e87f37914211f350dd3", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 17, "deletions": 32, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/66eb5884760eb069dae6df0b7993110b5614f595/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66eb5884760eb069dae6df0b7993110b5614f595/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=66eb5884760eb069dae6df0b7993110b5614f595", "patch": "@@ -213,7 +213,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         self.resolver.current_module = orig_module;\n \n         build_reduced_graph::populate_module_if_necessary(self.resolver, &module_);\n-        for (_, child_node) in module_.children.borrow().iter() {\n+        module_.for_each_local_child(|_, _, child_node| {\n             match child_node.module() {\n                 None => {\n                     // Nothing to do.\n@@ -222,7 +222,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                     errors.extend(self.resolve_imports_for_module_subtree(child_module));\n                 }\n             }\n-        }\n+        });\n \n         for (_, child_module) in module_.anonymous_children.borrow().iter() {\n             errors.extend(self.resolve_imports_for_module_subtree(child_module));\n@@ -386,18 +386,13 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                               -> (ResolveResult<(Module<'b>, NameBinding<'b>)>, bool) {\n         build_reduced_graph::populate_module_if_necessary(self.resolver, module);\n         if let Some(name_binding) = module.get_child(name, ns) {\n-            return (Success((module, name_binding)), false);\n-        }\n-\n-        if ns == TypeNS {\n-            if let Some(extern_crate) = module.external_module_children.borrow().get(&name) {\n+            if name_binding.is_extern_crate() {\n                 // track the extern crate as used.\n-                if let Some(DefId{ krate: kid, .. }) = extern_crate.def_id() {\n-                    self.resolver.used_crates.insert(kid);\n+                if let Some(DefId { krate, .. }) = name_binding.module().unwrap().def_id() {\n+                    self.resolver.used_crates.insert(krate);\n                 }\n-                let name_binding = NameBinding::create_from_module(extern_crate, None);\n-                return (Success((module, name_binding)), false);\n             }\n+            return (Success((module, name_binding)), false)\n         }\n \n         // If there is an unresolved glob at this point in the containing module, bail out.\n@@ -725,13 +720,13 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         // Add all children from the containing module.\n         build_reduced_graph::populate_module_if_necessary(self.resolver, &target_module);\n \n-        for (&name, name_binding) in target_module.children.borrow().iter() {\n+        target_module.for_each_local_child(|name, ns, name_binding| {\n             self.merge_import_resolution(module_,\n                                          target_module,\n                                          import_directive,\n-                                         name,\n+                                         (name, ns),\n                                          name_binding.clone());\n-        }\n+        });\n \n         // Record the destination of this import\n         if let Some(did) = target_module.def_id() {\n@@ -798,9 +793,6 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                 dest_import_resolution.is_public = is_public;\n                 self.add_export(module_, name, &dest_import_resolution);\n             }\n-        } else {\n-            // FIXME #30159: This is required for backwards compatability.\n-            dest_import_resolution.is_public |= is_public;\n         }\n \n         self.check_for_conflicts_between_imports_and_items(module_,\n@@ -881,21 +873,6 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                                      import: &ImportResolution<'b>,\n                                                      import_span: Span,\n                                                      (name, ns): (Name, Namespace)) {\n-        // First, check for conflicts between imports and `extern crate`s.\n-        if ns == TypeNS {\n-            if module.external_module_children.borrow().contains_key(&name) {\n-                match import.target {\n-                    Some(ref target) if target.shadowable != Shadowable::Always => {\n-                        let msg = format!(\"import `{0}` conflicts with imported crate \\\n-                                           in this module (maybe you meant `use {0}::*`?)\",\n-                                          name);\n-                        span_err!(self.resolver.session, import_span, E0254, \"{}\", &msg[..]);\n-                    }\n-                    Some(_) | None => {}\n-                }\n-            }\n-        }\n-\n         // Check for item conflicts.\n         let name_binding = match module.get_child(name, ns) {\n             None => {\n@@ -924,6 +901,14 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         } else {\n             match import.target {\n                 Some(ref target) if target.shadowable != Shadowable::Always => {\n+                    if name_binding.is_extern_crate() {\n+                        let msg = format!(\"import `{0}` conflicts with imported crate \\\n+                                           in this module (maybe you meant `use {0}::*`?)\",\n+                                          name);\n+                        span_err!(self.resolver.session, import_span, E0254, \"{}\", &msg[..]);\n+                        return;\n+                    }\n+\n                     let (what, note) = match name_binding.module() {\n                         Some(ref module) if module.is_normal() =>\n                             (\"existing submodule\", \"note conflicting module here\"),"}, {"sha": "f811eb872fcda1dbb1f0ffe506e1792f8dcf576a", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/66eb5884760eb069dae6df0b7993110b5614f595/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66eb5884760eb069dae6df0b7993110b5614f595/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=66eb5884760eb069dae6df0b7993110b5614f595", "patch": "@@ -4250,14 +4250,9 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     let def_id = ccx.tcx.map.local_def_id(id);\n     let hint = *ccx.tcx.lookup_repr_hints(def_id).get(0).unwrap_or(&attr::ReprAny);\n \n-    if hint != attr::ReprAny && vs.len() <= 1 {\n-        if vs.len() == 1 {\n-            span_err!(ccx.tcx.sess, sp, E0083,\n-                \"unsupported representation for univariant enum\");\n-        } else {\n-            span_err!(ccx.tcx.sess, sp, E0084,\n-                \"unsupported representation for zero-variant enum\");\n-        };\n+    if hint != attr::ReprAny && vs.is_empty() {\n+        span_err!(ccx.tcx.sess, sp, E0084,\n+            \"unsupported representation for zero-variant enum\");\n     }\n \n     do_check(ccx, vs, id, hint);"}, {"sha": "df09cd261344e4f3907dd8fa6695ee339a5deb93", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/66eb5884760eb069dae6df0b7993110b5614f595/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66eb5884760eb069dae6df0b7993110b5614f595/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=66eb5884760eb069dae6df0b7993110b5614f595", "patch": "@@ -1062,13 +1062,6 @@ Note also that without a representation manually defined, the compiler will\n optimize by using the smallest integer type possible.\n \"##,\n \n-E0083: r##\"\n-At present, it's not possible to define a custom representation for an enum with\n-a single variant. As a workaround you can add a `Dummy` variant.\n-\n-See: https://github.com/rust-lang/rust/issues/10292\n-\"##,\n-\n E0084: r##\"\n It is impossible to define an integer type to be used to represent zero-variant\n enum values because there are no zero-variant enum values. There is no way to"}, {"sha": "03dc25e1b3c2bd3617cb8e0449dd39a6f055397f", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66eb5884760eb069dae6df0b7993110b5614f595/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66eb5884760eb069dae6df0b7993110b5614f595/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=66eb5884760eb069dae6df0b7993110b5614f595", "patch": "@@ -356,7 +356,7 @@ pub fn pat_is_ident(pat: P<ast::Pat>) -> bool {\n // since I'm using this to replace ==, it seems appropriate\n // to compare the span, global, etc. fields as well.\n pub fn path_name_eq(a : &ast::Path, b : &ast::Path) -> bool {\n-    (a.span == b.span)\n+    (a.span.source_equal(&b.span))\n     && (a.global == b.global)\n     && (segments_name_eq(&a.segments[..], &b.segments[..]))\n }"}, {"sha": "9557310f318e9b4f3ef4cc9d04126c408a77eec3", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/66eb5884760eb069dae6df0b7993110b5614f595/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66eb5884760eb069dae6df0b7993110b5614f595/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=66eb5884760eb069dae6df0b7993110b5614f595", "patch": "@@ -123,7 +123,7 @@ impl Sub for CharPos {\n /// able to use many of the functions on spans in codemap and you cannot assume\n /// that the length of the span = hi - lo; there may be space in the BytePos\n /// range between files.\n-#[derive(Clone, Copy, Hash)]\n+#[derive(Clone, Copy, Hash, PartialEq, Eq)]\n pub struct Span {\n     pub lo: BytePos,\n     pub hi: BytePos,\n@@ -151,13 +151,21 @@ pub const COMMAND_LINE_SP: Span = Span { lo: BytePos(0),\n impl Span {\n     /// Returns `self` if `self` is not the dummy span, and `other` otherwise.\n     pub fn substitute_dummy(self, other: Span) -> Span {\n-        if self == DUMMY_SP { other } else { self }\n+        if self.source_equal(&DUMMY_SP) { other } else { self }\n     }\n \n     pub fn contains(self, other: Span) -> bool {\n         self.lo <= other.lo && other.hi <= self.hi\n     }\n \n+    /// Return true if the spans are equal with regards to the source text.\n+    ///\n+    /// Use this instead of `==` when either span could be generated code,\n+    /// and you only care that they point to the same bytes of source text.\n+    pub fn source_equal(&self, other: &Span) -> bool {\n+        self.lo == other.lo && self.hi == other.hi\n+    }\n+\n     /// Returns `Some(span)`, a union of `self` and `other`, on overlap.\n     pub fn merge(self, other: Span) -> Option<Span> {\n         if self.expn_id != other.expn_id {\n@@ -192,15 +200,6 @@ pub struct Spanned<T> {\n     pub span: Span,\n }\n \n-impl PartialEq for Span {\n-    fn eq(&self, other: &Span) -> bool {\n-        return (*self).lo == (*other).lo && (*self).hi == (*other).hi;\n-    }\n-    fn ne(&self, other: &Span) -> bool { !(*self).eq(other) }\n-}\n-\n-impl Eq for Span {}\n-\n impl Encodable for Span {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_struct(\"Span\", 2, |s| {\n@@ -940,7 +939,7 @@ impl CodeMap {\n     }\n \n     pub fn span_to_string(&self, sp: Span) -> String {\n-        if self.files.borrow().is_empty() && sp == DUMMY_SP {\n+        if self.files.borrow().is_empty() && sp.source_equal(&DUMMY_SP) {\n             return \"no-location\".to_string();\n         }\n \n@@ -1307,7 +1306,7 @@ impl CodeMap {\n                 expninfo.map_or(/* hit the top level */ true, |info| {\n \n                     let span_comes_from_this_expansion =\n-                        info.callee.span.map_or(span == info.call_site, |mac_span| {\n+                        info.callee.span.map_or(span.source_equal(&info.call_site), |mac_span| {\n                             mac_span.contains(span)\n                         });\n "}, {"sha": "7e0e17423de8c36ae782e09a1a6aca67989b2ce8", "filename": "src/libsyntax/errors/emitter.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/66eb5884760eb069dae6df0b7993110b5614f595/src%2Flibsyntax%2Ferrors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66eb5884760eb069dae6df0b7993110b5614f595/src%2Flibsyntax%2Ferrors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ferrors%2Femitter.rs?ref=66eb5884760eb069dae6df0b7993110b5614f595", "patch": "@@ -10,7 +10,7 @@\n \n use self::Destination::*;\n \n-use codemap::{self, COMMAND_LINE_SP, COMMAND_LINE_EXPN, DUMMY_SP, Pos, Span, MultiSpan};\n+use codemap::{self, COMMAND_LINE_SP, DUMMY_SP, Pos, Span, MultiSpan};\n use diagnostics;\n \n use errors::{Level, RenderSpan, CodeSuggestion, DiagnosticBuilder};\n@@ -175,9 +175,7 @@ impl EmitterWriter {\n         let msp = rsp.span();\n         let bounds = msp.to_span_bounds();\n \n-        // We cannot check equality directly with COMMAND_LINE_SP\n-        // since PartialEq is manually implemented to ignore the ExpnId\n-        let ss = if bounds.expn_id == COMMAND_LINE_EXPN {\n+        let ss = if bounds == COMMAND_LINE_SP {\n             \"<command line option>\".to_string()\n         } else if let EndSpan(_) = *rsp {\n             let span_end = Span { lo: bounds.hi, hi: bounds.hi, expn_id: bounds.expn_id};\n@@ -606,7 +604,7 @@ impl EmitterWriter {\n             };\n \n             // Don't print recursive invocations\n-            if span != last_span {\n+            if !span.source_equal(&last_span) {\n                 let mut diag_string = macro_decl_name;\n                 if let Some(def_site_span) = def_site_span {\n                     diag_string.push_str(&format!(\" (defined in {})\","}, {"sha": "07f80cf03d1dadf086ce798de5ba756d336bd5bf", "filename": "src/test/compile-fail/resolve-conflict-item-vs-extern-crate.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/66eb5884760eb069dae6df0b7993110b5614f595/src%2Ftest%2Fcompile-fail%2Fresolve-conflict-item-vs-extern-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66eb5884760eb069dae6df0b7993110b5614f595/src%2Ftest%2Fcompile-fail%2Fresolve-conflict-item-vs-extern-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fresolve-conflict-item-vs-extern-crate.rs?ref=66eb5884760eb069dae6df0b7993110b5614f595", "patch": "@@ -8,7 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn std() {}    //~ ERROR the name `std` conflicts with an external crate\n+fn std() {}\n+mod std {}    //~ ERROR the name `std` conflicts with an external crate\n \n fn main() {\n }"}, {"sha": "1bf7f3933849de76ba2307357ba574ebc776b90c", "filename": "src/test/compile-fail/shadowed-use-visibility.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66eb5884760eb069dae6df0b7993110b5614f595/src%2Ftest%2Fcompile-fail%2Fshadowed-use-visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66eb5884760eb069dae6df0b7993110b5614f595/src%2Ftest%2Fcompile-fail%2Fshadowed-use-visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fshadowed-use-visibility.rs?ref=66eb5884760eb069dae6df0b7993110b5614f595", "patch": "@@ -17,6 +17,10 @@ mod foo {\n \n mod bar {\n     use foo::bar::f as g; //~ ERROR unresolved import\n+\n+    use foo as f;\n+    pub use foo::*;\n }\n \n+use bar::f::f; //~ ERROR unresolved import\n fn main() {}"}, {"sha": "ef4cc60bf0da1fc62fa7ab98a7bab098e6798c2a", "filename": "src/test/run-pass/enum-univariant-repr.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/66eb5884760eb069dae6df0b7993110b5614f595/src%2Ftest%2Frun-pass%2Fenum-univariant-repr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66eb5884760eb069dae6df0b7993110b5614f595/src%2Ftest%2Frun-pass%2Fenum-univariant-repr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenum-univariant-repr.rs?ref=66eb5884760eb069dae6df0b7993110b5614f595", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+use std::mem;\n+\n+// Univariant C-like enum\n+#[repr(i32)]\n+enum Univariant {\n+    X = 17\n+}\n+\n+#[repr(u16)]\n+enum UnivariantWithoutDescr {\n+    Y\n+}\n+\n+pub fn main() {\n+    {\n+        assert_eq!(4, mem::size_of::<Univariant>());\n+        assert_eq!(17, Univariant::X as i32);\n+\n+        let enums: &[Univariant] =\n+            &[Univariant::X, Univariant::X, Univariant::X];\n+        let ints: &[i32] = unsafe { mem::transmute(enums) };\n+        // check it has the same memory layout as i32\n+        assert_eq!(&[17, 17, 17], ints);\n+    }\n+\n+    {\n+        assert_eq!(2, mem::size_of::<UnivariantWithoutDescr>());\n+        let descr = UnivariantWithoutDescr::Y as u16;\n+\n+        let enums: &[UnivariantWithoutDescr] =\n+            &[UnivariantWithoutDescr::Y, UnivariantWithoutDescr::Y, UnivariantWithoutDescr::Y];\n+        let ints: &[u16] = unsafe { mem::transmute(enums) };\n+        // check it has the same memory layout as u16\n+        assert_eq!(&[descr, descr, descr], ints);\n+    }\n+}"}]}