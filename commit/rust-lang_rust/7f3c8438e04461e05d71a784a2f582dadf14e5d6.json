{"sha": "7f3c8438e04461e05d71a784a2f582dadf14e5d6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmM2M4NDM4ZTA0NDYxZTA1ZDcxYTc4NGEyZjU4MmRhZGYxNGU1ZDY=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2019-10-11T01:33:16Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2019-10-25T22:26:27Z"}, "message": "Refactor check_attr", "tree": {"sha": "a4b1915c6b262114522b03a32d3cd524160a977a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a4b1915c6b262114522b03a32d3cd524160a977a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f3c8438e04461e05d71a784a2f582dadf14e5d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f3c8438e04461e05d71a784a2f582dadf14e5d6", "html_url": "https://github.com/rust-lang/rust/commit/7f3c8438e04461e05d71a784a2f582dadf14e5d6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f3c8438e04461e05d71a784a2f582dadf14e5d6/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "23f890f10202a71168c6424da0cdf94135d3c40c", "url": "https://api.github.com/repos/rust-lang/rust/commits/23f890f10202a71168c6424da0cdf94135d3c40c", "html_url": "https://github.com/rust-lang/rust/commit/23f890f10202a71168c6424da0cdf94135d3c40c"}], "stats": {"total": 138, "additions": 75, "deletions": 63}, "files": [{"sha": "ee5318153dadff9b24838e1865ad4f33d0685b19", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 75, "deletions": 63, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/7f3c8438e04461e05d71a784a2f582dadf14e5d6/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f3c8438e04461e05d71a784a2f582dadf14e5d6/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=7f3c8438e04461e05d71a784a2f582dadf14e5d6", "patch": "@@ -4,7 +4,8 @@\n //! conflicts between multiple such attributes attached to the same\n //! item.\n \n-use crate::hir;\n+use crate::hir::{self, HirId, HirVec, Attribute, Item, ItemKind, TraitItem, TraitItemKind};\n+use crate::hir::DUMMY_HIR_ID;\n use crate::hir::def_id::DefId;\n use crate::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use crate::ty::TyCtxt;\n@@ -64,24 +65,26 @@ impl Display for Target {\n }\n \n impl Target {\n-    pub(crate) fn from_item(item: &hir::Item) -> Target {\n+    pub(crate) fn from_item(item: &Item) -> Target {\n         match item.kind {\n-            hir::ItemKind::ExternCrate(..) => Target::ExternCrate,\n-            hir::ItemKind::Use(..) => Target::Use,\n-            hir::ItemKind::Static(..) => Target::Static,\n-            hir::ItemKind::Const(..) => Target::Const,\n-            hir::ItemKind::Fn(..) => Target::Fn,\n-            hir::ItemKind::Mod(..) => Target::Mod,\n-            hir::ItemKind::ForeignMod(..) => Target::ForeignMod,\n-            hir::ItemKind::GlobalAsm(..) => Target::GlobalAsm,\n-            hir::ItemKind::TyAlias(..) => Target::TyAlias,\n-            hir::ItemKind::OpaqueTy(..) => Target::OpaqueTy,\n-            hir::ItemKind::Enum(..) => Target::Enum,\n-            hir::ItemKind::Struct(..) => Target::Struct,\n-            hir::ItemKind::Union(..) => Target::Union,\n-            hir::ItemKind::Trait(..) => Target::Trait,\n-            hir::ItemKind::TraitAlias(..) => Target::TraitAlias,\n-            hir::ItemKind::Impl(..) => Target::Impl,\n+            ItemKind::ExternCrate(..) => Target::ExternCrate,\n+            ItemKind::Use(..) => Target::Use,\n+            ItemKind::Static(..) => Target::Static,\n+            ItemKind::Const(..) => Target::Const,\n+            ItemKind::Fn(..) => Target::Fn,\n+            ItemKind::Mod(..) => Target::Mod,\n+            ItemKind::ForeignMod(..) => Target::ForeignMod,\n+            ItemKind::GlobalAsm(..) => Target::GlobalAsm,\n+            ItemKind::TyAlias(..) => Target::TyAlias,\n+            ItemKind::OpaqueTy(..) => Target::OpaqueTy,\n+            ItemKind::Enum(..) => Target::Enum,\n+            ItemKind::Struct(..) => Target::Struct,\n+            ItemKind::Union(..) => Target::Union,\n+            ItemKind::Trait(..) => Target::Trait,\n+            ItemKind::TraitAlias(..) => Target::TraitAlias,\n+            ItemKind::Impl(..) => Target::Impl,\n+        }\n+    }\n         }\n     }\n }\n@@ -92,17 +95,24 @@ struct CheckAttrVisitor<'tcx> {\n \n impl CheckAttrVisitor<'tcx> {\n     /// Checks any attribute.\n-    fn check_attributes(&self, item: &hir::Item, target: Target) {\n+    fn check_attributes(\n+        &self,\n+        hir_id: HirId,\n+        attrs: &HirVec<Attribute>,\n+        span: &Span,\n+        target: Target,\n+        item: Option<&Item>,\n+    ) {\n         let mut is_valid = true;\n-        for attr in &item.attrs {\n+        for attr in attrs {\n             is_valid &= if attr.check_name(sym::inline) {\n-                self.check_inline(attr, &item.span, target)\n+                self.check_inline(hir_id, attr, span, target)\n             } else if attr.check_name(sym::non_exhaustive) {\n-                self.check_non_exhaustive(attr, item, target)\n+                self.check_non_exhaustive(attr, span, target)\n             } else if attr.check_name(sym::marker) {\n-                self.check_marker(attr, item, target)\n+                self.check_marker(attr, span, target)\n             } else if attr.check_name(sym::target_feature) {\n-                self.check_target_feature(attr, item, target)\n+                self.check_target_feature(attr, span, target)\n             } else if attr.check_name(sym::track_caller) {\n                 self.check_track_caller(attr, &item, target)\n             } else {\n@@ -115,25 +125,26 @@ impl CheckAttrVisitor<'tcx> {\n         }\n \n         if target == Target::Fn {\n-            self.tcx.codegen_fn_attrs(self.tcx.hir().local_def_id(item.hir_id));\n+            self.tcx.codegen_fn_attrs(self.tcx.hir().local_def_id(hir_id));\n         }\n \n-        self.check_repr(item, target);\n-        self.check_used(item, target);\n+        self.check_repr(attrs, span, target, item);\n+        self.check_used(attrs, target);\n     }\n \n     /// Checks if an `#[inline]` is applied to a function or a closure. Returns `true` if valid.\n-    fn check_inline(&self, attr: &hir::Attribute, span: &Span, target: Target) -> bool {\n-        if target != Target::Fn && target != Target::Closure {\n-            struct_span_err!(self.tcx.sess,\n-                             attr.span,\n-                             E0518,\n-                             \"attribute should be applied to function or closure\")\n-                .span_label(*span, \"not a function or closure\")\n-                .emit();\n-            false\n-        } else {\n-            true\n+    fn check_inline(&self, hir_id: HirId, attr: &Attribute, span: &Span, target: Target) -> bool {\n+        match target {\n+            Target::Fn | Target::Closure | Target::Method { body: true } => true,\n+            _ => {\n+                struct_span_err!(self.tcx.sess,\n+                                 attr.span,\n+                                 E0518,\n+                                 \"attribute should be applied to function or closure\")\n+                    .span_label(*span, \"not a function or closure\")\n+                    .emit();\n+                false\n+            }\n         }\n     }\n \n@@ -166,8 +177,8 @@ impl CheckAttrVisitor<'tcx> {\n     /// Checks if the `#[non_exhaustive]` attribute on an `item` is valid. Returns `true` if valid.\n     fn check_non_exhaustive(\n         &self,\n-        attr: &hir::Attribute,\n-        item: &hir::Item,\n+        attr: &Attribute,\n+        span: &Span,\n         target: Target,\n     ) -> bool {\n         match target {\n@@ -177,54 +188,55 @@ impl CheckAttrVisitor<'tcx> {\n                                  attr.span,\n                                  E0701,\n                                  \"attribute can only be applied to a struct or enum\")\n-                    .span_label(item.span, \"not a struct or enum\")\n+                    .span_label(*span, \"not a struct or enum\")\n                     .emit();\n                 false\n             }\n         }\n     }\n \n     /// Checks if the `#[marker]` attribute on an `item` is valid. Returns `true` if valid.\n-    fn check_marker(&self, attr: &hir::Attribute, item: &hir::Item, target: Target) -> bool {\n+    fn check_marker(&self, attr: &Attribute, span: &Span, target: Target) -> bool {\n         match target {\n             Target::Trait => true,\n             _ => {\n                 self.tcx.sess\n                     .struct_span_err(attr.span, \"attribute can only be applied to a trait\")\n-                    .span_label(item.span, \"not a trait\")\n+                    .span_label(*span, \"not a trait\")\n                     .emit();\n                 false\n             }\n         }\n     }\n \n     /// Checks if the `#[target_feature]` attribute on `item` is valid. Returns `true` if valid.\n-    fn check_target_feature(\n-        &self,\n-        attr: &hir::Attribute,\n-        item: &hir::Item,\n-        target: Target,\n-    ) -> bool {\n+    fn check_target_feature(&self, attr: &Attribute, span: &Span, target: Target) -> bool {\n         match target {\n             Target::Fn => true,\n             _ => {\n                 self.tcx.sess\n                     .struct_span_err(attr.span, \"attribute should be applied to a function\")\n-                    .span_label(item.span, \"not a function\")\n+                    .span_label(*span, \"not a function\")\n                     .emit();\n                 false\n             },\n         }\n     }\n \n     /// Checks if the `#[repr]` attributes on `item` are valid.\n-    fn check_repr(&self, item: &hir::Item, target: Target) {\n+    fn check_repr(\n+        &self,\n+        attrs: &HirVec<Attribute>,\n+        span: &Span,\n+        target: Target,\n+        item: Option<&Item>,\n+    ) {\n         // Extract the names of all repr hints, e.g., [foo, bar, align] for:\n         // ```\n         // #[repr(foo)]\n         // #[repr(bar, align(8))]\n         // ```\n-        let hints: Vec<_> = item.attrs\n+        let hints: Vec<_> = attrs\n             .iter()\n             .filter(|attr| attr.check_name(sym::repr))\n             .filter_map(|attr| attr.meta_item_list())\n@@ -282,7 +294,7 @@ impl CheckAttrVisitor<'tcx> {\n             };\n             self.emit_repr_error(\n                 hint.span(),\n-                item.span,\n+                *span,\n                 &format!(\"attribute should be applied to {}\", allowed_targets),\n                 &format!(\"not {} {}\", article, allowed_targets),\n             )\n@@ -301,7 +313,7 @@ impl CheckAttrVisitor<'tcx> {\n         // Warn on repr(u8, u16), repr(C, simd), and c-like-enum-repr(C, u8)\n         if (int_reprs > 1)\n            || (is_simd && is_c)\n-           || (int_reprs == 1 && is_c && is_c_like_enum(item)) {\n+           || (int_reprs == 1 && is_c && item.map(|item| is_c_like_enum(item)).unwrap_or(false)) {\n             let hint_spans: Vec<_> = hint_spans.collect();\n             span_warn!(self.tcx.sess, hint_spans, E0566,\n                        \"conflicting representation hints\");\n@@ -325,7 +337,7 @@ impl CheckAttrVisitor<'tcx> {\n         if let hir::StmtKind::Local(ref l) = stmt.kind {\n             for attr in l.attrs.iter() {\n                 if attr.check_name(sym::inline) {\n-                    self.check_inline(attr, &stmt.span, Target::Statement);\n+                    self.check_inline(DUMMY_HIR_ID, attr, &stmt.span, Target::Statement);\n                 }\n                 if attr.check_name(sym::repr) {\n                     self.emit_repr_error(\n@@ -346,7 +358,7 @@ impl CheckAttrVisitor<'tcx> {\n         };\n         for attr in expr.attrs.iter() {\n             if attr.check_name(sym::inline) {\n-                self.check_inline(attr, &expr.span, target);\n+                self.check_inline(DUMMY_HIR_ID, attr, &expr.span, target);\n             }\n             if attr.check_name(sym::repr) {\n                 self.emit_repr_error(\n@@ -359,8 +371,8 @@ impl CheckAttrVisitor<'tcx> {\n         }\n     }\n \n-    fn check_used(&self, item: &hir::Item, target: Target) {\n-        for attr in &item.attrs {\n+    fn check_used(&self, attrs: &HirVec<Attribute>, target: Target) {\n+        for attr in attrs {\n             if attr.check_name(sym::used) && target != Target::Static {\n                 self.tcx.sess\n                     .span_err(attr.span, \"attribute must be applied to a `static` variable\");\n@@ -374,9 +386,9 @@ impl Visitor<'tcx> for CheckAttrVisitor<'tcx> {\n         NestedVisitorMap::OnlyBodies(&self.tcx.hir())\n     }\n \n-    fn visit_item(&mut self, item: &'tcx hir::Item) {\n+    fn visit_item(&mut self, item: &'tcx Item) {\n         let target = Target::from_item(item);\n-        self.check_attributes(item, target);\n+        self.check_attributes(item.hir_id, &item.attrs, &item.span, target, Some(item));\n         intravisit::walk_item(self, item)\n     }\n \n@@ -392,12 +404,12 @@ impl Visitor<'tcx> for CheckAttrVisitor<'tcx> {\n     }\n }\n \n-fn is_c_like_enum(item: &hir::Item) -> bool {\n-    if let hir::ItemKind::Enum(ref def, _) = item.kind {\n+fn is_c_like_enum(item: &Item) -> bool {\n+    if let ItemKind::Enum(ref def, _) = item.kind {\n         for variant in &def.variants {\n             match variant.data {\n                 hir::VariantData::Unit(..) => { /* continue */ }\n-                _ => { return false; }\n+                _ => return false,\n             }\n         }\n         true"}]}