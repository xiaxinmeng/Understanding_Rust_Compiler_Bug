{"sha": "e5d482eecaa51a3a4836c550c2e36e93f543e576", "node_id": "C_kwDOAAsO6NoAKGU1ZDQ4MmVlY2FhNTFhM2E0ODM2YzU1MGMyZTM2ZTkzZjU0M2U1NzY", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-07-15T14:40:41Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-03-31T11:47:56Z"}, "message": "Create a new LoweringContext for each item-like.", "tree": {"sha": "4c50b0a70a1fd475896144273fba2f48fa6d3682", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4c50b0a70a1fd475896144273fba2f48fa6d3682"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e5d482eecaa51a3a4836c550c2e36e93f543e576", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e5d482eecaa51a3a4836c550c2e36e93f543e576", "html_url": "https://github.com/rust-lang/rust/commit/e5d482eecaa51a3a4836c550c2e36e93f543e576", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e5d482eecaa51a3a4836c550c2e36e93f543e576/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e4fb2038a23829e8b4fcf5522d7821ee8017a97", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e4fb2038a23829e8b4fcf5522d7821ee8017a97", "html_url": "https://github.com/rust-lang/rust/commit/6e4fb2038a23829e8b4fcf5522d7821ee8017a97"}], "stats": {"total": 233, "additions": 104, "deletions": 129}, "files": [{"sha": "fc374fdf333d90dc4804fb50df39562832e239ab", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 91, "deletions": 92, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/e5d482eecaa51a3a4836c550c2e36e93f543e576/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d482eecaa51a3a4836c550c2e36e93f543e576/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=e5d482eecaa51a3a4836c550c2e36e93f543e576", "patch": "@@ -1,16 +1,19 @@\n use super::{AnonymousLifetimeMode, LoweringContext, ParamMode};\n-use super::{AstOwner, ImplTraitContext, ImplTraitPosition};\n+use super::{AstOwner, ImplTraitContext, ImplTraitPosition, ResolverAstLowering};\n use crate::{Arena, FnDeclKind};\n \n use rustc_ast::ptr::P;\n use rustc_ast::visit::AssocCtxt;\n use rustc_ast::*;\n use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::sorted_map::SortedMap;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{LocalDefId, CRATE_DEF_ID};\n use rustc_index::vec::{Idx, IndexVec};\n+use rustc_session::utils::NtToTokenstream;\n+use rustc_session::Session;\n use rustc_span::source_map::{respan, DesugaringKind};\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::Span;\n@@ -19,11 +22,14 @@ use smallvec::{smallvec, SmallVec};\n use tracing::debug;\n \n use std::iter;\n-use std::mem;\n \n-pub(super) struct ItemLowerer<'a, 'lowering, 'hir> {\n-    pub(super) lctx: &'a mut LoweringContext<'lowering, 'hir>,\n-    pub(super) ast_index: &'a IndexVec<LocalDefId, AstOwner<'lowering>>,\n+pub(super) struct ItemLowerer<'a, 'hir> {\n+    pub(super) sess: &'a Session,\n+    pub(super) resolver: &'a mut dyn ResolverAstLowering,\n+    pub(super) nt_to_tokenstream: NtToTokenstream,\n+    pub(super) arena: &'hir Arena<'hir>,\n+    pub(super) ast_index: &'a IndexVec<LocalDefId, AstOwner<'a>>,\n+    pub(super) owners: &'a mut IndexVec<LocalDefId, hir::MaybeOwner<&'hir hir::OwnerInfo<'hir>>>,\n }\n \n /// When we have a ty alias we *may* have two where clauses. To give the best diagnostics, we set the span\n@@ -46,76 +52,50 @@ fn add_ty_alias_where_clause(\n     }\n }\n \n-impl<'a, 'hir> ItemLowerer<'_, 'a, 'hir> {\n-    /// Clears (and restores) the `in_scope_lifetimes` field. Used when\n-    /// visiting nested items, which never inherit in-scope lifetimes\n-    /// from their surrounding environment.\n-    #[tracing::instrument(level = \"debug\", skip(self, f))]\n-    fn without_in_scope_lifetime_defs<T>(&mut self, f: impl FnOnce(&mut Self) -> T) -> T {\n-        let old_in_scope_lifetimes = mem::take(&mut self.lctx.in_scope_lifetimes);\n-        debug!(?old_in_scope_lifetimes);\n-\n-        // this vector is only used when walking over impl headers,\n-        // input types, and the like, and should not be non-empty in\n-        // between items\n-        assert!(self.lctx.lifetimes_to_define.is_empty());\n-\n-        let res = f(self);\n-\n-        assert!(self.lctx.in_scope_lifetimes.is_empty());\n-        self.lctx.in_scope_lifetimes = old_in_scope_lifetimes;\n-\n-        res\n-    }\n-\n-    /// Evaluates `f` with the lifetimes in `params` in-scope.\n-    /// This is used to track which lifetimes have already been defined, and\n-    /// which are new in-band lifetimes that need to have a definition created\n-    /// for them.\n-    fn with_parent_item_lifetime_defs(\n-        &mut self,\n-        parent_hir: &'hir hir::Item<'hir>,\n-        f: impl FnOnce(&mut Self),\n-    ) {\n-        let parent_generics = match parent_hir.kind {\n-            hir::ItemKind::Impl(hir::Impl { ref generics, .. })\n-            | hir::ItemKind::Trait(_, _, ref generics, ..) => generics.params,\n-            _ => &[],\n-        };\n-        let lt_def_names = parent_generics\n-            .iter()\n-            .filter_map(|param| match param.kind {\n-                hir::GenericParamKind::Lifetime { .. } => {\n-                    Some(param.name.normalize_to_macros_2_0())\n-                }\n-                _ => None,\n-            })\n-            .collect();\n-        let old_in_scope_lifetimes = mem::replace(&mut self.lctx.in_scope_lifetimes, lt_def_names);\n-\n-        f(self);\n-\n-        self.lctx.in_scope_lifetimes = old_in_scope_lifetimes;\n-    }\n-\n-    fn with_trait_impl_ref(\n-        &mut self,\n-        impl_ref: &Option<hir::TraitRef<'_>>,\n-        f: impl FnOnce(&mut Self),\n-    ) {\n-        let old = self.lctx.is_in_trait_impl;\n-        self.lctx.is_in_trait_impl = impl_ref.is_some();\n-        let ret = f(self);\n-        self.lctx.is_in_trait_impl = old;\n-        ret\n+impl<'a, 'hir> ItemLowerer<'a, 'hir> {\n+    fn make_lctx(&mut self) -> LoweringContext<'_, 'hir> {\n+        LoweringContext {\n+            // Pseudo-globals.\n+            sess: &self.sess,\n+            resolver: self.resolver,\n+            nt_to_tokenstream: self.nt_to_tokenstream,\n+            arena: self.arena,\n+            owners: self.owners,\n+\n+            // HirId handling.\n+            bodies: Vec::new(),\n+            attrs: SortedMap::default(),\n+            current_hir_id_owner: CRATE_DEF_ID,\n+            item_local_id_counter: hir::ItemLocalId::new(0),\n+            node_id_to_local_id: Default::default(),\n+            local_id_to_def_id: SortedMap::new(),\n+            trait_map: Default::default(),\n+\n+            // Lowering state.\n+            catch_scope: None,\n+            loop_scope: None,\n+            is_in_loop_condition: false,\n+            is_in_trait_impl: false,\n+            is_in_dyn_type: false,\n+            anonymous_lifetime_mode: AnonymousLifetimeMode::PassThrough,\n+            generator_kind: None,\n+            task_context: None,\n+            current_item: None,\n+            lifetimes_to_define: Vec::new(),\n+            is_collecting_anonymous_lifetimes: None,\n+            in_scope_lifetimes: Vec::new(),\n+            allow_try_trait: Some([sym::try_trait_v2][..].into()),\n+            allow_gen_future: Some([sym::gen_future][..].into()),\n+            allow_into_future: Some([sym::into_future][..].into()),\n+        }\n     }\n \n     pub(super) fn lower_node(\n         &mut self,\n         def_id: LocalDefId,\n     ) -> hir::MaybeOwner<&'hir hir::OwnerInfo<'hir>> {\n-        self.lctx.owners.ensure_contains_elem(def_id, || hir::MaybeOwner::Phantom);\n-        if let hir::MaybeOwner::Phantom = self.lctx.owners[def_id] {\n+        self.owners.ensure_contains_elem(def_id, || hir::MaybeOwner::Phantom);\n+        if let hir::MaybeOwner::Phantom = self.owners[def_id] {\n             let node = self.ast_index[def_id];\n             match node {\n                 AstOwner::NonOwner => {}\n@@ -126,53 +106,72 @@ impl<'a, 'hir> ItemLowerer<'_, 'a, 'hir> {\n             }\n         }\n \n-        self.lctx.owners[def_id]\n+        self.owners[def_id]\n     }\n \n     fn lower_crate(&mut self, c: &'a Crate) {\n-        debug_assert_eq!(self.lctx.resolver.local_def_id(CRATE_NODE_ID), CRATE_DEF_ID);\n+        debug_assert_eq!(self.resolver.local_def_id(CRATE_NODE_ID), CRATE_DEF_ID);\n \n-        self.lctx.with_hir_id_owner(CRATE_NODE_ID, |lctx| {\n+        let mut lctx = self.make_lctx();\n+        lctx.with_hir_id_owner(CRATE_NODE_ID, |lctx| {\n             let module = lctx.lower_mod(&c.items, c.spans.inner_span);\n             lctx.lower_attrs(hir::CRATE_HIR_ID, &c.attrs);\n             hir::OwnerNode::Crate(lctx.arena.alloc(module))\n-        });\n+        })\n     }\n \n     fn lower_item(&mut self, item: &'a Item) {\n-        self.without_in_scope_lifetime_defs(|this| {\n-            this.lctx.with_hir_id_owner(item.id, |lctx| hir::OwnerNode::Item(lctx.lower_item(item)))\n-        });\n+        let mut lctx = self.make_lctx();\n+        lctx.with_hir_id_owner(item.id, |lctx| hir::OwnerNode::Item(lctx.lower_item(item)))\n     }\n \n     fn lower_assoc_item(&mut self, item: &'a AssocItem, ctxt: AssocCtxt) {\n-        let def_id = self.lctx.resolver.local_def_id(item.id);\n-\n-        let do_lower = |lctx: &mut LoweringContext<'_, '_>| {\n-            lctx.with_hir_id_owner(item.id, |lctx| match ctxt {\n-                AssocCtxt::Trait => hir::OwnerNode::TraitItem(lctx.lower_trait_item(item)),\n-                AssocCtxt::Impl => hir::OwnerNode::ImplItem(lctx.lower_impl_item(item)),\n-            });\n-        };\n+        let def_id = self.resolver.local_def_id(item.id);\n \n         let parent_id = {\n-            let parent = self.lctx.resolver.definitions().def_key(def_id).parent;\n+            let parent = self.resolver.definitions().def_key(def_id).parent;\n             let local_def_index = parent.unwrap();\n             LocalDefId { local_def_index }\n         };\n+\n         let parent_hir = self.lower_node(parent_id).unwrap().node().expect_item();\n-        self.with_parent_item_lifetime_defs(parent_hir, |this| match parent_hir.kind {\n-            hir::ItemKind::Impl(hir::Impl { ref of_trait, .. }) => {\n-                this.with_trait_impl_ref(of_trait, |this| do_lower(this.lctx))\n+        let mut lctx = self.make_lctx();\n+\n+        // Evaluate with the lifetimes in `params` in-scope.\n+        // This is used to track which lifetimes have already been defined,\n+        // and which need to be replicated when lowering an async fn.\n+        match parent_hir.kind {\n+            hir::ItemKind::Impl(hir::Impl { ref of_trait, ref generics, .. }) => {\n+                lctx.is_in_trait_impl = of_trait.is_some();\n+                lctx.in_scope_lifetimes = generics\n+                    .params\n+                    .iter()\n+                    .filter(|param| matches!(param.kind, hir::GenericParamKind::Lifetime { .. }))\n+                    .map(|param| param.name)\n+                    .collect();\n+            }\n+            hir::ItemKind::Trait(_, _, ref generics, ..) => {\n+                lctx.in_scope_lifetimes = generics\n+                    .params\n+                    .iter()\n+                    .filter(|param| matches!(param.kind, hir::GenericParamKind::Lifetime { .. }))\n+                    .map(|param| param.name)\n+                    .collect();\n             }\n-            _ => do_lower(this.lctx),\n-        });\n+            _ => {}\n+        };\n+\n+        lctx.with_hir_id_owner(item.id, |lctx| match ctxt {\n+            AssocCtxt::Trait => hir::OwnerNode::TraitItem(lctx.lower_trait_item(item)),\n+            AssocCtxt::Impl => hir::OwnerNode::ImplItem(lctx.lower_impl_item(item)),\n+        })\n     }\n \n     fn lower_foreign_item(&mut self, item: &'a ForeignItem) {\n-        self.lctx.with_hir_id_owner(item.id, |lctx| {\n+        let mut lctx = self.make_lctx();\n+        lctx.with_hir_id_owner(item.id, |lctx| {\n             hir::OwnerNode::ForeignItem(lctx.lower_foreign_item(item))\n-        });\n+        })\n     }\n }\n "}, {"sha": "1aa3388af1b8d53101e4ba35880843766963e71f", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 13, "deletions": 37, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/e5d482eecaa51a3a4836c550c2e36e93f543e576/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d482eecaa51a3a4836c550c2e36e93f543e576/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=e5d482eecaa51a3a4836c550c2e36e93f543e576", "patch": "@@ -85,7 +85,7 @@ mod path;\n \n rustc_hir::arena_types!(rustc_arena::declare_arena);\n \n-struct LoweringContext<'a, 'hir: 'a> {\n+struct LoweringContext<'a, 'hir> {\n     /// Used to assign IDs to HIR nodes that do not directly correspond to AST nodes.\n     sess: &'a Session,\n \n@@ -100,7 +100,7 @@ struct LoweringContext<'a, 'hir: 'a> {\n     arena: &'hir Arena<'hir>,\n \n     /// The items being lowered are collected here.\n-    owners: IndexVec<LocalDefId, hir::MaybeOwner<&'hir hir::OwnerInfo<'hir>>>,\n+    owners: &'a mut IndexVec<LocalDefId, hir::MaybeOwner<&'hir hir::OwnerInfo<'hir>>>,\n     /// Bodies inside the owner being lowered.\n     bodies: Vec<(hir::ItemLocalId, &'hir hir::Body<'hir>)>,\n     /// Attributes inside the owner being lowered.\n@@ -418,42 +418,20 @@ pub fn lower_crate<'a, 'hir>(\n \n     let ast_index = index_crate(resolver, krate);\n \n-    let owners =\n+    let mut owners =\n         IndexVec::from_fn_n(|_| hir::MaybeOwner::Phantom, resolver.definitions().def_index_count());\n-    let mut lctx = LoweringContext {\n-        sess,\n-        resolver,\n-        nt_to_tokenstream,\n-        arena,\n-        owners,\n-        bodies: Vec::new(),\n-        attrs: SortedMap::new(),\n-        catch_scope: None,\n-        loop_scope: None,\n-        is_in_loop_condition: false,\n-        is_in_trait_impl: false,\n-        is_in_dyn_type: false,\n-        anonymous_lifetime_mode: AnonymousLifetimeMode::PassThrough,\n-        current_hir_id_owner: CRATE_DEF_ID,\n-        item_local_id_counter: hir::ItemLocalId::new(0),\n-        node_id_to_local_id: FxHashMap::default(),\n-        local_id_to_def_id: SortedMap::new(),\n-        trait_map: FxHashMap::default(),\n-        generator_kind: None,\n-        task_context: None,\n-        current_item: None,\n-        lifetimes_to_define: Vec::new(),\n-        is_collecting_anonymous_lifetimes: None,\n-        in_scope_lifetimes: Vec::new(),\n-        allow_try_trait: Some([sym::try_trait_v2][..].into()),\n-        allow_gen_future: Some([sym::gen_future][..].into()),\n-        allow_into_future: Some([sym::into_future][..].into()),\n-    };\n \n     for def_id in ast_index.indices() {\n-        item::ItemLowerer { lctx: &mut lctx, ast_index: &ast_index }.lower_node(def_id);\n+        item::ItemLowerer {\n+            sess,\n+            resolver,\n+            nt_to_tokenstream,\n+            arena,\n+            ast_index: &ast_index,\n+            owners: &mut owners,\n+        }\n+        .lower_node(def_id);\n     }\n-    let owners = lctx.owners;\n \n     let hir_hash = compute_hir_hash(resolver, &owners);\n     let krate = hir::Crate { owners, hir_hash };\n@@ -530,7 +508,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         &mut self,\n         owner: NodeId,\n         f: impl FnOnce(&mut Self) -> hir::OwnerNode<'hir>,\n-    ) -> LocalDefId {\n+    ) {\n         let def_id = self.resolver.local_def_id(owner);\n \n         let current_attrs = std::mem::take(&mut self.attrs);\n@@ -560,8 +538,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n         self.owners.ensure_contains_elem(def_id, || hir::MaybeOwner::Phantom);\n         self.owners[def_id] = hir::MaybeOwner::Owner(self.arena.alloc(info));\n-\n-        def_id\n     }\n \n     fn make_owner_info(&mut self, node: hir::OwnerNode<'hir>) -> hir::OwnerInfo<'hir> {"}]}