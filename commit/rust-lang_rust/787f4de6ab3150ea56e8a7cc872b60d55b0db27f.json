{"sha": "787f4de6ab3150ea56e8a7cc872b60d55b0db27f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4N2Y0ZGU2YWIzMTUwZWE1NmU4YTdjYzg3MmI2MGQ1NWIwZGIyN2Y=", "commit": {"author": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2021-01-18T16:18:13Z"}, "committer": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2021-02-15T13:27:34Z"}, "message": "Use new pointer metadata API inside libcore instead of manual transmutes", "tree": {"sha": "15d1be38182ee0f04abe088a7b06d1a28eb8dcca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/15d1be38182ee0f04abe088a7b06d1a28eb8dcca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/787f4de6ab3150ea56e8a7cc872b60d55b0db27f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/787f4de6ab3150ea56e8a7cc872b60d55b0db27f", "html_url": "https://github.com/rust-lang/rust/commit/787f4de6ab3150ea56e8a7cc872b60d55b0db27f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/787f4de6ab3150ea56e8a7cc872b60d55b0db27f/comments", "author": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0e3a1b0968da04723ff326dc7def1d706c62377", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0e3a1b0968da04723ff326dc7def1d706c62377", "html_url": "https://github.com/rust-lang/rust/commit/c0e3a1b0968da04723ff326dc7def1d706c62377"}], "stats": {"total": 142, "additions": 100, "deletions": 42}, "files": [{"sha": "cd47f97496a4a8735ac3db8cf00b0bafe3afdab9", "filename": "library/core/src/hash/mod.rs", "status": "modified", "additions": 44, "deletions": 26, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/787f4de6ab3150ea56e8a7cc872b60d55b0db27f/library%2Fcore%2Fsrc%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/787f4de6ab3150ea56e8a7cc872b60d55b0db27f/library%2Fcore%2Fsrc%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fhash%2Fmod.rs?ref=787f4de6ab3150ea56e8a7cc872b60d55b0db27f", "patch": "@@ -673,39 +673,57 @@ mod impls {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl<T: ?Sized> Hash for *const T {\n         fn hash<H: Hasher>(&self, state: &mut H) {\n-            if mem::size_of::<Self>() == mem::size_of::<usize>() {\n-                // Thin pointer\n-                state.write_usize(*self as *const () as usize);\n-            } else {\n-                // Fat pointer\n-                // SAFETY: we are accessing the memory occupied by `self`\n-                // which is guaranteed to be valid.\n-                // This assumes a fat pointer can be represented by a `(usize, usize)`,\n-                // which is safe to do in `std` because it is shipped and kept in sync\n-                // with the implementation of fat pointers in `rustc`.\n-                let (a, b) = unsafe { *(self as *const Self as *const (usize, usize)) };\n-                state.write_usize(a);\n-                state.write_usize(b);\n+            #[cfg(not(bootstrap))]\n+            {\n+                let (address, metadata) = self.to_raw_parts();\n+                state.write_usize(address as usize);\n+                metadata.hash(state);\n+            }\n+            #[cfg(bootstrap)]\n+            {\n+                if mem::size_of::<Self>() == mem::size_of::<usize>() {\n+                    // Thin pointer\n+                    state.write_usize(*self as *const () as usize);\n+                } else {\n+                    // Fat pointer\n+                    // SAFETY: we are accessing the memory occupied by `self`\n+                    // which is guaranteed to be valid.\n+                    // This assumes a fat pointer can be represented by a `(usize, usize)`,\n+                    // which is safe to do in `std` because it is shipped and kept in sync\n+                    // with the implementation of fat pointers in `rustc`.\n+                    let (a, b) = unsafe { *(self as *const Self as *const (usize, usize)) };\n+                    state.write_usize(a);\n+                    state.write_usize(b);\n+                }\n             }\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl<T: ?Sized> Hash for *mut T {\n         fn hash<H: Hasher>(&self, state: &mut H) {\n-            if mem::size_of::<Self>() == mem::size_of::<usize>() {\n-                // Thin pointer\n-                state.write_usize(*self as *const () as usize);\n-            } else {\n-                // Fat pointer\n-                // SAFETY: we are accessing the memory occupied by `self`\n-                // which is guaranteed to be valid.\n-                // This assumes a fat pointer can be represented by a `(usize, usize)`,\n-                // which is safe to do in `std` because it is shipped and kept in sync\n-                // with the implementation of fat pointers in `rustc`.\n-                let (a, b) = unsafe { *(self as *const Self as *const (usize, usize)) };\n-                state.write_usize(a);\n-                state.write_usize(b);\n+            #[cfg(not(bootstrap))]\n+            {\n+                let (address, metadata) = self.to_raw_parts();\n+                state.write_usize(address as usize);\n+                metadata.hash(state);\n+            }\n+            #[cfg(bootstrap)]\n+            {\n+                if mem::size_of::<Self>() == mem::size_of::<usize>() {\n+                    // Thin pointer\n+                    state.write_usize(*self as *const () as usize);\n+                } else {\n+                    // Fat pointer\n+                    // SAFETY: we are accessing the memory occupied by `self`\n+                    // which is guaranteed to be valid.\n+                    // This assumes a fat pointer can be represented by a `(usize, usize)`,\n+                    // which is safe to do in `std` because it is shipped and kept in sync\n+                    // with the implementation of fat pointers in `rustc`.\n+                    let (a, b) = unsafe { *(self as *const Self as *const (usize, usize)) };\n+                    state.write_usize(a);\n+                    state.write_usize(b);\n+                }\n             }\n         }\n     }"}, {"sha": "a635e59e89beacd7446f3bbadc1020156c062a4b", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/787f4de6ab3150ea56e8a7cc872b60d55b0db27f/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/787f4de6ab3150ea56e8a7cc872b60d55b0db27f/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=787f4de6ab3150ea56e8a7cc872b60d55b0db27f", "patch": "@@ -916,9 +916,14 @@ impl<T> *const [T] {\n     #[unstable(feature = \"slice_ptr_len\", issue = \"71146\")]\n     #[rustc_const_unstable(feature = \"const_slice_ptr_len\", issue = \"71146\")]\n     pub const fn len(self) -> usize {\n-        // SAFETY: this is safe because `*const [T]` and `FatPtr<T>` have the same layout.\n-        // Only `std` can make this guarantee.\n-        unsafe { Repr { rust: self }.raw }.len\n+        #[cfg(bootstrap)]\n+        {\n+            // SAFETY: this is safe because `*const [T]` and `FatPtr<T>` have the same layout.\n+            // Only `std` can make this guarantee.\n+            unsafe { Repr { rust: self }.raw }.len\n+        }\n+        #[cfg(not(bootstrap))]\n+        metadata(self)\n     }\n \n     /// Returns a raw pointer to the slice's buffer."}, {"sha": "05fd090125ce2c6205d2a53184c1448e48e6b766", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/787f4de6ab3150ea56e8a7cc872b60d55b0db27f/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/787f4de6ab3150ea56e8a7cc872b60d55b0db27f/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=787f4de6ab3150ea56e8a7cc872b60d55b0db27f", "patch": "@@ -85,6 +85,8 @@ pub use crate::intrinsics::write_bytes;\n #[cfg(not(bootstrap))]\n mod metadata;\n #[cfg(not(bootstrap))]\n+pub(crate) use metadata::PtrRepr;\n+#[cfg(not(bootstrap))]\n #[unstable(feature = \"ptr_metadata\", issue = /* FIXME */ \"none\")]\n pub use metadata::{from_raw_parts, from_raw_parts_mut, metadata, DynMetadata, Pointee, Thin};\n \n@@ -226,26 +228,30 @@ pub const fn null_mut<T>() -> *mut T {\n     0 as *mut T\n }\n \n+#[cfg(bootstrap)]\n #[repr(C)]\n pub(crate) union Repr<T> {\n     pub(crate) rust: *const [T],\n     rust_mut: *mut [T],\n     pub(crate) raw: FatPtr<T>,\n }\n \n+#[cfg(bootstrap)]\n #[repr(C)]\n pub(crate) struct FatPtr<T> {\n     data: *const T,\n     pub(crate) len: usize,\n }\n \n+#[cfg(bootstrap)]\n // Manual impl needed to avoid `T: Clone` bound.\n impl<T> Clone for FatPtr<T> {\n     fn clone(&self) -> Self {\n         *self\n     }\n }\n \n+#[cfg(bootstrap)]\n // Manual impl needed to avoid `T: Copy` bound.\n impl<T> Copy for FatPtr<T> {}\n \n@@ -273,10 +279,15 @@ impl<T> Copy for FatPtr<T> {}\n #[stable(feature = \"slice_from_raw_parts\", since = \"1.42.0\")]\n #[rustc_const_unstable(feature = \"const_slice_from_raw_parts\", issue = \"67456\")]\n pub const fn slice_from_raw_parts<T>(data: *const T, len: usize) -> *const [T] {\n-    // SAFETY: Accessing the value from the `Repr` union is safe since *const [T]\n-    // and FatPtr have the same memory layouts. Only std can make this\n-    // guarantee.\n-    unsafe { Repr { raw: FatPtr { data, len } }.rust }\n+    #[cfg(bootstrap)]\n+    {\n+        // SAFETY: Accessing the value from the `Repr` union is safe since *const [T]\n+        // and FatPtr have the same memory layouts. Only std can make this\n+        // guarantee.\n+        unsafe { Repr { raw: FatPtr { data, len } }.rust }\n+    }\n+    #[cfg(not(bootstrap))]\n+    from_raw_parts(data.cast(), len)\n }\n \n /// Performs the same functionality as [`slice_from_raw_parts`], except that a\n@@ -308,9 +319,14 @@ pub const fn slice_from_raw_parts<T>(data: *const T, len: usize) -> *const [T] {\n #[stable(feature = \"slice_from_raw_parts\", since = \"1.42.0\")]\n #[rustc_const_unstable(feature = \"const_slice_from_raw_parts\", issue = \"67456\")]\n pub const fn slice_from_raw_parts_mut<T>(data: *mut T, len: usize) -> *mut [T] {\n-    // SAFETY: Accessing the value from the `Repr` union is safe since *mut [T]\n-    // and FatPtr have the same memory layouts\n-    unsafe { Repr { raw: FatPtr { data, len } }.rust_mut }\n+    #[cfg(bootstrap)]\n+    {\n+        // SAFETY: Accessing the value from the `Repr` union is safe since *mut [T]\n+        // and FatPtr have the same memory layouts\n+        unsafe { Repr { raw: FatPtr { data, len } }.rust_mut }\n+    }\n+    #[cfg(not(bootstrap))]\n+    from_raw_parts_mut(data.cast(), len)\n }\n \n /// Swaps the values at two mutable locations of the same type, without"}, {"sha": "f7da49290ae48f1275bd6f7fc4ffaccd7b1860d4", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/787f4de6ab3150ea56e8a7cc872b60d55b0db27f/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/787f4de6ab3150ea56e8a7cc872b60d55b0db27f/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=787f4de6ab3150ea56e8a7cc872b60d55b0db27f", "patch": "@@ -1173,9 +1173,14 @@ impl<T> *mut [T] {\n     #[unstable(feature = \"slice_ptr_len\", issue = \"71146\")]\n     #[rustc_const_unstable(feature = \"const_slice_ptr_len\", issue = \"71146\")]\n     pub const fn len(self) -> usize {\n-        // SAFETY: this is safe because `*const [T]` and `FatPtr<T>` have the same layout.\n-        // Only `std` can make this guarantee.\n-        unsafe { Repr { rust_mut: self }.raw }.len\n+        #[cfg(bootstrap)]\n+        {\n+            // SAFETY: this is safe because `*const [T]` and `FatPtr<T>` have the same layout.\n+            // Only `std` can make this guarantee.\n+            unsafe { Repr { rust_mut: self }.raw }.len\n+        }\n+        #[cfg(not(bootstrap))]\n+        metadata(self)\n     }\n \n     /// Returns a raw pointer to the slice's buffer."}, {"sha": "1c1b9e0b27e2558a8bc53e2b13a0da1f119572c4", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/787f4de6ab3150ea56e8a7cc872b60d55b0db27f/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/787f4de6ab3150ea56e8a7cc872b60d55b0db27f/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=787f4de6ab3150ea56e8a7cc872b60d55b0db27f", "patch": "@@ -94,9 +94,23 @@ impl<T> [T] {\n     // SAFETY: const sound because we transmute out the length field as a usize (which it must be)\n     #[rustc_allow_const_fn_unstable(const_fn_union)]\n     pub const fn len(&self) -> usize {\n-        // SAFETY: this is safe because `&[T]` and `FatPtr<T>` have the same layout.\n-        // Only `std` can make this guarantee.\n-        unsafe { crate::ptr::Repr { rust: self }.raw.len }\n+        #[cfg(bootstrap)]\n+        {\n+            // SAFETY: this is safe because `&[T]` and `FatPtr<T>` have the same layout.\n+            // Only `std` can make this guarantee.\n+            unsafe { crate::ptr::Repr { rust: self }.raw.len }\n+        }\n+        #[cfg(not(bootstrap))]\n+        {\n+            // FIXME: Replace with `crate::ptr::metadata(self)` when that is const-stable.\n+            // As of this writing this causes a \"Const-stable functions can only call other\n+            // const-stable functions\" error.\n+\n+            // SAFETY: Accessing the value from the `PtrRepr` union is safe since *const T\n+            // and PtrComponents<T> have the same memory layouts. Only std can make this\n+            // guarantee.\n+            unsafe { crate::ptr::PtrRepr { const_ptr: self }.components.metadata }\n+        }\n     }\n \n     /// Returns `true` if the slice has a length of 0."}]}