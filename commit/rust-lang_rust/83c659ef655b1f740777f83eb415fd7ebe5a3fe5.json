{"sha": "83c659ef655b1f740777f83eb415fd7ebe5a3fe5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzYzY1OWVmNjU1YjFmNzQwNzc3ZjgzZWI0MTVmZDdlYmU1YTNmZTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-07-18T10:20:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-07-18T10:20:13Z"}, "message": "Auto merge of #42492 - petrochenkov:methlife, r=nikomatsakis\n\nSupport generic lifetime arguments in method calls\n\nFixes https://github.com/rust-lang/rust/issues/42403\nFixes https://github.com/rust-lang/rust/issues/42115\nLifetimes in a method call `x.f::<'a, 'b, T, U>()` are treated exactly like lifetimes in the equivalent UFCS call `X::f::<'a, 'b, T, U>`.\nIn addition, if the method has late bound lifetime parameters (explicit or implicit), then explicitly specifying lifetime arguments is not permitted (guarded by a compatibility lint).\n[breaking-change] because previously lifetimes in method calls were accepted unconditionally.\n\nr? @eddyb", "tree": {"sha": "b33f8e7603cf90dba99ae18b867ebccfe552142d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b33f8e7603cf90dba99ae18b867ebccfe552142d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/83c659ef655b1f740777f83eb415fd7ebe5a3fe5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/83c659ef655b1f740777f83eb415fd7ebe5a3fe5", "html_url": "https://github.com/rust-lang/rust/commit/83c659ef655b1f740777f83eb415fd7ebe5a3fe5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/83c659ef655b1f740777f83eb415fd7ebe5a3fe5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2e6334062e2be142125e99d63867711da505cc9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e6334062e2be142125e99d63867711da505cc9e", "html_url": "https://github.com/rust-lang/rust/commit/2e6334062e2be142125e99d63867711da505cc9e"}, {"sha": "39114f916905b16b414f51031426309b63f856a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/39114f916905b16b414f51031426309b63f856a9", "html_url": "https://github.com/rust-lang/rust/commit/39114f916905b16b414f51031426309b63f856a9"}], "stats": {"total": 623, "additions": 417, "deletions": 206}, "files": [{"sha": "3e227872848efb36efcd10ac1cde8ef167f5787e", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83c659ef655b1f740777f83eb415fd7ebe5a3fe5/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83c659ef655b1f740777f83eb415fd7ebe5a3fe5/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=83c659ef655b1f740777f83eb415fd7ebe5a3fe5", "patch": "@@ -346,6 +346,7 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ty::Ge\n             // `def_id.index` (`def_id.krate` is the same as the item's).\n             type_param_to_index: _, // Don't hash this\n             has_self,\n+            has_late_bound_regions,\n         } = *self;\n \n         parent.hash_stable(hcx, hasher);\n@@ -354,6 +355,7 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ty::Ge\n         regions.hash_stable(hcx, hasher);\n         types.hash_stable(hcx, hasher);\n         has_self.hash_stable(hcx, hasher);\n+        has_late_bound_regions.hash_stable(hcx, hasher);\n     }\n }\n "}, {"sha": "cbe642a9a76a65b3afca29288f97de502778745e", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/83c659ef655b1f740777f83eb415fd7ebe5a3fe5/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83c659ef655b1f740777f83eb415fd7ebe5a3fe5/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=83c659ef655b1f740777f83eb415fd7ebe5a3fe5", "patch": "@@ -204,6 +204,12 @@ declare_lint! {\n     \"detects parenthesized generic parameters in type and module names\"\n }\n \n+declare_lint! {\n+    pub LATE_BOUND_LIFETIME_ARGUMENTS,\n+    Warn,\n+    \"detects generic lifetime arguments in path segments with late bound lifetime parameters\"\n+}\n+\n declare_lint! {\n     pub DEPRECATED,\n     Warn,\n@@ -249,6 +255,7 @@ impl LintPass for HardwiredLints {\n             LEGACY_CONSTRUCTOR_VISIBILITY,\n             MISSING_FRAGMENT_SPECIFIER,\n             PARENTHESIZED_PARAMS_IN_TYPES_AND_MODULES,\n+            LATE_BOUND_LIFETIME_ARGUMENTS,\n             DEPRECATED\n         )\n     }"}, {"sha": "1fee0dd98634ae3af07784b751bb122348240322", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/83c659ef655b1f740777f83eb415fd7ebe5a3fe5/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83c659ef655b1f740777f83eb415fd7ebe5a3fe5/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=83c659ef655b1f740777f83eb415fd7ebe5a3fe5", "patch": "@@ -719,6 +719,7 @@ pub struct Generics {\n     pub type_param_to_index: BTreeMap<DefIndex, u32>,\n \n     pub has_self: bool,\n+    pub has_late_bound_regions: bool,\n }\n \n impl Generics {"}, {"sha": "21dca7f6c61c413234671a38817e6aabba2c9231", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/83c659ef655b1f740777f83eb415fd7ebe5a3fe5/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83c659ef655b1f740777f83eb415fd7ebe5a3fe5/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=83c659ef655b1f740777f83eb415fd7ebe5a3fe5", "patch": "@@ -235,7 +235,11 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n         FutureIncompatibleInfo {\n             id: LintId::of(PARENTHESIZED_PARAMS_IN_TYPES_AND_MODULES),\n             reference: \"issue #42238 <https://github.com/rust-lang/rust/issues/42238>\",\n-        }\n+        },\n+        FutureIncompatibleInfo {\n+            id: LintId::of(LATE_BOUND_LIFETIME_ARGUMENTS),\n+            reference: \"issue #42868 <https://github.com/rust-lang/rust/issues/42868>\",\n+        },\n         ]);\n \n     // Register renamed and removed lints"}, {"sha": "99a49dbd7d732122c8a458ef8cac9804d5488005", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/83c659ef655b1f740777f83eb415fd7ebe5a3fe5/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83c659ef655b1f740777f83eb415fd7ebe5a3fe5/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=83c659ef655b1f740777f83eb415fd7ebe5a3fe5", "patch": "@@ -127,18 +127,9 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             }\n             ExprKind::MethodCall(ref segment, ..) => {\n                 if let Some(ref params) = segment.parameters {\n-                    match **params {\n-                        PathParameters::AngleBracketed(ref param_data) => {\n-                            if !param_data.bindings.is_empty() {\n-                                let binding_span = param_data.bindings[0].span;\n-                                self.err_handler().span_err(binding_span,\n-                                    \"type bindings cannot be used in method calls\");\n-                            }\n-                        }\n-                        PathParameters::Parenthesized(..) => {\n-                            self.err_handler().span_err(expr.span,\n-                                \"parenthesized parameters cannot be used on method calls\");\n-                        }\n+                    if let PathParameters::Parenthesized(..) = **params {\n+                        self.err_handler().span_err(expr.span,\n+                            \"parenthesized parameters cannot be used on method calls\");\n                     }\n                 }\n             }"}, {"sha": "ad4ee5a9d6dcf2c7dea25f84cf8c0616edc94a9a", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 18, "deletions": 41, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/83c659ef655b1f740777f83eb415fd7ebe5a3fe5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83c659ef655b1f740777f83eb415fd7ebe5a3fe5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=83c659ef655b1f740777f83eb415fd7ebe5a3fe5", "patch": "@@ -10,6 +10,7 @@\n \n use super::{probe, MethodCallee};\n \n+use astconv::AstConv;\n use check::{FnCtxt, LvalueOp, callee};\n use hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n@@ -280,62 +281,38 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n     fn instantiate_method_substs(&mut self,\n                                  pick: &probe::Pick<'tcx>,\n                                  segment: &hir::PathSegment,\n-                                 substs: &Substs<'tcx>)\n+                                 parent_substs: &Substs<'tcx>)\n                                  -> &'tcx Substs<'tcx> {\n-        let supplied_method_types = match segment.parameters {\n-            hir::AngleBracketedParameters(ref data) => &data.types,\n-            _ => bug!(\"unexpected generic arguments: {:?}\", segment.parameters),\n-        };\n-\n         // Determine the values for the generic parameters of the method.\n         // If they were not explicitly supplied, just construct fresh\n         // variables.\n-        let num_supplied_types = supplied_method_types.len();\n         let method_generics = self.tcx.generics_of(pick.item.def_id);\n-        let num_method_types = method_generics.types.len();\n-\n-        if num_supplied_types > 0 && num_supplied_types != num_method_types {\n-            if num_method_types == 0 {\n-                struct_span_err!(self.tcx.sess,\n-                                 self.span,\n-                                 E0035,\n-                                 \"does not take type parameters\")\n-                    .span_label(self.span, \"called with unneeded type parameters\")\n-                    .emit();\n-            } else {\n-                struct_span_err!(self.tcx.sess,\n-                                 self.span,\n-                                 E0036,\n-                                 \"incorrect number of type parameters given for this method: \\\n-                                  expected {}, found {}\",\n-                                 num_method_types,\n-                                 num_supplied_types)\n-                    .span_label(self.span,\n-                                format!(\"Passed {} type argument{}, expected {}\",\n-                                         num_supplied_types,\n-                                         if num_supplied_types != 1 { \"s\" } else { \"\" },\n-                                         num_method_types))\n-                    .emit();\n-            }\n-        }\n+        let mut fn_segment = Some((segment, method_generics));\n+        self.fcx.check_path_parameter_count(self.span, &mut fn_segment, true);\n \n         // Create subst for early-bound lifetime parameters, combining\n         // parameters from the type and those from the method.\n-        //\n-        // FIXME -- permit users to manually specify lifetimes\n-        let supplied_start = substs.len() + method_generics.regions.len();\n+        let (supplied_types, supplied_lifetimes) = match segment.parameters {\n+            hir::AngleBracketedParameters(ref data) => (&data.types, &data.lifetimes),\n+            _ => bug!(\"unexpected generic arguments: {:?}\", segment.parameters),\n+        };\n+        assert_eq!(method_generics.parent_count(), parent_substs.len());\n         Substs::for_item(self.tcx, pick.item.def_id, |def, _| {\n             let i = def.index as usize;\n-            if i < substs.len() {\n-                substs.region_at(i)\n+            if i < parent_substs.len() {\n+                parent_substs.region_at(i)\n+            } else if let Some(lifetime) =\n+                    supplied_lifetimes.get(i - parent_substs.len()) {\n+                AstConv::ast_region_to_region(self.fcx, lifetime, Some(def))\n             } else {\n                 self.region_var_for_def(self.span, def)\n             }\n         }, |def, cur_substs| {\n             let i = def.index as usize;\n-            if i < substs.len() {\n-                substs.type_at(i)\n-            } else if let Some(ast_ty) = supplied_method_types.get(i - supplied_start) {\n+            if i < parent_substs.len() {\n+                parent_substs.type_at(i)\n+            } else if let Some(ast_ty) =\n+                    supplied_types.get(i - parent_substs.len() - method_generics.regions.len()) {\n                 self.to_ty(ast_ty)\n             } else {\n                 self.type_var_for_def(self.span, def, cur_substs)"}, {"sha": "af11cacb247b6b6b90bef620d7a28e58b0768893", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 51, "deletions": 30, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/83c659ef655b1f740777f83eb415fd7ebe5a3fe5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83c659ef655b1f740777f83eb415fd7ebe5a3fe5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=83c659ef655b1f740777f83eb415fd7ebe5a3fe5", "patch": "@@ -4491,8 +4491,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // variables. If the user provided some types, we may still need\n         // to add defaults. If the user provided *too many* types, that's\n         // a problem.\n-        self.check_path_parameter_count(span, &mut type_segment);\n-        self.check_path_parameter_count(span, &mut fn_segment);\n+        self.check_path_parameter_count(span, &mut type_segment, false);\n+        self.check_path_parameter_count(span, &mut fn_segment, false);\n \n         let (fn_start, has_self) = match (type_segment, fn_segment) {\n             (_, Some((_, generics))) => {\n@@ -4618,7 +4618,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// Report errors if the provided parameters are too few or too many.\n     fn check_path_parameter_count(&self,\n                                   span: Span,\n-                                  segment: &mut Option<(&hir::PathSegment, &ty::Generics)>) {\n+                                  segment: &mut Option<(&hir::PathSegment, &ty::Generics)>,\n+                                  is_method_call: bool) {\n         let (lifetimes, types, infer_types, bindings) = {\n             match segment.map(|(s, _)| &s.parameters) {\n                 Some(&hir::AngleBracketedParameters(ref data)) => {\n@@ -4632,6 +4633,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 None => (&[][..], &[][..], true, &[][..])\n             }\n         };\n+        let infer_lifetimes = lifetimes.len() == 0;\n \n         let count_lifetime_params = |n| {\n             format!(\"{} lifetime parameter{}\", n, if n == 1 { \"\" } else { \"s\" })\n@@ -4640,32 +4642,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             format!(\"{} type parameter{}\", n, if n == 1 { \"\" } else { \"s\" })\n         };\n \n-        // Check provided lifetime parameters.\n-        let lifetime_defs = segment.map_or(&[][..], |(_, generics)| &generics.regions);\n-        if lifetimes.len() > lifetime_defs.len() {\n-            let expected_text = count_lifetime_params(lifetime_defs.len());\n-            let actual_text = count_lifetime_params(lifetimes.len());\n-            struct_span_err!(self.tcx.sess, span, E0088,\n-                             \"too many lifetime parameters provided: \\\n-                              expected at most {}, found {}\",\n-                             expected_text, actual_text)\n-                .span_label(span, format!(\"expected {}\", expected_text))\n-                .emit();\n-        } else if lifetimes.len() > 0 && lifetimes.len() < lifetime_defs.len() {\n-            let expected_text = count_lifetime_params(lifetime_defs.len());\n-            let actual_text = count_lifetime_params(lifetimes.len());\n-            struct_span_err!(self.tcx.sess, span, E0090,\n-                             \"too few lifetime parameters provided: \\\n-                              expected {}, found {}\",\n-                             expected_text, actual_text)\n-                .span_label(span, format!(\"expected {}\", expected_text))\n-                .emit();\n-        }\n-\n-        // The case where there is not enough lifetime parameters is not checked,\n-        // because this is not possible - a function never takes lifetime parameters.\n-        // See discussion for Pull Request 36208.\n-\n         // Check provided type parameters.\n         let type_defs = segment.map_or(&[][..], |(_, generics)| {\n             if generics.parent.is_none() {\n@@ -4690,7 +4666,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // type parameters, we force instantiate_value_path to\n             // use inference variables instead of the provided types.\n             *segment = None;\n-        } else if !infer_types && types.len() < required_len {\n+        } else if types.len() < required_len && !infer_types {\n             let expected_text = count_type_params(required_len);\n             let actual_text = count_type_params(types.len());\n             struct_span_err!(self.tcx.sess, span, E0089,\n@@ -4706,6 +4682,51 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                       \"unexpected binding of associated item in expression path \\\n                        (only allowed in type paths)\");\n         }\n+\n+        // Check provided lifetime parameters.\n+        let lifetime_defs = segment.map_or(&[][..], |(_, generics)| &generics.regions);\n+        let required_len = lifetime_defs.len();\n+\n+        // Prohibit explicit lifetime arguments if late bound lifetime parameters are present.\n+        let has_late_bound_lifetime_defs =\n+            segment.map_or(false, |(_, generics)| generics.has_late_bound_regions);\n+        if has_late_bound_lifetime_defs && !lifetimes.is_empty() {\n+            // Report this as a lint only if no error was reported previously.\n+            if !is_method_call && (lifetimes.len() > lifetime_defs.len() ||\n+                                   lifetimes.len() < required_len && !infer_lifetimes) {\n+                self.tcx.sess.span_err(lifetimes[0].span,\n+                                       \"cannot specify lifetime arguments explicitly \\\n+                                        if late bound lifetime parameters are present\");\n+                *segment = None;\n+            } else {\n+                self.tcx.sess.add_lint(lint::builtin::LATE_BOUND_LIFETIME_ARGUMENTS,\n+                                       lifetimes[0].id, lifetimes[0].span,\n+                                       format!(\"cannot specify lifetime arguments explicitly \\\n+                                                if late bound lifetime parameters are present\"));\n+            }\n+            return;\n+        }\n+\n+        if lifetimes.len() > lifetime_defs.len() {\n+            let span = lifetimes[lifetime_defs.len()].span;\n+            let expected_text = count_lifetime_params(lifetime_defs.len());\n+            let actual_text = count_lifetime_params(lifetimes.len());\n+            struct_span_err!(self.tcx.sess, span, E0088,\n+                             \"too many lifetime parameters provided: \\\n+                              expected at most {}, found {}\",\n+                             expected_text, actual_text)\n+                .span_label(span, format!(\"expected {}\", expected_text))\n+                .emit();\n+        } else if lifetimes.len() < required_len && !infer_lifetimes {\n+            let expected_text = count_lifetime_params(lifetime_defs.len());\n+            let actual_text = count_lifetime_params(lifetimes.len());\n+            struct_span_err!(self.tcx.sess, span, E0090,\n+                             \"too few lifetime parameters provided: \\\n+                              expected {}, found {}\",\n+                             expected_text, actual_text)\n+                .span_label(span, format!(\"expected {}\", expected_text))\n+                .emit();\n+        }\n     }\n \n     fn structurally_resolve_type_or_else<F>(&self, sp: Span, ty: Ty<'tcx>, f: F)"}, {"sha": "72bd084330dd3ca62d92373d351431533685dd09", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 91, "deletions": 1, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/83c659ef655b1f740777f83eb415fd7ebe5a3fe5/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83c659ef655b1f740777f83eb415fd7ebe5a3fe5/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=83c659ef655b1f740777f83eb415fd7ebe5a3fe5", "patch": "@@ -772,6 +772,95 @@ fn trait_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     tcx.alloc_trait_def(def)\n }\n \n+fn has_late_bound_regions<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                    node: hir_map::Node<'tcx>)\n+                                    -> bool {\n+    struct LateBoundRegionsDetector<'a, 'tcx: 'a> {\n+        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        binder_depth: u32,\n+        has_late_bound_regions: bool,\n+    }\n+\n+    impl<'a, 'tcx> Visitor<'tcx> for LateBoundRegionsDetector<'a, 'tcx> {\n+        fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+            NestedVisitorMap::None\n+        }\n+\n+        fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n+            if self.has_late_bound_regions { return }\n+            match ty.node {\n+                hir::TyBareFn(..) => {\n+                    self.binder_depth += 1;\n+                    intravisit::walk_ty(self, ty);\n+                    self.binder_depth -= 1;\n+                }\n+                _ => intravisit::walk_ty(self, ty)\n+            }\n+        }\n+\n+        fn visit_poly_trait_ref(&mut self,\n+                                tr: &'tcx hir::PolyTraitRef,\n+                                m: hir::TraitBoundModifier) {\n+            if self.has_late_bound_regions { return }\n+            self.binder_depth += 1;\n+            intravisit::walk_poly_trait_ref(self, tr, m);\n+            self.binder_depth -= 1;\n+        }\n+\n+        fn visit_lifetime(&mut self, lt: &'tcx hir::Lifetime) {\n+            if self.has_late_bound_regions { return }\n+\n+            match self.tcx.named_region_map.defs.get(&lt.id).cloned() {\n+                Some(rl::Region::Static) | Some(rl::Region::EarlyBound(..)) => {}\n+                Some(rl::Region::LateBound(debruijn, _)) |\n+                Some(rl::Region::LateBoundAnon(debruijn, _))\n+                    if debruijn.depth < self.binder_depth => {}\n+                _ => self.has_late_bound_regions = true,\n+            }\n+        }\n+    }\n+\n+    fn has_late_bound_regions<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                        generics: &'tcx hir::Generics,\n+                                        decl: &'tcx hir::FnDecl)\n+                                        -> bool {\n+        let mut visitor = LateBoundRegionsDetector {\n+            tcx, binder_depth: 1, has_late_bound_regions: false\n+        };\n+        for lifetime in &generics.lifetimes {\n+            if tcx.named_region_map.late_bound.contains(&lifetime.lifetime.id) {\n+                return true;\n+            }\n+        }\n+        visitor.visit_fn_decl(decl);\n+        visitor.has_late_bound_regions\n+    }\n+\n+    match node {\n+        hir_map::NodeTraitItem(item) => match item.node {\n+            hir::TraitItemKind::Method(ref sig, _) =>\n+                has_late_bound_regions(tcx, &sig.generics, &sig.decl),\n+            _ => false,\n+        },\n+        hir_map::NodeImplItem(item) => match item.node {\n+            hir::ImplItemKind::Method(ref sig, _) =>\n+                has_late_bound_regions(tcx, &sig.generics, &sig.decl),\n+            _ => false,\n+        },\n+        hir_map::NodeForeignItem(item) => match item.node {\n+            hir::ForeignItemFn(ref fn_decl, _, ref generics) =>\n+                has_late_bound_regions(tcx, generics, fn_decl),\n+            _ => false,\n+        },\n+        hir_map::NodeItem(item) => match item.node {\n+            hir::ItemFn(ref fn_decl, .., ref generics, _) =>\n+                has_late_bound_regions(tcx, generics, fn_decl),\n+            _ => false,\n+        },\n+        _ => false\n+    }\n+}\n+\n fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                          def_id: DefId)\n                          -> &'tcx ty::Generics {\n@@ -959,7 +1048,8 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         regions: regions,\n         types: types,\n         type_param_to_index: type_param_to_index,\n-        has_self: has_self || parent_has_self\n+        has_self: has_self || parent_has_self,\n+        has_late_bound_regions: has_late_bound_regions(tcx, node),\n     })\n }\n "}, {"sha": "1e26a734e7640d8e90765077522e6dba4ffade1d", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 86, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/83c659ef655b1f740777f83eb415fd7ebe5a3fe5/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83c659ef655b1f740777f83eb415fd7ebe5a3fe5/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=83c659ef655b1f740777f83eb415fd7ebe5a3fe5", "patch": "@@ -332,92 +332,6 @@ fn main() {\n ```\n \"##,\n \n-E0035: r##\"\n-You tried to give a type parameter where it wasn't needed. Erroneous code\n-example:\n-\n-```compile_fail,E0035\n-struct Test;\n-\n-impl Test {\n-    fn method(&self) {}\n-}\n-\n-fn main() {\n-    let x = Test;\n-\n-    x.method::<i32>(); // Error: Test::method doesn't need type parameter!\n-}\n-```\n-\n-To fix this error, just remove the type parameter:\n-\n-```\n-struct Test;\n-\n-impl Test {\n-    fn method(&self) {}\n-}\n-\n-fn main() {\n-    let x = Test;\n-\n-    x.method(); // OK, we're good!\n-}\n-```\n-\"##,\n-\n-E0036: r##\"\n-This error occurrs when you pass too many or not enough type parameters to\n-a method. Erroneous code example:\n-\n-```compile_fail,E0036\n-struct Test;\n-\n-impl Test {\n-    fn method<T>(&self, v: &[T]) -> usize {\n-        v.len()\n-    }\n-}\n-\n-fn main() {\n-    let x = Test;\n-    let v = &[0];\n-\n-    x.method::<i32, i32>(v); // error: only one type parameter is expected!\n-}\n-```\n-\n-To fix it, just specify a correct number of type parameters:\n-\n-```\n-struct Test;\n-\n-impl Test {\n-    fn method<T>(&self, v: &[T]) -> usize {\n-        v.len()\n-    }\n-}\n-\n-fn main() {\n-    let x = Test;\n-    let v = &[0];\n-\n-    x.method::<i32>(v); // OK, we're good!\n-}\n-```\n-\n-Please note on the last example that we could have called `method` like this:\n-\n-```\n-# struct Test;\n-# impl Test { fn method<T>(&self, v: &[T]) -> usize { v.len() } }\n-# let x = Test;\n-# let v = &[0];\n-x.method(v);\n-```\n-\"##,\n-\n E0040: r##\"\n It is not allowed to manually call destructors in Rust. It is also not\n necessary to do this since `drop` is called automatically whenever a value goes\n@@ -4681,6 +4595,8 @@ error, just declare a function.\n }\n \n register_diagnostics! {\n+//  E0035, merged into E0087/E0089\n+//  E0036, merged into E0087/E0089\n //  E0068,\n //  E0085,\n //  E0086,"}, {"sha": "db84a4edc487c98914f839dd8e9f92415f2d8a65", "filename": "src/test/compile-fail/E0088.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/83c659ef655b1f740777f83eb415fd7ebe5a3fe5/src%2Ftest%2Fcompile-fail%2FE0088.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83c659ef655b1f740777f83eb415fd7ebe5a3fe5/src%2Ftest%2Fcompile-fail%2FE0088.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0088.rs?ref=83c659ef655b1f740777f83eb415fd7ebe5a3fe5", "patch": "@@ -9,14 +9,9 @@\n // except according to those terms.\n \n fn f() {}\n-fn g<'a>() {}\n+fn g<'a>() -> &'a u8 { loop {} }\n \n fn main() {\n-    f::<'static>();\n-    //~^ ERROR expected at most 0 lifetime parameters, found 1 lifetime parameter [E0088]\n-    //~| NOTE expected 0 lifetime parameters\n-\n-    g::<'static, 'static>();\n-    //~^ ERROR expected at most 0 lifetime parameters, found 2 lifetime parameters [E0088]\n-    //~| NOTE expected 0 lifetime parameters\n+    f::<'static>(); //~ ERROR E0088\n+    g::<'static, 'static>(); //~ ERROR E0088\n }"}, {"sha": "50db9707355f4e69c2321fa639fbf9d959ae7eba", "filename": "src/test/compile-fail/constructor-lifetime-args.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/83c659ef655b1f740777f83eb415fd7ebe5a3fe5/src%2Ftest%2Fcompile-fail%2Fconstructor-lifetime-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83c659ef655b1f740777f83eb415fd7ebe5a3fe5/src%2Ftest%2Fcompile-fail%2Fconstructor-lifetime-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconstructor-lifetime-args.rs?ref=83c659ef655b1f740777f83eb415fd7ebe5a3fe5", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// All lifetime parameters in struct constructors are currently considered early bound,\n+// i.e. `S::<ARGS>` is interpreted kinda like an associated item `S::<ARGS>::ctor`.\n+// This behavior is a bit weird, because if equivalent constructor were written manually\n+// it would get late bound lifetime parameters.\n+// Variant constructors behave in the same way, lifetime parameters are considered\n+// belonging to the enum and being early bound.\n+// https://github.com/rust-lang/rust/issues/30904\n+\n+struct S<'a, 'b>(&'a u8, &'b u8);\n+enum E<'a, 'b> {\n+    V(&'a u8),\n+    U(&'b u8),\n+}\n+\n+fn main() {\n+    S(&0, &0); // OK\n+    S::<'static>(&0, &0);\n+    //~^ ERROR expected 2 lifetime parameters, found 1 lifetime parameter\n+    S::<'static, 'static, 'static>(&0, &0);\n+    //~^ ERROR expected at most 2 lifetime parameters, found 3 lifetime parameters\n+    E::V(&0); // OK\n+    E::V::<'static>(&0);\n+    //~^ ERROR expected 2 lifetime parameters, found 1 lifetime parameter\n+    E::V::<'static, 'static, 'static>(&0);\n+    //~^ ERROR expected at most 2 lifetime parameters, found 3 lifetime parameters\n+}"}, {"sha": "b2a94e0af420d41a5b045e96521bf4df02a93335", "filename": "src/test/compile-fail/method-call-lifetime-args-lint.rs", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/83c659ef655b1f740777f83eb415fd7ebe5a3fe5/src%2Ftest%2Fcompile-fail%2Fmethod-call-lifetime-args-lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83c659ef655b1f740777f83eb415fd7ebe5a3fe5/src%2Ftest%2Fcompile-fail%2Fmethod-call-lifetime-args-lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmethod-call-lifetime-args-lint.rs?ref=83c659ef655b1f740777f83eb415fd7ebe5a3fe5", "patch": "@@ -0,0 +1,97 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![deny(late_bound_lifetime_arguments)]\n+#![allow(unused)]\n+\n+struct S;\n+\n+impl S {\n+    fn late<'a, 'b>(self, _: &'a u8, _: &'b u8) {}\n+    fn late_implicit(self, _: &u8, _: &u8) {}\n+    fn late_early<'a, 'b>(self, _: &'a u8) -> &'b u8 { loop {} }\n+    fn late_implicit_early<'b>(self, _: &u8) -> &'b u8 { loop {} }\n+\n+    // 'late lifetimes here belong to nested types not to the tested functions.\n+    fn early_tricky_explicit<'a>(_: for<'late> fn(&'late u8),\n+                                 _: Box<for<'late> Fn(&'late u8)>)\n+                                 -> &'a u8 { loop {} }\n+    fn early_tricky_implicit<'a>(_: fn(&u8),\n+                                 _: Box<Fn(&u8)>)\n+                                 -> &'a u8 { loop {} }\n+}\n+\n+fn method_call() {\n+    S.late(&0, &0); // OK\n+    S.late::<'static>(&0, &0);\n+    //~^ ERROR cannot specify lifetime arguments explicitly\n+    //~| WARN this was previously accepted\n+    S.late::<'static, 'static>(&0, &0);\n+    //~^ ERROR cannot specify lifetime arguments explicitly\n+    //~| WARN this was previously accepted\n+    S.late::<'static, 'static, 'static>(&0, &0);\n+    //~^ ERROR cannot specify lifetime arguments explicitly\n+    //~| WARN this was previously accepted\n+    S.late_early(&0); // OK\n+    S.late_early::<'static>(&0);\n+    //~^ ERROR cannot specify lifetime arguments explicitly\n+    //~| WARN this was previously accepted\n+    S.late_early::<'static, 'static>(&0);\n+    //~^ ERROR cannot specify lifetime arguments explicitly\n+    //~| WARN this was previously accepted\n+    S.late_early::<'static, 'static, 'static>(&0);\n+    //~^ ERROR cannot specify lifetime arguments explicitly\n+    //~| WARN this was previously accepted\n+\n+    S.late_implicit(&0, &0); // OK\n+    S.late_implicit::<'static>(&0, &0);\n+    //~^ ERROR cannot specify lifetime arguments explicitly\n+    //~| WARN this was previously accepted\n+    S.late_implicit::<'static, 'static>(&0, &0);\n+    //~^ ERROR cannot specify lifetime arguments explicitly\n+    //~| WARN this was previously accepted\n+    S.late_implicit::<'static, 'static, 'static>(&0, &0);\n+    //~^ ERROR cannot specify lifetime arguments explicitly\n+    //~| WARN this was previously accepted\n+    S.late_implicit_early(&0); // OK\n+    S.late_implicit_early::<'static>(&0);\n+    //~^ ERROR cannot specify lifetime arguments explicitly\n+    //~| WARN this was previously accepted\n+    S.late_implicit_early::<'static, 'static>(&0);\n+    //~^ ERROR cannot specify lifetime arguments explicitly\n+    //~| WARN this was previously accepted\n+    S.late_implicit_early::<'static, 'static, 'static>(&0);\n+    //~^ ERROR cannot specify lifetime arguments explicitly\n+    //~| WARN this was previously accepted\n+\n+    S::early_tricky_explicit::<'static>(loop {}, loop {}); // OK\n+    S::early_tricky_implicit::<'static>(loop {}, loop {}); // OK\n+}\n+\n+fn ufcs() {\n+    S::late_early::<'static>(S, &0);\n+    //~^ ERROR cannot specify lifetime arguments explicitly\n+    //~| WARN this was previously accepted\n+\n+    S::late_implicit_early::<'static>(S, &0);\n+    //~^ ERROR cannot specify lifetime arguments explicitly\n+    //~| WARN this was previously accepted\n+}\n+\n+fn lint_not_inference_error() {\n+    fn f<'early, 'late, T: 'early>() {}\n+\n+    // Make sure `u8` is substituted and not replaced with an inference variable\n+    f::<'static, u8>;\n+    //~^ ERROR cannot specify lifetime arguments explicitly\n+    //~| WARN this was previously accepted\n+}\n+\n+fn main() {}"}, {"sha": "a9505e4f936a1b5bfe89ab821225fdc4002ced45", "filename": "src/test/compile-fail/method-call-lifetime-args-subst-index.rs", "status": "renamed", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/83c659ef655b1f740777f83eb415fd7ebe5a3fe5/src%2Ftest%2Fcompile-fail%2Fmethod-call-lifetime-args-subst-index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83c659ef655b1f740777f83eb415fd7ebe5a3fe5/src%2Ftest%2Fcompile-fail%2Fmethod-call-lifetime-args-subst-index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmethod-call-lifetime-args-subst-index.rs?ref=83c659ef655b1f740777f83eb415fd7ebe5a3fe5", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,17 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct Test;\n+#![feature(rustc_attrs)]\n+#![allow(unused)]\n \n-impl Test {\n-    fn method<T>(&self, v: &[T]) -> usize {\n-        v.len()\n-    }\n+struct S;\n+\n+impl S {\n+    fn early_and_type<'a, T>(self) -> &'a T { loop {} }\n }\n \n-fn main() {\n-    let x = Test;\n-    let v = &[0];\n-    x.method::<i32, i32>(v); //~ ERROR E0036\n-                             //~| NOTE Passed 2 type arguments, expected 1\n+fn test() {\n+    S.early_and_type::<u16>();\n }\n+\n+#[rustc_error]\n+fn main() {} //~ ERROR compilation successful", "previous_filename": "src/test/compile-fail/E0036.rs"}, {"sha": "4910bfaf4f60d7c98830968b0dc08881c8fd08bc", "filename": "src/test/compile-fail/method-call-lifetime-args-unresolved.rs", "status": "renamed", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/83c659ef655b1f740777f83eb415fd7ebe5a3fe5/src%2Ftest%2Fcompile-fail%2Fmethod-call-lifetime-args-unresolved.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83c659ef655b1f740777f83eb415fd7ebe5a3fe5/src%2Ftest%2Fcompile-fail%2Fmethod-call-lifetime-args-unresolved.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmethod-call-lifetime-args-unresolved.rs?ref=83c659ef655b1f740777f83eb415fd7ebe5a3fe5", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,14 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct Test;\n-\n-impl Test {\n-    fn method(&self) {}\n-}\n-\n fn main() {\n-    let x = Test;\n-    x.method::<i32>(); //~ ERROR E0035\n-                       //~| NOTE called with unneeded type parameters\n+    0.clone::<'a>(); //~ ERROR use of undeclared lifetime name `'a`\n }", "previous_filename": "src/test/compile-fail/E0035.rs"}, {"sha": "f0a87c7470386b3f3500e2bead3446e0d3ef7ce7", "filename": "src/test/compile-fail/method-call-lifetime-args.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/83c659ef655b1f740777f83eb415fd7ebe5a3fe5/src%2Ftest%2Fcompile-fail%2Fmethod-call-lifetime-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83c659ef655b1f740777f83eb415fd7ebe5a3fe5/src%2Ftest%2Fcompile-fail%2Fmethod-call-lifetime-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmethod-call-lifetime-args.rs?ref=83c659ef655b1f740777f83eb415fd7ebe5a3fe5", "patch": "@@ -0,0 +1,82 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct S;\n+\n+impl S {\n+    fn late<'a, 'b>(self, _: &'a u8, _: &'b u8) {}\n+    fn late_implicit(self, _: &u8, _: &u8) {}\n+    fn early<'a, 'b>(self) -> (&'a u8, &'b u8) { loop {} }\n+    fn late_early<'a, 'b>(self, _: &'a u8) -> &'b u8 { loop {} }\n+    fn late_implicit_early<'b>(self, _: &u8) -> &'b u8 { loop {} }\n+    fn late_implicit_self_early<'b>(&self) -> &'b u8 { loop {} }\n+    fn late_unused_early<'a, 'b>(self) -> &'b u8 { loop {} }\n+    fn life_and_type<'a, T>(self) -> &'a T { loop {} }\n+}\n+\n+fn method_call() {\n+    S.early(); // OK\n+    S.early::<'static>();\n+    //~^ ERROR expected 2 lifetime parameters, found 1 lifetime parameter\n+    S.early::<'static, 'static, 'static>();\n+    //~^ ERROR expected at most 2 lifetime parameters, found 3 lifetime parameters\n+    let _: &u8 = S.life_and_type::<'static>();\n+    S.life_and_type::<u8>();\n+    S.life_and_type::<'static, u8>();\n+}\n+\n+fn ufcs() {\n+    S::late(S, &0, &0); // OK\n+    S::late::<'static>(S, &0, &0);\n+    //~^ ERROR cannot specify lifetime arguments explicitly\n+    S::late::<'static, 'static>(S, &0, &0);\n+    //~^ ERROR cannot specify lifetime arguments explicitly\n+    S::late::<'static, 'static, 'static>(S, &0, &0);\n+    //~^ ERROR cannot specify lifetime arguments explicitly\n+    S::late_early(S, &0); // OK\n+    S::late_early::<'static, 'static>(S, &0);\n+    //~^ ERROR cannot specify lifetime arguments explicitly\n+    S::late_early::<'static, 'static, 'static>(S, &0);\n+    //~^ ERROR cannot specify lifetime arguments explicitly\n+\n+    S::late_implicit(S, &0, &0); // OK\n+    S::late_implicit::<'static>(S, &0, &0);\n+    //~^ ERROR cannot specify lifetime arguments explicitly\n+    S::late_implicit::<'static, 'static>(S, &0, &0);\n+    //~^ ERROR cannot specify lifetime arguments explicitly\n+    S::late_implicit::<'static, 'static, 'static>(S, &0, &0);\n+    //~^ ERROR cannot specify lifetime arguments explicitly\n+    S::late_implicit_early(S, &0); // OK\n+    S::late_implicit_early::<'static, 'static>(S, &0);\n+    //~^ ERROR cannot specify lifetime arguments explicitly\n+    S::late_implicit_early::<'static, 'static, 'static>(S, &0);\n+    //~^ ERROR cannot specify lifetime arguments explicitly\n+    S::late_implicit_self_early(&S); // OK\n+    S::late_implicit_self_early::<'static, 'static>(&S);\n+    //~^ ERROR cannot specify lifetime arguments explicitly\n+    S::late_implicit_self_early::<'static, 'static, 'static>(&S);\n+    //~^ ERROR cannot specify lifetime arguments explicitly\n+    S::late_unused_early(S); // OK\n+    S::late_unused_early::<'static, 'static>(S);\n+    //~^ ERROR cannot specify lifetime arguments explicitly\n+    S::late_unused_early::<'static, 'static, 'static>(S);\n+    //~^ ERROR cannot specify lifetime arguments explicitly\n+\n+    S::early(S); // OK\n+    S::early::<'static>(S);\n+    //~^ ERROR expected 2 lifetime parameters, found 1 lifetime parameter\n+    S::early::<'static, 'static, 'static>(S);\n+    //~^ ERROR expected at most 2 lifetime parameters, found 3 lifetime parameters\n+    let _: &u8 = S::life_and_type::<'static>(S);\n+    S::life_and_type::<u8>(S);\n+    S::life_and_type::<'static, u8>(S);\n+}\n+\n+fn main() {}"}, {"sha": "3ae878ed1cbc0659929d47885f8daaa90ce154ab", "filename": "src/test/compile-fail/method-call-type-binding.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83c659ef655b1f740777f83eb415fd7ebe5a3fe5/src%2Ftest%2Fcompile-fail%2Fmethod-call-type-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83c659ef655b1f740777f83eb415fd7ebe5a3fe5/src%2Ftest%2Fcompile-fail%2Fmethod-call-type-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmethod-call-type-binding.rs?ref=83c659ef655b1f740777f83eb415fd7ebe5a3fe5", "patch": "@@ -9,5 +9,5 @@\n // except according to those terms.\n \n fn main() {\n-    0.clone::<T = u8>(); //~ ERROR type bindings cannot be used in method calls\n+    0.clone::<T = u8>(); //~ ERROR unexpected binding of associated item\n }"}, {"sha": "b08aab6da852a71c6dfd3db0dce616c0d737a18b", "filename": "src/test/compile-fail/trait-test-2.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/83c659ef655b1f740777f83eb415fd7ebe5a3fe5/src%2Ftest%2Fcompile-fail%2Ftrait-test-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83c659ef655b1f740777f83eb415fd7ebe5a3fe5/src%2Ftest%2Fcompile-fail%2Ftrait-test-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-test-2.rs?ref=83c659ef655b1f740777f83eb415fd7ebe5a3fe5", "patch": "@@ -15,9 +15,8 @@ impl bar for i32 { fn dup(&self) -> i32 { *self } fn blah<X>(&self) {} }\n impl bar for u32 { fn dup(&self) -> u32 { *self } fn blah<X>(&self) {} }\n \n fn main() {\n-    10.dup::<i32>(); //~ ERROR does not take type parameters\n-    10.blah::<i32, i32>();\n-    //~^ ERROR incorrect number of type parameters given for this method: expected 1, found 2\n+    10.dup::<i32>(); //~ ERROR expected at most 0 type parameters, found 1 type parameter\n+    10.blah::<i32, i32>(); //~ ERROR expected at most 1 type parameter, found 2 type parameters\n     (box 10 as Box<bar>).dup();\n     //~^ ERROR E0038\n     //~| ERROR E0038"}, {"sha": "daddc0c9f5459a3af5c09c80158be76b96651db5", "filename": "src/test/incremental/hashes/inherent_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83c659ef655b1f740777f83eb415fd7ebe5a3fe5/src%2Ftest%2Fincremental%2Fhashes%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83c659ef655b1f740777f83eb415fd7ebe5a3fe5/src%2Ftest%2Fincremental%2Fhashes%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Finherent_impls.rs?ref=83c659ef655b1f740777f83eb415fd7ebe5a3fe5", "patch": "@@ -369,7 +369,7 @@ impl Foo {\n impl Foo {\n     #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n     #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-    #[rustc_metadata_clean(cfg=\"cfail2\")] // Apparently unused lifetimes don't show up in the type.\n+    #[rustc_metadata_clean(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     pub fn add_lifetime_parameter_to_method<'a>(&self) { }\n }"}, {"sha": "44950ee8a601f90865698e22d955bc9a07344bf5", "filename": "src/test/incremental/hashes/trait_defs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83c659ef655b1f740777f83eb415fd7ebe5a3fe5/src%2Ftest%2Fincremental%2Fhashes%2Ftrait_defs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83c659ef655b1f740777f83eb415fd7ebe5a3fe5/src%2Ftest%2Fincremental%2Fhashes%2Ftrait_defs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Ftrait_defs.rs?ref=83c659ef655b1f740777f83eb415fd7ebe5a3fe5", "patch": "@@ -448,7 +448,7 @@ trait TraitAddLifetimeParameterToMethod {\n trait TraitAddLifetimeParameterToMethod {\n     #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n     #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-    #[rustc_metadata_clean(cfg=\"cfail2\")] // Unused lifetimes don't seem to show up in type?\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     fn method<'a>();\n }"}]}