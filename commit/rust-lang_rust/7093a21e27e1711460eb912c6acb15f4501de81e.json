{"sha": "7093a21e27e1711460eb912c6acb15f4501de81e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwOTNhMjFlMjdlMTcxMTQ2MGViOTEyYzZhY2IxNWY0NTAxZGU4MWU=", "commit": {"author": {"name": "LeSeulArtichaut", "email": "leseulartichaut@gmail.com", "date": "2021-05-13T20:01:25Z"}, "committer": {"name": "LeSeulArtichaut", "email": "leseulartichaut@gmail.com", "date": "2021-05-19T14:03:41Z"}, "message": "Adapt the THIR visitor to the vec-stored THIR", "tree": {"sha": "ebcd0a3c0fc6a1bc18bdc03317c7c52a661f8f99", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ebcd0a3c0fc6a1bc18bdc03317c7c52a661f8f99"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7093a21e27e1711460eb912c6acb15f4501de81e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7093a21e27e1711460eb912c6acb15f4501de81e", "html_url": "https://github.com/rust-lang/rust/commit/7093a21e27e1711460eb912c6acb15f4501de81e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7093a21e27e1711460eb912c6acb15f4501de81e/comments", "author": {"login": "LeSeulArtichaut", "id": 38361244, "node_id": "MDQ6VXNlcjM4MzYxMjQ0", "avatar_url": "https://avatars.githubusercontent.com/u/38361244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LeSeulArtichaut", "html_url": "https://github.com/LeSeulArtichaut", "followers_url": "https://api.github.com/users/LeSeulArtichaut/followers", "following_url": "https://api.github.com/users/LeSeulArtichaut/following{/other_user}", "gists_url": "https://api.github.com/users/LeSeulArtichaut/gists{/gist_id}", "starred_url": "https://api.github.com/users/LeSeulArtichaut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LeSeulArtichaut/subscriptions", "organizations_url": "https://api.github.com/users/LeSeulArtichaut/orgs", "repos_url": "https://api.github.com/users/LeSeulArtichaut/repos", "events_url": "https://api.github.com/users/LeSeulArtichaut/events{/privacy}", "received_events_url": "https://api.github.com/users/LeSeulArtichaut/received_events", "type": "User", "site_admin": false}, "committer": {"login": "LeSeulArtichaut", "id": 38361244, "node_id": "MDQ6VXNlcjM4MzYxMjQ0", "avatar_url": "https://avatars.githubusercontent.com/u/38361244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LeSeulArtichaut", "html_url": "https://github.com/LeSeulArtichaut", "followers_url": "https://api.github.com/users/LeSeulArtichaut/followers", "following_url": "https://api.github.com/users/LeSeulArtichaut/following{/other_user}", "gists_url": "https://api.github.com/users/LeSeulArtichaut/gists{/gist_id}", "starred_url": "https://api.github.com/users/LeSeulArtichaut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LeSeulArtichaut/subscriptions", "organizations_url": "https://api.github.com/users/LeSeulArtichaut/orgs", "repos_url": "https://api.github.com/users/LeSeulArtichaut/repos", "events_url": "https://api.github.com/users/LeSeulArtichaut/events{/privacy}", "received_events_url": "https://api.github.com/users/LeSeulArtichaut/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc3eabd48700863075bd986a497fbe4f227aa33b", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc3eabd48700863075bd986a497fbe4f227aa33b", "html_url": "https://github.com/rust-lang/rust/commit/dc3eabd48700863075bd986a497fbe4f227aa33b"}], "stats": {"total": 191, "additions": 96, "deletions": 95}, "files": [{"sha": "3ef1155b91688fc106ae1f668ba0f73299a29e12", "filename": "compiler/rustc_mir_build/src/check_unsafety.rs", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/7093a21e27e1711460eb912c6acb15f4501de81e/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7093a21e27e1711460eb912c6acb15f4501de81e/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs?ref=7093a21e27e1711460eb912c6acb15f4501de81e", "patch": "@@ -9,8 +9,9 @@ use rustc_session::lint::Level;\n use rustc_span::def_id::{DefId, LocalDefId};\n use rustc_span::Span;\n \n-struct UnsafetyVisitor<'tcx> {\n+struct UnsafetyVisitor<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n+    thir: &'a Thir<'tcx>,\n     /// The `HirId` of the current scope, which would be the `HirId`\n     /// of the current HIR node, modulo adjustments. Used for lint levels.\n     hir_context: hir::HirId,\n@@ -20,7 +21,7 @@ struct UnsafetyVisitor<'tcx> {\n     body_unsafety: BodyUnsafety,\n }\n \n-impl<'tcx> UnsafetyVisitor<'tcx> {\n+impl<'tcx> UnsafetyVisitor<'_, 'tcx> {\n     fn in_safety_context<R>(\n         &mut self,\n         safety_context: SafetyContext,\n@@ -127,8 +128,12 @@ impl<'tcx> UnsafetyVisitor<'tcx> {\n     }\n }\n \n-impl<'thir, 'tcx> Visitor<'thir, 'tcx> for UnsafetyVisitor<'tcx> {\n-    fn visit_block(&mut self, block: &Block<'thir, 'tcx>) {\n+impl<'a, 'tcx> Visitor<'a, 'tcx> for UnsafetyVisitor<'a, 'tcx> {\n+    fn thir(&self) -> &'a Thir<'tcx> {\n+        &self.thir\n+    }\n+\n+    fn visit_block(&mut self, block: &Block) {\n         if let BlockSafety::ExplicitUnsafe(hir_id) = block.safety_mode {\n             self.in_safety_context(\n                 SafetyContext::UnsafeBlock { span: block.span, hir_id, used: false },\n@@ -139,17 +144,17 @@ impl<'thir, 'tcx> Visitor<'thir, 'tcx> for UnsafetyVisitor<'tcx> {\n         }\n     }\n \n-    fn visit_expr(&mut self, expr: &'thir Expr<'thir, 'tcx>) {\n+    fn visit_expr(&mut self, expr: &Expr<'tcx>) {\n         match expr.kind {\n             ExprKind::Scope { value, lint_level: LintLevel::Explicit(hir_id), region_scope: _ } => {\n                 let prev_id = self.hir_context;\n                 self.hir_context = hir_id;\n-                self.visit_expr(value);\n+                self.visit_expr(&self.thir[value]);\n                 self.hir_context = prev_id;\n                 return;\n             }\n             ExprKind::Call { fun, ty: _, args: _, from_hir_call: _, fn_span: _ } => {\n-                if fun.ty.fn_sig(self.tcx).unsafety() == hir::Unsafety::Unsafe {\n+                if self.thir[fun].ty.fn_sig(self.tcx).unsafety() == hir::Unsafety::Unsafe {\n                     self.requires_unsafe(expr.span, CallToUnsafeFunction);\n                 }\n             }\n@@ -293,7 +298,12 @@ impl UnsafeOpKind {\n \n // FIXME: checking unsafety for closures should be handled by their parent body,\n // as they inherit their \"safety context\" from their declaration site.\n-pub fn check_unsafety<'tcx>(tcx: TyCtxt<'tcx>, thir: &Expr<'_, 'tcx>, hir_id: hir::HirId) {\n+pub fn check_unsafety<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    thir: &Thir<'tcx>,\n+    expr: ExprId,\n+    hir_id: hir::HirId,\n+) {\n     let body_unsafety = tcx.hir().fn_sig_by_hir_id(hir_id).map_or(BodyUnsafety::Safe, |fn_sig| {\n         if fn_sig.header.unsafety == hir::Unsafety::Unsafe {\n             BodyUnsafety::Unsafe(fn_sig.span)\n@@ -303,8 +313,9 @@ pub fn check_unsafety<'tcx>(tcx: TyCtxt<'tcx>, thir: &Expr<'_, 'tcx>, hir_id: hi\n     });\n     let safety_context =\n         if body_unsafety.is_unsafe() { SafetyContext::UnsafeFn } else { SafetyContext::Safe };\n-    let mut visitor = UnsafetyVisitor { tcx, safety_context, hir_context: hir_id, body_unsafety };\n-    visitor.visit_expr(thir);\n+    let mut visitor =\n+        UnsafetyVisitor { tcx, thir, safety_context, hir_context: hir_id, body_unsafety };\n+    visitor.visit_expr(&thir[expr]);\n }\n \n crate fn thir_check_unsafety_inner<'tcx>(\n@@ -314,10 +325,8 @@ crate fn thir_check_unsafety_inner<'tcx>(\n     let hir_id = tcx.hir().local_def_id_to_hir_id(def.did);\n     let body_id = tcx.hir().body_owned_by(hir_id);\n     let body = tcx.hir().body(body_id);\n-\n-    let arena = Arena::default();\n-    let thir = cx::build_thir(tcx, def, &arena, &body.value);\n-    check_unsafety(tcx, thir, hir_id);\n+    let (thir, expr) = cx::build_thir(tcx, def, &body.value);\n+    check_unsafety(tcx, &thir, expr, hir_id);\n }\n \n crate fn thir_check_unsafety<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) {"}, {"sha": "671d1fe9b0305ed1600ff57d4fb4f56e828133f6", "filename": "compiler/rustc_mir_build/src/thir/visit.rs", "status": "modified", "additions": 73, "deletions": 81, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/7093a21e27e1711460eb912c6acb15f4501de81e/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7093a21e27e1711460eb912c6acb15f4501de81e/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fvisit.rs?ref=7093a21e27e1711460eb912c6acb15f4501de81e", "patch": "@@ -1,123 +1,124 @@\n use crate::thir::*;\n \n-pub trait Visitor<'thir, 'tcx>: Sized {\n-    fn visit_expr(&mut self, expr: &'thir Expr<'thir, 'tcx>) {\n+pub trait Visitor<'a, 'tcx: 'a>: Sized {\n+    fn thir(&self) -> &'a Thir<'tcx>;\n+\n+    fn visit_expr(&mut self, expr: &Expr<'tcx>) {\n         walk_expr(self, expr);\n     }\n \n-    fn visit_stmt(&mut self, stmt: &'thir Stmt<'thir, 'tcx>) {\n+    fn visit_stmt(&mut self, stmt: &Stmt<'tcx>) {\n         walk_stmt(self, stmt);\n     }\n \n-    fn visit_block(&mut self, block: &Block<'thir, 'tcx>) {\n+    fn visit_block(&mut self, block: &Block) {\n         walk_block(self, block);\n     }\n \n-    fn visit_arm(&mut self, arm: &'thir Arm<'thir, 'tcx>) {\n+    fn visit_arm(&mut self, arm: &Arm<'tcx>) {\n         walk_arm(self, arm);\n     }\n \n     fn visit_const(&mut self, _cnst: &'tcx Const<'tcx>) {}\n }\n \n-pub fn walk_expr<'thir, 'tcx, V: Visitor<'thir, 'tcx>>(\n-    visitor: &mut V,\n-    expr: &'thir Expr<'thir, 'tcx>,\n-) {\n+pub fn walk_expr<'a, 'tcx: 'a, V: Visitor<'a, 'tcx>>(visitor: &mut V, expr: &Expr<'tcx>) {\n     use ExprKind::*;\n     match expr.kind {\n-        Scope { value, region_scope: _, lint_level: _ } => visitor.visit_expr(value),\n-        Box { value } => visitor.visit_expr(value),\n+        Scope { value, region_scope: _, lint_level: _ } => {\n+            visitor.visit_expr(&visitor.thir()[value])\n+        }\n+        Box { value } => visitor.visit_expr(&visitor.thir()[value]),\n         If { cond, then, else_opt } => {\n-            visitor.visit_expr(cond);\n-            visitor.visit_expr(then);\n+            visitor.visit_expr(&visitor.thir()[cond]);\n+            visitor.visit_expr(&visitor.thir()[then]);\n             if let Some(else_expr) = else_opt {\n-                visitor.visit_expr(else_expr);\n+                visitor.visit_expr(&visitor.thir()[else_expr]);\n             }\n         }\n-        Call { fun, args, ty: _, from_hir_call: _, fn_span: _ } => {\n-            visitor.visit_expr(fun);\n-            for arg in args {\n-                visitor.visit_expr(arg);\n+        Call { fun, ref args, ty: _, from_hir_call: _, fn_span: _ } => {\n+            visitor.visit_expr(&visitor.thir()[fun]);\n+            for &arg in &**args {\n+                visitor.visit_expr(&visitor.thir()[arg]);\n             }\n         }\n-        Deref { arg } => visitor.visit_expr(arg),\n+        Deref { arg } => visitor.visit_expr(&visitor.thir()[arg]),\n         Binary { lhs, rhs, op: _ } | LogicalOp { lhs, rhs, op: _ } => {\n-            visitor.visit_expr(lhs);\n-            visitor.visit_expr(rhs);\n-        }\n-        Unary { arg, op: _ } => visitor.visit_expr(arg),\n-        Cast { source } => visitor.visit_expr(source),\n-        Use { source } => visitor.visit_expr(source),\n-        NeverToAny { source } => visitor.visit_expr(source),\n-        Pointer { source, cast: _ } => visitor.visit_expr(source),\n-        Loop { body } => visitor.visit_expr(body),\n-        Match { scrutinee, arms } => {\n-            visitor.visit_expr(scrutinee);\n-            for arm in arms {\n-                visitor.visit_arm(arm);\n+            visitor.visit_expr(&visitor.thir()[lhs]);\n+            visitor.visit_expr(&visitor.thir()[rhs]);\n+        }\n+        Unary { arg, op: _ } => visitor.visit_expr(&visitor.thir()[arg]),\n+        Cast { source } => visitor.visit_expr(&visitor.thir()[source]),\n+        Use { source } => visitor.visit_expr(&visitor.thir()[source]),\n+        NeverToAny { source } => visitor.visit_expr(&visitor.thir()[source]),\n+        Pointer { source, cast: _ } => visitor.visit_expr(&visitor.thir()[source]),\n+        Loop { body } => visitor.visit_expr(&visitor.thir()[body]),\n+        Match { scrutinee, ref arms } => {\n+            visitor.visit_expr(&visitor.thir()[scrutinee]);\n+            for &arm in &**arms {\n+                visitor.visit_arm(&visitor.thir()[arm]);\n             }\n         }\n         Block { ref body } => visitor.visit_block(body),\n         Assign { lhs, rhs } | AssignOp { lhs, rhs, op: _ } => {\n-            visitor.visit_expr(lhs);\n-            visitor.visit_expr(rhs);\n+            visitor.visit_expr(&visitor.thir()[lhs]);\n+            visitor.visit_expr(&visitor.thir()[rhs]);\n         }\n-        Field { lhs, name: _ } => visitor.visit_expr(lhs),\n+        Field { lhs, name: _ } => visitor.visit_expr(&visitor.thir()[lhs]),\n         Index { lhs, index } => {\n-            visitor.visit_expr(lhs);\n-            visitor.visit_expr(index);\n+            visitor.visit_expr(&visitor.thir()[lhs]);\n+            visitor.visit_expr(&visitor.thir()[index]);\n         }\n         VarRef { id: _ } | UpvarRef { closure_def_id: _, var_hir_id: _ } => {}\n-        Borrow { arg, borrow_kind: _ } => visitor.visit_expr(arg),\n-        AddressOf { arg, mutability: _ } => visitor.visit_expr(arg),\n+        Borrow { arg, borrow_kind: _ } => visitor.visit_expr(&visitor.thir()[arg]),\n+        AddressOf { arg, mutability: _ } => visitor.visit_expr(&visitor.thir()[arg]),\n         Break { value, label: _ } => {\n             if let Some(value) = value {\n-                visitor.visit_expr(value)\n+                visitor.visit_expr(&visitor.thir()[value])\n             }\n         }\n         Continue { label: _ } => {}\n         Return { value } => {\n             if let Some(value) = value {\n-                visitor.visit_expr(value)\n+                visitor.visit_expr(&visitor.thir()[value])\n             }\n         }\n         ConstBlock { value } => visitor.visit_const(value),\n         Repeat { value, count } => {\n-            visitor.visit_expr(value);\n+            visitor.visit_expr(&visitor.thir()[value]);\n             visitor.visit_const(count);\n         }\n-        Array { fields } | Tuple { fields } => {\n-            for field in fields {\n-                visitor.visit_expr(field);\n+        Array { ref fields } | Tuple { ref fields } => {\n+            for &field in &**fields {\n+                visitor.visit_expr(&visitor.thir()[field]);\n             }\n         }\n-        Adt { fields, ref base, adt_def: _, variant_index: _, substs: _, user_ty: _ } => {\n-            for field in fields {\n-                visitor.visit_expr(field.expr);\n+        Adt { ref fields, ref base, adt_def: _, variant_index: _, substs: _, user_ty: _ } => {\n+            for field in &**fields {\n+                visitor.visit_expr(&visitor.thir()[field.expr]);\n             }\n             if let Some(base) = base {\n-                visitor.visit_expr(base.base);\n+                visitor.visit_expr(&visitor.thir()[base.base]);\n             }\n         }\n         PlaceTypeAscription { source, user_ty: _ } | ValueTypeAscription { source, user_ty: _ } => {\n-            visitor.visit_expr(source)\n+            visitor.visit_expr(&visitor.thir()[source])\n         }\n         Closure { closure_id: _, substs: _, upvars: _, movability: _, fake_reads: _ } => {}\n         Literal { literal, user_ty: _, const_id: _ } => visitor.visit_const(literal),\n         StaticRef { literal, def_id: _ } => visitor.visit_const(literal),\n-        InlineAsm { operands, template: _, options: _, line_spans: _ } => {\n-            for op in operands {\n+        InlineAsm { ref operands, template: _, options: _, line_spans: _ } => {\n+            for op in &**operands {\n                 use InlineAsmOperand::*;\n                 match op {\n                     In { expr, reg: _ }\n                     | Out { expr: Some(expr), reg: _, late: _ }\n                     | InOut { expr, reg: _, late: _ }\n-                    | SymFn { expr } => visitor.visit_expr(expr),\n+                    | SymFn { expr } => visitor.visit_expr(&visitor.thir()[*expr]),\n                     SplitInOut { in_expr, out_expr, reg: _, late: _ } => {\n-                        visitor.visit_expr(in_expr);\n+                        visitor.visit_expr(&visitor.thir()[*in_expr]);\n                         if let Some(out_expr) = out_expr {\n-                            visitor.visit_expr(out_expr);\n+                            visitor.visit_expr(&visitor.thir()[*out_expr]);\n                         }\n                     }\n                     Out { expr: None, reg: _, late: _ }\n@@ -127,24 +128,21 @@ pub fn walk_expr<'thir, 'tcx, V: Visitor<'thir, 'tcx>>(\n             }\n         }\n         ThreadLocalRef(_) => {}\n-        LlvmInlineAsm { outputs, inputs, asm: _ } => {\n-            for out_expr in outputs {\n-                visitor.visit_expr(out_expr);\n+        LlvmInlineAsm { ref outputs, ref inputs, asm: _ } => {\n+            for &out_expr in &**outputs {\n+                visitor.visit_expr(&visitor.thir()[out_expr]);\n             }\n-            for in_expr in inputs {\n-                visitor.visit_expr(in_expr);\n+            for &in_expr in &**inputs {\n+                visitor.visit_expr(&visitor.thir()[in_expr]);\n             }\n         }\n-        Yield { value } => visitor.visit_expr(value),\n+        Yield { value } => visitor.visit_expr(&visitor.thir()[value]),\n     }\n }\n \n-pub fn walk_stmt<'thir, 'tcx, V: Visitor<'thir, 'tcx>>(\n-    visitor: &mut V,\n-    stmt: &'thir Stmt<'thir, 'tcx>,\n-) {\n+pub fn walk_stmt<'a, 'tcx: 'a, V: Visitor<'a, 'tcx>>(visitor: &mut V, stmt: &Stmt<'tcx>) {\n     match stmt.kind {\n-        StmtKind::Expr { expr, scope: _ } => visitor.visit_expr(expr),\n+        StmtKind::Expr { expr, scope: _ } => visitor.visit_expr(&visitor.thir()[expr]),\n         StmtKind::Let {\n             initializer,\n             remainder_scope: _,\n@@ -153,34 +151,28 @@ pub fn walk_stmt<'thir, 'tcx, V: Visitor<'thir, 'tcx>>(\n             lint_level: _,\n         } => {\n             if let Some(init) = initializer {\n-                visitor.visit_expr(init);\n+                visitor.visit_expr(&visitor.thir()[init]);\n             }\n         }\n     }\n }\n \n-pub fn walk_block<'thir, 'tcx, V: Visitor<'thir, 'tcx>>(\n-    visitor: &mut V,\n-    block: &Block<'thir, 'tcx>,\n-) {\n-    for stmt in block.stmts {\n-        visitor.visit_stmt(stmt);\n+pub fn walk_block<'a, 'tcx: 'a, V: Visitor<'a, 'tcx>>(visitor: &mut V, block: &Block) {\n+    for &stmt in &*block.stmts {\n+        visitor.visit_stmt(&visitor.thir()[stmt]);\n     }\n     if let Some(expr) = block.expr {\n-        visitor.visit_expr(expr);\n+        visitor.visit_expr(&visitor.thir()[expr]);\n     }\n }\n \n-pub fn walk_arm<'thir, 'tcx, V: Visitor<'thir, 'tcx>>(\n-    visitor: &mut V,\n-    arm: &'thir Arm<'thir, 'tcx>,\n-) {\n+pub fn walk_arm<'a, 'tcx: 'a, V: Visitor<'a, 'tcx>>(visitor: &mut V, arm: &Arm<'tcx>) {\n     match arm.guard {\n-        Some(Guard::If(expr)) => visitor.visit_expr(expr),\n+        Some(Guard::If(expr)) => visitor.visit_expr(&visitor.thir()[expr]),\n         Some(Guard::IfLet(ref _pat, expr)) => {\n-            visitor.visit_expr(expr);\n+            visitor.visit_expr(&visitor.thir()[expr]);\n         }\n         None => {}\n     }\n-    visitor.visit_expr(arm.body);\n+    visitor.visit_expr(&visitor.thir()[arm.body]);\n }"}]}