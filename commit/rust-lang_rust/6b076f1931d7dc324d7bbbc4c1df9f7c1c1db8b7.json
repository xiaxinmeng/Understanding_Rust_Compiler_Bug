{"sha": "6b076f1931d7dc324d7bbbc4c1df9f7c1c1db8b7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiMDc2ZjE5MzFkN2RjMzI0ZDdiYmJjNGMxZGY5ZjdjMWMxZGI4Yjc=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-01-26T21:52:04Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-02-01T21:45:23Z"}, "message": "Use new Resolver API in type inference", "tree": {"sha": "131f12f5b0c9ea0ea499b8d4e9ff0c5112192352", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/131f12f5b0c9ea0ea499b8d4e9ff0c5112192352"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6b076f1931d7dc324d7bbbc4c1df9f7c1c1db8b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6b076f1931d7dc324d7bbbc4c1df9f7c1c1db8b7", "html_url": "https://github.com/rust-lang/rust/commit/6b076f1931d7dc324d7bbbc4c1df9f7c1c1db8b7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6b076f1931d7dc324d7bbbc4c1df9f7c1c1db8b7/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "758bc72873efe36f579236d1abf240d14866fd82", "url": "https://api.github.com/repos/rust-lang/rust/commits/758bc72873efe36f579236d1abf240d14866fd82", "html_url": "https://github.com/rust-lang/rust/commit/758bc72873efe36f579236d1abf240d14866fd82"}], "stats": {"total": 546, "additions": 296, "deletions": 250}, "files": [{"sha": "6a5377f8ed0dbcd4cb98a3c4b0af63fbaec7137b", "filename": ".gitignore", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6b076f1931d7dc324d7bbbc4c1df9f7c1c1db8b7/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/6b076f1931d7dc324d7bbbc4c1df9f7c1c1db8b7/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=6b076f1931d7dc324d7bbbc4c1df9f7c1c1db8b7", "patch": "@@ -5,3 +5,4 @@ crates/*/target\n *.log\n *.iml\n .vscode/settings.json\n+**/*.snap.new"}, {"sha": "92ab0f6922cab410c973d9c7dc50509ddac46ebe", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 32, "deletions": 7, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/6b076f1931d7dc324d7bbbc4c1df9f7c1c1db8b7/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b076f1931d7dc324d7bbbc4c1df9f7c1c1db8b7/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=6b076f1931d7dc324d7bbbc4c1df9f7c1c1db8b7", "patch": "@@ -5,7 +5,7 @@ use ra_db::{CrateId, FileId};\n use ra_syntax::{ast::self, TreeArc, SyntaxNode};\n \n use crate::{\n-    Name, Path, PerNs, ScopesWithSyntaxMapping, Ty, HirFileId,\n+    Name, ScopesWithSyntaxMapping, Ty, HirFileId,\n     type_ref::TypeRef,\n     nameres::{ModuleScope, lower::ImportId},\n     HirDatabase, PersistentHirDatabase,\n@@ -175,18 +175,13 @@ impl Module {\n         db.item_map(self.krate)[self.module_id].clone()\n     }\n \n-    pub fn resolve_path(&self, db: &impl PersistentHirDatabase, path: &Path) -> PerNs<ModuleDef> {\n-        // TODO replace by Resolver::resolve_path\n-        db.item_map(self.krate).resolve_path(db, *self, path)\n-    }\n-\n     pub fn problems(&self, db: &impl HirDatabase) -> Vec<(TreeArc<SyntaxNode>, Problem)> {\n         self.problems_impl(db)\n     }\n \n     pub fn resolver(&self, db: &impl HirDatabase) -> Resolver {\n         let item_map = db.item_map(self.krate);\n-        Resolver::default().push_module_scope(item_map, self.module_id)\n+        Resolver::default().push_module_scope(item_map, *self)\n     }\n }\n \n@@ -289,6 +284,21 @@ impl Struct {\n     pub fn ty(&self, db: &impl HirDatabase) -> Ty {\n         db.type_for_def((*self).into())\n     }\n+\n+    // TODO move to a more general type\n+    /// Builds a resolver for type references inside this struct.\n+    pub fn resolver(&self, db: &impl HirDatabase) -> Resolver {\n+        // take the outer scope...\n+        let r = self.module(db).resolver(db);\n+        // ...and add generic params, if present\n+        let p = self.generic_params(db);\n+        let r = if !p.params.is_empty() {\n+            r.push_generic_params_scope(p)\n+        } else {\n+            r\n+        };\n+        r\n+    }\n }\n \n impl Docs for Struct {\n@@ -338,6 +348,21 @@ impl Enum {\n     pub fn ty(&self, db: &impl HirDatabase) -> Ty {\n         db.type_for_def((*self).into())\n     }\n+\n+    // TODO move to a more general type\n+    /// Builds a resolver for type references inside this struct.\n+    pub fn resolver(&self, db: &impl HirDatabase) -> Resolver {\n+        // take the outer scope...\n+        let r = self.module(db).resolver(db);\n+        // ...and add generic params, if present\n+        let p = self.generic_params(db);\n+        let r = if !p.params.is_empty() {\n+            r.push_generic_params_scope(p)\n+        } else {\n+            r\n+        };\n+        r\n+    }\n }\n \n impl Docs for Enum {"}, {"sha": "503a09f25e58cb008d1b70a2ae5d4c37ea063749", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6b076f1931d7dc324d7bbbc4c1df9f7c1c1db8b7/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b076f1931d7dc324d7bbbc4c1df9f7c1c1db8b7/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=6b076f1931d7dc324d7bbbc4c1df9f7c1c1db8b7", "patch": "@@ -75,9 +75,6 @@ impl Body {\n #[allow(dead_code)]\n pub fn resolver_for_expr(body: Arc<Body>, db: &impl HirDatabase, expr_id: ExprId) -> Resolver {\n     let mut r = body.owner.resolver(db);\n-    if !body.params.is_empty() {\n-        r = r.push_function_params(Arc::clone(&body));\n-    }\n     let scopes = db.expr_scopes(body.owner);\n     let scope_chain = scopes.scope_chain_for(expr_id).collect::<Vec<_>>();\n     for scope in scope_chain.into_iter().rev() {"}, {"sha": "a3908048b2a5aa991b82adca76223648cd281be8", "filename": "crates/ra_hir/src/impl_block.rs", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6b076f1931d7dc324d7bbbc4c1df9f7c1c1db8b7/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b076f1931d7dc324d7bbbc4c1df9f7c1c1db8b7/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs?ref=6b076f1931d7dc324d7bbbc4c1df9f7c1c1db8b7", "patch": "@@ -7,13 +7,13 @@ use ra_syntax::{\n ast::{self, AstNode}};\n \n use crate::{\n-    Const, Type,\n-    Function, HirFileId,\n-    HirDatabase,\n-    PersistentHirDatabase,\n+    Const, Type, Function, HirFileId,\n+    HirDatabase, PersistentHirDatabase,\n+    ModuleDef, Trait, Resolution,\n     type_ref::TypeRef,\n     ids::LocationCtx,\n     resolve::Resolver,\n+    ty::Ty,\n };\n \n use crate::code_model_api::{Module, ModuleSource};\n@@ -75,14 +75,31 @@ impl ImplBlock {\n         self.module_impl_blocks.module.clone()\n     }\n \n-    pub fn target_trait(&self) -> Option<&TypeRef> {\n+    pub fn target_trait_ref(&self) -> Option<&TypeRef> {\n         self.impl_data().target_trait()\n     }\n \n     pub fn target_type(&self) -> &TypeRef {\n         self.impl_data().target_type()\n     }\n \n+    pub fn target_ty(&self, db: &impl HirDatabase) -> Ty {\n+        Ty::from_hir(db, &self.resolver(db), self.target_type())\n+    }\n+\n+    pub fn target_trait(&self, db: &impl HirDatabase) -> Option<Trait> {\n+        if let Some(TypeRef::Path(path)) = self.target_trait_ref() {\n+            let resolver = self.resolver(db);\n+            if let Some(Resolution::Def {\n+                def: ModuleDef::Trait(tr),\n+            }) = resolver.resolve_path(db, path).take_types()\n+            {\n+                return Some(tr);\n+            }\n+        }\n+        None\n+    }\n+\n     pub fn items(&self) -> &[ImplItem] {\n         self.impl_data().items()\n     }"}, {"sha": "54da5559857eeba84a4bfdc4e96255fb686be19d", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b076f1931d7dc324d7bbbc4c1df9f7c1c1db8b7/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b076f1931d7dc324d7bbbc4c1df9f7c1c1db8b7/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=6b076f1931d7dc324d7bbbc4c1df9f7c1c1db8b7", "patch": "@@ -55,13 +55,13 @@ pub use self::{\n     name::Name,\n     ids::{HirFileId, MacroCallId, MacroCallLoc, HirInterner},\n     macros::{MacroDef, MacroInput, MacroExpansion},\n-    nameres::{ItemMap, PerNs, Namespace, Resolution},\n+    nameres::{ItemMap, PerNs, Namespace},\n     ty::Ty,\n     impl_block::{ImplBlock, ImplItem},\n     docs::{Docs, Documentation},\n     adt::AdtDef,\n     expr::{ExprScopes, ScopesWithSyntaxMapping},\n-    resolve::Resolver,\n+    resolve::{Resolver, Resolution},\n };\n \n pub use self::code_model_api::{"}, {"sha": "193c6a9779eb12ddb3cf157ed312663cd5cedb0b", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6b076f1931d7dc324d7bbbc4c1df9f7c1c1db8b7/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b076f1931d7dc324d7bbbc4c1df9f7c1c1db8b7/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=6b076f1931d7dc324d7bbbc4c1df9f7c1c1db8b7", "patch": "@@ -24,8 +24,9 @@ use rustc_hash::{FxHashMap, FxHashSet};\n \n use crate::{\n     Module, ModuleDef,\n-    Path, PathKind, Crate,\n-    Name, PersistentHirDatabase,\n+    Path, PathKind, PersistentHirDatabase,\n+    Crate,\n+    Name,\n     module_tree::{ModuleId, ModuleTree},\n     nameres::lower::{ImportId, LoweredModule, ImportData},\n };\n@@ -46,7 +47,7 @@ impl std::ops::Index<ModuleId> for ItemMap {\n \n #[derive(Debug, Default, PartialEq, Eq, Clone)]\n pub struct ModuleScope {\n-    items: FxHashMap<Name, Resolution>,\n+    pub(crate) items: FxHashMap<Name, Resolution>,\n }\n \n impl ModuleScope {\n@@ -113,6 +114,10 @@ impl<T> PerNs<T> {\n         self.types.is_none() && self.values.is_none()\n     }\n \n+    pub fn is_both(&self) -> bool {\n+        self.types.is_some() && self.values.is_some()\n+    }\n+\n     pub fn take(self, namespace: Namespace) -> Option<T> {\n         match namespace {\n             Namespace::Types => self.types,\n@@ -139,6 +144,13 @@ impl<T> PerNs<T> {\n         }\n     }\n \n+    pub fn combine(self, other: PerNs<T>) -> PerNs<T> {\n+        PerNs {\n+            types: self.types.or(other.types),\n+            values: self.values.or(other.values),\n+        }\n+    }\n+\n     pub fn and_then<U>(self, f: impl Fn(T) -> Option<U>) -> PerNs<U> {\n         PerNs {\n             types: self.types.and_then(&f),\n@@ -402,10 +414,11 @@ impl ItemMap {\n                     if module.krate != original_module.krate {\n                         let path = Path {\n                             segments: path.segments[i..].iter().cloned().collect(),\n-                            kind: PathKind::Crate,\n+                            kind: PathKind::Self_,\n                         };\n                         log::debug!(\"resolving {:?} in other crate\", path);\n-                        let def = module.resolve_path(db, &path);\n+                        let item_map = db.item_map(module.krate);\n+                        let def = item_map.resolve_path(db, *module, &path);\n                         return (def, ReachedFixedPoint::Yes);\n                     }\n "}, {"sha": "0e0683db7723e037c07c4a5a30574a49aea5e8fc", "filename": "crates/ra_hir/src/nameres/tests.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6b076f1931d7dc324d7bbbc4c1df9f7c1c1db8b7/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b076f1931d7dc324d7bbbc4c1df9f7c1c1db8b7/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs?ref=6b076f1931d7dc324d7bbbc4c1df9f7c1c1db8b7", "patch": "@@ -5,11 +5,12 @@ use relative_path::RelativePath;\n use test_utils::{assert_eq_text, covers};\n \n use crate::{\n-    ItemMap, Resolution,\n+    ItemMap,\n     PersistentHirDatabase,\n     mock::MockDatabase,\n     module_tree::ModuleId,\n };\n+use super::Resolution;\n \n fn item_map(fixture: &str) -> (Arc<ItemMap>, ModuleId) {\n     let (db, pos) = MockDatabase::with_position(fixture);"}, {"sha": "36daed65b8518cbefa4366113ea24d8405022fb5", "filename": "crates/ra_hir/src/resolve.rs", "status": "modified", "additions": 82, "deletions": 34, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/6b076f1931d7dc324d7bbbc4c1df9f7c1c1db8b7/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b076f1931d7dc324d7bbbc4c1df9f7c1c1db8b7/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fresolve.rs?ref=6b076f1931d7dc324d7bbbc4c1df9f7c1c1db8b7", "patch": "@@ -1,30 +1,29 @@\n-#![allow(unused_variables, dead_code)]\n //! Name resolution.\n use std::sync::Arc;\n \n use rustc_hash::FxHashMap;\n \n use crate::{\n-    ModuleDef,\n-    name::Name,\n-    nameres::{PerNs, lower::ImportId, ItemMap},\n-    module_tree::ModuleId,\n+    ModuleDef, Module,\n+    db::HirDatabase,\n+    name::{Name, KnownName},\n+    nameres::{PerNs, ItemMap},\n     generics::GenericParams,\n-    expr::{Body, scope::{ExprScopes, ScopeId}, PatId},\n+    expr::{scope::{ExprScopes, ScopeId}, PatId},\n     impl_block::ImplBlock,\n     path::Path,\n };\n \n #[derive(Debug, Clone, Default)]\n pub struct Resolver {\n-    scopes: Vec<Scope>, // maybe a 'linked list' of scopes? or allow linking a Resolver to a parent Resolver? that's an optimization that might not be necessary, though\n+    scopes: Vec<Scope>,\n }\n \n // TODO how to store these best\n #[derive(Debug, Clone)]\n pub(crate) struct ModuleItemMap {\n     item_map: Arc<ItemMap>,\n-    module_id: ModuleId,\n+    module: Module,\n }\n \n #[derive(Debug, Clone)]\n@@ -39,8 +38,6 @@ pub(crate) enum Scope {\n     ModuleScope(ModuleItemMap),\n     /// Brings the generic parameters of an item into scope\n     GenericParams(Arc<GenericParams>),\n-    /// Brings the function parameters into scope\n-    FunctionParams(Arc<Body>),\n     /// Brings `Self` into scope\n     ImplBlockScope(ImplBlock),\n     /// Local bindings\n@@ -49,36 +46,64 @@ pub(crate) enum Scope {\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n pub enum Resolution {\n+    // FIXME make these tuple variants\n     /// An item\n     Def {\n         def: ModuleDef,\n-        import: Option<ImportId>,\n     },\n     /// A local binding (only value namespace)\n-    LocalBinding { pat: PatId },\n+    LocalBinding {\n+        pat: PatId,\n+    },\n     /// A generic parameter\n-    GenericParam { idx: u32 },\n-    // TODO how does `Self` resolve?\n+    GenericParam {\n+        idx: u32,\n+    },\n+    SelfType(ImplBlock),\n }\n \n impl Resolver {\n     pub fn resolve_name(&self, name: &Name) -> PerNs<Resolution> {\n+        let mut resolution = PerNs::none();\n         for scope in self.scopes.iter().rev() {\n-            let resolution = scope.resolve_name(name);\n-            if !resolution.is_none() {\n+            resolution = resolution.combine(scope.resolve_name(name));\n+            if resolution.is_both() {\n                 return resolution;\n             }\n         }\n-        PerNs::none()\n+        resolution\n     }\n \n-    pub fn resolve_path(&self, path: &Path) -> PerNs<Resolution> {\n-        unimplemented!()\n+    pub fn resolve_path(&self, db: &impl HirDatabase, path: &Path) -> PerNs<Resolution> {\n+        if let Some(name) = path.as_ident() {\n+            self.resolve_name(name)\n+        } else if path.is_self() {\n+            self.resolve_name(&Name::self_param())\n+        } else {\n+            let (item_map, module) = match self.module() {\n+                Some(m) => m,\n+                _ => return PerNs::none(),\n+            };\n+            let module_res = item_map.resolve_path(db, module, path);\n+            module_res.map(|def| Resolution::Def { def })\n+        }\n     }\n \n     pub fn all_names(&self) -> FxHashMap<Name, Resolution> {\n         unimplemented!()\n     }\n+\n+    fn module(&self) -> Option<(&ItemMap, Module)> {\n+        for scope in self.scopes.iter().rev() {\n+            match scope {\n+                Scope::ModuleScope(m) => {\n+                    return Some((&m.item_map, m.module.clone()));\n+                }\n+                _ => {}\n+            }\n+        }\n+        None\n+    }\n }\n \n impl Resolver {\n@@ -95,11 +120,8 @@ impl Resolver {\n         self.push_scope(Scope::ImplBlockScope(impl_block))\n     }\n \n-    pub(crate) fn push_module_scope(self, item_map: Arc<ItemMap>, module_id: ModuleId) -> Resolver {\n-        self.push_scope(Scope::ModuleScope(ModuleItemMap {\n-            item_map,\n-            module_id,\n-        }))\n+    pub(crate) fn push_module_scope(self, item_map: Arc<ItemMap>, module: Module) -> Resolver {\n+        self.push_scope(Scope::ModuleScope(ModuleItemMap { item_map, module }))\n     }\n \n     pub(crate) fn push_expr_scope(\n@@ -112,19 +134,45 @@ impl Resolver {\n             scope_id,\n         }))\n     }\n-\n-    pub(crate) fn push_function_params(self, body: Arc<Body>) -> Resolver {\n-        self.push_scope(Scope::FunctionParams(body))\n-    }\n-\n-    pub(crate) fn pop_scope(mut self) -> Resolver {\n-        self.scopes.pop();\n-        self\n-    }\n }\n \n impl Scope {\n     fn resolve_name(&self, name: &Name) -> PerNs<Resolution> {\n-        unimplemented!()\n+        match self {\n+            Scope::ModuleScope(m) => {\n+                if let Some(KnownName::SelfParam) = name.as_known_name() {\n+                    PerNs::types(Resolution::Def {\n+                        def: m.module.into(),\n+                    })\n+                } else {\n+                    match m.item_map[m.module.module_id].get(name) {\n+                        Some(res) => res.def.map(|def| Resolution::Def { def }),\n+                        None => PerNs::none(),\n+                    }\n+                }\n+            }\n+            Scope::GenericParams(gp) => match gp.find_by_name(name) {\n+                Some(gp) => PerNs::types(Resolution::GenericParam { idx: gp.idx }),\n+                None => PerNs::none(),\n+            },\n+            Scope::ImplBlockScope(i) => {\n+                if name.as_known_name() == Some(KnownName::SelfType) {\n+                    PerNs::types(Resolution::SelfType(i.clone()))\n+                } else {\n+                    PerNs::none()\n+                }\n+            }\n+            Scope::ExprScope(e) => {\n+                let entry = e\n+                    .expr_scopes\n+                    .entries(e.scope_id)\n+                    .iter()\n+                    .find(|entry| entry.name() == name);\n+                match entry {\n+                    Some(e) => PerNs::values(Resolution::LocalBinding { pat: e.pat() }),\n+                    None => PerNs::none(),\n+                }\n+            }\n+        }\n     }\n }"}, {"sha": "d9c62f84c008eb8b898938fd1a502f32f9101c19", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 113, "deletions": 157, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/6b076f1931d7dc324d7bbbc4c1df9f7c1c1db8b7/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b076f1931d7dc324d7bbbc4c1df9f7c1c1db8b7/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=6b076f1931d7dc324d7bbbc4c1df9f7c1c1db8b7", "patch": "@@ -33,15 +33,16 @@ use rustc_hash::FxHashMap;\n use test_utils::tested_by;\n \n use crate::{\n-    Module, Function, Struct, StructField, Enum, EnumVariant, Path, Name, ImplBlock,\n-    FnSignature, ExprScopes, ModuleDef, AdtDef,\n+    Function, Struct, StructField, Enum, EnumVariant, Path, Name,\n+    FnSignature, ModuleDef, AdtDef,\n     HirDatabase,\n     type_ref::{TypeRef, Mutability},\n     name::KnownName,\n-    expr::{Body, Expr, BindingAnnotation, Literal, ExprId, Pat, PatId, UnaryOp, BinaryOp, Statement, FieldPat},\n+    expr::{Body, Expr, BindingAnnotation, Literal, ExprId, Pat, PatId, UnaryOp, BinaryOp, Statement, FieldPat, self},\n     generics::GenericParams,\n     path::GenericArg,\n     adt::VariantDef,\n+    resolve::{Resolver, Resolution},\n };\n \n /// The ID of a type variable.\n@@ -300,47 +301,38 @@ pub struct FnSig {\n }\n \n impl Ty {\n-    pub(crate) fn from_hir(\n-        db: &impl HirDatabase,\n-        // TODO: the next three parameters basically describe the scope for name\n-        // resolution; this should be refactored into something like a general\n-        // resolver architecture\n-        module: &Module,\n-        impl_block: Option<&ImplBlock>,\n-        generics: &GenericParams,\n-        type_ref: &TypeRef,\n-    ) -> Self {\n+    pub(crate) fn from_hir(db: &impl HirDatabase, resolver: &Resolver, type_ref: &TypeRef) -> Self {\n         match type_ref {\n             TypeRef::Never => Ty::Never,\n             TypeRef::Tuple(inner) => {\n                 let inner_tys = inner\n                     .iter()\n-                    .map(|tr| Ty::from_hir(db, module, impl_block, generics, tr))\n+                    .map(|tr| Ty::from_hir(db, resolver, tr))\n                     .collect::<Vec<_>>();\n                 Ty::Tuple(inner_tys.into())\n             }\n-            TypeRef::Path(path) => Ty::from_hir_path(db, module, impl_block, generics, path),\n+            TypeRef::Path(path) => Ty::from_hir_path(db, resolver, path),\n             TypeRef::RawPtr(inner, mutability) => {\n-                let inner_ty = Ty::from_hir(db, module, impl_block, generics, inner);\n+                let inner_ty = Ty::from_hir(db, resolver, inner);\n                 Ty::RawPtr(Arc::new(inner_ty), *mutability)\n             }\n             TypeRef::Array(inner) => {\n-                let inner_ty = Ty::from_hir(db, module, impl_block, generics, inner);\n+                let inner_ty = Ty::from_hir(db, resolver, inner);\n                 Ty::Array(Arc::new(inner_ty))\n             }\n             TypeRef::Slice(inner) => {\n-                let inner_ty = Ty::from_hir(db, module, impl_block, generics, inner);\n+                let inner_ty = Ty::from_hir(db, resolver, inner);\n                 Ty::Slice(Arc::new(inner_ty))\n             }\n             TypeRef::Reference(inner, mutability) => {\n-                let inner_ty = Ty::from_hir(db, module, impl_block, generics, inner);\n+                let inner_ty = Ty::from_hir(db, resolver, inner);\n                 Ty::Ref(Arc::new(inner_ty), *mutability)\n             }\n             TypeRef::Placeholder => Ty::Unknown,\n             TypeRef::Fn(params) => {\n                 let mut inner_tys = params\n                     .iter()\n-                    .map(|tr| Ty::from_hir(db, module, impl_block, generics, tr))\n+                    .map(|tr| Ty::from_hir(db, resolver, tr))\n                     .collect::<Vec<_>>();\n                 let return_ty = inner_tys\n                     .pop()\n@@ -355,77 +347,62 @@ impl Ty {\n         }\n     }\n \n-    pub(crate) fn from_hir_opt(\n-        db: &impl HirDatabase,\n-        module: &Module,\n-        impl_block: Option<&ImplBlock>,\n-        generics: &GenericParams,\n-        type_ref: Option<&TypeRef>,\n-    ) -> Self {\n-        type_ref.map_or(Ty::Unknown, |t| {\n-            Ty::from_hir(db, module, impl_block, generics, t)\n-        })\n-    }\n-\n-    pub(crate) fn from_hir_path(\n-        db: &impl HirDatabase,\n-        module: &Module,\n-        impl_block: Option<&ImplBlock>,\n-        generics: &GenericParams,\n-        path: &Path,\n-    ) -> Self {\n+    pub(crate) fn from_hir_path(db: &impl HirDatabase, resolver: &Resolver, path: &Path) -> Self {\n         if let Some(name) = path.as_ident() {\n+            // TODO handle primitive type names in resolver as well?\n             if let Some(int_ty) = primitive::UncertainIntTy::from_name(name) {\n                 return Ty::Int(int_ty);\n             } else if let Some(float_ty) = primitive::UncertainFloatTy::from_name(name) {\n                 return Ty::Float(float_ty);\n-            } else if name.as_known_name() == Some(KnownName::SelfType) {\n-                // TODO pass the impl block's generics?\n-                let generics = &GenericParams::default();\n-                return Ty::from_hir_opt(\n-                    db,\n-                    module,\n-                    None,\n-                    generics,\n-                    impl_block.map(|i| i.target_type()),\n-                );\n             } else if let Some(known) = name.as_known_name() {\n                 match known {\n                     KnownName::Bool => return Ty::Bool,\n                     KnownName::Char => return Ty::Char,\n                     KnownName::Str => return Ty::Str,\n                     _ => {}\n                 }\n-            } else if let Some(generic_param) = generics.find_by_name(&name) {\n+            }\n+        }\n+\n+        // Resolve the path (in type namespace)\n+        let resolution = resolver.resolve_path(db, path).take_types();\n+\n+        let def = match resolution {\n+            Some(Resolution::Def { def, .. }) => def,\n+            Some(Resolution::LocalBinding { .. }) => {\n+                // this should never happen\n+                panic!(\"path resolved to local binding in type ns\");\n+            }\n+            Some(Resolution::GenericParam { idx }) => {\n                 return Ty::Param {\n-                    idx: generic_param.idx,\n-                    name: generic_param.name.clone(),\n+                    idx,\n+                    // TODO: maybe return name in resolution?\n+                    name: path\n+                        .as_ident()\n+                        .expect(\"generic param should be single-segment path\")\n+                        .clone(),\n                 };\n             }\n-        }\n+            Some(Resolution::SelfType(impl_block)) => {\n+                return impl_block.target_ty(db);\n+            }\n+            None => return Ty::Unknown,\n+        };\n \n-        // Resolve in module (in type namespace)\n-        let typable: TypableDef = match module\n-            .resolve_path(db, path)\n-            .take_types()\n-            .and_then(|it| it.into())\n-        {\n+        let typable: TypableDef = match def.into() {\n             None => return Ty::Unknown,\n             Some(it) => it,\n         };\n         let ty = db.type_for_def(typable);\n-        let substs = Ty::substs_from_path(db, module, impl_block, generics, path, typable);\n+        let substs = Ty::substs_from_path(db, resolver, path, typable);\n         ty.apply_substs(substs)\n     }\n \n     /// Collect generic arguments from a path into a `Substs`. See also\n     /// `create_substs_for_ast_path` and `def_to_ty` in rustc.\n     fn substs_from_path(\n         db: &impl HirDatabase,\n-        // the scope of the segment...\n-        module: &Module,\n-        impl_block: Option<&ImplBlock>,\n-        outer_generics: &GenericParams,\n+        resolver: &Resolver,\n         path: &Path,\n         resolved: TypableDef,\n     ) -> Substs {\n@@ -462,7 +439,7 @@ impl Ty {\n             for arg in generic_args.args.iter().take(param_count) {\n                 match arg {\n                     GenericArg::Type(type_ref) => {\n-                        let ty = Ty::from_hir(db, module, impl_block, outer_generics, type_ref);\n+                        let ty = Ty::from_hir(db, resolver, type_ref);\n                         substs.push(ty);\n                     }\n                 }\n@@ -666,24 +643,17 @@ impl fmt::Display for Ty {\n /// function body.\n fn type_for_fn(db: &impl HirDatabase, def: Function) -> Ty {\n     let signature = def.signature(db);\n-    let module = def.module(db);\n-    let impl_block = def.impl_block(db);\n+    let resolver = def.resolver(db);\n     let generics = def.generic_params(db);\n+    let name = def.name(db);\n     let input = signature\n         .params()\n         .iter()\n-        .map(|tr| Ty::from_hir(db, &module, impl_block.as_ref(), &generics, tr))\n+        .map(|tr| Ty::from_hir(db, &resolver, tr))\n         .collect::<Vec<_>>();\n-    let output = Ty::from_hir(\n-        db,\n-        &module,\n-        impl_block.as_ref(),\n-        &generics,\n-        signature.ret_type(),\n-    );\n+    let output = Ty::from_hir(db, &resolver, signature.ret_type());\n     let sig = Arc::new(FnSig { input, output });\n     let substs = make_substs(&generics);\n-    let name = def.name(db);\n     Ty::FnDef {\n         def,\n         sig,\n@@ -764,13 +734,13 @@ pub(super) fn type_for_def(db: &impl HirDatabase, def: TypableDef) -> Ty {\n \n pub(super) fn type_for_field(db: &impl HirDatabase, field: StructField) -> Ty {\n     let parent_def = field.parent_def(db);\n-    let (generics, module) = match parent_def {\n-        VariantDef::Struct(it) => (it.generic_params(db), it.module(db)),\n-        VariantDef::EnumVariant(it) => (it.parent_enum(db).generic_params(db), it.module(db)),\n+    let resolver = match parent_def {\n+        VariantDef::Struct(it) => it.resolver(db),\n+        VariantDef::EnumVariant(it) => it.parent_enum(db).resolver(db),\n     };\n     let var_data = parent_def.variant_data(db);\n     let type_ref = &var_data.fields().unwrap()[field.id].type_ref;\n-    Ty::from_hir(db, &module, None, &generics, type_ref)\n+    Ty::from_hir(db, &resolver, type_ref)\n }\n \n /// The result of type inference: A mapping from expressions and patterns to types.\n@@ -814,9 +784,7 @@ impl Index<PatId> for InferenceResult {\n struct InferenceContext<'a, D: HirDatabase> {\n     db: &'a D,\n     body: Arc<Body>,\n-    scopes: Arc<ExprScopes>,\n-    module: Module,\n-    impl_block: Option<ImplBlock>,\n+    resolver: Resolver,\n     var_unification_table: InPlaceUnificationTable<TypeVarId>,\n     method_resolutions: FxHashMap<ExprId, Function>,\n     field_resolutions: FxHashMap<ExprId, StructField>,\n@@ -905,13 +873,7 @@ fn binary_op_rhs_expectation(op: BinaryOp, lhs_ty: Ty) -> Ty {\n }\n \n impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n-    fn new(\n-        db: &'a D,\n-        body: Arc<Body>,\n-        scopes: Arc<ExprScopes>,\n-        module: Module,\n-        impl_block: Option<ImplBlock>,\n-    ) -> Self {\n+    fn new(db: &'a D, body: Arc<Body>, resolver: Resolver) -> Self {\n         InferenceContext {\n             method_resolutions: FxHashMap::default(),\n             field_resolutions: FxHashMap::default(),\n@@ -921,9 +883,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             return_ty: Ty::Unknown, // set in collect_fn_signature\n             db,\n             body,\n-            scopes,\n-            module,\n-            impl_block,\n+            resolver,\n         }\n     }\n \n@@ -940,8 +900,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             *ty = resolved;\n         }\n         InferenceResult {\n-            method_resolutions: mem::replace(&mut self.method_resolutions, Default::default()),\n-            field_resolutions: mem::replace(&mut self.field_resolutions, Default::default()),\n+            method_resolutions: self.method_resolutions,\n+            field_resolutions: self.field_resolutions,\n             type_of_expr: expr_types,\n             type_of_pat: pat_types,\n         }\n@@ -964,13 +924,10 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     }\n \n     fn make_ty(&mut self, type_ref: &TypeRef) -> Ty {\n-        // TODO provide generics of function\n-        let generics = GenericParams::default();\n         let ty = Ty::from_hir(\n             self.db,\n-            &self.module,\n-            self.impl_block.as_ref(),\n-            &generics,\n+            // TODO use right resolver for block\n+            &self.resolver,\n             type_ref,\n         );\n         let ty = self.insert_type_vars(ty);\n@@ -1147,65 +1104,62 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         })\n     }\n \n-    fn infer_path_expr(&mut self, expr: ExprId, path: &Path) -> Option<Ty> {\n-        if path.is_ident() || path.is_self() {\n-            // resolve locally\n-            let name = path.as_ident().cloned().unwrap_or_else(Name::self_param);\n-            if let Some(scope_entry) = self.scopes.resolve_local_name(expr, name) {\n-                let ty = self.type_of_pat.get(scope_entry.pat())?;\n+    fn infer_path_expr(&mut self, resolver: &Resolver, path: &Path) -> Option<Ty> {\n+        let resolved = resolver.resolve_path(self.db, &path).take_values()?;\n+        match resolved {\n+            Resolution::Def { def, .. } => {\n+                let typable: Option<TypableDef> = def.into();\n+                let typable = typable?;\n+                let substs = Ty::substs_from_path(self.db, &self.resolver, path, typable);\n+                let ty = self.db.type_for_def(typable).apply_substs(substs);\n+                let ty = self.insert_type_vars(ty);\n+                Some(ty)\n+            }\n+            Resolution::LocalBinding { pat } => {\n+                let ty = self.type_of_pat.get(pat)?;\n                 let ty = self.resolve_ty_as_possible(&mut vec![], ty.clone());\n-                return Some(ty);\n-            };\n-        };\n-\n-        // resolve in module\n-        let typable: Option<TypableDef> = self\n-            .module\n-            .resolve_path(self.db, &path)\n-            .take_values()?\n-            .into();\n-        let typable = typable?;\n-        let ty = self.db.type_for_def(typable);\n-        let generics = GenericParams::default();\n-        let substs = Ty::substs_from_path(\n-            self.db,\n-            &self.module,\n-            self.impl_block.as_ref(),\n-            &generics,\n-            path,\n-            typable,\n-        );\n-        let ty = ty.apply_substs(substs);\n-        let ty = self.insert_type_vars(ty);\n-\n-        Some(ty)\n+                Some(ty)\n+            }\n+            Resolution::GenericParam { .. } => {\n+                // generic params can't refer to values... yet\n+                None\n+            }\n+            Resolution::SelfType(_) => {\n+                log::error!(\"path expr {:?} resolved to Self type in values ns\", path);\n+                None\n+            }\n+        }\n     }\n \n     fn resolve_variant(&mut self, path: Option<&Path>) -> (Ty, Option<VariantDef>) {\n         let path = match path {\n             Some(path) => path,\n             None => return (Ty::Unknown, None),\n         };\n-        let typable: Option<TypableDef> = self\n-            .module\n-            .resolve_path(self.db, &path)\n-            .take_types()\n-            .and_then(|it| it.into());\n+        let resolver = &self.resolver;\n+        let typable: Option<TypableDef> = match resolver.resolve_path(self.db, &path).take_types() {\n+            Some(Resolution::Def { def, .. }) => def.into(),\n+            Some(Resolution::LocalBinding { .. }) => {\n+                // this cannot happen\n+                log::error!(\"path resolved to local binding in type ns\");\n+                return (Ty::Unknown, None);\n+            }\n+            Some(Resolution::GenericParam { .. }) => {\n+                // generic params can't be used in struct literals\n+                return (Ty::Unknown, None);\n+            }\n+            Some(Resolution::SelfType(..)) => {\n+                // TODO this is allowed in an impl for a struct, handle this\n+                return (Ty::Unknown, None);\n+            }\n+            None => return (Ty::Unknown, None),\n+        };\n         let def = match typable {\n             None => return (Ty::Unknown, None),\n             Some(it) => it,\n         };\n         // TODO remove the duplication between here and `Ty::from_path`?\n-        // TODO provide generics of function\n-        let generics = GenericParams::default();\n-        let substs = Ty::substs_from_path(\n-            self.db,\n-            &self.module,\n-            self.impl_block.as_ref(),\n-            &generics,\n-            path,\n-            def,\n-        );\n+        let substs = Ty::substs_from_path(self.db, resolver, path, def);\n         match def {\n             TypableDef::Struct(s) => {\n                 let ty = type_for_struct(self.db, s);\n@@ -1303,12 +1257,12 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 path: ref p,\n                 args: ref fields,\n             } => self.infer_struct_pat(p.as_ref(), fields, expected),\n-            Pat::Path(path) => self\n-                .module\n-                .resolve_path(self.db, &path)\n-                .take_values()\n-                .and_then(|module_def| module_def.into())\n-                .map_or(Ty::Unknown, |resolved| self.db.type_for_def(resolved)),\n+            Pat::Path(path) => {\n+                // TODO use correct resolver for the surrounding expression\n+                let resolver = self.resolver.clone();\n+                self.infer_path_expr(&resolver, &path)\n+                    .unwrap_or(Ty::Unknown)\n+            }\n             Pat::Bind {\n                 mode,\n                 name: _name,\n@@ -1496,7 +1450,11 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n                 expected.ty\n             }\n-            Expr::Path(p) => self.infer_path_expr(tgt_expr, p).unwrap_or(Ty::Unknown),\n+            Expr::Path(p) => {\n+                // TODO this could be more efficient...\n+                let resolver = expr::resolver_for_expr(self.body.clone(), self.db, tgt_expr);\n+                self.infer_path_expr(&resolver, p).unwrap_or(Ty::Unknown)\n+            }\n             Expr::Continue => Ty::Never,\n             Expr::Break { expr } => {\n                 if let Some(expr) = expr {\n@@ -1730,10 +1688,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n pub fn infer(db: &impl HirDatabase, func: Function) -> Arc<InferenceResult> {\n     db.check_canceled();\n     let body = func.body(db);\n-    let scopes = db.expr_scopes(func);\n-    let module = func.module(db);\n-    let impl_block = func.impl_block(db);\n-    let mut ctx = InferenceContext::new(db, body, scopes, module, impl_block);\n+    let resolver = func.resolver(db);\n+    let mut ctx = InferenceContext::new(db, body, resolver);\n \n     let signature = func.signature(db);\n     ctx.collect_fn_signature(&signature);"}, {"sha": "2282286b0b83f69f3e14baab4719b72615eacffc", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 9, "deletions": 21, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6b076f1931d7dc324d7bbbc4c1df9f7c1c1db8b7/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b076f1931d7dc324d7bbbc4c1df9f7c1c1db8b7/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=6b076f1931d7dc324d7bbbc4c1df9f7c1c1db8b7", "patch": "@@ -7,12 +7,10 @@ use std::sync::Arc;\n use rustc_hash::FxHashMap;\n \n use crate::{\n-    HirDatabase, module_tree::ModuleId, Module, ModuleDef, Crate, Name, Function, Trait,\n+    HirDatabase, module_tree::ModuleId, Module, Crate, Name, Function, Trait,\n     ids::TraitId,\n     impl_block::{ImplId, ImplBlock, ImplItem},\n-    generics::GenericParams,\n     ty::{AdtDef, Ty},\n-    type_ref::TypeRef,\n };\n \n /// This is used as a key for indexing impls.\n@@ -85,17 +83,10 @@ impl CrateImplBlocks {\n     fn collect_recursive(&mut self, db: &impl HirDatabase, module: &Module) {\n         let module_impl_blocks = db.impls_in_module(module.clone());\n \n-        for (impl_id, impl_data) in module_impl_blocks.impls.iter() {\n+        for (impl_id, _) in module_impl_blocks.impls.iter() {\n             let impl_block = ImplBlock::from_id(Arc::clone(&module_impl_blocks), impl_id);\n-            // TODO provide generics of impl\n-            let generics = GenericParams::default();\n-            let target_ty = Ty::from_hir(\n-                db,\n-                &module,\n-                Some(&impl_block),\n-                &generics,\n-                impl_data.target_type(),\n-            );\n+\n+            let target_ty = impl_block.target_ty(db);\n \n             if let Some(target_ty_fp) = TyFingerprint::for_impl(&target_ty) {\n                 self.impls\n@@ -104,14 +95,11 @@ impl CrateImplBlocks {\n                     .push((module.module_id, impl_id));\n             }\n \n-            if let Some(TypeRef::Path(path)) = impl_data.target_trait() {\n-                let perns = module.resolve_path(db, path);\n-                if let Some(ModuleDef::Trait(tr)) = perns.take_types() {\n-                    self.impls_by_trait\n-                        .entry(tr.id)\n-                        .or_insert_with(Vec::new)\n-                        .push((module.module_id, impl_id));\n-                }\n+            if let Some(tr) = impl_block.target_trait(db) {\n+                self.impls_by_trait\n+                    .entry(tr.id)\n+                    .or_insert_with(Vec::new)\n+                    .push((module.module_id, impl_id));\n             }\n         }\n "}, {"sha": "91c48897cf7b26fd29415a97803249806611f17e", "filename": "crates/ra_hir/src/ty/snapshots/tests__infer_function_generics.snap", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6b076f1931d7dc324d7bbbc4c1df9f7c1c1db8b7/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_function_generics.snap", "raw_url": "https://github.com/rust-lang/rust/raw/6b076f1931d7dc324d7bbbc4c1df9f7c1c1db8b7/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_function_generics.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_function_generics.snap?ref=6b076f1931d7dc324d7bbbc4c1df9f7c1c1db8b7", "patch": "@@ -1,12 +1,12 @@\n ---\n-created: \"2019-01-26T18:16:16.530712344+00:00\"\n+created: \"2019-01-27T14:52:29.934503829+00:00\"\n creator: insta@0.5.2\n expression: \"&result\"\n source: crates/ra_hir/src/ty/tests.rs\n ---\n-[10; 11) 't': [unknown]\n-[21; 26) '{ t }': [unknown]\n-[23; 24) 't': [unknown]\n+[10; 11) 't': T\n+[21; 26) '{ t }': T\n+[23; 24) 't': T\n [38; 98) '{     ...(1); }': ()\n [44; 46) 'id': fn id<u32>(T) -> T\n [44; 52) 'id(1u32)': u32"}, {"sha": "626f31252556acd495bb6f7ae5127437b1a48304", "filename": "crates/ra_hir/src/ty/snapshots/tests__infer_generic_chain.snap", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6b076f1931d7dc324d7bbbc4c1df9f7c1c1db8b7/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_generic_chain.snap", "raw_url": "https://github.com/rust-lang/rust/raw/6b076f1931d7dc324d7bbbc4c1df9f7c1c1db8b7/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_generic_chain.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_generic_chain.snap?ref=6b076f1931d7dc324d7bbbc4c1df9f7c1c1db8b7", "patch": "@@ -1,5 +1,5 @@\n ---\n-created: \"2019-01-26T17:46:03.866825843+00:00\"\n+created: \"2019-01-27T14:52:29.938713255+00:00\"\n creator: insta@0.5.2\n expression: \"&result\"\n source: crates/ra_hir/src/ty/tests.rs\n@@ -8,9 +8,9 @@ source: crates/ra_hir/src/ty/tests.rs\n [65; 87) '{     ...     }': [unknown]\n [75; 79) 'self': A<[unknown]>\n [75; 81) 'self.x': [unknown]\n-[99; 100) 't': [unknown]\n-[110; 115) '{ t }': [unknown]\n-[112; 113) 't': [unknown]\n+[99; 100) 't': T\n+[110; 115) '{ t }': T\n+[112; 113) 't': T\n [135; 261) '{     ....x() }': i128\n [146; 147) 'x': i32\n [150; 151) '1': i32"}, {"sha": "216d1e41f103a1d01bfc29b1a7ae3ed8cf592b97", "filename": "crates/ra_hir/src/ty/snapshots/tests__infer_type_param.snap", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6b076f1931d7dc324d7bbbc4c1df9f7c1c1db8b7/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_type_param.snap", "raw_url": "https://github.com/rust-lang/rust/raw/6b076f1931d7dc324d7bbbc4c1df9f7c1c1db8b7/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_type_param.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_type_param.snap?ref=6b076f1931d7dc324d7bbbc4c1df9f7c1c1db8b7", "patch": "@@ -1,15 +1,15 @@\n ---\n-created: \"2019-01-27T16:54:18.368427685+00:00\"\n+created: \"2019-01-27T20:38:32.153717698+00:00\"\n creator: insta@0.5.2\n expression: \"&result\"\n source: crates/ra_hir/src/ty/tests.rs\n ---\n-[10; 11) 'x': [unknown]\n-[21; 30) '{     x }': [unknown]\n-[27; 28) 'x': [unknown]\n-[44; 45) 'x': &[unknown]\n-[56; 65) '{     x }': &[unknown]\n-[62; 63) 'x': &[unknown]\n+[10; 11) 'x': T\n+[21; 30) '{     x }': T\n+[27; 28) 'x': T\n+[44; 45) 'x': &T\n+[56; 65) '{     x }': &T\n+[62; 63) 'x': &T\n [77; 157) '{     ...(1); }': ()\n [87; 88) 'y': u32\n [91; 96) '10u32': u32"}]}