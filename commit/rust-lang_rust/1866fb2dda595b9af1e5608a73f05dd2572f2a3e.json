{"sha": "1866fb2dda595b9af1e5608a73f05dd2572f2a3e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4NjZmYjJkZGE1OTViOWFmMWU1NjA4YTczZjA1ZGQyNTcyZjJhM2U=", "commit": {"author": {"name": "Andrea Pretto", "email": "eulerdisk@gmail.com", "date": "2019-02-08T20:30:59Z"}, "committer": {"name": "Andrea Pretto", "email": "eulerdisk@gmail.com", "date": "2019-02-09T10:30:09Z"}, "message": "auto_import: remove PathSegmentsMatch", "tree": {"sha": "dd1e1e3cded541f787489a1056d349ff24f9d2f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dd1e1e3cded541f787489a1056d349ff24f9d2f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1866fb2dda595b9af1e5608a73f05dd2572f2a3e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1866fb2dda595b9af1e5608a73f05dd2572f2a3e", "html_url": "https://github.com/rust-lang/rust/commit/1866fb2dda595b9af1e5608a73f05dd2572f2a3e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1866fb2dda595b9af1e5608a73f05dd2572f2a3e/comments", "author": {"login": "eulerdisk", "id": 10089822, "node_id": "MDQ6VXNlcjEwMDg5ODIy", "avatar_url": "https://avatars.githubusercontent.com/u/10089822?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eulerdisk", "html_url": "https://github.com/eulerdisk", "followers_url": "https://api.github.com/users/eulerdisk/followers", "following_url": "https://api.github.com/users/eulerdisk/following{/other_user}", "gists_url": "https://api.github.com/users/eulerdisk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eulerdisk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eulerdisk/subscriptions", "organizations_url": "https://api.github.com/users/eulerdisk/orgs", "repos_url": "https://api.github.com/users/eulerdisk/repos", "events_url": "https://api.github.com/users/eulerdisk/events{/privacy}", "received_events_url": "https://api.github.com/users/eulerdisk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eulerdisk", "id": 10089822, "node_id": "MDQ6VXNlcjEwMDg5ODIy", "avatar_url": "https://avatars.githubusercontent.com/u/10089822?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eulerdisk", "html_url": "https://github.com/eulerdisk", "followers_url": "https://api.github.com/users/eulerdisk/followers", "following_url": "https://api.github.com/users/eulerdisk/following{/other_user}", "gists_url": "https://api.github.com/users/eulerdisk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eulerdisk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eulerdisk/subscriptions", "organizations_url": "https://api.github.com/users/eulerdisk/orgs", "repos_url": "https://api.github.com/users/eulerdisk/repos", "events_url": "https://api.github.com/users/eulerdisk/events{/privacy}", "received_events_url": "https://api.github.com/users/eulerdisk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6d8832359e6f9236f4c6dcc6e8afa194f8181630", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d8832359e6f9236f4c6dcc6e8afa194f8181630", "html_url": "https://github.com/rust-lang/rust/commit/6d8832359e6f9236f4c6dcc6e8afa194f8181630"}], "stats": {"total": 104, "additions": 37, "deletions": 67}, "files": [{"sha": "9c65b39f7618c28ad58967932a882425c946d1e6", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1866fb2dda595b9af1e5608a73f05dd2572f2a3e/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/1866fb2dda595b9af1e5608a73f05dd2572f2a3e/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=1866fb2dda595b9af1e5608a73f05dd2572f2a3e", "patch": "@@ -900,7 +900,6 @@ version = \"0.1.0\"\n name = \"ra_assists\"\n version = \"0.1.0\"\n dependencies = [\n- \"itertools 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"join_to_string 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_db 0.1.0\",\n  \"ra_fmt 0.1.0\","}, {"sha": "71ab2dcd2a051b851c09e7886d9ae597d2045094", "filename": "crates/ra_assists/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1866fb2dda595b9af1e5608a73f05dd2572f2a3e/crates%2Fra_assists%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1866fb2dda595b9af1e5608a73f05dd2572f2a3e/crates%2Fra_assists%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2FCargo.toml?ref=1866fb2dda595b9af1e5608a73f05dd2572f2a3e", "patch": "@@ -6,7 +6,6 @@ authors = [\"Aleksey Kladov <aleksey.kladov@gmail.com>\"]\n \n [dependencies]\n join_to_string = \"0.1.3\"\n-itertools = \"0.8.0\"\n \n ra_syntax = { path = \"../ra_syntax\" }\n ra_text_edit = { path = \"../ra_text_edit\" }"}, {"sha": "14a564301091d428fb48b89eed5fe838260e606b", "filename": "crates/ra_assists/src/auto_import.rs", "status": "modified", "additions": 37, "deletions": 65, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/1866fb2dda595b9af1e5608a73f05dd2572f2a3e/crates%2Fra_assists%2Fsrc%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1866fb2dda595b9af1e5608a73f05dd2572f2a3e/crates%2Fra_assists%2Fsrc%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fauto_import.rs?ref=1866fb2dda595b9af1e5608a73f05dd2572f2a3e", "patch": "@@ -4,7 +4,6 @@ use ra_syntax::{\n     SyntaxKind::{ PATH, PATH_SEGMENT, COLONCOLON, COMMA }\n };\n use crate::assist_ctx::{AssistCtx, Assist, AssistBuilder};\n-use itertools::{ Itertools, EitherOrBoth };\n \n // TODO: refactor this before merge\n mod formatting {\n@@ -101,44 +100,13 @@ fn fmt_segments_raw(segments: &[&ast::PathSegment], buf: &mut String) {\n     }\n }\n \n-#[derive(Copy, Clone)]\n-enum PathSegmentsMatch {\n-    // Patch matches exactly\n-    Full,\n-    // When some of the segments matched\n-    Partial(usize),\n-    // When all the segments of the right path are matched against the left path,\n-    // but the left path is longer.\n-    PartialLeft(usize),\n-    // When all the segments of the left path are matched against the right path,\n-    // but the right path is longer.\n-    PartialRight(usize),\n-    // In all the three cases above we keep track of how many segments matched\n-}\n-\n-fn compare_path_segments(\n-    left: &[&ast::PathSegment],\n-    right: &[&ast::PathSegment],\n-) -> PathSegmentsMatch {\n-    let mut matching = 0;\n-    for either_or_both in left.iter().zip_longest(right.iter()) {\n-        match either_or_both {\n-            EitherOrBoth::Both(left, right) => {\n-                if compare_path_segment(left, right) {\n-                    matching += 1\n-                } else {\n-                    return PathSegmentsMatch::Partial(matching);\n-                }\n-            }\n-            EitherOrBoth::Left(_) => {\n-                return PathSegmentsMatch::PartialLeft(matching);\n-            }\n-            EitherOrBoth::Right(_) => {\n-                return PathSegmentsMatch::PartialRight(matching);\n-            }\n-        }\n-    }\n-    return PathSegmentsMatch::Full;\n+// Returns the numeber of common segments.\n+fn compare_path_segments(left: &[&ast::PathSegment], right: &[&ast::PathSegment]) -> usize {\n+    return left\n+        .iter()\n+        .zip(right)\n+        .filter(|(l, r)| compare_path_segment(l, r))\n+        .count();\n }\n \n fn compare_path_segment(a: &ast::PathSegment, b: &ast::PathSegment) -> bool {\n@@ -259,13 +227,22 @@ fn walk_use_tree_for_best_action<'a>(\n \n     // We compare only the new segments added in the line just above.\n     // The first prev_len segments were already compared in 'parent' recursive calls.\n-    let c = compare_path_segments(\n-        target.split_at(prev_len).1,\n-        current_path_segments.split_at(prev_len).1,\n-    );\n-\n-    let mut action = match c {\n-        PathSegmentsMatch::Full => {\n+    let left = target.split_at(prev_len).1;\n+    let right = current_path_segments.split_at(prev_len).1;\n+    let common = compare_path_segments(left, right);\n+    let mut action = match common {\n+        0 => ImportAction::AddNewUse(\n+            // e.g: target is std::fmt and we can have\n+            // use foo::bar\n+            // We add a brand new use statement\n+            current_use_tree\n+                .syntax()\n+                .ancestors()\n+                .find_map(ast::UseItem::cast)\n+                .map(AstNode::syntax),\n+            true,\n+        ),\n+        common if common == left.len() && left.len() == right.len() => {\n             // e.g: target is std::fmt and we can have\n             // 1- use std::fmt;\n             // 2- use std::fmt:{ ... }\n@@ -289,25 +266,19 @@ fn walk_use_tree_for_best_action<'a>(\n                 ImportAction::Nothing\n             }\n         }\n-        PathSegmentsMatch::Partial(0) => ImportAction::AddNewUse(\n-            // e.g: target is std::fmt and we can have\n-            // use foo::bar\n-            // We add a brand new use statement\n-            current_use_tree\n-                .syntax()\n-                .ancestors()\n-                .find_map(ast::UseItem::cast)\n-                .map(AstNode::syntax),\n-            true,\n-        ),\n-        PathSegmentsMatch::Partial(n) => {\n+        common if common != left.len() && left.len() == right.len() => {\n             // e.g: target is std::fmt and we have\n             // use std::io;\n             // We need to split.\n-            let segments_to_split = current_path_segments.split_at(prev_len + n).1;\n-            ImportAction::AddNestedImport(prev_len + n, path, Some(segments_to_split[0]), false)\n+            let segments_to_split = current_path_segments.split_at(prev_len + common).1;\n+            ImportAction::AddNestedImport(\n+                prev_len + common,\n+                path,\n+                Some(segments_to_split[0]),\n+                false,\n+            )\n         }\n-        PathSegmentsMatch::PartialLeft(n) => {\n+        common if left.len() > right.len() => {\n             // e.g: target is std::fmt and we can have\n             // 1- use std;\n             // 2- use std::{ ... };\n@@ -335,16 +306,17 @@ fn walk_use_tree_for_best_action<'a>(\n                 }\n             } else {\n                 // Case 1, split\n-                better_action = ImportAction::AddNestedImport(prev_len + n, path, None, true)\n+                better_action = ImportAction::AddNestedImport(prev_len + common, path, None, true)\n             }\n             better_action\n         }\n-        PathSegmentsMatch::PartialRight(n) => {\n+        common if left.len() < right.len() => {\n             // e.g: target is std::fmt and we can have\n             // use std::fmt::Debug;\n-            let segments_to_split = current_path_segments.split_at(prev_len + n).1;\n-            ImportAction::AddNestedImport(prev_len + n, path, Some(segments_to_split[0]), true)\n+            let segments_to_split = current_path_segments.split_at(prev_len + common).1;\n+            ImportAction::AddNestedImport(prev_len + common, path, Some(segments_to_split[0]), true)\n         }\n+        _ => unreachable!(),\n     };\n \n     // If we are inside a UseTreeList adding a use statement become adding to the existing"}]}