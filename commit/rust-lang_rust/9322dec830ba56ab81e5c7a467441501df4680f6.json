{"sha": "9322dec830ba56ab81e5c7a467441501df4680f6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzMjJkZWM4MzBiYTU2YWI4MWU1YzdhNDY3NDQxNTAxZGY0NjgwZjY=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-11-17T04:06:24Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-11-17T04:06:24Z"}, "message": "Merge pull request #81 from oli-obk/master\n\nensure that integers cast to pointers will never point at a valid alloc, not even the zst alloc", "tree": {"sha": "8f9c6b9b63dd8393dc79b1790d6eb925019873a8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f9c6b9b63dd8393dc79b1790d6eb925019873a8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9322dec830ba56ab81e5c7a467441501df4680f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9322dec830ba56ab81e5c7a467441501df4680f6", "html_url": "https://github.com/rust-lang/rust/commit/9322dec830ba56ab81e5c7a467441501df4680f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9322dec830ba56ab81e5c7a467441501df4680f6/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2d4301ea7eb7569881e2250a00098d119d053c14", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d4301ea7eb7569881e2250a00098d119d053c14", "html_url": "https://github.com/rust-lang/rust/commit/2d4301ea7eb7569881e2250a00098d119d053c14"}, {"sha": "fd68670c0a65dc6b972b336d449ca60547a01355", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd68670c0a65dc6b972b336d449ca60547a01355", "html_url": "https://github.com/rust-lang/rust/commit/fd68670c0a65dc6b972b336d449ca60547a01355"}], "stats": {"total": 778, "additions": 559, "deletions": 219}, "files": [{"sha": "481815996a0e194baca5fc844bb5c5be06053551", "filename": "src/error.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9322dec830ba56ab81e5c7a467441501df4680f6/src%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9322dec830ba56ab81e5c7a467441501df4680f6/src%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ferror.rs?ref=9322dec830ba56ab81e5c7a467441501df4680f6", "patch": "@@ -1,14 +1,15 @@\n use std::error::Error;\n use std::fmt;\n use rustc::mir;\n-use rustc::ty::{BareFnTy, Ty};\n+use rustc::ty::{BareFnTy, Ty, FnSig};\n+use syntax::abi::Abi;\n use memory::Pointer;\n use rustc_const_math::ConstMathErr;\n use syntax::codemap::Span;\n \n #[derive(Clone, Debug)]\n pub enum EvalError<'tcx> {\n-    FunctionPointerTyMismatch(&'tcx BareFnTy<'tcx>, &'tcx BareFnTy<'tcx>),\n+    FunctionPointerTyMismatch(Abi, &'tcx FnSig<'tcx>, &'tcx BareFnTy<'tcx>),\n     NoMirFor(String),\n     DanglingPointerDeref,\n     InvalidMemoryAccess,\n@@ -61,7 +62,7 @@ impl<'tcx> Error for EvalError<'tcx> {\n             EvalError::DanglingPointerDeref =>\n                 \"dangling pointer was dereferenced\",\n             EvalError::InvalidFunctionPointer =>\n-                \"tried to use a pointer as a function pointer\",\n+                \"tried to use an integer pointer or a dangling pointer as a function pointer\",\n             EvalError::InvalidBool =>\n                 \"invalid boolean value read\",\n             EvalError::InvalidDiscriminant =>\n@@ -123,8 +124,8 @@ impl<'tcx> fmt::Display for EvalError<'tcx> {\n                        ptr.offset, ptr.offset + size, ptr.alloc_id, allocation_size)\n             },\n             EvalError::NoMirFor(ref func) => write!(f, \"no mir for `{}`\", func),\n-            EvalError::FunctionPointerTyMismatch(expected, got) =>\n-                write!(f, \"tried to call a function of type {:?} through a function pointer of type {:?}\", expected, got),\n+            EvalError::FunctionPointerTyMismatch(abi, sig, got) =>\n+                write!(f, \"tried to call a function with abi {:?} and sig {:?} through a function pointer of type {:?}\", abi, sig, got),\n             EvalError::ArrayIndexOutOfBounds(span, len, index) =>\n                 write!(f, \"index out of bounds: the len is {} but the index is {} at {:?}\", len, index, span),\n             EvalError::Math(span, ref err) =>"}, {"sha": "217a10a4c7bccb60d8fd53d49d3cceafddc49d26", "filename": "src/interpreter/cast.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9322dec830ba56ab81e5c7a467441501df4680f6/src%2Finterpreter%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9322dec830ba56ab81e5c7a467441501df4680f6/src%2Finterpreter%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fcast.rs?ref=9322dec830ba56ab81e5c7a467441501df4680f6", "patch": "@@ -21,10 +21,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             Bool | Char | U8 | U16 | U32 | U64 => self.cast_int(val.bits, ty, false),\n \n-            FnPtr | Ptr => {\n-                let ptr = val.expect_ptr(\"FnPtr- or Ptr-tagged PrimVal had no relocation\");\n-                self.cast_ptr(ptr, ty)\n-            }\n+            FnPtr | Ptr => self.cast_ptr(val.to_ptr(), ty),\n         }\n     }\n "}, {"sha": "ee503f97d78ea5f7facd7b92b1087b95919127a1", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 70, "deletions": 55, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/9322dec830ba56ab81e5c7a467441501df4680f6/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9322dec830ba56ab81e5c7a467441501df4680f6/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=9322dec830ba56ab81e5c7a467441501df4680f6", "patch": "@@ -182,7 +182,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         ty: Ty<'tcx>,\n         substs: &'tcx Substs<'tcx>\n     ) -> EvalResult<'tcx, Pointer> {\n-        let size = self.type_size_with_substs(ty, substs);\n+        let size = self.type_size_with_substs(ty, substs).expect(\"cannot alloc memory for unsized type\");\n         let align = self.type_align_with_substs(ty, substs);\n         self.memory.allocate(size, align)\n     }\n@@ -203,10 +203,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         PrimVal::from_uint_with_size(n, self.memory.pointer_size())\n     }\n \n-    fn isize_primval(&self, n: i64) -> PrimVal {\n-        PrimVal::from_int_with_size(n, self.memory.pointer_size())\n-    }\n-\n     fn str_to_value(&mut self, s: &str) -> EvalResult<'tcx, Value> {\n         // FIXME: cache these allocs\n         let ptr = self.memory.allocate(s.len(), 1)?;\n@@ -290,16 +286,21 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         self.tcx.normalize_associated_type(&substituted)\n     }\n \n-    fn type_size(&self, ty: Ty<'tcx>) -> usize {\n+    fn type_size(&self, ty: Ty<'tcx>) -> Option<usize> {\n         self.type_size_with_substs(ty, self.substs())\n     }\n \n     fn type_align(&self, ty: Ty<'tcx>) -> usize {\n         self.type_align_with_substs(ty, self.substs())\n     }\n \n-    fn type_size_with_substs(&self, ty: Ty<'tcx>, substs: &'tcx Substs<'tcx>) -> usize {\n-        self.type_layout_with_substs(ty, substs).size(&self.tcx.data_layout).bytes() as usize\n+    fn type_size_with_substs(&self, ty: Ty<'tcx>, substs: &'tcx Substs<'tcx>) -> Option<usize> {\n+        let layout = self.type_layout_with_substs(ty, substs);\n+        if layout.is_unsized() {\n+            None\n+        } else {\n+            Some(layout.size(&self.tcx.data_layout).bytes() as usize)\n+        }\n     }\n \n     fn type_align_with_substs(&self, ty: Ty<'tcx>, substs: &'tcx Substs<'tcx>) -> usize {\n@@ -480,7 +481,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                     Array { .. } => {\n                         let elem_size = match dest_ty.sty {\n-                            ty::TyArray(elem_ty, _) => self.type_size(elem_ty) as u64,\n+                            ty::TyArray(elem_ty, _) => self.type_size(elem_ty).expect(\"array elements are sized\") as u64,\n                             _ => bug!(\"tried to assign {:?} to non-array type {:?}\", kind, dest_ty),\n                         };\n                         let offsets = (0..).map(|i| i * elem_size);\n@@ -517,8 +518,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                                 let value_ty = self.operand_ty(operand);\n                                 self.write_value(value, dest, value_ty)?;\n                             } else {\n-                                assert_eq!(operands.len(), 0);\n-                                let zero = self.isize_primval(0);\n+                                if let Some(operand) = operands.get(0) {\n+                                    assert_eq!(operands.len(), 1);\n+                                    let operand_ty = self.operand_ty(operand);\n+                                    assert_eq!(self.type_size(operand_ty), Some(0));\n+                                }\n+                                let value_size = self.type_size(dest_ty).expect(\"pointer types are sized\");\n+                                let zero = PrimVal::from_int_with_size(0, value_size);\n                                 self.write_primval(dest, zero)?;\n                             }\n                         } else {\n@@ -534,15 +540,16 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                             } else {\n                                 for operand in operands {\n                                     let operand_ty = self.operand_ty(operand);\n-                                    assert_eq!(self.type_size(operand_ty), 0);\n+                                    assert_eq!(self.type_size(operand_ty), Some(0));\n                                 }\n-                                let offset = self.nonnull_offset(dest_ty, nndiscr, discrfield)?;\n+                                let (offset, ty) = self.nonnull_offset_and_ty(dest_ty, nndiscr, discrfield)?;\n \n                                 // FIXME(solson)\n                                 let dest = self.force_allocation(dest)?.to_ptr();\n \n                                 let dest = dest.offset(offset.bytes() as isize);\n-                                try!(self.memory.write_isize(dest, 0));\n+                                let dest_size = self.type_size(ty).expect(\"bad StructWrappedNullablePointer discrfield\");\n+                                try!(self.memory.write_int(dest, 0, dest_size));\n                             }\n                         } else {\n                             bug!(\"tried to assign {:?} to Layout::RawNullablePointer\", kind);\n@@ -567,6 +574,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         }\n                     }\n \n+                    Vector { element, count } => {\n+                        let elem_size = element.size(&self.tcx.data_layout).bytes();\n+                        debug_assert_eq!(count, operands.len() as u64);\n+                        let offsets = (0..).map(|i| i * elem_size);\n+                        self.assign_fields(dest, offsets, operands)?;\n+                    }\n+\n                     _ => return Err(EvalError::Unimplemented(format!(\"can't handle destination layout {:?} when assigning {:?}\", dest_layout, kind))),\n                 }\n             }\n@@ -576,7 +590,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     ty::TyArray(elem_ty, n) => (elem_ty, n),\n                     _ => bug!(\"tried to assign array-repeat to non-array type {:?}\", dest_ty),\n                 };\n-                let elem_size = self.type_size(elem_ty);\n+                let elem_size = self.type_size(elem_ty).expect(\"repeat element type must be sized\");\n                 let value = self.eval_operand(operand)?;\n \n                 // FIXME(solson)\n@@ -651,7 +665,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                     ReifyFnPointer => match self.operand_ty(operand).sty {\n                         ty::TyFnDef(def_id, substs, fn_ty) => {\n-                            let fn_ptr = self.memory.create_fn_ptr(def_id, substs, fn_ty);\n+                            let fn_ty = self.tcx.erase_regions(&fn_ty);\n+                            let fn_ptr = self.memory.create_fn_ptr(self.tcx,def_id, substs, fn_ty);\n                             self.write_value(Value::ByVal(PrimVal::from_fn_ptr(fn_ptr)), dest, dest_ty)?;\n                         },\n                         ref other => bug!(\"reify fn pointer on {:?}\", other),\n@@ -661,8 +676,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         ty::TyFnPtr(unsafe_fn_ty) => {\n                             let src = self.eval_operand(operand)?;\n                             let ptr = src.read_ptr(&self.memory)?;\n-                            let (def_id, substs, _) = self.memory.get_fn(ptr.alloc_id)?;\n-                            let fn_ptr = self.memory.create_fn_ptr(def_id, substs, unsafe_fn_ty);\n+                            let (def_id, substs, _, _) = self.memory.get_fn(ptr.alloc_id)?;\n+                            let unsafe_fn_ty = self.tcx.erase_regions(&unsafe_fn_ty);\n+                            let fn_ptr = self.memory.create_fn_ptr(self.tcx, def_id, substs, unsafe_fn_ty);\n                             self.write_value(Value::ByVal(PrimVal::from_fn_ptr(fn_ptr)), dest, dest_ty)?;\n                         },\n                         ref other => bug!(\"fn to unsafe fn cast on {:?}\", other),\n@@ -689,7 +705,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    fn nonnull_offset(&self, ty: Ty<'tcx>, nndiscr: u64, discrfield: &[u32]) -> EvalResult<'tcx, Size> {\n+    fn nonnull_offset_and_ty(&self, ty: Ty<'tcx>, nndiscr: u64, discrfield: &[u32]) -> EvalResult<'tcx, (Size, Ty<'tcx>)> {\n         // Skip the constant 0 at the start meant for LLVM GEP.\n         let mut path = discrfield.iter().skip(1).map(|&i| i as usize);\n \n@@ -704,10 +720,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             _ => bug!(\"non-enum for StructWrappedNullablePointer: {}\", ty),\n         };\n \n-        self.field_path_offset(inner_ty, path)\n+        self.field_path_offset_and_ty(inner_ty, path)\n     }\n \n-    fn field_path_offset<I: Iterator<Item = usize>>(&self, mut ty: Ty<'tcx>, path: I) -> EvalResult<'tcx, Size> {\n+    fn field_path_offset_and_ty<I: Iterator<Item = usize>>(&self, mut ty: Ty<'tcx>, path: I) -> EvalResult<'tcx, (Size, Ty<'tcx>)> {\n         let mut offset = Size::from_bytes(0);\n \n         // Skip the initial 0 intended for LLVM GEP.\n@@ -717,7 +733,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             offset = offset.checked_add(field_offset, &self.tcx.data_layout).unwrap();\n         }\n \n-        Ok(offset)\n+        Ok((offset, ty))\n     }\n \n     fn get_field_ty(&self, ty: Ty<'tcx>, field_index: usize) -> EvalResult<'tcx, Ty<'tcx>> {\n@@ -731,8 +747,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             ty::TyRef(_, ty::TypeAndMut { ty, .. }) |\n             ty::TyRawPtr(ty::TypeAndMut { ty, .. }) |\n             ty::TyBox(ty) => {\n-                assert_eq!(field_index, 0);\n-                Ok(ty)\n+                match (field_index, &self.tcx.struct_tail(ty).sty) {\n+                    (1, &ty::TyStr) |\n+                    (1, &ty::TySlice(_)) => Ok(self.tcx.types.usize),\n+                    (1, &ty::TyTrait(_)) |\n+                    (0, _) => Ok(self.tcx.mk_imm_ptr(self.tcx.types.u8)),\n+                    _ => bug!(\"invalid fat pointee type: {}\", ty),\n+                }\n             }\n             _ => Err(EvalError::Unimplemented(format!(\"can't handle type: {:?}, {:?}\", ty, ty.sty))),\n         }\n@@ -955,33 +976,27 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             Deref => {\n-                use interpreter::value::Value::*;\n+                let val = self.eval_and_read_lvalue(&proj.base)?;\n \n-                let val = match self.eval_and_read_lvalue(&proj.base)? {\n-                    ByRef(ptr) => self.read_value(ptr, base_ty)?,\n-                    v => v,\n+                let pointee_type = match base_ty.sty {\n+                    ty::TyRawPtr(ty::TypeAndMut{ty, ..}) |\n+                    ty::TyRef(_, ty::TypeAndMut{ty, ..}) |\n+                    ty::TyBox(ty) => ty,\n+                    _ => bug!(\"can only deref pointer types\"),\n                 };\n \n-                match val {\n-                    ByValPair(ptr, vtable)\n-                        if ptr.try_as_ptr().is_some() && vtable.try_as_ptr().is_some()\n-                    => {\n-                        let ptr = ptr.try_as_ptr().unwrap();\n-                        let vtable = vtable.try_as_ptr().unwrap();\n-                        (ptr, LvalueExtra::Vtable(vtable))\n-                    }\n-\n-                    ByValPair(ptr, n) if ptr.try_as_ptr().is_some() => {\n-                        let ptr = ptr.try_as_ptr().unwrap();\n-                        (ptr, LvalueExtra::Length(n.expect_uint(\"slice length\")))\n-                    }\n+                trace!(\"deref to {} on {:?}\", pointee_type, val);\n \n-                    ByVal(ptr) if ptr.try_as_ptr().is_some() => {\n-                        let ptr = ptr.try_as_ptr().unwrap();\n-                        (ptr, LvalueExtra::None)\n-                    }\n-\n-                    _ => bug!(\"can't deref non pointer types\"),\n+                match self.tcx.struct_tail(pointee_type).sty {\n+                    ty::TyTrait(_) => {\n+                        let (ptr, vtable) = val.expect_ptr_vtable_pair(&self.memory)?;\n+                        (ptr, LvalueExtra::Vtable(vtable))\n+                    },\n+                    ty::TyStr | ty::TySlice(_) => {\n+                        let (ptr, len) = val.expect_slice(&self.memory)?;\n+                        (ptr, LvalueExtra::Length(len))\n+                    },\n+                    _ => (val.read_ptr(&self.memory)?, LvalueExtra::None),\n                 }\n             }\n \n@@ -991,7 +1006,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let (base_ptr, _) = base.to_ptr_and_extra();\n \n                 let (elem_ty, len) = base.elem_ty_and_len(base_ty);\n-                let elem_size = self.type_size(elem_ty);\n+                let elem_size = self.type_size(elem_ty).expect(\"slice element must be sized\");\n                 let n_ptr = self.eval_operand(operand)?;\n                 let usize = self.tcx.types.usize;\n                 let n = self.value_to_primval(n_ptr, usize)?\n@@ -1007,7 +1022,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let (base_ptr, _) = base.to_ptr_and_extra();\n \n                 let (elem_ty, n) = base.elem_ty_and_len(base_ty);\n-                let elem_size = self.type_size(elem_ty);\n+                let elem_size = self.type_size(elem_ty).expect(\"sequence element must be sized\");\n                 assert!(n >= min_length as u64);\n \n                 let index = if from_end {\n@@ -1026,7 +1041,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let (base_ptr, _) = base.to_ptr_and_extra();\n \n                 let (elem_ty, n) = base.elem_ty_and_len(base_ty);\n-                let elem_size = self.type_size(elem_ty);\n+                let elem_size = self.type_size(elem_ty).expect(\"slice element must be sized\");\n                 assert!((from as u64) <= n - (to as u64));\n                 let ptr = base_ptr.offset(from as isize * elem_size as isize);\n                 let extra = LvalueExtra::Length(n - to as u64 - from as u64);\n@@ -1046,7 +1061,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     }\n \n     fn copy(&mut self, src: Pointer, dest: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, ()> {\n-        let size = self.type_size(ty);\n+        let size = self.type_size(ty).expect(\"cannot copy from an unsized type\");\n         let align = self.type_align(ty);\n         self.memory.copy(src, dest, size, align)?;\n         Ok(())\n@@ -1388,7 +1403,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             ty::TyFloat(FloatTy::F64) => PrimVal::from_f64(self.memory.read_f64(ptr)?),\n \n             ty::TyFnDef(def_id, substs, fn_ty) => {\n-                PrimVal::from_fn_ptr(self.memory.create_fn_ptr(def_id, substs, fn_ty))\n+                PrimVal::from_fn_ptr(self.memory.create_fn_ptr(self.tcx, def_id, substs, fn_ty))\n             },\n             ty::TyFnPtr(_) => self.memory.read_ptr(ptr).map(PrimVal::from_fn_ptr)?,\n             ty::TyBox(ty) |\n@@ -1398,7 +1413,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 if self.type_is_sized(ty) {\n                     PrimVal::from_ptr(p)\n                 } else {\n-                    // FIXME: extract the offset to the tail field for `Box<(i64, i32, [u8])>`\n+                    trace!(\"reading fat pointer extra of type {}\", ty);\n                     let extra = ptr.offset(self.memory.pointer_size() as isize);\n                     let extra = match self.tcx.struct_tail(ty).sty {\n                         ty::TyTrait(..) => PrimVal::from_ptr(self.memory.read_ptr(extra)?),\n@@ -1505,14 +1520,14 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 //let dst = adt::MaybeSizedValue::sized(dst);\n                 let src_ptr = match src {\n                     Value::ByRef(ptr) => ptr,\n-                    _ => panic!(\"expected pointer, got {:?}\", src),\n+                    _ => bug!(\"expected pointer, got {:?}\", src),\n                 };\n \n                 let iter = src_fields.zip(dst_fields).enumerate();\n                 for (i, (src_f, dst_f)) in iter {\n                     let src_fty = monomorphize_field_ty(self.tcx, src_f, substs_a);\n                     let dst_fty = monomorphize_field_ty(self.tcx, dst_f, substs_b);\n-                    if self.type_size(dst_fty) == 0 {\n+                    if self.type_size(dst_fty) == Some(0) {\n                         continue;\n                     }\n                     let src_field_offset = self.get_field_offset(src_ty, i)?.bytes() as isize;"}, {"sha": "5cea0bc2d0c7096ba4fcc95adc00c4d1476d6e7c", "filename": "src/interpreter/terminator/intrinsics.rs", "status": "modified", "additions": 66, "deletions": 12, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/9322dec830ba56ab81e5c7a467441501df4680f6/src%2Finterpreter%2Fterminator%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9322dec830ba56ab81e5c7a467441501df4680f6/src%2Finterpreter%2Fterminator%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator%2Fintrinsics.rs?ref=9322dec830ba56ab81e5c7a467441501df4680f6", "patch": "@@ -57,6 +57,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             \"atomic_load\" |\n+            \"atomic_load_acq\" |\n             \"volatile_load\" => {\n                 let ty = substs.type_at(0);\n                 let ptr = arg_vals[0].read_ptr(&self.memory)?;\n@@ -74,6 +75,53 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 // we are inherently singlethreaded and singlecored, this is a nop\n             }\n \n+            \"atomic_xchg\" => {\n+                let ty = substs.type_at(0);\n+                let ptr = arg_vals[0].read_ptr(&self.memory)?;\n+                let change = self.value_to_primval(arg_vals[1], ty)?;\n+                let old = self.read_value(ptr, ty)?;\n+                let old = match old {\n+                    Value::ByVal(val) => val,\n+                    Value::ByRef(_) => bug!(\"just read the value, can't be byref\"),\n+                    Value::ByValPair(..) => bug!(\"atomic_xchg doesn't work with nonprimitives\"),\n+                };\n+                self.write_primval(dest, old)?;\n+                self.write_primval(Lvalue::from_ptr(ptr), change)?;\n+            }\n+\n+            \"atomic_cxchg\" => {\n+                let ty = substs.type_at(0);\n+                let ptr = arg_vals[0].read_ptr(&self.memory)?;\n+                let expect_old = self.value_to_primval(arg_vals[1], ty)?;\n+                let change = self.value_to_primval(arg_vals[2], ty)?;\n+                let old = self.read_value(ptr, ty)?;\n+                let old = match old {\n+                    Value::ByVal(val) => val,\n+                    Value::ByRef(_) => bug!(\"just read the value, can't be byref\"),\n+                    Value::ByValPair(..) => bug!(\"atomic_cxchg doesn't work with nonprimitives\"),\n+                };\n+                let (val, _) = primval::binary_op(mir::BinOp::Eq, old, expect_old)?;\n+                let dest = self.force_allocation(dest)?.to_ptr();\n+                self.write_pair_to_ptr(old, val, dest, dest_ty)?;\n+                self.write_primval(Lvalue::from_ptr(ptr), change)?;\n+            }\n+\n+            \"atomic_xadd_relaxed\" => {\n+                let ty = substs.type_at(0);\n+                let ptr = arg_vals[0].read_ptr(&self.memory)?;\n+                let change = self.value_to_primval(arg_vals[1], ty)?;\n+                let old = self.read_value(ptr, ty)?;\n+                let old = match old {\n+                    Value::ByVal(val) => val,\n+                    Value::ByRef(_) => bug!(\"just read the value, can't be byref\"),\n+                    Value::ByValPair(..) => bug!(\"atomic_xadd_relaxed doesn't work with nonprimitives\"),\n+                };\n+                self.write_primval(dest, old)?;\n+                // FIXME: what do atomics do on overflow?\n+                let (val, _) = primval::binary_op(mir::BinOp::Add, old, change)?;\n+                self.write_primval(Lvalue::from_ptr(ptr), val)?;\n+            },\n+\n             \"atomic_xsub_rel\" => {\n                 let ty = substs.type_at(0);\n                 let ptr = arg_vals[0].read_ptr(&self.memory)?;\n@@ -96,7 +144,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"copy_nonoverlapping\" => {\n                 // FIXME: check whether overlapping occurs\n                 let elem_ty = substs.type_at(0);\n-                let elem_size = self.type_size(elem_ty);\n+                let elem_size = self.type_size(elem_ty).expect(\"cannot copy unsized value\");\n                 let elem_align = self.type_align(elem_ty);\n                 let src = arg_vals[0].read_ptr(&self.memory)?;\n                 let dest = arg_vals[1].read_ptr(&self.memory)?;\n@@ -124,15 +172,17 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"drop_in_place\" => {\n                 let ty = substs.type_at(0);\n+                trace!(\"drop in place on {}\", ty);\n                 let ptr_ty = self.tcx.mk_mut_ptr(ty);\n                 let lvalue = match self.follow_by_ref_value(arg_vals[0], ptr_ty)? {\n                     Value::ByRef(_) => bug!(\"follow_by_ref_value returned ByRef\"),\n-                    Value::ByVal(ptr) => Lvalue::from_ptr(ptr.expect_ptr(\"drop_in_place first arg not a pointer\")),\n+                    Value::ByVal(value) => Lvalue::from_ptr(value.to_ptr()),\n                     Value::ByValPair(ptr, extra) => Lvalue::Ptr {\n-                        ptr: ptr.expect_ptr(\"drop_in_place first arg not a pointer\"),\n-                        extra: match extra.try_as_ptr() {\n-                            Some(vtable) => LvalueExtra::Vtable(vtable),\n-                            None => LvalueExtra::Length(extra.expect_uint(\"either pointer or not, but not neither\")),\n+                        ptr: ptr.to_ptr(),\n+                        extra: match self.tcx.struct_tail(ty).sty {\n+                            ty::TyTrait(_) => LvalueExtra::Vtable(extra.to_ptr()),\n+                            ty::TyStr | ty::TySlice(_) => LvalueExtra::Length(extra.try_as_uint()?),\n+                            _ => bug!(\"invalid fat pointer type: {}\", ptr_ty),\n                         },\n                     },\n                 };\n@@ -230,7 +280,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"offset\" => {\n                 let pointee_ty = substs.type_at(0);\n-                let pointee_size = self.type_size(pointee_ty) as isize;\n+                let pointee_size = self.type_size(pointee_ty).expect(\"cannot offset a pointer to an unsized type\") as isize;\n                 let offset = self.value_to_primval(arg_vals[1], isize)?\n                     .expect_int(\"offset second arg not isize\");\n \n@@ -281,7 +331,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"size_of\" => {\n                 let ty = substs.type_at(0);\n-                let size = self.type_size(ty) as u64;\n+                // FIXME: change the `box_free` lang item to take `T: ?Sized` and have it use the\n+                // `size_of_val` intrinsic, then change this back to\n+                // .expect(\"size_of intrinsic called on unsized value\")\n+                // see https://github.com/rust-lang/rust/pull/37708\n+                let size = self.type_size(ty).unwrap_or(!0) as u64;\n                 let size_val = self.usize_primval(size);\n                 self.write_primval(dest, size_val)?;\n             }\n@@ -360,8 +414,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         value: Value,\n     ) -> EvalResult<'tcx, (u64, u64)> {\n         let pointer_size = self.memory.pointer_size();\n-        if self.type_is_sized(ty) {\n-            Ok((self.type_size(ty) as u64, self.type_align(ty) as u64))\n+        if let Some(size) = self.type_size(ty) {\n+            Ok((size as u64, self.type_align(ty) as u64))\n         } else {\n             match ty.sty {\n                 ty::TyAdt(def, substs) => {\n@@ -435,8 +489,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                 ty::TySlice(_) | ty::TyStr => {\n                     let elem_ty = ty.sequence_element_type(self.tcx);\n-                    let elem_size = self.type_size(elem_ty) as u64;\n-                    let len = value.expect_slice_len(&self.memory)?;\n+                    let elem_size = self.type_size(elem_ty).expect(\"slice element must be sized\") as u64;\n+                    let (_, len) = value.expect_slice(&self.memory)?;\n                     let align = self.type_align(elem_ty);\n                     Ok((len * elem_size, align as u64))\n                 }"}, {"sha": "ccf7671eec23e5082fe6a20c85c3fd376f077c49", "filename": "src/interpreter/terminator/mod.rs", "status": "modified", "additions": 27, "deletions": 26, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/9322dec830ba56ab81e5c7a467441501df4680f6/src%2Finterpreter%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9322dec830ba56ab81e5c7a467441501df4680f6/src%2Finterpreter%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator%2Fmod.rs?ref=9322dec830ba56ab81e5c7a467441501df4680f6", "patch": "@@ -85,11 +85,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let func_ty = self.operand_ty(func);\n                 match func_ty.sty {\n                     ty::TyFnPtr(bare_fn_ty) => {\n-                        let fn_ptr = self.eval_operand_to_primval(func)?\n-                            .expect_fn_ptr(\"TyFnPtr callee did not evaluate to FnPtr\");\n-                        let (def_id, substs, fn_ty) = self.memory.get_fn(fn_ptr.alloc_id)?;\n-                        if fn_ty != bare_fn_ty {\n-                            return Err(EvalError::FunctionPointerTyMismatch(fn_ty, bare_fn_ty));\n+                        let fn_ptr = self.eval_operand_to_primval(func)?.to_ptr();\n+                        let (def_id, substs, abi, sig) = self.memory.get_fn(fn_ptr.alloc_id)?;\n+                        if abi != bare_fn_ty.abi || sig != bare_fn_ty.sig.skip_binder() {\n+                            return Err(EvalError::FunctionPointerTyMismatch(abi, sig, bare_fn_ty));\n                         }\n                         self.eval_fn_call(def_id, substs, bare_fn_ty, destination, args,\n                                           terminator.source_info.span)?\n@@ -193,7 +192,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             Abi::C => {\n                 let ty = fn_ty.sig.0.output;\n-                let size = self.type_size(ty);\n+                let size = self.type_size(ty).expect(\"function return type cannot be unsized\");\n                 let (ret, target) = destination.unwrap();\n                 self.call_c_abi(def_id, arg_operands, ret, size)?;\n                 self.goto_block(target);\n@@ -263,14 +262,17 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 self.memory.read_int(adt_ptr, discr_size as usize)? as u64\n             }\n \n-            RawNullablePointer { nndiscr, .. } => {\n-                self.read_nonnull_discriminant_value(adt_ptr, nndiscr)?\n+            RawNullablePointer { nndiscr, value } => {\n+                let discr_size = value.size(&self.tcx.data_layout).bytes() as usize;\n+                self.read_nonnull_discriminant_value(adt_ptr, nndiscr, discr_size)?\n             }\n \n             StructWrappedNullablePointer { nndiscr, ref discrfield, .. } => {\n-                let offset = self.nonnull_offset(adt_ty, nndiscr, discrfield)?;\n+                let (offset, ty) = self.nonnull_offset_and_ty(adt_ty, nndiscr, discrfield)?;\n                 let nonnull = adt_ptr.offset(offset.bytes() as isize);\n-                self.read_nonnull_discriminant_value(nonnull, nndiscr)?\n+                // only the pointer part of a fat pointer is used for this space optimization\n+                let discr_size = self.type_size(ty).expect(\"bad StructWrappedNullablePointer discrfield\");\n+                self.read_nonnull_discriminant_value(nonnull, nndiscr, discr_size)?\n             }\n \n             // The discriminant_value intrinsic returns 0 for non-sum types.\n@@ -281,8 +283,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(discr_val)\n     }\n \n-    fn read_nonnull_discriminant_value(&self, ptr: Pointer, nndiscr: u64) -> EvalResult<'tcx, u64> {\n-        let not_null = match self.memory.read_usize(ptr) {\n+    fn read_nonnull_discriminant_value(&self, ptr: Pointer, nndiscr: u64, discr_size: usize) -> EvalResult<'tcx, u64> {\n+        let not_null = match self.memory.read_uint(ptr, discr_size) {\n             Ok(0) => false,\n             Ok(_) | Err(EvalError::ReadPointerAsBytes) => true,\n             Err(e) => return Err(e),\n@@ -498,9 +500,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     let idx = idx + 3;\n                     let offset = idx * self.memory.pointer_size();\n                     let fn_ptr = self.memory.read_ptr(vtable.offset(offset as isize))?;\n-                    let (def_id, substs, ty) = self.memory.get_fn(fn_ptr.alloc_id)?;\n-                    // FIXME: skip_binder is wrong for HKL\n-                    *first_ty = ty.sig.skip_binder().inputs[0];\n+                    let (def_id, substs, _abi, sig) = self.memory.get_fn(fn_ptr.alloc_id)?;\n+                    *first_ty = sig.inputs[0];\n                     Ok((def_id, substs))\n                 } else {\n                     Err(EvalError::VtableForArgumentlessMethod)\n@@ -539,14 +540,15 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     Value::ByRef(_) => bug!(\"follow_by_ref_value can't result in ByRef\"),\n                     Value::ByVal(ptr) => {\n                         assert!(self.type_is_sized(contents_ty));\n-                        let contents_ptr = ptr.expect_ptr(\"value of Box type must be a pointer\");\n+                        let contents_ptr = ptr.to_ptr();\n                         self.drop(Lvalue::from_ptr(contents_ptr), contents_ty, drop)?;\n                     },\n                     Value::ByValPair(prim_ptr, extra) => {\n-                        let ptr = prim_ptr.expect_ptr(\"value of Box type must be a pointer\");\n-                        let extra = match extra.try_as_ptr() {\n-                            Some(vtable) => LvalueExtra::Vtable(vtable),\n-                            None => LvalueExtra::Length(extra.expect_uint(\"slice length\")),\n+                        let ptr = prim_ptr.to_ptr();\n+                        let extra = match self.tcx.struct_tail(contents_ty).sty {\n+                            ty::TyTrait(_) => LvalueExtra::Vtable(extra.to_ptr()),\n+                            ty::TyStr | ty::TySlice(_) => LvalueExtra::Length(extra.try_as_uint()?),\n+                            _ => bug!(\"invalid fat pointer type: {}\", ty),\n                         };\n                         self.drop(\n                             Lvalue::Ptr {\n@@ -639,10 +641,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 };\n                 let drop_fn = self.memory.read_ptr(vtable)?;\n                 // some values don't need to call a drop impl, so the value is null\n-                if !drop_fn.points_to_zst() {\n-                    let (def_id, substs, ty) = self.memory.get_fn(drop_fn.alloc_id)?;\n-                    let fn_sig = self.tcx.erase_late_bound_regions_and_normalize(&ty.sig);\n-                    let real_ty = fn_sig.inputs[0];\n+                if drop_fn != Pointer::from_int(0) {\n+                    let (def_id, substs, _abi, sig) = self.memory.get_fn(drop_fn.alloc_id)?;\n+                    let real_ty = sig.inputs[0];\n                     self.drop(Lvalue::from_ptr(ptr), real_ty, drop)?;\n                     drop.push((def_id, Value::ByVal(PrimVal::from_ptr(ptr)), substs));\n                 } else {\n@@ -655,7 +656,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     Lvalue::Ptr { ptr, extra: LvalueExtra::Length(len) } => (ptr, len as isize),\n                     _ => bug!(\"expected an lvalue with a length\"),\n                 };\n-                let size = self.type_size(elem_ty) as isize;\n+                let size = self.type_size(elem_ty).expect(\"slice element must be sized\") as isize;\n                 // FIXME: this creates a lot of stack frames if the element type has\n                 // a drop impl\n                 for i in 0..len {\n@@ -668,7 +669,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     Lvalue::Ptr { ptr, extra } => (ptr, extra),\n                     _ => bug!(\"expected an lvalue with optional extra data\"),\n                 };\n-                let size = self.type_size(elem_ty) as isize;\n+                let size = self.type_size(elem_ty).expect(\"array element cannot be unsized\") as isize;\n                 // FIXME: this creates a lot of stack frames if the element type has\n                 // a drop impl\n                 for i in 0..len {"}, {"sha": "fa89d02ad77d12dc151cff4248a99c5813d307bc", "filename": "src/interpreter/value.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9322dec830ba56ab81e5c7a467441501df4680f6/src%2Finterpreter%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9322dec830ba56ab81e5c7a467441501df4680f6/src%2Finterpreter%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fvalue.rs?ref=9322dec830ba56ab81e5c7a467441501df4680f6", "patch": "@@ -22,10 +22,7 @@ impl<'a, 'tcx: 'a> Value {\n         use self::Value::*;\n         match *self {\n             ByRef(ptr) => mem.read_ptr(ptr),\n-\n-            ByVal(ptr) | ByValPair(ptr, _) => {\n-                Ok(ptr.try_as_ptr().expect(\"unimplemented: `read_ptr` on non-ptr primval\"))\n-            }\n+            ByVal(ptr) | ByValPair(ptr, _) => Ok(ptr.to_ptr()),\n         }\n     }\n \n@@ -35,29 +32,29 @@ impl<'a, 'tcx: 'a> Value {\n     ) -> EvalResult<'tcx, (Pointer, Pointer)> {\n         use self::Value::*;\n         match *self {\n-            ByRef(ptr) => {\n-                let ptr = mem.read_ptr(ptr)?;\n-                let vtable = mem.read_ptr(ptr.offset(mem.pointer_size() as isize))?;\n+            ByRef(ref_ptr) => {\n+                let ptr = mem.read_ptr(ref_ptr)?;\n+                let vtable = mem.read_ptr(ref_ptr.offset(mem.pointer_size() as isize))?;\n                 Ok((ptr, vtable))\n             }\n \n-            ByValPair(ptr, vtable)\n-                if ptr.try_as_ptr().is_some() && vtable.try_as_ptr().is_some()\n-            => {\n-                let ptr = ptr.try_as_ptr().unwrap();\n-                let vtable = vtable.try_as_ptr().unwrap();\n-                Ok((ptr, vtable))\n-            }\n+            ByValPair(ptr, vtable) => Ok((ptr.to_ptr(), vtable.to_ptr())),\n \n             _ => bug!(\"expected ptr and vtable, got {:?}\", self),\n         }\n     }\n \n-    pub(super) fn expect_slice_len(&self, mem: &Memory<'a, 'tcx>) -> EvalResult<'tcx, u64> {\n+    pub(super) fn expect_slice(&self, mem: &Memory<'a, 'tcx>) -> EvalResult<'tcx, (Pointer, u64)> {\n         use self::Value::*;\n         match *self {\n-            ByRef(ptr) => mem.read_usize(ptr.offset(mem.pointer_size() as isize)),\n-            ByValPair(_, val) if val.kind.is_int() => Ok(val.bits),\n+            ByRef(ref_ptr) => {\n+                let ptr = mem.read_ptr(ref_ptr)?;\n+                let len = mem.read_usize(ref_ptr.offset(mem.pointer_size() as isize))?;\n+                Ok((ptr, len))\n+            },\n+            ByValPair(ptr, val) => {\n+                Ok((ptr.to_ptr(), val.try_as_uint()?))\n+            },\n             _ => unimplemented!(),\n         }\n     }"}, {"sha": "6651194be7d1a8c88989692aa189df9f559eb808", "filename": "src/interpreter/vtable.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9322dec830ba56ab81e5c7a467441501df4680f6/src%2Finterpreter%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9322dec830ba56ab81e5c7a467441501df4680f6/src%2Finterpreter%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fvtable.rs?ref=9322dec830ba56ab81e5c7a467441501df4680f6", "patch": "@@ -35,7 +35,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     self.get_vtable_methods(id, substs)\n                         .into_iter()\n                         .map(|opt_mth| opt_mth.map(|mth| {\n-                            self.memory.create_fn_ptr(mth.method.def_id, mth.substs, mth.method.fty)\n+                            let fn_ty = self.tcx.erase_regions(&mth.method.fty);\n+                            self.memory.create_fn_ptr(self.tcx, mth.method.def_id, mth.substs, fn_ty)\n                         }))\n                         .collect::<Vec<_>>()\n                         .into_iter()\n@@ -46,22 +47,18 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         substs,\n                         nested: _ }) => {\n                     let closure_type = self.tcx.closure_type(closure_def_id, substs);\n-                    let fn_ty = ty::BareFnTy {\n-                        unsafety: closure_type.unsafety,\n-                        abi: closure_type.abi,\n-                        sig: closure_type.sig,\n-                    };\n-                    let _fn_ty = self.tcx.mk_bare_fn(fn_ty);\n-                    unimplemented!()\n-                    //vec![Some(self.memory.create_fn_ptr(closure_def_id, substs.func_substs, fn_ty))].into_iter()\n+                    vec![Some(self.memory.create_closure_ptr(self.tcx, closure_def_id, substs, closure_type))].into_iter()\n                 }\n                 traits::VtableFnPointer(\n                     traits::VtableFnPointerData {\n-                        fn_ty: _bare_fn_ty,\n+                        fn_ty,\n                         nested: _ }) => {\n-                    let _trait_closure_kind = tcx.lang_items.fn_trait_kind(trait_ref.def_id()).unwrap();\n-                    //vec![trans_fn_pointer_shim(ccx, trait_closure_kind, bare_fn_ty)].into_iter()\n-                    unimplemented!()\n+                    match fn_ty.sty {\n+                        ty::TyFnDef(did, substs, bare_fn_ty) => {\n+                            vec![Some(self.memory.create_fn_ptr(self.tcx, did, substs, bare_fn_ty))].into_iter()\n+                        },\n+                        _ => bug!(\"bad VtableFnPointer fn_ty: {:?}\", fn_ty),\n+                    }\n                 }\n                 traits::VtableObject(ref data) => {\n                     // this would imply that the Self type being erased is\n@@ -78,7 +75,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n         }).collect();\n \n-        let size = self.type_size(trait_ref.self_ty());\n+        let size = self.type_size(trait_ref.self_ty()).expect(\"can't create a vtable for an unsized type\");\n         let align = self.type_align(trait_ref.self_ty());\n \n         let ptr_size = self.memory.pointer_size();\n@@ -90,10 +87,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             if let Some(drop_def_id) = adt_def.destructor() {\n                 let ty_scheme = self.tcx.lookup_item_type(drop_def_id);\n                 let fn_ty = match ty_scheme.ty.sty {\n-                    ty::TyFnDef(_, _, fn_ty) => fn_ty,\n+                    ty::TyFnDef(_, _, fn_ty) => self.tcx.erase_regions(&fn_ty),\n                     _ => bug!(\"drop method is not a TyFnDef\"),\n                 };\n-                let fn_ptr = self.memory.create_fn_ptr(drop_def_id, substs, fn_ty);\n+                let fn_ptr = self.memory.create_fn_ptr(self.tcx, drop_def_id, substs, fn_ty);\n                 self.memory.write_ptr(vtable, fn_ptr)?;\n             }\n         }"}, {"sha": "fce0ff4c976a4830a8ffbd267e0d2dd8042af76e", "filename": "src/memory.rs", "status": "modified", "additions": 37, "deletions": 54, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/9322dec830ba56ab81e5c7a467441501df4680f6/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9322dec830ba56ab81e5c7a467441501df4680f6/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=9322dec830ba56ab81e5c7a467441501df4680f6", "patch": "@@ -4,10 +4,12 @@ use std::collections::{btree_map, BTreeMap, HashMap, HashSet, VecDeque};\n use std::{fmt, iter, ptr};\n \n use rustc::hir::def_id::DefId;\n-use rustc::ty::{BareFnTy, ClosureTy, ClosureSubsts};\n+use rustc::ty::{self, BareFnTy, ClosureTy, ClosureSubsts, TyCtxt};\n use rustc::ty::subst::Substs;\n use rustc::ty::layout::{self, TargetDataLayout};\n \n+use syntax::abi::Abi;\n+\n use error::{EvalError, EvalResult};\n use primval::PrimVal;\n \n@@ -73,7 +75,7 @@ impl Pointer {\n     // FIXME(solson): Integer pointers should use u64, not usize. Target pointers can be larger\n     // than host usize.\n     pub fn from_int(i: usize) -> Self {\n-        Pointer::new(ZST_ALLOC_ID, i)\n+        Pointer::new(NEVER_ALLOC_ID, i)\n     }\n \n     pub fn zst_ptr() -> Self {\n@@ -88,19 +90,9 @@ impl Pointer {\n #[derive(Debug, Clone, Hash, Eq, PartialEq)]\n struct FunctionDefinition<'tcx> {\n     pub def_id: DefId,\n-    pub kind: FunctionKind<'tcx>,\n-}\n-\n-#[derive(Debug, Clone, Hash, Eq, PartialEq)]\n-enum FunctionKind<'tcx> {\n-    Closure {\n-        substs: ClosureSubsts<'tcx>,\n-        ty: ClosureTy<'tcx>,\n-    },\n-    Function {\n-        substs: &'tcx Substs<'tcx>,\n-        ty: &'tcx BareFnTy<'tcx>,\n-    }\n+    pub substs: &'tcx Substs<'tcx>,\n+    pub abi: Abi,\n+    pub sig: &'tcx ty::FnSig<'tcx>,\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -143,23 +135,31 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         self.alloc_map.iter()\n     }\n \n-    pub fn create_closure_ptr(&mut self, def_id: DefId, substs: ClosureSubsts<'tcx>, fn_ty: ClosureTy<'tcx>) -> Pointer {\n+    pub fn create_closure_ptr(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId, substs: ClosureSubsts<'tcx>, fn_ty: ClosureTy<'tcx>) -> Pointer {\n+        // FIXME: this is a hack\n+        let fn_ty = tcx.mk_bare_fn(ty::BareFnTy {\n+            unsafety: fn_ty.unsafety,\n+            abi: fn_ty.abi,\n+            sig: fn_ty.sig,\n+        });\n         self.create_fn_alloc(FunctionDefinition {\n             def_id: def_id,\n-            kind: FunctionKind::Closure {\n-                substs: substs,\n-                ty: fn_ty,\n-            }\n+            substs: substs.func_substs,\n+            abi: fn_ty.abi,\n+            // FIXME: why doesn't this compile?\n+            //sig: tcx.erase_late_bound_regions(&fn_ty.sig),\n+            sig: fn_ty.sig.skip_binder(),\n         })\n     }\n \n-    pub fn create_fn_ptr(&mut self, def_id: DefId, substs: &'tcx Substs<'tcx>, fn_ty: &'tcx BareFnTy<'tcx>) -> Pointer {\n+    pub fn create_fn_ptr(&mut self, _tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId, substs: &'tcx Substs<'tcx>, fn_ty: &'tcx BareFnTy<'tcx>) -> Pointer {\n         self.create_fn_alloc(FunctionDefinition {\n             def_id: def_id,\n-            kind: FunctionKind::Function {\n-                substs: substs,\n-                ty: fn_ty,\n-            }\n+            substs: substs,\n+            abi: fn_ty.abi,\n+            // FIXME: why doesn't this compile?\n+            //sig: tcx.erase_late_bound_regions(&fn_ty.sig),\n+            sig: fn_ty.sig.skip_binder(),\n         })\n     }\n \n@@ -290,7 +290,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             Some(alloc) => Ok(alloc),\n             None => match self.functions.get(&id) {\n                 Some(_) => Err(EvalError::DerefFunctionPointer),\n-                None if id == ZST_ALLOC_ID => Err(EvalError::InvalidMemoryAccess),\n+                None if id == NEVER_ALLOC_ID || id == ZST_ALLOC_ID => Err(EvalError::InvalidMemoryAccess),\n                 None => Err(EvalError::DanglingPointerDeref),\n             }\n         }\n@@ -302,39 +302,21 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             Some(alloc) => Ok(alloc),\n             None => match self.functions.get(&id) {\n                 Some(_) => Err(EvalError::DerefFunctionPointer),\n-                None if id == ZST_ALLOC_ID => Err(EvalError::InvalidMemoryAccess),\n+                None if id == NEVER_ALLOC_ID || id == ZST_ALLOC_ID => Err(EvalError::InvalidMemoryAccess),\n                 None => Err(EvalError::DanglingPointerDeref),\n             }\n         }\n     }\n \n-    pub fn get_closure(&self, id: AllocId) -> EvalResult<'tcx, (DefId, ClosureSubsts<'tcx>, ClosureTy<'tcx>)> {\n-        debug!(\"reading closure fn ptr: {}\", id);\n-        match self.functions.get(&id) {\n-            Some(&FunctionDefinition {\n-                def_id,\n-                kind: FunctionKind::Closure { ref substs, ref ty }\n-            }) => Ok((def_id, *substs, ty.clone())),\n-            Some(&FunctionDefinition {\n-                kind: FunctionKind::Function { .. }, ..\n-            }) => Err(EvalError::CalledClosureAsFunction),\n-            None => match self.alloc_map.get(&id) {\n-                Some(_) => Err(EvalError::ExecuteMemory),\n-                None => Err(EvalError::InvalidFunctionPointer),\n-            }\n-        }\n-    }\n-\n-    pub fn get_fn(&self, id: AllocId) -> EvalResult<'tcx, (DefId, &'tcx Substs<'tcx>, &'tcx BareFnTy<'tcx>)> {\n+    pub fn get_fn(&self, id: AllocId) -> EvalResult<'tcx, (DefId, &'tcx Substs<'tcx>, Abi, &'tcx ty::FnSig<'tcx>)> {\n         debug!(\"reading fn ptr: {}\", id);\n         match self.functions.get(&id) {\n             Some(&FunctionDefinition {\n                 def_id,\n-                kind: FunctionKind::Function { substs, ty }\n-            }) => Ok((def_id, substs, ty)),\n-            Some(&FunctionDefinition {\n-                kind: FunctionKind::Closure { .. }, ..\n-            }) => Err(EvalError::CalledClosureAsFunction),\n+                substs,\n+                abi,\n+                sig,\n+            }) => Ok((def_id, substs, abi, sig)),\n             None => match self.alloc_map.get(&id) {\n                 Some(_) => Err(EvalError::ExecuteMemory),\n                 None => Err(EvalError::InvalidFunctionPointer),\n@@ -533,8 +515,8 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     }\n \n     pub fn write_primval(&mut self, dest: Pointer, val: PrimVal) -> EvalResult<'tcx, ()> {\n-        if let Some(ptr) = val.try_as_ptr() {\n-            return self.write_ptr(dest, ptr);\n+        if let Some(alloc_id) = val.relocation {\n+            return self.write_ptr(dest, Pointer::new(alloc_id, val.bits as usize));\n         }\n \n         use primval::PrimValKind::*;\n@@ -543,7 +525,8 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             I16 | U16              => (2, val.bits as u16 as u64),\n             I32 | U32 | F32 | Char => (4, val.bits as u32 as u64),\n             I64 | U64 | F64        => (8, val.bits),\n-            FnPtr | Ptr            => bug!(\"handled above\"),\n+            // int -> ptr transmutes are handled here\n+            FnPtr | Ptr            => return self.write_usize(dest, val.bits),\n         };\n \n         self.write_uint(dest, bits, size)\n@@ -570,7 +553,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             2 => Ok(self.layout.i16_align.abi() as usize),\n             4 => Ok(self.layout.i32_align.abi() as usize),\n             8 => Ok(self.layout.i64_align.abi() as usize),\n-            _ => bug!(\"bad integer size\"),\n+            _ => bug!(\"bad integer size: {}\", size),\n         }\n     }\n "}, {"sha": "15cc88ca4cf9ec53d3fb93fafb9b8462842349a2", "filename": "src/primval.rs", "status": "modified", "additions": 21, "deletions": 29, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/9322dec830ba56ab81e5c7a467441501df4680f6/src%2Fprimval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9322dec830ba56ab81e5c7a467441501df4680f6/src%2Fprimval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fprimval.rs?ref=9322dec830ba56ab81e5c7a467441501df4680f6", "patch": "@@ -137,15 +137,19 @@ impl PrimVal {\n         bits_to_f64(self.bits)\n     }\n \n-    pub fn try_as_ptr(self) -> Option<Pointer> {\n+    pub fn to_ptr(self) -> Pointer {\n         self.relocation.map(|alloc_id| {\n             Pointer::new(alloc_id, self.bits as usize)\n-        })\n+        }).unwrap_or_else(|| Pointer::from_int(self.bits as usize))\n+    }\n+\n+    pub fn try_as_uint<'tcx>(self) -> EvalResult<'tcx, u64> {\n+        self.to_ptr().to_int().map(|val| val as u64)\n     }\n \n     pub fn expect_uint(self, error_msg: &str) -> u64 {\n-        if let Some(ptr) = self.try_as_ptr() {\n-            return ptr.to_int().expect(\"non abstract ptr\") as u64\n+        if let Ok(int) = self.try_as_uint() {\n+            return int;\n         }\n \n         use self::PrimValKind::*;\n@@ -156,8 +160,8 @@ impl PrimVal {\n     }\n \n     pub fn expect_int(self, error_msg: &str) -> i64 {\n-        if let Some(ptr) = self.try_as_ptr() {\n-            return ptr.to_int().expect(\"non abstract ptr\") as i64\n+        if let Ok(int) = self.try_as_uint() {\n+            return int as i64;\n         }\n \n         use self::PrimValKind::*;\n@@ -188,15 +192,6 @@ impl PrimVal {\n             _ => bug!(\"{}\", error_msg),\n         }\n     }\n-\n-    pub fn expect_ptr(self, error_msg: &str) -> Pointer {\n-        self.try_as_ptr().expect(error_msg)\n-    }\n-\n-    /// FIXME(solson): Refactored into a duplicate of `expect_ptr`. Investigate removal.\n-    pub fn expect_fn_ptr(self, error_msg: &str) -> Pointer {\n-        self.try_as_ptr().expect(error_msg)\n-    }\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -277,19 +272,13 @@ pub fn binary_op<'tcx>(\n     use rustc::mir::BinOp::*;\n     use self::PrimValKind::*;\n \n-    match (left.try_as_ptr(), right.try_as_ptr()) {\n-        (Some(left_ptr), Some(right_ptr)) => {\n-            if left_ptr.alloc_id != right_ptr.alloc_id {\n-                return Ok((unrelated_ptr_ops(bin_op)?, false));\n-            }\n-\n-            // If the pointers are into the same allocation, fall through to the more general match\n-            // later, which will do comparisons on the `bits` fields, which are the pointer offsets\n-            // in this case.\n-        }\n-\n-        (None, None) => {}\n-        _ => return Err(EvalError::ReadPointerAsBytes),\n+    // If the pointers are into the same allocation, fall through to the more general match\n+    // later, which will do comparisons on the `bits` fields, which are the pointer offsets\n+    // in this case.\n+    let left_ptr = left.to_ptr();\n+    let right_ptr = right.to_ptr();\n+    if left_ptr.alloc_id != right_ptr.alloc_id {\n+        return Ok((unrelated_ptr_ops(bin_op, left_ptr, right_ptr)?, false));\n     }\n \n     let (l, r) = (left.bits, right.bits);\n@@ -376,12 +365,15 @@ pub fn binary_op<'tcx>(\n     Ok((val, false))\n }\n \n-fn unrelated_ptr_ops<'tcx>(bin_op: mir::BinOp) -> EvalResult<'tcx, PrimVal> {\n+fn unrelated_ptr_ops<'tcx>(bin_op: mir::BinOp, left: Pointer, right: Pointer) -> EvalResult<'tcx, PrimVal> {\n     use rustc::mir::BinOp::*;\n     match bin_op {\n         Eq => Ok(PrimVal::from_bool(false)),\n         Ne => Ok(PrimVal::from_bool(true)),\n         Lt | Le | Gt | Ge => Err(EvalError::InvalidPointerMath),\n+        _ if left.to_int().is_ok() ^ right.to_int().is_ok() => {\n+            Err(EvalError::ReadPointerAsBytes)\n+        },\n         _ => bug!(),\n     }\n }"}, {"sha": "030bed6a35298430e449ed7f5b79a4c7cbe4d68d", "filename": "tests/compile-fail/cast_box_int_to_fn_ptr.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9322dec830ba56ab81e5c7a467441501df4680f6/tests%2Fcompile-fail%2Fcast_box_int_to_fn_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9322dec830ba56ab81e5c7a467441501df4680f6/tests%2Fcompile-fail%2Fcast_box_int_to_fn_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcast_box_int_to_fn_ptr.rs?ref=9322dec830ba56ab81e5c7a467441501df4680f6", "patch": "@@ -0,0 +1,8 @@\n+fn main() {\n+    let b = Box::new(42);\n+    let g = unsafe {\n+        std::mem::transmute::<&usize, &fn(i32)>(&b)\n+    };\n+\n+    (*g)(42) //~ ERROR tried to use an integer pointer or a dangling pointer as a function pointer\n+}"}, {"sha": "c8070913f1cb5da88d3ba643275dffe6ac6813d3", "filename": "tests/compile-fail/cast_fn_ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9322dec830ba56ab81e5c7a467441501df4680f6/tests%2Fcompile-fail%2Fcast_fn_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9322dec830ba56ab81e5c7a467441501df4680f6/tests%2Fcompile-fail%2Fcast_fn_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcast_fn_ptr.rs?ref=9322dec830ba56ab81e5c7a467441501df4680f6", "patch": "@@ -5,5 +5,5 @@ fn main() {\n         std::mem::transmute::<fn(), fn(i32)>(f)\n     };\n \n-    g(42) //~ ERROR tried to call a function of type\n+    g(42) //~ ERROR tried to call a function with abi Rust and sig\n }"}, {"sha": "dc39f7dda1b638dac4136c1ba8fa2e82ff4f53ca", "filename": "tests/compile-fail/cast_int_to_fn_ptr.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9322dec830ba56ab81e5c7a467441501df4680f6/tests%2Fcompile-fail%2Fcast_int_to_fn_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9322dec830ba56ab81e5c7a467441501df4680f6/tests%2Fcompile-fail%2Fcast_int_to_fn_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcast_int_to_fn_ptr.rs?ref=9322dec830ba56ab81e5c7a467441501df4680f6", "patch": "@@ -0,0 +1,7 @@\n+fn main() {\n+    let g = unsafe {\n+        std::mem::transmute::<usize, fn(i32)>(42)\n+    };\n+\n+    g(42) //~ ERROR tried to use an integer pointer or a dangling pointer as a function pointer\n+}"}, {"sha": "025ec660d2e8fda284c9a455d79d72a85325b45c", "filename": "tests/compiletest.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9322dec830ba56ab81e5c7a467441501df4680f6/tests%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9322dec830ba56ab81e5c7a467441501df4680f6/tests%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompiletest.rs?ref=9322dec830ba56ab81e5c7a467441501df4680f6", "patch": "@@ -60,6 +60,8 @@ fn compile_test() {\n         let files: Box<Iterator<Item=_>> = if let Ok(path) = std::env::var(\"MIRI_RUSTC_TEST\") {\n             Box::new(files.chain(std::fs::read_dir(path).unwrap()))\n         } else {\n+            // print traces only when not running on the rust run-pass test suite (since tracing is slow)\n+            std::env::set_var(\"MIRI_LOG\", \"trace\");\n             Box::new(files)\n         };\n         let mut mir_not_found = 0;"}, {"sha": "e14f875c022e3fabd4a06ae5e1fd25551be267fe", "filename": "tests/run-pass/assume_bug.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9322dec830ba56ab81e5c7a467441501df4680f6/tests%2Frun-pass%2Fassume_bug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9322dec830ba56ab81e5c7a467441501df4680f6/tests%2Frun-pass%2Fassume_bug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fassume_bug.rs?ref=9322dec830ba56ab81e5c7a467441501df4680f6", "patch": "@@ -0,0 +1,3 @@\n+fn main() {\n+    vec![()].into_iter();\n+}"}, {"sha": "a03b96fa499fdbae3deb52e2f1125a4da39fbbd9", "filename": "tests/run-pass/binops.rs", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/9322dec830ba56ab81e5c7a467441501df4680f6/tests%2Frun-pass%2Fbinops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9322dec830ba56ab81e5c7a467441501df4680f6/tests%2Frun-pass%2Fbinops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fbinops.rs?ref=9322dec830ba56ab81e5c7a467441501df4680f6", "patch": "@@ -0,0 +1,91 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Binop corner cases\n+\n+fn test_nil() {\n+    assert_eq!((), ());\n+    assert!((!(() != ())));\n+    assert!((!(() < ())));\n+    assert!((() <= ()));\n+    assert!((!(() > ())));\n+    assert!((() >= ()));\n+}\n+\n+fn test_bool() {\n+    assert!((!(true < false)));\n+    assert!((!(true <= false)));\n+    assert!((true > false));\n+    assert!((true >= false));\n+\n+    assert!((false < true));\n+    assert!((false <= true));\n+    assert!((!(false > true)));\n+    assert!((!(false >= true)));\n+\n+    // Bools support bitwise binops\n+    assert_eq!(false & false, false);\n+    assert_eq!(true & false, false);\n+    assert_eq!(true & true, true);\n+    assert_eq!(false | false, false);\n+    assert_eq!(true | false, true);\n+    assert_eq!(true | true, true);\n+    assert_eq!(false ^ false, false);\n+    assert_eq!(true ^ false, true);\n+    assert_eq!(true ^ true, false);\n+}\n+\n+fn test_ptr() {\n+    unsafe {\n+        let p1: *const u8 = ::std::mem::transmute(0_usize);\n+        let p2: *const u8 = ::std::mem::transmute(0_usize);\n+        let p3: *const u8 = ::std::mem::transmute(1_usize);\n+\n+        assert_eq!(p1, p2);\n+        assert!(p1 != p3);\n+        assert!(p1 < p3);\n+        assert!(p1 <= p3);\n+        assert!(p3 > p1);\n+        assert!(p3 >= p3);\n+        assert!(p1 <= p2);\n+        assert!(p1 >= p2);\n+    }\n+}\n+\n+#[derive(PartialEq, Debug)]\n+struct P {\n+    x: isize,\n+    y: isize,\n+}\n+\n+fn p(x: isize, y: isize) -> P {\n+    P {\n+        x: x,\n+        y: y\n+    }\n+}\n+\n+fn test_class() {\n+  let q = p(1, 2);\n+  let mut r = p(1, 2);\n+\n+  assert_eq!(q, r);\n+  r.y = 17;\n+  assert!((r.y != q.y));\n+  assert_eq!(r.y, 17);\n+  assert!((q != r));\n+}\n+\n+pub fn main() {\n+    test_nil();\n+    test_bool();\n+    test_ptr();\n+    test_class();\n+}"}, {"sha": "1342c4e104de5bf01f16f6375a90dfe87068ac65", "filename": "tests/run-pass/enum-nullable-const-null-with-fields.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9322dec830ba56ab81e5c7a467441501df4680f6/tests%2Frun-pass%2Fenum-nullable-const-null-with-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9322dec830ba56ab81e5c7a467441501df4680f6/tests%2Frun-pass%2Fenum-nullable-const-null-with-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fenum-nullable-const-null-with-fields.rs?ref=9322dec830ba56ab81e5c7a467441501df4680f6", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+use std::result::Result;\n+use std::result::Result::Ok;\n+\n+static C: Result<(), Box<isize>> = Ok(());\n+\n+// This is because of yet another bad assertion (ICE) about the null side of a nullable enum.\n+// So we won't actually compile if the bug is present, but we check the value in main anyway.\n+\n+pub fn main() {\n+    assert!(C.is_ok());\n+}"}, {"sha": "d5139c908bdac2ea2b743c7e354c398a5c7ec399", "filename": "tests/run-pass/issue-30530.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/9322dec830ba56ab81e5c7a467441501df4680f6/tests%2Frun-pass%2Fissue-30530.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9322dec830ba56ab81e5c7a467441501df4680f6/tests%2Frun-pass%2Fissue-30530.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fissue-30530.rs?ref=9322dec830ba56ab81e5c7a467441501df4680f6", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for Issue #30530: alloca's created for storing\n+// intermediate scratch values during brace-less match arms need to be\n+// initialized with their drop-flag set to \"dropped\" (or else we end\n+// up running the destructors on garbage data at the end of the\n+// function).\n+\n+pub enum Handler {\n+    Default,\n+    #[allow(dead_code)]\n+    Custom(*mut Box<Fn()>),\n+}\n+\n+fn main() {\n+    take(Handler::Default, Box::new(main));\n+}\n+\n+#[inline(never)]\n+pub fn take(h: Handler, f: Box<Fn()>) -> Box<Fn()> {\n+    unsafe {\n+        match h {\n+            Handler::Custom(ptr) => *Box::from_raw(ptr),\n+            Handler::Default => f,\n+        }\n+    }\n+}"}, {"sha": "de2d815ca54ebe5de160bf28cde817197e4f5c54", "filename": "tests/run-pass/last-use-in-cap-clause.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9322dec830ba56ab81e5c7a467441501df4680f6/tests%2Frun-pass%2Flast-use-in-cap-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9322dec830ba56ab81e5c7a467441501df4680f6/tests%2Frun-pass%2Flast-use-in-cap-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Flast-use-in-cap-clause.rs?ref=9322dec830ba56ab81e5c7a467441501df4680f6", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Make sure #1399 stays fixed\n+\n+#[allow(dead_code)]\n+struct A { a: Box<isize> }\n+\n+fn foo() -> Box<FnMut() -> isize + 'static> {\n+    let k: Box<_> = Box::new(22);\n+    let _u = A {a: k.clone()};\n+    let result  = || 22;\n+    Box::new(result)\n+}\n+\n+pub fn main() {\n+    assert_eq!(foo()(), 22);\n+}"}, {"sha": "b3e07d00f010f0582b0d1647edc288f3e66b486e", "filename": "tests/run-pass/sendable-class.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/9322dec830ba56ab81e5c7a467441501df4680f6/tests%2Frun-pass%2Fsendable-class.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9322dec830ba56ab81e5c7a467441501df4680f6/tests%2Frun-pass%2Fsendable-class.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fsendable-class.rs?ref=9322dec830ba56ab81e5c7a467441501df4680f6", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that a class with only sendable fields can be sent\n+\n+// pretty-expanded FIXME #23616\n+\n+use std::sync::mpsc::channel;\n+\n+#[allow(dead_code)]\n+struct Foo {\n+    i: isize,\n+    j: char,\n+}\n+\n+fn foo(i:isize, j: char) -> Foo {\n+    Foo {\n+        i: i,\n+        j: j\n+    }\n+}\n+\n+pub fn main() {\n+    let (tx, rx) = channel();\n+    let _ = tx.send(foo(42, 'c'));\n+    let _ = rx;\n+}"}, {"sha": "36567f4c03310b287fc836c184272b4811080659", "filename": "tests/run-pass/simd-intrinsic-generic-elements.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9322dec830ba56ab81e5c7a467441501df4680f6/tests%2Frun-pass%2Fsimd-intrinsic-generic-elements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9322dec830ba56ab81e5c7a467441501df4680f6/tests%2Frun-pass%2Fsimd-intrinsic-generic-elements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fsimd-intrinsic-generic-elements.rs?ref=9322dec830ba56ab81e5c7a467441501df4680f6", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(repr_simd, platform_intrinsics)]\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+#[allow(non_camel_case_types)]\n+struct i32x2(i32, i32);\n+#[repr(simd)]\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+#[allow(non_camel_case_types)]\n+struct i32x3(i32, i32, i32);\n+#[repr(simd)]\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+#[allow(non_camel_case_types)]\n+struct i32x4(i32, i32, i32, i32);\n+#[repr(simd)]\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+#[allow(non_camel_case_types)]\n+struct i32x8(i32, i32, i32, i32,\n+             i32, i32, i32, i32);\n+\n+fn main() {\n+    let _x2 = i32x2(20, 21);\n+    let _x3 = i32x3(30, 31, 32);\n+    let _x4 = i32x4(40, 41, 42, 43);\n+    let _x8 = i32x8(80, 81, 82, 83, 84, 85, 86, 87);\n+\n+    let _y2 = i32x2(120, 121);\n+    let _y3 = i32x3(130, 131, 132);\n+    let _y4 = i32x4(140, 141, 142, 143);\n+    let _y8 = i32x8(180, 181, 182, 183, 184, 185, 186, 187);\n+\n+}"}, {"sha": "7576a97e36adf5715992b29a18b23754328654ee", "filename": "tests/run-pass/small_enum_size_bug.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9322dec830ba56ab81e5c7a467441501df4680f6/tests%2Frun-pass%2Fsmall_enum_size_bug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9322dec830ba56ab81e5c7a467441501df4680f6/tests%2Frun-pass%2Fsmall_enum_size_bug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fsmall_enum_size_bug.rs?ref=9322dec830ba56ab81e5c7a467441501df4680f6", "patch": "@@ -0,0 +1,14 @@\n+#![allow(dead_code)]\n+\n+enum E {\n+    A = 1,\n+    B = 2,\n+    C = 3,\n+}\n+\n+fn main() {\n+    let enone = None::<E>;\n+    if let Some(..) = enone {\n+        panic!();\n+    }\n+}"}, {"sha": "7644da08e4afa7cf144dbbb3a5b0142f687ac5c7", "filename": "tests/run-pass/unique-send.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9322dec830ba56ab81e5c7a467441501df4680f6/tests%2Frun-pass%2Funique-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9322dec830ba56ab81e5c7a467441501df4680f6/tests%2Frun-pass%2Funique-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Funique-send.rs?ref=9322dec830ba56ab81e5c7a467441501df4680f6", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(box_syntax)]\n+\n+use std::sync::mpsc::channel;\n+\n+pub fn main() {\n+    let (tx, rx) = channel::<Box<_>>();\n+    tx.send(box 100).unwrap();\n+    let v = rx.recv().unwrap();\n+    assert_eq!(v, box 100);\n+}"}]}