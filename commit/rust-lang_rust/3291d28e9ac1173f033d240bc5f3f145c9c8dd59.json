{"sha": "3291d28e9ac1173f033d240bc5f3f145c9c8dd59", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyOTFkMjhlOWFjMTE3M2YwMzNkMjQwYmM1ZjNmMTQ1YzljOGRkNTk=", "commit": {"author": {"name": "Rich Kadel", "email": "richkadel@google.com", "date": "2020-10-23T03:28:16Z"}, "committer": {"name": "Rich Kadel", "email": "richkadel@google.com", "date": "2020-11-06T02:24:14Z"}, "message": "Adds coverage graphviz", "tree": {"sha": "9434df1af15a71dec68b47ed307e07a0d40efebb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9434df1af15a71dec68b47ed307e07a0d40efebb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3291d28e9ac1173f033d240bc5f3f145c9c8dd59", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3291d28e9ac1173f033d240bc5f3f145c9c8dd59", "html_url": "https://github.com/rust-lang/rust/commit/3291d28e9ac1173f033d240bc5f3f145c9c8dd59", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3291d28e9ac1173f033d240bc5f3f145c9c8dd59/comments", "author": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "committer": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5020648fe294a1f139586e4243903d8c1a105b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5020648fe294a1f139586e4243903d8c1a105b8", "html_url": "https://github.com/rust-lang/rust/commit/b5020648fe294a1f139586e4243903d8c1a105b8"}], "stats": {"total": 667, "additions": 657, "deletions": 10}, "files": [{"sha": "c31f401780e10d788b544baaeb9d54940203f5b5", "filename": "compiler/rustc_mir/src/transform/coverage/counters.rs", "status": "modified", "additions": 32, "deletions": 5, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/3291d28e9ac1173f033d240bc5f3f145c9c8dd59/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fcounters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3291d28e9ac1173f033d240bc5f3f145c9c8dd59/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fcounters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fcounters.rs?ref=3291d28e9ac1173f033d240bc5f3f145c9c8dd59", "patch": "@@ -1,3 +1,7 @@\n+use super::debug;\n+\n+use debug::DebugCounters;\n+\n use rustc_middle::mir::coverage::*;\n \n /// Manages the counter and expression indexes/IDs to generate `CoverageKind` components for MIR\n@@ -6,6 +10,7 @@ pub(crate) struct CoverageCounters {\n     function_source_hash: u64,\n     next_counter_id: u32,\n     num_expressions: u32,\n+    pub debug_counters: DebugCounters,\n }\n \n impl CoverageCounters {\n@@ -14,24 +19,46 @@ impl CoverageCounters {\n             function_source_hash,\n             next_counter_id: CounterValueReference::START.as_u32(),\n             num_expressions: 0,\n+            debug_counters: DebugCounters::new(),\n         }\n     }\n \n-    pub fn make_counter(&mut self) -> CoverageKind {\n-        CoverageKind::Counter {\n+    /// Activate the `DebugCounters` data structures, to provide additional debug formatting\n+    /// features when formating `CoverageKind` (counter) values.\n+    pub fn enable_debug(&mut self) {\n+        self.debug_counters.enable();\n+    }\n+\n+    pub fn make_counter<F>(&mut self, debug_block_label_fn: F) -> CoverageKind\n+    where\n+        F: Fn() -> Option<String>,\n+    {\n+        let counter = CoverageKind::Counter {\n             function_source_hash: self.function_source_hash,\n             id: self.next_counter(),\n+        };\n+        if self.debug_counters.is_enabled() {\n+            self.debug_counters.add_counter(&counter, (debug_block_label_fn)());\n         }\n+        counter\n     }\n \n-    pub fn make_expression(\n+    pub fn make_expression<F>(\n         &mut self,\n         lhs: ExpressionOperandId,\n         op: Op,\n         rhs: ExpressionOperandId,\n-    ) -> CoverageKind {\n+        debug_block_label_fn: F,\n+    ) -> CoverageKind\n+    where\n+        F: Fn() -> Option<String>,\n+    {\n         let id = self.next_expression();\n-        CoverageKind::Expression { id, lhs, op, rhs }\n+        let expression = CoverageKind::Expression { id, lhs, op, rhs };\n+        if self.debug_counters.is_enabled() {\n+            self.debug_counters.add_counter(&expression, (debug_block_label_fn)());\n+        }\n+        expression\n     }\n \n     /// Counter IDs start from one and go up."}, {"sha": "fbf2ad224a8219d95f51e4d32bd3a576808e722e", "filename": "compiler/rustc_mir/src/transform/coverage/debug.rs", "status": "modified", "additions": 363, "deletions": 2, "changes": 365, "blob_url": "https://github.com/rust-lang/rust/blob/3291d28e9ac1173f033d240bc5f3f145c9c8dd59/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3291d28e9ac1173f033d240bc5f3f145c9c8dd59/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fdebug.rs?ref=3291d28e9ac1173f033d240bc5f3f145c9c8dd59", "patch": "@@ -1,12 +1,294 @@\n-use super::graph::CoverageGraph;\n+use super::graph::{BasicCoverageBlock, BasicCoverageBlockData, CoverageGraph};\n use super::spans::CoverageSpan;\n \n+use crate::util::generic_graphviz::GraphvizWriter;\n use crate::util::pretty;\n use crate::util::spanview::{self, SpanViewable};\n \n-use rustc_middle::mir::{self, TerminatorKind};\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_index::vec::Idx;\n+use rustc_middle::mir::coverage::*;\n+use rustc_middle::mir::{self, BasicBlock, TerminatorKind};\n use rustc_middle::ty::TyCtxt;\n \n+use std::lazy::SyncOnceCell;\n+\n+const RUSTC_COVERAGE_DEBUG_OPTIONS: &str = \"RUSTC_COVERAGE_DEBUG_OPTIONS\";\n+\n+pub(crate) fn debug_options<'a>() -> &'a DebugOptions {\n+    static DEBUG_OPTIONS: SyncOnceCell<DebugOptions> = SyncOnceCell::new();\n+\n+    &DEBUG_OPTIONS.get_or_init(|| DebugOptions::new())\n+}\n+\n+/// Parses and maintains coverage-specific debug options captured from the environment variable\n+/// \"RUSTC_COVERAGE_DEBUG_OPTIONS\", if set. Options can be set on the command line by, for example:\n+///\n+///     $ RUSTC_COVERAGE_DEBUG_OPTIONS=counter-format=block cargo build\n+#[derive(Debug, Clone)]\n+pub(crate) struct DebugOptions {\n+    counter_format: ExpressionFormat,\n+}\n+\n+impl DebugOptions {\n+    fn new() -> Self {\n+        let mut counter_format = ExpressionFormat::default();\n+\n+        if let Ok(env_debug_options) = std::env::var(RUSTC_COVERAGE_DEBUG_OPTIONS) {\n+            for setting_str in env_debug_options.replace(\" \", \"\").replace(\"-\", \"_\").split(\",\") {\n+                let mut setting = setting_str.splitn(2, \"=\");\n+                match setting.next() {\n+                    Some(option) if option == \"counter_format\" => {\n+                        if let Some(strval) = setting.next() {\n+                            counter_format = counter_format_option_val(strval);\n+                            debug!(\n+                                \"{} env option `counter_format` is set to {:?}\",\n+                                RUSTC_COVERAGE_DEBUG_OPTIONS, counter_format\n+                            );\n+                        } else {\n+                            bug!(\n+                                \"`{}` option in environment variable {} requires one or more \\\n+                                plus-separated choices (a non-empty subset of \\\n+                                `id+block+operation`)\",\n+                                option,\n+                                RUSTC_COVERAGE_DEBUG_OPTIONS\n+                            );\n+                        }\n+                    }\n+                    Some(\"\") => {}\n+                    Some(invalid) => bug!(\n+                        \"Unsupported setting `{}` in environment variable {}\",\n+                        invalid,\n+                        RUSTC_COVERAGE_DEBUG_OPTIONS\n+                    ),\n+                    None => {}\n+                }\n+            }\n+        }\n+\n+        Self { counter_format }\n+    }\n+}\n+\n+fn counter_format_option_val(strval: &str) -> ExpressionFormat {\n+    let mut counter_format = ExpressionFormat { id: false, block: false, operation: false };\n+    let components = strval.splitn(3, \"+\");\n+    for component in components {\n+        match component {\n+            \"id\" => counter_format.id = true,\n+            \"block\" => counter_format.block = true,\n+            \"operation\" => counter_format.operation = true,\n+            _ => bug!(\n+                \"Unsupported counter_format choice `{}` in environment variable {}\",\n+                component,\n+                RUSTC_COVERAGE_DEBUG_OPTIONS\n+            ),\n+        }\n+    }\n+    counter_format\n+}\n+\n+#[derive(Debug, Clone)]\n+struct ExpressionFormat {\n+    id: bool,\n+    block: bool,\n+    operation: bool,\n+}\n+\n+impl Default for ExpressionFormat {\n+    fn default() -> Self {\n+        Self { id: false, block: true, operation: true }\n+    }\n+}\n+\n+/// If enabled, this struct maintains a map from `CoverageKind` IDs (as `ExpressionOperandId`) to\n+/// the `CoverageKind` data and optional label (normally, the counter's associated\n+/// `BasicCoverageBlock` format string, if any).\n+///\n+/// Use `format_counter` to convert one of these `CoverageKind` counters to a debug output string,\n+/// as directed by the `DebugOptions`. This allows the format of counter labels in logs and dump\n+/// files (including the `CoverageGraph` graphviz file) to be changed at runtime, via environment\n+/// variable.\n+///\n+/// `DebugCounters` supports a recursive rendering of `Expression` counters, so they can be\n+/// presented as nested expressions such as `(bcb3 - (bcb0 + bcb1))`.\n+pub(crate) struct DebugCounters {\n+    some_counters: Option<FxHashMap<ExpressionOperandId, DebugCounter>>,\n+}\n+\n+impl DebugCounters {\n+    pub fn new() -> Self {\n+        Self { some_counters: None }\n+    }\n+\n+    pub fn enable(&mut self) {\n+        self.some_counters.replace(FxHashMap::default());\n+    }\n+\n+    pub fn is_enabled(&mut self) -> bool {\n+        self.some_counters.is_some()\n+    }\n+\n+    pub fn add_counter(&mut self, counter_kind: &CoverageKind, some_block_label: Option<String>) {\n+        if let Some(counters) = &mut self.some_counters {\n+            let id: ExpressionOperandId = match *counter_kind {\n+                CoverageKind::Counter { id, .. } => id.into(),\n+                CoverageKind::Expression { id, .. } => id.into(),\n+                _ => bug!(\n+                    \"the given `CoverageKind` is not an counter or expression: {:?}\",\n+                    counter_kind\n+                ),\n+            };\n+            counters\n+                .insert(id.into(), DebugCounter::new(counter_kind.clone(), some_block_label))\n+                .expect_none(\n+                    \"attempt to add the same counter_kind to DebugCounters more than once\",\n+                );\n+        }\n+    }\n+\n+    pub fn format_counter(&self, counter_kind: &CoverageKind) -> String {\n+        match *counter_kind {\n+            CoverageKind::Counter { .. } => {\n+                format!(\"Counter({})\", self.format_counter_kind(counter_kind))\n+            }\n+            CoverageKind::Expression { .. } => {\n+                format!(\"Expression({})\", self.format_counter_kind(counter_kind))\n+            }\n+            CoverageKind::Unreachable { .. } => \"Unreachable\".to_owned(),\n+        }\n+    }\n+\n+    fn format_counter_kind(&self, counter_kind: &CoverageKind) -> String {\n+        let counter_format = &debug_options().counter_format;\n+        if let CoverageKind::Expression { id, lhs, op, rhs } = *counter_kind {\n+            if counter_format.operation {\n+                return format!(\n+                    \"{}{} {} {}\",\n+                    if counter_format.id || self.some_counters.is_none() {\n+                        format!(\"#{} = \", id.index())\n+                    } else {\n+                        String::new()\n+                    },\n+                    self.format_operand(lhs),\n+                    if op == Op::Add { \"+\" } else { \"-\" },\n+                    self.format_operand(rhs),\n+                );\n+            }\n+        }\n+\n+        let id: ExpressionOperandId = match *counter_kind {\n+            CoverageKind::Counter { id, .. } => id.into(),\n+            CoverageKind::Expression { id, .. } => id.into(),\n+            _ => {\n+                bug!(\"the given `CoverageKind` is not an counter or expression: {:?}\", counter_kind)\n+            }\n+        };\n+        if self.some_counters.is_some() && (counter_format.block || !counter_format.id) {\n+            let counters = self.some_counters.as_ref().unwrap();\n+            if let Some(DebugCounter { some_block_label: Some(block_label), .. }) =\n+                counters.get(&id.into())\n+            {\n+                return if counter_format.id {\n+                    format!(\"{}#{}\", block_label, id.index())\n+                } else {\n+                    format!(\"{}\", block_label)\n+                };\n+            }\n+        }\n+        format!(\"#{}\", id.index())\n+    }\n+\n+    fn format_operand(&self, operand: ExpressionOperandId) -> String {\n+        if operand.index() == 0 {\n+            return String::from(\"0\");\n+        }\n+        if let Some(counters) = &self.some_counters {\n+            if let Some(DebugCounter { counter_kind, some_block_label }) = counters.get(&operand) {\n+                if let CoverageKind::Expression { .. } = counter_kind {\n+                    if let Some(block_label) = some_block_label {\n+                        if debug_options().counter_format.block {\n+                            return format!(\n+                                \"{}:({})\",\n+                                block_label,\n+                                self.format_counter_kind(counter_kind)\n+                            );\n+                        }\n+                    }\n+                    return format!(\"({})\", self.format_counter_kind(counter_kind));\n+                }\n+                return format!(\"{}\", self.format_counter_kind(counter_kind));\n+            }\n+        }\n+        format!(\"#{}\", operand.index().to_string())\n+    }\n+}\n+\n+/// A non-public support class to `DebugCounters`.\n+#[derive(Debug)]\n+struct DebugCounter {\n+    counter_kind: CoverageKind,\n+    some_block_label: Option<String>,\n+}\n+\n+impl DebugCounter {\n+    fn new(counter_kind: CoverageKind, some_block_label: Option<String>) -> Self {\n+        Self { counter_kind, some_block_label }\n+    }\n+}\n+\n+/// If enabled, this data structure captures additional debugging information used when generating\n+/// a Graphviz (.dot file) representation of the `CoverageGraph`, for debugging purposes.\n+pub(crate) struct GraphvizData {\n+    some_bcb_to_coverage_spans_with_counters:\n+        Option<FxHashMap<BasicCoverageBlock, Vec<(CoverageSpan, CoverageKind)>>>,\n+    some_edge_to_counter: Option<FxHashMap<(BasicCoverageBlock, BasicBlock), CoverageKind>>,\n+}\n+\n+impl GraphvizData {\n+    pub fn new() -> Self {\n+        Self { some_bcb_to_coverage_spans_with_counters: None, some_edge_to_counter: None }\n+    }\n+\n+    pub fn enable(&mut self) {\n+        self.some_bcb_to_coverage_spans_with_counters = Some(FxHashMap::default());\n+        self.some_edge_to_counter = Some(FxHashMap::default());\n+    }\n+\n+    pub fn is_enabled(&mut self) -> bool {\n+        self.some_bcb_to_coverage_spans_with_counters.is_some()\n+    }\n+\n+    pub fn add_bcb_coverage_span_with_counter(\n+        &mut self,\n+        bcb: BasicCoverageBlock,\n+        coverage_span: &CoverageSpan,\n+        counter_kind: &CoverageKind,\n+    ) {\n+        if let Some(bcb_to_coverage_spans_with_counters) =\n+            self.some_bcb_to_coverage_spans_with_counters.as_mut()\n+        {\n+            bcb_to_coverage_spans_with_counters\n+                .entry(bcb)\n+                .or_insert_with(|| Vec::new())\n+                .push((coverage_span.clone(), counter_kind.clone()));\n+        }\n+    }\n+\n+    pub fn get_bcb_coverage_spans_with_counters(\n+        &self,\n+        bcb: BasicCoverageBlock,\n+    ) -> Option<&Vec<(CoverageSpan, CoverageKind)>> {\n+        if let Some(bcb_to_coverage_spans_with_counters) =\n+            self.some_bcb_to_coverage_spans_with_counters.as_ref()\n+        {\n+            bcb_to_coverage_spans_with_counters.get(&bcb)\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n /// Generates the MIR pass `CoverageSpan`-specific spanview dump file.\n pub(crate) fn dump_coverage_spanview(\n     tcx: TyCtxt<'tcx>,\n@@ -47,6 +329,85 @@ fn span_viewables(\n     span_viewables\n }\n \n+/// Generates the MIR pass coverage-specific graphviz dump file.\n+pub(crate) fn dump_coverage_graphviz(\n+    tcx: TyCtxt<'tcx>,\n+    mir_body: &mir::Body<'tcx>,\n+    pass_name: &str,\n+    basic_coverage_blocks: &CoverageGraph,\n+    debug_counters: &DebugCounters,\n+    graphviz_data: &GraphvizData,\n+) {\n+    let mir_source = mir_body.source;\n+    let def_id = mir_source.def_id();\n+    let node_content = |bcb| {\n+        bcb_to_string_sections(\n+            tcx,\n+            mir_body,\n+            debug_counters,\n+            &basic_coverage_blocks[bcb],\n+            graphviz_data.get_bcb_coverage_spans_with_counters(bcb),\n+        )\n+    };\n+    let edge_labels = |from_bcb| {\n+        let from_bcb_data = &basic_coverage_blocks[from_bcb];\n+        let from_terminator = from_bcb_data.terminator(mir_body);\n+        from_terminator\n+            .kind\n+            .fmt_successor_labels()\n+            .iter()\n+            .map(|label| label.to_string())\n+            .collect::<Vec<_>>()\n+    };\n+    let graphviz_name = format!(\"Cov_{}_{}\", def_id.krate.index(), def_id.index.index());\n+    let graphviz_writer =\n+        GraphvizWriter::new(basic_coverage_blocks, &graphviz_name, node_content, edge_labels);\n+    let mut file = pretty::create_dump_file(tcx, \"dot\", None, pass_name, &0, mir_source)\n+        .expect(\"Unexpected error creating BasicCoverageBlock graphviz DOT file\");\n+    graphviz_writer\n+        .write_graphviz(tcx, &mut file)\n+        .expect(\"Unexpected error writing BasicCoverageBlock graphviz DOT file\");\n+}\n+\n+fn bcb_to_string_sections(\n+    tcx: TyCtxt<'tcx>,\n+    mir_body: &mir::Body<'tcx>,\n+    debug_counters: &DebugCounters,\n+    bcb_data: &BasicCoverageBlockData,\n+    some_coverage_spans_with_counters: Option<&Vec<(CoverageSpan, CoverageKind)>>,\n+) -> Vec<String> {\n+    let len = bcb_data.basic_blocks.len();\n+    let mut sections = Vec::new();\n+    if let Some(coverage_spans_with_counters) = some_coverage_spans_with_counters {\n+        sections.push(\n+            coverage_spans_with_counters\n+                .iter()\n+                .map(|(covspan, counter)| {\n+                    format!(\n+                        \"{} at {}\",\n+                        debug_counters.format_counter(counter),\n+                        covspan.format(tcx, mir_body)\n+                    )\n+                })\n+                .collect::<Vec<_>>()\n+                .join(\"\\n\"),\n+        );\n+    }\n+    let non_term_blocks = bcb_data.basic_blocks[0..len - 1]\n+        .iter()\n+        .map(|&bb| format!(\"{:?}: {}\", bb, term_type(&mir_body[bb].terminator().kind)))\n+        .collect::<Vec<_>>();\n+    if non_term_blocks.len() > 0 {\n+        sections.push(non_term_blocks.join(\"\\n\"));\n+    }\n+    sections.push(format!(\n+        \"{:?}: {}\",\n+        bcb_data.basic_blocks.last().unwrap(),\n+        term_type(&bcb_data.terminator(mir_body).kind)\n+    ));\n+    sections\n+}\n+\n /// Returns a simple string representation of a `TerminatorKind` variant, indenpendent of any\n /// values it might hold.\n pub(crate) fn term_type(kind: &TerminatorKind<'tcx>) -> &'static str {"}, {"sha": "d1d94092c9defb90a829a0d45cf5870f2369519e", "filename": "compiler/rustc_mir/src/transform/coverage/mod.rs", "status": "modified", "additions": 31, "deletions": 3, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3291d28e9ac1173f033d240bc5f3f145c9c8dd59/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3291d28e9ac1173f033d240bc5f3f145c9c8dd59/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fmod.rs?ref=3291d28e9ac1173f033d240bc5f3f145c9c8dd59", "patch": "@@ -103,6 +103,14 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n \n         debug!(\"instrumenting {:?}, span: {}\", def_id, source_map.span_to_string(body_span));\n \n+        let mut graphviz_data = debug::GraphvizData::new();\n+\n+        let dump_graphviz = tcx.sess.opts.debugging_opts.dump_mir_graphviz;\n+        if dump_graphviz {\n+            graphviz_data.enable();\n+            self.coverage_counters.enable_debug();\n+        }\n+\n         ////////////////////////////////////////////////////\n         // Compute `CoverageSpan`s from the `CoverageGraph`.\n         let coverage_spans = CoverageSpans::generate_coverage_spans(\n@@ -121,15 +129,32 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n             );\n         }\n \n-        self.inject_coverage_span_counters(coverage_spans);\n+        self.inject_coverage_span_counters(coverage_spans, &mut graphviz_data);\n+\n+        if graphviz_data.is_enabled() {\n+            // Even if there was an error, a partial CoverageGraph can still generate a useful\n+            // graphviz output.\n+            debug::dump_coverage_graphviz(\n+                tcx,\n+                self.mir_body,\n+                self.pass_name,\n+                &self.basic_coverage_blocks,\n+                &self.coverage_counters.debug_counters,\n+                &graphviz_data,\n+            );\n+        }\n     }\n \n     /// Inject a counter for each `CoverageSpan`. There can be multiple `CoverageSpan`s for a given\n     /// BCB, but only one actual counter needs to be incremented per BCB. `bcb_counters` maps each\n     /// `bcb` to its `Counter`, when injected. Subsequent `CoverageSpan`s for a BCB that already has\n     /// a `Counter` will inject an `Expression` instead, and compute its value by adding `ZERO` to\n     /// the BCB `Counter` value.\n-    fn inject_coverage_span_counters(&mut self, coverage_spans: Vec<CoverageSpan>) {\n+    fn inject_coverage_span_counters(\n+        &mut self,\n+        coverage_spans: Vec<CoverageSpan>,\n+        graphviz_data: &mut debug::GraphvizData,\n+    ) {\n         let tcx = self.tcx;\n         let source_map = tcx.sess.source_map();\n         let body_span = self.body_span;\n@@ -145,18 +170,20 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n                     counter_operand,\n                     Op::Add,\n                     ExpressionOperandId::ZERO,\n+                    || Some(format!(\"{:?}\", bcb)),\n                 );\n                 debug!(\n                     \"Injecting counter expression {:?} at: {:?}:\\n{}\\n==========\",\n                     expression,\n                     span,\n                     source_map.span_to_snippet(span).expect(\"Error getting source for span\"),\n                 );\n+                graphviz_data.add_bcb_coverage_span_with_counter(bcb, &covspan, &expression);\n                 let bb = self.basic_coverage_blocks[bcb].leader_bb();\n                 let code_region = make_code_region(file_name, &source_file, span, body_span);\n                 inject_statement(self.mir_body, expression, bb, Some(code_region));\n             } else {\n-                let counter = self.coverage_counters.make_counter();\n+                let counter = self.coverage_counters.make_counter(|| Some(format!(\"{:?}\", bcb)));\n                 debug!(\n                     \"Injecting counter {:?} at: {:?}:\\n{}\\n==========\",\n                     counter,\n@@ -165,6 +192,7 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n                 );\n                 let counter_operand = counter.as_operand_id();\n                 bcb_counters[bcb] = Some(counter_operand);\n+                graphviz_data.add_bcb_coverage_span_with_counter(bcb, &covspan, &counter);\n                 let bb = self.basic_coverage_blocks[bcb].leader_bb();\n                 let code_region = make_code_region(file_name, &source_file, span, body_span);\n                 inject_statement(self.mir_body, counter, bb, Some(code_region));"}, {"sha": "61b5b1480532a7f7f9a354ab505541909c7ebaaf", "filename": "compiler/rustc_mir/src/transform/coverage/spans.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3291d28e9ac1173f033d240bc5f3f145c9c8dd59/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fspans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3291d28e9ac1173f033d240bc5f3f145c9c8dd59/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fspans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fspans.rs?ref=3291d28e9ac1173f033d240bc5f3f145c9c8dd59", "patch": "@@ -134,6 +134,14 @@ impl CoverageSpan {\n         self.bcb == other.bcb\n     }\n \n+    pub fn format(&self, tcx: TyCtxt<'tcx>, mir_body: &'a mir::Body<'tcx>) -> String {\n+        format!(\n+            \"{}\\n    {}\",\n+            source_range_no_file(tcx, &self.span),\n+            self.format_coverage_statements(tcx, mir_body).replace(\"\\n\", \"\\n    \"),\n+        )\n+    }\n+\n     pub fn format_coverage_statements(\n         &self,\n         tcx: TyCtxt<'tcx>,"}, {"sha": "91499bb61c287c81b512bd8c73e906aac89cabf7", "filename": "compiler/rustc_mir/src/util/generic_graphviz.rs", "status": "added", "additions": 185, "deletions": 0, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/3291d28e9ac1173f033d240bc5f3f145c9c8dd59/compiler%2Frustc_mir%2Fsrc%2Futil%2Fgeneric_graphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3291d28e9ac1173f033d240bc5f3f145c9c8dd59/compiler%2Frustc_mir%2Fsrc%2Futil%2Fgeneric_graphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Futil%2Fgeneric_graphviz.rs?ref=3291d28e9ac1173f033d240bc5f3f145c9c8dd59", "patch": "@@ -0,0 +1,185 @@\n+use rustc_data_structures::graph::{self, iterate};\n+use rustc_graphviz as dot;\n+use rustc_middle::ty::TyCtxt;\n+use std::io::{self, Write};\n+\n+pub struct GraphvizWriter<\n+    'a,\n+    G: graph::DirectedGraph + graph::WithSuccessors + graph::WithStartNode + graph::WithNumNodes,\n+    NodeContentFn: Fn(<G as rustc_data_structures::graph::DirectedGraph>::Node) -> Vec<String>,\n+    EdgeLabelsFn: Fn(<G as rustc_data_structures::graph::DirectedGraph>::Node) -> Vec<String>,\n+> {\n+    graph: &'a G,\n+    is_subgraph: bool,\n+    graphviz_name: String,\n+    graph_label: Option<String>,\n+    node_content_fn: NodeContentFn,\n+    edge_labels_fn: EdgeLabelsFn,\n+}\n+\n+impl<\n+    'a,\n+    G: graph::DirectedGraph + graph::WithSuccessors + graph::WithStartNode + graph::WithNumNodes,\n+    NodeContentFn: Fn(<G as rustc_data_structures::graph::DirectedGraph>::Node) -> Vec<String>,\n+    EdgeLabelsFn: Fn(<G as rustc_data_structures::graph::DirectedGraph>::Node) -> Vec<String>,\n+> GraphvizWriter<'a, G, NodeContentFn, EdgeLabelsFn>\n+{\n+    pub fn new(\n+        graph: &'a G,\n+        graphviz_name: &str,\n+        node_content_fn: NodeContentFn,\n+        edge_labels_fn: EdgeLabelsFn,\n+    ) -> Self {\n+        Self {\n+            graph,\n+            is_subgraph: false,\n+            graphviz_name: graphviz_name.to_owned(),\n+            graph_label: None,\n+            node_content_fn,\n+            edge_labels_fn,\n+        }\n+    }\n+\n+    pub fn new_subgraph(\n+        graph: &'a G,\n+        graphviz_name: &str,\n+        node_content_fn: NodeContentFn,\n+        edge_labels_fn: EdgeLabelsFn,\n+    ) -> Self {\n+        Self {\n+            graph,\n+            is_subgraph: true,\n+            graphviz_name: graphviz_name.to_owned(),\n+            graph_label: None,\n+            node_content_fn,\n+            edge_labels_fn,\n+        }\n+    }\n+\n+    pub fn set_graph_label(&mut self, graph_label: &str) {\n+        self.graph_label = Some(graph_label.to_owned());\n+    }\n+\n+    /// Write a graphviz DOT of the graph\n+    pub fn write_graphviz<'tcx, W>(&self, tcx: TyCtxt<'tcx>, w: &mut W) -> io::Result<()>\n+    where\n+        W: Write,\n+    {\n+        let kind = if self.is_subgraph { \"subgraph\" } else { \"digraph\" };\n+        let cluster = if self.is_subgraph { \"cluster_\" } else { \"\" }; // Print border around graph\n+        // FIXME(richkadel): If/when migrating the MIR graphviz to this generic implementation,\n+        // prepend \"Mir_\" to the graphviz_safe_def_name(def_id)\n+        writeln!(w, \"{} {}{} {{\", kind, cluster, self.graphviz_name)?;\n+\n+        // Global graph properties\n+        let font = format!(r#\"fontname=\"{}\"\"#, tcx.sess.opts.debugging_opts.graphviz_font);\n+        let mut graph_attrs = vec![&font[..]];\n+        let mut content_attrs = vec![&font[..]];\n+\n+        let dark_mode = tcx.sess.opts.debugging_opts.graphviz_dark_mode;\n+        if dark_mode {\n+            graph_attrs.push(r#\"bgcolor=\"black\"\"#);\n+            graph_attrs.push(r#\"fontcolor=\"white\"\"#);\n+            content_attrs.push(r#\"color=\"white\"\"#);\n+            content_attrs.push(r#\"fontcolor=\"white\"\"#);\n+        }\n+\n+        writeln!(w, r#\"    graph [{}];\"#, graph_attrs.join(\" \"))?;\n+        let content_attrs_str = content_attrs.join(\" \");\n+        writeln!(w, r#\"    node [{}];\"#, content_attrs_str)?;\n+        writeln!(w, r#\"    edge [{}];\"#, content_attrs_str)?;\n+\n+        // Graph label\n+        if let Some(graph_label) = &self.graph_label {\n+            self.write_graph_label(graph_label, w)?;\n+        }\n+\n+        // Nodes\n+        for node in iterate::post_order_from(self.graph, self.graph.start_node()) {\n+            self.write_node(node, dark_mode, w)?;\n+        }\n+\n+        // Edges\n+        for source in iterate::post_order_from(self.graph, self.graph.start_node()) {\n+            self.write_edges(source, w)?;\n+        }\n+        writeln!(w, \"}}\")\n+    }\n+\n+    /// Write a graphviz DOT node for the given node.\n+    pub fn write_node<W>(&self, node: G::Node, dark_mode: bool, w: &mut W) -> io::Result<()>\n+    where\n+        W: Write,\n+    {\n+        // Start a new node with the label to follow, in one of DOT's pseudo-HTML tables.\n+        write!(w, r#\"    {} [shape=\"none\", label=<\"#, self.node(node))?;\n+\n+        write!(w, r#\"<table border=\"0\" cellborder=\"1\" cellspacing=\"0\">\"#)?;\n+\n+        // FIXME(richkadel): Need generic way to know if node header should have a different color\n+        // let (blk, bgcolor) = if data.is_cleanup {\n+        //    (format!(\"{:?} (cleanup)\", node), \"lightblue\")\n+        // } else {\n+        //     let color = if dark_mode { \"dimgray\" } else { \"gray\" };\n+        //     (format!(\"{:?}\", node), color)\n+        // };\n+        let color = if dark_mode { \"dimgray\" } else { \"gray\" };\n+        let (blk, bgcolor) = (format!(\"{:?}\", node), color);\n+        write!(\n+            w,\n+            r#\"<tr><td bgcolor=\"{bgcolor}\" {attrs} colspan=\"{colspan}\">{blk}</td></tr>\"#,\n+            attrs = r#\"align=\"center\"\"#,\n+            colspan = 1,\n+            blk = blk,\n+            bgcolor = bgcolor\n+        )?;\n+\n+        for section in (self.node_content_fn)(node) {\n+            write!(\n+                w,\n+                r#\"<tr><td align=\"left\" balign=\"left\">{}</td></tr>\"#,\n+                dot::escape_html(&section).replace(\"\\n\", \"<br/>\")\n+            )?;\n+        }\n+\n+        // Close the table\n+        write!(w, \"</table>\")?;\n+\n+        // Close the node label and the node itself.\n+        writeln!(w, \">];\")\n+    }\n+\n+    /// Write graphviz DOT edges with labels between the given node and all of its successors.\n+    fn write_edges<W>(&self, source: G::Node, w: &mut W) -> io::Result<()>\n+    where\n+        W: Write,\n+    {\n+        let edge_labels = (self.edge_labels_fn)(source);\n+        for (index, target) in self.graph.successors(source).enumerate() {\n+            let src = self.node(source);\n+            let trg = self.node(target);\n+            let escaped_edge_label = if let Some(edge_label) = edge_labels.get(index) {\n+                dot::escape_html(edge_label).replace(\"\\n\", r#\"<br align=\"left\"/>\"#)\n+            } else {\n+                \"\".to_owned()\n+            };\n+            writeln!(w, r#\"    {} -> {} [label=<{}>];\"#, src, trg, escaped_edge_label)?;\n+        }\n+        Ok(())\n+    }\n+\n+    /// Write the graphviz DOT label for the overall graph. This is essentially a block of text that\n+    /// will appear below the graph.\n+    fn write_graph_label<W>(&self, label: &str, w: &mut W) -> io::Result<()>\n+    where\n+        W: Write,\n+    {\n+        let lines = label.split(\"\\n\").map(|s| dot::escape_html(s)).collect::<Vec<_>>();\n+        let escaped_label = lines.join(r#\"<br align=\"left\"/>\"#);\n+        writeln!(w, r#\"    label=<<br/><br/>{}<br align=\"left\"/><br/><br/><br/>>;\"#, escaped_label)\n+    }\n+\n+    fn node(&self, node: G::Node) -> String {\n+        format!(\"{:?}__{}\", node, self.graphviz_name)\n+    }\n+}"}, {"sha": "aaee0bc526db5511defa5660d57f1dd7aa2d3501", "filename": "compiler/rustc_mir/src/util/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3291d28e9ac1173f033d240bc5f3f145c9c8dd59/compiler%2Frustc_mir%2Fsrc%2Futil%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3291d28e9ac1173f033d240bc5f3f145c9c8dd59/compiler%2Frustc_mir%2Fsrc%2Futil%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Futil%2Fmod.rs?ref=3291d28e9ac1173f033d240bc5f3f145c9c8dd59", "patch": "@@ -7,6 +7,7 @@ pub mod storage;\n mod alignment;\n pub mod collect_writes;\n mod find_self_call;\n+pub(crate) mod generic_graphviz;\n mod graphviz;\n pub(crate) mod pretty;\n pub(crate) mod spanview;"}, {"sha": "df9f7aa627b2620aab98f75c01feb8cabd5350f3", "filename": "src/test/mir-opt/coverage_graphviz.bar.InstrumentCoverage.0.dot", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3291d28e9ac1173f033d240bc5f3f145c9c8dd59/src%2Ftest%2Fmir-opt%2Fcoverage_graphviz.bar.InstrumentCoverage.0.dot", "raw_url": "https://github.com/rust-lang/rust/raw/3291d28e9ac1173f033d240bc5f3f145c9c8dd59/src%2Ftest%2Fmir-opt%2Fcoverage_graphviz.bar.InstrumentCoverage.0.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fcoverage_graphviz.bar.InstrumentCoverage.0.dot?ref=3291d28e9ac1173f033d240bc5f3f145c9c8dd59", "patch": "@@ -0,0 +1,6 @@\n+digraph Cov_0_4 {\n+    graph [fontname=\"Courier, monospace\"];\n+    node [fontname=\"Courier, monospace\"];\n+    edge [fontname=\"Courier, monospace\"];\n+    bcb0__Cov_0_4 [shape=\"none\", label=<<table border=\"0\" cellborder=\"1\" cellspacing=\"0\"><tr><td bgcolor=\"gray\" align=\"center\" colspan=\"1\">bcb0</td></tr><tr><td align=\"left\" balign=\"left\">Counter(bcb0) at 19:5-20:2<br/>    19:5-19:9: @0[0]: _0 = const true<br/>    20:2-20:2: @0.Return: return</td></tr><tr><td align=\"left\" balign=\"left\">bb0: Return</td></tr></table>>];\n+}"}, {"sha": "051ef498fb7fee5c4d4e5a947084bc8b74837c7d", "filename": "src/test/mir-opt/coverage_graphviz.main.InstrumentCoverage.0.dot", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3291d28e9ac1173f033d240bc5f3f145c9c8dd59/src%2Ftest%2Fmir-opt%2Fcoverage_graphviz.main.InstrumentCoverage.0.dot", "raw_url": "https://github.com/rust-lang/rust/raw/3291d28e9ac1173f033d240bc5f3f145c9c8dd59/src%2Ftest%2Fmir-opt%2Fcoverage_graphviz.main.InstrumentCoverage.0.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fcoverage_graphviz.main.InstrumentCoverage.0.dot?ref=3291d28e9ac1173f033d240bc5f3f145c9c8dd59", "patch": "@@ -0,0 +1,11 @@\n+digraph Cov_0_3 {\n+    graph [fontname=\"Courier, monospace\"];\n+    node [fontname=\"Courier, monospace\"];\n+    edge [fontname=\"Courier, monospace\"];\n+    bcb2__Cov_0_3 [shape=\"none\", label=<<table border=\"0\" cellborder=\"1\" cellspacing=\"0\"><tr><td bgcolor=\"gray\" align=\"center\" colspan=\"1\">bcb2</td></tr><tr><td align=\"left\" balign=\"left\">Counter(bcb2) at 14:6-14:6<br/>    14:6-14:6: @4.Goto: goto -&gt; bb0</td></tr><tr><td align=\"left\" balign=\"left\">bb4: Goto</td></tr></table>>];\n+    bcb1__Cov_0_3 [shape=\"none\", label=<<table border=\"0\" cellborder=\"1\" cellspacing=\"0\"><tr><td bgcolor=\"gray\" align=\"center\" colspan=\"1\">bcb1</td></tr><tr><td align=\"left\" balign=\"left\">Counter(bcb1) at 12:13-12:18<br/>    12:13-12:18: @5[0]: _0 = const ()<br/>Expression(bcb1 + 0) at 15:2-15:2<br/>    15:2-15:2: @5.Return: return</td></tr><tr><td align=\"left\" balign=\"left\">bb3: FalseEdge</td></tr><tr><td align=\"left\" balign=\"left\">bb5: Return</td></tr></table>>];\n+    bcb0__Cov_0_3 [shape=\"none\", label=<<table border=\"0\" cellborder=\"1\" cellspacing=\"0\"><tr><td bgcolor=\"gray\" align=\"center\" colspan=\"1\">bcb0</td></tr><tr><td align=\"left\" balign=\"left\">Counter(bcb0) at 11:12-11:17<br/>    11:12-11:17: @1.Call: _2 = bar() -&gt; [return: bb2, unwind: bb6]<br/>    11:12-11:17: @2[0]: FakeRead(ForMatchedPlace, _2)</td></tr><tr><td align=\"left\" balign=\"left\">bb0: FalseUnwind<br/>bb1: Call</td></tr><tr><td align=\"left\" balign=\"left\">bb2: SwitchInt</td></tr></table>>];\n+    bcb2__Cov_0_3 -> bcb0__Cov_0_3 [label=<>];\n+    bcb0__Cov_0_3 -> bcb2__Cov_0_3 [label=<false>];\n+    bcb0__Cov_0_3 -> bcb1__Cov_0_3 [label=<otherwise>];\n+}"}, {"sha": "b3c90c528377d6fe8787f758cf2d8902487d10f4", "filename": "src/test/mir-opt/coverage_graphviz.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3291d28e9ac1173f033d240bc5f3f145c9c8dd59/src%2Ftest%2Fmir-opt%2Fcoverage_graphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3291d28e9ac1173f033d240bc5f3f145c9c8dd59/src%2Ftest%2Fmir-opt%2Fcoverage_graphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fcoverage_graphviz.rs?ref=3291d28e9ac1173f033d240bc5f3f145c9c8dd59", "patch": "@@ -0,0 +1,20 @@\n+// Test that `-Z instrument-coverage` with `-Z dump-mir-graphviz` generates a graphviz (.dot file)\n+// rendering of the `BasicCoverageBlock` coverage control flow graph, with counters and\n+// expressions.\n+\n+// needs-profiler-support\n+// compile-flags: -Z instrument-coverage -Z dump-mir-graphviz\n+// EMIT_MIR coverage_graphviz.main.InstrumentCoverage.0.dot\n+// EMIT_MIR coverage_graphviz.bar.InstrumentCoverage.0.dot\n+fn main() {\n+    loop {\n+        if bar() {\n+            break;\n+        }\n+    }\n+}\n+\n+#[inline(never)]\n+fn bar() -> bool {\n+    true\n+}"}]}