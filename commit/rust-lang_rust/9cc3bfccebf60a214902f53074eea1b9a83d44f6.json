{"sha": "9cc3bfccebf60a214902f53074eea1b9a83d44f6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljYzNiZmNjZWJmNjBhMjE0OTAyZjUzMDc0ZWVhMWI5YTgzZDQ0ZjY=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2016-02-26T18:51:10Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2016-03-11T18:36:28Z"}, "message": "Introduce `ImplHeader`\n\nThis commit introduces the idea of an \"impl header\", which consists of\neverything outside the impl body: the Self type, the trait\nreference (when applicable), and predicates from `where` clauses. This\ntype is usable with the type folding machinery, making it possible to\nwork with impl headers at a higher and more generic level.", "tree": {"sha": "74706f8de0fefdf163a5c6465dde508ba66eaf71", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/74706f8de0fefdf163a5c6465dde508ba66eaf71"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9cc3bfccebf60a214902f53074eea1b9a83d44f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9cc3bfccebf60a214902f53074eea1b9a83d44f6", "html_url": "https://github.com/rust-lang/rust/commit/9cc3bfccebf60a214902f53074eea1b9a83d44f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9cc3bfccebf60a214902f53074eea1b9a83d44f6/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "40c85cd8aec5de06140252610ad4bdc352324e2c", "url": "https://api.github.com/repos/rust-lang/rust/commits/40c85cd8aec5de06140252610ad4bdc352324e2c", "html_url": "https://github.com/rust-lang/rust/commit/40c85cd8aec5de06140252610ad4bdc352324e2c"}], "stats": {"total": 182, "additions": 107, "deletions": 75}, "files": [{"sha": "7cc7f599e14f9561f393917e2ec742ddf16a3b2a", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9cc3bfccebf60a214902f53074eea1b9a83d44f6/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc3bfccebf60a214902f53074eea1b9a83d44f6/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=9cc3bfccebf60a214902f53074eea1b9a83d44f6", "patch": "@@ -458,14 +458,13 @@ pub fn mk_eqty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n }\n \n pub fn mk_eq_trait_refs<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n-                                   a_is_expected: bool,\n-                                   origin: TypeOrigin,\n-                                   a: ty::TraitRef<'tcx>,\n-                                   b: ty::TraitRef<'tcx>)\n-                                   -> UnitResult<'tcx>\n+                                  a_is_expected: bool,\n+                                  origin: TypeOrigin,\n+                                  a: ty::TraitRef<'tcx>,\n+                                  b: ty::TraitRef<'tcx>)\n+                                  -> UnitResult<'tcx>\n {\n-    debug!(\"mk_eq_trait_refs({:?} <: {:?})\",\n-           a, b);\n+    debug!(\"mk_eq_trait_refs({:?} = {:?})\", a, b);\n     cx.eq_trait_refs(a_is_expected, origin, a, b)\n }\n \n@@ -476,11 +475,25 @@ pub fn mk_sub_poly_trait_refs<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n                                         b: ty::PolyTraitRef<'tcx>)\n                                         -> UnitResult<'tcx>\n {\n-    debug!(\"mk_sub_poly_trait_refs({:?} <: {:?})\",\n-           a, b);\n+    debug!(\"mk_sub_poly_trait_refs({:?} <: {:?})\", a, b);\n     cx.sub_poly_trait_refs(a_is_expected, origin, a, b)\n }\n \n+pub fn mk_eq_impl_headers<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n+                                    a_is_expected: bool,\n+                                    origin: TypeOrigin,\n+                                    a: ty::ImplHeader<'tcx>,\n+                                    b: ty::ImplHeader<'tcx>)\n+                                    -> UnitResult<'tcx>\n+{\n+    debug!(\"mk_eq_impl_header({:?} = {:?})\", a, b);\n+    match (a.trait_ref, b.trait_ref) {\n+        (Some(a_ref), Some(b_ref)) => mk_eq_trait_refs(cx, a_is_expected, a_ref, b_ref),\n+        (None, None) => mk_eqty(cx, a_is_expected, a.self_ty, b.self_ty),\n+        _ => cx.tcx.sess.bug(\"mk_eq_impl_headers given mismatched impl kinds\"),\n+    }\n+}\n+\n fn expected_found<T>(a_is_expected: bool,\n                      a: T,\n                      b: T)"}, {"sha": "b59fb5c7e257c0b314f963851d18d93975eb4dc3", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 24, "deletions": 65, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/9cc3bfccebf60a214902f53074eea1b9a83d44f6/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc3bfccebf60a214902f53074eea1b9a83d44f6/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=9cc3bfccebf60a214902f53074eea1b9a83d44f6", "patch": "@@ -10,29 +10,28 @@\n \n //! See `README.md` for high-level documentation\n \n-use super::Normalized;\n-use super::SelectionContext;\n-use super::ObligationCause;\n-use super::PredicateObligation;\n+use super::{Normalized, SelectionContext};\n+use super::{Obligation, ObligationCause, PredicateObligation};\n use super::project;\n use super::util;\n \n use middle::cstore::LOCAL_CRATE;\n use middle::def_id::DefId;\n use middle::subst::{Subst, Substs, TypeSpace};\n use middle::ty::{self, Ty, TyCtxt};\n+use middle::ty::error::TypeError;\n use middle::infer::{self, InferCtxt, TypeOrigin};\n use syntax::codemap::{DUMMY_SP, Span};\n \n #[derive(Copy, Clone)]\n struct InferIsLocal(bool);\n \n-/// If there are types that satisfy both impls, returns a `TraitRef`\n+/// If there are types that satisfy both impls, returns an `ImplTy`\n /// with those types substituted (by updating the given `infcx`)\n pub fn overlapping_impls<'cx, 'tcx>(infcx: &InferCtxt<'cx, 'tcx>,\n                                     impl1_def_id: DefId,\n                                     impl2_def_id: DefId)\n-                                    -> Option<ty::TraitRef<'tcx>>\n+                                    -> Option<ImplTy<'tcx>>\n {\n     debug!(\"impl_can_satisfy(\\\n            impl1_def_id={:?}, \\\n@@ -45,34 +44,28 @@ pub fn overlapping_impls<'cx, 'tcx>(infcx: &InferCtxt<'cx, 'tcx>,\n }\n \n /// Can both impl `a` and impl `b` be satisfied by a common type (including\n-/// `where` clauses)? If so, returns a `TraitRef` that unifies the two impls.\n+/// `where` clauses)? If so, returns an `ImplHeader` that unifies the two impls.\n fn overlap<'cx, 'tcx>(selcx: &mut SelectionContext<'cx, 'tcx>,\n                       a_def_id: DefId,\n                       b_def_id: DefId)\n-                      -> Option<ty::TraitRef<'tcx>>\n+                      -> Option<ImplHeader<'tcx>>\n {\n     debug!(\"overlap(a_def_id={:?}, b_def_id={:?})\",\n            a_def_id,\n            b_def_id);\n \n-    let (a_trait_ref, a_obligations) = impl_trait_ref_and_oblig(selcx,\n-                                                                a_def_id,\n-                                                                util::fresh_type_vars_for_impl);\n+    let a_impl_header = ty::ImplHeader::with_fresh_ty_vars(selcx, a_def_id);\n+    let b_impl_header = ty::ImplHeader::with_fresh_ty_vars(selcx, b_def_id);\n \n-    let (b_trait_ref, b_obligations) = impl_trait_ref_and_oblig(selcx,\n-                                                                b_def_id,\n-                                                                util::fresh_type_vars_for_impl);\n-\n-    debug!(\"overlap: a_trait_ref={:?} a_obligations={:?}\", a_trait_ref, a_obligations);\n-\n-    debug!(\"overlap: b_trait_ref={:?} b_obligations={:?}\", b_trait_ref, b_obligations);\n+    debug!(\"overlap: a_impl_header={:?}\", a_impl_header);\n+    debug!(\"overlap: b_impl_header={:?}\", b_impl_header);\n \n     // Do `a` and `b` unify? If not, no overlap.\n-    if let Err(_) = infer::mk_eq_trait_refs(selcx.infcx(),\n-                                            true,\n-                                            TypeOrigin::Misc(DUMMY_SP),\n-                                            a_trait_ref,\n-                                            b_trait_ref) {\n+    if let Err(_) = infer::mk_eq_impl_headers(selcx.infcx(),\n+                                              true,\n+                                              TypeOrigin::Misc(DUMMY_SP),\n+                                              a_impl_header,\n+                                              b_impl_header) {\n         return None;\n     }\n \n@@ -81,17 +74,21 @@ fn overlap<'cx, 'tcx>(selcx: &mut SelectionContext<'cx, 'tcx>,\n     // Are any of the obligations unsatisfiable? If so, no overlap.\n     let infcx = selcx.infcx();\n     let opt_failing_obligation =\n-        a_obligations.iter()\n-                     .chain(&b_obligations)\n-                     .map(|o| infcx.resolve_type_vars_if_possible(o))\n+        a_impl_header.prediates\n+                     .iter()\n+                     .chain(&b_impl_header.predicates)\n+                     .map(|p| infcx.resolve_type_vars_if_possible(p))\n+                     .map(|p| Obligation { cause: ObligationCause::dummy(),\n+                                           recursion_depth: 0,\n+                                           predicate: p })\n                      .find(|o| !selcx.evaluate_obligation(o));\n \n     if let Some(failing_obligation) = opt_failing_obligation {\n         debug!(\"overlap: obligation unsatisfiable {:?}\", failing_obligation);\n         return None\n     }\n \n-    Some(selcx.infcx().resolve_type_vars_if_possible(&a_trait_ref))\n+    Some(selcx.infcx().resolve_type_vars_if_possible(&a_impl_header))\n }\n \n pub fn trait_ref_is_knowable<'tcx>(tcx: &TyCtxt<'tcx>, trait_ref: &ty::TraitRef<'tcx>) -> bool\n@@ -125,44 +122,6 @@ pub fn trait_ref_is_knowable<'tcx>(tcx: &TyCtxt<'tcx>, trait_ref: &ty::TraitRef<\n     orphan_check_trait_ref(tcx, trait_ref, InferIsLocal(true)).is_err()\n }\n \n-type SubstsFn = for<'a,'tcx> fn(infcx: &InferCtxt<'a, 'tcx>,\n-                                span: Span,\n-                                impl_def_id: DefId)\n-                                -> Substs<'tcx>;\n-\n-/// Instantiate fresh variables for all bound parameters of the impl\n-/// and return the impl trait ref with those variables substituted.\n-fn impl_trait_ref_and_oblig<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n-                                     impl_def_id: DefId,\n-                                     substs_fn: SubstsFn)\n-                                     -> (ty::TraitRef<'tcx>,\n-                                         Vec<PredicateObligation<'tcx>>)\n-{\n-    let impl_substs =\n-        &substs_fn(selcx.infcx(), DUMMY_SP, impl_def_id);\n-    let impl_trait_ref =\n-        selcx.tcx().impl_trait_ref(impl_def_id).unwrap();\n-    let impl_trait_ref =\n-        impl_trait_ref.subst(selcx.tcx(), impl_substs);\n-    let Normalized { value: impl_trait_ref, obligations: normalization_obligations1 } =\n-        project::normalize(selcx, ObligationCause::dummy(), &impl_trait_ref);\n-\n-    let predicates = selcx.tcx().lookup_predicates(impl_def_id);\n-    let predicates = predicates.instantiate(selcx.tcx(), impl_substs);\n-    let Normalized { value: predicates, obligations: normalization_obligations2 } =\n-        project::normalize(selcx, ObligationCause::dummy(), &predicates);\n-    let impl_obligations =\n-        util::predicates_for_generics(ObligationCause::dummy(), 0, &predicates);\n-\n-    let impl_obligations: Vec<_> =\n-        impl_obligations.into_iter()\n-        .chain(normalization_obligations1)\n-        .chain(normalization_obligations2)\n-        .collect();\n-\n-    (impl_trait_ref, impl_obligations)\n-}\n-\n pub enum OrphanCheckErr<'tcx> {\n     NoLocalInputType,\n     UncoveredTy(Ty<'tcx>),"}, {"sha": "fbfd4b67b5bd5393b8c71ad2b62f98ca8f281bec", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9cc3bfccebf60a214902f53074eea1b9a83d44f6/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc3bfccebf60a214902f53074eea1b9a83d44f6/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=9cc3bfccebf60a214902f53074eea1b9a83d44f6", "patch": "@@ -391,7 +391,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     // The result is \"true\" if the obligation *may* hold and \"false\" if\n     // we can be sure it does not.\n \n-\n     /// Evaluates whether the obligation `obligation` can be satisfied (by any means).\n     pub fn evaluate_obligation(&mut self,\n                                obligation: &PredicateObligation<'tcx>)"}, {"sha": "090d4eeb87437bcc7bf7cb783fd7c0d9881657ff", "filename": "src/librustc/middle/ty/fold.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cc3bfccebf60a214902f53074eea1b9a83d44f6/src%2Flibrustc%2Fmiddle%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc3bfccebf60a214902f53074eea1b9a83d44f6/src%2Flibrustc%2Fmiddle%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Ffold.rs?ref=9cc3bfccebf60a214902f53074eea1b9a83d44f6", "patch": "@@ -146,6 +146,10 @@ pub trait TypeFolder<'tcx> : Sized {\n         t.super_fold_with(self)\n     }\n \n+    fn fold_impl_header(&mut self, imp: &ty::ImplHeader<'tcx>) -> ty::ImplHeader<'tcx> {\n+        imp.super_fold_with(self)\n+    }\n+\n     fn fold_substs(&mut self,\n                    substs: &subst::Substs<'tcx>)\n                    -> subst::Substs<'tcx> {"}, {"sha": "2405f661ab3f16cbd5624846c8f03fb0333dbb47", "filename": "src/librustc/middle/ty/mod.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/9cc3bfccebf60a214902f53074eea1b9a83d44f6/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc3bfccebf60a214902f53074eea1b9a83d44f6/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs?ref=9cc3bfccebf60a214902f53074eea1b9a83d44f6", "patch": "@@ -152,6 +152,41 @@ impl ImplOrTraitItemContainer {\n     }\n }\n \n+/// The \"header\" of an impl is everything outside the body: a Self type, a trait\n+/// ref (in the case of a trait impl), and a set of predicates (from the\n+/// bounds/where clauses).\n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+pub struct ImplHeader<'tcx> {\n+    pub impl_def_id: DefId,\n+    pub self_ty: Ty<'tcx>,\n+    pub trait_ref: Option<TraitRef<'tcx>>,\n+    pub predicates: Vec<Predicate<'tcx>>,\n+}\n+\n+impl<'tcx> ImplHeader<'tcx> {\n+    pub fn with_fresh_ty_vars<'a,'tcx>(selcx: &mut traits::SelectionContext<'a,'tcx>,\n+                                       impl_def_id: DefId)\n+                                       -> ImplHeader<'tcx>\n+    {\n+        let tcx = selcx.tcx();\n+        let impl_generics = tcx.lookup_item_type(impl_def_id).generics;\n+        let impl_substs = selcx.infcx().fresh_substs_for_generics(DUMMY_SP, &impl_generics);\n+\n+        let header = ImplHeader {\n+            impl_def_id: impl_def_id,\n+            self_ty: tcx.lookup_item_type(impl_def_id),\n+            trait_ref: tcx.impl_trait_ref(impl_def_id),\n+            predicates: tcx.lookup_predicates(impl_def_id),\n+        }.subst(tcx, impl_substs);\n+\n+        let Normalized { value: mut header, obligations: obligations } =\n+            proect::normalize(selcx, ObligationCause::dummy(), &header);\n+\n+        header.predicates.extend(obligations.into_iter().map(|o| o.predicate));\n+        header\n+    }\n+}\n+\n #[derive(Clone)]\n pub enum ImplOrTraitItem<'tcx> {\n     ConstTraitItem(Rc<AssociatedConst<'tcx>>),"}, {"sha": "645e709f512352440406b0bd2968feaffe50b3a4", "filename": "src/librustc/middle/ty/structural_impls.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9cc3bfccebf60a214902f53074eea1b9a83d44f6/src%2Flibrustc%2Fmiddle%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc3bfccebf60a214902f53074eea1b9a83d44f6/src%2Flibrustc%2Fmiddle%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fstructural_impls.rs?ref=9cc3bfccebf60a214902f53074eea1b9a83d44f6", "patch": "@@ -446,6 +446,28 @@ impl<'tcx> TypeFoldable<'tcx> for ty::TraitRef<'tcx> {\n     }\n }\n \n+impl<'tcx> TypeFoldable<'tcx> for ty::ImplHeader<'tcx> {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        ty::ImplHeader {\n+            impl_def_id: self.impl_def_id,\n+            self_ty: self.self_ty.fold_with(folder),\n+            trait_ref: self.trait_ref.map(|t| t.fold_with(folder)),\n+            predicates: self.predicates.into_iter().map(|p| p.fold_with(folder)).collect(),\n+            polarity: self.polarity,\n+        }\n+    }\n+\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        folder.fold_impl_header(self)\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.self_ty.visit_with(visitor) ||\n+            self.trait_ref.map(|r| r.visit_with(visitor)).unwrap_or(false) ||\n+            self.predicates.iter().any(|p| p.visit_with(visitor))\n+    }\n+}\n+\n impl<'tcx> TypeFoldable<'tcx> for ty::Region {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, _folder: &mut F) -> Self {\n         *self"}]}