{"sha": "4f5e73be1bf439a9881600ad4cdfd5865391eaef", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmNWU3M2JlMWJmNDM5YTk4ODE2MDBhZDRjZGZkNTg2NTM5MWVhZWY=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2016-09-27T21:27:22Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2016-09-30T21:03:00Z"}, "message": "Build a dummy alloc_jemalloc crate on platforms that don't support it\n\nThis is a hack to support building targets that don't support jemalloc\nalongside hosts that do. The jemalloc build is controlled by a feature\nof the std crate, and if that feature changes between targets, it\ninvalidates the fingerprint of std's build script (this is a cargo\nbug); so we must ensure that the feature set used by std is the same\nacross all targets, which means we have to build the alloc_jemalloc\ncrate for targets like emscripten, even if we don't use it.", "tree": {"sha": "e8f04e1018d5fb02297fafb8c36f2d857655ce3a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e8f04e1018d5fb02297fafb8c36f2d857655ce3a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f5e73be1bf439a9881600ad4cdfd5865391eaef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f5e73be1bf439a9881600ad4cdfd5865391eaef", "html_url": "https://github.com/rust-lang/rust/commit/4f5e73be1bf439a9881600ad4cdfd5865391eaef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f5e73be1bf439a9881600ad4cdfd5865391eaef/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c038c0505a5f937aba9a4c3208fe8e0aebdd370", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c038c0505a5f937aba9a4c3208fe8e0aebdd370", "html_url": "https://github.com/rust-lang/rust/commit/3c038c0505a5f937aba9a4c3208fe8e0aebdd370"}], "stats": {"total": 297, "additions": 180, "deletions": 117}, "files": [{"sha": "9429af565258b7b11b9eb4657de55ea46229556a", "filename": "src/bootstrap/sanity.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4f5e73be1bf439a9881600ad4cdfd5865391eaef/src%2Fbootstrap%2Fsanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f5e73be1bf439a9881600ad4cdfd5865391eaef/src%2Fbootstrap%2Fsanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsanity.rs?ref=4f5e73be1bf439a9881600ad4cdfd5865391eaef", "patch": "@@ -104,22 +104,21 @@ pub fn check(build: &mut Build) {\n         need_cmd(build.cxx(host).as_ref());\n     }\n \n+    // The msvc hosts don't use jemalloc, turn it off globally to\n+    // avoid packaging the dummy liballoc_jemalloc on that platform.\n+    for host in build.config.host.iter() {\n+        if host.contains(\"msvc\") {\n+            build.config.use_jemalloc = false;\n+        }\n+    }\n+\n     // Externally configured LLVM requires FileCheck to exist\n     let filecheck = build.llvm_filecheck(&build.config.build);\n     if !filecheck.starts_with(&build.out) && !filecheck.exists() && build.config.codegen_tests {\n         panic!(\"filecheck executable {:?} does not exist\", filecheck);\n     }\n \n     for target in build.config.target.iter() {\n-        // Either can't build or don't want to run jemalloc on these targets\n-        if target.contains(\"rumprun\") ||\n-           target.contains(\"bitrig\") ||\n-           target.contains(\"openbsd\") ||\n-           target.contains(\"msvc\") ||\n-           target.contains(\"emscripten\") {\n-            build.config.use_jemalloc = false;\n-        }\n-\n         // Can't compile for iOS unless we're on OSX\n         if target.contains(\"apple-ios\") &&\n            !build.config.build.contains(\"apple-darwin\") {"}, {"sha": "028d742cc832ea7c0a466562075f25c787f629e3", "filename": "src/liballoc_jemalloc/build.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4f5e73be1bf439a9881600ad4cdfd5865391eaef/src%2Fliballoc_jemalloc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f5e73be1bf439a9881600ad4cdfd5865391eaef/src%2Fliballoc_jemalloc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2Fbuild.rs?ref=4f5e73be1bf439a9881600ad4cdfd5865391eaef", "patch": "@@ -27,6 +27,24 @@ fn main() {\n     let build_dir = PathBuf::from(env::var_os(\"OUT_DIR\").unwrap());\n     let src_dir = env::current_dir().unwrap();\n \n+    // FIXME: This is a hack to support building targets that don't\n+    // support jemalloc alongside hosts that do. The jemalloc build is\n+    // controlled by a feature of the std crate, and if that feature\n+    // changes between targets, it invalidates the fingerprint of\n+    // std's build script (this is a cargo bug); so we must ensure\n+    // that the feature set used by std is the same across all\n+    // targets, which means we have to build the alloc_jemalloc crate\n+    // for targets like emscripten, even if we don't use it.\n+    if target.contains(\"rumprun\") ||\n+        target.contains(\"bitrig\") ||\n+        target.contains(\"openbsd\") ||\n+        target.contains(\"msvc\") ||\n+        target.contains(\"emscripten\")\n+    {\n+        println!(\"cargo:rustc-cfg=dummy_jemalloc\");\n+        return;\n+    }\n+\n     if let Some(jemalloc) = env::var_os(\"JEMALLOC_OVERRIDE\") {\n         let jemalloc = PathBuf::from(jemalloc);\n         println!(\"cargo:rustc-link-search=native={}\","}, {"sha": "21e45f9c4b20c81598c7629da18deeedc31941b4", "filename": "src/liballoc_jemalloc/lib.rs", "status": "modified", "additions": 154, "deletions": 108, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/4f5e73be1bf439a9881600ad4cdfd5865391eaef/src%2Fliballoc_jemalloc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f5e73be1bf439a9881600ad4cdfd5865391eaef/src%2Fliballoc_jemalloc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2Flib.rs?ref=4f5e73be1bf439a9881600ad4cdfd5865391eaef", "patch": "@@ -23,124 +23,170 @@\n \n extern crate libc;\n \n-use libc::{c_int, c_void, size_t};\n+pub use imp::*;\n \n-// Linkage directives to pull in jemalloc and its dependencies.\n-//\n-// On some platforms we need to be sure to link in `pthread` which jemalloc\n-// depends on, and specifically on android we need to also link to libgcc.\n-// Currently jemalloc is compiled with gcc which will generate calls to\n-// intrinsics that are libgcc specific (e.g. those intrinsics aren't present in\n-// libcompiler-rt), so link that in to get that support.\n-#[link(name = \"jemalloc\", kind = \"static\")]\n-#[cfg_attr(target_os = \"android\", link(name = \"gcc\"))]\n-#[cfg_attr(all(not(windows),\n-               not(target_os = \"android\"),\n-               not(target_env = \"musl\")),\n-           link(name = \"pthread\"))]\n-#[cfg(not(cargobuild))]\n-extern \"C\" {}\n-\n-// Note that the symbols here are prefixed by default on OSX and Windows (we\n-// don't explicitly request it), and on Android and DragonFly we explicitly\n-// request it as unprefixing cause segfaults (mismatches in allocators).\n-extern \"C\" {\n-    #[cfg_attr(any(target_os = \"macos\", target_os = \"android\", target_os = \"ios\",\n-                   target_os = \"dragonfly\", target_os = \"windows\"),\n-               link_name = \"je_mallocx\")]\n-    fn mallocx(size: size_t, flags: c_int) -> *mut c_void;\n-    #[cfg_attr(any(target_os = \"macos\", target_os = \"android\", target_os = \"ios\",\n-                   target_os = \"dragonfly\", target_os = \"windows\"),\n-               link_name = \"je_rallocx\")]\n-    fn rallocx(ptr: *mut c_void, size: size_t, flags: c_int) -> *mut c_void;\n-    #[cfg_attr(any(target_os = \"macos\", target_os = \"android\", target_os = \"ios\",\n-                   target_os = \"dragonfly\", target_os = \"windows\"),\n-               link_name = \"je_xallocx\")]\n-    fn xallocx(ptr: *mut c_void, size: size_t, extra: size_t, flags: c_int) -> size_t;\n-    #[cfg_attr(any(target_os = \"macos\", target_os = \"android\", target_os = \"ios\",\n-                   target_os = \"dragonfly\", target_os = \"windows\"),\n-               link_name = \"je_sdallocx\")]\n-    fn sdallocx(ptr: *mut c_void, size: size_t, flags: c_int);\n-    #[cfg_attr(any(target_os = \"macos\", target_os = \"android\", target_os = \"ios\",\n-                   target_os = \"dragonfly\", target_os = \"windows\"),\n-               link_name = \"je_nallocx\")]\n-    fn nallocx(size: size_t, flags: c_int) -> size_t;\n-}\n+// See comments in build.rs for why we sometimes build a crate that does nothing\n+#[cfg(not(dummy_jemalloc))]\n+mod imp {\n+    use libc::{c_int, c_void, size_t};\n \n-// The minimum alignment guaranteed by the architecture. This value is used to\n-// add fast paths for low alignment values. In practice, the alignment is a\n-// constant at the call site and the branch will be optimized out.\n-#[cfg(all(any(target_arch = \"arm\",\n-              target_arch = \"mips\",\n-              target_arch = \"powerpc\")))]\n-const MIN_ALIGN: usize = 8;\n-#[cfg(all(any(target_arch = \"x86\",\n-              target_arch = \"x86_64\",\n-              target_arch = \"aarch64\",\n-              target_arch = \"powerpc64\",\n-              target_arch = \"mips64\",\n-              target_arch = \"s390x\")))]\n-const MIN_ALIGN: usize = 16;\n-\n-// MALLOCX_ALIGN(a) macro\n-fn mallocx_align(a: usize) -> c_int {\n-    a.trailing_zeros() as c_int\n-}\n+    // Linkage directives to pull in jemalloc and its dependencies.\n+    //\n+    // On some platforms we need to be sure to link in `pthread` which jemalloc\n+    // depends on, and specifically on android we need to also link to libgcc.\n+    // Currently jemalloc is compiled with gcc which will generate calls to\n+    // intrinsics that are libgcc specific (e.g. those intrinsics aren't present in\n+    // libcompiler-rt), so link that in to get that support.\n+    #[link(name = \"jemalloc\", kind = \"static\")]\n+    #[cfg_attr(target_os = \"android\", link(name = \"gcc\"))]\n+    #[cfg_attr(all(not(windows),\n+                   not(target_os = \"android\"),\n+                   not(target_env = \"musl\")),\n+               link(name = \"pthread\"))]\n+    #[cfg(not(cargobuild))]\n+    extern \"C\" {}\n+\n+    // Note that the symbols here are prefixed by default on OSX and Windows (we\n+    // don't explicitly request it), and on Android and DragonFly we explicitly\n+    // request it as unprefixing cause segfaults (mismatches in allocators).\n+    extern \"C\" {\n+        #[cfg_attr(any(target_os = \"macos\", target_os = \"android\", target_os = \"ios\",\n+                       target_os = \"dragonfly\", target_os = \"windows\"),\n+                   link_name = \"je_mallocx\")]\n+        fn mallocx(size: size_t, flags: c_int) -> *mut c_void;\n+        #[cfg_attr(any(target_os = \"macos\", target_os = \"android\", target_os = \"ios\",\n+                       target_os = \"dragonfly\", target_os = \"windows\"),\n+                   link_name = \"je_rallocx\")]\n+        fn rallocx(ptr: *mut c_void, size: size_t, flags: c_int) -> *mut c_void;\n+        #[cfg_attr(any(target_os = \"macos\", target_os = \"android\", target_os = \"ios\",\n+                       target_os = \"dragonfly\", target_os = \"windows\"),\n+                   link_name = \"je_xallocx\")]\n+        fn xallocx(ptr: *mut c_void, size: size_t, extra: size_t, flags: c_int) -> size_t;\n+        #[cfg_attr(any(target_os = \"macos\", target_os = \"android\", target_os = \"ios\",\n+                       target_os = \"dragonfly\", target_os = \"windows\"),\n+                   link_name = \"je_sdallocx\")]\n+        fn sdallocx(ptr: *mut c_void, size: size_t, flags: c_int);\n+        #[cfg_attr(any(target_os = \"macos\", target_os = \"android\", target_os = \"ios\",\n+                       target_os = \"dragonfly\", target_os = \"windows\"),\n+                   link_name = \"je_nallocx\")]\n+        fn nallocx(size: size_t, flags: c_int) -> size_t;\n+    }\n+\n+    // The minimum alignment guaranteed by the architecture. This value is used to\n+    // add fast paths for low alignment values. In practice, the alignment is a\n+    // constant at the call site and the branch will be optimized out.\n+    #[cfg(all(any(target_arch = \"arm\",\n+                  target_arch = \"mips\",\n+                  target_arch = \"powerpc\")))]\n+    const MIN_ALIGN: usize = 8;\n+    #[cfg(all(any(target_arch = \"x86\",\n+                  target_arch = \"x86_64\",\n+                  target_arch = \"aarch64\",\n+                  target_arch = \"powerpc64\",\n+                  target_arch = \"mips64\",\n+                  target_arch = \"s390x\")))]\n+    const MIN_ALIGN: usize = 16;\n+\n+    // MALLOCX_ALIGN(a) macro\n+    fn mallocx_align(a: usize) -> c_int {\n+        a.trailing_zeros() as c_int\n+    }\n+\n+    fn align_to_flags(align: usize) -> c_int {\n+        if align <= MIN_ALIGN {\n+            0\n+        } else {\n+            mallocx_align(align)\n+        }\n+    }\n+\n+    #[no_mangle]\n+    pub extern \"C\" fn __rust_allocate(size: usize, align: usize) -> *mut u8 {\n+        let flags = align_to_flags(align);\n+        unsafe { mallocx(size as size_t, flags) as *mut u8 }\n+    }\n+\n+    #[no_mangle]\n+    pub extern \"C\" fn __rust_reallocate(ptr: *mut u8,\n+                                        _old_size: usize,\n+                                        size: usize,\n+                                        align: usize)\n+                                        -> *mut u8 {\n+        let flags = align_to_flags(align);\n+        unsafe { rallocx(ptr as *mut c_void, size as size_t, flags) as *mut u8 }\n+    }\n+\n+    #[no_mangle]\n+    pub extern \"C\" fn __rust_reallocate_inplace(ptr: *mut u8,\n+                                                _old_size: usize,\n+                                                size: usize,\n+                                                align: usize)\n+                                                -> usize {\n+        let flags = align_to_flags(align);\n+        unsafe { xallocx(ptr as *mut c_void, size as size_t, 0, flags) as usize }\n+    }\n \n-fn align_to_flags(align: usize) -> c_int {\n-    if align <= MIN_ALIGN {\n+    #[no_mangle]\n+    pub extern \"C\" fn __rust_deallocate(ptr: *mut u8, old_size: usize, align: usize) {\n+        let flags = align_to_flags(align);\n+        unsafe { sdallocx(ptr as *mut c_void, old_size as size_t, flags) }\n+    }\n+\n+    #[no_mangle]\n+    pub extern \"C\" fn __rust_usable_size(size: usize, align: usize) -> usize {\n+        let flags = align_to_flags(align);\n+        unsafe { nallocx(size as size_t, flags) as usize }\n+    }\n+\n+    // These symbols are used by jemalloc on android but the really old android\n+    // we're building on doesn't have them defined, so just make sure the symbols\n+    // are available.\n+    #[no_mangle]\n+    #[cfg(target_os = \"android\")]\n+    pub extern \"C\" fn pthread_atfork(_prefork: *mut u8,\n+                                     _postfork_parent: *mut u8,\n+                                     _postfork_child: *mut u8)\n+                                     -> i32 {\n         0\n-    } else {\n-        mallocx_align(align)\n     }\n }\n \n-#[no_mangle]\n-pub extern \"C\" fn __rust_allocate(size: usize, align: usize) -> *mut u8 {\n-    let flags = align_to_flags(align);\n-    unsafe { mallocx(size as size_t, flags) as *mut u8 }\n-}\n+#[cfg(dummy_jemalloc)]\n+mod imp {\n+    fn bogus() -> ! {\n+        panic!(\"jemalloc is not implemented for this platform\");\n+    }\n \n-#[no_mangle]\n-pub extern \"C\" fn __rust_reallocate(ptr: *mut u8,\n-                                    _old_size: usize,\n-                                    size: usize,\n-                                    align: usize)\n-                                    -> *mut u8 {\n-    let flags = align_to_flags(align);\n-    unsafe { rallocx(ptr as *mut c_void, size as size_t, flags) as *mut u8 }\n-}\n+    #[no_mangle]\n+    pub extern \"C\" fn __rust_allocate(_size: usize, _align: usize) -> *mut u8 {\n+        bogus()\n+    }\n \n-#[no_mangle]\n-pub extern \"C\" fn __rust_reallocate_inplace(ptr: *mut u8,\n-                                            _old_size: usize,\n-                                            size: usize,\n-                                            align: usize)\n-                                            -> usize {\n-    let flags = align_to_flags(align);\n-    unsafe { xallocx(ptr as *mut c_void, size as size_t, 0, flags) as usize }\n-}\n+    #[no_mangle]\n+    pub extern \"C\" fn __rust_reallocate(_ptr: *mut u8,\n+                                        _old_size: usize,\n+                                        _size: usize,\n+                                        _align: usize)\n+                                        -> *mut u8 {\n+        bogus()\n+    }\n \n-#[no_mangle]\n-pub extern \"C\" fn __rust_deallocate(ptr: *mut u8, old_size: usize, align: usize) {\n-    let flags = align_to_flags(align);\n-    unsafe { sdallocx(ptr as *mut c_void, old_size as size_t, flags) }\n-}\n+    #[no_mangle]\n+    pub extern \"C\" fn __rust_reallocate_inplace(_ptr: *mut u8,\n+                                                _old_size: usize,\n+                                                _size: usize,\n+                                                _align: usize)\n+                                                -> usize {\n+        bogus()\n+    }\n \n-#[no_mangle]\n-pub extern \"C\" fn __rust_usable_size(size: usize, align: usize) -> usize {\n-    let flags = align_to_flags(align);\n-    unsafe { nallocx(size as size_t, flags) as usize }\n-}\n+    #[no_mangle]\n+    pub extern \"C\" fn __rust_deallocate(_ptr: *mut u8, _old_size: usize, _align: usize) {\n+        bogus()\n+    }\n \n-// These symbols are used by jemalloc on android but the really old android\n-// we're building on doesn't have them defined, so just make sure the symbols\n-// are available.\n-#[no_mangle]\n-#[cfg(target_os = \"android\")]\n-pub extern \"C\" fn pthread_atfork(_prefork: *mut u8,\n-                                 _postfork_parent: *mut u8,\n-                                 _postfork_child: *mut u8)\n-                                 -> i32 {\n-    0\n+    #[no_mangle]\n+    pub extern \"C\" fn __rust_usable_size(_size: usize, _align: usize) -> usize {\n+        bogus()\n+    }\n }"}]}