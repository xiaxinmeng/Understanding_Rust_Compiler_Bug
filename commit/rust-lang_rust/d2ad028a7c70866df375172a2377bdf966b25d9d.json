{"sha": "d2ad028a7c70866df375172a2377bdf966b25d9d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyYWQwMjhhN2M3MDg2NmRmMzc1MTcyYTIzNzdiZGY5NjZiMjVkOWQ=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-12-07T00:13:54Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-12-07T00:14:54Z"}, "message": "Rename std::ebml::Reader => std::ebml::reader, same for writer\n\nCloses #4076", "tree": {"sha": "fe77741c3e909b8f4887e3f39414c63253fe6dd7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe77741c3e909b8f4887e3f39414c63253fe6dd7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d2ad028a7c70866df375172a2377bdf966b25d9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d2ad028a7c70866df375172a2377bdf966b25d9d", "html_url": "https://github.com/rust-lang/rust/commit/d2ad028a7c70866df375172a2377bdf966b25d9d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d2ad028a7c70866df375172a2377bdf966b25d9d/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fe9a339939e27e8cb617c04a80661297d47e4d70", "url": "https://api.github.com/repos/rust-lang/rust/commits/fe9a339939e27e8cb617c04a80661297d47e4d70", "html_url": "https://github.com/rust-lang/rust/commit/fe9a339939e27e8cb617c04a80661297d47e4d70"}], "stats": {"total": 358, "additions": 179, "deletions": 179}, "files": [{"sha": "913c63d0e3234400d2b9574278c88d06bf03f0f7", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2ad028a7c70866df375172a2377bdf966b25d9d/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ad028a7c70866df375172a2377bdf966b25d9d/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=d2ad028a7c70866df375172a2377bdf966b25d9d", "patch": "@@ -11,7 +11,7 @@\n // Searching for information from the cstore\n \n use std::ebml;\n-use Reader = std::ebml::Reader;\n+use reader = std::ebml::reader;\n use syntax::ast;\n use syntax::ast_util;\n use syntax::ast_map;\n@@ -192,7 +192,7 @@ fn get_field_type(tcx: ty::ctxt, class_id: ast::def_id,\n                   def: ast::def_id) -> ty::ty_param_bounds_and_ty {\n     let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, class_id.crate);\n-    let all_items = Reader::get_doc(Reader::Doc(cdata.data), tag_items);\n+    let all_items = reader::get_doc(reader::Doc(cdata.data), tag_items);\n     debug!(\"Looking up %?\", class_id);\n     let class_doc = expect(tcx.diag,\n                            decoder::maybe_find_item(class_id.node, all_items),"}, {"sha": "8859c952471c548386128154197997be52dd46d6", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 99, "deletions": 99, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/d2ad028a7c70866df375172a2377bdf966b25d9d/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ad028a7c70866df375172a2377bdf966b25d9d/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=d2ad028a7c70866df375172a2377bdf966b25d9d", "patch": "@@ -14,7 +14,7 @@ use std::ebml;\n use std::map;\n use std::map::HashMap;\n use std::serialization::deserialize;\n-use Reader = ebml::Reader;\n+use reader = ebml::reader;\n use io::WriterUtil;\n use dvec::DVec;\n use syntax::{ast, ast_util};\n@@ -84,17 +84,17 @@ export translate_def_id;\n \n fn lookup_hash(d: ebml::Doc, eq_fn: fn(x:&[u8]) -> bool, hash: uint) ->\n    Option<ebml::Doc> {\n-    let index = Reader::get_doc(d, tag_index);\n-    let table = Reader::get_doc(index, tag_index_table);\n+    let index = reader::get_doc(d, tag_index);\n+    let table = reader::get_doc(index, tag_index_table);\n     let hash_pos = table.start + hash % 256u * 4u;\n     let pos = io::u64_from_be_bytes(*d.data, hash_pos, 4u) as uint;\n-    let tagged_doc = Reader::doc_at(d.data, pos);\n+    let tagged_doc = reader::doc_at(d.data, pos);\n \n     let belt = tag_index_buckets_bucket_elt;\n-    for Reader::tagged_docs(tagged_doc.doc, belt) |elt| {\n+    for reader::tagged_docs(tagged_doc.doc, belt) |elt| {\n         let pos = io::u64_from_be_bytes(*elt.data, elt.start, 4u) as uint;\n         if eq_fn(vec::view(*elt.data, elt.start + 4u, elt.end)) {\n-            return Some(Reader::doc_at(d.data, pos).doc);\n+            return Some(reader::doc_at(d.data, pos).doc);\n         }\n     };\n     None\n@@ -119,7 +119,7 @@ fn find_item(item_id: int, items: ebml::Doc) -> ebml::Doc {\n // Looks up an item in the given metadata and returns an ebml doc pointing\n // to the item data.\n fn lookup_item(item_id: int, data: @~[u8]) -> ebml::Doc {\n-    let items = Reader::get_doc(Reader::Doc(data), tag_items);\n+    let items = reader::get_doc(reader::Doc(data), tag_items);\n     match maybe_find_item(item_id, items) {\n        None => fail(fmt!(\"lookup_item: id not found: %d\", item_id)),\n        Some(d) => d\n@@ -157,8 +157,8 @@ impl Family : cmp::Eq {\n }\n \n fn item_family(item: ebml::Doc) -> Family {\n-    let fam = Reader::get_doc(item, tag_items_data_item_family);\n-    match Reader::doc_as_u8(fam) as char {\n+    let fam = reader::get_doc(item, tag_items_data_item_family);\n+    match reader::doc_as_u8(fam) as char {\n       'c' => Const,\n       'f' => Fn,\n       'u' => UnsafeFn,\n@@ -184,20 +184,20 @@ fn item_family(item: ebml::Doc) -> Family {\n }\n \n fn item_method_sort(item: ebml::Doc) -> char {\n-    for Reader::tagged_docs(item, tag_item_trait_method_sort) |doc| {\n-        return str::from_bytes(Reader::doc_data(doc))[0] as char;\n+    for reader::tagged_docs(item, tag_item_trait_method_sort) |doc| {\n+        return str::from_bytes(reader::doc_data(doc))[0] as char;\n     }\n     return 'r';\n }\n \n fn item_symbol(item: ebml::Doc) -> ~str {\n-    let sym = Reader::get_doc(item, tag_items_data_item_symbol);\n-    return str::from_bytes(Reader::doc_data(sym));\n+    let sym = reader::get_doc(item, tag_items_data_item_symbol);\n+    return str::from_bytes(reader::doc_data(sym));\n }\n \n fn item_parent_item(d: ebml::Doc) -> Option<ast::def_id> {\n-    for Reader::tagged_docs(d, tag_items_data_parent_item) |did| {\n-        return Some(Reader::with_doc_data(did, |d| parse_def_id(d)));\n+    for reader::tagged_docs(d, tag_items_data_parent_item) |did| {\n+        return Some(reader::with_doc_data(did, |d| parse_def_id(d)));\n     }\n     None\n }\n@@ -215,13 +215,13 @@ fn item_reqd_and_translated_parent_item(cnum: ast::crate_num,\n }\n \n fn item_def_id(d: ebml::Doc, cdata: cmd) -> ast::def_id {\n-    let tagdoc = Reader::get_doc(d, tag_def_id);\n-    return translate_def_id(cdata, Reader::with_doc_data(tagdoc,\n+    let tagdoc = reader::get_doc(d, tag_def_id);\n+    return translate_def_id(cdata, reader::with_doc_data(tagdoc,\n                                                     |d| parse_def_id(d)));\n }\n \n fn each_reexport(d: ebml::Doc, f: fn(ebml::Doc) -> bool) {\n-    for Reader::tagged_docs(d, tag_items_data_item_reexport) |reexport_doc| {\n+    for reader::tagged_docs(d, tag_items_data_item_reexport) |reexport_doc| {\n         if !f(reexport_doc) {\n             return;\n         }\n@@ -231,24 +231,24 @@ fn each_reexport(d: ebml::Doc, f: fn(ebml::Doc) -> bool) {\n fn field_mutability(d: ebml::Doc) -> ast::class_mutability {\n     // Use maybe_get_doc in case it's a method\n     option::map_default(\n-        &Reader::maybe_get_doc(d, tag_class_mut),\n+        &reader::maybe_get_doc(d, tag_class_mut),\n         ast::class_immutable,\n         |d| {\n-            match Reader::doc_as_u8(*d) as char {\n+            match reader::doc_as_u8(*d) as char {\n               'm' => ast::class_mutable,\n               _   => ast::class_immutable\n             }\n         })\n }\n \n fn variant_disr_val(d: ebml::Doc) -> Option<int> {\n-    do option::chain(Reader::maybe_get_doc(d, tag_disr_val)) |val_doc| {\n-        int::parse_bytes(Reader::doc_data(val_doc), 10u)\n+    do option::chain(reader::maybe_get_doc(d, tag_disr_val)) |val_doc| {\n+        int::parse_bytes(reader::doc_data(val_doc), 10u)\n     }\n }\n \n fn doc_type(doc: ebml::Doc, tcx: ty::ctxt, cdata: cmd) -> ty::t {\n-    let tp = Reader::get_doc(doc, tag_items_data_item_type);\n+    let tp = reader::get_doc(doc, tag_items_data_item_type);\n     parse_ty_data(tp.data, cdata.cnum, tp.start, tcx, |did| {\n         translate_def_id(cdata, did)\n     })\n@@ -264,7 +264,7 @@ fn item_type(item_id: ast::def_id, item: ebml::Doc,\n \n fn item_impl_traits(item: ebml::Doc, tcx: ty::ctxt, cdata: cmd) -> ~[ty::t] {\n     let mut results = ~[];\n-    for Reader::tagged_docs(item, tag_impl_trait) |ity| {\n+    for reader::tagged_docs(item, tag_impl_trait) |ity| {\n         results.push(doc_type(ity, tcx, cdata));\n     };\n     results\n@@ -273,7 +273,7 @@ fn item_impl_traits(item: ebml::Doc, tcx: ty::ctxt, cdata: cmd) -> ~[ty::t] {\n fn item_ty_param_bounds(item: ebml::Doc, tcx: ty::ctxt, cdata: cmd)\n     -> @~[ty::param_bounds] {\n     let mut bounds = ~[];\n-    for Reader::tagged_docs(item, tag_items_data_item_ty_param_bounds) |p| {\n+    for reader::tagged_docs(item, tag_items_data_item_ty_param_bounds) |p| {\n         let bd = parse_bounds_data(p.data, p.start, cdata.cnum, tcx, |did| {\n             translate_def_id(cdata, did)\n         });\n@@ -283,41 +283,41 @@ fn item_ty_param_bounds(item: ebml::Doc, tcx: ty::ctxt, cdata: cmd)\n }\n \n fn item_ty_region_param(item: ebml::Doc) -> Option<ty::region_variance> {\n-    Reader::maybe_get_doc(item, tag_region_param).map(|doc| {\n-        deserialize(&Reader::Deserializer(*doc))\n+    reader::maybe_get_doc(item, tag_region_param).map(|doc| {\n+        deserialize(&reader::Deserializer(*doc))\n     })\n }\n \n fn item_ty_param_count(item: ebml::Doc) -> uint {\n     let mut n = 0u;\n-    Reader::tagged_docs(item, tag_items_data_item_ty_param_bounds,\n+    reader::tagged_docs(item, tag_items_data_item_ty_param_bounds,\n                       |_p| { n += 1u; true } );\n     n\n }\n \n fn enum_variant_ids(item: ebml::Doc, cdata: cmd) -> ~[ast::def_id] {\n     let mut ids: ~[ast::def_id] = ~[];\n     let v = tag_items_data_item_variant;\n-    for Reader::tagged_docs(item, v) |p| {\n-        let ext = Reader::with_doc_data(p, |d| parse_def_id(d));\n+    for reader::tagged_docs(item, v) |p| {\n+        let ext = reader::with_doc_data(p, |d| parse_def_id(d));\n         ids.push({crate: cdata.cnum, node: ext.node});\n     };\n     return ids;\n }\n \n fn item_path(intr: @ident_interner, item_doc: ebml::Doc) -> ast_map::path {\n-    let path_doc = Reader::get_doc(item_doc, tag_path);\n+    let path_doc = reader::get_doc(item_doc, tag_path);\n \n-    let len_doc = Reader::get_doc(path_doc, tag_path_len);\n-    let len = Reader::doc_as_u32(len_doc) as uint;\n+    let len_doc = reader::get_doc(path_doc, tag_path_len);\n+    let len = reader::doc_as_u32(len_doc) as uint;\n \n     let mut result = vec::with_capacity(len);\n-    for Reader::docs(path_doc) |tag, elt_doc| {\n+    for reader::docs(path_doc) |tag, elt_doc| {\n         if tag == tag_path_elt_mod {\n-            let str = Reader::doc_as_str(elt_doc);\n+            let str = reader::doc_as_str(elt_doc);\n             result.push(ast_map::path_mod(intr.intern(@str)));\n         } else if tag == tag_path_elt_name {\n-            let str = Reader::doc_as_str(elt_doc);\n+            let str = reader::doc_as_str(elt_doc);\n             result.push(ast_map::path_name(intr.intern(@str)));\n         } else {\n             // ignore tag_path_len element\n@@ -328,8 +328,8 @@ fn item_path(intr: @ident_interner, item_doc: ebml::Doc) -> ast_map::path {\n }\n \n fn item_name(intr: @ident_interner, item: ebml::Doc) -> ast::ident {\n-    let name = Reader::get_doc(item, tag_paths_data_name);\n-    intr.intern(@str::from_bytes(Reader::doc_data(name)))\n+    let name = reader::get_doc(item, tag_paths_data_name);\n+    intr.intern(@str::from_bytes(reader::doc_data(name)))\n }\n \n fn item_to_def_like(item: ebml::Doc, did: ast::def_id, cnum: ast::crate_num)\n@@ -407,11 +407,11 @@ fn get_impl_traits(cdata: cmd, id: ast::node_id, tcx: ty::ctxt) -> ~[ty::t] {\n \n fn get_impl_method(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n                    name: ast::ident) -> ast::def_id {\n-    let items = Reader::get_doc(Reader::Doc(cdata.data), tag_items);\n+    let items = reader::get_doc(reader::Doc(cdata.data), tag_items);\n     let mut found = None;\n-    for Reader::tagged_docs(find_item(id, items), tag_item_impl_method)\n+    for reader::tagged_docs(find_item(id, items), tag_item_impl_method)\n         |mid| {\n-            let m_did = Reader::with_doc_data(mid, |d| parse_def_id(d));\n+            let m_did = reader::with_doc_data(mid, |d| parse_def_id(d));\n             if item_name(intr, find_item(m_did.node, items)) == name {\n                 found = Some(translate_def_id(cdata, m_did));\n             }\n@@ -421,14 +421,14 @@ fn get_impl_method(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n \n fn get_class_method(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n                     name: ast::ident) -> ast::def_id {\n-    let items = Reader::get_doc(Reader::Doc(cdata.data), tag_items);\n+    let items = reader::get_doc(reader::Doc(cdata.data), tag_items);\n     let mut found = None;\n     let cls_items = match maybe_find_item(id, items) {\n       Some(it) => it,\n       None => fail (fmt!(\"get_class_method: class id not found \\\n                               when looking up method %s\", *intr.get(name)))\n     };\n-    for Reader::tagged_docs(cls_items, tag_item_trait_method) |mid| {\n+    for reader::tagged_docs(cls_items, tag_item_trait_method) |mid| {\n         let m_did = item_def_id(mid, cdata);\n         if item_name(intr, mid) == name {\n             found = Some(m_did);\n@@ -442,16 +442,16 @@ fn get_class_method(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n }\n \n fn class_dtor(cdata: cmd, id: ast::node_id) -> Option<ast::def_id> {\n-    let items = Reader::get_doc(Reader::Doc(cdata.data), tag_items);\n+    let items = reader::get_doc(reader::Doc(cdata.data), tag_items);\n     let mut found = None;\n     let cls_items = match maybe_find_item(id, items) {\n             Some(it) => it,\n             None     => fail (fmt!(\"class_dtor: class id not found \\\n               when looking up dtor for %d\", id))\n     };\n-    for Reader::tagged_docs(cls_items, tag_item_dtor) |doc| {\n-         let doc1 = Reader::get_doc(doc, tag_def_id);\n-         let did = Reader::with_doc_data(doc1, |d| parse_def_id(d));\n+    for reader::tagged_docs(cls_items, tag_item_dtor) |doc| {\n+         let doc1 = reader::get_doc(doc, tag_def_id);\n+         let did = reader::with_doc_data(doc1, |d| parse_def_id(d));\n          found = Some(translate_def_id(cdata, did));\n     };\n     found\n@@ -495,14 +495,14 @@ fn path_entry(path_string: ~str, def_like: def_like) -> path_entry {\n fn each_path(intr: @ident_interner, cdata: cmd,\n              get_crate_data: GetCrateDataCb,\n              f: fn(path_entry) -> bool) {\n-    let root = Reader::Doc(cdata.data);\n-    let items = Reader::get_doc(root, tag_items);\n-    let items_data = Reader::get_doc(items, tag_items_data);\n+    let root = reader::Doc(cdata.data);\n+    let items = reader::get_doc(root, tag_items);\n+    let items_data = reader::get_doc(items, tag_items_data);\n \n     let mut broken = false;\n \n     // First, go through all the explicit items.\n-    for Reader::tagged_docs(items_data, tag_items_data_item) |item_doc| {\n+    for reader::tagged_docs(items_data, tag_items_data_item) |item_doc| {\n         if !broken {\n             let path = ast_map::path_to_str_with_sep(\n                 item_path(intr, item_doc), ~\"::\", intr);\n@@ -525,17 +525,17 @@ fn each_path(intr: @ident_interner, cdata: cmd,\n             for each_reexport(item_doc) |reexport_doc| {\n                 if !broken {\n                     let def_id_doc =\n-                        Reader::get_doc(reexport_doc,\n+                        reader::get_doc(reexport_doc,\n                             tag_items_data_item_reexport_def_id);\n                     let def_id =\n-                        Reader::with_doc_data(def_id_doc,\n+                        reader::with_doc_data(def_id_doc,\n                                               |d| parse_def_id(d));\n                     let def_id = translate_def_id(cdata, def_id);\n \n                     let reexport_name_doc =\n-                        Reader::get_doc(reexport_doc,\n+                        reader::get_doc(reexport_doc,\n                                       tag_items_data_item_reexport_name);\n-                    let reexport_name = Reader::doc_as_str(reexport_name_doc);\n+                    let reexport_name = reader::doc_as_str(reexport_name_doc);\n \n                     let reexport_path;\n                     if path == ~\"\" {\n@@ -549,8 +549,8 @@ fn each_path(intr: @ident_interner, cdata: cmd,\n                         items\n                     } else {\n                         let crate_data = get_crate_data(def_id.crate);\n-                        let root = Reader::Doc(crate_data.data);\n-                        Reader::get_doc(root, tag_items)\n+                        let root = reader::Doc(crate_data.data);\n+                        reader::get_doc(root, tag_items)\n                     };\n \n                     // Get the item.\n@@ -624,7 +624,7 @@ fn maybe_get_item_ast(intr: @ident_interner, cdata: cmd, tcx: ty::ctxt,\n fn get_enum_variants(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n                      tcx: ty::ctxt) -> ~[ty::VariantInfo] {\n     let data = cdata.data;\n-    let items = Reader::get_doc(Reader::Doc(data), tag_items);\n+    let items = reader::get_doc(reader::Doc(data), tag_items);\n     let item = find_item(id, items);\n     let mut infos: ~[ty::VariantInfo] = ~[];\n     let variant_ids = enum_variant_ids(item, cdata);\n@@ -676,8 +676,8 @@ fn get_self_ty(item: ebml::Doc) -> ast::self_ty_ {\n         }\n     }\n \n-    let self_type_doc = Reader::get_doc(item, tag_item_trait_method_self_ty);\n-    let string = Reader::doc_as_str(self_type_doc);\n+    let self_type_doc = reader::get_doc(item, tag_item_trait_method_self_ty);\n+    let string = reader::doc_as_str(self_type_doc);\n \n     let self_ty_kind = string[0];\n     match self_ty_kind as char {\n@@ -696,8 +696,8 @@ fn get_self_ty(item: ebml::Doc) -> ast::self_ty_ {\n fn item_impl_methods(intr: @ident_interner, cdata: cmd, item: ebml::Doc,\n                      base_tps: uint) -> ~[@method_info] {\n     let mut rslt = ~[];\n-    for Reader::tagged_docs(item, tag_item_impl_method) |doc| {\n-        let m_did = Reader::with_doc_data(doc, |d| parse_def_id(d));\n+    for reader::tagged_docs(item, tag_item_impl_method) |doc| {\n+        let m_did = reader::with_doc_data(doc, |d| parse_def_id(d));\n         let mth_item = lookup_item(m_did.node, cdata.data);\n         let self_ty = get_self_ty(mth_item);\n         rslt.push(@{did: translate_def_id(cdata, m_did),\n@@ -716,8 +716,8 @@ fn get_impls_for_mod(intr: @ident_interner, cdata: cmd,\n     let data = cdata.data;\n     let mod_item = lookup_item(m_id, data);\n     let mut result = ~[];\n-    for Reader::tagged_docs(mod_item, tag_mod_impl) |doc| {\n-        let did = Reader::with_doc_data(doc, |d| parse_def_id(d));\n+    for reader::tagged_docs(mod_item, tag_mod_impl) |doc| {\n+        let did = reader::with_doc_data(doc, |d| parse_def_id(d));\n         let local_did = translate_def_id(cdata, did);\n         debug!(\"(get impls for mod) getting did %? for '%?'\",\n                local_did, name);\n@@ -744,7 +744,7 @@ fn get_trait_methods(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n     let data = cdata.data;\n     let item = lookup_item(id, data);\n     let mut result = ~[];\n-    for Reader::tagged_docs(item, tag_item_trait_method) |mth| {\n+    for reader::tagged_docs(item, tag_item_trait_method) |mth| {\n         let bounds = item_ty_param_bounds(mth, tcx, cdata);\n         let name = item_name(intr, mth);\n         let ty = doc_type(mth, tcx, cdata);\n@@ -770,7 +770,7 @@ fn get_provided_trait_methods(intr: @ident_interner, cdata: cmd,\n     let item = lookup_item(id, data);\n     let mut result = ~[];\n \n-    for Reader::tagged_docs(item, tag_item_trait_method) |mth| {\n+    for reader::tagged_docs(item, tag_item_trait_method) |mth| {\n         if item_method_sort(mth) != 'p' { loop; }\n \n         let did = item_def_id(mth, cdata);\n@@ -806,7 +806,7 @@ fn get_provided_trait_methods(intr: @ident_interner, cdata: cmd,\n fn get_supertraits(cdata: cmd, id: ast::node_id, tcx: ty::ctxt) -> ~[ty::t] {\n     let results = dvec::DVec();\n     let item_doc = lookup_item(id, cdata.data);\n-    for Reader::tagged_docs(item_doc, tag_impl_trait) |trait_doc| {\n+    for reader::tagged_docs(item_doc, tag_impl_trait) |trait_doc| {\n         results.push(doc_type(trait_doc, tcx, cdata));\n     }\n     return dvec::unwrap(move results);\n@@ -825,7 +825,7 @@ fn get_method_names_if_trait(intr: @ident_interner, cdata: cmd,\n     }\n \n     let resulting_methods = @DVec();\n-    for Reader::tagged_docs(item, tag_item_trait_method) |method| {\n+    for reader::tagged_docs(item, tag_item_trait_method) |method| {\n         resulting_methods.push(\n             (item_name(intr, method), get_self_ty(method)));\n     }\n@@ -840,8 +840,8 @@ fn get_type_name_if_impl(intr: @ident_interner,\n         return None;\n     }\n \n-    for Reader::tagged_docs(item, tag_item_impl_type_basename) |doc| {\n-        return Some(intr.intern(@str::from_bytes(Reader::doc_data(doc))));\n+    for reader::tagged_docs(item, tag_item_impl_type_basename) |doc| {\n+        return Some(intr.intern(@str::from_bytes(reader::doc_data(doc))));\n     }\n \n     return None;\n@@ -857,13 +857,13 @@ fn get_static_methods_if_impl(intr: @ident_interner,\n     }\n \n     // If this impl has a trait ref, don't consider it.\n-    for Reader::tagged_docs(item, tag_impl_trait) |_doc| {\n+    for reader::tagged_docs(item, tag_impl_trait) |_doc| {\n         return None;\n     }\n \n     let impl_method_ids = DVec();\n-    for Reader::tagged_docs(item, tag_item_impl_method) |impl_method_doc| {\n-        impl_method_ids.push(parse_def_id(Reader::doc_data(impl_method_doc)));\n+    for reader::tagged_docs(item, tag_item_impl_method) |impl_method_doc| {\n+        impl_method_ids.push(parse_def_id(reader::doc_data(impl_method_doc)));\n     }\n \n     let static_impl_methods = DVec();\n@@ -898,8 +898,8 @@ fn get_item_attrs(cdata: cmd,\n                   f: fn(~[@ast::meta_item])) {\n \n     let item = lookup_item(node_id, cdata.data);\n-    for Reader::tagged_docs(item, tag_attributes) |attributes| {\n-        for Reader::tagged_docs(attributes, tag_attribute) |attribute| {\n+    for reader::tagged_docs(item, tag_attributes) |attributes| {\n+        for reader::tagged_docs(attributes, tag_attribute) |attribute| {\n             f(get_meta_items(attribute));\n         }\n     }\n@@ -911,7 +911,7 @@ fn get_class_members(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n     let data = cdata.data;\n     let item = lookup_item(id, data);\n     let mut result = ~[];\n-    for Reader::tagged_docs(item, tag_item_field) |an_item| {\n+    for reader::tagged_docs(item, tag_item_field) |an_item| {\n        let f = item_family(an_item);\n        if p(f) {\n           let name = item_name(intr, an_item);\n@@ -952,7 +952,7 @@ fn family_names_type(fam: Family) -> bool {\n }\n \n fn read_path(d: ebml::Doc) -> {path: ~str, pos: uint} {\n-    let desc = Reader::doc_data(d);\n+    let desc = reader::doc_data(d);\n     let pos = io::u64_from_be_bytes(desc, 0u, 4u) as uint;\n     let pathbytes = vec::slice::<u8>(desc, 4u, vec::len::<u8>(desc));\n     let path = str::from_bytes(pathbytes);\n@@ -995,23 +995,23 @@ fn item_family_to_str(fam: Family) -> ~str {\n \n fn get_meta_items(md: ebml::Doc) -> ~[@ast::meta_item] {\n     let mut items: ~[@ast::meta_item] = ~[];\n-    for Reader::tagged_docs(md, tag_meta_item_word) |meta_item_doc| {\n-        let nd = Reader::get_doc(meta_item_doc, tag_meta_item_name);\n-        let n = str::from_bytes(Reader::doc_data(nd));\n+    for reader::tagged_docs(md, tag_meta_item_word) |meta_item_doc| {\n+        let nd = reader::get_doc(meta_item_doc, tag_meta_item_name);\n+        let n = str::from_bytes(reader::doc_data(nd));\n         items.push(attr::mk_word_item(n));\n     };\n-    for Reader::tagged_docs(md, tag_meta_item_name_value) |meta_item_doc| {\n-        let nd = Reader::get_doc(meta_item_doc, tag_meta_item_name);\n-        let vd = Reader::get_doc(meta_item_doc, tag_meta_item_value);\n-        let n = str::from_bytes(Reader::doc_data(nd));\n-        let v = str::from_bytes(Reader::doc_data(vd));\n+    for reader::tagged_docs(md, tag_meta_item_name_value) |meta_item_doc| {\n+        let nd = reader::get_doc(meta_item_doc, tag_meta_item_name);\n+        let vd = reader::get_doc(meta_item_doc, tag_meta_item_value);\n+        let n = str::from_bytes(reader::doc_data(nd));\n+        let v = str::from_bytes(reader::doc_data(vd));\n         // FIXME (#623): Should be able to decode meta_name_value variants,\n         // but currently the encoder just drops them\n         items.push(attr::mk_name_value_item_str(n, v));\n     };\n-    for Reader::tagged_docs(md, tag_meta_item_list) |meta_item_doc| {\n-        let nd = Reader::get_doc(meta_item_doc, tag_meta_item_name);\n-        let n = str::from_bytes(Reader::doc_data(nd));\n+    for reader::tagged_docs(md, tag_meta_item_list) |meta_item_doc| {\n+        let nd = reader::get_doc(meta_item_doc, tag_meta_item_name);\n+        let n = str::from_bytes(reader::doc_data(nd));\n         let subitems = get_meta_items(meta_item_doc);\n         items.push(attr::mk_list_item(n, subitems));\n     };\n@@ -1020,9 +1020,9 @@ fn get_meta_items(md: ebml::Doc) -> ~[@ast::meta_item] {\n \n fn get_attributes(md: ebml::Doc) -> ~[ast::attribute] {\n     let mut attrs: ~[ast::attribute] = ~[];\n-    match Reader::maybe_get_doc(md, tag_attributes) {\n+    match reader::maybe_get_doc(md, tag_attributes) {\n       option::Some(attrs_d) => {\n-        for Reader::tagged_docs(attrs_d, tag_attribute) |attr_doc| {\n+        for reader::tagged_docs(attrs_d, tag_attribute) |attr_doc| {\n             let meta_items = get_meta_items(attr_doc);\n             // Currently it's only possible to have a single meta item on\n             // an attribute\n@@ -1058,21 +1058,21 @@ fn list_crate_attributes(intr: @ident_interner, md: ebml::Doc, hash: ~str,\n }\n \n fn get_crate_attributes(data: @~[u8]) -> ~[ast::attribute] {\n-    return get_attributes(Reader::Doc(data));\n+    return get_attributes(reader::Doc(data));\n }\n \n type crate_dep = {cnum: ast::crate_num, name: ast::ident,\n                   vers: ~str, hash: ~str};\n \n fn get_crate_deps(intr: @ident_interner, data: @~[u8]) -> ~[crate_dep] {\n     let mut deps: ~[crate_dep] = ~[];\n-    let cratedoc = Reader::Doc(data);\n-    let depsdoc = Reader::get_doc(cratedoc, tag_crate_deps);\n+    let cratedoc = reader::Doc(data);\n+    let depsdoc = reader::get_doc(cratedoc, tag_crate_deps);\n     let mut crate_num = 1;\n     fn docstr(doc: ebml::Doc, tag_: uint) -> ~str {\n-        str::from_bytes(Reader::doc_data(Reader::get_doc(doc, tag_)))\n+        str::from_bytes(reader::doc_data(reader::get_doc(doc, tag_)))\n     }\n-    for Reader::tagged_docs(depsdoc, tag_crate_dep) |depdoc| {\n+    for reader::tagged_docs(depsdoc, tag_crate_dep) |depdoc| {\n         deps.push({cnum: crate_num,\n                   name: intr.intern(@docstr(depdoc, tag_crate_dep_name)),\n                   vers: docstr(depdoc, tag_crate_dep_vers),\n@@ -1095,9 +1095,9 @@ fn list_crate_deps(intr: @ident_interner, data: @~[u8], out: io::Writer) {\n }\n \n fn get_crate_hash(data: @~[u8]) -> ~str {\n-    let cratedoc = Reader::Doc(data);\n-    let hashdoc = Reader::get_doc(cratedoc, tag_crate_hash);\n-    return str::from_bytes(Reader::doc_data(hashdoc));\n+    let cratedoc = reader::Doc(data);\n+    let hashdoc = reader::get_doc(cratedoc, tag_crate_hash);\n+    return str::from_bytes(reader::doc_data(hashdoc));\n }\n \n fn get_crate_vers(data: @~[u8]) -> ~str {\n@@ -1153,7 +1153,7 @@ fn get_crate_module_paths(intr: @ident_interner, cdata: cmd,\n fn list_crate_metadata(intr: @ident_interner, bytes: @~[u8],\n                        out: io::Writer) {\n     let hash = get_crate_hash(bytes);\n-    let md = Reader::Doc(bytes);\n+    let md = reader::Doc(bytes);\n     list_crate_attributes(intr, md, hash, out);\n     list_crate_deps(intr, bytes, out);\n }"}, {"sha": "acfbcc947d6a8382bdf5acb619906fbbb5bab30e", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/d2ad028a7c70866df375172a2377bdf966b25d9d/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ad028a7c70866df375172a2377bdf966b25d9d/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=d2ad028a7c70866df375172a2377bdf966b25d9d", "patch": "@@ -15,7 +15,7 @@ use util::ppaux::ty_to_str;\n use std::{ebml, map};\n use std::map::HashMap;\n use io::WriterUtil;\n-use Writer = ebml::Writer;\n+use writer = ebml::writer;\n use syntax::ast::*;\n use syntax::print::pprust;\n use syntax::{ast_util, visit};\n@@ -50,7 +50,7 @@ export encode_def_id;\n type abbrev_map = map::HashMap<ty::t, tyencode::ty_abbrev>;\n \n type encode_inlined_item = fn@(ecx: @encode_ctxt,\n-                               ebml_w: Writer::Serializer,\n+                               ebml_w: writer::Serializer,\n                                path: ast_map::path,\n                                ii: ast::inlined_item);\n \n@@ -96,21 +96,21 @@ fn reachable(ecx: @encode_ctxt, id: node_id) -> bool {\n     ecx.reachable.contains_key(id)\n }\n \n-fn encode_name(ecx: @encode_ctxt, ebml_w: Writer::Serializer, name: ident) {\n+fn encode_name(ecx: @encode_ctxt, ebml_w: writer::Serializer, name: ident) {\n     ebml_w.wr_tagged_str(tag_paths_data_name, ecx.tcx.sess.str_of(name));\n }\n \n-fn encode_impl_type_basename(ecx: @encode_ctxt, ebml_w: Writer::Serializer,\n+fn encode_impl_type_basename(ecx: @encode_ctxt, ebml_w: writer::Serializer,\n                              name: ident) {\n     ebml_w.wr_tagged_str(tag_item_impl_type_basename,\n                          ecx.tcx.sess.str_of(name));\n }\n \n-fn encode_def_id(ebml_w: Writer::Serializer, id: def_id) {\n+fn encode_def_id(ebml_w: writer::Serializer, id: def_id) {\n     ebml_w.wr_tagged_str(tag_def_id, def_to_str(id));\n }\n \n-fn encode_region_param(ecx: @encode_ctxt, ebml_w: Writer::Serializer,\n+fn encode_region_param(ecx: @encode_ctxt, ebml_w: writer::Serializer,\n                        it: @ast::item) {\n     let opt_rp = ecx.tcx.region_paramd_items.find(it.id);\n     for opt_rp.each |rp| {\n@@ -120,7 +120,7 @@ fn encode_region_param(ecx: @encode_ctxt, ebml_w: Writer::Serializer,\n     }\n }\n \n-fn encode_mutability(ebml_w: Writer::Serializer, mt: class_mutability) {\n+fn encode_mutability(ebml_w: writer::Serializer, mt: class_mutability) {\n     do ebml_w.wr_tag(tag_class_mut) {\n         let val = match mt {\n           class_immutable => 'a',\n@@ -132,7 +132,7 @@ fn encode_mutability(ebml_w: Writer::Serializer, mt: class_mutability) {\n \n type entry<T> = {val: T, pos: uint};\n \n-fn add_to_index(ecx: @encode_ctxt, ebml_w: Writer::Serializer, path: &[ident],\n+fn add_to_index(ecx: @encode_ctxt, ebml_w: writer::Serializer, path: &[ident],\n                 index: &mut ~[entry<~str>], name: ident) {\n     let mut full_path = ~[];\n     full_path.push_all(path);\n@@ -143,7 +143,7 @@ fn add_to_index(ecx: @encode_ctxt, ebml_w: Writer::Serializer, path: &[ident],\n          pos: ebml_w.writer.tell()});\n }\n \n-fn encode_trait_ref(ebml_w: Writer::Serializer, ecx: @encode_ctxt,\n+fn encode_trait_ref(ebml_w: writer::Serializer, ecx: @encode_ctxt,\n                     t: @trait_ref) {\n     ebml_w.start_tag(tag_impl_trait);\n     encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, t.ref_id));\n@@ -152,15 +152,15 @@ fn encode_trait_ref(ebml_w: Writer::Serializer, ecx: @encode_ctxt,\n \n \n // Item info table encoding\n-fn encode_family(ebml_w: Writer::Serializer, c: char) {\n+fn encode_family(ebml_w: writer::Serializer, c: char) {\n     ebml_w.start_tag(tag_items_data_item_family);\n     ebml_w.writer.write(&[c as u8]);\n     ebml_w.end_tag();\n }\n \n fn def_to_str(did: def_id) -> ~str { fmt!(\"%d:%d\", did.crate, did.node) }\n \n-fn encode_ty_type_param_bounds(ebml_w: Writer::Serializer, ecx: @encode_ctxt,\n+fn encode_ty_type_param_bounds(ebml_w: writer::Serializer, ecx: @encode_ctxt,\n                                params: @~[ty::param_bounds]) {\n     let ty_str_ctxt = @{diag: ecx.diag,\n                         ds: def_to_str,\n@@ -174,21 +174,21 @@ fn encode_ty_type_param_bounds(ebml_w: Writer::Serializer, ecx: @encode_ctxt,\n     }\n }\n \n-fn encode_type_param_bounds(ebml_w: Writer::Serializer, ecx: @encode_ctxt,\n+fn encode_type_param_bounds(ebml_w: writer::Serializer, ecx: @encode_ctxt,\n                             params: ~[ty_param]) {\n     let ty_param_bounds =\n         @params.map(|param| ecx.tcx.ty_param_bounds.get(param.id));\n     encode_ty_type_param_bounds(ebml_w, ecx, ty_param_bounds);\n }\n \n \n-fn encode_variant_id(ebml_w: Writer::Serializer, vid: def_id) {\n+fn encode_variant_id(ebml_w: writer::Serializer, vid: def_id) {\n     ebml_w.start_tag(tag_items_data_item_variant);\n     ebml_w.writer.write(str::to_bytes(def_to_str(vid)));\n     ebml_w.end_tag();\n }\n \n-fn write_type(ecx: @encode_ctxt, ebml_w: Writer::Serializer, typ: ty::t) {\n+fn write_type(ecx: @encode_ctxt, ebml_w: writer::Serializer, typ: ty::t) {\n     let ty_str_ctxt =\n         @{diag: ecx.diag,\n           ds: def_to_str,\n@@ -198,7 +198,7 @@ fn write_type(ecx: @encode_ctxt, ebml_w: Writer::Serializer, typ: ty::t) {\n     tyencode::enc_ty(ebml_w.writer, ty_str_ctxt, typ);\n }\n \n-fn write_vstore(ecx: @encode_ctxt, ebml_w: Writer::Serializer,\n+fn write_vstore(ecx: @encode_ctxt, ebml_w: writer::Serializer,\n                 vstore: ty::vstore) {\n     let ty_str_ctxt =\n         @{diag: ecx.diag,\n@@ -209,13 +209,13 @@ fn write_vstore(ecx: @encode_ctxt, ebml_w: Writer::Serializer,\n     tyencode::enc_vstore(ebml_w.writer, ty_str_ctxt, vstore);\n }\n \n-fn encode_type(ecx: @encode_ctxt, ebml_w: Writer::Serializer, typ: ty::t) {\n+fn encode_type(ecx: @encode_ctxt, ebml_w: writer::Serializer, typ: ty::t) {\n     ebml_w.start_tag(tag_items_data_item_type);\n     write_type(ecx, ebml_w, typ);\n     ebml_w.end_tag();\n }\n \n-fn encode_symbol(ecx: @encode_ctxt, ebml_w: Writer::Serializer, id: node_id) {\n+fn encode_symbol(ecx: @encode_ctxt, ebml_w: writer::Serializer, id: node_id) {\n     ebml_w.start_tag(tag_items_data_item_symbol);\n     let sym = match ecx.item_symbols.find(id) {\n       Some(ref x) => (*x),\n@@ -228,27 +228,27 @@ fn encode_symbol(ecx: @encode_ctxt, ebml_w: Writer::Serializer, id: node_id) {\n     ebml_w.end_tag();\n }\n \n-fn encode_discriminant(ecx: @encode_ctxt, ebml_w: Writer::Serializer,\n+fn encode_discriminant(ecx: @encode_ctxt, ebml_w: writer::Serializer,\n                        id: node_id) {\n     ebml_w.start_tag(tag_items_data_item_symbol);\n     ebml_w.writer.write(str::to_bytes(ecx.discrim_symbols.get(id)));\n     ebml_w.end_tag();\n }\n \n-fn encode_disr_val(_ecx: @encode_ctxt, ebml_w: Writer::Serializer,\n+fn encode_disr_val(_ecx: @encode_ctxt, ebml_w: writer::Serializer,\n                    disr_val: int) {\n     ebml_w.start_tag(tag_disr_val);\n     ebml_w.writer.write(str::to_bytes(int::to_str(disr_val,10u)));\n     ebml_w.end_tag();\n }\n \n-fn encode_parent_item(ebml_w: Writer::Serializer, id: def_id) {\n+fn encode_parent_item(ebml_w: writer::Serializer, id: def_id) {\n     ebml_w.start_tag(tag_items_data_parent_item);\n     ebml_w.writer.write(str::to_bytes(def_to_str(id)));\n     ebml_w.end_tag();\n }\n \n-fn encode_enum_variant_info(ecx: @encode_ctxt, ebml_w: Writer::Serializer,\n+fn encode_enum_variant_info(ecx: @encode_ctxt, ebml_w: writer::Serializer,\n                             id: node_id, variants: ~[variant],\n                             path: ast_map::path, index: @mut ~[entry<int>],\n                             ty_params: ~[ty_param]) {\n@@ -285,9 +285,9 @@ fn encode_enum_variant_info(ecx: @encode_ctxt, ebml_w: Writer::Serializer,\n     }\n }\n \n-fn encode_path(ecx: @encode_ctxt, ebml_w: Writer::Serializer,\n+fn encode_path(ecx: @encode_ctxt, ebml_w: writer::Serializer,\n                path: ast_map::path, name: ast_map::path_elt) {\n-    fn encode_path_elt(ecx: @encode_ctxt, ebml_w: Writer::Serializer,\n+    fn encode_path_elt(ecx: @encode_ctxt, ebml_w: writer::Serializer,\n                        elt: ast_map::path_elt) {\n         let (tag, name) = match elt {\n           ast_map::path_mod(name) => (tag_path_elt_mod, name),\n@@ -306,7 +306,7 @@ fn encode_path(ecx: @encode_ctxt, ebml_w: Writer::Serializer,\n     }\n }\n \n-fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: Writer::Serializer,\n+fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: writer::Serializer,\n                        md: _mod, id: node_id, path: ast_map::path,\n                        name: ident) {\n     ebml_w.start_tag(tag_items_data_item);\n@@ -365,15 +365,15 @@ fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: Writer::Serializer,\n     ebml_w.end_tag();\n }\n \n-fn encode_visibility(ebml_w: Writer::Serializer, visibility: visibility) {\n+fn encode_visibility(ebml_w: writer::Serializer, visibility: visibility) {\n     encode_family(ebml_w, match visibility {\n         public => 'g',\n         private => 'j',\n         inherited => 'N'\n     });\n }\n \n-fn encode_self_type(ebml_w: Writer::Serializer, self_type: ast::self_ty_) {\n+fn encode_self_type(ebml_w: writer::Serializer, self_type: ast::self_ty_) {\n     ebml_w.start_tag(tag_item_trait_method_self_ty);\n \n     // Encode the base self type.\n@@ -405,14 +405,14 @@ fn encode_self_type(ebml_w: Writer::Serializer, self_type: ast::self_ty_) {\n     ebml_w.end_tag();\n }\n \n-fn encode_method_sort(ebml_w: Writer::Serializer, sort: char) {\n+fn encode_method_sort(ebml_w: writer::Serializer, sort: char) {\n     ebml_w.start_tag(tag_item_trait_method_sort);\n     ebml_w.writer.write(&[ sort as u8 ]);\n     ebml_w.end_tag();\n }\n \n /* Returns an index of items in this class */\n-fn encode_info_for_class(ecx: @encode_ctxt, ebml_w: Writer::Serializer,\n+fn encode_info_for_class(ecx: @encode_ctxt, ebml_w: writer::Serializer,\n                          id: node_id, path: ast_map::path,\n                          class_tps: ~[ty_param],\n                          fields: ~[@struct_field],\n@@ -468,7 +468,7 @@ fn encode_info_for_class(ecx: @encode_ctxt, ebml_w: Writer::Serializer,\n }\n \n // This is for encoding info for ctors and dtors\n-fn encode_info_for_ctor(ecx: @encode_ctxt, ebml_w: Writer::Serializer,\n+fn encode_info_for_ctor(ecx: @encode_ctxt, ebml_w: writer::Serializer,\n                         id: node_id, ident: ident, path: ast_map::path,\n                         item: Option<inlined_item>, tps: ~[ty_param]) {\n         ebml_w.start_tag(tag_items_data_item);\n@@ -493,7 +493,7 @@ fn encode_info_for_ctor(ecx: @encode_ctxt, ebml_w: Writer::Serializer,\n         ebml_w.end_tag();\n }\n \n-fn encode_info_for_method(ecx: @encode_ctxt, ebml_w: Writer::Serializer,\n+fn encode_info_for_method(ecx: @encode_ctxt, ebml_w: writer::Serializer,\n                           impl_path: ast_map::path, should_inline: bool,\n                           parent_id: node_id,\n                           m: @method, all_tps: ~[ty_param]) {\n@@ -548,7 +548,7 @@ fn should_inline(attrs: ~[attribute]) -> bool {\n }\n \n \n-fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: Writer::Serializer,\n+fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: writer::Serializer,\n                         item: @item, index: @mut ~[entry<int>],\n                         path: ast_map::path) {\n \n@@ -561,7 +561,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: Writer::Serializer,\n         };\n     if !must_write && !reachable(ecx, item.id) { return; }\n \n-    fn add_to_index_(item: @item, ebml_w: Writer::Serializer,\n+    fn add_to_index_(item: @item, ebml_w: writer::Serializer,\n                      index: @mut ~[entry<int>]) {\n         index.push({val: item.id, pos: ebml_w.writer.tell()});\n     }\n@@ -851,7 +851,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: Writer::Serializer,\n     }\n }\n \n-fn encode_info_for_foreign_item(ecx: @encode_ctxt, ebml_w: Writer::Serializer,\n+fn encode_info_for_foreign_item(ecx: @encode_ctxt, ebml_w: writer::Serializer,\n                                 nitem: @foreign_item,\n                                 index: @mut ~[entry<int>],\n                                 path: ast_map::path, abi: foreign_abi) {\n@@ -884,7 +884,7 @@ fn encode_info_for_foreign_item(ecx: @encode_ctxt, ebml_w: Writer::Serializer,\n     ebml_w.end_tag();\n }\n \n-fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: Writer::Serializer,\n+fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: writer::Serializer,\n                          crate: @crate) -> ~[entry<int>] {\n     let index = @mut ~[];\n     ebml_w.start_tag(tag_items_data);\n@@ -939,7 +939,7 @@ fn create_index<T: Copy Hash IterBytes>(index: ~[entry<T>]) ->\n     return buckets_frozen;\n }\n \n-fn encode_index<T>(ebml_w: Writer::Serializer, buckets: ~[@~[entry<T>]],\n+fn encode_index<T>(ebml_w: writer::Serializer, buckets: ~[@~[entry<T>]],\n                    write_fn: fn(io::Writer, T)) {\n     let writer = ebml_w.writer;\n     ebml_w.start_tag(tag_index);\n@@ -974,7 +974,7 @@ fn write_int(writer: io::Writer, &&n: int) {\n     writer.write_be_u32(n as u32);\n }\n \n-fn encode_meta_item(ebml_w: Writer::Serializer, mi: meta_item) {\n+fn encode_meta_item(ebml_w: writer::Serializer, mi: meta_item) {\n     match mi.node {\n       meta_word(ref name) => {\n         ebml_w.start_tag(tag_meta_item_word);\n@@ -1011,7 +1011,7 @@ fn encode_meta_item(ebml_w: Writer::Serializer, mi: meta_item) {\n     }\n }\n \n-fn encode_attributes(ebml_w: Writer::Serializer, attrs: ~[attribute]) {\n+fn encode_attributes(ebml_w: writer::Serializer, attrs: ~[attribute]) {\n     ebml_w.start_tag(tag_attributes);\n     for attrs.each |attr| {\n         ebml_w.start_tag(tag_attribute);\n@@ -1072,7 +1072,7 @@ fn synthesize_crate_attrs(ecx: @encode_ctxt, crate: @crate) -> ~[attribute] {\n     return attrs;\n }\n \n-fn encode_crate_deps(ecx: @encode_ctxt, ebml_w: Writer::Serializer,\n+fn encode_crate_deps(ecx: @encode_ctxt, ebml_w: writer::Serializer,\n                      cstore: cstore::CStore) {\n \n     fn get_ordered_deps(ecx: @encode_ctxt, cstore: cstore::CStore)\n@@ -1118,7 +1118,7 @@ fn encode_crate_deps(ecx: @encode_ctxt, ebml_w: Writer::Serializer,\n     ebml_w.end_tag();\n }\n \n-fn encode_crate_dep(ecx: @encode_ctxt, ebml_w: Writer::Serializer,\n+fn encode_crate_dep(ecx: @encode_ctxt, ebml_w: writer::Serializer,\n                     dep: decoder::crate_dep) {\n     ebml_w.start_tag(tag_crate_dep);\n     ebml_w.start_tag(tag_crate_dep_name);\n@@ -1133,7 +1133,7 @@ fn encode_crate_dep(ecx: @encode_ctxt, ebml_w: Writer::Serializer,\n     ebml_w.end_tag();\n }\n \n-fn encode_hash(ebml_w: Writer::Serializer, hash: ~str) {\n+fn encode_hash(ebml_w: writer::Serializer, hash: ~str) {\n     ebml_w.start_tag(tag_crate_hash);\n     ebml_w.writer.write(str::to_bytes(hash));\n     ebml_w.end_tag();\n@@ -1171,7 +1171,7 @@ fn encode_metadata(parms: encode_parms, crate: @crate) -> ~[u8] {\n         type_abbrevs: ty::new_ty_hash()\n      });\n \n-    let ebml_w = Writer::Serializer(wr as io::Writer);\n+    let ebml_w = writer::Serializer(wr as io::Writer);\n \n     encode_hash(ebml_w, ecx.link_meta.extras_hash);\n "}, {"sha": "8c0bc8a2983515a8e2a235b64bc54efe50fe3c90", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/d2ad028a7c70866df375172a2377bdf966b25d9d/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ad028a7c70866df375172a2377bdf966b25d9d/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=d2ad028a7c70866df375172a2377bdf966b25d9d", "patch": "@@ -18,10 +18,10 @@ use syntax::ast_map;\n use syntax::ast_util;\n use syntax::codemap::span;\n use std::ebml;\n-use Writer = std::ebml::Writer;\n-use Reader = std::ebml::Reader;\n-use Reader::get_doc;\n-use Writer::Serializer;\n+use writer = std::ebml::writer;\n+use reader = std::ebml::reader;\n+use reader::get_doc;\n+use writer::Serializer;\n use std::map::HashMap;\n use std::serialization;\n use std::serialization::{Serializable,\n@@ -90,7 +90,7 @@ trait tr_intern {\n // Top-level methods.\n \n fn encode_inlined_item(ecx: @e::encode_ctxt,\n-                       ebml_w: Writer::Serializer,\n+                       ebml_w: writer::Serializer,\n                        path: ast_map::path,\n                        ii: ast::inlined_item,\n                        maps: maps) {\n@@ -123,7 +123,7 @@ fn decode_inlined_item(cdata: cstore::crate_metadata,\n       Some(ast_doc) => {\n         debug!(\"> Decoding inlined fn: %s::?\",\n                ast_map::path_to_str(path, tcx.sess.parse_sess.interner));\n-        let ast_dsr = &Reader::Deserializer(ast_doc);\n+        let ast_dsr = &reader::Deserializer(ast_doc);\n         let from_id_range = deserialize(ast_dsr);\n         let to_id_range = reserve_id_range(dcx.tcx.sess, from_id_range);\n         let xcx = extended_decode_ctxt_(@{dcx: dcx,\n@@ -237,7 +237,7 @@ impl<D: serialization::Deserializer> D: def_id_deserializer_helpers {\n // We also have to adjust the spans: for now we just insert a dummy span,\n // but eventually we should add entries to the local codemap as required.\n \n-fn encode_ast(ebml_w: Writer::Serializer, item: ast::inlined_item) {\n+fn encode_ast(ebml_w: writer::Serializer, item: ast::inlined_item) {\n     do ebml_w.wr_tag(c::tag_tree as uint) {\n         item.serialize(&ebml_w)\n     }\n@@ -293,7 +293,7 @@ fn simplify_ast(ii: ast::inlined_item) -> ast::inlined_item {\n \n fn decode_ast(par_doc: ebml::Doc) -> ast::inlined_item {\n     let chi_doc = par_doc[c::tag_tree as uint];\n-    let d = &Reader::Deserializer(chi_doc);\n+    let d = &reader::Deserializer(chi_doc);\n     deserialize(d)\n }\n \n@@ -333,12 +333,12 @@ fn renumber_ast(xcx: extended_decode_ctxt, ii: ast::inlined_item)\n // ______________________________________________________________________\n // Encoding and decoding of ast::def\n \n-fn encode_def(ebml_w: Writer::Serializer, def: ast::def) {\n+fn encode_def(ebml_w: writer::Serializer, def: ast::def) {\n     def.serialize(&ebml_w)\n }\n \n fn decode_def(xcx: extended_decode_ctxt, doc: ebml::Doc) -> ast::def {\n-    let dsr = &Reader::Deserializer(doc);\n+    let dsr = &reader::Deserializer(doc);\n     let def: ast::def = deserialize(dsr);\n     def.tr(xcx)\n }\n@@ -426,15 +426,15 @@ impl ty::bound_region: tr {\n // ______________________________________________________________________\n // Encoding and decoding of freevar information\n \n-fn encode_freevar_entry(ebml_w: Writer::Serializer, fv: @freevar_entry) {\n+fn encode_freevar_entry(ebml_w: writer::Serializer, fv: @freevar_entry) {\n     (*fv).serialize(&ebml_w)\n }\n \n trait ebml_deserializer_helper {\n     fn read_freevar_entry(xcx: extended_decode_ctxt) -> freevar_entry;\n }\n \n-impl Reader::Deserializer: ebml_deserializer_helper {\n+impl reader::Deserializer: ebml_deserializer_helper {\n     fn read_freevar_entry(xcx: extended_decode_ctxt) -> freevar_entry {\n         let fv: freevar_entry = deserialize(&self);\n         fv.tr(xcx)\n@@ -455,7 +455,7 @@ trait read_method_map_entry_helper {\n }\n \n fn serialize_method_map_entry(ecx: @e::encode_ctxt,\n-                              ebml_w: Writer::Serializer,\n+                              ebml_w: writer::Serializer,\n                               mme: method_map_entry) {\n     do ebml_w.emit_rec {\n         do ebml_w.emit_field(~\"self_arg\", 0u) {\n@@ -470,7 +470,7 @@ fn serialize_method_map_entry(ecx: @e::encode_ctxt,\n     }\n }\n \n-impl Reader::Deserializer: read_method_map_entry_helper {\n+impl reader::Deserializer: read_method_map_entry_helper {\n     fn read_method_map_entry(xcx: extended_decode_ctxt) -> method_map_entry {\n         do self.read_rec {\n             {self_arg:\n@@ -514,7 +514,7 @@ impl method_origin: tr {\n // Encoding and decoding vtable_res\n \n fn encode_vtable_res(ecx: @e::encode_ctxt,\n-                     ebml_w: Writer::Serializer,\n+                     ebml_w: writer::Serializer,\n                      dr: typeck::vtable_res) {\n     // can't autogenerate this code because automatic serialization of\n     // ty::t doesn't work, and there is no way (atm) to have\n@@ -526,7 +526,7 @@ fn encode_vtable_res(ecx: @e::encode_ctxt,\n }\n \n fn encode_vtable_origin(ecx: @e::encode_ctxt,\n-                      ebml_w: Writer::Serializer,\n+                      ebml_w: writer::Serializer,\n                       vtable_origin: typeck::vtable_origin) {\n     do ebml_w.emit_enum(~\"vtable_origin\") {\n         match vtable_origin {\n@@ -573,7 +573,7 @@ trait vtable_deserialization_helpers {\n     fn read_vtable_origin(xcx: extended_decode_ctxt) -> typeck::vtable_origin;\n }\n \n-impl Reader::Deserializer: vtable_deserialization_helpers {\n+impl reader::Deserializer: vtable_deserialization_helpers {\n     fn read_vtable_res(xcx: extended_decode_ctxt) -> typeck::vtable_res {\n         @self.read_to_vec(|| self.read_vtable_origin(xcx) )\n     }\n@@ -650,7 +650,7 @@ trait ebml_writer_helpers {\n     fn emit_tpbt(ecx: @e::encode_ctxt, tpbt: ty::ty_param_bounds_and_ty);\n }\n \n-impl Writer::Serializer: ebml_writer_helpers {\n+impl writer::Serializer: ebml_writer_helpers {\n     fn emit_ty(ecx: @e::encode_ctxt, ty: ty::t) {\n         do self.emit_opaque {\n             e::write_type(ecx, self, ty)\n@@ -703,7 +703,7 @@ trait write_tag_and_id {\n     fn id(id: ast::node_id);\n }\n \n-impl Writer::Serializer: write_tag_and_id {\n+impl writer::Serializer: write_tag_and_id {\n     fn tag(tag_id: c::astencode_tag, f: fn()) {\n         do self.wr_tag(tag_id as uint) { f() }\n     }\n@@ -715,7 +715,7 @@ impl Writer::Serializer: write_tag_and_id {\n \n fn encode_side_tables_for_ii(ecx: @e::encode_ctxt,\n                              maps: maps,\n-                             ebml_w: Writer::Serializer,\n+                             ebml_w: writer::Serializer,\n                              ii: ast::inlined_item) {\n     do ebml_w.wr_tag(c::tag_table as uint) {\n         ast_util::visit_ids_for_inlined_item(\n@@ -731,7 +731,7 @@ fn encode_side_tables_for_ii(ecx: @e::encode_ctxt,\n \n fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n                              maps: maps,\n-                             ebml_w: Writer::Serializer,\n+                             ebml_w: writer::Serializer,\n                              id: ast::node_id) {\n     let tcx = ecx.tcx;\n \n@@ -873,9 +873,9 @@ trait doc_decoder_helpers {\n }\n \n impl ebml::Doc: doc_decoder_helpers {\n-    fn as_int() -> int { Reader::doc_as_u64(self) as int }\n+    fn as_int() -> int { reader::doc_as_u64(self) as int }\n     fn opt_child(tag: c::astencode_tag) -> Option<ebml::Doc> {\n-        Reader::maybe_get_doc(self, tag as uint)\n+        reader::maybe_get_doc(self, tag as uint)\n     }\n }\n \n@@ -888,7 +888,7 @@ trait ebml_deserializer_decoder_helpers {\n                                 -> ty::ty_param_bounds_and_ty;\n }\n \n-impl Reader::Deserializer: ebml_deserializer_decoder_helpers {\n+impl reader::Deserializer: ebml_deserializer_decoder_helpers {\n \n     fn read_arg(xcx: extended_decode_ctxt) -> ty::arg {\n         do self.read_opaque |doc| {\n@@ -946,7 +946,7 @@ fn decode_side_tables(xcx: extended_decode_ctxt,\n                       ast_doc: ebml::Doc) {\n     let dcx = xcx.dcx;\n     let tbl_doc = ast_doc[c::tag_table as uint];\n-    for Reader::docs(tbl_doc) |tag, entry_doc| {\n+    for reader::docs(tbl_doc) |tag, entry_doc| {\n         let id0 = entry_doc[c::tag_table_id as uint].as_int();\n         let id = xcx.tr_id(id0);\n \n@@ -960,7 +960,7 @@ fn decode_side_tables(xcx: extended_decode_ctxt,\n             dcx.tcx.legacy_boxed_traits.insert(id, ());\n         } else {\n             let val_doc = entry_doc[c::tag_table_val as uint];\n-            let val_dsr = &Reader::Deserializer(val_doc);\n+            let val_dsr = &reader::Deserializer(val_doc);\n             if tag == (c::tag_table_def as uint) {\n                 let def = decode_def(xcx, val_doc);\n                 dcx.tcx.def_map.insert(id, def);\n@@ -1016,7 +1016,7 @@ fn decode_side_tables(xcx: extended_decode_ctxt,\n // Testing of astencode_gen\n \n #[cfg(test)]\n-fn encode_item_ast(ebml_w: Writer::Serializer, item: @ast::item) {\n+fn encode_item_ast(ebml_w: writer::Serializer, item: @ast::item) {\n     do ebml_w.wr_tag(c::tag_tree as uint) {\n         (*item).serialize(&ebml_w)\n     }\n@@ -1025,7 +1025,7 @@ fn encode_item_ast(ebml_w: Writer::Serializer, item: @ast::item) {\n #[cfg(test)]\n fn decode_item_ast(par_doc: ebml::Doc) -> @ast::item {\n     let chi_doc = par_doc[c::tag_tree as uint];\n-    let d = &Reader::Deserializer(chi_doc);\n+    let d = &reader::Deserializer(chi_doc);\n     @deserialize(d)\n }\n \n@@ -1052,10 +1052,10 @@ fn mk_ctxt() -> fake_ext_ctxt {\n #[cfg(test)]\n fn roundtrip(in_item: @ast::item) {\n     let bytes = do io::with_bytes_writer |wr| {\n-        let ebml_w = Writer::Serializer(wr);\n+        let ebml_w = writer::Serializer(wr);\n         encode_item_ast(ebml_w, in_item);\n     };\n-    let ebml_doc = Reader::Doc(@bytes);\n+    let ebml_doc = reader::Doc(@bytes);\n     let out_item = decode_item_ast(ebml_doc);\n \n     let exp_str = do io::with_str_writer |w| {"}, {"sha": "164021783d198a81237eb4cea8d47f22d449f323", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d2ad028a7c70866df375172a2377bdf966b25d9d/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ad028a7c70866df375172a2377bdf966b25d9d/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=d2ad028a7c70866df375172a2377bdf966b25d9d", "patch": "@@ -53,7 +53,7 @@ enum EbmlSerializerTag {\n }\n // --------------------------------------\n \n-pub mod Reader {\n+pub mod reader {\n \n     // ebml reading\n \n@@ -395,7 +395,7 @@ pub mod Reader {\n \n }\n \n-pub mod Writer {\n+pub mod writer {\n \n     // ebml writing\n     struct Serializer {\n@@ -663,11 +663,11 @@ mod tests {\n         fn test_v(v: Option<int>) {\n             debug!(\"v == %?\", v);\n             let bytes = do io::with_bytes_writer |wr| {\n-                let ebml_w = Writer::Serializer(wr);\n+                let ebml_w = writer::Serializer(wr);\n                 v.serialize(&ebml_w)\n             };\n-            let ebml_doc = Reader::Doc(@bytes);\n-            let deser = Reader::Deserializer(ebml_doc);\n+            let ebml_doc = reader::Doc(@bytes);\n+            let deser = reader::Deserializer(ebml_doc);\n             let v1 = serialization::deserialize(&deser);\n             debug!(\"v1 == %?\", v1);\n             assert v == v1;"}, {"sha": "68312b0423f962e433169aaea51e24f182192bb0", "filename": "src/test/run-pass/auto_serialize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2ad028a7c70866df375172a2377bdf966b25d9d/src%2Ftest%2Frun-pass%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ad028a7c70866df375172a2377bdf966b25d9d/src%2Ftest%2Frun-pass%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto_serialize.rs?ref=d2ad028a7c70866df375172a2377bdf966b25d9d", "patch": "@@ -7,8 +7,8 @@ extern mod std;\n \n use cmp::Eq;\n use std::ebml;\n-use EBReader = std::ebml::Reader;\n-use EBWriter = std::ebml::Writer;\n+use EBReader = std::ebml::reader;\n+use EBWriter = std::ebml::writer;\n use io::Writer;\n use std::serialization::{Serializable, Deserializable, deserialize};\n use std::prettyprint;"}]}