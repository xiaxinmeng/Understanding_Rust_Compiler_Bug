{"sha": "6bce61cd4b20ae0661a1a7bd656cebc999b5a2ee", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiY2U2MWNkNGIyMGFlMDY2MWExYTdiZDY1NmNlYmM5OTliNWEyZWU=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2019-03-07T21:47:43Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2019-03-21T21:49:43Z"}, "message": "Fix invalid returned types generation", "tree": {"sha": "0f17e0fabef829de87504d1524207f589d6b9eed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f17e0fabef829de87504d1524207f589d6b9eed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6bce61cd4b20ae0661a1a7bd656cebc999b5a2ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6bce61cd4b20ae0661a1a7bd656cebc999b5a2ee", "html_url": "https://github.com/rust-lang/rust/commit/6bce61cd4b20ae0661a1a7bd656cebc999b5a2ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6bce61cd4b20ae0661a1a7bd656cebc999b5a2ee/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aefe75095adf8a5c6714a5c89b3899d4f9570514", "url": "https://api.github.com/repos/rust-lang/rust/commits/aefe75095adf8a5c6714a5c89b3899d4f9570514", "html_url": "https://github.com/rust-lang/rust/commit/aefe75095adf8a5c6714a5c89b3899d4f9570514"}], "stats": {"total": 109, "additions": 63, "deletions": 46}, "files": [{"sha": "c41d02fbfbbc2c6296ddc3ae54384a8029969c95", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/6bce61cd4b20ae0661a1a7bd656cebc999b5a2ee/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bce61cd4b20ae0661a1a7bd656cebc999b5a2ee/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=6bce61cd4b20ae0661a1a7bd656cebc999b5a2ee", "patch": "@@ -1755,55 +1755,59 @@ fn get_real_types(\n     generics: &Generics,\n     arg: &Type,\n     cx: &DocContext<'_, '_, '_>,\n-) -> Option<Vec<Type>> {\n+) -> Vec<Type> {\n+    let arg_s = arg.to_string();\n     let mut res = Vec::new();\n-    if let Some(where_pred) = generics.where_predicates.iter().find(|g| {\n-        match g {\n-            &WherePredicate::BoundPredicate { ref ty, .. } => ty.def_id() == arg.def_id(),\n-            _ => false,\n-        }\n-    }) {\n-        let bounds = where_pred.get_bounds().unwrap_or_else(|| &[]);\n-        for bound in bounds.iter() {\n-            match *bound {\n-                GenericBound::TraitBound(ref poly_trait, _) => {\n-                    for x in poly_trait.generic_params.iter() {\n-                        if !x.is_type() {\n-                            continue\n-                        }\n-                        if let Some(ty) = x.get_type(cx) {\n-                            if let Some(mut adds) = get_real_types(generics, &ty, cx) {\n-                                res.append(&mut adds);\n-                            } else if !ty.is_full_generic() {\n-                                res.push(ty);\n+    if arg.is_full_generic() {\n+        if let Some(where_pred) = generics.where_predicates.iter().find(|g| {\n+            match g {\n+                &WherePredicate::BoundPredicate { ref ty, .. } => ty.def_id() == arg.def_id(),\n+                _ => false,\n+            }\n+        }) {\n+            let bounds = where_pred.get_bounds().unwrap_or_else(|| &[]);\n+            for bound in bounds.iter() {\n+                match *bound {\n+                    GenericBound::TraitBound(ref poly_trait, _) => {\n+                        for x in poly_trait.generic_params.iter() {\n+                            if !x.is_type() {\n+                                continue\n+                            }\n+                            if let Some(ty) = x.get_type(cx) {\n+                                let mut adds = get_real_types(generics, &ty, cx);\n+                                if !adds.is_empty() {\n+                                    res.append(&mut adds);\n+                                } else if !ty.is_full_generic() {\n+                                    res.push(ty);\n+                                }\n                             }\n                         }\n                     }\n+                    _ => {}\n                 }\n-                _ => {}\n             }\n         }\n-    } else {\n-        let arg_s = arg.to_string();\n         if let Some(bound) = generics.params.iter().find(|g| {\n             g.is_type() && g.name == arg_s\n         }) {\n             for bound in bound.get_bounds().unwrap_or_else(|| &[]) {\n                 if let Some(ty) = bound.get_trait_type() {\n-                    if let Some(mut adds) = get_real_types(generics, &ty, cx) {\n+                    let mut adds = get_real_types(generics, &ty, cx);\n+                    if !adds.is_empty() {\n                         res.append(&mut adds);\n-                    } else {\n-                        if !ty.is_full_generic() {\n-                            res.push(ty.clone());\n-                        }\n+                    } else if !ty.is_full_generic() {\n+                        res.push(ty.clone());\n                     }\n                 }\n             }\n-        } else if let Some(gens) = arg.generics() {\n-            res.push(arg.clone());\n+        }\n+    } else {\n+        res.push(arg.clone());\n+        if let Some(gens) = arg.generics() {\n             for gen in gens.iter() {\n                 if gen.is_full_generic() {\n-                    if let Some(mut adds) = get_real_types(generics, gen, cx) {\n+                    let mut adds = get_real_types(generics, gen, cx);\n+                    if !adds.is_empty() {\n                         res.append(&mut adds);\n                     }\n                 } else {\n@@ -1812,10 +1816,7 @@ fn get_real_types(\n             }\n         }\n     }\n-    if res.is_empty() && !arg.is_full_generic() {\n-        res.push(arg.clone());\n-    }\n-    Some(res)\n+    res\n }\n \n pub fn get_all_types(\n@@ -1828,7 +1829,8 @@ pub fn get_all_types(\n         if arg.type_.is_self_type() {\n             continue;\n         }\n-        if let Some(mut args) = get_real_types(generics, &arg.type_, cx) {\n+        let mut args = get_real_types(generics, &arg.type_, cx);\n+        if !args.is_empty() {\n             all_types.append(&mut args);\n         } else {\n             all_types.push(arg.type_.clone());\n@@ -1840,10 +1842,8 @@ pub fn get_all_types(\n \n     let mut ret_types = match decl.output {\n         FunctionRetTy::Return(ref return_type) => {\n-            let mut ret = Vec::new();\n-            if let Some(mut args) = get_real_types(generics, &return_type, cx) {\n-                ret.append(&mut args);\n-            } else {\n+            let mut ret = get_real_types(generics, &return_type, cx);\n+            if ret.is_empty() {\n                 ret.push(return_type.clone());\n             }\n             ret"}, {"sha": "930f3fd3c5c82e9a287151379d14dd0303470657", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6bce61cd4b20ae0661a1a7bd656cebc999b5a2ee/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bce61cd4b20ae0661a1a7bd656cebc999b5a2ee/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=6bce61cd4b20ae0661a1a7bd656cebc999b5a2ee", "patch": "@@ -455,19 +455,27 @@ impl ToJson for Type {\n #[derive(Debug)]\n struct IndexItemFunctionType {\n     inputs: Vec<Type>,\n-    output: Vec<Type>,\n+    output: Option<Vec<Type>>,\n }\n \n impl ToJson for IndexItemFunctionType {\n     fn to_json(&self) -> Json {\n         // If we couldn't figure out a type, just write `null`.\n-        if self.inputs.iter().chain(self.output.iter()).any(|ref i| i.name.is_none()) {\n+        let mut iter = self.inputs.iter();\n+        if match self.output {\n+            Some(ref output) => iter.chain(output.iter()).any(|ref i| i.name.is_none()),\n+            None => iter.any(|ref i| i.name.is_none()),\n+        } {\n             Json::Null\n         } else {\n             let mut data = Vec::with_capacity(2);\n             data.push(self.inputs.to_json());\n-            if !self.output.is_empty() {\n-                data.push(self.output.to_json());\n+            if let Some(ref output) = self.output {\n+                if output.len() > 1 {\n+                    data.push(output.to_json());\n+                } else {\n+                    data.push(output[0].to_json());\n+                }\n             }\n             Json::Array(data)\n         }\n@@ -5034,11 +5042,17 @@ fn get_index_search_type(item: &clean::Item) -> Option<IndexItemFunctionType> {\n \n     let inputs = all_types.iter().map(|arg| {\n         get_index_type(&arg)\n-    }).collect();\n+    }).filter(|a| a.name.is_some()).collect();\n     let output = ret_types.iter().map(|arg| {\n         get_index_type(&arg)\n-    }).collect();\n+    }).filter(|a| a.name.is_some()).collect::<Vec<_>>();\n+    let output = if output.is_empty() {\n+        None\n+    } else {\n+        Some(output)\n+    };\n \n+    println!(\"===> {:?}\", output);\n     Some(IndexItemFunctionType { inputs, output })\n }\n "}, {"sha": "94247b2fa4567e616c371b8f888f994a4bbcafee", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6bce61cd4b20ae0661a1a7bd656cebc999b5a2ee/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/6bce61cd4b20ae0661a1a7bd656cebc999b5a2ee/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=6bce61cd4b20ae0661a1a7bd656cebc999b5a2ee", "patch": "@@ -756,6 +756,9 @@ if (!DOMTokenList.prototype.remove) {\n \n                 if (obj && obj.type && obj.type.length > OUTPUT_DATA) {\n                     var ret = obj.type[OUTPUT_DATA];\n+                    //if (obj.name === \"xo\") {\n+                    //    debugger;\n+                    //}\n                     if (!obj.type[OUTPUT_DATA].length) {\n                         ret = [ret];\n                     }"}]}