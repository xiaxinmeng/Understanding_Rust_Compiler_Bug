{"sha": "b9ca3195abeb5d8112b6739fc77e25d101937a56", "node_id": "C_kwDOAAsO6NoAKGI5Y2EzMTk1YWJlYjVkODExMmI2NzM5ZmM3N2UyNWQxMDE5MzdhNTY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-08T14:15:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-08T14:15:40Z"}, "message": "Auto merge of #9791 - smoelius:issues-9739-9782, r=Jarcho\n\nAddress issues 9739 and 9782\n\nThis PR fixes #9739 in the manner I suggested in https://github.com/rust-lang/rust-clippy/issues/9739#issuecomment-1296802376.\n\nThis PR also fixes the compilation failures in #9782 (but doesn't address `@e00E's` other objections).\n\nFixes #9739\n\nr? `@Jarcho`\n\nchangelog: Fix two `needless_borrow` false positives, one involving borrows in `if`-`else`s, the other involving qualified function calls", "tree": {"sha": "35cc6bf1176098fa2ef9e7b6ec561de4ef88e41d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/35cc6bf1176098fa2ef9e7b6ec561de4ef88e41d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b9ca3195abeb5d8112b6739fc77e25d101937a56", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b9ca3195abeb5d8112b6739fc77e25d101937a56", "html_url": "https://github.com/rust-lang/rust/commit/b9ca3195abeb5d8112b6739fc77e25d101937a56", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b9ca3195abeb5d8112b6739fc77e25d101937a56/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e31877ef969d2f5ad30a92bd8fbb39036681a8f", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e31877ef969d2f5ad30a92bd8fbb39036681a8f", "html_url": "https://github.com/rust-lang/rust/commit/4e31877ef969d2f5ad30a92bd8fbb39036681a8f"}, {"sha": "50f63a0f240b4c37d992eaf55babaef1f162cacf", "url": "https://api.github.com/repos/rust-lang/rust/commits/50f63a0f240b4c37d992eaf55babaef1f162cacf", "html_url": "https://github.com/rust-lang/rust/commit/50f63a0f240b4c37d992eaf55babaef1f162cacf"}], "stats": {"total": 257, "additions": 233, "deletions": 24}, "files": [{"sha": "400fbd6d8a751bba5888d977773c8ba29789bffd", "filename": "clippy_lints/src/dereference.rs", "status": "modified", "additions": 46, "deletions": 23, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/b9ca3195abeb5d8112b6739fc77e25d101937a56/clippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9ca3195abeb5d8112b6739fc77e25d101937a56/clippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdereference.rs?ref=b9ca3195abeb5d8112b6739fc77e25d101937a56", "patch": "@@ -805,30 +805,39 @@ fn walk_parents<'tcx>(\n                     .position(|arg| arg.hir_id == child_id)\n                     .zip(expr_sig(cx, func))\n                     .and_then(|(i, sig)| {\n-                        sig.input_with_hir(i).map(|(hir_ty, ty)| match hir_ty {\n-                            // Type inference for closures can depend on how they're called. Only go by the explicit\n-                            // types here.\n-                            Some(hir_ty) => binding_ty_auto_deref_stability(cx, hir_ty, precedence, ty.bound_vars()),\n-                            None => {\n-                                if let ty::Param(param_ty) = ty.skip_binder().kind() {\n-                                    needless_borrow_impl_arg_position(\n-                                        cx,\n-                                        possible_borrowers,\n-                                        parent,\n-                                        i,\n-                                        *param_ty,\n-                                        e,\n-                                        precedence,\n-                                        msrv,\n-                                    )\n-                                } else {\n-                                    ty_auto_deref_stability(cx, cx.tcx.erase_late_bound_regions(ty), precedence)\n-                                        .position_for_arg()\n-                                }\n-                            },\n+                        sig.input_with_hir(i).map(|(hir_ty, ty)| {\n+                            match hir_ty {\n+                                // Type inference for closures can depend on how they're called. Only go by the explicit\n+                                // types here.\n+                                Some(hir_ty) => {\n+                                    binding_ty_auto_deref_stability(cx, hir_ty, precedence, ty.bound_vars())\n+                                },\n+                                None => {\n+                                    // `e.hir_id == child_id` for https://github.com/rust-lang/rust-clippy/issues/9739\n+                                    // `!call_is_qualified(func)` for https://github.com/rust-lang/rust-clippy/issues/9782\n+                                    if e.hir_id == child_id\n+                                        && !call_is_qualified(func)\n+                                        && let ty::Param(param_ty) = ty.skip_binder().kind()\n+                                    {\n+                                        needless_borrow_impl_arg_position(\n+                                            cx,\n+                                            possible_borrowers,\n+                                            parent,\n+                                            i,\n+                                            *param_ty,\n+                                            e,\n+                                            precedence,\n+                                            msrv,\n+                                        )\n+                                    } else {\n+                                        ty_auto_deref_stability(cx, cx.tcx.erase_late_bound_regions(ty), precedence)\n+                                            .position_for_arg()\n+                                    }\n+                                },\n+                            }\n                         })\n                     }),\n-                ExprKind::MethodCall(_, receiver, args, _) => {\n+                ExprKind::MethodCall(method, receiver, args, _) => {\n                     let id = cx.typeck_results().type_dependent_def_id(parent.hir_id).unwrap();\n                     if receiver.hir_id == child_id {\n                         // Check for calls to trait methods where the trait is implemented on a reference.\n@@ -866,7 +875,9 @@ fn walk_parents<'tcx>(\n                     }\n                     args.iter().position(|arg| arg.hir_id == child_id).map(|i| {\n                         let ty = cx.tcx.fn_sig(id).skip_binder().inputs()[i + 1];\n-                        if let ty::Param(param_ty) = ty.kind() {\n+                        // `e.hir_id == child_id` for https://github.com/rust-lang/rust-clippy/issues/9739\n+                        // `method.args.is_none()` for https://github.com/rust-lang/rust-clippy/issues/9782\n+                        if e.hir_id == child_id && method.args.is_none() && let ty::Param(param_ty) = ty.kind() {\n                             needless_borrow_impl_arg_position(\n                                 cx,\n                                 possible_borrowers,\n@@ -1044,6 +1055,18 @@ fn ty_contains_infer(ty: &hir::Ty<'_>) -> bool {\n     v.0\n }\n \n+fn call_is_qualified(expr: &Expr<'_>) -> bool {\n+    if let ExprKind::Path(path) = &expr.kind {\n+        match path {\n+            QPath::Resolved(_, path) => path.segments.last().map_or(false, |segment| segment.args.is_some()),\n+            QPath::TypeRelative(_, segment) => segment.args.is_some(),\n+            QPath::LangItem(..) => false,\n+        }\n+    } else {\n+        false\n+    }\n+}\n+\n // Checks whether:\n // * child is an expression of the form `&e` in an argument position requiring an `impl Trait`\n // * `e`'s type implements `Trait` and is copyable"}, {"sha": "85b6b639d5549c9b6636597617a8c486370a7863", "filename": "tests/ui/needless_borrow.fixed", "status": "modified", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/b9ca3195abeb5d8112b6739fc77e25d101937a56/tests%2Fui%2Fneedless_borrow.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/b9ca3195abeb5d8112b6739fc77e25d101937a56/tests%2Fui%2Fneedless_borrow.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrow.fixed?ref=b9ca3195abeb5d8112b6739fc77e25d101937a56", "patch": "@@ -420,3 +420,93 @@ mod issue_9710 {\n \n     fn f<T: AsRef<str>>(_: T) {}\n }\n+\n+#[allow(dead_code)]\n+mod issue_9739 {\n+    fn foo<D: std::fmt::Display>(_it: impl IntoIterator<Item = D>) {}\n+\n+    fn main() {\n+        foo(if std::env::var_os(\"HI\").is_some() {\n+            &[0]\n+        } else {\n+            &[] as &[u32]\n+        });\n+    }\n+}\n+\n+#[allow(dead_code)]\n+mod issue_9739_method_variant {\n+    struct S;\n+\n+    impl S {\n+        fn foo<D: std::fmt::Display>(&self, _it: impl IntoIterator<Item = D>) {}\n+    }\n+\n+    fn main() {\n+        S.foo(if std::env::var_os(\"HI\").is_some() {\n+            &[0]\n+        } else {\n+            &[] as &[u32]\n+        });\n+    }\n+}\n+\n+#[allow(dead_code)]\n+mod issue_9782 {\n+    fn foo<T: AsRef<[u8]>>(t: T) {\n+        println!(\"{}\", std::mem::size_of::<T>());\n+        let _t: &[u8] = t.as_ref();\n+    }\n+\n+    fn main() {\n+        let a: [u8; 100] = [0u8; 100];\n+\n+        // 100\n+        foo::<[u8; 100]>(a);\n+        foo(a);\n+\n+        // 16\n+        foo::<&[u8]>(&a);\n+        foo(a.as_slice());\n+\n+        // 8\n+        foo::<&[u8; 100]>(&a);\n+        foo(a);\n+    }\n+}\n+\n+#[allow(dead_code)]\n+mod issue_9782_type_relative_variant {\n+    struct S;\n+\n+    impl S {\n+        fn foo<T: AsRef<[u8]>>(t: T) {\n+            println!(\"{}\", std::mem::size_of::<T>());\n+            let _t: &[u8] = t.as_ref();\n+        }\n+    }\n+\n+    fn main() {\n+        let a: [u8; 100] = [0u8; 100];\n+\n+        S::foo::<&[u8; 100]>(&a);\n+    }\n+}\n+\n+#[allow(dead_code)]\n+mod issue_9782_method_variant {\n+    struct S;\n+\n+    impl S {\n+        fn foo<T: AsRef<[u8]>>(&self, t: T) {\n+            println!(\"{}\", std::mem::size_of::<T>());\n+            let _t: &[u8] = t.as_ref();\n+        }\n+    }\n+\n+    fn main() {\n+        let a: [u8; 100] = [0u8; 100];\n+\n+        S.foo::<&[u8; 100]>(&a);\n+    }\n+}"}, {"sha": "7b97bcf3817ec0bc60c4b93acdfdabf1de063a70", "filename": "tests/ui/needless_borrow.rs", "status": "modified", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/b9ca3195abeb5d8112b6739fc77e25d101937a56/tests%2Fui%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9ca3195abeb5d8112b6739fc77e25d101937a56/tests%2Fui%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrow.rs?ref=b9ca3195abeb5d8112b6739fc77e25d101937a56", "patch": "@@ -420,3 +420,93 @@ mod issue_9710 {\n \n     fn f<T: AsRef<str>>(_: T) {}\n }\n+\n+#[allow(dead_code)]\n+mod issue_9739 {\n+    fn foo<D: std::fmt::Display>(_it: impl IntoIterator<Item = D>) {}\n+\n+    fn main() {\n+        foo(if std::env::var_os(\"HI\").is_some() {\n+            &[0]\n+        } else {\n+            &[] as &[u32]\n+        });\n+    }\n+}\n+\n+#[allow(dead_code)]\n+mod issue_9739_method_variant {\n+    struct S;\n+\n+    impl S {\n+        fn foo<D: std::fmt::Display>(&self, _it: impl IntoIterator<Item = D>) {}\n+    }\n+\n+    fn main() {\n+        S.foo(if std::env::var_os(\"HI\").is_some() {\n+            &[0]\n+        } else {\n+            &[] as &[u32]\n+        });\n+    }\n+}\n+\n+#[allow(dead_code)]\n+mod issue_9782 {\n+    fn foo<T: AsRef<[u8]>>(t: T) {\n+        println!(\"{}\", std::mem::size_of::<T>());\n+        let _t: &[u8] = t.as_ref();\n+    }\n+\n+    fn main() {\n+        let a: [u8; 100] = [0u8; 100];\n+\n+        // 100\n+        foo::<[u8; 100]>(a);\n+        foo(a);\n+\n+        // 16\n+        foo::<&[u8]>(&a);\n+        foo(a.as_slice());\n+\n+        // 8\n+        foo::<&[u8; 100]>(&a);\n+        foo(&a);\n+    }\n+}\n+\n+#[allow(dead_code)]\n+mod issue_9782_type_relative_variant {\n+    struct S;\n+\n+    impl S {\n+        fn foo<T: AsRef<[u8]>>(t: T) {\n+            println!(\"{}\", std::mem::size_of::<T>());\n+            let _t: &[u8] = t.as_ref();\n+        }\n+    }\n+\n+    fn main() {\n+        let a: [u8; 100] = [0u8; 100];\n+\n+        S::foo::<&[u8; 100]>(&a);\n+    }\n+}\n+\n+#[allow(dead_code)]\n+mod issue_9782_method_variant {\n+    struct S;\n+\n+    impl S {\n+        fn foo<T: AsRef<[u8]>>(&self, t: T) {\n+            println!(\"{}\", std::mem::size_of::<T>());\n+            let _t: &[u8] = t.as_ref();\n+        }\n+    }\n+\n+    fn main() {\n+        let a: [u8; 100] = [0u8; 100];\n+\n+        S.foo::<&[u8; 100]>(&a);\n+    }\n+}"}, {"sha": "485e6b84c868b11972932b16a35f6e664e7ae6f4", "filename": "tests/ui/needless_borrow.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b9ca3195abeb5d8112b6739fc77e25d101937a56/tests%2Fui%2Fneedless_borrow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b9ca3195abeb5d8112b6739fc77e25d101937a56/tests%2Fui%2Fneedless_borrow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrow.stderr?ref=b9ca3195abeb5d8112b6739fc77e25d101937a56", "patch": "@@ -210,5 +210,11 @@ error: the borrowed expression implements the required traits\n LL |         use_x(&x);\n    |               ^^ help: change this to: `x`\n \n-error: aborting due to 35 previous errors\n+error: the borrowed expression implements the required traits\n+  --> $DIR/needless_borrow.rs:474:13\n+   |\n+LL |         foo(&a);\n+   |             ^^ help: change this to: `a`\n+\n+error: aborting due to 36 previous errors\n "}]}