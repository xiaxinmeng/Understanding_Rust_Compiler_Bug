{"sha": "43756934d255603a0fb7a871f2a145380e488b71", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzNzU2OTM0ZDI1NTYwM2EwZmI3YTg3MWYyYTE0NTM4MGU0ODhiNzE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-12-23T00:44:01Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-01-14T18:00:10Z"}, "message": "switch the fulfillment context to use the new obligation forest;\nthis commit won't build because, as of this version, no coinductive\nreasoning at all is really supported", "tree": {"sha": "9a5ec028fe2cf55ba126ba65f5d042d1f8432981", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9a5ec028fe2cf55ba126ba65f5d042d1f8432981"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/43756934d255603a0fb7a871f2a145380e488b71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/43756934d255603a0fb7a871f2a145380e488b71", "html_url": "https://github.com/rust-lang/rust/commit/43756934d255603a0fb7a871f2a145380e488b71", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/43756934d255603a0fb7a871f2a145380e488b71/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0defb158aa77e9002dfa836cec005ea5d12200a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/0defb158aa77e9002dfa836cec005ea5d12200a2", "html_url": "https://github.com/rust-lang/rust/commit/0defb158aa77e9002dfa836cec005ea5d12200a2"}], "stats": {"total": 219, "additions": 90, "deletions": 129}, "files": [{"sha": "7e48f20ce10aae43d72886c252f0817fa073430c", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 90, "deletions": 129, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/43756934d255603a0fb7a871f2a145380e488b71/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43756934d255603a0fb7a871f2a145380e488b71/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=43756934d255603a0fb7a871f2a145380e488b71", "patch": "@@ -10,6 +10,7 @@\n \n use middle::infer::InferCtxt;\n use middle::ty::{self, Ty, TypeFoldable};\n+use rustc_data_structures::obligation_forest::{Backtrace, ObligationForest, Error};\n \n use syntax::ast;\n use util::common::ErrorReported;\n@@ -20,6 +21,7 @@ use super::CodeProjectionError;\n use super::CodeSelectionError;\n use super::is_object_safe;\n use super::FulfillmentError;\n+use super::FulfillmentErrorCode;\n use super::ObligationCause;\n use super::PredicateObligation;\n use super::project;\n@@ -57,7 +59,7 @@ pub struct FulfillmentContext<'tcx> {\n \n     // A list of all obligations that have been registered with this\n     // fulfillment context.\n-    predicates: Vec<PendingPredicateObligation<'tcx>>,\n+    predicates: ObligationForest<PendingPredicateObligation<'tcx>>,\n \n     // A set of constraints that regionck must validate. Each\n     // constraint has the form `T:'a`, meaning \"some type `T` must\n@@ -122,7 +124,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n     pub fn new(errors_will_be_reported: bool) -> FulfillmentContext<'tcx> {\n         FulfillmentContext {\n             duplicate_set: FulfilledPredicates::new(),\n-            predicates: Vec::new(),\n+            predicates: ObligationForest::new(),\n             region_obligations: NodeMap(),\n             errors_will_be_reported: errors_will_be_reported,\n         }\n@@ -202,7 +204,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n             obligation: obligation,\n             stalled_on: vec![]\n         };\n-        self.predicates.push(obligation);\n+        self.predicates.push_root(obligation);\n     }\n \n     pub fn region_obligations(&self,\n@@ -220,14 +222,11 @@ impl<'tcx> FulfillmentContext<'tcx> {\n                                    -> Result<(),Vec<FulfillmentError<'tcx>>>\n     {\n         try!(self.select_where_possible(infcx));\n-\n-        // Anything left is ambiguous.\n-        let errors: Vec<FulfillmentError> =\n-            self.predicates\n-            .iter()\n-            .map(|o| FulfillmentError::new(o.obligation.clone(), CodeAmbiguity))\n-            .collect();\n-\n+        let errors: Vec<_> =\n+            self.predicates.to_errors(CodeAmbiguity)\n+                           .into_iter()\n+                           .map(|e| to_fulfillment_error(e))\n+                           .collect();\n         if errors.is_empty() {\n             Ok(())\n         } else {\n@@ -240,11 +239,11 @@ impl<'tcx> FulfillmentContext<'tcx> {\n                                      -> Result<(),Vec<FulfillmentError<'tcx>>>\n     {\n         let mut selcx = SelectionContext::new(infcx);\n-        self.select(&mut selcx, false)\n+        self.select(&mut selcx)\n     }\n \n-    pub fn pending_obligations(&self) -> &[PendingPredicateObligation<'tcx>] {\n-        &self.predicates\n+    pub fn pending_obligations(&self) -> Vec<PendingPredicateObligation<'tcx>> {\n+        self.predicates.pending_obligations()\n     }\n \n     fn is_duplicate_or_add(&mut self,\n@@ -273,58 +272,43 @@ impl<'tcx> FulfillmentContext<'tcx> {\n     /// Attempts to select obligations using `selcx`. If `only_new_obligations` is true, then it\n     /// only attempts to select obligations that haven't been seen before.\n     fn select<'a>(&mut self,\n-                  selcx: &mut SelectionContext<'a, 'tcx>,\n-                  only_new_obligations: bool)\n+                  selcx: &mut SelectionContext<'a, 'tcx>)\n                   -> Result<(),Vec<FulfillmentError<'tcx>>>\n     {\n-        debug!(\"select({} obligations, only_new_obligations={}) start\",\n-               self.predicates.len(),\n-               only_new_obligations);\n+        debug!(\"select(obligation-forest-size={})\", self.predicates.len());\n \n         let mut errors = Vec::new();\n \n         loop {\n-            let count = self.predicates.len();\n+            debug!(\"select_where_possible: starting another iteration\");\n \n-            debug!(\"select_where_possible({} obligations) iteration\",\n-                   count);\n+            // Process pending obligations.\n+            let outcome = {\n+                let region_obligations = &mut self.region_obligations;\n+                self.predicates.process_obligations(\n+                    |obligation, backtrace| process_predicate(selcx,\n+                                                              obligation,\n+                                                              backtrace,\n+                                                              region_obligations))\n+            };\n \n-            let mut new_obligations = Vec::new();\n+            debug!(\"select_where_possible: outcome={:?}\", outcome);\n \n-            // First pass: walk each obligation, retaining\n-            // only those that we cannot yet process.\n-            {\n-                let region_obligations = &mut self.region_obligations;\n-                let mut i = 0;\n-                while i < self.predicates.len() {\n-                    let processed = process_predicate(selcx,\n-                                                      &mut self.predicates[i],\n-                                                      &mut new_obligations,\n-                                                      &mut errors,\n-                                                      region_obligations);\n-                    if processed {\n-                        self.predicates.swap_remove(i);\n-                    } else {\n-                        i += 1;\n-                    }\n                 }\n             }\n \n-            if self.predicates.len() == count {\n-                // Nothing changed.\n-                break;\n-            }\n+            errors.extend(\n+                outcome.errors.into_iter()\n+                              .map(|e| to_fulfillment_error(e)));\n \n-            // Now go through all the successful ones,\n-            // registering any nested obligations for the future.\n-            for new_obligation in new_obligations {\n-                self.register_predicate_obligation(selcx.infcx(), new_obligation);\n+            // If nothing new was added, no need to keep looping.\n+            if outcome.stalled {\n+                break;\n             }\n         }\n \n-        debug!(\"select({} obligations, {} errors) done\",\n-               self.predicates.len(),\n-               errors.len());\n+        debug!(\"select({} predicates remaining, {} errors) done\",\n+               self.predicates.len(), errors.len());\n \n         if errors.is_empty() {\n             Ok(())\n@@ -334,20 +318,37 @@ impl<'tcx> FulfillmentContext<'tcx> {\n     }\n }\n \n+/// Like `process_predicate1`, but wrap result into a pending predicate.\n fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n                               pending_obligation: &mut PendingPredicateObligation<'tcx>,\n-                              new_obligations: &mut Vec<PredicateObligation<'tcx>>,\n-                              errors: &mut Vec<FulfillmentError<'tcx>>,\n+                              backtrace: Backtrace<PendingPredicateObligation<'tcx>>,\n                               region_obligations: &mut NodeMap<Vec<RegionObligation<'tcx>>>)\n-                              -> bool\n+                              -> Result<Option<Vec<PendingPredicateObligation<'tcx>>>,\n+                                        FulfillmentErrorCode<'tcx>>\n {\n-    /*!\n-     * Processes a predicate obligation and modifies the appropriate\n-     * output array with the successful/error result.  Returns `false`\n-     * if the predicate could not be processed due to insufficient\n-     * type inference.\n-     */\n+    match process_predicate1(selcx, pending_obligation, backtrace, region_obligations) {\n+        Ok(Some(v)) => Ok(Some(v.into_iter()\n+                                .map(|o| PendingPredicateObligation {\n+                                    obligation: o,\n+                                    stalled_on: vec![]\n+                                })\n+                               .collect())),\n+        Ok(None) => Ok(None),\n+        Err(e) => Err(e)\n+    }\n+}\n \n+/// Processes a predicate obligation and returns either:\n+/// - `Ok(Some(v))` if the predicate is true, presuming that `v` are also true\n+/// - `Ok(None)` if we don't have enough info to be sure\n+/// - `Err` if the predicate does not hold\n+fn process_predicate1<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n+                               pending_obligation: &mut PendingPredicateObligation<'tcx>,\n+                               backtrace: Backtrace<PendingPredicateObligation<'tcx>>,\n+                               region_obligations: &mut NodeMap<Vec<RegionObligation<'tcx>>>)\n+                               -> Result<Option<Vec<PredicateObligation<'tcx>>>,\n+                                         FulfillmentErrorCode<'tcx>>\n+{\n     // if we were stalled on some unresolved variables, first check\n     // whether any of them have been resolved; if not, don't bother\n     // doing more work yet\n@@ -359,16 +360,19 @@ fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n             debug!(\"process_predicate: pending obligation {:?} still stalled on {:?}\",\n                    selcx.infcx().resolve_type_vars_if_possible(&pending_obligation.obligation),\n                    pending_obligation.stalled_on);\n-            return false;\n+            return Ok(None);\n         }\n         pending_obligation.stalled_on = vec![];\n     }\n \n-    let obligation = &mut pending_obligation.obligation;\n+    let obligation = &pending_obligation.obligation;\n     match obligation.predicate {\n         ty::Predicate::Trait(ref data) => {\n             let trait_obligation = obligation.with(data.clone());\n             match selcx.select(&trait_obligation) {\n+                Ok(Some(vtable)) => {\n+                    Ok(Some(vtable.nested_obligations()))\n+                }\n                 Ok(None) => {\n                     // This is a bit subtle: for the most part, the\n                     // only reason we can fail to make progress on\n@@ -395,50 +399,26 @@ fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n                            selcx.infcx().resolve_type_vars_if_possible(obligation),\n                            pending_obligation.stalled_on);\n \n-                    false\n-                }\n-                Ok(Some(s)) => {\n-                    new_obligations.append(&mut s.nested_obligations());\n-                    true\n+                    Ok(None)\n                 }\n                 Err(selection_err) => {\n-                    debug!(\"predicate: {:?} error: {:?}\",\n-                           obligation,\n-                           selection_err);\n-                    errors.push(\n-                        FulfillmentError::new(\n-                            obligation.clone(),\n-                            CodeSelectionError(selection_err)));\n-                    true\n+                    Err(CodeSelectionError(selection_err))\n                 }\n             }\n         }\n \n         ty::Predicate::Equate(ref binder) => {\n             match selcx.infcx().equality_predicate(obligation.cause.span, binder) {\n-                Ok(()) => { }\n-                Err(_) => {\n-                    errors.push(\n-                        FulfillmentError::new(\n-                            obligation.clone(),\n-                            CodeSelectionError(Unimplemented)));\n-                }\n+                Ok(()) => Ok(Some(Vec::new())),\n+                Err(_) => Err(CodeSelectionError(Unimplemented)),\n             }\n-            true\n         }\n \n         ty::Predicate::RegionOutlives(ref binder) => {\n             match selcx.infcx().region_outlives_predicate(obligation.cause.span, binder) {\n-                Ok(()) => { }\n-                Err(_) => {\n-                    errors.push(\n-                        FulfillmentError::new(\n-                            obligation.clone(),\n-                            CodeSelectionError(Unimplemented)));\n-                }\n+                Ok(()) => Ok(Some(Vec::new())),\n+                Err(_) => Err(CodeSelectionError(Unimplemented)),\n             }\n-\n-            true\n         }\n \n         ty::Predicate::TypeOutlives(ref binder) => {\n@@ -454,17 +434,15 @@ fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n                         // If so, this obligation is an error (for now). Eventually we should be\n                         // able to support additional cases here, like `for<'a> &'a str: 'a`.\n                         None => {\n-                            errors.push(\n-                                FulfillmentError::new(\n-                                    obligation.clone(),\n-                                    CodeSelectionError(Unimplemented)))\n+                            Err(CodeSelectionError(Unimplemented))\n                         }\n                         // Otherwise, we have something of the form\n                         // `for<'a> T: 'a where 'a not in T`, which we can treat as `T: 'static`.\n                         Some(t_a) => {\n                             register_region_obligation(t_a, ty::ReStatic,\n                                                        obligation.cause.clone(),\n                                                        region_obligations);\n+                            Ok(Some(vec![]))\n                         }\n                     }\n                 }\n@@ -473,55 +451,30 @@ fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n                     register_region_obligation(t_a, r_b,\n                                                obligation.cause.clone(),\n                                                region_obligations);\n+                    Ok(Some(vec![]))\n                 }\n             }\n-            true\n         }\n \n         ty::Predicate::Projection(ref data) => {\n             let project_obligation = obligation.with(data.clone());\n-            let result = project::poly_project_and_unify_type(selcx, &project_obligation);\n-            debug!(\"process_predicate: poly_project_and_unify_type({:?}) returned {:?}\",\n-                   project_obligation,\n-                   result);\n-            match result {\n-                Ok(Some(obligations)) => {\n-                    new_obligations.extend(obligations);\n-                    true\n-                }\n-                Ok(None) => {\n-                    false\n-                }\n-                Err(err) => {\n-                    errors.push(\n-                        FulfillmentError::new(\n-                            obligation.clone(),\n-                            CodeProjectionError(err)));\n-                    true\n-                }\n+            match project::poly_project_and_unify_type(selcx, &project_obligation) {\n+                Ok(v) => Ok(v),\n+                Err(e) => Err(CodeProjectionError(e))\n             }\n         }\n \n         ty::Predicate::ObjectSafe(trait_def_id) => {\n             if !is_object_safe(selcx.tcx(), trait_def_id) {\n-                errors.push(FulfillmentError::new(\n-                    obligation.clone(),\n-                    CodeSelectionError(Unimplemented)));\n+                Err(CodeSelectionError(Unimplemented))\n+            } else {\n+                Ok(Some(Vec::new()))\n             }\n-            true\n         }\n \n         ty::Predicate::WellFormed(ty) => {\n-            match ty::wf::obligations(selcx.infcx(), obligation.cause.body_id,\n-                                      ty, obligation.cause.span) {\n-                Some(obligations) => {\n-                    new_obligations.extend(obligations);\n-                    true\n-                }\n-                None => {\n-                    false\n-                }\n-            }\n+            Ok(ty::wf::obligations(selcx.infcx(), obligation.cause.body_id,\n+                                   ty, obligation.cause.span))\n         }\n     }\n }\n@@ -559,3 +512,11 @@ impl<'tcx> FulfilledPredicates<'tcx> {\n         !self.set.insert(key.clone())\n     }\n }\n+\n+fn to_fulfillment_error<'tcx>(\n+    error: Error<PendingPredicateObligation<'tcx>, FulfillmentErrorCode<'tcx>>)\n+    -> FulfillmentError<'tcx>\n+{\n+    let obligation = error.backtrace.into_iter().next().unwrap().obligation;\n+    FulfillmentError::new(obligation, error.error)\n+}"}]}