{"sha": "d0357fc3b270d5b05665395b95958ac2a3d1c51a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwMzU3ZmMzYjI3MGQ1YjA1NjY1Mzk1Yjk1OTU4YWMyYTNkMWM1MWE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-11-16T19:51:25Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-11-16T19:51:25Z"}, "message": "Merge #2280\n\n2280: Add ast for plain and raw string literals r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "e3766c348d90f933b0f374b0a528e2ffc67d58fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e3766c348d90f933b0f374b0a528e2ffc67d58fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d0357fc3b270d5b05665395b95958ac2a3d1c51a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd0FM9CRBK7hj4Ov3rIwAAdHIIAHfpq0Z0D468VpV8mlpqwODJ\nDzI7kaual3pPO3mui4ii0RSwAPWPkcwE9Q88g/D4zlaZImVajg/H4Uaw/sWJpT3x\nA+JWiOXhIbVn/y8+SUssxZYF0oyT/qeiq6Xpj6SNLuVCPkxAhVAOD4ijZPPXqrpw\nWRmB2ecM3vYck0sIwjxgM+A7jAqQCgQV/MFnKkLe99l9ggs/5OIkx0KQWUA601gZ\n4FCwrIDqIZNcORMaOeWnbV2p5J/cGY0zkukXUG1BFrRvcFIZ8c39M1GWWIdD7wbu\n1a7EvdFxecyJb6KpsKqHXDU/YKd+Gpd1aiGPjyAiFW80e4ez2SYBdYG6pe2eu6A=\n=wfrm\n-----END PGP SIGNATURE-----\n", "payload": "tree e3766c348d90f933b0f374b0a528e2ffc67d58fd\nparent c27fb3a0cafd01a699e78a36e711c00b39468a65\nparent 5b54a93fe71137606674ff11dc57bc6e7eaa37f9\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1573933885 +0000\ncommitter GitHub <noreply@github.com> 1573933885 +0000\n\nMerge #2280\n\n2280: Add ast for plain and raw string literals r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d0357fc3b270d5b05665395b95958ac2a3d1c51a", "html_url": "https://github.com/rust-lang/rust/commit/d0357fc3b270d5b05665395b95958ac2a3d1c51a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d0357fc3b270d5b05665395b95958ac2a3d1c51a/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c27fb3a0cafd01a699e78a36e711c00b39468a65", "url": "https://api.github.com/repos/rust-lang/rust/commits/c27fb3a0cafd01a699e78a36e711c00b39468a65", "html_url": "https://github.com/rust-lang/rust/commit/c27fb3a0cafd01a699e78a36e711c00b39468a65"}, {"sha": "5b54a93fe71137606674ff11dc57bc6e7eaa37f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b54a93fe71137606674ff11dc57bc6e7eaa37f9", "html_url": "https://github.com/rust-lang/rust/commit/5b54a93fe71137606674ff11dc57bc6e7eaa37f9"}], "stats": {"total": 156, "additions": 98, "deletions": 58}, "files": [{"sha": "820cf2acccdf99fe340fcf02e3738a22cd5017ca", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d0357fc3b270d5b05665395b95958ac2a3d1c51a/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/d0357fc3b270d5b05665395b95958ac2a3d1c51a/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=d0357fc3b270d5b05665395b95958ac2a3d1c51a", "patch": "@@ -947,7 +947,6 @@ dependencies = [\n  \"ra_hir 0.1.0\",\n  \"ra_syntax 0.1.0\",\n  \"ra_text_edit 0.1.0\",\n- \"rustc_lexer 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"test_utils 0.1.0\",\n ]\n "}, {"sha": "125c6222d532b95739f119291fb139d36eceed96", "filename": "crates/ra_assists/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d0357fc3b270d5b05665395b95958ac2a3d1c51a/crates%2Fra_assists%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d0357fc3b270d5b05665395b95958ac2a3d1c51a/crates%2Fra_assists%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2FCargo.toml?ref=d0357fc3b270d5b05665395b95958ac2a3d1c51a", "patch": "@@ -8,7 +8,6 @@ authors = [\"rust-analyzer developers\"]\n format-buf = \"1.0.0\"\n join_to_string = \"0.1.3\"\n itertools = \"0.8.0\"\n-rustc_lexer = \"0.1.0\"\n \n ra_syntax = { path = \"../ra_syntax\" }\n ra_text_edit = { path = \"../ra_text_edit\" }"}, {"sha": "93912a4706686a81cb4cce55358ce3cc03d07105", "filename": "crates/ra_assists/src/assists/raw_string.rs", "status": "modified", "additions": 13, "deletions": 46, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/d0357fc3b270d5b05665395b95958ac2a3d1c51a/crates%2Fra_assists%2Fsrc%2Fassists%2Fraw_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0357fc3b270d5b05665395b95958ac2a3d1c51a/crates%2Fra_assists%2Fsrc%2Fassists%2Fraw_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fraw_string.rs?ref=d0357fc3b270d5b05665395b95958ac2a3d1c51a", "patch": "@@ -1,9 +1,9 @@\n use hir::db::HirDatabase;\n use ra_syntax::{\n+    ast, AstToken,\n     SyntaxKind::{RAW_STRING, STRING},\n-    TextRange, TextUnit,\n+    TextUnit,\n };\n-use rustc_lexer;\n \n use crate::{Assist, AssistCtx, AssistId};\n \n@@ -23,32 +23,16 @@ use crate::{Assist, AssistCtx, AssistId};\n // }\n // ```\n pub(crate) fn make_raw_string(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n-    let token = ctx.find_token_at_offset(STRING)?;\n-    let text = token.text().as_str();\n-    let usual_string_range = find_usual_string_range(text)?;\n-    let start_of_inside = usual_string_range.start().to_usize() + 1;\n-    let end_of_inside = usual_string_range.end().to_usize();\n-    let inside_str = &text[start_of_inside..end_of_inside];\n-    let mut unescaped = String::with_capacity(inside_str.len());\n-    let mut error = Ok(());\n-    rustc_lexer::unescape::unescape_str(\n-        inside_str,\n-        &mut |_, unescaped_char| match unescaped_char {\n-            Ok(c) => unescaped.push(c),\n-            Err(_) => error = Err(()),\n-        },\n-    );\n-    if error.is_err() {\n-        return None;\n-    }\n+    let token = ctx.find_token_at_offset(STRING).and_then(ast::String::cast)?;\n+    let value = token.value()?;\n     ctx.add_assist(AssistId(\"make_raw_string\"), \"make raw string\", |edit| {\n-        edit.target(token.text_range());\n-        let max_hash_streak = count_hashes(&unescaped);\n+        edit.target(token.syntax().text_range());\n+        let max_hash_streak = count_hashes(&value);\n         let mut hashes = String::with_capacity(max_hash_streak + 1);\n         for _ in 0..hashes.capacity() {\n             hashes.push('#');\n         }\n-        edit.replace(token.text_range(), format!(\"r{}\\\"{}\\\"{}\", hashes, unescaped, hashes));\n+        edit.replace(token.syntax().text_range(), format!(\"r{}\\\"{}\\\"{}\", hashes, value, hashes));\n     })\n }\n \n@@ -68,17 +52,13 @@ pub(crate) fn make_raw_string(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist\n // }\n // ```\n pub(crate) fn make_usual_string(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n-    let token = ctx.find_token_at_offset(RAW_STRING)?;\n-    let text = token.text().as_str();\n-    let usual_string_range = find_usual_string_range(text)?;\n+    let token = ctx.find_token_at_offset(RAW_STRING).and_then(ast::RawString::cast)?;\n+    let value = token.value()?;\n     ctx.add_assist(AssistId(\"make_usual_string\"), \"make usual string\", |edit| {\n-        edit.target(token.text_range());\n+        edit.target(token.syntax().text_range());\n         // parse inside string to escape `\"`\n-        let start_of_inside = usual_string_range.start().to_usize() + 1;\n-        let end_of_inside = usual_string_range.end().to_usize();\n-        let inside_str = &text[start_of_inside..end_of_inside];\n-        let escaped = inside_str.escape_default().to_string();\n-        edit.replace(token.text_range(), format!(\"\\\"{}\\\"\", escaped));\n+        let escaped = value.escape_default().to_string();\n+        edit.replace(token.syntax().text_range(), format!(\"\\\"{}\\\"\", escaped));\n     })\n }\n \n@@ -132,6 +112,7 @@ pub(crate) fn remove_hash(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n         edit.target(token.text_range());\n         let result = &text[2..text.len() - 1];\n         let result = if result.starts_with('\\\"') {\n+            // FIXME: this logic is wrong, not only the last has has to handled specially\n             // no more hash, escape\n             let internal_str = &result[1..result.len() - 1];\n             format!(\"\\\"{}\\\"\", internal_str.escape_default().to_string())\n@@ -154,20 +135,6 @@ fn count_hashes(s: &str) -> usize {\n     max_hash_streak\n }\n \n-fn find_usual_string_range(s: &str) -> Option<TextRange> {\n-    let left_quote = s.find('\"')?;\n-    let right_quote = s.rfind('\"')?;\n-    if left_quote == right_quote {\n-        // `s` only contains one quote\n-        None\n-    } else {\n-        Some(TextRange::from_to(\n-            TextUnit::from(left_quote as u32),\n-            TextUnit::from(right_quote as u32),\n-        ))\n-    }\n-}\n-\n #[cfg(test)]\n mod test {\n     use super::*;"}, {"sha": "ed8661faf5db94417cfdb649450cc9ecdf529734", "filename": "crates/ra_syntax/src/ast/tokens.rs", "status": "modified", "additions": 85, "deletions": 10, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/d0357fc3b270d5b05665395b95958ac2a3d1c51a/crates%2Fra_syntax%2Fsrc%2Fast%2Ftokens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0357fc3b270d5b05665395b95958ac2a3d1c51a/crates%2Fra_syntax%2Fsrc%2Fast%2Ftokens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Ftokens.rs?ref=d0357fc3b270d5b05665395b95958ac2a3d1c51a", "patch": "@@ -2,19 +2,18 @@\n \n use crate::{\n     ast::AstToken,\n-    SyntaxKind::{COMMENT, WHITESPACE},\n-    SyntaxToken,\n+    SyntaxKind::{COMMENT, RAW_STRING, STRING, WHITESPACE},\n+    SyntaxToken, TextRange, TextUnit,\n };\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Comment(SyntaxToken);\n \n impl AstToken for Comment {\n     fn cast(token: SyntaxToken) -> Option<Self> {\n-        if token.kind() == COMMENT {\n-            Some(Comment(token))\n-        } else {\n-            None\n+        match token.kind() {\n+            COMMENT => Some(Comment(token)),\n+            _ => None,\n         }\n     }\n     fn syntax(&self) -> &SyntaxToken {\n@@ -94,10 +93,9 @@ pub struct Whitespace(SyntaxToken);\n \n impl AstToken for Whitespace {\n     fn cast(token: SyntaxToken) -> Option<Self> {\n-        if token.kind() == WHITESPACE {\n-            Some(Whitespace(token))\n-        } else {\n-            None\n+        match token.kind() {\n+            WHITESPACE => Some(Whitespace(token)),\n+            _ => None,\n         }\n     }\n     fn syntax(&self) -> &SyntaxToken {\n@@ -111,3 +109,80 @@ impl Whitespace {\n         text.find('\\n').map_or(false, |idx| text[idx + 1..].contains('\\n'))\n     }\n }\n+\n+pub struct String(SyntaxToken);\n+\n+impl AstToken for String {\n+    fn cast(token: SyntaxToken) -> Option<Self> {\n+        match token.kind() {\n+            STRING => Some(String(token)),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken {\n+        &self.0\n+    }\n+}\n+\n+impl String {\n+    pub fn value(&self) -> Option<std::string::String> {\n+        let text = self.text().as_str();\n+        let usual_string_range = find_usual_string_range(text)?;\n+        let start_of_inside = usual_string_range.start().to_usize() + 1;\n+        let end_of_inside = usual_string_range.end().to_usize();\n+        let inside_str = &text[start_of_inside..end_of_inside];\n+\n+        let mut buf = std::string::String::with_capacity(inside_str.len());\n+        let mut has_error = false;\n+        rustc_lexer::unescape::unescape_str(inside_str, &mut |_, unescaped_char| {\n+            match unescaped_char {\n+                Ok(c) => buf.push(c),\n+                Err(_) => has_error = true,\n+            }\n+        });\n+\n+        if has_error {\n+            return None;\n+        }\n+        Some(buf)\n+    }\n+}\n+\n+pub struct RawString(SyntaxToken);\n+\n+impl AstToken for RawString {\n+    fn cast(token: SyntaxToken) -> Option<Self> {\n+        match token.kind() {\n+            RAW_STRING => Some(RawString(token)),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken {\n+        &self.0\n+    }\n+}\n+\n+impl RawString {\n+    pub fn value(&self) -> Option<std::string::String> {\n+        let text = self.text().as_str();\n+        let usual_string_range = find_usual_string_range(text)?;\n+        let start_of_inside = usual_string_range.start().to_usize() + 1;\n+        let end_of_inside = usual_string_range.end().to_usize();\n+        let inside_str = &text[start_of_inside..end_of_inside];\n+        Some(inside_str.to_string())\n+    }\n+}\n+\n+fn find_usual_string_range(s: &str) -> Option<TextRange> {\n+    let left_quote = s.find('\"')?;\n+    let right_quote = s.rfind('\"')?;\n+    if left_quote == right_quote {\n+        // `s` only contains one quote\n+        None\n+    } else {\n+        Some(TextRange::from_to(\n+            TextUnit::from(left_quote as u32),\n+            TextUnit::from(right_quote as u32),\n+        ))\n+    }\n+}"}]}