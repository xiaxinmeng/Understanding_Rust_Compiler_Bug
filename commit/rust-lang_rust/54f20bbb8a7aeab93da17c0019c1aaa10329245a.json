{"sha": "54f20bbb8a7aeab93da17c0019c1aaa10329245a", "node_id": "C_kwDOAAsO6NoAKDU0ZjIwYmJiOGE3YWVhYjkzZGExN2MwMDE5YzFhYWExMDMyOTI0NWE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-16T12:43:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-16T12:43:22Z"}, "message": "Auto merge of #101895 - GuillaumeGomez:rollup-ured85q, r=GuillaumeGomez\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #101494 (rustdoc mobile: move notable traits to return type)\n - #101813 (Extend CSS check to CSS variables)\n - #101825 (Fix back RPIT changes)\n - #101843 (Suggest associated const for incorrect use of let in traits)\n - #101859 (Slight vertical formatting)\n - #101868 (rustdoc: use more precise URLs for jump-to-definition links)\n - #101877 (rustdoc: remove no-op CSS `.block { padding: 0 }`)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "69d1183ee00d8749fff9052462eecae022f222ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/69d1183ee00d8749fff9052462eecae022f222ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/54f20bbb8a7aeab93da17c0019c1aaa10329245a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/54f20bbb8a7aeab93da17c0019c1aaa10329245a", "html_url": "https://github.com/rust-lang/rust/commit/54f20bbb8a7aeab93da17c0019c1aaa10329245a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/54f20bbb8a7aeab93da17c0019c1aaa10329245a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2d1aa57d1e05d1d745aaf864965eebd1fd8d6071", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d1aa57d1e05d1d745aaf864965eebd1fd8d6071", "html_url": "https://github.com/rust-lang/rust/commit/2d1aa57d1e05d1d745aaf864965eebd1fd8d6071"}, {"sha": "e284393c9e1f48431b67d95a49ae29a98489c317", "url": "https://api.github.com/repos/rust-lang/rust/commits/e284393c9e1f48431b67d95a49ae29a98489c317", "html_url": "https://github.com/rust-lang/rust/commit/e284393c9e1f48431b67d95a49ae29a98489c317"}], "stats": {"total": 995, "additions": 542, "deletions": 453}, "files": [{"sha": "24672efc63c55635b358be2f9e56a844928d9594", "filename": "compiler/rustc_ast_lowering/src/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/54f20bbb8a7aeab93da17c0019c1aaa10329245a/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54f20bbb8a7aeab93da17c0019c1aaa10329245a/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs?ref=54f20bbb8a7aeab93da17c0019c1aaa10329245a", "patch": "@@ -220,7 +220,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                                 &sym.qself,\n                                 &sym.path,\n                                 ParamMode::Optional,\n-                                &mut ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n+                                &ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n                             );\n                             hir::InlineAsmOperand::SymStatic { path, def_id }\n                         } else {"}, {"sha": "e0869bb1063d91a5b51bd4192b5921550af4b9d4", "filename": "compiler/rustc_ast_lowering/src/block.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/54f20bbb8a7aeab93da17c0019c1aaa10329245a/compiler%2Frustc_ast_lowering%2Fsrc%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54f20bbb8a7aeab93da17c0019c1aaa10329245a/compiler%2Frustc_ast_lowering%2Fsrc%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fblock.rs?ref=54f20bbb8a7aeab93da17c0019c1aaa10329245a", "patch": "@@ -84,9 +84,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     }\n \n     fn lower_local(&mut self, l: &Local) -> &'hir hir::Local<'hir> {\n-        let ty = l.ty.as_ref().map(|t| {\n-            self.lower_ty(t, &mut ImplTraitContext::Disallowed(ImplTraitPosition::Variable))\n-        });\n+        let ty = l\n+            .ty\n+            .as_ref()\n+            .map(|t| self.lower_ty(t, &ImplTraitContext::Disallowed(ImplTraitPosition::Variable)));\n         let init = l.kind.init().map(|init| self.lower_expr(init));\n         let hir_id = self.lower_node_id(l.id);\n         let pat = self.lower_pat(&l.pat);"}, {"sha": "6c09269352cf25892c6eb2cb3b2df192814e4c55", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 47, "deletions": 51, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/54f20bbb8a7aeab93da17c0019c1aaa10329245a/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54f20bbb8a7aeab93da17c0019c1aaa10329245a/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=54f20bbb8a7aeab93da17c0019c1aaa10329245a", "patch": "@@ -66,7 +66,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         seg,\n                         ParamMode::Optional,\n                         ParenthesizedGenericArgs::Err,\n-                        &mut ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n+                        &ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n                     ));\n                     let receiver = self.lower_expr(receiver);\n                     let args =\n@@ -89,14 +89,14 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 }\n                 ExprKind::Cast(ref expr, ref ty) => {\n                     let expr = self.lower_expr(expr);\n-                    let ty = self\n-                        .lower_ty(ty, &mut ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n+                    let ty =\n+                        self.lower_ty(ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n                     hir::ExprKind::Cast(expr, ty)\n                 }\n                 ExprKind::Type(ref expr, ref ty) => {\n                     let expr = self.lower_expr(expr);\n-                    let ty = self\n-                        .lower_ty(ty, &mut ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n+                    let ty =\n+                        self.lower_ty(ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n                     hir::ExprKind::Type(expr, ty)\n                 }\n                 ExprKind::AddrOf(k, m, ref ohs) => {\n@@ -225,7 +225,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         qself,\n                         path,\n                         ParamMode::Optional,\n-                        &mut ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n+                        &ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n                     );\n                     hir::ExprKind::Path(qpath)\n                 }\n@@ -259,7 +259,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                             &se.qself,\n                             &se.path,\n                             ParamMode::Optional,\n-                            &mut ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n+                            &ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n                         )),\n                         self.arena\n                             .alloc_from_iter(se.fields.iter().map(|x| self.lower_expr_field(x))),\n@@ -556,14 +556,12 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         async_gen_kind: hir::AsyncGeneratorKind,\n         body: impl FnOnce(&mut Self) -> hir::Expr<'hir>,\n     ) -> hir::ExprKind<'hir> {\n-        let output =\n-            match ret_ty {\n-                Some(ty) => hir::FnRetTy::Return(self.lower_ty(\n-                    &ty,\n-                    &mut ImplTraitContext::Disallowed(ImplTraitPosition::AsyncBlock),\n-                )),\n-                None => hir::FnRetTy::DefaultReturn(self.lower_span(span)),\n-            };\n+        let output = match ret_ty {\n+            Some(ty) => hir::FnRetTy::Return(\n+                self.lower_ty(&ty, &ImplTraitContext::Disallowed(ImplTraitPosition::AsyncBlock)),\n+            ),\n+            None => hir::FnRetTy::DefaultReturn(self.lower_span(span)),\n+        };\n \n         // Resume argument type. We let the compiler infer this to simplify the lowering. It is\n         // fully constrained by `future::from_generator`.\n@@ -855,22 +853,21 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             (body_id, generator_option)\n         });\n \n-        self.lower_lifetime_binder(closure_id, generic_params, |lctx, bound_generic_params| {\n-            // Lower outside new scope to preserve `is_in_loop_condition`.\n-            let fn_decl = lctx.lower_fn_decl(decl, None, fn_decl_span, FnDeclKind::Closure, None);\n-\n-            let c = lctx.arena.alloc(hir::Closure {\n-                binder: binder_clause,\n-                capture_clause,\n-                bound_generic_params,\n-                fn_decl,\n-                body: body_id,\n-                fn_decl_span: lctx.lower_span(fn_decl_span),\n-                movability: generator_option,\n-            });\n+        let bound_generic_params = self.lower_lifetime_binder(closure_id, generic_params);\n+        // Lower outside new scope to preserve `is_in_loop_condition`.\n+        let fn_decl = self.lower_fn_decl(decl, None, fn_decl_span, FnDeclKind::Closure, None);\n+\n+        let c = self.arena.alloc(hir::Closure {\n+            binder: binder_clause,\n+            capture_clause,\n+            bound_generic_params,\n+            fn_decl,\n+            body: body_id,\n+            fn_decl_span: self.lower_span(fn_decl_span),\n+            movability: generator_option,\n+        });\n \n-            hir::ExprKind::Closure(c)\n-        })\n+        hir::ExprKind::Closure(c)\n     }\n \n     fn generator_movability_for_fn(\n@@ -957,24 +954,23 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             body_id\n         });\n \n-        self.lower_lifetime_binder(closure_id, generic_params, |lctx, bound_generic_params| {\n-            // We need to lower the declaration outside the new scope, because we\n-            // have to conserve the state of being inside a loop condition for the\n-            // closure argument types.\n-            let fn_decl =\n-                lctx.lower_fn_decl(&outer_decl, None, fn_decl_span, FnDeclKind::Closure, None);\n-\n-            let c = lctx.arena.alloc(hir::Closure {\n-                binder: binder_clause,\n-                capture_clause,\n-                bound_generic_params,\n-                fn_decl,\n-                body,\n-                fn_decl_span: lctx.lower_span(fn_decl_span),\n-                movability: None,\n-            });\n-            hir::ExprKind::Closure(c)\n-        })\n+        let bound_generic_params = self.lower_lifetime_binder(closure_id, generic_params);\n+        // We need to lower the declaration outside the new scope, because we\n+        // have to conserve the state of being inside a loop condition for the\n+        // closure argument types.\n+        let fn_decl =\n+            self.lower_fn_decl(&outer_decl, None, fn_decl_span, FnDeclKind::Closure, None);\n+\n+        let c = self.arena.alloc(hir::Closure {\n+            binder: binder_clause,\n+            capture_clause,\n+            bound_generic_params,\n+            fn_decl,\n+            body,\n+            fn_decl_span: self.lower_span(fn_decl_span),\n+            movability: None,\n+        });\n+        hir::ExprKind::Closure(c)\n     }\n \n     /// Destructure the LHS of complex assignments.\n@@ -1133,7 +1129,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         qself,\n                         path,\n                         ParamMode::Optional,\n-                        &mut ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n+                        &ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n                     );\n                     // Destructure like a tuple struct.\n                     let tuple_struct_pat = hir::PatKind::TupleStruct(\n@@ -1152,7 +1148,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         qself,\n                         path,\n                         ParamMode::Optional,\n-                        &mut ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n+                        &ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n                     );\n                     // Destructure like a unit struct.\n                     let unit_struct_pat = hir::PatKind::Path(qpath);\n@@ -1176,7 +1172,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     &se.qself,\n                     &se.path,\n                     ParamMode::Optional,\n-                    &mut ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n+                    &ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n                 );\n                 let fields_omitted = match &se.rest {\n                     StructRest::Base(e) => {"}, {"sha": "550833275e4413e70836883ba61de3d690dd1295", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 35, "deletions": 48, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/54f20bbb8a7aeab93da17c0019c1aaa10329245a/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54f20bbb8a7aeab93da17c0019c1aaa10329245a/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=54f20bbb8a7aeab93da17c0019c1aaa10329245a", "patch": "@@ -313,8 +313,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 let (generics, ty) = self.lower_generics(\n                     &generics,\n                     id,\n-                    &mut ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n-                    |this| this.lower_ty(ty, &mut ImplTraitContext::TypeAliasesOpaqueTy),\n+                    &ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n+                    |this| this.lower_ty(ty, &ImplTraitContext::TypeAliasesOpaqueTy),\n                 );\n                 hir::ItemKind::TyAlias(ty, generics)\n             }\n@@ -326,7 +326,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 let (generics, ty) = self.lower_generics(\n                     &generics,\n                     id,\n-                    &mut ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n+                    &ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n                     |this| this.arena.alloc(this.ty(span, hir::TyKind::Err)),\n                 );\n                 hir::ItemKind::TyAlias(ty, generics)\n@@ -335,7 +335,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 let (generics, variants) = self.lower_generics(\n                     generics,\n                     id,\n-                    &mut ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n+                    &ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n                     |this| {\n                         this.arena.alloc_from_iter(\n                             enum_definition.variants.iter().map(|x| this.lower_variant(x)),\n@@ -348,7 +348,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 let (generics, struct_def) = self.lower_generics(\n                     generics,\n                     id,\n-                    &mut ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n+                    &ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n                     |this| this.lower_variant_data(hir_id, struct_def),\n                 );\n                 hir::ItemKind::Struct(struct_def, generics)\n@@ -357,7 +357,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 let (generics, vdata) = self.lower_generics(\n                     generics,\n                     id,\n-                    &mut ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n+                    &ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n                     |this| this.lower_variant_data(hir_id, vdata),\n                 );\n                 hir::ItemKind::Union(vdata, generics)\n@@ -391,14 +391,12 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         let trait_ref = trait_ref.as_ref().map(|trait_ref| {\n                             this.lower_trait_ref(\n                                 trait_ref,\n-                                &mut ImplTraitContext::Disallowed(ImplTraitPosition::Trait),\n+                                &ImplTraitContext::Disallowed(ImplTraitPosition::Trait),\n                             )\n                         });\n \n-                        let lowered_ty = this.lower_ty(\n-                            ty,\n-                            &mut ImplTraitContext::Disallowed(ImplTraitPosition::Type),\n-                        );\n+                        let lowered_ty = this\n+                            .lower_ty(ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n \n                         (trait_ref, lowered_ty)\n                     });\n@@ -437,11 +435,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 let (generics, (unsafety, items, bounds)) = self.lower_generics(\n                     generics,\n                     id,\n-                    &mut ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n+                    &ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n                     |this| {\n                         let bounds = this.lower_param_bounds(\n                             bounds,\n-                            &mut ImplTraitContext::Disallowed(ImplTraitPosition::Bound),\n+                            &ImplTraitContext::Disallowed(ImplTraitPosition::Bound),\n                         );\n                         let items = this.arena.alloc_from_iter(\n                             items.iter().map(|item| this.lower_trait_item_ref(item)),\n@@ -456,11 +454,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 let (generics, bounds) = self.lower_generics(\n                     generics,\n                     id,\n-                    &mut ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n+                    &ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n                     |this| {\n                         this.lower_param_bounds(\n                             bounds,\n-                            &mut ImplTraitContext::Disallowed(ImplTraitPosition::Bound),\n+                            &ImplTraitContext::Disallowed(ImplTraitPosition::Bound),\n                         )\n                     },\n                 );\n@@ -483,7 +481,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         span: Span,\n         body: Option<&Expr>,\n     ) -> (&'hir hir::Ty<'hir>, hir::BodyId) {\n-        let ty = self.lower_ty(ty, &mut ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n+        let ty = self.lower_ty(ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n         (ty, self.lower_const_body(span, body))\n     }\n \n@@ -675,8 +673,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     hir::ForeignItemKind::Fn(fn_dec, fn_args, generics)\n                 }\n                 ForeignItemKind::Static(ref t, m, _) => {\n-                    let ty = self\n-                        .lower_ty(t, &mut ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n+                    let ty =\n+                        self.lower_ty(t, &ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n                     hir::ForeignItemKind::Static(ty, m)\n                 }\n                 ForeignItemKind::TyAlias(..) => hir::ForeignItemKind::Type,\n@@ -744,11 +742,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 qself,\n                 path,\n                 ParamMode::ExplicitNamed, // no `'_` in declarations (Issue #61124)\n-                &mut ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n+                &ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n             );\n             self.arena.alloc(t)\n         } else {\n-            self.lower_ty(&f.ty, &mut ImplTraitContext::Disallowed(ImplTraitPosition::Type))\n+            self.lower_ty(&f.ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Type))\n         };\n         let hir_id = self.lower_node_id(f.id);\n         self.lower_attrs(hir_id, &f.attrs);\n@@ -771,8 +769,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n         let (generics, kind, has_default) = match i.kind {\n             AssocItemKind::Const(_, ref ty, ref default) => {\n-                let ty =\n-                    self.lower_ty(ty, &mut ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n+                let ty = self.lower_ty(ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n                 let body = default.as_ref().map(|x| self.lower_const_body(i.span, Some(x)));\n                 (hir::Generics::empty(), hir::TraitItemKind::Const(ty, body), body.is_some())\n             }\n@@ -813,18 +810,15 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 let (generics, kind) = self.lower_generics(\n                     &generics,\n                     i.id,\n-                    &mut ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n+                    &ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n                     |this| {\n                         let ty = ty.as_ref().map(|x| {\n-                            this.lower_ty(\n-                                x,\n-                                &mut ImplTraitContext::Disallowed(ImplTraitPosition::Type),\n-                            )\n+                            this.lower_ty(x, &ImplTraitContext::Disallowed(ImplTraitPosition::Type))\n                         });\n                         hir::TraitItemKind::Type(\n                             this.lower_param_bounds(\n                                 bounds,\n-                                &mut ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n+                                &ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n                             ),\n                             ty,\n                         )\n@@ -877,8 +871,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n         let (generics, kind) = match &i.kind {\n             AssocItemKind::Const(_, ty, expr) => {\n-                let ty =\n-                    self.lower_ty(ty, &mut ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n+                let ty = self.lower_ty(ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n                 (\n                     hir::Generics::empty(),\n                     hir::ImplItemKind::Const(ty, self.lower_const_body(i.span, expr.as_deref())),\n@@ -905,14 +898,14 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 self.lower_generics(\n                     &generics,\n                     i.id,\n-                    &mut ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n+                    &ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n                     |this| match ty {\n                         None => {\n                             let ty = this.arena.alloc(this.ty(i.span, hir::TyKind::Err));\n                             hir::ImplItemKind::TyAlias(ty)\n                         }\n                         Some(ty) => {\n-                            let ty = this.lower_ty(ty, &mut ImplTraitContext::TypeAliasesOpaqueTy);\n+                            let ty = this.lower_ty(ty, &ImplTraitContext::TypeAliasesOpaqueTy);\n                             hir::ImplItemKind::TyAlias(ty)\n                         }\n                     },\n@@ -1322,7 +1315,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         &mut self,\n         generics: &Generics,\n         parent_node_id: NodeId,\n-        itctx: &mut ImplTraitContext,\n+        itctx: &ImplTraitContext,\n         f: impl FnOnce(&mut Self) -> T,\n     ) -> (&'hir hir::Generics<'hir>, T) {\n         debug_assert!(self.impl_trait_defs.is_empty());\n@@ -1427,7 +1420,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         id: NodeId,\n         kind: &GenericParamKind,\n         bounds: &[GenericBound],\n-        itctx: &mut ImplTraitContext,\n+        itctx: &ImplTraitContext,\n         origin: PredicateOrigin,\n     ) -> Option<hir::WherePredicate<'hir>> {\n         // Do not create a clause if we do not have anything inside it.\n@@ -1502,14 +1495,12 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 span,\n             }) => hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate {\n                 bound_generic_params: self.lower_generic_params(bound_generic_params),\n-                bounded_ty: self.lower_ty(\n-                    bounded_ty,\n-                    &mut ImplTraitContext::Disallowed(ImplTraitPosition::Type),\n-                ),\n+                bounded_ty: self\n+                    .lower_ty(bounded_ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Type)),\n                 bounds: self.arena.alloc_from_iter(bounds.iter().map(|bound| {\n                     self.lower_param_bound(\n                         bound,\n-                        &mut ImplTraitContext::Disallowed(ImplTraitPosition::Bound),\n+                        &ImplTraitContext::Disallowed(ImplTraitPosition::Bound),\n                     )\n                 })),\n                 span: self.lower_span(span),\n@@ -1524,20 +1515,16 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 lifetime: self.lower_lifetime(lifetime),\n                 bounds: self.lower_param_bounds(\n                     bounds,\n-                    &mut ImplTraitContext::Disallowed(ImplTraitPosition::Bound),\n+                    &ImplTraitContext::Disallowed(ImplTraitPosition::Bound),\n                 ),\n                 in_where_clause: true,\n             }),\n             WherePredicate::EqPredicate(WhereEqPredicate { ref lhs_ty, ref rhs_ty, span }) => {\n                 hir::WherePredicate::EqPredicate(hir::WhereEqPredicate {\n-                    lhs_ty: self.lower_ty(\n-                        lhs_ty,\n-                        &mut ImplTraitContext::Disallowed(ImplTraitPosition::Type),\n-                    ),\n-                    rhs_ty: self.lower_ty(\n-                        rhs_ty,\n-                        &mut ImplTraitContext::Disallowed(ImplTraitPosition::Type),\n-                    ),\n+                    lhs_ty: self\n+                        .lower_ty(lhs_ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Type)),\n+                    rhs_ty: self\n+                        .lower_ty(rhs_ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Type)),\n                     span: self.lower_span(span),\n                 })\n             }"}, {"sha": "cb6bf0863b387e3151385dd23f52cce60e2ff977", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 42, "deletions": 63, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/54f20bbb8a7aeab93da17c0019c1aaa10329245a/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54f20bbb8a7aeab93da17c0019c1aaa10329245a/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=54f20bbb8a7aeab93da17c0019c1aaa10329245a", "patch": "@@ -839,31 +839,23 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     /// name resolver owing to lifetime elision; this also populates the resolver's node-id->def-id\n     /// map, so that later calls to `opt_node_id_to_def_id` that refer to these extra lifetime\n     /// parameters will be successful.\n-    #[instrument(level = \"debug\", skip(self, in_binder))]\n+    #[instrument(level = \"debug\", skip(self))]\n     #[inline]\n-    fn lower_lifetime_binder<R>(\n+    fn lower_lifetime_binder(\n         &mut self,\n         binder: NodeId,\n         generic_params: &[GenericParam],\n-        in_binder: impl FnOnce(&mut Self, &'hir [hir::GenericParam<'hir>]) -> R,\n-    ) -> R {\n+    ) -> &'hir [hir::GenericParam<'hir>] {\n+        let mut generic_params: Vec<_> = self.lower_generic_params_mut(generic_params).collect();\n         let extra_lifetimes = self.resolver.take_extra_lifetime_params(binder);\n         debug!(?extra_lifetimes);\n-        let extra_lifetimes: Vec<_> = extra_lifetimes\n-            .into_iter()\n-            .filter_map(|(ident, node_id, res)| {\n-                self.lifetime_res_to_generic_param(ident, node_id, res)\n-            })\n-            .collect();\n-\n-        let generic_params: Vec<_> = self\n-            .lower_generic_params_mut(generic_params)\n-            .chain(extra_lifetimes.into_iter())\n-            .collect();\n+        generic_params.extend(extra_lifetimes.into_iter().filter_map(|(ident, node_id, res)| {\n+            self.lifetime_res_to_generic_param(ident, node_id, res)\n+        }));\n         let generic_params = self.arena.alloc_from_iter(generic_params);\n         debug!(?generic_params);\n \n-        in_binder(self, generic_params)\n+        generic_params\n     }\n \n     fn with_dyn_type_scope<T>(&mut self, in_scope: bool, f: impl FnOnce(&mut Self) -> T) -> T {\n@@ -992,7 +984,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_assoc_ty_constraint(\n         &mut self,\n         constraint: &AssocConstraint,\n-        itctx: &mut ImplTraitContext,\n+        itctx: &ImplTraitContext,\n     ) -> hir::TypeBinding<'hir> {\n         debug!(\"lower_assoc_ty_constraint(constraint={:?}, itctx={:?})\", constraint, itctx);\n         // lower generic arguments of identifier in constraint\n@@ -1011,7 +1003,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         } else {\n             self.arena.alloc(hir::GenericArgs::none())\n         };\n-        let mut itctx_tait = ImplTraitContext::TypeAliasesOpaqueTy;\n+        let itctx_tait = &ImplTraitContext::TypeAliasesOpaqueTy;\n \n         let kind = match constraint.kind {\n             AssocConstraintKind::Equality { ref term } => {\n@@ -1049,9 +1041,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     // then to an opaque type).\n                     //\n                     // FIXME: this is only needed until `impl Trait` is allowed in type aliases.\n-                    ImplTraitContext::Disallowed(_) if self.is_in_dyn_type => {\n-                        (true, &mut itctx_tait)\n-                    }\n+                    ImplTraitContext::Disallowed(_) if self.is_in_dyn_type => (true, itctx_tait),\n \n                     // We are in the parameter position, but not within a dyn type:\n                     //\n@@ -1130,7 +1120,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_generic_arg(\n         &mut self,\n         arg: &ast::GenericArg,\n-        itctx: &mut ImplTraitContext,\n+        itctx: &ImplTraitContext,\n     ) -> hir::GenericArg<'hir> {\n         match arg {\n             ast::GenericArg::Lifetime(lt) => GenericArg::Lifetime(self.lower_lifetime(&lt)),\n@@ -1192,7 +1182,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     }\n \n     #[instrument(level = \"debug\", skip(self))]\n-    fn lower_ty(&mut self, t: &Ty, itctx: &mut ImplTraitContext) -> &'hir hir::Ty<'hir> {\n+    fn lower_ty(&mut self, t: &Ty, itctx: &ImplTraitContext) -> &'hir hir::Ty<'hir> {\n         self.arena.alloc(self.lower_ty_direct(t, itctx))\n     }\n \n@@ -1202,7 +1192,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         qself: &Option<QSelf>,\n         path: &Path,\n         param_mode: ParamMode,\n-        itctx: &mut ImplTraitContext,\n+        itctx: &ImplTraitContext,\n     ) -> hir::Ty<'hir> {\n         // Check whether we should interpret this as a bare trait object.\n         // This check mirrors the one in late resolution.  We only introduce this special case in\n@@ -1245,7 +1235,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         self.ty(span, hir::TyKind::Tup(tys))\n     }\n \n-    fn lower_ty_direct(&mut self, t: &Ty, itctx: &mut ImplTraitContext) -> hir::Ty<'hir> {\n+    fn lower_ty_direct(&mut self, t: &Ty, itctx: &ImplTraitContext) -> hir::Ty<'hir> {\n         let kind = match t.kind {\n             TyKind::Infer => hir::TyKind::Infer,\n             TyKind::Err => hir::TyKind::Err,\n@@ -1268,15 +1258,14 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 hir::TyKind::Rptr(lifetime, self.lower_mt(mt, itctx))\n             }\n             TyKind::BareFn(ref f) => {\n-                self.lower_lifetime_binder(t.id, &f.generic_params, |lctx, generic_params| {\n-                    hir::TyKind::BareFn(lctx.arena.alloc(hir::BareFnTy {\n-                        generic_params,\n-                        unsafety: lctx.lower_unsafety(f.unsafety),\n-                        abi: lctx.lower_extern(f.ext),\n-                        decl: lctx.lower_fn_decl(&f.decl, None, t.span, FnDeclKind::Pointer, None),\n-                        param_names: lctx.lower_fn_params_to_names(&f.decl),\n-                    }))\n-                })\n+                let generic_params = self.lower_lifetime_binder(t.id, &f.generic_params);\n+                hir::TyKind::BareFn(self.arena.alloc(hir::BareFnTy {\n+                    generic_params,\n+                    unsafety: self.lower_unsafety(f.unsafety),\n+                    abi: self.lower_extern(f.ext),\n+                    decl: self.lower_fn_decl(&f.decl, None, t.span, FnDeclKind::Pointer, None),\n+                    param_names: self.lower_fn_params_to_names(&f.decl),\n+                }))\n             }\n             TyKind::Never => hir::TyKind::Never,\n             TyKind::Tup(ref tys) => hir::TyKind::Tup(\n@@ -1357,7 +1346,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         def_node_id,\n                         bounds,\n                         false,\n-                        &mut ImplTraitContext::TypeAliasesOpaqueTy,\n+                        &ImplTraitContext::TypeAliasesOpaqueTy,\n                     ),\n                     ImplTraitContext::Universal => {\n                         let span = t.span;\n@@ -1444,7 +1433,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         opaque_ty_node_id: NodeId,\n         bounds: &GenericBounds,\n         in_trait: bool,\n-        itctx: &mut ImplTraitContext,\n+        itctx: &ImplTraitContext,\n     ) -> hir::TyKind<'hir> {\n         // Make sure we know that some funky desugaring has been going on here.\n         // This is a first: there is code in other places like for loop\n@@ -1690,11 +1679,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         }\n         let inputs = self.arena.alloc_from_iter(inputs.iter().map(|param| {\n             if fn_node_id.is_some() {\n-                self.lower_ty_direct(&param.ty, &mut ImplTraitContext::Universal)\n+                self.lower_ty_direct(&param.ty, &ImplTraitContext::Universal)\n             } else {\n                 self.lower_ty_direct(\n                     &param.ty,\n-                    &mut ImplTraitContext::Disallowed(match kind {\n+                    &ImplTraitContext::Disallowed(match kind {\n                         FnDeclKind::Fn | FnDeclKind::Inherent => {\n                             unreachable!(\"fn should allow in-band lifetimes\")\n                         }\n@@ -2093,7 +2082,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_param_bound(\n         &mut self,\n         tpb: &GenericBound,\n-        itctx: &mut ImplTraitContext,\n+        itctx: &ImplTraitContext,\n     ) -> hir::GenericBound<'hir> {\n         match tpb {\n             GenericBound::Trait(p, modifier) => hir::GenericBound::Trait(\n@@ -2209,16 +2198,15 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             GenericParamKind::Type { ref default, .. } => {\n                 let kind = hir::GenericParamKind::Type {\n                     default: default.as_ref().map(|x| {\n-                        self.lower_ty(x, &mut ImplTraitContext::Disallowed(ImplTraitPosition::Type))\n+                        self.lower_ty(x, &ImplTraitContext::Disallowed(ImplTraitPosition::Type))\n                     }),\n                     synthetic: false,\n                 };\n \n                 (hir::ParamName::Plain(self.lower_ident(param.ident)), kind)\n             }\n             GenericParamKind::Const { ref ty, kw_span: _, ref default } => {\n-                let ty =\n-                    self.lower_ty(&ty, &mut ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n+                let ty = self.lower_ty(&ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n                 let default = default.as_ref().map(|def| self.lower_anon_const(def));\n                 (\n                     hir::ParamName::Plain(self.lower_ident(param.ident)),\n@@ -2228,11 +2216,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         }\n     }\n \n-    fn lower_trait_ref(\n-        &mut self,\n-        p: &TraitRef,\n-        itctx: &mut ImplTraitContext,\n-    ) -> hir::TraitRef<'hir> {\n+    fn lower_trait_ref(&mut self, p: &TraitRef, itctx: &ImplTraitContext) -> hir::TraitRef<'hir> {\n         let path = match self.lower_qpath(p.ref_id, &None, &p.path, ParamMode::Explicit, itctx) {\n             hir::QPath::Resolved(None, path) => path,\n             qpath => panic!(\"lower_trait_ref: unexpected QPath `{:?}`\", qpath),\n@@ -2244,37 +2228,32 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_poly_trait_ref(\n         &mut self,\n         p: &PolyTraitRef,\n-        itctx: &mut ImplTraitContext,\n+        itctx: &ImplTraitContext,\n     ) -> hir::PolyTraitRef<'hir> {\n-        self.lower_lifetime_binder(\n-            p.trait_ref.ref_id,\n-            &p.bound_generic_params,\n-            |lctx, bound_generic_params| {\n-                let trait_ref = lctx.lower_trait_ref(&p.trait_ref, itctx);\n-                hir::PolyTraitRef { bound_generic_params, trait_ref, span: lctx.lower_span(p.span) }\n-            },\n-        )\n+        let bound_generic_params =\n+            self.lower_lifetime_binder(p.trait_ref.ref_id, &p.bound_generic_params);\n+        let trait_ref = self.lower_trait_ref(&p.trait_ref, itctx);\n+        hir::PolyTraitRef { bound_generic_params, trait_ref, span: self.lower_span(p.span) }\n     }\n \n-    fn lower_mt(&mut self, mt: &MutTy, itctx: &mut ImplTraitContext) -> hir::MutTy<'hir> {\n+    fn lower_mt(&mut self, mt: &MutTy, itctx: &ImplTraitContext) -> hir::MutTy<'hir> {\n         hir::MutTy { ty: self.lower_ty(&mt.ty, itctx), mutbl: mt.mutbl }\n     }\n \n     #[instrument(level = \"debug\", skip(self), ret)]\n     fn lower_param_bounds(\n         &mut self,\n         bounds: &[GenericBound],\n-        itctx: &mut ImplTraitContext,\n+        itctx: &ImplTraitContext,\n     ) -> hir::GenericBounds<'hir> {\n         self.arena.alloc_from_iter(self.lower_param_bounds_mut(bounds, itctx))\n     }\n \n-    fn lower_param_bounds_mut<'s, 'b>(\n+    fn lower_param_bounds_mut<'s>(\n         &'s mut self,\n         bounds: &'s [GenericBound],\n-        itctx: &'b mut ImplTraitContext,\n-    ) -> impl Iterator<Item = hir::GenericBound<'hir>> + Captures<'s> + Captures<'a> + Captures<'b>\n-    {\n+        itctx: &'s ImplTraitContext,\n+    ) -> impl Iterator<Item = hir::GenericBound<'hir>> + Captures<'s> + Captures<'a> {\n         bounds.iter().map(move |bound| self.lower_param_bound(bound, itctx))\n     }\n \n@@ -2304,7 +2283,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             node_id,\n             &GenericParamKind::Type { default: None },\n             bounds,\n-            &mut ImplTraitContext::Universal,\n+            &ImplTraitContext::Universal,\n             hir::PredicateOrigin::ImplTrait,\n         );\n "}, {"sha": "6bb1bb9eace8b9c1b5f056e2a76a06b8d6f6090e", "filename": "compiler/rustc_ast_lowering/src/path.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/54f20bbb8a7aeab93da17c0019c1aaa10329245a/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54f20bbb8a7aeab93da17c0019c1aaa10329245a/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs?ref=54f20bbb8a7aeab93da17c0019c1aaa10329245a", "patch": "@@ -22,7 +22,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         qself: &Option<QSelf>,\n         p: &Path,\n         param_mode: ParamMode,\n-        itctx: &mut ImplTraitContext,\n+        itctx: &ImplTraitContext,\n     ) -> hir::QPath<'hir> {\n         let qself_position = qself.as_ref().map(|q| q.position);\n         let qself = qself.as_ref().map(|q| self.lower_ty(&q.ty, itctx));\n@@ -156,7 +156,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     segment,\n                     param_mode,\n                     ParenthesizedGenericArgs::Err,\n-                    &mut ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n+                    &ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n                 )\n             })),\n             span: self.lower_span(p.span),\n@@ -180,7 +180,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         segment: &PathSegment,\n         param_mode: ParamMode,\n         parenthesized_generic_args: ParenthesizedGenericArgs,\n-        itctx: &mut ImplTraitContext,\n+        itctx: &ImplTraitContext,\n     ) -> hir::PathSegment<'hir> {\n         debug!(\"path_span: {:?}, lower_path_segment(segment: {:?})\", path_span, segment,);\n         let (mut generic_args, infer_args) = if let Some(ref generic_args) = segment.args {\n@@ -316,7 +316,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         &mut self,\n         data: &AngleBracketedArgs,\n         param_mode: ParamMode,\n-        itctx: &mut ImplTraitContext,\n+        itctx: &ImplTraitContext,\n     ) -> (GenericArgsCtor<'hir>, bool) {\n         let has_non_lt_args = data.args.iter().any(|arg| match arg {\n             AngleBracketedArg::Arg(ast::GenericArg::Lifetime(_))\n@@ -350,14 +350,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // we generally don't permit such things (see #51008).\n         let ParenthesizedArgs { span, inputs, inputs_span, output } = data;\n         let inputs = self.arena.alloc_from_iter(inputs.iter().map(|ty| {\n-            self.lower_ty_direct(\n-                ty,\n-                &mut ImplTraitContext::Disallowed(ImplTraitPosition::FnTraitParam),\n-            )\n+            self.lower_ty_direct(ty, &ImplTraitContext::Disallowed(ImplTraitPosition::FnTraitParam))\n         }));\n         let output_ty = match output {\n-            FnRetTy::Ty(ty) => self\n-                .lower_ty(&ty, &mut ImplTraitContext::Disallowed(ImplTraitPosition::FnTraitReturn)),\n+            FnRetTy::Ty(ty) => {\n+                self.lower_ty(&ty, &ImplTraitContext::Disallowed(ImplTraitPosition::FnTraitReturn))\n+            }\n             FnRetTy::Default(_) => self.arena.alloc(self.ty_tup(*span, &[])),\n         };\n         let args = smallvec![GenericArg::Type(self.arena.alloc(self.ty_tup(*inputs_span, inputs)))];"}, {"sha": "e55b5ce71cded2766206c2786b623a72cf730333", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/54f20bbb8a7aeab93da17c0019c1aaa10329245a/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54f20bbb8a7aeab93da17c0019c1aaa10329245a/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=54f20bbb8a7aeab93da17c0019c1aaa10329245a", "patch": "@@ -698,11 +698,22 @@ impl<'a> Parser<'a> {\n                     let semicolon_span = self.token.span;\n                     // We have to bail or we'll potentially never make progress.\n                     let non_item_span = self.token.span;\n-                    self.consume_block(Delimiter::Brace, ConsumeClosingDelim::Yes);\n+                    let is_let = self.token.is_keyword(kw::Let);\n+\n                     let mut err = self.struct_span_err(non_item_span, \"non-item in item list\");\n-                    err.span_label(open_brace_span, \"item list starts here\")\n-                        .span_label(non_item_span, \"non-item starts here\")\n-                        .span_label(self.prev_token.span, \"item list ends here\");\n+                    self.consume_block(Delimiter::Brace, ConsumeClosingDelim::Yes);\n+                    if is_let {\n+                        err.span_suggestion(\n+                            non_item_span,\n+                            \"consider using `const` instead of `let` for associated const\",\n+                            \"const\",\n+                            Applicability::MachineApplicable,\n+                        );\n+                    } else {\n+                        err.span_label(open_brace_span, \"item list starts here\")\n+                            .span_label(non_item_span, \"non-item starts here\")\n+                            .span_label(self.prev_token.span, \"item list ends here\");\n+                    }\n                     if is_unnecessary_semicolon {\n                         err.span_suggestion(\n                             semicolon_span,"}, {"sha": "103dd801257a728f2d738174066db1020504a1a2", "filename": "compiler/rustc_parse/src/parser/nonterminal.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/54f20bbb8a7aeab93da17c0019c1aaa10329245a/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54f20bbb8a7aeab93da17c0019c1aaa10329245a/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs?ref=54f20bbb8a7aeab93da17c0019c1aaa10329245a", "patch": "@@ -66,18 +66,18 @@ impl<'a> Parser<'a> {\n             },\n             NonterminalKind::PatParam { .. } | NonterminalKind::PatWithOr { .. } => {\n                 match token.kind {\n-                token::Ident(..) |                  // box, ref, mut, and other identifiers (can stricten)\n-                token::OpenDelim(Delimiter::Parenthesis) |    // tuple pattern\n-                token::OpenDelim(Delimiter::Bracket) |  // slice pattern\n-                token::BinOp(token::And) |          // reference\n-                token::BinOp(token::Minus) |        // negative literal\n-                token::AndAnd |                     // double reference\n-                token::Literal(..) |                // literal\n-                token::DotDot |                     // range pattern (future compat)\n-                token::DotDotDot |                  // range pattern (future compat)\n-                token::ModSep |                     // path\n-                token::Lt |                         // path (UFCS constant)\n-                token::BinOp(token::Shl) => true,   // path (double UFCS)\n+                token::Ident(..) |                          // box, ref, mut, and other identifiers (can stricten)\n+                token::OpenDelim(Delimiter::Parenthesis) |  // tuple pattern\n+                token::OpenDelim(Delimiter::Bracket) |      // slice pattern\n+                token::BinOp(token::And) |                  // reference\n+                token::BinOp(token::Minus) |                // negative literal\n+                token::AndAnd |                             // double reference\n+                token::Literal(..) |                        // literal\n+                token::DotDot |                             // range pattern (future compat)\n+                token::DotDotDot |                          // range pattern (future compat)\n+                token::ModSep |                             // path\n+                token::Lt |                                 // path (UFCS constant)\n+                token::BinOp(token::Shl) => true,           // path (double UFCS)\n                 // leading vert `|` or-pattern\n                 token::BinOp(token::Or) =>  matches!(kind, NonterminalKind::PatWithOr {..}),\n                 token::Interpolated(ref nt) => may_be_ident(nt),"}, {"sha": "932533db05c14066f43ceed4dab20604847c42e0", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/54f20bbb8a7aeab93da17c0019c1aaa10329245a/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54f20bbb8a7aeab93da17c0019c1aaa10329245a/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=54f20bbb8a7aeab93da17c0019c1aaa10329245a", "patch": "@@ -412,7 +412,13 @@ impl Options {\n \n         let to_check = matches.opt_strs(\"check-theme\");\n         if !to_check.is_empty() {\n-            let paths = theme::load_css_paths(static_files::themes::LIGHT.as_bytes());\n+            let paths = match theme::load_css_paths(static_files::themes::LIGHT) {\n+                Ok(p) => p,\n+                Err(e) => {\n+                    diag.struct_err(&e.to_string()).emit();\n+                    return Err(1);\n+                }\n+            };\n             let mut errors = 0;\n \n             println!(\"rustdoc: [check-theme] Starting tests! (Ignoring all other arguments)\");\n@@ -547,7 +553,13 @@ impl Options {\n \n         let mut themes = Vec::new();\n         if matches.opt_present(\"theme\") {\n-            let paths = theme::load_css_paths(static_files::themes::LIGHT.as_bytes());\n+            let paths = match theme::load_css_paths(static_files::themes::LIGHT) {\n+                Ok(p) => p,\n+                Err(e) => {\n+                    diag.struct_err(&e.to_string()).emit();\n+                    return Err(1);\n+                }\n+            };\n \n             for (theme_file, theme_s) in\n                 matches.opt_strs(\"theme\").iter().map(|s| (PathBuf::from(&s), s.to_owned()))"}, {"sha": "8922bf377858e21981838171b29250bf66acfb5e", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/54f20bbb8a7aeab93da17c0019c1aaa10329245a/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54f20bbb8a7aeab93da17c0019c1aaa10329245a/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=54f20bbb8a7aeab93da17c0019c1aaa10329245a", "patch": "@@ -29,6 +29,8 @@ pub(crate) struct HrefContext<'a, 'b, 'c> {\n     /// This field is used to know \"how far\" from the top of the directory we are to link to either\n     /// documentation pages or other source pages.\n     pub(crate) root_path: &'c str,\n+    /// This field is used to calculate precise local URLs.\n+    pub(crate) current_href: &'c str,\n }\n \n /// Decorations are represented as a map from CSS class to vector of character ranges.\n@@ -977,9 +979,9 @@ fn string_without_closing_tag<T: Display>(\n                 // a link to their definition can be generated using this:\n                 // https://github.com/rust-lang/rust/blob/60f1a2fc4b535ead9c85ce085fdce49b1b097531/src/librustdoc/html/render/context.rs#L315-L338\n                 match href {\n-                    LinkFromSrc::Local(span) => context\n-                        .href_from_span(*span, true)\n-                        .map(|s| format!(\"{}{}\", href_context.root_path, s)),\n+                    LinkFromSrc::Local(span) => {\n+                        context.href_from_span_relative(*span, href_context.current_href)\n+                    }\n                     LinkFromSrc::External(def_id) => {\n                         format::href_with_root_path(*def_id, context, Some(href_context.root_path))\n                             .ok()"}, {"sha": "62def4a94e8dccd6026ef4eb95c8c43896609a4a", "filename": "src/librustdoc/html/render/context.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/54f20bbb8a7aeab93da17c0019c1aaa10329245a/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54f20bbb8a7aeab93da17c0019c1aaa10329245a/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs?ref=54f20bbb8a7aeab93da17c0019c1aaa10329245a", "patch": "@@ -31,6 +31,7 @@ use crate::formats::FormatRenderer;\n use crate::html::escape::Escape;\n use crate::html::format::{join_with_double_colon, Buffer};\n use crate::html::markdown::{self, plain_text_summary, ErrorCodes, IdMap};\n+use crate::html::url_parts_builder::UrlPartsBuilder;\n use crate::html::{layout, sources};\n use crate::scrape_examples::AllCallLocations;\n use crate::try_err;\n@@ -370,6 +371,35 @@ impl<'tcx> Context<'tcx> {\n             anchor = anchor\n         ))\n     }\n+\n+    pub(crate) fn href_from_span_relative(\n+        &self,\n+        span: clean::Span,\n+        relative_to: &str,\n+    ) -> Option<String> {\n+        self.href_from_span(span, false).map(|s| {\n+            let mut url = UrlPartsBuilder::new();\n+            let mut dest_href_parts = s.split('/');\n+            let mut cur_href_parts = relative_to.split('/');\n+            for (cur_href_part, dest_href_part) in (&mut cur_href_parts).zip(&mut dest_href_parts) {\n+                if cur_href_part != dest_href_part {\n+                    url.push(dest_href_part);\n+                    break;\n+                }\n+            }\n+            for dest_href_part in dest_href_parts {\n+                url.push(dest_href_part);\n+            }\n+            let loline = span.lo(self.sess()).line;\n+            let hiline = span.hi(self.sess()).line;\n+            format!(\n+                \"{}{}#{}\",\n+                \"../\".repeat(cur_href_parts.count()),\n+                url.finish(),\n+                if loline == hiline { loline.to_string() } else { format!(\"{loline}-{hiline}\") }\n+            )\n+        })\n+    }\n }\n \n /// Generates the documentation for `crate` into the directory `dst`"}, {"sha": "2e2bee78b95f9b441b6f3d6a8f2113d1c98ab8a5", "filename": "src/librustdoc/html/sources.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/54f20bbb8a7aeab93da17c0019c1aaa10329245a/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54f20bbb8a7aeab93da17c0019c1aaa10329245a/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fsources.rs?ref=54f20bbb8a7aeab93da17c0019c1aaa10329245a", "patch": "@@ -288,11 +288,14 @@ pub(crate) fn print_src(\n         }\n     }\n     line_numbers.write_str(\"</pre>\");\n+    let current_href = &context\n+        .href_from_span(clean::Span::new(file_span), false)\n+        .expect(\"only local crates should have sources emitted\");\n     highlight::render_source_with_highlighting(\n         s,\n         buf,\n         line_numbers,\n-        highlight::HrefContext { context, file_span, root_path },\n+        highlight::HrefContext { context, file_span, root_path, current_href },\n         decoration_info,\n     );\n }"}, {"sha": "ccb302620603c05036a8a776ceb231fa9639e11b", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/54f20bbb8a7aeab93da17c0019c1aaa10329245a/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/54f20bbb8a7aeab93da17c0019c1aaa10329245a/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=54f20bbb8a7aeab93da17c0019c1aaa10329245a", "patch": "@@ -497,9 +497,6 @@ img {\n \tfont-weight: 500;\n }\n \n-.block {\n-\tpadding: 0;\n-}\n .block ul, .block li {\n \tpadding: 0;\n \tmargin: 0;\n@@ -1865,12 +1862,6 @@ in storage.js plus the media query with (min-width: 701px)\n \t\tdisplay: none !important;\n \t}\n \n-\t.notable-traits {\n-\t\tposition: absolute;\n-\t\tleft: -22px;\n-\t\ttop: 24px;\n-\t}\n-\n \t#titles > button > div.count {\n \t\tdisplay: block;\n \t}"}, {"sha": "e7a26cb346ee6a2e26a33877f9208f23716cc00b", "filename": "src/librustdoc/theme.rs", "status": "modified", "additions": 187, "deletions": 206, "changes": 393, "blob_url": "https://github.com/rust-lang/rust/blob/54f20bbb8a7aeab93da17c0019c1aaa10329245a/src%2Flibrustdoc%2Ftheme.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54f20bbb8a7aeab93da17c0019c1aaa10329245a/src%2Flibrustdoc%2Ftheme.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftheme.rs?ref=54f20bbb8a7aeab93da17c0019c1aaa10329245a", "patch": "@@ -1,271 +1,252 @@\n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::FxHashMap;\n+use std::collections::hash_map::Entry;\n use std::fs;\n-use std::hash::{Hash, Hasher};\n+use std::iter::Peekable;\n use std::path::Path;\n+use std::str::Chars;\n \n use rustc_errors::Handler;\n \n #[cfg(test)]\n mod tests;\n \n-#[derive(Debug, Clone, Eq)]\n+#[derive(Debug)]\n pub(crate) struct CssPath {\n-    pub(crate) name: String,\n-    pub(crate) children: FxHashSet<CssPath>,\n-}\n-\n-// This PartialEq implementation IS NOT COMMUTATIVE!!!\n-//\n-// The order is very important: the second object must have all first's rules.\n-// However, the first is not required to have all of the second's rules.\n-impl PartialEq for CssPath {\n-    fn eq(&self, other: &CssPath) -> bool {\n-        if self.name != other.name {\n-            false\n-        } else {\n-            for child in &self.children {\n-                if !other.children.iter().any(|c| child == c) {\n-                    return false;\n-                }\n-            }\n-            true\n+    pub(crate) rules: FxHashMap<String, String>,\n+    pub(crate) children: FxHashMap<String, CssPath>,\n+}\n+\n+/// When encountering a `\"` or a `'`, returns the whole string, including the quote characters.\n+fn get_string(iter: &mut Peekable<Chars<'_>>, string_start: char, buffer: &mut String) {\n+    buffer.push(string_start);\n+    while let Some(c) = iter.next() {\n+        buffer.push(c);\n+        if c == '\\\\' {\n+            iter.next();\n+        } else if c == string_start {\n+            break;\n         }\n     }\n }\n \n-impl Hash for CssPath {\n-    fn hash<H: Hasher>(&self, state: &mut H) {\n-        self.name.hash(state);\n-        for x in &self.children {\n-            x.hash(state);\n+fn get_inside_paren(\n+    iter: &mut Peekable<Chars<'_>>,\n+    paren_start: char,\n+    paren_end: char,\n+    buffer: &mut String,\n+) {\n+    buffer.push(paren_start);\n+    while let Some(c) = iter.next() {\n+        handle_common_chars(c, buffer, iter);\n+        if c == paren_end {\n+            break;\n         }\n     }\n }\n \n-impl CssPath {\n-    fn new(name: String) -> CssPath {\n-        CssPath { name, children: FxHashSet::default() }\n+/// Skips a `/*` comment.\n+fn skip_comment(iter: &mut Peekable<Chars<'_>>) {\n+    while let Some(c) = iter.next() {\n+        if c == '*' && iter.next() == Some('/') {\n+            break;\n+        }\n     }\n }\n \n-/// All variants contain the position they occur.\n-#[derive(Debug, Clone, Copy)]\n-enum Events {\n-    StartLineComment(usize),\n-    StartComment(usize),\n-    EndComment(usize),\n-    InBlock(usize),\n-    OutBlock(usize),\n-}\n-\n-impl Events {\n-    fn get_pos(&self) -> usize {\n-        match *self {\n-            Events::StartLineComment(p)\n-            | Events::StartComment(p)\n-            | Events::EndComment(p)\n-            | Events::InBlock(p)\n-            | Events::OutBlock(p) => p,\n+/// Skips a line comment (`//`).\n+fn skip_line_comment(iter: &mut Peekable<Chars<'_>>) {\n+    while let Some(c) = iter.next() {\n+        if c == '\\n' {\n+            break;\n         }\n     }\n-\n-    fn is_comment(&self) -> bool {\n-        matches!(\n-            self,\n-            Events::StartLineComment(_) | Events::StartComment(_) | Events::EndComment(_)\n-        )\n-    }\n }\n \n-fn previous_is_line_comment(events: &[Events]) -> bool {\n-    matches!(events.last(), Some(&Events::StartLineComment(_)))\n-}\n-\n-fn is_line_comment(pos: usize, v: &[u8], events: &[Events]) -> bool {\n-    if let Some(&Events::StartComment(_)) = events.last() {\n-        return false;\n+fn handle_common_chars(c: char, buffer: &mut String, iter: &mut Peekable<Chars<'_>>) {\n+    match c {\n+        '\"' | '\\'' => get_string(iter, c, buffer),\n+        '/' if iter.peek() == Some(&'*') => skip_comment(iter),\n+        '/' if iter.peek() == Some(&'/') => skip_line_comment(iter),\n+        '(' => get_inside_paren(iter, c, ')', buffer),\n+        '[' => get_inside_paren(iter, c, ']', buffer),\n+        _ => buffer.push(c),\n     }\n-    v[pos + 1] == b'/'\n }\n \n-fn load_css_events(v: &[u8]) -> Vec<Events> {\n-    let mut pos = 0;\n-    let mut events = Vec::with_capacity(100);\n-\n-    while pos + 1 < v.len() {\n-        match v[pos] {\n-            b'/' if v[pos + 1] == b'*' => {\n-                events.push(Events::StartComment(pos));\n-                pos += 1;\n-            }\n-            b'/' if is_line_comment(pos, v, &events) => {\n-                events.push(Events::StartLineComment(pos));\n-                pos += 1;\n-            }\n-            b'\\n' if previous_is_line_comment(&events) => {\n-                events.push(Events::EndComment(pos));\n-            }\n-            b'*' if v[pos + 1] == b'/' => {\n-                events.push(Events::EndComment(pos + 2));\n-                pos += 1;\n-            }\n-            b'{' if !previous_is_line_comment(&events) => {\n-                if let Some(&Events::StartComment(_)) = events.last() {\n-                    pos += 1;\n-                    continue;\n-                }\n-                events.push(Events::InBlock(pos + 1));\n-            }\n-            b'}' if !previous_is_line_comment(&events) => {\n-                if let Some(&Events::StartComment(_)) = events.last() {\n-                    pos += 1;\n-                    continue;\n-                }\n-                events.push(Events::OutBlock(pos + 1));\n-            }\n-            _ => {}\n+/// Returns a CSS property name. Ends when encountering a `:` character.\n+///\n+/// If the `:` character isn't found, returns `None`.\n+///\n+/// If a `{` character is encountered, returns an error.\n+fn parse_property_name(iter: &mut Peekable<Chars<'_>>) -> Result<Option<String>, String> {\n+    let mut content = String::new();\n+\n+    while let Some(c) = iter.next() {\n+        match c {\n+            ':' => return Ok(Some(content.trim().to_owned())),\n+            '{' => return Err(\"Unexpected `{` in a `{}` block\".to_owned()),\n+            '}' => break,\n+            _ => handle_common_chars(c, &mut content, iter),\n         }\n-        pos += 1;\n     }\n-    events\n-}\n-\n-fn get_useful_next(events: &[Events], pos: &mut usize) -> Option<Events> {\n-    while *pos < events.len() {\n-        if !events[*pos].is_comment() {\n-            return Some(events[*pos]);\n+    Ok(None)\n+}\n+\n+/// Try to get the value of a CSS property (the `#fff` in `color: #fff`). It'll stop when it\n+/// encounters a `{` or a `;` character.\n+///\n+/// It returns the value string and a boolean set to `true` if the value is ended with a `}` because\n+/// it means that the parent block is done and that we should notify the parent caller.\n+fn parse_property_value(iter: &mut Peekable<Chars<'_>>) -> (String, bool) {\n+    let mut value = String::new();\n+    let mut out_block = false;\n+\n+    while let Some(c) = iter.next() {\n+        match c {\n+            ';' => break,\n+            '}' => {\n+                out_block = true;\n+                break;\n+            }\n+            _ => handle_common_chars(c, &mut value, iter),\n         }\n-        *pos += 1;\n     }\n-    None\n+    (value.trim().to_owned(), out_block)\n }\n \n-fn get_previous_positions(events: &[Events], mut pos: usize) -> Vec<usize> {\n-    let mut ret = Vec::with_capacity(3);\n+/// This is used to parse inside a CSS `{}` block. If we encounter a new `{` inside it, we consider\n+/// it as a new block and therefore recurse into `parse_rules`.\n+fn parse_rules(\n+    content: &str,\n+    selector: String,\n+    iter: &mut Peekable<Chars<'_>>,\n+    paths: &mut FxHashMap<String, CssPath>,\n+) -> Result<(), String> {\n+    let mut rules = FxHashMap::default();\n+    let mut children = FxHashMap::default();\n \n-    ret.push(events[pos].get_pos());\n-    if pos > 0 {\n-        pos -= 1;\n-    }\n     loop {\n-        if pos < 1 || !events[pos].is_comment() {\n-            let x = events[pos].get_pos();\n-            if *ret.last().unwrap() != x {\n-                ret.push(x);\n-            } else {\n-                ret.push(0);\n+        // If the parent isn't a \"normal\" CSS selector, we only expect sub-selectors and not CSS\n+        // properties.\n+        if selector.starts_with('@') {\n+            parse_selectors(content, iter, &mut children)?;\n+            break;\n+        }\n+        let rule = match parse_property_name(iter)? {\n+            Some(r) => {\n+                if r.is_empty() {\n+                    return Err(format!(\"Found empty rule in selector `{selector}`\"));\n+                }\n+                r\n+            }\n+            None => break,\n+        };\n+        let (value, out_block) = parse_property_value(iter);\n+        if value.is_empty() {\n+            return Err(format!(\"Found empty value for rule `{rule}` in selector `{selector}`\"));\n+        }\n+        match rules.entry(rule) {\n+            Entry::Occupied(mut o) => {\n+                *o.get_mut() = value;\n+            }\n+            Entry::Vacant(v) => {\n+                v.insert(value);\n             }\n+        }\n+        if out_block {\n             break;\n         }\n-        ret.push(events[pos].get_pos());\n-        pos -= 1;\n-    }\n-    if ret.len() & 1 != 0 && events[pos].is_comment() {\n-        ret.push(0);\n     }\n-    ret.iter().rev().cloned().collect()\n-}\n-\n-fn build_rule(v: &[u8], positions: &[usize]) -> String {\n-    minifier::css::minify(\n-        &positions\n-            .chunks(2)\n-            .map(|x| ::std::str::from_utf8(&v[x[0]..x[1]]).unwrap_or(\"\"))\n-            .collect::<String>()\n-            .trim()\n-            .chars()\n-            .filter_map(|c| match c {\n-                '\\n' | '\\t' => Some(' '),\n-                '/' | '{' | '}' => None,\n-                c => Some(c),\n-            })\n-            .collect::<String>()\n-            .split(' ')\n-            .filter(|s| !s.is_empty())\n-            .intersperse(\" \")\n-            .collect::<String>(),\n-    )\n-    .map(|css| css.to_string())\n-    .unwrap_or_else(|_| String::new())\n-}\n-\n-fn inner(v: &[u8], events: &[Events], pos: &mut usize) -> FxHashSet<CssPath> {\n-    let mut paths = Vec::with_capacity(50);\n \n-    while *pos < events.len() {\n-        if let Some(Events::OutBlock(_)) = get_useful_next(events, pos) {\n-            *pos += 1;\n-            break;\n+    match paths.entry(selector) {\n+        Entry::Occupied(mut o) => {\n+            let v = o.get_mut();\n+            for (key, value) in rules.into_iter() {\n+                v.rules.insert(key, value);\n+            }\n+            for (sel, child) in children.into_iter() {\n+                v.children.insert(sel, child);\n+            }\n         }\n-        if let Some(Events::InBlock(_)) = get_useful_next(events, pos) {\n-            paths.push(CssPath::new(build_rule(v, &get_previous_positions(events, *pos))));\n-            *pos += 1;\n+        Entry::Vacant(v) => {\n+            v.insert(CssPath { rules, children });\n         }\n-        while let Some(Events::InBlock(_)) = get_useful_next(events, pos) {\n-            if let Some(ref mut path) = paths.last_mut() {\n-                for entry in inner(v, events, pos).iter() {\n-                    path.children.insert(entry.clone());\n-                }\n+    }\n+    Ok(())\n+}\n+\n+pub(crate) fn parse_selectors(\n+    content: &str,\n+    iter: &mut Peekable<Chars<'_>>,\n+    paths: &mut FxHashMap<String, CssPath>,\n+) -> Result<(), String> {\n+    let mut selector = String::new();\n+\n+    while let Some(c) = iter.next() {\n+        match c {\n+            '{' => {\n+                let s = minifier::css::minify(selector.trim()).map(|s| s.to_string())?;\n+                parse_rules(content, s, iter, paths)?;\n+                selector.clear();\n             }\n-        }\n-        if let Some(Events::OutBlock(_)) = get_useful_next(events, pos) {\n-            *pos += 1;\n+            '}' => break,\n+            ';' => selector.clear(), // We don't handle inline selectors like `@import`.\n+            _ => handle_common_chars(c, &mut selector, iter),\n         }\n     }\n-    paths.iter().cloned().collect()\n-}\n-\n-pub(crate) fn load_css_paths(v: &[u8]) -> CssPath {\n-    let events = load_css_events(v);\n-    let mut pos = 0;\n-\n-    let mut parent = CssPath::new(\"parent\".to_owned());\n-    parent.children = inner(v, &events, &mut pos);\n-    parent\n-}\n-\n-pub(crate) fn get_differences(against: &CssPath, other: &CssPath, v: &mut Vec<String>) {\n-    if against.name == other.name {\n-        for child in &against.children {\n-            let mut found = false;\n-            let mut found_working = false;\n-            let mut tmp = Vec::new();\n-\n-            for other_child in &other.children {\n-                if child.name == other_child.name {\n-                    if child != other_child {\n-                        get_differences(child, other_child, &mut tmp);\n-                    } else {\n-                        found_working = true;\n+    Ok(())\n+}\n+\n+/// The entry point to parse the CSS rules. Every time we encounter a `{`, we then parse the rules\n+/// inside it.\n+pub(crate) fn load_css_paths(content: &str) -> Result<FxHashMap<String, CssPath>, String> {\n+    let mut iter = content.chars().peekable();\n+    let mut paths = FxHashMap::default();\n+\n+    parse_selectors(content, &mut iter, &mut paths)?;\n+    Ok(paths)\n+}\n+\n+pub(crate) fn get_differences(\n+    origin: &FxHashMap<String, CssPath>,\n+    against: &FxHashMap<String, CssPath>,\n+    v: &mut Vec<String>,\n+) {\n+    for (selector, entry) in origin.iter() {\n+        match against.get(selector) {\n+            Some(a) => {\n+                get_differences(&entry.children, &a.children, v);\n+                if selector == \":root\" {\n+                    // We need to check that all variables have been set.\n+                    for rule in entry.rules.keys() {\n+                        if !a.rules.contains_key(rule) {\n+                            v.push(format!(\"  Missing CSS variable `{rule}` in `:root`\"));\n+                        }\n                     }\n-                    found = true;\n-                    break;\n                 }\n             }\n-            if !found {\n-                v.push(format!(\"  Missing \\\"{}\\\" rule\", child.name));\n-            } else if !found_working {\n-                v.extend(tmp.iter().cloned());\n-            }\n+            None => v.push(format!(\"  Missing rule `{selector}`\")),\n         }\n     }\n }\n \n pub(crate) fn test_theme_against<P: AsRef<Path>>(\n     f: &P,\n-    against: &CssPath,\n+    origin: &FxHashMap<String, CssPath>,\n     diag: &Handler,\n ) -> (bool, Vec<String>) {\n-    let data = match fs::read(f) {\n+    let against = match fs::read_to_string(f)\n+        .map_err(|e| e.to_string())\n+        .and_then(|data| load_css_paths(&data))\n+    {\n         Ok(c) => c,\n         Err(e) => {\n-            diag.struct_err(&e.to_string()).emit();\n+            diag.struct_err(&e).emit();\n             return (false, vec![]);\n         }\n     };\n \n-    let paths = load_css_paths(&data);\n     let mut ret = vec![];\n-    get_differences(against, &paths, &mut ret);\n+    get_differences(origin, &against, &mut ret);\n     (true, ret)\n }"}, {"sha": "08a174d27d35740f6e1aa6de553dc28d3957162b", "filename": "src/librustdoc/theme/tests.rs", "status": "modified", "additions": 95, "deletions": 25, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/54f20bbb8a7aeab93da17c0019c1aaa10329245a/src%2Flibrustdoc%2Ftheme%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54f20bbb8a7aeab93da17c0019c1aaa10329245a/src%2Flibrustdoc%2Ftheme%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftheme%2Ftests.rs?ref=54f20bbb8a7aeab93da17c0019c1aaa10329245a", "patch": "@@ -44,11 +44,7 @@ rule j end {}\n \"#;\n \n     let mut ret = Vec::new();\n-    get_differences(\n-        &load_css_paths(against.as_bytes()),\n-        &load_css_paths(text.as_bytes()),\n-        &mut ret,\n-    );\n+    get_differences(&load_css_paths(against).unwrap(), &load_css_paths(text).unwrap(), &mut ret);\n     assert!(ret.is_empty());\n }\n \n@@ -61,57 +57,131 @@ a\n c // sdf\n d {}\n \"#;\n-    let paths = load_css_paths(text.as_bytes());\n-    assert!(paths.children.contains(&CssPath::new(\"a b c d\".to_owned())));\n+    let paths = load_css_paths(text).unwrap();\n+    assert!(paths.contains_key(&\"a b c d\".to_owned()));\n }\n \n #[test]\n fn test_comparison() {\n-    let x = r#\"\n-a {\n-    b {\n-        c {}\n-    }\n+    let origin = r#\"\n+@a {\n+    b {}\n+    c {}\n }\n \"#;\n \n-    let y = r#\"\n-a {\n+    let against = r#\"\n+@a {\n     b {}\n }\n \"#;\n \n-    let against = load_css_paths(y.as_bytes());\n-    let other = load_css_paths(x.as_bytes());\n+    let origin = load_css_paths(origin).unwrap();\n+    let against = load_css_paths(against).unwrap();\n \n     let mut ret = Vec::new();\n-    get_differences(&against, &other, &mut ret);\n+    get_differences(&against, &origin, &mut ret);\n     assert!(ret.is_empty());\n-    get_differences(&other, &against, &mut ret);\n-    assert_eq!(ret, vec![\"  Missing \\\"c\\\" rule\".to_owned()]);\n+    get_differences(&origin, &against, &mut ret);\n+    assert_eq!(ret, vec![\"  Missing rule `c`\".to_owned()]);\n }\n \n #[test]\n fn check_empty_css() {\n-    let events = load_css_events(&[]);\n-    assert_eq!(events.len(), 0);\n+    let paths = load_css_paths(\"\").unwrap();\n+    assert_eq!(paths.len(), 0);\n }\n \n #[test]\n fn check_invalid_css() {\n-    let events = load_css_events(b\"*\");\n-    assert_eq!(events.len(), 0);\n+    let paths = load_css_paths(\"*\").unwrap();\n+    assert_eq!(paths.len(), 0);\n }\n \n #[test]\n fn test_with_minification() {\n     let text = include_str!(\"../html/static/css/themes/dark.css\");\n     let minified = minifier::css::minify(&text).expect(\"CSS minification failed\").to_string();\n \n-    let against = load_css_paths(text.as_bytes());\n-    let other = load_css_paths(minified.as_bytes());\n+    let against = load_css_paths(text).unwrap();\n+    let other = load_css_paths(&minified).unwrap();\n+\n+    let mut ret = Vec::new();\n+    get_differences(&against, &other, &mut ret);\n+    assert!(ret.is_empty());\n+}\n+\n+#[test]\n+fn test_media() {\n+    let text = r#\"\n+@media (min-width: 701px) {\n+    a:hover {\n+        color: #fff;\n+    }\n+\n+    b {\n+        x: y;\n+    }\n+}\n+\n+@media (max-width: 1001px) {\n+    b {\n+        x: y;\n+    }\n+}\n+\"#;\n+\n+    let paths = load_css_paths(text).unwrap();\n+    let p = paths.get(\"@media (min-width:701px)\");\n+    assert!(p.is_some());\n+    let p = p.unwrap();\n+    assert!(p.children.get(\"a:hover\").is_some());\n+    assert!(p.children.get(\"b\").is_some());\n+\n+    let p = paths.get(\"@media (max-width:1001px)\");\n+    assert!(p.is_some());\n+    let p = p.unwrap();\n+    assert!(p.children.get(\"b\").is_some());\n+}\n+\n+#[test]\n+fn test_css_variables() {\n+    let x = r#\"\n+:root {\n+    --a: #fff;\n+}\n+\"#;\n+\n+    let y = r#\"\n+:root {\n+    --a: #fff;\n+    --b: #fff;\n+}\n+\"#;\n+\n+    let against = load_css_paths(x).unwrap();\n+    let other = load_css_paths(y).unwrap();\n \n     let mut ret = Vec::new();\n     get_differences(&against, &other, &mut ret);\n     assert!(ret.is_empty());\n+    get_differences(&other, &against, &mut ret);\n+    assert_eq!(ret, vec![\"  Missing CSS variable `--b` in `:root`\".to_owned()]);\n+}\n+\n+#[test]\n+fn test_weird_rule_value() {\n+    let x = r#\"\n+a[text=(\"a\")] {\n+    b: url({;}.png);\n+    c: #fff\n+}\n+\"#;\n+\n+    let paths = load_css_paths(&x).unwrap();\n+    let p = paths.get(\"a[text=(\\\"a\\\")]\");\n+    assert!(p.is_some());\n+    let p = p.unwrap();\n+    assert_eq!(p.rules.get(\"b\"), Some(&\"url({;}.png)\".to_owned()));\n+    assert_eq!(p.rules.get(\"c\"), Some(&\"#fff\".to_owned()));\n }"}, {"sha": "e12d8445f4fa3788e5db0efb9f3650a9d7ef2f90", "filename": "src/test/rustdoc/check-source-code-urls-to-def-std.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/54f20bbb8a7aeab93da17c0019c1aaa10329245a/src%2Ftest%2Frustdoc%2Fcheck-source-code-urls-to-def-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54f20bbb8a7aeab93da17c0019c1aaa10329245a/src%2Ftest%2Frustdoc%2Fcheck-source-code-urls-to-def-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fcheck-source-code-urls-to-def-std.rs?ref=54f20bbb8a7aeab93da17c0019c1aaa10329245a", "patch": "@@ -9,7 +9,7 @@ fn babar() {}\n // @has - '//a[@href=\"{{channel}}/std/primitive.u32.html\"]' 'u32'\n // @has - '//a[@href=\"{{channel}}/std/primitive.str.html\"]' 'str'\n // @has - '//a[@href=\"{{channel}}/std/primitive.bool.html\"]' 'bool'\n-// @has - '//a[@href=\"../../src/foo/check-source-code-urls-to-def-std.rs.html#7\"]' 'babar'\n+// @has - '//a[@href=\"#7\"]' 'babar'\n pub fn foo(a: u32, b: &str, c: String) {\n     let x = 12;\n     let y: bool = true;\n@@ -31,12 +31,12 @@ macro_rules! data {\n pub fn another_foo() {\n     // This is known limitation: if the macro doesn't generate anything, the visitor\n     // can't find any item or anything that could tell us that it comes from expansion.\n-    // @!has - '//a[@href=\"../../src/foo/check-source-code-urls-to-def-std.rs.html#19\"]' 'yolo!'\n+    // @!has - '//a[@href=\"#19\"]' 'yolo!'\n     yolo!();\n     // @has - '//a[@href=\"{{channel}}/std/macro.eprintln.html\"]' 'eprintln!'\n     eprintln!();\n-    // @has - '//a[@href=\"../../src/foo/check-source-code-urls-to-def-std.rs.html#27-29\"]' 'data!'\n+    // @has - '//a[@href=\"#27-29\"]' 'data!'\n     let x = data!(4);\n-    // @has - '//a[@href=\"../../src/foo/check-source-code-urls-to-def-std.rs.html#23-25\"]' 'bar!'\n+    // @has - '//a[@href=\"#23-25\"]' 'bar!'\n     bar!(x);\n }"}, {"sha": "d00a3e3551991d63aa14b22f3817ea87a2451851", "filename": "src/test/rustdoc/check-source-code-urls-to-def.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/54f20bbb8a7aeab93da17c0019c1aaa10329245a/src%2Ftest%2Frustdoc%2Fcheck-source-code-urls-to-def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54f20bbb8a7aeab93da17c0019c1aaa10329245a/src%2Ftest%2Frustdoc%2Fcheck-source-code-urls-to-def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fcheck-source-code-urls-to-def.rs?ref=54f20bbb8a7aeab93da17c0019c1aaa10329245a", "patch": "@@ -10,14 +10,14 @@ extern crate source_code;\n \n // @has 'src/foo/check-source-code-urls-to-def.rs.html'\n \n-// @has - '//a[@href=\"../../src/foo/auxiliary/source-code-bar.rs.html#1-17\"]' 'bar'\n+// @has - '//a[@href=\"auxiliary/source-code-bar.rs.html#1-17\"]' 'bar'\n #[path = \"auxiliary/source-code-bar.rs\"]\n pub mod bar;\n \n-// @count - '//a[@href=\"../../src/foo/auxiliary/source-code-bar.rs.html#5\"]' 4\n+// @count - '//a[@href=\"auxiliary/source-code-bar.rs.html#5\"]' 4\n use bar::Bar;\n-// @has - '//a[@href=\"../../src/foo/auxiliary/source-code-bar.rs.html#13\"]' 'self'\n-// @has - '//a[@href=\"../../src/foo/auxiliary/source-code-bar.rs.html#14\"]' 'Trait'\n+// @has - '//a[@href=\"auxiliary/source-code-bar.rs.html#13\"]' 'self'\n+// @has - '//a[@href=\"auxiliary/source-code-bar.rs.html#14\"]' 'Trait'\n use bar::sub::{self, Trait};\n \n pub struct Foo;\n@@ -31,26 +31,26 @@ fn babar() {}\n // @has - '//a/@href' '/struct.String.html'\n // @has - '//a/@href' '/primitive.u32.html'\n // @has - '//a/@href' '/primitive.str.html'\n-// @count - '//a[@href=\"../../src/foo/check-source-code-urls-to-def.rs.html#23\"]' 5\n+// @count - '//a[@href=\"#23\"]' 5\n // @has - '//a[@href=\"../../source_code/struct.SourceCode.html\"]' 'source_code::SourceCode'\n pub fn foo(a: u32, b: &str, c: String, d: Foo, e: bar::Bar, f: source_code::SourceCode) {\n     let x = 12;\n     let y: Foo = Foo;\n     let z: Bar = bar::Bar { field: Foo };\n     babar();\n-    // @has - '//a[@href=\"../../src/foo/check-source-code-urls-to-def.rs.html#26\"]' 'hello'\n+    // @has - '//a[@href=\"#26\"]' 'hello'\n     y.hello();\n }\n \n-// @has - '//a[@href=\"../../src/foo/auxiliary/source-code-bar.rs.html#14\"]' 'bar::sub::Trait'\n-// @has - '//a[@href=\"../../src/foo/auxiliary/source-code-bar.rs.html#14\"]' 'Trait'\n+// @has - '//a[@href=\"auxiliary/source-code-bar.rs.html#14\"]' 'bar::sub::Trait'\n+// @has - '//a[@href=\"auxiliary/source-code-bar.rs.html#14\"]' 'Trait'\n pub fn foo2<T: bar::sub::Trait, V: Trait>(t: &T, v: &V, b: bool) {}\n \n pub trait AnotherTrait {}\n pub trait WhyNot {}\n \n-// @has - '//a[@href=\"../../src/foo/check-source-code-urls-to-def.rs.html#49\"]' 'AnotherTrait'\n-// @has - '//a[@href=\"../../src/foo/check-source-code-urls-to-def.rs.html#50\"]' 'WhyNot'\n+// @has - '//a[@href=\"#49\"]' 'AnotherTrait'\n+// @has - '//a[@href=\"#50\"]' 'WhyNot'\n pub fn foo3<T, V>(t: &T, v: &V)\n where\n     T: AnotherTrait,\n@@ -59,7 +59,7 @@ where\n \n pub trait AnotherTrait2 {}\n \n-// @has - '//a[@href=\"../../src/foo/check-source-code-urls-to-def.rs.html#60\"]' 'AnotherTrait2'\n+// @has - '//a[@href=\"#60\"]' 'AnotherTrait2'\n pub fn foo4() {\n     let x: Vec<AnotherTrait2> = Vec::new();\n }"}, {"sha": "259f37b23a5845bc78580a65f7c33e2297d883ac", "filename": "src/test/ui/parser/suggest-assoc-const.fixed", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/54f20bbb8a7aeab93da17c0019c1aaa10329245a/src%2Ftest%2Fui%2Fparser%2Fsuggest-assoc-const.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/54f20bbb8a7aeab93da17c0019c1aaa10329245a/src%2Ftest%2Fui%2Fparser%2Fsuggest-assoc-const.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fsuggest-assoc-const.fixed?ref=54f20bbb8a7aeab93da17c0019c1aaa10329245a", "patch": "@@ -0,0 +1,10 @@\n+// Issue: 101797, Suggest associated const for incorrect use of let in traits\n+// run-rustfix\n+trait Trait {\n+    const _X: i32;\n+    //~^ ERROR non-item in item list\n+}\n+\n+fn main() {\n+\n+}"}, {"sha": "c7be712ec076e2efe894d8c3b7c9758b20fb0fbb", "filename": "src/test/ui/parser/suggest-assoc-const.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/54f20bbb8a7aeab93da17c0019c1aaa10329245a/src%2Ftest%2Fui%2Fparser%2Fsuggest-assoc-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54f20bbb8a7aeab93da17c0019c1aaa10329245a/src%2Ftest%2Fui%2Fparser%2Fsuggest-assoc-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fsuggest-assoc-const.rs?ref=54f20bbb8a7aeab93da17c0019c1aaa10329245a", "patch": "@@ -0,0 +1,10 @@\n+// Issue: 101797, Suggest associated const for incorrect use of let in traits\n+// run-rustfix\n+trait Trait {\n+    let _X: i32;\n+    //~^ ERROR non-item in item list\n+}\n+\n+fn main() {\n+\n+}"}, {"sha": "2ddfa07c5be4714af6666629ec69e38fe1c06ac1", "filename": "src/test/ui/parser/suggest-assoc-const.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/54f20bbb8a7aeab93da17c0019c1aaa10329245a/src%2Ftest%2Fui%2Fparser%2Fsuggest-assoc-const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/54f20bbb8a7aeab93da17c0019c1aaa10329245a/src%2Ftest%2Fui%2Fparser%2Fsuggest-assoc-const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fsuggest-assoc-const.stderr?ref=54f20bbb8a7aeab93da17c0019c1aaa10329245a", "patch": "@@ -0,0 +1,8 @@\n+error: non-item in item list\n+  --> $DIR/suggest-assoc-const.rs:4:5\n+   |\n+LL |     let _X: i32;\n+   |     ^^^ help: consider using `const` instead of `let` for associated const: `const`\n+\n+error: aborting due to previous error\n+"}]}