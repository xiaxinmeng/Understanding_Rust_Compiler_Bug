{"sha": "39d33a653fd4aebae813ec6ad83ea2ea6009c64f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5ZDMzYTY1M2ZkNGFlYmFlODEzZWM2YWQ4M2VhMmVhNjAwOWM2NGY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-09-15T04:58:04Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-09-15T14:35:09Z"}, "message": "regionck: fix bug where autoref regions are not inferred to be large enough", "tree": {"sha": "f85bca6f2c2e64f5b5b84f4b1f2c264687fbc0e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f85bca6f2c2e64f5b5b84f4b1f2c264687fbc0e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/39d33a653fd4aebae813ec6ad83ea2ea6009c64f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/39d33a653fd4aebae813ec6ad83ea2ea6009c64f", "html_url": "https://github.com/rust-lang/rust/commit/39d33a653fd4aebae813ec6ad83ea2ea6009c64f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/39d33a653fd4aebae813ec6ad83ea2ea6009c64f/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6332c2d728f82188c415e335142bc042ff1d7ad0", "url": "https://api.github.com/repos/rust-lang/rust/commits/6332c2d728f82188c415e335142bc042ff1d7ad0", "html_url": "https://github.com/rust-lang/rust/commit/6332c2d728f82188c415e335142bc042ff1d7ad0"}], "stats": {"total": 145, "additions": 101, "deletions": 44}, "files": [{"sha": "109c1f636441e1132bc26641335aa71fee633bd3", "filename": "src/rustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 46, "deletions": 30, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/39d33a653fd4aebae813ec6ad83ea2ea6009c64f/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d33a653fd4aebae813ec6ad83ea2ea6009c64f/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=39d33a653fd4aebae813ec6ad83ea2ea6009c64f", "patch": "@@ -338,39 +338,49 @@ impl gather_loan_ctxt {\n             };\n \n             match result {\n-              Ok(pc_ok) => {\n-                // we were able guarantee the validity of the ptr,\n-                // perhaps by rooting or because it is immutably\n-                // rooted.  good.\n-                self.bccx.stable_paths += 1;\n-              }\n-              Ok(pc_if_pure(e)) => {\n-                // we are only able to guarantee the validity if\n-                // the scope is pure\n-                match scope_r {\n-                  ty::re_scope(pure_id) => {\n-                    // if the scope is some block/expr in the fn,\n-                    // then just require that this scope be pure\n-                    self.req_maps.pure_map.insert(pure_id, e);\n-                    self.bccx.req_pure_paths += 1;\n-\n-                    if self.tcx().sess.borrowck_note_pure() {\n-                        self.bccx.span_note(\n-                            cmt.span,\n-                            fmt!(\"purity required\"));\n+                Ok(pc_ok) => {\n+                    debug!(\"result of preserve: pc_ok\");\n+\n+                    // we were able guarantee the validity of the ptr,\n+                    // perhaps by rooting or because it is immutably\n+                    // rooted.  good.\n+                    self.bccx.stable_paths += 1;\n+                }\n+                Ok(pc_if_pure(e)) => {\n+                    debug!(\"result of preserve: %?\", pc_if_pure(e));\n+\n+                    // we are only able to guarantee the validity if\n+                    // the scope is pure\n+                    match scope_r {\n+                        ty::re_scope(pure_id) => {\n+                            // if the scope is some block/expr in the\n+                            // fn, then just require that this scope\n+                            // be pure\n+                            self.req_maps.pure_map.insert(pure_id, e);\n+                            self.bccx.req_pure_paths += 1;\n+\n+                            debug!(\"requiring purity for scope %?\",\n+                                   scope_r);\n+\n+                            if self.tcx().sess.borrowck_note_pure() {\n+                                self.bccx.span_note(\n+                                    cmt.span,\n+                                    fmt!(\"purity required\"));\n+                            }\n+                        }\n+                        _ => {\n+                            // otherwise, we can't enforce purity for\n+                            // that scope, so give up and report an\n+                            // error\n+                            self.bccx.report(e);\n+                        }\n                     }\n-                  }\n-                  _ => {\n-                    // otherwise, we can't enforce purity for that\n-                    // scope, so give up and report an error\n+                }\n+                Err(e) => {\n+                    // we cannot guarantee the validity of this pointer\n+                    debug!(\"result of preserve: error\");\n                     self.bccx.report(e);\n-                  }\n                 }\n-              }\n-              Err(e) => {\n-                // we cannot guarantee the validity of this pointer\n-                self.bccx.report(e);\n-              }\n             }\n           }\n         }\n@@ -386,13 +396,19 @@ impl gather_loan_ctxt {\n     // mutable memory.\n     fn check_mutbl(req_mutbl: ast::mutability,\n                    cmt: cmt) -> bckres<preserve_condition> {\n+        debug!(\"check_mutbl(req_mutbl=%?, cmt.mutbl=%?)\",\n+               req_mutbl, cmt.mutbl);\n+\n         if req_mutbl == m_const || req_mutbl == cmt.mutbl {\n+            debug!(\"required is const or they are the same\");\n             Ok(pc_ok)\n         } else {\n             let e = {cmt: cmt,\n                      code: err_mutbl(req_mutbl)};\n             if req_mutbl == m_imm {\n                 // you can treat mutable things as imm if you are pure\n+                debug!(\"imm required, must be pure\");\n+\n                 Ok(pc_if_pure(e))\n             } else {\n                 Err(e)"}, {"sha": "0223fed38373586f22fb1f20318940bea7f304bd", "filename": "src/rustc/middle/typeck/check/method.rs", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/39d33a653fd4aebae813ec6ad83ea2ea6009c64f/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d33a653fd4aebae813ec6ad83ea2ea6009c64f/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=39d33a653fd4aebae813ec6ad83ea2ea6009c64f", "patch": "@@ -758,6 +758,9 @@ impl LookupContext {\n     }\n \n     fn is_relevant(&self, self_ty: ty::t, candidate: &Candidate) -> bool {\n+        debug!(\"is_relevant(self_ty=%s, candidate=%s)\",\n+               self.ty_to_str(self_ty), self.cand_to_str(candidate));\n+\n         self.fcx.can_mk_subty(self_ty, candidate.rcvr_ty).is_ok()\n     }\n \n@@ -782,7 +785,7 @@ impl LookupContext {\n         }\n     }\n \n-    fn report_candidate(idx: uint, origin: &method_origin) {\n+    fn report_candidate(&self, idx: uint, origin: &method_origin) {\n         match *origin {\n             method_static(impl_did) => {\n                 self.report_static_candidate(idx, impl_did)\n@@ -796,7 +799,7 @@ impl LookupContext {\n         }\n     }\n \n-    fn report_static_candidate(idx: uint, did: def_id) {\n+    fn report_static_candidate(&self, idx: uint, did: def_id) {\n         let span = if did.crate == ast::local_crate {\n             match self.tcx().items.get(did.node) {\n               ast_map::node_method(m, _, _) => m.span,\n@@ -812,15 +815,15 @@ impl LookupContext {\n                  ty::item_path_str(self.tcx(), did)));\n     }\n \n-    fn report_param_candidate(idx: uint, did: def_id) {\n+    fn report_param_candidate(&self, idx: uint, did: def_id) {\n         self.tcx().sess.span_note(\n             self.expr.span,\n             fmt!(\"candidate #%u derives from the bound `%s`\",\n                  (idx+1u),\n                  ty::item_path_str(self.tcx(), did)));\n     }\n \n-    fn report_trait_candidate(idx: uint, did: def_id) {\n+    fn report_trait_candidate(&self, idx: uint, did: def_id) {\n         self.tcx().sess.span_note(\n             self.expr.span,\n             fmt!(\"candidate #%u derives from the type of the receiver, \\\n@@ -829,23 +832,31 @@ impl LookupContext {\n                  ty::item_path_str(self.tcx(), did)));\n     }\n \n-    fn infcx() -> infer::infer_ctxt {\n+    fn infcx(&self) -> infer::infer_ctxt {\n         self.fcx.inh.infcx\n     }\n \n-    fn tcx() -> ty::ctxt {\n+    fn tcx(&self) -> ty::ctxt {\n         self.fcx.tcx()\n     }\n \n-    fn ty_to_str(t: ty::t) -> ~str {\n+    fn ty_to_str(&self, t: ty::t) -> ~str {\n         self.fcx.infcx().ty_to_str(t)\n     }\n \n-    fn did_to_str(did: def_id) -> ~str {\n+    fn cand_to_str(&self, cand: &Candidate) -> ~str {\n+        fmt!(\"Candidate(rcvr_ty=%s, rcvr_substs=%s, self_mode=%?, origin=%?)\",\n+             self.ty_to_str(cand.rcvr_ty),\n+             ty::substs_to_str(self.tcx(), &cand.rcvr_substs),\n+             cand.self_mode,\n+             cand.origin)\n+    }\n+\n+    fn did_to_str(&self, did: def_id) -> ~str {\n         ty::item_path_str(self.tcx(), did)\n     }\n \n-    fn bug(s: ~str) -> ! {\n+    fn bug(&self, s: ~str) -> ! {\n         self.tcx().sess.bug(s)\n     }\n }"}, {"sha": "1eedb572d2c8fd3cb9c705195a1482de2a1d0177", "filename": "src/rustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 34, "deletions": 4, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/39d33a653fd4aebae813ec6ad83ea2ea6009c64f/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d33a653fd4aebae813ec6ad83ea2ea6009c64f/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=39d33a653fd4aebae813ec6ad83ea2ea6009c64f", "patch": "@@ -159,8 +159,6 @@ fn visit_expr(expr: @ast::expr, &&rcx: @rcx, v: rvt) {\n     debug!(\"visit_expr(e=%s)\",\n            pprust::expr_to_str(expr, rcx.fcx.tcx().sess.intr()));\n \n-    // constrain_auto_ref(rcx, expr);\n-\n     match expr.node {\n         ast::expr_path(*) => {\n             // Avoid checking the use of local variables, as we\n@@ -176,6 +174,36 @@ fn visit_expr(expr: @ast::expr, &&rcx: @rcx, v: rvt) {\n             }\n         }\n \n+        ast::expr_call(callee, args, _) => {\n+            // Check for a.b() where b is a method.  Ensure that\n+            // any types in the callee are valid for the entire\n+            // method call.\n+\n+            // FIXME(#3387)--we should really invoke\n+            // `constrain_auto_ref()` on all exprs.  But that causes a\n+            // lot of spurious errors because of how the region\n+            // hierarchy is setup.\n+            let tcx = rcx.fcx.tcx();\n+            if rcx.fcx.ccx.method_map.contains_key(callee.id) {\n+                match callee.node {\n+                    ast::expr_field(base, _, _) => {\n+                        constrain_auto_ref(rcx, base);\n+                    }\n+                    _ => {\n+                        tcx.sess.span_bug(\n+                            callee.span,\n+                            ~\"call of method that is not a field\");\n+                    }\n+                }\n+            } else {\n+                constrain_auto_ref(rcx, callee);\n+            }\n+\n+            for args.each |arg| {\n+                constrain_auto_ref(rcx, arg);\n+            }\n+        }\n+\n         ast::expr_cast(source, _) => {\n             // Determine if we are casting `source` to an trait\n             // instance.  If so, we have to be sure that the type of\n@@ -275,15 +303,17 @@ fn constrain_auto_ref(\n      * function ensures that the lifetime of the resulting borrowed\n      * ptr includes at least the expression `expr`. */\n \n+    debug!(\"constrain_auto_ref(expr=%s)\", rcx.fcx.expr_to_str(expr));\n+\n     let adjustment = rcx.fcx.inh.adjustments.find(expr.id);\n     let region = match adjustment {\n         Some(@{autoref: Some(ref auto_ref), _}) => auto_ref.region,\n         _ => { return; }\n     };\n \n     let tcx = rcx.fcx.tcx();\n-    let expr_region = ty::re_scope(expr.id);\n-    match rcx.fcx.mk_subr(true, expr.span, expr_region, region) {\n+    let encl_region = ty::encl_region(tcx, expr.id);\n+    match rcx.fcx.mk_subr(true, expr.span, encl_region, region) {\n         result::Ok(()) => {}\n         result::Err(_) => {\n             // In practice, this cannot happen: `region` is always a"}, {"sha": "4f2eb7c7c753c37cccfb9e14b7370798d460a888", "filename": "src/rustc/middle/typeck/infer/region_var_bindings.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39d33a653fd4aebae813ec6ad83ea2ea6009c64f/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_var_bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d33a653fd4aebae813ec6ad83ea2ea6009c64f/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_var_bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_var_bindings.rs?ref=39d33a653fd4aebae813ec6ad83ea2ea6009c64f", "patch": "@@ -583,7 +583,7 @@ impl RegionVarBindings {\n     }\n \n     fn resolve_var(rid: RegionVid) -> ty::region {\n-        debug!(\"RegionVarBindings: resolve_var(%?)\", rid);\n+        debug!(\"RegionVarBindings: resolve_var(%?=%u)\", rid, *rid);\n         if self.values.is_empty() {\n             self.tcx.sess.span_bug(\n                 self.var_spans[*rid],"}]}