{"sha": "80a7e2644c86846e06907a6bed5b0d7773051d20", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwYTdlMjY0NGM4Njg0NmUwNjkwN2E2YmVkNWIwZDc3NzMwNTFkMjA=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-05-15T00:46:52Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-05-15T01:13:45Z"}, "message": "rustpkg: Tests for well-formed and ill-formed package IDs...\n\n...and cleanup, making how we handle version numbers more rational\n(specifically, not passing in a versioned name to rustc\nwith the -o flag), and removing unused code.", "tree": {"sha": "049da5a7ff176e4f25350750cb72cf24f9412711", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/049da5a7ff176e4f25350750cb72cf24f9412711"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/80a7e2644c86846e06907a6bed5b0d7773051d20", "comment_count": 6, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/80a7e2644c86846e06907a6bed5b0d7773051d20", "html_url": "https://github.com/rust-lang/rust/commit/80a7e2644c86846e06907a6bed5b0d7773051d20", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/80a7e2644c86846e06907a6bed5b0d7773051d20/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c3875e8c7066b5879437b3a5b578a6665fe767f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3875e8c7066b5879437b3a5b578a6665fe767f2", "html_url": "https://github.com/rust-lang/rust/commit/c3875e8c7066b5879437b3a5b578a6665fe767f2"}], "stats": {"total": 392, "additions": 121, "deletions": 271}, "files": [{"sha": "680e0924d798c033fbf072e7fd1286481cce7882", "filename": "src/librustpkg/conditions.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/80a7e2644c86846e06907a6bed5b0d7773051d20/src%2Flibrustpkg%2Fconditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a7e2644c86846e06907a6bed5b0d7773051d20/src%2Flibrustpkg%2Fconditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fconditions.rs?ref=80a7e2644c86846e06907a6bed5b0d7773051d20", "patch": "@@ -28,3 +28,7 @@ condition! {\n condition! {\n     missing_pkg_files: (super::PkgId) -> ();\n }\n+\n+condition! {\n+    bad_pkg_id: (super::Path, ~str) -> ::util::PkgId;\n+}"}, {"sha": "bbd8d09235484f32689655997a5acaaeb2dc9de8", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/80a7e2644c86846e06907a6bed5b0d7773051d20/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a7e2644c86846e06907a6bed5b0d7773051d20/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=80a7e2644c86846e06907a6bed5b0d7773051d20", "patch": "@@ -35,7 +35,7 @@ pub fn make_dir_rwx(p: &Path) -> bool { os::make_dir(p, u_rwx) }\n \n /// True if there's a directory in <workspace> with\n /// pkgid's short name\n-pub fn workspace_contains_package_id(pkgid: PkgId, workspace: &Path) -> bool {\n+pub fn workspace_contains_package_id(pkgid: &PkgId, workspace: &Path) -> bool {\n     let pkgpath = workspace.push(\"src\").push(pkgid.local_path.to_str());\n     os::path_is_dir(&pkgpath)\n }\n@@ -67,17 +67,17 @@ pub fn built_executable_in_workspace(pkgid: &PkgId, workspace: &Path) -> Option<\n \n /// Figure out what the test name for <pkgid> in <workspace>'s build\n /// directory is, and if the file exists, return it.\n-pub fn built_test_in_workspace(pkgid: PkgId, workspace: &Path) -> Option<Path> {\n+pub fn built_test_in_workspace(pkgid: &PkgId, workspace: &Path) -> Option<Path> {\n     output_in_workspace(pkgid, workspace, Test)\n }\n \n /// Figure out what the test name for <pkgid> in <workspace>'s build\n /// directory is, and if the file exists, return it.\n-pub fn built_bench_in_workspace(pkgid: PkgId, workspace: &Path) -> Option<Path> {\n+pub fn built_bench_in_workspace(pkgid: &PkgId, workspace: &Path) -> Option<Path> {\n     output_in_workspace(pkgid, workspace, Bench)\n }\n \n-fn output_in_workspace(pkgid: PkgId, workspace: &Path, what: OutputType) -> Option<Path> {\n+fn output_in_workspace(pkgid: &PkgId, workspace: &Path, what: OutputType) -> Option<Path> {\n     let mut result = workspace.push(\"build\");\n     // should use a target-specific subdirectory\n     result = mk_output_path(what, pkgid, &result);\n@@ -94,7 +94,7 @@ fn output_in_workspace(pkgid: PkgId, workspace: &Path, what: OutputType) -> Opti\n \n /// Figure out what the library name for <pkgid> in <workspace>'s build\n /// directory is, and if the file exists, return it.\n-pub fn built_library_in_workspace(pkgid: PkgId, workspace: &Path) -> Option<Path> {\n+pub fn built_library_in_workspace(pkgid: &PkgId, workspace: &Path) -> Option<Path> {\n     let result = mk_output_path(Lib, pkgid, &workspace.push(\"build\"));\n     debug!(\"built_library_in_workspace: checking whether %s exists\",\n            result.to_str());\n@@ -177,28 +177,27 @@ pub fn target_library_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n /// Returns the test executable that would be installed for <pkgid>\n /// in <workspace>\n /// note that we *don't* install test executables, so this is just for unit testing\n-pub fn target_test_in_workspace(pkgid: PkgId, workspace: &Path) -> Path {\n+pub fn target_test_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n     target_file_in_workspace(pkgid, workspace, Test)\n }\n \n /// Returns the bench executable that would be installed for <pkgid>\n /// in <workspace>\n /// note that we *don't* install bench executables, so this is just for unit testing\n-pub fn target_bench_in_workspace(pkgid: PkgId, workspace: &Path) -> Path {\n+pub fn target_bench_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n     target_file_in_workspace(pkgid, workspace, Bench)\n }\n \n fn target_file_in_workspace(pkgid: &PkgId, workspace: &Path,\n                             what: OutputType) -> Path {\n     use conditions::bad_path::cond;\n \n-    let (subdir, create_dir) = match what {\n+    let subdir = match what {\n         Lib => \"lib\", Main | Test | Bench => \"bin\"\n     };\n     let result = workspace.push(subdir);\n-    debug!(\"target_file_in_workspace: %s %?\", result.to_str(), create_dir);\n     if !os::path_exists(&result) && !mkdir_recursive(&result, u_rwx) {\n-        cond.raise((result, fmt!(\"I couldn't create the %s dir\", subdir)));\n+        cond.raise((copy result, fmt!(\"I couldn't create the %s dir\", subdir)));\n     }\n     mk_output_path(what, pkgid, &result)\n }\n@@ -222,17 +221,19 @@ pub fn build_pkg_id_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n \n /// Return the output file for a given directory name,\n /// given whether we're building a library and whether we're building tests\n-pub fn mk_output_path(what: OutputType, pkg_id: PkgId, workspace: &Path) -> Path {\n-    let short_name = pkg_id.short_name_with_version();\n+pub fn mk_output_path(what: OutputType, pkg_id: &PkgId, workspace: &Path) -> Path {\n+    let short_name_with_version = pkg_id.short_name_with_version();\n     // Not local_path.dir_path()! For package foo/bar/blat/, we want\n     // the executable blat-0.5 to live under blat/\n     let dir = workspace.push_rel(&*pkg_id.local_path);\n     debug!(\"mk_output_path: short_name = %s, path = %s\",\n-           short_name, dir.to_str());\n+           if what == Lib { copy short_name_with_version } else { copy pkg_id.short_name },\n+           dir.to_str());\n     let output_path = match what {\n         // this code is duplicated from elsewhere; fix this\n-        Lib => dir.push(os::dll_filename(short_name)),\n-        _ => dir.push(fmt!(\"%s%s%s\", short_name,\n+        Lib => dir.push(os::dll_filename(short_name_with_version)),\n+        // executable names *aren't* versioned\n+        _ => dir.push(fmt!(\"%s%s%s\", copy pkg_id.short_name,\n                            match what {\n                                Test => \"test\",\n                                Bench => \"bench\","}, {"sha": "a69613776efdc4ac8abb597cc44f0f0b33645e51", "filename": "src/librustpkg/rustpkg.rc", "status": "modified", "additions": 16, "deletions": 72, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/80a7e2644c86846e06907a6bed5b0d7773051d20/src%2Flibrustpkg%2Frustpkg.rc", "raw_url": "https://github.com/rust-lang/rust/raw/80a7e2644c86846e06907a6bed5b0d7773051d20/src%2Flibrustpkg%2Frustpkg.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rc?ref=80a7e2644c86846e06907a6bed5b0d7773051d20", "patch": "@@ -157,27 +157,6 @@ impl<'self> PkgScript<'self> {\n impl Ctx {\n \n     fn run(&self, cmd: ~str, args: ~[~str]) {\n-        let root = util::root();\n-\n-        util::need_dir(&root);\n-        util::need_dir(&root.push(~\"work\"));\n-        util::need_dir(&root.push(~\"lib\"));\n-        util::need_dir(&root.push(~\"bin\"));\n-        util::need_dir(&root.push(~\"tmp\"));\n-\n-        fn sep_name_vers(in: ~str) -> (Option<~str>, Option<~str>) {\n-            let mut name = None;\n-            let mut vers = None;\n-\n-            for str::each_split_char(in, '@') |s| {\n-                if      name.is_none() { name = Some(s.to_owned()); }\n-                else if vers.is_none() { vers = Some(s.to_owned()); }\n-                else                   { break;               }\n-            }\n-\n-            (name, vers)\n-        }\n-\n         match cmd {\n             ~\"build\" => {\n                 if args.len() < 1 {\n@@ -227,9 +206,7 @@ impl Ctx {\n                     return usage::uninstall();\n                 }\n \n-                let (name, vers) = sep_name_vers(copy args[0]);\n-\n-                self.prefer(name.get(), vers);\n+                self.prefer(args[0], None);\n             }\n             ~\"test\" => {\n                 self.test();\n@@ -239,20 +216,16 @@ impl Ctx {\n                     return usage::uninstall();\n                 }\n \n-                let (name, vers) = sep_name_vers(copy args[0]);\n-\n-                self.uninstall(name.get(), vers);\n+                self.uninstall(args[0], None);\n             }\n             ~\"unprefer\" => {\n                 if args.len() < 1 {\n                     return usage::uninstall();\n                 }\n \n-                let (name, vers) = sep_name_vers(copy args[0]);\n-\n-                self.unprefer(name.get(), vers);\n+                self.unprefer(args[0], None);\n             }\n-            _ => fail!(\"reached an unhandled command\")\n+            _ => fail!(fmt!(\"I don't know the command `%s`\", cmd))\n         }\n     }\n \n@@ -267,7 +240,7 @@ impl Ctx {\n         debug!(\"Destination dir = %s\", build_dir.to_str());\n \n         // Create the package source\n-        let mut src = PkgSrc::new(workspace, &build_dir, &pkgid);\n+        let mut src = PkgSrc::new(workspace, &build_dir, pkgid);\n         debug!(\"Package src = %?\", src);\n \n         // Is there custom build logic? If so, use it\n@@ -305,7 +278,6 @@ impl Ctx {\n             // Build it!\n             src.build(&build_dir, cfgs, self.sysroot_opt);\n         }\n-\n     }\n \n     fn clean(&self, workspace: &Path, id: &PkgId)  {\n@@ -317,7 +289,7 @@ impl Ctx {\n         util::note(fmt!(\"Cleaning package %s (removing directory %s)\",\n                         id.to_str(), dir.to_str()));\n         if os::path_exists(&dir) {\n-            util::remove_dir_r(&dir);\n+            os::remove_dir_recursive(&dir);\n             util::note(fmt!(\"Removed directory %s\", dir.to_str()));\n         }\n \n@@ -353,19 +325,19 @@ impl Ctx {\n             debug!(\"Copying: %s -> %s\", exec.to_str(), target_exec.to_str());\n             if !(os::mkdir_recursive(&target_exec.dir_path(), u_rwx) &&\n                  os::copy_file(exec, &target_exec)) {\n-                cond.raise((*exec, target_exec));\n+                cond.raise((copy *exec, copy target_exec));\n             }\n         }\n         for maybe_library.each |lib| {\n             debug!(\"Copying: %s -> %s\", lib.to_str(), target_lib.to_str());\n             if !(os::mkdir_recursive(&target_lib.dir_path(), u_rwx) &&\n                  os::copy_file(lib, &target_lib)) {\n-                cond.raise((*lib, target_lib));\n+                cond.raise((copy *lib, copy target_lib));\n             }\n         }\n     }\n \n-    fn prefer(&self, _id: ~str, _vers: Option<~str>)  {\n+    fn prefer(&self, _id: &str, _vers: Option<~str>)  {\n         fail!(~\"prefer not yet implemented\");\n     }\n \n@@ -374,15 +346,16 @@ impl Ctx {\n         fail!(\"test not yet implemented\");\n     }\n \n-    fn uninstall(&self, _id: ~str, _vers: Option<~str>)  {\n+    fn uninstall(&self, _id: &str, _vers: Option<~str>)  {\n         fail!(\"uninstall not yet implemented\");\n     }\n \n-    fn unprefer(&self, _id: ~str, _vers: Option<~str>)  {\n+    fn unprefer(&self, _id: &str, _vers: Option<~str>)  {\n         fail!(\"unprefer not yet implemented\");\n     }\n }\n \n+\n pub fn main() {\n     io::println(\"WARNING: The Rust package manager is experimental and may be unstable\");\n \n@@ -443,32 +416,6 @@ pub struct Crate {\n     cfgs: ~[~str]\n }\n \n-pub struct Listener {\n-    cmds: ~[~str],\n-    cb: ~fn()\n-}\n-\n-pub fn run(listeners: ~[Listener]) {\n-    let rcmd = copy os::args()[2];\n-    let mut found = false;\n-\n-    for listeners.each |listener| {\n-        for listener.cmds.each |&cmd| {\n-            if cmd == rcmd {\n-                (listener.cb)();\n-\n-                found = true;\n-\n-                break;\n-            }\n-        }\n-    }\n-\n-    if !found {\n-        os::set_exit_status(42);\n-    }\n-}\n-\n pub impl Crate {\n \n     fn new(p: &Path) -> Crate {\n@@ -527,10 +474,6 @@ pub fn src_dir() -> Path {\n     os::getcwd()\n }\n \n-condition! {\n-    bad_pkg_id: (super::Path, ~str) -> ::util::PkgId;\n-}\n-\n // An enumeration of the unpacked source of a package workspace.\n // This contains a list of files found in the source workspace.\n pub struct PkgSrc {\n@@ -576,7 +519,7 @@ impl PkgSrc {\n \n         if !os::path_exists(&dir) {\n             if !self.fetch_git() {\n-                cond.raise((self.id, ~\"supplied path for package dir does not \\\n+                cond.raise((copy self.id, ~\"supplied path for package dir does not \\\n                     exist, and couldn't interpret it as a URL fragment\"));\n             }\n         }\n@@ -598,12 +541,12 @@ impl PkgSrc {\n         let mut local = self.root.push(\"src\");\n         local = local.push(self.id.to_str());\n         // Git can't clone into a non-empty directory\n-        util::remove_dir_r(&local);\n+        os::remove_dir_recursive(&local);\n \n         let url = fmt!(\"https://%s\", self.id.remote_path.to_str());\n         util::note(fmt!(\"git clone %s %s\", url, local.to_str()));\n \n-        if run::program_output(~\"git\", ~[~\"clone\", url, local.to_str()]).status != 0 {\n+        if run::program_output(~\"git\", ~[~\"clone\", copy url, local.to_str()]).status != 0 {\n             util::note(fmt!(\"fetching %s failed: can't clone repository\", url));\n             return false;\n         }\n@@ -733,3 +676,4 @@ impl PkgSrc {\n         self.build_crates(maybe_sysroot, dst_dir, &dir, self.benchs, cfgs, Bench);\n     }\n }\n+"}, {"sha": "487e8d0da36e2d8f98535511392fc7fb0f46b7fd", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 59, "deletions": 13, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/80a7e2644c86846e06907a6bed5b0d7773051d20/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a7e2644c86846e06907a6bed5b0d7773051d20/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=80a7e2644c86846e06907a6bed5b0d7773051d20", "patch": "@@ -19,7 +19,6 @@ use path_util::{target_executable_in_workspace, target_library_in_workspace,\n                target_test_in_workspace, target_bench_in_workspace,\n                make_dir_rwx, u_rwx, RemotePath, LocalPath, normalize,\n                built_bench_in_workspace, built_test_in_workspace};\n-use core::os::mkdir_recursive;\n \n fn fake_ctxt(sysroot_opt: Option<@Path>) -> Ctx {\n     Ctx {\n@@ -33,7 +32,7 @@ fn fake_pkg() -> PkgId {\n     let sn = ~\"bogus\";\n     let remote = RemotePath(Path(sn));\n     PkgId {\n-        local_path: normalize(remote),\n+        local_path: normalize(copy remote),\n         remote_path: remote,\n         short_name: sn,\n         version: default_version()\n@@ -43,7 +42,7 @@ fn fake_pkg() -> PkgId {\n fn remote_pkg() -> PkgId {\n     let remote = RemotePath(Path(~\"github.com/catamorphism/test-pkg\"));\n     PkgId {\n-        local_path: normalize(remote),\n+        local_path: normalize(copy remote),\n         remote_path: remote,\n         short_name: ~\"test_pkg\",\n         version: default_version()\n@@ -59,9 +58,9 @@ fn writeFile(file_path: &Path, contents: ~str) {\n \n fn mk_temp_workspace(short_name: &LocalPath) -> Path {\n     let workspace = mkdtemp(&os::tmpdir(), \"test\").expect(\"couldn't create temp dir\");\n-    // Ugh, including version number\n-    let package_dir = workspace.push(~\"src\").push(fmt!(\"%s-0-1\", short_name.to_str()));\n-    assert!(mkdir_recursive(&package_dir, u_rwx));\n+    // include version number in directory name\n+    let package_dir = workspace.push(~\"src\").push(fmt!(\"%s-0.1\", short_name.to_str()));\n+    assert!(os::mkdir_recursive(&package_dir, u_rwx));\n     // Create main, lib, test, and bench files\n     writeFile(&package_dir.push(~\"main.rs\"),\n               ~\"fn main() { let _x = (); }\");\n@@ -162,25 +161,72 @@ fn test_install_url() {\n     let ctxt = fake_ctxt(Some(@sysroot));\n     let temp_pkg_id = remote_pkg();\n     // should have test, bench, lib, and main\n-    ctxt.install(&workspace, temp_pkg_id);\n+    ctxt.install(&workspace, &temp_pkg_id);\n     // Check that all files exist\n-    let exec = target_executable_in_workspace(temp_pkg_id, &workspace);\n+    let exec = target_executable_in_workspace(&temp_pkg_id, &workspace);\n     debug!(\"exec = %s\", exec.to_str());\n     assert!(os::path_exists(&exec));\n     assert!(is_rwx(&exec));\n-    let lib = target_library_in_workspace(temp_pkg_id, &workspace);\n+    let lib = target_library_in_workspace(&temp_pkg_id, &workspace);\n     debug!(\"lib = %s\", lib.to_str());\n     assert!(os::path_exists(&lib));\n     assert!(is_rwx(&lib));\n-    let built_test = built_test_in_workspace(temp_pkg_id, &workspace).expect(~\"test_install_url\");\n+    let built_test = built_test_in_workspace(&temp_pkg_id, &workspace).expect(~\"test_install_url\");\n     assert!(os::path_exists(&built_test));\n-    let built_bench = built_bench_in_workspace(temp_pkg_id, &workspace).expect(~\"test_install_url\");\n+    let built_bench = built_bench_in_workspace(&temp_pkg_id,\n+                                               &workspace).expect(~\"test_install_url\");\n     assert!(os::path_exists(&built_bench));\n     // And that the test and bench executables aren't installed\n-    let test = target_test_in_workspace(temp_pkg_id, &workspace);\n+    let test = target_test_in_workspace(&temp_pkg_id, &workspace);\n     assert!(!os::path_exists(&test));\n     debug!(\"test = %s\", test.to_str());\n-    let bench = target_bench_in_workspace(temp_pkg_id, &workspace);\n+    let bench = target_bench_in_workspace(&temp_pkg_id, &workspace);\n     debug!(\"bench = %s\", bench.to_str());\n     assert!(!os::path_exists(&bench));\n }\n+\n+#[test]\n+fn test_package_ids_must_be_relative_path_like() {\n+    use conditions::bad_pkg_id::cond;\n+\n+    /*\n+    Okay:\n+    - One identifier, with no slashes\n+    - Several slash-delimited things, with no / at the root\n+\n+    Not okay:\n+    - Empty string\n+    - Absolute path (as per os::is_absolute)\n+\n+    */\n+\n+    let default_version_str = \"0.1\";\n+    let addversion = |s| {\n+        fmt!(\"%s-%s\", s, default_version_str)\n+    };\n+\n+    let whatever = PkgId::new(\"foo\");\n+\n+    assert!(addversion(\"foo\") == whatever.to_str());\n+    assert!(addversion(\"github.com/mozilla/rust\") ==\n+            PkgId::new(\"github.com/mozilla/rust\").to_str());\n+\n+    do cond.trap(|(p, e)| {\n+        assert!(\"\" == p.to_str());\n+        assert!(\"0-length pkgid\" == e);\n+        copy whatever\n+    }).in {\n+        let x = PkgId::new(\"\");\n+        assert!(addversion(\"foo\") == x.to_str());\n+    }\n+\n+    do cond.trap(|(p, e)| {\n+        assert!(p.to_str() == os::make_absolute(&Path(\"foo/bar/quux\")).to_str());\n+        assert!(\"absolute pkgid\" == e);\n+        copy whatever\n+    }).in {\n+        let z = PkgId::new(os::make_absolute(&Path(\"foo/bar/quux\")).to_str());\n+        assert!(addversion(\"foo\") == z.to_str());\n+    }\n+\n+}"}, {"sha": "4a9c276948aa04a912e66fcfb84680d46ec037ae", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 26, "deletions": 171, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/80a7e2644c86846e06907a6bed5b0d7773051d20/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a7e2644c86846e06907a6bed5b0d7773051d20/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=80a7e2644c86846e06907a6bed5b0d7773051d20", "patch": "@@ -16,13 +16,12 @@ use rustc::driver::{driver, session};\n use rustc::metadata::filesearch;\n use std::getopts::groups::getopts;\n use std::semver;\n-use std::{json, term, getopts};\n+use std::{term, getopts};\n use syntax::ast_util::*;\n use syntax::codemap::{dummy_sp, spanned, dummy_spanned};\n use syntax::ext::base::{mk_ctxt, ext_ctxt};\n-use syntax::ext::build;\n use syntax::{ast, attr, codemap, diagnostic, fold};\n-use syntax::ast::{meta_name_value, meta_list, attribute};\n+use syntax::ast::{meta_name_value, meta_list};\n use syntax::attr::{mk_attr};\n use rustc::back::link::output_type_exe;\n use rustc::driver::session::{lib_crate, bin_crate};\n@@ -109,7 +108,7 @@ pub struct PkgId {\n \n pub impl PkgId {\n     fn new(s: &str) -> PkgId {\n-        use bad_pkg_id::cond;\n+        use conditions::bad_pkg_id::cond;\n \n         let p = Path(s);\n         if p.is_absolute {\n@@ -119,11 +118,12 @@ pub impl PkgId {\n             return cond.raise((p, ~\"0-length pkgid\"));\n         }\n         let remote_path = RemotePath(p);\n-        let local_path = normalize(remote_path);\n+        let local_path = normalize(copy remote_path);\n+        let short_name = (copy local_path).filestem().expect(fmt!(\"Strange path! %s\", s));\n         PkgId {\n             local_path: local_path,\n             remote_path: remote_path,\n-            short_name: local_path.filestem().expect(fmt!(\"Strange path! %s\", s)),\n+            short_name: short_name,\n             version: default_version()\n         }\n     }\n@@ -142,14 +142,7 @@ pub impl PkgId {\n impl ToStr for PkgId {\n     fn to_str(&self) -> ~str {\n         // should probably use the filestem and not the whole path\n-        fmt!(\"%s-%s\", self.local_path.to_str(),\n-             // Replace dots with -s in the version\n-             // this is because otherwise rustc will think\n-             // that foo-0.1 has .1 as its extension\n-             // (Temporary hack until I figure out how to\n-             // get rustc to not name the object file\n-             // foo-0.o if I pass in foo-0.1 to build_output_filenames)\n-             str::replace(self.version.to_str(), \".\", \"-\"))\n+        fmt!(\"%s-%s\", self.local_path.to_str(), self.version.to_str())\n     }\n }\n \n@@ -176,26 +169,6 @@ pub fn is_cmd(cmd: &str) -> bool {\n     Commands.any(|&c| c == cmd)\n }\n \n-pub fn parse_name(id: ~str) -> result::Result<~str, ~str> {\n-    let mut last_part = None;\n-\n-    for str::each_split_char(id, '.') |part| {\n-        for str::each_char(part) |char| {\n-            if char::is_whitespace(char) {\n-                return result::Err(\n-                    ~\"could not parse id: contains whitespace\");\n-            } else if char::is_uppercase(char) {\n-                return result::Err(\n-                    ~\"could not parse id: should be all lowercase\");\n-            }\n-        }\n-        last_part = Some(part.to_owned());\n-    }\n-    if last_part.is_none() { return result::Err(~\"could not parse id: is empty\"); }\n-\n-    result::Ok(last_part.unwrap())\n-}\n-\n struct ListenerFn {\n     cmds: ~[~str],\n     span: codemap::span,\n@@ -268,52 +241,6 @@ fn fold_item(ctx: @mut ReadyCtx,\n     res\n }\n \n-fn add_pkg_module(ctx: @mut ReadyCtx, m: ast::_mod) -> ast::_mod {\n-    let listeners = mk_listener_vec(ctx);\n-    let ext_cx = ctx.ext_cx;\n-    let item = quote_item! (\n-        mod __pkg {\n-            extern mod rustpkg (vers=\"0.7-pre\");\n-            static listeners : &[rustpkg::Listener] = $listeners;\n-            #[main]\n-            fn main() {\n-                rustpkg::run(listeners);\n-            }\n-        }\n-    );\n-    ast::_mod {\n-        items: vec::append_one(/*bad*/copy m.items, item.get()),\n-        .. m\n-    }\n-}\n-\n-fn mk_listener_vec(ctx: @mut ReadyCtx) -> @ast::expr {\n-    let descs = do ctx.fns.map |listener| {\n-        mk_listener_rec(ctx, listener)\n-    };\n-    let ext_cx = ctx.ext_cx;\n-    build::mk_slice_vec_e(ext_cx, dummy_sp(), descs)\n-}\n-\n-fn mk_listener_rec(ctx: @mut ReadyCtx, listener: &ListenerFn) -> @ast::expr {\n-    let span = listener.span;\n-    let cmds = do listener.cmds.map |&cmd| {\n-        let ext_cx = ctx.ext_cx;\n-        build::mk_base_str(ext_cx, span, cmd)\n-    };\n-\n-    let ext_cx = ctx.ext_cx;\n-    let cmds_expr = build::mk_slice_vec_e(ext_cx, span, cmds);\n-    let cb_expr = build::mk_path(ext_cx, span, copy listener.path);\n-\n-    quote_expr!(\n-        Listener {\n-            cmds: $cmds_expr,\n-            cb: $cb_expr\n-        }\n-    )\n-}\n-\n /// Generate/filter main function, add the list of commands, etc.\n pub fn ready_crate(sess: session::Session,\n                    crate: @ast::crate) -> @ast::crate {\n@@ -395,67 +322,6 @@ pub fn hash(data: ~str) -> ~str {\n     hasher.result_str()\n }\n \n-pub fn temp_change_dir<T>(dir: &Path, cb: &fn() -> T) {\n-    let cwd = os::getcwd();\n-\n-    os::change_dir(dir);\n-    cb();\n-    os::change_dir(&cwd);\n-}\n-\n-pub fn touch(path: &Path) {\n-    match io::mk_file_writer(path, ~[io::Create]) {\n-        result::Ok(writer) => writer.write_line(~\"\"),\n-        _ => {}\n-    }\n-}\n-\n-pub fn remove_dir_r(path: &Path) {\n-    for os::walk_dir(path) |&file| {\n-        let mut cdir = file;\n-\n-        loop {\n-            if os::path_is_dir(&cdir) {\n-                os::remove_dir(&cdir);\n-            } else {\n-                os::remove_file(&cdir);\n-            }\n-\n-            cdir = cdir.dir_path();\n-\n-            if cdir == *path { break; }\n-        }\n-    }\n-\n-    os::remove_dir(path);\n-}\n-\n-pub fn wait_for_lock(path: &Path) {\n-    if os::path_exists(path) {\n-        warn(fmt!(\"the database appears locked, please wait (or rm %s)\",\n-                        path.to_str()));\n-\n-        loop {\n-            if !os::path_exists(path) { break; }\n-        }\n-    }\n-}\n-\n-pub fn load_pkgs() -> result::Result<~[json::Json], ~str> {\n-    fail!(\"load_pkg not implemented\");\n-}\n-\n-pub fn get_pkg(_id: ~str,\n-               _vers: Option<~str>) -> result::Result<Pkg, ~str> {\n-    fail!(\"get_pkg not implemented\");\n-}\n-\n-pub fn add_pkg(pkg: &Pkg) -> bool {\n-    note(fmt!(\"Would be adding package, but add_pkg is not yet implemented %s\",\n-         pkg.to_str()));\n-    false\n-}\n-\n // FIXME (#4432): Use workcache to only compile when needed\n pub fn compile_input(sysroot: Option<@Path>,\n                      pkg_id: &PkgId,\n@@ -466,22 +332,20 @@ pub fn compile_input(sysroot: Option<@Path>,\n                      opt: bool,\n                      what: OutputType) -> bool {\n \n-    let short_name = pkg_id.short_name_with_version();\n-\n     assert!(in_file.components.len() > 1);\n     let input = driver::file_input(copy *in_file);\n     debug!(\"compile_input: %s / %?\", in_file.to_str(), what);\n     // tjc: by default, use the package ID name as the link name\n     // not sure if we should support anything else\n \n-    let binary = os::args()[0];\n+    let binary = @(copy os::args()[0]);\n     let building_library = what == Lib;\n \n     let out_file = if building_library {\n-        out_dir.push(os::dll_filename(short_name))\n+        out_dir.push(os::dll_filename(pkg_id.short_name))\n     }\n     else {\n-        out_dir.push(short_name + match what {\n+        out_dir.push(pkg_id.short_name + match what {\n             Test => ~\"test\", Bench => ~\"bench\", Main | Lib => ~\"\"\n         } + os::EXE_SUFFIX)\n     };\n@@ -561,24 +425,27 @@ pub fn compile_crate_from_input(input: &driver::input,\n             debug!(\"Calling compile_upto, outputs = %?\", outputs);\n             let (crate, _) = driver::compile_upto(sess, copy cfg, input,\n                                                   driver::cu_parse, Some(outputs));\n+            let mut crate = crate;\n \n             debug!(\"About to inject link_meta info...\");\n             // Inject the inferred link_meta info if it's not already there\n             // (assumes that name and vers are the only linkage metas)\n-            let mut crate_to_use = crate;\n \n             debug!(\"How many attrs? %?\", attr::find_linkage_metas(crate.node.attrs).len());\n \n             if attr::find_linkage_metas(crate.node.attrs).is_empty() {\n-                crate_to_use = add_attrs(*crate, ~[mk_attr(@dummy_spanned(meta_list(@~\"link\",\n-                    ~[@dummy_spanned(meta_name_value(@~\"name\",\n-                                         mk_string_lit(@pkg_id.short_name))),\n-                      @dummy_spanned(meta_name_value(@~\"vers\",\n-                                         mk_string_lit(@pkg_id.version.to_str())))])))]);\n+                crate = @codemap::respan(crate.span, ast::crate_ {\n+                    attrs: ~[mk_attr(@dummy_spanned(\n+                        meta_list(@~\"link\",\n+                                  ~[@dummy_spanned(meta_name_value(@~\"name\",\n+                                        mk_string_lit(@(copy pkg_id.short_name)))),\n+                                    @dummy_spanned(meta_name_value(@~\"vers\",\n+                                        mk_string_lit(@(copy pkg_id.version.to_str()))))])))],\n+                    ..copy crate.node});\n             }\n \n-            driver::compile_rest(sess, cfg, what, Some(outputs), Some(crate_to_use));\n-            crate_to_use\n+            driver::compile_rest(sess, cfg, what, Some(outputs), Some(crate));\n+            crate\n         }\n     }\n }\n@@ -592,14 +459,6 @@ pub fn exe_suffix() -> ~str { ~\".exe\" }\n #[cfg(target_os = \"macos\")]\n pub fn exe_suffix() -> ~str { ~\"\" }\n \n-\n-/// Returns a copy of crate `c` with attributes `attrs` added to its\n-/// attributes\n-fn add_attrs(mut c: ast::crate, new_attrs: ~[attribute]) -> @ast::crate {\n-    c.node.attrs += new_attrs;\n-    @c\n-}\n-\n // Called by build_crates\n // FIXME (#4432): Use workcache to only compile when needed\n pub fn compile_crate(sysroot: Option<@Path>, pkg_id: &PkgId,\n@@ -619,16 +478,17 @@ pub fn compile_crate(sysroot: Option<@Path>, pkg_id: &PkgId,\n /// Replace all occurrences of '-' in the stem part of path with '_'\n /// This is because we treat rust-foo-bar-quux and rust_foo_bar_quux\n /// as the same name\n-pub fn normalize(p: RemotePath) -> LocalPath {\n+pub fn normalize(p_: RemotePath) -> LocalPath {\n+    let RemotePath(p) = p_;\n     match p.filestem() {\n-        None => LocalPath(*p),\n+        None => LocalPath(p),\n         Some(st) => {\n             let replaced = str::replace(st, \"-\", \"_\");\n             if replaced != st {\n                 LocalPath(p.with_filestem(replaced))\n             }\n             else {\n-                LocalPath(*p)\n+                LocalPath(p)\n             }\n         }\n     }\n@@ -671,7 +531,7 @@ pub struct LocalPath (Path);\n \n #[cfg(test)]\n mod test {\n-    use super::{is_cmd, parse_name};\n+    use super::is_cmd;\n \n     #[test]\n     fn test_is_cmd() {\n@@ -686,9 +546,4 @@ mod test {\n         assert!(is_cmd(~\"unprefer\"));\n     }\n \n-    #[test]\n-    fn test_parse_name() {\n-        assert!(parse_name(~\"org.mozilla.servo\").get() == ~\"servo\");\n-        assert!(parse_name(~\"org. mozilla.servo 2131\").is_err());\n-    }\n }"}]}