{"sha": "5a288dc1121621fbf82244c3119becee25efed4d", "node_id": "C_kwDOAAsO6NoAKDVhMjg4ZGMxMTIxNjIxZmJmODIyNDRjMzExOWJlY2VlMjVlZmVkNGQ", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-11-02T17:02:06Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-11-02T17:02:06Z"}, "message": "Rollup merge of #103864 - smoelius:reorder-walk-functions, r=fee1-dead\n\nReorder `walk_` functions in intravisit.rs\n\nReorder the `walk_` functions to match the order of the `visit_` methods. This is a follow up to https://github.com/rust-lang/rust/pull/103692.\n\nNote that there are some oddballs. I put them where I thought made the most sense:\n```diff\n$ diff \\\n<(sed -n 's/^.*\\<fn visit_\\([^(]*\\).*$/\\1/;T;p' compiler/rustc_hir/src/intravisit.rs) \\\n<(sed -n 's/^.*\\<fn walk_\\([^<]*\\).*$/\\1/;T;p' compiler/rustc_hir/src/intravisit.rs)\n1,5d0\n< nested_item\n< nested_trait_item\n< nested_impl_item\n< nested_foreign_item\n< nested_body\n9,10d3\n< id\n< name\n20c13\n< array_length\n---\n> array_len\n30a24\n> fn_ret_ty\n31a26\n> fn_kind\n41c36\n< variant_data\n---\n> struct_def\n46c41\n< infer\n---\n> inf\n54d48\n< attribute\n```\n\nAlso, as some weak evidence that i did things correctly, I get the following before and after the change:\n```sh\n$ sort compiler/rustc_hir/src/intravisit.rs | openssl sha256\nSHA256(stdin)= cac13d2545731ef442f318e2b4286490d7ac5494f4ad10c4cf4c5d4f50d21641\n```\n\nr? `@fee1-dead`", "tree": {"sha": "23f9e77b96d560318694f3136c02844774a5f900", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/23f9e77b96d560318694f3136c02844774a5f900"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a288dc1121621fbf82244c3119becee25efed4d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjYqKOCRBK7hj4Ov3rIwAAlAwIACRxBX42OMRrSPlD/Nkm2xBE\nCA7yWUKFAZ5FMJUb8oWD7xX/xchSv8iCvhr/EC9gHbl1lvkcuwBgvQAcd4UayAJR\n2UeHCDpXoK4YJKoWlEW+omRnMon4dW4NalreHcjmGLqM2hLgHDViDgELB8lJRtx4\nLGOtuWIF7WaFMUwhEo8iAg9rK7+kSYLEW10yPzx6p2Npoy4g25Y0uTdjrv0hq+wD\n6QoNNagOO5jxa0P638QyGCRK8K6LyxrHFREI3gxwHymkycaTpFHKNfjH2qTMrPwK\nReCD5SLI9X8LjVeRLckUJbrQlMUyhfzZU9EO8fDmrG9mX9Os1bV/FsvF/pEFP+c=\n=YZZX\n-----END PGP SIGNATURE-----\n", "payload": "tree 23f9e77b96d560318694f3136c02844774a5f900\nparent 031293547383b305beed135c4edcafad4fd5f0f6\nparent e6043272863e836a513b3d914eb66e1965d2f14a\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1667408526 +0530\ncommitter GitHub <noreply@github.com> 1667408526 +0530\n\nRollup merge of #103864 - smoelius:reorder-walk-functions, r=fee1-dead\n\nReorder `walk_` functions in intravisit.rs\n\nReorder the `walk_` functions to match the order of the `visit_` methods. This is a follow up to https://github.com/rust-lang/rust/pull/103692.\n\nNote that there are some oddballs. I put them where I thought made the most sense:\n```diff\n$ diff \\\n<(sed -n 's/^.*\\<fn visit_\\([^(]*\\).*$/\\1/;T;p' compiler/rustc_hir/src/intravisit.rs) \\\n<(sed -n 's/^.*\\<fn walk_\\([^<]*\\).*$/\\1/;T;p' compiler/rustc_hir/src/intravisit.rs)\n1,5d0\n< nested_item\n< nested_trait_item\n< nested_impl_item\n< nested_foreign_item\n< nested_body\n9,10d3\n< id\n< name\n20c13\n< array_length\n---\n> array_len\n30a24\n> fn_ret_ty\n31a26\n> fn_kind\n41c36\n< variant_data\n---\n> struct_def\n46c41\n< infer\n---\n> inf\n54d48\n< attribute\n```\n\nAlso, as some weak evidence that i did things correctly, I get the following before and after the change:\n```sh\n$ sort compiler/rustc_hir/src/intravisit.rs | openssl sha256\nSHA256(stdin)= cac13d2545731ef442f318e2b4286490d7ac5494f4ad10c4cf4c5d4f50d21641\n```\n\nr? `@fee1-dead`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a288dc1121621fbf82244c3119becee25efed4d", "html_url": "https://github.com/rust-lang/rust/commit/5a288dc1121621fbf82244c3119becee25efed4d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a288dc1121621fbf82244c3119becee25efed4d/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "031293547383b305beed135c4edcafad4fd5f0f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/031293547383b305beed135c4edcafad4fd5f0f6", "html_url": "https://github.com/rust-lang/rust/commit/031293547383b305beed135c4edcafad4fd5f0f6"}, {"sha": "e6043272863e836a513b3d914eb66e1965d2f14a", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6043272863e836a513b3d914eb66e1965d2f14a", "html_url": "https://github.com/rust-lang/rust/commit/e6043272863e836a513b3d914eb66e1965d2f14a"}], "stats": {"total": 726, "additions": 363, "deletions": 363}, "files": [{"sha": "d852893ad5dc607782c8471fea9bf935f5fe84e9", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 363, "deletions": 363, "changes": 726, "blob_url": "https://github.com/rust-lang/rust/blob/5a288dc1121621fbf82244c3119becee25efed4d/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a288dc1121621fbf82244c3119becee25efed4d/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=5a288dc1121621fbf82244c3119becee25efed4d", "patch": "@@ -443,72 +443,6 @@ pub trait Visitor<'v>: Sized {\n     }\n }\n \n-pub fn walk_mod<'v, V: Visitor<'v>>(visitor: &mut V, module: &'v Mod<'v>, mod_hir_id: HirId) {\n-    visitor.visit_id(mod_hir_id);\n-    for &item_id in module.item_ids {\n-        visitor.visit_nested_item(item_id);\n-    }\n-}\n-\n-pub fn walk_body<'v, V: Visitor<'v>>(visitor: &mut V, body: &'v Body<'v>) {\n-    walk_list!(visitor, visit_param, body.params);\n-    visitor.visit_expr(&body.value);\n-}\n-\n-pub fn walk_local<'v, V: Visitor<'v>>(visitor: &mut V, local: &'v Local<'v>) {\n-    // Intentionally visiting the expr first - the initialization expr\n-    // dominates the local's definition.\n-    walk_list!(visitor, visit_expr, &local.init);\n-    visitor.visit_id(local.hir_id);\n-    visitor.visit_pat(&local.pat);\n-    if let Some(els) = local.els {\n-        visitor.visit_block(els);\n-    }\n-    walk_list!(visitor, visit_ty, &local.ty);\n-}\n-\n-pub fn walk_ident<'v, V: Visitor<'v>>(visitor: &mut V, ident: Ident) {\n-    visitor.visit_name(ident.name);\n-}\n-\n-pub fn walk_label<'v, V: Visitor<'v>>(visitor: &mut V, label: &'v Label) {\n-    visitor.visit_ident(label.ident);\n-}\n-\n-pub fn walk_generic_arg<'v, V: Visitor<'v>>(visitor: &mut V, generic_arg: &'v GenericArg<'v>) {\n-    match generic_arg {\n-        GenericArg::Lifetime(lt) => visitor.visit_lifetime(lt),\n-        GenericArg::Type(ty) => visitor.visit_ty(ty),\n-        GenericArg::Const(ct) => visitor.visit_anon_const(&ct.value),\n-        GenericArg::Infer(inf) => visitor.visit_infer(inf),\n-    }\n-}\n-\n-pub fn walk_lifetime<'v, V: Visitor<'v>>(visitor: &mut V, lifetime: &'v Lifetime) {\n-    visitor.visit_id(lifetime.hir_id);\n-    match lifetime.name {\n-        LifetimeName::Param(_, ParamName::Plain(ident)) => {\n-            visitor.visit_ident(ident);\n-        }\n-        LifetimeName::Param(_, ParamName::Fresh)\n-        | LifetimeName::Param(_, ParamName::Error)\n-        | LifetimeName::Static\n-        | LifetimeName::Error\n-        | LifetimeName::ImplicitObjectLifetimeDefault\n-        | LifetimeName::Infer => {}\n-    }\n-}\n-\n-pub fn walk_poly_trait_ref<'v, V: Visitor<'v>>(visitor: &mut V, trait_ref: &'v PolyTraitRef<'v>) {\n-    walk_list!(visitor, visit_generic_param, trait_ref.bound_generic_params);\n-    visitor.visit_trait_ref(&trait_ref.trait_ref);\n-}\n-\n-pub fn walk_trait_ref<'v, V: Visitor<'v>>(visitor: &mut V, trait_ref: &'v TraitRef<'v>) {\n-    visitor.visit_id(trait_ref.hir_ref_id);\n-    visitor.visit_path(&trait_ref.path, trait_ref.hir_ref_id)\n-}\n-\n pub fn walk_param<'v, V: Visitor<'v>>(visitor: &mut V, param: &'v Param<'v>) {\n     visitor.visit_id(param.hir_id);\n     visitor.visit_pat(&param.pat);\n@@ -605,142 +539,80 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item<'v>) {\n     }\n }\n \n-pub fn walk_inline_asm<'v, V: Visitor<'v>>(visitor: &mut V, asm: &'v InlineAsm<'v>, id: HirId) {\n-    for (op, op_sp) in asm.operands {\n-        match op {\n-            InlineAsmOperand::In { expr, .. } | InlineAsmOperand::InOut { expr, .. } => {\n-                visitor.visit_expr(expr)\n-            }\n-            InlineAsmOperand::Out { expr, .. } => {\n-                if let Some(expr) = expr {\n-                    visitor.visit_expr(expr);\n-                }\n-            }\n-            InlineAsmOperand::SplitInOut { in_expr, out_expr, .. } => {\n-                visitor.visit_expr(in_expr);\n-                if let Some(out_expr) = out_expr {\n-                    visitor.visit_expr(out_expr);\n-                }\n-            }\n-            InlineAsmOperand::Const { anon_const, .. }\n-            | InlineAsmOperand::SymFn { anon_const, .. } => visitor.visit_anon_const(anon_const),\n-            InlineAsmOperand::SymStatic { path, .. } => visitor.visit_qpath(path, id, *op_sp),\n-        }\n-    }\n-}\n-\n-pub fn walk_use<'v, V: Visitor<'v>>(visitor: &mut V, path: &'v Path<'v>, hir_id: HirId) {\n-    visitor.visit_id(hir_id);\n-    visitor.visit_path(path, hir_id);\n+pub fn walk_body<'v, V: Visitor<'v>>(visitor: &mut V, body: &'v Body<'v>) {\n+    walk_list!(visitor, visit_param, body.params);\n+    visitor.visit_expr(&body.value);\n }\n \n-pub fn walk_enum_def<'v, V: Visitor<'v>>(\n-    visitor: &mut V,\n-    enum_definition: &'v EnumDef<'v>,\n-    item_id: HirId,\n-) {\n-    visitor.visit_id(item_id);\n-    walk_list!(visitor, visit_variant, enum_definition.variants);\n+pub fn walk_ident<'v, V: Visitor<'v>>(visitor: &mut V, ident: Ident) {\n+    visitor.visit_name(ident.name);\n }\n \n-pub fn walk_variant<'v, V: Visitor<'v>>(visitor: &mut V, variant: &'v Variant<'v>) {\n-    visitor.visit_ident(variant.ident);\n-    visitor.visit_id(variant.id);\n-    visitor.visit_variant_data(&variant.data);\n-    walk_list!(visitor, visit_anon_const, &variant.disr_expr);\n+pub fn walk_mod<'v, V: Visitor<'v>>(visitor: &mut V, module: &'v Mod<'v>, mod_hir_id: HirId) {\n+    visitor.visit_id(mod_hir_id);\n+    for &item_id in module.item_ids {\n+        visitor.visit_nested_item(item_id);\n+    }\n }\n \n-pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty<'v>) {\n-    visitor.visit_id(typ.hir_id);\n+pub fn walk_foreign_item<'v, V: Visitor<'v>>(visitor: &mut V, foreign_item: &'v ForeignItem<'v>) {\n+    visitor.visit_id(foreign_item.hir_id());\n+    visitor.visit_ident(foreign_item.ident);\n \n-    match typ.kind {\n-        TyKind::Slice(ref ty) => visitor.visit_ty(ty),\n-        TyKind::Ptr(ref mutable_type) => visitor.visit_ty(&mutable_type.ty),\n-        TyKind::Rptr(ref lifetime, ref mutable_type) => {\n-            visitor.visit_lifetime(lifetime);\n-            visitor.visit_ty(&mutable_type.ty)\n-        }\n-        TyKind::Never => {}\n-        TyKind::Tup(tuple_element_types) => {\n-            walk_list!(visitor, visit_ty, tuple_element_types);\n-        }\n-        TyKind::BareFn(ref function_declaration) => {\n-            walk_list!(visitor, visit_generic_param, function_declaration.generic_params);\n-            visitor.visit_fn_decl(&function_declaration.decl);\n-        }\n-        TyKind::Path(ref qpath) => {\n-            visitor.visit_qpath(qpath, typ.hir_id, typ.span);\n-        }\n-        TyKind::OpaqueDef(item_id, lifetimes, _in_trait) => {\n-            visitor.visit_nested_item(item_id);\n-            walk_list!(visitor, visit_generic_arg, lifetimes);\n-        }\n-        TyKind::Array(ref ty, ref length) => {\n-            visitor.visit_ty(ty);\n-            visitor.visit_array_length(length)\n-        }\n-        TyKind::TraitObject(bounds, ref lifetime, _syntax) => {\n-            for bound in bounds {\n-                visitor.visit_poly_trait_ref(bound);\n+    match foreign_item.kind {\n+        ForeignItemKind::Fn(ref function_declaration, param_names, ref generics) => {\n+            visitor.visit_generics(generics);\n+            visitor.visit_fn_decl(function_declaration);\n+            for &param_name in param_names {\n+                visitor.visit_ident(param_name);\n             }\n-            visitor.visit_lifetime(lifetime);\n         }\n-        TyKind::Typeof(ref expression) => visitor.visit_anon_const(expression),\n-        TyKind::Infer | TyKind::Err => {}\n+        ForeignItemKind::Static(ref typ, _) => visitor.visit_ty(typ),\n+        ForeignItemKind::Type => (),\n     }\n }\n \n-pub fn walk_inf<'v, V: Visitor<'v>>(visitor: &mut V, inf: &'v InferArg) {\n-    visitor.visit_id(inf.hir_id);\n-}\n-\n-pub fn walk_qpath<'v, V: Visitor<'v>>(visitor: &mut V, qpath: &'v QPath<'v>, id: HirId) {\n-    match *qpath {\n-        QPath::Resolved(ref maybe_qself, ref path) => {\n-            walk_list!(visitor, visit_ty, maybe_qself);\n-            visitor.visit_path(path, id)\n-        }\n-        QPath::TypeRelative(ref qself, ref segment) => {\n-            visitor.visit_ty(qself);\n-            visitor.visit_path_segment(segment);\n-        }\n-        QPath::LangItem(..) => {}\n+pub fn walk_local<'v, V: Visitor<'v>>(visitor: &mut V, local: &'v Local<'v>) {\n+    // Intentionally visiting the expr first - the initialization expr\n+    // dominates the local's definition.\n+    walk_list!(visitor, visit_expr, &local.init);\n+    visitor.visit_id(local.hir_id);\n+    visitor.visit_pat(&local.pat);\n+    if let Some(els) = local.els {\n+        visitor.visit_block(els);\n     }\n+    walk_list!(visitor, visit_ty, &local.ty);\n }\n \n-pub fn walk_path<'v, V: Visitor<'v>>(visitor: &mut V, path: &'v Path<'v>) {\n-    for segment in path.segments {\n-        visitor.visit_path_segment(segment);\n-    }\n+pub fn walk_block<'v, V: Visitor<'v>>(visitor: &mut V, block: &'v Block<'v>) {\n+    visitor.visit_id(block.hir_id);\n+    walk_list!(visitor, visit_stmt, block.stmts);\n+    walk_list!(visitor, visit_expr, &block.expr);\n }\n \n-pub fn walk_path_segment<'v, V: Visitor<'v>>(visitor: &mut V, segment: &'v PathSegment<'v>) {\n-    visitor.visit_ident(segment.ident);\n-    visitor.visit_id(segment.hir_id);\n-    if let Some(ref args) = segment.args {\n-        visitor.visit_generic_args(args);\n+pub fn walk_stmt<'v, V: Visitor<'v>>(visitor: &mut V, statement: &'v Stmt<'v>) {\n+    visitor.visit_id(statement.hir_id);\n+    match statement.kind {\n+        StmtKind::Local(ref local) => visitor.visit_local(local),\n+        StmtKind::Item(item) => visitor.visit_nested_item(item),\n+        StmtKind::Expr(ref expression) | StmtKind::Semi(ref expression) => {\n+            visitor.visit_expr(expression)\n+        }\n     }\n }\n \n-pub fn walk_generic_args<'v, V: Visitor<'v>>(visitor: &mut V, generic_args: &'v GenericArgs<'v>) {\n-    walk_list!(visitor, visit_generic_arg, generic_args.args);\n-    walk_list!(visitor, visit_assoc_type_binding, generic_args.bindings);\n-}\n-\n-pub fn walk_assoc_type_binding<'v, V: Visitor<'v>>(\n-    visitor: &mut V,\n-    type_binding: &'v TypeBinding<'v>,\n-) {\n-    visitor.visit_id(type_binding.hir_id);\n-    visitor.visit_ident(type_binding.ident);\n-    visitor.visit_generic_args(type_binding.gen_args);\n-    match type_binding.kind {\n-        TypeBindingKind::Equality { ref term } => match term {\n-            Term::Ty(ref ty) => visitor.visit_ty(ty),\n-            Term::Const(ref c) => visitor.visit_anon_const(c),\n-        },\n-        TypeBindingKind::Constraint { bounds } => walk_list!(visitor, visit_param_bound, bounds),\n+pub fn walk_arm<'v, V: Visitor<'v>>(visitor: &mut V, arm: &'v Arm<'v>) {\n+    visitor.visit_id(arm.hir_id);\n+    visitor.visit_pat(&arm.pat);\n+    if let Some(ref g) = arm.guard {\n+        match g {\n+            Guard::If(ref e) => visitor.visit_expr(e),\n+            Guard::IfLet(ref l) => {\n+                visitor.visit_let_expr(l);\n+            }\n+        }\n     }\n+    visitor.visit_expr(&arm.body);\n }\n \n pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat<'v>) {\n@@ -788,33 +660,181 @@ pub fn walk_pat_field<'v, V: Visitor<'v>>(visitor: &mut V, field: &'v PatField<'\n     visitor.visit_pat(&field.pat)\n }\n \n-pub fn walk_foreign_item<'v, V: Visitor<'v>>(visitor: &mut V, foreign_item: &'v ForeignItem<'v>) {\n-    visitor.visit_id(foreign_item.hir_id());\n-    visitor.visit_ident(foreign_item.ident);\n-\n-    match foreign_item.kind {\n-        ForeignItemKind::Fn(ref function_declaration, param_names, ref generics) => {\n-            visitor.visit_generics(generics);\n-            visitor.visit_fn_decl(function_declaration);\n-            for &param_name in param_names {\n-                visitor.visit_ident(param_name);\n-            }\n-        }\n-        ForeignItemKind::Static(ref typ, _) => visitor.visit_ty(typ),\n-        ForeignItemKind::Type => (),\n+pub fn walk_array_len<'v, V: Visitor<'v>>(visitor: &mut V, len: &'v ArrayLen) {\n+    match len {\n+        &ArrayLen::Infer(hir_id, _span) => visitor.visit_id(hir_id),\n+        ArrayLen::Body(c) => visitor.visit_anon_const(c),\n     }\n }\n \n-pub fn walk_param_bound<'v, V: Visitor<'v>>(visitor: &mut V, bound: &'v GenericBound<'v>) {\n-    match *bound {\n-        GenericBound::Trait(ref typ, _modifier) => {\n-            visitor.visit_poly_trait_ref(typ);\n+pub fn walk_anon_const<'v, V: Visitor<'v>>(visitor: &mut V, constant: &'v AnonConst) {\n+    visitor.visit_id(constant.hir_id);\n+    visitor.visit_nested_body(constant.body);\n+}\n+\n+pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr<'v>) {\n+    visitor.visit_id(expression.hir_id);\n+    match expression.kind {\n+        ExprKind::Box(ref subexpression) => visitor.visit_expr(subexpression),\n+        ExprKind::Array(subexpressions) => {\n+            walk_list!(visitor, visit_expr, subexpressions);\n         }\n-        GenericBound::LangItemTrait(_, _span, hir_id, args) => {\n-            visitor.visit_id(hir_id);\n-            visitor.visit_generic_args(args);\n+        ExprKind::ConstBlock(ref anon_const) => visitor.visit_anon_const(anon_const),\n+        ExprKind::Repeat(ref element, ref count) => {\n+            visitor.visit_expr(element);\n+            visitor.visit_array_length(count)\n         }\n-        GenericBound::Outlives(ref lifetime) => visitor.visit_lifetime(lifetime),\n+        ExprKind::Struct(ref qpath, fields, ref optional_base) => {\n+            visitor.visit_qpath(qpath, expression.hir_id, expression.span);\n+            walk_list!(visitor, visit_expr_field, fields);\n+            walk_list!(visitor, visit_expr, optional_base);\n+        }\n+        ExprKind::Tup(subexpressions) => {\n+            walk_list!(visitor, visit_expr, subexpressions);\n+        }\n+        ExprKind::Call(ref callee_expression, arguments) => {\n+            visitor.visit_expr(callee_expression);\n+            walk_list!(visitor, visit_expr, arguments);\n+        }\n+        ExprKind::MethodCall(ref segment, receiver, arguments, _) => {\n+            visitor.visit_path_segment(segment);\n+            visitor.visit_expr(receiver);\n+            walk_list!(visitor, visit_expr, arguments);\n+        }\n+        ExprKind::Binary(_, ref left_expression, ref right_expression) => {\n+            visitor.visit_expr(left_expression);\n+            visitor.visit_expr(right_expression)\n+        }\n+        ExprKind::AddrOf(_, _, ref subexpression) | ExprKind::Unary(_, ref subexpression) => {\n+            visitor.visit_expr(subexpression)\n+        }\n+        ExprKind::Cast(ref subexpression, ref typ) | ExprKind::Type(ref subexpression, ref typ) => {\n+            visitor.visit_expr(subexpression);\n+            visitor.visit_ty(typ)\n+        }\n+        ExprKind::DropTemps(ref subexpression) => {\n+            visitor.visit_expr(subexpression);\n+        }\n+        ExprKind::Let(ref let_expr) => visitor.visit_let_expr(let_expr),\n+        ExprKind::If(ref cond, ref then, ref else_opt) => {\n+            visitor.visit_expr(cond);\n+            visitor.visit_expr(then);\n+            walk_list!(visitor, visit_expr, else_opt);\n+        }\n+        ExprKind::Loop(ref block, ref opt_label, _, _) => {\n+            walk_list!(visitor, visit_label, opt_label);\n+            visitor.visit_block(block);\n+        }\n+        ExprKind::Match(ref subexpression, arms, _) => {\n+            visitor.visit_expr(subexpression);\n+            walk_list!(visitor, visit_arm, arms);\n+        }\n+        ExprKind::Closure(&Closure {\n+            binder: _,\n+            bound_generic_params,\n+            fn_decl,\n+            body,\n+            capture_clause: _,\n+            fn_decl_span: _,\n+            movability: _,\n+        }) => {\n+            walk_list!(visitor, visit_generic_param, bound_generic_params);\n+            visitor.visit_fn(FnKind::Closure, fn_decl, body, expression.span, expression.hir_id)\n+        }\n+        ExprKind::Block(ref block, ref opt_label) => {\n+            walk_list!(visitor, visit_label, opt_label);\n+            visitor.visit_block(block);\n+        }\n+        ExprKind::Assign(ref lhs, ref rhs, _) => {\n+            visitor.visit_expr(rhs);\n+            visitor.visit_expr(lhs)\n+        }\n+        ExprKind::AssignOp(_, ref left_expression, ref right_expression) => {\n+            visitor.visit_expr(right_expression);\n+            visitor.visit_expr(left_expression);\n+        }\n+        ExprKind::Field(ref subexpression, ident) => {\n+            visitor.visit_expr(subexpression);\n+            visitor.visit_ident(ident);\n+        }\n+        ExprKind::Index(ref main_expression, ref index_expression) => {\n+            visitor.visit_expr(main_expression);\n+            visitor.visit_expr(index_expression)\n+        }\n+        ExprKind::Path(ref qpath) => {\n+            visitor.visit_qpath(qpath, expression.hir_id, expression.span);\n+        }\n+        ExprKind::Break(ref destination, ref opt_expr) => {\n+            walk_list!(visitor, visit_label, &destination.label);\n+            walk_list!(visitor, visit_expr, opt_expr);\n+        }\n+        ExprKind::Continue(ref destination) => {\n+            walk_list!(visitor, visit_label, &destination.label);\n+        }\n+        ExprKind::Ret(ref optional_expression) => {\n+            walk_list!(visitor, visit_expr, optional_expression);\n+        }\n+        ExprKind::InlineAsm(ref asm) => {\n+            visitor.visit_inline_asm(asm, expression.hir_id);\n+        }\n+        ExprKind::Yield(ref subexpression, _) => {\n+            visitor.visit_expr(subexpression);\n+        }\n+        ExprKind::Lit(_) | ExprKind::Err => {}\n+    }\n+}\n+\n+pub fn walk_let_expr<'v, V: Visitor<'v>>(visitor: &mut V, let_expr: &'v Let<'v>) {\n+    // match the visit order in walk_local\n+    visitor.visit_expr(let_expr.init);\n+    visitor.visit_id(let_expr.hir_id);\n+    visitor.visit_pat(let_expr.pat);\n+    walk_list!(visitor, visit_ty, let_expr.ty);\n+}\n+\n+pub fn walk_expr_field<'v, V: Visitor<'v>>(visitor: &mut V, field: &'v ExprField<'v>) {\n+    visitor.visit_id(field.hir_id);\n+    visitor.visit_ident(field.ident);\n+    visitor.visit_expr(&field.expr)\n+}\n+\n+pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty<'v>) {\n+    visitor.visit_id(typ.hir_id);\n+\n+    match typ.kind {\n+        TyKind::Slice(ref ty) => visitor.visit_ty(ty),\n+        TyKind::Ptr(ref mutable_type) => visitor.visit_ty(&mutable_type.ty),\n+        TyKind::Rptr(ref lifetime, ref mutable_type) => {\n+            visitor.visit_lifetime(lifetime);\n+            visitor.visit_ty(&mutable_type.ty)\n+        }\n+        TyKind::Never => {}\n+        TyKind::Tup(tuple_element_types) => {\n+            walk_list!(visitor, visit_ty, tuple_element_types);\n+        }\n+        TyKind::BareFn(ref function_declaration) => {\n+            walk_list!(visitor, visit_generic_param, function_declaration.generic_params);\n+            visitor.visit_fn_decl(&function_declaration.decl);\n+        }\n+        TyKind::Path(ref qpath) => {\n+            visitor.visit_qpath(qpath, typ.hir_id, typ.span);\n+        }\n+        TyKind::OpaqueDef(item_id, lifetimes, _in_trait) => {\n+            visitor.visit_nested_item(item_id);\n+            walk_list!(visitor, visit_generic_arg, lifetimes);\n+        }\n+        TyKind::Array(ref ty, ref length) => {\n+            visitor.visit_ty(ty);\n+            visitor.visit_array_length(length)\n+        }\n+        TyKind::TraitObject(bounds, ref lifetime, _syntax) => {\n+            for bound in bounds {\n+                visitor.visit_poly_trait_ref(bound);\n+            }\n+            visitor.visit_lifetime(lifetime);\n+        }\n+        TyKind::Typeof(ref expression) => visitor.visit_anon_const(expression),\n+        TyKind::Infer | TyKind::Err => {}\n     }\n }\n \n@@ -879,25 +899,16 @@ pub fn walk_where_predicate<'v, V: Visitor<'v>>(\n     }\n }\n \n-pub fn walk_fn_ret_ty<'v, V: Visitor<'v>>(visitor: &mut V, ret_ty: &'v FnRetTy<'v>) {\n-    if let FnRetTy::Return(ref output_ty) = *ret_ty {\n-        visitor.visit_ty(output_ty)\n-    }\n-}\n-\n pub fn walk_fn_decl<'v, V: Visitor<'v>>(visitor: &mut V, function_declaration: &'v FnDecl<'v>) {\n     for ty in function_declaration.inputs {\n         visitor.visit_ty(ty)\n     }\n     walk_fn_ret_ty(visitor, &function_declaration.output)\n }\n \n-pub fn walk_fn_kind<'v, V: Visitor<'v>>(visitor: &mut V, function_kind: FnKind<'v>) {\n-    match function_kind {\n-        FnKind::ItemFn(_, generics, ..) => {\n-            visitor.visit_generics(generics);\n-        }\n-        FnKind::Closure | FnKind::Method(..) => {}\n+pub fn walk_fn_ret_ty<'v, V: Visitor<'v>>(visitor: &mut V, ret_ty: &'v FnRetTy<'v>) {\n+    if let FnRetTy::Return(ref output_ty) = *ret_ty {\n+        visitor.visit_ty(output_ty)\n     }\n }\n \n@@ -914,6 +925,20 @@ pub fn walk_fn<'v, V: Visitor<'v>>(\n     visitor.visit_nested_body(body_id)\n }\n \n+pub fn walk_fn_kind<'v, V: Visitor<'v>>(visitor: &mut V, function_kind: FnKind<'v>) {\n+    match function_kind {\n+        FnKind::ItemFn(_, generics, ..) => {\n+            visitor.visit_generics(generics);\n+        }\n+        FnKind::Closure | FnKind::Method(..) => {}\n+    }\n+}\n+\n+pub fn walk_use<'v, V: Visitor<'v>>(visitor: &mut V, path: &'v Path<'v>, hir_id: HirId) {\n+    visitor.visit_id(hir_id);\n+    visitor.visit_path(path, hir_id);\n+}\n+\n pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v TraitItem<'v>) {\n     // N.B., deliberately force a compilation error if/when new fields are added.\n     let TraitItem { ident, generics, ref defaultness, ref kind, span, owner_id: _ } = *trait_item;\n@@ -1008,6 +1033,29 @@ pub fn walk_impl_item_ref<'v, V: Visitor<'v>>(visitor: &mut V, impl_item_ref: &'\n     visitor.visit_associated_item_kind(kind);\n }\n \n+pub fn walk_trait_ref<'v, V: Visitor<'v>>(visitor: &mut V, trait_ref: &'v TraitRef<'v>) {\n+    visitor.visit_id(trait_ref.hir_ref_id);\n+    visitor.visit_path(&trait_ref.path, trait_ref.hir_ref_id)\n+}\n+\n+pub fn walk_param_bound<'v, V: Visitor<'v>>(visitor: &mut V, bound: &'v GenericBound<'v>) {\n+    match *bound {\n+        GenericBound::Trait(ref typ, _modifier) => {\n+            visitor.visit_poly_trait_ref(typ);\n+        }\n+        GenericBound::LangItemTrait(_, _span, hir_id, args) => {\n+            visitor.visit_id(hir_id);\n+            visitor.visit_generic_args(args);\n+        }\n+        GenericBound::Outlives(ref lifetime) => visitor.visit_lifetime(lifetime),\n+    }\n+}\n+\n+pub fn walk_poly_trait_ref<'v, V: Visitor<'v>>(visitor: &mut V, trait_ref: &'v PolyTraitRef<'v>) {\n+    walk_list!(visitor, visit_generic_param, trait_ref.bound_generic_params);\n+    visitor.visit_trait_ref(&trait_ref.trait_ref);\n+}\n+\n pub fn walk_struct_def<'v, V: Visitor<'v>>(\n     visitor: &mut V,\n     struct_definition: &'v VariantData<'v>,\n@@ -1022,173 +1070,101 @@ pub fn walk_field_def<'v, V: Visitor<'v>>(visitor: &mut V, field: &'v FieldDef<'\n     visitor.visit_ty(&field.ty);\n }\n \n-pub fn walk_block<'v, V: Visitor<'v>>(visitor: &mut V, block: &'v Block<'v>) {\n-    visitor.visit_id(block.hir_id);\n-    walk_list!(visitor, visit_stmt, block.stmts);\n-    walk_list!(visitor, visit_expr, &block.expr);\n+pub fn walk_enum_def<'v, V: Visitor<'v>>(\n+    visitor: &mut V,\n+    enum_definition: &'v EnumDef<'v>,\n+    item_id: HirId,\n+) {\n+    visitor.visit_id(item_id);\n+    walk_list!(visitor, visit_variant, enum_definition.variants);\n }\n \n-pub fn walk_stmt<'v, V: Visitor<'v>>(visitor: &mut V, statement: &'v Stmt<'v>) {\n-    visitor.visit_id(statement.hir_id);\n-    match statement.kind {\n-        StmtKind::Local(ref local) => visitor.visit_local(local),\n-        StmtKind::Item(item) => visitor.visit_nested_item(item),\n-        StmtKind::Expr(ref expression) | StmtKind::Semi(ref expression) => {\n-            visitor.visit_expr(expression)\n-        }\n-    }\n+pub fn walk_variant<'v, V: Visitor<'v>>(visitor: &mut V, variant: &'v Variant<'v>) {\n+    visitor.visit_ident(variant.ident);\n+    visitor.visit_id(variant.id);\n+    visitor.visit_variant_data(&variant.data);\n+    walk_list!(visitor, visit_anon_const, &variant.disr_expr);\n }\n \n-pub fn walk_array_len<'v, V: Visitor<'v>>(visitor: &mut V, len: &'v ArrayLen) {\n-    match len {\n-        &ArrayLen::Infer(hir_id, _span) => visitor.visit_id(hir_id),\n-        ArrayLen::Body(c) => visitor.visit_anon_const(c),\n-    }\n+pub fn walk_label<'v, V: Visitor<'v>>(visitor: &mut V, label: &'v Label) {\n+    visitor.visit_ident(label.ident);\n }\n \n-pub fn walk_anon_const<'v, V: Visitor<'v>>(visitor: &mut V, constant: &'v AnonConst) {\n-    visitor.visit_id(constant.hir_id);\n-    visitor.visit_nested_body(constant.body);\n+pub fn walk_inf<'v, V: Visitor<'v>>(visitor: &mut V, inf: &'v InferArg) {\n+    visitor.visit_id(inf.hir_id);\n }\n \n-pub fn walk_let_expr<'v, V: Visitor<'v>>(visitor: &mut V, let_expr: &'v Let<'v>) {\n-    // match the visit order in walk_local\n-    visitor.visit_expr(let_expr.init);\n-    visitor.visit_id(let_expr.hir_id);\n-    visitor.visit_pat(let_expr.pat);\n-    walk_list!(visitor, visit_ty, let_expr.ty);\n+pub fn walk_generic_arg<'v, V: Visitor<'v>>(visitor: &mut V, generic_arg: &'v GenericArg<'v>) {\n+    match generic_arg {\n+        GenericArg::Lifetime(lt) => visitor.visit_lifetime(lt),\n+        GenericArg::Type(ty) => visitor.visit_ty(ty),\n+        GenericArg::Const(ct) => visitor.visit_anon_const(&ct.value),\n+        GenericArg::Infer(inf) => visitor.visit_infer(inf),\n+    }\n }\n \n-pub fn walk_expr_field<'v, V: Visitor<'v>>(visitor: &mut V, field: &'v ExprField<'v>) {\n-    visitor.visit_id(field.hir_id);\n-    visitor.visit_ident(field.ident);\n-    visitor.visit_expr(&field.expr)\n+pub fn walk_lifetime<'v, V: Visitor<'v>>(visitor: &mut V, lifetime: &'v Lifetime) {\n+    visitor.visit_id(lifetime.hir_id);\n+    match lifetime.name {\n+        LifetimeName::Param(_, ParamName::Plain(ident)) => {\n+            visitor.visit_ident(ident);\n+        }\n+        LifetimeName::Param(_, ParamName::Fresh)\n+        | LifetimeName::Param(_, ParamName::Error)\n+        | LifetimeName::Static\n+        | LifetimeName::Error\n+        | LifetimeName::ImplicitObjectLifetimeDefault\n+        | LifetimeName::Infer => {}\n+    }\n }\n \n-pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr<'v>) {\n-    visitor.visit_id(expression.hir_id);\n-    match expression.kind {\n-        ExprKind::Box(ref subexpression) => visitor.visit_expr(subexpression),\n-        ExprKind::Array(subexpressions) => {\n-            walk_list!(visitor, visit_expr, subexpressions);\n-        }\n-        ExprKind::ConstBlock(ref anon_const) => visitor.visit_anon_const(anon_const),\n-        ExprKind::Repeat(ref element, ref count) => {\n-            visitor.visit_expr(element);\n-            visitor.visit_array_length(count)\n-        }\n-        ExprKind::Struct(ref qpath, fields, ref optional_base) => {\n-            visitor.visit_qpath(qpath, expression.hir_id, expression.span);\n-            walk_list!(visitor, visit_expr_field, fields);\n-            walk_list!(visitor, visit_expr, optional_base);\n-        }\n-        ExprKind::Tup(subexpressions) => {\n-            walk_list!(visitor, visit_expr, subexpressions);\n-        }\n-        ExprKind::Call(ref callee_expression, arguments) => {\n-            visitor.visit_expr(callee_expression);\n-            walk_list!(visitor, visit_expr, arguments);\n+pub fn walk_qpath<'v, V: Visitor<'v>>(visitor: &mut V, qpath: &'v QPath<'v>, id: HirId) {\n+    match *qpath {\n+        QPath::Resolved(ref maybe_qself, ref path) => {\n+            walk_list!(visitor, visit_ty, maybe_qself);\n+            visitor.visit_path(path, id)\n         }\n-        ExprKind::MethodCall(ref segment, receiver, arguments, _) => {\n+        QPath::TypeRelative(ref qself, ref segment) => {\n+            visitor.visit_ty(qself);\n             visitor.visit_path_segment(segment);\n-            visitor.visit_expr(receiver);\n-            walk_list!(visitor, visit_expr, arguments);\n         }\n-        ExprKind::Binary(_, ref left_expression, ref right_expression) => {\n-            visitor.visit_expr(left_expression);\n-            visitor.visit_expr(right_expression)\n-        }\n-        ExprKind::AddrOf(_, _, ref subexpression) | ExprKind::Unary(_, ref subexpression) => {\n-            visitor.visit_expr(subexpression)\n-        }\n-        ExprKind::Cast(ref subexpression, ref typ) | ExprKind::Type(ref subexpression, ref typ) => {\n-            visitor.visit_expr(subexpression);\n-            visitor.visit_ty(typ)\n-        }\n-        ExprKind::DropTemps(ref subexpression) => {\n-            visitor.visit_expr(subexpression);\n-        }\n-        ExprKind::Let(ref let_expr) => visitor.visit_let_expr(let_expr),\n-        ExprKind::If(ref cond, ref then, ref else_opt) => {\n-            visitor.visit_expr(cond);\n-            visitor.visit_expr(then);\n-            walk_list!(visitor, visit_expr, else_opt);\n-        }\n-        ExprKind::Loop(ref block, ref opt_label, _, _) => {\n-            walk_list!(visitor, visit_label, opt_label);\n-            visitor.visit_block(block);\n-        }\n-        ExprKind::Match(ref subexpression, arms, _) => {\n-            visitor.visit_expr(subexpression);\n-            walk_list!(visitor, visit_arm, arms);\n-        }\n-        ExprKind::Closure(&Closure {\n-            binder: _,\n-            bound_generic_params,\n-            fn_decl,\n-            body,\n-            capture_clause: _,\n-            fn_decl_span: _,\n-            movability: _,\n-        }) => {\n-            walk_list!(visitor, visit_generic_param, bound_generic_params);\n-            visitor.visit_fn(FnKind::Closure, fn_decl, body, expression.span, expression.hir_id)\n-        }\n-        ExprKind::Block(ref block, ref opt_label) => {\n-            walk_list!(visitor, visit_label, opt_label);\n-            visitor.visit_block(block);\n-        }\n-        ExprKind::Assign(ref lhs, ref rhs, _) => {\n-            visitor.visit_expr(rhs);\n-            visitor.visit_expr(lhs)\n-        }\n-        ExprKind::AssignOp(_, ref left_expression, ref right_expression) => {\n-            visitor.visit_expr(right_expression);\n-            visitor.visit_expr(left_expression);\n-        }\n-        ExprKind::Field(ref subexpression, ident) => {\n-            visitor.visit_expr(subexpression);\n-            visitor.visit_ident(ident);\n-        }\n-        ExprKind::Index(ref main_expression, ref index_expression) => {\n-            visitor.visit_expr(main_expression);\n-            visitor.visit_expr(index_expression)\n-        }\n-        ExprKind::Path(ref qpath) => {\n-            visitor.visit_qpath(qpath, expression.hir_id, expression.span);\n-        }\n-        ExprKind::Break(ref destination, ref opt_expr) => {\n-            walk_list!(visitor, visit_label, &destination.label);\n-            walk_list!(visitor, visit_expr, opt_expr);\n-        }\n-        ExprKind::Continue(ref destination) => {\n-            walk_list!(visitor, visit_label, &destination.label);\n-        }\n-        ExprKind::Ret(ref optional_expression) => {\n-            walk_list!(visitor, visit_expr, optional_expression);\n-        }\n-        ExprKind::InlineAsm(ref asm) => {\n-            visitor.visit_inline_asm(asm, expression.hir_id);\n-        }\n-        ExprKind::Yield(ref subexpression, _) => {\n-            visitor.visit_expr(subexpression);\n-        }\n-        ExprKind::Lit(_) | ExprKind::Err => {}\n+        QPath::LangItem(..) => {}\n     }\n }\n \n-pub fn walk_arm<'v, V: Visitor<'v>>(visitor: &mut V, arm: &'v Arm<'v>) {\n-    visitor.visit_id(arm.hir_id);\n-    visitor.visit_pat(&arm.pat);\n-    if let Some(ref g) = arm.guard {\n-        match g {\n-            Guard::If(ref e) => visitor.visit_expr(e),\n-            Guard::IfLet(ref l) => {\n-                visitor.visit_let_expr(l);\n-            }\n-        }\n+pub fn walk_path<'v, V: Visitor<'v>>(visitor: &mut V, path: &'v Path<'v>) {\n+    for segment in path.segments {\n+        visitor.visit_path_segment(segment);\n+    }\n+}\n+\n+pub fn walk_path_segment<'v, V: Visitor<'v>>(visitor: &mut V, segment: &'v PathSegment<'v>) {\n+    visitor.visit_ident(segment.ident);\n+    visitor.visit_id(segment.hir_id);\n+    if let Some(ref args) = segment.args {\n+        visitor.visit_generic_args(args);\n+    }\n+}\n+\n+pub fn walk_generic_args<'v, V: Visitor<'v>>(visitor: &mut V, generic_args: &'v GenericArgs<'v>) {\n+    walk_list!(visitor, visit_generic_arg, generic_args.args);\n+    walk_list!(visitor, visit_assoc_type_binding, generic_args.bindings);\n+}\n+\n+pub fn walk_assoc_type_binding<'v, V: Visitor<'v>>(\n+    visitor: &mut V,\n+    type_binding: &'v TypeBinding<'v>,\n+) {\n+    visitor.visit_id(type_binding.hir_id);\n+    visitor.visit_ident(type_binding.ident);\n+    visitor.visit_generic_args(type_binding.gen_args);\n+    match type_binding.kind {\n+        TypeBindingKind::Equality { ref term } => match term {\n+            Term::Ty(ref ty) => visitor.visit_ty(ty),\n+            Term::Const(ref c) => visitor.visit_anon_const(c),\n+        },\n+        TypeBindingKind::Constraint { bounds } => walk_list!(visitor, visit_param_bound, bounds),\n     }\n-    visitor.visit_expr(&arm.body);\n }\n \n pub fn walk_associated_item_kind<'v, V: Visitor<'v>>(_: &mut V, _: &'v AssocItemKind) {\n@@ -1202,3 +1178,27 @@ pub fn walk_defaultness<'v, V: Visitor<'v>>(_: &mut V, _: &'v Defaultness) {\n     // the right thing to do, should content be added in the future,\n     // would be to walk it.\n }\n+\n+pub fn walk_inline_asm<'v, V: Visitor<'v>>(visitor: &mut V, asm: &'v InlineAsm<'v>, id: HirId) {\n+    for (op, op_sp) in asm.operands {\n+        match op {\n+            InlineAsmOperand::In { expr, .. } | InlineAsmOperand::InOut { expr, .. } => {\n+                visitor.visit_expr(expr)\n+            }\n+            InlineAsmOperand::Out { expr, .. } => {\n+                if let Some(expr) = expr {\n+                    visitor.visit_expr(expr);\n+                }\n+            }\n+            InlineAsmOperand::SplitInOut { in_expr, out_expr, .. } => {\n+                visitor.visit_expr(in_expr);\n+                if let Some(out_expr) = out_expr {\n+                    visitor.visit_expr(out_expr);\n+                }\n+            }\n+            InlineAsmOperand::Const { anon_const, .. }\n+            | InlineAsmOperand::SymFn { anon_const, .. } => visitor.visit_anon_const(anon_const),\n+            InlineAsmOperand::SymStatic { path, .. } => visitor.visit_qpath(path, id, *op_sp),\n+        }\n+    }\n+}"}]}