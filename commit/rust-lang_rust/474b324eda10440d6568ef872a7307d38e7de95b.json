{"sha": "474b324eda10440d6568ef872a7307d38e7de95b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3NGIzMjRlZGExMDQ0MGQ2NTY4ZWY4NzJhNzMwN2QzOGU3ZGU5NWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-31T03:57:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-31T03:57:01Z"}, "message": "Auto merge of #21791 - alexcrichton:rollup, r=alexcrichton", "tree": {"sha": "53fc5aaa615f1c6e5abd757e42a75b3d19ce3abb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/53fc5aaa615f1c6e5abd757e42a75b3d19ce3abb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/474b324eda10440d6568ef872a7307d38e7de95b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/474b324eda10440d6568ef872a7307d38e7de95b", "html_url": "https://github.com/rust-lang/rust/commit/474b324eda10440d6568ef872a7307d38e7de95b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/474b324eda10440d6568ef872a7307d38e7de95b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d00c545ede609b9d43fdf9f252c15da5a66dac7", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d00c545ede609b9d43fdf9f252c15da5a66dac7", "html_url": "https://github.com/rust-lang/rust/commit/1d00c545ede609b9d43fdf9f252c15da5a66dac7"}, {"sha": "e8fd9d3d0bf0f4974460337df29c0d3ceb514987", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8fd9d3d0bf0f4974460337df29c0d3ceb514987", "html_url": "https://github.com/rust-lang/rust/commit/e8fd9d3d0bf0f4974460337df29c0d3ceb514987"}], "stats": {"total": 11855, "additions": 4539, "deletions": 7316}, "files": [{"sha": "605c2fc9a611a88e3ea580eeff5459f99058a1ba", "filename": "README.md", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -110,12 +110,14 @@ There is a lot more documentation in the [wiki].\n \n The Rust community congregates in a few places:\n \n-* [StackOverflow] - Get help here.\n-* [/r/rust] - General discussion.\n+* [StackOverflow] - Direct questions about using the language here.\n+* [users.rust-lang.org] - General discussion, broader questions.\n * [internals.rust-lang.org] - For development of the Rust language itself.\n+* [/r/rust] - News and general discussion.\n \n [StackOverflow]: http://stackoverflow.com/questions/tagged/rust\n [/r/rust]: http://reddit.com/r/rust\n+[users.rust-lang.org]: http://users.rust-lang.org/\n [internals.rust-lang.org]: http://internals.rust-lang.org/\n \n ## License"}, {"sha": "df2981a6c8334a385180a405c4f8155797e020ee", "filename": "src/compiletest/common.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Fcompiletest%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Fcompiletest%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcommon.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -25,17 +25,18 @@ pub enum Mode {\n }\n \n impl FromStr for Mode {\n-    fn from_str(s: &str) -> Option<Mode> {\n+    type Err = ();\n+    fn from_str(s: &str) -> Result<Mode, ()> {\n         match s {\n-          \"compile-fail\" => Some(CompileFail),\n-          \"run-fail\" => Some(RunFail),\n-          \"run-pass\" => Some(RunPass),\n-          \"run-pass-valgrind\" => Some(RunPassValgrind),\n-          \"pretty\" => Some(Pretty),\n-          \"debuginfo-lldb\" => Some(DebugInfoLldb),\n-          \"debuginfo-gdb\" => Some(DebugInfoGdb),\n-          \"codegen\" => Some(Codegen),\n-          _ => None,\n+          \"compile-fail\" => Ok(CompileFail),\n+          \"run-fail\" => Ok(RunFail),\n+          \"run-pass\" => Ok(RunPass),\n+          \"run-pass-valgrind\" => Ok(RunPassValgrind),\n+          \"pretty\" => Ok(Pretty),\n+          \"debuginfo-lldb\" => Ok(DebugInfoLldb),\n+          \"debuginfo-gdb\" => Ok(DebugInfoGdb),\n+          \"codegen\" => Ok(Codegen),\n+          _ => Err(()),\n         }\n     }\n }"}, {"sha": "b73623223fd4eecbc197eb940507ba40cf618059", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -9,21 +9,20 @@\n // except according to those terms.\n \n #![crate_type = \"bin\"]\n-#![allow(unknown_features)]\n-#![feature(slicing_syntax, unboxed_closures)]\n+\n #![feature(box_syntax)]\n+#![feature(collections)]\n+#![feature(core)]\n #![feature(int_uint)]\n-#![feature(test)]\n-#![feature(rustc_private)]\n-#![feature(std_misc)]\n-#![feature(path)]\n #![feature(io)]\n-#![feature(core)]\n-#![feature(collections)]\n #![feature(os)]\n+#![feature(path)]\n+#![feature(rustc_private)]\n+#![feature(slicing_syntax, unboxed_closures)]\n+#![feature(std_misc)]\n+#![feature(test)]\n #![feature(unicode)]\n \n-#![allow(unstable)]\n #![deny(warnings)]\n \n extern crate test;\n@@ -35,7 +34,6 @@ extern crate log;\n use std::os;\n use std::old_io;\n use std::old_io::fs;\n-use std::str::FromStr;\n use std::thunk::Thunk;\n use getopts::{optopt, optflag, reqopt};\n use common::Config;\n@@ -140,9 +138,7 @@ pub fn parse_config(args: Vec<String> ) -> Config {\n         build_base: opt_path(matches, \"build-base\"),\n         aux_base: opt_path(matches, \"aux-base\"),\n         stage_id: matches.opt_str(\"stage-id\").unwrap(),\n-        mode: FromStr::from_str(matches.opt_str(\"mode\")\n-                                       .unwrap()\n-                                       .as_slice()).expect(\"invalid mode\"),\n+        mode: matches.opt_str(\"mode\").unwrap().parse().ok().expect(\"invalid mode\"),\n         run_ignored: matches.opt_present(\"ignored\"),\n         filter: filter,\n         logfile: matches.opt_str(\"logfile\").map(|s| Path::new(s)),"}, {"sha": "66059d2d13d263bca1f9895eca4b293b716890e8", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -352,8 +352,8 @@ pub fn gdb_version_to_int(version_string: &str) -> int {\n         panic!(\"{}\", error_string);\n     }\n \n-    let major: int = components[0].parse().expect(error_string);\n-    let minor: int = components[1].parse().expect(error_string);\n+    let major: int = components[0].parse().ok().expect(error_string);\n+    let minor: int = components[1].parse().ok().expect(error_string);\n \n     return major * 1000 + minor;\n }\n@@ -363,6 +363,6 @@ pub fn lldb_version_to_int(version_string: &str) -> int {\n         \"Encountered LLDB version string with unexpected format: {}\",\n         version_string);\n     let error_string = error_string.as_slice();\n-    let major: int = version_string.parse().expect(error_string);\n+    let major: int = version_string.parse().ok().expect(error_string);\n     return major;\n }"}, {"sha": "252a3125ebdf388c32a1850b7722ac7610536875", "filename": "src/doc/index.md", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Fdoc%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Fdoc%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Findex.md?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -39,10 +39,12 @@ Overflow](http://stackoverflow.com/questions/tagged/rust). Searching for your\n problem might reveal someone who has asked it before!\n \n There is an active [subreddit](http://reddit.com/r/rust) with lots of\n-discussion about Rust.\n+discussion and news about Rust.\n \n-There is also a [developer forum](http://internals.rust-lang.org/), where the\n-development of Rust itself is discussed.\n+There is also a [user forum](http://users.rust-lang.org), for all\n+user-oriented discussion, and a [developer\n+forum](http://internals.rust-lang.org/), where the development of Rust\n+itself is discussed.\n \n # Specification\n "}, {"sha": "936c0aac79f16e021c9f74a3f6935511561d78c7", "filename": "src/doc/reference.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -2994,7 +2994,7 @@ Some examples of call expressions:\n # fn add(x: i32, y: i32) -> i32 { 0 }\n \n let x: i32 = add(1i32, 2i32);\n-let pi: Option<f32> = \"3.14\".parse();\n+let pi: Option<f32> = \"3.14\".parse().ok();\n ```\n \n ### Lambda expressions\n@@ -3518,7 +3518,7 @@ An example of each kind:\n ```{rust}\n let vec: Vec<i32> = vec![1, 2, 3];\n let arr: [i32; 3] = [1, 2, 3];\n-let s: &[i32] = vec.as_slice();\n+let s: &[i32] = &vec;\n ```\n \n As you can see, the `vec!` macro allows you to create a `Vec<T>` easily. The"}, {"sha": "162e533d8bb72cb02aedfa75a79ca98691d9aa9f", "filename": "src/doc/trpl/guessing-game.md", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Fdoc%2Ftrpl%2Fguessing-game.md", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Fdoc%2Ftrpl%2Fguessing-game.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fguessing-game.md?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -400,7 +400,7 @@ a function for that:\n let input = old_io::stdin().read_line()\n                        .ok()\n                        .expect(\"Failed to read line\");\n-let input_num: Option<u32> = input.parse();\n+let input_num: Option<u32> = input.parse().ok();\n ```\n \n The `parse` function takes in a `&str` value and converts it into something.\n@@ -422,11 +422,13 @@ In this case, we say `x` is a `u32` explicitly, so Rust is able to properly\n tell `random()` what to generate. In a similar fashion, both of these work:\n \n ```{rust,ignore}\n-let input_num = \"5\".parse::<u32>(); // input_num: Option<u32>\n-let input_num: Option<u32> = \"5\".parse(); // input_num: Option<u32>\n+let input_num = \"5\".parse::<u32>().ok(); // input_num: Option<u32>\n+let input_num: Option<u32> = \"5\".parse().ok(); // input_num: Option<u32>\n ```\n \n-Anyway, with us now converting our input to a number, our code looks like this:\n+Here we're converting the `Result` returned by `parse` to an `Option` by using\n+the `ok` method as well.  Anyway, with us now converting our input to a number,\n+our code looks like this:\n \n ```{rust,ignore}\n use std::old_io;\n@@ -445,7 +447,7 @@ fn main() {\n     let input = old_io::stdin().read_line()\n                            .ok()\n                            .expect(\"Failed to read line\");\n-    let input_num: Option<u32> = input.parse();\n+    let input_num: Option<u32> = input.parse().ok();\n \n     println!(\"You guessed: {}\", input_num);\n \n@@ -495,7 +497,7 @@ fn main() {\n     let input = old_io::stdin().read_line()\n                            .ok()\n                            .expect(\"Failed to read line\");\n-    let input_num: Option<u32> = input.parse();\n+    let input_num: Option<u32> = input.parse().ok();\n \n     let num = match input_num {\n         Some(num) => num,\n@@ -562,7 +564,7 @@ fn main() {\n     let input = old_io::stdin().read_line()\n                            .ok()\n                            .expect(\"Failed to read line\");\n-    let input_num: Option<u32> = input.trim().parse();\n+    let input_num: Option<u32> = input.trim().parse().ok();\n \n     let num = match input_num {\n         Some(num) => num,\n@@ -638,7 +640,7 @@ fn main() {\n         let input = old_io::stdin().read_line()\n                                .ok()\n                                .expect(\"Failed to read line\");\n-        let input_num: Option<u32> = input.trim().parse();\n+        let input_num: Option<u32> = input.trim().parse().ok();\n \n         let num = match input_num {\n             Some(num) => num,\n@@ -714,7 +716,7 @@ fn main() {\n         let input = old_io::stdin().read_line()\n                                .ok()\n                                .expect(\"Failed to read line\");\n-        let input_num: Option<u32> = input.trim().parse();\n+        let input_num: Option<u32> = input.trim().parse().ok();\n \n         let num = match input_num {\n             Some(num) => num,\n@@ -770,7 +772,7 @@ fn main() {\n         let input = old_io::stdin().read_line()\n                                .ok()\n                                .expect(\"Failed to read line\");\n-        let input_num: Option<u32> = input.trim().parse();\n+        let input_num: Option<u32> = input.trim().parse().ok();\n \n         let num = match input_num {\n             Some(num) => num,\n@@ -847,7 +849,7 @@ fn main() {\n         let input = old_io::stdin().read_line()\n                                .ok()\n                                .expect(\"Failed to read line\");\n-        let input_num: Option<u32> = input.trim().parse();\n+        let input_num: Option<u32> = input.trim().parse().ok();\n \n         let num = match input_num {\n             Some(num) => num,"}, {"sha": "986ad23c665a705a9b34a9fb11abd3c39ffcae00", "filename": "src/doc/trpl/more-strings.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Fdoc%2Ftrpl%2Fmore-strings.md", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Fdoc%2Ftrpl%2Fmore-strings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmore-strings.md?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -100,7 +100,7 @@ To write a function that's generic over types of strings, use `&str`.\n \n ```\n fn some_string_length(x: &str) -> uint {\n-        x.len()\n+    x.len()\n }\n \n fn main() {\n@@ -110,7 +110,7 @@ fn main() {\n \n     let s = \"Hello, world\".to_string();\n \n-    println!(\"{}\", some_string_length(s.as_slice()));\n+    println!(\"{}\", some_string_length(&s));\n }\n ```\n "}, {"sha": "122cffe36975f397a4974e9e3537e3e8d19a9189", "filename": "src/doc/trpl/patterns.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Fdoc%2Ftrpl%2Fpatterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Fdoc%2Ftrpl%2Fpatterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fpatterns.md?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -174,13 +174,13 @@ match origin {\n }\n ```\n \n-If you want to match against a slice or array, you can use `[]`:\n+If you want to match against a slice or array, you can use `&`:\n \n ```{rust}\n fn main() {\n     let v = vec![\"match_this\", \"1\"];\n \n-    match v.as_slice() {\n+    match &v[] {\n         [\"match_this\", second] => println!(\"The second element is {}\", second),\n         _ => {},\n     }"}, {"sha": "5ff233b4844157f78450859bc9a5cf7335595768", "filename": "src/doc/trpl/plugins.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Fdoc%2Ftrpl%2Fplugins.md", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Fdoc%2Ftrpl%2Fplugins.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fplugins.md?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -82,7 +82,7 @@ fn expand_rn(cx: &mut ExtCtxt, sp: Span, args: &[TokenTree])\n         }\n     };\n \n-    let mut text = text.as_slice();\n+    let mut text = &text;\n     let mut total = 0;\n     while !text.is_empty() {\n         match NUMERALS.iter().find(|&&(rn, _)| text.starts_with(rn)) {"}, {"sha": "794b1df7563de7cde12943cf122762f1265806e5", "filename": "src/doc/trpl/standard-input.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Fdoc%2Ftrpl%2Fstandard-input.md", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Fdoc%2Ftrpl%2Fstandard-input.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fstandard-input.md?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -20,7 +20,7 @@ Let's go over these chunks, one by one:\n std::old_io::stdin();\n ```\n \n-This calls a function, `stdin()`, that lives inside the `std::io` module. As\n+This calls a function, `stdin()`, that lives inside the `std::old_io` module. As\n you can imagine, everything in `std` is provided by Rust, the 'standard\n library.' We'll talk more about the module system later.\n "}, {"sha": "e05c6e172a49e9d5dafd6dd355702de4be60a510", "filename": "src/doc/trpl/strings.md", "status": "modified", "additions": 3, "deletions": 23, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Fdoc%2Ftrpl%2Fstrings.md", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Fdoc%2Ftrpl%2Fstrings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fstrings.md?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -36,36 +36,16 @@ s.push_str(\", world.\");\n println!(\"{}\", s);\n ```\n \n-You can get a `&str` view into a `String` with the `as_slice()` method:\n+`String`s will coerece into `&str` with an `&`:\n \n-```{rust}\n+```\n fn takes_slice(slice: &str) {\n     println!(\"Got: {}\", slice);\n }\n \n fn main() {\n     let s = \"Hello\".to_string();\n-    takes_slice(s.as_slice());\n-}\n-```\n-\n-To compare a String to a constant string, prefer `as_slice()`...\n-\n-```{rust}\n-fn compare(string: String) {\n-    if string.as_slice() == \"Hello\" {\n-        println!(\"yes\");\n-    }\n-}\n-```\n-\n-... over `to_string()`:\n-\n-```{rust}\n-fn compare(string: String) {\n-    if string == \"Hello\".to_string() {\n-        println!(\"yes\");\n-    }\n+    takes_slice(&s);\n }\n ```\n "}, {"sha": "2bd86fa987f4be962bd3ec3086dd5ee2b8cf5b2e", "filename": "src/doc/trpl/unsafe.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Fdoc%2Ftrpl%2Funsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Fdoc%2Ftrpl%2Funsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Funsafe.md?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -576,6 +576,10 @@ extern fn panic_fmt(args: &core::fmt::Arguments,\n #[lang = \"eh_personality\"] extern fn eh_personality() {}\n # #[start] fn start(argc: isize, argv: *const *const u8) -> isize { 0 }\n # fn main() {}\n+# mod std {  // for-loops\n+#     pub use core::iter;\n+#     pub use core::option;\n+# }\n ```\n \n Note that there is one extra lang item here which differs from the examples"}, {"sha": "6b56c2b630346ff32c1cf6650917017e0204fc1a", "filename": "src/driver/driver.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Fdriver.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(unknown_features)]\n #![cfg_attr(rustc, feature(rustc_private))]\n #![cfg_attr(rustdoc, feature(rustdoc))]\n "}, {"sha": "24470c258b375a2f7113df38568811a8aa98b102", "filename": "src/etc/emacs/README.md", "status": "removed", "additions": 0, "deletions": 79, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/1d00c545ede609b9d43fdf9f252c15da5a66dac7/src%2Fetc%2Femacs%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/1d00c545ede609b9d43fdf9f252c15da5a66dac7/src%2Fetc%2Femacs%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Femacs%2FREADME.md?ref=1d00c545ede609b9d43fdf9f252c15da5a66dac7", "patch": "@@ -1,79 +0,0 @@\n-`rust-mode`: A major Emacs mode for editing Rust source code\n-============================================================\n-\n-`rust-mode` makes editing [Rust](http://rust-lang.org) code with Emacs\n-enjoyable.\n-\n-\n-### Manual Installation\n-\n-To install manually, check out this repository and add this to your\n-`.emacs` file:\n-\n-```lisp\n-(add-to-list 'load-path \"/path/to/rust-mode/\")\n-(autoload 'rust-mode \"rust-mode\" nil t)\n-(add-to-list 'auto-mode-alist '(\"\\\\.rs\\\\'\" . rust-mode))\n-```\n-\n-This associates `rust-mode` with `.rs` files. To enable it explicitly, do\n-<kbd>M-x rust-mode</kbd>.\n-\n-### `package.el` installation via Marmalade or MELPA\n-\n-It can be more convenient to use Emacs's package manager to handle\n-installation for you if you use many elisp libraries. If you have\n-`package.el` but haven't added Marmalade or MELPA, the community\n-package source, yet, add this to `~/.emacs.d/init.el`:\n-\n-Using Marmalade:\n-\n-```lisp\n-(require 'package)\n-(add-to-list 'package-archives\n-             '(\"marmalade\" . \"http://marmalade-repo.org/packages/\"))\n-(package-initialize)\n-```\n-\n-Using MELPA:\n-\n-```lisp\n-(require 'package)\n-(add-to-list 'package-archives\n-             '(\"melpa\" . \"http://melpa.milkbox.net/packages/\") t)\n-(package-initialize)\n-```\n-\n-Then do this to load the package listing:\n-\n-* <kbd>M-x eval-buffer</kbd>\n-* <kbd>M-x package-refresh-contents</kbd>\n-\n-If you use a version of Emacs prior to 24 that doesn't include\n-`package.el`, you can get it from [here](http://bit.ly/pkg-el23).\n-\n-If you have an older ELPA `package.el` installed from tromey.com, you\n-should upgrade in order to support installation from multiple sources.\n-The ELPA archive is deprecated and no longer accepting new packages,\n-so the version there (1.7.1) is very outdated.\n-\n-#### Install `rust-mode`\n-\n-One you have `package.el`, you can install `rust-mode` or any other\n-modes by choosing them from a list:\n-\n-* <kbd>M-x package-list-packages</kbd>\n-\n-Now, to install packages, move your cursor to them and press\n-<kbd>i</kbd>. This will mark the packages for installation. When\n-you're done with marking, press <kbd>x</kbd>, and ELPA will install\n-the packages for you (under `~/.emacs.d/elpa/`).\n-\n-* or using <kbd>M-x package-install rust-mode</kbd>\n-\n-### Tests via ERT\n-\n-The file `rust-mode-tests.el` contains tests that can be run via\n-[ERT](http://www.gnu.org/software/emacs/manual/html_node/ert/index.html).\n-You can use `run_rust_emacs_tests.sh` to run them in batch mode, if\n-Emacs is somewhere in your `$PATH`."}, {"sha": "b35fcf870c4d36f4ae7eb499edd31eef4968bb59", "filename": "src/etc/emacs/run_rust_emacs_tests.sh", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1d00c545ede609b9d43fdf9f252c15da5a66dac7/src%2Fetc%2Femacs%2Frun_rust_emacs_tests.sh", "raw_url": "https://github.com/rust-lang/rust/raw/1d00c545ede609b9d43fdf9f252c15da5a66dac7/src%2Fetc%2Femacs%2Frun_rust_emacs_tests.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Femacs%2Frun_rust_emacs_tests.sh?ref=1d00c545ede609b9d43fdf9f252c15da5a66dac7", "patch": "@@ -1,14 +0,0 @@\n-#!/bin/sh\n-# Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-# file at the top-level directory of this distribution and at\n-# http://rust-lang.org/COPYRIGHT.\n-#\n-# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-# option. This file may not be copied, modified, or distributed\n-# except according to those terms.\n-#\n-# This runs the test for emacs rust-mode.\n-# It must be possible to find emacs via PATH.\n-emacs -batch -l rust-mode.el -l rust-mode-tests.el -f ert-run-tests-batch-and-exit"}, {"sha": "f255dbf15071b6dc3852bace3c21aa7d706ab759", "filename": "src/etc/emacs/rust-mode-tests.el", "status": "removed", "additions": 0, "deletions": 896, "changes": 896, "blob_url": "https://github.com/rust-lang/rust/blob/1d00c545ede609b9d43fdf9f252c15da5a66dac7/src%2Fetc%2Femacs%2Frust-mode-tests.el", "raw_url": "https://github.com/rust-lang/rust/raw/1d00c545ede609b9d43fdf9f252c15da5a66dac7/src%2Fetc%2Femacs%2Frust-mode-tests.el", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Femacs%2Frust-mode-tests.el?ref=1d00c545ede609b9d43fdf9f252c15da5a66dac7", "patch": "@@ -1,896 +0,0 @@\n-;;; rust-mode-tests.el --- ERT tests for rust-mode.el\n-\n-(require 'rust-mode)\n-(require 'ert)\n-(require 'cl)\n-\n-(setq rust-test-fill-column 32)\n-\n-(defun rust-compare-code-after-manip (original point-pos manip-func expected got)\n-  (equal expected got))\n-\n-(defun rust-test-explain-bad-manip (original point-pos manip-func expected got)\n-  (if (equal expected got)\n-      nil\n-    (list\n-     ;; The (goto-char) and (insert) business here is just for\n-     ;; convenience--after an error, you can copy-paste that into emacs eval to\n-     ;; insert the bare strings into a buffer\n-     \"Rust code was manipulated wrong after:\"\n-     `(insert ,original)\n-     `(goto-char ,point-pos)\n-     'expected `(insert ,expected)\n-     'got `(insert ,got)\n-     (loop for i from 0 to (max (length original) (length expected))\n-           for oi = (if (< i (length got)) (elt got i))\n-           for ei = (if (< i (length expected)) (elt expected i))\n-           while (equal oi ei)\n-           finally return `(first-difference-at\n-                            (goto-char ,(+ 1 i))\n-                            expected ,(char-to-string ei)\n-                            got ,(char-to-string oi))))))\n-(put 'rust-compare-code-after-manip 'ert-explainer\n-     'rust-test-explain-bad-manip)\n-\n-(defun rust-test-manip-code (original point-pos manip-func expected)\n-  (with-temp-buffer\n-    (rust-mode)\n-    (insert original)\n-    (goto-char point-pos)\n-    (funcall manip-func)\n-    (should (rust-compare-code-after-manip\n-             original point-pos manip-func expected (buffer-string)))))\n-\n-(defun test-fill-paragraph (unfilled expected &optional start-pos end-pos)\n-  \"We're going to run through many scenarios here--the point should be able to be anywhere from the start-pos (defaults to 1) through end-pos (defaults to the length of what was passed in) and (fill-paragraph) should return the same result.\n-\n-Also, the result should be the same regardless of whether the code is at the beginning or end of the file.  (If you're not careful, that can make a difference.)  So we test each position given above with the passed code at the beginning, the end, neither and both.  So we do this a total of (end-pos - start-pos)*4 times.  Oy.\"\n-  (let* ((start-pos (or start-pos 1))\n-         (end-pos (or end-pos (length unfilled)))\n-         (padding \"\\n     \\n\")\n-         (padding-len (length padding)))\n-    (loop\n-     for pad-at-beginning from 0 to 1\n-     do (loop for pad-at-end from 0 to 1\n-              with padding-beginning = (if (= 0 pad-at-beginning) \"\" padding)\n-              with padding-end = (if (= 0 pad-at-end) \"\" padding)\n-              with padding-adjust = (* padding-len pad-at-beginning)\n-              with padding-beginning = (if (= 0 pad-at-beginning) \"\" padding)\n-              with padding-end = (if (= 0 pad-at-end) \"\" padding)\n-              ;; If we're adding space to the beginning, and our start position\n-              ;; is at the very beginning, we want to test within the added space.\n-              ;; Otherwise adjust the start and end for the beginning padding.\n-              with start-pos = (if (= 1 start-pos) 1 (+ padding-adjust start-pos))\n-              with end-pos = (+ end-pos padding-adjust)\n-              do (loop for pos from start-pos to end-pos\n-                       do (rust-test-manip-code\n-                           (concat padding-beginning unfilled padding-end)\n-                           pos\n-                           (lambda ()\n-                             (let ((fill-column rust-test-fill-column))\n-                               (fill-paragraph)))\n-                           (concat padding-beginning expected padding-end)))))))\n-\n-(ert-deftest fill-paragraph-top-level-multi-line-style-doc-comment-second-line ()\n-  (test-fill-paragraph\n-   \"/**\n- * This is a very very very very very very very long string\n- */\"\n-   \"/**\n- * This is a very very very very\n- * very very very long string\n- */\"))\n-\n-\n-(ert-deftest fill-paragraph-top-level-multi-line-style-doc-comment-first-line ()\n-  (test-fill-paragraph\n-   \"/** This is a very very very very very very very long string\n- */\"\n-   \"/** This is a very very very\n- * very very very very long\n- * string\n- */\"))\n-\n-(ert-deftest fill-paragraph-multi-paragraph-multi-line-style-doc-comment ()\n-  (let\n-      ((multi-paragraph-unfilled\n-        \"/**\n- * This is the first really really really really really really really long paragraph\n- *\n- * This is the second really really really really really really long paragraph\n- */\"))\n-    (test-fill-paragraph\n-     multi-paragraph-unfilled\n-     \"/**\n- * This is the first really\n- * really really really really\n- * really really long paragraph\n- *\n- * This is the second really really really really really really long paragraph\n- */\"\n-     1 89)\n-    (test-fill-paragraph\n-     multi-paragraph-unfilled\n-     \"/**\n- * This is the first really really really really really really really long paragraph\n- *\n- * This is the second really\n- * really really really really\n- * really long paragraph\n- */\"\n-     90)))\n-\n-(ert-deftest fill-paragraph-multi-paragraph-single-line-style-doc-comment ()\n-  (let\n-      ((multi-paragraph-unfilled\n-        \"/// This is the first really really really really really really really long paragraph\n-///\n-/// This is the second really really really really really really long paragraph\"))\n-    (test-fill-paragraph\n-     multi-paragraph-unfilled\n-     \"/// This is the first really\n-/// really really really really\n-/// really really long paragraph\n-///\n-/// This is the second really really really really really really long paragraph\"\n-     1 86)\n-    (test-fill-paragraph\n-     multi-paragraph-unfilled\n-     \"/// This is the first really really really really really really really long paragraph\n-///\n-/// This is the second really\n-/// really really really really\n-/// really long paragraph\"\n-     87)))\n-\n-(ert-deftest fill-paragraph-multi-paragraph-single-line-style-indented ()\n-  (test-fill-paragraph\n-   \"     // This is the first really really really really really really really long paragraph\n-     //\n-     // This is the second really really really really really really long paragraph\"\n-   \"     // This is the first really\n-     // really really really\n-     // really really really\n-     // long paragraph\n-     //\n-     // This is the second really really really really really really long paragraph\" 1 89))\n-\n-(ert-deftest fill-paragraph-multi-line-style-inner-doc-comment ()\n-  (test-fill-paragraph\n-   \"/*! This is a very very very very very very very long string\n- */\"\n-   \"/*! This is a very very very\n- * very very very very long\n- * string\n- */\"))\n-\n-(ert-deftest fill-paragraph-single-line-style-inner-doc-comment ()\n-  (test-fill-paragraph\n-   \"//! This is a very very very very very very very long string\"\n-   \"//! This is a very very very\n-//! very very very very long\n-//! string\"))\n-\n-(ert-deftest fill-paragraph-prefixless-multi-line-doc-comment ()\n-  (test-fill-paragraph\n-   \"/**\n-This is my summary. Blah blah blah blah blah. Dilly dally dilly dally dilly dally doo.\n-\n-This is some more text.  Fee fie fo fum.  Humpty dumpty sat on a wall.\n-*/\"\n-   \"/**\n-This is my summary. Blah blah\n-blah blah blah. Dilly dally\n-dilly dally dilly dally doo.\n-\n-This is some more text.  Fee fie fo fum.  Humpty dumpty sat on a wall.\n-*/\" 4 90))\n-\n-(ert-deftest fill-paragraph-with-no-space-after-star-prefix ()\n-  (test-fill-paragraph\n-   \"/**\n- *This is a very very very very very very very long string\n- */\"\n-   \"/**\n- *This is a very very very very\n- *very very very long string\n- */\"))\n-\n-(ert-deftest fill-paragraph-single-line-style-with-code-before ()\n-  (test-fill-paragraph\n-   \"fn foo() { }\n-/// This is my comment.  This is more of my comment.  This is even more.\"\n-   \"fn foo() { }\n-/// This is my comment.  This is\n-/// more of my comment.  This is\n-/// even more.\" 14))\n-\n-(ert-deftest fill-paragraph-single-line-style-with-code-after ()\n-  (test-fill-paragraph\n-   \"/// This is my comment.  This is more of my comment.  This is even more.\n-fn foo() { }\"\n-   \"/// This is my comment.  This is\n-/// more of my comment.  This is\n-/// even more.\n-fn foo() { }\" 1 73))\n-\n-(ert-deftest fill-paragraph-single-line-style-code-before-and-after ()\n-  (test-fill-paragraph\n-   \"fn foo() { }\n-/// This is my comment.  This is more of my comment.  This is even more.\n-fn bar() { }\"\n-   \"fn foo() { }\n-/// This is my comment.  This is\n-/// more of my comment.  This is\n-/// even more.\n-fn bar() { }\" 14 67))\n-\n-(defun test-auto-fill (initial position inserted expected)\n-  (rust-test-manip-code\n-   initial\n-   position\n-   (lambda ()\n-     (unwind-protect\n-         (progn\n-           (let ((fill-column rust-test-fill-column))\n-             (auto-fill-mode)\n-             (goto-char position)\n-             (insert inserted)\n-             (syntax-ppss-flush-cache 1)\n-             (funcall auto-fill-function)))\n-       (auto-fill-mode t)))\n-   expected))\n-\n-(ert-deftest auto-fill-multi-line-doc-comment ()\n-  (test-auto-fill\n-   \"/**\n- *\n- */\"\n-   8\n-   \"This is a very very very very very very very long string\"\n-   \"/**\n- * This is a very very very very\n- * very very very long string\n- */\"))\n-\n-(ert-deftest auto-fill-single-line-doc-comment ()\n-  (test-auto-fill\n-   \"/// This is the first really\n-/// really really really really\n-/// really really long paragraph\n-///\n-/// \"\n-   103\n-   \"This is the second really really really really really really long paragraph\"\n-   \"/// This is the first really\n-/// really really really really\n-/// really really long paragraph\n-///\n-/// This is the second really\n-/// really really really really\n-/// really long paragraph\"\n-   ))\n-\n-(ert-deftest auto-fill-multi-line-prefixless ()\n-  (test-auto-fill\n-   \"/*\n-\n- */\"\n-   4\n-   \"This is a very very very very very very very long string\"\n-   \"/*\n-This is a very very very very\n-very very very long string\n- */\"\n-   ))\n-\n-(defun test-indent (indented)\n-  (let ((deindented (replace-regexp-in-string \"^[[:blank:]]*\" \"      \" indented)))\n-    (rust-test-manip-code\n-     deindented\n-     1\n-     (lambda () (indent-region 1 (buffer-size)))\n-     indented)))\n-\n-\n-(ert-deftest indent-struct-fields-aligned ()\n-  (test-indent\n-   \"\n-struct Foo { bar: int,\n-             baz: int }\n-\n-struct Blah {x:int,\n-             y:int,\n-             z:String\"))\n-\n-(ert-deftest indent-doc-comments ()\n-  (test-indent\n-   \"\n-/**\n- * This is a doc comment\n- *\n- */\n-\n-/// So is this\n-\n-fn foo() {\n-    /*!\n-     * this is a nested doc comment\n-     */\n-\n-    //! And so is this\n-}\"))\n-\n-(ert-deftest indent-inside-braces ()\n-  (test-indent\n-   \"\n-// struct fields out one level:\n-struct foo {\n-    a:int,\n-    // comments too\n-    b:char\n-}\n-\n-fn bar(x:Box<int>) {   // comment here should not affect the next indent\n-    bla();\n-    bla();\n-}\"))\n-\n-(ert-deftest indent-top-level ()\n-  (test-indent\n-   \"\n-// Everything here is at the top level and should not be indented\n-#[attrib]\n-mod foo;\n-\n-pub static bar = Quux{a: b()}\n-\n-use foo::bar::baz;\n-\n-fn foo() { }\n-\"))\n-\n-(ert-deftest indent-params-no-align ()\n-  (test-indent\n-   \"\n-// Indent out one level because no params appear on the first line\n-fn xyzzy(\n-    a:int,\n-    b:char) { }\n-\n-fn abcdef(\n-    a:int,\n-    b:char)\n-    -> char\n-{ }\"))\n-\n-(ert-deftest indent-params-align ()\n-  (test-indent\n-   \"\n-// Align the second line of params to the first\n-fn foo(a:int,\n-       b:char) { }\n-\n-fn bar(   a:int,\n-          b:char)\n-          -> int\n-{ }\n-\n-fn baz(   a:int,  // should work with a comment here\n-          b:char)\n-          -> int\n-{ }\n-\"))\n-\n-(ert-deftest indent-square-bracket-alignment ()\n-  (test-indent\n-   \"\n-fn args_on_the_next_line( // with a comment\n-    a:int,\n-    b:String) {\n-    let aaaaaa = [\n-        1,\n-        2,\n-        3];\n-    let bbbbbbb = [1, 2, 3,\n-                   4, 5, 6];\n-    let ccc = [   10, 9, 8,\n-                  7, 6, 5];\n-}\n-\"))\n-\n-(ert-deftest indent-nested-fns ()\n-  (test-indent\n-   \"\n-fn nexted_fns(a: fn(b:int,\n-                    c:char)\n-                    -> int,\n-              d: int)\n-              -> uint\n-{\n-    0\n-}\n-\"\n-   ))\n-\n-(ert-deftest indent-multi-line-expr ()\n-  (test-indent\n-   \"\n-fn foo()\n-{\n-    x();\n-    let a =\n-        b();\n-}\n-\"\n-   ))\n-\n-(ert-deftest indent-match ()\n-  (test-indent\n-   \"\n-fn foo() {\n-    match blah {\n-        Pattern => stuff(),\n-        _ => whatever\n-    }\n-}\n-\"\n-   ))\n-\n-(ert-deftest indent-match-multiline-pattern ()\n-  (test-indent\n-   \"\n-fn foo() {\n-    match blah {\n-        Pattern |\n-        Pattern2 => {\n-            hello()\n-        },\n-        _ => whatever\n-    }\n-}\n-\"\n-   ))\n-\n-(ert-deftest indent-indented-match ()\n-  (test-indent\n-   \"\n-fn foo() {\n-    let x =\n-        match blah {\n-            Pattern |\n-            Pattern2 => {\n-                hello()\n-            },\n-            _ => whatever\n-        };\n-    y();\n-}\n-\"\n-   ))\n-\n-(ert-deftest indent-curly-braces-within-parens ()\n-  (test-indent\n-   \"\n-fn foo() {\n-    let x =\n-        foo(bar(|x| {\n-            only_one_indent_here();\n-        }));\n-    y();\n-}\n-\"\n-   ))\n-\n-(ert-deftest indent-weirdly-indented-block ()\n-  (rust-test-manip-code\n-   \"\n-fn foo() {\n- {\n-this_block_is_over_to_the_left_for_some_reason();\n- }\n-\n-}\n-\"\n-   16\n-   #'indent-for-tab-command\n-   \"\n-fn foo() {\n- {\n-     this_block_is_over_to_the_left_for_some_reason();\n- }\n-\n-}\n-\"\n-   ))\n-\n-(ert-deftest indent-multi-line-attrib ()\n-  (test-indent\n-   \"\n-#[attrib(\n-    this,\n-    that,\n-    theotherthing)]\n-fn function_with_multiline_attribute() {}\n-\"\n-   ))\n-\n-\n-;; Make sure that in effort to cover match patterns we don't mistreat || or expressions\n-(ert-deftest indent-nonmatch-or-expression ()\n-  (test-indent\n-   \"\n-fn foo() {\n-    let x = foo() ||\n-        bar();\n-}\n-\"\n-   ))\n-\n-(setq rust-test-motion-string\n-      \"\n-fn fn1(arg: int) -> bool {\n-    let x = 5;\n-    let y = b();\n-    true\n-}\n-\n-fn fn2(arg: int) -> bool {\n-    let x = 5;\n-    let y = b();\n-    true\n-}\n-\n-pub fn fn3(arg: int) -> bool {\n-    let x = 5;\n-    let y = b();\n-    true\n-}\n-\n-struct Foo {\n-    x: int\n-}\n-\"\n-      rust-test-region-string rust-test-motion-string\n-      rust-test-indent-motion-string\n-      \"\n-fn blank_line(arg:int) -> bool {\n-\n-}\n-\n-fn indenting_closing_brace() {\n-    if(true) {\n-}\n-}\n-\n-fn indenting_middle_of_line() {\n-    if(true) {\n- push_me_out();\n-} else {\n-               pull_me_back_in();\n-}\n-}\n-\n-fn indented_already() {\n-\n-    // The previous line already has its spaces\n-}\n-\"\n-\n-      ;; Symbol -> (line column)\n-      rust-test-positions-alist '((start-of-fn1 (2 0))\n-                                  (start-of-fn1-middle-of-line (2 15))\n-                                  (middle-of-fn1 (3 7))\n-                                  (end-of-fn1 (6 0))\n-                                  (between-fn1-fn2 (7 0))\n-                                  (start-of-fn2 (8 0))\n-                                  (middle-of-fn2 (10 4))\n-                                  (before-start-of-fn1 (1 0))\n-                                  (after-end-of-fn2 (13 0))\n-                                  (beginning-of-fn3 (14 0))\n-                                  (middle-of-fn3 (16 4))\n-                                  (middle-of-struct (21 10))\n-                                  (before-start-of-struct (19 0))\n-                                  (after-end-of-struct (23 0))\n-                                  (blank-line-indent-start (3 0))\n-                                  (blank-line-indent-target (3 4))\n-                                  (closing-brace-indent-start (8 1))\n-                                  (closing-brace-indent-target (8 5))\n-                                  (middle-push-indent-start (13 2))\n-                                  (middle-push-indent-target (13 9))\n-                                  (after-whitespace-indent-start (13 1))\n-                                  (after-whitespace-indent-target (13 8))\n-                                  (middle-pull-indent-start (15 19))\n-                                  (middle-pull-indent-target (15 12))\n-                                  (blank-line-indented-already-bol-start (20 0))\n-                                  (blank-line-indented-already-bol-target (20 4))\n-                                  (blank-line-indented-already-middle-start (20 2))\n-                                  (blank-line-indented-already-middle-target (20 4))\n-                                  (nonblank-line-indented-already-bol-start (21 0))\n-                                  (nonblank-line-indented-already-bol-target (21 4))\n-                                  (nonblank-line-indented-already-middle-start (21 2))\n-                                  (nonblank-line-indented-already-middle-target (21 4))))\n-\n-(defun rust-get-buffer-pos (pos-symbol)\n-  \"Get buffer position from POS-SYMBOL.\n-\n-POS-SYMBOL is a symbol found in `rust-test-positions-alist'.\n-Convert the line-column information from that list into a buffer position value.\"\n-  (interactive \"P\")\n-  (pcase-let ((`(,line ,column) (cadr (assoc pos-symbol rust-test-positions-alist))))\n-    (save-excursion\n-      (goto-line line)\n-      (move-to-column column)\n-      (point))))\n-\n-;;; FIXME: Maybe add an ERT explainer function (something that shows the\n-;;; surrounding code of the final point, not just the position).\n-(defun rust-test-motion (source-code init-pos final-pos manip-func &optional &rest args)\n-  \"Test that MANIP-FUNC moves point from INIT-POS to FINAL-POS.\n-\n-If ARGS are provided, send them to MANIP-FUNC.\n-\n-INIT-POS, FINAL-POS are position symbols found in `rust-test-positions-alist'.\"\n-  (with-temp-buffer\n-    (rust-mode)\n-    (insert source-code)\n-    (goto-char (rust-get-buffer-pos init-pos))\n-    (apply manip-func args)\n-    (should (equal (point) (rust-get-buffer-pos final-pos)))))\n-\n-(defun rust-test-region (source-code init-pos reg-beg reg-end manip-func &optional &rest args)\n-  \"Test that MANIP-FUNC marks region from REG-BEG to REG-END.\n-\n-INIT-POS is the initial position of point.\n-If ARGS are provided, send them to MANIP-FUNC.\n-All positions are position symbols found in `rust-test-positions-alist'.\"\n-  (with-temp-buffer\n-    (rust-mode)\n-    (insert source-code)\n-    (goto-char (rust-get-buffer-pos init-pos))\n-    (apply manip-func args)\n-    (should (equal (list (region-beginning) (region-end))\n-                   (list (rust-get-buffer-pos reg-beg)\n-                         (rust-get-buffer-pos reg-end))))))\n-\n-(ert-deftest rust-beginning-of-defun-from-middle-of-fn ()\n-  (rust-test-motion\n-   rust-test-motion-string\n-   'middle-of-fn1\n-   'start-of-fn1\n-   #'beginning-of-defun))\n-\n-(ert-deftest rust-beginning-of-defun-from-end ()\n-  (rust-test-motion\n-   rust-test-motion-string\n-   'end-of-fn1\n-   'start-of-fn1\n-   #'beginning-of-defun))\n-\n-(ert-deftest rust-beginning-of-defun-before-open-brace ()\n-  (rust-test-motion\n-   rust-test-motion-string\n-   'start-of-fn1-middle-of-line\n-   'start-of-fn1\n-   #'beginning-of-defun))\n-\n-(ert-deftest rust-beginning-of-defun-between-fns ()\n-  (rust-test-motion\n-   rust-test-motion-string\n-   'between-fn1-fn2\n-   'start-of-fn1\n-   #'beginning-of-defun))\n-\n-(ert-deftest rust-beginning-of-defun-with-arg ()\n-  (rust-test-motion\n-   rust-test-motion-string\n-   'middle-of-fn2\n-   'start-of-fn1\n-   #'beginning-of-defun 2))\n-\n-(ert-deftest rust-beginning-of-defun-with-negative-arg ()\n-  (rust-test-motion\n-   rust-test-motion-string\n-   'middle-of-fn1\n-   'beginning-of-fn3\n-   #'beginning-of-defun -2))\n-\n-(ert-deftest rust-beginning-of-defun-pub-fn ()\n-  (rust-test-motion\n-   rust-test-motion-string\n-   'middle-of-fn3\n-   'beginning-of-fn3\n-   #'beginning-of-defun))\n-\n-(ert-deftest rust-end-of-defun-from-middle-of-fn ()\n-  (rust-test-motion\n-   rust-test-motion-string\n-   'middle-of-fn1\n-   'between-fn1-fn2\n-   #'end-of-defun))\n-\n-(ert-deftest rust-end-of-defun-from-beg ()\n-  (rust-test-motion\n-   rust-test-motion-string\n-   'start-of-fn1\n-   'between-fn1-fn2\n-   #'end-of-defun))\n-\n-(ert-deftest rust-end-of-defun-before-open-brace ()\n-  (rust-test-motion\n-   rust-test-motion-string\n-   'start-of-fn1-middle-of-line\n-   'between-fn1-fn2\n-   #'end-of-defun))\n-\n-(ert-deftest rust-end-of-defun-between-fns ()\n-  (rust-test-motion\n-   rust-test-motion-string\n-   'between-fn1-fn2\n-   'after-end-of-fn2\n-   #'end-of-defun))\n-\n-(ert-deftest rust-end-of-defun-with-arg ()\n-  (rust-test-motion\n-   rust-test-motion-string\n-   'middle-of-fn1\n-   'after-end-of-fn2\n-   #'end-of-defun 2))\n-\n-(ert-deftest rust-end-of-defun-with-negative-arg ()\n-  (rust-test-motion\n-   rust-test-motion-string\n-   'middle-of-fn3\n-   'between-fn1-fn2\n-   #'end-of-defun -2))\n-\n-(ert-deftest rust-mark-defun-from-middle-of-fn ()\n-  (rust-test-region\n-   rust-test-region-string\n-   'middle-of-fn2\n-   'between-fn1-fn2 'after-end-of-fn2\n-   #'mark-defun))\n-\n-(ert-deftest rust-mark-defun-from-end ()\n-  (rust-test-region\n-   rust-test-region-string\n-   'end-of-fn1\n-   'before-start-of-fn1 'between-fn1-fn2\n-   #'mark-defun))\n-\n-(ert-deftest rust-mark-defun-start-of-defun ()\n-  (rust-test-region\n-   rust-test-region-string\n-   'start-of-fn2\n-   'between-fn1-fn2 'after-end-of-fn2\n-   #'mark-defun))\n-\n-(ert-deftest rust-mark-defun-from-middle-of-struct ()\n-  (rust-test-region\n-   rust-test-region-string\n-   'middle-of-struct\n-   'before-start-of-struct 'after-end-of-struct\n-   #'mark-defun))\n-\n-(ert-deftest indent-line-blank-line-motion ()\n-  (rust-test-motion\n-   rust-test-indent-motion-string\n-   'blank-line-indent-start\n-   'blank-line-indent-target\n-   #'indent-for-tab-command))\n-\n-(ert-deftest indent-line-closing-brace-motion ()\n-  (rust-test-motion\n-   rust-test-indent-motion-string\n-   'closing-brace-indent-start\n-   'closing-brace-indent-target\n-   #'indent-for-tab-command))\n-\n-(ert-deftest indent-line-middle-push-motion ()\n-  (rust-test-motion\n-   rust-test-indent-motion-string\n-   'middle-push-indent-start\n-   'middle-push-indent-target\n-   #'indent-for-tab-command))\n-\n-(ert-deftest indent-line-after-whitespace-motion ()\n-  (rust-test-motion\n-   rust-test-indent-motion-string\n-   'after-whitespace-indent-start\n-   'after-whitespace-indent-target\n-   #'indent-for-tab-command))\n-\n-(ert-deftest indent-line-middle-pull-motion ()\n-  (rust-test-motion\n-   rust-test-indent-motion-string\n-   'middle-pull-indent-start\n-   'middle-pull-indent-target\n-   #'indent-for-tab-command))\n-\n-(ert-deftest indent-line-blank-line-indented-already-bol ()\n-  (rust-test-motion\n-   rust-test-indent-motion-string\n-   'blank-line-indented-already-bol-start\n-   'blank-line-indented-already-bol-target\n-   #'indent-for-tab-command))\n-\n-(ert-deftest indent-line-blank-line-indented-already-middle ()\n-  (rust-test-motion\n-   rust-test-indent-motion-string\n-   'blank-line-indented-already-middle-start\n-   'blank-line-indented-already-middle-target\n-   #'indent-for-tab-command))\n-\n-(ert-deftest indent-line-nonblank-line-indented-already-bol ()\n-  (rust-test-motion\n-   rust-test-indent-motion-string\n-   'nonblank-line-indented-already-bol-start\n-   'nonblank-line-indented-already-bol-target\n-   #'indent-for-tab-command))\n-\n-(ert-deftest indent-line-nonblank-line-indented-already-middle ()\n-  (rust-test-motion\n-   rust-test-indent-motion-string\n-   'nonblank-line-indented-already-middle-start\n-   'nonblank-line-indented-already-middle-target\n-   #'indent-for-tab-command))\n-\n-(defun rust-test-fontify-string (str)\n-  (with-temp-buffer\n-    (rust-mode)\n-    (insert str)\n-    (font-lock-fontify-buffer)\n-    (buffer-string)))\n-\n-(defun rust-test-group-str-by-face (str)\n-  \"Fontify `STR' in rust-mode and group it by face, returning a\n-list of substrings of `STR' each followed by its face.\"\n-  (cl-loop with fontified = (rust-test-fontify-string str)\n-           for start = 0 then end\n-           while start\n-           for end   = (next-single-property-change start 'face fontified)\n-           for prop  = (get-text-property start 'face fontified)\n-           for text  = (substring-no-properties fontified start end)\n-           if prop\n-           append (list text prop)))\n-\n-(defun rust-test-font-lock (source face-groups)\n-  \"Test that `SOURCE' fontifies to the expected `FACE-GROUPS'\"\n-  (should (equal (rust-test-group-str-by-face source)\n-                 face-groups)))\n-\n-(ert-deftest font-lock-attribute-simple ()\n-  (rust-test-font-lock\n-   \"#[foo]\"\n-   '(\"#[foo]\" font-lock-preprocessor-face)))\n-\n-(ert-deftest font-lock-attribute-inner ()\n-  (rust-test-font-lock\n-   \"#![foo]\"\n-   '(\"#![foo]\" font-lock-preprocessor-face)))\n-\n-(ert-deftest font-lock-attribute-key-value ()\n-  (rust-test-font-lock\n-   \"#[foo = \\\"bar\\\"]\"\n-   '(\"#[foo = \" font-lock-preprocessor-face\n-     \"\\\"bar\\\"\" font-lock-string-face\n-     \"]\" font-lock-preprocessor-face)))\n-\n-(ert-deftest font-lock-attribute-around-comment ()\n-  (rust-test-font-lock\n-   \"#[foo /* bar */]\"\n-   '(\"#[foo \" font-lock-preprocessor-face\n-     \"/* \" font-lock-comment-delimiter-face\n-     \"bar */\" font-lock-comment-face\n-     \"]\" font-lock-preprocessor-face)))\n-\n-(ert-deftest font-lock-attribute-inside-string ()\n-  (rust-test-font-lock\n-   \"\\\"#[foo]\\\"\"\n-   '(\"\\\"#[foo]\\\"\" font-lock-string-face)))\n-\n-(ert-deftest font-lock-attribute-inside-comment ()\n-  (rust-test-font-lock\n-   \"/* #[foo] */\"\n-   '(\"/* \" font-lock-comment-delimiter-face\n-     \"#[foo] */\" font-lock-comment-face)))"}, {"sha": "dae685f3a540a63dc1185304c4710e7f42547673", "filename": "src/etc/emacs/rust-mode.el", "status": "removed", "additions": 0, "deletions": 520, "changes": 520, "blob_url": "https://github.com/rust-lang/rust/blob/1d00c545ede609b9d43fdf9f252c15da5a66dac7/src%2Fetc%2Femacs%2Frust-mode.el", "raw_url": "https://github.com/rust-lang/rust/raw/1d00c545ede609b9d43fdf9f252c15da5a66dac7/src%2Fetc%2Femacs%2Frust-mode.el", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Femacs%2Frust-mode.el?ref=1d00c545ede609b9d43fdf9f252c15da5a66dac7", "patch": "@@ -1,520 +0,0 @@\n-;;; rust-mode.el --- A major emacs mode for editing Rust source code\n-\n-;; Version: 0.2.0\n-;; Author: Mozilla\n-;; Url: https://github.com/rust-lang/rust\n-;; Keywords: languages\n-\n-;;; Commentary:\n-;;\n-\n-;;; Code:\n-\n-(eval-when-compile (require 'misc))\n-\n-;; for GNU Emacs < 24.3\n-(eval-when-compile\n-  (unless (fboundp 'setq-local)\n-    (defmacro setq-local (var val)\n-      \"Set variable VAR to value VAL in current buffer.\"\n-      (list 'set (list 'make-local-variable (list 'quote var)) val))))\n-\n-;; Syntax definitions and helpers\n-(defvar rust-mode-syntax-table\n-  (let ((table (make-syntax-table)))\n-\n-    ;; Operators\n-    (dolist (i '(?+ ?- ?* ?/ ?& ?| ?^ ?! ?< ?> ?~ ?@))\n-      (modify-syntax-entry i \".\" table))\n-\n-    ;; Strings\n-    (modify-syntax-entry ?\\\" \"\\\"\" table)\n-    (modify-syntax-entry ?\\\\ \"\\\\\" table)\n-\n-    ;; mark _ as a word constituent so that identifiers\n-    ;; such as xyz_type don't cause type to be highlighted\n-    ;; as a keyword\n-    (modify-syntax-entry ?_ \"w\" table)\n-\n-    ;; Comments\n-    (modify-syntax-entry ?/  \". 124b\" table)\n-    (modify-syntax-entry ?*  \". 23\"   table)\n-    (modify-syntax-entry ?\\n \"> b\"    table)\n-    (modify-syntax-entry ?\\^m \"> b\"   table)\n-\n-    table))\n-\n-(defgroup rust-mode nil\n-  \"Support for Rust code.\"\n-  :link '(url-link \"http://www.rust-lang.org/\")\n-  :group 'languages)\n-\n-(defcustom rust-indent-offset 4\n-  \"Indent Rust code by this number of spaces.\"\n-  :type 'integer\n-  :group 'rust-mode)\n-\n-(defcustom rust-indent-method-chain nil\n-  \"Indent Rust method chains, aligned by the '.' operators\"\n-  :type 'boolean\n-  :group 'rust-mode)\n-\n-(defun rust-paren-level () (nth 0 (syntax-ppss)))\n-(defun rust-in-str-or-cmnt () (nth 8 (syntax-ppss)))\n-(defun rust-rewind-past-str-cmnt () (goto-char (nth 8 (syntax-ppss))))\n-(defun rust-rewind-irrelevant ()\n-  (let ((starting (point)))\n-    (skip-chars-backward \"[:space:]\\n\")\n-    (if (looking-back \"\\\\*/\") (backward-char))\n-    (if (rust-in-str-or-cmnt)\n-        (rust-rewind-past-str-cmnt))\n-    (if (/= starting (point))\n-        (rust-rewind-irrelevant))))\n-\n-(defun rust-align-to-expr-after-brace ()\n-  (save-excursion\n-    (forward-char)\n-    ;; We don't want to indent out to the open bracket if the\n-    ;; open bracket ends the line\n-    (when (not (looking-at \"[[:blank:]]*\\\\(?://.*\\\\)?$\"))\n-      (when (looking-at \"[[:space:]]\")\n-    (forward-word 1)\n-    (backward-word 1))\n-      (current-column))))\n-\n-(defun rust-align-to-method-chain ()\n-  (save-excursion\n-    (previous-line)\n-    (end-of-line)\n-    (backward-word 1)\n-    (backward-char)\n-    (when (looking-at \"\\\\..+\\(.*\\)\\n\")\n-      (- (current-column) rust-indent-offset))))\n-\n-(defun rust-rewind-to-beginning-of-current-level-expr ()\n-  (let ((current-level (rust-paren-level)))\n-    (back-to-indentation)\n-    (while (> (rust-paren-level) current-level)\n-      (backward-up-list)\n-      (back-to-indentation))))\n-\n-(defun rust-mode-indent-line ()\n-  (interactive)\n-  (let ((indent\n-         (save-excursion\n-           (back-to-indentation)\n-           ;; Point is now at beginning of current line\n-           (let* ((level (rust-paren-level))\n-                  (baseline\n-                   ;; Our \"baseline\" is one level out from the indentation of the expression\n-                   ;; containing the innermost enclosing opening bracket.  That\n-                   ;; way if we are within a block that has a different\n-                   ;; indentation than this mode would give it, we still indent\n-                   ;; the inside of it correctly relative to the outside.\n-                   (if (= 0 level)\n-                       0\n-                     (or\n-                      (when rust-indent-method-chain\n-                        (rust-align-to-method-chain))\n-                     (save-excursion\n-                       (backward-up-list)\n-                       (rust-rewind-to-beginning-of-current-level-expr)\n-                       (+ (current-column) rust-indent-offset))))))\n-             (cond\n-              ;; A function return type is indented to the corresponding function arguments\n-              ((looking-at \"->\")\n-               (save-excursion\n-                 (backward-list)\n-                 (or (rust-align-to-expr-after-brace)\n-                     (+ baseline rust-indent-offset))))\n-\n-              ;; A closing brace is 1 level unindended\n-              ((looking-at \"}\") (- baseline rust-indent-offset))\n-\n-              ;;Line up method chains by their .'s\n-              ((when (and rust-indent-method-chain\n-                          (looking-at \"\\..+\\(.*\\);?\\n\"))\n-                 (or\n-                  (let ((method-indent (rust-align-to-method-chain)))\n-                    (when method-indent\n-                      (+ method-indent rust-indent-offset)))\n-                  (+ baseline rust-indent-offset))))\n-\n-              \n-              ;; Doc comments in /** style with leading * indent to line up the *s\n-              ((and (nth 4 (syntax-ppss)) (looking-at \"*\"))\n-               (+ 1 baseline))\n-\n-              ;; If we're in any other token-tree / sexp, then:\n-              (t\n-               (or\n-                ;; If we are inside a pair of braces, with something after the\n-                ;; open brace on the same line and ending with a comma, treat\n-                ;; it as fields and align them.\n-                (when (> level 0)\n-                  (save-excursion\n-                    (rust-rewind-irrelevant)\n-                    (backward-up-list)\n-                    ;; Point is now at the beginning of the containing set of braces\n-                    (rust-align-to-expr-after-brace)))\n-\n-                (progn\n-                  (back-to-indentation)\n-                  ;; Point is now at the beginning of the current line\n-                  (if (or\n-                       ;; If this line begins with \"else\" or \"{\", stay on the\n-                       ;; baseline as well (we are continuing an expression,\n-                       ;; but the \"else\" or \"{\" should align with the beginning\n-                       ;; of the expression it's in.)\n-                       (looking-at \"\\\\<else\\\\>\\\\|{\")\n-\n-                       (save-excursion\n-                         (rust-rewind-irrelevant)\n-                         ;; Point is now at the end of the previous ine\n-                         (or\n-                          ;; If we are at the first line, no indentation is needed, so stay at baseline...\n-                          (= 1 (line-number-at-pos (point)))\n-                          ;; ..or if the previous line ends with any of these:\n-                          ;;     { ? : ( , ; [ }\n-                          ;; then we are at the beginning of an expression, so stay on the baseline...\n-                          (looking-back \"[(,:;?[{}]\\\\|[^|]|\")\n-                          ;; or if the previous line is the end of an attribute, stay at the baseline...\n-                          (progn (rust-rewind-to-beginning-of-current-level-expr) (looking-at \"#\")))))\n-                      baseline\n-\n-                    ;; Otherwise, we are continuing the same expression from the previous line,\n-                    ;; so add one additional indent level\n-                    (+ baseline rust-indent-offset))))))))))\n-\n-    ;; If we're at the beginning of the line (before or at the current\n-    ;; indentation), jump with the indentation change.  Otherwise, save the\n-    ;; excursion so that adding the indentations will leave us at the\n-    ;; equivalent position within the line to where we were before.\n-    (if (<= (current-column) (current-indentation))\n-        (indent-line-to indent)\n-      (save-excursion (indent-line-to indent)))))\n-\n-\n-;; Font-locking definitions and helpers\n-(defconst rust-mode-keywords\n-  '(\"as\"\n-    \"box\" \"break\"\n-    \"const\" \"continue\" \"crate\"\n-    \"do\"\n-    \"else\" \"enum\" \"extern\"\n-    \"false\" \"fn\" \"for\"\n-    \"if\" \"impl\" \"in\"\n-    \"let\" \"loop\"\n-    \"match\" \"mod\" \"move\" \"mut\"\n-    \"priv\" \"pub\"\n-    \"ref\" \"return\"\n-    \"self\" \"static\" \"struct\" \"super\"\n-    \"true\" \"trait\" \"type\"\n-    \"unsafe\" \"use\"\n-    \"virtual\"\n-    \"where\" \"while\"))\n-\n-(defconst rust-special-types\n-  '(\"u8\" \"i8\"\n-    \"u16\" \"i16\"\n-    \"u32\" \"i32\"\n-    \"u64\" \"i64\"\n-\n-    \"f32\" \"f64\"\n-    \"float\" \"int\" \"uint\" \"isize\" \"usize\"\n-    \"bool\"\n-    \"str\" \"char\"))\n-\n-(defconst rust-re-ident \"[[:word:][:multibyte:]_][[:word:][:multibyte:]_[:digit:]]*\")\n-(defconst rust-re-CamelCase \"[[:upper:]][[:word:][:multibyte:]_[:digit:]]*\")\n-(defun rust-re-word (inner) (concat \"\\\\<\" inner \"\\\\>\"))\n-(defun rust-re-grab (inner) (concat \"\\\\(\" inner \"\\\\)\"))\n-(defun rust-re-grabword (inner) (rust-re-grab (rust-re-word inner)))\n-(defun rust-re-item-def (itype)\n-  (concat (rust-re-word itype) \"[[:space:]]+\" (rust-re-grab rust-re-ident)))\n-\n-(defvar rust-mode-font-lock-keywords\n-  (append\n-   `(\n-     ;; Keywords proper\n-     (,(regexp-opt rust-mode-keywords 'words) . font-lock-keyword-face)\n-\n-     ;; Special types\n-     (,(regexp-opt rust-special-types 'words) . font-lock-type-face)\n-\n-     ;; Attributes like `#[bar(baz)]` or `#![bar(baz)]` or `#[bar = \"baz\"]`\n-     (,(rust-re-grab (concat \"#\\\\!?\\\\[\" rust-re-ident \"[^]]*\\\\]\"))\n-      1 font-lock-preprocessor-face keep)\n-\n-     ;; Syntax extension invocations like `foo!`, highlight including the !\n-     (,(concat (rust-re-grab (concat rust-re-ident \"!\")) \"[({[:space:][]\")\n-      1 font-lock-preprocessor-face)\n-\n-     ;; Field names like `foo:`, highlight excluding the :\n-     (,(concat (rust-re-grab rust-re-ident) \":[^:]\") 1 font-lock-variable-name-face)\n-\n-     ;; Module names like `foo::`, highlight including the ::\n-     (,(rust-re-grab (concat rust-re-ident \"::\")) 1 font-lock-type-face)\n-\n-     ;; Lifetimes like `'foo`\n-     (,(concat \"'\" (rust-re-grab rust-re-ident) \"[^']\") 1 font-lock-variable-name-face)\n-\n-     ;; Character constants, since they're not treated as strings\n-     ;; in order to have sufficient leeway to parse 'lifetime above.\n-     (,(rust-re-grab \"'[^']'\") 1 font-lock-string-face)\n-     (,(rust-re-grab \"'\\\\\\\\[nrt]'\") 1 font-lock-string-face)\n-     (,(rust-re-grab \"'\\\\\\\\x[[:xdigit:]]\\\\{2\\\\}'\") 1 font-lock-string-face)\n-     (,(rust-re-grab \"'\\\\\\\\u[[:xdigit:]]\\\\{4\\\\}'\") 1 font-lock-string-face)\n-     (,(rust-re-grab \"'\\\\\\\\U[[:xdigit:]]\\\\{8\\\\}'\") 1 font-lock-string-face)\n-\n-     ;; CamelCase Means Type Or Constructor\n-     (,(rust-re-grabword rust-re-CamelCase) 1 font-lock-type-face)\n-     )\n-\n-   ;; Item definitions\n-   (mapcar #'(lambda (x)\n-               (list (rust-re-item-def (car x))\n-                     1 (cdr x)))\n-           '((\"enum\" . font-lock-type-face)\n-             (\"struct\" . font-lock-type-face)\n-             (\"type\" . font-lock-type-face)\n-             (\"mod\" . font-lock-type-face)\n-             (\"use\" . font-lock-type-face)\n-             (\"fn\" . font-lock-function-name-face)\n-             (\"static\" . font-lock-constant-face)))))\n-\n-(defun rust-fill-prefix-for-comment-start (line-start)\n-  \"Determine what to use for `fill-prefix' based on what is at the beginning of a line.\"\n-  (let ((result\n-         ;; Replace /* with same number of spaces\n-         (replace-regexp-in-string\n-          \"\\\\(?:/\\\\*+\\\\)[!*]\"\n-          (lambda (s)\n-            ;; We want the * to line up with the first * of the comment start\n-            (concat (make-string (- (length s) 2) ?\\x20) \"*\"))\n-          line-start)))\n-    ;; Make sure we've got at least one space at the end\n-    (if (not (= (aref result (- (length result) 1)) ?\\x20))\n-        (setq result (concat result \" \")))\n-    result))\n-\n-(defun rust-in-comment-paragraph (body)\n-  ;; We might move the point to fill the next comment, but we don't want it\n-  ;; seeming to jump around on the user\n-  (save-excursion\n-    ;; If we're outside of a comment, with only whitespace and then a comment\n-    ;; in front, jump to the comment and prepare to fill it.\n-    (when (not (nth 4 (syntax-ppss)))\n-      (beginning-of-line)\n-      (when (looking-at (concat \"[[:space:]\\n]*\" comment-start-skip))\n-        (goto-char (match-end 0))))\n-\n-    ;; We need this when we're moving the point around and then checking syntax\n-    ;; while doing paragraph fills, because the cache it uses isn't always\n-    ;; invalidated during this.\n-    (syntax-ppss-flush-cache 1)\n-    ;; If we're at the beginning of a comment paragraph with nothing but\n-    ;; whitespace til the next line, jump to the next line so that we use the\n-    ;; existing prefix to figure out what the new prefix should be, rather than\n-    ;; inferring it from the comment start.\n-    (let ((next-bol (line-beginning-position 2)))\n-      (while (save-excursion\n-               (end-of-line)\n-               (syntax-ppss-flush-cache 1)\n-               (and (nth 4 (syntax-ppss))\n-                    (save-excursion\n-                      (beginning-of-line)\n-                      (looking-at paragraph-start))\n-                    (looking-at \"[[:space:]]*$\")\n-                    (nth 4 (syntax-ppss next-bol))))\n-        (goto-char next-bol)))\n-\n-    (syntax-ppss-flush-cache 1)\n-    ;; If we're on the last line of a multiline-style comment that started\n-    ;; above, back up one line so we don't mistake the * of the */ that ends\n-    ;; the comment for a prefix.\n-    (when (save-excursion\n-            (and (nth 4 (syntax-ppss (line-beginning-position 1)))\n-                 (looking-at \"[[:space:]]*\\\\*/\")))\n-      (goto-char (line-end-position 0)))\n-    (funcall body)))\n-\n-(defun rust-with-comment-fill-prefix (body)\n-  (let*\n-      ((line-string (buffer-substring-no-properties\n-                     (line-beginning-position) (line-end-position)))\n-       (line-comment-start\n-        (when (nth 4 (syntax-ppss))\n-          (cond\n-           ;; If we're inside the comment and see a * prefix, use it\n-           ((string-match \"^\\\\([[:space:]]*\\\\*+[[:space:]]*\\\\)\"\n-                          line-string)\n-            (match-string 1 line-string))\n-           ;; If we're at the start of a comment, figure out what prefix\n-           ;; to use for the subsequent lines after it\n-           ((string-match (concat \"[[:space:]]*\" comment-start-skip) line-string)\n-            (rust-fill-prefix-for-comment-start\n-             (match-string 0 line-string))))))\n-       (fill-prefix\n-        (or line-comment-start\n-            fill-prefix)))\n-    (funcall body)))\n-\n-(defun rust-find-fill-prefix ()\n-  (rust-with-comment-fill-prefix (lambda () fill-prefix)))\n-\n-(defun rust-fill-paragraph (&rest args)\n-  \"Special wrapping for `fill-paragraph' to handle multi-line comments with a * prefix on each line.\"\n-  (rust-in-comment-paragraph\n-   (lambda ()\n-     (rust-with-comment-fill-prefix\n-      (lambda ()\n-        (let\n-            ((fill-paragraph-function\n-              (if (not (eq fill-paragraph-function 'rust-fill-paragraph))\n-                  fill-paragraph-function))\n-             (fill-paragraph-handle-comment t))\n-          (apply 'fill-paragraph args)\n-          t))))))\n-\n-(defun rust-do-auto-fill (&rest args)\n-  \"Special wrapping for `do-auto-fill' to handle multi-line comments with a * prefix on each line.\"\n-  (rust-with-comment-fill-prefix\n-   (lambda ()\n-     (apply 'do-auto-fill args)\n-     t)))\n-\n-(defun rust-fill-forward-paragraph (arg)\n-  ;; This is to work around some funny behavior when a paragraph separator is\n-  ;; at the very top of the file and there is a fill prefix.\n-  (let ((fill-prefix nil)) (forward-paragraph arg)))\n-\n-(defun rust-comment-indent-new-line (&optional arg)\n-  (rust-with-comment-fill-prefix\n-   (lambda () (comment-indent-new-line arg))))\n-\n-;;; Imenu support\n-(defvar rust-imenu-generic-expression\n-  (append (mapcar #'(lambda (x)\n-                      (list nil (rust-re-item-def x) 1))\n-                  '(\"enum\" \"struct\" \"type\" \"mod\" \"fn\" \"trait\"))\n-          `((\"Impl\" ,(rust-re-item-def \"impl\") 1)))\n-  \"Value for `imenu-generic-expression' in Rust mode.\n-\n-Create a flat index of the item definitions in a Rust file.\n-\n-Imenu will show all the enums, structs, etc. at the same level.\n-Implementations will be shown under the `Impl` subheading.  Use\n-idomenu (imenu with `ido-mode') for best mileage.\")\n-\n-;;; Defun Motions\n-\n-;;; Start of a Rust item\n-(defvar rust-top-item-beg-re\n-  (concat \"^\\\\s-*\\\\(?:priv\\\\|pub\\\\)?\\\\s-*\"\n-          (regexp-opt\n-           '(\"enum\" \"struct\" \"type\" \"mod\" \"use\" \"fn\" \"static\" \"impl\"\n-             \"extern\" \"impl\" \"static\" \"trait\"))))\n-\n-(defun rust-beginning-of-defun (&optional arg)\n-  \"Move backward to the beginning of the current defun.\n-\n-With ARG, move backward multiple defuns.  Negative ARG means\n-move forward.\n-\n-This is written mainly to be used as `beginning-of-defun-function' for Rust.\n-Don't move to the beginning of the line. `beginning-of-defun',\n-which calls this, does that afterwards.\"\n-  (interactive \"p\")\n-  (re-search-backward (concat \"^\\\\(\" rust-top-item-beg-re \"\\\\)\\\\_>\")\n-                      nil 'move (or arg 1)))\n-\n-(defun rust-end-of-defun ()\n-  \"Move forward to the next end of defun.\n-\n-With argument, do it that many times.\n-Negative argument -N means move back to Nth preceding end of defun.\n-\n-Assume that this is called after beginning-of-defun. So point is\n-at the beginning of the defun body.\n-\n-This is written mainly to be used as `end-of-defun-function' for Rust.\"\n-  (interactive \"p\")\n-  ;; Find the opening brace\n-  (re-search-forward \"[{]\" nil t)\n-  (goto-char (match-beginning 0))\n-  ;; Go to the closing brace\n-  (forward-sexp))\n-\n-;; For compatibility with Emacs < 24, derive conditionally\n-(defalias 'rust-parent-mode\n-  (if (fboundp 'prog-mode) 'prog-mode 'fundamental-mode))\n-\n-\n-;;;###autoload\n-(define-derived-mode rust-mode rust-parent-mode \"Rust\"\n-  \"Major mode for Rust code.\"\n-  :group 'rust-mode\n-  :syntax-table rust-mode-syntax-table\n-\n-  ;; Indentation\n-  (setq-local indent-line-function 'rust-mode-indent-line)\n-\n-  ;; Fonts\n-  (setq-local font-lock-defaults '(rust-mode-font-lock-keywords nil nil nil nil))\n-\n-  ;; Misc\n-  (setq-local comment-start \"// \")\n-  (setq-local comment-end   \"\")\n-  (setq-local indent-tabs-mode nil)\n-\n-  ;; Allow paragraph fills for comments\n-  (setq-local comment-start-skip \"\\\\(?://[/!]*\\\\|/\\\\*[*!]?\\\\)[[:space:]]*\")\n-  (setq-local paragraph-start\n-       (concat \"[[:space:]]*\\\\(?:\" comment-start-skip \"\\\\|\\\\*/?[[:space:]]*\\\\|\\\\)$\"))\n-  (setq-local paragraph-separate paragraph-start)\n-  (setq-local normal-auto-fill-function 'rust-do-auto-fill)\n-  (setq-local fill-paragraph-function 'rust-fill-paragraph)\n-  (setq-local fill-forward-paragraph-function 'rust-fill-forward-paragraph)\n-  (setq-local adaptive-fill-function 'rust-find-fill-prefix)\n-  (setq-local comment-multi-line t)\n-  (setq-local comment-line-break-function 'rust-comment-indent-new-line)\n-  (setq-local imenu-generic-expression rust-imenu-generic-expression)\n-  (setq-local beginning-of-defun-function 'rust-beginning-of-defun)\n-  (setq-local end-of-defun-function 'rust-end-of-defun))\n-\n-;;;###autoload\n-(add-to-list 'auto-mode-alist '(\"\\\\.rs\\\\'\" . rust-mode))\n-\n-(defun rust-mode-reload ()\n-  (interactive)\n-  (unload-feature 'rust-mode)\n-  (require 'rust-mode)\n-  (rust-mode))\n-\n-;; Issue #6887: Rather than inheriting the 'gnu compilation error\n-;; regexp (which is broken on a few edge cases), add our own 'rust\n-;; compilation error regexp and use it instead.\n-(defvar rustc-compilation-regexps\n-  (let ((file \"\\\\([^\\n]+\\\\)\")\n-        (start-line \"\\\\([0-9]+\\\\)\")\n-        (start-col  \"\\\\([0-9]+\\\\)\")\n-        (end-line   \"\\\\([0-9]+\\\\)\")\n-        (end-col    \"\\\\([0-9]+\\\\)\")\n-        (error-or-warning \"\\\\(?:[Ee]rror\\\\|\\\\([Ww]arning\\\\)\\\\)\"))\n-    (let ((re (concat \"^\" file \":\" start-line \":\" start-col\n-                      \": \" end-line \":\" end-col\n-                      \" \\\\(?:[Ee]rror\\\\|\\\\([Ww]arning\\\\)\\\\):\")))\n-      (cons re '(1 (2 . 4) (3 . 5) (6)))))\n-  \"Specifications for matching errors in rustc invocations.\n-See `compilation-error-regexp-alist for help on their format.\")\n-\n-(eval-after-load 'compile\n-  '(progn\n-     (add-to-list 'compilation-error-regexp-alist-alist\n-                  (cons 'rustc rustc-compilation-regexps))\n-     (add-to-list 'compilation-error-regexp-alist 'rustc)))\n-\n-(provide 'rust-mode)\n-\n-;;; rust-mode.el ends here"}, {"sha": "e394f1916088f081c36505288f8b30f500b08307", "filename": "src/etc/gedit/readme.txt", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1d00c545ede609b9d43fdf9f252c15da5a66dac7/src%2Fetc%2Fgedit%2Freadme.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1d00c545ede609b9d43fdf9f252c15da5a66dac7/src%2Fetc%2Fgedit%2Freadme.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgedit%2Freadme.txt?ref=1d00c545ede609b9d43fdf9f252c15da5a66dac7", "patch": "@@ -1,10 +0,0 @@\n-Add syntax highlighting for Mozilla Rust in GtkSourceView (used by GEdit).\n-\n-\n-Instructions for Ubuntu Linux 12.04+\n-\n-1) Close all instances of GEdit\n-\n-2) Copy the included \"share\" folder into \"~/.local/\"\n-\n-3) Open a shell in \"~/.local/share/\" and run \"update-mime-database mime\""}, {"sha": "8291b38a9bd0b94b8c970ba648d0d3db7ef1b819", "filename": "src/etc/gedit/share/gtksourceview-3.0/language-specs/rust.lang", "status": "removed", "additions": 0, "deletions": 340, "changes": 340, "blob_url": "https://github.com/rust-lang/rust/blob/1d00c545ede609b9d43fdf9f252c15da5a66dac7/src%2Fetc%2Fgedit%2Fshare%2Fgtksourceview-3.0%2Flanguage-specs%2Frust.lang", "raw_url": "https://github.com/rust-lang/rust/raw/1d00c545ede609b9d43fdf9f252c15da5a66dac7/src%2Fetc%2Fgedit%2Fshare%2Fgtksourceview-3.0%2Flanguage-specs%2Frust.lang", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgedit%2Fshare%2Fgtksourceview-3.0%2Flanguage-specs%2Frust.lang?ref=1d00c545ede609b9d43fdf9f252c15da5a66dac7", "patch": "@@ -1,340 +0,0 @@\n-<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n-\n-<!-- Syntax highlighting for the under-development Mozilla Rust language -->\n-\n-<language id=\"rust\" _name=\"Rust\" version=\"2.0\" _section=\"Sources\">\n-  <metadata>\n-    <property name=\"mimetypes\">text/x-rust</property>\n-    <property name=\"globs\">*.rs</property>\n-    <property name=\"line-comment-start\">//</property>\n-    <property name=\"block-comment-start\">/*</property>\n-    <property name=\"block-comment-end\">*/</property>\n-  </metadata>\n-\n-  <styles>\n-    <style id=\"comment\" _name=\"Comment\" map-to=\"def:comment\"/>\n-    <style id=\"string\" _name=\"String\" map-to=\"def:string\"/>\n-    <style id=\"char\" _name=\"Character\" map-to=\"def:character\"/>\n-    <style id=\"keyword\" _name=\"Keyword\" map-to=\"def:keyword\"/>\n-    <style id=\"type\" _name=\"Data Type\" map-to=\"def:type\"/>\n-    <style id=\"constant\" _name=\"Constant\" map-to=\"def:constant\"/>\n-    <style id=\"identifier\" _name=\"Identifier\" map-to=\"def:identifier\"/>\n-    <style id=\"number\" _name=\"Number\" map-to=\"def:number\"/>\n-    <style id=\"scope\" _name=\"Scope\" map-to=\"def:preprocessor\"/>\n-    <style id=\"attribute\" _name=\"Attribute\" map-to=\"def:preprocessor\"/>\n-    <style id=\"macro\" _name=\"Macro\" map-to=\"def:preprocessor\"/>\n-  </styles>\n-\n-  <definitions>\n-\n-    <context id=\"function\" style-ref=\"keyword\">\n-\t\t<keyword>fn</keyword>\n-    </context>\n-\n-    <context id=\"type\" style-ref=\"keyword\">\n-\t\t<keyword>type</keyword>\n-    </context>\n-\n-    <context id=\"keywords\" style-ref=\"keyword\">\n-\t\t<keyword>as</keyword>\n-\t\t<keyword>assert</keyword>\n-\t\t<keyword>break</keyword>\n-\t\t<keyword>box</keyword>\n-\t\t<keyword>const</keyword>\n-\t\t<keyword>continue</keyword>\n-\t\t<keyword>crate</keyword>\n-\t\t<keyword>do</keyword>\n-\t\t<keyword>drop</keyword>\n-\t\t<keyword>else</keyword>\n-\t\t<keyword>enum</keyword>\n-\t\t<keyword>export</keyword>\n-\t\t<keyword>extern</keyword>\n-\t\t<keyword>fail</keyword>\n-\t\t<keyword>for</keyword>\n-\t\t<keyword>if</keyword>\n-\t\t<keyword>impl</keyword>\n-\t\t<keyword>in</keyword>\n-\t\t<keyword>let</keyword>\n-\t\t<keyword>log</keyword>\n-\t\t<keyword>loop</keyword>\n-\t\t<keyword>match</keyword>\n-\t\t<keyword>mod</keyword>\n-\t\t<keyword>move</keyword>\n-\t\t<keyword>mut</keyword>\n-\t\t<keyword>priv</keyword>\n-\t\t<keyword>pub</keyword>\n-\t\t<keyword>pure</keyword>\n-\t\t<keyword>ref</keyword>\n-\t\t<keyword>return</keyword>\n-\t\t<keyword>static</keyword>\n-\t\t<keyword>struct</keyword>\n-\t\t<keyword>trait</keyword>\n-\t\t<keyword>unsafe</keyword>\n-\t\t<keyword>use</keyword>\n-\t\t<keyword>virtual</keyword>\n-\t\t<keyword>where</keyword>\n-\t\t<keyword>while</keyword>\n-    </context>\n-\n-    <context id=\"types\" style-ref=\"type\">\n-\t\t<keyword>bool</keyword>\n-\t\t<keyword>int</keyword>\n-\t\t<keyword>isize</keyword>\n-\t\t<keyword>uint</keyword>\n-\t\t<keyword>usize</keyword>\n-\t\t<keyword>i8</keyword>\n-\t\t<keyword>i16</keyword>\n-\t\t<keyword>i32</keyword>\n-\t\t<keyword>i64</keyword>\n-\t\t<keyword>u8</keyword>\n-\t\t<keyword>u16</keyword>\n-\t\t<keyword>u32</keyword>\n-\t\t<keyword>u64</keyword>\n-\t\t<keyword>f32</keyword>\n-\t\t<keyword>f64</keyword>\n-\t\t<keyword>char</keyword>\n-\t\t<keyword>str</keyword>\n-\t\t<keyword>Option</keyword>\n-\t\t<keyword>Result</keyword>\n-    </context>\n-\n-    <context id=\"ctypes\" style-ref=\"type\">\n-\t\t<keyword>c_float</keyword>\n-\t\t<keyword>c_double</keyword>\n-\t\t<keyword>c_void</keyword>\n-\t\t<keyword>FILE</keyword>\n-\t\t<keyword>fpos_t</keyword>\n-\t\t<keyword>DIR</keyword>\n-\t\t<keyword>dirent</keyword>\n-\t\t<keyword>c_char</keyword>\n-\t\t<keyword>c_schar</keyword>\n-\t\t<keyword>c_uchar</keyword>\n-\t\t<keyword>c_short</keyword>\n-\t\t<keyword>c_ushort</keyword>\n-\t\t<keyword>c_int</keyword>\n-\t\t<keyword>c_uint</keyword>\n-\t\t<keyword>c_long</keyword>\n-\t\t<keyword>c_ulong</keyword>\n-\t\t<keyword>size_t</keyword>\n-\t\t<keyword>ptrdiff_t</keyword>\n-\t\t<keyword>clock_t</keyword>\n-\t\t<keyword>time_t</keyword>\n-\t\t<keyword>c_longlong</keyword>\n-\t\t<keyword>c_ulonglong</keyword>\n-\t\t<keyword>intptr_t</keyword>\n-\t\t<keyword>uintptr_t</keyword>\n-\t\t<keyword>off_t</keyword>\n-\t\t<keyword>dev_t</keyword>\n-\t\t<keyword>ino_t</keyword>\n-\t\t<keyword>pid_t</keyword>\n-\t\t<keyword>mode_t</keyword>\n-\t\t<keyword>ssize_t</keyword>\n-    </context>\n-\n-    <context id=\"self\" style-ref=\"identifier\">\n-\t\t<keyword>self</keyword>\n-    </context>\n-\n-    <context id=\"constants\" style-ref=\"constant\">\n-\t\t<keyword>true</keyword>\n-\t\t<keyword>false</keyword>\n-\t\t<keyword>Some</keyword>\n-\t\t<keyword>None</keyword>\n-\t\t<keyword>Ok</keyword>\n-\t\t<keyword>Err</keyword>\n-\t\t<keyword>Success</keyword>\n-\t\t<keyword>Failure</keyword>\n-\t\t<keyword>Cons</keyword>\n-\t\t<keyword>Nil</keyword>\n-    </context>\n-\n-    <context id=\"cconstants\" style-ref=\"constant\">\n-\t\t<keyword>EXIT_FAILURE</keyword>\n-\t\t<keyword>EXIT_SUCCESS</keyword>\n-\t\t<keyword>RAND_MAX</keyword>\n-\t\t<keyword>EOF</keyword>\n-\t\t<keyword>SEEK_SET</keyword>\n-\t\t<keyword>SEEK_CUR</keyword>\n-\t\t<keyword>SEEK_END</keyword>\n-\t\t<keyword>_IOFBF</keyword>\n-\t\t<keyword>_IONBF</keyword>\n-\t\t<keyword>_IOLBF</keyword>\n-\t\t<keyword>BUFSIZ</keyword>\n-\t\t<keyword>FOPEN_MAX</keyword>\n-\t\t<keyword>FILENAME_MAX</keyword>\n-\t\t<keyword>L_tmpnam</keyword>\n-\t\t<keyword>TMP_MAX</keyword>\n-\t\t<keyword>O_RDONLY</keyword>\n-\t\t<keyword>O_WRONLY</keyword>\n-\t\t<keyword>O_RDWR</keyword>\n-\t\t<keyword>O_APPEND</keyword>\n-\t\t<keyword>O_CREAT</keyword>\n-\t\t<keyword>O_EXCL</keyword>\n-\t\t<keyword>O_TRUNC</keyword>\n-\t\t<keyword>S_IFIFO</keyword>\n-\t\t<keyword>S_IFCHR</keyword>\n-\t\t<keyword>S_IFBLK</keyword>\n-\t\t<keyword>S_IFDIR</keyword>\n-\t\t<keyword>S_IFREG</keyword>\n-\t\t<keyword>S_IFMT</keyword>\n-\t\t<keyword>S_IEXEC</keyword>\n-\t\t<keyword>S_IWRITE</keyword>\n-\t\t<keyword>S_IREAD</keyword>\n-\t\t<keyword>S_IRWXU</keyword>\n-\t\t<keyword>S_IXUSR</keyword>\n-\t\t<keyword>S_IWUSR</keyword>\n-\t\t<keyword>S_IRUSR</keyword>\n-\t\t<keyword>F_OK</keyword>\n-\t\t<keyword>R_OK</keyword>\n-\t\t<keyword>W_OK</keyword>\n-\t\t<keyword>X_OK</keyword>\n-\t\t<keyword>STDIN_FILENO</keyword>\n-\t\t<keyword>STDOUT_FILENO</keyword>\n-\t\t<keyword>STDERR_FILENO</keyword>\n-    </context>\n-\n-    <context id=\"line-comment\" style-ref=\"comment\" end-at-line-end=\"true\" class=\"comment\" class-disabled=\"no-spell-check\">\n-      <start>//</start>\n-      <include>\n-        <context ref=\"def:in-line-comment\"/>\n-      </include>\n-    </context>\n-\n-    <context id=\"block-comment\" style-ref=\"comment\" class=\"comment\" class-disabled=\"no-spell-check\">\n-      <start>/\\*</start>\n-      <end>\\*/</end>\n-      <include>\n-        <context ref=\"def:in-comment\"/>\n-      </include>\n-    </context>\n-\n-    <define-regex id=\"int_suffix\" extended=\"true\">\n-      (i8|i16|i32|i64|i|u8|u16|u32|u64|u)\n-    </define-regex>\n-\n-    <define-regex id=\"exponent\" extended=\"true\">\n-      ([eE][+-]?[0-9_]+)\n-    </define-regex>\n-\n-    <define-regex id=\"float_suffix\" extended=\"true\">\n-      (\\%{exponent}?(f32|f64)?)|(\\.[0-9][0-9_]*\\%{exponent}?)?(f32|f64)?|\\.\n-    </define-regex>\n-\n-    <define-regex id=\"num_suffix\" extended=\"true\">\n-      \\%{int_suffix}|\\%{float_suffix}\n-    </define-regex>\n-\n-    <define-regex id=\"hex_digit\" extended=\"true\">\n-      [0-9a-fA-F]\n-    </define-regex>\n-\n-    <define-regex id=\"oct_digit\" extended=\"true\">\n-      [0-7]\n-    </define-regex>\n-\n-    <context id=\"number\" style-ref=\"number\">\n-      <match extended=\"true\">\n-        ((?&lt;=\\.\\.)|(?&lt;![\\w\\.]))\n-        (\n-        [1-9][0-9_]*\\%{num_suffix}?|\n-        0[0-9_]*\\%{num_suffix}?|\n-        0b[01_]+\\%{int_suffix}?|\n-        0o(\\%{oct_digit}|_)+\\%{int_suffix}?|\n-        0x(\\%{hex_digit}|_)+\\%{int_suffix}?\n-        )\n-        ((?![\\w\\.].)|(?=\\.\\.))\n-      </match>\n-    </context>\n-\n-    <define-regex id=\"ident\" extended=\"true\">\n-      ([^[:cntrl:][:space:][:punct:][:digit:]]|_)([^[:cntrl:][:punct:][:space:]]|_)*\n-    </define-regex>\n-\n-    <context id=\"scope\" style-ref=\"scope\">\n-      <match extended=\"true\">\n-        \\%{ident}::\n-      </match>\n-    </context>\n-\n-    <context id=\"macro\" style-ref=\"macro\">\n-      <match extended=\"true\">\n-        \\%{ident}!\n-      </match>\n-    </context>\n-\n-    <context id=\"lifetime\" style-ref=\"keyword\">\n-      <match extended=\"true\">\n-        '\\%{ident}\n-      </match>\n-    </context>\n-\n-    <define-regex id=\"common_escape\" extended=\"true\">\n-      '|\"|\n-      \\\\|n|r|t|0|\n-      x\\%{hex_digit}{2}|\n-      u{\\%{hex_digit}{1,6}}|\n-      u\\%{hex_digit}{4}|\n-      U\\%{hex_digit}{8}\n-    </define-regex>\n-\n-    <context id=\"string_escape\" style-ref=\"def:special-char\">\n-      <match>\\\\\\%{common_escape}</match>\n-    </context>\n-\n-    <context id=\"raw-string\" style-ref=\"string\" class=\"string\" class-disabled=\"no-spell-check\">\n-      <start>r(#*)\"</start>\n-      <end>\"\\%{1@start}</end>\n-      <include>\n-        <context ref=\"def:line-continue\"/>\n-      </include>\n-    </context>\n-\n-    <context id=\"string\" style-ref=\"string\" class=\"string\" class-disabled=\"no-spell-check\">\n-      <start>\"</start>\n-      <end>\"</end>\n-      <include>\n-        <context ref=\"string_escape\"/>\n-        <context ref=\"def:line-continue\"/>\n-      </include>\n-    </context>\n-\n-    <context id=\"char\" style-ref=\"char\">\n-      <match extended=\"true\">'([^\\\\']|\\\\\\%{common_escape})'</match>\n-    </context>\n-\n-    <context id=\"attribute\" style-ref=\"attribute\" class=\"attribute\">\n-      <start extended=\"true\">\\#!?\\[</start>\n-      <end>\\]</end>\n-      <include>\n-        <context ref=\"def:in-comment\"/>\n-        <context ref=\"string\"/>\n-        <context ref=\"raw-string\"/>\n-      </include>\n-    </context>\n-\n-    <context id=\"rust\" class=\"no-spell-check\">\n-      <include>\n-        <context ref=\"function\"/>\n-        <context ref=\"type\"/>\n-        <context ref=\"keywords\"/>\n-        <context ref=\"types\"/>\n-        <context ref=\"ctypes\"/>\n-        <context ref=\"self\"/>\n-        <context ref=\"macro\"/>\n-        <context ref=\"constants\"/>\n-        <context ref=\"cconstants\"/>\n-        <context ref=\"line-comment\"/>\n-        <context ref=\"block-comment\"/>\n-        <context ref=\"number\"/>\n-        <context ref=\"scope\"/>\n-        <context ref=\"string\"/>\n-        <context ref=\"raw-string\"/>\n-        <context ref=\"char\"/>\n-        <context ref=\"lifetime\"/>\n-        <context ref=\"attribute\"/>\n-      </include>\n-    </context>\n-\n-  </definitions>\n-\n-</language>"}, {"sha": "ede1c14907c8ba2905d49f0b0ebfbf010f878a3d", "filename": "src/etc/gedit/share/mime/packages/rust.xml", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1d00c545ede609b9d43fdf9f252c15da5a66dac7/src%2Fetc%2Fgedit%2Fshare%2Fmime%2Fpackages%2Frust.xml", "raw_url": "https://github.com/rust-lang/rust/raw/1d00c545ede609b9d43fdf9f252c15da5a66dac7/src%2Fetc%2Fgedit%2Fshare%2Fmime%2Fpackages%2Frust.xml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgedit%2Fshare%2Fmime%2Fpackages%2Frust.xml?ref=1d00c545ede609b9d43fdf9f252c15da5a66dac7", "patch": "@@ -1,6 +0,0 @@\n-<mime-info xmlns='http://www.freedesktop.org/standards/shared-mime-info'>\n-  <mime-type type=\"text/x-rust\">\n-    <comment>Rust Source</comment>\n-    <glob pattern=\"*.rs\"/>\n-  </mime-type>\n-</mime-info>"}, {"sha": "3ceec0f250a33a3d06b9573baba2fa73aa76c706", "filename": "src/etc/kate/rust.xml", "status": "removed", "additions": 0, "deletions": 304, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/1d00c545ede609b9d43fdf9f252c15da5a66dac7/src%2Fetc%2Fkate%2Frust.xml", "raw_url": "https://github.com/rust-lang/rust/raw/1d00c545ede609b9d43fdf9f252c15da5a66dac7/src%2Fetc%2Fkate%2Frust.xml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fkate%2Frust.xml?ref=1d00c545ede609b9d43fdf9f252c15da5a66dac7", "patch": "@@ -1,304 +0,0 @@\n-<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n-<!DOCTYPE language SYSTEM \"language.dtd\"\n-[\n-\t<!-- FIXME: Kate's regex engine has very limited support for\n-\tpredefined char classes, so making rustIdent consistent with actual\n-\tRust identifiers will be a bit difficult -->\n-\t<!ENTITY rustIdent \"[a-zA-Z_][a-zA-Z_0-9]*\">\n-\t<!ENTITY rustIntSuf \"([iu](8|16|32|64)?)?\">\n-]>\n-<language name=\"Rust\" version=\"1.0.0\" kateversion=\"2.4\" section=\"Sources\" extensions=\"*.rs\" mimetype=\"text/x-rust\" priority=\"15\">\n-<highlighting>\n-\t<list name=\"fn\">\n-\t\t<item> fn </item>\n-\t</list>\n-\t<list name=\"type\">\n-\t\t<item> type </item>\n-\t</list>\n-\t<list name=\"reserved\">\n-\t\t<item> abstract </item>\n-\t\t<item> alignof </item>\n-\t\t<item> be </item>\n-\t\t<item> do </item>\n-\t\t<item> final </item>\n-\t\t<item> offsetof </item>\n-\t\t<item> override </item>\n-\t\t<item> priv </item>\n-\t\t<item> pure </item>\n-\t\t<item> sizeof </item>\n-\t\t<item> typeof </item>\n-\t\t<item> unsized </item>\n-\t\t<item> yield </item>\n-\t</list>\n-\t<list name=\"keywords\">\n-\t\t<item> as </item>\n-\t\t<item> box </item>\n-\t\t<item> break </item>\n-\t\t<item> const </item>\n-\t\t<item> continue </item>\n-\t\t<item> crate </item>\n-\t\t<item> else </item>\n-\t\t<item> enum </item>\n-\t\t<item> extern </item>\n-\t\t<item> for </item>\n-\t\t<item> if </item>\n-\t\t<item> impl </item>\n-\t\t<item> in </item>\n-\t\t<item> let </item>\n-\t\t<item> loop </item>\n-\t\t<item> match </item>\n-\t\t<item> mod </item>\n-\t\t<item> move </item>\n-\t\t<item> mut </item>\n-\t\t<item> pub </item>\n-\t\t<item> ref </item>\n-\t\t<item> return </item>\n-\t\t<item> static </item>\n-\t\t<item> struct </item>\n-\t\t<item> super </item>\n-\t\t<item> trait </item>\n-\t\t<item> unsafe </item>\n-\t\t<item> use </item>\n-\t\t<item> virtual </item>\n-\t\t<item> where </item>\n-\t\t<item> while </item>\n-\t</list>\n-\t<list name=\"traits\">\n-\t\t<item> Const </item>\n-\t\t<item> Copy </item>\n-\t\t<item> Send </item>\n-\t\t<item> Owned </item>\n-\t\t<item> Sized </item>\n-\t\t<item> Eq </item>\n-\t\t<item> Ord </item>\n-\t\t<item> Num </item>\n-\t\t<item> Ptr </item>\n-\t\t<item> Drop </item>\n-\t\t<item> Add </item>\n-\t\t<item> Sub </item>\n-\t\t<item> Mul </item>\n-\t\t<item> Quot </item>\n-\t\t<item> Rem </item>\n-\t\t<item> Neg </item>\n-\t\t<item> BitAnd </item>\n-\t\t<item> BitOr </item>\n-\t\t<item> BitXor </item>\n-\t\t<item> Shl </item>\n-\t\t<item> Shr </item>\n-\t\t<item> Index </item>\n-\t\t<item> Not </item>\n-\t</list>\n-\t<list name=\"types\">\n-\t\t<item> bool </item>\n-\t\t<item> int </item>\n-\t\t<item> isize </item>\n-\t\t<item> uint </item>\n-\t\t<item> usize </item>\n-\t\t<item> i8 </item>\n-\t\t<item> i16 </item>\n-\t\t<item> i32 </item>\n-\t\t<item> i64 </item>\n-\t\t<item> u8 </item>\n-\t\t<item> u16 </item>\n-\t\t<item> u32 </item>\n-\t\t<item> u64 </item>\n-\t\t<item> f32 </item>\n-\t\t<item> f64 </item>\n-\t\t<item> float </item>\n-\t\t<item> char </item>\n-\t\t<item> str </item>\n-\t\t<item> Option </item>\n-\t\t<item> Result </item>\n-\t\t<item> Self </item>\n-\t</list>\n-\t<list name=\"ctypes\">\n-\t\t<item> c_float </item>\n-\t\t<item> c_double </item>\n-\t\t<item> c_void </item>\n-\t\t<item> FILE </item>\n-\t\t<item> fpos_t </item>\n-\t\t<item> DIR </item>\n-\t\t<item> dirent </item>\n-\t\t<item> c_char </item>\n-\t\t<item> c_schar </item>\n-\t\t<item> c_uchar </item>\n-\t\t<item> c_short </item>\n-\t\t<item> c_ushort </item>\n-\t\t<item> c_int </item>\n-\t\t<item> c_uint </item>\n-\t\t<item> c_long </item>\n-\t\t<item> c_ulong </item>\n-\t\t<item> size_t </item>\n-\t\t<item> ptrdiff_t </item>\n-\t\t<item> clock_t </item>\n-\t\t<item> time_t </item>\n-\t\t<item> c_longlong </item>\n-\t\t<item> c_ulonglong </item>\n-\t\t<item> intptr_t </item>\n-\t\t<item> uintptr_t </item>\n-\t\t<item> off_t </item>\n-\t\t<item> dev_t </item>\n-\t\t<item> ino_t </item>\n-\t\t<item> pid_t </item>\n-\t\t<item> mode_t </item>\n-\t\t<item> ssize_t </item>\n-\t</list>\n-\t<list name=\"self\">\n-\t\t<item> self </item>\n-\t</list>\n-\t<list name=\"constants\">\n-\t\t<item> true </item>\n-\t\t<item> false </item>\n-\t\t<item> Some </item>\n-\t\t<item> None </item>\n-\t\t<item> Ok </item>\n-\t\t<item> Err </item>\n-\t\t<item> Success </item>\n-\t\t<item> Failure </item>\n-\t\t<item> Cons </item>\n-\t\t<item> Nil </item>\n-\t</list>\n-\t<list name=\"cconstants\">\n-\t\t<item> EXIT_FAILURE </item>\n-\t\t<item> EXIT_SUCCESS </item>\n-\t\t<item> RAND_MAX </item>\n-\t\t<item> EOF </item>\n-\t\t<item> SEEK_SET </item>\n-\t\t<item> SEEK_CUR </item>\n-\t\t<item> SEEK_END </item>\n-\t\t<item> _IOFBF </item>\n-\t\t<item> _IONBF </item>\n-\t\t<item> _IOLBF </item>\n-\t\t<item> BUFSIZ </item>\n-\t\t<item> FOPEN_MAX </item>\n-\t\t<item> FILENAME_MAX </item>\n-\t\t<item> L_tmpnam </item>\n-\t\t<item> TMP_MAX </item>\n-\t\t<item> O_RDONLY </item>\n-\t\t<item> O_WRONLY </item>\n-\t\t<item> O_RDWR </item>\n-\t\t<item> O_APPEND </item>\n-\t\t<item> O_CREAT </item>\n-\t\t<item> O_EXCL </item>\n-\t\t<item> O_TRUNC </item>\n-\t\t<item> S_IFIFO </item>\n-\t\t<item> S_IFCHR </item>\n-\t\t<item> S_IFBLK </item>\n-\t\t<item> S_IFDIR </item>\n-\t\t<item> S_IFREG </item>\n-\t\t<item> S_IFMT </item>\n-\t\t<item> S_IEXEC </item>\n-\t\t<item> S_IWRITE </item>\n-\t\t<item> S_IREAD </item>\n-\t\t<item> S_IRWXU </item>\n-\t\t<item> S_IXUSR </item>\n-\t\t<item> S_IWUSR </item>\n-\t\t<item> S_IRUSR </item>\n-\t\t<item> F_OK </item>\n-\t\t<item> R_OK </item>\n-\t\t<item> W_OK </item>\n-\t\t<item> X_OK </item>\n-\t\t<item> STDIN_FILENO </item>\n-\t\t<item> STDOUT_FILENO </item>\n-\t\t<item> STDERR_FILENO </item>\n-\t</list>\n-\t<contexts>\n-\t\t<context attribute=\"Normal Text\" lineEndContext=\"#stay\" name=\"Normal\">\n-\t\t\t<DetectSpaces/>\n-\t\t\t<keyword String=\"fn\" attribute=\"Keyword\" context=\"Function\"/>\n-\t\t\t<keyword String=\"type\" attribute=\"Keyword\" context=\"Type\"/>\n-\t\t\t<keyword String=\"reserved\" attribute=\"Keyword\" context=\"#stay\"/>\n-\t\t\t<keyword String=\"keywords\" attribute=\"Keyword\" context=\"#stay\"/>\n-\t\t\t<keyword String=\"types\" attribute=\"Type\" context=\"#stay\"/>\n-\t\t\t<keyword String=\"traits\" attribute=\"Trait\" context=\"#stay\"/>\n-\t\t\t<keyword String=\"ctypes\" attribute=\"CType\" context=\"#stay\"/>\n-\t\t\t<keyword String=\"self\" attribute=\"Self\" context=\"#stay\"/>\n-\t\t\t<keyword String=\"constants\" attribute=\"Constant\" context=\"#stay\"/>\n-\t\t\t<keyword String=\"cconstants\" attribute=\"CConstant\" context=\"#stay\"/>\n-\t\t\t<Detect2Chars char=\"/\" char1=\"/\" attribute=\"Comment\" context=\"Commentar 1\"/>\n-\t\t\t<Detect2Chars char=\"/\" char1=\"*\" attribute=\"Comment\" context=\"Commentar 2\" beginRegion=\"Comment\"/>\n-\t\t\t<RegExpr String=\"0x[0-9a-fA-F_]+&rustIntSuf;\" attribute=\"Number\" context=\"#stay\"/>\n-\t\t\t<RegExpr String=\"0o[0-7_]+&rustIntSuf;\" attribute=\"Number\" context=\"#stay\"/>\n-\t\t\t<RegExpr String=\"0b[0-1_]+&rustIntSuf;\" attribute=\"Number\" context=\"#stay\"/>\n-\t\t\t<RegExpr String=\"[0-9][0-9_]*\\.[0-9_]*([eE][+-]?[0-9_]+)?(f32|f64|f)?\" attribute=\"Number\" context=\"#stay\"/>\n-\t\t\t<RegExpr String=\"[0-9][0-9_]*&rustIntSuf;\" attribute=\"Number\" context=\"#stay\"/>\n-\t\t\t<Detect2Chars char=\"#\" char1=\"[\" attribute=\"Attribute\" context=\"Attribute\" beginRegion=\"Attribute\"/>\n-\t\t\t<StringDetect String=\"#![\" attribute=\"Attribute\" context=\"Attribute\" beginRegion=\"Attribute\"/>\n-\t\t\t<RegExpr String=\"&rustIdent;::\" attribute=\"Scope\"/>\n-\t\t\t<RegExpr String=\"&rustIdent;!\" attribute=\"Macro\"/>\n-\t\t\t<RegExpr String=\"&apos;&rustIdent;(?!&apos;)\" attribute=\"Lifetime\"/>\n-\t\t\t<DetectChar char=\"{\" attribute=\"Symbol\" context=\"#stay\" beginRegion=\"Brace\" />\n-\t\t\t<DetectChar char=\"}\" attribute=\"Symbol\" context=\"#stay\" endRegion=\"Brace\" />\n-\t\t\t<DetectChar char=\"&quot;\" attribute=\"String\" context=\"String\"/>\n-\t\t\t<DetectChar char=\"&apos;\" attribute=\"Character\" context=\"Character\"/>\n-\t\t\t<DetectChar char=\"[\" attribute=\"Symbol\" context=\"#stay\" beginRegion=\"Bracket\" />\n-\t\t\t<DetectChar char=\"]\" attribute=\"Symbol\" context=\"#stay\" endRegion=\"Bracket\" />\n-\t\t\t<DetectIdentifier/>\n-\t\t</context>\n-\t\t<context attribute=\"Attribute\" lineEndContext=\"#stay\" name=\"Attribute\">\n-\t\t\t<DetectChar char=\"]\" attribute=\"Attribute\" context=\"#pop\" endRegion=\"Attribute\"/>\n-\t\t\t<IncludeRules context=\"Normal\"/>\n-\t\t</context>\n-\t\t<context attribute=\"Definition\" lineEndContext=\"#stay\" name=\"Function\">\n-\t\t\t<DetectSpaces/>\n-\t\t\t<DetectChar char=\"(\" attribute=\"Normal Text\" context=\"#pop\"/>\n-\t\t\t<DetectChar char=\"&lt;\" attribute=\"Normal Text\" context=\"#pop\"/>\n-\t\t</context>\n-\t\t<context attribute=\"Definition\" lineEndContext=\"#stay\" name=\"Type\">\n-\t\t\t<DetectSpaces/>\n-\t\t\t<DetectChar char=\"=\" attribute=\"Normal Text\" context=\"#pop\"/>\n-\t\t\t<DetectChar char=\"&lt;\" attribute=\"Normal Text\" context=\"#pop\"/>\n-\t\t</context>\n-\t\t<context attribute=\"String\" lineEndContext=\"#pop\" name=\"String\">\n-\t\t\t<LineContinue attribute=\"String\" context=\"#stay\"/>\n-\t\t\t<DetectChar char=\"\\\" attribute=\"CharEscape\" context=\"CharEscape\"/>\n-\t\t\t<DetectChar attribute=\"String\" context=\"#pop\" char=\"&quot;\"/>\n-\t\t</context>\n-\t\t<context attribute=\"Character\" lineEndContext=\"#pop\" name=\"Character\">\n-\t\t\t<DetectChar char=\"\\\" attribute=\"CharEscape\" context=\"CharEscape\"/>\n-\t\t\t<DetectChar attribute=\"Character\" context=\"#pop\" char=\"&apos;\"/>\n-\t\t</context>\n-\t\t<context attribute=\"CharEscape\" lineEndContext=\"#pop\" name=\"CharEscape\">\n-\t\t\t<AnyChar String=\"nrt\\&apos;&quot;\" attribute=\"CharEscape\" context=\"#pop\"/>\n-\t\t\t<RegExpr String=\"x[0-9a-fA-F]{2}\" attribute=\"CharEscape\" context=\"#pop\"/>\n-\t\t\t<RegExpr String=\"u\\{[0-9a-fA-F]{1,6}\\}\" attribute=\"CharEscape\" context=\"#pop\"/>\n-\t\t\t<RegExpr String=\"u[0-9a-fA-F]{4}\" attribute=\"CharEscape\" context=\"#pop\"/>\n-\t\t\t<RegExpr String=\"U[0-9a-fA-F]{8}\" attribute=\"CharEscape\" context=\"#pop\"/>\n-\t\t\t<RegExpr String=\".\" attribute=\"Error\" context=\"#pop\"/>\n-\t\t</context>\n-\t\t<context attribute=\"Comment\" lineEndContext=\"#pop\" name=\"Commentar 1\"/>\n-\t\t<context attribute=\"Comment\" lineEndContext=\"#stay\" name=\"Commentar 2\">\n-\t\t\t<DetectSpaces/>\n-\t\t\t<Detect2Chars char=\"*\" char1=\"/\" attribute=\"Comment\" context=\"#pop\" endRegion=\"Comment\"/>\n-\t\t</context>\n-\t</contexts>\n-\t<itemDatas>\n-\t\t<itemData name=\"Normal Text\"  defStyleNum=\"dsNormal\"/>\n-\t\t<itemData name=\"Keyword\"      defStyleNum=\"dsKeyword\" color=\"#770088\" bold=\"1\"/>\n-\t\t<itemData name=\"Self\"         defStyleNum=\"dsKeyword\" color=\"#FF0000\" bold=\"1\"/>\n-\t\t<itemData name=\"Type\"         defStyleNum=\"dsKeyword\" color=\"#4e9a06\" bold=\"1\"/>\n-\t\t<itemData name=\"Trait\"        defStyleNum=\"dsKeyword\" color=\"#4e9a06\" bold=\"1\"/>\n-\t\t<itemData name=\"CType\"        defStyleNum=\"dsNormal\" color=\"#4e9a06\"/>\n-\t\t<itemData name=\"Constant\"     defStyleNum=\"dsKeyword\" color=\"#116644\"/>\n-\t\t<itemData name=\"CConstant\"    defStyleNum=\"dsNormal\" color=\"#116644\"/>\n-\t\t<itemData name=\"Definition\"   defStyleNum=\"dsNormal\" color=\"#0000FF\"/>\n-\t\t<itemData name=\"Comment\"      defStyleNum=\"dsComment\" color=\"#AA5500\"/>\n-\t\t<itemData name=\"Scope\"        defStyleNum=\"dsNormal\" color=\"#0055AA\"/>\n-\t\t<itemData name=\"Number\"       defStyleNum=\"dsDecVal\" color=\"#116644\"/>\n-\t\t<itemData name=\"String\"       defStyleNum=\"dsString\" color=\"#FF0000\"/>\n-\t\t<itemData name=\"CharEscape\"   defStyleNum=\"dsChar\" color=\"#FF0000\" bold=\"1\"/>\n-\t\t<itemData name=\"Character\"    defStyleNum=\"dsChar\" color=\"#FF0000\"/>\n-\t\t<itemData name=\"Macro\"        defStyleNum=\"dsOthers\"/>\n-\t\t<itemData name=\"Attribute\"    defStyleNum=\"dsOthers\"/>\n-\t\t<itemData name=\"Lifetime\"     defStyleNum=\"dsOthers\" bold=\"1\"/>\n-\t\t<itemData name=\"Error\"        defStyleNum=\"dsError\"/>\n-\t</itemDatas>\n-</highlighting>\n-<general>\n-\t<comments>\n-\t\t<comment name=\"singleLine\" start=\"//\" />\n-\t\t<comment name=\"multiLine\" start=\"/*\" end=\"*/\" region=\"Comment\"/>\n-\t</comments>\n-\t<keywords casesensitive=\"1\" />\n-</general>\n-</language>"}, {"sha": "1217769096df0be2e12aca1937f8a899501c687e", "filename": "src/etc/nano/rust.nanorc", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1d00c545ede609b9d43fdf9f252c15da5a66dac7/src%2Fetc%2Fnano%2Frust.nanorc", "raw_url": "https://github.com/rust-lang/rust/raw/1d00c545ede609b9d43fdf9f252c15da5a66dac7/src%2Fetc%2Fnano%2Frust.nanorc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fnano%2Frust.nanorc?ref=1d00c545ede609b9d43fdf9f252c15da5a66dac7", "patch": "@@ -1,35 +0,0 @@\n-# Nano configuration for Rust\n-# Copyright 2015 The Rust Project Developers.\n-#\n-# NOTE: Rules are applied in order: later rules re-colorize matching text.\n-syntax \"rust\" \"\\.rs\"\n-\n-# function definition\n-color magenta \"fn [a-z0-9_]+\"\n-\n-# Reserved words\n-color yellow \"\\<(abstract|alignof|as|be|box|break|const|continue|crate|do|else|enum|extern|false|final|fn|for|if|impl|in|let|loop|macro|match|mod|move|mut|offsetof|override|priv|pub|pure|ref|return|sizeof|static|self|struct|super|true|trait|type|typeof|unsafe|unsized|use|virtual|where|while|yield)\\>\"\n-\n-# macros\n-color red \"[a-z_]+!\"\n-\n-# Constants\n-color magenta \"[A-Z][A-Z_]+\"\n-\n-# Traits/Enums/Structs/Types/etc.\n-color magenta \"[A-Z][a-z]+\"\n-\n-# Strings\n-color green \"\\\".*\\\"\"\n-color green start=\"\\\".*\\\\$\" end=\".*\\\"\"\n-# NOTE: This isn't accurate but matching \"#{0,} for the end of the string is too liberal\n-color green start=\"r#+\\\"\" end=\"\\\"#+\"\n-\n-# Comments\n-color blue \"//.*\"\n-\n-# Attributes\n-color magenta start=\"#!\\[\" end=\"\\]\"\n-\n-# Some common markers\n-color brightcyan \"(XXX|TODO|FIXME|\\?\\?\\?)\""}, {"sha": "735c1e153a60dc070662d424cfcf1eef2714f6d4", "filename": "src/etc/vim/after/syntax/rust.vim", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/1d00c545ede609b9d43fdf9f252c15da5a66dac7/src%2Fetc%2Fvim%2Fafter%2Fsyntax%2Frust.vim", "raw_url": "https://github.com/rust-lang/rust/raw/1d00c545ede609b9d43fdf9f252c15da5a66dac7/src%2Fetc%2Fvim%2Fafter%2Fsyntax%2Frust.vim", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvim%2Fafter%2Fsyntax%2Frust.vim?ref=1d00c545ede609b9d43fdf9f252c15da5a66dac7", "patch": "@@ -1,31 +0,0 @@\n-if !exists('g:rust_conceal') || !has('conceal') || &enc != 'utf-8'\n-\tfinish\n-endif\n-\n-\" For those who don't want to see `::`...\n-if exists('g:rust_conceal_mod_path')\n-\tsyn match rustNiceOperator \"::\" conceal cchar=\u318d\n-endif\n-\n-syn match rustRightArrowHead contained \">\" conceal cchar=\u2000\n-syn match rustRightArrowTail contained \"-\" conceal cchar=\u27f6\n-syn match rustNiceOperator \"->\" contains=rustRightArrowHead,rustRightArrowTail\n-\n-syn match rustFatRightArrowHead contained \">\" conceal cchar=\u2000\n-syn match rustFatRightArrowTail contained \"=\" conceal cchar=\u27f9\n-syn match rustNiceOperator \"=>\" contains=rustFatRightArrowHead,rustFatRightArrowTail\n-\n-syn match rustNiceOperator /\\<\\@!_\\(_*\\>\\)\\@=/ conceal cchar=\u2032\n-\n-\" For those who don't want to see `pub`...\n-if exists('g:rust_conceal_pub')\n-    syn match rustPublicSigil contained \"pu\" conceal cchar=\uff0a\n-    syn match rustPublicRest contained \"b\" conceal cchar=\u2000\n-    syn match rustNiceOperator \"pub \" contains=rustPublicSigil,rustPublicRest\n-endif\n-\n-hi link rustNiceOperator Operator\n-\n-if !exists('g:rust_conceal_mod_path')\n-    hi! link Conceal Operator\n-endif"}, {"sha": "fe8e743e7826dae0055ed476667fd304a9588b73", "filename": "src/etc/vim/autoload/rust.vim", "status": "removed", "additions": 0, "deletions": 225, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/1d00c545ede609b9d43fdf9f252c15da5a66dac7/src%2Fetc%2Fvim%2Fautoload%2Frust.vim", "raw_url": "https://github.com/rust-lang/rust/raw/1d00c545ede609b9d43fdf9f252c15da5a66dac7/src%2Fetc%2Fvim%2Fautoload%2Frust.vim", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvim%2Fautoload%2Frust.vim?ref=1d00c545ede609b9d43fdf9f252c15da5a66dac7", "patch": "@@ -1,225 +0,0 @@\n-\" Author: Kevin Ballard\n-\" Description: Helper functions for Rust commands/mappings\n-\" Last Modified: May 27, 2014\n-\n-\" Jump {{{1\n-\n-function! rust#Jump(mode, function) range\n-\tlet cnt = v:count1\n-\tnormal! m'\n-\tif a:mode ==# 'v'\n-\t\tnorm! gv\n-\tendif\n-\tlet foldenable = &foldenable\n-\tset nofoldenable\n-\twhile cnt > 0\n-\t\texecute \"call <SID>Jump_\" . a:function . \"()\"\n-\t\tlet cnt = cnt - 1\n-\tendwhile\n-\tlet &foldenable = foldenable\n-endfunction\n-\n-function! s:Jump_Back()\n-\tcall search('{', 'b')\n-\tkeepjumps normal! w99[{\n-endfunction\n-\n-function! s:Jump_Forward()\n-\tnormal! j0\n-\tcall search('{', 'b')\n-\tkeepjumps normal! w99[{%\n-\tcall search('{')\n-endfunction\n-\n-\" Run {{{1\n-\n-function! rust#Run(bang, args)\n-\tif a:bang\n-\t\tlet idx = index(a:args, '--')\n-\t\tif idx != -1\n-\t\t\tlet rustc_args = idx == 0 ? [] : a:args[:idx-1]\n-\t\t\tlet args = a:args[idx+1:]\n-\t\telse\n-\t\t\tlet rustc_args = a:args\n-\t\t\tlet args = []\n-\t\tendif\n-\telse\n-\t\tlet rustc_args = []\n-\t\tlet args = a:args\n-\tendif\n-\n-\tlet b:rust_last_rustc_args = rustc_args\n-\tlet b:rust_last_args = args\n-\n-\tcall s:WithPath(function(\"s:Run\"), rustc_args, args)\n-endfunction\n-\n-function! s:Run(path, rustc_args, args)\n-\ttry\n-\t\tlet exepath = tempname()\n-\t\tif has('win32')\n-\t\t\tlet exepath .= '.exe'\n-\t\tendif\n-\n-\t\tlet rustc_args = [a:path, '-o', exepath] + a:rustc_args\n-\n-\t\tlet rustc = exists(\"g:rustc_path\") ? g:rustc_path : \"rustc\"\n-\n-\t\tlet output = system(shellescape(rustc) . \" \" . join(map(rustc_args, 'shellescape(v:val)')))\n-\t\tif output != ''\n-\t\t\techohl WarningMsg\n-\t\t\techo output\n-\t\t\techohl None\n-\t\tendif\n-\t\tif !v:shell_error\n-\t\t\texe '!' . shellescape(exepath) . \" \" . join(map(a:args, 'shellescape(v:val)'))\n-\t\tendif\n-\tfinally\n-\t\tif exists(\"exepath\")\n-\t\t\tsilent! call delete(exepath)\n-\t\tendif\n-\tendtry\n-endfunction\n-\n-\" Expand {{{1\n-\n-function! rust#Expand(bang, args)\n-\tif a:bang && !empty(a:args)\n-\t\tlet pretty = a:args[0]\n-\t\tlet args = a:args[1:]\n-\telse\n-\t\tlet pretty = \"expanded\"\n-\t\tlet args = a:args\n-\tendif\n-\tcall s:WithPath(function(\"s:Expand\"), pretty, args)\n-endfunction\n-\n-function! s:Expand(path, pretty, args)\n-\ttry\n-\t\tlet rustc = exists(\"g:rustc_path\") ? g:rustc_path : \"rustc\"\n-\n-\t\tlet args = [a:path, '--pretty', a:pretty] + a:args\n-\t\tlet output = system(shellescape(rustc) . \" \" . join(map(args, \"shellescape(v:val)\")))\n-\t\tif v:shell_error\n-\t\t\techohl WarningMsg\n-\t\t\techo output\n-\t\t\techohl None\n-\t\telse\n-\t\t\tnew\n-\t\t\tsilent put =output\n-\t\t\t1\n-\t\t\td\n-\t\t\tsetl filetype=rust\n-\t\t\tsetl buftype=nofile\n-\t\t\tsetl bufhidden=hide\n-\t\t\tsetl noswapfile\n-\t\tendif\n-\tendtry\n-endfunction\n-\n-function! rust#CompleteExpand(lead, line, pos)\n-\tif a:line[: a:pos-1] =~ '^RustExpand!\\s*\\S*$'\n-\t\t\" first argument and it has a !\n-\t\tlet list = [\"normal\", \"expanded\", \"typed\", \"expanded,identified\", \"flowgraph=\"]\n-\t\tif !empty(a:lead)\n-\t\t\tcall filter(list, \"v:val[:len(a:lead)-1] == a:lead\")\n-\t\tendif\n-\t\treturn list\n-\tendif\n-\n-\treturn glob(escape(a:lead, \"*?[\") . '*', 0, 1)\n-endfunction\n-\n-\" Emit {{{1\n-\n-function! rust#Emit(type, args)\n-\tcall s:WithPath(function(\"s:Emit\"), a:type, a:args)\n-endfunction\n-\n-function! s:Emit(path, type, args)\n-\ttry\n-\t\tlet rustc = exists(\"g:rustc_path\") ? g:rustc_path : \"rustc\"\n-\n-\t\tlet args = [a:path, '--emit', a:type, '-o', '-'] + a:args\n-\t\tlet output = system(shellescape(rustc) . \" \" . join(map(args, \"shellescape(v:val)\")))\n-\t\tif v:shell_error\n-\t\t\techohl WarningMsg\n-\t\t\techo output\n-\t\t\techohl None\n-\t\telse\n-\t\t\tnew\n-\t\t\tsilent put =output\n-\t\t\t1\n-\t\t\td\n-\t\t\tif a:type == \"ir\"\n-\t\t\t\tsetl filetype=llvm\n-\t\t\telseif a:type == \"asm\"\n-\t\t\t\tsetl filetype=asm\n-\t\t\tendif\n-\t\t\tsetl buftype=nofile\n-\t\t\tsetl bufhidden=hide\n-\t\t\tsetl noswapfile\n-\t\tendif\n-\tendtry\n-endfunction\n-\n-\" Utility functions {{{1\n-\n-function! s:WithPath(func, ...)\n-\ttry\n-\t\tlet save_write = &write\n-\t\tset write\n-\t\tlet path = expand('%')\n-\t\tlet pathisempty = empty(path)\n-\t\tif pathisempty || !save_write\n-\t\t\t\" use a temporary file named 'unnamed.rs' inside a temporary\n-\t\t\t\" directory. This produces better error messages\n-\t\t\tlet tmpdir = tempname()\n-\t\t\tcall mkdir(tmpdir)\n-\n-\t\t\tlet save_cwd = getcwd()\n-\t\t\tsilent exe 'lcd' fnameescape(tmpdir)\n-\n-\t\t\tlet path = 'unnamed.rs'\n-\n-\t\t\tlet save_mod = &mod\n-\t\t\tset nomod\n-\n-\t\t\tsilent exe 'keepalt write! ' . fnameescape(path)\n-\t\t\tif pathisempty\n-\t\t\t\tsilent keepalt 0file\n-\t\t\tendif\n-\t\telse\n-\t\t\tupdate\n-\t\tendif\n-\n-\t\tcall call(a:func, [path] + a:000)\n-\tfinally\n-\t\tif exists(\"save_mod\")   | let &mod = save_mod                    | endif\n-\t\tif exists(\"save_write\") | let &write = save_write                | endif\n-\t\tif exists(\"save_cwd\")   | silent exe 'lcd' fnameescape(save_cwd) | endif\n-\t\tif exists(\"tmpdir\")     | silent call s:RmDir(tmpdir)            | endif\n-\tendtry\n-endfunction\n-\n-function! rust#AppendCmdLine(text)\n-\tcall setcmdpos(getcmdpos())\n-\tlet cmd = getcmdline() . a:text\n-\treturn cmd\n-endfunction\n-\n-function! s:RmDir(path)\n-\t\" sanity check; make sure it's not empty, /, or $HOME\n-\tif empty(a:path)\n-\t\techoerr 'Attempted to delete empty path'\n-\t\treturn 0\n-\telseif a:path == '/' || a:path == $HOME\n-\t\techoerr 'Attempted to delete protected path: ' . a:path\n-\t\treturn 0\n-\tendif\n-\tsilent exe \"!rm -rf \" . shellescape(a:path)\n-endfunction\n-\n-\" }}}1\n-\n-\" vim: set noet sw=4 ts=4:"}, {"sha": "ed487a308e199d6a3d19fdfe8f16b0c1d3ebe6cf", "filename": "src/etc/vim/compiler/cargo.vim", "status": "removed", "additions": 0, "deletions": 65, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/1d00c545ede609b9d43fdf9f252c15da5a66dac7/src%2Fetc%2Fvim%2Fcompiler%2Fcargo.vim", "raw_url": "https://github.com/rust-lang/rust/raw/1d00c545ede609b9d43fdf9f252c15da5a66dac7/src%2Fetc%2Fvim%2Fcompiler%2Fcargo.vim", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvim%2Fcompiler%2Fcargo.vim?ref=1d00c545ede609b9d43fdf9f252c15da5a66dac7", "patch": "@@ -1,65 +0,0 @@\n-\" Vim compiler file\n-\" Compiler:         Cargo Compiler\n-\" Maintainer:       Damien Radtke <damienradtke@gmail.com>\n-\" Latest Revision:  2014 Sep 24\n-\n-if exists('current_compiler')\n-  finish\n-endif\n-runtime compiler/rustc.vim\n-let current_compiler = \"cargo\"\n-\n-if exists(':CompilerSet') != 2\n-    command -nargs=* CompilerSet setlocal <args>\n-endif\n-\n-if exists('g:cargo_makeprg_params')\n-    execute 'CompilerSet makeprg=cargo\\ '.escape(g:cargo_makeprg_params, ' \\|\"').'\\ $*'\n-else\n-    CompilerSet makeprg=cargo\\ $*\n-endif\n-\n-\" Allow a configurable global Cargo.toml name. This makes it easy to\n-\" support variations like 'cargo.toml'.\n-let s:cargo_manifest_name = get(g:, 'cargo_manifest_name', 'Cargo.toml')\n-\n-function! s:is_absolute(path)\n-    return a:path[0] == '/' || a:path =~ '[A-Z]\\+:'\n-endfunction\n-\n-let s:local_manifest = findfile(s:cargo_manifest_name, '.;')\n-if s:local_manifest != ''\n-    let s:local_manifest = fnamemodify(s:local_manifest, ':p:h').'/'\n-    augroup cargo\n-        au!\n-        au QuickfixCmdPost make call s:FixPaths()\n-    augroup END\n-\n-    \" FixPaths() is run after Cargo, and is used to change the file paths\n-    \" to be relative to the current directory instead of Cargo.toml.\n-    function! s:FixPaths()\n-        let qflist = getqflist()\n-        let manifest = s:local_manifest\n-        for qf in qflist\n-            if !qf.valid\n-                let m = matchlist(qf.text, '(file://\\(.*\\))$')\n-                if !empty(m)\n-                    let manifest = m[1].'/'\n-                    \" Manually strip another slash if needed; usually just an\n-                    \" issue on Windows.\n-                    if manifest =~ '^/[A-Z]\\+:/'\n-                        let manifest = manifest[1:]\n-                    endif\n-                endif\n-                continue\n-            endif\n-            let filename = bufname(qf.bufnr)\n-            if s:is_absolute(filename)\n-                continue\n-            endif\n-            let qf.filename = simplify(manifest.filename)\n-            call remove(qf, 'bufnr')\n-        endfor\n-        call setqflist(qflist, 'r')\n-    endfunction\n-endif"}, {"sha": "f9b854ed0491398b2364912a2f3c4598f5ad8e34", "filename": "src/etc/vim/compiler/rustc.vim", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/1d00c545ede609b9d43fdf9f252c15da5a66dac7/src%2Fetc%2Fvim%2Fcompiler%2Frustc.vim", "raw_url": "https://github.com/rust-lang/rust/raw/1d00c545ede609b9d43fdf9f252c15da5a66dac7/src%2Fetc%2Fvim%2Fcompiler%2Frustc.vim", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvim%2Fcompiler%2Frustc.vim?ref=1d00c545ede609b9d43fdf9f252c15da5a66dac7", "patch": "@@ -1,33 +0,0 @@\n-\" Vim compiler file\n-\" Compiler:         Rust Compiler\n-\" Maintainer:       Chris Morgan <me@chrismorgan.info>\n-\" Latest Revision:  2013 Jul 12\n-\n-if exists(\"current_compiler\")\n-  finish\n-endif\n-let current_compiler = \"rustc\"\n-\n-let s:cpo_save = &cpo\n-set cpo&vim\n-\n-if exists(\":CompilerSet\") != 2\n-\tcommand -nargs=* CompilerSet setlocal <args>\n-endif\n-\n-if exists(\"g:rustc_makeprg_no_percent\") && g:rustc_makeprg_no_percent == 1\n-\tCompilerSet makeprg=rustc\n-else\n-\tCompilerSet makeprg=rustc\\ \\%\n-endif\n-\n-CompilerSet errorformat=\n-\t\t\t\\%f:%l:%c:\\ %t%*[^:]:\\ %m,\n-\t\t\t\\%f:%l:%c:\\ %*\\\\d:%*\\\\d\\ %t%*[^:]:\\ %m,\n-\t\t\t\\%-G%f:%l\\ %s,\n-\t\t\t\\%-G%*[\\ ]^,\n-\t\t\t\\%-G%*[\\ ]^%*[~],\n-\t\t\t\\%-G%*[\\ ]...\n-\n-let &cpo = s:cpo_save\n-unlet s:cpo_save"}, {"sha": "e117b0c155b762d979ae96324ee1991b338737ef", "filename": "src/etc/vim/doc/rust.txt", "status": "removed", "additions": 0, "deletions": 178, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/1d00c545ede609b9d43fdf9f252c15da5a66dac7/src%2Fetc%2Fvim%2Fdoc%2Frust.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1d00c545ede609b9d43fdf9f252c15da5a66dac7/src%2Fetc%2Fvim%2Fdoc%2Frust.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvim%2Fdoc%2Frust.txt?ref=1d00c545ede609b9d43fdf9f252c15da5a66dac7", "patch": "@@ -1,178 +0,0 @@\n-*rust.txt*      Filetype plugin for Rust\n-\n-==============================================================================\n-CONTENTS                                                      *rust* *ft-rust*\n-\n-1. Introduction                                                   |rust-intro|\n-2. Settings                                                    |rust-settings|\n-3. Commands                                                    |rust-commands|\n-4. Mappings                                                    |rust-mappings|\n-\n-==============================================================================\n-INTRODUCTION                                                      *rust-intro*\n-\n-This plugin provides syntax and supporting functionality for the Rust\n-filetype.\n-\n-==============================================================================\n-SETTINGS                                                       *rust-settings*\n-\n-This plugin has a few variables you can define in your vimrc that change the\n-behavior of the plugin.\n-\n-                                                                *g:rustc_path*\n-g:rustc_path~\n-\tSet this option to the path to rustc for use in the |:RustRun| and\n-\t|:RustExpand| commands. If unset, \"rustc\" will be located in $PATH: >\n-\t    let g:rustc_path = $HOME.\"/bin/rustc\"\n-<\n-\n-                                                  *g:rustc_makeprg_no_percent*\n-g:rustc_makeprg_no_percent~\n-\tSet this option to 1 to have 'makeprg' default to \"rustc\" instead of\n-\t\"rustc %\": >\n-\t    let g:rustc_makeprg_no_percent = 1\n-<\n-\n-                                                              *g:rust_conceal*\n-g:rust_conceal~\n-\tSet this option to turn on the basic |conceal| support: >\n-\t    let g:rust_conceal = 1\n-<\n-\n-                                                     *g:rust_conceal_mod_path*\n-g:rust_conceal_mod_path~\n-\tSet this option to turn on |conceal| for the path connecting token\n-\t\"::\": >\n-\t    let g:rust_conceal_mod_path = 1\n-<\n-\n-                                                          *g:rust_conceal_pub*\n-g:rust_conceal_pub~\n-\tSet this option to turn on |conceal| for the \"pub\" token: >\n-\t    let g:rust_conceal_pub = 1\n-<\n-\n-                                                     *g:rust_recommended_style*\n-g:rust_recommended_style~\n-        Set this option to enable vim indentation and textwidth settings to\n-        conform to style conventions of the rust standard library (i.e. use 4\n-        spaces for indents and sets 'textwidth' to 99). This option is enabled\n-\tby default. To disable it: >\n-\t    let g:rust_recommended_style = 0\n-<\n-\n-                                                                 *g:rust_fold*\n-g:rust_fold~\n-\tSet this option to turn on |folding|: >\n-\t    let g:rust_fold = 1\n-<\n-\tValue\t\tEffect ~\n-\t0\t\tNo folding\n-\t1\t\tBraced blocks are folded. All folds are open by\n-\t\t\tdefault.\n-\t2\t\tBraced blocks are folded. 'foldlevel' is left at the\n-\t\t\tglobal value (all folds are closed by default).\n-\n-                                                  *g:rust_bang_comment_leader*\n-g:rust_bang_comment_leader~\n-\tSet this option to 1 to preserve the leader on multi-line doc comments\n-\tusing the /*! syntax: >\n-\t    let g:rust_bang_comment_leader = 1\n-<\n-\n-                                                 *g:ftplugin_rust_source_path*\n-g:ftplugin_rust_source_path~\n-\tSet this option to a path that should be prepended to 'path' for Rust\n-\tsource files: >\n-\t    let g:ftplugin_rust_source_path = $HOME.'/dev/rust'\n-<\n-\n-                                                       *g:cargo_manifest_name*\n-g:cargo_manifest_name~\n-\tSet this option to the name of the manifest file for your projects. If\n-\tnot specified it defaults to 'Cargo.toml' : >\n-\t    let g:cargo_manifest_name = 'Cargo.toml'\n-<\n-\n-==============================================================================\n-COMMANDS                                                       *rust-commands*\n-\n-:RustRun  [args]                                                    *:RustRun*\n-:RustRun! [rustc-args] [--] [args]\n-\t\tCompiles and runs the current file. If it has unsaved changes,\n-\t\tit will be saved first using |:update|. If the current file is\n-\t\tan unnamed buffer, it will be written to a temporary file\n-\t\tfirst. The compiled binary is always placed in a temporary\n-\t\tdirectory, but is run from the current directory.\n-\n-\t\tThe arguments given to |:RustRun| will be passed to the\n-\t\tcompiled binary.\n-\n-\t\tIf ! is specified, the arguments are passed to rustc instead.\n-\t\tA \"--\" argument will separate the rustc arguments from the\n-\t\targuments passed to the binary.\n-\n-\t\tIf |g:rustc_path| is defined, it is used as the path to rustc.\n-\t\tOtherwise it is assumed rustc can be found in $PATH.\n-\n-:RustExpand  [args]                                              *:RustExpand*\n-:RustExpand! [TYPE] [args]\n-\t\tExpands the current file using --pretty and displays the\n-\t\tresults in a new split. If the current file has unsaved\n-\t\tchanges, it will be saved first using |:update|. If the\n-\t\tcurrent file is an unnamed buffer, it will be written to a\n-\t\ttemporary file first.\n-\n-\t\tThe arguments given to |:RustExpand| will be passed to rustc.\n-\t\tThis is largely intended for specifying various --cfg\n-\t\tconfigurations.\n-\n-\t\tIf ! is specified, the first argument is the expansion type to\n-\t\tpass to rustc --pretty. Otherwise it will default to\n-\t\t\"expanded\".\n-\n-\t\tIf |g:rustc_path| is defined, it is used as the path to rustc.\n-\t\tOtherwise it is assumed rustc can be found in $PATH.\n-\n-:RustEmitIr [args]                                               *:RustEmitIr*\n-\t\tCompiles the current file to LLVM IR and displays the results\n-\t\tin a new split. If the current file has unsaved changes, it\n-\t\twill be saved first using |:update|. If the current file is an\n-\t\tunnamed buffer, it will be written to a temporary file first.\n-\n-\t\tThe arguments given to |:RustEmitIr| will be passed to rustc.\n-\n-\t\tIf |g:rustc_path| is defined, it is used as the path to rustc.\n-\t\tOtherwise it is assumed rustc can be found in $PATH.\n-\n-:RustEmitAsm [args]                                             *:RustEmitAsm*\n-\t\tCompiles the current file to assembly and displays the results\n-\t\tin a new split. If the current file has unsaved changes, it\n-\t\twill be saved first using |:update|. If the current file is an\n-\t\tunnamed buffer, it will be written to a temporary file first.\n-\n-\t\tThe arguments given to |:RustEmitAsm| will be passed to rustc.\n-\n-\t\tIf |g:rustc_path| is defined, it is used as the path to rustc.\n-\t\tOtherwise it is assumed rustc can be found in $PATH.\n-\n-==============================================================================\n-MAPPINGS                                                       *rust-mappings*\n-\n-This plugin defines mappings for |[[| and |]]| to support hanging indents.\n-\n-It also has a few other mappings:\n-\n-\t\t\t\t\t\t\t*rust_<D-r>*\n-<D-r>\t\t\tExecutes |:RustRun| with no arguments.\n-\t\t\tNote: This binding is only available in MacVim.\n-\n-\t\t\t\t\t\t\t*rust_<D-R>*\n-<D-R>\t\t\tPopulates the command line with |:RustRun|! using the\n-\t\t\targuments given to the last invocation, but does not\n-\t\t\texecute it.\n-\t\t\tNote: This binding is only available in MacVim.\n-\n-==============================================================================\n- vim:tw=78:sw=4:noet:ts=8:ft=help:norl:"}, {"sha": "bf685d43243cc4553155ac50d32f0b8c9243e0cc", "filename": "src/etc/vim/ftdetect/rust.vim", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1d00c545ede609b9d43fdf9f252c15da5a66dac7/src%2Fetc%2Fvim%2Fftdetect%2Frust.vim", "raw_url": "https://github.com/rust-lang/rust/raw/1d00c545ede609b9d43fdf9f252c15da5a66dac7/src%2Fetc%2Fvim%2Fftdetect%2Frust.vim", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvim%2Fftdetect%2Frust.vim?ref=1d00c545ede609b9d43fdf9f252c15da5a66dac7", "patch": "@@ -1 +0,0 @@\n-au BufRead,BufNewFile *.rs set filetype=rust"}, {"sha": "5d5569945f581bc435c4e0971ab0e2fcb12e0c6e", "filename": "src/etc/vim/ftplugin/rust.vim", "status": "removed", "additions": 0, "deletions": 150, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/1d00c545ede609b9d43fdf9f252c15da5a66dac7/src%2Fetc%2Fvim%2Fftplugin%2Frust.vim", "raw_url": "https://github.com/rust-lang/rust/raw/1d00c545ede609b9d43fdf9f252c15da5a66dac7/src%2Fetc%2Fvim%2Fftplugin%2Frust.vim", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvim%2Fftplugin%2Frust.vim?ref=1d00c545ede609b9d43fdf9f252c15da5a66dac7", "patch": "@@ -1,150 +0,0 @@\n-\" Language:     Rust\n-\" Description:  Vim syntax file for Rust\n-\" Maintainer:   Chris Morgan <me@chrismorgan.info>\n-\" Maintainer:   Kevin Ballard <kevin@sb.org>\n-\" Last Change:  Jul 07, 2014\n-\n-if exists(\"b:did_ftplugin\")\n-\tfinish\n-endif\n-let b:did_ftplugin = 1\n-\n-let s:save_cpo = &cpo\n-set cpo&vim\n-\n-\" Variables {{{1\n-\n-\" The rust source code at present seems to typically omit a leader on /*!\n-\" comments, so we'll use that as our default, but make it easy to switch.\n-\" This does not affect indentation at all (I tested it with and without\n-\" leader), merely whether a leader is inserted by default or not.\n-if exists(\"g:rust_bang_comment_leader\") && g:rust_bang_comment_leader == 1\n-\t\" Why is the `,s0:/*,mb:\\ ,ex:*/` there, you ask? I don't understand why,\n-\t\" but without it, */ gets indented one space even if there were no\n-\t\" leaders. I'm fairly sure that's a Vim bug.\n-\tsetlocal comments=s1:/*,mb:*,ex:*/,s0:/*,mb:\\ ,ex:*/,:///,://!,://\n-else\n-\tsetlocal comments=s0:/*!,m:\\ ,ex:*/,s1:/*,mb:*,ex:*/,:///,://!,://\n-endif\n-setlocal commentstring=//%s\n-setlocal formatoptions-=t formatoptions+=croqnl\n-\" j was only added in 7.3.541, so stop complaints about its nonexistence\n-silent! setlocal formatoptions+=j\n-\n-\" smartindent will be overridden by indentexpr if filetype indent is on, but\n-\" otherwise it's better than nothing.\n-setlocal smartindent nocindent\n-\n-if !exists(\"g:rust_recommended_style\") || g:rust_recommended_style == 1\n-\tsetlocal tabstop=4 shiftwidth=4 softtabstop=4 expandtab\n-\tsetlocal textwidth=99\n-endif\n-\n-\" This includeexpr isn't perfect, but it's a good start\n-setlocal includeexpr=substitute(v:fname,'::','/','g')\n-\n-\" NOT adding .rc as it's being phased out (0.7)\n-setlocal suffixesadd=.rs\n-\n-if exists(\"g:ftplugin_rust_source_path\")\n-    let &l:path=g:ftplugin_rust_source_path . ',' . &l:path\n-endif\n-\n-if exists(\"g:loaded_delimitMate\")\n-\tif exists(\"b:delimitMate_excluded_regions\")\n-\t\tlet b:rust_original_delimitMate_excluded_regions = b:delimitMate_excluded_regions\n-\tendif\n-\tlet b:delimitMate_excluded_regions = delimitMate#Get(\"excluded_regions\") . ',rustLifetimeCandidate,rustGenericLifetimeCandidate'\n-endif\n-\n-if has(\"folding\") && exists('g:rust_fold') && g:rust_fold != 0\n-\tlet b:rust_set_foldmethod=1\n-\tsetlocal foldmethod=syntax\n-\tif g:rust_fold == 2\n-\t\tsetlocal foldlevel<\n-\telse\n-\t\tsetlocal foldlevel=99\n-\tendif\n-endif\n-\n-if has('conceal') && exists('g:rust_conceal')\n-\tlet b:rust_set_conceallevel=1\n-\tsetlocal conceallevel=2\n-endif\n-\n-\" Motion Commands {{{1\n-\n-\" Bind motion commands to support hanging indents\n-nnoremap <silent> <buffer> [[ :call rust#Jump('n', 'Back')<CR>\n-nnoremap <silent> <buffer> ]] :call rust#Jump('n', 'Forward')<CR>\n-xnoremap <silent> <buffer> [[ :call rust#Jump('v', 'Back')<CR>\n-xnoremap <silent> <buffer> ]] :call rust#Jump('v', 'Forward')<CR>\n-onoremap <silent> <buffer> [[ :call rust#Jump('o', 'Back')<CR>\n-onoremap <silent> <buffer> ]] :call rust#Jump('o', 'Forward')<CR>\n-\n-\" Commands {{{1\n-\n-\" See |:RustRun| for docs\n-command! -nargs=* -complete=file -bang -bar -buffer RustRun call rust#Run(<bang>0, [<f-args>])\n-\n-\" See |:RustExpand| for docs\n-command! -nargs=* -complete=customlist,rust#CompleteExpand -bang -bar -buffer RustExpand call rust#Expand(<bang>0, [<f-args>])\n-\n-\" See |:RustEmitIr| for docs\n-command! -nargs=* -bar -buffer RustEmitIr call rust#Emit(\"ir\", [<f-args>])\n-\n-\" See |:RustEmitAsm| for docs\n-command! -nargs=* -bar -buffer RustEmitAsm call rust#Emit(\"asm\", [<f-args>])\n-\n-\" Mappings {{{1\n-\n-\" Bind \u2318R in MacVim to :RustRun\n-nnoremap <silent> <buffer> <D-r> :RustRun<CR>\n-\" Bind \u2318\u21e7R in MacVim to :RustRun! pre-filled with the last args\n-nnoremap <buffer> <D-R> :RustRun! <C-r>=join(b:rust_last_rustc_args)<CR><C-\\>erust#AppendCmdLine(' -- ' . join(b:rust_last_args))<CR>\n-\n-if !exists(\"b:rust_last_rustc_args\") || !exists(\"b:rust_last_args\")\n-\tlet b:rust_last_rustc_args = []\n-\tlet b:rust_last_args = []\n-endif\n-\n-\" Cleanup {{{1\n-\n-let b:undo_ftplugin = \"\n-\t\t\\ setlocal formatoptions< comments< commentstring< includeexpr< suffixesadd<\n-\t\t\\|setlocal tabstop< shiftwidth< softtabstop< expandtab< textwidth<\n-\t\t\\|if exists('b:rust_original_delimitMate_excluded_regions')\n-\t\t  \\|let b:delimitMate_excluded_regions = b:rust_original_delimitMate_excluded_regions\n-\t\t  \\|unlet b:rust_original_delimitMate_excluded_regions\n-\t\t\\|else\n-\t\t  \\|unlet! b:delimitMate_excluded_regions\n-\t\t\\|endif\n-\t\t\\|if exists('b:rust_set_foldmethod')\n-\t\t  \\|setlocal foldmethod< foldlevel<\n-\t\t  \\|unlet b:rust_set_foldmethod\n-\t\t\\|endif\n-\t\t\\|if exists('b:rust_set_conceallevel')\n-\t\t  \\|setlocal conceallevel<\n-\t\t  \\|unlet b:rust_set_conceallevel\n-\t\t\\|endif\n-\t\t\\|unlet! b:rust_last_rustc_args b:rust_last_args\n-\t\t\\|delcommand RustRun\n-\t\t\\|delcommand RustExpand\n-\t\t\\|delcommand RustEmitIr\n-\t\t\\|delcommand RustEmitAsm\n-\t\t\\|nunmap <buffer> <D-r>\n-\t\t\\|nunmap <buffer> <D-R>\n-\t\t\\|nunmap <buffer> [[\n-\t\t\\|nunmap <buffer> ]]\n-\t\t\\|xunmap <buffer> [[\n-\t\t\\|xunmap <buffer> ]]\n-\t\t\\|ounmap <buffer> [[\n-\t\t\\|ounmap <buffer> ]]\n-\t\t\\\"\n-\n-\" }}}1\n-\n-let &cpo = s:save_cpo\n-unlet s:save_cpo\n-\n-\" vim: set noet sw=4 ts=4:"}, {"sha": "300d7dacfa9ae57c3b119470448f7e91f6a7d992", "filename": "src/etc/vim/indent/rust.vim", "status": "removed", "additions": 0, "deletions": 196, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/1d00c545ede609b9d43fdf9f252c15da5a66dac7/src%2Fetc%2Fvim%2Findent%2Frust.vim", "raw_url": "https://github.com/rust-lang/rust/raw/1d00c545ede609b9d43fdf9f252c15da5a66dac7/src%2Fetc%2Fvim%2Findent%2Frust.vim", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvim%2Findent%2Frust.vim?ref=1d00c545ede609b9d43fdf9f252c15da5a66dac7", "patch": "@@ -1,196 +0,0 @@\n-\" Vim indent file\n-\" Language:         Rust\n-\" Author:           Chris Morgan <me@chrismorgan.info>\n-\" Last Change:      2014 Sep 13\n-\n-\" Only load this indent file when no other was loaded.\n-if exists(\"b:did_indent\")\n-  finish\n-endif\n-let b:did_indent = 1\n-\n-setlocal cindent\n-setlocal cinoptions=L0,(0,Ws,J1,j1\n-setlocal cinkeys=0{,0},!^F,o,O,0[,0]\n-\" Don't think cinwords will actually do anything at all... never mind\n-setlocal cinwords=for,if,else,while,loop,impl,mod,unsafe,trait,struct,enum,fn,extern\n-\n-\" Some preliminary settings\n-setlocal nolisp\t\t\" Make sure lisp indenting doesn't supersede us\n-setlocal autoindent\t\" indentexpr isn't much help otherwise\n-\" Also do indentkeys, otherwise # gets shoved to column 0 :-/\n-setlocal indentkeys=0{,0},!^F,o,O,0[,0]\n-\n-setlocal indentexpr=GetRustIndent(v:lnum)\n-\n-\" Only define the function once.\n-if exists(\"*GetRustIndent\")\n-  finish\n-endif\n-\n-\" Come here when loading the script the first time.\n-\n-function! s:get_line_trimmed(lnum)\n-\t\" Get the line and remove a trailing comment.\n-\t\" Use syntax highlighting attributes when possible.\n-\t\" NOTE: this is not accurate; /* */ or a line continuation could trick it\n-\tlet line = getline(a:lnum)\n-\tlet line_len = strlen(line)\n-\tif has('syntax_items')\n-\t\t\" If the last character in the line is a comment, do a binary search for\n-\t\t\" the start of the comment.  synID() is slow, a linear search would take\n-\t\t\" too long on a long line.\n-\t\tif synIDattr(synID(a:lnum, line_len, 1), \"name\") =~ 'Comment\\|Todo'\n-\t\t\tlet min = 1\n-\t\t\tlet max = line_len\n-\t\t\twhile min < max\n-\t\t\t\tlet col = (min + max) / 2\n-\t\t\t\tif synIDattr(synID(a:lnum, col, 1), \"name\") =~ 'Comment\\|Todo'\n-\t\t\t\t\tlet max = col\n-\t\t\t\telse\n-\t\t\t\t\tlet min = col + 1\n-\t\t\t\tendif\n-\t\t\tendwhile\n-\t\t\tlet line = strpart(line, 0, min - 1)\n-\t\tendif\n-\t\treturn substitute(line, \"\\s*$\", \"\", \"\")\n-\telse\n-\t\t\" Sorry, this is not complete, nor fully correct (e.g. string \"//\").\n-\t\t\" Such is life.\n-\t\treturn substitute(line, \"\\s*//.*$\", \"\", \"\")\n-\tendif\n-endfunction\n-\n-function! s:is_string_comment(lnum, col)\n-\tif has('syntax_items')\n-\t\tfor id in synstack(a:lnum, a:col)\n-\t\t\tlet synname = synIDattr(id, \"name\")\n-\t\t\tif synname == \"rustString\" || synname =~ \"^rustComment\"\n-\t\t\t\treturn 1\n-\t\t\tendif\n-\t\tendfor\n-\telse\n-\t\t\" without syntax, let's not even try\n-\t\treturn 0\n-\tendif\n-endfunction\n-\n-function GetRustIndent(lnum)\n-\n-\t\" Starting assumption: cindent (called at the end) will do it right\n-\t\" normally. We just want to fix up a few cases.\n-\n-\tlet line = getline(a:lnum)\n-\n-\tif has('syntax_items')\n-\t\tlet synname = synIDattr(synID(a:lnum, 1, 1), \"name\")\n-\t\tif synname == \"rustString\"\n-\t\t\t\" If the start of the line is in a string, don't change the indent\n-\t\t\treturn -1\n-\t\telseif synname =~ '\\(Comment\\|Todo\\)'\n-\t\t\t\t\t\\ && line !~ '^\\s*/\\*'  \" not /* opening line\n-\t\t\tif synname =~ \"CommentML\" \" multi-line\n-\t\t\t\tif line !~ '^\\s*\\*' && getline(a:lnum - 1) =~ '^\\s*/\\*'\n-\t\t\t\t\t\" This is (hopefully) the line after a /*, and it has no\n-\t\t\t\t\t\" leader, so the correct indentation is that of the\n-\t\t\t\t\t\" previous line.\n-\t\t\t\t\treturn GetRustIndent(a:lnum - 1)\n-\t\t\t\tendif\n-\t\t\tendif\n-\t\t\t\" If it's in a comment, let cindent take care of it now. This is\n-\t\t\t\" for cases like \"/*\" where the next line should start \" * \", not\n-\t\t\t\" \"* \" as the code below would otherwise cause for module scope\n-\t\t\t\" Fun fact: \"  /*\\n*\\n*/\" takes two calls to get right!\n-\t\t\treturn cindent(a:lnum)\n-\t\tendif\n-\tendif\n-\n-\t\" cindent gets second and subsequent match patterns/struct members wrong,\n-\t\" as it treats the comma as indicating an unfinished statement::\n-\t\"\n-\t\" match a {\n-\t\"     b => c,\n-\t\"         d => e,\n-\t\"         f => g,\n-\t\" };\n-\n-\t\" Search backwards for the previous non-empty line.\n-\tlet prevlinenum = prevnonblank(a:lnum - 1)\n-\tlet prevline = s:get_line_trimmed(prevlinenum)\n-\twhile prevlinenum > 1 && prevline !~ '[^[:blank:]]'\n-\t\tlet prevlinenum = prevnonblank(prevlinenum - 1)\n-\t\tlet prevline = s:get_line_trimmed(prevlinenum)\n-\tendwhile\n-\tif prevline[len(prevline) - 1] == \",\"\n-\t\t\t\t\\ && s:get_line_trimmed(a:lnum) !~ '^\\s*[\\[\\]{}]'\n-\t\t\t\t\\ && prevline !~ '^\\s*fn\\s'\n-\t\t\t\t\\ && prevline !~ '([^()]\\+,$'\n-\t\t\" Oh ho! The previous line ended in a comma! I bet cindent will try to\n-\t\t\" take this too far... For now, let's normally use the previous line's\n-\t\t\" indent.\n-\n-\t\t\" One case where this doesn't work out is where *this* line contains\n-\t\t\" square or curly brackets; then we normally *do* want to be indenting\n-\t\t\" further.\n-\t\t\"\n-\t\t\" Another case where we don't want to is one like a function\n-\t\t\" definition with arguments spread over multiple lines:\n-\t\t\"\n-\t\t\" fn foo(baz: Baz,\n-\t\t\"        baz: Baz) // <-- cindent gets this right by itself\n-\t\t\"\n-\t\t\" Another case is similar to the previous, except calling a function\n-\t\t\" instead of defining it, or any conditional expression that leaves\n-\t\t\" an open paren:\n-\t\t\"\n-\t\t\" foo(baz,\n-\t\t\"     baz);\n-\t\t\"\n-\t\t\" if baz && (foo ||\n-\t\t\"            bar) {\n-\t\t\"\n-\t\t\" There are probably other cases where we don't want to do this as\n-\t\t\" well. Add them as needed.\n-\t\treturn indent(prevlinenum)\n-\tendif\n-\n-\tif !has(\"patch-7.4.355\")\n-\t\t\" cindent before 7.4.355 doesn't do the module scope well at all; e.g.::\n-\t\t\"\n-\t\t\" static FOO : &'static [bool] = [\n-\t\t\" true,\n-\t\t\"\t false,\n-\t\t\"\t false,\n-\t\t\"\t true,\n-\t\t\"\t ];\n-\t\t\"\n-\t\t\"\t uh oh, next statement is indented further!\n-\n-\t\t\" Note that this does *not* apply the line continuation pattern properly;\n-\t\t\" that's too hard to do correctly for my liking at present, so I'll just\n-\t\t\" start with these two main cases (square brackets and not returning to\n-\t\t\" column zero)\n-\n-\t\tcall cursor(a:lnum, 1)\n-\t\tif searchpair('{\\|(', '', '}\\|)', 'nbW',\n-\t\t\t\t\t\\ 's:is_string_comment(line(\".\"), col(\".\"))') == 0\n-\t\t\tif searchpair('\\[', '', '\\]', 'nbW',\n-\t\t\t\t\t\t\\ 's:is_string_comment(line(\".\"), col(\".\"))') == 0\n-\t\t\t\t\" Global scope, should be zero\n-\t\t\t\treturn 0\n-\t\t\telse\n-\t\t\t\t\" At the module scope, inside square brackets only\n-\t\t\t\t\"if getline(a:lnum)[0] == ']' || search('\\[', '', '\\]', 'nW') == a:lnum\n-\t\t\t\tif line =~ \"^\\\\s*]\"\n-\t\t\t\t\t\" It's the closing line, dedent it\n-\t\t\t\t\treturn 0\n-\t\t\t\telse\n-\t\t\t\t\treturn &shiftwidth\n-\t\t\t\tendif\n-\t\t\tendif\n-\t\tendif\n-\tendif\n-\n-\t\" Fall back on cindent, which does it mostly right\n-\treturn cindent(a:lnum)\n-endfunction"}, {"sha": "4ec4f33d54559c991b196305e6c7af0a2dfe0b16", "filename": "src/etc/vim/plugin/rust.vim", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1d00c545ede609b9d43fdf9f252c15da5a66dac7/src%2Fetc%2Fvim%2Fplugin%2Frust.vim", "raw_url": "https://github.com/rust-lang/rust/raw/1d00c545ede609b9d43fdf9f252c15da5a66dac7/src%2Fetc%2Fvim%2Fplugin%2Frust.vim", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvim%2Fplugin%2Frust.vim?ref=1d00c545ede609b9d43fdf9f252c15da5a66dac7", "patch": "@@ -1,22 +0,0 @@\n-\" Vim syntastic plugin helper\n-\" Language:     Rust\n-\" Maintainer:   Andrew Gallant <jamslam@gmail.com>\n-\n-if exists(\"g:loaded_syntastic_rust_filetype\")\n-  finish\n-endif\n-let g:loaded_syntastic_rust_filetype = 1\n-let s:save_cpo = &cpo\n-set cpo&vim\n-\n-\" This is to let Syntastic know about the Rust filetype.\n-\" It enables tab completion for the 'SyntasticInfo' command.\n-\" (This does not actually register the syntax checker.)\n-if exists('g:syntastic_extra_filetypes')\n-    call add(g:syntastic_extra_filetypes, 'rust')\n-else\n-    let g:syntastic_extra_filetypes = ['rust']\n-endif\n-\n-let &cpo = s:save_cpo\n-unlet s:save_cpo"}, {"sha": "a37b7b6d57dbfe0e129c91fa01a7b621b7d63131", "filename": "src/etc/vim/syntax/rust.vim", "status": "removed", "additions": 0, "deletions": 262, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/1d00c545ede609b9d43fdf9f252c15da5a66dac7/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim", "raw_url": "https://github.com/rust-lang/rust/raw/1d00c545ede609b9d43fdf9f252c15da5a66dac7/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim?ref=1d00c545ede609b9d43fdf9f252c15da5a66dac7", "patch": "@@ -1,262 +0,0 @@\n-\" Vim syntax file\n-\" Language:     Rust\n-\" Maintainer:   Patrick Walton <pcwalton@mozilla.com>\n-\" Maintainer:   Ben Blum <bblum@cs.cmu.edu>\n-\" Maintainer:   Chris Morgan <me@chrismorgan.info>\n-\" Last Change:  January 5, 2015\n-\n-if version < 600\n-  syntax clear\n-elseif exists(\"b:current_syntax\")\n-  finish\n-endif\n-\n-\" Syntax definitions {{{1\n-\" Basic keywords {{{2\n-syn keyword   rustConditional match if else\n-syn keyword   rustOperator    as\n-\n-syn match     rustAssert      \"\\<assert\\(\\w\\)*!\" contained\n-syn match     rustPanic       \"\\<panic\\(\\w\\)*!\" contained\n-syn keyword   rustKeyword     break\n-syn keyword   rustKeyword     box nextgroup=rustBoxPlacement skipwhite skipempty\n-syn keyword   rustKeyword     continue\n-syn keyword   rustKeyword     extern nextgroup=rustExternCrate,rustObsoleteExternMod skipwhite skipempty\n-syn keyword   rustKeyword     fn nextgroup=rustFuncName skipwhite skipempty\n-syn keyword   rustKeyword     for in if impl let\n-syn keyword   rustKeyword     loop once pub\n-syn keyword   rustKeyword     return super\n-syn keyword   rustKeyword     unsafe virtual where while\n-syn keyword   rustKeyword     use nextgroup=rustModPath skipwhite skipempty\n-\" FIXME: Scoped impl's name is also fallen in this category\n-syn keyword   rustKeyword     mod trait struct enum type nextgroup=rustIdentifier skipwhite skipempty\n-syn keyword   rustStorage     move mut ref static const\n-\n-syn keyword   rustInvalidBareKeyword crate\n-\n-syn keyword   rustExternCrate crate contained nextgroup=rustIdentifier,rustExternCrateString skipwhite skipempty\n-\" This is to get the `bar` part of `extern crate \"foo\" as bar;` highlighting.\n-syn match   rustExternCrateString /\".*\"\\_s*as/ contained nextgroup=rustIdentifier skipwhite transparent skipempty contains=rustString,rustOperator\n-syn keyword   rustObsoleteExternMod mod contained nextgroup=rustIdentifier skipwhite skipempty\n-\n-syn match     rustIdentifier  contains=rustIdentifierPrime \"\\%([^[:cntrl:][:space:][:punct:][:digit:]]\\|_\\)\\%([^[:cntrl:][:punct:][:space:]]\\|_\\)*\" display contained\n-syn match     rustFuncName    \"\\%([^[:cntrl:][:space:][:punct:][:digit:]]\\|_\\)\\%([^[:cntrl:][:punct:][:space:]]\\|_\\)*\" display contained\n-\n-syn region    rustBoxPlacement matchgroup=rustBoxPlacementParens start=\"(\" end=\")\" contains=TOP contained\n-syn keyword   rustBoxPlacementExpr GC containedin=rustBoxPlacement\n-\" Ideally we'd have syntax rules set up to match arbitrary expressions. Since\n-\" we don't, we'll just define temporary contained rules to handle balancing\n-\" delimiters.\n-syn region    rustBoxPlacementBalance start=\"(\" end=\")\" containedin=rustBoxPlacement transparent\n-syn region    rustBoxPlacementBalance start=\"\\[\" end=\"\\]\" containedin=rustBoxPlacement transparent\n-\" {} are handled by rustFoldBraces\n-\n-syn region rustMacroRepeat matchgroup=rustMacroRepeatDelimiters start=\"$(\" end=\")\" contains=TOP nextgroup=rustMacroRepeatCount\n-syn match rustMacroRepeatCount \".\\?[*+]\" contained\n-syn match rustMacroVariable \"$\\w\\+\"\n-\n-\" Reserved (but not yet used) keywords {{{2\n-syn keyword   rustReservedKeyword alignof be do offsetof priv pure sizeof typeof unsized yield abstract final override macro\n-\n-\" Built-in types {{{2\n-syn keyword   rustType        isize usize float char bool u8 u16 u32 u64 f32\n-syn keyword   rustType        f64 i8 i16 i32 i64 str Self\n-\n-\" Things from the prelude (src/libstd/prelude.rs) {{{2\n-\" This section is just straight transformation of the contents of the prelude,\n-\" to make it easy to update.\n-\n-\" Reexported core operators {{{3\n-syn keyword   rustTrait       Copy Send Sized Sync\n-syn keyword   rustTrait       Drop Fn FnMut FnOnce\n-\n-\" Reexported functions {{{3\n-syn keyword rustFunction drop\n-\n-\" Reexported types and traits {{{3\n-syn keyword rustTrait Box\n-syn keyword rustTrait CharExt\n-syn keyword rustTrait Clone\n-syn keyword rustTrait PartialEq PartialOrd Eq Ord\n-syn keyword rustTrait DoubleEndedIterator\n-syn keyword rustTrait ExactSizeIterator\n-syn keyword rustTrait Iterator IteratorExt Extend\n-syn keyword rustEnum Option\n-syn keyword rustEnumVariant Some None\n-syn keyword rustTrait PtrExt MutPtrExt\n-syn keyword rustEnum Result\n-syn keyword rustEnumVariant Ok Err\n-syn keyword rustTrait AsSlice\n-syn keyword rustTrait SliceExt SliceConcatExt\n-syn keyword rustTrait Str StrExt\n-syn keyword rustTrait String ToString\n-syn keyword rustTrait Vec\n-\" FIXME: remove when path reform lands\n-syn keyword rustTrait Path GenericPath\n-\" FIXME: remove when I/O reform lands\n-syn keyword rustTrait Buffer Writer Reader Seek BufferPrelude\n-\n-\" Other syntax {{{2\n-syn keyword   rustSelf        self\n-syn keyword   rustBoolean     true false\n-\n-\" If foo::bar changes to foo.bar, change this (\"::\" to \"\\.\").\n-\" If foo::bar changes to Foo::bar, change this (first \"\\w\" to \"\\u\").\n-syn match     rustModPath     \"\\w\\(\\w\\)*::[^<]\"he=e-3,me=e-3\n-syn match     rustModPathSep  \"::\"\n-\n-syn match     rustFuncCall    \"\\w\\(\\w\\)*(\"he=e-1,me=e-1\n-syn match     rustFuncCall    \"\\w\\(\\w\\)*::<\"he=e-3,me=e-3 \" foo::<T>();\n-\n-\" This is merely a convention; note also the use of [A-Z], restricting it to\n-\" latin identifiers rather than the full Unicode uppercase. I have not used\n-\" [:upper:] as it depends upon 'noignorecase'\n-\"syn match     rustCapsIdent    display \"[A-Z]\\w\\(\\w\\)*\"\n-\n-syn match     rustOperator     display \"\\%(+\\|-\\|/\\|*\\|=\\|\\^\\|&\\||\\|!\\|>\\|<\\|%\\)=\\?\"\n-\" This one isn't *quite* right, as we could have binary-& with a reference\n-syn match     rustSigil        display /&\\s\\+[&~@*][^)= \\t\\r\\n]/he=e-1,me=e-1\n-syn match     rustSigil        display /[&~@*][^)= \\t\\r\\n]/he=e-1,me=e-1\n-\" This isn't actually correct; a closure with no arguments can be `|| { }`.\n-\" Last, because the & in && isn't a sigil\n-syn match     rustOperator     display \"&&\\|||\"\n-\n-syn match     rustMacro       '\\w\\(\\w\\)*!' contains=rustAssert,rustPanic\n-syn match     rustMacro       '#\\w\\(\\w\\)*' contains=rustAssert,rustPanic\n-\n-syn match     rustEscapeError   display contained /\\\\./\n-syn match     rustEscape        display contained /\\\\\\([nrt0\\\\'\"]\\|x\\x\\{2}\\)/\n-syn match     rustEscapeUnicode display contained /\\\\\\(u\\x\\{4}\\|U\\x\\{8}\\)/\n-syn match     rustEscapeUnicode display contained /\\\\u{\\x\\{1,6}}/\n-syn match     rustStringContinuation display contained /\\\\\\n\\s*/\n-syn region    rustString      start=+b\"+ skip=+\\\\\\\\\\|\\\\\"+ end=+\"+ contains=rustEscape,rustEscapeError,rustStringContinuation\n-syn region    rustString      start=+\"+ skip=+\\\\\\\\\\|\\\\\"+ end=+\"+ contains=rustEscape,rustEscapeUnicode,rustEscapeError,rustStringContinuation,@Spell\n-syn region    rustString      start='b\\?r\\z(#*\\)\"' end='\"\\z1' contains=@Spell\n-\n-syn region    rustAttribute   start=\"#!\\?\\[\" end=\"\\]\" contains=rustString,rustDerive\n-syn region    rustDerive      start=\"derive(\" end=\")\" contained contains=rustTrait\n-\n-\" Number literals\n-syn match     rustDecNumber   display \"\\<[0-9][0-9_]*\\%([iu]\\%(s\\|8\\|16\\|32\\|64\\)\\)\\=\"\n-syn match     rustHexNumber   display \"\\<0x[a-fA-F0-9_]\\+\\%([iu]\\%(s\\|8\\|16\\|32\\|64\\)\\)\\=\"\n-syn match     rustOctNumber   display \"\\<0o[0-7_]\\+\\%([iu]\\%(s\\|8\\|16\\|32\\|64\\)\\)\\=\"\n-syn match     rustBinNumber   display \"\\<0b[01_]\\+\\%([iu]\\%(s\\|8\\|16\\|32\\|64\\)\\)\\=\"\n-\n-\" Special case for numbers of the form \"1.\" which are float literals, unless followed by\n-\" an identifier, which makes them integer literals with a method call or field access,\n-\" or by another \".\", which makes them integer literals followed by the \"..\" token.\n-\" (This must go first so the others take precedence.)\n-syn match     rustFloat       display \"\\<[0-9][0-9_]*\\.\\%([^[:cntrl:][:space:][:punct:][:digit:]]\\|_\\|\\.\\)\\@!\"\n-\" To mark a number as a normal float, it must have at least one of the three things integral values don't have:\n-\" a decimal point and more numbers; an exponent; and a type suffix.\n-syn match     rustFloat       display \"\\<[0-9][0-9_]*\\%(\\.[0-9][0-9_]*\\)\\%([eE][+-]\\=[0-9_]\\+\\)\\=\\(f32\\|f64\\)\\=\"\n-syn match     rustFloat       display \"\\<[0-9][0-9_]*\\%(\\.[0-9][0-9_]*\\)\\=\\%([eE][+-]\\=[0-9_]\\+\\)\\(f32\\|f64\\)\\=\"\n-syn match     rustFloat       display \"\\<[0-9][0-9_]*\\%(\\.[0-9][0-9_]*\\)\\=\\%([eE][+-]\\=[0-9_]\\+\\)\\=\\(f32\\|f64\\)\"\n-\n-\" For the benefit of delimitMate\n-syn region rustLifetimeCandidate display start=/&'\\%(\\([^'\\\\]\\|\\\\\\(['nrt0\\\\\\\"]\\|x\\x\\{2}\\|u\\x\\{4}\\|U\\x\\{8}\\)\\)'\\)\\@!/ end=/[[:cntrl:][:space:][:punct:]]\\@=\\|$/ contains=rustSigil,rustLifetime\n-syn region rustGenericRegion display start=/<\\%('\\|[^[cntrl:][:space:][:punct:]]\\)\\@=')\\S\\@=/ end=/>/ contains=rustGenericLifetimeCandidate\n-syn region rustGenericLifetimeCandidate display start=/\\%(<\\|,\\s*\\)\\@<='/ end=/[[:cntrl:][:space:][:punct:]]\\@=\\|$/ contains=rustSigil,rustLifetime\n-\n-\"rustLifetime must appear before rustCharacter, or chars will get the lifetime highlighting\n-syn match     rustLifetime    display \"\\'\\%([^[:cntrl:][:space:][:punct:][:digit:]]\\|_\\)\\%([^[:cntrl:][:punct:][:space:]]\\|_\\)*\"\n-syn match   rustCharacterInvalid   display contained /b\\?'\\zs[\\n\\r\\t']\\ze'/\n-\" The groups negated here add up to 0-255 but nothing else (they do not seem to go beyond ASCII).\n-syn match   rustCharacterInvalidUnicode   display contained /b'\\zs[^[:cntrl:][:graph:][:alnum:][:space:]]\\ze'/\n-syn match   rustCharacter   /b'\\([^\\\\]\\|\\\\\\(.\\|x\\x\\{2}\\)\\)'/ contains=rustEscape,rustEscapeError,rustCharacterInvalid,rustCharacterInvalidUnicode\n-syn match   rustCharacter   /'\\([^\\\\]\\|\\\\\\(.\\|x\\x\\{2}\\|u\\x\\{4}\\|U\\x\\{8}\\|u{\\x\\{1,6}}\\)\\)'/ contains=rustEscape,rustEscapeUnicode,rustEscapeError,rustCharacterInvalid\n-\n-syn region rustCommentLine                                        start=\"//\"                      end=\"$\"   contains=rustTodo,@Spell\n-syn region rustCommentLineDoc                                     start=\"//\\%(//\\@!\\|!\\)\"         end=\"$\"   contains=rustTodo,@Spell\n-syn region rustCommentBlock    matchgroup=rustCommentBlock        start=\"/\\*\\%(!\\|\\*[*/]\\@!\\)\\@!\" end=\"\\*/\" contains=rustTodo,rustCommentBlockNest,@Spell\n-syn region rustCommentBlockDoc matchgroup=rustCommentBlockDoc     start=\"/\\*\\%(!\\|\\*[*/]\\@!\\)\"    end=\"\\*/\" contains=rustTodo,rustCommentBlockDocNest,@Spell\n-syn region rustCommentBlockNest matchgroup=rustCommentBlock       start=\"/\\*\"                     end=\"\\*/\" contains=rustTodo,rustCommentBlockNest,@Spell contained transparent\n-syn region rustCommentBlockDocNest matchgroup=rustCommentBlockDoc start=\"/\\*\"                     end=\"\\*/\" contains=rustTodo,rustCommentBlockDocNest,@Spell contained transparent\n-\" FIXME: this is a really ugly and not fully correct implementation. Most\n-\" importantly, a case like ``/* */*`` should have the final ``*`` not being in\n-\" a comment, but in practice at present it leaves comments open two levels\n-\" deep. But as long as you stay away from that particular case, I *believe*\n-\" the highlighting is correct. Due to the way Vim's syntax engine works\n-\" (greedy for start matches, unlike Rust's tokeniser which is searching for\n-\" the earliest-starting match, start or end), I believe this cannot be solved.\n-\" Oh you who would fix it, don't bother with things like duplicating the Block\n-\" rules and putting ``\\*\\@<!`` at the start of them; it makes it worse, as\n-\" then you must deal with cases like ``/*/**/*/``. And don't try making it\n-\" worse with ``\\%(/\\@<!\\*\\)\\@<!``, either...\n-\n-syn keyword rustTodo contained TODO FIXME XXX NB NOTE\n-\n-\" Folding rules {{{2\n-\" Trivial folding rules to begin with.\n-\" FIXME: use the AST to make really good folding\n-syn region rustFoldBraces start=\"{\" end=\"}\" transparent fold\n-\n-\" Default highlighting {{{1\n-hi def link rustDecNumber       rustNumber\n-hi def link rustHexNumber       rustNumber\n-hi def link rustOctNumber       rustNumber\n-hi def link rustBinNumber       rustNumber\n-hi def link rustIdentifierPrime rustIdentifier\n-hi def link rustTrait           rustType\n-\n-hi def link rustMacroRepeatCount   rustMacroRepeatDelimiters\n-hi def link rustMacroRepeatDelimiters   Macro\n-hi def link rustMacroVariable Define\n-hi def link rustSigil         StorageClass\n-hi def link rustEscape        Special\n-hi def link rustEscapeUnicode rustEscape\n-hi def link rustEscapeError   Error\n-hi def link rustStringContinuation Special\n-hi def link rustString        String\n-hi def link rustCharacterInvalid Error\n-hi def link rustCharacterInvalidUnicode rustCharacterInvalid\n-hi def link rustCharacter     Character\n-hi def link rustNumber        Number\n-hi def link rustBoolean       Boolean\n-hi def link rustEnum          rustType\n-hi def link rustEnumVariant   rustConstant\n-hi def link rustConstant      Constant\n-hi def link rustSelf          Constant\n-hi def link rustFloat         Float\n-hi def link rustOperator      Operator\n-hi def link rustKeyword       Keyword\n-hi def link rustReservedKeyword Error\n-hi def link rustConditional   Conditional\n-hi def link rustIdentifier    Identifier\n-hi def link rustCapsIdent     rustIdentifier\n-hi def link rustModPath       Include\n-hi def link rustModPathSep    Delimiter\n-hi def link rustFunction      Function\n-hi def link rustFuncName      Function\n-hi def link rustFuncCall      Function\n-hi def link rustCommentLine   Comment\n-hi def link rustCommentLineDoc SpecialComment\n-hi def link rustCommentBlock  rustCommentLine\n-hi def link rustCommentBlockDoc rustCommentLineDoc\n-hi def link rustAssert        PreCondit\n-hi def link rustPanic         PreCondit\n-hi def link rustMacro         Macro\n-hi def link rustType          Type\n-hi def link rustTodo          Todo\n-hi def link rustAttribute     PreProc\n-hi def link rustDerive        PreProc\n-hi def link rustStorage       StorageClass\n-hi def link rustObsoleteStorage Error\n-hi def link rustLifetime      Special\n-hi def link rustInvalidBareKeyword Error\n-hi def link rustExternCrate   rustKeyword\n-hi def link rustObsoleteExternMod Error\n-hi def link rustBoxPlacementParens Delimiter\n-hi def link rustBoxPlacementExpr rustKeyword\n-\n-\" Other Suggestions:\n-\" hi rustAttribute ctermfg=cyan\n-\" hi rustDerive ctermfg=cyan\n-\" hi rustAssert ctermfg=yellow\n-\" hi rustPanic ctermfg=red\n-\" hi rustMacro ctermfg=magenta\n-\n-syn sync minlines=200\n-syn sync maxlines=500\n-\n-let b:current_syntax = \"rust\""}, {"sha": "5d196086168df91b84be9fa2de07ad878f5ea804", "filename": "src/etc/vim/syntax_checkers/rust/rustc.vim", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1d00c545ede609b9d43fdf9f252c15da5a66dac7/src%2Fetc%2Fvim%2Fsyntax_checkers%2Frust%2Frustc.vim", "raw_url": "https://github.com/rust-lang/rust/raw/1d00c545ede609b9d43fdf9f252c15da5a66dac7/src%2Fetc%2Fvim%2Fsyntax_checkers%2Frust%2Frustc.vim", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvim%2Fsyntax_checkers%2Frust%2Frustc.vim?ref=1d00c545ede609b9d43fdf9f252c15da5a66dac7", "patch": "@@ -1,35 +0,0 @@\n-\" Vim syntastic plugin\n-\" Language:     Rust\n-\" Maintainer:   Andrew Gallant <jamslam@gmail.com>\n-\"\n-\" See for details on how to add an external Syntastic checker:\n-\" https://github.com/scrooloose/syntastic/wiki/Syntax-Checker-Guide#external\n-\n-if exists(\"g:loaded_syntastic_rust_rustc_checker\")\n-    finish\n-endif\n-let g:loaded_syntastic_rust_rustc_checker = 1\n-\n-let s:save_cpo = &cpo\n-set cpo&vim\n-\n-function! SyntaxCheckers_rust_rustc_GetLocList() dict\n-    let makeprg = self.makeprgBuild({ 'args': '-Zparse-only' })\n-\n-    let errorformat  =\n-        \\ '%E%f:%l:%c: %\\d%#:%\\d%# %.%\\{-}error:%.%\\{-} %m,'   .\n-        \\ '%W%f:%l:%c: %\\d%#:%\\d%# %.%\\{-}warning:%.%\\{-} %m,' .\n-        \\ '%C%f:%l %m,' .\n-        \\ '%-Z%.%#'\n-\n-    return SyntasticMake({\n-        \\ 'makeprg': makeprg,\n-        \\ 'errorformat': errorformat })\n-endfunction\n-\n-call g:SyntasticRegistry.CreateAndRegisterChecker({\n-    \\ 'filetype': 'rust',\n-    \\ 'name': 'rustc'})\n-\n-let &cpo = s:save_cpo\n-unlet s:save_cpo"}, {"sha": "404f622f970c37f237bed5fd51a79964889b192b", "filename": "src/etc/zsh/_rust", "status": "removed", "additions": 0, "deletions": 215, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/1d00c545ede609b9d43fdf9f252c15da5a66dac7/src%2Fetc%2Fzsh%2F_rust", "raw_url": "https://github.com/rust-lang/rust/raw/1d00c545ede609b9d43fdf9f252c15da5a66dac7/src%2Fetc%2Fzsh%2F_rust", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fzsh%2F_rust?ref=1d00c545ede609b9d43fdf9f252c15da5a66dac7", "patch": "@@ -1,215 +0,0 @@\n-#compdef rustc\n-\n-local -a _rustc_opts_switches _rustc_opts_lint _rustc_opts_debug\n-\n-typeset -A opt_args\n-\n-_rustc_debuginfo_levels=(\n-    \"0[no debug info]\"\n-    \"1[line-tables only (for stacktraces and breakpoints)]\"\n-    \"2[full debug info with variable and type information (same as -g)]\"\n-)\n-\n-_rustc_crate_types=(\n-    'bin'\n-    'lib'\n-    'rlib'\n-    'dylib'\n-    'staticlib'\n-)\n-\n-_rustc_emit_types=(\n-    'asm'\n-    'llvm-bc'\n-    'llvm-ir'\n-    'obj'\n-    'link'\n-    'dep-info'\n-)\n-_rustc_pretty_types=(\n-    'normal[un-annotated source]'\n-    'expanded[crates expanded]'\n-    'typed[crates  expanded,  with  type  annotations]'\n-    'identified[fully parenthesized, AST nodes and blocks with IDs]'\n-    'flowgraph[graphviz formatted flowgraph for node]:NODEID:'\n-)\n-_rustc_color_types=(\n-    'auto[colorize, if output goes to a tty (default)]'\n-    'always[always colorize output]'\n-    'never[never colorize output]'\n-)\n-_rustc_info_types=(\n-    'crate-name[Output the crate name and exit]'\n-    'file-names[Output the file(s) that would be written if compilation continued and exited]'\n-    'sysroot[Output the sysroot and exit]'\n-)\n-\n-_rustc_opts_vals=(\n-    --crate-name='[Specify the name of the crate being built]'\n-    --crate-type='[Comma separated list of types of crates for the compiler to emit]:TYPES:_values -s \",\" \"Crate types\"  \"$_rustc_crate_types[@]\"'\n-    --emit='[Comma separated list of types of output for the compiler to emit]:TYPES:_values -s \",\" \"Emit Targets\" \"$_rustc_emit_types[@]\"'\n-    --cfg='[Configure the compilation environment]:SPEC:'\n-    --out-dir='[Write output to compiler-chosen filename in <dir>.  Ignored  if  -o  is  specified. (default the current directory)]:DIR:_files -/'\n-    -o'[Write output to <filename>. Ignored if more than one --emit is specified.]:FILENAME:_files'\n-    --pretty='[Pretty-print the input instead of compiling]::TYPE:_values \"TYPES\" \"$_rustc_pretty_types[@]\"'\n-    -L'[Add a directory to the library search path]:DIR:_files -/'\n-    --target='[Target triple cpu-manufacturer-kernel\\[-os\\] to compile]:TRIPLE:'\n-    --color='[Configure coloring of output]:CONF:_values \"COLORS\" \"$_rustc_color_types[@]\"'\n-    {-v,--version}'[Print version info and exit]::VERBOSE:(verbose)'\n-    --explain='[Provide a detailed explanation of an error message]:OPT:'\n-    --extern'[Specify where an external rust library is located]:ARG:'\n-    --print='[Comma separated list of compiler information to print on stdout]:TYPES:_values -s \",\" \"Compiler Information\" \"$_rustc_info_types[@]\"'\n-)\n-\n-_rustc_opts_switches=(\n-    -g'[Equivalent to -C debuginfo=2]'\n-    {-h,--help}'[Display the help message]'\n-    {-V,--verbose}'[use verbose output]'\n-    -O'[Equivalent to -C opt-level=2]'\n-    --test'[Build a test harness]'\n-)\n-\n-\n-_rustc_opts_link=(\n-    'static[Path to the library to link statically]:PATH:_files -/'\n-    'dylib[Path to the library to link dynamically]:PATH:_files -/'\n-    'framework[Path to the library to link as a framework]:PATH:_files -/'\n-)\n-\n-_rustc_opts_codegen=(\n-    'ar[Path to the archive utility to use when assembling archives.]:BIN:_path_files'\n-    'linker[Path to the linker utility to use when linking libraries, executables, and objects.]:BIN:_path_files'\n-    'link-args[A space-separated list of extra arguments to pass to the linker when the linker is invoked.]:ARGS:'\n-    'lto[Perform LLVM link-time optimizations]'\n-    'target-cpu[Selects a target processor. If the value is \"help\", then a list of  available  CPUs is printed.]:CPU:'\n-    'target-feature[A space-separated list of features to enable or disable for the target. A preceding \"+\" enables a feature while a preceding \"-\" disables it. Available features can be discovered through target-cpu=help.]:FEATURE:'\n-    'passes[A space-separated list of extra LLVM passes to run. A value of \"list\" will cause rustc to print all known passes and exit. The passes specified are appended at the end of the normal pass manager.]:LIST:'\n-    'llvm-args[A space-separated list of arguments to pass through to LLVM.]:ARGS:'\n-    'save-temps[If specified, the compiler will save more files (.bc, .o, .no-opt.bc) generated throughout compilation in the output directory.]'\n-    'rpath[If specified, then the rpath value for dynamic libraries will be set in either dynamic library or executable outputs.]'\n-    'no-prepopulate-passes[Suppresses pre-population of the LLVM pass manager that is run over the module.]'\n-    'no-vectorize-loops[Suppresses running the loop vectorization LLVM pass, regardless of optimization level.]'\n-    'no-vectorize-slp[Suppresses running the LLVM SLP vectorization pass, regardless of optimization level.]'\n-    'soft-float[Generates software floating point library calls instead of hardware instructions.]'\n-    'prefer-dynamic[Prefers dynamic linking to static linking.]'\n-    \"no-integrated-as[Force usage of an external assembler rather than LLVM's integrated one.]\"\n-    'no-redzone[disable the use of the redzone]'\n-    'relocation-model[The relocation model to use. (default: pic)]:MODEL:(pic static dynamic-no-pic)'\n-    'code-model[choose the code model to use (llc -code-model for details)]:MODEL:'\n-    'metadata[metadata to mangle symbol names with]:VAL:'\n-    'extra-filenames[extra data to put in each output filename]:VAL:'\n-    'codegen-units[divide crate into N units to optimize in parallel]:N:'\n-    'remark[print remarks for these optimization passes (space separated, or \"all\")]:TYPE:'\n-    'debuginfo[debug info emission level, 0 = no debug info, 1 = line tables only, 2 = full debug info with variable and type information]:LEVEL:_values \"Debug Levels\" \"$_rustc_debuginfo_levels[@]\"'\n-    'opt-level[Optimize with possible levels 0-3]:LEVEL:(0 1 2 3)'\n-    'help[Show all codegen options]'\n-)\n-\n-_rustc_opts_lint=(\n-    'help[Show a list of all lints]'\n-    'box-pointers[(default: allow) use of owned (Box type) heap memory]'\n-    'experimental[(default: allow) detects use of #\\[experimental\\] items]'\n-    'fat-ptr-transmutes[(default: allow) detects transmutes of fat pointers]'\n-    'missing-docs[(default: allow) detects missing documentation for public members]'\n-    'unsafe-blocks[(default: allow) usage of an \"unsafe\" block]'\n-    'unstable[(default: allow) detects use of #\\[unstable\\] items (incl. items with no stability attribute)]'\n-    'unused-extern-crates[(default: allow) extern crates that are never used]'\n-    'unused-import-braces[(default: allow) unnecessary braces around an imported item]'\n-    'unused-qualifications[(default: allow) detects unnecessarily qualified names]'\n-    'unused-results[(default: allow) unused result of an expression in a statement]'\n-    'unused-typecasts[(default: allow) detects unnecessary type casts that can be removed]'\n-    'variant-size-differences[(default: allow) detects enums with widely varying variant sizes]'\n-    'dead-code[(default: warn) detect unused, unexported items]'\n-    'deprecated[(default: warn) detects use of #\\[deprecated\\] items]'\n-    'improper-ctypes[(default: warn) proper use of libc types in foreign modules]'\n-    'missing-copy-implementations[(default: warn) detects potentially-forgotten implementations of \"Copy\"]'\n-    'non-camel-case-types[(default: warn) types, variants, traits and type parameters should have camel case names]'\n-    'non-shorthand-field-patterns[(default: warn) using \"Struct { x: x }\" instead of \"Struct { x }\"]'\n-    'non-snake-case[(default: warn) methods, functions, lifetime parameters and modules should have snake case names]'\n-    'non-upper-case-globals[(default: warn) static constants should have uppercase identifiers]'\n-    'overflowing-literals[(default: warn) literal out of range for its type]'\n-    'path-statements[(default: warn) path statements with no effect]'\n-    'raw-pointer-deriving[(default: warn) uses of #\\[derive\\] with raw pointers are rarely correct]'\n-    'unknown-lints[(default: warn) unrecognized lint attribute]'\n-    'unreachable-code[(default: warn) detects unreachable code paths]'\n-    'unsigned-negation[(default: warn) using an unary minus operator on unsigned type]'\n-    'unused-allocation[(default: warn) detects unnecessary allocations that can be eliminated]'\n-    'unused-assignments[(default: warn) detect assignments that will never be read]'\n-    'unused-attributes[(default: warn) detects attributes that were not used by the compiler]'\n-    'unused-comparisons[(default: warn) comparisons made useless by limits of the types involved]'\n-    'unused-imports[(default: warn) imports that are never used]'\n-    'unused-must-use[(default: warn) unused result of a type flagged as must_use]'\n-    \"unused-mut[(default: warn) detect mut variables which don't need to be mutable]\"\n-    'unused-parens[(default: warn) \"if\", \"match\", \"while\" and \"return\" do not need parentheses]'\n-    'unused-unsafe[(default: warn) unnecessary use of an \"unsafe\" block]'\n-    'unused-variables[(default: warn) detect variables which are not used in any way]'\n-    'warnings[(default: warn) mass-change the level for lints which produce warnings]'\n-    'while-true[(default: warn) suggest using \"loop { }\" instead of \"while true { }\"]'\n-    \"exceeding-bitshifts[(default: deny) shift exceeds the type's number of bits]\"\n-    'unknown-crate-types[(default: deny) unknown crate type found in #\\[crate_type\\] directive]'\n-    'unknown-features[(default: deny) unknown features found in crate-level #\\[feature\\] directives]'\n-    'bad-style[non-camel-case-types, non-snake-case, non-upper-case-globals]'\n-    'unused[unused-imports, unused-variables, unused-assignments, dead-code, unused-mut, unreachable-code, unused-must-use, unused-unsafe, path-statements]'\n-)\n-\n-_rustc_opts_debug=(\n-    'verbose[in general, enable more debug printouts]'\n-    'time-passes[measure time of each rustc pass]'\n-    'count-llvm-insns[count where LLVM instrs originate]'\n-    'time-llvm-passes[measure time of each LLVM pass]'\n-    'trans-stats[gather trans statistics]'\n-    'asm-comments[generate comments into the assembly (may change behavior)]'\n-    'no-verify[skip LLVM verification]'\n-    'borrowck-stats[gather borrowck statistics]'\n-    'no-landing-pads[omit landing pads for unwinding]'\n-    'debug-llvm[enable debug output from LLVM]'\n-    'show-span[show spans for compiler debugging]'\n-    'count-type-sizes[count the sizes of aggregate types]'\n-    'meta-stats[gather metadata statistics]'\n-    'print-link-args[Print the arguments passed to the linker]'\n-    'gc[Garbage collect shared data (experimental)]'\n-    'print-llvm-passes[Prints the llvm optimization passes being run]'\n-    'ast-json[Print the AST as JSON and halt]'\n-    'ast-json-noexpand[Print the pre-expansion AST as JSON and halt]'\n-    'ls[List the symbols defined by a library crate]'\n-    'save-analysis[Write syntax and type analysis information in addition to normal output]'\n-    'flowgraph-print-loans[Include loan analysis data in --pretty flowgraph output]'\n-    'flowgraph-print-moves[Include move analysis data in --pretty flowgraph output]'\n-    'flowgraph-print-assigns[Include assignment analysis data in --pretty flowgraph output]'\n-    'flowgraph-print-all[Include all dataflow analysis data in --pretty flowgraph output]'\n-    'print-regiion-graph[Prints region inference graph. Use with RUST_REGION_GRAPH=help for more info]'\n-    'parse-only[Parse only; do not compile, assemble, or link]'\n-    'no-trans[Run all passes except translation; no output]'\n-    'no-analysis[Parse and expand the source, but run no analysis]'\n-    'unstable-options[Adds unstable command line options to rustc interface]'\n-    'print-enum-sizes[Print the size of enums and their variants]'\n-)\n-\n-_rustc_opts_fun_lint(){\n-    _values -s , 'options' \\\n-        \"$_rustc_opts_lint[@]\"\n-}\n-\n-_rustc_opts_fun_debug(){\n-    _values 'options' \"$_rustc_opts_debug[@]\"\n-}\n-\n-_rustc_opts_fun_codegen(){\n-    _values 'options' \"$_rustc_opts_codegen[@]\"\n-}\n-\n-_rustc_opts_fun_link(){\n-    _values 'options' \"$_rustc_opts_link[@]\"\n-}\n-\n-_arguments -s :  \\\n-    '(-W --warn)'{-W,--warn=}'[Set lint warnings]:lint options:_rustc_opts_fun_lint' \\\n-    '(-A --allow)'{-A,--allow=}'[Set lint allowed]:lint options:_rustc_opts_fun_lint' \\\n-    '(-D --deny)'{-D,--deny=}'[Set lint denied]:lint options:_rustc_opts_fun_lint' \\\n-    '(-F --forbid)'{-F,--forbid=}'[Set lint forbidden]:lint options:_rustc_opts_fun_lint' \\\n-    '*-Z[Set internal debugging options]:debug options:_rustc_opts_fun_debug' \\\n-    '(-C --codegen)'{-C,--codegen}'[Set internal Codegen options]:codegen options:_rustc_opts_fun_codegen' \\\n-    '*-l[Link the generated crates to the specified native library NAME. the optional KIND can be one of, static, dylib, or framework. If omitted, dylib is assumed.]:ARG:_rustc_opts_fun_link' \\\n-    \"$_rustc_opts_switches[@]\" \\\n-    \"$_rustc_opts_vals[@]\" \\\n-    '::files:_files -g \"*.rs\"'"}, {"sha": "4818e4abaf2a9e217772a28e8eec3d038ce1c631", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 44, "deletions": 41, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -12,20 +12,22 @@\n \n //! Threadsafe reference-counted boxes (the `Arc<T>` type).\n //!\n-//! The `Arc<T>` type provides shared ownership of an immutable value. Destruction is\n-//! deterministic, and will occur as soon as the last owner is gone. It is marked as `Send` because\n-//! it uses atomic reference counting.\n+//! The `Arc<T>` type provides shared ownership of an immutable value.\n+//! Destruction is deterministic, and will occur as soon as the last owner is\n+//! gone. It is marked as `Send` because it uses atomic reference counting.\n //!\n-//! If you do not need thread-safety, and just need shared ownership, consider the [`Rc<T>`\n-//! type](../rc/struct.Rc.html). It is the same as `Arc<T>`, but does not use atomics, making it\n-//! both thread-unsafe as well as significantly faster when updating the reference count.\n+//! If you do not need thread-safety, and just need shared ownership, consider\n+//! the [`Rc<T>` type](../rc/struct.Rc.html). It is the same as `Arc<T>`, but\n+//! does not use atomics, making it both thread-unsafe as well as significantly\n+//! faster when updating the reference count.\n //!\n-//! The `downgrade` method can be used to create a non-owning `Weak<T>` pointer to the box. A\n-//! `Weak<T>` pointer can be upgraded to an `Arc<T>` pointer, but will return `None` if the value\n-//! has already been dropped.\n+//! The `downgrade` method can be used to create a non-owning `Weak<T>` pointer\n+//! to the box. A `Weak<T>` pointer can be upgraded to an `Arc<T>` pointer, but\n+//! will return `None` if the value has already been dropped.\n //!\n-//! For example, a tree with parent pointers can be represented by putting the nodes behind strong\n-//! `Arc<T>` pointers, and then storing the parent pointers as `Weak<T>` pointers.\n+//! For example, a tree with parent pointers can be represented by putting the\n+//! nodes behind strong `Arc<T>` pointers, and then storing the parent pointers\n+//! as `Weak<T>` pointers.\n //!\n //! # Examples\n //!\n@@ -35,7 +37,7 @@\n //! use std::sync::Arc;\n //! use std::thread::Thread;\n //!\n-//! let five = Arc::new(5i);\n+//! let five = Arc::new(5);\n //!\n //! for _ in 0u..10 {\n //!     let five = five.clone();\n@@ -52,7 +54,7 @@\n //! use std::sync::{Arc, Mutex};\n //! use std::thread::Thread;\n //!\n-//! let five = Arc::new(Mutex::new(5i));\n+//! let five = Arc::new(Mutex::new(5));\n //!\n //! for _ in 0u..10 {\n //!     let five = five.clone();\n@@ -87,8 +89,9 @@ use heap::deallocate;\n ///\n /// # Example\n ///\n-/// In this example, a large vector of floats is shared between several tasks. With simple pipes,\n-/// without `Arc`, a copy would have to be made for each task.\n+/// In this example, a large vector of floats is shared between several tasks.\n+/// With simple pipes, without `Arc`, a copy would have to be made for each\n+/// task.\n ///\n /// ```rust\n /// use std::sync::Arc;\n@@ -154,7 +157,7 @@ impl<T> Arc<T> {\n     /// ```\n     /// use std::sync::Arc;\n     ///\n-    /// let five = Arc::new(5i);\n+    /// let five = Arc::new(5);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -176,7 +179,7 @@ impl<T> Arc<T> {\n     /// ```\n     /// use std::sync::Arc;\n     ///\n-    /// let five = Arc::new(5i);\n+    /// let five = Arc::new(5);\n     ///\n     /// let weak_five = five.downgrade();\n     /// ```\n@@ -221,7 +224,7 @@ impl<T> Clone for Arc<T> {\n     /// ```\n     /// use std::sync::Arc;\n     ///\n-    /// let five = Arc::new(5i);\n+    /// let five = Arc::new(5);\n     ///\n     /// five.clone();\n     /// ```\n@@ -268,7 +271,7 @@ impl<T: Send + Sync + Clone> Arc<T> {\n     /// ```\n     /// use std::sync::Arc;\n     ///\n-    /// let mut five = Arc::new(5i);\n+    /// let mut five = Arc::new(5);\n     ///\n     /// let mut_five = five.make_unique();\n     /// ```\n@@ -304,14 +307,14 @@ impl<T: Sync + Send> Drop for Arc<T> {\n     /// use std::sync::Arc;\n     ///\n     /// {\n-    ///     let five = Arc::new(5i);\n+    ///     let five = Arc::new(5);\n     ///\n     ///     // stuff\n     ///\n     ///     drop(five); // explict drop\n     /// }\n     /// {\n-    ///     let five = Arc::new(5i);\n+    ///     let five = Arc::new(5);\n     ///\n     ///     // stuff\n     ///\n@@ -371,7 +374,7 @@ impl<T: Sync + Send> Weak<T> {\n     /// ```\n     /// use std::sync::Arc;\n     ///\n-    /// let five = Arc::new(5i);\n+    /// let five = Arc::new(5);\n     ///\n     /// let weak_five = five.downgrade();\n     ///\n@@ -408,7 +411,7 @@ impl<T: Sync + Send> Clone for Weak<T> {\n     /// ```\n     /// use std::sync::Arc;\n     ///\n-    /// let weak_five = Arc::new(5i).downgrade();\n+    /// let weak_five = Arc::new(5).downgrade();\n     ///\n     /// weak_five.clone();\n     /// ```\n@@ -433,15 +436,15 @@ impl<T: Sync + Send> Drop for Weak<T> {\n     /// use std::sync::Arc;\n     ///\n     /// {\n-    ///     let five = Arc::new(5i);\n+    ///     let five = Arc::new(5);\n     ///     let weak_five = five.downgrade();\n     ///\n     ///     // stuff\n     ///\n     ///     drop(weak_five); // explict drop\n     /// }\n     /// {\n-    ///     let five = Arc::new(5i);\n+    ///     let five = Arc::new(5);\n     ///     let weak_five = five.downgrade();\n     ///\n     ///     // stuff\n@@ -475,9 +478,9 @@ impl<T: PartialEq> PartialEq for Arc<T> {\n     /// ```\n     /// use std::sync::Arc;\n     ///\n-    /// let five = Arc::new(5i);\n+    /// let five = Arc::new(5);\n     ///\n-    /// five == Arc::new(5i);\n+    /// five == Arc::new(5);\n     /// ```\n     fn eq(&self, other: &Arc<T>) -> bool { *(*self) == *(*other) }\n \n@@ -490,9 +493,9 @@ impl<T: PartialEq> PartialEq for Arc<T> {\n     /// ```\n     /// use std::sync::Arc;\n     ///\n-    /// let five = Arc::new(5i);\n+    /// let five = Arc::new(5);\n     ///\n-    /// five != Arc::new(5i);\n+    /// five != Arc::new(5);\n     /// ```\n     fn ne(&self, other: &Arc<T>) -> bool { *(*self) != *(*other) }\n }\n@@ -507,9 +510,9 @@ impl<T: PartialOrd> PartialOrd for Arc<T> {\n     /// ```\n     /// use std::sync::Arc;\n     ///\n-    /// let five = Arc::new(5i);\n+    /// let five = Arc::new(5);\n     ///\n-    /// five.partial_cmp(&Arc::new(5i));\n+    /// five.partial_cmp(&Arc::new(5));\n     /// ```\n     fn partial_cmp(&self, other: &Arc<T>) -> Option<Ordering> {\n         (**self).partial_cmp(&**other)\n@@ -524,9 +527,9 @@ impl<T: PartialOrd> PartialOrd for Arc<T> {\n     /// ```\n     /// use std::sync::Arc;\n     ///\n-    /// let five = Arc::new(5i);\n+    /// let five = Arc::new(5);\n     ///\n-    /// five < Arc::new(5i);\n+    /// five < Arc::new(5);\n     /// ```\n     fn lt(&self, other: &Arc<T>) -> bool { *(*self) < *(*other) }\n \n@@ -539,9 +542,9 @@ impl<T: PartialOrd> PartialOrd for Arc<T> {\n     /// ```\n     /// use std::sync::Arc;\n     ///\n-    /// let five = Arc::new(5i);\n+    /// let five = Arc::new(5);\n     ///\n-    /// five <= Arc::new(5i);\n+    /// five <= Arc::new(5);\n     /// ```\n     fn le(&self, other: &Arc<T>) -> bool { *(*self) <= *(*other) }\n \n@@ -554,9 +557,9 @@ impl<T: PartialOrd> PartialOrd for Arc<T> {\n     /// ```\n     /// use std::sync::Arc;\n     ///\n-    /// let five = Arc::new(5i);\n+    /// let five = Arc::new(5);\n     ///\n-    /// five > Arc::new(5i);\n+    /// five > Arc::new(5);\n     /// ```\n     fn gt(&self, other: &Arc<T>) -> bool { *(*self) > *(*other) }\n \n@@ -569,9 +572,9 @@ impl<T: PartialOrd> PartialOrd for Arc<T> {\n     /// ```\n     /// use std::sync::Arc;\n     ///\n-    /// let five = Arc::new(5i);\n+    /// let five = Arc::new(5);\n     ///\n-    /// five >= Arc::new(5i);\n+    /// five >= Arc::new(5);\n     /// ```\n     fn ge(&self, other: &Arc<T>) -> bool { *(*self) >= *(*other) }\n }\n@@ -719,14 +722,14 @@ mod tests {\n \n     #[test]\n     fn test_live() {\n-        let x = Arc::new(5i);\n+        let x = Arc::new(5);\n         let y = x.downgrade();\n         assert!(y.upgrade().is_some());\n     }\n \n     #[test]\n     fn test_dead() {\n-        let x = Arc::new(5i);\n+        let x = Arc::new(5);\n         let y = x.downgrade();\n         drop(x);\n         assert!(y.upgrade().is_none());"}, {"sha": "4ffb94e7a6106b60d111299a613891b86d0fd3ad", "filename": "src/liballoc/boxed_test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Fliballoc%2Fboxed_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Fliballoc%2Fboxed_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed_test.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -20,7 +20,7 @@ use std::boxed::BoxAny;\n \n #[test]\n fn test_owned_clone() {\n-    let a = Box::new(5i);\n+    let a = Box::new(5);\n     let b: Box<int> = a.clone();\n     assert!(a == b);\n }"}, {"sha": "1d5637a6ad6b34c351e9e7e1874d7d92f557f261", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -403,7 +403,7 @@ mod test {\n     #[bench]\n     fn alloc_owned_small(b: &mut Bencher) {\n         b.iter(|| {\n-            box 10i\n+            box 10\n         })\n     }\n }"}, {"sha": "99423349020393721ac3b32c6d7de92ec7e85dc9", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -66,12 +66,11 @@\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n #![no_std]\n-#![allow(unknown_features)]\n #![feature(lang_items, unsafe_destructor)]\n #![feature(box_syntax)]\n #![feature(optin_builtin_traits)]\n+#![feature(int_uint)]\n #![feature(unboxed_closures)]\n-#![allow(unknown_features)] #![feature(int_uint)]\n #![feature(core)]\n #![feature(hash)]\n #![feature(libc)]"}, {"sha": "8a542e1b8cbdb5716c73fbfdf713b02aee0b65f2", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -192,7 +192,7 @@ impl<T> Rc<T> {\n     /// ```\n     /// use std::rc::Rc;\n     ///\n-    /// let five = Rc::new(5i);\n+    /// let five = Rc::new(5);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(value: T) -> Rc<T> {\n@@ -217,7 +217,7 @@ impl<T> Rc<T> {\n     /// ```\n     /// use std::rc::Rc;\n     ///\n-    /// let five = Rc::new(5i);\n+    /// let five = Rc::new(5);\n     ///\n     /// let weak_five = five.downgrade();\n     /// ```\n@@ -247,7 +247,7 @@ pub fn strong_count<T>(this: &Rc<T>) -> uint { this.strong() }\n /// use std::rc;\n /// use std::rc::Rc;\n ///\n-/// let five = Rc::new(5i);\n+/// let five = Rc::new(5);\n ///\n /// rc::is_unique(&five);\n /// ```\n@@ -329,7 +329,7 @@ impl<T: Clone> Rc<T> {\n     /// ```\n     /// use std::rc::Rc;\n     ///\n-    /// let mut five = Rc::new(5i);\n+    /// let mut five = Rc::new(5);\n     ///\n     /// let mut_five = five.make_unique();\n     /// ```\n@@ -378,14 +378,14 @@ impl<T> Drop for Rc<T> {\n     /// use std::rc::Rc;\n     ///\n     /// {\n-    ///     let five = Rc::new(5i);\n+    ///     let five = Rc::new(5);\n     ///\n     ///     // stuff\n     ///\n     ///     drop(five); // explict drop\n     /// }\n     /// {\n-    ///     let five = Rc::new(5i);\n+    ///     let five = Rc::new(5);\n     ///\n     ///     // stuff\n     ///\n@@ -425,7 +425,7 @@ impl<T> Clone for Rc<T> {\n     /// ```\n     /// use std::rc::Rc;\n     ///\n-    /// let five = Rc::new(5i);\n+    /// let five = Rc::new(5);\n     ///\n     /// five.clone();\n     /// ```\n@@ -466,9 +466,9 @@ impl<T: PartialEq> PartialEq for Rc<T> {\n     /// ```\n     /// use std::rc::Rc;\n     ///\n-    /// let five = Rc::new(5i);\n+    /// let five = Rc::new(5);\n     ///\n-    /// five == Rc::new(5i);\n+    /// five == Rc::new(5);\n     /// ```\n     #[inline(always)]\n     fn eq(&self, other: &Rc<T>) -> bool { **self == **other }\n@@ -482,9 +482,9 @@ impl<T: PartialEq> PartialEq for Rc<T> {\n     /// ```\n     /// use std::rc::Rc;\n     ///\n-    /// let five = Rc::new(5i);\n+    /// let five = Rc::new(5);\n     ///\n-    /// five != Rc::new(5i);\n+    /// five != Rc::new(5);\n     /// ```\n     #[inline(always)]\n     fn ne(&self, other: &Rc<T>) -> bool { **self != **other }\n@@ -504,9 +504,9 @@ impl<T: PartialOrd> PartialOrd for Rc<T> {\n     /// ```\n     /// use std::rc::Rc;\n     ///\n-    /// let five = Rc::new(5i);\n+    /// let five = Rc::new(5);\n     ///\n-    /// five.partial_cmp(&Rc::new(5i));\n+    /// five.partial_cmp(&Rc::new(5));\n     /// ```\n     #[inline(always)]\n     fn partial_cmp(&self, other: &Rc<T>) -> Option<Ordering> {\n@@ -522,9 +522,9 @@ impl<T: PartialOrd> PartialOrd for Rc<T> {\n     /// ```\n     /// use std::rc::Rc;\n     ///\n-    /// let five = Rc::new(5i);\n+    /// let five = Rc::new(5);\n     ///\n-    /// five < Rc::new(5i);\n+    /// five < Rc::new(5);\n     /// ```\n     #[inline(always)]\n     fn lt(&self, other: &Rc<T>) -> bool { **self < **other }\n@@ -538,9 +538,9 @@ impl<T: PartialOrd> PartialOrd for Rc<T> {\n     /// ```\n     /// use std::rc::Rc;\n     ///\n-    /// let five = Rc::new(5i);\n+    /// let five = Rc::new(5);\n     ///\n-    /// five <= Rc::new(5i);\n+    /// five <= Rc::new(5);\n     /// ```\n     #[inline(always)]\n     fn le(&self, other: &Rc<T>) -> bool { **self <= **other }\n@@ -554,9 +554,9 @@ impl<T: PartialOrd> PartialOrd for Rc<T> {\n     /// ```\n     /// use std::rc::Rc;\n     ///\n-    /// let five = Rc::new(5i);\n+    /// let five = Rc::new(5);\n     ///\n-    /// five > Rc::new(5i);\n+    /// five > Rc::new(5);\n     /// ```\n     #[inline(always)]\n     fn gt(&self, other: &Rc<T>) -> bool { **self > **other }\n@@ -570,9 +570,9 @@ impl<T: PartialOrd> PartialOrd for Rc<T> {\n     /// ```\n     /// use std::rc::Rc;\n     ///\n-    /// let five = Rc::new(5i);\n+    /// let five = Rc::new(5);\n     ///\n-    /// five >= Rc::new(5i);\n+    /// five >= Rc::new(5);\n     /// ```\n     #[inline(always)]\n     fn ge(&self, other: &Rc<T>) -> bool { **self >= **other }\n@@ -589,9 +589,9 @@ impl<T: Ord> Ord for Rc<T> {\n     /// ```\n     /// use std::rc::Rc;\n     ///\n-    /// let five = Rc::new(5i);\n+    /// let five = Rc::new(5);\n     ///\n-    /// five.partial_cmp(&Rc::new(5i));\n+    /// five.partial_cmp(&Rc::new(5));\n     /// ```\n     #[inline]\n     fn cmp(&self, other: &Rc<T>) -> Ordering { (**self).cmp(&**other) }\n@@ -653,7 +653,7 @@ impl<T> Weak<T> {\n     /// ```\n     /// use std::rc::Rc;\n     ///\n-    /// let five = Rc::new(5i);\n+    /// let five = Rc::new(5);\n     ///\n     /// let weak_five = five.downgrade();\n     ///\n@@ -682,15 +682,15 @@ impl<T> Drop for Weak<T> {\n     /// use std::rc::Rc;\n     ///\n     /// {\n-    ///     let five = Rc::new(5i);\n+    ///     let five = Rc::new(5);\n     ///     let weak_five = five.downgrade();\n     ///\n     ///     // stuff\n     ///\n     ///     drop(weak_five); // explict drop\n     /// }\n     /// {\n-    ///     let five = Rc::new(5i);\n+    ///     let five = Rc::new(5);\n     ///     let weak_five = five.downgrade();\n     ///\n     ///     // stuff\n@@ -726,7 +726,7 @@ impl<T> Clone for Weak<T> {\n     /// ```\n     /// use std::rc::Rc;\n     ///\n-    /// let weak_five = Rc::new(5i).downgrade();\n+    /// let weak_five = Rc::new(5).downgrade();\n     ///\n     /// weak_five.clone();\n     /// ```\n@@ -789,42 +789,42 @@ mod tests {\n \n     #[test]\n     fn test_clone() {\n-        let x = Rc::new(RefCell::new(5i));\n+        let x = Rc::new(RefCell::new(5));\n         let y = x.clone();\n         *x.borrow_mut() = 20;\n         assert_eq!(*y.borrow(), 20);\n     }\n \n     #[test]\n     fn test_simple() {\n-        let x = Rc::new(5i);\n+        let x = Rc::new(5);\n         assert_eq!(*x, 5);\n     }\n \n     #[test]\n     fn test_simple_clone() {\n-        let x = Rc::new(5i);\n+        let x = Rc::new(5);\n         let y = x.clone();\n         assert_eq!(*x, 5);\n         assert_eq!(*y, 5);\n     }\n \n     #[test]\n     fn test_destructor() {\n-        let x = Rc::new(box 5i);\n+        let x = Rc::new(box 5);\n         assert_eq!(**x, 5);\n     }\n \n     #[test]\n     fn test_live() {\n-        let x = Rc::new(5i);\n+        let x = Rc::new(5);\n         let y = x.downgrade();\n         assert!(y.upgrade().is_some());\n     }\n \n     #[test]\n     fn test_dead() {\n-        let x = Rc::new(5i);\n+        let x = Rc::new(5);\n         let y = x.downgrade();\n         drop(x);\n         assert!(y.upgrade().is_none());"}, {"sha": "5ada51976ac9608fd565f5782adfb932f6044a8b", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -21,24 +21,21 @@\n \n #![crate_name = \"arena\"]\n #![unstable(feature = \"rustc_private\")]\n-#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n-#![allow(unknown_features)]\n-#![feature(unsafe_destructor)]\n-#![feature(unboxed_closures)]\n-#![feature(box_syntax)]\n-#![allow(unknown_features)] #![feature(int_uint)]\n-#![allow(missing_docs)]\n #![feature(alloc)]\n+#![feature(box_syntax)]\n #![feature(core)]\n+#![feature(int_uint)]\n+#![feature(staged_api)]\n+#![feature(unboxed_closures)]\n+#![feature(unsafe_destructor)]\n #![cfg_attr(test, feature(test))]\n-#![cfg_attr(test, feature(collections))]\n \n extern crate alloc;\n "}, {"sha": "8aa4c77f6f9cf299a2bb2435660166259c943309", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 55, "deletions": 39, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -153,7 +153,7 @@\n use core::prelude::*;\n \n use core::default::Default;\n-use core::iter::FromIterator;\n+use core::iter::{FromIterator, IntoIterator};\n use core::mem::{zeroed, replace, swap};\n use core::ptr;\n \n@@ -212,7 +212,7 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n-    /// let heap = BinaryHeap::from_vec(vec![9i, 1, 2, 7, 3, 2]);\n+    /// let heap = BinaryHeap::from_vec(vec![9, 1, 2, 7, 3, 2]);\n     /// ```\n     pub fn from_vec(vec: Vec<T>) -> BinaryHeap<T> {\n         let mut heap = BinaryHeap { data: vec };\n@@ -231,7 +231,7 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n-    /// let heap = BinaryHeap::from_vec(vec![1i, 2, 3, 4]);\n+    /// let heap = BinaryHeap::from_vec(vec![1, 2, 3, 4]);\n     ///\n     /// // Print 1, 2, 3, 4 in arbitrary order\n     /// for x in heap.iter() {\n@@ -251,7 +251,7 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n-    /// let heap = BinaryHeap::from_vec(vec![1i, 2, 3, 4]);\n+    /// let heap = BinaryHeap::from_vec(vec![1, 2, 3, 4]);\n     ///\n     /// // Print 1, 2, 3, 4 in arbitrary order\n     /// for x in heap.into_iter() {\n@@ -273,7 +273,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// let mut heap = BinaryHeap::new();\n     /// assert_eq!(heap.peek(), None);\n     ///\n-    /// heap.push(1i);\n+    /// heap.push(1);\n     /// heap.push(5);\n     /// heap.push(2);\n     /// assert_eq!(heap.peek(), Some(&5));\n@@ -356,7 +356,7 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n-    /// let mut heap = BinaryHeap::from_vec(vec![1i, 3]);\n+    /// let mut heap = BinaryHeap::from_vec(vec![1, 3]);\n     ///\n     /// assert_eq!(heap.pop(), Some(3));\n     /// assert_eq!(heap.pop(), Some(1));\n@@ -380,7 +380,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// ```\n     /// use std::collections::BinaryHeap;\n     /// let mut heap = BinaryHeap::new();\n-    /// heap.push(3i);\n+    /// heap.push(3);\n     /// heap.push(5);\n     /// heap.push(1);\n     ///\n@@ -402,7 +402,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// ```\n     /// use std::collections::BinaryHeap;\n     /// let mut heap = BinaryHeap::new();\n-    /// heap.push(1i);\n+    /// heap.push(1);\n     /// heap.push(5);\n     ///\n     /// assert_eq!(heap.push_pop(3), 5);\n@@ -434,7 +434,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// use std::collections::BinaryHeap;\n     /// let mut heap = BinaryHeap::new();\n     ///\n-    /// assert_eq!(heap.replace(1i), None);\n+    /// assert_eq!(heap.replace(1), None);\n     /// assert_eq!(heap.replace(3), Some(1));\n     /// assert_eq!(heap.len(), 1);\n     /// assert_eq!(heap.peek(), Some(&3));\n@@ -457,7 +457,7 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n-    /// let heap = BinaryHeap::from_vec(vec![1i, 2, 3, 4, 5, 6, 7]);\n+    /// let heap = BinaryHeap::from_vec(vec![1, 2, 3, 4, 5, 6, 7]);\n     /// let vec = heap.into_vec();\n     ///\n     /// // Will print in some order\n@@ -475,12 +475,12 @@ impl<T: Ord> BinaryHeap<T> {\n     /// ```\n     /// use std::collections::BinaryHeap;\n     ///\n-    /// let mut heap = BinaryHeap::from_vec(vec![1i, 2, 4, 5, 7]);\n+    /// let mut heap = BinaryHeap::from_vec(vec![1, 2, 4, 5, 7]);\n     /// heap.push(6);\n     /// heap.push(3);\n     ///\n     /// let vec = heap.into_sorted_vec();\n-    /// assert_eq!(vec, vec![1i, 2, 3, 4, 5, 6, 7]);\n+    /// assert_eq!(vec, vec![1, 2, 3, 4, 5, 6, 7]);\n     /// ```\n     pub fn into_sorted_vec(mut self) -> Vec<T> {\n         let mut end = self.len();\n@@ -655,6 +655,22 @@ impl<T: Ord> FromIterator<T> for BinaryHeap<T> {\n     }\n }\n \n+impl<T: Ord> IntoIterator for BinaryHeap<T> {\n+    type Iter = IntoIter<T>;\n+\n+    fn into_iter(self) -> IntoIter<T> {\n+        self.into_iter()\n+    }\n+}\n+\n+impl<'a, T> IntoIterator for &'a BinaryHeap<T> where T: Ord {\n+    type Iter = Iter<'a, T>;\n+\n+    fn into_iter(self) -> Iter<'a, T> {\n+        self.iter()\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> Extend<T> for BinaryHeap<T> {\n     fn extend<Iter: Iterator<Item=T>>(&mut self, mut iter: Iter) {\n@@ -676,8 +692,8 @@ mod tests {\n \n     #[test]\n     fn test_iterator() {\n-        let data = vec!(5i, 9, 3);\n-        let iterout = [9i, 5, 3];\n+        let data = vec!(5, 9, 3);\n+        let iterout = [9, 5, 3];\n         let heap = BinaryHeap::from_vec(data);\n         let mut i = 0;\n         for el in heap.iter() {\n@@ -688,8 +704,8 @@ mod tests {\n \n     #[test]\n     fn test_iterator_reverse() {\n-        let data = vec!(5i, 9, 3);\n-        let iterout = vec!(3i, 5, 9);\n+        let data = vec!(5, 9, 3);\n+        let iterout = vec!(3, 5, 9);\n         let pq = BinaryHeap::from_vec(data);\n \n         let v: Vec<int> = pq.iter().rev().map(|&x| x).collect();\n@@ -698,8 +714,8 @@ mod tests {\n \n     #[test]\n     fn test_move_iter() {\n-        let data = vec!(5i, 9, 3);\n-        let iterout = vec!(9i, 5, 3);\n+        let data = vec!(5, 9, 3);\n+        let iterout = vec!(9, 5, 3);\n         let pq = BinaryHeap::from_vec(data);\n \n         let v: Vec<int> = pq.into_iter().collect();\n@@ -708,25 +724,25 @@ mod tests {\n \n     #[test]\n     fn test_move_iter_size_hint() {\n-        let data = vec!(5i, 9);\n+        let data = vec!(5, 9);\n         let pq = BinaryHeap::from_vec(data);\n \n         let mut it = pq.into_iter();\n \n         assert_eq!(it.size_hint(), (2, Some(2)));\n-        assert_eq!(it.next(), Some(9i));\n+        assert_eq!(it.next(), Some(9));\n \n         assert_eq!(it.size_hint(), (1, Some(1)));\n-        assert_eq!(it.next(), Some(5i));\n+        assert_eq!(it.next(), Some(5));\n \n         assert_eq!(it.size_hint(), (0, Some(0)));\n         assert_eq!(it.next(), None);\n     }\n \n     #[test]\n     fn test_move_iter_reverse() {\n-        let data = vec!(5i, 9, 3);\n-        let iterout = vec!(3i, 5, 9);\n+        let data = vec!(5, 9, 3);\n+        let iterout = vec!(3, 5, 9);\n         let pq = BinaryHeap::from_vec(data);\n \n         let v: Vec<int> = pq.into_iter().rev().collect();\n@@ -747,7 +763,7 @@ mod tests {\n \n     #[test]\n     fn test_push() {\n-        let mut heap = BinaryHeap::from_vec(vec!(2i, 4, 9));\n+        let mut heap = BinaryHeap::from_vec(vec!(2, 4, 9));\n         assert_eq!(heap.len(), 3);\n         assert!(*heap.peek().unwrap() == 9);\n         heap.push(11);\n@@ -769,7 +785,7 @@ mod tests {\n \n     #[test]\n     fn test_push_unique() {\n-        let mut heap = BinaryHeap::from_vec(vec!(box 2i, box 4, box 9));\n+        let mut heap = BinaryHeap::from_vec(vec!(box 2, box 4, box 9));\n         assert_eq!(heap.len(), 3);\n         assert!(*heap.peek().unwrap() == box 9);\n         heap.push(box 11);\n@@ -791,7 +807,7 @@ mod tests {\n \n     #[test]\n     fn test_push_pop() {\n-        let mut heap = BinaryHeap::from_vec(vec!(5i, 5, 2, 1, 3));\n+        let mut heap = BinaryHeap::from_vec(vec!(5, 5, 2, 1, 3));\n         assert_eq!(heap.len(), 5);\n         assert_eq!(heap.push_pop(6), 6);\n         assert_eq!(heap.len(), 5);\n@@ -805,7 +821,7 @@ mod tests {\n \n     #[test]\n     fn test_replace() {\n-        let mut heap = BinaryHeap::from_vec(vec!(5i, 5, 2, 1, 3));\n+        let mut heap = BinaryHeap::from_vec(vec!(5, 5, 2, 1, 3));\n         assert_eq!(heap.len(), 5);\n         assert_eq!(heap.replace(6).unwrap(), 5);\n         assert_eq!(heap.len(), 5);\n@@ -830,18 +846,18 @@ mod tests {\n     #[test]\n     fn test_to_vec() {\n         check_to_vec(vec!());\n-        check_to_vec(vec!(5i));\n-        check_to_vec(vec!(3i, 2));\n-        check_to_vec(vec!(2i, 3));\n-        check_to_vec(vec!(5i, 1, 2));\n-        check_to_vec(vec!(1i, 100, 2, 3));\n-        check_to_vec(vec!(1i, 3, 5, 7, 9, 2, 4, 6, 8, 0));\n-        check_to_vec(vec!(2i, 4, 6, 2, 1, 8, 10, 3, 5, 7, 0, 9, 1));\n-        check_to_vec(vec!(9i, 11, 9, 9, 9, 9, 11, 2, 3, 4, 11, 9, 0, 0, 0, 0));\n-        check_to_vec(vec!(0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10));\n-        check_to_vec(vec!(10i, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0));\n-        check_to_vec(vec!(0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 0, 1, 2));\n-        check_to_vec(vec!(5i, 4, 3, 2, 1, 5, 4, 3, 2, 1, 5, 4, 3, 2, 1));\n+        check_to_vec(vec!(5));\n+        check_to_vec(vec!(3, 2));\n+        check_to_vec(vec!(2, 3));\n+        check_to_vec(vec!(5, 1, 2));\n+        check_to_vec(vec!(1, 100, 2, 3));\n+        check_to_vec(vec!(1, 3, 5, 7, 9, 2, 4, 6, 8, 0));\n+        check_to_vec(vec!(2, 4, 6, 2, 1, 8, 10, 3, 5, 7, 0, 9, 1));\n+        check_to_vec(vec!(9, 11, 9, 9, 9, 9, 11, 2, 3, 4, 11, 9, 0, 0, 0, 0));\n+        check_to_vec(vec!(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10));\n+        check_to_vec(vec!(10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0));\n+        check_to_vec(vec!(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 0, 1, 2));\n+        check_to_vec(vec!(5, 4, 3, 2, 1, 5, 4, 3, 2, 1, 5, 4, 3, 2, 1));\n     }\n \n     #[test]"}, {"sha": "ec2a274a45d64fa1afcc5f65f80b0558cb62a5ba", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -89,7 +89,7 @@ use core::fmt;\n use core::hash;\n use core::iter::RandomAccessIterator;\n use core::iter::{Chain, Enumerate, Repeat, Skip, Take, repeat, Cloned};\n-use core::iter::{self, FromIterator};\n+use core::iter::{self, FromIterator, IntoIterator};\n use core::num::Int;\n use core::ops::Index;\n use core::slice;\n@@ -1070,6 +1070,14 @@ impl<'a> RandomAccessIterator for Iter<'a> {\n     }\n }\n \n+impl<'a> IntoIterator for &'a Bitv {\n+    type Iter = Iter<'a>;\n+\n+    fn into_iter(self) -> Iter<'a> {\n+        self.iter()\n+    }\n+}\n+\n /// An implementation of a set using a bit vector as an underlying\n /// representation for holding unsigned numerical elements.\n ///\n@@ -1730,6 +1738,7 @@ impl BitvSet {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Debug for BitvSet {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(fmt, \"BitvSet {{\"));\n@@ -1873,6 +1882,13 @@ impl<'a> Iterator for SymmetricDifference<'a> {\n     #[inline] fn size_hint(&self) -> (uint, Option<uint>) { self.0.size_hint() }\n }\n \n+impl<'a> IntoIterator for &'a BitvSet {\n+    type Iter = SetIter<'a>;\n+\n+    fn into_iter(self) -> SetIter<'a> {\n+        self.iter()\n+    }\n+}\n \n #[cfg(test)]\n mod tests {"}, {"sha": "ce5e8f07be1b2e46f4bd64fe32ac63c04fa2a06f", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -24,7 +24,7 @@ use core::cmp::Ordering;\n use core::default::Default;\n use core::fmt::Debug;\n use core::hash::{Hash, Hasher};\n-use core::iter::{Map, FromIterator};\n+use core::iter::{Map, FromIterator, IntoIterator};\n use core::ops::{Index, IndexMut};\n use core::{iter, fmt, mem};\n use Bound::{self, Included, Excluded, Unbounded};\n@@ -478,6 +478,30 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     }\n }\n \n+impl<K, V> IntoIterator for BTreeMap<K, V> {\n+    type Iter = IntoIter<K, V>;\n+\n+    fn into_iter(self) -> IntoIter<K, V> {\n+        self.into_iter()\n+    }\n+}\n+\n+impl<'a, K, V> IntoIterator for &'a BTreeMap<K, V> {\n+    type Iter = Iter<'a, K, V>;\n+\n+    fn into_iter(self) -> Iter<'a, K, V> {\n+        self.iter()\n+    }\n+}\n+\n+impl<'a, K, V> IntoIterator for &'a mut BTreeMap<K, V> {\n+    type Iter = IterMut<'a, K, V>;\n+\n+    fn into_iter(mut self) -> IterMut<'a, K, V> {\n+        self.iter_mut()\n+    }\n+}\n+\n /// A helper enum useful for deciding whether to continue a loop since we can't\n /// return from a closure\n enum Continuation<A, B> {\n@@ -1782,7 +1806,7 @@ mod test {\n \n     #[test]\n     fn test_entry(){\n-        let xs = [(1i, 10i), (2, 20), (3, 30), (4, 40), (5, 50), (6, 60)];\n+        let xs = [(1, 10), (2, 20), (3, 30), (4, 40), (5, 50), (6, 60)];\n \n         let mut map: BTreeMap<int, int> = xs.iter().map(|&x| x).collect();\n "}, {"sha": "8d6f06b25c5be42512197325e74381087784be10", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -271,7 +271,7 @@ impl<T> DoubleEndedIterator for RawItems<T> {\n #[unsafe_destructor]\n impl<T> Drop for RawItems<T> {\n     fn drop(&mut self) {\n-        for _ in *self {}\n+        for _ in self.by_ref() {}\n     }\n }\n \n@@ -1374,9 +1374,9 @@ impl<K, V> Drop for MoveTraversalImpl<K, V> {\n     fn drop(&mut self) {\n         // We need to cleanup the stored values manually, as the RawItems destructor would run\n         // after our deallocation.\n-        for _ in self.keys {}\n-        for _ in self.vals {}\n-        for _ in self.edges {}\n+        for _ in self.keys.by_ref() {}\n+        for _ in self.vals.by_ref() {}\n+        for _ in self.edges.by_ref() {}\n \n         let (alignment, size) =\n                 calculate_allocation_generic::<K, V>(self.capacity, self.is_leaf);"}, {"sha": "72d5bf6d7993297142a045e01e35b4c9ced95c52", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 31, "deletions": 15, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -18,7 +18,7 @@ use core::cmp::Ordering::{self, Less, Greater, Equal};\n use core::default::Default;\n use core::fmt::Debug;\n use core::fmt;\n-use core::iter::{Peekable, Map, FromIterator};\n+use core::iter::{Peekable, Map, FromIterator, IntoIterator};\n use core::ops::{BitOr, BitAnd, BitXor, Sub};\n \n use btree_map::{BTreeMap, Keys};\n@@ -282,7 +282,7 @@ impl<T: Ord> BTreeSet<T> {\n     ///\n     /// let mut v = BTreeSet::new();\n     /// assert_eq!(v.len(), 0);\n-    /// v.insert(1i);\n+    /// v.insert(1);\n     /// assert_eq!(v.len(), 1);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -297,7 +297,7 @@ impl<T: Ord> BTreeSet<T> {\n     ///\n     /// let mut v = BTreeSet::new();\n     /// assert!(v.is_empty());\n-    /// v.insert(1i);\n+    /// v.insert(1);\n     /// assert!(!v.is_empty());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -311,7 +311,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// use std::collections::BTreeSet;\n     ///\n     /// let mut v = BTreeSet::new();\n-    /// v.insert(1i);\n+    /// v.insert(1);\n     /// v.clear();\n     /// assert!(v.is_empty());\n     /// ```\n@@ -331,7 +331,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// ```\n     /// use std::collections::BTreeSet;\n     ///\n-    /// let set: BTreeSet<int> = [1i, 2, 3].iter().map(|&x| x).collect();\n+    /// let set: BTreeSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n     /// assert_eq!(set.contains(&1), true);\n     /// assert_eq!(set.contains(&4), false);\n     /// ```\n@@ -348,7 +348,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// ```\n     /// use std::collections::BTreeSet;\n     ///\n-    /// let a: BTreeSet<int> = [1i, 2, 3].iter().map(|&x| x).collect();\n+    /// let a: BTreeSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n     /// let mut b: BTreeSet<int> = BTreeSet::new();\n     ///\n     /// assert_eq!(a.is_disjoint(&b), true);\n@@ -369,7 +369,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// ```\n     /// use std::collections::BTreeSet;\n     ///\n-    /// let sup: BTreeSet<int> = [1i, 2, 3].iter().map(|&x| x).collect();\n+    /// let sup: BTreeSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n     /// let mut set: BTreeSet<int> = BTreeSet::new();\n     ///\n     /// assert_eq!(set.is_subset(&sup), true);\n@@ -411,7 +411,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// ```\n     /// use std::collections::BTreeSet;\n     ///\n-    /// let sub: BTreeSet<int> = [1i, 2].iter().map(|&x| x).collect();\n+    /// let sub: BTreeSet<int> = [1, 2].iter().map(|&x| x).collect();\n     /// let mut set: BTreeSet<int> = BTreeSet::new();\n     ///\n     /// assert_eq!(set.is_superset(&sub), false);\n@@ -438,8 +438,8 @@ impl<T: Ord> BTreeSet<T> {\n     ///\n     /// let mut set = BTreeSet::new();\n     ///\n-    /// assert_eq!(set.insert(2i), true);\n-    /// assert_eq!(set.insert(2i), false);\n+    /// assert_eq!(set.insert(2), true);\n+    /// assert_eq!(set.insert(2), false);\n     /// assert_eq!(set.len(), 1);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -461,7 +461,7 @@ impl<T: Ord> BTreeSet<T> {\n     ///\n     /// let mut set = BTreeSet::new();\n     ///\n-    /// set.insert(2i);\n+    /// set.insert(2);\n     /// assert_eq!(set.remove(&2), true);\n     /// assert_eq!(set.remove(&2), false);\n     /// ```\n@@ -480,6 +480,22 @@ impl<T: Ord> FromIterator<T> for BTreeSet<T> {\n     }\n }\n \n+impl<T> IntoIterator for BTreeSet<T> {\n+    type Iter = IntoIter<T>;\n+\n+    fn into_iter(self) -> IntoIter<T> {\n+        self.into_iter()\n+    }\n+}\n+\n+impl<'a, T> IntoIterator for &'a BTreeSet<T> {\n+    type Iter = Iter<'a, T>;\n+\n+    fn into_iter(self) -> Iter<'a, T> {\n+        self.iter()\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> Extend<T> for BTreeSet<T> {\n     #[inline]\n@@ -731,7 +747,7 @@ mod test {\n     fn test_clone_eq() {\n       let mut m = BTreeSet::new();\n \n-      m.insert(1i);\n+      m.insert(1);\n       m.insert(2);\n \n       assert!(m.clone() == m);\n@@ -742,11 +758,11 @@ mod test {\n       let mut x = BTreeSet::new();\n       let mut y = BTreeSet::new();\n \n-      x.insert(1i);\n+      x.insert(1);\n       x.insert(2);\n       x.insert(3);\n \n-      y.insert(3i);\n+      y.insert(3);\n       y.insert(2);\n       y.insert(1);\n \n@@ -874,7 +890,7 @@ mod test {\n \n     #[test]\n     fn test_from_iter() {\n-        let xs = [1i, 2, 3, 4, 5, 6, 7, 8, 9];\n+        let xs = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n \n         let set: BTreeSet<int> = xs.iter().map(|&x| x).collect();\n "}, {"sha": "911ed58b6eed4d44c5a2ff97f5d5d4d05759bb51", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 63, "deletions": 39, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -28,7 +28,7 @@ use core::cmp::Ordering;\n use core::default::Default;\n use core::fmt;\n use core::hash::{Writer, Hasher, Hash};\n-use core::iter::{self, FromIterator};\n+use core::iter::{self, FromIterator, IntoIterator};\n use core::mem;\n use core::ptr;\n \n@@ -235,9 +235,9 @@ impl<T> DList<T> {\n     ///\n     /// let mut a = DList::new();\n     /// let mut b = DList::new();\n-    /// a.push_back(1i);\n+    /// a.push_back(1);\n     /// a.push_back(2);\n-    /// b.push_back(3i);\n+    /// b.push_back(3);\n     /// b.push_back(4);\n     ///\n     /// a.append(&mut b);\n@@ -529,7 +529,7 @@ impl<T> DList<T> {\n     /// use std::collections::DList;\n     ///\n     /// let mut d = DList::new();\n-    /// d.push_back(1i);\n+    /// d.push_back(1);\n     /// d.push_back(3);\n     /// assert_eq!(3, *d.back().unwrap());\n     /// ```\n@@ -548,7 +548,7 @@ impl<T> DList<T> {\n     ///\n     /// let mut d = DList::new();\n     /// assert_eq!(d.pop_back(), None);\n-    /// d.push_back(1i);\n+    /// d.push_back(1);\n     /// d.push_back(3);\n     /// assert_eq!(d.pop_back(), Some(3));\n     /// ```\n@@ -766,7 +766,7 @@ impl<'a, A> IterMut<'a, A> {\n     /// }\n     /// {\n     ///     let vec: Vec<int> = list.into_iter().collect();\n-    ///     assert_eq!(vec, vec![1i, 2, 3, 4]);\n+    ///     assert_eq!(vec, vec![1, 2, 3, 4]);\n     /// }\n     /// ```\n     #[inline]\n@@ -830,6 +830,30 @@ impl<A> FromIterator<A> for DList<A> {\n     }\n }\n \n+impl<T> IntoIterator for DList<T> {\n+    type Iter = IntoIter<T>;\n+\n+    fn into_iter(self) -> IntoIter<T> {\n+        self.into_iter()\n+    }\n+}\n+\n+impl<'a, T> IntoIterator for &'a DList<T> {\n+    type Iter = Iter<'a, T>;\n+\n+    fn into_iter(self) -> Iter<'a, T> {\n+        self.iter()\n+    }\n+}\n+\n+impl<'a, T> IntoIterator for &'a mut DList<T> {\n+    type Iter = IterMut<'a, T>;\n+\n+    fn into_iter(mut self) -> IterMut<'a, T> {\n+        self.iter_mut()\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> Extend<A> for DList<A> {\n     fn extend<T: Iterator<Item=A>>(&mut self, mut iterator: T) {\n@@ -964,7 +988,7 @@ mod tests {\n         assert_eq!(m.pop_front(), Some(box 1));\n \n         let mut n = DList::new();\n-        n.push_front(2i);\n+        n.push_front(2);\n         n.push_front(3);\n         {\n             assert_eq!(n.front().unwrap(), &3);\n@@ -984,7 +1008,7 @@ mod tests {\n \n     #[cfg(test)]\n     fn generate_test() -> DList<int> {\n-        list_from(&[0i,1,2,3,4,5,6])\n+        list_from(&[0,1,2,3,4,5,6])\n     }\n \n     #[cfg(test)]\n@@ -1007,7 +1031,7 @@ mod tests {\n         {\n             let mut m = DList::new();\n             let mut n = DList::new();\n-            n.push_back(2i);\n+            n.push_back(2);\n             m.append(&mut n);\n             check_links(&m);\n             assert_eq!(m.len(), 1);\n@@ -1019,7 +1043,7 @@ mod tests {\n         {\n             let mut m = DList::new();\n             let mut n = DList::new();\n-            m.push_back(2i);\n+            m.push_back(2);\n             m.append(&mut n);\n             check_links(&m);\n             assert_eq!(m.len(), 1);\n@@ -1028,8 +1052,8 @@ mod tests {\n         }\n \n         // Non-empty to non-empty\n-        let v = vec![1i,2,3,4,5];\n-        let u = vec![9i,8,1,2,3,4,5];\n+        let v = vec![1,2,3,4,5];\n+        let u = vec![9,8,1,2,3,4,5];\n         let mut m = list_from(v.as_slice());\n         let mut n = list_from(u.as_slice());\n         m.append(&mut n);\n@@ -1054,7 +1078,7 @@ mod tests {\n         // singleton\n         {\n             let mut m = DList::new();\n-            m.push_back(1i);\n+            m.push_back(1);\n \n             let p = m.split_off(0);\n             assert_eq!(m.len(), 0);\n@@ -1065,29 +1089,29 @@ mod tests {\n \n         // not singleton, forwards\n         {\n-            let u = vec![1i,2,3,4,5];\n+            let u = vec![1,2,3,4,5];\n             let mut m = list_from(u.as_slice());\n             let mut n = m.split_off(2);\n             assert_eq!(m.len(), 2);\n             assert_eq!(n.len(), 3);\n-            for elt in 1i..3 {\n+            for elt in 1..3 {\n                 assert_eq!(m.pop_front(), Some(elt));\n             }\n-            for elt in 3i..6 {\n+            for elt in 3..6 {\n                 assert_eq!(n.pop_front(), Some(elt));\n             }\n         }\n         // not singleton, backwards\n         {\n-            let u = vec![1i,2,3,4,5];\n+            let u = vec![1,2,3,4,5];\n             let mut m = list_from(u.as_slice());\n             let mut n = m.split_off(4);\n             assert_eq!(m.len(), 4);\n             assert_eq!(n.len(), 1);\n-            for elt in 1i..5 {\n+            for elt in 1..5 {\n                 assert_eq!(m.pop_front(), Some(elt));\n             }\n-            for elt in 5i..6 {\n+            for elt in 5..6 {\n                 assert_eq!(n.pop_front(), Some(elt));\n             }\n         }\n@@ -1102,7 +1126,7 @@ mod tests {\n         }\n         let mut n = DList::new();\n         assert_eq!(n.iter().next(), None);\n-        n.push_front(4i);\n+        n.push_front(4);\n         let mut it = n.iter();\n         assert_eq!(it.size_hint(), (1, Some(1)));\n         assert_eq!(it.next().unwrap(), &4);\n@@ -1113,7 +1137,7 @@ mod tests {\n     #[test]\n     fn test_iterator_clone() {\n         let mut n = DList::new();\n-        n.push_back(2i);\n+        n.push_back(2);\n         n.push_back(3);\n         n.push_back(4);\n         let mut it = n.iter();\n@@ -1128,7 +1152,7 @@ mod tests {\n     fn test_iterator_double_end() {\n         let mut n = DList::new();\n         assert_eq!(n.iter().next(), None);\n-        n.push_front(4i);\n+        n.push_front(4);\n         n.push_front(5);\n         n.push_front(6);\n         let mut it = n.iter();\n@@ -1150,7 +1174,7 @@ mod tests {\n         }\n         let mut n = DList::new();\n         assert_eq!(n.iter().rev().next(), None);\n-        n.push_front(4i);\n+        n.push_front(4);\n         let mut it = n.iter().rev();\n         assert_eq!(it.size_hint(), (1, Some(1)));\n         assert_eq!(it.next().unwrap(), &4);\n@@ -1169,7 +1193,7 @@ mod tests {\n         assert_eq!(len, 0);\n         let mut n = DList::new();\n         assert!(n.iter_mut().next().is_none());\n-        n.push_front(4i);\n+        n.push_front(4);\n         n.push_back(5);\n         let mut it = n.iter_mut();\n         assert_eq!(it.size_hint(), (2, Some(2)));\n@@ -1183,7 +1207,7 @@ mod tests {\n     fn test_iterator_mut_double_end() {\n         let mut n = DList::new();\n         assert!(n.iter_mut().next_back().is_none());\n-        n.push_front(4i);\n+        n.push_front(4);\n         n.push_front(5);\n         n.push_front(6);\n         let mut it = n.iter_mut();\n@@ -1199,7 +1223,7 @@ mod tests {\n \n     #[test]\n     fn test_insert_prev() {\n-        let mut m = list_from(&[0i,2,4,6,8]);\n+        let mut m = list_from(&[0,2,4,6,8]);\n         let len = m.len();\n         {\n             let mut it = m.iter_mut();\n@@ -1232,15 +1256,15 @@ mod tests {\n         }\n         let mut n = DList::new();\n         assert!(n.iter_mut().rev().next().is_none());\n-        n.push_front(4i);\n+        n.push_front(4);\n         let mut it = n.iter_mut().rev();\n         assert!(it.next().is_some());\n         assert!(it.next().is_none());\n     }\n \n     #[test]\n     fn test_send() {\n-        let n = list_from(&[1i,2,3]);\n+        let n = list_from(&[1,2,3]);\n         Thread::scoped(move || {\n             check_links(&n);\n             let a: &[_] = &[&1,&2,&3];\n@@ -1258,8 +1282,8 @@ mod tests {\n         m.push_back(1);\n         assert!(n == m);\n \n-        let n = list_from(&[2i,3,4]);\n-        let m = list_from(&[1i,2,3]);\n+        let n = list_from(&[2,3,4]);\n+        let m = list_from(&[1,2,3]);\n         assert!(n != m);\n     }\n \n@@ -1270,11 +1294,11 @@ mod tests {\n \n       assert!(hash::hash::<_, SipHasher>(&x) == hash::hash::<_, SipHasher>(&y));\n \n-      x.push_back(1i);\n+      x.push_back(1);\n       x.push_back(2);\n       x.push_back(3);\n \n-      y.push_front(3i);\n+      y.push_front(3);\n       y.push_front(2);\n       y.push_front(1);\n \n@@ -1284,7 +1308,7 @@ mod tests {\n     #[test]\n     fn test_ord() {\n         let n: DList<int> = list_from(&[]);\n-        let m = list_from(&[1i,2,3]);\n+        let m = list_from(&[1,2,3]);\n         assert!(n < m);\n         assert!(m > n);\n         assert!(n <= n);\n@@ -1334,7 +1358,7 @@ mod tests {\n \n     #[test]\n     fn test_show() {\n-        let list: DList<int> = (0i..10).collect();\n+        let list: DList<i32> = (0..10).collect();\n         assert_eq!(format!(\"{:?}\", list), \"DList [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n \n         let list: DList<&str> = vec![\"just\", \"one\", \"test\", \"more\"].iter()\n@@ -1384,7 +1408,7 @@ mod tests {\n \n     #[bench]\n     fn bench_collect_into(b: &mut test::Bencher) {\n-        let v = &[0i; 64];\n+        let v = &[0; 64];\n         b.iter(|| {\n             let _: DList<int> = v.iter().map(|x| *x).collect();\n         })\n@@ -1426,31 +1450,31 @@ mod tests {\n \n     #[bench]\n     fn bench_iter(b: &mut test::Bencher) {\n-        let v = &[0i; 128];\n+        let v = &[0; 128];\n         let m: DList<int> = v.iter().map(|&x|x).collect();\n         b.iter(|| {\n             assert!(m.iter().count() == 128);\n         })\n     }\n     #[bench]\n     fn bench_iter_mut(b: &mut test::Bencher) {\n-        let v = &[0i; 128];\n+        let v = &[0; 128];\n         let mut m: DList<int> = v.iter().map(|&x|x).collect();\n         b.iter(|| {\n             assert!(m.iter_mut().count() == 128);\n         })\n     }\n     #[bench]\n     fn bench_iter_rev(b: &mut test::Bencher) {\n-        let v = &[0i; 128];\n+        let v = &[0; 128];\n         let m: DList<int> = v.iter().map(|&x|x).collect();\n         b.iter(|| {\n             assert!(m.iter().rev().count() == 128);\n         })\n     }\n     #[bench]\n     fn bench_iter_mut_rev(b: &mut test::Bencher) {\n-        let v = &[0i; 128];\n+        let v = &[0; 128];\n         let mut m: DList<int> = v.iter().map(|&x|x).collect();\n         b.iter(|| {\n             assert!(m.iter_mut().rev().count() == 128);"}, {"sha": "9765bb5875efee6766949074891a9ce6ae354d7c", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -16,7 +16,7 @@\n use core::prelude::*;\n use core::fmt;\n use core::num::Int;\n-use core::iter::FromIterator;\n+use core::iter::{FromIterator, IntoIterator};\n use core::ops::{Sub, BitOr, BitAnd, BitXor};\n \n // FIXME(contentions): implement union family of methods? (general design may be wrong here)\n@@ -31,6 +31,7 @@ pub struct EnumSet<E> {\n \n impl<E> Copy for EnumSet<E> {}\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<E:CLike + fmt::Debug> fmt::Debug for EnumSet<E> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(fmt, \"EnumSet {{\"));\n@@ -256,6 +257,14 @@ impl<E:CLike> FromIterator<E> for EnumSet<E> {\n     }\n }\n \n+impl<'a, E> IntoIterator for &'a EnumSet<E> where E: CLike {\n+    type Iter = Iter<E>;\n+\n+    fn into_iter(self) -> Iter<E> {\n+        self.iter()\n+    }\n+}\n+\n impl<E:CLike> Extend<E> for EnumSet<E> {\n     fn extend<I: Iterator<Item=E>>(&mut self, mut iterator: I) {\n         for element in iterator {"}, {"sha": "ce00bd48bb8baf321092b8bf8acdcc375f7a066c", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -15,26 +15,28 @@\n \n #![crate_name = \"collections\"]\n #![unstable(feature = \"collections\")]\n-#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n \n-#![allow(unknown_features)]\n-#![feature(unsafe_destructor, slicing_syntax)]\n+#![cfg_attr(not(stage0), allow(unused_mut))] // NOTE: remove after stage0 snap\n+\n+#![feature(alloc)]\n #![feature(box_syntax)]\n-#![feature(unboxed_closures)]\n-#![allow(unknown_features)] #![feature(int_uint)]\n-#![no_std]\n #![feature(core)]\n-#![feature(alloc)]\n-#![feature(unicode)]\n #![feature(hash)]\n+#![feature(int_uint)]\n+#![feature(staged_api)]\n+#![feature(unboxed_closures)]\n+#![feature(unicode)]\n+#![feature(unsafe_destructor, slicing_syntax)]\n #![cfg_attr(test, feature(test))]\n \n+#![no_std]\n+\n #[macro_use]\n extern crate core;\n \n@@ -114,6 +116,8 @@ mod std {\n     pub use core::marker;   // derive(Copy)\n     pub use core::hash;     // derive(Hash)\n     pub use core::ops;      // RangeFull\n+    // for-loops\n+    pub use core::iter;\n }\n \n #[cfg(test)]"}, {"sha": "7032a3d9137ab11f59ac4549ba2a5ac49652cef1", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 158, "deletions": 134, "changes": 292, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -19,7 +19,7 @@ use core::prelude::*;\n use core::cmp::Ordering;\n use core::default::Default;\n use core::fmt;\n-use core::iter::{self, repeat, FromIterator, RandomAccessIterator};\n+use core::iter::{self, repeat, FromIterator, IntoIterator, RandomAccessIterator};\n use core::marker;\n use core::mem;\n use core::num::{Int, UnsignedInt};\n@@ -186,7 +186,7 @@ impl<T> RingBuf<T> {\n     /// use std::collections::RingBuf;\n     ///\n     /// let mut buf = RingBuf::new();\n-    /// buf.push_back(3i);\n+    /// buf.push_back(3);\n     /// buf.push_back(4);\n     /// buf.push_back(5);\n     /// assert_eq!(buf.get(1).unwrap(), &4);\n@@ -209,7 +209,7 @@ impl<T> RingBuf<T> {\n     /// use std::collections::RingBuf;\n     ///\n     /// let mut buf = RingBuf::new();\n-    /// buf.push_back(3i);\n+    /// buf.push_back(3);\n     /// buf.push_back(4);\n     /// buf.push_back(5);\n     /// match buf.get_mut(1) {\n@@ -243,7 +243,7 @@ impl<T> RingBuf<T> {\n     /// use std::collections::RingBuf;\n     ///\n     /// let mut buf = RingBuf::new();\n-    /// buf.push_back(3i);\n+    /// buf.push_back(3);\n     /// buf.push_back(4);\n     /// buf.push_back(5);\n     /// buf.swap(0, 2);\n@@ -269,7 +269,7 @@ impl<T> RingBuf<T> {\n     /// ```\n     /// use std::collections::RingBuf;\n     ///\n-    /// let buf: RingBuf<int> = RingBuf::with_capacity(10);\n+    /// let buf: RingBuf<i32> = RingBuf::with_capacity(10);\n     /// assert!(buf.capacity() >= 10);\n     /// ```\n     #[inline]\n@@ -292,7 +292,7 @@ impl<T> RingBuf<T> {\n     /// ```\n     /// use std::collections::RingBuf;\n     ///\n-    /// let mut buf: RingBuf<int> = vec![1].into_iter().collect();\n+    /// let mut buf: RingBuf<i32> = vec![1].into_iter().collect();\n     /// buf.reserve_exact(10);\n     /// assert!(buf.capacity() >= 11);\n     /// ```\n@@ -313,7 +313,7 @@ impl<T> RingBuf<T> {\n     /// ```\n     /// use std::collections::RingBuf;\n     ///\n-    /// let mut buf: RingBuf<int> = vec![1].into_iter().collect();\n+    /// let mut buf: RingBuf<i32> = vec![1].into_iter().collect();\n     /// buf.reserve(10);\n     /// assert!(buf.capacity() >= 11);\n     /// ```\n@@ -473,8 +473,8 @@ impl<T> RingBuf<T> {\n     /// use std::collections::RingBuf;\n     ///\n     /// let mut buf = RingBuf::new();\n-    /// buf.push_back(5i);\n-    /// buf.push_back(10i);\n+    /// buf.push_back(5);\n+    /// buf.push_back(10);\n     /// buf.push_back(15);\n     /// buf.truncate(1);\n     /// assert_eq!(buf.len(), 1);\n@@ -496,11 +496,11 @@ impl<T> RingBuf<T> {\n     /// use std::collections::RingBuf;\n     ///\n     /// let mut buf = RingBuf::new();\n-    /// buf.push_back(5i);\n+    /// buf.push_back(5);\n     /// buf.push_back(3);\n     /// buf.push_back(4);\n     /// let b: &[_] = &[&5, &3, &4];\n-    /// assert_eq!(buf.iter().collect::<Vec<&int>>().as_slice(), b);\n+    /// assert_eq!(buf.iter().collect::<Vec<&i32>>().as_slice(), b);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<T> {\n@@ -519,14 +519,14 @@ impl<T> RingBuf<T> {\n     /// use std::collections::RingBuf;\n     ///\n     /// let mut buf = RingBuf::new();\n-    /// buf.push_back(5i);\n+    /// buf.push_back(5);\n     /// buf.push_back(3);\n     /// buf.push_back(4);\n     /// for num in buf.iter_mut() {\n     ///     *num = *num - 2;\n     /// }\n     /// let b: &[_] = &[&mut 3, &mut 1, &mut 2];\n-    /// assert_eq!(&buf.iter_mut().collect::<Vec<&mut int>>()[], b);\n+    /// assert_eq!(&buf.iter_mut().collect::<Vec<&mut i32>>()[], b);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter_mut<'a>(&'a mut self) -> IterMut<'a, T> {\n@@ -600,7 +600,7 @@ impl<T> RingBuf<T> {\n     ///\n     /// let mut v = RingBuf::new();\n     /// assert_eq!(v.len(), 0);\n-    /// v.push_back(1i);\n+    /// v.push_back(1);\n     /// assert_eq!(v.len(), 1);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -615,7 +615,7 @@ impl<T> RingBuf<T> {\n     ///\n     /// let mut v = RingBuf::new();\n     /// assert!(v.is_empty());\n-    /// v.push_front(1i);\n+    /// v.push_front(1);\n     /// assert!(!v.is_empty());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -630,7 +630,7 @@ impl<T> RingBuf<T> {\n     /// use std::collections::RingBuf;\n     ///\n     /// let mut v = RingBuf::new();\n-    /// v.push_back(1i);\n+    /// v.push_back(1);\n     /// assert_eq!(v.drain().next(), Some(1));\n     /// assert!(v.is_empty());\n     /// ```\n@@ -651,7 +651,7 @@ impl<T> RingBuf<T> {\n     /// use std::collections::RingBuf;\n     ///\n     /// let mut v = RingBuf::new();\n-    /// v.push_back(1i);\n+    /// v.push_back(1);\n     /// v.clear();\n     /// assert!(v.is_empty());\n     /// ```\n@@ -672,9 +672,9 @@ impl<T> RingBuf<T> {\n     /// let mut d = RingBuf::new();\n     /// assert_eq!(d.front(), None);\n     ///\n-    /// d.push_back(1i);\n-    /// d.push_back(2i);\n-    /// assert_eq!(d.front(), Some(&1i));\n+    /// d.push_back(1);\n+    /// d.push_back(2);\n+    /// assert_eq!(d.front(), Some(&1));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn front(&self) -> Option<&T> {\n@@ -692,13 +692,13 @@ impl<T> RingBuf<T> {\n     /// let mut d = RingBuf::new();\n     /// assert_eq!(d.front_mut(), None);\n     ///\n-    /// d.push_back(1i);\n-    /// d.push_back(2i);\n+    /// d.push_back(1);\n+    /// d.push_back(2);\n     /// match d.front_mut() {\n-    ///     Some(x) => *x = 9i,\n+    ///     Some(x) => *x = 9,\n     ///     None => (),\n     /// }\n-    /// assert_eq!(d.front(), Some(&9i));\n+    /// assert_eq!(d.front(), Some(&9));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn front_mut(&mut self) -> Option<&mut T> {\n@@ -716,9 +716,9 @@ impl<T> RingBuf<T> {\n     /// let mut d = RingBuf::new();\n     /// assert_eq!(d.back(), None);\n     ///\n-    /// d.push_back(1i);\n-    /// d.push_back(2i);\n-    /// assert_eq!(d.back(), Some(&2i));\n+    /// d.push_back(1);\n+    /// d.push_back(2);\n+    /// assert_eq!(d.back(), Some(&2));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn back(&self) -> Option<&T> {\n@@ -736,13 +736,13 @@ impl<T> RingBuf<T> {\n     /// let mut d = RingBuf::new();\n     /// assert_eq!(d.back(), None);\n     ///\n-    /// d.push_back(1i);\n-    /// d.push_back(2i);\n+    /// d.push_back(1);\n+    /// d.push_back(2);\n     /// match d.back_mut() {\n-    ///     Some(x) => *x = 9i,\n+    ///     Some(x) => *x = 9,\n     ///     None => (),\n     /// }\n-    /// assert_eq!(d.back(), Some(&9i));\n+    /// assert_eq!(d.back(), Some(&9));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn back_mut(&mut self) -> Option<&mut T> {\n@@ -759,11 +759,11 @@ impl<T> RingBuf<T> {\n     /// use std::collections::RingBuf;\n     ///\n     /// let mut d = RingBuf::new();\n-    /// d.push_back(1i);\n-    /// d.push_back(2i);\n+    /// d.push_back(1);\n+    /// d.push_back(2);\n     ///\n-    /// assert_eq!(d.pop_front(), Some(1i));\n-    /// assert_eq!(d.pop_front(), Some(2i));\n+    /// assert_eq!(d.pop_front(), Some(1));\n+    /// assert_eq!(d.pop_front(), Some(2));\n     /// assert_eq!(d.pop_front(), None);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -785,9 +785,9 @@ impl<T> RingBuf<T> {\n     /// use std::collections::RingBuf;\n     ///\n     /// let mut d = RingBuf::new();\n-    /// d.push_front(1i);\n-    /// d.push_front(2i);\n-    /// assert_eq!(d.front(), Some(&2i));\n+    /// d.push_front(1);\n+    /// d.push_front(2);\n+    /// assert_eq!(d.front(), Some(&2));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push_front(&mut self, t: T) {\n@@ -809,7 +809,7 @@ impl<T> RingBuf<T> {\n     /// use std::collections::RingBuf;\n     ///\n     /// let mut buf = RingBuf::new();\n-    /// buf.push_back(1i);\n+    /// buf.push_back(1);\n     /// buf.push_back(3);\n     /// assert_eq!(3, *buf.back().unwrap());\n     /// ```\n@@ -835,7 +835,7 @@ impl<T> RingBuf<T> {\n     ///\n     /// let mut buf = RingBuf::new();\n     /// assert_eq!(buf.pop_back(), None);\n-    /// buf.push_back(1i);\n+    /// buf.push_back(1);\n     /// buf.push_back(3);\n     /// assert_eq!(buf.pop_back(), Some(3));\n     /// ```\n@@ -869,7 +869,7 @@ impl<T> RingBuf<T> {\n     ///\n     /// let mut buf = RingBuf::new();\n     /// assert_eq!(buf.swap_back_remove(0), None);\n-    /// buf.push_back(5i);\n+    /// buf.push_back(5);\n     /// buf.push_back(99);\n     /// buf.push_back(15);\n     /// buf.push_back(20);\n@@ -902,11 +902,11 @@ impl<T> RingBuf<T> {\n     ///\n     /// let mut buf = RingBuf::new();\n     /// assert_eq!(buf.swap_front_remove(0), None);\n-    /// buf.push_back(15i);\n+    /// buf.push_back(15);\n     /// buf.push_back(5);\n     /// buf.push_back(10);\n     /// buf.push_back(99);\n-    /// buf.push_back(20i);\n+    /// buf.push_back(20);\n     /// assert_eq!(buf.swap_front_remove(3), Some(99));\n     /// ```\n     #[unstable(feature = \"collections\",\n@@ -934,7 +934,7 @@ impl<T> RingBuf<T> {\n     /// use std::collections::RingBuf;\n     ///\n     /// let mut buf = RingBuf::new();\n-    /// buf.push_back(10i);\n+    /// buf.push_back(10);\n     /// buf.push_back(12);\n     /// buf.insert(1,11);\n     /// assert_eq!(Some(&11), buf.get(1));\n@@ -1136,9 +1136,9 @@ impl<T> RingBuf<T> {\n     /// use std::collections::RingBuf;\n     ///\n     /// let mut buf = RingBuf::new();\n-    /// buf.push_back(5i);\n-    /// buf.push_back(10i);\n-    /// buf.push_back(12i);\n+    /// buf.push_back(5);\n+    /// buf.push_back(10);\n+    /// buf.push_back(12);\n     /// buf.push_back(15);\n     /// buf.remove(2);\n     /// assert_eq!(Some(&15), buf.get(2));\n@@ -1301,8 +1301,8 @@ impl<T: Clone> RingBuf<T> {\n     /// use std::collections::RingBuf;\n     ///\n     /// let mut buf = RingBuf::new();\n-    /// buf.push_back(5i);\n-    /// buf.push_back(10i);\n+    /// buf.push_back(5);\n+    /// buf.push_back(10);\n     /// buf.push_back(15);\n     /// buf.resize(2, 0);\n     /// buf.resize(6, 20);\n@@ -1510,7 +1510,7 @@ pub struct Drain<'a, T: 'a> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: 'a> Drop for Drain<'a, T> {\n     fn drop(&mut self) {\n-        for _ in *self {}\n+        for _ in self.by_ref() {}\n         self.inner.head = 0;\n         self.inner.tail = 0;\n     }\n@@ -1609,6 +1609,30 @@ impl<A> FromIterator<A> for RingBuf<A> {\n     }\n }\n \n+impl<T> IntoIterator for RingBuf<T> {\n+    type Iter = IntoIter<T>;\n+\n+    fn into_iter(self) -> IntoIter<T> {\n+        self.into_iter()\n+    }\n+}\n+\n+impl<'a, T> IntoIterator for &'a RingBuf<T> {\n+    type Iter = Iter<'a, T>;\n+\n+    fn into_iter(self) -> Iter<'a, T> {\n+        self.iter()\n+    }\n+}\n+\n+impl<'a, T> IntoIterator for &'a mut RingBuf<T> {\n+    type Iter = IterMut<'a, T>;\n+\n+    fn into_iter(mut self) -> IterMut<'a, T> {\n+        self.iter_mut()\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> Extend<A> for RingBuf<A> {\n     fn extend<T: Iterator<Item=A>>(&mut self, mut iterator: T) {\n@@ -1650,8 +1674,8 @@ mod tests {\n     fn test_simple() {\n         let mut d = RingBuf::new();\n         assert_eq!(d.len(), 0u);\n-        d.push_front(17i);\n-        d.push_front(42i);\n+        d.push_front(17);\n+        d.push_front(42);\n         d.push_back(137);\n         assert_eq!(d.len(), 3u);\n         d.push_back(137);\n@@ -1769,7 +1793,7 @@ mod tests {\n     fn bench_push_back_100(b: &mut test::Bencher) {\n         let mut deq = RingBuf::with_capacity(101);\n         b.iter(|| {\n-            for i in 0i..100 {\n+            for i in 0..100 {\n                 deq.push_back(i);\n             }\n             deq.head = 0;\n@@ -1781,7 +1805,7 @@ mod tests {\n     fn bench_push_front_100(b: &mut test::Bencher) {\n         let mut deq = RingBuf::with_capacity(101);\n         b.iter(|| {\n-            for i in 0i..100 {\n+            for i in 0..100 {\n                 deq.push_front(i);\n             }\n             deq.head = 0;\n@@ -1791,7 +1815,7 @@ mod tests {\n \n     #[bench]\n     fn bench_pop_back_100(b: &mut test::Bencher) {\n-        let mut deq: RingBuf<int> = RingBuf::with_capacity(101);\n+        let mut deq: RingBuf<i32> = RingBuf::with_capacity(101);\n \n         b.iter(|| {\n             deq.head = 100;\n@@ -1804,7 +1828,7 @@ mod tests {\n \n     #[bench]\n     fn bench_pop_front_100(b: &mut test::Bencher) {\n-        let mut deq: RingBuf<int> = RingBuf::with_capacity(101);\n+        let mut deq: RingBuf<i32> = RingBuf::with_capacity(101);\n \n         b.iter(|| {\n             deq.head = 100;\n@@ -1819,7 +1843,7 @@ mod tests {\n     fn bench_grow_1025(b: &mut test::Bencher) {\n         b.iter(|| {\n             let mut deq = RingBuf::new();\n-            for i in 0i..1025 {\n+            for i in 0..1025 {\n                 deq.push_front(i);\n             }\n             test::black_box(deq);\n@@ -1828,7 +1852,7 @@ mod tests {\n \n     #[bench]\n     fn bench_iter_1000(b: &mut test::Bencher) {\n-        let ring: RingBuf<int> = (0i..1000).collect();\n+        let ring: RingBuf<i32> = (0..1000).collect();\n \n         b.iter(|| {\n             let mut sum = 0;\n@@ -1841,7 +1865,7 @@ mod tests {\n \n     #[bench]\n     fn bench_mut_iter_1000(b: &mut test::Bencher) {\n-        let mut ring: RingBuf<int> = (0i..1000).collect();\n+        let mut ring: RingBuf<i32> = (0..1000).collect();\n \n         b.iter(|| {\n             let mut sum = 0;\n@@ -1854,28 +1878,28 @@ mod tests {\n \n     #[derive(Clone, PartialEq, Debug)]\n     enum Taggy {\n-        One(int),\n-        Two(int, int),\n-        Three(int, int, int),\n+        One(i32),\n+        Two(i32, i32),\n+        Three(i32, i32, i32),\n     }\n \n     #[derive(Clone, PartialEq, Debug)]\n     enum Taggypar<T> {\n-        Onepar(int),\n-        Twopar(int, int),\n-        Threepar(int, int, int),\n+        Onepar(i32),\n+        Twopar(i32, i32),\n+        Threepar(i32, i32, i32),\n     }\n \n     #[derive(Clone, PartialEq, Debug)]\n     struct RecCy {\n-        x: int,\n-        y: int,\n+        x: i32,\n+        y: i32,\n         t: Taggy\n     }\n \n     #[test]\n     fn test_param_int() {\n-        test_parameterized::<int>(5, 72, 64, 175);\n+        test_parameterized::<i32>(5, 72, 64, 175);\n     }\n \n     #[test]\n@@ -1885,10 +1909,10 @@ mod tests {\n \n     #[test]\n     fn test_param_taggypar() {\n-        test_parameterized::<Taggypar<int>>(Onepar::<int>(1),\n-                                            Twopar::<int>(1, 2),\n-                                            Threepar::<int>(1, 2, 3),\n-                                            Twopar::<int>(17, 42));\n+        test_parameterized::<Taggypar<i32>>(Onepar::<i32>(1),\n+                                            Twopar::<i32>(1, 2),\n+                                            Threepar::<i32>(1, 2, 3),\n+                                            Twopar::<i32>(17, 42));\n     }\n \n     #[test]\n@@ -1903,17 +1927,17 @@ mod tests {\n     #[test]\n     fn test_with_capacity() {\n         let mut d = RingBuf::with_capacity(0);\n-        d.push_back(1i);\n+        d.push_back(1);\n         assert_eq!(d.len(), 1);\n         let mut d = RingBuf::with_capacity(50);\n-        d.push_back(1i);\n+        d.push_back(1);\n         assert_eq!(d.len(), 1);\n     }\n \n     #[test]\n     fn test_with_capacity_non_power_two() {\n         let mut d3 = RingBuf::with_capacity(3);\n-        d3.push_back(1i);\n+        d3.push_back(1);\n \n         // X = None, | = lo\n         // [|1, X, X]\n@@ -1977,10 +2001,10 @@ mod tests {\n \n     #[test]\n     fn test_swap() {\n-        let mut d: RingBuf<int> = (0i..5).collect();\n+        let mut d: RingBuf<i32> = (0..5).collect();\n         d.pop_front();\n         d.swap(0, 3);\n-        assert_eq!(d.iter().map(|&x|x).collect::<Vec<int>>(), vec!(4, 2, 3, 1));\n+        assert_eq!(d.iter().map(|&x|x).collect::<Vec<i32>>(), vec!(4, 2, 3, 1));\n     }\n \n     #[test]\n@@ -1989,20 +2013,20 @@ mod tests {\n         assert_eq!(d.iter().next(), None);\n         assert_eq!(d.iter().size_hint(), (0, Some(0)));\n \n-        for i in 0i..5 {\n+        for i in 0..5 {\n             d.push_back(i);\n         }\n         {\n             let b: &[_] = &[&0,&1,&2,&3,&4];\n-            assert_eq!(d.iter().collect::<Vec<&int>>(), b);\n+            assert_eq!(d.iter().collect::<Vec<&i32>>(), b);\n         }\n \n-        for i in 6i..9 {\n+        for i in 6..9 {\n             d.push_front(i);\n         }\n         {\n             let b: &[_] = &[&8,&7,&6,&0,&1,&2,&3,&4];\n-            assert_eq!(d.iter().collect::<Vec<&int>>(), b);\n+            assert_eq!(d.iter().collect::<Vec<&i32>>(), b);\n         }\n \n         let mut it = d.iter();\n@@ -2020,33 +2044,33 @@ mod tests {\n         let mut d = RingBuf::new();\n         assert_eq!(d.iter().rev().next(), None);\n \n-        for i in 0i..5 {\n+        for i in 0..5 {\n             d.push_back(i);\n         }\n         {\n             let b: &[_] = &[&4,&3,&2,&1,&0];\n-            assert_eq!(d.iter().rev().collect::<Vec<&int>>(), b);\n+            assert_eq!(d.iter().rev().collect::<Vec<&i32>>(), b);\n         }\n \n-        for i in 6i..9 {\n+        for i in 6..9 {\n             d.push_front(i);\n         }\n         let b: &[_] = &[&4,&3,&2,&1,&0,&6,&7,&8];\n-        assert_eq!(d.iter().rev().collect::<Vec<&int>>(), b);\n+        assert_eq!(d.iter().rev().collect::<Vec<&i32>>(), b);\n     }\n \n     #[test]\n     fn test_mut_rev_iter_wrap() {\n         let mut d = RingBuf::with_capacity(3);\n         assert!(d.iter_mut().rev().next().is_none());\n \n-        d.push_back(1i);\n+        d.push_back(1);\n         d.push_back(2);\n         d.push_back(3);\n         assert_eq!(d.pop_front(), Some(1));\n         d.push_back(4);\n \n-        assert_eq!(d.iter_mut().rev().map(|x| *x).collect::<Vec<int>>(),\n+        assert_eq!(d.iter_mut().rev().map(|x| *x).collect::<Vec<i32>>(),\n                    vec!(4, 3, 2));\n     }\n \n@@ -2101,7 +2125,7 @@ mod tests {\n \n         // Empty iter\n         {\n-            let d: RingBuf<int> = RingBuf::new();\n+            let d: RingBuf<i32> = RingBuf::new();\n             let mut iter = d.into_iter();\n \n             assert_eq!(iter.size_hint(), (0, Some(0)));\n@@ -2112,35 +2136,35 @@ mod tests {\n         // simple iter\n         {\n             let mut d = RingBuf::new();\n-            for i in 0i..5 {\n+            for i in 0..5 {\n                 d.push_back(i);\n             }\n \n             let b = vec![0,1,2,3,4];\n-            assert_eq!(d.into_iter().collect::<Vec<int>>(), b);\n+            assert_eq!(d.into_iter().collect::<Vec<i32>>(), b);\n         }\n \n         // wrapped iter\n         {\n             let mut d = RingBuf::new();\n-            for i in 0i..5 {\n+            for i in 0..5 {\n                 d.push_back(i);\n             }\n-            for i in 6i..9 {\n+            for i in 6..9 {\n                 d.push_front(i);\n             }\n \n             let b = vec![8,7,6,0,1,2,3,4];\n-            assert_eq!(d.into_iter().collect::<Vec<int>>(), b);\n+            assert_eq!(d.into_iter().collect::<Vec<i32>>(), b);\n         }\n \n         // partially used\n         {\n             let mut d = RingBuf::new();\n-            for i in 0i..5 {\n+            for i in 0..5 {\n                 d.push_back(i);\n             }\n-            for i in 6i..9 {\n+            for i in 6..9 {\n                 d.push_front(i);\n             }\n \n@@ -2160,7 +2184,7 @@ mod tests {\n \n         // Empty iter\n         {\n-            let mut d: RingBuf<int> = RingBuf::new();\n+            let mut d: RingBuf<i32> = RingBuf::new();\n \n             {\n                 let mut iter = d.drain();\n@@ -2176,35 +2200,35 @@ mod tests {\n         // simple iter\n         {\n             let mut d = RingBuf::new();\n-            for i in 0i..5 {\n+            for i in 0..5 {\n                 d.push_back(i);\n             }\n \n-            assert_eq!(d.drain().collect::<Vec<int>>(), [0, 1, 2, 3, 4]);\n+            assert_eq!(d.drain().collect::<Vec<_>>(), [0, 1, 2, 3, 4]);\n             assert!(d.is_empty());\n         }\n \n         // wrapped iter\n         {\n             let mut d = RingBuf::new();\n-            for i in 0i..5 {\n+            for i in 0..5 {\n                 d.push_back(i);\n             }\n-            for i in 6i..9 {\n+            for i in 6..9 {\n                 d.push_front(i);\n             }\n \n-            assert_eq!(d.drain().collect::<Vec<int>>(), [8,7,6,0,1,2,3,4]);\n+            assert_eq!(d.drain().collect::<Vec<_>>(), [8,7,6,0,1,2,3,4]);\n             assert!(d.is_empty());\n         }\n \n         // partially used\n         {\n-            let mut d = RingBuf::new();\n-            for i in 0i..5 {\n+            let mut d: RingBuf<i32> = RingBuf::new();\n+            for i in 0..5 {\n                 d.push_back(i);\n             }\n-            for i in 6i..9 {\n+            for i in 6..9 {\n                 d.push_front(i);\n             }\n \n@@ -2225,9 +2249,9 @@ mod tests {\n     #[test]\n     fn test_from_iter() {\n         use core::iter;\n-        let v = vec!(1i,2,3,4,5,6,7);\n-        let deq: RingBuf<int> = v.iter().map(|&x| x).collect();\n-        let u: Vec<int> = deq.iter().map(|&x| x).collect();\n+        let v = vec!(1,2,3,4,5,6,7);\n+        let deq: RingBuf<i32> = v.iter().map(|&x| x).collect();\n+        let u: Vec<i32> = deq.iter().map(|&x| x).collect();\n         assert_eq!(u, v);\n \n         let seq = iter::count(0u, 2).take(256);\n@@ -2241,7 +2265,7 @@ mod tests {\n     #[test]\n     fn test_clone() {\n         let mut d = RingBuf::new();\n-        d.push_front(17i);\n+        d.push_front(17);\n         d.push_front(42);\n         d.push_back(137);\n         d.push_back(137);\n@@ -2259,7 +2283,7 @@ mod tests {\n     fn test_eq() {\n         let mut d = RingBuf::new();\n         assert!(d == RingBuf::with_capacity(0));\n-        d.push_front(137i);\n+        d.push_front(137);\n         d.push_front(17);\n         d.push_front(42);\n         d.push_back(137);\n@@ -2281,12 +2305,12 @@ mod tests {\n       let mut x = RingBuf::new();\n       let mut y = RingBuf::new();\n \n-      x.push_back(1i);\n+      x.push_back(1);\n       x.push_back(2);\n       x.push_back(3);\n \n-      y.push_back(0i);\n-      y.push_back(1i);\n+      y.push_back(0);\n+      y.push_back(1);\n       y.pop_front();\n       y.push_back(2);\n       y.push_back(3);\n@@ -2298,7 +2322,7 @@ mod tests {\n     fn test_ord() {\n         let x = RingBuf::new();\n         let mut y = RingBuf::new();\n-        y.push_back(1i);\n+        y.push_back(1);\n         y.push_back(2);\n         y.push_back(3);\n         assert!(x < y);\n@@ -2309,7 +2333,7 @@ mod tests {\n \n     #[test]\n     fn test_show() {\n-        let ringbuf: RingBuf<int> = (0i..10).collect();\n+        let ringbuf: RingBuf<i32> = (0..10).collect();\n         assert_eq!(format!(\"{:?}\", ringbuf), \"RingBuf [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n \n         let ringbuf: RingBuf<&str> = vec![\"just\", \"one\", \"test\", \"more\"].iter()\n@@ -2389,49 +2413,49 @@ mod tests {\n         // test growth path A\n         // [T o o H] -> [T o o H . . . . ]\n         let mut ring = RingBuf::with_capacity(4);\n-        for i in 0i..3 {\n+        for i in 0..3 {\n             ring.push_back(i);\n         }\n         ring.reserve(7);\n-        for i in 0i..3 {\n+        for i in 0..3 {\n             assert_eq!(ring.pop_front(), Some(i));\n         }\n \n         // test growth path B\n         // [H T o o] -> [. T o o H . . . ]\n         let mut ring = RingBuf::with_capacity(4);\n-        for i in 0i..1 {\n+        for i in 0..1 {\n             ring.push_back(i);\n             assert_eq!(ring.pop_front(), Some(i));\n         }\n-        for i in 0i..3 {\n+        for i in 0..3 {\n             ring.push_back(i);\n         }\n         ring.reserve(7);\n-        for i in 0i..3 {\n+        for i in 0..3 {\n             assert_eq!(ring.pop_front(), Some(i));\n         }\n \n         // test growth path C\n         // [o o H T] -> [o o H . . . . T ]\n         let mut ring = RingBuf::with_capacity(4);\n-        for i in 0i..3 {\n+        for i in 0..3 {\n             ring.push_back(i);\n             assert_eq!(ring.pop_front(), Some(i));\n         }\n-        for i in 0i..3 {\n+        for i in 0..3 {\n             ring.push_back(i);\n         }\n         ring.reserve(7);\n-        for i in 0i..3 {\n+        for i in 0..3 {\n             assert_eq!(ring.pop_front(), Some(i));\n         }\n     }\n \n     #[test]\n     fn test_get() {\n         let mut ring = RingBuf::new();\n-        ring.push_back(0i);\n+        ring.push_back(0);\n         assert_eq!(ring.get(0), Some(&0));\n         assert_eq!(ring.get(1), None);\n \n@@ -2463,7 +2487,7 @@ mod tests {\n     #[test]\n     fn test_get_mut() {\n         let mut ring = RingBuf::new();\n-        for i in 0i..3 {\n+        for i in 0..3 {\n             ring.push_back(i);\n         }\n \n@@ -2633,8 +2657,8 @@ mod tests {\n     #[test]\n     fn test_front() {\n         let mut ring = RingBuf::new();\n-        ring.push_back(10i);\n-        ring.push_back(20i);\n+        ring.push_back(10);\n+        ring.push_back(20);\n         assert_eq!(ring.front(), Some(&10));\n         ring.pop_front();\n         assert_eq!(ring.front(), Some(&20));\n@@ -2644,8 +2668,8 @@ mod tests {\n \n     #[test]\n     fn test_as_slices() {\n-        let mut ring: RingBuf<int> = RingBuf::with_capacity(127);\n-        let cap = ring.capacity() as int;\n+        let mut ring: RingBuf<i32> = RingBuf::with_capacity(127);\n+        let cap = ring.capacity() as i32;\n         let first = cap/2;\n         let last  = cap - first;\n         for i in 0..first {\n@@ -2666,14 +2690,14 @@ mod tests {\n             assert_eq!(right, expected_right);\n         }\n \n-        assert_eq!(ring.len() as int, cap);\n-        assert_eq!(ring.capacity() as int, cap);\n+        assert_eq!(ring.len() as i32, cap);\n+        assert_eq!(ring.capacity() as i32, cap);\n     }\n \n     #[test]\n     fn test_as_mut_slices() {\n-        let mut ring: RingBuf<int> = RingBuf::with_capacity(127);\n-        let cap = ring.capacity() as int;\n+        let mut ring: RingBuf<i32> = RingBuf::with_capacity(127);\n+        let cap = ring.capacity() as i32;\n         let first = cap/2;\n         let last  = cap - first;\n         for i in 0..first {\n@@ -2694,7 +2718,7 @@ mod tests {\n             assert_eq!(right, expected_right);\n         }\n \n-        assert_eq!(ring.len() as int, cap);\n-        assert_eq!(ring.capacity() as int, cap);\n+        assert_eq!(ring.len() as i32, cap);\n+        assert_eq!(ring.capacity() as i32, cap);\n     }\n }"}, {"sha": "d2f92d1c8dba6d0876e4a680fe2fa23d357c40bf", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 191, "deletions": 191, "changes": 382, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -15,7 +15,7 @@\n //!\n //! ```rust\n //! // slicing a Vec\n-//! let vec = vec!(1i, 2, 3);\n+//! let vec = vec!(1, 2, 3);\n //! let int_slice = vec.as_slice();\n //! // coercing an array to a slice\n //! let str_slice: &[&str] = &[\"one\", \"two\", \"three\"];\n@@ -26,7 +26,7 @@\n //! block of memory that a mutable slice points to:\n //!\n //! ```rust\n-//! let x: &mut[int] = &mut [1i, 2, 3];\n+//! let x: &mut[int] = &mut [1, 2, 3];\n //! x[1] = 7;\n //! assert_eq!(x[0], 1);\n //! assert_eq!(x[1], 7);\n@@ -54,9 +54,9 @@\n //! ```rust\n //! #![feature(slicing_syntax)]\n //! fn main() {\n-//!     let numbers = [0i, 1i, 2i];\n+//!     let numbers = [0, 1, 2];\n //!     let last_numbers = &numbers[1..3];\n-//!     // last_numbers is now &[1i, 2i]\n+//!     // last_numbers is now &[1, 2]\n //! }\n //! ```\n //!\n@@ -76,7 +76,7 @@\n //! type of the slice is `int`, the element type of the iterator is `&int`.\n //!\n //! ```rust\n-//! let numbers = [0i, 1i, 2i];\n+//! let numbers = [0, 1, 2];\n //! for &x in numbers.iter() {\n //!     println!(\"{} is a number!\", x);\n //! }\n@@ -137,7 +137,7 @@ pub trait SliceExt {\n     /// # Examples\n     ///\n     /// ```rust\n-    /// let mut v = [5i, 4, 1, 3, 2];\n+    /// let mut v = [5, 4, 1, 3, 2];\n     /// v.sort_by(|a, b| a.cmp(b));\n     /// assert!(v == [1, 2, 3, 4, 5]);\n     ///\n@@ -163,11 +163,11 @@ pub trait SliceExt {\n     /// # Examples\n     ///\n     /// ```rust\n-    /// let mut a = [1i, 2, 3, 4, 5];\n-    /// let b = vec![6i, 7, 8];\n+    /// let mut a = [1, 2, 3, 4, 5];\n+    /// let b = vec![6, 7, 8];\n     /// let num_moved = a.move_from(b, 0, 3);\n     /// assert_eq!(num_moved, 3);\n-    /// assert!(a == [6i, 7, 8, 4, 5]);\n+    /// assert!(a == [6, 7, 8, 4, 5]);\n     /// ```\n     #[unstable(feature = \"collections\",\n                reason = \"uncertain about this API approach\")]\n@@ -285,7 +285,7 @@ pub trait SliceExt {\n     /// `[3,4]`):\n     ///\n     /// ```rust\n-    /// let v = &[1i, 2, 3, 4];\n+    /// let v = &[1, 2, 3, 4];\n     /// for win in v.windows(2) {\n     ///     println!(\"{:?}\", win);\n     /// }\n@@ -308,7 +308,7 @@ pub trait SliceExt {\n     /// `[3,4]`, `[5]`):\n     ///\n     /// ```rust\n-    /// let v = &[1i, 2, 3, 4, 5];\n+    /// let v = &[1, 2, 3, 4, 5];\n     /// for win in v.chunks(2) {\n     ///     println!(\"{:?}\", win);\n     /// }\n@@ -399,7 +399,7 @@ pub trait SliceExt {\n     /// found; the fourth could match any position in `[1,4]`.\n     ///\n     /// ```rust\n-    /// let s = [0i, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n+    /// let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n     /// let s = s.as_slice();\n     ///\n     /// let seek = 13;\n@@ -421,7 +421,7 @@ pub trait SliceExt {\n     /// # Example\n     ///\n     /// ```\n-    /// let a = [1i, 2, 3];\n+    /// let a = [1, 2, 3];\n     /// assert_eq!(a.len(), 3);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -432,7 +432,7 @@ pub trait SliceExt {\n     /// # Example\n     ///\n     /// ```\n-    /// let a = [1i, 2, 3];\n+    /// let a = [1, 2, 3];\n     /// assert!(!a.is_empty());\n     /// ```\n     #[inline]\n@@ -554,24 +554,24 @@ pub trait SliceExt {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let mut v = [1i, 2, 3, 4, 5, 6];\n+    /// let mut v = [1, 2, 3, 4, 5, 6];\n     ///\n     /// // scoped to restrict the lifetime of the borrows\n     /// {\n     ///    let (left, right) = v.split_at_mut(0);\n     ///    assert!(left == []);\n-    ///    assert!(right == [1i, 2, 3, 4, 5, 6]);\n+    ///    assert!(right == [1, 2, 3, 4, 5, 6]);\n     /// }\n     ///\n     /// {\n     ///     let (left, right) = v.split_at_mut(2);\n-    ///     assert!(left == [1i, 2]);\n-    ///     assert!(right == [3i, 4, 5, 6]);\n+    ///     assert!(left == [1, 2]);\n+    ///     assert!(right == [3, 4, 5, 6]);\n     /// }\n     ///\n     /// {\n     ///     let (left, right) = v.split_at_mut(6);\n-    ///     assert!(left == [1i, 2, 3, 4, 5, 6]);\n+    ///     assert!(left == [1, 2, 3, 4, 5, 6]);\n     ///     assert!(right == []);\n     /// }\n     /// ```\n@@ -583,9 +583,9 @@ pub trait SliceExt {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let mut v = [1i, 2, 3];\n+    /// let mut v = [1, 2, 3];\n     /// v.reverse();\n-    /// assert!(v == [3i, 2, 1]);\n+    /// assert!(v == [3, 2, 1]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn reverse(&mut self);\n@@ -615,7 +615,7 @@ pub trait SliceExt {\n     /// # Examples\n     ///\n     /// ```rust\n-    /// let v = [1i, 2, 3];\n+    /// let v = [1, 2, 3];\n     /// let mut perms = v.permutations();\n     ///\n     /// for p in perms {\n@@ -626,12 +626,12 @@ pub trait SliceExt {\n     /// Iterating through permutations one by one.\n     ///\n     /// ```rust\n-    /// let v = [1i, 2, 3];\n+    /// let v = [1, 2, 3];\n     /// let mut perms = v.permutations();\n     ///\n-    /// assert_eq!(Some(vec![1i, 2, 3]), perms.next());\n-    /// assert_eq!(Some(vec![1i, 3, 2]), perms.next());\n-    /// assert_eq!(Some(vec![3i, 1, 2]), perms.next());\n+    /// assert_eq!(Some(vec![1, 2, 3]), perms.next());\n+    /// assert_eq!(Some(vec![1, 3, 2]), perms.next());\n+    /// assert_eq!(Some(vec![3, 1, 2]), perms.next());\n     /// ```\n     #[unstable(feature = \"collections\")]\n     fn permutations(&self) -> Permutations<Self::Item> where Self::Item: Clone;\n@@ -643,15 +643,15 @@ pub trait SliceExt {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let mut dst = [0i, 0, 0];\n-    /// let src = [1i, 2];\n+    /// let mut dst = [0, 0, 0];\n+    /// let src = [1, 2];\n     ///\n     /// assert!(dst.clone_from_slice(&src) == 2);\n     /// assert!(dst == [1, 2, 0]);\n     ///\n-    /// let src2 = [3i, 4, 5, 6];\n+    /// let src2 = [3, 4, 5, 6];\n     /// assert!(dst.clone_from_slice(&src2) == 3);\n-    /// assert!(dst == [3i, 4, 5]);\n+    /// assert!(dst == [3, 4, 5]);\n     /// ```\n     #[unstable(feature = \"collections\")]\n     fn clone_from_slice(&mut self, &[Self::Item]) -> uint where Self::Item: Clone;\n@@ -663,10 +663,10 @@ pub trait SliceExt {\n     /// # Examples\n     ///\n     /// ```rust\n-    /// let mut v = [-5i, 4, 1, -3, 2];\n+    /// let mut v = [-5, 4, 1, -3, 2];\n     ///\n     /// v.sort();\n-    /// assert!(v == [-5i, -3, 1, 2, 4]);\n+    /// assert!(v == [-5, -3, 1, 2, 4]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn sort(&mut self) where Self::Item: Ord;\n@@ -685,7 +685,7 @@ pub trait SliceExt {\n     /// found; the fourth could match any position in `[1,4]`.\n     ///\n     /// ```rust\n-    /// let s = [0i, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n+    /// let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n     /// let s = s.as_slice();\n     ///\n     /// assert_eq!(s.binary_search(&13),  Ok(9));\n@@ -712,12 +712,12 @@ pub trait SliceExt {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let v: &mut [_] = &mut [0i, 1, 2];\n+    /// let v: &mut [_] = &mut [0, 1, 2];\n     /// v.next_permutation();\n-    /// let b: &mut [_] = &mut [0i, 2, 1];\n+    /// let b: &mut [_] = &mut [0, 2, 1];\n     /// assert!(v == b);\n     /// v.next_permutation();\n-    /// let b: &mut [_] = &mut [1i, 0, 2];\n+    /// let b: &mut [_] = &mut [1, 0, 2];\n     /// assert!(v == b);\n     /// ```\n     #[unstable(feature = \"collections\",\n@@ -732,12 +732,12 @@ pub trait SliceExt {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let v: &mut [_] = &mut [1i, 0, 2];\n+    /// let v: &mut [_] = &mut [1, 0, 2];\n     /// v.prev_permutation();\n-    /// let b: &mut [_] = &mut [0i, 2, 1];\n+    /// let b: &mut [_] = &mut [0, 2, 1];\n     /// assert!(v == b);\n     /// v.prev_permutation();\n-    /// let b: &mut [_] = &mut [0i, 1, 2];\n+    /// let b: &mut [_] = &mut [0, 1, 2];\n     /// assert!(v == b);\n     /// ```\n     #[unstable(feature = \"collections\",\n@@ -1582,7 +1582,7 @@ mod tests {\n     fn test_is_empty() {\n         let xs: [int; 0] = [];\n         assert!(xs.is_empty());\n-        assert!(![0i].is_empty());\n+        assert!(![0].is_empty());\n     }\n \n     #[test]\n@@ -1599,50 +1599,50 @@ mod tests {\n \n     #[test]\n     fn test_get() {\n-        let mut a = vec![11i];\n+        let mut a = vec![11];\n         assert_eq!(a.get(1), None);\n-        a = vec![11i, 12];\n+        a = vec![11, 12];\n         assert_eq!(a.get(1).unwrap(), &12);\n-        a = vec![11i, 12, 13];\n+        a = vec![11, 12, 13];\n         assert_eq!(a.get(1).unwrap(), &12);\n     }\n \n     #[test]\n     fn test_first() {\n         let mut a = vec![];\n         assert_eq!(a.first(), None);\n-        a = vec![11i];\n+        a = vec![11];\n         assert_eq!(a.first().unwrap(), &11);\n-        a = vec![11i, 12];\n+        a = vec![11, 12];\n         assert_eq!(a.first().unwrap(), &11);\n     }\n \n     #[test]\n     fn test_first_mut() {\n         let mut a = vec![];\n         assert_eq!(a.first_mut(), None);\n-        a = vec![11i];\n+        a = vec![11];\n         assert_eq!(*a.first_mut().unwrap(), 11);\n-        a = vec![11i, 12];\n+        a = vec![11, 12];\n         assert_eq!(*a.first_mut().unwrap(), 11);\n     }\n \n     #[test]\n     fn test_tail() {\n-        let mut a = vec![11i];\n+        let mut a = vec![11];\n         let b: &[int] = &[];\n         assert_eq!(a.tail(), b);\n-        a = vec![11i, 12];\n+        a = vec![11, 12];\n         let b: &[int] = &[12];\n         assert_eq!(a.tail(), b);\n     }\n \n     #[test]\n     fn test_tail_mut() {\n-        let mut a = vec![11i];\n+        let mut a = vec![11];\n         let b: &mut [int] = &mut [];\n         assert!(a.tail_mut() == b);\n-        a = vec![11i, 12];\n+        a = vec![11, 12];\n         let b: &mut [int] = &mut [12];\n         assert!(a.tail_mut() == b);\n     }\n@@ -1663,20 +1663,20 @@ mod tests {\n \n     #[test]\n     fn test_init() {\n-        let mut a = vec![11i];\n+        let mut a = vec![11];\n         let b: &[int] = &[];\n         assert_eq!(a.init(), b);\n-        a = vec![11i, 12];\n+        a = vec![11, 12];\n         let b: &[int] = &[11];\n         assert_eq!(a.init(), b);\n     }\n \n     #[test]\n     fn test_init_mut() {\n-        let mut a = vec![11i];\n+        let mut a = vec![11];\n         let b: &mut [int] = &mut [];\n         assert!(a.init_mut() == b);\n-        a = vec![11i, 12];\n+        a = vec![11, 12];\n         let b: &mut [int] = &mut [11];\n         assert!(a.init_mut() == b);\n     }\n@@ -1699,26 +1699,26 @@ mod tests {\n     fn test_last() {\n         let mut a = vec![];\n         assert_eq!(a.last(), None);\n-        a = vec![11i];\n+        a = vec![11];\n         assert_eq!(a.last().unwrap(), &11);\n-        a = vec![11i, 12];\n+        a = vec![11, 12];\n         assert_eq!(a.last().unwrap(), &12);\n     }\n \n     #[test]\n     fn test_last_mut() {\n         let mut a = vec![];\n         assert_eq!(a.last_mut(), None);\n-        a = vec![11i];\n+        a = vec![11];\n         assert_eq!(*a.last_mut().unwrap(), 11);\n-        a = vec![11i, 12];\n+        a = vec![11, 12];\n         assert_eq!(*a.last_mut().unwrap(), 12);\n     }\n \n     #[test]\n     fn test_slice() {\n         // Test fixed length vector.\n-        let vec_fixed = [1i, 2, 3, 4];\n+        let vec_fixed = [1, 2, 3, 4];\n         let v_a = vec_fixed[1u..vec_fixed.len()].to_vec();\n         assert_eq!(v_a.len(), 3u);\n         let v_a = v_a.as_slice();\n@@ -1727,15 +1727,15 @@ mod tests {\n         assert_eq!(v_a[2], 4);\n \n         // Test on stack.\n-        let vec_stack: &[_] = &[1i, 2, 3];\n+        let vec_stack: &[_] = &[1, 2, 3];\n         let v_b = vec_stack[1u..3u].to_vec();\n         assert_eq!(v_b.len(), 2u);\n         let v_b = v_b.as_slice();\n         assert_eq!(v_b[0], 2);\n         assert_eq!(v_b[1], 3);\n \n         // Test `Box<[T]>`\n-        let vec_unique = vec![1i, 2, 3, 4, 5, 6];\n+        let vec_unique = vec![1, 2, 3, 4, 5, 6];\n         let v_d = vec_unique[1u..6u].to_vec();\n         assert_eq!(v_d.len(), 5u);\n         let v_d = v_d.as_slice();\n@@ -1769,7 +1769,7 @@ mod tests {\n \n     #[test]\n     fn test_pop() {\n-        let mut v = vec![5i];\n+        let mut v = vec![5];\n         let e = v.pop();\n         assert_eq!(v.len(), 0);\n         assert_eq!(e, Some(5));\n@@ -1781,19 +1781,19 @@ mod tests {\n \n     #[test]\n     fn test_swap_remove() {\n-        let mut v = vec![1i, 2, 3, 4, 5];\n+        let mut v = vec![1, 2, 3, 4, 5];\n         let mut e = v.swap_remove(0);\n         assert_eq!(e, 1);\n-        assert_eq!(v, vec![5i, 2, 3, 4]);\n+        assert_eq!(v, vec![5, 2, 3, 4]);\n         e = v.swap_remove(3);\n         assert_eq!(e, 4);\n-        assert_eq!(v, vec![5i, 2, 3]);\n+        assert_eq!(v, vec![5, 2, 3]);\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_swap_remove_fail() {\n-        let mut v = vec![1i];\n+        let mut v = vec![1];\n         let _ = v.swap_remove(0);\n         let _ = v.swap_remove(0);\n     }\n@@ -1817,20 +1817,20 @@ mod tests {\n     fn test_push() {\n         // Test on-stack push().\n         let mut v = vec![];\n-        v.push(1i);\n+        v.push(1);\n         assert_eq!(v.len(), 1u);\n         assert_eq!(v.as_slice()[0], 1);\n \n         // Test on-heap push().\n-        v.push(2i);\n+        v.push(2);\n         assert_eq!(v.len(), 2u);\n         assert_eq!(v.as_slice()[0], 1);\n         assert_eq!(v.as_slice()[1], 2);\n     }\n \n     #[test]\n     fn test_truncate() {\n-        let mut v = vec![box 6i,box 5,box 4];\n+        let mut v = vec![box 6,box 5,box 4];\n         v.truncate(1);\n         let v = v.as_slice();\n         assert_eq!(v.len(), 1);\n@@ -1840,7 +1840,7 @@ mod tests {\n \n     #[test]\n     fn test_clear() {\n-        let mut v = vec![box 6i,box 5,box 4];\n+        let mut v = vec![box 6,box 5,box 4];\n         v.clear();\n         assert_eq!(v.len(), 0);\n         // If the unsafe block didn't drop things properly, we blow up here.\n@@ -1865,11 +1865,11 @@ mod tests {\n \n     #[test]\n     fn test_dedup_unique() {\n-        let mut v0 = vec![box 1i, box 1, box 2, box 3];\n+        let mut v0 = vec![box 1, box 1, box 2, box 3];\n         v0.dedup();\n-        let mut v1 = vec![box 1i, box 2, box 2, box 3];\n+        let mut v1 = vec![box 1, box 2, box 2, box 3];\n         v1.dedup();\n-        let mut v2 = vec![box 1i, box 2, box 3, box 3];\n+        let mut v2 = vec![box 1, box 2, box 3, box 3];\n         v2.dedup();\n         /*\n          * If the boxed pointers were leaked or otherwise misused, valgrind\n@@ -1879,11 +1879,11 @@ mod tests {\n \n     #[test]\n     fn test_dedup_shared() {\n-        let mut v0 = vec![box 1i, box 1, box 2, box 3];\n+        let mut v0 = vec![box 1, box 1, box 2, box 3];\n         v0.dedup();\n-        let mut v1 = vec![box 1i, box 2, box 2, box 3];\n+        let mut v1 = vec![box 1, box 2, box 2, box 3];\n         v1.dedup();\n-        let mut v2 = vec![box 1i, box 2, box 3, box 3];\n+        let mut v2 = vec![box 1, box 2, box 3, box 3];\n         v2.dedup();\n         /*\n          * If the pointers were leaked or otherwise misused, valgrind and/or\n@@ -1900,7 +1900,7 @@ mod tests {\n \n     #[test]\n     fn test_element_swaps() {\n-        let mut v = [1i, 2, 3];\n+        let mut v = [1, 2, 3];\n         for (i, (a, b)) in ElementSwaps::new(v.len()).enumerate() {\n             v.swap(a, b);\n             match i {\n@@ -1936,7 +1936,7 @@ mod tests {\n             assert_eq!(it.next(), None);\n         }\n         {\n-            let v = [1i, 2, 3];\n+            let v = [1, 2, 3];\n             let mut it = v.permutations();\n             let (min_size, max_opt) = it.size_hint();\n             assert_eq!(min_size, 3*2);\n@@ -1958,7 +1958,7 @@ mod tests {\n             let mut amt = 0;\n             let mut it = v.permutations();\n             let (min_size, max_opt) = it.size_hint();\n-            for _perm in it {\n+            for _perm in it.by_ref() {\n                 amt += 1;\n             }\n             assert_eq!(amt, it.swaps.swaps_made);\n@@ -1970,7 +1970,7 @@ mod tests {\n \n     #[test]\n     fn test_lexicographic_permutations() {\n-        let v : &mut[int] = &mut[1i, 2, 3, 4, 5];\n+        let v : &mut[int] = &mut[1, 2, 3, 4, 5];\n         assert!(v.prev_permutation() == false);\n         assert!(v.next_permutation());\n         let b: &mut[int] = &mut[1, 2, 3, 5, 4];\n@@ -1986,7 +1986,7 @@ mod tests {\n         let b: &mut[int] = &mut[1, 2, 4, 5, 3];\n         assert!(v == b);\n \n-        let v : &mut[int] = &mut[1i, 0, 0, 0];\n+        let v : &mut[int] = &mut[1, 0, 0, 0];\n         assert!(v.next_permutation() == false);\n         assert!(v.prev_permutation());\n         let b: &mut[int] = &mut[0, 1, 0, 0];\n@@ -2009,14 +2009,14 @@ mod tests {\n         assert!(empty.prev_permutation() == false);\n         assert!(empty == b);\n \n-        let one_elem : &mut[int] = &mut[4i];\n+        let one_elem : &mut[int] = &mut[4];\n         assert!(one_elem.prev_permutation() == false);\n         let b: &mut[int] = &mut[4];\n         assert!(one_elem == b);\n         assert!(one_elem.next_permutation() == false);\n         assert!(one_elem == b);\n \n-        let two_elem : &mut[int] = &mut[1i, 2];\n+        let two_elem : &mut[int] = &mut[1, 2];\n         assert!(two_elem.prev_permutation() == false);\n         let b : &mut[int] = &mut[1, 2];\n         let c : &mut[int] = &mut[2, 1];\n@@ -2033,9 +2033,9 @@ mod tests {\n \n     #[test]\n     fn test_position_elem() {\n-        assert!([].position_elem(&1i).is_none());\n+        assert!([].position_elem(&1).is_none());\n \n-        let v1 = vec![1i, 2, 3, 3, 2, 5];\n+        let v1 = vec![1, 2, 3, 3, 2, 5];\n         assert_eq!(v1.position_elem(&1), Some(0u));\n         assert_eq!(v1.position_elem(&2), Some(1u));\n         assert_eq!(v1.position_elem(&5), Some(5u));\n@@ -2044,52 +2044,52 @@ mod tests {\n \n     #[test]\n     fn test_binary_search() {\n-        assert_eq!([1i,2,3,4,5].binary_search(&5).ok(), Some(4));\n-        assert_eq!([1i,2,3,4,5].binary_search(&4).ok(), Some(3));\n-        assert_eq!([1i,2,3,4,5].binary_search(&3).ok(), Some(2));\n-        assert_eq!([1i,2,3,4,5].binary_search(&2).ok(), Some(1));\n-        assert_eq!([1i,2,3,4,5].binary_search(&1).ok(), Some(0));\n+        assert_eq!([1,2,3,4,5].binary_search(&5).ok(), Some(4));\n+        assert_eq!([1,2,3,4,5].binary_search(&4).ok(), Some(3));\n+        assert_eq!([1,2,3,4,5].binary_search(&3).ok(), Some(2));\n+        assert_eq!([1,2,3,4,5].binary_search(&2).ok(), Some(1));\n+        assert_eq!([1,2,3,4,5].binary_search(&1).ok(), Some(0));\n \n-        assert_eq!([2i,4,6,8,10].binary_search(&1).ok(), None);\n-        assert_eq!([2i,4,6,8,10].binary_search(&5).ok(), None);\n-        assert_eq!([2i,4,6,8,10].binary_search(&4).ok(), Some(1));\n-        assert_eq!([2i,4,6,8,10].binary_search(&10).ok(), Some(4));\n+        assert_eq!([2,4,6,8,10].binary_search(&1).ok(), None);\n+        assert_eq!([2,4,6,8,10].binary_search(&5).ok(), None);\n+        assert_eq!([2,4,6,8,10].binary_search(&4).ok(), Some(1));\n+        assert_eq!([2,4,6,8,10].binary_search(&10).ok(), Some(4));\n \n-        assert_eq!([2i,4,6,8].binary_search(&1).ok(), None);\n-        assert_eq!([2i,4,6,8].binary_search(&5).ok(), None);\n-        assert_eq!([2i,4,6,8].binary_search(&4).ok(), Some(1));\n-        assert_eq!([2i,4,6,8].binary_search(&8).ok(), Some(3));\n+        assert_eq!([2,4,6,8].binary_search(&1).ok(), None);\n+        assert_eq!([2,4,6,8].binary_search(&5).ok(), None);\n+        assert_eq!([2,4,6,8].binary_search(&4).ok(), Some(1));\n+        assert_eq!([2,4,6,8].binary_search(&8).ok(), Some(3));\n \n-        assert_eq!([2i,4,6].binary_search(&1).ok(), None);\n-        assert_eq!([2i,4,6].binary_search(&5).ok(), None);\n-        assert_eq!([2i,4,6].binary_search(&4).ok(), Some(1));\n-        assert_eq!([2i,4,6].binary_search(&6).ok(), Some(2));\n+        assert_eq!([2,4,6].binary_search(&1).ok(), None);\n+        assert_eq!([2,4,6].binary_search(&5).ok(), None);\n+        assert_eq!([2,4,6].binary_search(&4).ok(), Some(1));\n+        assert_eq!([2,4,6].binary_search(&6).ok(), Some(2));\n \n-        assert_eq!([2i,4].binary_search(&1).ok(), None);\n-        assert_eq!([2i,4].binary_search(&5).ok(), None);\n-        assert_eq!([2i,4].binary_search(&2).ok(), Some(0));\n-        assert_eq!([2i,4].binary_search(&4).ok(), Some(1));\n+        assert_eq!([2,4].binary_search(&1).ok(), None);\n+        assert_eq!([2,4].binary_search(&5).ok(), None);\n+        assert_eq!([2,4].binary_search(&2).ok(), Some(0));\n+        assert_eq!([2,4].binary_search(&4).ok(), Some(1));\n \n-        assert_eq!([2i].binary_search(&1).ok(), None);\n-        assert_eq!([2i].binary_search(&5).ok(), None);\n-        assert_eq!([2i].binary_search(&2).ok(), Some(0));\n+        assert_eq!([2].binary_search(&1).ok(), None);\n+        assert_eq!([2].binary_search(&5).ok(), None);\n+        assert_eq!([2].binary_search(&2).ok(), Some(0));\n \n-        assert_eq!([].binary_search(&1i).ok(), None);\n-        assert_eq!([].binary_search(&5i).ok(), None);\n+        assert_eq!([].binary_search(&1).ok(), None);\n+        assert_eq!([].binary_search(&5).ok(), None);\n \n-        assert!([1i,1,1,1,1].binary_search(&1).ok() != None);\n-        assert!([1i,1,1,1,2].binary_search(&1).ok() != None);\n-        assert!([1i,1,1,2,2].binary_search(&1).ok() != None);\n-        assert!([1i,1,2,2,2].binary_search(&1).ok() != None);\n-        assert_eq!([1i,2,2,2,2].binary_search(&1).ok(), Some(0));\n+        assert!([1,1,1,1,1].binary_search(&1).ok() != None);\n+        assert!([1,1,1,1,2].binary_search(&1).ok() != None);\n+        assert!([1,1,1,2,2].binary_search(&1).ok() != None);\n+        assert!([1,1,2,2,2].binary_search(&1).ok() != None);\n+        assert_eq!([1,2,2,2,2].binary_search(&1).ok(), Some(0));\n \n-        assert_eq!([1i,2,3,4,5].binary_search(&6).ok(), None);\n-        assert_eq!([1i,2,3,4,5].binary_search(&0).ok(), None);\n+        assert_eq!([1,2,3,4,5].binary_search(&6).ok(), None);\n+        assert_eq!([1,2,3,4,5].binary_search(&0).ok(), None);\n     }\n \n     #[test]\n     fn test_reverse() {\n-        let mut v: Vec<int> = vec![10i, 20];\n+        let mut v: Vec<int> = vec![10, 20];\n         assert_eq!(v[0], 10);\n         assert_eq!(v[1], 20);\n         v.reverse();\n@@ -2104,7 +2104,7 @@ mod tests {\n     #[test]\n     fn test_sort() {\n         for len in 4u..25 {\n-            for _ in 0i..100 {\n+            for _ in 0..100 {\n                 let mut v = thread_rng().gen_iter::<uint>().take(len)\n                                       .collect::<Vec<uint>>();\n                 let mut v1 = v.clone();\n@@ -2131,9 +2131,9 @@ mod tests {\n \n     #[test]\n     fn test_sort_stability() {\n-        for len in 4i..25 {\n+        for len in 4..25 {\n             for _ in 0u..10 {\n-                let mut counts = [0i; 10];\n+                let mut counts = [0; 10];\n \n                 // create a vector like [(6, 1), (5, 1), (6, 2), ...],\n                 // where the first item of each tuple is random, but\n@@ -2165,21 +2165,21 @@ mod tests {\n         let v: [Vec<int>; 0] = [];\n         let c: Vec<int> = v.concat();\n         assert_eq!(c, []);\n-        let d: Vec<int> = [vec![1i], vec![2i,3i]].concat();\n-        assert_eq!(d, vec![1i, 2, 3]);\n+        let d: Vec<int> = [vec![1], vec![2,3]].concat();\n+        assert_eq!(d, vec![1, 2, 3]);\n \n         let v: [&[int]; 2] = [&[1], &[2, 3]];\n-        assert_eq!(v.connect(&0), vec![1i, 0, 2, 3]);\n-        let v: [&[int]; 3] = [&[1i], &[2], &[3]];\n-        assert_eq!(v.connect(&0), vec![1i, 0, 2, 0, 3]);\n+        assert_eq!(v.connect(&0), vec![1, 0, 2, 3]);\n+        let v: [&[int]; 3] = [&[1], &[2], &[3]];\n+        assert_eq!(v.connect(&0), vec![1, 0, 2, 0, 3]);\n     }\n \n     #[test]\n     fn test_connect() {\n         let v: [Vec<int>; 0] = [];\n         assert_eq!(v.connect(&0), vec![]);\n-        assert_eq!([vec![1i], vec![2i, 3]].connect(&0), vec![1, 0, 2, 3]);\n-        assert_eq!([vec![1i], vec![2i], vec![3i]].connect(&0), vec![1, 0, 2, 0, 3]);\n+        assert_eq!([vec![1], vec![2, 3]].connect(&0), vec![1, 0, 2, 3]);\n+        assert_eq!([vec![1], vec![2], vec![3]].connect(&0), vec![1, 0, 2, 0, 3]);\n \n         let v: [&[int]; 2] = [&[1], &[2, 3]];\n         assert_eq!(v.connect(&0), vec![1, 0, 2, 3]);\n@@ -2189,42 +2189,42 @@ mod tests {\n \n     #[test]\n     fn test_insert() {\n-        let mut a = vec![1i, 2, 4];\n+        let mut a = vec![1, 2, 4];\n         a.insert(2, 3);\n         assert_eq!(a, vec![1, 2, 3, 4]);\n \n-        let mut a = vec![1i, 2, 3];\n+        let mut a = vec![1, 2, 3];\n         a.insert(0, 0);\n         assert_eq!(a, vec![0, 1, 2, 3]);\n \n-        let mut a = vec![1i, 2, 3];\n+        let mut a = vec![1, 2, 3];\n         a.insert(3, 4);\n         assert_eq!(a, vec![1, 2, 3, 4]);\n \n         let mut a = vec![];\n-        a.insert(0, 1i);\n+        a.insert(0, 1);\n         assert_eq!(a, vec![1]);\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_insert_oob() {\n-        let mut a = vec![1i, 2, 3];\n+        let mut a = vec![1, 2, 3];\n         a.insert(4, 5);\n     }\n \n     #[test]\n     fn test_remove() {\n-        let mut a = vec![1i,2,3,4];\n+        let mut a = vec![1,2,3,4];\n \n         assert_eq!(a.remove(2), 3);\n-        assert_eq!(a, vec![1i,2,4]);\n+        assert_eq!(a, vec![1,2,4]);\n \n         assert_eq!(a.remove(2), 4);\n-        assert_eq!(a, vec![1i,2]);\n+        assert_eq!(a, vec![1,2]);\n \n         assert_eq!(a.remove(0), 1);\n-        assert_eq!(a, vec![2i]);\n+        assert_eq!(a, vec![2]);\n \n         assert_eq!(a.remove(0), 2);\n         assert_eq!(a, vec![]);\n@@ -2233,7 +2233,7 @@ mod tests {\n     #[test]\n     #[should_fail]\n     fn test_remove_fail() {\n-        let mut a = vec![1i];\n+        let mut a = vec![1];\n         let _ = a.remove(0);\n         let _ = a.remove(0);\n     }\n@@ -2250,7 +2250,7 @@ mod tests {\n \n     #[test]\n     fn test_slice_2() {\n-        let v = vec![1i, 2, 3, 4, 5];\n+        let v = vec![1, 2, 3, 4, 5];\n         let v = v.slice(1u, 3u);\n         assert_eq!(v.len(), 2u);\n         assert_eq!(v[0], 2);\n@@ -2260,8 +2260,8 @@ mod tests {\n     #[test]\n     #[should_fail]\n     fn test_permute_fail() {\n-        let v = [(box 0i, Rc::new(0i)), (box 0i, Rc::new(0i)),\n-                 (box 0i, Rc::new(0i)), (box 0i, Rc::new(0i))];\n+        let v = [(box 0, Rc::new(0)), (box 0, Rc::new(0)),\n+                 (box 0, Rc::new(0)), (box 0, Rc::new(0))];\n         let mut i = 0u;\n         for _ in v.permutations() {\n             if i == 2 {\n@@ -2287,7 +2287,7 @@ mod tests {\n \n     #[test]\n     fn test_iterator() {\n-        let xs = [1i, 2, 5, 10, 11];\n+        let xs = [1, 2, 5, 10, 11];\n         let mut it = xs.iter();\n         assert_eq!(it.size_hint(), (5, Some(5)));\n         assert_eq!(it.next().unwrap(), &1);\n@@ -2305,7 +2305,7 @@ mod tests {\n \n     #[test]\n     fn test_random_access_iterator() {\n-        let xs = [1i, 2, 5, 10, 11];\n+        let xs = [1, 2, 5, 10, 11];\n         let mut it = xs.iter();\n \n         assert_eq!(it.indexable(), 5);\n@@ -2343,14 +2343,14 @@ mod tests {\n \n     #[test]\n     fn test_iter_size_hints() {\n-        let mut xs = [1i, 2, 5, 10, 11];\n+        let mut xs = [1, 2, 5, 10, 11];\n         assert_eq!(xs.iter().size_hint(), (5, Some(5)));\n         assert_eq!(xs.iter_mut().size_hint(), (5, Some(5)));\n     }\n \n     #[test]\n     fn test_iter_clone() {\n-        let xs = [1i, 2, 5];\n+        let xs = [1, 2, 5];\n         let mut it = xs.iter();\n         it.next();\n         let mut jt = it.clone();\n@@ -2361,7 +2361,7 @@ mod tests {\n \n     #[test]\n     fn test_mut_iterator() {\n-        let mut xs = [1i, 2, 3, 4, 5];\n+        let mut xs = [1, 2, 3, 4, 5];\n         for x in xs.iter_mut() {\n             *x += 1;\n         }\n@@ -2371,7 +2371,7 @@ mod tests {\n     #[test]\n     fn test_rev_iterator() {\n \n-        let xs = [1i, 2, 5, 10, 11];\n+        let xs = [1, 2, 5, 10, 11];\n         let ys = [11, 10, 5, 2, 1];\n         let mut i = 0;\n         for &x in xs.iter().rev() {\n@@ -2404,7 +2404,7 @@ mod tests {\n \n     #[test]\n     fn test_splitator() {\n-        let xs = &[1i,2,3,4,5];\n+        let xs = &[1,2,3,4,5];\n \n         let splits: &[&[int]] = &[&[1], &[3], &[5]];\n         assert_eq!(xs.split(|x| *x % 2 == 0).collect::<Vec<&[int]>>(),\n@@ -2429,7 +2429,7 @@ mod tests {\n \n     #[test]\n     fn test_splitnator() {\n-        let xs = &[1i,2,3,4,5];\n+        let xs = &[1,2,3,4,5];\n \n         let splits: &[&[int]] = &[&[1,2,3,4,5]];\n         assert_eq!(xs.splitn(0, |x| *x % 2 == 0).collect::<Vec<&[int]>>(),\n@@ -2448,7 +2448,7 @@ mod tests {\n \n     #[test]\n     fn test_splitnator_mut() {\n-        let xs = &mut [1i,2,3,4,5];\n+        let xs = &mut [1,2,3,4,5];\n \n         let splits: &[&mut [int]] = &[&mut [1,2,3,4,5]];\n         assert_eq!(xs.splitn_mut(0, |x| *x % 2 == 0).collect::<Vec<&mut [int]>>(),\n@@ -2468,7 +2468,7 @@ mod tests {\n \n     #[test]\n     fn test_rsplitator() {\n-        let xs = &[1i,2,3,4,5];\n+        let xs = &[1,2,3,4,5];\n \n         let splits: &[&[int]] = &[&[5], &[3], &[1]];\n         assert_eq!(xs.split(|x| *x % 2 == 0).rev().collect::<Vec<&[int]>>(),\n@@ -2509,38 +2509,38 @@ mod tests {\n \n     #[test]\n     fn test_windowsator() {\n-        let v = &[1i,2,3,4];\n+        let v = &[1,2,3,4];\n \n         let wins: &[&[int]] = &[&[1,2], &[2,3], &[3,4]];\n         assert_eq!(v.windows(2).collect::<Vec<&[int]>>(), wins);\n-        let wins: &[&[int]] = &[&[1i,2,3], &[2,3,4]];\n+        let wins: &[&[int]] = &[&[1,2,3], &[2,3,4]];\n         assert_eq!(v.windows(3).collect::<Vec<&[int]>>(), wins);\n         assert!(v.windows(6).next().is_none());\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_windowsator_0() {\n-        let v = &[1i,2,3,4];\n+        let v = &[1,2,3,4];\n         let _it = v.windows(0);\n     }\n \n     #[test]\n     fn test_chunksator() {\n         use core::iter::ExactSizeIterator;\n \n-        let v = &[1i,2,3,4,5];\n+        let v = &[1,2,3,4,5];\n \n         assert_eq!(v.chunks(2).len(), 3);\n \n-        let chunks: &[&[int]] = &[&[1i,2], &[3,4], &[5]];\n+        let chunks: &[&[int]] = &[&[1,2], &[3,4], &[5]];\n         assert_eq!(v.chunks(2).collect::<Vec<&[int]>>(), chunks);\n-        let chunks: &[&[int]] = &[&[1i,2,3], &[4,5]];\n+        let chunks: &[&[int]] = &[&[1,2,3], &[4,5]];\n         assert_eq!(v.chunks(3).collect::<Vec<&[int]>>(), chunks);\n-        let chunks: &[&[int]] = &[&[1i,2,3,4,5]];\n+        let chunks: &[&[int]] = &[&[1,2,3,4,5]];\n         assert_eq!(v.chunks(6).collect::<Vec<&[int]>>(), chunks);\n \n-        let chunks: &[&[int]] = &[&[5i], &[3,4], &[1,2]];\n+        let chunks: &[&[int]] = &[&[5], &[3,4], &[1,2]];\n         assert_eq!(v.chunks(2).rev().collect::<Vec<&[int]>>(), chunks);\n         let mut it = v.chunks(2);\n         assert_eq!(it.indexable(), 3);\n@@ -2556,33 +2556,33 @@ mod tests {\n     #[test]\n     #[should_fail]\n     fn test_chunksator_0() {\n-        let v = &[1i,2,3,4];\n+        let v = &[1,2,3,4];\n         let _it = v.chunks(0);\n     }\n \n     #[test]\n     fn test_move_from() {\n-        let mut a = [1i,2,3,4,5];\n-        let b = vec![6i,7,8];\n+        let mut a = [1,2,3,4,5];\n+        let b = vec![6,7,8];\n         assert_eq!(a.move_from(b, 0, 3), 3);\n-        assert!(a == [6i,7,8,4,5]);\n-        let mut a = [7i,2,8,1];\n-        let b = vec![3i,1,4,1,5,9];\n+        assert!(a == [6,7,8,4,5]);\n+        let mut a = [7,2,8,1];\n+        let b = vec![3,1,4,1,5,9];\n         assert_eq!(a.move_from(b, 0, 6), 4);\n-        assert!(a == [3i,1,4,1]);\n-        let mut a = [1i,2,3,4];\n-        let b = vec![5i,6,7,8,9,0];\n+        assert!(a == [3,1,4,1]);\n+        let mut a = [1,2,3,4];\n+        let b = vec![5,6,7,8,9,0];\n         assert_eq!(a.move_from(b, 2, 3), 1);\n-        assert!(a == [7i,2,3,4]);\n-        let mut a = [1i,2,3,4,5];\n-        let b = vec![5i,6,7,8,9,0];\n+        assert!(a == [7,2,3,4]);\n+        let mut a = [1,2,3,4,5];\n+        let b = vec![5,6,7,8,9,0];\n         assert_eq!(a[2..4].move_from(b,1,6), 2);\n-        assert!(a == [1i,2,6,7,5]);\n+        assert!(a == [1,2,6,7,5]);\n     }\n \n     #[test]\n     fn test_reverse_part() {\n-        let mut values = [1i,2,3,4,5];\n+        let mut values = [1,2,3,4,5];\n         values[1..4].reverse();\n         assert!(values == [1,4,3,2,5]);\n     }\n@@ -2598,8 +2598,8 @@ mod tests {\n         }\n         let empty: Vec<int> = vec![];\n         test_show_vec!(empty, \"[]\");\n-        test_show_vec!(vec![1i], \"[1]\");\n-        test_show_vec!(vec![1i, 2, 3], \"[1, 2, 3]\");\n+        test_show_vec!(vec![1], \"[1]\");\n+        test_show_vec!(vec![1, 2, 3], \"[1, 2, 3]\");\n         test_show_vec!(vec![vec![], vec![1u], vec![1u, 1u]],\n                        \"[[], [1], [1, 1]]\");\n \n@@ -2641,16 +2641,16 @@ mod tests {\n     fn test_overflow_does_not_cause_segfault() {\n         let mut v = vec![];\n         v.reserve_exact(-1);\n-        v.push(1i);\n+        v.push(1);\n         v.push(2);\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_overflow_does_not_cause_segfault_managed() {\n-        let mut v = vec![Rc::new(1i)];\n+        let mut v = vec![Rc::new(1)];\n         v.reserve_exact(-1);\n-        v.push(Rc::new(2i));\n+        v.push(Rc::new(2));\n     }\n \n     #[test]\n@@ -2723,13 +2723,13 @@ mod tests {\n     #[test]\n     fn test_shrink_to_fit() {\n         let mut xs = vec![0, 1, 2, 3];\n-        for i in 4i..100 {\n+        for i in 4..100 {\n             xs.push(i)\n         }\n         assert_eq!(xs.capacity(), 128);\n         xs.shrink_to_fit();\n         assert_eq!(xs.capacity(), 100);\n-        assert_eq!(xs, (0i..100i).collect::<Vec<_>>());\n+        assert_eq!(xs, (0..100).collect::<Vec<_>>());\n     }\n \n     #[test]\n@@ -2762,14 +2762,14 @@ mod tests {\n \n     #[test]\n     fn test_mut_splitator() {\n-        let mut xs = [0i,1,0,2,3,0,0,4,5,0];\n+        let mut xs = [0,1,0,2,3,0,0,4,5,0];\n         assert_eq!(xs.split_mut(|x| *x == 0).count(), 6);\n         for slice in xs.split_mut(|x| *x == 0) {\n             slice.reverse();\n         }\n         assert!(xs == [0,1,0,3,2,0,0,5,4,0]);\n \n-        let mut xs = [0i,1,0,2,3,0,0,4,5,0,6,7];\n+        let mut xs = [0,1,0,2,3,0,0,4,5,0,6,7];\n         for slice in xs.split_mut(|x| *x == 0).take(5) {\n             slice.reverse();\n         }\n@@ -2778,7 +2778,7 @@ mod tests {\n \n     #[test]\n     fn test_mut_splitator_rev() {\n-        let mut xs = [1i,2,0,3,4,0,0,5,6,0];\n+        let mut xs = [1,2,0,3,4,0,0,5,6,0];\n         for slice in xs.split_mut(|x| *x == 0).rev().take(4) {\n             slice.reverse();\n         }\n@@ -2787,7 +2787,7 @@ mod tests {\n \n     #[test]\n     fn test_get_mut() {\n-        let mut v = [0i,1,2];\n+        let mut v = [0,1,2];\n         assert_eq!(v.get_mut(3), None);\n         v.get_mut(1).map(|e| *e = 7);\n         assert_eq!(v[1], 7);\n@@ -2825,13 +2825,13 @@ mod tests {\n     #[test]\n     #[should_fail]\n     fn test_mut_chunks_0() {\n-        let mut v = [1i, 2, 3, 4];\n+        let mut v = [1, 2, 3, 4];\n         let _it = v.chunks_mut(0);\n     }\n \n     #[test]\n     fn test_mut_last() {\n-        let mut x = [1i, 2, 3, 4, 5];\n+        let mut x = [1, 2, 3, 4, 5];\n         let h = x.last_mut();\n         assert_eq!(*h.unwrap(), 5);\n \n@@ -2874,10 +2874,10 @@ mod bench {\n \n     #[bench]\n     fn mut_iterator(b: &mut Bencher) {\n-        let mut v = repeat(0i).take(100).collect::<Vec<_>>();\n+        let mut v = repeat(0).take(100).collect::<Vec<_>>();\n \n         b.iter(|| {\n-            let mut i = 0i;\n+            let mut i = 0;\n             for x in v.iter_mut() {\n                 *x = i;\n                 i += 1;\n@@ -3013,7 +3013,7 @@ mod bench {\n                 v.set_len(1024);\n             }\n             for x in v.iter_mut() {\n-                *x = 0i;\n+                *x = 0;\n             }\n             v\n         });"}, {"sha": "ded6385d29325b90cce788211d5b820f76b405f6", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -68,6 +68,7 @@ use core::ops::FullRange;\n #[cfg(not(stage0))]\n use core::ops::RangeFull;\n use core::option::Option::{self, Some, None};\n+use core::result::Result;\n use core::slice::AsSlice;\n use core::str as core_str;\n use unicode::str::{UnicodeStr, Utf16Encoder};\n@@ -199,7 +200,7 @@ impl<'a> Iterator for Decompositions<'a> {\n         }\n \n         if !self.sorted {\n-            for ch in self.iter {\n+            for ch in self.iter.by_ref() {\n                 let buffer = &mut self.buffer;\n                 let sorted = &mut self.sorted;\n                 {\n@@ -279,7 +280,7 @@ impl<'a> Iterator for Recompositions<'a> {\n         loop {\n             match self.state {\n                 Composing => {\n-                    for ch in self.iter {\n+                    for ch in self.iter.by_ref() {\n                         let ch_class = unicode::char::canonical_combining_class(ch);\n                         if self.composee.is_none() {\n                             if ch_class != 0 {\n@@ -443,12 +444,9 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// # Examples\n     ///\n     /// ```rust\n-    /// let s = \"Do you know the muffin man,\n-    /// The muffin man, the muffin man, ...\".to_string();\n+    /// let s = \"this is old\";\n     ///\n-    /// assert_eq!(s.replace(\"muffin man\", \"little lamb\"),\n-    ///            \"Do you know the little lamb,\n-    /// The little lamb, the little lamb, ...\".to_string());\n+    /// assert_eq!(s.replace(\"old\", \"new\"), \"this is new\");\n     ///\n     /// // not found, so no change.\n     /// assert_eq!(s.replace(\"cookie monster\", \"little lamb\"), s);\n@@ -1231,13 +1229,12 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// # Example\n     ///\n     /// ```\n-    /// assert_eq!(\"4\".parse::<u32>(), Some(4));\n-    /// assert_eq!(\"j\".parse::<u32>(), None);\n+    /// assert_eq!(\"4\".parse::<u32>(), Ok(4));\n+    /// assert!(\"j\".parse::<u32>().is_err());\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"collections\",\n-               reason = \"this method was just created\")]\n-    fn parse<F: FromStr>(&self) -> Option<F> {\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn parse<F: FromStr>(&self) -> Result<F, F::Err> {\n         core_str::StrExt::parse(&self[])\n     }\n \n@@ -2154,7 +2151,7 @@ mod tests {\n         let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n         let mut it = s.chars();\n         it.next();\n-        assert!(it.zip(it.clone()).all(|(x,y)| x == y));\n+        assert!(it.clone().zip(it).all(|(x,y)| x == y));\n     }\n \n     #[test]"}, {"sha": "4cb7b05f967a063b7d0c8fa1b88346e8e07c8e30", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -940,19 +940,24 @@ pub fn as_string<'a>(x: &'a str) -> DerefString<'a> {\n     DerefString { x: as_vec(x.as_bytes()) }\n }\n \n+#[unstable(feature = \"collections\", reason = \"associated error type may change\")]\n impl FromStr for String {\n+    type Err = ();\n     #[inline]\n-    fn from_str(s: &str) -> Option<String> {\n-        Some(String::from_str(s))\n+    fn from_str(s: &str) -> Result<String, ()> {\n+        Ok(String::from_str(s))\n     }\n }\n \n /// A generic trait for converting a value to a string\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait ToString {\n     /// Converts the value of `self` to an owned string\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn to_string(&self) -> String;\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: fmt::Display + ?Sized> ToString for T {\n     #[inline]\n     fn to_string(&self) -> String {\n@@ -989,6 +994,7 @@ impl<'a> Str for CowString<'a> {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Writer for String {\n     #[inline]\n     fn write_str(&mut self, s: &str) -> fmt::Result {\n@@ -1016,7 +1022,7 @@ mod tests {\n \n     #[test]\n     fn test_from_str() {\n-      let owned: Option<::std::string::String> = \"string\".parse();\n+      let owned: Option<::std::string::String> = \"string\".parse().ok();\n       assert_eq!(owned.as_ref().map(|s| s.as_slice()), Some(\"string\"));\n     }\n \n@@ -1302,8 +1308,8 @@ mod tests {\n \n     #[test]\n     fn test_simple_types() {\n-        assert_eq!(1i.to_string(), \"1\");\n-        assert_eq!((-1i).to_string(), \"-1\");\n+        assert_eq!(1.to_string(), \"1\");\n+        assert_eq!((-1).to_string(), \"-1\");\n         assert_eq!(200u.to_string(), \"200\");\n         assert_eq!(2u8.to_string(), \"2\");\n         assert_eq!(true.to_string(), \"true\");\n@@ -1315,9 +1321,9 @@ mod tests {\n     fn test_vectors() {\n         let x: Vec<int> = vec![];\n         assert_eq!(format!(\"{:?}\", x), \"[]\");\n-        assert_eq!(format!(\"{:?}\", vec![1i]), \"[1]\");\n-        assert_eq!(format!(\"{:?}\", vec![1i, 2, 3]), \"[1, 2, 3]\");\n-        assert!(format!(\"{:?}\", vec![vec![], vec![1i], vec![1i, 1]]) ==\n+        assert_eq!(format!(\"{:?}\", vec![1]), \"[1]\");\n+        assert_eq!(format!(\"{:?}\", vec![1, 2, 3]), \"[1, 2, 3]\");\n+        assert!(format!(\"{:?}\", vec![vec![], vec![1], vec![1, 1]]) ==\n                \"[[], [1], [1, 1]]\");\n     }\n "}, {"sha": "c45879ae251a52546a3330db5f5c20824827845e", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 74, "deletions": 56, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -56,7 +56,7 @@ use core::cmp::{Ordering};\n use core::default::Default;\n use core::fmt;\n use core::hash::{self, Hash};\n-use core::iter::{repeat, FromIterator};\n+use core::iter::{repeat, FromIterator, IntoIterator};\n use core::marker::{ContravariantLifetime, InvariantType};\n use core::mem;\n use core::nonzero::NonZero;\n@@ -65,6 +65,7 @@ use core::ops::{Index, IndexMut, Deref, Add};\n use core::ops;\n use core::ptr;\n use core::raw::Slice as RawSlice;\n+use core::slice;\n use core::uint;\n \n /// A growable list type, written `Vec<T>` but pronounced 'vector.'\n@@ -73,30 +74,30 @@ use core::uint;\n ///\n /// ```\n /// let mut vec = Vec::new();\n-/// vec.push(1i);\n-/// vec.push(2i);\n+/// vec.push(1);\n+/// vec.push(2);\n ///\n /// assert_eq!(vec.len(), 2);\n /// assert_eq!(vec[0], 1);\n ///\n /// assert_eq!(vec.pop(), Some(2));\n /// assert_eq!(vec.len(), 1);\n ///\n-/// vec[0] = 7i;\n+/// vec[0] = 7;\n /// assert_eq!(vec[0], 7);\n ///\n /// vec.push_all(&[1, 2, 3]);\n ///\n /// for x in vec.iter() {\n ///     println!(\"{}\", x);\n /// }\n-/// assert_eq!(vec, vec![7i, 1, 2, 3]);\n+/// assert_eq!(vec, vec![7, 1, 2, 3]);\n /// ```\n ///\n /// The `vec!` macro is provided to make initialization more convenient:\n ///\n /// ```\n-/// let mut vec = vec![1i, 2i, 3i];\n+/// let mut vec = vec![1, 2, 3];\n /// vec.push(4);\n /// assert_eq!(vec, vec![1, 2, 3, 4]);\n /// ```\n@@ -106,9 +107,9 @@ use core::uint;\n /// ```\n /// let mut stack = Vec::new();\n ///\n-/// stack.push(1i);\n-/// stack.push(2i);\n-/// stack.push(3i);\n+/// stack.push(1);\n+/// stack.push(2);\n+/// stack.push(3);\n ///\n /// loop {\n ///     let top = match stack.pop() {\n@@ -180,13 +181,13 @@ impl<T> Vec<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// let mut vec: Vec<int> = Vec::with_capacity(10);\n+    /// let mut vec: Vec<_> = Vec::with_capacity(10);\n     ///\n     /// // The vector contains no items, even though it has capacity for more\n     /// assert_eq!(vec.len(), 0);\n     ///\n     /// // These are all done without reallocating...\n-    /// for i in 0i..10 {\n+    /// for i in 0..10 {\n     ///     vec.push(i);\n     /// }\n     ///\n@@ -220,7 +221,7 @@ impl<T> Vec<T> {\n     /// use std::mem;\n     ///\n     /// fn main() {\n-    ///     let mut v = vec![1i, 2, 3];\n+    ///     let mut v = vec![1, 2, 3];\n     ///\n     ///     // Pull out the various important pieces of information about `v`\n     ///     let p = v.as_mut_ptr();\n@@ -239,7 +240,7 @@ impl<T> Vec<T> {\n     ///\n     ///         // Put everything back together into a Vec\n     ///         let rebuilt = Vec::from_raw_parts(p, len, cap);\n-    ///         assert_eq!(rebuilt, vec![4i, 5i, 6i]);\n+    ///         assert_eq!(rebuilt, vec![4, 5, 6]);\n     ///     }\n     /// }\n     /// ```\n@@ -395,7 +396,7 @@ impl<T> Vec<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// let mut vec = vec![1i, 2, 3, 4];\n+    /// let mut vec = vec![1, 2, 3, 4];\n     /// vec.truncate(2);\n     /// assert_eq!(vec, vec![1, 2]);\n     /// ```\n@@ -419,7 +420,7 @@ impl<T> Vec<T> {\n     /// ```\n     /// fn foo(slice: &mut [int]) {}\n     ///\n-    /// let mut vec = vec![1i, 2];\n+    /// let mut vec = vec![1, 2];\n     /// foo(vec.as_mut_slice());\n     /// ```\n     #[inline]\n@@ -522,7 +523,7 @@ impl<T> Vec<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// let mut vec = vec![1i, 2, 3];\n+    /// let mut vec = vec![1, 2, 3];\n     /// vec.insert(1, 4);\n     /// assert_eq!(vec, vec![1, 4, 2, 3]);\n     /// vec.insert(4, 5);\n@@ -560,7 +561,7 @@ impl<T> Vec<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// let mut v = vec![1i, 2, 3];\n+    /// let mut v = vec![1, 2, 3];\n     /// assert_eq!(v.remove(1), 2);\n     /// assert_eq!(v, vec![1, 3]);\n     /// ```\n@@ -594,7 +595,7 @@ impl<T> Vec<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// let mut vec = vec![1i, 2, 3, 4];\n+    /// let mut vec = vec![1, 2, 3, 4];\n     /// vec.retain(|&x| x%2 == 0);\n     /// assert_eq!(vec, vec![2, 4]);\n     /// ```\n@@ -627,7 +628,7 @@ impl<T> Vec<T> {\n     /// # Examples\n     ///\n     /// ```rust\n-    /// let mut vec = vec!(1i, 2);\n+    /// let mut vec = vec!(1, 2);\n     /// vec.push(3);\n     /// assert_eq!(vec, vec!(1, 2, 3));\n     /// ```\n@@ -665,7 +666,7 @@ impl<T> Vec<T> {\n     /// # Examples\n     ///\n     /// ```rust\n-    /// let mut vec = vec![1i, 2, 3];\n+    /// let mut vec = vec![1, 2, 3];\n     /// assert_eq!(vec.pop(), Some(3));\n     /// assert_eq!(vec, vec![1, 2]);\n     /// ```\n@@ -758,7 +759,7 @@ impl<T> Vec<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// let mut v = vec![1i, 2, 3];\n+    /// let mut v = vec![1, 2, 3];\n     ///\n     /// v.clear();\n     ///\n@@ -775,7 +776,7 @@ impl<T> Vec<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// let a = vec![1i, 2, 3];\n+    /// let a = vec![1, 2, 3];\n     /// assert_eq!(a.len(), 3);\n     /// ```\n     #[inline]\n@@ -790,7 +791,7 @@ impl<T> Vec<T> {\n     /// let mut v = Vec::new();\n     /// assert!(v.is_empty());\n     ///\n-    /// v.push(1i);\n+    /// v.push(1);\n     /// assert!(!v.is_empty());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1045,7 +1046,7 @@ impl<T: Clone> Vec<T> {\n     /// vec.resize(3, \"world\");\n     /// assert_eq!(vec, vec![\"hello\", \"world\", \"world\"]);\n     ///\n-    /// let mut vec = vec![1i, 2, 3, 4];\n+    /// let mut vec = vec![1, 2, 3, 4];\n     /// vec.resize(2, 0);\n     /// assert_eq!(vec, vec![1, 2]);\n     /// ```\n@@ -1069,8 +1070,8 @@ impl<T: Clone> Vec<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// let mut vec = vec![1i];\n-    /// vec.push_all(&[2i, 3, 4]);\n+    /// let mut vec = vec![1];\n+    /// vec.push_all(&[2, 3, 4]);\n     /// assert_eq!(vec, vec![1, 2, 3, 4]);\n     /// ```\n     #[inline]\n@@ -1103,11 +1104,11 @@ impl<T: PartialEq> Vec<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// let mut vec = vec![1i, 2, 2, 3, 2];\n+    /// let mut vec = vec![1, 2, 2, 3, 2];\n     ///\n     /// vec.dedup();\n     ///\n-    /// assert_eq!(vec, vec![1i, 2, 3, 2]);\n+    /// assert_eq!(vec, vec![1, 2, 3, 2]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn dedup(&mut self) {\n@@ -1404,6 +1405,30 @@ impl<T> FromIterator<T> for Vec<T> {\n     }\n }\n \n+impl<T> IntoIterator for Vec<T> {\n+    type Iter = IntoIter<T>;\n+\n+    fn into_iter(self) -> IntoIter<T> {\n+        self.into_iter()\n+    }\n+}\n+\n+impl<'a, T> IntoIterator for &'a Vec<T> {\n+    type Iter = slice::Iter<'a, T>;\n+\n+    fn into_iter(self) -> slice::Iter<'a, T> {\n+        self.iter()\n+    }\n+}\n+\n+impl<'a, T> IntoIterator for &'a mut Vec<T> {\n+    type Iter = slice::IterMut<'a, T>;\n+\n+    fn into_iter(mut self) -> slice::IterMut<'a, T> {\n+        self.iter_mut()\n+    }\n+}\n+\n #[unstable(feature = \"collections\", reason = \"waiting on Extend stability\")]\n impl<T> Extend<T> for Vec<T> {\n     #[inline]\n@@ -1507,7 +1532,7 @@ impl<T> AsSlice<T> for Vec<T> {\n     /// ```\n     /// fn foo(slice: &[int]) {}\n     ///\n-    /// let vec = vec![1i, 2];\n+    /// let vec = vec![1, 2];\n     /// foo(vec.as_slice());\n     /// ```\n     #[inline]\n@@ -1566,13 +1591,6 @@ impl<T: fmt::Debug> fmt::Debug for Vec<T> {\n     }\n }\n \n-impl<'a> fmt::Writer for Vec<u8> {\n-    fn write_str(&mut self, s: &str) -> fmt::Result {\n-        self.push_all(s.as_bytes());\n-        Ok(())\n-    }\n-}\n-\n ////////////////////////////////////////////////////////////////////////////////\n // Clone-on-write\n ////////////////////////////////////////////////////////////////////////////////\n@@ -1623,7 +1641,7 @@ impl<T> IntoIter<T> {\n     #[unstable(feature = \"collections\")]\n     pub fn into_inner(mut self) -> Vec<T> {\n         unsafe {\n-            for _x in self { }\n+            for _x in self.by_ref() { }\n             let IntoIter { allocation, cap, ptr: _ptr, end: _end } = self;\n             mem::forget(self);\n             Vec { ptr: NonZero::new(allocation), cap: cap, len: 0 }\n@@ -1701,7 +1719,7 @@ impl<T> Drop for IntoIter<T> {\n     fn drop(&mut self) {\n         // destroy the remaining elements\n         if self.cap != 0 {\n-            for _x in *self {}\n+            for _x in self.by_ref() {}\n             unsafe {\n                 dealloc(self.allocation, self.cap);\n             }\n@@ -1791,7 +1809,7 @@ impl<'a, T> Drop for Drain<'a, T> {\n         // so we can use #[unsafe_no_drop_flag].\n \n         // destroy the remaining elements\n-        for _x in *self {}\n+        for _x in self.by_ref() {}\n     }\n }\n \n@@ -1990,7 +2008,7 @@ mod tests {\n         v.reserve(2);\n         assert!(v.capacity() >= 2);\n \n-        for i in 0i..16 {\n+        for i in 0..16 {\n             v.push(i);\n         }\n \n@@ -2009,13 +2027,13 @@ mod tests {\n         let mut v = Vec::new();\n         let mut w = Vec::new();\n \n-        v.extend(0i..3);\n-        for i in 0i..3 { w.push(i) }\n+        v.extend(0..3);\n+        for i in 0..3 { w.push(i) }\n \n         assert_eq!(v, w);\n \n-        v.extend(3i..10);\n-        for i in 3i..10 { w.push(i) }\n+        v.extend(3..10);\n+        for i in 3..10 { w.push(i) }\n \n         assert_eq!(v, w);\n     }\n@@ -2076,7 +2094,7 @@ mod tests {\n     #[test]\n     fn test_clone() {\n         let v: Vec<int> = vec!();\n-        let w = vec!(1i, 2, 3);\n+        let w = vec!(1, 2, 3);\n \n         assert_eq!(v, v.clone());\n \n@@ -2089,8 +2107,8 @@ mod tests {\n     #[test]\n     fn test_clone_from() {\n         let mut v = vec!();\n-        let three = vec!(box 1i, box 2, box 3);\n-        let two = vec!(box 4i, box 5);\n+        let three = vec!(box 1, box 2, box 3);\n+        let two = vec!(box 4, box 5);\n         // zero, long\n         v.clone_from(&three);\n         assert_eq!(v, three);\n@@ -2149,14 +2167,14 @@ mod tests {\n     #[test]\n     fn test_partition() {\n         assert_eq!(vec![].into_iter().partition(|x: &int| *x < 3), (vec![], vec![]));\n-        assert_eq!(vec![1i, 2, 3].into_iter().partition(|x: &int| *x < 4), (vec![1, 2, 3], vec![]));\n-        assert_eq!(vec![1i, 2, 3].into_iter().partition(|x: &int| *x < 2), (vec![1], vec![2, 3]));\n-        assert_eq!(vec![1i, 2, 3].into_iter().partition(|x: &int| *x < 0), (vec![], vec![1, 2, 3]));\n+        assert_eq!(vec![1, 2, 3].into_iter().partition(|x: &int| *x < 4), (vec![1, 2, 3], vec![]));\n+        assert_eq!(vec![1, 2, 3].into_iter().partition(|x: &int| *x < 2), (vec![1], vec![2, 3]));\n+        assert_eq!(vec![1, 2, 3].into_iter().partition(|x: &int| *x < 0), (vec![], vec![1, 2, 3]));\n     }\n \n     #[test]\n     fn test_zip_unzip() {\n-        let z1 = vec![(1i, 4i), (2, 5), (3, 6)];\n+        let z1 = vec![(1, 4), (2, 5), (3, 6)];\n \n         let (left, right): (Vec<_>, Vec<_>) = z1.iter().map(|&x| x).unzip();\n \n@@ -2169,13 +2187,13 @@ mod tests {\n     fn test_unsafe_ptrs() {\n         unsafe {\n             // Test on-stack copy-from-buf.\n-            let a = [1i, 2, 3];\n+            let a = [1, 2, 3];\n             let ptr = a.as_ptr();\n             let b = Vec::from_raw_buf(ptr, 3u);\n             assert_eq!(b, vec![1, 2, 3]);\n \n             // Test on-heap copy-from-buf.\n-            let c = vec![1i, 2, 3, 4, 5];\n+            let c = vec![1, 2, 3, 4, 5];\n             let ptr = c.as_ptr();\n             let d = Vec::from_raw_buf(ptr, 5u);\n             assert_eq!(d, vec![1, 2, 3, 4, 5]);\n@@ -2219,14 +2237,14 @@ mod tests {\n \n     #[test]\n     fn test_index() {\n-        let vec = vec!(1i, 2, 3);\n+        let vec = vec!(1, 2, 3);\n         assert!(vec[1] == 2);\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_index_out_of_bounds() {\n-        let vec = vec!(1i, 2, 3);\n+        let vec = vec!(1, 2, 3);\n         let _ = vec[3];\n     }\n \n@@ -2294,7 +2312,7 @@ mod tests {\n     #[test]\n     fn test_map_in_place() {\n         let v = vec![0u, 1, 2];\n-        assert_eq!(v.map_in_place(|i: uint| i as int - 1), [-1i, 0, 1]);\n+        assert_eq!(v.map_in_place(|i: uint| i as int - 1), [-1, 0, 1]);\n     }\n \n     #[test]"}, {"sha": "f2a9bb4392cccc7935d4c19daab78caa592f7df1", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 45, "deletions": 21, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -19,7 +19,7 @@ use core::cmp::Ordering;\n use core::default::Default;\n use core::fmt;\n use core::hash::{Hash, Writer, Hasher};\n-use core::iter::{Enumerate, FilterMap, Map, FromIterator};\n+use core::iter::{Enumerate, FilterMap, Map, FromIterator, IntoIterator};\n use core::iter;\n use core::mem::replace;\n use core::ops::{Index, IndexMut};\n@@ -536,6 +536,30 @@ impl<V> FromIterator<(uint, V)> for VecMap<V> {\n     }\n }\n \n+impl<T> IntoIterator for VecMap<T> {\n+    type Iter = IntoIter<T>;\n+\n+    fn into_iter(self) -> IntoIter<T> {\n+        self.into_iter()\n+    }\n+}\n+\n+impl<'a, T> IntoIterator for &'a VecMap<T> {\n+    type Iter = Iter<'a, T>;\n+\n+    fn into_iter(self) -> Iter<'a, T> {\n+        self.iter()\n+    }\n+}\n+\n+impl<'a, T> IntoIterator for &'a mut VecMap<T> {\n+    type Iter = IterMut<'a, T>;\n+\n+    fn into_iter(mut self) -> IterMut<'a, T> {\n+        self.iter_mut()\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<V> Extend<(uint, V)> for VecMap<V> {\n     fn extend<Iter: Iterator<Item=(uint, V)>>(&mut self, mut iter: Iter) {\n@@ -768,7 +792,7 @@ mod test_map {\n     #[test]\n     fn test_get_mut() {\n         let mut m = VecMap::new();\n-        assert!(m.insert(1, 12i).is_none());\n+        assert!(m.insert(1, 12).is_none());\n         assert!(m.insert(2, 8).is_none());\n         assert!(m.insert(5, 14).is_none());\n         let new = 100;\n@@ -783,7 +807,7 @@ mod test_map {\n         let mut map = VecMap::new();\n         assert_eq!(map.len(), 0);\n         assert!(map.is_empty());\n-        assert!(map.insert(5, 20i).is_none());\n+        assert!(map.insert(5, 20).is_none());\n         assert_eq!(map.len(), 1);\n         assert!(!map.is_empty());\n         assert!(map.insert(11, 12).is_none());\n@@ -797,7 +821,7 @@ mod test_map {\n     #[test]\n     fn test_clear() {\n         let mut map = VecMap::new();\n-        assert!(map.insert(5, 20i).is_none());\n+        assert!(map.insert(5, 20).is_none());\n         assert!(map.insert(11, 12).is_none());\n         assert!(map.insert(14, 22).is_none());\n         map.clear();\n@@ -810,15 +834,15 @@ mod test_map {\n     #[test]\n     fn test_insert() {\n         let mut m = VecMap::new();\n-        assert_eq!(m.insert(1, 2i), None);\n-        assert_eq!(m.insert(1, 3i), Some(2));\n-        assert_eq!(m.insert(1, 4i), Some(3));\n+        assert_eq!(m.insert(1, 2), None);\n+        assert_eq!(m.insert(1, 3), Some(2));\n+        assert_eq!(m.insert(1, 4), Some(3));\n     }\n \n     #[test]\n     fn test_remove() {\n         let mut m = VecMap::new();\n-        m.insert(1, 2i);\n+        m.insert(1, 2);\n         assert_eq!(m.remove(&1), Some(2));\n         assert_eq!(m.remove(&1), None);\n     }\n@@ -853,7 +877,7 @@ mod test_map {\n     fn test_iterator() {\n         let mut m = VecMap::new();\n \n-        assert!(m.insert(0, 1i).is_none());\n+        assert!(m.insert(0, 1).is_none());\n         assert!(m.insert(1, 2).is_none());\n         assert!(m.insert(3, 5).is_none());\n         assert!(m.insert(6, 10).is_none());\n@@ -878,7 +902,7 @@ mod test_map {\n     fn test_iterator_size_hints() {\n         let mut m = VecMap::new();\n \n-        assert!(m.insert(0, 1i).is_none());\n+        assert!(m.insert(0, 1).is_none());\n         assert!(m.insert(1, 2).is_none());\n         assert!(m.insert(3, 5).is_none());\n         assert!(m.insert(6, 10).is_none());\n@@ -894,7 +918,7 @@ mod test_map {\n     fn test_mut_iterator() {\n         let mut m = VecMap::new();\n \n-        assert!(m.insert(0, 1i).is_none());\n+        assert!(m.insert(0, 1).is_none());\n         assert!(m.insert(1, 2).is_none());\n         assert!(m.insert(3, 5).is_none());\n         assert!(m.insert(6, 10).is_none());\n@@ -917,7 +941,7 @@ mod test_map {\n     fn test_rev_iterator() {\n         let mut m = VecMap::new();\n \n-        assert!(m.insert(0, 1i).is_none());\n+        assert!(m.insert(0, 1).is_none());\n         assert!(m.insert(1, 2).is_none());\n         assert!(m.insert(3, 5).is_none());\n         assert!(m.insert(6, 10).is_none());\n@@ -936,7 +960,7 @@ mod test_map {\n     fn test_mut_rev_iterator() {\n         let mut m = VecMap::new();\n \n-        assert!(m.insert(0, 1i).is_none());\n+        assert!(m.insert(0, 1).is_none());\n         assert!(m.insert(1, 2).is_none());\n         assert!(m.insert(3, 5).is_none());\n         assert!(m.insert(6, 10).is_none());\n@@ -958,13 +982,13 @@ mod test_map {\n     #[test]\n     fn test_move_iter() {\n         let mut m = VecMap::new();\n-        m.insert(1, box 2i);\n+        m.insert(1, box 2);\n         let mut called = false;\n         for (k, v) in m.into_iter() {\n             assert!(!called);\n             called = true;\n             assert_eq!(k, 1);\n-            assert_eq!(v, box 2i);\n+            assert_eq!(v, box 2);\n         }\n         assert!(called);\n     }\n@@ -987,8 +1011,8 @@ mod test_map {\n         let mut map = VecMap::new();\n         let empty = VecMap::<int>::new();\n \n-        map.insert(1, 2i);\n-        map.insert(3, 4i);\n+        map.insert(1, 2);\n+        map.insert(3, 4);\n \n         let map_str = format!(\"{:?}\", map);\n         assert!(map_str == \"VecMap {1: 2, 3: 4}\" || map_str == \"{3: 4, 1: 2}\");\n@@ -1012,9 +1036,9 @@ mod test_map {\n         let mut b = VecMap::new();\n \n         assert!(a == b);\n-        assert!(a.insert(0, 5i).is_none());\n+        assert!(a.insert(0, 5).is_none());\n         assert!(a != b);\n-        assert!(b.insert(0, 4i).is_none());\n+        assert!(b.insert(0, 4).is_none());\n         assert!(a != b);\n         assert!(a.insert(5, 19).is_none());\n         assert!(a != b);\n@@ -1034,7 +1058,7 @@ mod test_map {\n         let mut b = VecMap::new();\n \n         assert!(!(a < b) && !(b < a));\n-        assert!(b.insert(2u, 5i).is_none());\n+        assert!(b.insert(2u, 5).is_none());\n         assert!(a < b);\n         assert!(a.insert(2, 7).is_none());\n         assert!(!(a < b) && b < a);\n@@ -1052,7 +1076,7 @@ mod test_map {\n         let mut b = VecMap::new();\n \n         assert!(a <= b && a >= b);\n-        assert!(a.insert(1u, 1i).is_none());\n+        assert!(a.insert(1u, 1).is_none());\n         assert!(a > b && a >= b);\n         assert!(b < a && b <= a);\n         assert!(b.insert(2, 2).is_none());"}, {"sha": "ec3d9783255cb77a13c09e24d45fc606bb7c57d9", "filename": "src/libcore/array.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -18,12 +18,14 @@ use clone::Clone;\n use cmp::{PartialEq, Eq, PartialOrd, Ord, Ordering};\n use fmt;\n use hash::{Hash, Hasher, self};\n+use iter::IntoIterator;\n use marker::Copy;\n #[cfg(stage0)]\n use ops::{Deref, FullRange};\n #[cfg(not(stage0))]\n use ops::Deref;\n use option::Option;\n+use slice::{Iter, IterMut, SliceExt};\n \n // macro for implementing n-ary tuple functions and operations\n macro_rules! array_impls {\n@@ -49,6 +51,22 @@ macro_rules! array_impls {\n                 }\n             }\n \n+            impl<'a, T> IntoIterator for &'a [T; $N] {\n+                type Iter = Iter<'a, T>;\n+\n+                fn into_iter(self) -> Iter<'a, T> {\n+                    self.iter()\n+                }\n+            }\n+\n+            impl<'a, T> IntoIterator for &'a mut [T; $N] {\n+                type Iter = IterMut<'a, T>;\n+\n+                fn into_iter(self) -> IterMut<'a, T> {\n+                    self.iter_mut()\n+                }\n+            }\n+\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<A, B> PartialEq<[B; $N]> for [A; $N] where A: PartialEq<B> {\n                 #[inline]"}, {"sha": "2ff67ebd550abb910d5a82eec4b1ad8abb07b9a7", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 145, "deletions": 107, "changes": 252, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -10,7 +10,6 @@\n \n //! Utilities for formatting and printing strings\n \n-#![allow(unused_variables)]\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use any;\n@@ -27,17 +26,23 @@ use result;\n use slice::SliceExt;\n use slice;\n use str::{self, StrExt};\n+use self::rt::v1::Alignment;\n \n pub use self::num::radix;\n pub use self::num::Radix;\n pub use self::num::RadixFmt;\n \n mod num;\n mod float;\n-pub mod rt;\n \n-#[unstable(feature = \"core\",\n-           reason = \"core and I/O reconciliation may alter this definition\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[doc(hidden)]\n+pub mod rt {\n+    #[cfg(stage0)] pub use self::v1::*;\n+    pub mod v1;\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n /// The type returned by formatter methods.\n pub type Result = result::Result<(), Error>;\n \n@@ -46,8 +51,7 @@ pub type Result = result::Result<(), Error>;\n /// This type does not support transmission of an error other than that an error\n /// occurred. Any extra information must be arranged to be transmitted through\n /// some other means.\n-#[unstable(feature = \"core\",\n-           reason = \"core and I/O reconciliation may alter this definition\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Copy, Debug)]\n pub struct Error;\n \n@@ -60,8 +64,7 @@ pub struct Error;\n /// This trait should generally not be implemented by consumers of the standard\n /// library. The `write!` macro accepts an instance of `io::Writer`, and the\n /// `io::Writer` trait is favored over implementing this trait.\n-#[unstable(feature = \"core\",\n-           reason = \"waiting for core and I/O reconciliation\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Writer {\n     /// Writes a slice of bytes into this writer, returning whether the write\n     /// succeeded.\n@@ -73,12 +76,14 @@ pub trait Writer {\n     /// # Errors\n     ///\n     /// This function will return an instance of `FormatError` on error.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn write_str(&mut self, s: &str) -> Result;\n \n     /// Glue for usage of the `write!` macro with implementers of this trait.\n     ///\n     /// This method should generally not be invoked manually, but rather through\n     /// the `write!` macro itself.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn write_fmt(&mut self, args: Arguments) -> Result {\n         // This Adapter is needed to allow `self` (of type `&mut\n         // Self`) to be cast to a FormatWriter (below) without\n@@ -104,18 +109,17 @@ pub trait Writer {\n /// A struct to represent both where to emit formatting strings to and how they\n /// should be formatted. A mutable version of this is passed to all formatting\n /// traits.\n-#[unstable(feature = \"core\",\n-           reason = \"name may change and implemented traits are also unstable\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Formatter<'a> {\n     flags: uint,\n     fill: char,\n-    align: rt::Alignment,\n+    align: rt::v1::Alignment,\n     width: Option<uint>,\n     precision: Option<uint>,\n \n     buf: &'a mut (Writer+'a),\n-    curarg: slice::Iter<'a, Argument<'a>>,\n-    args: &'a [Argument<'a>],\n+    curarg: slice::Iter<'a, ArgumentV1<'a>>,\n+    args: &'a [ArgumentV1<'a>],\n }\n \n // NB. Argument is essentially an optimized partially applied formatting function,\n@@ -127,50 +131,73 @@ enum Void {}\n /// family of functions. It contains a function to format the given value. At\n /// compile time it is ensured that the function and the value have the correct\n /// types, and then this struct is used to canonicalize arguments to one type.\n-#[unstable(feature = \"core\",\n-           reason = \"implementation detail of the `format_args!` macro\")]\n #[derive(Copy)]\n-pub struct Argument<'a> {\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[doc(hidden)]\n+pub struct ArgumentV1<'a> {\n     value: &'a Void,\n     formatter: fn(&Void, &mut Formatter) -> Result,\n }\n \n-impl<'a> Argument<'a> {\n+impl<'a> ArgumentV1<'a> {\n     #[inline(never)]\n     fn show_uint(x: &uint, f: &mut Formatter) -> Result {\n         Display::fmt(x, f)\n     }\n \n-    fn new<'b, T>(x: &'b T, f: fn(&T, &mut Formatter) -> Result) -> Argument<'b> {\n+    #[doc(hidden)]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn new<'b, T>(x: &'b T,\n+                      f: fn(&T, &mut Formatter) -> Result) -> ArgumentV1<'b> {\n         unsafe {\n-            Argument {\n+            ArgumentV1 {\n                 formatter: mem::transmute(f),\n                 value: mem::transmute(x)\n             }\n         }\n     }\n \n-    fn from_uint(x: &uint) -> Argument {\n-        Argument::new(x, Argument::show_uint)\n+    #[doc(hidden)]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn from_uint(x: &uint) -> ArgumentV1 {\n+        ArgumentV1::new(x, ArgumentV1::show_uint)\n     }\n \n     fn as_uint(&self) -> Option<uint> {\n-        if self.formatter as uint == Argument::show_uint as uint {\n+        if self.formatter as uint == ArgumentV1::show_uint as uint {\n             Some(unsafe { *(self.value as *const _ as *const uint) })\n         } else {\n             None\n         }\n     }\n }\n \n+// flags available in the v1 format of format_args\n+#[derive(Copy)]\n+#[allow(dead_code)] // SignMinus isn't currently used\n+enum FlagV1 { SignPlus, SignMinus, Alternate, SignAwareZeroPad, }\n+\n impl<'a> Arguments<'a> {\n     /// When using the format_args!() macro, this function is used to generate the\n     /// Arguments structure.\n     #[doc(hidden)] #[inline]\n-    #[unstable(feature = \"core\",\n-               reason = \"implementation detail of the `format_args!` macro\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn new_v1(pieces: &'a [&'a str],\n+                  args: &'a [ArgumentV1<'a>]) -> Arguments<'a> {\n+        Arguments {\n+            pieces: pieces,\n+            fmt: None,\n+            args: args\n+        }\n+    }\n+\n+    /// When using the format_args!() macro, this function is used to generate the\n+    /// Arguments structure.\n+    #[doc(hidden)] #[inline]\n+    #[cfg(stage0)]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(pieces: &'a [&'a str],\n-               args: &'a [Argument<'a>]) -> Arguments<'a> {\n+               args: &'a [ArgumentV1<'a>]) -> Arguments<'a> {\n         Arguments {\n             pieces: pieces,\n             fmt: None,\n@@ -185,11 +212,28 @@ impl<'a> Arguments<'a> {\n     /// created with `argumentuint`. However, failing to do so doesn't cause\n     /// unsafety, but will ignore invalid .\n     #[doc(hidden)] #[inline]\n-    #[unstable(feature = \"core\",\n-               reason = \"implementation detail of the `format_args!` macro\")]\n+    #[cfg(stage0)]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_placeholders(pieces: &'a [&'a str],\n-                             fmt: &'a [rt::Argument],\n-                             args: &'a [Argument<'a>]) -> Arguments<'a> {\n+                             fmt: &'a [rt::v1::Argument],\n+                             args: &'a [ArgumentV1<'a>]) -> Arguments<'a> {\n+        Arguments {\n+            pieces: pieces,\n+            fmt: Some(fmt),\n+            args: args\n+        }\n+    }\n+    /// This function is used to specify nonstandard formatting parameters.\n+    /// The `pieces` array must be at least as long as `fmt` to construct\n+    /// a valid Arguments structure. Also, any `Count` within `fmt` that is\n+    /// `CountIsParam` or `CountIsNextParam` has to point to an argument\n+    /// created with `argumentuint`. However, failing to do so doesn't cause\n+    /// unsafety, but will ignore invalid .\n+    #[doc(hidden)] #[inline]\n+    #[cfg(not(stage0))]\n+    pub fn new_v1_formatted(pieces: &'a [&'a str],\n+                            args: &'a [ArgumentV1<'a>],\n+                            fmt: &'a [rt::v1::Argument]) -> Arguments<'a> {\n         Arguments {\n             pieces: pieces,\n             fmt: Some(fmt),\n@@ -214,11 +258,11 @@ pub struct Arguments<'a> {\n     pieces: &'a [&'a str],\n \n     // Placeholder specs, or `None` if all specs are default (as in \"{}{}\").\n-    fmt: Option<&'a [rt::Argument]>,\n+    fmt: Option<&'a [rt::v1::Argument]>,\n \n     // Dynamic arguments for interpolation, to be interleaved with string\n     // pieces. (Every argument is preceded by a string piece.)\n-    args: &'a [Argument<'a>],\n+    args: &'a [ArgumentV1<'a>],\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -237,20 +281,20 @@ impl<'a> Display for Arguments<'a> {\n \n /// Format trait for the `:?` format. Useful for debugging, all types\n /// should implement this.\n-#[unstable(feature = \"core\",\n-           reason = \"I/O and core have yet to be reconciled\")]\n #[deprecated(since = \"1.0.0\", reason = \"renamed to Debug\")]\n+#[unstable(feature = \"old_fmt\")]\n pub trait Show {\n     /// Formats the value using the given formatter.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n /// Format trait for the `:?` format. Useful for debugging, all types\n /// should implement this.\n-#[unstable(feature = \"core\",\n-           reason = \"I/O and core have yet to be reconciled\")]\n-#[rustc_on_unimplemented = \"`{Self}` cannot be formatted using `:?`; if it is defined in your \\\n-                            crate, add `#[derive(Debug)]` or manually implement it\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"`{Self}` cannot be formatted using `:?`; if it is \\\n+                            defined in your crate, add `#[derive(Debug)]` or \\\n+                            manually implement it\"]\n #[lang = \"debug_trait\"]\n pub trait Debug {\n     /// Formats the value using the given formatter.\n@@ -264,19 +308,20 @@ impl<T: Show + ?Sized> Debug for T {\n \n /// When a value can be semantically expressed as a String, this trait may be\n /// used. It corresponds to the default format, `{}`.\n-#[unstable(feature = \"core\")]\n #[deprecated(since = \"1.0.0\", reason = \"renamed to Display\")]\n+#[unstable(feature = \"old_fmt\")]\n pub trait String {\n     /// Formats the value using the given formatter.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n /// When a value can be semantically expressed as a String, this trait may be\n /// used. It corresponds to the default format, `{}`.\n-#[unstable(feature = \"core\",\n-           reason = \"I/O and core have yet to be reconciled\")]\n-#[rustc_on_unimplemented = \"`{Self}` cannot be formatted with the default formatter; try using \\\n-                            `:?` instead if you are using a format string\"]\n+#[rustc_on_unimplemented = \"`{Self}` cannot be formatted with the default \\\n+                            formatter; try using `:?` instead if you are using \\\n+                            a format string\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Display {\n     /// Formats the value using the given formatter.\n     fn fmt(&self, &mut Formatter) -> Result;\n@@ -288,58 +333,58 @@ impl<T: String + ?Sized> Display for T {\n }\n \n /// Format trait for the `o` character\n-#[unstable(feature = \"core\",\n-           reason = \"I/O and core have yet to be reconciled\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Octal {\n     /// Formats the value using the given formatter.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n /// Format trait for the `b` character\n-#[unstable(feature = \"core\",\n-           reason = \"I/O and core have yet to be reconciled\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Binary {\n     /// Formats the value using the given formatter.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n /// Format trait for the `x` character\n-#[unstable(feature = \"core\",\n-           reason = \"I/O and core have yet to be reconciled\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait LowerHex {\n     /// Formats the value using the given formatter.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n /// Format trait for the `X` character\n-#[unstable(feature = \"core\",\n-           reason = \"I/O and core have yet to be reconciled\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait UpperHex {\n     /// Formats the value using the given formatter.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n /// Format trait for the `p` character\n-#[unstable(feature = \"core\",\n-           reason = \"I/O and core have yet to be reconciled\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Pointer {\n     /// Formats the value using the given formatter.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n /// Format trait for the `e` character\n-#[unstable(feature = \"core\",\n-           reason = \"I/O and core have yet to be reconciled\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait LowerExp {\n     /// Formats the value using the given formatter.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n /// Format trait for the `E` character\n-#[unstable(feature = \"core\",\n-           reason = \"I/O and core have yet to be reconciled\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait UpperExp {\n     /// Formats the value using the given formatter.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n@@ -351,16 +396,14 @@ pub trait UpperExp {\n ///\n ///   * output - the buffer to write output to\n ///   * args - the precompiled arguments generated by `format_args!`\n-#[unstable(feature = \"core\",\n-           reason = \"libcore and I/O have yet to be reconciled, and this is an \\\n-                     implementation detail which should not otherwise be exported\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn write(output: &mut Writer, args: Arguments) -> Result {\n     let mut formatter = Formatter {\n         flags: 0,\n         width: None,\n         precision: None,\n         buf: output,\n-        align: rt::AlignUnknown,\n+        align: Alignment::Unknown,\n         fill: ' ',\n         args: args.args,\n         curarg: args.args.iter(),\n@@ -402,7 +445,7 @@ impl<'a> Formatter<'a> {\n     // First up is the collection of functions used to execute a format string\n     // at runtime. This consumes all of the compile-time statics generated by\n     // the format! syntax extension.\n-    fn run(&mut self, arg: &rt::Argument) -> Result {\n+    fn run(&mut self, arg: &rt::v1::Argument) -> Result {\n         // Fill in the format parameters into the formatter\n         self.fill = arg.format.fill;\n         self.align = arg.format.align;\n@@ -412,22 +455,22 @@ impl<'a> Formatter<'a> {\n \n         // Extract the correct argument\n         let value = match arg.position {\n-            rt::ArgumentNext => { *self.curarg.next().unwrap() }\n-            rt::ArgumentIs(i) => self.args[i],\n+            rt::v1::Position::Next => { *self.curarg.next().unwrap() }\n+            rt::v1::Position::At(i) => self.args[i],\n         };\n \n         // Then actually do some printing\n         (value.formatter)(value.value, self)\n     }\n \n-    fn getcount(&mut self, cnt: &rt::Count) -> Option<uint> {\n+    fn getcount(&mut self, cnt: &rt::v1::Count) -> Option<uint> {\n         match *cnt {\n-            rt::CountIs(n) => Some(n),\n-            rt::CountImplied => None,\n-            rt::CountIsParam(i) => {\n+            rt::v1::Count::Is(n) => Some(n),\n+            rt::v1::Count::Implied => None,\n+            rt::v1::Count::Param(i) => {\n                 self.args[i].as_uint()\n             }\n-            rt::CountIsNextParam => {\n+            rt::v1::Count::NextParam => {\n                 self.curarg.next().and_then(|arg| arg.as_uint())\n             }\n         }\n@@ -437,8 +480,8 @@ impl<'a> Formatter<'a> {\n     // all formatting traits can use.\n \n     /// Performs the correct padding for an integer which has already been\n-    /// emitted into a byte-array. The byte-array should *not* contain the sign\n-    /// for the integer, that will be added by this method.\n+    /// emitted into a str. The str should *not* contain the sign for the\n+    /// integer, that will be added by this method.\n     ///\n     /// # Arguments\n     ///\n@@ -449,27 +492,25 @@ impl<'a> Formatter<'a> {\n     ///\n     /// This function will correctly account for the flags provided as well as\n     /// the minimum width. It will not take precision into account.\n-    #[unstable(feature = \"core\",\n-               reason = \"definition may change slightly over time\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn pad_integral(&mut self,\n                         is_positive: bool,\n                         prefix: &str,\n                         buf: &str)\n                         -> Result {\n         use char::CharExt;\n-        use fmt::rt::{FlagAlternate, FlagSignPlus, FlagSignAwareZeroPad};\n \n         let mut width = buf.len();\n \n         let mut sign = None;\n         if !is_positive {\n             sign = Some('-'); width += 1;\n-        } else if self.flags & (1 << (FlagSignPlus as uint)) != 0 {\n+        } else if self.flags & (1 << (FlagV1::SignPlus as uint)) != 0 {\n             sign = Some('+'); width += 1;\n         }\n \n         let mut prefixed = false;\n-        if self.flags & (1 << (FlagAlternate as uint)) != 0 {\n+        if self.flags & (1 << (FlagV1::Alternate as uint)) != 0 {\n             prefixed = true; width += prefix.char_len();\n         }\n \n@@ -499,16 +540,16 @@ impl<'a> Formatter<'a> {\n             }\n             // The sign and prefix goes before the padding if the fill character\n             // is zero\n-            Some(min) if self.flags & (1 << (FlagSignAwareZeroPad as uint)) != 0 => {\n+            Some(min) if self.flags & (1 << (FlagV1::SignAwareZeroPad as uint)) != 0 => {\n                 self.fill = '0';\n                 try!(write_prefix(self));\n-                self.with_padding(min - width, rt::AlignRight, |f| {\n+                self.with_padding(min - width, Alignment::Right, |f| {\n                     f.buf.write_str(buf)\n                 })\n             }\n             // Otherwise, the sign and prefix goes after the padding\n             Some(min) => {\n-                self.with_padding(min - width, rt::AlignRight, |f| {\n+                self.with_padding(min - width, Alignment::Right, |f| {\n                     try!(write_prefix(f)); f.buf.write_str(buf)\n                 })\n             }\n@@ -526,8 +567,7 @@ impl<'a> Formatter<'a> {\n     ///               is longer than this length\n     ///\n     /// Notably this function ignored the `flag` parameters\n-    #[unstable(feature = \"core\",\n-               reason = \"definition may change slightly over time\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn pad(&mut self, s: &str) -> Result {\n         // Make sure there's a fast path up front\n         if self.width.is_none() && self.precision.is_none() {\n@@ -561,7 +601,7 @@ impl<'a> Formatter<'a> {\n             // If we're under both the maximum and the minimum width, then fill\n             // up the minimum width with the specified string + some alignment.\n             Some(width) => {\n-                self.with_padding(width - s.char_len(), rt::AlignLeft, |me| {\n+                self.with_padding(width - s.char_len(), Alignment::Left, |me| {\n                     me.buf.write_str(s)\n                 })\n             }\n@@ -570,19 +610,20 @@ impl<'a> Formatter<'a> {\n \n     /// Runs a callback, emitting the correct padding either before or\n     /// afterwards depending on whether right or left alignment is requested.\n-    fn with_padding<F>(&mut self, padding: uint, default: rt::Alignment, f: F) -> Result where\n-        F: FnOnce(&mut Formatter) -> Result,\n+    fn with_padding<F>(&mut self, padding: uint, default: Alignment,\n+                       f: F) -> Result\n+        where F: FnOnce(&mut Formatter) -> Result,\n     {\n         use char::CharExt;\n         let align = match self.align {\n-            rt::AlignUnknown => default,\n+            Alignment::Unknown => default,\n             _ => self.align\n         };\n \n         let (pre_pad, post_pad) = match align {\n-            rt::AlignLeft => (0, padding),\n-            rt::AlignRight | rt::AlignUnknown => (padding, 0),\n-            rt::AlignCenter => (padding / 2, (padding + 1) / 2),\n+            Alignment::Left => (0, padding),\n+            Alignment::Right | Alignment::Unknown => (padding, 0),\n+            Alignment::Center => (padding / 2, (padding + 1) / 2),\n         };\n \n         let mut fill = [0u8; 4];\n@@ -604,31 +645,28 @@ impl<'a> Formatter<'a> {\n \n     /// Writes some data to the underlying buffer contained within this\n     /// formatter.\n-    #[unstable(feature = \"core\",\n-               reason = \"reconciling core and I/O may alter this definition\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn write_str(&mut self, data: &str) -> Result {\n         self.buf.write_str(data)\n     }\n \n     /// Writes some formatted information into this instance\n-    #[unstable(feature = \"core\",\n-               reason = \"reconciling core and I/O may alter this definition\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn write_fmt(&mut self, fmt: Arguments) -> Result {\n         write(self.buf, fmt)\n     }\n \n     /// Flags for formatting (packed version of rt::Flag)\n-    #[unstable(feature = \"core\",\n-               reason = \"return type may change and method was just created\")]\n-    pub fn flags(&self) -> uint { self.flags }\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn flags(&self) -> usize { self.flags }\n \n     /// Character used as 'fill' whenever there is alignment\n     #[unstable(feature = \"core\", reason = \"method was just created\")]\n     pub fn fill(&self) -> char { self.fill }\n \n     /// Flag indicating what form of alignment was requested\n     #[unstable(feature = \"core\", reason = \"method was just created\")]\n-    pub fn align(&self) -> rt::Alignment { self.align }\n+    pub fn align(&self) -> Alignment { self.align }\n \n     /// Optionally specified integer width that the output should be\n     #[unstable(feature = \"core\", reason = \"method was just created\")]\n@@ -649,20 +687,20 @@ impl Display for Error {\n /// This is a function which calls are emitted to by the compiler itself to\n /// create the Argument structures that are passed into the `format` function.\n #[doc(hidden)] #[inline]\n-#[unstable(feature = \"core\",\n-           reason = \"implementation detail of the `format_args!` macro\")]\n+#[cfg(stage0)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn argument<'a, T>(f: fn(&T, &mut Formatter) -> Result,\n-                       t: &'a T) -> Argument<'a> {\n-    Argument::new(t, f)\n+                       t: &'a T) -> ArgumentV1<'a> {\n+    ArgumentV1::new(t, f)\n }\n \n /// When the compiler determines that the type of an argument *must* be a uint\n /// (such as for width and precision), then it invokes this method.\n #[doc(hidden)] #[inline]\n-#[unstable(feature = \"core\",\n-           reason = \"implementation detail of the `format_args!` macro\")]\n-pub fn argumentuint<'a>(s: &'a uint) -> Argument<'a> {\n-    Argument::from_uint(s)\n+#[cfg(stage0)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn argumentuint<'a>(s: &'a uint) -> ArgumentV1<'a> {\n+    ArgumentV1::from_uint(s)\n }\n \n // Implementations of the core formatting traits\n@@ -741,9 +779,9 @@ impl Display for char {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Pointer for *const T {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n-        f.flags |= 1 << (rt::FlagAlternate as uint);\n+        f.flags |= 1 << (FlagV1::Alternate as uint);\n         let ret = LowerHex::fmt(&(*self as uint), f);\n-        f.flags &= !(1 << (rt::FlagAlternate as uint));\n+        f.flags &= !(1 << (FlagV1::Alternate as uint));\n         ret\n     }\n }\n@@ -899,7 +937,7 @@ impl<'a> Debug for &'a (any::Any+'a) {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Debug> Debug for [T] {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n-        if f.flags & (1 << (rt::FlagAlternate as uint)) == 0 {\n+        if f.flags & (1 << (FlagV1::Alternate as uint)) == 0 {\n             try!(write!(f, \"[\"));\n         }\n         let mut is_first = true;\n@@ -911,7 +949,7 @@ impl<T: Debug> Debug for [T] {\n             }\n             try!(write!(f, \"{:?}\", *x))\n         }\n-        if f.flags & (1 << (rt::FlagAlternate as uint)) == 0 {\n+        if f.flags & (1 << (FlagV1::Alternate as uint)) == 0 {\n             try!(write!(f, \"]\"));\n         }\n         Ok(())"}, {"sha": "0b2c1efbc5dee1682228f5e2ea263589265c2ee0", "filename": "src/libcore/fmt/rt.rs", "status": "removed", "additions": 0, "deletions": 86, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/1d00c545ede609b9d43fdf9f252c15da5a66dac7/src%2Flibcore%2Ffmt%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d00c545ede609b9d43fdf9f252c15da5a66dac7/src%2Flibcore%2Ffmt%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Frt.rs?ref=1d00c545ede609b9d43fdf9f252c15da5a66dac7", "patch": "@@ -1,86 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! This is an internal module used by the ifmt! runtime. These structures are\n-//! emitted to static arrays to precompile format strings ahead of time.\n-//!\n-//! These definitions are similar to their `ct` equivalents, but differ in that\n-//! these can be statically allocated and are slightly optimized for the runtime\n-\n-#![unstable(feature = \"core\",\n-            reason = \"implementation detail of the `format_args!` macro\")]\n-\n-pub use self::Alignment::*;\n-pub use self::Count::*;\n-pub use self::Position::*;\n-pub use self::Flag::*;\n-\n-#[doc(hidden)]\n-#[derive(Copy)]\n-pub struct Argument {\n-    pub position: Position,\n-    pub format: FormatSpec,\n-}\n-\n-#[doc(hidden)]\n-#[derive(Copy)]\n-pub struct FormatSpec {\n-    pub fill: char,\n-    pub align: Alignment,\n-    pub flags: uint,\n-    pub precision: Count,\n-    pub width: Count,\n-}\n-\n-/// Possible alignments that can be requested as part of a formatting directive.\n-#[derive(Copy, PartialEq)]\n-pub enum Alignment {\n-    /// Indication that contents should be left-aligned.\n-    AlignLeft,\n-    /// Indication that contents should be right-aligned.\n-    AlignRight,\n-    /// Indication that contents should be center-aligned.\n-    AlignCenter,\n-    /// No alignment was requested.\n-    AlignUnknown,\n-}\n-\n-#[doc(hidden)]\n-#[derive(Copy)]\n-pub enum Count {\n-    CountIs(uint), CountIsParam(uint), CountIsNextParam, CountImplied,\n-}\n-\n-#[doc(hidden)]\n-#[derive(Copy)]\n-pub enum Position {\n-    ArgumentNext, ArgumentIs(uint)\n-}\n-\n-/// Flags which can be passed to formatting via a directive.\n-///\n-/// These flags are discovered through the `flags` field of the `Formatter`\n-/// structure. The flag in that structure is a union of these flags into a\n-/// `uint` where each flag's discriminant is the corresponding bit.\n-#[derive(Copy)]\n-pub enum Flag {\n-    /// A flag which enables number formatting to always print the sign of a\n-    /// number.\n-    FlagSignPlus,\n-    /// Currently not a used flag\n-    FlagSignMinus,\n-    /// Indicates that the \"alternate formatting\" for a type should be used.\n-    ///\n-    /// The meaning of this flag is type-specific.\n-    FlagAlternate,\n-    /// Indicates that padding should be done with a `0` character as well as\n-    /// being aware of the sign to be printed.\n-    FlagSignAwareZeroPad,\n-}"}, {"sha": "f0c82759b70560ffce03c6c947b2b7c5622c9d68", "filename": "src/libcore/fmt/rt/v1.rs", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcore%2Ffmt%2Frt%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcore%2Ffmt%2Frt%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Frt%2Fv1.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -0,0 +1,94 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This is an internal module used by the ifmt! runtime. These structures are\n+//! emitted to static arrays to precompile format strings ahead of time.\n+//!\n+//! These definitions are similar to their `ct` equivalents, but differ in that\n+//! these can be statically allocated and are slightly optimized for the runtime\n+\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+#[cfg(stage0)] pub use self::Position::*;\n+\n+#[cfg(stage0)] pub use self::Alignment::Left as AlignLeft;\n+#[cfg(stage0)] pub use self::Alignment::Right as AlignRight;\n+#[cfg(stage0)] pub use self::Alignment::Center as AlignCenter;\n+#[cfg(stage0)] pub use self::Alignment::Unknown as AlignUnknown;\n+#[cfg(stage0)] pub use self::Count::Is as CountIs;\n+#[cfg(stage0)] pub use self::Count::Implied as CountImplied;\n+#[cfg(stage0)] pub use self::Count::Param as CountIsParam;\n+#[cfg(stage0)] pub use self::Count::NextParam as CountIsNextParam;\n+#[cfg(stage0)] pub use self::Position::Next as ArgumentNext;\n+#[cfg(stage0)] pub use self::Position::At as ArgumentIs;\n+\n+#[derive(Copy)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Argument {\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub position: Position,\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub format: FormatSpec,\n+}\n+\n+#[derive(Copy)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct FormatSpec {\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fill: char,\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub align: Alignment,\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub flags: uint,\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub precision: Count,\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub width: Count,\n+}\n+\n+/// Possible alignments that can be requested as part of a formatting directive.\n+#[derive(Copy, PartialEq)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub enum Alignment {\n+    /// Indication that contents should be left-aligned.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    Left,\n+    /// Indication that contents should be right-aligned.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    Right,\n+    /// Indication that contents should be center-aligned.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    Center,\n+    /// No alignment was requested.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    Unknown,\n+}\n+\n+#[derive(Copy)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub enum Count {\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    Is(usize),\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    Param(usize),\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    NextParam,\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    Implied,\n+}\n+\n+#[derive(Copy)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub enum Position {\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    Next,\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    At(usize)\n+}"}, {"sha": "b0906651da803abfa24e682c9eecbcd2f1967b1b", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 28, "deletions": 13, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -122,6 +122,22 @@ pub trait FromIterator<A> {\n     fn from_iter<T: Iterator<Item=A>>(iterator: T) -> Self;\n }\n \n+/// Conversion into an `Iterator`\n+pub trait IntoIterator {\n+    type Iter: Iterator;\n+\n+    /// Consumes `Self` and returns an iterator over it\n+    fn into_iter(self) -> Self::Iter;\n+}\n+\n+impl<I> IntoIterator for I where I: Iterator {\n+    type Iter = I;\n+\n+    fn into_iter(self) -> I {\n+        self\n+    }\n+}\n+\n /// A type growable from an `Iterator` implementation\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Extend<A> {\n@@ -178,7 +194,7 @@ pub trait IteratorExt: Iterator + Sized {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn nth(&mut self, mut n: usize) -> Option<Self::Item> {\n-        for x in *self {\n+        for x in self.by_ref() {\n             if n == 0 { return Some(x) }\n             n -= 1;\n         }\n@@ -475,7 +491,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// fn process<U: Iterator<Item=isize>>(it: U) -> isize {\n     ///     let mut it = it.fuse();\n     ///     let mut sum = 0;\n-    ///     for x in it {\n+    ///     for x in it.by_ref() {\n     ///         if x > 5 {\n     ///             break;\n     ///         }\n@@ -643,7 +659,7 @@ pub trait IteratorExt: Iterator + Sized {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn any<F>(&mut self, mut f: F) -> bool where F: FnMut(Self::Item) -> bool {\n-        for x in *self { if f(x) { return true; } }\n+        for x in self.by_ref() { if f(x) { return true; } }\n         false\n     }\n \n@@ -663,7 +679,7 @@ pub trait IteratorExt: Iterator + Sized {\n     fn find<P>(&mut self, mut predicate: P) -> Option<Self::Item> where\n         P: FnMut(&Self::Item) -> bool,\n     {\n-        for x in *self {\n+        for x in self.by_ref() {\n             if predicate(&x) { return Some(x) }\n         }\n         None\n@@ -686,7 +702,7 @@ pub trait IteratorExt: Iterator + Sized {\n         P: FnMut(Self::Item) -> bool,\n     {\n         let mut i = 0;\n-        for x in *self {\n+        for x in self.by_ref() {\n             if predicate(x) {\n                 return Some(i);\n             }\n@@ -1312,7 +1328,7 @@ impl<T, D, I> ExactSizeIterator for Cloned<I> where\n {}\n \n /// An iterator that repeats endlessly\n-#[derive(Clone, Copy)]\n+#[derive(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Cycle<I> {\n@@ -1647,7 +1663,7 @@ impl<A, I, P> Iterator for Filter<A, I, P> where I: Iterator<Item=A>, P: FnMut(&\n \n     #[inline]\n     fn next(&mut self) -> Option<A> {\n-        for x in self.iter {\n+        for x in self.iter.by_ref() {\n             if (self.predicate)(&x) {\n                 return Some(x);\n             } else {\n@@ -1711,7 +1727,7 @@ impl<A, B, I, F> Iterator for FilterMap<A, B, I, F> where\n \n     #[inline]\n     fn next(&mut self) -> Option<B> {\n-        for x in self.iter {\n+        for x in self.iter.by_ref() {\n             match (self.f)(x) {\n                 Some(y) => return Some(y),\n                 None => ()\n@@ -1810,7 +1826,6 @@ impl<I> RandomAccessIterator for Enumerate<I> where I: RandomAccessIterator {\n /// An iterator with a `peek()` that returns an optional reference to the next element.\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[derive(Copy)]\n pub struct Peekable<T, I> where I: Iterator<Item=T> {\n     iter: I,\n     peeked: Option<T>,\n@@ -1897,7 +1912,7 @@ impl<A, I, P> Iterator for SkipWhile<A, I, P> where I: Iterator<Item=A>, P: FnMu\n \n     #[inline]\n     fn next(&mut self) -> Option<A> {\n-        for x in self.iter {\n+        for x in self.iter.by_ref() {\n             if self.flag || !(self.predicate)(&x) {\n                 self.flag = true;\n                 return Some(x);\n@@ -2190,7 +2205,7 @@ impl<A, B, I, U, F> Iterator for FlatMap<A, B, I, U, F> where\n     fn next(&mut self) -> Option<B> {\n         loop {\n             for inner in self.frontiter.iter_mut() {\n-                for x in *inner {\n+                for x in inner.by_ref() {\n                     return Some(x)\n                 }\n             }\n@@ -2484,7 +2499,7 @@ impl<A, St, F> Iterator for Unfold<A, St, F> where F: FnMut(&mut St) -> Option<A\n \n /// An infinite iterator starting at `start` and advancing by `step` with each\n /// iteration\n-#[derive(Clone, Copy)]\n+#[derive(Clone)]\n #[unstable(feature = \"core\",\n            reason = \"may be renamed or replaced by range notation adapaters\")]\n pub struct Counter<A> {\n@@ -2520,7 +2535,7 @@ impl<A: Add<Output=A> + Clone> Iterator for Counter<A> {\n }\n \n /// An iterator over the range [start, stop)\n-#[derive(Clone, Copy)]\n+#[derive(Clone)]\n #[unstable(feature = \"core\",\n            reason = \"will be replaced by range notation\")]\n pub struct Range<A> {"}, {"sha": "d2bc30fa74a183335540d13a87ab739a8bf02ff1", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -49,7 +49,6 @@\n \n #![crate_name = \"core\"]\n #![unstable(feature = \"core\")]\n-#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n@@ -58,13 +57,16 @@\n        html_playground_url = \"http://play.rust-lang.org/\")]\n \n #![no_std]\n-#![allow(unknown_features, raw_pointer_derive)]\n-#![allow(unknown_features)] #![feature(intrinsics, lang_items)]\n+#![allow(raw_pointer_derive)]\n+#![deny(missing_docs)]\n+#![cfg_attr(not(stage0), allow(unused_mut))] // NOTE: remove after stage0 snap\n+\n+#![feature(int_uint)]\n+#![feature(intrinsics, lang_items)]\n+#![feature(on_unimplemented)]\n #![feature(simd, unsafe_destructor, slicing_syntax)]\n+#![feature(staged_api)]\n #![feature(unboxed_closures)]\n-#![allow(unknown_features)] #![feature(int_uint)]\n-#![feature(on_unimplemented)]\n-#![deny(missing_docs)]\n \n #[macro_use]\n mod macros;\n@@ -158,4 +160,6 @@ mod std {\n     pub use marker;\n     pub use ops;\n     pub use option;\n+    // for-loops\n+    pub use iter;\n }"}, {"sha": "3f83302742c8caffef831c7d1c1c22d8764a5acb", "filename": "src/libcore/nonzero.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcore%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcore%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnonzero.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -11,12 +11,14 @@\n //! Exposes the NonZero lang item which provides optimization hints.\n \n use ops::Deref;\n+use ptr::Unique;\n \n /// Unsafe trait to indicate what types are usable with the NonZero struct\n pub unsafe trait Zeroable {}\n \n unsafe impl<T> Zeroable for *const T {}\n unsafe impl<T> Zeroable for *mut T {}\n+unsafe impl<T> Zeroable for Unique<T> { }\n unsafe impl Zeroable for int {}\n unsafe impl Zeroable for uint {}\n unsafe impl Zeroable for i8 {}"}, {"sha": "b7c5c6640ced0132dddde8709a0c2b222b262e55", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 125, "deletions": 53, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -17,16 +17,17 @@\n \n use char::CharExt;\n use clone::Clone;\n-use cmp::{PartialEq, Eq};\n-use cmp::{PartialOrd, Ord};\n+use cmp::{PartialEq, Eq, PartialOrd, Ord};\n+use error::Error;\n+use fmt;\n use intrinsics;\n use iter::IteratorExt;\n use marker::Copy;\n use mem::size_of;\n use ops::{Add, Sub, Mul, Div, Rem, Neg};\n use ops::{Not, BitAnd, BitOr, BitXor, Shl, Shr};\n-use option::Option;\n-use option::Option::{Some, None};\n+use option::Option::{self, Some, None};\n+use result::Result::{self, Ok, Err};\n use str::{FromStr, StrExt};\n \n /// A built-in signed or unsigned integer.\n@@ -1428,22 +1429,25 @@ pub trait Float\n }\n \n /// A generic trait for converting a string with a radix (base) to a value\n-#[unstable(feature = \"core\", reason = \"might need to return Result\")]\n+#[unstable(feature = \"core\", reason = \"needs reevaluation\")]\n pub trait FromStrRadix {\n-    fn from_str_radix(str: &str, radix: uint) -> Option<Self>;\n+    type Err;\n+    fn from_str_radix(str: &str, radix: uint) -> Result<Self, Self::Err>;\n }\n \n /// A utility function that just calls FromStrRadix::from_str_radix.\n-#[unstable(feature = \"core\", reason = \"might need to return Result\")]\n-pub fn from_str_radix<T: FromStrRadix>(str: &str, radix: uint) -> Option<T> {\n+#[unstable(feature = \"core\", reason = \"needs reevaluation\")]\n+pub fn from_str_radix<T: FromStrRadix>(str: &str, radix: uint)\n+                                       -> Result<T, T::Err> {\n     FromStrRadix::from_str_radix(str, radix)\n }\n \n macro_rules! from_str_radix_float_impl {\n     ($T:ty) => {\n-        #[unstable(feature = \"core\",\n-                   reason = \"might need to return Result\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl FromStr for $T {\n+            type Err = ParseFloatError;\n+\n             /// Convert a string in base 10 to a float.\n             /// Accepts an optional decimal exponent.\n             ///\n@@ -1470,14 +1474,15 @@ macro_rules! from_str_radix_float_impl {\n             /// `None` if the string did not represent a valid number.  Otherwise,\n             /// `Some(n)` where `n` is the floating-point number represented by `src`.\n             #[inline]\n-            fn from_str(src: &str) -> Option<$T> {\n+            fn from_str(src: &str) -> Result<$T, ParseFloatError> {\n                 from_str_radix(src, 10)\n             }\n         }\n \n-        #[unstable(feature = \"core\",\n-                   reason = \"might need to return Result\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl FromStrRadix for $T {\n+            type Err = ParseFloatError;\n+\n             /// Convert a string in a given base to a float.\n             ///\n             /// Due to possible conflicts, this function does **not** accept\n@@ -1493,24 +1498,28 @@ macro_rules! from_str_radix_float_impl {\n             ///\n             /// # Return value\n             ///\n-            /// `None` if the string did not represent a valid number. Otherwise,\n-            /// `Some(n)` where `n` is the floating-point number represented by `src`.\n-            fn from_str_radix(src: &str, radix: uint) -> Option<$T> {\n-               assert!(radix >= 2 && radix <= 36,\n+            /// `None` if the string did not represent a valid number.\n+            /// Otherwise, `Some(n)` where `n` is the floating-point number\n+            /// represented by `src`.\n+            fn from_str_radix(src: &str, radix: uint)\n+                              -> Result<$T, ParseFloatError> {\n+                use self::FloatErrorKind::*;\n+                use self::ParseFloatError as PFE;\n+                assert!(radix >= 2 && radix <= 36,\n                        \"from_str_radix_float: must lie in the range `[2, 36]` - found {}\",\n                        radix);\n \n                 // Special values\n                 match src {\n-                    \"inf\"   => return Some(Float::infinity()),\n-                    \"-inf\"  => return Some(Float::neg_infinity()),\n-                    \"NaN\"   => return Some(Float::nan()),\n+                    \"inf\"   => return Ok(Float::infinity()),\n+                    \"-inf\"  => return Ok(Float::neg_infinity()),\n+                    \"NaN\"   => return Ok(Float::nan()),\n                     _       => {},\n                 }\n \n                 let (is_positive, src) =  match src.slice_shift_char() {\n-                    None             => return None,\n-                    Some(('-', \"\"))  => return None,\n+                    None             => return Err(PFE { kind: Empty }),\n+                    Some(('-', \"\"))  => return Err(PFE { kind: Empty }),\n                     Some(('-', src)) => (false, src),\n                     Some((_, _))     => (true,  src),\n                 };\n@@ -1524,7 +1533,7 @@ macro_rules! from_str_radix_float_impl {\n                 let mut exp_info = None::<(char, uint)>;\n \n                 // Parse the integer part of the significand\n-                for (i, c) in cs {\n+                for (i, c) in cs.by_ref() {\n                     match c.to_digit(radix) {\n                         Some(digit) => {\n                             // shift significand one digit left\n@@ -1541,15 +1550,15 @@ macro_rules! from_str_radix_float_impl {\n                             // if we've not seen any non-zero digits.\n                             if prev_sig != 0.0 {\n                                 if is_positive && sig <= prev_sig\n-                                    { return Some(Float::infinity()); }\n+                                    { return Ok(Float::infinity()); }\n                                 if !is_positive && sig >= prev_sig\n-                                    { return Some(Float::neg_infinity()); }\n+                                    { return Ok(Float::neg_infinity()); }\n \n                                 // Detect overflow by reversing the shift-and-add process\n                                 if is_positive && (prev_sig != (sig - digit as $T) / radix as $T)\n-                                    { return Some(Float::infinity()); }\n+                                    { return Ok(Float::infinity()); }\n                                 if !is_positive && (prev_sig != (sig + digit as $T) / radix as $T)\n-                                    { return Some(Float::neg_infinity()); }\n+                                    { return Ok(Float::neg_infinity()); }\n                             }\n                             prev_sig = sig;\n                         },\n@@ -1562,7 +1571,7 @@ macro_rules! from_str_radix_float_impl {\n                                 break;  // start of fractional part\n                             },\n                             _ => {\n-                                return None;\n+                                return Err(PFE { kind: Invalid });\n                             },\n                         },\n                     }\n@@ -1572,7 +1581,7 @@ macro_rules! from_str_radix_float_impl {\n                 // part of the significand\n                 if exp_info.is_none() {\n                     let mut power = 1.0;\n-                    for (i, c) in cs {\n+                    for (i, c) in cs.by_ref() {\n                         match c.to_digit(radix) {\n                             Some(digit) => {\n                                 // Decrease power one order of magnitude\n@@ -1585,9 +1594,9 @@ macro_rules! from_str_radix_float_impl {\n                                 };\n                                 // Detect overflow by comparing to last value\n                                 if is_positive && sig < prev_sig\n-                                    { return Some(Float::infinity()); }\n+                                    { return Ok(Float::infinity()); }\n                                 if !is_positive && sig > prev_sig\n-                                    { return Some(Float::neg_infinity()); }\n+                                    { return Ok(Float::neg_infinity()); }\n                                 prev_sig = sig;\n                             },\n                             None => match c {\n@@ -1596,7 +1605,7 @@ macro_rules! from_str_radix_float_impl {\n                                     break; // start of exponent\n                                 },\n                                 _ => {\n-                                    return None; // invalid number\n+                                    return Err(PFE { kind: Invalid });\n                                 },\n                             },\n                         }\n@@ -1609,7 +1618,7 @@ macro_rules! from_str_radix_float_impl {\n                         let base = match c {\n                             'E' | 'e' if radix == 10 => 10.0,\n                             'P' | 'p' if radix == 16 => 2.0,\n-                            _ => return None,\n+                            _ => return Err(PFE { kind: Invalid }),\n                         };\n \n                         // Parse the exponent as decimal integer\n@@ -1618,19 +1627,19 @@ macro_rules! from_str_radix_float_impl {\n                             Some(('-', src)) => (false, src.parse::<uint>()),\n                             Some(('+', src)) => (true,  src.parse::<uint>()),\n                             Some((_, _))     => (true,  src.parse::<uint>()),\n-                            None             => return None,\n+                            None             => return Err(PFE { kind: Invalid }),\n                         };\n \n                         match (is_positive, exp) {\n-                            (true,  Some(exp)) => base.powi(exp as i32),\n-                            (false, Some(exp)) => 1.0 / base.powi(exp as i32),\n-                            (_, None)          => return None,\n+                            (true,  Ok(exp)) => base.powi(exp as i32),\n+                            (false, Ok(exp)) => 1.0 / base.powi(exp as i32),\n+                            (_, Err(_))      => return Err(PFE { kind: Invalid }),\n                         }\n                     },\n                     None => 1.0, // no exponent\n                 };\n \n-                Some(sig * exp)\n+                Ok(sig * exp)\n             }\n         }\n     }\n@@ -1640,19 +1649,22 @@ from_str_radix_float_impl! { f64 }\n \n macro_rules! from_str_radix_int_impl {\n     ($T:ty) => {\n-        #[unstable(feature = \"core\",\n-                   reason = \"might need to return Result\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl FromStr for $T {\n+            type Err = ParseIntError;\n             #[inline]\n-            fn from_str(src: &str) -> Option<$T> {\n+            fn from_str(src: &str) -> Result<$T, ParseIntError> {\n                 from_str_radix(src, 10)\n             }\n         }\n \n-        #[unstable(feature = \"core\",\n-                   reason = \"might need to return Result\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl FromStrRadix for $T {\n-            fn from_str_radix(src: &str, radix: uint) -> Option<$T> {\n+            type Err = ParseIntError;\n+            fn from_str_radix(src: &str, radix: uint)\n+                              -> Result<$T, ParseIntError> {\n+                use self::IntErrorKind::*;\n+                use self::ParseIntError as PIE;\n                 assert!(radix >= 2 && radix <= 36,\n                        \"from_str_radix_int: must lie in the range `[2, 36]` - found {}\",\n                        radix);\n@@ -1666,39 +1678,39 @@ macro_rules! from_str_radix_int_impl {\n                         for c in src.chars() {\n                             let x = match c.to_digit(radix) {\n                                 Some(x) => x,\n-                                None => return None,\n+                                None => return Err(PIE { kind: InvalidDigit }),\n                             };\n                             result = match result.checked_mul(radix as $T) {\n                                 Some(result) => result,\n-                                None => return None,\n+                                None => return Err(PIE { kind: Underflow }),\n                             };\n                             result = match result.checked_sub(x as $T) {\n                                 Some(result) => result,\n-                                None => return None,\n+                                None => return Err(PIE { kind: Underflow }),\n                             };\n                         }\n-                        Some(result)\n+                        Ok(result)\n                     },\n                     Some((_, _)) => {\n                         // The number is signed\n                         let mut result = 0;\n                         for c in src.chars() {\n                             let x = match c.to_digit(radix) {\n                                 Some(x) => x,\n-                                None => return None,\n+                                None => return Err(PIE { kind: InvalidDigit }),\n                             };\n                             result = match result.checked_mul(radix as $T) {\n                                 Some(result) => result,\n-                                None => return None,\n+                                None => return Err(PIE { kind: Overflow }),\n                             };\n                             result = match result.checked_add(x as $T) {\n                                 Some(result) => result,\n-                                None => return None,\n+                                None => return Err(PIE { kind: Overflow }),\n                             };\n                         }\n-                        Some(result)\n+                        Ok(result)\n                     },\n-                    None => None,\n+                    None => Err(ParseIntError { kind: Empty }),\n                 }\n             }\n         }\n@@ -1714,3 +1726,63 @@ from_str_radix_int_impl! { u8 }\n from_str_radix_int_impl! { u16 }\n from_str_radix_int_impl! { u32 }\n from_str_radix_int_impl! { u64 }\n+\n+/// An error which can be returned when parsing an integer.\n+#[derive(Debug, Clone, PartialEq)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct ParseIntError { kind: IntErrorKind }\n+\n+#[derive(Debug, Clone, PartialEq)]\n+enum IntErrorKind {\n+    Empty,\n+    InvalidDigit,\n+    Overflow,\n+    Underflow,\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Display for ParseIntError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        self.description().fmt(f)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Error for ParseIntError {\n+    fn description(&self) -> &str {\n+        match self.kind {\n+            IntErrorKind::Empty => \"cannot parse integer from empty string\",\n+            IntErrorKind::InvalidDigit => \"invalid digit found in string\",\n+            IntErrorKind::Overflow => \"number too large to fit in target type\",\n+            IntErrorKind::Underflow => \"number too small to fit in target type\",\n+        }\n+    }\n+}\n+\n+/// An error which can be returned when parsing a float.\n+#[derive(Debug, Clone, PartialEq)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct ParseFloatError { kind: FloatErrorKind }\n+\n+#[derive(Debug, Clone, PartialEq)]\n+enum FloatErrorKind {\n+    Empty,\n+    Invalid,\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Display for ParseFloatError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        self.description().fmt(f)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Error for ParseFloatError {\n+    fn description(&self) -> &str {\n+        match self.kind {\n+            FloatErrorKind::Empty => \"cannot parse float from empty string\",\n+            FloatErrorKind::Invalid => \"invalid float literal\",\n+        }\n+    }\n+}"}, {"sha": "4b19d29330baa2c0ea3921811b793f1252ca9c9a", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -1134,55 +1134,6 @@ impl<'a, T: ?Sized> DerefMut for &'a mut T {\n #[lang=\"fn\"]\n #[unstable(feature = \"core\",\n            reason = \"uncertain about variadic generics, input versus associated types\")]\n-#[cfg(stage0)]\n-pub trait Fn<Args,Output> {\n-    /// This is called when the call operator is used.\n-    extern \"rust-call\" fn call(&self, args: Args) -> Output;\n-}\n-\n-/// A version of the call operator that takes a mutable receiver.\n-#[lang=\"fn_mut\"]\n-#[unstable(feature = \"core\",\n-           reason = \"uncertain about variadic generics, input versus associated types\")]\n-#[cfg(stage0)]\n-pub trait FnMut<Args,Output> {\n-    /// This is called when the call operator is used.\n-    extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Output;\n-}\n-\n-/// A version of the call operator that takes a by-value receiver.\n-#[lang=\"fn_once\"]\n-#[unstable(feature = \"core\",\n-           reason = \"uncertain about variadic generics, input versus associated types\")]\n-#[cfg(stage0)]\n-pub trait FnOnce<Args,Output> {\n-    /// This is called when the call operator is used.\n-    extern \"rust-call\" fn call_once(self, args: Args) -> Output;\n-}\n-\n-#[cfg(stage0)]\n-impl<F: ?Sized, A, R> FnMut<A, R> for F\n-    where F : Fn<A, R>\n-{\n-    extern \"rust-call\" fn call_mut(&mut self, args: A) -> R {\n-        self.call(args)\n-    }\n-}\n-\n-#[cfg(stage0)]\n-impl<F,A,R> FnOnce<A,R> for F\n-    where F : FnMut<A,R>\n-{\n-    extern \"rust-call\" fn call_once(mut self, args: A) -> R {\n-        self.call_mut(args)\n-    }\n-}\n-\n-/// A version of the call operator that takes an immutable receiver.\n-#[lang=\"fn\"]\n-#[unstable(feature = \"core\",\n-           reason = \"uncertain about variadic generics, input versus associated types\")]\n-#[cfg(not(stage0))]\n #[rustc_paren_sugar]\n pub trait Fn<Args> {\n     type Output;\n@@ -1195,7 +1146,6 @@ pub trait Fn<Args> {\n #[lang=\"fn_mut\"]\n #[unstable(feature = \"core\",\n            reason = \"uncertain about variadic generics, input versus associated types\")]\n-#[cfg(not(stage0))]\n #[rustc_paren_sugar]\n pub trait FnMut<Args> {\n     type Output;\n@@ -1208,7 +1158,6 @@ pub trait FnMut<Args> {\n #[lang=\"fn_once\"]\n #[unstable(feature = \"core\",\n            reason = \"uncertain about variadic generics, input versus associated types\")]\n-#[cfg(not(stage0))]\n #[rustc_paren_sugar]\n pub trait FnOnce<Args> {\n     type Output;\n@@ -1217,7 +1166,6 @@ pub trait FnOnce<Args> {\n     extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n }\n \n-#[cfg(not(stage0))]\n impl<F: ?Sized, A> FnMut<A> for F\n     where F : Fn<A>\n {\n@@ -1228,7 +1176,6 @@ impl<F: ?Sized, A> FnMut<A> for F\n     }\n }\n \n-#[cfg(not(stage0))]\n impl<F,A> FnOnce<A> for F\n     where F : FnMut<A>\n {"}, {"sha": "2f261b0628faf1cd6b550c4d27e55a022f1e4e29", "filename": "src/libcore/option.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -728,8 +728,8 @@ impl<T: Default> Option<T> {\n     /// ```\n     /// let good_year_from_input = \"1909\";\n     /// let bad_year_from_input = \"190blarg\";\n-    /// let good_year = good_year_from_input.parse().unwrap_or_default();\n-    /// let bad_year = bad_year_from_input.parse().unwrap_or_default();\n+    /// let good_year = good_year_from_input.parse().ok().unwrap_or_default();\n+    /// let bad_year = bad_year_from_input.parse().ok().unwrap_or_default();\n     ///\n     /// assert_eq!(1909, good_year);\n     /// assert_eq!(0, bad_year);"}, {"sha": "fc7d4e868f746890841e199f139f6f0215fa9062", "filename": "src/libcore/result.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -229,7 +229,7 @@\n use self::Result::{Ok, Err};\n \n use clone::Clone;\n-use fmt::Debug;\n+use fmt;\n use iter::{Iterator, IteratorExt, DoubleEndedIterator, FromIterator, ExactSizeIterator};\n use ops::{FnMut, FnOnce};\n use option::Option::{self, None, Some};\n@@ -715,7 +715,7 @@ impl<T, E> Result<T, E> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, E: Debug> Result<T, E> {\n+impl<T, E: fmt::Debug> Result<T, E> {\n     /// Unwraps a result, yielding the content of an `Ok`.\n     ///\n     /// # Panics\n@@ -746,7 +746,7 @@ impl<T, E: Debug> Result<T, E> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Debug, E> Result<T, E> {\n+impl<T: fmt::Debug, E> Result<T, E> {\n     /// Unwraps a result, yielding the content of an `Err`.\n     ///\n     /// # Panics"}, {"sha": "a368ddba9bc30d177d8b7913c69ee54c1d176532", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -41,7 +41,6 @@ use cmp::Ordering::{Less, Equal, Greater};\n use cmp;\n use default::Default;\n use iter::*;\n-use marker::Copy;\n use num::Int;\n use ops::{FnMut, self, Index};\n #[cfg(stage0)]\n@@ -637,6 +636,22 @@ impl<'a, T> Default for &'a [T] {\n // Iterators\n //\n \n+impl<'a, T> IntoIterator for &'a [T] {\n+    type Iter = Iter<'a, T>;\n+\n+    fn into_iter(self) -> Iter<'a, T> {\n+        self.iter()\n+    }\n+}\n+\n+impl<'a, T> IntoIterator for &'a mut [T] {\n+    type Iter = IterMut<'a, T>;\n+\n+    fn into_iter(self) -> IterMut<'a, T> {\n+        self.iter_mut()\n+    }\n+}\n+\n // The shared definition of the `Iter` and `IterMut` iterators\n macro_rules! iterator {\n     (struct $name:ident -> $ptr:ty, $elem:ty) => {\n@@ -784,16 +799,14 @@ impl<'a, T> Iter<'a, T> {\n     }\n }\n \n-impl<'a,T> Copy for Iter<'a,T> {}\n-\n iterator!{struct Iter -> *const T, &'a T}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for Iter<'a, T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Clone for Iter<'a, T> {\n-    fn clone(&self) -> Iter<'a, T> { *self }\n+    fn clone(&self) -> Iter<'a, T> { Iter { ptr: self.ptr, end: self.end, marker: self.marker } }\n }\n \n #[unstable(feature = \"core\", reason = \"trait is experimental\")]"}, {"sha": "cb7af3b3d35a1297fe73e529e2105435443b23fa", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 43, "deletions": 26, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -18,6 +18,7 @@\n \n use self::Searcher::{Naive, TwoWay, TwoWayLong};\n \n+use clone::Clone;\n use cmp::{self, Eq};\n use default::Default;\n use error::Error;\n@@ -108,37 +109,62 @@ macro_rules! delegate_iter {\n \n /// A trait to abstract the idea of creating a new instance of a type from a\n /// string.\n-// FIXME(#17307): there should be an `E` associated type for a `Result` return\n-#[unstable(feature = \"core\",\n-           reason = \"will return a Result once associated types are working\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait FromStr {\n+    /// The associated error which can be returned from parsing.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    type Err;\n+\n     /// Parses a string `s` to return an optional value of this type. If the\n     /// string is ill-formatted, the None is returned.\n-    fn from_str(s: &str) -> Option<Self>;\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn from_str(s: &str) -> Result<Self, Self::Err>;\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl FromStr for bool {\n+    type Err = ParseBoolError;\n+\n     /// Parse a `bool` from a string.\n     ///\n-    /// Yields an `Option<bool>`, because `s` may or may not actually be parseable.\n+    /// Yields an `Option<bool>`, because `s` may or may not actually be\n+    /// parseable.\n     ///\n     /// # Examples\n     ///\n     /// ```rust\n-    /// assert_eq!(\"true\".parse(), Some(true));\n-    /// assert_eq!(\"false\".parse(), Some(false));\n-    /// assert_eq!(\"not even a boolean\".parse::<bool>(), None);\n+    /// assert_eq!(\"true\".parse(), Ok(true));\n+    /// assert_eq!(\"false\".parse(), Ok(false));\n+    /// assert!(\"not even a boolean\".parse::<bool>().is_err());\n     /// ```\n     #[inline]\n-    fn from_str(s: &str) -> Option<bool> {\n+    fn from_str(s: &str) -> Result<bool, ParseBoolError> {\n         match s {\n-            \"true\"  => Some(true),\n-            \"false\" => Some(false),\n-            _       => None,\n+            \"true\"  => Ok(true),\n+            \"false\" => Ok(false),\n+            _       => Err(ParseBoolError { _priv: () }),\n         }\n     }\n }\n \n+/// An error returned when parsing a `bool` from a string fails.\n+#[derive(Debug, Clone, PartialEq)]\n+#[allow(missing_copy_implementations)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct ParseBoolError { _priv: () }\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Display for ParseBoolError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        \"provided string was not `true` or `false`\".fmt(f)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Error for ParseBoolError {\n+    fn description(&self) -> &str { \"failed to parse bool\" }\n+}\n+\n /*\n Section: Creating a string\n */\n@@ -279,7 +305,7 @@ Section: Iterators\n /// Iterator for the char (representing *Unicode Scalar Values*) of a string\n ///\n /// Created with the method `.chars()`.\n-#[derive(Clone, Copy)]\n+#[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Chars<'a> {\n     iter: slice::Iter<'a, u8>\n@@ -460,15 +486,6 @@ delegate_iter!{exact u8 : Bytes<'a>}\n #[derive(Copy, Clone)]\n struct BytesDeref;\n \n-#[cfg(stage0)]\n-impl<'a> Fn(&'a u8) -> u8 for BytesDeref {\n-    #[inline]\n-    extern \"rust-call\" fn call(&self, (ptr,): (&'a u8,)) -> u8 {\n-        *ptr\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<'a> Fn<(&'a u8,)> for BytesDeref {\n     type Output = u8;\n \n@@ -1007,11 +1024,11 @@ fn run_utf8_validation_iterator(iter: &mut slice::Iter<u8>)\n     let whole = iter.as_slice();\n     loop {\n         // save the current thing we're pointing at.\n-        let old = *iter;\n+        let old = iter.clone();\n \n         // restore the iterator we had at the start of this codepoint.\n         macro_rules! err { () => {{\n-            *iter = old;\n+            *iter = old.clone();\n             return Err(Utf8Error::InvalidByte(whole.len() - iter.as_slice().len()))\n         }}}\n \n@@ -1355,7 +1372,7 @@ pub trait StrExt {\n     fn as_ptr(&self) -> *const u8;\n     fn len(&self) -> uint;\n     fn is_empty(&self) -> bool;\n-    fn parse<T: FromStr>(&self) -> Option<T>;\n+    fn parse<T: FromStr>(&self) -> Result<T, T::Err>;\n }\n \n #[inline(never)]\n@@ -1670,7 +1687,7 @@ impl StrExt for str {\n     fn is_empty(&self) -> bool { self.len() == 0 }\n \n     #[inline]\n-    fn parse<T: FromStr>(&self) -> Option<T> { FromStr::from_str(self) }\n+    fn parse<T: FromStr>(&self) -> Result<T, T::Err> { FromStr::from_str(self) }\n }\n \n /// Pluck a code point out of a UTF-8-like byte slice and return the"}, {"sha": "5ad3833a5ef2e3c49e694da871285ba61a73611e", "filename": "src/libcoretest/any.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcoretest%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcoretest%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fany.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -123,7 +123,7 @@ fn any_fixed_vec() {\n #[bench]\n fn bench_downcast_ref(b: &mut Bencher) {\n     b.iter(|| {\n-        let mut x = 0i;\n+        let mut x = 0;\n         let mut y = &mut x as &mut Any;\n         test::black_box(&mut y);\n         test::black_box(y.downcast_ref::<int>() == Some(&0));"}, {"sha": "5815dbc0accfd324801feeecae3660cc19e81b30", "filename": "src/libcoretest/cell.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcoretest%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcoretest%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fcell.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -14,14 +14,14 @@ use std::mem::drop;\n \n #[test]\n fn smoketest_cell() {\n-    let x = Cell::new(10i);\n+    let x = Cell::new(10);\n     assert!(x == Cell::new(10));\n     assert!(x.get() == 10);\n     x.set(20);\n     assert!(x == Cell::new(20));\n     assert!(x.get() == 20);\n \n-    let y = Cell::new((30i, 40i));\n+    let y = Cell::new((30, 40));\n     assert!(y == Cell::new((30, 40)));\n     assert!(y.get() == (30, 40));\n }\n@@ -50,35 +50,35 @@ fn ref_and_refmut_have_sensible_show() {\n \n #[test]\n fn double_imm_borrow() {\n-    let x = RefCell::new(0i);\n+    let x = RefCell::new(0);\n     let _b1 = x.borrow();\n     x.borrow();\n }\n \n #[test]\n fn no_mut_then_imm_borrow() {\n-    let x = RefCell::new(0i);\n+    let x = RefCell::new(0);\n     let _b1 = x.borrow_mut();\n     assert!(x.try_borrow().is_none());\n }\n \n #[test]\n fn no_imm_then_borrow_mut() {\n-    let x = RefCell::new(0i);\n+    let x = RefCell::new(0);\n     let _b1 = x.borrow();\n     assert!(x.try_borrow_mut().is_none());\n }\n \n #[test]\n fn no_double_borrow_mut() {\n-    let x = RefCell::new(0i);\n+    let x = RefCell::new(0);\n     let _b1 = x.borrow_mut();\n     assert!(x.try_borrow_mut().is_none());\n }\n \n #[test]\n fn imm_release_borrow_mut() {\n-    let x = RefCell::new(0i);\n+    let x = RefCell::new(0);\n     {\n         let _b1 = x.borrow();\n     }\n@@ -87,7 +87,7 @@ fn imm_release_borrow_mut() {\n \n #[test]\n fn mut_release_borrow_mut() {\n-    let x = RefCell::new(0i);\n+    let x = RefCell::new(0);\n     {\n         let _b1 = x.borrow_mut();\n     }\n@@ -96,7 +96,7 @@ fn mut_release_borrow_mut() {\n \n #[test]\n fn double_borrow_single_release_no_borrow_mut() {\n-    let x = RefCell::new(0i);\n+    let x = RefCell::new(0);\n     let _b1 = x.borrow();\n     {\n         let _b2 = x.borrow();\n@@ -107,15 +107,15 @@ fn double_borrow_single_release_no_borrow_mut() {\n #[test]\n #[should_fail]\n fn discard_doesnt_unborrow() {\n-    let x = RefCell::new(0i);\n+    let x = RefCell::new(0);\n     let _b = x.borrow();\n     let _ = _b;\n     let _b = x.borrow_mut();\n }\n \n #[test]\n fn clone_ref_updates_flag() {\n-    let x = RefCell::new(0i);\n+    let x = RefCell::new(0);\n     {\n         let b1 = x.borrow();\n         assert!(x.try_borrow_mut().is_none());"}, {"sha": "5ab6ab27ba1d0680170d2ae9fa33cd9a4787e9b2", "filename": "src/libcoretest/clone.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcoretest%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcoretest%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fclone.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -10,16 +10,16 @@\n \n #[test]\n fn test_borrowed_clone() {\n-    let x = 5i;\n+    let x = 5;\n     let y: &int = &x;\n     let z: &int = (&y).clone();\n     assert_eq!(*z, 5);\n }\n \n #[test]\n fn test_clone_from() {\n-    let a = box 5i;\n-    let mut b = box 10i;\n+    let a = box 5;\n+    let mut b = box 10;\n     b.clone_from(&a);\n     assert_eq!(*b, 5);\n }"}, {"sha": "6bc1f14cc5af4df47af59fa3674207669e30bee9", "filename": "src/libcoretest/cmp.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcoretest%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcoretest%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fcmp.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -13,20 +13,20 @@ use core::cmp::Ordering::{Less, Greater, Equal};\n \n #[test]\n fn test_int_totalord() {\n-    assert_eq!(5i.cmp(&10), Less);\n-    assert_eq!(10i.cmp(&5), Greater);\n-    assert_eq!(5i.cmp(&5), Equal);\n-    assert_eq!((-5i).cmp(&12), Less);\n-    assert_eq!(12i.cmp(&-5), Greater);\n+    assert_eq!(5.cmp(&10), Less);\n+    assert_eq!(10.cmp(&5), Greater);\n+    assert_eq!(5.cmp(&5), Equal);\n+    assert_eq!((-5).cmp(&12), Less);\n+    assert_eq!(12.cmp(&-5), Greater);\n }\n \n #[test]\n fn test_mut_int_totalord() {\n-    assert_eq!((&mut 5i).cmp(&&mut 10), Less);\n-    assert_eq!((&mut 10i).cmp(&&mut 5), Greater);\n-    assert_eq!((&mut 5i).cmp(&&mut 5), Equal);\n-    assert_eq!((&mut -5i).cmp(&&mut 12), Less);\n-    assert_eq!((&mut 12i).cmp(&&mut -5), Greater);\n+    assert_eq!((&mut 5).cmp(&&mut 10), Less);\n+    assert_eq!((&mut 10).cmp(&&mut 5), Greater);\n+    assert_eq!((&mut 5).cmp(&&mut 5), Equal);\n+    assert_eq!((&mut -5).cmp(&&mut 12), Less);\n+    assert_eq!((&mut 12).cmp(&&mut -5), Greater);\n }\n \n #[test]\n@@ -47,11 +47,11 @@ fn test_partial_min() {\n     use core::f64::NAN;\n     let data_integer = [\n         // a, b, result\n-        (0i, 0i, Some(0i)),\n-        (1i, 0i, Some(0i)),\n-        (0i, 1i, Some(0i)),\n-        (-1i, 0i, Some(-1i)),\n-        (0i, -1i, Some(-1i))\n+        (0, 0, Some(0)),\n+        (1, 0, Some(0)),\n+        (0, 1, Some(0)),\n+        (-1, 0, Some(-1)),\n+        (0, -1, Some(-1))\n     ];\n \n     let data_float = [\n@@ -80,11 +80,11 @@ fn test_partial_max() {\n     use core::f64::NAN;\n     let data_integer = [\n         // a, b, result\n-        (0i, 0i, Some(0i)),\n-        (1i, 0i, Some(1i)),\n-        (0i, 1i, Some(1i)),\n-        (-1i, 0i, Some(0i)),\n-        (0i, -1i, Some(0i))\n+        (0, 0, Some(0)),\n+        (1, 0, Some(1)),\n+        (0, 1, Some(1)),\n+        (-1, 0, Some(0)),\n+        (0, -1, Some(0))\n     ];\n \n     let data_float = ["}, {"sha": "22917b09ce9959856b3dcbb8c3451c380290d61f", "filename": "src/libcoretest/finally.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcoretest%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcoretest%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Ffinally.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -15,7 +15,7 @@ use std::thread::Thread;\n \n #[test]\n fn test_success() {\n-    let mut i = 0i;\n+    let mut i = 0;\n     try_finally(\n         &mut i, (),\n         |i, ()| {\n@@ -32,7 +32,7 @@ fn test_success() {\n #[test]\n #[should_fail]\n fn test_fail() {\n-    let mut i = 0i;\n+    let mut i = 0;\n     try_finally(\n         &mut i, (),\n         |i, ()| {\n@@ -47,7 +47,7 @@ fn test_fail() {\n \n #[test]\n fn test_retval() {\n-    let mut closure = |&mut:| 10i;\n+    let mut closure = |&mut:| 10;\n     let i = closure.finally(|| { });\n     assert_eq!(i, 10);\n }"}, {"sha": "ae23024cf20ae5cbd5cf8df921e00dd3a04a1e28", "filename": "src/libcoretest/hash/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcoretest%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcoretest%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fhash%2Fmod.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -56,7 +56,7 @@ fn test_writer_hasher() {\n     assert_eq!(hash(&5i16), 5);\n     assert_eq!(hash(&5i32), 5);\n     assert_eq!(hash(&5i64), 5);\n-    assert_eq!(hash(&5i), 5);\n+    assert_eq!(hash(&5), 5);\n \n     assert_eq!(hash(&false), 0);\n     assert_eq!(hash(&true), 1);\n@@ -76,12 +76,12 @@ fn test_writer_hasher() {\n     // FIXME (#18248) Add tests for hashing Rc<str> and Rc<[T]>\n \n     unsafe {\n-        let ptr: *const int = mem::transmute(5i);\n+        let ptr: *const i32 = mem::transmute(5is);\n         assert_eq!(hash(&ptr), 5);\n     }\n \n     unsafe {\n-        let ptr: *mut int = mem::transmute(5i);\n+        let ptr: *mut i32 = mem::transmute(5is);\n         assert_eq!(hash(&ptr), 5);\n     }\n }"}, {"sha": "3102abb660fb806f91595decd2985434b2e3db11", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 115, "deletions": 115, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -20,8 +20,8 @@ use test::Bencher;\n #[test]\n fn test_lt() {\n     let empty: [int; 0] = [];\n-    let xs = [1i,2,3];\n-    let ys = [1i,2,0];\n+    let xs = [1,2,3];\n+    let ys = [1,2,0];\n \n     assert!(!lt(xs.iter(), ys.iter()));\n     assert!(!le(xs.iter(), ys.iter()));\n@@ -64,15 +64,15 @@ fn test_lt() {\n \n #[test]\n fn test_multi_iter() {\n-    let xs = [1i,2,3,4];\n-    let ys = [4i,3,2,1];\n+    let xs = [1,2,3,4];\n+    let ys = [4,3,2,1];\n     assert!(eq(xs.iter(), ys.iter().rev()));\n     assert!(lt(xs.iter(), xs.iter().skip(2)));\n }\n \n #[test]\n fn test_counter_from_iter() {\n-    let it = count(0i, 5).take(10);\n+    let it = count(0, 5).take(10);\n     let xs: Vec<int> = FromIterator::from_iter(it);\n     assert!(xs == vec![0, 5, 10, 15, 20, 25, 30, 35, 40, 45]);\n }\n@@ -304,7 +304,7 @@ fn test_cycle() {\n \n #[test]\n fn test_iterator_nth() {\n-    let v: &[_] = &[0i, 1, 2, 3, 4];\n+    let v: &[_] = &[0, 1, 2, 3, 4];\n     for i in 0u..v.len() {\n         assert_eq!(v.iter().nth(i).unwrap(), &v[i]);\n     }\n@@ -313,98 +313,98 @@ fn test_iterator_nth() {\n \n #[test]\n fn test_iterator_last() {\n-    let v: &[_] = &[0i, 1, 2, 3, 4];\n+    let v: &[_] = &[0, 1, 2, 3, 4];\n     assert_eq!(v.iter().last().unwrap(), &4);\n     assert_eq!(v[..1].iter().last().unwrap(), &0);\n }\n \n #[test]\n fn test_iterator_len() {\n-    let v: &[_] = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+    let v: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n     assert_eq!(v[..4].iter().count(), 4);\n     assert_eq!(v[..10].iter().count(), 10);\n     assert_eq!(v[..0].iter().count(), 0);\n }\n \n #[test]\n fn test_iterator_sum() {\n-    let v: &[_] = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+    let v: &[i32] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n     assert_eq!(v[..4].iter().map(|&x| x).sum(), 6);\n     assert_eq!(v.iter().map(|&x| x).sum(), 55);\n     assert_eq!(v[..0].iter().map(|&x| x).sum(), 0);\n }\n \n #[test]\n fn test_iterator_product() {\n-    let v: &[_] = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+    let v: &[i32] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n     assert_eq!(v[..4].iter().map(|&x| x).product(), 0);\n     assert_eq!(v[1..5].iter().map(|&x| x).product(), 24);\n     assert_eq!(v[..0].iter().map(|&x| x).product(), 1);\n }\n \n #[test]\n fn test_iterator_max() {\n-    let v: &[_] = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+    let v: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n     assert_eq!(v[..4].iter().map(|&x| x).max(), Some(3));\n     assert_eq!(v.iter().map(|&x| x).max(), Some(10));\n     assert_eq!(v[..0].iter().map(|&x| x).max(), None);\n }\n \n #[test]\n fn test_iterator_min() {\n-    let v: &[_] = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+    let v: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n     assert_eq!(v[..4].iter().map(|&x| x).min(), Some(0));\n     assert_eq!(v.iter().map(|&x| x).min(), Some(0));\n     assert_eq!(v[..0].iter().map(|&x| x).min(), None);\n }\n \n #[test]\n fn test_iterator_size_hint() {\n-    let c = count(0i, 1);\n-    let v: &[_] = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n-    let v2 = &[10i, 11, 12];\n+    let c = count(0, 1);\n+    let v: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n+    let v2 = &[10, 11, 12];\n     let vi = v.iter();\n \n     assert_eq!(c.size_hint(), (uint::MAX, None));\n-    assert_eq!(vi.size_hint(), (10, Some(10)));\n-\n-    assert_eq!(c.take(5).size_hint(), (5, Some(5)));\n-    assert_eq!(c.skip(5).size_hint().1, None);\n-    assert_eq!(c.take_while(|_| false).size_hint(), (0, None));\n-    assert_eq!(c.skip_while(|_| false).size_hint(), (0, None));\n-    assert_eq!(c.enumerate().size_hint(), (uint::MAX, None));\n-    assert_eq!(c.chain(vi.map(|&i| i)).size_hint(), (uint::MAX, None));\n-    assert_eq!(c.zip(vi).size_hint(), (10, Some(10)));\n-    assert_eq!(c.scan(0i, |_,_| Some(0i)).size_hint(), (0, None));\n-    assert_eq!(c.filter(|_| false).size_hint(), (0, None));\n-    assert_eq!(c.map(|_| 0i).size_hint(), (uint::MAX, None));\n-    assert_eq!(c.filter_map(|_| Some(0i)).size_hint(), (0, None));\n-\n-    assert_eq!(vi.take(5).size_hint(), (5, Some(5)));\n-    assert_eq!(vi.take(12).size_hint(), (10, Some(10)));\n-    assert_eq!(vi.skip(3).size_hint(), (7, Some(7)));\n-    assert_eq!(vi.skip(12).size_hint(), (0, Some(0)));\n-    assert_eq!(vi.take_while(|_| false).size_hint(), (0, Some(10)));\n-    assert_eq!(vi.skip_while(|_| false).size_hint(), (0, Some(10)));\n-    assert_eq!(vi.enumerate().size_hint(), (10, Some(10)));\n-    assert_eq!(vi.chain(v2.iter()).size_hint(), (13, Some(13)));\n-    assert_eq!(vi.zip(v2.iter()).size_hint(), (3, Some(3)));\n-    assert_eq!(vi.scan(0i, |_,_| Some(0i)).size_hint(), (0, Some(10)));\n-    assert_eq!(vi.filter(|_| false).size_hint(), (0, Some(10)));\n-    assert_eq!(vi.map(|&i| i+1).size_hint(), (10, Some(10)));\n-    assert_eq!(vi.filter_map(|_| Some(0i)).size_hint(), (0, Some(10)));\n+    assert_eq!(vi.clone().size_hint(), (10, Some(10)));\n+\n+    assert_eq!(c.clone().take(5).size_hint(), (5, Some(5)));\n+    assert_eq!(c.clone().skip(5).size_hint().1, None);\n+    assert_eq!(c.clone().take_while(|_| false).size_hint(), (0, None));\n+    assert_eq!(c.clone().skip_while(|_| false).size_hint(), (0, None));\n+    assert_eq!(c.clone().enumerate().size_hint(), (uint::MAX, None));\n+    assert_eq!(c.clone().chain(vi.clone().map(|&i| i)).size_hint(), (uint::MAX, None));\n+    assert_eq!(c.clone().zip(vi.clone()).size_hint(), (10, Some(10)));\n+    assert_eq!(c.clone().scan(0i, |_,_| Some(0)).size_hint(), (0, None));\n+    assert_eq!(c.clone().filter(|_| false).size_hint(), (0, None));\n+    assert_eq!(c.clone().map(|_| 0).size_hint(), (uint::MAX, None));\n+    assert_eq!(c.filter_map(|_| Some(0)).size_hint(), (0, None));\n+\n+    assert_eq!(vi.clone().take(5).size_hint(), (5, Some(5)));\n+    assert_eq!(vi.clone().take(12).size_hint(), (10, Some(10)));\n+    assert_eq!(vi.clone().skip(3).size_hint(), (7, Some(7)));\n+    assert_eq!(vi.clone().skip(12).size_hint(), (0, Some(0)));\n+    assert_eq!(vi.clone().take_while(|_| false).size_hint(), (0, Some(10)));\n+    assert_eq!(vi.clone().skip_while(|_| false).size_hint(), (0, Some(10)));\n+    assert_eq!(vi.clone().enumerate().size_hint(), (10, Some(10)));\n+    assert_eq!(vi.clone().chain(v2.iter()).size_hint(), (13, Some(13)));\n+    assert_eq!(vi.clone().zip(v2.iter()).size_hint(), (3, Some(3)));\n+    assert_eq!(vi.clone().scan(0i, |_,_| Some(0)).size_hint(), (0, Some(10)));\n+    assert_eq!(vi.clone().filter(|_| false).size_hint(), (0, Some(10)));\n+    assert_eq!(vi.clone().map(|&i| i+1).size_hint(), (10, Some(10)));\n+    assert_eq!(vi.filter_map(|_| Some(0)).size_hint(), (0, Some(10)));\n }\n \n #[test]\n fn test_collect() {\n-    let a = vec![1i, 2, 3, 4, 5];\n+    let a = vec![1, 2, 3, 4, 5];\n     let b: Vec<int> = a.iter().map(|&x| x).collect();\n     assert!(a == b);\n }\n \n #[test]\n fn test_all() {\n-    let v: Box<[int]> = box [1i, 2, 3, 4, 5];\n+    let v: Box<[int]> = box [1, 2, 3, 4, 5];\n     assert!(v.iter().all(|&x| x < 10));\n     assert!(!v.iter().all(|&x| x % 2 == 0));\n     assert!(!v.iter().all(|&x| x > 100));\n@@ -413,7 +413,7 @@ fn test_all() {\n \n #[test]\n fn test_any() {\n-    let v: Box<[int]> = box [1i, 2, 3, 4, 5];\n+    let v: Box<[int]> = box [1, 2, 3, 4, 5];\n     assert!(v.iter().any(|&x| x < 10));\n     assert!(v.iter().any(|&x| x % 2 == 0));\n     assert!(!v.iter().any(|&x| x > 100));\n@@ -422,43 +422,43 @@ fn test_any() {\n \n #[test]\n fn test_find() {\n-    let v: &[int] = &[1i, 3, 9, 27, 103, 14, 11];\n+    let v: &[int] = &[1, 3, 9, 27, 103, 14, 11];\n     assert_eq!(*v.iter().find(|&&x| x & 1 == 0).unwrap(), 14);\n     assert_eq!(*v.iter().find(|&&x| x % 3 == 0).unwrap(), 3);\n     assert!(v.iter().find(|&&x| x % 12 == 0).is_none());\n }\n \n #[test]\n fn test_position() {\n-    let v = &[1i, 3, 9, 27, 103, 14, 11];\n+    let v = &[1, 3, 9, 27, 103, 14, 11];\n     assert_eq!(v.iter().position(|x| *x & 1 == 0).unwrap(), 5);\n     assert_eq!(v.iter().position(|x| *x % 3 == 0).unwrap(), 1);\n     assert!(v.iter().position(|x| *x % 12 == 0).is_none());\n }\n \n #[test]\n fn test_count() {\n-    let xs = &[1i, 2, 2, 1, 5, 9, 0, 2];\n+    let xs = &[1, 2, 2, 1, 5, 9, 0, 2];\n     assert_eq!(xs.iter().filter(|x| **x == 2).count(), 3);\n     assert_eq!(xs.iter().filter(|x| **x == 5).count(), 1);\n     assert_eq!(xs.iter().filter(|x| **x == 95).count(), 0);\n }\n \n #[test]\n fn test_max_by() {\n-    let xs: &[int] = &[-3i, 0, 1, 5, -10];\n+    let xs: &[int] = &[-3, 0, 1, 5, -10];\n     assert_eq!(*xs.iter().max_by(|x| x.abs()).unwrap(), -10);\n }\n \n #[test]\n fn test_min_by() {\n-    let xs: &[int] = &[-3i, 0, 1, 5, -10];\n+    let xs: &[int] = &[-3, 0, 1, 5, -10];\n     assert_eq!(*xs.iter().min_by(|x| x.abs()).unwrap(), 0);\n }\n \n #[test]\n fn test_by_ref() {\n-    let mut xs = 0i..10;\n+    let mut xs = 0..10;\n     // sum the first five values\n     let partial_sum = xs.by_ref().take(5).fold(0, |a, b| a + b);\n     assert_eq!(partial_sum, 10);\n@@ -467,7 +467,7 @@ fn test_by_ref() {\n \n #[test]\n fn test_rev() {\n-    let xs = [2i, 4, 6, 8, 10, 12, 14, 16];\n+    let xs = [2, 4, 6, 8, 10, 12, 14, 16];\n     let mut it = xs.iter();\n     it.next();\n     it.next();\n@@ -494,7 +494,7 @@ fn test_cloned() {\n \n #[test]\n fn test_double_ended_map() {\n-    let xs = [1i, 2, 3, 4, 5, 6];\n+    let xs = [1, 2, 3, 4, 5, 6];\n     let mut it = xs.iter().map(|&x| x * -1);\n     assert_eq!(it.next(), Some(-1));\n     assert_eq!(it.next(), Some(-2));\n@@ -507,7 +507,7 @@ fn test_double_ended_map() {\n \n #[test]\n fn test_double_ended_enumerate() {\n-    let xs = [1i, 2, 3, 4, 5, 6];\n+    let xs = [1, 2, 3, 4, 5, 6];\n     let mut it = xs.iter().map(|&x| x).enumerate();\n     assert_eq!(it.next(), Some((0, 1)));\n     assert_eq!(it.next(), Some((1, 2)));\n@@ -520,8 +520,8 @@ fn test_double_ended_enumerate() {\n \n #[test]\n fn test_double_ended_zip() {\n-    let xs = [1i, 2, 3, 4, 5, 6];\n-    let ys = [1i, 2, 3, 7];\n+    let xs = [1, 2, 3, 4, 5, 6];\n+    let ys = [1, 2, 3, 7];\n     let a = xs.iter().map(|&x| x);\n     let b = ys.iter().map(|&x| x);\n     let mut it = a.zip(b);\n@@ -534,7 +534,7 @@ fn test_double_ended_zip() {\n \n #[test]\n fn test_double_ended_filter() {\n-    let xs = [1i, 2, 3, 4, 5, 6];\n+    let xs = [1, 2, 3, 4, 5, 6];\n     let mut it = xs.iter().filter(|&x| *x & 1 == 0);\n     assert_eq!(it.next_back().unwrap(), &6);\n     assert_eq!(it.next_back().unwrap(), &4);\n@@ -544,7 +544,7 @@ fn test_double_ended_filter() {\n \n #[test]\n fn test_double_ended_filter_map() {\n-    let xs = [1i, 2, 3, 4, 5, 6];\n+    let xs = [1, 2, 3, 4, 5, 6];\n     let mut it = xs.iter().filter_map(|&x| if x & 1 == 0 { Some(x * 2) } else { None });\n     assert_eq!(it.next_back().unwrap(), 12);\n     assert_eq!(it.next_back().unwrap(), 8);\n@@ -554,8 +554,8 @@ fn test_double_ended_filter_map() {\n \n #[test]\n fn test_double_ended_chain() {\n-    let xs = [1i, 2, 3, 4, 5];\n-    let ys = [7i, 9, 11];\n+    let xs = [1, 2, 3, 4, 5];\n+    let ys = [7, 9, 11];\n     let mut it = xs.iter().chain(ys.iter()).rev();\n     assert_eq!(it.next().unwrap(), &11);\n     assert_eq!(it.next().unwrap(), &9);\n@@ -572,7 +572,7 @@ fn test_double_ended_chain() {\n fn test_rposition() {\n     fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n     fn g(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'd' }\n-    let v = [(0i, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n+    let v = [(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n \n     assert_eq!(v.iter().rposition(f), Some(3u));\n     assert!(v.iter().rposition(g).is_none());\n@@ -581,9 +581,9 @@ fn test_rposition() {\n #[test]\n #[should_fail]\n fn test_rposition_panic() {\n-    let v = [(box 0i, box 0i), (box 0i, box 0i),\n-             (box 0i, box 0i), (box 0i, box 0i)];\n-    let mut i = 0i;\n+    let v = [(box 0, box 0), (box 0, box 0),\n+             (box 0, box 0), (box 0, box 0)];\n+    let mut i = 0;\n     v.iter().rposition(|_elt| {\n         if i == 2 {\n             panic!()\n@@ -635,8 +635,8 @@ fn test_double_ended_flat_map() {\n \n #[test]\n fn test_random_access_chain() {\n-    let xs = [1i, 2, 3, 4, 5];\n-    let ys = [7i, 9, 11];\n+    let xs = [1, 2, 3, 4, 5];\n+    let ys = [7, 9, 11];\n     let mut it = xs.iter().chain(ys.iter());\n     assert_eq!(it.idx(0).unwrap(), &1);\n     assert_eq!(it.idx(5).unwrap(), &7);\n@@ -656,13 +656,13 @@ fn test_random_access_chain() {\n \n #[test]\n fn test_random_access_enumerate() {\n-    let xs = [1i, 2, 3, 4, 5];\n+    let xs = [1, 2, 3, 4, 5];\n     check_randacc_iter(xs.iter().enumerate(), xs.len());\n }\n \n #[test]\n fn test_random_access_rev() {\n-    let xs = [1i, 2, 3, 4, 5];\n+    let xs = [1, 2, 3, 4, 5];\n     check_randacc_iter(xs.iter().rev(), xs.len());\n     let mut it = xs.iter().rev();\n     it.next();\n@@ -673,14 +673,14 @@ fn test_random_access_rev() {\n \n #[test]\n fn test_random_access_zip() {\n-    let xs = [1i, 2, 3, 4, 5];\n-    let ys = [7i, 9, 11];\n+    let xs = [1, 2, 3, 4, 5];\n+    let ys = [7, 9, 11];\n     check_randacc_iter(xs.iter().zip(ys.iter()), cmp::min(xs.len(), ys.len()));\n }\n \n #[test]\n fn test_random_access_take() {\n-    let xs = [1i, 2, 3, 4, 5];\n+    let xs = [1, 2, 3, 4, 5];\n     let empty: &[int] = &[];\n     check_randacc_iter(xs.iter().take(3), 3);\n     check_randacc_iter(xs.iter().take(20), xs.len());\n@@ -690,15 +690,15 @@ fn test_random_access_take() {\n \n #[test]\n fn test_random_access_skip() {\n-    let xs = [1i, 2, 3, 4, 5];\n+    let xs = [1, 2, 3, 4, 5];\n     let empty: &[int] = &[];\n     check_randacc_iter(xs.iter().skip(2), xs.len() - 2);\n     check_randacc_iter(empty.iter().skip(2), 0);\n }\n \n #[test]\n fn test_random_access_inspect() {\n-    let xs = [1i, 2, 3, 4, 5];\n+    let xs = [1, 2, 3, 4, 5];\n \n     // test .map and .inspect that don't implement Clone\n     let mut it = xs.iter().inspect(|_| {});\n@@ -711,7 +711,7 @@ fn test_random_access_inspect() {\n \n #[test]\n fn test_random_access_map() {\n-    let xs = [1i, 2, 3, 4, 5];\n+    let xs = [1, 2, 3, 4, 5];\n \n     let mut it = xs.iter().map(|x| *x);\n     assert_eq!(xs.len(), it.indexable());\n@@ -722,94 +722,94 @@ fn test_random_access_map() {\n \n #[test]\n fn test_random_access_cycle() {\n-    let xs = [1i, 2, 3, 4, 5];\n+    let xs = [1, 2, 3, 4, 5];\n     let empty: &[int] = &[];\n     check_randacc_iter(xs.iter().cycle().take(27), 27);\n     check_randacc_iter(empty.iter().cycle(), 0);\n }\n \n #[test]\n fn test_double_ended_range() {\n-    assert!((11i..14).rev().collect::<Vec<int>>() == vec![13i, 12, 11]);\n-    for _ in (10i..0).rev() {\n+    assert!((11..14).rev().collect::<Vec<_>>() == vec![13, 12, 11]);\n+    for _ in (10..0).rev() {\n         panic!(\"unreachable\");\n     }\n \n-    assert!((11u..14).rev().collect::<Vec<uint>>() == vec![13u, 12, 11]);\n-    for _ in (10u..0).rev() {\n+    assert!((11..14).rev().collect::<Vec<_>>() == vec![13, 12, 11]);\n+    for _ in (10..0).rev() {\n         panic!(\"unreachable\");\n     }\n }\n \n #[test]\n fn test_range() {\n-    assert!((0i..5).collect::<Vec<int>>() == vec![0i, 1, 2, 3, 4]);\n-    assert!((-10i..-1).collect::<Vec<int>>() ==\n+    assert!((0..5).collect::<Vec<_>>() == vec![0, 1, 2, 3, 4]);\n+    assert!((-10..-1).collect::<Vec<_>>() ==\n                vec![-10, -9, -8, -7, -6, -5, -4, -3, -2]);\n-    assert!((0i..5).rev().collect::<Vec<int>>() == vec![4, 3, 2, 1, 0]);\n-    assert_eq!((200i..-5).count(), 0);\n-    assert_eq!((200i..-5).rev().count(), 0);\n-    assert_eq!((200i..200).count(), 0);\n-    assert_eq!((200i..200).rev().count(), 0);\n+    assert!((0..5).rev().collect::<Vec<_>>() == vec![4, 3, 2, 1, 0]);\n+    assert_eq!((200..-5).count(), 0);\n+    assert_eq!((200..-5).rev().count(), 0);\n+    assert_eq!((200..200).count(), 0);\n+    assert_eq!((200..200).rev().count(), 0);\n \n-    assert_eq!((0i..100).size_hint(), (100, Some(100)));\n+    assert_eq!((0..100).size_hint(), (100, Some(100)));\n     // this test is only meaningful when sizeof uint < sizeof u64\n     assert_eq!((uint::MAX - 1..uint::MAX).size_hint(), (1, Some(1)));\n-    assert_eq!((-10i..-1).size_hint(), (9, Some(9)));\n+    assert_eq!((-10..-1).size_hint(), (9, Some(9)));\n }\n \n #[test]\n fn test_range_inclusive() {\n-    assert!(range_inclusive(0i, 5).collect::<Vec<int>>() ==\n-            vec![0i, 1, 2, 3, 4, 5]);\n-    assert!(range_inclusive(0i, 5).rev().collect::<Vec<int>>() ==\n-            vec![5i, 4, 3, 2, 1, 0]);\n-    assert_eq!(range_inclusive(200i, -5).count(), 0);\n-    assert_eq!(range_inclusive(200i, -5).rev().count(), 0);\n-    assert!(range_inclusive(200i, 200).collect::<Vec<int>>() == vec![200]);\n-    assert!(range_inclusive(200i, 200).rev().collect::<Vec<int>>() == vec![200]);\n+    assert!(range_inclusive(0, 5).collect::<Vec<int>>() ==\n+            vec![0, 1, 2, 3, 4, 5]);\n+    assert!(range_inclusive(0, 5).rev().collect::<Vec<int>>() ==\n+            vec![5, 4, 3, 2, 1, 0]);\n+    assert_eq!(range_inclusive(200, -5).count(), 0);\n+    assert_eq!(range_inclusive(200, -5).rev().count(), 0);\n+    assert!(range_inclusive(200, 200).collect::<Vec<int>>() == vec![200]);\n+    assert!(range_inclusive(200, 200).rev().collect::<Vec<int>>() == vec![200]);\n }\n \n #[test]\n fn test_range_step() {\n-    assert!(range_step(0i, 20, 5).collect::<Vec<int>>() ==\n+    assert!(range_step(0, 20, 5).collect::<Vec<int>>() ==\n             vec![0, 5, 10, 15]);\n-    assert!(range_step(20i, 0, -5).collect::<Vec<int>>() ==\n+    assert!(range_step(20, 0, -5).collect::<Vec<int>>() ==\n             vec![20, 15, 10, 5]);\n-    assert!(range_step(20i, 0, -6).collect::<Vec<int>>() ==\n+    assert!(range_step(20, 0, -6).collect::<Vec<int>>() ==\n             vec![20, 14, 8, 2]);\n     assert!(range_step(200u8, 255, 50).collect::<Vec<u8>>() ==\n             vec![200u8, 250]);\n-    assert!(range_step(200i, -5, 1).collect::<Vec<int>>() == vec![]);\n-    assert!(range_step(200i, 200, 1).collect::<Vec<int>>() == vec![]);\n+    assert!(range_step(200, -5, 1).collect::<Vec<int>>() == vec![]);\n+    assert!(range_step(200, 200, 1).collect::<Vec<int>>() == vec![]);\n }\n \n #[test]\n fn test_range_step_inclusive() {\n-    assert!(range_step_inclusive(0i, 20, 5).collect::<Vec<int>>() ==\n+    assert!(range_step_inclusive(0, 20, 5).collect::<Vec<int>>() ==\n             vec![0, 5, 10, 15, 20]);\n-    assert!(range_step_inclusive(20i, 0, -5).collect::<Vec<int>>() ==\n+    assert!(range_step_inclusive(20, 0, -5).collect::<Vec<int>>() ==\n             vec![20, 15, 10, 5, 0]);\n-    assert!(range_step_inclusive(20i, 0, -6).collect::<Vec<int>>() ==\n+    assert!(range_step_inclusive(20, 0, -6).collect::<Vec<int>>() ==\n             vec![20, 14, 8, 2]);\n     assert!(range_step_inclusive(200u8, 255, 50).collect::<Vec<u8>>() ==\n             vec![200u8, 250]);\n-    assert!(range_step_inclusive(200i, -5, 1).collect::<Vec<int>>() ==\n+    assert!(range_step_inclusive(200, -5, 1).collect::<Vec<int>>() ==\n             vec![]);\n-    assert!(range_step_inclusive(200i, 200, 1).collect::<Vec<int>>() ==\n+    assert!(range_step_inclusive(200, 200, 1).collect::<Vec<int>>() ==\n             vec![200]);\n }\n \n #[test]\n fn test_reverse() {\n-    let mut ys = [1i, 2, 3, 4, 5];\n+    let mut ys = [1, 2, 3, 4, 5];\n     ys.iter_mut().reverse_in_place();\n     assert!(ys == [5, 4, 3, 2, 1]);\n }\n \n #[test]\n fn test_peekable_is_empty() {\n-    let a = [1i];\n+    let a = [1];\n     let mut it = a.iter().peekable();\n     assert!( !it.is_empty() );\n     it.next();\n@@ -821,16 +821,16 @@ fn test_min_max() {\n     let v: [int; 0] = [];\n     assert_eq!(v.iter().min_max(), NoElements);\n \n-    let v = [1i];\n+    let v = [1];\n     assert!(v.iter().min_max() == OneElement(&1));\n \n-    let v = [1i, 2, 3, 4, 5];\n+    let v = [1, 2, 3, 4, 5];\n     assert!(v.iter().min_max() == MinMax(&1, &5));\n \n-    let v = [1i, 2, 3, 4, 5, 6];\n+    let v = [1, 2, 3, 4, 5, 6];\n     assert!(v.iter().min_max() == MinMax(&1, &6));\n \n-    let v = [1i, 1, 1, 1];\n+    let v = [1, 1, 1, 1];\n     assert!(v.iter().min_max() == MinMax(&1, &1));\n }\n \n@@ -839,10 +839,10 @@ fn test_min_max_result() {\n     let r: MinMaxResult<int> = NoElements;\n     assert_eq!(r.into_option(), None);\n \n-    let r = OneElement(1i);\n+    let r = OneElement(1);\n     assert_eq!(r.into_option(), Some((1,1)));\n \n-    let r = MinMax(1i,2);\n+    let r = MinMax(1,2);\n     assert_eq!(r.into_option(), Some((1,2)));\n }\n \n@@ -904,7 +904,7 @@ fn bench_multiple_take(b: &mut Bencher) {\n     b.iter(|| {\n         let n = it.next().unwrap();\n         for _ in 0u..n {\n-            it.take(it.next().unwrap()).all(|_| true);\n+            it.clone().take(it.next().unwrap()).all(|_| true);\n         }\n     });\n }"}, {"sha": "c26d3e7bb8a7dd6b6ff0f72e094b9018b5594f98", "filename": "src/libcoretest/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcoretest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcoretest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Flib.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(unsafe_destructor, slicing_syntax)]\n-#![feature(unboxed_closures)]\n #![feature(box_syntax)]\n-#![allow(unknown_features)] #![feature(int_uint)]\n+#![feature(int_uint)]\n+#![feature(unboxed_closures)]\n+#![feature(unsafe_destructor, slicing_syntax)]\n \n extern crate core;\n extern crate test;"}, {"sha": "fd9dc696bdffe16fb549cd13a4b440f83e8afb8f", "filename": "src/libcoretest/mem.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcoretest%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcoretest%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fmem.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -70,8 +70,8 @@ fn align_of_val_basic() {\n \n #[test]\n fn test_swap() {\n-    let mut x = 31337i;\n-    let mut y = 42i;\n+    let mut x = 31337;\n+    let mut y = 42;\n     swap(&mut x, &mut y);\n     assert_eq!(x, 42);\n     assert_eq!(y, 31337);\n@@ -87,15 +87,15 @@ fn test_replace() {\n \n #[test]\n fn test_transmute_copy() {\n-    assert_eq!(1u, unsafe { transmute_copy(&1i) });\n+    assert_eq!(1u, unsafe { transmute_copy(&1) });\n }\n \n #[test]\n fn test_transmute() {\n     trait Foo {}\n     impl Foo for int {}\n \n-    let a = box 100i as Box<Foo>;\n+    let a = box 100 as Box<Foo>;\n     unsafe {\n         let x: ::core::raw::TraitObject = transmute(a);\n         assert!(*(x.data as *const int) == 100);\n@@ -146,7 +146,7 @@ fn trait_static_method_call(b: &mut Bencher) {\n \n #[bench]\n fn match_option_some(b: &mut Bencher) {\n-    let x = Some(10i);\n+    let x = Some(10);\n     b.iter(|| {\n         match x {\n             Some(y) => y,\n@@ -157,11 +157,11 @@ fn match_option_some(b: &mut Bencher) {\n \n #[bench]\n fn match_vec_pattern(b: &mut Bencher) {\n-    let x = [1i,2,3,4,5,6];\n+    let x = [1,2,3,4,5,6];\n     b.iter(|| {\n         match x {\n-            [1,2,3,..] => 10i,\n-            _ => 11i,\n+            [1,2,3,..] => 10,\n+            _ => 11,\n         }\n     });\n }"}, {"sha": "be4c83d23e8b33796600da56907aa81a3a7a5a11", "filename": "src/libcoretest/nonzero.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcoretest%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcoretest%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnonzero.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -16,7 +16,7 @@ use std::mem::size_of;\n #[test]\n fn test_create_nonzero_instance() {\n     let _a = unsafe {\n-        NonZero::new(21i)\n+        NonZero::new(21)\n     };\n }\n \n@@ -28,14 +28,14 @@ fn test_size_nonzero_in_option() {\n #[test]\n fn test_match_on_nonzero_option() {\n     let a = Some(unsafe {\n-        NonZero::new(42i)\n+        NonZero::new(42)\n     });\n     match a {\n         Some(val) => assert_eq!(*val, 42),\n         None => panic!(\"unexpected None while matching on Some(NonZero(_))\")\n     }\n \n-    match unsafe { Some(NonZero::new(43i)) } {\n+    match unsafe { Some(NonZero::new(43)) } {\n         Some(val) => assert_eq!(*val, 43),\n         None => panic!(\"unexpected None while matching on Some(NonZero(_))\")\n     }\n@@ -52,9 +52,9 @@ fn test_match_option_empty_vec() {\n \n #[test]\n fn test_match_option_vec() {\n-    let a = Some(vec![1i, 2, 3, 4]);\n+    let a = Some(vec![1, 2, 3, 4]);\n     match a {\n-        Some(v) => assert_eq!(v, vec![1i, 2, 3, 4]),\n+        Some(v) => assert_eq!(v, vec![1, 2, 3, 4]),\n         None => panic!(\"unexpected None while matching on Some(vec![1, 2, 3, 4])\")\n     }\n }\n@@ -63,9 +63,9 @@ fn test_match_option_vec() {\n fn test_match_option_rc() {\n     use std::rc::Rc;\n \n-    let five = Rc::new(5i);\n+    let five = Rc::new(5);\n     match Some(five) {\n-        Some(r) => assert_eq!(*r, 5i),\n+        Some(r) => assert_eq!(*r, 5),\n         None => panic!(\"unexpected None while matching on Some(Rc::new(5))\")\n     }\n }\n@@ -74,9 +74,9 @@ fn test_match_option_rc() {\n fn test_match_option_arc() {\n     use std::sync::Arc;\n \n-    let five = Arc::new(5i);\n+    let five = Arc::new(5);\n     match Some(five) {\n-        Some(a) => assert_eq!(*a, 5i),\n+        Some(a) => assert_eq!(*a, 5),\n         None => panic!(\"unexpected None while matching on Some(Arc::new(5))\")\n     }\n }"}, {"sha": "f5657d939b2afccb1258032a88a37251f1809316", "filename": "src/libcoretest/num/int_macros.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcoretest%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcoretest%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fint_macros.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -151,15 +151,15 @@ mod tests {\n \n     #[test]\n     fn test_signed_checked_div() {\n-        assert!(10i.checked_div(2) == Some(5));\n-        assert!(5i.checked_div(0) == None);\n+        assert!(10.checked_div(2) == Some(5));\n+        assert!(5.checked_div(0) == None);\n         assert!(int::MIN.checked_div(-1) == None);\n     }\n \n     #[test]\n     fn test_from_str() {\n         fn from_str<T: ::std::str::FromStr>(t: &str) -> Option<T> {\n-            ::std::str::FromStr::from_str(t)\n+            ::std::str::FromStr::from_str(t).ok()\n         }\n         assert_eq!(from_str::<$T>(\"0\"), Some(0 as $T));\n         assert_eq!(from_str::<$T>(\"3\"), Some(3 as $T));\n@@ -180,26 +180,26 @@ mod tests {\n \n     #[test]\n     fn test_from_str_radix() {\n-        assert_eq!(FromStrRadix::from_str_radix(\"123\", 10), Some(123 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"1001\", 2), Some(9 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"123\", 8), Some(83 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"123\", 16), Some(291 as i32));\n-        assert_eq!(FromStrRadix::from_str_radix(\"ffff\", 16), Some(65535 as i32));\n-        assert_eq!(FromStrRadix::from_str_radix(\"FFFF\", 16), Some(65535 as i32));\n-        assert_eq!(FromStrRadix::from_str_radix(\"z\", 36), Some(35 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"Z\", 36), Some(35 as $T));\n-\n-        assert_eq!(FromStrRadix::from_str_radix(\"-123\", 10), Some(-123 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"-1001\", 2), Some(-9 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"-123\", 8), Some(-83 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"-123\", 16), Some(-291 as i32));\n-        assert_eq!(FromStrRadix::from_str_radix(\"-ffff\", 16), Some(-65535 as i32));\n-        assert_eq!(FromStrRadix::from_str_radix(\"-FFFF\", 16), Some(-65535 as i32));\n-        assert_eq!(FromStrRadix::from_str_radix(\"-z\", 36), Some(-35 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"-Z\", 36), Some(-35 as $T));\n-\n-        assert_eq!(FromStrRadix::from_str_radix(\"Z\", 35), None::<$T>);\n-        assert_eq!(FromStrRadix::from_str_radix(\"-9\", 2), None::<$T>);\n+        assert_eq!(FromStrRadix::from_str_radix(\"123\", 10), Ok(123 as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"1001\", 2), Ok(9 as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"123\", 8), Ok(83 as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"123\", 16), Ok(291 as i32));\n+        assert_eq!(FromStrRadix::from_str_radix(\"ffff\", 16), Ok(65535 as i32));\n+        assert_eq!(FromStrRadix::from_str_radix(\"FFFF\", 16), Ok(65535 as i32));\n+        assert_eq!(FromStrRadix::from_str_radix(\"z\", 36), Ok(35 as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"Z\", 36), Ok(35 as $T));\n+\n+        assert_eq!(FromStrRadix::from_str_radix(\"-123\", 10), Ok(-123 as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"-1001\", 2), Ok(-9 as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"-123\", 8), Ok(-83 as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"-123\", 16), Ok(-291 as i32));\n+        assert_eq!(FromStrRadix::from_str_radix(\"-ffff\", 16), Ok(-65535 as i32));\n+        assert_eq!(FromStrRadix::from_str_radix(\"-FFFF\", 16), Ok(-65535 as i32));\n+        assert_eq!(FromStrRadix::from_str_radix(\"-z\", 36), Ok(-35 as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"-Z\", 36), Ok(-35 as $T));\n+\n+        assert_eq!(FromStrRadix::from_str_radix(\"Z\", 35).ok(), None::<$T>);\n+        assert_eq!(FromStrRadix::from_str_radix(\"-9\", 2).ok(), None::<$T>);\n     }\n }\n "}, {"sha": "2c6efc0040fae82bb3adb7247ae9506e7ed6b972", "filename": "src/libcoretest/num/mod.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcoretest%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcoretest%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fmod.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -40,11 +40,11 @@ pub fn test_num<T>(ten: T, two: T) where\n      + Rem<Output=T> + Debug\n      + Copy\n {\n-    assert_eq!(ten.add(two),  cast(12i).unwrap());\n-    assert_eq!(ten.sub(two),  cast(8i).unwrap());\n-    assert_eq!(ten.mul(two),  cast(20i).unwrap());\n-    assert_eq!(ten.div(two),  cast(5i).unwrap());\n-    assert_eq!(ten.rem(two),  cast(0i).unwrap());\n+    assert_eq!(ten.add(two),  cast(12).unwrap());\n+    assert_eq!(ten.sub(two),  cast(8).unwrap());\n+    assert_eq!(ten.mul(two),  cast(20).unwrap());\n+    assert_eq!(ten.div(two),  cast(5).unwrap());\n+    assert_eq!(ten.rem(two),  cast(0).unwrap());\n \n     assert_eq!(ten.add(two),  ten + two);\n     assert_eq!(ten.sub(two),  ten - two);\n@@ -62,64 +62,64 @@ mod test {\n \n     #[test]\n     fn from_str_issue7588() {\n-        let u : Option<u8> = from_str_radix(\"1000\", 10);\n+        let u : Option<u8> = from_str_radix(\"1000\", 10).ok();\n         assert_eq!(u, None);\n-        let s : Option<i16> = from_str_radix(\"80000\", 10);\n+        let s : Option<i16> = from_str_radix(\"80000\", 10).ok();\n         assert_eq!(s, None);\n-        let f : Option<f32> = from_str_radix(\"10000000000000000000000000000000000000000\", 10);\n+        let f : Option<f32> = from_str_radix(\"10000000000000000000000000000000000000000\", 10).ok();\n         assert_eq!(f, Some(Float::infinity()));\n-        let fe : Option<f32> = from_str_radix(\"1e40\", 10);\n+        let fe : Option<f32> = from_str_radix(\"1e40\", 10).ok();\n         assert_eq!(fe, Some(Float::infinity()));\n     }\n \n     #[test]\n     fn test_from_str_radix_float() {\n-        let x1 : Option<f64> = from_str_radix(\"-123.456\", 10);\n+        let x1 : Option<f64> = from_str_radix(\"-123.456\", 10).ok();\n         assert_eq!(x1, Some(-123.456));\n-        let x2 : Option<f32> = from_str_radix(\"123.456\", 10);\n+        let x2 : Option<f32> = from_str_radix(\"123.456\", 10).ok();\n         assert_eq!(x2, Some(123.456));\n-        let x3 : Option<f32> = from_str_radix(\"-0.0\", 10);\n+        let x3 : Option<f32> = from_str_radix(\"-0.0\", 10).ok();\n         assert_eq!(x3, Some(-0.0));\n-        let x4 : Option<f32> = from_str_radix(\"0.0\", 10);\n+        let x4 : Option<f32> = from_str_radix(\"0.0\", 10).ok();\n         assert_eq!(x4, Some(0.0));\n-        let x4 : Option<f32> = from_str_radix(\"1.0\", 10);\n+        let x4 : Option<f32> = from_str_radix(\"1.0\", 10).ok();\n         assert_eq!(x4, Some(1.0));\n-        let x5 : Option<f32> = from_str_radix(\"-1.0\", 10);\n+        let x5 : Option<f32> = from_str_radix(\"-1.0\", 10).ok();\n         assert_eq!(x5, Some(-1.0));\n     }\n \n     #[test]\n     fn test_int_from_str_overflow() {\n         let mut i8_val: i8 = 127_i8;\n-        assert_eq!(\"127\".parse::<i8>(), Some(i8_val));\n-        assert_eq!(\"128\".parse::<i8>(), None);\n+        assert_eq!(\"127\".parse::<i8>().ok(), Some(i8_val));\n+        assert_eq!(\"128\".parse::<i8>().ok(), None);\n \n         i8_val += 1 as i8;\n-        assert_eq!(\"-128\".parse::<i8>(), Some(i8_val));\n-        assert_eq!(\"-129\".parse::<i8>(), None);\n+        assert_eq!(\"-128\".parse::<i8>().ok(), Some(i8_val));\n+        assert_eq!(\"-129\".parse::<i8>().ok(), None);\n \n         let mut i16_val: i16 = 32_767_i16;\n-        assert_eq!(\"32767\".parse::<i16>(), Some(i16_val));\n-        assert_eq!(\"32768\".parse::<i16>(), None);\n+        assert_eq!(\"32767\".parse::<i16>().ok(), Some(i16_val));\n+        assert_eq!(\"32768\".parse::<i16>().ok(), None);\n \n         i16_val += 1 as i16;\n-        assert_eq!(\"-32768\".parse::<i16>(), Some(i16_val));\n-        assert_eq!(\"-32769\".parse::<i16>(), None);\n+        assert_eq!(\"-32768\".parse::<i16>().ok(), Some(i16_val));\n+        assert_eq!(\"-32769\".parse::<i16>().ok(), None);\n \n         let mut i32_val: i32 = 2_147_483_647_i32;\n-        assert_eq!(\"2147483647\".parse::<i32>(), Some(i32_val));\n-        assert_eq!(\"2147483648\".parse::<i32>(), None);\n+        assert_eq!(\"2147483647\".parse::<i32>().ok(), Some(i32_val));\n+        assert_eq!(\"2147483648\".parse::<i32>().ok(), None);\n \n         i32_val += 1 as i32;\n-        assert_eq!(\"-2147483648\".parse::<i32>(), Some(i32_val));\n-        assert_eq!(\"-2147483649\".parse::<i32>(), None);\n+        assert_eq!(\"-2147483648\".parse::<i32>().ok(), Some(i32_val));\n+        assert_eq!(\"-2147483649\".parse::<i32>().ok(), None);\n \n         let mut i64_val: i64 = 9_223_372_036_854_775_807_i64;\n-        assert_eq!(\"9223372036854775807\".parse::<i64>(), Some(i64_val));\n-        assert_eq!(\"9223372036854775808\".parse::<i64>(), None);\n+        assert_eq!(\"9223372036854775807\".parse::<i64>().ok(), Some(i64_val));\n+        assert_eq!(\"9223372036854775808\".parse::<i64>().ok(), None);\n \n         i64_val += 1 as i64;\n-        assert_eq!(\"-9223372036854775808\".parse::<i64>(), Some(i64_val));\n-        assert_eq!(\"-9223372036854775809\".parse::<i64>(), None);\n+        assert_eq!(\"-9223372036854775808\".parse::<i64>().ok(), Some(i64_val));\n+        assert_eq!(\"-9223372036854775809\".parse::<i64>().ok(), None);\n     }\n }"}, {"sha": "b32ae68b5d3923b54db83694be90f2363015f9ca", "filename": "src/libcoretest/option.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcoretest%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcoretest%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Foption.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -16,7 +16,7 @@ use core::clone::Clone;\n #[test]\n fn test_get_ptr() {\n     unsafe {\n-        let x = box 0i;\n+        let x = box 0;\n         let addr_x: *const int = mem::transmute(&*x);\n         let opt = Some(x);\n         let y = opt.unwrap();\n@@ -59,7 +59,7 @@ fn test_get_resource() {\n         }\n     }\n \n-    let i = Rc::new(RefCell::new(0i));\n+    let i = Rc::new(RefCell::new(0));\n     {\n         let x = r(i.clone());\n         let opt = Some(x);\n@@ -71,7 +71,7 @@ fn test_get_resource() {\n #[test]\n fn test_option_dance() {\n     let x = Some(());\n-    let mut y = Some(5i);\n+    let mut y = Some(5);\n     let mut y2 = 0;\n     for _x in x.iter() {\n         y2 = y.take().unwrap();\n@@ -89,12 +89,12 @@ fn test_option_too_much_dance() {\n \n #[test]\n fn test_and() {\n-    let x: Option<int> = Some(1i);\n-    assert_eq!(x.and(Some(2i)), Some(2));\n+    let x: Option<int> = Some(1);\n+    assert_eq!(x.and(Some(2)), Some(2));\n     assert_eq!(x.and(None::<int>), None);\n \n     let x: Option<int> = None;\n-    assert_eq!(x.and(Some(2i)), None);\n+    assert_eq!(x.and(Some(2)), None);\n     assert_eq!(x.and(None::<int>), None);\n }\n \n@@ -133,7 +133,7 @@ fn test_or_else() {\n \n #[test]\n fn test_unwrap() {\n-    assert_eq!(Some(1i).unwrap(), 1);\n+    assert_eq!(Some(1).unwrap(), 1);\n     let s = Some(\"hello\".to_string()).unwrap();\n     assert_eq!(s, \"hello\");\n }\n@@ -172,7 +172,7 @@ fn test_unwrap_or_else() {\n \n #[test]\n fn test_iter() {\n-    let val = 5i;\n+    let val = 5;\n \n     let x = Some(val);\n     let mut it = x.iter();\n@@ -185,8 +185,8 @@ fn test_iter() {\n \n #[test]\n fn test_mut_iter() {\n-    let val = 5i;\n-    let new_val = 11i;\n+    let val = 5;\n+    let new_val = 11;\n \n     let mut x = Some(val);\n     {\n@@ -223,13 +223,13 @@ fn test_ord() {\n /* FIXME(#20575)\n #[test]\n fn test_collect() {\n-    let v: Option<Vec<int>> = (0i..0).map(|_| Some(0i)).collect();\n+    let v: Option<Vec<int>> = (0..0).map(|_| Some(0i)).collect();\n     assert!(v == Some(vec![]));\n \n-    let v: Option<Vec<int>> = (0i..3).map(|x| Some(x)).collect();\n+    let v: Option<Vec<int>> = (0..3).map(|x| Some(x)).collect();\n     assert!(v == Some(vec![0, 1, 2]));\n \n-    let v: Option<Vec<int>> = (0i..3).map(|x| {\n+    let v: Option<Vec<int>> = (0..3).map(|x| {\n         if x > 1 { None } else { Some(x) }\n     }).collect();\n     assert!(v == None);"}, {"sha": "7f0b97c53d465b371f70331f9bee38d5cbbb9f15", "filename": "src/libcoretest/ptr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcoretest%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcoretest%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fptr.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -84,7 +84,7 @@ fn test_as_ref() {\n         assert_eq!(q.as_ref().unwrap(), &2);\n \n         // Lifetime inference\n-        let u = 2i;\n+        let u = 2;\n         {\n             let p: *const int = &u as *const _;\n             assert_eq!(p.as_ref().unwrap(), &2);\n@@ -102,7 +102,7 @@ fn test_as_mut() {\n         assert!(q.as_mut().unwrap() == &mut 2);\n \n         // Lifetime inference\n-        let mut u = 2i;\n+        let mut u = 2;\n         {\n             let p: *mut int = &mut u as *mut _;\n             assert!(p.as_mut().unwrap() == &mut 2);\n@@ -113,7 +113,7 @@ fn test_as_mut() {\n #[test]\n fn test_ptr_addition() {\n     unsafe {\n-        let xs = repeat(5i).take(16).collect::<Vec<_>>();\n+        let xs = repeat(5).take(16).collect::<Vec<_>>();\n         let mut ptr = xs.as_ptr();\n         let end = ptr.offset(16);\n \n@@ -131,7 +131,7 @@ fn test_ptr_addition() {\n             m_ptr = m_ptr.offset(1);\n         }\n \n-        assert!(xs_mut == repeat(10i).take(16).collect::<Vec<_>>());\n+        assert!(xs_mut == repeat(10).take(16).collect::<Vec<_>>());\n     }\n }\n "}, {"sha": "ab7b5101e726a59f652cad6367e09f8b6c151056", "filename": "src/libcoretest/result.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcoretest%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcoretest%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fresult.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -13,11 +13,11 @@ pub fn op2() -> Result<int, &'static str> { Err(\"sadface\") }\n \n #[test]\n pub fn test_and() {\n-    assert_eq!(op1().and(Ok(667i)).unwrap(), 667);\n+    assert_eq!(op1().and(Ok(667)).unwrap(), 667);\n     assert_eq!(op1().and(Err::<i32, &'static str>(\"bad\")).unwrap_err(),\n                \"bad\");\n \n-    assert_eq!(op2().and(Ok(667i)).unwrap_err(), \"sadface\");\n+    assert_eq!(op2().and(Ok(667)).unwrap_err(), \"sadface\");\n     assert_eq!(op2().and(Err::<i32,&'static str>(\"bad\")).unwrap_err(),\n                \"sadface\");\n }\n@@ -68,20 +68,20 @@ pub fn test_impl_map_err() {\n /* FIXME(#20575)\n #[test]\n fn test_collect() {\n-    let v: Result<Vec<int>, ()> = (0i..0).map(|_| Ok::<int, ()>(0)).collect();\n+    let v: Result<Vec<int>, ()> = (0..0).map(|_| Ok::<int, ()>(0)).collect();\n     assert!(v == Ok(vec![]));\n \n-    let v: Result<Vec<int>, ()> = (0i..3).map(|x| Ok::<int, ()>(x)).collect();\n+    let v: Result<Vec<int>, ()> = (0..3).map(|x| Ok::<int, ()>(x)).collect();\n     assert!(v == Ok(vec![0, 1, 2]));\n \n-    let v: Result<Vec<int>, int> = (0i..3).map(|x| {\n+    let v: Result<Vec<int>, int> = (0..3).map(|x| {\n         if x > 1 { Err(x) } else { Ok(x) }\n     }).collect();\n     assert!(v == Err(2));\n \n     // test that it does not take more elements than it needs\n     let mut functions: [Box<Fn() -> Result<(), int>>; 3] =\n-        [box || Ok(()), box || Err(1i), box || panic!()];\n+        [box || Ok(()), box || Err(1), box || panic!()];\n \n     let v: Result<Vec<()>, int> = functions.iter_mut().map(|f| (*f)()).collect();\n     assert!(v == Err(1));\n@@ -101,7 +101,7 @@ pub fn test_fmt_default() {\n \n #[test]\n pub fn test_unwrap_or() {\n-    let ok: Result<int, &'static str> = Ok(100i);\n+    let ok: Result<int, &'static str> = Ok(100);\n     let ok_err: Result<int, &'static str> = Err(\"Err\");\n \n     assert_eq!(ok.unwrap_or(50), 100);\n@@ -112,7 +112,7 @@ pub fn test_unwrap_or() {\n pub fn test_unwrap_or_else() {\n     fn handler(msg: &'static str) -> int {\n         if msg == \"I got this.\" {\n-            50i\n+            50\n         } else {\n             panic!(\"BadBad\")\n         }\n@@ -130,7 +130,7 @@ pub fn test_unwrap_or_else() {\n pub fn test_unwrap_or_else_panic() {\n     fn handler(msg: &'static str) -> int {\n         if msg == \"I got this.\" {\n-            50i\n+            50\n         } else {\n             panic!(\"BadBad\")\n         }"}, {"sha": "6d5cc38ef0a74f98c86d206a97f01fb5589240f2", "filename": "src/libcoretest/slice.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcoretest%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcoretest%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fslice.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -12,25 +12,25 @@ use core::result::Result::{Ok, Err};\n \n #[test]\n fn binary_search_not_found() {\n-    let b = [1i, 2, 4, 6, 8, 9];\n+    let b = [1, 2, 4, 6, 8, 9];\n     assert!(b.binary_search_by(|v| v.cmp(&6)) == Ok(3));\n-    let b = [1i, 2, 4, 6, 8, 9];\n+    let b = [1, 2, 4, 6, 8, 9];\n     assert!(b.binary_search_by(|v| v.cmp(&5)) == Err(3));\n-    let b = [1i, 2, 4, 6, 7, 8, 9];\n+    let b = [1, 2, 4, 6, 7, 8, 9];\n     assert!(b.binary_search_by(|v| v.cmp(&6)) == Ok(3));\n-    let b = [1i, 2, 4, 6, 7, 8, 9];\n+    let b = [1, 2, 4, 6, 7, 8, 9];\n     assert!(b.binary_search_by(|v| v.cmp(&5)) == Err(3));\n-    let b = [1i, 2, 4, 6, 8, 9];\n+    let b = [1, 2, 4, 6, 8, 9];\n     assert!(b.binary_search_by(|v| v.cmp(&8)) == Ok(4));\n-    let b = [1i, 2, 4, 6, 8, 9];\n+    let b = [1, 2, 4, 6, 8, 9];\n     assert!(b.binary_search_by(|v| v.cmp(&7)) == Err(4));\n-    let b = [1i, 2, 4, 6, 7, 8, 9];\n+    let b = [1, 2, 4, 6, 7, 8, 9];\n     assert!(b.binary_search_by(|v| v.cmp(&8)) == Ok(5));\n-    let b = [1i, 2, 4, 5, 6, 8, 9];\n+    let b = [1, 2, 4, 5, 6, 8, 9];\n     assert!(b.binary_search_by(|v| v.cmp(&7)) == Err(5));\n-    let b = [1i, 2, 4, 5, 6, 8, 9];\n+    let b = [1, 2, 4, 5, 6, 8, 9];\n     assert!(b.binary_search_by(|v| v.cmp(&0)) == Err(0));\n-    let b = [1i, 2, 4, 5, 6, 8];\n+    let b = [1, 2, 4, 5, 6, 8];\n     assert!(b.binary_search_by(|v| v.cmp(&9)) == Err(6));\n }\n "}, {"sha": "f2a1b0ac584d3d34875b5ede0d2db196fbb50c3e", "filename": "src/libcoretest/str.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcoretest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcoretest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fstr.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -10,9 +10,9 @@\n \n #[test]\n fn test_bool_from_str() {\n-    assert_eq!(\"true\".parse(), Some(true));\n-    assert_eq!(\"false\".parse(), Some(false));\n-    assert_eq!(\"not even a boolean\".parse::<bool>(), None);\n+    assert_eq!(\"true\".parse().ok(), Some(true));\n+    assert_eq!(\"false\".parse().ok(), Some(false));\n+    assert_eq!(\"not even a boolean\".parse::<bool>().ok(), None);\n }\n \n fn check_contains_all_substrings(s: &str) {"}, {"sha": "57844f5995f802601626e3eab2e7f3f72d86d59c", "filename": "src/libcoretest/tuple.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcoretest%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibcoretest%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Ftuple.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -12,7 +12,7 @@ use std::cmp::Ordering::{Equal, Less, Greater};\n \n #[test]\n fn test_clone() {\n-    let a = (1i, \"2\");\n+    let a = (1, \"2\");\n     let b = a.clone();\n     assert_eq!(a, b);\n }\n@@ -59,10 +59,10 @@ fn test_tuple_cmp() {\n \n #[test]\n fn test_show() {\n-    let s = format!(\"{:?}\", (1i,));\n+    let s = format!(\"{:?}\", (1,));\n     assert_eq!(s, \"(1,)\");\n-    let s = format!(\"{:?}\", (1i, true));\n+    let s = format!(\"{:?}\", (1, true));\n     assert_eq!(s, \"(1, true)\");\n-    let s = format!(\"{:?}\", (1i, \"hi\", true));\n+    let s = format!(\"{:?}\", (1, \"hi\", true));\n     assert_eq!(s, \"(1, \\\"hi\\\", true)\");\n }"}, {"sha": "e7fb2ba56ab358c37651fb03e43a563bc958b41f", "filename": "src/libflate/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibflate%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibflate%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2Flib.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -16,17 +16,17 @@\n \n #![crate_name = \"flate\"]\n #![unstable(feature = \"rustc_private\")]\n-#![feature(staged_api)]\n #![staged_api]\n-#![allow(unknown_features)] #![feature(int_uint)]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n-#![feature(hash)]\n+\n #![feature(core)]\n+#![feature(int_uint)]\n #![feature(libc)]\n+#![feature(staged_api)]\n \n #[cfg(test)] #[macro_use] extern crate log;\n "}, {"sha": "8a473ad43af19bf0bc36b51a7c167446b0ad1640", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -16,7 +16,6 @@\n \n #![crate_name = \"fmt_macros\"]\n #![unstable(feature = \"rustc_private\")]\n-#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n@@ -25,10 +24,10 @@\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n \n+#![cfg_attr(stage0, feature(core))]\n+#![feature(int_uint)]\n #![feature(slicing_syntax)]\n-#![allow(unknown_features)] #![feature(int_uint)]\n-#![feature(collections)]\n-#![feature(core)]\n+#![feature(staged_api)]\n #![feature(unicode)]\n \n pub use self::Piece::*;"}, {"sha": "055672df5d14c04c78451496ee32bbcf1bd87490", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -80,19 +80,20 @@\n #![crate_name = \"getopts\"]\n #![unstable(feature = \"rustc_private\",\n             reason = \"use the crates.io `getopts` library instead\")]\n-#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n-#![feature(slicing_syntax)]\n-#![allow(unknown_features)] #![feature(int_uint)]\n+\n #![deny(missing_docs)]\n #![feature(collections)]\n #![feature(core)]\n+#![feature(int_uint)]\n+#![feature(slicing_syntax)]\n+#![feature(staged_api)]\n #![cfg_attr(test, feature(rustc_private))]\n \n #[cfg(test)] #[macro_use] extern crate log;"}, {"sha": "3606387ad2318202bd964e17c0ec61b26e2ff4fc", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -274,7 +274,7 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n #![feature(slicing_syntax)]\n-#![allow(unknown_features)] #![feature(int_uint)]\n+#![feature(int_uint)]\n #![feature(collections)]\n #![feature(core)]\n #![feature(io)]\n@@ -362,19 +362,19 @@ impl<'a> Id<'a> {\n     ///\n     /// Passing an invalid string (containing spaces, brackets,\n     /// quotes, ...) will return an empty `Err` value.\n-    pub fn new<Name: IntoCow<'a, String, str>>(name: Name) -> Option<Id<'a>> {\n+    pub fn new<Name: IntoCow<'a, String, str>>(name: Name) -> Result<Id<'a>, ()> {\n         let name = name.into_cow();\n         {\n             let mut chars = name.chars();\n             match chars.next() {\n                 Some(c) if is_letter_or_underscore(c) => { ; },\n-                _ => return None\n+                _ => return Err(())\n             }\n             if !chars.all(is_constituent) {\n-                return None\n+                return Err(())\n             }\n         }\n-        return Some(Id{ name: name });\n+        return Ok(Id{ name: name });\n \n         fn is_letter_or_underscore(c: char) -> bool {\n             in_range('a', c, 'z') || in_range('A', c, 'Z') || c == '_'\n@@ -878,17 +878,17 @@ r#\"digraph syntax_tree {\n     fn simple_id_construction() {\n         let id1 = Id::new(\"hello\");\n         match id1 {\n-            Some(_) => {;},\n-            None => panic!(\"'hello' is not a valid value for id anymore\")\n+            Ok(_) => {;},\n+            Err(..) => panic!(\"'hello' is not a valid value for id anymore\")\n         }\n     }\n \n     #[test]\n     fn badly_formatted_id() {\n         let id2 = Id::new(\"Weird { struct : ure } !!!\");\n         match id2 {\n-            Some(_) => panic!(\"graphviz id suddenly allows spaces, brackets and stuff\"),\n-            None => {;}\n+            Ok(_) => panic!(\"graphviz id suddenly allows spaces, brackets and stuff\"),\n+            Err(..) => {;}\n         }\n     }\n }"}, {"sha": "bd8537f53cd32b41948ef44d74301539b7ffbb96", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -15,7 +15,7 @@\n #![cfg_attr(not(feature = \"cargo-build\"), feature(staged_api))]\n #![cfg_attr(not(feature = \"cargo-build\"), staged_api)]\n #![cfg_attr(not(feature = \"cargo-build\"), feature(core))]\n-#![allow(unknown_features)] #![feature(int_uint)]\n+#![feature(int_uint)]\n #![no_std]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\","}, {"sha": "46b9b2ed86539483d95ca88017678dfcd077f6e8", "filename": "src/liblog/directive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Fliblog%2Fdirective.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Fliblog%2Fdirective.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Fdirective.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -22,7 +22,7 @@ pub static LOG_LEVEL_NAMES: [&'static str; 4] = [\"ERROR\", \"WARN\", \"INFO\",\n \n /// Parse an individual log level that is either a number or a symbolic log level\n fn parse_log_level(level: &str) -> Option<u32> {\n-    level.parse::<u32>().or_else(|| {\n+    level.parse::<u32>().ok().or_else(|| {\n         let pos = LOG_LEVEL_NAMES.iter().position(|&name| name.eq_ignore_ascii_case(level));\n         pos.map(|p| p as u32 + 1)\n     }).map(|p| cmp::min(p, ::MAX_LOG_LEVEL))"}, {"sha": "81d8c60f8939b92a1cdd0f232a324c2713c1d030", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -20,7 +20,7 @@\n //!     error!(\"this is printed by default\");\n //!\n //!     if log_enabled!(log::INFO) {\n-//!         let x = 3i * 4i; // expensive computation\n+//!         let x = 3 * 4; // expensive computation\n //!         info!(\"the answer was: {:?}\", x);\n //!     }\n //! }\n@@ -158,25 +158,22 @@\n #![crate_name = \"log\"]\n #![unstable(feature = \"rustc_private\",\n             reason = \"use the crates.io `log` library instead\")]\n-#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n+#![deny(missing_docs)]\n \n-#![allow(unknown_features)]\n+#![feature(staged_api)]\n #![feature(slicing_syntax)]\n #![feature(box_syntax)]\n-#![allow(unknown_features)] #![feature(int_uint)]\n-#![deny(missing_docs)]\n-#![feature(collections)]\n+#![feature(int_uint)]\n #![feature(core)]\n #![feature(io)]\n #![feature(os)]\n-#![feature(rustc_private)]\n #![feature(std_misc)]\n \n use std::cell::RefCell;"}, {"sha": "5c7085b7b6c5f8909a451fcaf892ba473d66b6a7", "filename": "src/liblog/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Fliblog%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Fliblog%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Fmacros.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -119,7 +119,7 @@ macro_rules! warn {\n /// #[macro_use] extern crate log;\n ///\n /// fn main() {\n-///     let ret = 3i;\n+///     let ret = 3;\n ///     info!(\"this function is about to return: {}\", ret);\n /// }\n /// ```\n@@ -145,7 +145,7 @@ macro_rules! info {\n /// #[macro_use] extern crate log;\n ///\n /// fn main() {\n-///     debug!(\"x = {x}, y = {y}\", x=10i, y=20i);\n+///     debug!(\"x = {x}, y = {y}\", x=10, y=20);\n /// }\n /// ```\n ///"}, {"sha": "1b5e5ae8398e0ecf558e36321f039f74137cf0b2", "filename": "src/librand/distributions/mod.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fmod.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -311,36 +311,36 @@ mod tests {\n             }}\n         }\n \n-        t!(vec!(Weighted { weight: 1, item: 10i}), [10]);\n+        t!(vec!(Weighted { weight: 1, item: 10}), [10]);\n \n         // skip some\n-        t!(vec!(Weighted { weight: 0, item: 20i},\n-                Weighted { weight: 2, item: 21i},\n-                Weighted { weight: 0, item: 22i},\n-                Weighted { weight: 1, item: 23i}),\n+        t!(vec!(Weighted { weight: 0, item: 20},\n+                Weighted { weight: 2, item: 21},\n+                Weighted { weight: 0, item: 22},\n+                Weighted { weight: 1, item: 23}),\n            [21,21, 23]);\n \n         // different weights\n-        t!(vec!(Weighted { weight: 4, item: 30i},\n-                Weighted { weight: 3, item: 31i}),\n+        t!(vec!(Weighted { weight: 4, item: 30},\n+                Weighted { weight: 3, item: 31}),\n            [30,30,30,30, 31,31,31]);\n \n         // check that we're binary searching\n         // correctly with some vectors of odd\n         // length.\n-        t!(vec!(Weighted { weight: 1, item: 40i},\n-                Weighted { weight: 1, item: 41i},\n-                Weighted { weight: 1, item: 42i},\n-                Weighted { weight: 1, item: 43i},\n-                Weighted { weight: 1, item: 44i}),\n+        t!(vec!(Weighted { weight: 1, item: 40},\n+                Weighted { weight: 1, item: 41},\n+                Weighted { weight: 1, item: 42},\n+                Weighted { weight: 1, item: 43},\n+                Weighted { weight: 1, item: 44}),\n            [40, 41, 42, 43, 44]);\n-        t!(vec!(Weighted { weight: 1, item: 50i},\n-                Weighted { weight: 1, item: 51i},\n-                Weighted { weight: 1, item: 52i},\n-                Weighted { weight: 1, item: 53i},\n-                Weighted { weight: 1, item: 54i},\n-                Weighted { weight: 1, item: 55i},\n-                Weighted { weight: 1, item: 56i}),\n+        t!(vec!(Weighted { weight: 1, item: 50},\n+                Weighted { weight: 1, item: 51},\n+                Weighted { weight: 1, item: 52},\n+                Weighted { weight: 1, item: 53},\n+                Weighted { weight: 1, item: 54},\n+                Weighted { weight: 1, item: 55},\n+                Weighted { weight: 1, item: 56}),\n            [50, 51, 52, 53, 54, 55, 56]);\n     }\n \n@@ -350,15 +350,15 @@ mod tests {\n     }\n     #[test] #[should_fail]\n     fn test_weighted_choice_zero_weight() {\n-        WeightedChoice::new(&mut [Weighted { weight: 0, item: 0i},\n-                                  Weighted { weight: 0, item: 1i}]);\n+        WeightedChoice::new(&mut [Weighted { weight: 0, item: 0},\n+                                  Weighted { weight: 0, item: 1}]);\n     }\n     #[test] #[should_fail]\n     fn test_weighted_choice_weight_overflows() {\n         let x = (-1) as uint / 2; // x + x + 2 is the overflow\n-        WeightedChoice::new(&mut [Weighted { weight: x, item: 0i },\n-                                  Weighted { weight: 1, item: 1i },\n-                                  Weighted { weight: x, item: 2i },\n-                                  Weighted { weight: 1, item: 3i }]);\n+        WeightedChoice::new(&mut [Weighted { weight: x, item: 0 },\n+                                  Weighted { weight: 1, item: 1 },\n+                                  Weighted { weight: x, item: 2 },\n+                                  Weighted { weight: 1, item: 3 }]);\n     }\n }"}, {"sha": "16830c84c466cae173ceccccf43cd76d335f9995", "filename": "src/librand/distributions/range.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrand%2Fdistributions%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrand%2Fdistributions%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Frange.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -171,12 +171,12 @@ mod tests {\n     #[should_fail]\n     #[test]\n     fn test_range_bad_limits_equal() {\n-        Range::new(10i, 10i);\n+        Range::new(10, 10);\n     }\n     #[should_fail]\n     #[test]\n     fn test_range_bad_limits_flipped() {\n-        Range::new(10i, 5i);\n+        Range::new(10, 5);\n     }\n \n     #[test]"}, {"sha": "3ff400388721afdb0d60ac813371a94d4e4fd4e2", "filename": "src/librand/lib.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -22,7 +22,7 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n-#![allow(unknown_features)] #![feature(int_uint)]\n+#![feature(int_uint)]\n #![no_std]\n #![unstable(feature = \"rand\")]\n #![feature(staged_api)]\n@@ -152,7 +152,7 @@ pub trait Rng : Sized {\n         // (3) adds more `unsafe` that needs to be checked, (4)\n         // probably doesn't give much performance gain if\n         // optimisations are on.\n-        let mut count = 0i;\n+        let mut count = 0;\n         let mut num = 0;\n         for byte in dest.iter_mut() {\n             if count == 0 {\n@@ -269,7 +269,7 @@ pub trait Rng : Sized {\n     /// ```\n     /// use std::rand::{thread_rng, Rng};\n     ///\n-    /// let choices = [1i, 2, 4, 8, 16, 32];\n+    /// let choices = [1, 2, 4, 8, 16, 32];\n     /// let mut rng = thread_rng();\n     /// println!(\"{:?}\", rng.choose(&choices));\n     /// assert_eq!(rng.choose(&choices[..0]), None);\n@@ -290,7 +290,7 @@ pub trait Rng : Sized {\n     /// use std::rand::{thread_rng, Rng};\n     ///\n     /// let mut rng = thread_rng();\n-    /// let mut y = [1i, 2, 3];\n+    /// let mut y = [1, 2, 3];\n     /// rng.shuffle(&mut y);\n     /// println!(\"{:?}\", y.as_slice());\n     /// rng.shuffle(&mut y);\n@@ -498,6 +498,8 @@ mod std {\n     pub use core::{option, fmt}; // panic!()\n     pub use core::clone; // derive Clone\n     pub use core::marker;\n+    // for-loops\n+    pub use core::iter;\n }\n \n #[cfg(test)]"}, {"sha": "acc21cbf0600f9dcd957bd7619bb6122de4e0441", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -17,21 +17,21 @@\n \n #![crate_name = \"rbml\"]\n #![unstable(feature = \"rustc_private\")]\n-#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n-#![allow(unknown_features)]\n-#![feature(slicing_syntax)]\n-#![allow(unknown_features)] #![feature(int_uint)]\n+\n #![feature(collections)]\n #![feature(core)]\n+#![feature(int_uint)]\n #![feature(io)]\n #![feature(rustc_private)]\n+#![feature(slicing_syntax)]\n+#![feature(staged_api)]\n \n extern crate serialize;\n #[macro_use] extern crate log;"}, {"sha": "6ae861fcb04241447609ddfc174775effd65a8df", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -16,30 +16,31 @@\n \n #![crate_name = \"rustc\"]\n #![unstable(feature = \"rustc_private\")]\n-#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n-#![allow(unknown_features)]\n-#![feature(quote)]\n-#![feature(slicing_syntax, unsafe_destructor)]\n+#![cfg_attr(not(stage0), allow(unused_mut))] // NOTE: remove after stage0 snap\n+\n #![feature(box_syntax)]\n-#![allow(unknown_features)] #![feature(int_uint)]\n-#![feature(rustc_diagnostic_macros)]\n #![feature(collections)]\n #![feature(core)]\n+#![feature(hash)]\n+#![feature(int_uint)]\n #![feature(io)]\n #![feature(libc)]\n #![feature(os)]\n #![feature(path)]\n+#![feature(quote)]\n+#![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n+#![feature(slicing_syntax, unsafe_destructor)]\n+#![feature(staged_api)]\n #![feature(std_misc)]\n #![feature(unicode)]\n-#![feature(hash)]\n #![cfg_attr(test, feature(test))]\n \n extern crate arena;"}, {"sha": "e8e8d35fe072a33c160e2dd8dea309815c70deae", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 70, "deletions": 48, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -254,7 +254,7 @@ impl LintPass for TypeLimits {\n                         let lit_val: f64 = match lit.node {\n                             ast::LitFloat(ref v, _) |\n                             ast::LitFloatUnsuffixed(ref v) => {\n-                                match v.parse() {\n+                                match v.parse().ok() {\n                                     Some(f) => f,\n                                     None => return\n                                 }\n@@ -493,7 +493,7 @@ pub struct BoxPointers;\n impl BoxPointers {\n     fn check_heap_type<'a, 'tcx>(&self, cx: &Context<'a, 'tcx>,\n                                  span: Span, ty: Ty<'tcx>) {\n-        let mut n_uniq = 0i;\n+        let mut n_uniq = 0u;\n         ty::fold_ty(cx.tcx, ty, |t| {\n             match t.sty {\n                 ty::ty_uniq(_) => {\n@@ -938,6 +938,34 @@ declare_lint! {\n pub struct NonSnakeCase;\n \n impl NonSnakeCase {\n+    fn to_snake_case(mut str: &str) -> String {\n+        let mut words = vec![];\n+        // Preserve leading underscores\n+        str = str.trim_left_matches(|&mut: c: char| {\n+            if c == '_' {\n+                words.push(String::new());\n+                true\n+            } else { false }\n+        });\n+        for s in str.split('_') {\n+            let mut last_upper = false;\n+            let mut buf = String::new();\n+            if s.is_empty() { continue; }\n+            for ch in s.chars() {\n+                if !buf.is_empty() && buf != \"'\"\n+                                   && ch.is_uppercase()\n+                                   && !last_upper {\n+                    words.push(buf);\n+                    buf = String::new();\n+                }\n+                last_upper = ch.is_uppercase();\n+                buf.push(ch.to_lowercase());\n+            }\n+            words.push(buf);\n+        }\n+        words.connect(\"_\")\n+    }\n+\n     fn check_snake_case(&self, cx: &Context, sort: &str, ident: ast::Ident, span: Span) {\n         fn is_snake_case(ident: ast::Ident) -> bool {\n             let ident = token::get_ident(ident);\n@@ -948,41 +976,28 @@ impl NonSnakeCase {\n             let mut allow_underscore = true;\n             ident.chars().all(|c| {\n                 allow_underscore = match c {\n-                    c if c.is_lowercase() || c.is_numeric() => true,\n-                    '_' if allow_underscore => false,\n+                    '_' if !allow_underscore => return false,\n+                    '_' => false,\n+                    c if !c.is_uppercase() => true,\n                     _ => return false,\n                 };\n                 true\n             })\n         }\n \n-        fn to_snake_case(str: &str) -> String {\n-            let mut words = vec![];\n-            for s in str.split('_') {\n-                let mut last_upper = false;\n-                let mut buf = String::new();\n-                if s.is_empty() { continue; }\n-                for ch in s.chars() {\n-                    if !buf.is_empty() && buf != \"'\"\n-                                       && ch.is_uppercase()\n-                                       && !last_upper {\n-                        words.push(buf);\n-                        buf = String::new();\n-                    }\n-                    last_upper = ch.is_uppercase();\n-                    buf.push(ch.to_lowercase());\n-                }\n-                words.push(buf);\n-            }\n-            words.connect(\"_\")\n-        }\n-\n         let s = token::get_ident(ident);\n \n         if !is_snake_case(ident) {\n-            cx.span_lint(NON_SNAKE_CASE, span,\n-                &format!(\"{} `{}` should have a snake case name such as `{}`\",\n-                        sort, s, to_snake_case(s.get()))[]);\n+            let sc = NonSnakeCase::to_snake_case(s.get());\n+            if sc != s.get() {\n+                cx.span_lint(NON_SNAKE_CASE, span,\n+                    &*format!(\"{} `{}` should have a snake case name such as `{}`\",\n+                            sort, s, sc));\n+            } else {\n+                cx.span_lint(NON_SNAKE_CASE, span,\n+                    &*format!(\"{} `{}` should have a snake case name\",\n+                            sort, s));\n+            }\n         }\n     }\n }\n@@ -1050,6 +1065,26 @@ declare_lint! {\n #[derive(Copy)]\n pub struct NonUpperCaseGlobals;\n \n+impl NonUpperCaseGlobals {\n+    fn check_upper_case(cx: &Context, sort: &str, ident: ast::Ident, span: Span) {\n+        let s = token::get_ident(ident);\n+\n+        if s.get().chars().any(|c| c.is_lowercase()) {\n+            let uc: String = NonSnakeCase::to_snake_case(s.get()).chars()\n+                                           .map(|c| c.to_uppercase()).collect();\n+            if uc != s.get() {\n+                cx.span_lint(NON_UPPER_CASE_GLOBALS, span,\n+                    format!(\"{} `{}` should have an upper case name such as `{}`\",\n+                            sort, s, uc).as_slice());\n+            } else {\n+                cx.span_lint(NON_UPPER_CASE_GLOBALS, span,\n+                    format!(\"{} `{}` should have an upper case name\",\n+                            sort, s).as_slice());\n+            }\n+        }\n+    }\n+}\n+\n impl LintPass for NonUpperCaseGlobals {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(NON_UPPER_CASE_GLOBALS)\n@@ -1058,19 +1093,11 @@ impl LintPass for NonUpperCaseGlobals {\n     fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n         match it.node {\n             // only check static constants\n-            ast::ItemStatic(_, ast::MutImmutable, _) |\n+            ast::ItemStatic(_, ast::MutImmutable, _) => {\n+                NonUpperCaseGlobals::check_upper_case(cx, \"static constant\", it.ident, it.span);\n+            }\n             ast::ItemConst(..) => {\n-                let s = token::get_ident(it.ident);\n-                // check for lowercase letters rather than non-uppercase\n-                // ones (some scripts don't have a concept of\n-                // upper/lowercase)\n-                if s.get().chars().any(|c| c.is_lowercase()) {\n-                    cx.span_lint(NON_UPPER_CASE_GLOBALS, it.span,\n-                        &format!(\"static constant `{}` should have an uppercase name \\\n-                                 such as `{}`\",\n-                                s.get(), &s.get().chars().map(|c| c.to_uppercase())\n-                                .collect::<String>()[])[]);\n-                }\n+                NonUpperCaseGlobals::check_upper_case(cx, \"constant\", it.ident, it.span);\n             }\n             _ => {}\n         }\n@@ -1080,14 +1107,8 @@ impl LintPass for NonUpperCaseGlobals {\n         // Lint for constants that look like binding identifiers (#7526)\n         match (&p.node, cx.tcx.def_map.borrow().get(&p.id)) {\n             (&ast::PatIdent(_, ref path1, _), Some(&def::DefConst(..))) => {\n-                let s = token::get_ident(path1.node);\n-                if s.get().chars().any(|c| c.is_lowercase()) {\n-                    cx.span_lint(NON_UPPER_CASE_GLOBALS, path1.span,\n-                        &format!(\"static constant in pattern `{}` should have an uppercase \\\n-                                 name such as `{}`\",\n-                                s.get(), &s.get().chars().map(|c| c.to_uppercase())\n-                                    .collect::<String>()[])[]);\n-                }\n+                NonUpperCaseGlobals::check_upper_case(cx, \"constant in pattern\",\n+                                                      path1.node, p.span);\n             }\n             _ => {}\n         }\n@@ -1164,6 +1185,7 @@ impl LintPass for UnusedParens {\n                 ast::MatchSource::Normal => (head, \"`match` head expression\", true),\n                 ast::MatchSource::IfLetDesugar { .. } => (head, \"`if let` head expression\", true),\n                 ast::MatchSource::WhileLetDesugar => (head, \"`while let` head expression\", true),\n+                ast::MatchSource::ForLoopDesugar => (head, \"`for` head expression\", true),\n             },\n             ast::ExprRet(Some(ref value)) => (value, \"`return` value\", false),\n             ast::ExprAssign(_, ref value) => (value, \"assigned value\", false),"}, {"sha": "322abe79ed2435002d9b733ed8fc63390eed41e5", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -223,7 +223,7 @@ fn each_reexport<F>(d: rbml::Doc, f: F) -> bool where\n fn variant_disr_val(d: rbml::Doc) -> Option<ty::Disr> {\n     reader::maybe_get_doc(d, tag_disr_val).and_then(|val_doc| {\n         reader::with_doc_data(val_doc, |data| {\n-            str::from_utf8(data).ok().and_then(|s| s.parse())\n+            str::from_utf8(data).ok().and_then(|s| s.parse().ok())\n         })\n     })\n }"}, {"sha": "6d19107096a4b6b9569ea7f84159cb3d5a5e9bc7", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -717,12 +717,16 @@ pub fn parse_def_id(buf: &[u8]) -> ast::DefId {\n     let crate_part = &buf[0u..colon_idx];\n     let def_part = &buf[colon_idx + 1u..len];\n \n-    let crate_num = match str::from_utf8(crate_part).ok().and_then(|s| s.parse::<uint>()) {\n+    let crate_num = match str::from_utf8(crate_part).ok().and_then(|s| {\n+        s.parse::<uint>().ok()\n+    }) {\n        Some(cn) => cn as ast::CrateNum,\n        None => panic!(\"internal error: parse_def_id: crate number expected, found {:?}\",\n                      crate_part)\n     };\n-    let def_num = match str::from_utf8(def_part).ok().and_then(|s| s.parse::<uint>()) {\n+    let def_num = match str::from_utf8(def_part).ok().and_then(|s| {\n+        s.parse::<uint>().ok()\n+    }) {\n        Some(dn) => dn as ast::NodeId,\n        None => panic!(\"internal error: parse_def_id: id expected, found {:?}\",\n                      def_part)"}, {"sha": "0a575a31eadc0841f940a40e29ea139f66f8f68e", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 2, "deletions": 37, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -263,43 +263,8 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 self.tcx.sess.span_bug(expr.span, \"non-desugared ExprWhileLet\");\n             }\n \n-            ast::ExprForLoop(ref pat, ref head, ref body, _) => {\n-                //\n-                //          [pred]\n-                //            |\n-                //            v 1\n-                //          [head]\n-                //            |\n-                //            v 2\n-                //        [loopback] <--+ 7\n-                //            |         |\n-                //            v 3       |\n-                //   +------[cond]      |\n-                //   |        |         |\n-                //   |        v 5       |\n-                //   |       [pat]      |\n-                //   |        |         |\n-                //   |        v 6       |\n-                //   v 4    [body] -----+\n-                // [expr]\n-                //\n-                // Note that `break` and `continue` statements\n-                // may cause additional edges.\n-\n-                let head = self.expr(&**head, pred);             // 1\n-                let loopback = self.add_dummy_node(&[head]);     // 2\n-                let cond = self.add_dummy_node(&[loopback]);     // 3\n-                let expr_exit = self.add_node(expr.id, &[cond]); // 4\n-                self.loop_scopes.push(LoopScope {\n-                    loop_id: expr.id,\n-                    continue_index: loopback,\n-                    break_index: expr_exit,\n-                });\n-                let pat = self.pat(&**pat, cond);               // 5\n-                let body = self.block(&**body, pat);            // 6\n-                self.add_contained_edge(body, loopback);        // 7\n-                self.loop_scopes.pop();\n-                expr_exit\n+            ast::ExprForLoop(..) => {\n+                self.tcx.sess.span_bug(expr.span, \"non-desugared ExprForLoop\");\n             }\n \n             ast::ExprLoop(ref body, _) => {"}, {"sha": "1f0fe4f1acaeaa37669e606b0fac7a17f1eabfff", "filename": "src/librustc/middle/cfg/graphviz.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -54,10 +54,10 @@ fn replace_newline_with_backslash_l(s: String) -> String {\n }\n \n impl<'a, 'ast> dot::Labeller<'a, Node<'a>, Edge<'a>> for LabelledCFG<'a, 'ast> {\n-    fn graph_id(&'a self) -> dot::Id<'a> { dot::Id::new(&self.name[]).unwrap() }\n+    fn graph_id(&'a self) -> dot::Id<'a> { dot::Id::new(&self.name[]).ok().unwrap() }\n \n     fn node_id(&'a self, &(i,_): &Node<'a>) -> dot::Id<'a> {\n-        dot::Id::new(format!(\"N{}\", i.node_id())).unwrap()\n+        dot::Id::new(format!(\"N{}\", i.node_id())).ok().unwrap()\n     }\n \n     fn node_label(&'a self, &(i, n): &Node<'a>) -> dot::LabelText<'a> {"}, {"sha": "41ef55933cda2e841f14d54f9af249fdf29b0fa8", "filename": "src/librustc/middle/check_loop.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -45,10 +45,6 @@ impl<'a, 'v> Visitor<'v> for CheckLoopVisitor<'a> {\n             ast::ExprLoop(ref b, _) => {\n                 self.with_context(Loop, |v| v.visit_block(&**b));\n             }\n-            ast::ExprForLoop(_, ref e, ref b, _) => {\n-                self.visit_expr(&**e);\n-                self.with_context(Loop, |v| v.visit_block(&**b));\n-            }\n             ast::ExprClosure(_, _, _, ref b) => {\n                 self.with_context(Closure, |v| v.visit_block(&**b));\n             }"}, {"sha": "aded63336dcd538676c1caaa2f7f27d311bdd7eb", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 33, "deletions": 19, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -221,21 +221,8 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &ast::Expr) {\n                 .flat_map(|arm| arm.0.iter())\n                 .map(|pat| vec![&**pat])\n                 .collect();\n-            check_exhaustive(cx, ex.span, &matrix);\n+            check_exhaustive(cx, ex.span, &matrix, source);\n         },\n-        ast::ExprForLoop(ref pat, _, _, _) => {\n-            let mut static_inliner = StaticInliner::new(cx.tcx);\n-            is_refutable(cx, &*static_inliner.fold_pat((*pat).clone()), |uncovered_pat| {\n-                span_err!(cx.tcx.sess, pat.span, E0297,\n-                    \"refutable pattern in `for` loop binding: \\\n-                            `{}` not covered\",\n-                            pat_to_string(uncovered_pat));\n-            });\n-\n-            // Check legality of move bindings.\n-            check_legality_of_move_bindings(cx, false, slice::ref_slice(pat));\n-            check_legality_of_bindings_in_at_patterns(cx, &**pat);\n-        }\n         _ => ()\n     }\n }\n@@ -327,6 +314,14 @@ fn check_arms(cx: &MatchCheckCtxt,\n                             span_err!(cx.tcx.sess, span, E0165, \"irrefutable while-let pattern\");\n                         },\n \n+                        ast::MatchSource::ForLoopDesugar => {\n+                            // this is a bug, because on `match iter.next()` we cover\n+                            // `Some(<head>)` and `None`. It's impossible to have an unreachable\n+                            // pattern\n+                            // (see libsyntax/ext/expand.rs for the full expansion of a for loop)\n+                            cx.tcx.sess.span_bug(pat.span, \"unreachable for-loop pattern\")\n+                        },\n+\n                         ast::MatchSource::Normal => {\n                             span_err!(cx.tcx.sess, pat.span, E0001, \"unreachable pattern\")\n                         },\n@@ -351,18 +346,37 @@ fn raw_pat<'a>(p: &'a Pat) -> &'a Pat {\n     }\n }\n \n-fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, matrix: &Matrix) {\n+fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, matrix: &Matrix, source: ast::MatchSource) {\n     match is_useful(cx, matrix, &[DUMMY_WILD_PAT], ConstructWitness) {\n         UsefulWithWitness(pats) => {\n             let witness = match &pats[] {\n                 [ref witness] => &**witness,\n                 [] => DUMMY_WILD_PAT,\n                 _ => unreachable!()\n             };\n-            span_err!(cx.tcx.sess, sp, E0004,\n-                \"non-exhaustive patterns: `{}` not covered\",\n-                pat_to_string(witness)\n-            );\n+            match source {\n+                ast::MatchSource::ForLoopDesugar => {\n+                    // `witness` has the form `Some(<head>)`, peel off the `Some`\n+                    let witness = match witness.node {\n+                        ast::PatEnum(_, Some(ref pats)) => match &pats[] {\n+                            [ref pat] => &**pat,\n+                            _ => unreachable!(),\n+                        },\n+                        _ => unreachable!(),\n+                    };\n+\n+                    span_err!(cx.tcx.sess, sp, E0297,\n+                        \"refutable pattern in `for` loop binding: \\\n+                                `{}` not covered\",\n+                                pat_to_string(witness));\n+                },\n+                _ => {\n+                    span_err!(cx.tcx.sess, sp, E0004,\n+                        \"non-exhaustive patterns: `{}` not covered\",\n+                        pat_to_string(witness)\n+                    );\n+                },\n+            }\n         }\n         NotUseful => {\n             // This is good, wildcard pattern isn't reachable"}, {"sha": "188a56135ec33d26331bd3192d44c3e4ddec0397", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -540,22 +540,8 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                 self.tcx().sess.span_bug(expr.span, \"non-desugared ExprWhileLet\");\n             }\n \n-            ast::ExprForLoop(ref pat, ref head, ref blk, _) => {\n-                // The pattern lives as long as the block.\n-                debug!(\"walk_expr for loop case: blk id={}\", blk.id);\n-                self.consume_expr(&**head);\n-\n-                // Fetch the type of the value that the iteration yields to\n-                // produce the pattern's categorized mutable type.\n-                let pattern_type = return_if_err!(self.typer.node_ty(pat.id));\n-                let blk_scope = region::CodeExtent::from_node_id(blk.id);\n-                let pat_cmt = self.mc.cat_rvalue(pat.id,\n-                                                 pat.span,\n-                                                 ty::ReScope(blk_scope),\n-                                                 pattern_type);\n-                self.walk_irrefutable_pat(pat_cmt, &**pat);\n-\n-                self.walk_block(&**blk);\n+            ast::ExprForLoop(..) => {\n+                self.tcx().sess.span_bug(expr.span, \"non-desugared ExprForLoop\");\n             }\n \n             ast::ExprUnary(op, ref lhs) => {"}, {"sha": "8b29ef9b8800feb9499c0ba8a17871517bf7c962", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -263,7 +263,13 @@ pub trait Combine<'tcx> : Sized {\n             Err(ty::terr_projection_name_mismatched(\n                 expected_found(self, a.item_name, b.item_name)))\n         } else {\n-            let trait_ref = try!(self.trait_refs(&*a.trait_ref, &*b.trait_ref));\n+            // Note that the trait refs for the projection must be\n+            // *equal*. This is because there is no inherent\n+            // relationship between `<T as Foo>::Bar` and `<U as\n+            // Foo>::Bar` that we can derive based on how `T` relates\n+            // to `U`. Issue #21726 contains further discussion and\n+            // in-depth examples.\n+            let trait_ref = try!(self.equate().trait_refs(&*a.trait_ref, &*b.trait_ref));\n             Ok(ty::ProjectionTy { trait_ref: Rc::new(trait_ref), item_name: a.item_name })\n         }\n     }"}, {"sha": "460687629e7b545baa4ceb5c8ffdb943f11f0106", "filename": "src/librustc/middle/infer/region_inference/graphviz.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -59,7 +59,7 @@ pub fn maybe_print_constraints_for<'a, 'tcx>(region_vars: &RegionVarBindings<'a,\n     }\n \n     let requested_node : Option<ast::NodeId> =\n-        os::getenv(\"RUST_REGION_GRAPH_NODE\").and_then(|s| s.parse());\n+        os::getenv(\"RUST_REGION_GRAPH_NODE\").and_then(|s| s.parse().ok());\n \n     if requested_node.is_some() && requested_node != Some(subject_node) {\n         return;\n@@ -157,10 +157,10 @@ impl<'a, 'tcx> ConstraintGraph<'a, 'tcx> {\n \n impl<'a, 'tcx> dot::Labeller<'a, Node, Edge> for ConstraintGraph<'a, 'tcx> {\n     fn graph_id(&self) -> dot::Id {\n-        dot::Id::new(self.graph_name.as_slice()).unwrap()\n+        dot::Id::new(self.graph_name.as_slice()).ok().unwrap()\n     }\n     fn node_id(&self, n: &Node) -> dot::Id {\n-        dot::Id::new(format!(\"node_{}\", self.node_ids.get(n).unwrap())).unwrap()\n+        dot::Id::new(format!(\"node_{}\", self.node_ids.get(n).unwrap())).ok().unwrap()\n     }\n     fn node_label(&self, n: &Node) -> dot::LabelText {\n         match *n {"}, {"sha": "29a615f2b4052bd4ffe51417615a60327be18bf3", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -325,8 +325,6 @@ lets_do_this! {\n \n     NonZeroItem,                     \"non_zero\",                non_zero;\n \n-    IteratorItem,                    \"iterator\",                iterator;\n-\n     StackExhaustedLangItem,          \"stack_exhausted\",         stack_exhausted;\n \n     DebugTraitLangItem,              \"debug_trait\",             debug_trait;"}, {"sha": "982bc41f06a849cf38034487a7a8303b19ff5163", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 7, "deletions": 30, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -135,8 +135,6 @@ enum LoopKind<'a> {\n     LoopLoop,\n     /// A `while` loop, with the given expression as condition.\n     WhileLoop(&'a Expr),\n-    /// A `for` loop, with the given pattern to bind.\n-    ForLoop(&'a ast::Pat),\n }\n \n #[derive(Copy, PartialEq)]\n@@ -490,19 +488,8 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n       ast::ExprWhileLet(..) => {\n           ir.tcx.sess.span_bug(expr.span, \"non-desugared ExprWhileLet\");\n       }\n-      ast::ExprForLoop(ref pat, _, _, _) => {\n-        pat_util::pat_bindings(&ir.tcx.def_map, &**pat, |bm, p_id, sp, path1| {\n-            debug!(\"adding local variable {} from for loop with bm {:?}\",\n-                   p_id, bm);\n-            let name = path1.node;\n-            ir.add_live_node_for_node(p_id, VarDefNode(sp));\n-            ir.add_variable(Local(LocalInfo {\n-                id: p_id,\n-                ident: name\n-            }));\n-        });\n-        ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n-        visit::walk_expr(ir, expr);\n+      ast::ExprForLoop(..) => {\n+          ir.tcx.sess.span_bug(expr.span, \"non-desugared ExprForLoop\");\n       }\n       ast::ExprBinary(op, _, _) if ast_util::lazy_binop(op.node) => {\n         ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n@@ -1034,9 +1021,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n               self.ir.tcx.sess.span_bug(expr.span, \"non-desugared ExprWhileLet\");\n           }\n \n-          ast::ExprForLoop(ref pat, ref head, ref blk, _) => {\n-            let ln = self.propagate_through_loop(expr, ForLoop(&**pat), &**blk, succ);\n-            self.propagate_through_expr(&**head, ln)\n+          ast::ExprForLoop(..) => {\n+              self.ir.tcx.sess.span_bug(expr.span, \"non-desugared ExprForLoop\");\n           }\n \n           // Note that labels have been resolved, so we don't need to look\n@@ -1373,7 +1359,6 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n         let cond_ln = match kind {\n             LoopLoop => ln,\n-            ForLoop(ref pat) => self.define_bindings_in_pat(*pat, ln),\n             WhileLoop(ref cond) => self.propagate_through_expr(&**cond, ln),\n         };\n         let body_ln = self.with_loop_nodes(expr.id, succ, ln, |this| {\n@@ -1386,9 +1371,6 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n             let new_cond_ln = match kind {\n                 LoopLoop => ln,\n-                ForLoop(ref pat) => {\n-                    self.define_bindings_in_pat(*pat, ln)\n-                }\n                 WhileLoop(ref cond) => {\n                     self.propagate_through_expr(&**cond, ln)\n                 }\n@@ -1476,14 +1458,6 @@ fn check_expr(this: &mut Liveness, expr: &Expr) {\n         visit::walk_expr(this, expr);\n       }\n \n-      ast::ExprForLoop(ref pat, _, _, _) => {\n-        this.pat_bindings(&**pat, |this, ln, var, sp, id| {\n-            this.warn_about_unused(sp, id, ln, var);\n-        });\n-\n-        visit::walk_expr(this, expr);\n-      }\n-\n       // no correctness conditions related to liveness\n       ast::ExprCall(..) | ast::ExprMethodCall(..) | ast::ExprIf(..) |\n       ast::ExprMatch(..) | ast::ExprWhile(..) | ast::ExprLoop(..) |\n@@ -1503,6 +1477,9 @@ fn check_expr(this: &mut Liveness, expr: &Expr) {\n       ast::ExprWhileLet(..) => {\n         this.ir.tcx.sess.span_bug(expr.span, \"non-desugared ExprWhileLet\");\n       }\n+      ast::ExprForLoop(..) => {\n+        this.ir.tcx.sess.span_bug(expr.span, \"non-desugared ExprForLoop\");\n+      }\n     }\n }\n "}, {"sha": "0d86dbeadf4a74557944ca211b6ffa16be8dab0c", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -534,8 +534,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n           ast::ExprBlock(..) | ast::ExprLoop(..) | ast::ExprMatch(..) |\n           ast::ExprLit(..) | ast::ExprBreak(..) | ast::ExprMac(..) |\n           ast::ExprAgain(..) | ast::ExprStruct(..) | ast::ExprRepeat(..) |\n-          ast::ExprInlineAsm(..) | ast::ExprBox(..) |\n-          ast::ExprForLoop(..) => {\n+          ast::ExprInlineAsm(..) | ast::ExprBox(..) => {\n             Ok(self.cat_rvalue_node(expr.id(), expr.span(), expr_ty))\n           }\n \n@@ -545,6 +544,9 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n           ast::ExprWhileLet(..) => {\n             self.tcx().sess.span_bug(expr.span, \"non-desugared ExprWhileLet\");\n           }\n+          ast::ExprForLoop(..) => {\n+            self.tcx().sess.span_bug(expr.span, \"non-desugared ExprForLoop\");\n+          }\n         }\n     }\n "}, {"sha": "da83833fba3a14b3470293681f823bb26290b5a3", "filename": "src/librustc/middle/recursion_limit.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -18,7 +18,6 @@\n use session::Session;\n use syntax::ast;\n use syntax::attr::AttrMetaMethods;\n-use std::str::FromStr;\n \n pub fn update_recursion_limit(sess: &Session, krate: &ast::Crate) {\n     for attr in krate.attrs.iter() {\n@@ -27,7 +26,7 @@ pub fn update_recursion_limit(sess: &Session, krate: &ast::Crate) {\n         }\n \n         if let Some(s) = attr.value_str() {\n-            if let Some(n) = FromStr::from_str(s.get()) {\n+            if let Some(n) = s.parse().ok() {\n                 sess.recursion_limit.set(n);\n                 return;\n             }"}, {"sha": "c70532dbb30cb03723499a0e03bb23ad17f2e9d3", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -701,14 +701,6 @@ fn resolve_expr(visitor: &mut RegionResolutionVisitor, expr: &ast::Expr) {\n                 terminating(body.id);\n             }\n \n-            ast::ExprForLoop(ref _pat, ref _head, ref body, _) => {\n-                terminating(body.id);\n-\n-                // The variable parent of everything inside (most importantly, the\n-                // pattern) is the body.\n-                visitor.cx.var_parent = InnermostDeclaringBlock::Block(body.id);\n-            }\n-\n             ast::ExprMatch(..) => {\n                 visitor.cx.var_parent = InnermostDeclaringBlock::Match(expr.id);\n             }"}, {"sha": "ce66f4d5b355c76478981ff9ec88dc7d14dcb5a5", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -430,6 +430,11 @@ fn project_type<'cx,'tcx>(\n                                        &obligation_trait_ref,\n                                        &mut candidates);\n \n+    assemble_candidates_from_trait_def(selcx,\n+                                       obligation,\n+                                       &obligation_trait_ref,\n+                                       &mut candidates);\n+\n     if let Err(e) = assemble_candidates_from_impls(selcx,\n                                                    obligation,\n                                                    &obligation_trait_ref,\n@@ -474,6 +479,41 @@ fn assemble_candidates_from_param_env<'cx,'tcx>(\n                                         candidate_set, env_predicates);\n }\n \n+/// In the case of a nested projection like <<A as Foo>::FooT as Bar>::BarT, we may find\n+/// that the definition of `Foo` has some clues:\n+///\n+/// ```rust\n+/// trait Foo {\n+///     type FooT : Bar<BarT=i32>\n+/// }\n+/// ```\n+///\n+/// Here, for example, we could conclude that the result is `i32`.\n+fn assemble_candidates_from_trait_def<'cx,'tcx>(\n+    selcx: &mut SelectionContext<'cx,'tcx>,\n+    obligation: &ProjectionTyObligation<'tcx>,\n+    obligation_trait_ref: &Rc<ty::TraitRef<'tcx>>,\n+    candidate_set: &mut ProjectionTyCandidateSet<'tcx>)\n+{\n+    // Check whether the self-type is itself a projection.\n+    let trait_ref = match obligation_trait_ref.self_ty().sty {\n+        ty::ty_projection(ref data) => data.trait_ref.clone(),\n+        ty::ty_infer(ty::TyVar(_)) => {\n+            // If the self-type is an inference variable, then it MAY wind up\n+            // being a projected type, so induce an ambiguity.\n+            candidate_set.ambiguous = true;\n+            return;\n+        }\n+        _ => { return; }\n+    };\n+\n+    // If so, extract what we know from the trait and try to come up with a good answer.\n+    let trait_def = ty::lookup_trait_def(selcx.tcx(), trait_ref.def_id);\n+    let bounds = trait_def.generics.to_bounds(selcx.tcx(), trait_ref.substs);\n+    assemble_candidates_from_predicates(selcx, obligation, obligation_trait_ref,\n+                                        candidate_set, bounds.predicates.into_vec());\n+}\n+\n fn assemble_candidates_from_predicates<'cx,'tcx>(\n     selcx: &mut SelectionContext<'cx,'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,"}, {"sha": "8e88e4338cd85e84b8cdb276afdbcdba78062c4c", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -4465,9 +4465,6 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n             // the index method invoked for `a[i]` always yields an `&T`\n             ast::ExprIndex(..) => LvalueExpr,\n \n-            // `for` loops are statements\n-            ast::ExprForLoop(..) => RvalueStmtExpr,\n-\n             // in the general case, result could be any type, use DPS\n             _ => RvalueDpsExpr\n         };\n@@ -4554,6 +4551,10 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n             tcx.sess.span_bug(expr.span, \"non-desugared ExprWhileLet\");\n         }\n \n+        ast::ExprForLoop(..) => {\n+            tcx.sess.span_bug(expr.span, \"non-desugared ExprForLoop\");\n+        }\n+\n         ast::ExprLit(ref lit) if lit_is_str(&**lit) => {\n             RvalueDpsExpr\n         }\n@@ -4591,8 +4592,7 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n         ast::ExprLoop(..) |\n         ast::ExprAssign(..) |\n         ast::ExprInlineAsm(..) |\n-        ast::ExprAssignOp(..) |\n-        ast::ExprForLoop(..) => {\n+        ast::ExprAssignOp(..) => {\n             RvalueStmtExpr\n         }\n "}, {"sha": "ab182dd225637e52be6b3a17638e9bdbb4915910", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -333,8 +333,8 @@ macro_rules! options {\n                 break;\n             }\n             if !found {\n-                early_error(&format!(\"unknown codegen option: `{}`\",\n-                                    key)[]);\n+                early_error(&format!(\"unknown {} option: `{}`\",\n+                                    $outputname, key)[]);\n             }\n         }\n         return op;\n@@ -424,15 +424,15 @@ macro_rules! options {\n         }\n \n         fn parse_uint(slot: &mut uint, v: Option<&str>) -> bool {\n-            match v.and_then(|s| s.parse()) {\n+            match v.and_then(|s| s.parse().ok()) {\n                 Some(i) => { *slot = i; true },\n                 None => false\n             }\n         }\n \n         fn parse_opt_uint(slot: &mut Option<uint>, v: Option<&str>) -> bool {\n             match v {\n-                Some(s) => { *slot = s.parse(); slot.is_some() }\n+                Some(s) => { *slot = s.parse().ok(); slot.is_some() }\n                 None => { *slot = None; true }\n             }\n         }"}, {"sha": "a433161d659e8a5a4f0350de4f93b2da4dcec4e4", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -96,7 +96,7 @@ impl<'v, P> Visitor<'v> for LoopQueryVisitor<P> where P: FnMut(&ast::Expr_) -> b\n         match e.node {\n           // Skip inner loops, since a break in the inner loop isn't a\n           // break inside the outer loop\n-          ast::ExprLoop(..) | ast::ExprWhile(..) | ast::ExprForLoop(..) => {}\n+          ast::ExprLoop(..) | ast::ExprWhile(..) => {}\n           _ => visit::walk_expr(self, e)\n         }\n     }"}, {"sha": "6c723a583807e57e27e80d64ce0a55ecde3250a5", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -100,6 +100,7 @@ pub fn explain_region_and_span(cx: &ctxt, region: ty::Region)\n               ast::ExprMethodCall(..) => \"method call\",\n               ast::ExprMatch(_, _, ast::MatchSource::IfLetDesugar { .. }) => \"if let\",\n               ast::ExprMatch(_, _, ast::MatchSource::WhileLetDesugar) =>  \"while let\",\n+              ast::ExprMatch(_, _, ast::MatchSource::ForLoopDesugar) =>  \"for\",\n               ast::ExprMatch(..) => \"match\",\n               _ => \"expression\",\n           },"}, {"sha": "2c6b5797f572b3f4fafa142414abb7f70e59b876", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -23,23 +23,23 @@\n \n #![crate_name = \"rustc_back\"]\n #![unstable(feature = \"rustc_private\")]\n-#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n-#![allow(unknown_features)]\n-#![feature(slicing_syntax, box_syntax)]\n-#![allow(unknown_features)] #![feature(int_uint)]\n+\n+#![feature(box_syntax)]\n #![feature(collections)]\n #![feature(core)]\n #![feature(hash)]\n+#![feature(int_uint)]\n #![feature(io)]\n #![feature(os)]\n #![feature(path)]\n #![feature(rustc_private)]\n+#![feature(staged_api)]\n \n extern crate syntax;\n extern crate serialize;"}, {"sha": "3d7adc9934fb55f488b19556b9fcff71ac0775bb", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -252,7 +252,6 @@ mod svh_visitor {\n         SawExprStruct,\n         SawExprRepeat,\n         SawExprParen,\n-        SawExprForLoop,\n     }\n \n     fn saw_expr<'a>(node: &'a Expr_) -> SawExprComponent<'a> {\n@@ -288,9 +287,9 @@ mod svh_visitor {\n             ExprStruct(..)           => SawExprStruct,\n             ExprRepeat(..)           => SawExprRepeat,\n             ExprParen(..)            => SawExprParen,\n-            ExprForLoop(..)          => SawExprForLoop,\n \n             // just syntactic artifacts, expanded away by time of SVH.\n+            ExprForLoop(..)          => unreachable!(),\n             ExprIfLet(..)            => unreachable!(),\n             ExprWhileLet(..)         => unreachable!(),\n             ExprMac(..)              => unreachable!(),"}, {"sha": "031607728797ed29cd35716e2e776f20490c3a5c", "filename": "src/librustc_bitflags/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc_bitflags%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc_bitflags%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_bitflags%2Flib.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n #![crate_name = \"rustc_bitflags\"]\n-#![allow(unknown_features)]\n #![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"rlib\"]"}, {"sha": "c2677cc3fd0b386a27d16da3df43cec4a33fedb5", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -10,24 +10,23 @@\n \n #![crate_name = \"rustc_borrowck\"]\n #![unstable(feature = \"rustc_private\")]\n-#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n-#![allow(unknown_features)]\n-#![feature(quote)]\n-#![feature(slicing_syntax, unsafe_destructor)]\n-#![feature(rustc_diagnostic_macros)]\n-#![allow(unknown_features)] #![feature(int_uint)]\n #![allow(non_camel_case_types)]\n-#![feature(collections)]\n+\n #![feature(core)]\n-#![feature(rustc_private)]\n #![feature(hash)]\n+#![feature(int_uint)]\n+#![feature(quote)]\n+#![feature(rustc_diagnostic_macros)]\n+#![feature(rustc_private)]\n+#![feature(staged_api)]\n+#![feature(unsafe_destructor)]\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;"}, {"sha": "9e00844b7eea23168ed7934d95702b6a58124c9d", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -880,7 +880,7 @@ pub fn collect_crate_types(session: &Session,\n         let res = !link::invalid_output_for_target(session, *crate_type);\n \n         if !res {\n-            session.warn(&format!(\"dropping unsupported crate type `{:?}` \\\n+            session.warn(&format!(\"dropping unsupported crate type `{}` \\\n                                    for target `{}`\",\n                                  *crate_type, session.opts.target_triple)[]);\n         }"}, {"sha": "2eada1ff174f15ccc5beecbe369712d781b191f7", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -16,27 +16,26 @@\n \n #![crate_name = \"rustc_driver\"]\n #![unstable(feature = \"rustc_private\")]\n-#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n-#![allow(unknown_features)]\n-#![feature(quote)]\n-#![feature(slicing_syntax, unsafe_destructor)]\n #![feature(box_syntax)]\n-#![feature(rustc_diagnostic_macros)]\n-#![allow(unknown_features)] #![feature(int_uint)]\n #![feature(collections)]\n #![feature(core)]\n+#![feature(int_uint)]\n #![feature(io)]\n #![feature(libc)]\n #![feature(os)]\n #![feature(path)]\n+#![feature(quote)]\n+#![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n+#![feature(slicing_syntax, unsafe_destructor)]\n+#![feature(staged_api)]\n #![feature(std_misc)]\n #![feature(unicode)]\n "}, {"sha": "bd7ad51de37247ee77956eca4e91e248d38f90a6", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -99,7 +99,7 @@ pub fn parse_pretty(sess: &Session,\n             }\n         }\n     };\n-    let opt_second = opt_second.and_then(|s| s.parse::<UserIdentifiedItem>());\n+    let opt_second = opt_second.and_then(|s| s.parse::<UserIdentifiedItem>().ok());\n     (first, opt_second)\n }\n \n@@ -345,13 +345,11 @@ pub enum UserIdentifiedItem {\n }\n \n impl FromStr for UserIdentifiedItem {\n-    fn from_str(s: &str) -> Option<UserIdentifiedItem> {\n-        s.parse().map(ItemViaNode).or_else(|| {\n-            let v : Vec<_> = s.split_str(\"::\")\n-                .map(|x|x.to_string())\n-                .collect();\n-            Some(ItemViaPath(v))\n-        })\n+    type Err = ();\n+    fn from_str(s: &str) -> Result<UserIdentifiedItem, ()> {\n+        Ok(s.parse().map(ItemViaNode).unwrap_or_else(|_| {\n+            ItemViaPath(s.split_str(\"::\").map(|s| s.to_string()).collect())\n+        }))\n     }\n }\n "}, {"sha": "a24bc6eaec351da4c8799545bef8670c5d01f5d8", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -15,24 +15,23 @@\n \n #![crate_name = \"rustc_llvm\"]\n #![unstable(feature = \"rustc_private\")]\n-#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n-#![allow(unknown_features)]\n-#![feature(link_args)]\n #![feature(box_syntax)]\n-#![allow(unknown_features)] #![feature(int_uint)]\n #![feature(collections)]\n #![feature(core)]\n+#![feature(hash)]\n+#![feature(int_uint)]\n #![feature(libc)]\n+#![feature(link_args)]\n #![feature(path)]\n+#![feature(staged_api)]\n #![feature(std_misc)]\n-#![feature(hash)]\n \n extern crate libc;\n #[macro_use] #[no_link] extern crate rustc_bitflags;"}, {"sha": "14e80c6c8ef3ca40434690c0e18881d17a8de6c9", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -10,19 +10,18 @@\n \n #![crate_name = \"rustc_privacy\"]\n #![unstable(feature = \"rustc_private\")]\n-#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n-#![feature(rustc_diagnostic_macros)]\n-#![allow(unknown_features)] #![feature(int_uint)]\n-#![feature(collections)]\n #![feature(core)]\n+#![feature(int_uint)]\n+#![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n+#![feature(staged_api)]\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;"}, {"sha": "f07119035799988fe32cb5c732d530995b3b4bea", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 6, "deletions": 39, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -10,23 +10,23 @@\n \n #![crate_name = \"rustc_resolve\"]\n #![unstable(feature = \"rustc_private\")]\n-#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n-#![feature(slicing_syntax)]\n-#![feature(rustc_diagnostic_macros)]\n-#![allow(unknown_features)] #![feature(int_uint)]\n #![feature(alloc)]\n #![feature(collections)]\n #![feature(core)]\n+#![feature(hash)]\n+#![feature(int_uint)]\n+#![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n+#![feature(slicing_syntax)]\n+#![feature(staged_api)]\n #![feature(std_misc)]\n-#![feature(hash)]\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;\n@@ -68,7 +68,7 @@ use rustc::util::lev_distance::lev_distance;\n \n use syntax::ast::{Arm, BindByRef, BindByValue, BindingMode, Block, Crate, CrateNum};\n use syntax::ast::{DefId, Expr, ExprAgain, ExprBreak, ExprField};\n-use syntax::ast::{ExprClosure, ExprForLoop, ExprLoop, ExprWhile, ExprMethodCall};\n+use syntax::ast::{ExprClosure, ExprLoop, ExprWhile, ExprMethodCall};\n use syntax::ast::{ExprPath, ExprQPath, ExprStruct, FnDecl};\n use syntax::ast::{ForeignItemFn, ForeignItemStatic, Generics};\n use syntax::ast::{Ident, ImplItem, Item, ItemConst, ItemEnum, ItemExternCrate};\n@@ -4559,39 +4559,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 })\n             }\n \n-            ExprForLoop(ref pattern, ref head, ref body, optional_label) => {\n-                self.resolve_expr(&**head);\n-\n-                self.value_ribs.push(Rib::new(NormalRibKind));\n-\n-                self.resolve_pattern(&**pattern,\n-                                     LocalIrrefutableMode,\n-                                     &mut HashMap::new());\n-\n-                match optional_label {\n-                    None => {}\n-                    Some(label) => {\n-                        self.label_ribs\n-                            .push(Rib::new(NormalRibKind));\n-                        let def_like = DlDef(DefLabel(expr.id));\n-\n-                        {\n-                            let rib = self.label_ribs.last_mut().unwrap();\n-                            let renamed = mtwt::resolve(label);\n-                            rib.bindings.insert(renamed, def_like);\n-                        }\n-                    }\n-                }\n-\n-                self.resolve_block(&**body);\n-\n-                if optional_label.is_some() {\n-                    drop(self.label_ribs.pop())\n-                }\n-\n-                self.value_ribs.pop();\n-            }\n-\n             ExprBreak(Some(label)) | ExprAgain(Some(label)) => {\n                 let renamed = mtwt::resolve(label);\n                 match self.search_label(renamed) {"}, {"sha": "c46c2b7e6ddaf2410f45f08a0e4bf1238c081f55", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -16,31 +16,32 @@\n \n #![crate_name = \"rustc_trans\"]\n #![unstable(feature = \"rustc_private\")]\n-#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n-#![allow(unknown_features)]\n-#![feature(quote)]\n-#![feature(slicing_syntax, unsafe_destructor)]\n-#![feature(box_syntax)]\n-#![feature(rustc_diagnostic_macros)]\n-#![allow(unknown_features)] #![feature(int_uint)]\n+#![cfg_attr(not(stage0), allow(unused_mut))] // NOTE: remove after stage0 snap\n+\n #![feature(alloc)]\n+#![feature(box_syntax)]\n #![feature(collections)]\n #![feature(core)]\n+#![feature(hash)]\n+#![feature(int_uint)]\n #![feature(io)]\n #![feature(libc)]\n #![feature(os)]\n #![feature(path)]\n+#![feature(quote)]\n+#![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n+#![feature(slicing_syntax, unsafe_destructor)]\n+#![feature(staged_api)]\n #![feature(std_misc)]\n #![feature(unicode)]\n-#![feature(hash)]\n \n extern crate arena;\n extern crate flate;"}, {"sha": "fbeaae1d1dfa3a272ebd895447db8ca8b63ae2a4", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 93, "deletions": 67, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -44,7 +44,7 @@ use syntax::codemap::*;\n use syntax::parse::token::{self, get_ident, keywords};\n use syntax::owned_slice::OwnedSlice;\n use syntax::visit::{self, Visitor};\n-use syntax::print::pprust::{path_to_string,ty_to_string};\n+use syntax::print::pprust::{path_to_string, ty_to_string};\n use syntax::ptr::P;\n \n use self::span_utils::SpanUtils;\n@@ -123,24 +123,36 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n \n         let mut result: Vec<(Span, String)> = vec!();\n \n-\n         let mut segs = vec!();\n-        for (seg, span) in path.segments.iter().zip(spans.iter()) {\n+        for (i, (seg, span)) in path.segments.iter().zip(spans.iter()).enumerate() {\n             segs.push(seg.clone());\n             let sub_path = ast::Path{span: *span, // span for the last segment\n                                      global: path.global,\n                                      segments: segs};\n-            let qualname = path_to_string(&sub_path);\n+            let qualname = if i == 0 && path.global {\n+                format!(\"::{}\", path_to_string(&sub_path))\n+            } else {\n+                path_to_string(&sub_path)\n+            };\n             result.push((*span, qualname));\n             segs = sub_path.segments;\n         }\n \n         result\n     }\n \n-    fn write_sub_paths(&mut self, path: &ast::Path) {\n+    // The global arg allows us to override the global-ness of the path (which\n+    // actually means 'does the path start with `::`', rather than 'is the path\n+    // semantically global). We use the override for `use` imports (etc.) where\n+    // the syntax is non-global, but the semantics are global.\n+    fn write_sub_paths(&mut self, path: &ast::Path, global: bool) {\n         let sub_paths = self.process_path_prefixes(path);\n-        for &(ref span, ref qualname) in sub_paths.iter() {\n+        for (i, &(ref span, ref qualname)) in sub_paths.iter().enumerate() {\n+            let qualname = if i == 0 && global && !path.global {\n+                format!(\"::{}\", qualname)\n+            } else {\n+                qualname.clone()\n+            };\n             self.fmt.sub_mod_ref_str(path.span,\n                                      *span,\n                                      &qualname[],\n@@ -149,16 +161,21 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n     }\n \n     // As write_sub_paths, but does not process the last ident in the path (assuming it\n-    // will be processed elsewhere).\n-    fn write_sub_paths_truncated(&mut self, path: &ast::Path) {\n+    // will be processed elsewhere). See note on write_sub_paths about global.\n+    fn write_sub_paths_truncated(&mut self, path: &ast::Path, global: bool) {\n         let sub_paths = self.process_path_prefixes(path);\n         let len = sub_paths.len();\n         if len <= 1 {\n             return;\n         }\n \n-        let sub_paths = &sub_paths[.. (len-1)];\n-        for &(ref span, ref qualname) in sub_paths.iter() {\n+        let sub_paths = &sub_paths[..len-1];\n+        for (i, &(ref span, ref qualname)) in sub_paths.iter().enumerate() {\n+            let qualname = if i == 0 && global && !path.global {\n+                format!(\"::{}\", qualname)\n+            } else {\n+                qualname.clone()\n+            };\n             self.fmt.sub_mod_ref_str(path.span,\n                                      *span,\n                                      &qualname[],\n@@ -276,9 +293,9 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n \n         let mut scope_id;\n         // The qualname for a method is the trait name or name of the struct in an impl in\n-        // which the method is declared in followed by the method's name.\n-        let mut qualname = match ty::impl_of_method(&self.analysis.ty_cx,\n-                                                    ast_util::local_def(method.id)) {\n+        // which the method is declared in, followed by the method's name.\n+        let qualname = match ty::impl_of_method(&self.analysis.ty_cx,\n+                                                ast_util::local_def(method.id)) {\n             Some(impl_id) => match self.analysis.ty_cx.map.get(impl_id.node) {\n                 NodeItem(item) => {\n                     scope_id = item.id;\n@@ -296,7 +313,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                 },\n                                 None => {}\n                             }\n-                            result.push_str(\">::\");\n+                            result.push_str(\">\");\n                             result\n                         }\n                         _ => {\n@@ -321,9 +338,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                     scope_id = def_id.node;\n                     match self.analysis.ty_cx.map.get(def_id.node) {\n                         NodeItem(_) => {\n-                            let mut result = ty::item_path_str(&self.analysis.ty_cx, def_id);\n-                            result.push_str(\"::\");\n-                            result\n+                            format!(\"::{}\", ty::item_path_str(&self.analysis.ty_cx, def_id))\n                         }\n                         _ => {\n                             self.sess.span_bug(method.span,\n@@ -340,7 +355,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             },\n         };\n \n-        qualname.push_str(get_ident(method.pe_ident()).get());\n+        let qualname = format!(\"{}::{}\", qualname, get_ident(method.pe_ident()).get());\n         let qualname = &qualname[];\n \n         // record the decl for this def (if it has one)\n@@ -435,7 +450,8 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n     }\n \n     // Dump generic params bindings, then visit_generics\n-    fn process_generic_params(&mut self, generics:&ast::Generics,\n+    fn process_generic_params(&mut self,\n+                              generics:&ast::Generics,\n                               full_span: Span,\n                               prefix: &str,\n                               id: NodeId) {\n@@ -465,7 +481,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                   decl: &ast::FnDecl,\n                   ty_params: &ast::Generics,\n                   body: &ast::Block) {\n-        let qualname = self.analysis.ty_cx.map.path_to_string(item.id);\n+        let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n \n         let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Fn);\n         self.fmt.fn_str(item.span,\n@@ -497,7 +513,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                       mt: ast::Mutability,\n                       expr: &ast::Expr)\n     {\n-        let qualname = self.analysis.ty_cx.map.path_to_string(item.id);\n+        let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n \n         // If the variable is immutable, save the initialising expression.\n         let value = match mt {\n@@ -525,7 +541,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                       typ: &ast::Ty,\n                       expr: &ast::Expr)\n     {\n-        let qualname = self.analysis.ty_cx.map.path_to_string(item.id);\n+        let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n \n         let sub_span = self.span.sub_span_after_keyword(item.span,\n                                                         keywords::Const);\n@@ -547,7 +563,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                       item: &ast::Item,\n                       def: &ast::StructDef,\n                       ty_params: &ast::Generics) {\n-        let qualname = self.analysis.ty_cx.map.path_to_string(item.id);\n+        let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n \n         let ctor_id = match def.ctor_id {\n             Some(node_id) => node_id,\n@@ -576,7 +592,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                     item: &ast::Item,\n                     enum_definition: &ast::EnumDef,\n                     ty_params: &ast::Generics) {\n-        let enum_name = self.analysis.ty_cx.map.path_to_string(item.id);\n+        let enum_name = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n         let val = self.span.snippet(item.span);\n         match self.span.sub_span_after_keyword(item.span, keywords::Enum) {\n             Some(sub_span) => self.fmt.enum_str(item.span,\n@@ -702,7 +718,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                      generics: &ast::Generics,\n                      trait_refs: &OwnedSlice<ast::TyParamBound>,\n                      methods: &Vec<ast::TraitItem>) {\n-        let qualname = self.analysis.ty_cx.map.path_to_string(item.id);\n+        let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n         let val = self.span.snippet(item.span);\n         let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Trait);\n         self.fmt.trait_str(item.span,\n@@ -751,7 +767,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n     fn process_mod(&mut self,\n                    item: &ast::Item,  // The module in question, represented as an item.\n                    m: &ast::Mod) {\n-        let qualname = self.analysis.ty_cx.map.path_to_string(item.id);\n+        let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n \n         let cm = self.sess.codemap();\n         let filename = cm.span_to_filename(m.inner);\n@@ -798,7 +814,13 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                                        sub_span,\n                                                        def_id,\n                                                        self.cur_scope),\n-            def::DefStaticMethod(declid, provenence) => {\n+            def::DefTy(def_id, _) => self.fmt.ref_str(recorder::TypeRef,\n+                                                      span,\n+                                                      sub_span,\n+                                                      def_id,\n+                                                      self.cur_scope),\n+            def::DefStaticMethod(declid, provenence) |\n+            def::DefMethod(declid, _, provenence) => {\n                 let sub_span = self.span.sub_span_for_meth_name(span);\n                 let defid = if declid.krate == ast::LOCAL_CRATE {\n                     let ti = ty::impl_or_trait_item(&self.analysis.ty_cx,\n@@ -840,13 +862,17 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                        Some(declid),\n                                        self.cur_scope);\n             },\n-            def::DefFn(def_id, _) => self.fmt.fn_call_str(span,\n-                                                          sub_span,\n-                                                          def_id,\n-                                                          self.cur_scope),\n+            def::DefFn(def_id, _) => {\n+                self.fmt.fn_call_str(span,\n+                                     sub_span,\n+                                     def_id,\n+                                     self.cur_scope)\n+            }\n             _ => self.sess.span_bug(span,\n-                                    &format!(\"Unexpected def kind while looking up path in '{}'\",\n-                                            self.span.snippet(span))[]),\n+                                    &format!(\"Unexpected def kind while looking \\\n+                                              up path in `{}`: `{:?}`\",\n+                                             self.span.snippet(span),\n+                                             *def)[]),\n         }\n         // modules or types in the path prefix\n         match *def {\n@@ -856,7 +882,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             def::DefConst(..) |\n             def::DefStruct(_) |\n             def::DefVariant(..) |\n-            def::DefFn(..) => self.write_sub_paths_truncated(path),\n+            def::DefFn(..) => self.write_sub_paths_truncated(path, false),\n             _ => {},\n         }\n     }\n@@ -870,21 +896,21 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             return\n         }\n \n-        let mut struct_def: Option<DefId> = None;\n-        match self.lookup_type_ref(ex.id) {\n-            Some(id) => {\n-                struct_def = Some(id);\n+        self.write_sub_paths_truncated(path, false);\n+\n+        let ty = &ty::expr_ty_adjusted(&self.analysis.ty_cx, ex).sty;\n+        let struct_def = match *ty {\n+            ty::ty_struct(def_id, _) => {\n                 let sub_span = self.span.span_for_last_ident(path.span);\n                 self.fmt.ref_str(recorder::StructRef,\n                                  path.span,\n                                  sub_span,\n-                                 id,\n+                                 def_id,\n                                  self.cur_scope);\n-            },\n-            None => ()\n-        }\n-\n-        self.write_sub_paths_truncated(path);\n+                Some(def_id)\n+            }\n+            _ => None\n+        };\n \n         for field in fields.iter() {\n             match struct_def {\n@@ -1070,7 +1096,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                                                mod_id,\n                                                get_ident(ident).get(),\n                                                self.cur_scope);\n-                        self.write_sub_paths_truncated(path);\n+                        self.write_sub_paths_truncated(path, true);\n                     }\n                     ast::ViewPathGlob(ref path) => {\n                         // Make a comma-separated list of names of imported modules.\n@@ -1093,7 +1119,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                                               item.id,\n                                               name_string.as_slice(),\n                                               self.cur_scope);\n-                        self.write_sub_paths(path);\n+                        self.write_sub_paths(path, true);\n                     }\n                     ast::ViewPathList(ref path, ref list) => {\n                         for plid in list.iter() {\n@@ -1117,28 +1143,28 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                             }\n                         }\n \n-                        self.write_sub_paths(path);\n+                        self.write_sub_paths(path, true);\n                     }\n                 }\n             }\n             ast::ItemExternCrate(ref s) => {\n                 let name = get_ident(item.ident);\n                 let name = name.get();\n-                let s = match *s {\n+                let location = match *s {\n                     Some((ref s, _)) => s.get().to_string(),\n                     None => name.to_string(),\n                 };\n-                let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Crate);\n+                let alias_span = self.span.span_for_last_ident(item.span);\n                 let cnum = match self.sess.cstore.find_extern_mod_stmt_cnum(item.id) {\n                     Some(cnum) => cnum,\n                     None => 0,\n                 };\n                 self.fmt.extern_crate_str(item.span,\n-                                          sub_span,\n+                                          alias_span,\n                                           item.id,\n                                           cnum,\n                                           name,\n-                                          &s[],\n+                                          &location[],\n                                           self.cur_scope);\n             }\n             ast::ItemFn(ref decl, _, _, ref ty_params, ref body) =>\n@@ -1164,7 +1190,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                 self.process_trait(item, generics, trait_refs, methods),\n             ast::ItemMod(ref m) => self.process_mod(item, m),\n             ast::ItemTy(ref ty, ref ty_params) => {\n-                let qualname = self.analysis.ty_cx.map.path_to_string(item.id);\n+                let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n                 let value = ty_to_string(&**ty);\n                 let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Type);\n                 self.fmt.typedef_str(item.span,\n@@ -1224,9 +1250,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                                                            ast_util::local_def(method_type.id)) {\n                     Some(def_id) => {\n                         scope_id = def_id.node;\n-                        let mut s = ty::item_path_str(&self.analysis.ty_cx, def_id);\n-                        s.push_str(\"::\");\n-                        s\n+                        format!(\"::{}::\", ty::item_path_str(&self.analysis.ty_cx, def_id))\n                     },\n                     None => {\n                         self.sess.span_bug(method_type.span,\n@@ -1283,7 +1307,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                     None => ()\n                 }\n \n-                self.write_sub_paths_truncated(path);\n+                self.write_sub_paths_truncated(path, false);\n \n                 visit::walk_path(self, path);\n             },\n@@ -1321,8 +1345,8 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                 }\n \n                 self.visit_expr(&**sub_ex);\n-\n-                match ty::expr_ty_adjusted(&self.analysis.ty_cx, &**sub_ex).sty {\n+                let ty = &ty::expr_ty_adjusted(&self.analysis.ty_cx, &**sub_ex).sty;\n+                match *ty {\n                     ty::ty_struct(def_id, _) => {\n                         let fields = ty::lookup_struct_fields(&self.analysis.ty_cx, def_id);\n                         for f in fields.iter() {\n@@ -1336,9 +1360,9 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                                 break;\n                             }\n                         }\n-                    },\n+                    }\n                     _ => self.sess.span_bug(ex.span,\n-                                            \"Expected struct type, but not ty_struct\"),\n+                                            &format!(\"Expected struct type, found {:?}\", ty)[]),\n                 }\n             },\n             ast::ExprTupField(ref sub_ex, idx) => {\n@@ -1348,12 +1372,13 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n \n                 self.visit_expr(&**sub_ex);\n \n-                match ty::expr_ty_adjusted(&self.analysis.ty_cx, &**sub_ex).sty {\n+                let ty = &ty::expr_ty_adjusted(&self.analysis.ty_cx, &**sub_ex).sty;\n+                match *ty {\n                     ty::ty_struct(def_id, _) => {\n                         let fields = ty::lookup_struct_fields(&self.analysis.ty_cx, def_id);\n                         for (i, f) in fields.iter().enumerate() {\n                             if i == idx.node {\n-                                let sub_span = self.span.span_for_last_ident(ex.span);\n+                                let sub_span = self.span.sub_span_after_token(ex.span, token::Dot);\n                                 self.fmt.ref_str(recorder::VarRef,\n                                                  ex.span,\n                                                  sub_span,\n@@ -1362,9 +1387,11 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                                 break;\n                             }\n                         }\n-                    },\n+                    }\n+                    ty::ty_tup(_) => {}\n                     _ => self.sess.span_bug(ex.span,\n-                                            \"Expected struct type, but not ty_struct\"),\n+                                            &format!(\"Expected struct or tuple \\\n+                                                      type, found {:?}\", ty)[]),\n                 }\n             },\n             ast::ExprClosure(_, _, ref decl, ref body) => {\n@@ -1440,7 +1467,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                                           &value[],\n                                           \"\")\n                 }\n-                def::DefVariant(..) => {\n+                def::DefVariant(..) | def::DefTy(..) | def::DefStruct(..) => {\n                     paths_to_process.push((id, p.clone(), Some(ref_kind)))\n                 }\n                 // FIXME(nrc) what are these doing here?\n@@ -1568,8 +1595,7 @@ pub fn process_crate(sess: &Session,\n                         SpanUtils {\n                             sess: sess,\n                             err_count: Cell::new(0)\n-                        },\n-                        cratename.clone()),\n+                        }),\n         span: SpanUtils {\n             sess: sess,\n             err_count: Cell::new(0)"}, {"sha": "1378d40920808570c6ae64f2ba761e85bee149d3", "filename": "src/librustc_trans/save/recorder.rs", "status": "modified", "additions": 10, "deletions": 21, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Frecorder.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -50,7 +50,6 @@ impl Recorder {\n pub struct FmtStrs<'a> {\n     pub recorder: Box<Recorder>,\n     span: SpanUtils<'a>,\n-    krate: String,\n }\n \n macro_rules! s { ($e:expr) => { format!(\"{}\", $e) }}\n@@ -63,7 +62,7 @@ macro_rules! svec {\n     })\n }\n \n-#[derive(Copy,Debug)]\n+#[derive(Copy, Debug, Eq, PartialEq)]\n pub enum Row {\n     Variable,\n     Enum,\n@@ -92,11 +91,10 @@ pub enum Row {\n }\n \n impl<'a> FmtStrs<'a> {\n-    pub fn new(rec: Box<Recorder>, span: SpanUtils<'a>, krate: String) -> FmtStrs<'a> {\n+    pub fn new(rec: Box<Recorder>, span: SpanUtils<'a>) -> FmtStrs<'a> {\n         FmtStrs {\n             recorder: rec,\n             span: span,\n-            krate: krate,\n         }\n     }\n \n@@ -177,16 +175,7 @@ impl<'a> FmtStrs<'a> {\n         });\n \n         let pairs = fields.iter().zip(values);\n-        let strs = pairs.map(|(f, v)| format!(\",{},\\\"{}\\\"\", f, escape(\n-            if *f == \"qualname\" && v.len() > 0 {\n-                let mut n = self.krate.clone();\n-                n.push_str(\"::\");\n-                n.push_str(v);\n-                n\n-            } else {\n-                String::from_str(v)\n-            }\n-        )));\n+        let strs = pairs.map(|(f, v)| format!(\",{},\\\"{}\\\"\", f, escape(String::from_str(v))));\n         Some(strs.fold(String::new(), |mut s, ss| {\n             s.push_str(&ss[]);\n             s\n@@ -507,13 +496,13 @@ impl<'a> FmtStrs<'a> {\n     }\n \n     pub fn extern_crate_str(&mut self,\n-                          span: Span,\n-                          sub_span: Option<Span>,\n-                          id: NodeId,\n-                          cnum: ast::CrateNum,\n-                          name: &str,\n-                          loc: &str,\n-                          parent: NodeId) {\n+                            span: Span,\n+                            sub_span: Option<Span>,\n+                            id: NodeId,\n+                            cnum: ast::CrateNum,\n+                            name: &str,\n+                            loc: &str,\n+                            parent: NodeId) {\n         self.check_and_record(ExternCrate,\n                               span,\n                               sub_span,"}, {"sha": "419ccfa312ef74591a93926729ef968239a05591", "filename": "src/librustc_trans/save/span_utils.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -37,7 +37,7 @@ impl<'a> SpanUtils<'a> {\n         let lo_pos_byte = self.sess.codemap().lookup_byte_offset(span.lo).pos;\n         let hi_pos_byte = self.sess.codemap().lookup_byte_offset(span.hi).pos;\n \n-        format!(\"file_name,{},file_line,{},file_col,{},extent_start,{},extent_start_bytes,{},\\\n+        format!(\"file_name,\\\"{}\\\",file_line,{},file_col,{},extent_start,{},extent_start_bytes,{},\\\n                  file_line_end,{},file_col_end,{},extent_end,{},extent_end_bytes,{}\",\n                 lo_loc.file.name,\n                 lo_loc.line, lo_loc.col.to_usize(), lo_pos.to_usize(), lo_pos_byte.to_usize(),\n@@ -205,6 +205,7 @@ impl<'a> SpanUtils<'a> {\n             bracket_count += match prev.tok {\n                 token::Lt => 1,\n                 token::Gt => -1,\n+                token::BinOp(token::Shl) => 2,\n                 token::BinOp(token::Shr) => -2,\n                 _ => 0\n             };\n@@ -236,7 +237,7 @@ impl<'a> SpanUtils<'a> {\n \n         let mut toks = self.retokenise_span(span);\n         // We keep track of how many brackets we're nested in\n-        let mut bracket_count = 0i;\n+        let mut bracket_count = 0;\n         loop {\n             let ts = toks.real_token();\n             if ts.tok == token::Eof {\n@@ -296,13 +297,25 @@ impl<'a> SpanUtils<'a> {\n     pub fn sub_span_after_keyword(&self,\n                                   span: Span,\n                                   keyword: keywords::Keyword) -> Option<Span> {\n+        self.sub_span_after(span, |t| t.is_keyword(keyword))\n+    }\n+\n+    pub fn sub_span_after_token(&self,\n+                                span: Span,\n+                                tok: Token) -> Option<Span> {\n+        self.sub_span_after(span, |t| t == tok)\n+    }\n+\n+    fn sub_span_after<F: Fn(Token) -> bool>(&self,\n+                                            span: Span,\n+                                            f: F) -> Option<Span> {\n         let mut toks = self.retokenise_span(span);\n         loop {\n             let ts = toks.real_token();\n             if ts.tok == token::Eof {\n                 return None;\n             }\n-            if ts.tok.is_keyword(keyword) {\n+            if f(ts.tok) {\n                 let ts = toks.real_token();\n                 if ts.tok == token::Eof {\n                     return None\n@@ -313,6 +326,7 @@ impl<'a> SpanUtils<'a> {\n         }\n     }\n \n+\n     // Returns a list of the spans of idents in a patch.\n     // E.g., For foo::bar<x,t>::baz, we return [foo, bar, baz] (well, their spans)\n     pub fn spans_for_path_segments(&self, path: &ast::Path) -> Vec<Span> {"}, {"sha": "50dfbff0034d1ac2270c69a7e910867e2d2c2272", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 1, "deletions": 26, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -1078,7 +1078,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let sw = if kind == Switch {\n         build::Switch(bcx, test_val, else_cx.llbb, opts.len())\n     } else {\n-        C_int(ccx, 0i) // Placeholder for when not using a switch\n+        C_int(ccx, 0) // Placeholder for when not using a switch\n     };\n \n     let defaults = enter_default(else_cx, dm, m, col, val);\n@@ -1537,31 +1537,6 @@ pub fn store_arg<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     }\n }\n \n-/// Generates code for the pattern binding in a `for` loop like\n-/// `for <pat> in <expr> { ... }`.\n-pub fn store_for_loop_binding<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                          pat: &ast::Pat,\n-                                          llvalue: ValueRef,\n-                                          body_scope: cleanup::ScopeId)\n-                                          -> Block<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"match::store_for_loop_binding\");\n-\n-    if simple_identifier(&*pat).is_some() &&\n-       bcx.sess().opts.debuginfo != FullDebugInfo {\n-        // Generate nicer LLVM for the common case of a `for` loop pattern\n-        // like `for x in blahblah { ... }`.\n-        let binding_type = node_id_type(bcx, pat.id);\n-        bcx.fcx.lllocals.borrow_mut().insert(pat.id,\n-                                             Datum::new(llvalue,\n-                                                        binding_type,\n-                                                        Lvalue));\n-        return bcx\n-    }\n-\n-    // General path. Copy out the values that are used in the pattern.\n-    bind_irrefutable_pat(bcx, pat, llvalue, body_scope)\n-}\n-\n fn mk_binding_alloca<'blk, 'tcx, A, F>(bcx: Block<'blk, 'tcx>,\n                                        p_id: ast::NodeId,\n                                        ident: &ast::Ident,"}, {"sha": "1b212aca33034e25a92ce773b0e1b264a5207d01", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 25, "deletions": 18, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -623,7 +623,7 @@ pub fn compare_simd_types<'blk, 'tcx>(\n                     size: uint,\n                     op: ast::BinOp)\n                     -> ValueRef {\n-    match t.sty {\n+    let cmp = match t.sty {\n         ty::ty_float(_) => {\n             // The comparison operators for floating point vectors are challenging.\n             // LLVM outputs a `< size x i1 >`, but if we perform a sign extension\n@@ -632,25 +632,32 @@ pub fn compare_simd_types<'blk, 'tcx>(\n             cx.sess().bug(\"compare_simd_types: comparison operators \\\n                            not supported for floating point SIMD types\")\n         },\n-        ty::ty_uint(_) | ty::ty_int(_) => {\n-            let cmp = match op.node {\n-                ast::BiEq => llvm::IntEQ,\n-                ast::BiNe => llvm::IntNE,\n-                ast::BiLt => llvm::IntSLT,\n-                ast::BiLe => llvm::IntSLE,\n-                ast::BiGt => llvm::IntSGT,\n-                ast::BiGe => llvm::IntSGE,\n-                _ => cx.sess().bug(\"compare_simd_types: must be a comparison operator\"),\n-            };\n-            let return_ty = Type::vector(&type_of(cx.ccx(), t), size as u64);\n-            // LLVM outputs an `< size x i1 >`, so we need to perform a sign extension\n-            // to get the correctly sized type. This will compile to a single instruction\n-            // once the IR is converted to assembly if the SIMD instruction is supported\n-            // by the target architecture.\n-            SExt(cx, ICmp(cx, cmp, lhs, rhs), return_ty)\n+        ty::ty_uint(_) => match op.node {\n+            ast::BiEq => llvm::IntEQ,\n+            ast::BiNe => llvm::IntNE,\n+            ast::BiLt => llvm::IntULT,\n+            ast::BiLe => llvm::IntULE,\n+            ast::BiGt => llvm::IntUGT,\n+            ast::BiGe => llvm::IntUGE,\n+            _ => cx.sess().bug(\"compare_simd_types: must be a comparison operator\"),\n+        },\n+        ty::ty_int(_) => match op.node {\n+            ast::BiEq => llvm::IntEQ,\n+            ast::BiNe => llvm::IntNE,\n+            ast::BiLt => llvm::IntSLT,\n+            ast::BiLe => llvm::IntSLE,\n+            ast::BiGt => llvm::IntSGT,\n+            ast::BiGe => llvm::IntSGE,\n+            _ => cx.sess().bug(\"compare_simd_types: must be a comparison operator\"),\n         },\n         _ => cx.sess().bug(\"compare_simd_types: invalid SIMD type\"),\n-    }\n+    };\n+    let return_ty = Type::vector(&type_of(cx.ccx(), t), size as u64);\n+    // LLVM outputs an `< size x i1 >`, so we need to perform a sign extension\n+    // to get the correctly sized type. This will compile to a single instruction\n+    // once the IR is converted to assembly if the SIMD instruction is supported\n+    // by the target architecture.\n+    SExt(cx, ICmp(cx, cmp, lhs, rhs), return_ty)\n }\n \n // Iterates through the elements of a structural type."}, {"sha": "c4388603145fe2796b46a0926ef3d7e57c135cb2", "filename": "src/librustc_trans/trans/controlflow.rs", "status": "modified", "additions": 0, "deletions": 136, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -11,26 +11,19 @@\n use llvm::ValueRef;\n use middle::def;\n use middle::lang_items::{PanicFnLangItem, PanicBoundsCheckFnLangItem};\n-use trans::_match;\n-use trans::adt;\n use trans::base::*;\n use trans::build::*;\n use trans::callee;\n use trans::cleanup::CleanupMethods;\n use trans::cleanup;\n use trans::common::*;\n use trans::consts;\n-use trans::datum;\n use trans::debuginfo;\n use trans::debuginfo::{DebugLoc, ToDebugLoc};\n use trans::expr;\n-use trans::meth;\n-use trans::type_::Type;\n use trans;\n use middle::ty;\n-use middle::ty::MethodCall;\n use util::ppaux::Repr;\n-use util::ppaux;\n \n use syntax::ast;\n use syntax::ast::Ident;\n@@ -259,135 +252,6 @@ pub fn trans_while<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     return next_bcx_in;\n }\n \n-/// Translates a `for` loop.\n-pub fn trans_for<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n-                             loop_info: NodeIdAndSpan,\n-                             pat: &ast::Pat,\n-                             head: &ast::Expr,\n-                             body: &ast::Block)\n-                             -> Block<'blk, 'tcx>\n-{\n-    let _icx = push_ctxt(\"trans_for\");\n-\n-    //            bcx\n-    //             |\n-    //      loopback_bcx_in  <-------+\n-    //             |                 |\n-    //      loopback_bcx_out         |\n-    //           |      |            |\n-    //           |    body_bcx_in    |\n-    // cleanup_blk      |            |\n-    //    |           body_bcx_out --+\n-    // next_bcx_in\n-\n-    // Codegen the head to create the iterator value.\n-    let iterator_datum =\n-        unpack_datum!(bcx, expr::trans_to_lvalue(bcx, head, \"for_head\"));\n-    let iterator_type = node_id_type(bcx, head.id);\n-    debug!(\"iterator type is {}, datum type is {}\",\n-           ppaux::ty_to_string(bcx.tcx(), iterator_type),\n-           ppaux::ty_to_string(bcx.tcx(), iterator_datum.ty));\n-\n-    let lliterator = load_ty(bcx, iterator_datum.val, iterator_datum.ty);\n-\n-    // Create our basic blocks and set up our loop cleanups.\n-    let next_bcx_in = bcx.fcx.new_id_block(\"for_exit\", loop_info.id);\n-    let loopback_bcx_in = bcx.fcx.new_id_block(\"for_loopback\", head.id);\n-    let body_bcx_in = bcx.fcx.new_id_block(\"for_body\", body.id);\n-    bcx.fcx.push_loop_cleanup_scope(loop_info.id,\n-                                    [next_bcx_in, loopback_bcx_in]);\n-    Br(bcx, loopback_bcx_in.llbb, DebugLoc::None);\n-    let cleanup_llbb = bcx.fcx.normal_exit_block(loop_info.id,\n-                                                 cleanup::EXIT_BREAK);\n-\n-    // Set up the method call (to `.next()`).\n-    let method_call = MethodCall::expr(loop_info.id);\n-    let method_type = (*loopback_bcx_in.tcx()\n-                                     .method_map\n-                                     .borrow())[method_call]\n-                                     .ty;\n-    let method_type = monomorphize_type(loopback_bcx_in, method_type);\n-    let method_result_type =\n-        ty::assert_no_late_bound_regions( // LB regions are instantiated in invoked methods\n-            loopback_bcx_in.tcx(), &ty::ty_fn_ret(method_type)).unwrap();\n-    let option_cleanup_scope = body_bcx_in.fcx.push_custom_cleanup_scope();\n-    let option_cleanup_scope_id = cleanup::CustomScope(option_cleanup_scope);\n-\n-    // Compile the method call (to `.next()`).\n-    let mut loopback_bcx_out = loopback_bcx_in;\n-    let option_datum =\n-        unpack_datum!(loopback_bcx_out,\n-                      datum::lvalue_scratch_datum(loopback_bcx_out,\n-                                                  method_result_type,\n-                                                  \"loop_option\",\n-                                                  false,\n-                                                  option_cleanup_scope_id,\n-                                                  (),\n-                                                  |(), bcx, lloption| {\n-        let Result {\n-            bcx,\n-            val: _\n-        } = callee::trans_call_inner(bcx,\n-                                     Some(loop_info),\n-                                     method_type,\n-                                     |bcx, arg_cleanup_scope| {\n-                                         meth::trans_method_callee(\n-                                             bcx,\n-                                             method_call,\n-                                             None,\n-                                             arg_cleanup_scope)\n-                                     },\n-                                     callee::ArgVals(&[lliterator]),\n-                                     Some(expr::SaveIn(lloption)));\n-        bcx\n-    }));\n-\n-    // Check the discriminant; if the `None` case, exit the loop.\n-    let option_representation = adt::represent_type(loopback_bcx_out.ccx(),\n-                                                    method_result_type);\n-    let lldiscriminant = adt::trans_get_discr(loopback_bcx_out,\n-                                              &*option_representation,\n-                                              option_datum.val,\n-                                              None);\n-    let i1_type = Type::i1(loopback_bcx_out.ccx());\n-    let llcondition = Trunc(loopback_bcx_out, lldiscriminant, i1_type);\n-    CondBr(loopback_bcx_out, llcondition, body_bcx_in.llbb, cleanup_llbb, DebugLoc::None);\n-\n-    // Now we're in the body. Unpack the `Option` value into the programmer-\n-    // supplied pattern.\n-    let llpayload = adt::trans_field_ptr(body_bcx_in,\n-                                         &*option_representation,\n-                                         option_datum.val,\n-                                         1,\n-                                         0);\n-    let binding_cleanup_scope = body_bcx_in.fcx.push_custom_cleanup_scope();\n-    let binding_cleanup_scope_id =\n-        cleanup::CustomScope(binding_cleanup_scope);\n-    let mut body_bcx_out =\n-        _match::store_for_loop_binding(body_bcx_in,\n-                                       pat,\n-                                       llpayload,\n-                                       binding_cleanup_scope_id);\n-\n-    debuginfo::create_for_loop_var_metadata(body_bcx_in, pat);\n-\n-    // Codegen the body.\n-    body_bcx_out = trans_block(body_bcx_out, body, expr::Ignore);\n-    body_bcx_out =\n-        body_bcx_out.fcx\n-                    .pop_and_trans_custom_cleanup_scope(body_bcx_out,\n-                                                        binding_cleanup_scope);\n-    body_bcx_out =\n-        body_bcx_out.fcx\n-                    .pop_and_trans_custom_cleanup_scope(body_bcx_out,\n-                                                        option_cleanup_scope);\n-    Br(body_bcx_out, loopback_bcx_in.llbb, DebugLoc::None);\n-\n-    // Codegen cleanups and leave.\n-    next_bcx_in.fcx.pop_loop_cleanup_scope(loop_info.id);\n-    next_bcx_in\n-}\n-\n pub fn trans_loop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                               loop_expr: &ast::Expr,\n                               body: &ast::Block)"}, {"sha": "4f9c97795e1987428575ae03b5ae03237bf7d272", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 3, "deletions": 60, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -1053,48 +1053,6 @@ pub fn create_argument_metadata(bcx: Block, arg: &ast::Arg) {\n     })\n }\n \n-/// Creates debug information for the given for-loop variable.\n-///\n-/// This function assumes that there's a datum for each pattern component of the\n-/// loop variable in `bcx.fcx.lllocals`.\n-/// Adds the created metadata nodes directly to the crate's IR.\n-pub fn create_for_loop_var_metadata(bcx: Block, pat: &ast::Pat) {\n-    if bcx.unreachable.get() ||\n-       fn_should_be_ignored(bcx.fcx) ||\n-       bcx.sess().opts.debuginfo != FullDebugInfo {\n-        return;\n-    }\n-\n-    let def_map = &bcx.tcx().def_map;\n-    let locals = bcx.fcx.lllocals.borrow();\n-\n-    pat_util::pat_bindings(def_map, pat, |_, node_id, span, var_ident| {\n-        let datum = match locals.get(&node_id) {\n-            Some(datum) => datum,\n-            None => {\n-                bcx.sess().span_bug(span,\n-                    format!(\"no entry in lllocals table for {}\",\n-                            node_id).as_slice());\n-            }\n-        };\n-\n-        if unsafe { llvm::LLVMIsAAllocaInst(datum.val) } == ptr::null_mut() {\n-            bcx.sess().span_bug(span, \"debuginfo::create_for_loop_var_metadata() - \\\n-                                       Referenced variable location is not an alloca!\");\n-        }\n-\n-        let scope_metadata = scope_metadata(bcx.fcx, node_id, span);\n-\n-        declare_local(bcx,\n-                      var_ident.node,\n-                      datum.ty,\n-                      scope_metadata,\n-                      DirectVariable { alloca: datum.val },\n-                      LocalVariable,\n-                      span);\n-    })\n-}\n-\n pub fn get_cleanup_debug_loc_for_ast_node<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                                     node_id: ast::NodeId,\n                                                     node_span: Span,\n@@ -3627,24 +3585,9 @@ fn create_scope_map(cx: &CrateContext,\n                                               Found unexpanded while-let.\");\n             }\n \n-            ast::ExprForLoop(ref pattern, ref head, ref body, _) => {\n-                walk_expr(cx, &**head, scope_stack, scope_map);\n-\n-                with_new_scope(cx,\n-                               exp.span,\n-                               scope_stack,\n-                               scope_map,\n-                               |cx, scope_stack, scope_map| {\n-                    scope_map.insert(exp.id,\n-                                     scope_stack.last()\n-                                                .unwrap()\n-                                                .scope_metadata);\n-                    walk_pattern(cx,\n-                                 &**pattern,\n-                                 scope_stack,\n-                                 scope_map);\n-                    walk_block(cx, &**body, scope_stack, scope_map);\n-                })\n+            ast::ExprForLoop(..) => {\n+                cx.sess().span_bug(exp.span, \"debuginfo::create_scope_map() - \\\n+                                              Found unexpanded for loop.\");\n             }\n \n             ast::ExprMac(_) => {"}, {"sha": "46726f78d04f571e2b8616ec4bfb072a38180007", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -927,13 +927,6 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         ast::ExprWhile(ref cond, ref body, _) => {\n             controlflow::trans_while(bcx, expr, &**cond, &**body)\n         }\n-        ast::ExprForLoop(ref pat, ref head, ref body, _) => {\n-            controlflow::trans_for(bcx,\n-                                   expr_info(expr),\n-                                   &**pat,\n-                                   &**head,\n-                                   &**body)\n-        }\n         ast::ExprLoop(ref body, _) => {\n             controlflow::trans_loop(bcx, expr, &**body)\n         }"}, {"sha": "6c017866ef07ceda4690fd97b8161132c609018f", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -973,9 +973,9 @@ pub fn lltype_for_foreign_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n fn add_argument_attributes(tys: &ForeignTypes,\n                            llfn: ValueRef) {\n     let mut i = if tys.fn_ty.ret_ty.is_indirect() {\n-        1i\n+        1\n     } else {\n-        0i\n+        0\n     };\n \n     match tys.fn_ty.ret_ty.attr {"}, {"sha": "358e38a671d6d3aecc3f4f3305e5e45000291e82", "filename": "src/librustc_trans/trans/tvec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -499,7 +499,7 @@ pub fn iter_vec_raw<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n         CondBr(header_bcx, not_yet_at_end, body_bcx.llbb, next_bcx.llbb, DebugLoc::None);\n         let body_bcx = f(body_bcx, data_ptr, vt.unit_ty);\n         AddIncomingToPhi(data_ptr, InBoundsGEP(body_bcx, data_ptr,\n-                                               &[C_int(bcx.ccx(), 1i)]),\n+                                               &[C_int(bcx.ccx(), 1)]),\n                          body_bcx.llbb);\n         Br(body_bcx, header_bcx.llbb, DebugLoc::None);\n         next_bcx"}, {"sha": "9dcde1c2a0a50cc9cb4ed5438d2bec8526b6b6e5", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 104, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -87,7 +87,6 @@ use check::_match::pat_ctxt;\n use fmt_macros::{Parser, Piece, Position};\n use middle::{const_eval, def};\n use middle::infer;\n-use middle::lang_items::IteratorItem;\n use middle::mem_categorization as mc;\n use middle::mem_categorization::McResult;\n use middle::pat_util::{self, pat_id_map};\n@@ -1862,7 +1861,7 @@ pub enum LvaluePreference {\n }\n \n /// Whether `autoderef` requires types to resolve.\n-#[derive(Copy, Show, PartialEq, Eq)]\n+#[derive(Copy, Debug, PartialEq, Eq)]\n pub enum UnresolvedTypeAction {\n     /// Produce an error and return `ty_err` whenever a type cannot\n     /// be resolved (i.e. it is `ty_infer`).\n@@ -2136,92 +2135,6 @@ fn try_index_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     })\n }\n \n-/// Given the head of a `for` expression, looks up the `next` method in the\n-/// `Iterator` trait. Panics if the expression does not implement `next`.\n-///\n-/// The return type of this function represents the concrete element type\n-/// `A` in the type `Iterator<A>` that the method returns.\n-fn lookup_method_for_for_loop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                        iterator_expr: &ast::Expr,\n-                                        loop_id: ast::NodeId)\n-                                        -> Ty<'tcx> {\n-    let trait_did = match fcx.tcx().lang_items.require(IteratorItem) {\n-        Ok(trait_did) => trait_did,\n-        Err(ref err_string) => {\n-            span_err!(fcx.tcx().sess, iterator_expr.span, E0233,\n-                                    \"{}\", &err_string[]);\n-            return fcx.tcx().types.err\n-        }\n-    };\n-\n-    let expr_type = fcx.expr_ty(&*iterator_expr);\n-    let method = method::lookup_in_trait(fcx,\n-                                         iterator_expr.span,\n-                                         Some(&*iterator_expr),\n-                                         token::intern(\"next\"),\n-                                         trait_did,\n-                                         expr_type,\n-                                         None);\n-\n-    // Regardless of whether the lookup succeeds, check the method arguments\n-    // so that we have *some* type for each argument.\n-    let method_type = match method {\n-        Some(ref method) => method.ty,\n-        None => {\n-            let true_expr_type = fcx.infcx().resolve_type_vars_if_possible(&expr_type);\n-\n-            if !ty::type_is_error(true_expr_type) {\n-                let ty_string = fcx.infcx().ty_to_string(true_expr_type);\n-                span_err!(fcx.tcx().sess, iterator_expr.span, E0234,\n-                                        \"`for` loop expression has type `{}` which does \\\n-                                                not implement the `Iterator` trait; \\\n-                                                maybe try .iter()\", ty_string);\n-            }\n-            fcx.tcx().types.err\n-        }\n-    };\n-    let return_type = check_method_argument_types(fcx,\n-                                                  iterator_expr.span,\n-                                                  method_type,\n-                                                  iterator_expr,\n-                                                  &[],\n-                                                  AutorefArgs::No,\n-                                                  DontTupleArguments,\n-                                                  NoExpectation);\n-\n-    match method {\n-        Some(method) => {\n-            fcx.inh.method_map.borrow_mut().insert(MethodCall::expr(loop_id),\n-                                                   method);\n-\n-            // We expect the return type to be `Option` or something like it.\n-            // Grab the first parameter of its type substitution.\n-            let return_type = match return_type {\n-                ty::FnConverging(return_type) =>\n-                    structurally_resolved_type(fcx, iterator_expr.span, return_type),\n-                ty::FnDiverging => fcx.tcx().types.err\n-            };\n-            match return_type.sty {\n-                ty::ty_enum(_, ref substs)\n-                        if !substs.types.is_empty_in(subst::TypeSpace) => {\n-                    *substs.types.get(subst::TypeSpace, 0)\n-                }\n-                ty::ty_err => {\n-                    fcx.tcx().types.err\n-                }\n-                _ => {\n-                    span_err!(fcx.tcx().sess, iterator_expr.span, E0239,\n-                                            \"`next` method of the `Iterator` \\\n-                                                    trait has an unexpected type `{}`\",\n-                                                    fcx.infcx().ty_to_string(return_type));\n-                    fcx.tcx().types.err\n-                }\n-            }\n-        }\n-        None => fcx.tcx().types.err\n-    }\n-}\n-\n fn check_method_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                          sp: Span,\n                                          method_fn_ty: Ty<'tcx>,\n@@ -3758,22 +3671,8 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n       ast::ExprWhileLet(..) => {\n         tcx.sess.span_bug(expr.span, \"non-desugared ExprWhileLet\");\n       }\n-      ast::ExprForLoop(ref pat, ref head, ref block, _) => {\n-        check_expr(fcx, &**head);\n-        let typ = lookup_method_for_for_loop(fcx, &**head, expr.id);\n-        vtable::select_new_fcx_obligations(fcx);\n-\n-        debug!(\"ExprForLoop each item has type {}\",\n-               fcx.infcx().resolve_type_vars_if_possible(&typ).repr(fcx.tcx()));\n-\n-        let pcx = pat_ctxt {\n-            fcx: fcx,\n-            map: pat_id_map(&tcx.def_map, &**pat),\n-        };\n-        _match::check_pat(&pcx, &**pat, typ);\n-\n-        check_block_no_value(fcx, &**block);\n-        fcx.write_nil(id);\n+      ast::ExprForLoop(..) => {\n+        tcx.sess.span_bug(expr.span, \"non-desugared ExprForLoop\");\n       }\n       ast::ExprLoop(ref body, _) => {\n         check_block_no_value(fcx, &**body);"}, {"sha": "f8c7055a003685ff5a10535360982ee1236dd58d", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -658,30 +658,6 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n             rcx.set_repeating_scope(repeating_scope);\n         }\n \n-        ast::ExprForLoop(ref pat, ref head, ref body, _) => {\n-            constrain_bindings_in_pat(&**pat, rcx);\n-\n-            {\n-                let mc = mc::MemCategorizationContext::new(rcx.fcx);\n-                let pat_ty = rcx.resolve_node_type(pat.id);\n-                let pat_cmt = mc.cat_rvalue(pat.id,\n-                                            pat.span,\n-                                            ty::ReScope(CodeExtent::from_node_id(body.id)),\n-                                            pat_ty);\n-                link_pattern(rcx, mc, pat_cmt, &**pat);\n-            }\n-\n-            rcx.visit_expr(&**head);\n-            type_of_node_must_outlive(rcx,\n-                                      infer::AddrOf(expr.span),\n-                                      head.id,\n-                                      ty::ReScope(CodeExtent::from_node_id(expr.id)));\n-\n-            let repeating_scope = rcx.set_repeating_scope(body.id);\n-            rcx.visit_block(&**body);\n-            rcx.set_repeating_scope(repeating_scope);\n-        }\n-\n         _ => {\n             visit::walk_expr(rcx, expr);\n         }"}, {"sha": "68f5ec9c8c2705eb710e0f05e0ade6a9bdd6adef", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -65,24 +65,25 @@ This API is completely unstable and subject to change.\n \n #![crate_name = \"rustc_typeck\"]\n #![unstable(feature = \"rustc_private\")]\n-#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n-#![allow(unknown_features)]\n-#![feature(quote)]\n-#![feature(slicing_syntax, unsafe_destructor)]\n-#![feature(box_syntax)]\n-#![feature(rustc_diagnostic_macros)]\n-#![allow(unknown_features)] #![feature(int_uint)]\n #![allow(non_camel_case_types)]\n+#![cfg_attr(not(stage0), allow(unused_mut))] // NOTE: remove after stage0 snap\n+\n+#![feature(box_syntax)]\n #![feature(collections)]\n #![feature(core)]\n+#![feature(int_uint)]\n+#![feature(quote)]\n+#![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n+#![feature(slicing_syntax, unsafe_destructor)]\n+#![feature(staged_api)]\n #![feature(std_misc)]\n \n #[macro_use] extern crate log;"}, {"sha": "6c5950e4df5bab540f01fc43893f299dc6acd096", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -793,7 +793,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                     trait_def.generics.types.as_slice(),\n                     trait_def.generics.regions.as_slice(),\n                     trait_ref.substs,\n-                    variance);\n+                    self.invariant);\n             }\n \n             ty::ty_trait(ref data) => {"}, {"sha": "fe502922ffdf280b7ddd08f284e82b19b1373349", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -2249,7 +2249,7 @@ impl Clean<ViewListIdent> for ast::PathListItem {\n                 source: resolve_def(cx, id)\n             },\n             ast::PathListMod { id } => ViewListIdent {\n-                name: \"mod\".to_string(),\n+                name: \"self\".to_string(),\n                 source: resolve_def(cx, id)\n             }\n         }"}, {"sha": "7e08226019f9849ca56a1f7e7538a59201381f31", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -420,7 +420,7 @@ impl LangString {\n         let mut seen_other_tags = false;\n         let mut data = LangString::all_false();\n \n-        let mut tokens = string.split(|&: c: char|\n+        let tokens = string.split(|&: c: char|\n             !(c == '_' || c == '-' || c.is_alphanumeric())\n         );\n "}, {"sha": "8a007fb035e30772e38531d100da9890d8ae46eb", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -1942,7 +1942,7 @@ fn item_enum(w: &mut fmt::Formatter, it: &clean::Item,\n                 clean::VariantItem(ref var) => {\n                     match var.kind {\n                         clean::StructVariant(ref s) => {\n-                            let mut fields = s.fields.iter().filter(|f| {\n+                            let fields = s.fields.iter().filter(|f| {\n                                 match f.inner {\n                                     clean::StructFieldItem(ref t) => match *t {\n                                         clean::HiddenStructField => false,"}, {"sha": "29e52d627cdfe8c98eaad8ed5d1476edd28f3313", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -10,28 +10,29 @@\n \n #![crate_name = \"rustdoc\"]\n #![unstable(feature = \"rustdoc\")]\n-#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n-#![feature(slicing_syntax)]\n+\n #![feature(box_syntax)]\n-#![allow(unknown_features)] #![feature(int_uint)]\n #![feature(collections)]\n #![feature(core)]\n+#![feature(hash)]\n+#![feature(int_uint)]\n #![feature(io)]\n #![feature(libc)]\n #![feature(os)]\n #![feature(path)]\n #![feature(rustc_private)]\n+#![feature(slicing_syntax)]\n+#![feature(staged_api)]\n #![feature(std_misc)]\n #![feature(test)]\n #![feature(unicode)]\n-#![feature(hash)]\n \n extern crate arena;\n extern crate getopts;"}, {"sha": "c9b6af26ce0c3b6ca26b8367d657d33016e68bb4", "filename": "src/libserialize/hex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibserialize%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibserialize%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fhex.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -116,7 +116,7 @@ impl FromHex for str {\n     fn from_hex(&self) -> Result<Vec<u8>, FromHexError> {\n         // This may be an overestimate if there is any whitespace\n         let mut b = Vec::with_capacity(self.len() / 2);\n-        let mut modulus = 0i;\n+        let mut modulus = 0;\n         let mut buf = 0u8;\n \n         for (idx, byte) in self.bytes().enumerate() {"}, {"sha": "8d8bd32ba77a1cf00fea87f8fa5c0e83b476a7d1", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -2127,7 +2127,7 @@ macro_rules! read_primitive {\n                 Json::F64(f) => Err(ExpectedError(\"Integer\".to_string(), format!(\"{}\", f))),\n                 // re: #12967.. a type w/ numeric keys (ie HashMap<uint, V> etc)\n                 // is going to have a string here, as per JSON spec.\n-                Json::String(s) => match s.parse() {\n+                Json::String(s) => match s.parse().ok() {\n                     Some(f) => Ok(f),\n                     None => Err(ExpectedError(\"Number\".to_string(), s)),\n                 },\n@@ -2165,7 +2165,7 @@ impl ::Decoder for Decoder {\n             Json::String(s) => {\n                 // re: #12967.. a type w/ numeric keys (ie HashMap<uint, V> etc)\n                 // is going to have a string here, as per JSON spec.\n-                match s.parse() {\n+                match s.parse().ok() {\n                     Some(f) => Ok(f),\n                     None => Err(ExpectedError(\"Number\".to_string(), s)),\n                 }\n@@ -2597,8 +2597,9 @@ impl<'a, T: Encodable> fmt::Display for AsPrettyJson<'a, T> {\n }\n \n impl FromStr for Json {\n-    fn from_str(s: &str) -> Option<Json> {\n-        from_str(s).ok()\n+    type Err = BuilderError;\n+    fn from_str(s: &str) -> Result<Json, BuilderError> {\n+        from_str(s)\n     }\n }\n \n@@ -3937,7 +3938,7 @@ mod tests {\n         hash_map.insert(\"a\".to_string(), 1u);\n         hash_map.insert(\"b\".to_string(), 2);\n         assert_eq!(hash_map.to_json(), object);\n-        assert_eq!(Some(15i).to_json(), I64(15));\n+        assert_eq!(Some(15).to_json(), I64(15));\n         assert_eq!(Some(15u).to_json(), U64(15));\n         assert_eq!(None::<int>.to_json(), Null);\n     }\n@@ -3951,8 +3952,8 @@ mod tests {\n         struct ArbitraryType(uint);\n         let mut hm: HashMap<ArbitraryType, bool> = HashMap::new();\n         hm.insert(ArbitraryType(1), true);\n-        let mut mem_buf = Vec::new();\n-        let mut encoder = Encoder::new(&mut mem_buf as &mut fmt::Writer);\n+        let mut mem_buf = string::String::new();\n+        let mut encoder = Encoder::new(&mut mem_buf);\n         let result = hm.encode(&mut encoder);\n         match result.err().unwrap() {\n             EncoderError::BadHashmapKey => (),\n@@ -3997,7 +3998,7 @@ mod tests {\n \n     fn big_json() -> string::String {\n         let mut src = \"[\\n\".to_string();\n-        for _ in 0i..500 {\n+        for _ in 0..500 {\n             src.push_str(r#\"{ \"a\": true, \"b\": null, \"c\":3.1415, \"d\": \"Hello world\", \"e\": \\\n                             [1,2,3]},\"#);\n         }"}, {"sha": "e86ee4a73cea96b42ff148f66f9862ad7bbee320", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -17,24 +17,23 @@ Core encoding and decoding interfaces.\n #![crate_name = \"serialize\"]\n #![unstable(feature = \"rustc_private\",\n             reason = \"deprecated in favor of rustc-serialize on crates.io\")]\n-#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n-#![allow(unknown_features)]\n+\n #![feature(box_syntax)]\n-#![feature(old_impl_check)]\n-#![feature(slicing_syntax)]\n-#![allow(unknown_features)] #![feature(int_uint)]\n #![feature(collections)]\n #![feature(core)]\n+#![feature(int_uint)]\n #![feature(io)]\n #![feature(path)]\n #![feature(rustc_private)]\n+#![feature(slicing_syntax)]\n+#![feature(staged_api)]\n #![feature(std_misc)]\n #![feature(unicode)]\n #![cfg_attr(test, feature(test))]"}, {"sha": "ce02648b8f29d884a389185115f02e46302cc362", "filename": "src/libstd/collections/hash/bench.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fcollections%2Fhash%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fcollections%2Fhash%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fbench.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -32,7 +32,7 @@ fn new_insert_drop(b : &mut Bencher) {\n \n     b.iter(|| {\n         let mut m = HashMap::new();\n-        m.insert(0i, 0i);\n+        m.insert(0, 0);\n         assert_eq!(m.len(), 1);\n     })\n }\n@@ -43,7 +43,7 @@ fn grow_by_insertion(b: &mut Bencher) {\n \n     let mut m = HashMap::new();\n \n-    for i in range_inclusive(1i, 1000) {\n+    for i in range_inclusive(1, 1000) {\n         m.insert(i, i);\n     }\n \n@@ -61,12 +61,12 @@ fn find_existing(b: &mut Bencher) {\n \n     let mut m = HashMap::new();\n \n-    for i in range_inclusive(1i, 1000) {\n+    for i in range_inclusive(1, 1000) {\n         m.insert(i, i);\n     }\n \n     b.iter(|| {\n-        for i in range_inclusive(1i, 1000) {\n+        for i in range_inclusive(1, 1000) {\n             m.contains_key(&i);\n         }\n     });\n@@ -78,12 +78,12 @@ fn find_nonexisting(b: &mut Bencher) {\n \n     let mut m = HashMap::new();\n \n-    for i in range_inclusive(1i, 1000) {\n+    for i in range_inclusive(1, 1000) {\n         m.insert(i, i);\n     }\n \n     b.iter(|| {\n-        for i in range_inclusive(1001i, 2000) {\n+        for i in range_inclusive(1001, 2000) {\n             m.contains_key(&i);\n         }\n     });\n@@ -95,11 +95,11 @@ fn hashmap_as_queue(b: &mut Bencher) {\n \n     let mut m = HashMap::new();\n \n-    for i in range_inclusive(1i, 1000) {\n+    for i in range_inclusive(1, 1000) {\n         m.insert(i, i);\n     }\n \n-    let mut k = 1i;\n+    let mut k = 1;\n \n     b.iter(|| {\n         m.remove(&k);\n@@ -114,11 +114,11 @@ fn get_remove_insert(b: &mut Bencher) {\n \n     let mut m = HashMap::new();\n \n-    for i in range_inclusive(1i, 1000) {\n+    for i in range_inclusive(1, 1000) {\n         m.insert(i, i);\n     }\n \n-    let mut k = 1i;\n+    let mut k = 1;\n \n     b.iter(|| {\n         m.get(&(k + 400));"}, {"sha": "3e2c7627dbe55c700d6d39b6097582a08a703a7d", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -536,7 +536,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     ///\n     /// let s = RandomState::new();\n     /// let mut map = HashMap::with_hash_state(s);\n-    /// map.insert(1i, 2u);\n+    /// map.insert(1, 2u);\n     /// ```\n     #[inline]\n     #[unstable(feature = \"std_misc\", reason = \"hasher stuff is unclear\")]\n@@ -564,7 +564,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     ///\n     /// let s = RandomState::new();\n     /// let mut map = HashMap::with_capacity_and_hash_state(10, s);\n-    /// map.insert(1i, 2u);\n+    /// map.insert(1, 2u);\n     /// ```\n     #[inline]\n     #[unstable(feature = \"std_misc\", reason = \"hasher stuff is unclear\")]\n@@ -809,7 +809,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// use std::collections::HashMap;\n     ///\n     /// let mut map = HashMap::new();\n-    /// map.insert(\"a\", 1i);\n+    /// map.insert(\"a\", 1);\n     /// map.insert(\"b\", 2);\n     /// map.insert(\"c\", 3);\n     ///\n@@ -834,7 +834,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// use std::collections::HashMap;\n     ///\n     /// let mut map = HashMap::new();\n-    /// map.insert(\"a\", 1i);\n+    /// map.insert(\"a\", 1);\n     /// map.insert(\"b\", 2);\n     /// map.insert(\"c\", 3);\n     ///\n@@ -859,7 +859,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// use std::collections::HashMap;\n     ///\n     /// let mut map = HashMap::new();\n-    /// map.insert(\"a\", 1i);\n+    /// map.insert(\"a\", 1);\n     /// map.insert(\"b\", 2);\n     /// map.insert(\"c\", 3);\n     ///\n@@ -882,7 +882,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// use std::collections::HashMap;\n     ///\n     /// let mut map = HashMap::new();\n-    /// map.insert(\"a\", 1i);\n+    /// map.insert(\"a\", 1);\n     /// map.insert(\"b\", 2);\n     /// map.insert(\"c\", 3);\n     ///\n@@ -910,7 +910,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// use std::collections::HashMap;\n     ///\n     /// let mut map = HashMap::new();\n-    /// map.insert(\"a\", 1i);\n+    /// map.insert(\"a\", 1);\n     /// map.insert(\"b\", 2);\n     /// map.insert(\"c\", 3);\n     ///\n@@ -1622,7 +1622,7 @@ mod test_map {\n     fn test_create_capacity_zero() {\n         let mut m = HashMap::with_capacity(0);\n \n-        assert!(m.insert(1i, 1i).is_none());\n+        assert!(m.insert(1, 1).is_none());\n \n         assert!(m.contains_key(&1));\n         assert!(!m.contains_key(&0));\n@@ -1632,9 +1632,9 @@ mod test_map {\n     fn test_insert() {\n         let mut m = HashMap::new();\n         assert_eq!(m.len(), 0);\n-        assert!(m.insert(1i, 2i).is_none());\n+        assert!(m.insert(1, 2).is_none());\n         assert_eq!(m.len(), 1);\n-        assert!(m.insert(2i, 4i).is_none());\n+        assert!(m.insert(2, 4).is_none());\n         assert_eq!(m.len(), 2);\n         assert_eq!(*m.get(&1).unwrap(), 2);\n         assert_eq!(*m.get(&2).unwrap(), 4);\n@@ -1674,7 +1674,7 @@ mod test_map {\n     #[test]\n     fn test_drops() {\n         DROP_VECTOR.with(|slot| {\n-            *slot.borrow_mut() = repeat(0i).take(200).collect();\n+            *slot.borrow_mut() = repeat(0).take(200).collect();\n         });\n \n         {\n@@ -1772,7 +1772,7 @@ mod test_map {\n                 }\n             });\n \n-            for _ in half {}\n+            for _ in half.by_ref() {}\n \n             DROP_VECTOR.with(|v| {\n                 let nk = (0u..100).filter(|&i| {\n@@ -1807,10 +1807,10 @@ mod test_map {\n \n         // Try this a few times to make sure we never screw up the hashmap's\n         // internal state.\n-        for _ in 0i..10 {\n+        for _ in 0..10 {\n             assert!(m.is_empty());\n \n-            for i in range_inclusive(1i, 1000) {\n+            for i in range_inclusive(1, 1000) {\n                 assert!(m.insert(i, i).is_none());\n \n                 for j in range_inclusive(1, i) {\n@@ -1824,12 +1824,12 @@ mod test_map {\n                 }\n             }\n \n-            for i in range_inclusive(1001i, 2000) {\n+            for i in range_inclusive(1001, 2000) {\n                 assert!(!m.contains_key(&i));\n             }\n \n             // remove forwards\n-            for i in range_inclusive(1i, 1000) {\n+            for i in range_inclusive(1, 1000) {\n                 assert!(m.remove(&i).is_some());\n \n                 for j in range_inclusive(1, i) {\n@@ -1841,16 +1841,16 @@ mod test_map {\n                 }\n             }\n \n-            for i in range_inclusive(1i, 1000) {\n+            for i in range_inclusive(1, 1000) {\n                 assert!(!m.contains_key(&i));\n             }\n \n-            for i in range_inclusive(1i, 1000) {\n+            for i in range_inclusive(1, 1000) {\n                 assert!(m.insert(i, i).is_none());\n             }\n \n             // remove backwards\n-            for i in range_step_inclusive(1000i, 1, -1) {\n+            for i in range_step_inclusive(1000, 1, -1) {\n                 assert!(m.remove(&i).is_some());\n \n                 for j in range_inclusive(i, 1000) {\n@@ -1867,9 +1867,9 @@ mod test_map {\n     #[test]\n     fn test_find_mut() {\n         let mut m = HashMap::new();\n-        assert!(m.insert(1i, 12i).is_none());\n-        assert!(m.insert(2i, 8i).is_none());\n-        assert!(m.insert(5i, 14i).is_none());\n+        assert!(m.insert(1, 12).is_none());\n+        assert!(m.insert(2, 8).is_none());\n+        assert!(m.insert(5, 14).is_none());\n         let new = 100;\n         match m.get_mut(&5) {\n             None => panic!(), Some(x) => *x = new\n@@ -1880,18 +1880,18 @@ mod test_map {\n     #[test]\n     fn test_insert_overwrite() {\n         let mut m = HashMap::new();\n-        assert!(m.insert(1i, 2i).is_none());\n+        assert!(m.insert(1, 2).is_none());\n         assert_eq!(*m.get(&1).unwrap(), 2);\n-        assert!(!m.insert(1i, 3i).is_none());\n+        assert!(!m.insert(1, 3).is_none());\n         assert_eq!(*m.get(&1).unwrap(), 3);\n     }\n \n     #[test]\n     fn test_insert_conflicts() {\n         let mut m = HashMap::with_capacity(4);\n-        assert!(m.insert(1i, 2i).is_none());\n-        assert!(m.insert(5i, 3i).is_none());\n-        assert!(m.insert(9i, 4i).is_none());\n+        assert!(m.insert(1, 2).is_none());\n+        assert!(m.insert(5, 3).is_none());\n+        assert!(m.insert(9, 4).is_none());\n         assert_eq!(*m.get(&9).unwrap(), 4);\n         assert_eq!(*m.get(&5).unwrap(), 3);\n         assert_eq!(*m.get(&1).unwrap(), 2);\n@@ -1900,7 +1900,7 @@ mod test_map {\n     #[test]\n     fn test_conflict_remove() {\n         let mut m = HashMap::with_capacity(4);\n-        assert!(m.insert(1i, 2i).is_none());\n+        assert!(m.insert(1, 2).is_none());\n         assert_eq!(*m.get(&1).unwrap(), 2);\n         assert!(m.insert(5, 3).is_none());\n         assert_eq!(*m.get(&1).unwrap(), 2);\n@@ -1917,7 +1917,7 @@ mod test_map {\n     #[test]\n     fn test_is_empty() {\n         let mut m = HashMap::with_capacity(4);\n-        assert!(m.insert(1i, 2i).is_none());\n+        assert!(m.insert(1, 2).is_none());\n         assert!(!m.is_empty());\n         assert!(m.remove(&1).is_some());\n         assert!(m.is_empty());\n@@ -1926,7 +1926,7 @@ mod test_map {\n     #[test]\n     fn test_pop() {\n         let mut m = HashMap::new();\n-        m.insert(1i, 2i);\n+        m.insert(1, 2);\n         assert_eq!(m.remove(&1), Some(2));\n         assert_eq!(m.remove(&1), None);\n     }\n@@ -1950,7 +1950,7 @@ mod test_map {\n \n     #[test]\n     fn test_keys() {\n-        let vec = vec![(1i, 'a'), (2i, 'b'), (3i, 'c')];\n+        let vec = vec![(1, 'a'), (2, 'b'), (3, 'c')];\n         let map = vec.into_iter().collect::<HashMap<int, char>>();\n         let keys = map.keys().map(|&k| k).collect::<Vec<int>>();\n         assert_eq!(keys.len(), 3);\n@@ -1961,7 +1961,7 @@ mod test_map {\n \n     #[test]\n     fn test_values() {\n-        let vec = vec![(1i, 'a'), (2i, 'b'), (3i, 'c')];\n+        let vec = vec![(1, 'a'), (2, 'b'), (3, 'c')];\n         let map = vec.into_iter().collect::<HashMap<int, char>>();\n         let values = map.values().map(|&v| v).collect::<Vec<char>>();\n         assert_eq!(values.len(), 3);\n@@ -1973,8 +1973,8 @@ mod test_map {\n     #[test]\n     fn test_find() {\n         let mut m = HashMap::new();\n-        assert!(m.get(&1i).is_none());\n-        m.insert(1i, 2i);\n+        assert!(m.get(&1).is_none());\n+        m.insert(1, 2);\n         match m.get(&1) {\n             None => panic!(),\n             Some(v) => assert_eq!(*v, 2)\n@@ -1984,17 +1984,17 @@ mod test_map {\n     #[test]\n     fn test_eq() {\n         let mut m1 = HashMap::new();\n-        m1.insert(1i, 2i);\n-        m1.insert(2i, 3i);\n-        m1.insert(3i, 4i);\n+        m1.insert(1, 2);\n+        m1.insert(2, 3);\n+        m1.insert(3, 4);\n \n         let mut m2 = HashMap::new();\n-        m2.insert(1i, 2i);\n-        m2.insert(2i, 3i);\n+        m2.insert(1, 2);\n+        m2.insert(2, 3);\n \n         assert!(m1 != m2);\n \n-        m2.insert(3i, 4i);\n+        m2.insert(3, 4);\n \n         assert_eq!(m1, m2);\n     }\n@@ -2004,8 +2004,8 @@ mod test_map {\n         let mut map: HashMap<int, int> = HashMap::new();\n         let empty: HashMap<int, int> = HashMap::new();\n \n-        map.insert(1i, 2i);\n-        map.insert(3i, 4i);\n+        map.insert(1, 2);\n+        map.insert(3, 4);\n \n         let map_str = format!(\"{:?}\", map);\n \n@@ -2127,7 +2127,7 @@ mod test_map {\n \n     #[test]\n     fn test_from_iter() {\n-        let xs = [(1i, 1i), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n+        let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n \n         let map: HashMap<int, int> = xs.iter().map(|&x| x).collect();\n \n@@ -2138,7 +2138,7 @@ mod test_map {\n \n     #[test]\n     fn test_size_hint() {\n-        let xs = [(1i, 1i), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n+        let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n \n         let map: HashMap<int, int> = xs.iter().map(|&x| x).collect();\n \n@@ -2151,7 +2151,7 @@ mod test_map {\n \n     #[test]\n     fn test_iter_len() {\n-        let xs = [(1i, 1i), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n+        let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n \n         let map: HashMap<int, int> = xs.iter().map(|&x| x).collect();\n \n@@ -2164,7 +2164,7 @@ mod test_map {\n \n     #[test]\n     fn test_mut_size_hint() {\n-        let xs = [(1i, 1i), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n+        let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n \n         let mut map: HashMap<int, int> = xs.iter().map(|&x| x).collect();\n \n@@ -2177,7 +2177,7 @@ mod test_map {\n \n     #[test]\n     fn test_iter_mut_len() {\n-        let xs = [(1i, 1i), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n+        let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n \n         let mut map: HashMap<int, int> = xs.iter().map(|&x| x).collect();\n \n@@ -2213,7 +2213,7 @@ mod test_map {\n \n     #[test]\n     fn test_entry(){\n-        let xs = [(1i, 10i), (2, 20), (3, 30), (4, 40), (5, 50), (6, 60)];\n+        let xs = [(1, 10), (2, 20), (3, 30), (4, 40), (5, 50), (6, 60)];\n \n         let mut map: HashMap<int, int> = xs.iter().map(|&x| x).collect();\n "}, {"sha": "3095c2c0e41ff5975055b930b03c9bbc73d4643d", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -168,7 +168,7 @@ impl<T, S, H> HashSet<T, S>\n     ///\n     /// let s = RandomState::new();\n     /// let mut set = HashSet::with_capacity_and_hash_state(10u, s);\n-    /// set.insert(1i);\n+    /// set.insert(1);\n     /// ```\n     #[inline]\n     #[unstable(feature = \"std_misc\", reason = \"hasher stuff is unclear\")]\n@@ -290,21 +290,21 @@ impl<T, S, H> HashSet<T, S>\n     ///\n     /// ```\n     /// use std::collections::HashSet;\n-    /// let a: HashSet<int> = [1i, 2, 3].iter().map(|&x| x).collect();\n-    /// let b: HashSet<int> = [4i, 2, 3, 4].iter().map(|&x| x).collect();\n+    /// let a: HashSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n+    /// let b: HashSet<int> = [4, 2, 3, 4].iter().map(|&x| x).collect();\n     ///\n     /// // Can be seen as `a - b`.\n     /// for x in a.difference(&b) {\n     ///     println!(\"{}\", x); // Print 1\n     /// }\n     ///\n     /// let diff: HashSet<int> = a.difference(&b).map(|&x| x).collect();\n-    /// assert_eq!(diff, [1i].iter().map(|&x| x).collect());\n+    /// assert_eq!(diff, [1].iter().map(|&x| x).collect());\n     ///\n     /// // Note that difference is not symmetric,\n     /// // and `b - a` means something else:\n     /// let diff: HashSet<int> = b.difference(&a).map(|&x| x).collect();\n-    /// assert_eq!(diff, [4i].iter().map(|&x| x).collect());\n+    /// assert_eq!(diff, [4].iter().map(|&x| x).collect());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn difference<'a>(&'a self, other: &'a HashSet<T, S>) -> Difference<'a, T, S> {\n@@ -320,8 +320,8 @@ impl<T, S, H> HashSet<T, S>\n     ///\n     /// ```\n     /// use std::collections::HashSet;\n-    /// let a: HashSet<int> = [1i, 2, 3].iter().map(|&x| x).collect();\n-    /// let b: HashSet<int> = [4i, 2, 3, 4].iter().map(|&x| x).collect();\n+    /// let a: HashSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n+    /// let b: HashSet<int> = [4, 2, 3, 4].iter().map(|&x| x).collect();\n     ///\n     /// // Print 1, 4 in arbitrary order.\n     /// for x in a.symmetric_difference(&b) {\n@@ -332,7 +332,7 @@ impl<T, S, H> HashSet<T, S>\n     /// let diff2: HashSet<int> = b.symmetric_difference(&a).map(|&x| x).collect();\n     ///\n     /// assert_eq!(diff1, diff2);\n-    /// assert_eq!(diff1, [1i, 4].iter().map(|&x| x).collect());\n+    /// assert_eq!(diff1, [1, 4].iter().map(|&x| x).collect());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn symmetric_difference<'a>(&'a self, other: &'a HashSet<T, S>)\n@@ -346,16 +346,16 @@ impl<T, S, H> HashSet<T, S>\n     ///\n     /// ```\n     /// use std::collections::HashSet;\n-    /// let a: HashSet<int> = [1i, 2, 3].iter().map(|&x| x).collect();\n-    /// let b: HashSet<int> = [4i, 2, 3, 4].iter().map(|&x| x).collect();\n+    /// let a: HashSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n+    /// let b: HashSet<int> = [4, 2, 3, 4].iter().map(|&x| x).collect();\n     ///\n     /// // Print 2, 3 in arbitrary order.\n     /// for x in a.intersection(&b) {\n     ///     println!(\"{}\", x);\n     /// }\n     ///\n     /// let diff: HashSet<int> = a.intersection(&b).map(|&x| x).collect();\n-    /// assert_eq!(diff, [2i, 3].iter().map(|&x| x).collect());\n+    /// assert_eq!(diff, [2, 3].iter().map(|&x| x).collect());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn intersection<'a>(&'a self, other: &'a HashSet<T, S>) -> Intersection<'a, T, S> {\n@@ -371,16 +371,16 @@ impl<T, S, H> HashSet<T, S>\n     ///\n     /// ```\n     /// use std::collections::HashSet;\n-    /// let a: HashSet<int> = [1i, 2, 3].iter().map(|&x| x).collect();\n-    /// let b: HashSet<int> = [4i, 2, 3, 4].iter().map(|&x| x).collect();\n+    /// let a: HashSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n+    /// let b: HashSet<int> = [4, 2, 3, 4].iter().map(|&x| x).collect();\n     ///\n     /// // Print 1, 2, 3, 4 in arbitrary order.\n     /// for x in a.union(&b) {\n     ///     println!(\"{}\", x);\n     /// }\n     ///\n     /// let diff: HashSet<int> = a.union(&b).map(|&x| x).collect();\n-    /// assert_eq!(diff, [1i, 2, 3, 4].iter().map(|&x| x).collect());\n+    /// assert_eq!(diff, [1, 2, 3, 4].iter().map(|&x| x).collect());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn union<'a>(&'a self, other: &'a HashSet<T, S>) -> Union<'a, T, S> {\n@@ -955,8 +955,8 @@ mod test_set {\n         let mut ys = HashSet::new();\n         assert!(xs.is_disjoint(&ys));\n         assert!(ys.is_disjoint(&xs));\n-        assert!(xs.insert(5i));\n-        assert!(ys.insert(11i));\n+        assert!(xs.insert(5));\n+        assert!(ys.insert(11));\n         assert!(xs.is_disjoint(&ys));\n         assert!(ys.is_disjoint(&xs));\n         assert!(xs.insert(7));\n@@ -974,13 +974,13 @@ mod test_set {\n     #[test]\n     fn test_subset_and_superset() {\n         let mut a = HashSet::new();\n-        assert!(a.insert(0i));\n+        assert!(a.insert(0));\n         assert!(a.insert(5));\n         assert!(a.insert(11));\n         assert!(a.insert(7));\n \n         let mut b = HashSet::new();\n-        assert!(b.insert(0i));\n+        assert!(b.insert(0));\n         assert!(b.insert(7));\n         assert!(b.insert(19));\n         assert!(b.insert(250));\n@@ -1018,15 +1018,15 @@ mod test_set {\n         let mut a = HashSet::new();\n         let mut b = HashSet::new();\n \n-        assert!(a.insert(11i));\n+        assert!(a.insert(11));\n         assert!(a.insert(1));\n         assert!(a.insert(3));\n         assert!(a.insert(77));\n         assert!(a.insert(103));\n         assert!(a.insert(5));\n         assert!(a.insert(-5));\n \n-        assert!(b.insert(2i));\n+        assert!(b.insert(2));\n         assert!(b.insert(11));\n         assert!(b.insert(77));\n         assert!(b.insert(-9));\n@@ -1048,13 +1048,13 @@ mod test_set {\n         let mut a = HashSet::new();\n         let mut b = HashSet::new();\n \n-        assert!(a.insert(1i));\n+        assert!(a.insert(1));\n         assert!(a.insert(3));\n         assert!(a.insert(5));\n         assert!(a.insert(9));\n         assert!(a.insert(11));\n \n-        assert!(b.insert(3i));\n+        assert!(b.insert(3));\n         assert!(b.insert(9));\n \n         let mut i = 0;\n@@ -1071,13 +1071,13 @@ mod test_set {\n         let mut a = HashSet::new();\n         let mut b = HashSet::new();\n \n-        assert!(a.insert(1i));\n+        assert!(a.insert(1));\n         assert!(a.insert(3));\n         assert!(a.insert(5));\n         assert!(a.insert(9));\n         assert!(a.insert(11));\n \n-        assert!(b.insert(-2i));\n+        assert!(b.insert(-2));\n         assert!(b.insert(3));\n         assert!(b.insert(9));\n         assert!(b.insert(14));\n@@ -1097,7 +1097,7 @@ mod test_set {\n         let mut a = HashSet::new();\n         let mut b = HashSet::new();\n \n-        assert!(a.insert(1i));\n+        assert!(a.insert(1));\n         assert!(a.insert(3));\n         assert!(a.insert(5));\n         assert!(a.insert(9));\n@@ -1106,7 +1106,7 @@ mod test_set {\n         assert!(a.insert(19));\n         assert!(a.insert(24));\n \n-        assert!(b.insert(-2i));\n+        assert!(b.insert(-2));\n         assert!(b.insert(1));\n         assert!(b.insert(5));\n         assert!(b.insert(9));\n@@ -1124,7 +1124,7 @@ mod test_set {\n \n     #[test]\n     fn test_from_iter() {\n-        let xs = [1i, 2, 3, 4, 5, 6, 7, 8, 9];\n+        let xs = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n \n         let set: HashSet<int> = xs.iter().map(|&x| x).collect();\n \n@@ -1154,13 +1154,13 @@ mod test_set {\n         // I'm keeping them around to prevent a regression.\n         let mut s1 = HashSet::new();\n \n-        s1.insert(1i);\n+        s1.insert(1);\n         s1.insert(2);\n         s1.insert(3);\n \n         let mut s2 = HashSet::new();\n \n-        s2.insert(1i);\n+        s2.insert(1);\n         s2.insert(2);\n \n         assert!(s1 != s2);\n@@ -1175,7 +1175,7 @@ mod test_set {\n         let mut set: HashSet<int> = HashSet::new();\n         let empty: HashSet<int> = HashSet::new();\n \n-        set.insert(1i);\n+        set.insert(1);\n         set.insert(2);\n \n         let set_str = format!(\"{:?}\", set);\n@@ -1201,7 +1201,7 @@ mod test_set {\n         let mut s: HashSet<int> = (1is..100).collect();\n \n         // try this a bunch of times to make sure we don't screw up internal state.\n-        for _ in 0i..20 {\n+        for _ in 0..20 {\n             assert_eq!(s.len(), 99);\n \n             {"}, {"sha": "8016a343d67c5fe207ba925721a35ccd2252551c", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -15,7 +15,7 @@ use self::BucketState::*;\n use clone::Clone;\n use cmp;\n use hash::{Hash, Hasher};\n-use iter::{Iterator, ExactSizeIterator, count};\n+use iter::{Iterator, IteratorExt, ExactSizeIterator, count};\n use marker::{Copy, Sized, self};\n use mem::{min_align_of, size_of};\n use mem;\n@@ -274,7 +274,7 @@ impl<K, V, M: Deref<Target=RawTable<K, V>>> Bucket<K, V, M> {\n         // ... and it's zero at all other times.\n         let maybe_wraparound_dist = (self.idx ^ (self.idx + 1)) & self.table.capacity();\n         // Finally, we obtain the offset 1 or the offset -cap + 1.\n-        let dist = 1i - (maybe_wraparound_dist as int);\n+        let dist = 1 - (maybe_wraparound_dist as int);\n \n         self.idx += 1;\n \n@@ -921,7 +921,7 @@ impl<'a, K, V> ExactSizeIterator for Drain<'a, K, V> {\n #[unsafe_destructor]\n impl<'a, K: 'a, V: 'a> Drop for Drain<'a, K, V> {\n     fn drop(&mut self) {\n-        for _ in *self {}\n+        for _ in self.by_ref() {}\n     }\n }\n "}, {"sha": "2e55c007b551b32e55a9a3e4430a15f8b32995d9", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -122,7 +122,7 @@ impl Deref for CString {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Debug for CString {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        String::from_utf8_lossy(self.as_bytes()).fmt(f)\n+        fmt::Debug::fmt(&String::from_utf8_lossy(self.as_bytes()), f)\n     }\n }\n "}, {"sha": "8e86aa651967f9d4e2a281930db710e7c7d6ab2c", "filename": "src/libstd/fmt.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -29,10 +29,10 @@\n //! ```\n //! format!(\"Hello\");                  // => \"Hello\"\n //! format!(\"Hello, {}!\", \"world\");    // => \"Hello, world!\"\n-//! format!(\"The number is {}\", 1i);   // => \"The number is 1\"\n-//! format!(\"{:?}\", (3i, 4i));         // => \"(3i, 4i)\"\n-//! format!(\"{value}\", value=4i);      // => \"4\"\n-//! format!(\"{} {}\", 1i, 2u);          // => \"1 2\"\n+//! format!(\"The number is {}\", 1);   // => \"The number is 1\"\n+//! format!(\"{:?}\", (3, 4));         // => \"(3, 4)\"\n+//! format!(\"{value}\", value=4);      // => \"4\"\n+//! format!(\"{} {}\", 1, 2u);          // => \"1 2\"\n //! ```\n //!\n //! From these, you can see that the first argument is a format string. It is\n@@ -55,7 +55,7 @@\n //! the iterator advances. This leads to behavior like this:\n //!\n //! ```rust\n-//! format!(\"{1} {} {0} {}\", 1i, 2i); // => \"2 1 1 2\"\n+//! format!(\"{1} {} {0} {}\", 1, 2); // => \"2 1 1 2\"\n //! ```\n //!\n //! The internal iterator over the argument has not been advanced by the time\n@@ -83,8 +83,8 @@\n //!\n //! ```\n //! format!(\"{argument}\", argument = \"test\");   // => \"test\"\n-//! format!(\"{name} {}\", 1i, name = 2i);        // => \"2 1\"\n-//! format!(\"{a} {c} {b}\", a=\"a\", b='b', c=3i);  // => \"a 3 b\"\n+//! format!(\"{name} {}\", 1, name = 2);        // => \"2 1\"\n+//! format!(\"{a} {c} {b}\", a=\"a\", b='b', c=3);  // => \"a 3 b\"\n //! ```\n //!\n //! It is illegal to put positional parameters (those without names) after\n@@ -206,7 +206,7 @@\n //!     let myvector = Vector2D { x: 3, y: 4 };\n //!\n //!     println!(\"{}\", myvector);       // => \"(3, 4)\"\n-//!     println!(\"{:?}\", myvector);     // => \"Vector2D {x: 3i, y:4i}\"\n+//!     println!(\"{:?}\", myvector);     // => \"Vector2D {x: 3, y:4}\"\n //!     println!(\"{:10.3b}\", myvector); // => \"     5.000\"\n //! }\n //! ```\n@@ -411,9 +411,10 @@ pub use core::fmt::{Display, Debug};\n pub use core::fmt::{LowerHex, UpperHex, Pointer};\n pub use core::fmt::{LowerExp, UpperExp};\n pub use core::fmt::Error;\n-pub use core::fmt::{Argument, Arguments, write, radix, Radix, RadixFmt};\n+pub use core::fmt::{ArgumentV1, Arguments, write, radix, Radix, RadixFmt};\n \n #[doc(hidden)]\n+#[cfg(stage0)]\n pub use core::fmt::{argument, argumentuint};\n \n /// The format function takes a precompiled format string and a list of\n@@ -431,9 +432,7 @@ pub use core::fmt::{argument, argumentuint};\n /// let s = fmt::format(format_args!(\"Hello, {}!\", \"world\"));\n /// assert_eq!(s, \"Hello, world!\".to_string());\n /// ```\n-#[unstable(feature = \"std_misc\",\n-           reason = \"this is an implementation detail of format! and should not \\\n-                     be called directly\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn format(args: Arguments) -> string::String {\n     let mut output = string::String::new();\n     let _ = write!(&mut output, \"{}\", args);"}, {"sha": "96aebb735ef123ea1fb3f0e495778f97089f0a4c", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -97,7 +97,6 @@\n \n #![crate_name = \"std\"]\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n-#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n@@ -106,28 +105,29 @@\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n \n-#![allow(unknown_features)]\n-#![feature(linkage, thread_local, asm)]\n-#![feature(lang_items, unsafe_destructor)]\n-#![feature(slicing_syntax, unboxed_closures)]\n+#![feature(alloc)]\n #![feature(box_syntax)]\n-#![feature(old_impl_check)]\n-#![feature(optin_builtin_traits)]\n-#![feature(int_uint)]\n-#![feature(int_uint)]\n+#![feature(collections)]\n #![feature(core)]\n+#![feature(hash)]\n+#![feature(int_uint)]\n+#![feature(lang_items, unsafe_destructor)]\n #![feature(libc)]\n-#![feature(alloc)]\n-#![feature(unicode)]\n-#![feature(collections)]\n+#![feature(linkage, thread_local, asm)]\n+#![feature(old_impl_check)]\n+#![feature(optin_builtin_traits)]\n #![feature(rand)]\n-#![feature(hash)]\n+#![feature(staged_api)]\n+#![feature(unboxed_closures)]\n+#![feature(unicode)]\n+#![cfg_attr(not(stage0), feature(macro_reexport))]\n #![cfg_attr(test, feature(test))]\n \n // Don't link to std. We are std.\n #![no_std]\n \n #![deny(missing_docs)]\n+#![cfg_attr(not(stage0), allow(unused_mut))] // NOTE: remove after stage0 snap\n \n #[cfg(test)]\n #[macro_use]\n@@ -310,4 +310,6 @@ mod std {\n     pub use slice;\n \n     pub use boxed; // used for vec![]\n+    // for-loops\n+    pub use iter;\n }"}, {"sha": "e91e8241a55beb0f2946eeb178cc952625060d35", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -32,7 +32,7 @@\n /// # #![allow(unreachable_code)]\n /// panic!();\n /// panic!(\"this is a terrible mistake!\");\n-/// panic!(4i); // panic with the value of 4 to be collected elsewhere\n+/// panic!(4); // panic with the value of 4 to be collected elsewhere\n /// panic!(\"this is a {} {message}\", \"fancy\", message = \"message\");\n /// ```\n #[macro_export]\n@@ -68,7 +68,7 @@ macro_rules! panic {\n /// ```\n /// format!(\"test\");\n /// format!(\"hello {}\", \"world!\");\n-/// format!(\"x = {}, y = {y}\", 10i, y = 30i);\n+/// format!(\"x = {}, y = {y}\", 10, y = 30);\n /// ```\n #[macro_export]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -282,7 +282,7 @@ pub mod builtin {\n     /// # Example\n     ///\n     /// ```\n-    /// let s = concat!(\"test\", 10i, 'b', true);\n+    /// let s = concat!(\"test\", 10, 'b', true);\n     /// assert_eq!(s, \"test10btrue\");\n     /// ```\n     #[macro_export]"}, {"sha": "a996ad1f5b35d30fbc2ef605363b9b51bf29e9c6", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -356,11 +356,11 @@ pub fn test_num<T>(ten: T, two: T) where\n      + Rem<Output=T> + Debug\n      + Copy\n {\n-    assert_eq!(ten.add(two),  cast(12i).unwrap());\n-    assert_eq!(ten.sub(two),  cast(8i).unwrap());\n-    assert_eq!(ten.mul(two),  cast(20i).unwrap());\n-    assert_eq!(ten.div(two),  cast(5i).unwrap());\n-    assert_eq!(ten.rem(two),  cast(0i).unwrap());\n+    assert_eq!(ten.add(two),  cast(12).unwrap());\n+    assert_eq!(ten.sub(two),  cast(8).unwrap());\n+    assert_eq!(ten.mul(two),  cast(20).unwrap());\n+    assert_eq!(ten.div(two),  cast(5).unwrap());\n+    assert_eq!(ten.rem(two),  cast(0).unwrap());\n \n     assert_eq!(ten.add(two),  ten + two);\n     assert_eq!(ten.sub(two),  ten - two);\n@@ -393,7 +393,7 @@ mod tests {\n             assert_eq!(20u16, _20.to_u16().unwrap());\n             assert_eq!(20u32, _20.to_u32().unwrap());\n             assert_eq!(20u64, _20.to_u64().unwrap());\n-            assert_eq!(20i,   _20.to_int().unwrap());\n+            assert_eq!(20,   _20.to_int().unwrap());\n             assert_eq!(20i8,  _20.to_i8().unwrap());\n             assert_eq!(20i16, _20.to_i16().unwrap());\n             assert_eq!(20i32, _20.to_i32().unwrap());\n@@ -406,7 +406,7 @@ mod tests {\n             assert_eq!(_20, NumCast::from(20u16).unwrap());\n             assert_eq!(_20, NumCast::from(20u32).unwrap());\n             assert_eq!(_20, NumCast::from(20u64).unwrap());\n-            assert_eq!(_20, NumCast::from(20i).unwrap());\n+            assert_eq!(_20, NumCast::from(20).unwrap());\n             assert_eq!(_20, NumCast::from(20i8).unwrap());\n             assert_eq!(_20, NumCast::from(20i16).unwrap());\n             assert_eq!(_20, NumCast::from(20i32).unwrap());\n@@ -419,7 +419,7 @@ mod tests {\n             assert_eq!(_20, cast(20u16).unwrap());\n             assert_eq!(_20, cast(20u32).unwrap());\n             assert_eq!(_20, cast(20u64).unwrap());\n-            assert_eq!(_20, cast(20i).unwrap());\n+            assert_eq!(_20, cast(20).unwrap());\n             assert_eq!(_20, cast(20i8).unwrap());\n             assert_eq!(_20, cast(20i16).unwrap());\n             assert_eq!(_20, cast(20i32).unwrap());\n@@ -438,7 +438,7 @@ mod tests {\n     #[test] fn test_i16_cast()   { test_cast_20!(20i16) }\n     #[test] fn test_i32_cast()   { test_cast_20!(20i32) }\n     #[test] fn test_i64_cast()   { test_cast_20!(20i64) }\n-    #[test] fn test_int_cast()   { test_cast_20!(20i)   }\n+    #[test] fn test_int_cast()   { test_cast_20!(20)   }\n     #[test] fn test_f32_cast()   { test_cast_20!(20f32) }\n     #[test] fn test_f64_cast()   { test_cast_20!(20f64) }\n \n@@ -831,23 +831,23 @@ mod tests {\n     #[test]\n     fn test_saturating_add_int() {\n         use int::{MIN,MAX};\n-        assert_eq!(3i.saturating_add(5i), 8i);\n-        assert_eq!(3i.saturating_add(MAX-1), MAX);\n+        assert_eq!(3.saturating_add(5), 8);\n+        assert_eq!(3.saturating_add(MAX-1), MAX);\n         assert_eq!(MAX.saturating_add(MAX), MAX);\n         assert_eq!((MAX-2).saturating_add(1), MAX-1);\n-        assert_eq!(3i.saturating_add(-5i), -2i);\n-        assert_eq!(MIN.saturating_add(-1i), MIN);\n-        assert_eq!((-2i).saturating_add(-MAX), MIN);\n+        assert_eq!(3.saturating_add(-5), -2);\n+        assert_eq!(MIN.saturating_add(-1), MIN);\n+        assert_eq!((-2).saturating_add(-MAX), MIN);\n     }\n \n     #[test]\n     fn test_saturating_sub_int() {\n         use int::{MIN,MAX};\n-        assert_eq!(3i.saturating_sub(5i), -2i);\n-        assert_eq!(MIN.saturating_sub(1i), MIN);\n-        assert_eq!((-2i).saturating_sub(MAX), MIN);\n-        assert_eq!(3i.saturating_sub(-5i), 8i);\n-        assert_eq!(3i.saturating_sub(-(MAX-1)), MAX);\n+        assert_eq!(3.saturating_sub(5), -2);\n+        assert_eq!(MIN.saturating_sub(1), MIN);\n+        assert_eq!((-2).saturating_sub(MAX), MIN);\n+        assert_eq!(3.saturating_sub(-5), 8);\n+        assert_eq!(3.saturating_sub(-(MAX-1)), MAX);\n         assert_eq!(MAX.saturating_sub(-MAX), MAX);\n         assert_eq!((MAX-2).saturating_sub(-1), MAX-1);\n     }\n@@ -1010,10 +1010,10 @@ mod tests {\n                 assert_eq!(result, naive_pow($num, $exp));\n             }}\n         }\n-        assert_pow!((3i,     0 ) => 1);\n-        assert_pow!((5i,     1 ) => 5);\n-        assert_pow!((-4i,    2 ) => 16);\n-        assert_pow!((8i,     3 ) => 512);\n+        assert_pow!((3,     0 ) => 1);\n+        assert_pow!((5,     1 ) => 5);\n+        assert_pow!((-4,    2 ) => 16);\n+        assert_pow!((8,     3 ) => 512);\n         assert_pow!((2u64,   50) => 1125899906842624);\n     }\n }"}, {"sha": "4cd6391318f16925a401d78f331f34df04f501da", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -20,7 +20,7 @@ mod tests {\n     use num::FromStrRadix;\n \n     fn from_str<T: ::str::FromStr>(t: &str) -> Option<T> {\n-        ::str::FromStr::from_str(t)\n+        ::str::FromStr::from_str(t).ok()\n     }\n \n     #[test]\n@@ -38,15 +38,15 @@ mod tests {\n \n     #[test]\n     pub fn test_parse_bytes() {\n-        assert_eq!(FromStrRadix::from_str_radix(\"123\", 10), Some(123u as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"1001\", 2), Some(9u as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"123\", 8), Some(83u as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"123\", 16), Some(291u as u16));\n-        assert_eq!(FromStrRadix::from_str_radix(\"ffff\", 16), Some(65535u as u16));\n-        assert_eq!(FromStrRadix::from_str_radix(\"z\", 36), Some(35u as $T));\n-\n-        assert_eq!(FromStrRadix::from_str_radix(\"Z\", 10), None::<$T>);\n-        assert_eq!(FromStrRadix::from_str_radix(\"_\", 2), None::<$T>);\n+        assert_eq!(FromStrRadix::from_str_radix(\"123\", 10), Ok(123u as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"1001\", 2), Ok(9u as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"123\", 8), Ok(83u as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"123\", 16), Ok(291u as u16));\n+        assert_eq!(FromStrRadix::from_str_radix(\"ffff\", 16), Ok(65535u as u16));\n+        assert_eq!(FromStrRadix::from_str_radix(\"z\", 36), Ok(35u as $T));\n+\n+        assert_eq!(FromStrRadix::from_str_radix(\"Z\", 10).ok(), None::<$T>);\n+        assert_eq!(FromStrRadix::from_str_radix(\"_\", 2).ok(), None::<$T>);\n     }\n \n     #[test]"}, {"sha": "586cc1477f8dd6ecc35cd5633330e9d4ef74c7bb", "filename": "src/libstd/old_io/buffered.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fold_io%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fold_io%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fbuffered.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -111,7 +111,7 @@ impl<R: Reader> Buffer for BufferedReader<R> {\n \n impl<R: Reader> Reader for BufferedReader<R> {\n     fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n-        if self.pos == self.cap && buf.len() >= self.buf.capacity() {\n+        if self.pos == self.cap && buf.len() >= self.buf.len() {\n             return self.inner.read(buf);\n         }\n         let nread = {"}, {"sha": "1337675544d3171c1dcd577ffc218bb6e2516d35", "filename": "src/libstd/old_io/fs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fold_io%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fold_io%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Ffs.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -981,7 +981,7 @@ mod test {\n         let initial_msg =   \"food-is-yummy\";\n         let overwrite_msg =    \"-the-bar!!\";\n         let final_msg =     \"foo-the-bar!!\";\n-        let seek_idx = 3i;\n+        let seek_idx = 3;\n         let mut read_mem = [0; 13];\n         let tmpdir = tmpdir();\n         let filename = &tmpdir.join(\"file_rt_io_file_test_seek_and_write.txt\");\n@@ -1101,10 +1101,10 @@ mod test {\n         let dir = &tmpdir.join(\"di_readdir\");\n         check!(mkdir(dir, old_io::USER_RWX));\n         let prefix = \"foo\";\n-        for n in 0i..3 {\n+        for n in 0is..3 {\n             let f = dir.join(format!(\"{}.txt\", n));\n             let mut w = check!(File::create(&f));\n-            let msg_str = format!(\"{}{}\", prefix, n.to_string());\n+            let msg_str = format!(\"{}{}\", prefix, n);\n             let msg = msg_str.as_bytes();\n             check!(w.write(msg));\n         }"}, {"sha": "565f9d8381801a4573c1f5766e2544017010bed8", "filename": "src/libstd/old_io/net/ip.rs", "status": "modified", "additions": 59, "deletions": 49, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fold_io%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fold_io%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Fip.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -25,7 +25,7 @@ use iter::{Iterator, IteratorExt};\n use ops::{FnOnce, FnMut};\n use option::Option;\n use option::Option::{None, Some};\n-use result::Result::{Ok, Err};\n+use result::Result::{self, Ok, Err};\n use slice::SliceExt;\n use str::{FromStr, StrExt};\n use vec::Vec;\n@@ -350,17 +350,28 @@ impl<'a> Parser<'a> {\n }\n \n impl FromStr for IpAddr {\n-    fn from_str(s: &str) -> Option<IpAddr> {\n-        Parser::new(s).read_till_eof(|p| p.read_ip_addr())\n+    type Err = ParseError;\n+    fn from_str(s: &str) -> Result<IpAddr, ParseError> {\n+        match Parser::new(s).read_till_eof(|p| p.read_ip_addr()) {\n+            Some(s) => Ok(s),\n+            None => Err(ParseError),\n+        }\n     }\n }\n \n impl FromStr for SocketAddr {\n-    fn from_str(s: &str) -> Option<SocketAddr> {\n-        Parser::new(s).read_till_eof(|p| p.read_socket_addr())\n+    type Err = ParseError;\n+    fn from_str(s: &str) -> Result<SocketAddr, ParseError> {\n+        match Parser::new(s).read_till_eof(|p| p.read_socket_addr()) {\n+            Some(s) => Ok(s),\n+            None => Err(ParseError),\n+        }\n     }\n }\n \n+#[derive(Debug, Clone, PartialEq, Copy)]\n+pub struct ParseError;\n+\n /// A trait for objects which can be converted or resolved to one or more `SocketAddr` values.\n ///\n /// Implementing types minimally have to implement either `to_socket_addr` or `to_socket_addr_all`\n@@ -493,7 +504,7 @@ fn parse_and_resolve_socket_addr(s: &str) -> IoResult<Vec<SocketAddr>> {\n     let mut parts_iter = s.rsplitn(2, ':');\n     let port_str = try_opt!(parts_iter.next(), \"invalid socket address\");\n     let host = try_opt!(parts_iter.next(), \"invalid socket address\");\n-    let port: u16 = try_opt!(FromStr::from_str(port_str), \"invalid port value\");\n+    let port: u16 = try_opt!(port_str.parse().ok(), \"invalid port value\");\n     resolve_socket_addr(host, port)\n }\n \n@@ -502,7 +513,7 @@ impl<'a> ToSocketAddr for (&'a str, u16) {\n         let (host, port) = *self;\n \n         // try to parse the host as a regular IpAddr first\n-        match FromStr::from_str(host) {\n+        match host.parse().ok() {\n             Some(addr) => return Ok(vec![SocketAddr {\n                 ip: addr,\n                 port: port\n@@ -518,7 +529,7 @@ impl<'a> ToSocketAddr for (&'a str, u16) {\n impl<'a> ToSocketAddr for &'a str {\n     fn to_socket_addr(&self) -> IoResult<SocketAddr> {\n         // try to parse as a regular SocketAddr first\n-        match FromStr::from_str(*self) {\n+        match self.parse().ok() {\n             Some(addr) => return Ok(addr),\n             None => {}\n         }\n@@ -535,7 +546,7 @@ impl<'a> ToSocketAddr for &'a str {\n \n     fn to_socket_addr_all(&self) -> IoResult<Vec<SocketAddr>> {\n         // try to parse as a regular SocketAddr first\n-        match FromStr::from_str(*self) {\n+        match self.parse().ok() {\n             Some(addr) => return Ok(vec![addr]),\n             None => {}\n         }\n@@ -553,95 +564,94 @@ mod test {\n \n     #[test]\n     fn test_from_str_ipv4() {\n-        assert_eq!(Some(Ipv4Addr(127, 0, 0, 1)), FromStr::from_str(\"127.0.0.1\"));\n-        assert_eq!(Some(Ipv4Addr(255, 255, 255, 255)), FromStr::from_str(\"255.255.255.255\"));\n-        assert_eq!(Some(Ipv4Addr(0, 0, 0, 0)), FromStr::from_str(\"0.0.0.0\"));\n+        assert_eq!(Ok(Ipv4Addr(127, 0, 0, 1)), \"127.0.0.1\".parse());\n+        assert_eq!(Ok(Ipv4Addr(255, 255, 255, 255)), \"255.255.255.255\".parse());\n+        assert_eq!(Ok(Ipv4Addr(0, 0, 0, 0)), \"0.0.0.0\".parse());\n \n         // out of range\n-        let none: Option<IpAddr> = FromStr::from_str(\"256.0.0.1\");\n+        let none: Option<IpAddr> = \"256.0.0.1\".parse().ok();\n         assert_eq!(None, none);\n         // too short\n-        let none: Option<IpAddr> = FromStr::from_str(\"255.0.0\");\n+        let none: Option<IpAddr> = \"255.0.0\".parse().ok();\n         assert_eq!(None, none);\n         // too long\n-        let none: Option<IpAddr> = FromStr::from_str(\"255.0.0.1.2\");\n+        let none: Option<IpAddr> = \"255.0.0.1.2\".parse().ok();\n         assert_eq!(None, none);\n         // no number between dots\n-        let none: Option<IpAddr> = FromStr::from_str(\"255.0..1\");\n+        let none: Option<IpAddr> = \"255.0..1\".parse().ok();\n         assert_eq!(None, none);\n     }\n \n     #[test]\n     fn test_from_str_ipv6() {\n-        assert_eq!(Some(Ipv6Addr(0, 0, 0, 0, 0, 0, 0, 0)), FromStr::from_str(\"0:0:0:0:0:0:0:0\"));\n-        assert_eq!(Some(Ipv6Addr(0, 0, 0, 0, 0, 0, 0, 1)), FromStr::from_str(\"0:0:0:0:0:0:0:1\"));\n+        assert_eq!(Ok(Ipv6Addr(0, 0, 0, 0, 0, 0, 0, 0)), \"0:0:0:0:0:0:0:0\".parse());\n+        assert_eq!(Ok(Ipv6Addr(0, 0, 0, 0, 0, 0, 0, 1)), \"0:0:0:0:0:0:0:1\".parse());\n \n-        assert_eq!(Some(Ipv6Addr(0, 0, 0, 0, 0, 0, 0, 1)), FromStr::from_str(\"::1\"));\n-        assert_eq!(Some(Ipv6Addr(0, 0, 0, 0, 0, 0, 0, 0)), FromStr::from_str(\"::\"));\n+        assert_eq!(Ok(Ipv6Addr(0, 0, 0, 0, 0, 0, 0, 1)), \"::1\".parse());\n+        assert_eq!(Ok(Ipv6Addr(0, 0, 0, 0, 0, 0, 0, 0)), \"::\".parse());\n \n-        assert_eq!(Some(Ipv6Addr(0x2a02, 0x6b8, 0, 0, 0, 0, 0x11, 0x11)),\n-                FromStr::from_str(\"2a02:6b8::11:11\"));\n+        assert_eq!(Ok(Ipv6Addr(0x2a02, 0x6b8, 0, 0, 0, 0, 0x11, 0x11)),\n+                \"2a02:6b8::11:11\".parse());\n \n         // too long group\n-        let none: Option<IpAddr> = FromStr::from_str(\"::00000\");\n+        let none: Option<IpAddr> = \"::00000\".parse().ok();\n         assert_eq!(None, none);\n         // too short\n-        let none: Option<IpAddr> = FromStr::from_str(\"1:2:3:4:5:6:7\");\n+        let none: Option<IpAddr> = \"1:2:3:4:5:6:7\".parse().ok();\n         assert_eq!(None, none);\n         // too long\n-        let none: Option<IpAddr> = FromStr::from_str(\"1:2:3:4:5:6:7:8:9\");\n+        let none: Option<IpAddr> = \"1:2:3:4:5:6:7:8:9\".parse().ok();\n         assert_eq!(None, none);\n         // triple colon\n-        let none: Option<IpAddr> = FromStr::from_str(\"1:2:::6:7:8\");\n+        let none: Option<IpAddr> = \"1:2:::6:7:8\".parse().ok();\n         assert_eq!(None, none);\n         // two double colons\n-        let none: Option<IpAddr> = FromStr::from_str(\"1:2::6::8\");\n+        let none: Option<IpAddr> = \"1:2::6::8\".parse().ok();\n         assert_eq!(None, none);\n     }\n \n     #[test]\n     fn test_from_str_ipv4_in_ipv6() {\n-        assert_eq!(Some(Ipv6Addr(0, 0, 0, 0, 0, 0, 49152, 545)),\n-                FromStr::from_str(\"::192.0.2.33\"));\n-        assert_eq!(Some(Ipv6Addr(0, 0, 0, 0, 0, 0xFFFF, 49152, 545)),\n-                FromStr::from_str(\"::FFFF:192.0.2.33\"));\n-        assert_eq!(Some(Ipv6Addr(0x64, 0xff9b, 0, 0, 0, 0, 49152, 545)),\n-                FromStr::from_str(\"64:ff9b::192.0.2.33\"));\n-        assert_eq!(Some(Ipv6Addr(0x2001, 0xdb8, 0x122, 0xc000, 0x2, 0x2100, 49152, 545)),\n-                FromStr::from_str(\"2001:db8:122:c000:2:2100:192.0.2.33\"));\n+        assert_eq!(Ok(Ipv6Addr(0, 0, 0, 0, 0, 0, 49152, 545)),\n+                \"::192.0.2.33\".parse());\n+        assert_eq!(Ok(Ipv6Addr(0, 0, 0, 0, 0, 0xFFFF, 49152, 545)),\n+                \"::FFFF:192.0.2.33\".parse());\n+        assert_eq!(Ok(Ipv6Addr(0x64, 0xff9b, 0, 0, 0, 0, 49152, 545)),\n+                \"64:ff9b::192.0.2.33\".parse());\n+        assert_eq!(Ok(Ipv6Addr(0x2001, 0xdb8, 0x122, 0xc000, 0x2, 0x2100, 49152, 545)),\n+                \"2001:db8:122:c000:2:2100:192.0.2.33\".parse());\n \n         // colon after v4\n-        let none: Option<IpAddr> = FromStr::from_str(\"::127.0.0.1:\");\n+        let none: Option<IpAddr> = \"::127.0.0.1:\".parse().ok();\n         assert_eq!(None, none);\n         // not enough groups\n-        let none: Option<IpAddr> = FromStr::from_str(\"1.2.3.4.5:127.0.0.1\");\n+        let none: Option<IpAddr> = \"1.2.3.4.5:127.0.0.1\".parse().ok();\n         assert_eq!(None, none);\n         // too many groups\n-        let none: Option<IpAddr> =\n-            FromStr::from_str(\"1.2.3.4.5:6:7:127.0.0.1\");\n+        let none: Option<IpAddr> = \"1.2.3.4.5:6:7:127.0.0.1\".parse().ok();\n         assert_eq!(None, none);\n     }\n \n     #[test]\n     fn test_from_str_socket_addr() {\n-        assert_eq!(Some(SocketAddr { ip: Ipv4Addr(77, 88, 21, 11), port: 80 }),\n-                FromStr::from_str(\"77.88.21.11:80\"));\n-        assert_eq!(Some(SocketAddr { ip: Ipv6Addr(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), port: 53 }),\n-                FromStr::from_str(\"[2a02:6b8:0:1::1]:53\"));\n-        assert_eq!(Some(SocketAddr { ip: Ipv6Addr(0, 0, 0, 0, 0, 0, 0x7F00, 1), port: 22 }),\n-                FromStr::from_str(\"[::127.0.0.1]:22\"));\n+        assert_eq!(Ok(SocketAddr { ip: Ipv4Addr(77, 88, 21, 11), port: 80 }),\n+                \"77.88.21.11:80\".parse());\n+        assert_eq!(Ok(SocketAddr { ip: Ipv6Addr(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), port: 53 }),\n+                \"[2a02:6b8:0:1::1]:53\".parse());\n+        assert_eq!(Ok(SocketAddr { ip: Ipv6Addr(0, 0, 0, 0, 0, 0, 0x7F00, 1), port: 22 }),\n+                \"[::127.0.0.1]:22\".parse());\n \n         // without port\n-        let none: Option<SocketAddr> = FromStr::from_str(\"127.0.0.1\");\n+        let none: Option<SocketAddr> = \"127.0.0.1\".parse().ok();\n         assert_eq!(None, none);\n         // without port\n-        let none: Option<SocketAddr> = FromStr::from_str(\"127.0.0.1:\");\n+        let none: Option<SocketAddr> = \"127.0.0.1:\".parse().ok();\n         assert_eq!(None, none);\n         // wrong brackets around v4\n-        let none: Option<SocketAddr> = FromStr::from_str(\"[127.0.0.1]:22\");\n+        let none: Option<SocketAddr> = \"[127.0.0.1]:22\".parse().ok();\n         assert_eq!(None, none);\n         // port out of range\n-        let none: Option<SocketAddr> = FromStr::from_str(\"127.0.0.1:123456\");\n+        let none: Option<SocketAddr> = \"127.0.0.1:123456\".parse().ok();\n         assert_eq!(None, none);\n     }\n "}, {"sha": "122ac4c3445cc3c20f4541dec81f9bb93dd3ae7e", "filename": "src/libstd/old_io/net/tcp.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fold_io%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fold_io%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Ftcp.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -1160,7 +1160,7 @@ mod test {\n                 tx.send(TcpStream::connect(addr).unwrap()).unwrap();\n             });\n             let _l = rx.recv().unwrap();\n-            for i in 0i..1001 {\n+            for i in 0is..1001 {\n                 match a.accept() {\n                     Ok(..) => break,\n                     Err(ref e) if e.kind == TimedOut => {}\n@@ -1260,7 +1260,7 @@ mod test {\n         assert_eq!(s.read(&mut [0]).err().unwrap().kind, TimedOut);\n \n         s.set_timeout(Some(20));\n-        for i in 0i..1001 {\n+        for i in 0is..1001 {\n             match s.write(&[0; 128 * 1024]) {\n                 Ok(()) | Err(IoError { kind: ShortWrite(..), .. }) => {},\n                 Err(IoError { kind: TimedOut, .. }) => break,\n@@ -1299,7 +1299,7 @@ mod test {\n         assert_eq!(s.read(&mut [0]).err().unwrap().kind, TimedOut);\n \n         tx.send(()).unwrap();\n-        for _ in 0i..100 {\n+        for _ in 0..100 {\n             assert!(s.write(&[0;128 * 1024]).is_ok());\n         }\n     }\n@@ -1318,7 +1318,7 @@ mod test {\n \n         let mut s = a.accept().unwrap();\n         s.set_write_timeout(Some(20));\n-        for i in 0i..1001 {\n+        for i in 0is..1001 {\n             match s.write(&[0; 128 * 1024]) {\n                 Ok(()) | Err(IoError { kind: ShortWrite(..), .. }) => {},\n                 Err(IoError { kind: TimedOut, .. }) => break,\n@@ -1388,7 +1388,7 @@ mod test {\n         });\n \n         // Try to ensure that the reading clone is indeed reading\n-        for _ in 0i..50 {\n+        for _ in 0..50 {\n             ::thread::Thread::yield_now();\n         }\n "}, {"sha": "f253f9799e9bdb5af4221808f78b9acea1e77867", "filename": "src/libstd/old_io/process.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fold_io%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fold_io%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fprocess.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -393,14 +393,15 @@ impl Command {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Debug for Command {\n     /// Format the program and arguments of a Command for display. Any\n     /// non-utf8 data is lossily converted using the utf8 replacement\n     /// character.\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"{}\", String::from_utf8_lossy(self.program.as_bytes())));\n+        try!(write!(f, \"{:?}\", self.program));\n         for arg in self.args.iter() {\n-            try!(write!(f, \" '{}'\", String::from_utf8_lossy(arg.as_bytes())));\n+            try!(write!(f, \" '{:?}'\", arg));\n         }\n         Ok(())\n     }\n@@ -1142,7 +1143,7 @@ mod tests {\n     fn test_zero() {\n         let mut p = sleeper();\n         p.signal_kill().unwrap();\n-        for _ in 0i..20 {\n+        for _ in 0..20 {\n             if p.signal(0).is_err() {\n                 assert!(!p.wait().unwrap().success());\n                 return"}, {"sha": "600ca60349ae26ede5bee71d797a58d97b401f0d", "filename": "src/libstd/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -1484,7 +1484,7 @@ mod tests {\n     #[ignore]\n     fn test_getenv_big() {\n         let mut s = \"\".to_string();\n-        let mut i = 0i;\n+        let mut i = 0;\n         while i < 100 {\n             s.push_str(\"aaaaaaaaaa\");\n             i += 1;"}, {"sha": "6a0c8a930107095a6216df3f646f2ac19476ea2c", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -19,6 +19,7 @@ use iter::{AdditiveIterator, Extend};\n use iter::{Iterator, IteratorExt, Map};\n use marker::Sized;\n use option::Option::{self, Some, None};\n+use result::Result::{self, Ok, Err};\n use slice::{AsSlice, Split, SliceExt, SliceConcatExt};\n use str::{self, FromStr, StrExt};\n use vec::Vec;\n@@ -86,11 +87,19 @@ impl Ord for Path {\n }\n \n impl FromStr for Path {\n-    fn from_str(s: &str) -> Option<Path> {\n-        Path::new_opt(s)\n+    type Err = ParsePathError;\n+    fn from_str(s: &str) -> Result<Path, ParsePathError> {\n+        match Path::new_opt(s) {\n+            Some(p) => Ok(p),\n+            None => Err(ParsePathError),\n+        }\n     }\n }\n \n+/// Valuelue indicating that a path could not be parsed from a string.\n+#[derive(Debug, Clone, PartialEq, Copy)]\n+pub struct ParsePathError;\n+\n impl<S: hash::Writer + hash::Hasher> hash::Hash<S> for Path {\n     #[inline]\n     fn hash(&self, state: &mut S) {"}, {"sha": "b524b89ef9fb27b24a18bf26bccd5c90cfcbf392", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -27,6 +27,7 @@ use mem;\n use option::Option::{self, Some, None};\n #[cfg(stage0)]\n use ops::FullRange;\n+use result::Result::{self, Ok, Err};\n use slice::{SliceExt, SliceConcatExt};\n use str::{SplitTerminator, FromStr, StrExt};\n use string::{String, ToString};\n@@ -115,11 +116,19 @@ impl Ord for Path {\n }\n \n impl FromStr for Path {\n-    fn from_str(s: &str) -> Option<Path> {\n-        Path::new_opt(s)\n+    type Err = ParsePathError;\n+    fn from_str(s: &str) -> Result<Path, ParsePathError> {\n+        match Path::new_opt(s) {\n+            Some(p) => Ok(p),\n+            None => Err(ParsePathError),\n+        }\n     }\n }\n \n+/// Value indicating that a path could not be parsed from a string.\n+#[derive(Debug, Clone, PartialEq, Copy)]\n+pub struct ParsePathError;\n+\n impl<S: hash::Writer + hash::Hasher> hash::Hash<S> for Path {\n     #[cfg(not(test))]\n     #[inline]\n@@ -557,7 +566,7 @@ impl GenericPath for Path {\n                     }\n                     (Some(a), Some(_)) => {\n                         comps.push(\"..\");\n-                        for _ in itb {\n+                        for _ in itb.by_ref() {\n                             comps.push(\"..\");\n                         }\n                         comps.push(a);"}, {"sha": "211abc2fc83e70f3cf2aae31c24b423b8cdc0462", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -427,7 +427,7 @@ pub fn random<T: Rand>() -> T {\n /// use std::rand::{thread_rng, sample};\n ///\n /// let mut rng = thread_rng();\n-/// let sample = sample(&mut rng, 1i..100, 5);\n+/// let sample = sample(&mut rng, 1..100, 5);\n /// println!(\"{:?}\", sample);\n /// ```\n pub fn sample<T, I: Iterator<Item=T>, R: Rng>(rng: &mut R,\n@@ -481,16 +481,16 @@ mod test {\n     fn test_gen_range() {\n         let mut r = thread_rng();\n         for _ in 0u..1000 {\n-            let a = r.gen_range(-3i, 42);\n+            let a = r.gen_range(-3, 42);\n             assert!(a >= -3 && a < 42);\n-            assert_eq!(r.gen_range(0i, 1), 0);\n-            assert_eq!(r.gen_range(-12i, -11), -12);\n+            assert_eq!(r.gen_range(0, 1), 0);\n+            assert_eq!(r.gen_range(-12, -11), -12);\n         }\n \n         for _ in 0u..1000 {\n-            let a = r.gen_range(10i, 42);\n+            let a = r.gen_range(10, 42);\n             assert!(a >= 10 && a < 42);\n-            assert_eq!(r.gen_range(0i, 1), 0);\n+            assert_eq!(r.gen_range(0, 1), 0);\n             assert_eq!(r.gen_range(3_000_000, 3_000_001), 3_000_000);\n         }\n \n@@ -500,7 +500,7 @@ mod test {\n     #[should_fail]\n     fn test_gen_range_panic_int() {\n         let mut r = thread_rng();\n-        r.gen_range(5i, -2);\n+        r.gen_range(5, -2);\n     }\n \n     #[test]\n@@ -544,7 +544,7 @@ mod test {\n     #[test]\n     fn test_choose() {\n         let mut r = thread_rng();\n-        assert_eq!(r.choose(&[1i, 1, 1]).map(|&x|x), Some(1));\n+        assert_eq!(r.choose(&[1, 1, 1]).map(|&x|x), Some(1));\n \n         let v: &[int] = &[];\n         assert_eq!(r.choose(v), None);\n@@ -555,16 +555,16 @@ mod test {\n         let mut r = thread_rng();\n         let empty: &mut [int] = &mut [];\n         r.shuffle(empty);\n-        let mut one = [1i];\n+        let mut one = [1];\n         r.shuffle(&mut one);\n         let b: &[_] = &[1];\n         assert_eq!(one, b);\n \n-        let mut two = [1i, 2];\n+        let mut two = [1, 2];\n         r.shuffle(&mut two);\n         assert!(two == [1, 2] || two == [2, 1]);\n \n-        let mut x = [1i, 1, 1];\n+        let mut x = [1, 1, 1];\n         r.shuffle(&mut x);\n         let b: &[_] = &[1, 1, 1];\n         assert_eq!(x, b);\n@@ -574,7 +574,7 @@ mod test {\n     fn test_thread_rng() {\n         let mut r = thread_rng();\n         r.gen::<int>();\n-        let mut v = [1i, 1, 1];\n+        let mut v = [1, 1, 1];\n         r.shuffle(&mut v);\n         let b: &[_] = &[1, 1, 1];\n         assert_eq!(v, b);\n@@ -597,8 +597,8 @@ mod test {\n \n     #[test]\n     fn test_sample() {\n-        let min_val = 1i;\n-        let max_val = 100i;\n+        let min_val = 1;\n+        let max_val = 100;\n \n         let mut r = thread_rng();\n         let vals = (min_val..max_val).collect::<Vec<int>>();"}, {"sha": "fb40a6c8f609d37c4005d488f207f31147baf191", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -160,7 +160,7 @@ pub fn panicking() -> bool {\n // An uninlined, unmangled function upon which to slap yer breakpoints\n #[inline(never)]\n #[no_mangle]\n-#[allow(private_no_mangle_fns)]\n+#[cfg_attr(not(stage0), allow(private_no_mangle_fns))]\n fn rust_panic(cause: Box<Any + Send>) -> ! {\n     rtdebug!(\"begin_unwind()\");\n \n@@ -238,7 +238,7 @@ pub mod eabi {\n \n     #[lang=\"eh_personality\"]\n     #[no_mangle] // referenced from rust_try.ll\n-    #[allow(private_no_mangle_fns)]\n+    #[cfg_attr(not(stage0), allow(private_no_mangle_fns))]\n     extern fn rust_eh_personality(\n         version: c_int,\n         actions: uw::_Unwind_Action,"}, {"sha": "f5727a38b69976fee9652dec5ae55d5129cb0c0b", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -51,7 +51,7 @@ pub fn min_stack() -> uint {\n         0 => {}\n         n => return n - 1,\n     }\n-    let amt = os::getenv(\"RUST_MIN_STACK\").and_then(|s| s.parse());\n+    let amt = os::getenv(\"RUST_MIN_STACK\").and_then(|s| s.parse().ok());\n     let amt = amt.unwrap_or(2 * 1024 * 1024);\n     // 0 is our sentinel value, so ensure that we'll never see 0 after\n     // initialization has run\n@@ -64,7 +64,7 @@ pub fn min_stack() -> uint {\n pub fn default_sched_threads() -> uint {\n     match os::getenv(\"RUST_THREADS\") {\n         Some(nstr) => {\n-            let opt_n: Option<uint> = nstr.parse();\n+            let opt_n: Option<uint> = nstr.parse().ok();\n             match opt_n {\n                 Some(n) if n > 0 => n,\n                 _ => panic!(\"`RUST_THREADS` is `{}`, should be a positive integer\", nstr)"}, {"sha": "8340652d19ae6d8f06e225c66537b5bf90e1bf55", "filename": "src/libstd/sync/future.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fsync%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fsync%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ffuture.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -193,7 +193,7 @@ mod test {\n \n     #[test]\n     fn test_get_ref_method() {\n-        let mut f = Future::from_value(22i);\n+        let mut f = Future::from_value(22);\n         assert_eq!(*f.get_ref(), 22);\n     }\n "}, {"sha": "39c57a21d752ade70be4cf47b70ed3edf2fff240", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -59,9 +59,9 @@\n //! // Create a simple streaming channel\n //! let (tx, rx) = channel();\n //! Thread::spawn(move|| {\n-//!     tx.send(10i).unwrap();\n+//!     tx.send(10).unwrap();\n //! });\n-//! assert_eq!(rx.recv().unwrap(), 10i);\n+//! assert_eq!(rx.recv().unwrap(), 10);\n //! ```\n //!\n //! Shared usage:\n@@ -74,14 +74,14 @@\n //! // where tx is the sending half (tx for transmission), and rx is the receiving\n //! // half (rx for receiving).\n //! let (tx, rx) = channel();\n-//! for i in 0i..10i {\n+//! for i in 0..10 {\n //!     let tx = tx.clone();\n //!     Thread::spawn(move|| {\n //!         tx.send(i).unwrap();\n //!     });\n //! }\n //!\n-//! for _ in 0i..10i {\n+//! for _ in 0..10 {\n //!     let j = rx.recv().unwrap();\n //!     assert!(0 <= j && j < 10);\n //! }\n@@ -382,8 +382,8 @@ impl<T> !Sync for SyncSender<T> {}\n /// A `send` operation can only fail if the receiving end of a channel is\n /// disconnected, implying that the data could never be received. The error\n /// contains the data being sent as a payload so it can be recovered.\n-#[derive(PartialEq, Eq)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(PartialEq, Eq, Clone, Copy)]\n pub struct SendError<T>(pub T);\n \n /// An error returned from the `recv` function on a `Receiver`.\n@@ -396,7 +396,7 @@ pub struct RecvError;\n \n /// This enumeration is the list of the possible reasons that try_recv could not\n /// return data when called.\n-#[derive(PartialEq, Clone, Copy, Debug)]\n+#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum TryRecvError {\n     /// This channel is currently empty, but the sender(s) have not yet\n@@ -412,8 +412,8 @@ pub enum TryRecvError {\n \n /// This enumeration is the list of the possible error outcomes for the\n /// `SyncSender::try_send` method.\n-#[derive(PartialEq, Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(PartialEq, Eq, Clone, Copy)]\n pub enum TrySendError<T> {\n     /// The data could not be sent on the channel because it would require that\n     /// the callee block to send the data.\n@@ -514,15 +514,15 @@ pub fn channel<T: Send>() -> (Sender<T>, Receiver<T>) {\n /// let (tx, rx) = sync_channel(1);\n ///\n /// // this returns immediately\n-/// tx.send(1i).unwrap();\n+/// tx.send(1).unwrap();\n ///\n /// Thread::spawn(move|| {\n ///     // this will block until the previous message has been received\n-///     tx.send(2i).unwrap();\n+///     tx.send(2).unwrap();\n /// });\n ///\n-/// assert_eq!(rx.recv().unwrap(), 1i);\n-/// assert_eq!(rx.recv().unwrap(), 2i);\n+/// assert_eq!(rx.recv().unwrap(), 1);\n+/// assert_eq!(rx.recv().unwrap(), 2);\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn sync_channel<T: Send>(bound: uint) -> (SyncSender<T>, Receiver<T>) {\n@@ -562,11 +562,11 @@ impl<T: Send> Sender<T> {\n     /// let (tx, rx) = channel();\n     ///\n     /// // This send is always successful\n-    /// tx.send(1i).unwrap();\n+    /// tx.send(1).unwrap();\n     ///\n     /// // This send will fail because the receiver is gone\n     /// drop(rx);\n-    /// assert_eq!(tx.send(1i).err().unwrap().0, 1);\n+    /// assert_eq!(tx.send(1).err().unwrap().0, 1);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn send(&self, t: T) -> Result<(), SendError<T>> {\n@@ -1045,15 +1045,15 @@ mod test {\n     #[test]\n     fn drop_full() {\n         let (tx, _rx) = channel();\n-        tx.send(box 1i).unwrap();\n+        tx.send(box 1).unwrap();\n     }\n \n     #[test]\n     fn drop_full_shared() {\n         let (tx, _rx) = channel();\n         drop(tx.clone());\n         drop(tx.clone());\n-        tx.send(box 1i).unwrap();\n+        tx.send(box 1).unwrap();\n     }\n \n     #[test]\n@@ -1147,7 +1147,7 @@ mod test {\n     fn stress() {\n         let (tx, rx) = channel::<int>();\n         let t = Thread::scoped(move|| {\n-            for _ in 0u..10000 { tx.send(1i).unwrap(); }\n+            for _ in 0u..10000 { tx.send(1).unwrap(); }\n         });\n         for _ in 0u..10000 {\n             assert_eq!(rx.recv().unwrap(), 1);\n@@ -1187,13 +1187,13 @@ mod test {\n         let (tx2, rx2) = channel::<int>();\n         let t1 = Thread::scoped(move|| {\n             tx1.send(()).unwrap();\n-            for _ in 0i..40 {\n+            for _ in 0..40 {\n                 assert_eq!(rx2.recv().unwrap(), 1);\n             }\n         });\n         rx1.recv().unwrap();\n         let t2 = Thread::scoped(move|| {\n-            for _ in 0i..40 {\n+            for _ in 0..40 {\n                 tx2.send(1).unwrap();\n             }\n         });\n@@ -1205,7 +1205,7 @@ mod test {\n     fn recv_from_outside_runtime() {\n         let (tx, rx) = channel::<int>();\n         let t = Thread::scoped(move|| {\n-            for _ in 0i..40 {\n+            for _ in 0..40 {\n                 assert_eq!(rx.recv().unwrap(), 1);\n             }\n         });\n@@ -1391,9 +1391,9 @@ mod test {\n         for _ in 0..stress_factor() {\n             let (tx, rx) = channel();\n             let _t = Thread::spawn(move|| {\n-                tx.send(box 10i).unwrap();\n+                tx.send(box 10).unwrap();\n             });\n-            assert!(rx.recv().unwrap() == box 10i);\n+            assert!(rx.recv().unwrap() == box 10);\n         }\n     }\n \n@@ -1429,8 +1429,8 @@ mod test {\n     fn recv_a_lot() {\n         // Regression test that we don't run out of stack in scheduler context\n         let (tx, rx) = channel();\n-        for _ in 0i..10000 { tx.send(()).unwrap(); }\n-        for _ in 0i..10000 { rx.recv().unwrap(); }\n+        for _ in 0..10000 { tx.send(()).unwrap(); }\n+        for _ in 0..10000 { rx.recv().unwrap(); }\n     }\n \n     #[test]\n@@ -1567,7 +1567,7 @@ mod sync_tests {\n     #[test]\n     fn drop_full() {\n         let (tx, _rx) = sync_channel(1);\n-        tx.send(box 1i).unwrap();\n+        tx.send(box 1).unwrap();\n     }\n \n     #[test]\n@@ -1855,9 +1855,9 @@ mod sync_tests {\n         for _ in 0..stress_factor() {\n             let (tx, rx) = sync_channel::<Box<int>>(0);\n             let _t = Thread::spawn(move|| {\n-                tx.send(box 10i).unwrap();\n+                tx.send(box 10).unwrap();\n             });\n-            assert!(rx.recv().unwrap() == box 10i);\n+            assert!(rx.recv().unwrap() == box 10);\n         }\n     }\n "}, {"sha": "3980d2a1fefb521820fbe1b45863f6d45d584633", "filename": "src/libstd/sync/mpsc/mpsc_queue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -165,8 +165,8 @@ mod tests {\n     #[test]\n     fn test_full() {\n         let q = Queue::new();\n-        q.push(box 1i);\n-        q.push(box 2i);\n+        q.push(box 1);\n+        q.push(box 2);\n     }\n \n     #[test]"}, {"sha": "85c7572404b9509117bed8e3c9695d280bd44099", "filename": "src/libstd/sync/mpsc/select.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -32,15 +32,15 @@\n //! let (tx1, rx1) = channel();\n //! let (tx2, rx2) = channel();\n //!\n-//! tx1.send(1i).unwrap();\n-//! tx2.send(2i).unwrap();\n+//! tx1.send(1).unwrap();\n+//! tx2.send(2).unwrap();\n //!\n //! select! {\n //!     val = rx1.recv() => {\n-//!         assert_eq!(val.unwrap(), 1i);\n+//!         assert_eq!(val.unwrap(), 1);\n //!     },\n //!     val = rx2.recv() => {\n-//!         assert_eq!(val.unwrap(), 2i);\n+//!         assert_eq!(val.unwrap(), 2);\n //!     }\n //! }\n //! ```"}, {"sha": "c80aa56717315d9f5cdb76b0d706ab6983989a72", "filename": "src/libstd/sync/mpsc/spsc_queue.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -253,9 +253,9 @@ mod test {\n     fn smoke() {\n         unsafe {\n             let queue = Queue::new(0);\n-            queue.push(1i);\n+            queue.push(1);\n             queue.push(2);\n-            assert_eq!(queue.pop(), Some(1i));\n+            assert_eq!(queue.pop(), Some(1));\n             assert_eq!(queue.pop(), Some(2));\n             assert_eq!(queue.pop(), None);\n             queue.push(3);\n@@ -270,7 +270,7 @@ mod test {\n     fn peek() {\n         unsafe {\n             let queue = Queue::new(0);\n-            queue.push(vec![1i]);\n+            queue.push(vec![1]);\n \n             // Ensure the borrowchecker works\n             match queue.peek() {\n@@ -290,16 +290,16 @@ mod test {\n     fn drop_full() {\n         unsafe {\n             let q = Queue::new(0);\n-            q.push(box 1i);\n-            q.push(box 2i);\n+            q.push(box 1);\n+            q.push(box 2);\n         }\n     }\n \n     #[test]\n     fn smoke_bound() {\n         unsafe {\n             let q = Queue::new(0);\n-            q.push(1i);\n+            q.push(1);\n             q.push(2);\n             assert_eq!(q.pop(), Some(1));\n             assert_eq!(q.pop(), Some(2));\n@@ -328,15 +328,15 @@ mod test {\n                 for _ in 0u..100000 {\n                     loop {\n                         match q2.pop() {\n-                            Some(1i) => break,\n+                            Some(1) => break,\n                             Some(_) => panic!(),\n                             None => {}\n                         }\n                     }\n                 }\n                 tx.send(()).unwrap();\n             });\n-            for _ in 0i..100000 {\n+            for _ in 0..100000 {\n                 q.push(1);\n             }\n             rx.recv().unwrap();"}, {"sha": "7531d5b058d79686c1e425435fd82cbbb32b569d", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -428,7 +428,7 @@ mod test {\n \n     #[test]\n     fn test_arc_condvar_poison() {\n-        let packet = Packet(Arc::new((Mutex::new(1i), Condvar::new())));\n+        let packet = Packet(Arc::new((Mutex::new(1), Condvar::new())));\n         let packet2 = Packet(packet.0.clone());\n         let (tx, rx) = channel();\n \n@@ -457,7 +457,7 @@ mod test {\n \n     #[test]\n     fn test_mutex_arc_poison() {\n-        let arc = Arc::new(Mutex::new(1i));\n+        let arc = Arc::new(Mutex::new(1));\n         let arc2 = arc.clone();\n         let _ = Thread::scoped(move|| {\n             let lock = arc2.lock().unwrap();\n@@ -470,7 +470,7 @@ mod test {\n     fn test_mutex_arc_nested() {\n         // Tests nested mutexes and access\n         // to underlying data.\n-        let arc = Arc::new(Mutex::new(1i));\n+        let arc = Arc::new(Mutex::new(1));\n         let arc2 = Arc::new(Mutex::new(arc));\n         let (tx, rx) = channel();\n         let _t = Thread::spawn(move|| {\n@@ -484,7 +484,7 @@ mod test {\n \n     #[test]\n     fn test_mutex_arc_access_in_unwind() {\n-        let arc = Arc::new(Mutex::new(1i));\n+        let arc = Arc::new(Mutex::new(1));\n         let arc2 = arc.clone();\n         let _ = Thread::scoped(move|| -> () {\n             struct Unwinder {"}, {"sha": "2df211f37687fa4f61129957de178cef0f15f09e", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -134,7 +134,7 @@ mod test {\n     #[test]\n     fn smoke_once() {\n         static O: Once = ONCE_INIT;\n-        let mut a = 0i;\n+        let mut a = 0;\n         O.call_once(|| a += 1);\n         assert_eq!(a, 1);\n         O.call_once(|| a += 1);"}, {"sha": "95b570dd9c82a858bd7e5e46a3b2c5fd675c9548", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -41,7 +41,7 @@ use sys_common::rwlock as sys;\n /// ```\n /// use std::sync::RwLock;\n ///\n-/// let lock = RwLock::new(5i);\n+/// let lock = RwLock::new(5);\n ///\n /// // many reader locks can be held at once\n /// {\n@@ -437,7 +437,7 @@ mod tests {\n \n     #[test]\n     fn test_rw_arc_poison_wr() {\n-        let arc = Arc::new(RwLock::new(1i));\n+        let arc = Arc::new(RwLock::new(1));\n         let arc2 = arc.clone();\n         let _: Result<uint, _> = Thread::scoped(move|| {\n             let _lock = arc2.write().unwrap();\n@@ -448,7 +448,7 @@ mod tests {\n \n     #[test]\n     fn test_rw_arc_poison_ww() {\n-        let arc = Arc::new(RwLock::new(1i));\n+        let arc = Arc::new(RwLock::new(1));\n         let arc2 = arc.clone();\n         let _: Result<uint, _> = Thread::scoped(move|| {\n             let _lock = arc2.write().unwrap();\n@@ -459,7 +459,7 @@ mod tests {\n \n     #[test]\n     fn test_rw_arc_no_poison_rr() {\n-        let arc = Arc::new(RwLock::new(1i));\n+        let arc = Arc::new(RwLock::new(1));\n         let arc2 = arc.clone();\n         let _: Result<uint, _> = Thread::scoped(move|| {\n             let _lock = arc2.read().unwrap();\n@@ -470,7 +470,7 @@ mod tests {\n     }\n     #[test]\n     fn test_rw_arc_no_poison_rw() {\n-        let arc = Arc::new(RwLock::new(1i));\n+        let arc = Arc::new(RwLock::new(1));\n         let arc2 = arc.clone();\n         let _: Result<uint, _> = Thread::scoped(move|| {\n             let _lock = arc2.read().unwrap();\n@@ -482,7 +482,7 @@ mod tests {\n \n     #[test]\n     fn test_rw_arc() {\n-        let arc = Arc::new(RwLock::new(0i));\n+        let arc = Arc::new(RwLock::new(0));\n         let arc2 = arc.clone();\n         let (tx, rx) = channel();\n \n@@ -520,7 +520,7 @@ mod tests {\n \n     #[test]\n     fn test_rw_arc_access_in_unwind() {\n-        let arc = Arc::new(RwLock::new(1i));\n+        let arc = Arc::new(RwLock::new(1));\n         let arc2 = arc.clone();\n         let _ = Thread::scoped(move|| -> () {\n             struct Unwinder {"}, {"sha": "a71676c6bf229984c65710829674622a86305110", "filename": "src/libstd/sys/common/backtrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -54,7 +54,7 @@ pub fn demangle(writer: &mut Writer, s: &str) -> IoResult<()> {\n         let mut chars = inner.chars();\n         while valid {\n             let mut i = 0;\n-            for c in chars {\n+            for c in chars.by_ref() {\n                 if c.is_numeric() {\n                     i = i * 10 + c as uint - '0' as uint;\n                 } else {"}, {"sha": "7c9758ca9242d88cd28a2685d6a3224c270c5dfe", "filename": "src/libstd/sys/common/thread_info.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fsys%2Fcommon%2Fthread_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fsys%2Fcommon%2Fthread_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fthread_info.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -56,6 +56,10 @@ pub fn stack_guard() -> uint {\n \n pub fn set(stack_bounds: (uint, uint), stack_guard: uint, thread: Thread) {\n     THREAD_INFO.with(|c| assert!(c.borrow().is_none()));\n+    match thread.name() {\n+        Some(name) => unsafe { ::sys::thread::set_name(name.as_slice()); },\n+        None => {}\n+    }\n     THREAD_INFO.with(move |c| *c.borrow_mut() = Some(ThreadInfo{\n         stack_bounds: stack_bounds,\n         stack_guard: stack_guard,"}, {"sha": "dd343baa7c9c3842d4cc900a82253fbcd44e17d8", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -196,7 +196,7 @@ pub fn load_self() -> Option<Vec<u8>> {\n \n #[cfg(target_os = \"dragonfly\")]\n pub fn load_self() -> Option<Vec<u8>> {\n-    use std::io;\n+    use old_io;\n \n     match old_io::fs::readlink(&Path::new(\"/proc/curproc/file\")) {\n         Ok(path) => Some(path.into_vec()),"}, {"sha": "b004a47f8a349481b05fb65296c8345234f36223", "filename": "src/libstd/sys/unix/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -509,7 +509,7 @@ impl Process {\n         // which will wake up the other end at some point, so we just allow this\n         // signal to be coalesced with the pending signals on the pipe.\n         extern fn sigchld_handler(_signum: libc::c_int) {\n-            let msg = 1i;\n+            let msg = 1;\n             match unsafe {\n                 libc::write(WRITE_FD, &msg as *const _ as *const libc::c_void, 1)\n             } {"}, {"sha": "a526f3393f2d35e30cdd403d5bdc9cb85878b63f", "filename": "src/libstd/sys/unix/stack_overflow.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -162,7 +162,7 @@ mod imp {\n \n         pub static SIGSTKSZ: libc::size_t = 8192;\n \n-        pub const SIG_DFL: sighandler_t = 0i as sighandler_t;\n+        pub const SIG_DFL: sighandler_t = 0 as sighandler_t;\n \n         // This definition is not as accurate as it could be, {si_addr} is\n         // actually a giant union. Currently we're only interested in that field,\n@@ -214,7 +214,7 @@ mod imp {\n \n         pub const SIGSTKSZ: libc::size_t = 131072;\n \n-        pub const SIG_DFL: sighandler_t = 0i as sighandler_t;\n+        pub const SIG_DFL: sighandler_t = 0 as sighandler_t;\n \n         pub type sigset_t = u32;\n \n@@ -271,7 +271,7 @@ mod imp {\n     }\n \n     pub unsafe fn make_handler() -> super::Handler {\n-        super::Handler { _data: 0i as *mut libc::c_void }\n+        super::Handler { _data: 0 as *mut libc::c_void }\n     }\n \n     pub unsafe fn drop_handler(_handler: &mut super::Handler) {"}, {"sha": "26a450b8599dfaad964b60ccea1b1da62b9b0dff", "filename": "src/libstd/sys/unix/thread.rs", "status": "modified", "additions": 41, "deletions": 2, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fthread.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -17,6 +17,7 @@ use ptr;\n use libc::consts::os::posix01::{PTHREAD_CREATE_JOINABLE, PTHREAD_STACK_MIN};\n use libc;\n use thunk::Thunk;\n+use ffi::CString;\n \n use sys_common::stack::RED_ZONE;\n use sys_common::thread::*;\n@@ -206,6 +207,37 @@ pub unsafe fn create(stack: uint, p: Thunk) -> rust_thread {\n     native\n }\n \n+#[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n+pub unsafe fn set_name(name: &str) {\n+    // pthread_setname_np() since glibc 2.12\n+    // availability autodetected via weak linkage\n+    let cname = CString::from_slice(name.as_bytes());\n+    type F = unsafe extern \"C\" fn(libc::pthread_t, *const libc::c_char) -> libc::c_int;\n+    extern {\n+        #[linkage = \"extern_weak\"]\n+        static pthread_setname_np: *const ();\n+    }\n+    if !pthread_setname_np.is_null() {\n+        unsafe {\n+            mem::transmute::<*const (), F>(pthread_setname_np)(pthread_self(), cname.as_ptr());\n+        }\n+    }\n+}\n+\n+#[cfg(any(target_os = \"freebsd\", target_os = \"dragonfly\"))]\n+pub unsafe fn set_name(name: &str) {\n+    // pthread_set_name_np() since almost forever on all BSDs\n+    let cname = CString::from_slice(name.as_bytes());\n+    pthread_set_name_np(pthread_self(), cname.as_ptr());\n+}\n+\n+#[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n+pub unsafe fn set_name(name: &str) {\n+    // pthread_setname_np() since OS X 10.6 and iOS 3.2\n+    let cname = CString::from_slice(name.as_bytes());\n+    pthread_setname_np(cname.as_ptr());\n+}\n+\n pub unsafe fn join(native: rust_thread) {\n     assert_eq!(pthread_join(native, ptr::null_mut()), 0);\n }\n@@ -246,7 +278,7 @@ fn min_stack_size(_: *const libc::pthread_attr_t) -> libc::size_t {\n     PTHREAD_STACK_MIN\n }\n \n-#[cfg(any(target_os = \"linux\"))]\n+#[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n extern {\n     pub fn pthread_self() -> libc::pthread_t;\n     pub fn pthread_getattr_np(native: libc::pthread_t,\n@@ -258,11 +290,18 @@ extern {\n                                  stacksize: *mut libc::size_t) -> libc::c_int;\n }\n \n-#[cfg(target_os = \"macos\")]\n+#[cfg(any(target_os = \"freebsd\", target_os = \"dragonfly\"))]\n+extern {\n+    pub fn pthread_self() -> libc::pthread_t;\n+    fn pthread_set_name_np(tid: libc::pthread_t, name: *const libc::c_char);\n+}\n+\n+#[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n extern {\n     pub fn pthread_self() -> libc::pthread_t;\n     pub fn pthread_get_stackaddr_np(thread: libc::pthread_t) -> *mut libc::c_void;\n     pub fn pthread_get_stacksize_np(thread: libc::pthread_t) -> libc::size_t;\n+    fn pthread_setname_np(name: *const libc::c_char) -> libc::c_int;\n }\n \n extern {"}, {"sha": "1be1a412ffa9ff9c7dead7f4bf5537a4f4e1010c", "filename": "src/libstd/sys/windows/backtrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -333,7 +333,7 @@ pub fn write(w: &mut Writer) -> IoResult<()> {\n     let _c = Cleanup { handle: process, SymCleanup: SymCleanup };\n \n     // And now that we're done with all the setup, do the stack walking!\n-    let mut i = 0i;\n+    let mut i = 0;\n     try!(write!(w, \"stack backtrace:\\n\"));\n     while StackWalk64(image, process, thread, &mut frame, &mut context,\n                       ptr::null_mut(),"}, {"sha": "0cb4c573ae3ef63d47c48d04bac02d545eb638cf", "filename": "src/libstd/sys/windows/stack_overflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fsys%2Fwindows%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fsys%2Fwindows%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fstack_overflow.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -81,7 +81,7 @@ pub unsafe fn make_handler() -> Handler {\n         panic!(\"failed to reserve stack space for exception handling\");\n     }\n \n-    Handler { _data: 0i as *mut libc::c_void }\n+    Handler { _data: 0 as *mut libc::c_void }\n }\n \n pub struct EXCEPTION_RECORD {"}, {"sha": "a94adcb3bc7b93b80a61f5a8d621d3c1b96d6565", "filename": "src/libstd/sys/windows/thread.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -67,6 +67,13 @@ pub unsafe fn create(stack: uint, p: Thunk) -> rust_thread {\n     return ret;\n }\n \n+pub unsafe fn set_name(_name: &str) {\n+    // Windows threads are nameless\n+    // The names in MSVC debugger are obtained using a \"magic\" exception,\n+    // which requires a use of MS C++ extensions.\n+    // See https://msdn.microsoft.com/en-us/library/xcb2z8hs.aspx\n+}\n+\n pub unsafe fn join(native: rust_thread) {\n     use libc::consts::os::extra::INFINITE;\n     WaitForSingleObject(native, INFINITE);"}, {"sha": "0f8ceed39a6ccbfbcbcf98790fa0c618896795df", "filename": "src/libstd/sys/windows/thread_local.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -235,7 +235,7 @@ unsafe extern \"system\" fn on_tls_callback(h: LPVOID,\n \n unsafe fn run_dtors() {\n     let mut any_run = true;\n-    for _ in 0..5i {\n+    for _ in 0..5 {\n         if !any_run { break }\n         any_run = false;\n         let dtors = {"}, {"sha": "988b13cd160462b42fa62200dcc8fac8663d7005", "filename": "src/libstd/tuple.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibstd%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftuple.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -35,18 +35,18 @@\n //! let x = (\"colorless\",  \"green\", \"ideas\", \"sleep\", \"furiously\");\n //! assert_eq!(x.3, \"sleep\");\n //!\n-//! let v = (3i, 3i);\n-//! let u = (1i, -5i);\n-//! assert_eq!(v.0 * u.0 + v.1 * u.1, -12i);\n+//! let v = (3, 3);\n+//! let u = (1, -5);\n+//! assert_eq!(v.0 * u.0 + v.1 * u.1, -12);\n //! ```\n //!\n //! Using traits implemented for tuples:\n //!\n //! ```\n //! use std::default::Default;\n //!\n-//! let a = (1i, 2i);\n-//! let b = (3i, 4i);\n+//! let a = (1, 2);\n+//! let b = (3, 4);\n //! assert!(a != b);\n //!\n //! let c = b.clone();"}, {"sha": "d7283db25a5f2eedc23e4347b721e79716b599ce", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -788,6 +788,7 @@ pub enum MatchSource {\n     Normal,\n     IfLetDesugar { contains_else_clause: bool },\n     WhileLetDesugar,\n+    ForLoopDesugar,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]"}, {"sha": "5736400313e95f92dd40f5c6e5cd682f500836a6", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 93, "deletions": 3, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -225,11 +225,101 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n             fld.cx.expr(span, ast::ExprLoop(loop_block, opt_ident))\n         }\n \n+        // Desugar ExprForLoop\n+        // From: `[opt_ident]: for <pat> in <head> <body>`\n         ast::ExprForLoop(pat, head, body, opt_ident) => {\n-            let pat = fld.fold_pat(pat);\n+            // to:\n+            //\n+            //   match ::std::iter::IntoIterator::into_iter(<head>) {\n+            //     mut iter => {\n+            //       [opt_ident]: loop {\n+            //         match ::std::iter::Iterator::next(&mut iter) {\n+            //           ::std::option::Option::Some(<pat>) => <body>,\n+            //           ::std::option::Option::None => break\n+            //         }\n+            //       }\n+            //     }\n+            //   }\n+\n+            // expand <head>\n             let head = fld.fold_expr(head);\n-            let (body, opt_ident) = expand_loop_block(body, opt_ident, fld);\n-            fld.cx.expr(span, ast::ExprForLoop(pat, head, body, opt_ident))\n+\n+            // create an hygienic ident\n+            let iter = {\n+                let ident = fld.cx.ident_of(\"iter\");\n+                let new_ident = fresh_name(&ident);\n+                let rename = (ident, new_ident);\n+                let mut rename_list = vec![rename];\n+                let mut rename_fld = IdentRenamer{ renames: &mut rename_list };\n+\n+                rename_fld.fold_ident(ident)\n+            };\n+\n+            let pat_span = pat.span;\n+            // `:;std::option::Option::Some(<pat>) => <body>`\n+            let pat_arm = {\n+                let body_expr = fld.cx.expr_block(body);\n+                let some_pat = fld.cx.pat_some(pat_span, pat);\n+\n+                fld.cx.arm(pat_span, vec![some_pat], body_expr)\n+            };\n+\n+            // `::std::option::Option::None => break`\n+            let break_arm = {\n+                let break_expr = fld.cx.expr_break(span);\n+\n+                fld.cx.arm(span, vec![fld.cx.pat_none(span)], break_expr)\n+            };\n+\n+            // `match ::std::iter::Iterator::next(&mut iter) { ... }`\n+            let match_expr = {\n+                let next_path = {\n+                    let strs = vec![\n+                        fld.cx.ident_of(\"std\"),\n+                        fld.cx.ident_of(\"iter\"),\n+                        fld.cx.ident_of(\"Iterator\"),\n+                        fld.cx.ident_of(\"next\"),\n+                    ];\n+\n+                    fld.cx.path_global(span, strs)\n+                };\n+                let ref_mut_iter = fld.cx.expr_mut_addr_of(span, fld.cx.expr_ident(span, iter));\n+                let next_expr =\n+                    fld.cx.expr_call(span, fld.cx.expr_path(next_path), vec![ref_mut_iter]);\n+                let arms = vec![pat_arm, break_arm];\n+\n+                fld.cx.expr(pat_span,\n+                            ast::ExprMatch(next_expr, arms, ast::MatchSource::ForLoopDesugar))\n+            };\n+\n+            // `[opt_ident]: loop { ... }`\n+            let loop_block = fld.cx.block_expr(match_expr);\n+            let (loop_block, opt_ident) = expand_loop_block(loop_block, opt_ident, fld);\n+            let loop_expr = fld.cx.expr(span, ast::ExprLoop(loop_block, opt_ident));\n+\n+            // `mut iter => { ... }`\n+            let iter_arm = {\n+                let iter_pat =\n+                    fld.cx.pat_ident_binding_mode(span, iter, ast::BindByValue(ast::MutMutable));\n+                fld.cx.arm(span, vec![iter_pat], loop_expr)\n+            };\n+\n+            // `match ::std::iter::IntoIterator::into_iter(<head>) { ... }`\n+            let into_iter_expr = {\n+                let into_iter_path = {\n+                    let strs = vec![\n+                        fld.cx.ident_of(\"std\"),\n+                        fld.cx.ident_of(\"iter\"),\n+                        fld.cx.ident_of(\"IntoIterator\"),\n+                        fld.cx.ident_of(\"into_iter\"),\n+                    ];\n+\n+                    fld.cx.path_global(span, strs)\n+                };\n+\n+                fld.cx.expr_call(span, fld.cx.expr_path(into_iter_path), vec![head])\n+            };\n+            fld.cx.expr_match(span, into_iter_expr, vec![iter_arm])\n         }\n \n         ast::ExprClosure(capture_clause, opt_kind, fn_decl, block) => {"}, {"sha": "36dbf1176045741e220c1cacc94f3b4a83ff47dd", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 61, "deletions": 75, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -17,7 +17,7 @@ use ext::base::*;\n use ext::base;\n use ext::build::AstBuilder;\n use fmt_macros as parse;\n-use parse::token::{InternedString, special_idents};\n+use parse::token::special_idents;\n use parse::token;\n use ptr::P;\n \n@@ -300,56 +300,35 @@ impl<'a, 'b> Context<'a, 'b> {\n         }\n     }\n \n-    /// These attributes are applied to all statics that this syntax extension\n-    /// will generate.\n-    fn static_attrs(ecx: &ExtCtxt, fmtsp: Span) -> Vec<ast::Attribute> {\n-        // Flag statics as `inline` so LLVM can merge duplicate globals as much\n-        // as possible (which we're generating a whole lot of).\n-        let unnamed = ecx.meta_word(fmtsp, InternedString::new(\"inline\"));\n-        let unnamed = ecx.attribute(fmtsp, unnamed);\n-\n-        // Do not warn format string as dead code\n-        let dead_code = ecx.meta_word(fmtsp, InternedString::new(\"dead_code\"));\n-        let allow_dead_code = ecx.meta_list(fmtsp,\n-                                            InternedString::new(\"allow\"),\n-                                            vec![dead_code]);\n-        let allow_dead_code = ecx.attribute(fmtsp, allow_dead_code);\n-        vec![unnamed, allow_dead_code]\n-    }\n-\n     fn rtpath(ecx: &ExtCtxt, s: &str) -> Vec<ast::Ident> {\n-        vec![ecx.ident_of(\"std\"), ecx.ident_of(\"fmt\"), ecx.ident_of(\"rt\"), ecx.ident_of(s)]\n+        vec![ecx.ident_of(\"std\"), ecx.ident_of(\"fmt\"), ecx.ident_of(\"rt\"),\n+             ecx.ident_of(\"v1\"), ecx.ident_of(s)]\n     }\n \n     fn trans_count(&self, c: parse::Count) -> P<ast::Expr> {\n         let sp = self.fmtsp;\n-        match c {\n-            parse::CountIs(i) => {\n-                self.ecx.expr_call_global(sp, Context::rtpath(self.ecx, \"CountIs\"),\n-                                          vec!(self.ecx.expr_usize(sp, i)))\n+        let count = |: c, arg| {\n+            let mut path = Context::rtpath(self.ecx, \"Count\");\n+            path.push(self.ecx.ident_of(c));\n+            match arg {\n+                Some(arg) => self.ecx.expr_call_global(sp, path, vec![arg]),\n+                None => self.ecx.expr_path(self.ecx.path_global(sp, path)),\n             }\n+        };\n+        match c {\n+            parse::CountIs(i) => count(\"Is\", Some(self.ecx.expr_usize(sp, i))),\n             parse::CountIsParam(i) => {\n-                self.ecx.expr_call_global(sp, Context::rtpath(self.ecx, \"CountIsParam\"),\n-                                          vec!(self.ecx.expr_usize(sp, i)))\n-            }\n-            parse::CountImplied => {\n-                let path = self.ecx.path_global(sp, Context::rtpath(self.ecx,\n-                                                                    \"CountImplied\"));\n-                self.ecx.expr_path(path)\n-            }\n-            parse::CountIsNextParam => {\n-                let path = self.ecx.path_global(sp, Context::rtpath(self.ecx,\n-                                                                    \"CountIsNextParam\"));\n-                self.ecx.expr_path(path)\n+                count(\"Param\", Some(self.ecx.expr_usize(sp, i)))\n             }\n+            parse::CountImplied => count(\"Implied\", None),\n+            parse::CountIsNextParam => count(\"NextParam\", None),\n             parse::CountIsName(n) => {\n                 let i = match self.name_positions.get(n) {\n                     Some(&i) => i,\n                     None => 0, // error already emitted elsewhere\n                 };\n                 let i = i + self.args.len();\n-                self.ecx.expr_call_global(sp, Context::rtpath(self.ecx, \"CountIsParam\"),\n-                                          vec!(self.ecx.expr_usize(sp, i)))\n+                count(\"Param\", Some(self.ecx.expr_usize(sp, i)))\n             }\n         }\n     }\n@@ -373,27 +352,35 @@ impl<'a, 'b> Context<'a, 'b> {\n             }\n             parse::NextArgument(ref arg) => {\n                 // Translate the position\n-                let pos = match arg.position {\n-                    // These two have a direct mapping\n-                    parse::ArgumentNext => {\n-                        let path = self.ecx.path_global(sp, Context::rtpath(self.ecx,\n-                                                                            \"ArgumentNext\"));\n-                        self.ecx.expr_path(path)\n-                    }\n-                    parse::ArgumentIs(i) => {\n-                        self.ecx.expr_call_global(sp, Context::rtpath(self.ecx, \"ArgumentIs\"),\n-                                                  vec!(self.ecx.expr_usize(sp, i)))\n-                    }\n-                    // Named arguments are converted to positional arguments at\n-                    // the end of the list of arguments\n-                    parse::ArgumentNamed(n) => {\n-                        let i = match self.name_positions.get(n) {\n-                            Some(&i) => i,\n-                            None => 0, // error already emitted elsewhere\n-                        };\n-                        let i = i + self.args.len();\n-                        self.ecx.expr_call_global(sp, Context::rtpath(self.ecx, \"ArgumentIs\"),\n-                                                  vec!(self.ecx.expr_usize(sp, i)))\n+                let pos = {\n+                    let pos = |: c, arg| {\n+                        let mut path = Context::rtpath(self.ecx, \"Position\");\n+                        path.push(self.ecx.ident_of(c));\n+                        match arg {\n+                            Some(i) => {\n+                                let arg = self.ecx.expr_usize(sp, i);\n+                                self.ecx.expr_call_global(sp, path, vec![arg])\n+                            }\n+                            None => {\n+                                self.ecx.expr_path(self.ecx.path_global(sp, path))\n+                            }\n+                        }\n+                    };\n+                    match arg.position {\n+                        // These two have a direct mapping\n+                        parse::ArgumentNext => pos(\"Next\", None),\n+                        parse::ArgumentIs(i) => pos(\"At\", Some(i)),\n+\n+                        // Named arguments are converted to positional arguments\n+                        // at the end of the list of arguments\n+                        parse::ArgumentNamed(n) => {\n+                            let i = match self.name_positions.get(n) {\n+                                Some(&i) => i,\n+                                None => 0, // error already emitted elsewhere\n+                            };\n+                            let i = i + self.args.len();\n+                            pos(\"At\", Some(i))\n+                        }\n                     }\n                 };\n \n@@ -417,19 +404,16 @@ impl<'a, 'b> Context<'a, 'b> {\n \n                 // Translate the format\n                 let fill = self.ecx.expr_lit(sp, ast::LitChar(fill));\n+                let align = |:name| {\n+                    let mut p = Context::rtpath(self.ecx, \"Alignment\");\n+                    p.push(self.ecx.ident_of(name));\n+                    self.ecx.path_global(sp, p)\n+                };\n                 let align = match arg.format.align {\n-                    parse::AlignLeft => {\n-                        self.ecx.path_global(sp, Context::rtpath(self.ecx, \"AlignLeft\"))\n-                    }\n-                    parse::AlignRight => {\n-                        self.ecx.path_global(sp, Context::rtpath(self.ecx, \"AlignRight\"))\n-                    }\n-                    parse::AlignCenter => {\n-                        self.ecx.path_global(sp, Context::rtpath(self.ecx, \"AlignCenter\"))\n-                    }\n-                    parse::AlignUnknown => {\n-                        self.ecx.path_global(sp, Context::rtpath(self.ecx, \"AlignUnknown\"))\n-                    }\n+                    parse::AlignLeft => align(\"Left\"),\n+                    parse::AlignRight => align(\"Right\"),\n+                    parse::AlignCenter => align(\"Center\"),\n+                    parse::AlignUnknown => align(\"Unknown\"),\n                 };\n                 let align = self.ecx.expr_path(align);\n                 let flags = self.ecx.expr_usize(sp, arg.format.flags);\n@@ -465,7 +449,7 @@ impl<'a, 'b> Context<'a, 'b> {\n         let st = ast::ItemStatic(ty, ast::MutImmutable, slice);\n \n         let name = ecx.ident_of(name);\n-        let item = ecx.item(fmtsp, name, Context::static_attrs(ecx, fmtsp), st);\n+        let item = ecx.item(fmtsp, name, vec![], st);\n         let decl = respan(fmtsp, ast::DeclItem(item));\n \n         // Wrap the declaration in a block so that it forms a single expression.\n@@ -575,7 +559,7 @@ impl<'a, 'b> Context<'a, 'b> {\n \n         // Now create the fmt::Arguments struct with all our locals we created.\n         let (fn_name, fn_args) = if self.all_pieces_simple {\n-            (\"new\", vec![pieces, args_slice])\n+            (\"new_v1\", vec![pieces, args_slice])\n         } else {\n             // Build up the static array which will store our precompiled\n             // nonstandard placeholders, if there are any.\n@@ -587,7 +571,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                                             piece_ty,\n                                             self.pieces);\n \n-            (\"with_placeholders\", vec![pieces, fmt, args_slice])\n+            (\"new_v1_formatted\", vec![pieces, args_slice, fmt])\n         };\n \n         self.ecx.expr_call_global(self.fmtsp, vec!(\n@@ -624,7 +608,8 @@ impl<'a, 'b> Context<'a, 'b> {\n                 return ecx.expr_call_global(sp, vec![\n                         ecx.ident_of(\"std\"),\n                         ecx.ident_of(\"fmt\"),\n-                        ecx.ident_of(\"argumentuint\")], vec![arg])\n+                        ecx.ident_of(\"ArgumentV1\"),\n+                        ecx.ident_of(\"from_uint\")], vec![arg])\n             }\n         };\n \n@@ -636,7 +621,8 @@ impl<'a, 'b> Context<'a, 'b> {\n         ecx.expr_call_global(sp, vec![\n                 ecx.ident_of(\"std\"),\n                 ecx.ident_of(\"fmt\"),\n-                ecx.ident_of(\"argument\")], vec![ecx.expr_path(format_fn), arg])\n+                ecx.ident_of(\"ArgumentV1\"),\n+                ecx.ident_of(\"new\")], vec![arg, ecx.expr_path(format_fn)])\n     }\n }\n "}, {"sha": "775cfede70d9b3faf86776bcad43b9c202aff1dc", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -109,6 +109,9 @@ static KNOWN_FEATURES: &'static [(&'static str, &'static str, Status)] = &[\n     // int and uint are now deprecated\n     (\"int_uint\", \"1.0.0\", Active),\n \n+    // macro reexport needs more discusion and stabilization\n+    (\"macro_reexport\", \"1.0.0\", Active),\n+\n     // These are used to test this portion of the compiler, they don't actually\n     // mean anything\n     (\"test_accepted_feature\", \"1.0.0\", Accepted),\n@@ -272,6 +275,10 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n                     self.gate_feature(\"plugin\", i.span,\n                                       \"compiler plugins are experimental \\\n                                        and possibly buggy\");\n+                } else if attr::contains_name(&i.attrs[], \"macro_reexport\") {\n+                    self.gate_feature(\"macro_reexport\", i.span,\n+                                      \"macros reexports are experimental \\\n+                                       and possibly buggy\");\n                 }\n             }\n "}, {"sha": "73424136cfbcb44594e0f6d964197b45dcaec803", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -16,27 +16,28 @@\n \n #![crate_name = \"syntax\"]\n #![unstable(feature = \"rustc_private\")]\n-#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n-#![allow(unknown_features)]\n-#![feature(slicing_syntax)]\n+#![cfg_attr(not(stage0), allow(unused_mut))] // NOTE: remove after stage0 snap\n+\n #![feature(box_syntax)]\n-#![feature(quote, unsafe_destructor)]\n-#![allow(unknown_features)] #![feature(int_uint)]\n #![feature(collections)]\n #![feature(core)]\n #![feature(hash)]\n+#![feature(int_uint)]\n #![feature(io)]\n #![feature(libc)]\n #![feature(os)]\n #![feature(path)]\n+#![feature(quote, unsafe_destructor)]\n #![feature(rustc_private)]\n+#![feature(slicing_syntax)]\n+#![feature(staged_api)]\n #![feature(std_misc)]\n #![feature(unicode)]\n "}, {"sha": "2cf6058a43379a093d7db89c2372a6476f07d875", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -613,7 +613,7 @@ impl<'a> StringReader<'a> {\n         // find the integer representing the name\n         self.scan_digits(base);\n         let encoded_name : u32 = self.with_str_from(start_bpos, |s| {\n-            num::from_str_radix(s, 10).unwrap_or_else(|| {\n+            num::from_str_radix(s, 10).ok().unwrap_or_else(|| {\n                 panic!(\"expected digits representing a name, got {:?}, {}, range [{:?},{:?}]\",\n                       s, whence, start_bpos, self.last_pos);\n             })\n@@ -631,7 +631,7 @@ impl<'a> StringReader<'a> {\n         let start_bpos = self.last_pos;\n         self.scan_digits(base);\n         let encoded_ctxt : ast::SyntaxContext = self.with_str_from(start_bpos, |s| {\n-            num::from_str_radix(s, 10).unwrap_or_else(|| {\n+            num::from_str_radix(s, 10).ok().unwrap_or_else(|| {\n                 panic!(\"expected digits representing a ctxt, got {:?}, {}\", s, whence);\n             })\n         });"}, {"sha": "e7be876edbbecd618ad645ce585c19fe5abf6281", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -401,7 +401,7 @@ pub fn char_lit(lit: &str) -> (char, isize) {\n     let msg2 = &msg[];\n \n     fn esc(len: usize, lit: &str) -> Option<(char, isize)> {\n-        num::from_str_radix(&lit[2..len], 16)\n+        num::from_str_radix(&lit[2..len], 16).ok()\n         .and_then(char::from_u32)\n         .map(|x| (x, len as isize))\n     }\n@@ -410,7 +410,7 @@ pub fn char_lit(lit: &str) -> (char, isize) {\n         if lit.as_bytes()[2] == b'{' {\n             let idx = lit.find('}').expect(msg2);\n             let subslice = &lit[3..idx];\n-            num::from_str_radix(subslice, 16)\n+            num::from_str_radix(subslice, 16).ok()\n                 .and_then(char::from_u32)\n                 .map(|x| (x, subslice.chars().count() as isize + 4))\n         } else {\n@@ -583,7 +583,7 @@ pub fn byte_lit(lit: &str) -> (u8, usize) {\n             b'\\'' => b'\\'',\n             b'0' => b'\\0',\n             _ => {\n-                match ::std::num::from_str_radix::<u64>(&lit[2..4], 16) {\n+                match ::std::num::from_str_radix::<u64>(&lit[2..4], 16).ok() {\n                     Some(c) =>\n                         if c > 0xFF {\n                             panic!(err(2))\n@@ -732,7 +732,7 @@ pub fn integer_lit(s: &str, suffix: Option<&str>, sd: &SpanHandler, sp: Span) ->\n     debug!(\"integer_lit: the type is {:?}, base {:?}, the new string is {:?}, the original \\\n            string was {:?}, the original suffix was {:?}\", ty, base, s, orig, suffix);\n \n-    let res: u64 = match ::std::num::from_str_radix(s, base) {\n+    let res: u64 = match ::std::num::from_str_radix(s, base).ok() {\n         Some(r) => r,\n         None => { sd.span_err(sp, \"int literal is too large\"); 0 }\n     };"}, {"sha": "d99095eeba37799be8df741502767973732cf712", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -2459,7 +2459,7 @@ impl<'a> Parser<'a> {\n                     hi = self.span.hi;\n                     self.bump();\n \n-                    let index = n.as_str().parse::<usize>();\n+                    let index = n.as_str().parse::<usize>().ok();\n                     match index {\n                         Some(n) => {\n                             let id = spanned(dot, hi, n);\n@@ -2479,7 +2479,7 @@ impl<'a> Parser<'a> {\n                     self.span_err(last_span,\n                                   &format!(\"unexpected token: `{}`\", n.as_str())[]);\n                     if fstr.chars().all(|x| \"0123456789.\".contains_char(x)) {\n-                        let float = match fstr.parse::<f64>() {\n+                        let float = match fstr.parse::<f64>().ok() {\n                             Some(f) => f,\n                             None => continue,\n                         };"}, {"sha": "6492cd4b095a775260897f12b606f360c8f0abad", "filename": "src/libsyntax/show_span.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibsyntax%2Fshow_span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibsyntax%2Fshow_span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fshow_span.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -27,14 +27,15 @@ enum Mode {\n }\n \n impl FromStr for Mode {\n-    fn from_str(s: &str) -> Option<Mode> {\n+    type Err = ();\n+    fn from_str(s: &str) -> Result<Mode, ()> {\n         let mode = match s {\n             \"expr\" => Mode::Expression,\n             \"pat\" => Mode::Pattern,\n             \"ty\" => Mode::Type,\n-            _ => return None\n+            _ => return Err(())\n         };\n-        Some(mode)\n+        Ok(mode)\n     }\n }\n \n@@ -73,7 +74,7 @@ impl<'a, 'v> Visitor<'v> for ShowSpanVisitor<'a> {\n pub fn run(span_diagnostic: &diagnostic::SpanHandler,\n            mode: &str,\n            krate: &ast::Crate) {\n-    let mode = match mode.parse() {\n+    let mode = match mode.parse().ok() {\n         Some(mode) => mode,\n         None => return\n     };"}, {"sha": "27a46fb5a682ddc3b1475a40c5c03c0218bb02ef", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -41,26 +41,25 @@\n #![crate_name = \"term\"]\n #![unstable(feature = \"rustc_private\",\n             reason = \"use the crates.io `term` library instead\")]\n-#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n+#![deny(missing_docs)]\n \n-#![allow(unknown_features)]\n-#![feature(slicing_syntax)]\n #![feature(box_syntax)]\n-#![allow(unknown_features)] #![feature(int_uint)]\n-#![deny(missing_docs)]\n #![feature(collections)]\n #![feature(core)]\n+#![feature(int_uint)]\n #![feature(io)]\n #![feature(os)]\n #![feature(path)]\n #![feature(rustc_private)]\n+#![feature(slicing_syntax)]\n+#![feature(staged_api)]\n #![feature(std_misc)]\n #![feature(unicode)]\n "}, {"sha": "f22c58c54a6851a00cff14575b378ef1225b86f4", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -25,25 +25,27 @@\n \n #![crate_name = \"test\"]\n #![unstable(feature = \"test\")]\n-#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n-#![allow(unknown_features)]\n+\n+#![cfg_attr(not(stage0), allow(unused_mut))] // NOTE: remove after stage0 snap\n+\n #![feature(asm, slicing_syntax)]\n #![feature(box_syntax)]\n-#![allow(unknown_features)] #![feature(int_uint)]\n #![feature(collections)]\n #![feature(core)]\n+#![feature(hash)]\n+#![feature(int_uint)]\n #![feature(io)]\n #![feature(os)]\n #![feature(path)]\n #![feature(rustc_private)]\n+#![feature(staged_api)]\n #![feature(std_misc)]\n-#![feature(hash)]\n \n extern crate getopts;\n extern crate serialize;\n@@ -74,7 +76,6 @@ use std::old_io;\n use std::iter::repeat;\n use std::num::{Float, Int};\n use std::os;\n-use std::str::FromStr;\n use std::sync::mpsc::{channel, Sender};\n use std::thread::{self, Thread};\n use std::thunk::{Thunk, Invoke};\n@@ -818,7 +819,7 @@ fn get_concurrency() -> uint {\n     use std::rt;\n     match os::getenv(\"RUST_TEST_TASKS\") {\n         Some(s) => {\n-            let opt_n: Option<uint> = FromStr::from_str(s.as_slice());\n+            let opt_n: Option<uint> = s.parse().ok();\n             match opt_n {\n                 Some(n) if n > 0 => n,\n                 _ => panic!(\"RUST_TEST_TASKS is `{}`, should be a positive integer.\", s)"}, {"sha": "822dde7eb2c61084045b3cedbe57a6032d8f64b5", "filename": "src/libunicode/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibunicode%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibunicode%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Flib.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -31,7 +31,7 @@\n        html_playground_url = \"http://play.rust-lang.org/\")]\n #![no_std]\n #![feature(slicing_syntax)]\n-#![allow(unknown_features)] #![feature(int_uint)]\n+#![feature(int_uint)]\n #![feature(core)]\n \n extern crate core;\n@@ -84,4 +84,7 @@ mod std {\n     pub use core::cmp;\n     pub use core::fmt;\n     pub use core::marker;\n+    // for-loops\n+    pub use core::iter;\n+    pub use core::option;\n }"}, {"sha": "9a757c0c980dde279e0e2412fb6af74ac34c5906", "filename": "src/libunicode/u_str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibunicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Flibunicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_str.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -447,7 +447,7 @@ impl<'a> Iterator for Utf16Items<'a> {\n             Some(Utf16Item::LoneSurrogate(u))\n         } else {\n             // preserve state for rewinding.\n-            let old = self.iter;\n+            let old = self.iter.clone();\n \n             let u2 = match self.iter.next() {\n                 Some(u2) => *u2,\n@@ -457,7 +457,7 @@ impl<'a> Iterator for Utf16Items<'a> {\n             if u2 < 0xDC00 || u2 > 0xDFFF {\n                 // not a trailing surrogate so we're not a valid\n                 // surrogate pair, so rewind to redecode u2 next time.\n-                self.iter = old;\n+                self.iter = old.clone();\n                 return Some(Utf16Item::LoneSurrogate(u))\n             }\n "}, {"sha": "8b933fdd6dd57802f0d60b20a9efa0d559d8d575", "filename": "src/rustbook/css.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Frustbook%2Fcss.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Frustbook%2Fcss.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fcss.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -48,6 +48,7 @@ body {\n     margin-left: auto;\n     margin-right:auto;\n     max-width: 750px;\n+    padding-bottom: 50px;\n }\n \n .chapter {\n@@ -125,4 +126,12 @@ body {\n     padding: 0;\n }\n \n+.left {\n+    float: left;\n+}\n+\n+.right {\n+    float: right;\n+}\n+\n \"#;"}, {"sha": "d34887d2b08b59e6af92c34c6b7b2f48d62d97fe", "filename": "src/rustbook/javascript.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Frustbook%2Fjavascript.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Frustbook%2Fjavascript.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fjavascript.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -38,6 +38,37 @@ document.addEventListener(\"DOMContentLoaded\", function(event) {\n        el.className = classes.join(' ');\n      }\n   }\n+\n+  // The below code is used to add prev and next navigation links to the bottom\n+  // of each of the sections.\n+  // It works by extracting the current page based on the url and iterates over\n+  // the menu links until it finds the menu item for the current page. We then\n+  // create a copy of the preceeding and following menu links and add the\n+  // correct css class and insert them into the bottom of the page.\n+  var toc = document.getElementById('toc').getElementsByTagName('a');\n+  var href = document.location.pathname.split('/').pop();\n+  if (href === 'index.html' || href === '') {\n+    href = 'README.html';\n+  }\n+\n+  for (var i = 0; i < toc.length; i++) {\n+    if (toc[i].attributes['href'].value === href) {\n+      var nav = document.createElement('p');\n+      if (i > 0) {\n+        var prevNode = toc[i-1].cloneNode(true);\n+        prevNode.className = 'left';\n+        nav.appendChild(prevNode);\n+      }\n+      if (i < toc.length - 1) {\n+        var nextNode = toc[i+1].cloneNode(true);\n+        nextNode.className = 'right';\n+        nav.appendChild(nextNode);\n+      }\n+      document.getElementById('page').appendChild(nav);\n+      break;\n+    }\n+  }\n+\n });\n </script>\n \"#;"}, {"sha": "e159e9729b635a2c416931c41a9361676045f091", "filename": "src/rustllvm/llvm-auto-clean-trigger", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Frustllvm%2Fllvm-auto-clean-trigger", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Frustllvm%2Fllvm-auto-clean-trigger", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Fllvm-auto-clean-trigger?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -1,4 +1,4 @@\n # If this file is modified, then llvm will be forcibly cleaned and then rebuilt.\n # The actual contents of this file do not matter, but to trigger a change on the\n # build bots then the contents should be changed so git updates the mtime.\n-2015-01-18\n+2015-01-30"}, {"sha": "3406a91e718b066db72da294af01b7bb0edf9200", "filename": "src/snapshots.txt", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -1,3 +1,12 @@\n+S 2015-01-28 a45e117\n+  freebsd-x86_64 08a3ce7331fd1a52466acc0598cf745a009f86f6\n+  linux-i386 66e36a3461c12e2102a7f7f241d1b0e242c704d0\n+  linux-x86_64 0ae2f5da9913cfa211a367de77d5faa2ff798918\n+  macos-i386 d1a6776f00bf5091d73816d46c7fca8617575bd8\n+  macos-x86_64 cd4d7659b93e2341316cef4b7c5c9b50d23c6bbf\n+  winnt-i386 14859dde2eb57f8c54989852ae6f807e66576338\n+  winnt-x86_64 693c0d1068debe5781e89e0d9efee85825eeae6c\n+\n S 2015-01-27 7774359\n   freebsd-x86_64 63623b632d4f9c33ad3b3cfaeebf8e2dd8395c96\n   linux-i386 937b0b126aade54dc2c7198cad67f40d711b64ba"}, {"sha": "560844332a128d4718362b8a7debb61deb7436a0", "filename": "src/test/auxiliary/issue-11224.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fauxiliary%2Fissue-11224.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fauxiliary%2Fissue-11224.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-11224.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -21,6 +21,6 @@ mod inner {\n }\n \n pub fn foo() {\n-    let a = &1i as &inner::Trait;\n+    let a = &1 as &inner::Trait;\n     a.f();\n }"}, {"sha": "c5b3fceaf4a5febc01773f6a43254baf8f587e42", "filename": "src/test/auxiliary/issue-16643.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fauxiliary%2Fissue-16643.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fauxiliary%2Fissue-16643.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-16643.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -15,7 +15,7 @@ pub struct TreeBuilder<H>;\n impl<H> TreeBuilder<H> {\n     pub fn process_token(&mut self) {\n         match self {\n-            _ => for _y in *self {}\n+            _ => for _y in self.by_ref() {}\n         }\n     }\n }"}, {"sha": "7bfd2e79641d038ccc86f2f9ec81aa32bd6832b5", "filename": "src/test/auxiliary/issue-8044.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fauxiliary%2Fissue-8044.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fauxiliary%2Fissue-8044.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-8044.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -21,5 +21,5 @@ pub fn leaf<V>(value: V) -> TreeItem<V> {\n }\n \n fn main() {\n-    BTree::<int> { node: leaf(1i) };\n+    BTree::<int> { node: leaf(1) };\n }"}, {"sha": "1e746bf39db6196074bca1ea181bde9d73e9ab3c", "filename": "src/test/auxiliary/issue-9906.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fauxiliary%2Fissue-9906.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fauxiliary%2Fissue-9906.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-9906.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -22,6 +22,6 @@ mod other {\n     }\n \n     pub fn foo(){\n-        1i+1;\n+        1+1;\n     }\n }"}, {"sha": "d545a42ae1927ec7c30fa5a312a3c7bd4baca0b8", "filename": "src/test/auxiliary/macro_crate_test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -25,9 +25,9 @@ use syntax::ptr::P;\n use rustc::plugin::Registry;\n \n #[macro_export]\n-macro_rules! exported_macro { () => (2i) }\n+macro_rules! exported_macro { () => (2) }\n \n-macro_rules! unexported_macro { () => (3i) }\n+macro_rules! unexported_macro { () => (3) }\n \n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n@@ -47,7 +47,7 @@ fn expand_make_a_1(cx: &mut ExtCtxt, sp: Span, tts: &[TokenTree])\n     if !tts.is_empty() {\n         cx.span_fatal(sp, \"make_a_1 takes no arguments\");\n     }\n-    MacExpr::new(quote_expr!(cx, 1i))\n+    MacExpr::new(quote_expr!(cx, 1))\n }\n \n // See Issue #15750"}, {"sha": "3918be88d867684e1d27b1a3eee7248da595e024", "filename": "src/test/auxiliary/macro_reexport_2.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fauxiliary%2Fmacro_reexport_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fauxiliary%2Fmacro_reexport_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmacro_reexport_2.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #![crate_type = \"dylib\"]\n+#![feature(macro_reexport)]\n \n #[macro_reexport(reexported)]\n #[macro_use] #[no_link]"}, {"sha": "1d3dc26b0b4cb6beb04a03699bac8ec8709f0e54", "filename": "src/test/auxiliary/macro_reexport_2_no_use.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fauxiliary%2Fmacro_reexport_2_no_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fauxiliary%2Fmacro_reexport_2_no_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmacro_reexport_2_no_use.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #![crate_type = \"dylib\"]\n+#![feature(macro_reexport)]\n \n #[macro_reexport(reexported)]\n #[no_link]"}, {"sha": "6cb16f04ce115713ab4bd4f2b52f2cf162f6e85b", "filename": "src/test/auxiliary/static-methods-crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -19,7 +19,7 @@ pub trait read {\n \n impl read for int {\n     fn readMaybe(s: String) -> Option<int> {\n-        s.parse()\n+        s.parse().ok()\n     }\n }\n "}, {"sha": "388868eee708efd86c6bbbbf2c6a8238244d7d83", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -62,7 +62,7 @@ fn maybe_run_test<F>(argv: &[String], name: String, test: F) where F: FnOnce() {\n }\n \n fn shift_push() {\n-    let mut v1 = repeat(1i).take(30000).collect::<Vec<_>>();\n+    let mut v1 = repeat(1).take(30000).collect::<Vec<_>>();\n     let mut v2 = Vec::new();\n \n     while v1.len() > 0 {"}, {"sha": "15a63e153b9f5ef44621e154459148ed02df26b8", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -232,7 +232,7 @@ fn main() {\n     } else {\n         std::os::args().as_slice()\n                        .get(1)\n-                       .and_then(|arg| arg.parse())\n+                       .and_then(|arg| arg.parse().ok())\n                        .unwrap_or(600u)\n     };\n "}, {"sha": "03666c84d576f71c637961b70a635b53ad587efc", "filename": "src/test/bench/shootout-fannkuch-redux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -182,7 +182,7 @@ fn fannkuch(n: i32) -> (i32, i32) {\n fn main() {\n     let n = std::os::args().as_slice()\n         .get(1)\n-        .and_then(|arg| arg.parse())\n+        .and_then(|arg| arg.parse().ok())\n         .unwrap_or(2i32);\n \n     let (checksum, maxflips) = fannkuch(n);"}, {"sha": "3c01697166e8bdafdd19f84925d8d1c471335d37", "filename": "src/test/bench/shootout-meteor.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-meteor.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -104,8 +104,8 @@ impl<'a, T> Iterator for ListIterator<'a, T> {\n // corresponding mirrored piece), with, as minimum coordinates, (0,\n // 0).  If all is false, only generate half of the possibilities (used\n // to break the symmetry of the board).\n-fn transform(piece: Vec<(int, int)> , all: bool) -> Vec<Vec<(int, int)>> {\n-    let mut res: Vec<Vec<(int, int)>> =\n+fn transform(piece: Vec<(isize, isize)> , all: bool) -> Vec<Vec<(isize, isize)>> {\n+    let mut res: Vec<Vec<(isize, isize)>> =\n         // rotations\n         iterate(piece, |rot| rot.iter().map(|&(y, x)| (x + y, -y)).collect())\n         .take(if all {6} else {3})\n@@ -133,14 +133,14 @@ fn transform(piece: Vec<(int, int)> , all: bool) -> Vec<Vec<(int, int)>> {\n // Takes a piece with minimum coordinate (0, 0) (as generated by\n // transform).  Returns the corresponding mask if p translated by (dy,\n // dx) is on the board.\n-fn mask(dy: int, dx: int, id: uint, p: &Vec<(int, int)>) -> Option<u64> {\n+fn mask(dy: isize, dx: isize, id: usize, p: &Vec<(isize, isize)>) -> Option<u64> {\n     let mut m = 1 << (50 + id);\n     for &(y, x) in p.iter() {\n         let x = x + dx + (y + (dy % 2)) / 2;\n         if x < 0 || x > 4 {return None;}\n         let y = y + dy;\n         if y < 0 || y > 9 {return None;}\n-        m |= 1 << (y * 5 + x) as uint;\n+        m |= 1 << (y * 5 + x) as usize;\n     }\n     Some(m)\n }\n@@ -150,26 +150,26 @@ fn mask(dy: int, dx: int, id: uint, p: &Vec<(int, int)>) -> Option<u64> {\n // (i/5, i%5).\n fn make_masks() -> Vec<Vec<Vec<u64> > > {\n     let pieces = vec!(\n-        vec!((0i,0i),(0,1),(0,2),(0,3),(1,3)),\n-        vec!((0i,0i),(0,2),(0,3),(1,0),(1,1)),\n-        vec!((0i,0i),(0,1),(0,2),(1,2),(2,1)),\n-        vec!((0i,0i),(0,1),(0,2),(1,1),(2,1)),\n-        vec!((0i,0i),(0,2),(1,0),(1,1),(2,1)),\n-        vec!((0i,0i),(0,1),(0,2),(1,1),(1,2)),\n-        vec!((0i,0i),(0,1),(1,1),(1,2),(2,1)),\n-        vec!((0i,0i),(0,1),(0,2),(1,0),(1,2)),\n-        vec!((0i,0i),(0,1),(0,2),(1,2),(1,3)),\n-        vec!((0i,0i),(0,1),(0,2),(0,3),(1,2)));\n+        vec!((0,0),(0,1),(0,2),(0,3),(1,3)),\n+        vec!((0,0),(0,2),(0,3),(1,0),(1,1)),\n+        vec!((0,0),(0,1),(0,2),(1,2),(2,1)),\n+        vec!((0,0),(0,1),(0,2),(1,1),(2,1)),\n+        vec!((0,0),(0,2),(1,0),(1,1),(2,1)),\n+        vec!((0,0),(0,1),(0,2),(1,1),(1,2)),\n+        vec!((0,0),(0,1),(1,1),(1,2),(2,1)),\n+        vec!((0,0),(0,1),(0,2),(1,0),(1,2)),\n+        vec!((0,0),(0,1),(0,2),(1,2),(1,3)),\n+        vec!((0,0),(0,1),(0,2),(0,3),(1,2)));\n \n     // To break the central symmetry of the problem, every\n     // transformation must be taken except for one piece (piece 3\n     // here).\n-    let transforms: Vec<Vec<Vec<(int, int)>>> =\n+    let transforms: Vec<Vec<Vec<(isize, isize)>>> =\n         pieces.into_iter().enumerate()\n         .map(|(id, p)| transform(p, id != 3))\n         .collect();\n \n-    (0i..50).map(|yx| {\n+    (0is..50).map(|yx| {\n         transforms.iter().enumerate().map(|(id, t)| {\n             t.iter().filter_map(|p| mask(yx / 5, yx % 5, id, p)).collect()\n         }).collect()\n@@ -212,7 +212,7 @@ fn filter_masks(masks: &mut Vec<Vec<Vec<u64>>>) {\n // Gets the identifier of a mask.\n fn get_id(m: u64) -> u8 {\n     for id in 0u8..10 {\n-        if m & (1 << (id + 50) as uint) != 0 {return id;}\n+        if m & (1 << (id + 50) as usize) != 0 {return id;}\n     }\n     panic!(\"{:016x} does not have a valid identifier\", m);\n }\n@@ -222,7 +222,7 @@ fn to_vec(raw_sol: &List<u64>) -> Vec<u8> {\n     let mut sol = repeat('.' as u8).take(50).collect::<Vec<_>>();\n     for &m in raw_sol.iter() {\n         let id = '0' as u8 + get_id(m);\n-        for i in 0u..50 {\n+        for i in 0us..50 {\n             if m & 1 << i != 0 {\n                 sol[i] = id;\n             }\n@@ -244,7 +244,7 @@ fn print_sol(sol: &Vec<u8>) {\n // The data managed during the search\n struct Data {\n     // Number of solution found.\n-    nb: int,\n+    nb: isize,\n     // Lexicographically minimal solution found.\n     min: Vec<u8>,\n     // Lexicographically maximal solution found.\n@@ -286,7 +286,7 @@ fn handle_sol(raw_sol: &List<u64>, data: &mut Data) {\n fn search(\n     masks: &Vec<Vec<Vec<u64>>>,\n     board: u64,\n-    mut i: uint,\n+    mut i: usize,\n     cur: List<u64>,\n     data: &mut Data)\n {\n@@ -297,7 +297,7 @@ fn search(\n     let masks_at = &masks[i];\n \n     // for every unused piece\n-    for id in (0u..10).filter(|&id| board & (1 << (id + 50)) == 0) {\n+    for id in (0us..10).filter(|&id| board & (1 << (id + 50)) == 0) {\n         // for each mask that fits on the board\n         for m in masks_at[id].iter().filter(|&m| board & *m == 0) {\n             // This check is too costly."}, {"sha": "b216100032221894fb027cc7400d4447ec219a61", "filename": "src/test/bench/shootout-nbody.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-nbody.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -174,7 +174,7 @@ fn main() {\n         5000000\n     } else {\n         std::os::args().get(1)\n-            .and_then(|arg| arg.parse())\n+            .and_then(|arg| arg.parse().ok())\n             .unwrap_or(1000)\n     };\n     let mut bodies = BODIES;"}, {"sha": "dd3ae1699a90230a41334cf28a084229467cb364", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -66,9 +66,9 @@ fn parse_opts(argv: Vec<String> ) -> Config {\n }\n \n fn stress_task(id: int) {\n-    let mut i = 0i;\n+    let mut i = 0;\n     loop {\n-        let n = 15i;\n+        let n = 15;\n         assert_eq!(fib(n), fib(n));\n         i += 1;\n         println!(\"{}: Completed {} iterations\", id, i);"}, {"sha": "ebe8a0751c3b009226550afcb57fae16ab925bbd", "filename": "src/test/bench/shootout-threadring.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-threadring.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -68,10 +68,10 @@ fn main() {\n     let token = if std::os::getenv(\"RUST_BENCH\").is_some() {\n         2000000\n     } else {\n-        args.get(1).and_then(|arg| arg.parse()).unwrap_or(1000)\n+        args.get(1).and_then(|arg| arg.parse().ok()).unwrap_or(1000)\n     };\n     let n_tasks = args.get(2)\n-                      .and_then(|arg| arg.parse())\n+                      .and_then(|arg| arg.parse().ok())\n                       .unwrap_or(503);\n \n     start(n_tasks, token);"}, {"sha": "f9106ba3960b13879ebebe6781b76f0ce6c5d2c5", "filename": "src/test/compile-fail/associated-types-subtyping-1.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fcompile-fail%2Fassociated-types-subtyping-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fcompile-fail%2Fassociated-types-subtyping-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-subtyping-1.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -0,0 +1,55 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(unused_variables)]\n+\n+trait Trait<'a> {\n+    type Type;\n+\n+    fn method(&'a self) { }\n+}\n+\n+fn method1<'a,'b,T>(x: &'a T, y: &'b T)\n+    where T : for<'z> Trait<'z>, 'a : 'b\n+{\n+    // Note that &'static T <: &'a T.\n+    let a: <T as Trait<'a>>::Type = loop { };\n+    let b: <T as Trait<'b>>::Type = loop { };\n+    let _: <T as Trait<'a>>::Type = a;\n+}\n+\n+fn method2<'a,'b,T>(x: &'a T, y: &'b T)\n+    where T : for<'z> Trait<'z>, 'a : 'b\n+{\n+    // Note that &'static T <: &'a T.\n+    let a: <T as Trait<'a>>::Type = loop { };\n+    let b: <T as Trait<'b>>::Type = loop { };\n+    let _: <T as Trait<'b>>::Type = a; //~ ERROR mismatched types\n+}\n+\n+fn method3<'a,'b,T>(x: &'a T, y: &'b T)\n+    where T : for<'z> Trait<'z>, 'a : 'b\n+{\n+    // Note that &'static T <: &'a T.\n+    let a: <T as Trait<'a>>::Type = loop { };\n+    let b: <T as Trait<'b>>::Type = loop { };\n+    let _: <T as Trait<'a>>::Type = b; //~ ERROR mismatched types\n+}\n+\n+fn method4<'a,'b,T>(x: &'a T, y: &'b T)\n+    where T : for<'z> Trait<'z>, 'a : 'b\n+{\n+    // Note that &'static T <: &'a T.\n+    let a: <T as Trait<'a>>::Type = loop { };\n+    let b: <T as Trait<'b>>::Type = loop { };\n+    let _: <T as Trait<'b>>::Type = b;\n+}\n+\n+fn main() { }"}, {"sha": "6bc0e74a2eb58f16b8f0d4e970069a0e65a695db", "filename": "src/test/compile-fail/for-loop-bogosity.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fcompile-fail%2Ffor-loop-bogosity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fcompile-fail%2Ffor-loop-bogosity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffor-loop-bogosity.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -24,7 +24,10 @@ pub fn main() {\n         x: 1,\n         y: 2,\n     };\n-    for x in bogus { //~ ERROR has type `MyStruct` which does not implement the `Iterator` trait\n+    for x in bogus { //~ ERROR `core::iter::Iterator` is not implemented for the type `MyStruct`\n+    //~^ ERROR\n+    //~^^ ERROR\n+    // FIXME(#21528) not fulfilled obligation error should be reported once, not thrice\n         drop(x);\n     }\n }"}, {"sha": "ff6f848ab598d7313ca216841d7d9a24c73e2c8e", "filename": "src/test/compile-fail/for-loop-hygiene.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fcompile-fail%2Ffor-loop-hygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fcompile-fail%2Ffor-loop-hygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffor-loop-hygiene.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// for-loops are expanded in the front end, and use an `iter` ident in their expansion. Check that\n+// `iter` is not accessible inside the for loop.\n+\n+#![allow(unstable)]\n+\n+fn main() {\n+    for _ in 0..10 {\n+        iter.next();  //~ error: unresolved name `iter`\n+    }\n+}"}, {"sha": "fa55e7215c0b260698751fee63b6eec7ef743f97", "filename": "src/test/compile-fail/for-loop-refutable-pattern-error-message.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fcompile-fail%2Ffor-loop-refutable-pattern-error-message.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fcompile-fail%2Ffor-loop-refutable-pattern-error-message.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffor-loop-refutable-pattern-error-message.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n fn main() {\n     for\n         &1is //~ ERROR refutable pattern in `for` loop binding"}, {"sha": "251da2c6b3ee979c020bf7e21c55d490c5a4dadd", "filename": "src/test/compile-fail/issue-13853.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fcompile-fail%2Fissue-13853.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fcompile-fail%2Fissue-13853.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13853.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -32,7 +32,7 @@ impl Node for Stuff {\n \n fn iterate<N: Node, G: Graph<N>>(graph: &G) {\n     for node in graph.iter() { //~ ERROR does not implement any method in scope named\n-        node.zomg();\n+        node.zomg();  //~ error: the type of this value must be known in this context\n     }\n }\n "}, {"sha": "06719e2756b19f07fc142c5a9720eb90534c4a25", "filename": "src/test/compile-fail/issue-17718-const-naming.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fcompile-fail%2Fissue-17718-const-naming.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fcompile-fail%2Fissue-17718-const-naming.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17718-const-naming.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -11,7 +11,7 @@\n #[deny(warnings)]\n \n const foo: isize = 3;\n-//~^ ERROR: should have an uppercase name such as\n+//~^ ERROR: should have an upper case name such as\n //~^^ ERROR: constant item is never used\n \n fn main() {}"}, {"sha": "f336fdbfbed9552d6210296fc14b52aefccd51f6", "filename": "src/test/compile-fail/issue-17999.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fcompile-fail%2Fissue-17999.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fcompile-fail%2Fissue-17999.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17999.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #![deny(unused_variables)]\n+#![feature(core)]\n \n fn main() {\n     for _ in 1is..101 {"}, {"sha": "87b7616db8ed23b35619a2f6603e55a5f48e95a7", "filename": "src/test/compile-fail/issue-20605.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fcompile-fail%2Fissue-20605.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fcompile-fail%2Fissue-20605.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20605.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn changer<'a>(mut things: Box<Iterator<Item=&'a mut u8>>) {\n+    for item in *things { *item = 0 }\n+//~^ ERROR the trait `core::marker::Sized` is not implemented for the type `core::iter::Iterator\n+//~^^ ERROR\n+//~^^^ ERROR\n+// FIXME(#21528) error should be reported once, not thrice\n+}\n+\n+fn main() {}"}, {"sha": "68195985eec4ba2fd2f6019be389995530483f46", "filename": "src/test/compile-fail/issue-2150.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fcompile-fail%2Fissue-2150.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fcompile-fail%2Fissue-2150.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2150.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -11,6 +11,7 @@\n #![deny(unreachable_code)]\n #![allow(unused_variables)]\n #![allow(dead_code)]\n+#![feature(core)]\n \n fn fail_len(v: Vec<isize> ) -> usize {\n     let mut i = 3;"}, {"sha": "449788459dcffc8da518cab723b1bbd669acf5f7", "filename": "src/test/compile-fail/lint-dead-code-4.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fcompile-fail%2Flint-dead-code-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fcompile-fail%2Flint-dead-code-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-dead-code-4.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -13,7 +13,6 @@\n #![deny(dead_code)]\n #![feature(libc)]\n #![feature(core)]\n-#![feature(collections)]\n \n extern crate libc;\n "}, {"sha": "59ab5be1572a3d43d7bbe74e1aeb3cd367f430f8", "filename": "src/test/compile-fail/lint-group-style.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fcompile-fail%2Flint-group-style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fcompile-fail%2Flint-group-style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-group-style.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -24,7 +24,7 @@ mod test {\n     mod bad {\n         fn CamelCase() {} //~ ERROR function `CamelCase` should have a snake case name\n \n-        static bad: isize = 1; //~ ERROR static constant `bad` should have an uppercase name\n+        static bad: isize = 1; //~ ERROR static constant `bad` should have an upper case name\n     }\n \n     mod warn {"}, {"sha": "e1fbc73bbed15ad420d8a21e79ef66ee622e24a4", "filename": "src/test/compile-fail/lint-non-uppercase-statics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fcompile-fail%2Flint-non-uppercase-statics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fcompile-fail%2Flint-non-uppercase-statics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-non-uppercase-statics.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -11,6 +11,6 @@\n #![forbid(non_upper_case_globals)]\n #![allow(dead_code)]\n \n-static foo: isize = 1; //~ ERROR static constant `foo` should have an uppercase name such as `FOO`\n+static foo: isize = 1; //~ ERROR static constant `foo` should have an upper case name such as `FOO`\n \n fn main() { }"}, {"sha": "ebcf46f7277d6f41e23d5cdf0c02ef3c28258198", "filename": "src/test/compile-fail/liveness-unused.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -11,6 +11,7 @@\n #![deny(unused_variables)]\n #![deny(unused_assignments)]\n #![allow(dead_code, non_camel_case_types)]\n+#![feature(core)]\n #![feature(os)]\n \n fn f1(x: isize) {"}, {"sha": "6c85cf5c7f5db91db5c73df5b9fca1095ec2c609", "filename": "src/test/compile-fail/macro-reexport-malformed-1.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fcompile-fail%2Fmacro-reexport-malformed-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fcompile-fail%2Fmacro-reexport-malformed-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-reexport-malformed-1.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(macro_reexport)]\n+\n #[macro_reexport]  //~ ERROR bad macro reexport\n extern crate std;\n "}, {"sha": "1dd0168181f83c3f7bebf5375933df21ab22e811", "filename": "src/test/compile-fail/macro-reexport-malformed-2.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fcompile-fail%2Fmacro-reexport-malformed-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fcompile-fail%2Fmacro-reexport-malformed-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-reexport-malformed-2.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(macro_reexport)]\n+\n #[macro_reexport=\"foo\"]  //~ ERROR bad macro reexport\n extern crate std;\n "}, {"sha": "7ae045f6e4f5160a556d407d36206f84a8972bdf", "filename": "src/test/compile-fail/macro-reexport-malformed-3.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fcompile-fail%2Fmacro-reexport-malformed-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fcompile-fail%2Fmacro-reexport-malformed-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-reexport-malformed-3.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(macro_reexport)]\n+\n #[macro_reexport(foo=\"bar\")]  //~ ERROR bad macro reexport\n extern crate std;\n "}, {"sha": "6859ccfe3b7534b18965aedf024fe27847b80417", "filename": "src/test/compile-fail/macro-reexport-not-locally-visible.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fcompile-fail%2Fmacro-reexport-not-locally-visible.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fcompile-fail%2Fmacro-reexport-not-locally-visible.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-reexport-not-locally-visible.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -11,6 +11,8 @@\n // aux-build:macro_reexport_1.rs\n // ignore-stage1\n \n+#![feature(macro_reexport)]\n+\n #[macro_reexport(reexported)]\n #[no_link]\n extern crate macro_reexport_1;"}, {"sha": "04b234d8db7f1fa2ed2eedf6e130c1d067e8beb1", "filename": "src/test/compile-fail/match-static-const-lc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fcompile-fail%2Fmatch-static-const-lc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fcompile-fail%2Fmatch-static-const-lc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-static-const-lc.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -19,7 +19,7 @@ pub const a : isize = 97;\n fn f() {\n     let r = match (0,0) {\n         (0, a) => 0,\n-        //~^ ERROR static constant in pattern `a` should have an uppercase name such as `A`\n+        //~^ ERROR constant in pattern `a` should have an upper case name such as `A`\n         (x, y) => 1 + x + y,\n     };\n     assert!(r == 1);\n@@ -34,7 +34,7 @@ fn g() {\n     use self::m::aha;\n     let r = match (0,0) {\n         (0, aha) => 0,\n-        //~^ ERROR static constant in pattern `aha` should have an uppercase name such as `AHA`\n+        //~^ ERROR constant in pattern `aha` should have an upper case name such as `AHA`\n         (x, y)   => 1 + x + y,\n     };\n     assert!(r == 1);\n@@ -48,7 +48,7 @@ fn h() {\n     use self::n::OKAY as not_okay;\n     let r = match (0,0) {\n         (0, not_okay) => 0,\n-//~^ ERROR static constant in pattern `not_okay` should have an uppercase name such as `NOT_OKAY`\n+//~^ ERROR constant in pattern `not_okay` should have an upper case name such as `NOT_OKAY`\n         (x, y)   => 1 + x + y,\n     };\n     assert!(r == 1);"}, {"sha": "bc4bfef4d48c45adfb9696e0bb8862230c441f57", "filename": "src/test/compile-fail/missing_debug_impls.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fcompile-fail%2Fmissing_debug_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fcompile-fail%2Fmissing_debug_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmissing_debug_impls.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -11,7 +11,6 @@\n // compile-flags: --crate-type lib\n #![deny(missing_debug_implementations)]\n #![allow(unused, missing_copy_implementations)]\n-#![feature(core)]\n \n use std::fmt;\n "}, {"sha": "fbc9ad99b72434c8299f7a5f13ee37a7eb73603a", "filename": "src/test/compile-fail/range-1.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fcompile-fail%2Frange-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fcompile-fail%2Frange-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frange-1.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -17,7 +17,10 @@ pub fn main() {\n \n     // Float => does not implement iterator.\n     for i in 0f32..42f32 {}\n-    //~^ ERROR `for` loop expression has type `core::ops::Range<f32>` which does not implement\n+    //~^ ERROR `core::iter::Iterator` is not implemented for the type `core::ops::Range<f32>`\n+    //~^^ ERROR\n+    //~^^^ ERROR\n+    // FIXME(#21528) not fulfilled obligation error should be reported once, not thrice\n \n     // Unsized type.\n     let arr: &[_] = &[1us, 2, 3];"}, {"sha": "83b9d4633dcf360289f50511d0239d04198945ae", "filename": "src/test/compile-fail/regions-infer-not-param.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fcompile-fail%2Fregions-infer-not-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fcompile-fail%2Fregions-infer-not-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-not-param.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -27,5 +27,10 @@ fn take_direct<'a,'b>(p: direct<'a>) -> direct<'b> { p } //~ ERROR mismatched ty\n fn take_indirect1(p: indirect1) -> indirect1 { p }\n \n fn take_indirect2<'a,'b>(p: indirect2<'a>) -> indirect2<'b> { p } //~ ERROR mismatched types\n+//~| expected `indirect2<'b>`\n+//~| found `indirect2<'a>`\n+//~| ERROR mismatched types\n+//~| expected `indirect2<'b>`\n+//~| found `indirect2<'a>`\n \n fn main() {}"}, {"sha": "ecb2287769bbd01c045c502512a9d7f72eb780c9", "filename": "src/test/compile-fail/variance-associated-types.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fcompile-fail%2Fvariance-associated-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fcompile-fail%2Fvariance-associated-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-associated-types.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that the variance computation considers types/regions that\n+// appear in projections to be invariant.\n+\n+trait Trait<'a> {\n+    type Type;\n+\n+    fn method(&'a self) { }\n+}\n+\n+#[rustc_variance]\n+struct Foo<'a, T : Trait<'a>> { //~ ERROR ItemVariances(types=[[+];[];[]], regions=[[-];[];[]])\n+    field: (T, &'a ())\n+}\n+\n+#[rustc_variance]\n+struct Bar<'a, T : Trait<'a>> { //~ ERROR ItemVariances(types=[[o];[];[]], regions=[[o];[];[]])\n+    field: <T as Trait<'a>>::Type\n+}\n+\n+fn main() { }"}, {"sha": "3b016f287fbcfa56ff4aeea051fdb6375beb1fcf", "filename": "src/test/debuginfo/basic-types-metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fdebuginfo%2Fbasic-types-metadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fdebuginfo%2Fbasic-types-metadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fbasic-types-metadata.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -67,7 +67,7 @@ fn main() {\n     let f32: f32 = 2.5;\n     let f64: f64 = 3.5;\n     _zzz(); // #break\n-    if 1i == 1 { _yyy(); }\n+    if 1 == 1 { _yyy(); }\n }\n \n fn _zzz() {()}"}, {"sha": "6db3dce466880c965fde8be928583dfa3d1ab833", "filename": "src/test/debuginfo/box.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fdebuginfo%2Fbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fdebuginfo%2Fbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fbox.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -36,8 +36,8 @@\n #![omit_gdb_pretty_printer_section]\n \n fn main() {\n-    let a = box 1i;\n-    let b = box() (2i, 3.5f64);\n+    let a = box 1;\n+    let b = box() (2, 3.5f64);\n \n     zzz(); // #break\n }"}, {"sha": "59428a2c06f5218e819b255cd04e57e59485d3ab", "filename": "src/test/debuginfo/closure-in-generic-function.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fdebuginfo%2Fclosure-in-generic-function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fdebuginfo%2Fclosure-in-generic-function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fclosure-in-generic-function.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -60,8 +60,8 @@ fn some_generic_fun<T1, T2>(a: T1, b: T2) -> (T2, T1) {\n }\n \n fn main() {\n-    some_generic_fun(0.5f64, 10i);\n-    some_generic_fun(&29i, box 110i);\n+    some_generic_fun(0.5f64, 10);\n+    some_generic_fun(&29, box 110);\n }\n \n fn zzz() { () }"}, {"sha": "08062ce896631e3bb13b7f7c9b95e2cecf7543ad", "filename": "src/test/debuginfo/destructured-for-loop-variable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fdebuginfo%2Fdestructured-for-loop-variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fdebuginfo%2Fdestructured-for-loop-variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fdestructured-for-loop-variable.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -202,7 +202,7 @@ fn main() {\n         zzz(); // #break\n     }\n \n-    for i in 1234..1235i {\n+    for i in 1234..1235 {\n         zzz(); // #break\n     }\n "}, {"sha": "22cc779aeca7b456a4df442fd3d1c8c0af726337", "filename": "src/test/debuginfo/destructured-local.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fdebuginfo%2Fdestructured-local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fdebuginfo%2Fdestructured-local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fdestructured-local.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -278,7 +278,7 @@ fn main() {\n     let Struct { a: k, b: l } = Struct { a: 12, b: 13 };\n \n     // ignored tuple element\n-    let (m, _, n) = (14i, 15i, 16i);\n+    let (m, _, n) = (14, 15, 16);\n \n     // ignored struct field\n     let Struct { b: o, .. } = Struct { a: 17, b: 18 };\n@@ -291,25 +291,25 @@ fn main() {\n \n     // complex nesting\n     let ((u, v), ((w, (x, Struct { a: y, b: z})), Struct { a: ae, b: oe }), ue) =\n-        ((25i, 26i), ((27i, (28i, Struct { a: 29, b: 30})), Struct { a: 31, b: 32 }), 33i);\n+        ((25, 26), ((27, (28, Struct { a: 29, b: 30})), Struct { a: 31, b: 32 }), 33);\n \n     // reference\n-    let &aa = &(34i, 35i);\n+    let &aa = &(34, 35);\n \n     // reference\n-    let &bb = &(36i, 37i);\n+    let &bb = &(36, 37);\n \n     // contained reference\n-    let (&cc, _) = (&38i, 39i);\n+    let (&cc, _) = (&38, 39);\n \n     // unique pointer\n-    let box dd = box() (40i, 41i, 42i);\n+    let box dd = box() (40, 41, 42);\n \n     // ref binding\n-    let ref ee = (43i, 44i, 45i);\n+    let ref ee = (43, 44, 45);\n \n     // ref binding in tuple\n-    let (ref ff, gg) = (46i, (47i, 48i));\n+    let (ref ff, gg) = (46, (47, 48));\n \n     // ref binding in struct\n     let Struct { b: ref hh, .. } = Struct { a: 49, b: 50 };"}, {"sha": "f9a2b2fef343a282a237aa4f3d8a7d3a1f9770a6", "filename": "src/test/debuginfo/function-arg-initialization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fdebuginfo%2Ffunction-arg-initialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fdebuginfo%2Ffunction-arg-initialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ffunction-arg-initialization.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -245,7 +245,7 @@ fn non_immediate_args(a: BigStruct, b: BigStruct) {\n }\n \n fn binding(a: i64, b: u64, c: f64) {\n-    let x = 0i; // #break\n+    let x = 0; // #break\n     ::std::old_io::print(\"\")\n }\n "}, {"sha": "8d456f334323c5681157df3a29df3124687d3eff", "filename": "src/test/debuginfo/function-prologue-stepping-no-stack-check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fdebuginfo%2Ffunction-prologue-stepping-no-stack-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fdebuginfo%2Ffunction-prologue-stepping-no-stack-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ffunction-prologue-stepping-no-stack-check.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -270,7 +270,7 @@ fn non_immediate_args(a: BigStruct, b: BigStruct) {\n \n #[no_stack_check]\n fn binding(a: i64, b: u64, c: f64) {\n-    let x = 0i;\n+    let x = 0;\n     ::std::old_io::print(\"\");\n }\n "}, {"sha": "14433fbcd23b3500de51f516d881aaea705ea328", "filename": "src/test/debuginfo/function-prologue-stepping-regular.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fdebuginfo%2Ffunction-prologue-stepping-regular.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fdebuginfo%2Ffunction-prologue-stepping-regular.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ffunction-prologue-stepping-regular.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -148,7 +148,7 @@ fn non_immediate_args(a: BigStruct, b: BigStruct) {\n }\n \n fn binding(a: i64, b: u64, c: f64) {\n-    let x = 0i;\n+    let x = 0;\n }\n \n fn assignment(mut a: u64, b: u64, c: f64) {"}, {"sha": "b9a09867a0048ebd377b27445ef5dbd3fee00c7e", "filename": "src/test/debuginfo/generic-function.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fdebuginfo%2Fgeneric-function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fdebuginfo%2Fgeneric-function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fgeneric-function.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -86,9 +86,9 @@ fn dup_tup<T0: Clone, T1: Clone>(t0: &T0, t1: &T1) -> ((T0, T1), (T1, T0)) {\n \n fn main() {\n \n-    let _ = dup_tup(&1i, &2.5f64);\n+    let _ = dup_tup(&1, &2.5f64);\n     let _ = dup_tup(&3.5f64, &4_u16);\n-    let _ = dup_tup(&5i, &Struct { a: 6, b: 7.5 });\n+    let _ = dup_tup(&5, &Struct { a: 6, b: 7.5 });\n }\n \n fn zzz() {()}"}, {"sha": "9f6d8a45a995642d88bf2a14c7e16b4138db242e", "filename": "src/test/debuginfo/generic-functions-nested.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fdebuginfo%2Fgeneric-functions-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fdebuginfo%2Fgeneric-functions-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fgeneric-functions-nested.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -74,7 +74,7 @@\n #![omit_gdb_pretty_printer_section]\n \n fn outer<TA: Clone>(a: TA) {\n-    inner(a.clone(), 1i);\n+    inner(a.clone(), 1);\n     inner(a.clone(), 2.5f64);\n \n     fn inner<TX, TY>(x: TX, y: TY) {\n@@ -83,7 +83,7 @@ fn outer<TA: Clone>(a: TA) {\n }\n \n fn main() {\n-    outer(-1i);\n+    outer(-1);\n     outer(-2.5f64);\n }\n "}, {"sha": "61843a20d055f384aa0d93e340204a6471ff03f4", "filename": "src/test/debuginfo/generic-static-method-on-struct-and-enum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fdebuginfo%2Fgeneric-static-method-on-struct-and-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fdebuginfo%2Fgeneric-static-method-on-struct-and-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fgeneric-static-method-on-struct-and-enum.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -61,8 +61,8 @@ impl Enum {\n }\n \n fn main() {\n-    Struct::static_method(1i, 2i);\n-    Enum::static_method(-3i, 4.5f64, 5i);\n+    Struct::static_method(1, 2);\n+    Enum::static_method(-3, 4.5f64, 5);\n }\n \n fn zzz() {()}"}, {"sha": "2faafbd76340c4d88db70423dab0206ad765b28c", "filename": "src/test/debuginfo/generic-struct-style-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fdebuginfo%2Fgeneric-struct-style-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fdebuginfo%2Fgeneric-struct-style-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fgeneric-struct-style-enum.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -76,7 +76,7 @@ fn main() {\n     // 0b01011001 = 89\n     let case3: Regular<u16, i32, u64>  = Case3 { a: 0, b: 6438275382588823897 };\n \n-    let univariant = TheOnlyCase { a: -1i };\n+    let univariant = TheOnlyCase { a: -1 };\n \n     zzz(); // #break\n }"}, {"sha": "696d2703bdef4ee04658a4f6aa9d59d0c40bbad4", "filename": "src/test/debuginfo/generic-struct.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fdebuginfo%2Fgeneric-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fdebuginfo%2Fgeneric-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fgeneric-struct.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -32,14 +32,14 @@\n // lldb-command:run\n \n // lldb-command:print int_int\n-// lldb-check:[...]$0 = AGenericStruct<isize, isize> { key: 0, value: 1 }\n+// lldb-check:[...]$0 = AGenericStruct<i32, i32> { key: 0, value: 1 }\n // lldb-command:print int_float\n-// lldb-check:[...]$1 = AGenericStruct<isize, f64> { key: 2, value: 3.5 }\n+// lldb-check:[...]$1 = AGenericStruct<i32, f64> { key: 2, value: 3.5 }\n // lldb-command:print float_int\n-// lldb-check:[...]$2 = AGenericStruct<f64, isize> { key: 4.5, value: 5 }\n+// lldb-check:[...]$2 = AGenericStruct<f64, i32> { key: 4.5, value: 5 }\n \n // lldb-command:print float_int_float\n-// lldb-check:[...]$3 = AGenericStruct<f64, generic-struct::AGenericStruct<isize, f64>> { key: 6.5, value: AGenericStruct<isize, f64> { key: 7, value: 8.5 } }\n+// lldb-check:[...]$3 = AGenericStruct<f64, generic-struct::AGenericStruct<i32, f64>> { key: 6.5, value: AGenericStruct<i32, f64> { key: 7, value: 8.5 } }\n \n \n #![omit_gdb_pretty_printer_section]\n@@ -51,12 +51,12 @@ struct AGenericStruct<TKey, TValue> {\n \n fn main() {\n \n-    let int_int = AGenericStruct { key: 0i, value: 1i };\n-    let int_float = AGenericStruct { key: 2i, value: 3.5f64 };\n-    let float_int = AGenericStruct { key: 4.5f64, value: 5i };\n+    let int_int = AGenericStruct { key: 0, value: 1 };\n+    let int_float = AGenericStruct { key: 2, value: 3.5f64 };\n+    let float_int = AGenericStruct { key: 4.5f64, value: 5 };\n     let float_int_float = AGenericStruct {\n         key: 6.5f64,\n-        value: AGenericStruct { key: 7i, value: 8.5f64 },\n+        value: AGenericStruct { key: 7, value: 8.5f64 },\n     };\n \n     zzz(); // #break"}, {"sha": "1fa54e47163341f2d67e94e2f552adac12e22cdc", "filename": "src/test/debuginfo/lexical-scope-in-for-loop.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-for-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-for-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-for-loop.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -90,15 +90,15 @@\n \n fn main() {\n \n-    let range = [1i, 2, 3];\n+    let range = [1, 2, 3];\n \n-    let x = 1000000i; // wan meeeljen doollaars!\n+    let x = 1000000; // wan meeeljen doollaars!\n \n     for &x in range.iter() {\n         zzz(); // #break\n         sentinel();\n \n-        let x = -1i * x;\n+        let x = -1 * x;\n \n         zzz(); // #break\n         sentinel();"}, {"sha": "c885bfce216d477e91879e1edf698d1d5b93ec8b", "filename": "src/test/debuginfo/lexical-scope-in-if.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-if.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -138,8 +138,8 @@\n \n fn main() {\n \n-    let x = 999i;\n-    let y = -1i;\n+    let x = 999;\n+    let y = -1;\n \n     zzz(); // #break\n     sentinel();\n@@ -148,13 +148,13 @@ fn main() {\n         zzz(); // #break\n         sentinel();\n \n-        let x = 1001i;\n+        let x = 1001;\n \n         zzz(); // #break\n         sentinel();\n \n-        let x = 1002i;\n-        let y = 1003i;\n+        let x = 1002;\n+        let y = 1003;\n         zzz(); // #break\n         sentinel();\n     } else {\n@@ -170,8 +170,8 @@ fn main() {\n         zzz(); // #break\n         sentinel();\n \n-        let x = 1004i;\n-        let y = 1005i;\n+        let x = 1004;\n+        let y = 1005;\n         zzz(); // #break\n         sentinel();\n     }"}, {"sha": "c596253560ef4745113103d0f147c37b9d51ee53", "filename": "src/test/debuginfo/lexical-scope-in-match.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-match.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -135,21 +135,21 @@ struct Struct {\n \n fn main() {\n \n-    let shadowed = 231i;\n-    let not_shadowed = 232i;\n+    let shadowed = 231;\n+    let not_shadowed = 232;\n \n     zzz(); // #break\n     sentinel();\n \n-    match (233i, 234i) {\n+    match (233, 234) {\n         (shadowed, local_to_arm) => {\n \n             zzz(); // #break\n             sentinel();\n         }\n     }\n \n-    match (235i, 236i) {\n+    match (235, 236) {\n         // with literal\n         (235, shadowed) => {\n \n@@ -186,7 +186,7 @@ fn main() {\n         _ => {}\n     }\n \n-    match (243i, 244i) {\n+    match (243, 244) {\n         (shadowed, ref local_to_arm) => {\n \n             zzz(); // #break"}, {"sha": "5e04c81cefd7657000eb81bbd0625f5e11d2659b", "filename": "src/test/debuginfo/lexical-scope-in-parameterless-closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-parameterless-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-parameterless-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-parameterless-closure.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -19,6 +19,6 @@\n // Nothing to do here really, just make sure it compiles. See issue #8513.\n fn main() {\n     let _ = |&:|();\n-    let _ = (1u..3).map(|_| 5i);\n+    let _ = (1u..3).map(|_| 5);\n }\n "}, {"sha": "6826bca695b91d080b2f57ad9ac9dca8ab94f5f2", "filename": "src/test/debuginfo/lexical-scope-in-unconditional-loop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-unconditional-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-unconditional-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-unconditional-loop.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -136,7 +136,7 @@\n \n fn main() {\n \n-    let mut x = 0i;\n+    let mut x = 0;\n \n     loop {\n         if x >= 2 {\n@@ -160,7 +160,7 @@ fn main() {\n             zzz(); // #break\n             sentinel();\n \n-            let x = -987i;\n+            let x = -987;\n \n             zzz(); // #break\n             sentinel();"}, {"sha": "40280b469f70799bab4e2f72adaeb41258b52f55", "filename": "src/test/debuginfo/lexical-scope-in-while.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-while.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-while.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-while.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -136,7 +136,7 @@\n \n fn main() {\n \n-    let mut x = 0i;\n+    let mut x = 0;\n \n     while x < 2 {\n         zzz(); // #break\n@@ -156,7 +156,7 @@ fn main() {\n             zzz(); // #break\n             sentinel();\n \n-            let x = -987i;\n+            let x = -987;\n \n             zzz(); // #break\n             sentinel();"}, {"sha": "da941979fb661d41ca052d8d8e1f075ab6c3af7b", "filename": "src/test/debuginfo/lexical-scope-with-macro.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fdebuginfo%2Flexical-scope-with-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fdebuginfo%2Flexical-scope-with-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Flexical-scope-with-macro.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -123,7 +123,7 @@ macro_rules! no_new_scope {\n \n macro_rules! new_scope {\n     () => ({\n-        let a = 890242i;\n+        let a = 890242;\n         zzz(); // #break\n         sentinel();\n     })\n@@ -151,8 +151,8 @@ macro_rules! dup_expr {\n \n fn main() {\n \n-    let a = trivial!(10i);\n-    let b = no_new_scope!(33i);\n+    let a = trivial!(10);\n+    let b = no_new_scope!(33);\n \n     zzz(); // #break\n     sentinel();\n@@ -162,12 +162,12 @@ fn main() {\n     zzz(); // #break\n     sentinel();\n \n-    shadow_within_macro!(100i);\n+    shadow_within_macro!(100);\n \n     zzz(); // #break\n     sentinel();\n \n-    let c = dup_expr!(10i * 20);\n+    let c = dup_expr!(10 * 20);\n \n     zzz(); // #break\n     sentinel();"}, {"sha": "118d096d31b05d377a6ad4c2fe2a100f10f24d16", "filename": "src/test/debuginfo/lexical-scopes-in-block-expression.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fdebuginfo%2Flexical-scopes-in-block-expression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fdebuginfo%2Flexical-scopes-in-block-expression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Flexical-scopes-in-block-expression.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -364,8 +364,8 @@ fn a_function(x: int) -> int {\n \n fn main() {\n \n-    let val = -1i;\n-    let ten = 10i;\n+    let val = -1;\n+    let ten = 10;\n \n     // surrounded by struct expression\n     let point = Point {\n@@ -417,7 +417,7 @@ fn main() {\n         sentinel();\n \n         val\n-    }, 0i);\n+    }, 0);\n \n     zzz(); // #break\n     sentinel();\n@@ -492,7 +492,7 @@ fn main() {\n     sentinel();\n \n     // index expression\n-    let a_vector = [10i; 20];\n+    let a_vector = [10; 20];\n     let _ = a_vector[{\n         zzz(); // #break\n         sentinel();"}, {"sha": "c8fe76fdbe56a1d2ae1ddb0472f51c0e75c247fd", "filename": "src/test/debuginfo/limited-debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fdebuginfo%2Flimited-debuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fdebuginfo%2Flimited-debuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Flimited-debuginfo.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -47,7 +47,7 @@ fn zzz() {()}\n \n fn some_function(a: int, b: int) {\n     let some_variable = Struct { a: 11, b: 22 };\n-    let some_other_variable = 23i;\n+    let some_other_variable = 23;\n \n     for x in 0..1 {\n         zzz(); // #break"}, {"sha": "0b2f8ef8181e109a2c9616ee4f4ed5f3dafe0823", "filename": "src/test/debuginfo/multiple-functions-equal-var-names.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fdebuginfo%2Fmultiple-functions-equal-var-names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fdebuginfo%2Fmultiple-functions-equal-var-names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fmultiple-functions-equal-var-names.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -48,18 +48,18 @@\n #![omit_gdb_pretty_printer_section]\n \n fn function_one() {\n-    let abc = 10101i;\n+    let abc = 10101;\n     zzz(); // #break\n }\n \n fn function_two() {\n-    let abc = 20202i;\n+    let abc = 20202;\n     zzz(); // #break\n }\n \n \n fn function_three() {\n-    let abc = 30303i;\n+    let abc = 30303;\n     zzz(); // #break\n }\n "}, {"sha": "00698ae1dfb433ed361d923c12d3fd6aabfd8b5b", "filename": "src/test/debuginfo/multiple-functions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fdebuginfo%2Fmultiple-functions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fdebuginfo%2Fmultiple-functions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fmultiple-functions.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -48,18 +48,18 @@\n #![omit_gdb_pretty_printer_section]\n \n fn function_one() {\n-    let a = 10101i;\n+    let a = 10101;\n     zzz(); // #break\n }\n \n fn function_two() {\n-    let b = 20202i;\n+    let b = 20202;\n     zzz(); // #break\n }\n \n \n fn function_three() {\n-    let c = 30303i;\n+    let c = 30303;\n     zzz(); // #break\n }\n "}, {"sha": "8c1a5376dba72af383d8f70628836ba5362356c8", "filename": "src/test/debuginfo/name-shadowing-and-scope-nesting.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fdebuginfo%2Fname-shadowing-and-scope-nesting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fdebuginfo%2Fname-shadowing-and-scope-nesting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fname-shadowing-and-scope-nesting.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -103,20 +103,20 @@ fn main() {\n     zzz(); // #break\n     sentinel();\n \n-    let x = 10i;\n+    let x = 10;\n \n     zzz(); // #break\n     sentinel();\n \n     let x = 10.5f64;\n-    let y = 20i;\n+    let y = 20;\n \n     zzz(); // #break\n     sentinel();\n \n     {\n         let x = true;\n-        let y = 2220i;\n+        let y = 2220;\n \n         zzz(); // #break\n         sentinel();"}, {"sha": "5b36d32e49fcf440b6cc2b6b8f0ce86f3ceeb228", "filename": "src/test/debuginfo/shadowed-argument.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fdebuginfo%2Fshadowed-argument.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fdebuginfo%2Fshadowed-argument.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fshadowed-argument.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -65,13 +65,13 @@ fn a_function(x: bool, y: bool) {\n     zzz(); // #break\n     sentinel();\n \n-    let x = 10i;\n+    let x = 10;\n \n     zzz(); // #break\n     sentinel();\n \n     let x = 10.5f64;\n-    let y = 20i;\n+    let y = 20;\n \n     zzz(); // #break\n     sentinel();"}, {"sha": "66fd656eaacaff40d031cfe1f95b14222d31f14b", "filename": "src/test/debuginfo/shadowed-variable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fdebuginfo%2Fshadowed-variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fdebuginfo%2Fshadowed-variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fshadowed-variable.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -67,13 +67,13 @@ fn main() {\n     zzz(); // #break\n     sentinel();\n \n-    let x = 10i;\n+    let x = 10;\n \n     zzz(); // #break\n     sentinel();\n \n     let x = 10.5f64;\n-    let y = 20i;\n+    let y = 20;\n \n     zzz(); // #break\n     sentinel();"}, {"sha": "31441db20f10028887140b600a1137fa14ef531c", "filename": "src/test/debuginfo/simple-lexical-scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fdebuginfo%2Fsimple-lexical-scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fdebuginfo%2Fsimple-lexical-scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fsimple-lexical-scope.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -91,7 +91,7 @@ fn main() {\n         zzz(); // #break\n         sentinel();\n \n-        let x = 10i;\n+        let x = 10;\n \n         zzz(); // #break\n         sentinel();"}, {"sha": "24b6df4e8f1425abbdad1f1ab17ff20e9838b0b1", "filename": "src/test/debuginfo/type-names.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fdebuginfo%2Ftype-names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fdebuginfo%2Ftype-names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ftype-names.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -288,15 +288,15 @@ fn main() {\n     let slice2 = vec2.as_slice();\n \n     // Trait Objects\n-    let box_trait = (box 0i) as Box<Trait1>;\n-    let ref_trait = &0i as &Trait1;\n-    let mut mut_int1 = 0i;\n+    let box_trait = (box 0) as Box<Trait1>;\n+    let ref_trait = &0 as &Trait1;\n+    let mut mut_int1 = 0;\n     let mut_ref_trait = (&mut mut_int1) as &mut Trait1;\n \n-    let generic_box_trait = (box 0i) as Box<Trait2<i32, Mod1::Struct2>>;\n-    let generic_ref_trait  = (&0i) as &Trait2<Struct1, Struct1>;\n+    let generic_box_trait = (box 0) as Box<Trait2<i32, Mod1::Struct2>>;\n+    let generic_ref_trait  = (&0) as &Trait2<Struct1, Struct1>;\n \n-    let mut generic_mut_ref_trait_impl = 0i;\n+    let mut generic_mut_ref_trait_impl = 0;\n     let generic_mut_ref_trait = (&mut generic_mut_ref_trait_impl) as\n         &mut Trait2<Mod1::Mod2::Struct3, GenericStruct<usize, isize>>;\n "}, {"sha": "9ee18c0d77b7f6df6f0aa1e81b2dc69e79843c6f", "filename": "src/test/debuginfo/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fdebuginfo%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fdebuginfo%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fvec.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -34,7 +34,7 @@\n static mut VECT: [i32; 3] = [1, 2, 3];\n \n fn main() {\n-    let a = [1i, 2, 3];\n+    let a = [1, 2, 3];\n \n     unsafe {\n         VECT[0] = 4;"}, {"sha": "c9cb72d8af7193875fc37752a37c76a21cac2a60", "filename": "src/test/pretty/block-disambig.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fpretty%2Fblock-disambig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fpretty%2Fblock-disambig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fblock-disambig.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -15,9 +15,9 @@\n \n use std::cell::Cell;\n \n-fn test1() { let val = &0i; { } *val; }\n+fn test1() { let val = &0; { } *val; }\n \n-fn test2() -> int { let val = &0i; { } *val }\n+fn test2() -> int { let val = &0; { } *val }\n \n #[derive(Copy)]\n struct S { eax: int }\n@@ -35,13 +35,13 @@ fn test5() -> (int, int) { { } (0, 1) }\n fn test6() -> bool { { } (true || false) && true }\n \n fn test7() -> uint {\n-    let regs = &0i;\n+    let regs = &0;\n     match true { true => { } _ => { } }\n     (*regs < 2) as uint\n }\n \n fn test8() -> int {\n-    let val = &0i;\n+    let val = &0;\n     match true {\n         true => { }\n         _    => { }\n@@ -54,12 +54,12 @@ fn test8() -> int {\n }\n \n fn test9() {\n-    let regs = &Cell::new(0i);\n+    let regs = &Cell::new(0);\n     match true { true => { } _ => { } } regs.set(regs.get() + 1);\n }\n \n fn test10() -> int {\n-    let regs = vec!(0i);\n+    let regs = vec!(0);\n     match true { true => { } _ => { } }\n     regs[0]\n }"}, {"sha": "b1d38f5dc9b16587a1ca05139d8562f50228740a", "filename": "src/test/pretty/issue-4264.pp", "status": "modified", "additions": 30, "deletions": 32, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fpretty%2Fissue-4264.pp", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fpretty%2Fissue-4264.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue-4264.pp?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -41,41 +41,39 @@\n \n \n     ((::std::fmt::format as\n-         fn(core::fmt::Arguments<'_>) -> collections::string::String {std::fmt::format})(((::std::fmt::Arguments::new\n+         fn(core::fmt::Arguments<'_>) -> collections::string::String {std::fmt::format})(((::std::fmt::Arguments::new_v1\n                                                                                               as\n-                                                                                              fn(&[&str], &[core::fmt::Argument<'_>]) -> core::fmt::Arguments<'_> {core::fmt::Arguments<'a>::new})(({\n-                                                                                                                                                                                                        #[inline]\n-                                                                                                                                                                                                        #[allow(dead_code)]\n-                                                                                                                                                                                                        static __STATIC_FMTSTR:\n-                                                                                                                                                                                                               &'static [&'static str]\n-                                                                                                                                                                                                               =\n-                                                                                                                                                                                                            (&([(\"test\"\n-                                                                                                                                                                                                                    as\n-                                                                                                                                                                                                                    &'static str)]\n-                                                                                                                                                                                                                  as\n-                                                                                                                                                                                                                  [&'static str; 1])\n-                                                                                                                                                                                                                as\n-                                                                                                                                                                                                                &'static [&'static str; 1]);\n-                                                                                                                                                                                                        (__STATIC_FMTSTR\n+                                                                                              fn(&[&str], &[core::fmt::ArgumentV1<'_>]) -> core::fmt::Arguments<'_> {core::fmt::Arguments<'a>::new_v1})(({\n+                                                                                                                                                                                                             static __STATIC_FMTSTR:\n+                                                                                                                                                                                                                    &'static [&'static str]\n+                                                                                                                                                                                                                    =\n+                                                                                                                                                                                                                 (&([(\"test\"\n+                                                                                                                                                                                                                         as\n+                                                                                                                                                                                                                         &'static str)]\n+                                                                                                                                                                                                                       as\n+                                                                                                                                                                                                                       [&'static str; 1])\n+                                                                                                                                                                                                                     as\n+                                                                                                                                                                                                                     &'static [&'static str; 1]);\n+                                                                                                                                                                                                             (__STATIC_FMTSTR\n+                                                                                                                                                                                                                 as\n+                                                                                                                                                                                                                 &'static [&'static str])\n+                                                                                                                                                                                                         }\n                                                                                                                                                                                                             as\n-                                                                                                                                                                                                            &'static [&'static str])\n-                                                                                                                                                                                                    }\n-                                                                                                                                                                                                       as\n-                                                                                                                                                                                                       &[&str]),\n-                                                                                                                                                                                                   (&(match (()\n-                                                                                                                                                                                                                as\n-                                                                                                                                                                                                                ())\n-                                                                                                                                                                                                          {\n-                                                                                                                                                                                                          ()\n-                                                                                                                                                                                                          =>\n-                                                                                                                                                                                                          ([]\n+                                                                                                                                                                                                            &[&str]),\n+                                                                                                                                                                                                        (&(match (()\n+                                                                                                                                                                                                                     as\n+                                                                                                                                                                                                                     ())\n+                                                                                                                                                                                                               {\n+                                                                                                                                                                                                               ()\n+                                                                                                                                                                                                               =>\n+                                                                                                                                                                                                               ([]\n+                                                                                                                                                                                                                   as\n+                                                                                                                                                                                                                   [core::fmt::ArgumentV1<'_>; 0]),\n+                                                                                                                                                                                                           }\n                                                                                                                                                                                                               as\n-                                                                                                                                                                                                              [core::fmt::Argument<'_>; 0]),\n-                                                                                                                                                                                                      }\n-                                                                                                                                                                                                         as\n-                                                                                                                                                                                                         [core::fmt::Argument<'_>; 0])\n-                                                                                                                                                                                                       as\n-                                                                                                                                                                                                       &[core::fmt::Argument<'_>; 0]))\n+                                                                                                                                                                                                              [core::fmt::ArgumentV1<'_>; 0])\n+                                                                                                                                                                                                            as\n+                                                                                                                                                                                                            &[core::fmt::ArgumentV1<'_>; 0]))\n                                                                                              as\n                                                                                              core::fmt::Arguments<'_>))\n         as collections::string::String);"}, {"sha": "75a6b919342bf81b4f447bb6fba66eb3b1827610", "filename": "src/test/pretty/issue-929.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fpretty%2Fissue-929.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fpretty%2Fissue-929.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue-929.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -8,6 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn f() { if (1i == panic!()) { } else { } }\n+fn f() { if (1 == panic!()) { } else { } }\n \n fn main() { }"}, {"sha": "7751f155da4874aee349160dc2d297c9c2b523ae", "filename": "src/test/pretty/match-block-expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fpretty%2Fmatch-block-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fpretty%2Fmatch-block-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fmatch-block-expr.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -11,6 +11,6 @@\n // pp-exact\n \n fn main() {\n-    let x = match { 5i } { 1 => 5i, 2 => 6, _ => 7, };\n+    let x = match { 5 } { 1 => 5, 2 => 6, _ => 7, };\n     assert_eq!(x , 7);\n }"}, {"sha": "39af19dbf6f36788725902ae7a3227e1fa5389dd", "filename": "src/test/pretty/match-naked-expr-medium.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fpretty%2Fmatch-naked-expr-medium.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fpretty%2Fmatch-naked-expr-medium.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fmatch-naked-expr-medium.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -11,7 +11,7 @@\n // pp-exact\n \n fn main() {\n-    let x = Some(3i);\n+    let x = Some(3);\n     let _y =\n         match x {\n             Some(_) =>"}, {"sha": "02bbf667d96bc591ade3a74c22c307d71706506c", "filename": "src/test/pretty/match-naked-expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fpretty%2Fmatch-naked-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fpretty%2Fmatch-naked-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fmatch-naked-expr.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -11,7 +11,7 @@\n // pp-exact\n \n fn main() {\n-    let x = Some(3i);\n+    let x = Some(3);\n     let _y =\n         match x {\n             Some(_) => \"some(_)\".to_string(),"}, {"sha": "e27a3365a4105d1d7025eb002f6be59a3d14612c", "filename": "src/test/pretty/path-type-bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fpretty%2Fpath-type-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fpretty%2Fpath-type-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fpath-type-bounds.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -19,6 +19,6 @@ fn foo<'a>(x: Box<Tr+ Sync + 'a>) -> Box<Tr+ Sync + 'a> { x }\n fn main() {\n     let x: Box<Tr+ Sync>;\n \n-    Box::new(1i) as Box<Tr+ Sync>;\n+    Box::new(1) as Box<Tr+ Sync>;\n }\n "}, {"sha": "1592e010aaff770537a7f36ee76eb80867ccb86a", "filename": "src/test/pretty/unary-op-disambig.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fpretty%2Funary-op-disambig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fpretty%2Funary-op-disambig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Funary-op-disambig.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -18,10 +18,10 @@ fn block_nosemi() -> int { ({ 0 }) - 1 }\n \n fn if_semi() -> int { if true { f() } else { f() }; -1 }\n \n-fn if_nosemi() -> int { (if true { 0i } else { 0i }) - 1 }\n+fn if_nosemi() -> int { (if true { 0 } else { 0 }) - 1 }\n \n fn alt_semi() -> int { match true { true => { f() } _ => { } }; -1 }\n \n fn alt_no_semi() -> int { (match true { true => { 0 } _ => { 1 } }) - 1 }\n \n-fn stmt() { { f() }; -1i; }\n+fn stmt() { { f() }; -1; }"}, {"sha": "dc2dae1044dac2354ef981979bce687c4384e4cd", "filename": "src/test/pretty/vec-comments.pp", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fpretty%2Fvec-comments.pp", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fpretty%2Fvec-comments.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fvec-comments.pp?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -15,25 +15,25 @@\n     let _v1 =\n         [\n          // Comment\n-         0i,\n+         0,\n          // Comment\n-         1i,\n+         1,\n          // Comment\n-         2i];\n+         2];\n     let _v2 =\n-        [0i, // Comment\n-         1i, // Comment\n-         2i]; // Comment\n+        [0, // Comment\n+         1, // Comment\n+         2]; // Comment\n     let _v3 =\n         [\n          /* Comment */\n-         0i,\n+         0,\n          /* Comment */\n-         1i,\n+         1,\n          /* Comment */\n-         2i];\n+         2];\n     let _v4 =\n-        [0i, /* Comment */\n-         1i, /* Comment */\n-         2i]; /* Comment */\n+        [0, /* Comment */\n+         1, /* Comment */\n+         2]; /* Comment */\n }"}, {"sha": "dc2dae1044dac2354ef981979bce687c4384e4cd", "filename": "src/test/pretty/vec-comments.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fpretty%2Fvec-comments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Fpretty%2Fvec-comments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fvec-comments.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -15,25 +15,25 @@ fn main() {\n     let _v1 =\n         [\n          // Comment\n-         0i,\n+         0,\n          // Comment\n-         1i,\n+         1,\n          // Comment\n-         2i];\n+         2];\n     let _v2 =\n-        [0i, // Comment\n-         1i, // Comment\n-         2i]; // Comment\n+        [0, // Comment\n+         1, // Comment\n+         2]; // Comment\n     let _v3 =\n         [\n          /* Comment */\n-         0i,\n+         0,\n          /* Comment */\n-         1i,\n+         1,\n          /* Comment */\n-         2i];\n+         2];\n     let _v4 =\n-        [0i, /* Comment */\n-         1i, /* Comment */\n-         2i]; /* Comment */\n+        [0, /* Comment */\n+         1, /* Comment */\n+         2]; /* Comment */\n }"}, {"sha": "fd6d69efb4f6e018664bdbe38fc43ff311e30c82", "filename": "src/test/run-fail/assert-eq-macro-panic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Frun-fail%2Fassert-eq-macro-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Frun-fail%2Fassert-eq-macro-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fassert-eq-macro-panic.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -11,5 +11,5 @@\n // error-pattern:assertion failed: `(left == right) && (right == left)` (left: `14`, right: `15`)\n \n fn main() {\n-    assert_eq!(14i,15i);\n+    assert_eq!(14,15);\n }"}, {"sha": "78239a2217e6b1fd4912b20e39c2ecd59813ad96", "filename": "src/test/run-fail/assert-macro-fmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Frun-fail%2Fassert-macro-fmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Frun-fail%2Fassert-macro-fmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fassert-macro-fmt.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -11,5 +11,5 @@\n // error-pattern:panicked at 'test-assert-fmt 42 rust'\n \n fn main() {\n-    assert!(false, \"test-assert-fmt {} {}\", 42i, \"rust\");\n+    assert!(false, \"test-assert-fmt {} {}\", 42, \"rust\");\n }"}, {"sha": "be4ad0781f272f9ee40110772d5b1b79000ca3e9", "filename": "src/test/run-fail/bounds-check-no-overflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Frun-fail%2Fbounds-check-no-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Frun-fail%2Fbounds-check-no-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fbounds-check-no-overflow.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -14,6 +14,6 @@ use std::uint;\n use std::mem::size_of;\n \n fn main() {\n-    let xs = [1i, 2, 3];\n+    let xs = [1, 2, 3];\n     xs[uint::MAX / size_of::<int>() + 1];\n }"}, {"sha": "de69b7b9fa6705ed03afd7c07abd96ef49415334", "filename": "src/test/run-fail/divide-by-zero.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Frun-fail%2Fdivide-by-zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Frun-fail%2Fdivide-by-zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fdivide-by-zero.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -10,6 +10,6 @@\n \n // error-pattern:attempted to divide by zero\n fn main() {\n-    let y = 0i;\n-    let _z = 1i / y;\n+    let y = 0;\n+    let _z = 1 / y;\n }"}, {"sha": "77cec8b632728bdd719cfd4895ad2666f34ae344", "filename": "src/test/run-fail/dst-raw-slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Frun-fail%2Fdst-raw-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Frun-fail%2Fdst-raw-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fdst-raw-slice.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -12,7 +12,7 @@\n // error-pattern:index out of bounds\n \n fn main() {\n-    let a: *const [_] = &[1i, 2, 3];\n+    let a: *const [_] = &[1, 2, 3];\n     unsafe {\n         let _b = (*a)[3];\n     }"}, {"sha": "c9c04e5f2daab8614e703fc17eb3d1839e5b1929", "filename": "src/test/run-fail/explicit-panic-msg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Frun-fail%2Fexplicit-panic-msg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Frun-fail%2Fexplicit-panic-msg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fexplicit-panic-msg.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -13,7 +13,7 @@\n \n // error-pattern:wooooo\n fn main() {\n-    let mut a = 1i;\n-    if 1i == 1 { a = 2; }\n+    let mut a = 1;\n+    if 1 == 1 { a = 2; }\n     panic!(format!(\"woooo{}\", \"o\"));\n }"}, {"sha": "b6791271a11ba98ba66024f69f5af625a22e32b2", "filename": "src/test/run-fail/expr-if-panic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Frun-fail%2Fexpr-if-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Frun-fail%2Fexpr-if-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fexpr-if-panic.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -10,4 +10,4 @@\n \n // error-pattern:explicit panic\n \n-fn main() { let _x = if false { 0i } else if true { panic!() } else { 10i }; }\n+fn main() { let _x = if false { 0 } else if true { panic!() } else { 10 }; }"}, {"sha": "3a6bd59b3acaa44133f76487ecb5377b2872c097", "filename": "src/test/run-fail/expr-match-panic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Frun-fail%2Fexpr-match-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Frun-fail%2Fexpr-match-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fexpr-match-panic.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -10,4 +10,4 @@\n \n // error-pattern:explicit panic\n \n-fn main() { let _x = match true { false => { 0i } true => { panic!() } }; }\n+fn main() { let _x = match true { false => { 0 } true => { panic!() } }; }"}, {"sha": "cbc92c640d2ca6816e311bfca1336a5b3bb03357", "filename": "src/test/run-fail/issue-12920.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Frun-fail%2Fissue-12920.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Frun-fail%2Fissue-12920.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fissue-12920.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -11,5 +11,5 @@\n // error-pattern:explicit panic\n \n pub fn main() {\n-    panic!(); println!(\"{}\", 1i);\n+    panic!(); println!(\"{}\", 1);\n }"}, {"sha": "4d048fe0fcf4b2c8e3f1286e9f84275502fc0a84", "filename": "src/test/run-fail/issue-3029.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Frun-fail%2Fissue-3029.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Frun-fail%2Fissue-3029.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fissue-3029.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -16,7 +16,7 @@\n // error-pattern:so long\n fn main() {\n     let mut x = Vec::new();\n-    let y = vec!(3i);\n+    let y = vec!(3);\n     panic!(\"so long\");\n     x.extend(y.into_iter());\n }"}, {"sha": "76d4de7ecb03ce907b987c4e16e705a4dc36373e", "filename": "src/test/run-fail/mod-zero.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Frun-fail%2Fmod-zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Frun-fail%2Fmod-zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmod-zero.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -10,6 +10,6 @@\n \n // error-pattern:attempted remainder with a divisor of zero\n fn main() {\n-    let y = 0i;\n-    let _z = 1i % y;\n+    let y = 0;\n+    let _z = 1 % y;\n }"}, {"sha": "ce6a5d46cc740b1ec75a3395fa7d0887a4ee7e85", "filename": "src/test/run-fail/panic-macro-any.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Frun-fail%2Fpanic-macro-any.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Frun-fail%2Fpanic-macro-any.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fpanic-macro-any.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -14,5 +14,5 @@\n #![feature(box_syntax)]\n \n fn main() {\n-    panic!(box 413i as Box<::std::any::Any+Send>);\n+    panic!(box 413 as Box<::std::any::Any+Send>);\n }"}, {"sha": "50ad99c6747b2becd9d05e689b92a93f4cfb8e5a", "filename": "src/test/run-fail/panic-macro-fmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Frun-fail%2Fpanic-macro-fmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Frun-fail%2Fpanic-macro-fmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fpanic-macro-fmt.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -11,5 +11,5 @@\n // error-pattern:panicked at 'test-fail-fmt 42 rust'\n \n fn main() {\n-    panic!(\"test-fail-fmt {} {}\", 42i, \"rust\");\n+    panic!(\"test-fail-fmt {} {}\", 42, \"rust\");\n }"}, {"sha": "816ee84a8410a3b7aab073bb7c7badcc2ed1e911", "filename": "src/test/run-fail/panic-task-name-none.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Frun-fail%2Fpanic-task-name-none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Frun-fail%2Fpanic-task-name-none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fpanic-task-name-none.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -15,7 +15,7 @@ use std::thread::Thread;\n fn main() {\n     let r: Result<int,_> = Thread::scoped(move|| {\n         panic!(\"test\");\n-        1i\n+        1\n     }).join();\n     assert!(r.is_ok());\n }"}, {"sha": "d48d282c9eb3578d8244c7f11ce12d446c439062", "filename": "src/test/run-fail/panic-task-name-owned.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Frun-fail%2Fpanic-task-name-owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474b324eda10440d6568ef872a7307d38e7de95b/src%2Ftest%2Frun-fail%2Fpanic-task-name-owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fpanic-task-name-owned.rs?ref=474b324eda10440d6568ef872a7307d38e7de95b", "patch": "@@ -15,7 +15,7 @@ use std::thread::Builder;\n fn main() {\n     let r: Result<int,_> = Builder::new().name(\"owned name\".to_string()).scoped(move|| {\n         panic!(\"test\");\n-        1i\n+        1\n     }).join();\n     assert!(r.is_ok());\n }"}]}