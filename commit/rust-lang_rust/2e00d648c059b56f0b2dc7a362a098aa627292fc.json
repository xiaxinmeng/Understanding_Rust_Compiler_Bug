{"sha": "2e00d648c059b56f0b2dc7a362a098aa627292fc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlMDBkNjQ4YzA1OWI1NmYwYjJkYzdhMzYyYTA5OGFhNjI3MjkyZmM=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2018-12-03T15:31:20Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2018-12-03T15:31:20Z"}, "message": "s/AllocType/AllocKind/", "tree": {"sha": "390332dec714faddc4ba7c691f3941d60d119a40", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/390332dec714faddc4ba7c691f3941d60d119a40"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2e00d648c059b56f0b2dc7a362a098aa627292fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2e00d648c059b56f0b2dc7a362a098aa627292fc", "html_url": "https://github.com/rust-lang/rust/commit/2e00d648c059b56f0b2dc7a362a098aa627292fc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2e00d648c059b56f0b2dc7a362a098aa627292fc/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a1e83a905f1ad82f2f35fd72b6b6797d7b60b8d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1e83a905f1ad82f2f35fd72b6b6797d7b60b8d0", "html_url": "https://github.com/rust-lang/rust/commit/a1e83a905f1ad82f2f35fd72b6b6797d7b60b8d0"}], "stats": {"total": 80, "additions": 40, "deletions": 40}, "files": [{"sha": "56da6b719f4a7287f7b3d749105162a85606cb96", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e00d648c059b56f0b2dc7a362a098aa627292fc/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e00d648c059b56f0b2dc7a362a098aa627292fc/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=2e00d648c059b56f0b2dc7a362a098aa627292fc", "patch": "@@ -338,7 +338,7 @@ impl_stable_hash_for!(\n );\n \n impl_stable_hash_for!(\n-    impl<'tcx> for enum mir::interpret::AllocType<'tcx> [ mir::interpret::AllocType ] {\n+    impl<'tcx> for enum mir::interpret::AllocKind<'tcx> [ mir::interpret::AllocKind ] {\n         Function(instance),\n         Static(def_id),\n         Memory(mem),"}, {"sha": "fbfe0cdae6beda21690583e1f884fb003350d5d2", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2e00d648c059b56f0b2dc7a362a098aa627292fc/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e00d648c059b56f0b2dc7a362a098aa627292fc/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=2e00d648c059b56f0b2dc7a362a098aa627292fc", "patch": "@@ -103,20 +103,20 @@ pub fn specialized_encode_alloc_id<\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     alloc_id: AllocId,\n ) -> Result<(), E::Error> {\n-    let alloc_type: AllocType<'tcx> =\n+    let alloc_type: AllocKind<'tcx> =\n         tcx.alloc_map.lock().get(alloc_id).expect(\"no value for AllocId\");\n     match alloc_type {\n-        AllocType::Memory(alloc) => {\n+        AllocKind::Memory(alloc) => {\n             trace!(\"encoding {:?} with {:#?}\", alloc_id, alloc);\n             AllocDiscriminant::Alloc.encode(encoder)?;\n             alloc.encode(encoder)?;\n         }\n-        AllocType::Function(fn_instance) => {\n+        AllocKind::Function(fn_instance) => {\n             trace!(\"encoding {:?} with {:#?}\", alloc_id, fn_instance);\n             AllocDiscriminant::Fn.encode(encoder)?;\n             fn_instance.encode(encoder)?;\n         }\n-        AllocType::Static(did) => {\n+        AllocKind::Static(did) => {\n             // referring to statics doesn't need to know about their allocations,\n             // just about its DefId\n             AllocDiscriminant::Static.encode(encoder)?;\n@@ -291,7 +291,7 @@ impl fmt::Display for AllocId {\n }\n \n #[derive(Debug, Clone, Eq, PartialEq, Hash, RustcDecodable, RustcEncodable)]\n-pub enum AllocType<'tcx> {\n+pub enum AllocKind<'tcx> {\n     /// The alloc id is used as a function pointer\n     Function(Instance<'tcx>),\n     /// The alloc id points to a \"lazy\" static variable that did not get computed (yet).\n@@ -303,10 +303,10 @@ pub enum AllocType<'tcx> {\n \n pub struct AllocMap<'tcx> {\n     /// Lets you know what an AllocId refers to\n-    id_to_type: FxHashMap<AllocId, AllocType<'tcx>>,\n+    id_to_type: FxHashMap<AllocId, AllocKind<'tcx>>,\n \n     /// Used to ensure that statics only get one associated AllocId\n-    type_interner: FxHashMap<AllocType<'tcx>, AllocId>,\n+    type_interner: FxHashMap<AllocKind<'tcx>, AllocId>,\n \n     /// The AllocId to assign to the next requested id.\n     /// Always incremented, never gets smaller.\n@@ -339,7 +339,7 @@ impl<'tcx> AllocMap<'tcx> {\n         next\n     }\n \n-    fn intern(&mut self, alloc_type: AllocType<'tcx>) -> AllocId {\n+    fn intern(&mut self, alloc_type: AllocKind<'tcx>) -> AllocId {\n         if let Some(&alloc_id) = self.type_interner.get(&alloc_type) {\n             return alloc_id;\n         }\n@@ -356,29 +356,29 @@ impl<'tcx> AllocMap<'tcx> {\n     /// `main as fn() == main as fn()` is false, while `let x = main as fn(); x == x` is true.\n     pub fn create_fn_alloc(&mut self, instance: Instance<'tcx>) -> AllocId {\n         let id = self.reserve();\n-        self.id_to_type.insert(id, AllocType::Function(instance));\n+        self.id_to_type.insert(id, AllocKind::Function(instance));\n         id\n     }\n \n     /// Returns `None` in case the `AllocId` is dangling.\n     /// This function exists to allow const eval to detect the difference between evaluation-\n     /// local dangling pointers and allocations in constants/statics.\n-    pub fn get(&self, id: AllocId) -> Option<AllocType<'tcx>> {\n+    pub fn get(&self, id: AllocId) -> Option<AllocKind<'tcx>> {\n         self.id_to_type.get(&id).cloned()\n     }\n \n     /// Panics if the `AllocId` does not refer to an `Allocation`\n     pub fn unwrap_memory(&self, id: AllocId) -> &'tcx Allocation {\n         match self.get(id) {\n-            Some(AllocType::Memory(mem)) => mem,\n+            Some(AllocKind::Memory(mem)) => mem,\n             _ => bug!(\"expected allocation id {} to point to memory\", id),\n         }\n     }\n \n     /// Generate an `AllocId` for a static or return a cached one in case this function has been\n     /// called on the same static before.\n     pub fn intern_static(&mut self, static_id: DefId) -> AllocId {\n-        self.intern(AllocType::Static(static_id))\n+        self.intern(AllocKind::Static(static_id))\n     }\n \n     /// Intern the `Allocation` and return a new `AllocId`, even if there's already an identical\n@@ -395,15 +395,15 @@ impl<'tcx> AllocMap<'tcx> {\n     /// Freeze an `AllocId` created with `reserve` by pointing it at an `Allocation`. Trying to\n     /// call this function twice, even with the same `Allocation` will ICE the compiler.\n     pub fn set_id_memory(&mut self, id: AllocId, mem: &'tcx Allocation) {\n-        if let Some(old) = self.id_to_type.insert(id, AllocType::Memory(mem)) {\n+        if let Some(old) = self.id_to_type.insert(id, AllocKind::Memory(mem)) {\n             bug!(\"tried to set allocation id {}, but it was already existing as {:#?}\", id, old);\n         }\n     }\n \n     /// Freeze an `AllocId` created with `reserve` by pointing it at an `Allocation`. May be called\n     /// twice for the same `(AllocId, Allocation)` pair.\n     pub fn set_id_same_memory(&mut self, id: AllocId, mem: &'tcx Allocation) {\n-        self.id_to_type.insert_same(id, AllocType::Memory(mem));\n+        self.id_to_type.insert_same(id, AllocKind::Memory(mem));\n     }\n }\n "}, {"sha": "16374c92606eee722f4ce0855a01d0902c09df5a", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e00d648c059b56f0b2dc7a362a098aa627292fc/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e00d648c059b56f0b2dc7a362a098aa627292fc/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=2e00d648c059b56f0b2dc7a362a098aa627292fc", "patch": "@@ -18,7 +18,7 @@ use super::{EvalResult, Pointer, PointerArithmetic, Allocation, AllocId, sign_ex\n /// Represents the result of a raw const operation, pre-validation.\n #[derive(Copy, Clone, Debug, Eq, PartialEq, RustcEncodable, RustcDecodable, Hash)]\n pub struct RawConst<'tcx> {\n-    // the value lives here, at offset 0, and that allocation definitely is a `AllocType::Memory`\n+    // the value lives here, at offset 0, and that allocation definitely is a `AllocKind::Memory`\n     // (so you can use `AllocMap::unwrap_memory`).\n     pub alloc_id: AllocId,\n     pub ty: Ty<'tcx>,"}, {"sha": "47058f91525a89e988b79821b3ced0670c974f95", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e00d648c059b56f0b2dc7a362a098aa627292fc/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e00d648c059b56f0b2dc7a362a098aa627292fc/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=2e00d648c059b56f0b2dc7a362a098aa627292fc", "patch": "@@ -2629,7 +2629,7 @@ pub fn fmt_const_val(f: &mut impl Write, const_val: &ty::Const<'_>) -> fmt::Resu\n                 if let Ref(_, &ty::TyS { sty: Str, .. }, _) = ty.sty {\n                     return ty::tls::with(|tcx| {\n                         let alloc = tcx.alloc_map.lock().get(ptr.alloc_id);\n-                        if let Some(interpret::AllocType::Memory(alloc)) = alloc {\n+                        if let Some(interpret::AllocKind::Memory(alloc)) = alloc {\n                             assert_eq!(len as usize as u128, len);\n                             let slice =\n                                 &alloc.bytes[(ptr.offset.bytes() as usize)..][..(len as usize)];"}, {"sha": "0d9c417f5229ba3164f3d83b5b397666b43204c2", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2e00d648c059b56f0b2dc7a362a098aa627292fc/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e00d648c059b56f0b2dc7a362a098aa627292fc/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=2e00d648c059b56f0b2dc7a362a098aa627292fc", "patch": "@@ -21,7 +21,7 @@ use value::Value;\n use rustc_codegen_ssa::traits::*;\n \n use rustc::ty::layout::{HasDataLayout, LayoutOf, self, TyLayout, Size};\n-use rustc::mir::interpret::{Scalar, AllocType, Allocation};\n+use rustc::mir::interpret::{Scalar, AllocKind, Allocation};\n use consts::const_alloc_to_llvm;\n use rustc_codegen_ssa::mir::place::PlaceRef;\n \n@@ -318,18 +318,18 @@ impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n             Scalar::Ptr(ptr) => {\n                 let alloc_type = self.tcx.alloc_map.lock().get(ptr.alloc_id);\n                 let base_addr = match alloc_type {\n-                    Some(AllocType::Memory(alloc)) => {\n+                    Some(AllocKind::Memory(alloc)) => {\n                         let init = const_alloc_to_llvm(self, alloc);\n                         if alloc.mutability == Mutability::Mutable {\n                             self.static_addr_of_mut(init, alloc.align, None)\n                         } else {\n                             self.static_addr_of(init, alloc.align, None)\n                         }\n                     }\n-                    Some(AllocType::Function(fn_instance)) => {\n+                    Some(AllocKind::Function(fn_instance)) => {\n                         self.get_fn(fn_instance)\n                     }\n-                    Some(AllocType::Static(def_id)) => {\n+                    Some(AllocKind::Static(def_id)) => {\n                         assert!(self.tcx.is_static(def_id).is_some());\n                         self.get_static(def_id)\n                     }"}, {"sha": "cc96976e74a3055516a947b0cdc9bd605d366738", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2e00d648c059b56f0b2dc7a362a098aa627292fc/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e00d648c059b56f0b2dc7a362a098aa627292fc/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=2e00d648c059b56f0b2dc7a362a098aa627292fc", "patch": "@@ -29,7 +29,7 @@ use syntax::ast::Mutability;\n \n use super::{\n     Pointer, AllocId, Allocation, GlobalId, AllocationExtra,\n-    EvalResult, Scalar, EvalErrorKind, AllocType, PointerArithmetic,\n+    EvalResult, Scalar, EvalErrorKind, AllocKind, PointerArithmetic,\n     Machine, AllocMap, MayLeak, ErrorHandled, InboundsCheck,\n };\n \n@@ -204,12 +204,12 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             None => {\n                 // Deallocating static memory -- always an error\n                 return match self.tcx.alloc_map.lock().get(ptr.alloc_id) {\n-                    Some(AllocType::Function(..)) => err!(DeallocatedWrongMemoryKind(\n+                    Some(AllocKind::Function(..)) => err!(DeallocatedWrongMemoryKind(\n                         \"function\".to_string(),\n                         format!(\"{:?}\", kind),\n                     )),\n-                    Some(AllocType::Static(..)) |\n-                    Some(AllocType::Memory(..)) => err!(DeallocatedWrongMemoryKind(\n+                    Some(AllocKind::Static(..)) |\n+                    Some(AllocKind::Memory(..)) => err!(DeallocatedWrongMemoryKind(\n                         \"static\".to_string(),\n                         format!(\"{:?}\", kind),\n                     )),\n@@ -326,15 +326,15 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     ) -> EvalResult<'tcx, Cow<'tcx, Allocation<M::PointerTag, M::AllocExtra>>> {\n         let alloc = tcx.alloc_map.lock().get(id);\n         let def_id = match alloc {\n-            Some(AllocType::Memory(mem)) => {\n+            Some(AllocKind::Memory(mem)) => {\n                 // We got tcx memory. Let the machine figure out whether and how to\n                 // turn that into memory with the right pointer tag.\n                 return Ok(M::adjust_static_allocation(mem, memory_extra))\n             }\n-            Some(AllocType::Function(..)) => {\n+            Some(AllocKind::Function(..)) => {\n                 return err!(DerefFunctionPointer)\n             }\n-            Some(AllocType::Static(did)) => {\n+            Some(AllocKind::Static(did)) => {\n                 did\n             }\n             None =>\n@@ -435,8 +435,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         }\n         // Could also be a fn ptr or extern static\n         match self.tcx.alloc_map.lock().get(id) {\n-            Some(AllocType::Function(..)) => (Size::ZERO, Align::from_bytes(1).unwrap()),\n-            Some(AllocType::Static(did)) => {\n+            Some(AllocKind::Function(..)) => (Size::ZERO, Align::from_bytes(1).unwrap()),\n+            Some(AllocKind::Static(did)) => {\n                 // The only way `get` couldn't have worked here is if this is an extern static\n                 assert!(self.tcx.is_foreign_item(did));\n                 // Use size and align of the type\n@@ -459,7 +459,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         }\n         trace!(\"reading fn ptr: {}\", ptr.alloc_id);\n         match self.tcx.alloc_map.lock().get(ptr.alloc_id) {\n-            Some(AllocType::Function(instance)) => Ok(instance),\n+            Some(AllocKind::Function(instance)) => Ok(instance),\n             _ => Err(EvalErrorKind::ExecuteMemory.into()),\n         }\n     }\n@@ -557,16 +557,16 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n                 Err(()) => {\n                     // static alloc?\n                     match self.tcx.alloc_map.lock().get(id) {\n-                        Some(AllocType::Memory(alloc)) => {\n+                        Some(AllocKind::Memory(alloc)) => {\n                             self.dump_alloc_helper(\n                                 &mut allocs_seen, &mut allocs_to_print,\n                                 msg, alloc, \" (immutable)\".to_owned()\n                             );\n                         }\n-                        Some(AllocType::Function(func)) => {\n+                        Some(AllocKind::Function(func)) => {\n                             trace!(\"{} {}\", msg, func);\n                         }\n-                        Some(AllocType::Static(did)) => {\n+                        Some(AllocKind::Static(did)) => {\n                             trace!(\"{} {:?}\", msg, did);\n                         }\n                         None => {"}, {"sha": "bf771789c8dee1ddd5155fb5198ecb138d770a4b", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2e00d648c059b56f0b2dc7a362a098aa627292fc/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e00d648c059b56f0b2dc7a362a098aa627292fc/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=2e00d648c059b56f0b2dc7a362a098aa627292fc", "patch": "@@ -17,7 +17,7 @@ use rustc::ty::layout::{self, Size, Align, TyLayout, LayoutOf, VariantIdx};\n use rustc::ty;\n use rustc_data_structures::fx::FxHashSet;\n use rustc::mir::interpret::{\n-    Scalar, AllocType, EvalResult, EvalErrorKind,\n+    Scalar, AllocKind, EvalResult, EvalErrorKind,\n };\n \n use super::{\n@@ -388,7 +388,7 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n                             \"integer pointer in non-ZST reference\", self.path);\n                         // Skip validation entirely for some external statics\n                         let alloc_kind = self.ecx.tcx.alloc_map.lock().get(ptr.alloc_id);\n-                        if let Some(AllocType::Static(did)) = alloc_kind {\n+                        if let Some(AllocKind::Static(did)) = alloc_kind {\n                             // `extern static` cannot be validated as they have no body.\n                             // FIXME: Statics from other crates are also skipped.\n                             // They might be checked at a different type, but for now we"}, {"sha": "ec5c57ee0ba68d435e5796996f4d3c4e5160ac88", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2e00d648c059b56f0b2dc7a362a098aa627292fc/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e00d648c059b56f0b2dc7a362a098aa627292fc/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=2e00d648c059b56f0b2dc7a362a098aa627292fc", "patch": "@@ -197,7 +197,7 @@ use rustc::session::config;\n use rustc::mir::{self, Location, Promoted};\n use rustc::mir::visit::Visitor as MirVisitor;\n use rustc::mir::mono::MonoItem;\n-use rustc::mir::interpret::{Scalar, GlobalId, AllocType, ErrorHandled};\n+use rustc::mir::interpret::{Scalar, GlobalId, AllocKind, ErrorHandled};\n \n use monomorphize::{self, Instance};\n use rustc::util::nodemap::{FxHashSet, FxHashMap, DefIdMap};\n@@ -1163,20 +1163,20 @@ fn collect_miri<'a, 'tcx>(\n ) {\n     let alloc_type = tcx.alloc_map.lock().get(alloc_id);\n     match alloc_type {\n-        Some(AllocType::Static(did)) => {\n+        Some(AllocKind::Static(did)) => {\n             let instance = Instance::mono(tcx, did);\n             if should_monomorphize_locally(tcx, &instance) {\n                 trace!(\"collecting static {:?}\", did);\n                 output.push(MonoItem::Static(did));\n             }\n         }\n-        Some(AllocType::Memory(alloc)) => {\n+        Some(AllocKind::Memory(alloc)) => {\n             trace!(\"collecting {:?} with {:#?}\", alloc_id, alloc);\n             for &((), inner) in alloc.relocations.values() {\n                 collect_miri(tcx, inner, output);\n             }\n         },\n-        Some(AllocType::Function(fn_instance)) => {\n+        Some(AllocKind::Function(fn_instance)) => {\n             if should_monomorphize_locally(tcx, &fn_instance) {\n                 trace!(\"collecting {:?} with {:#?}\", alloc_id, fn_instance);\n                 output.push(create_fn_mono_item(fn_instance));"}]}