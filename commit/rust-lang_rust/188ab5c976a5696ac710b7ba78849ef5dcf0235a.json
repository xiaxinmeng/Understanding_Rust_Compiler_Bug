{"sha": "188ab5c976a5696ac710b7ba78849ef5dcf0235a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4OGFiNWM5NzZhNTY5NmFjNzEwYjdiYTc4ODQ5ZWY1ZGNmMDIzNWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-06T13:37:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-06T13:37:22Z"}, "message": "Auto merge of #63328 - Centril:rollup-482ujaf, r=Centril\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #62459 (Use internal iteration in the Sum and Product impls of Result and Option)\n - #62821 (Not listed methods)\n - #62837 (Fix theme picker blur handler: always hide instead of switching)\n - #63286 (Replace error callback with Result)\n - #63296 (Deduplicate rustc_demangle in librustc_codegen_llvm)\n - #63298 (assume_init: warn about valid != safe)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "d6cb1ce7bb550a89bfbd9c9d2f3ec332b97a6003", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d6cb1ce7bb550a89bfbd9c9d2f3ec332b97a6003"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/188ab5c976a5696ac710b7ba78849ef5dcf0235a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/188ab5c976a5696ac710b7ba78849ef5dcf0235a", "html_url": "https://github.com/rust-lang/rust/commit/188ab5c976a5696ac710b7ba78849ef5dcf0235a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/188ab5c976a5696ac710b7ba78849ef5dcf0235a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8996328ebf34aa73e83a1db326767c11041f811d", "url": "https://api.github.com/repos/rust-lang/rust/commits/8996328ebf34aa73e83a1db326767c11041f811d", "html_url": "https://github.com/rust-lang/rust/commit/8996328ebf34aa73e83a1db326767c11041f811d"}, {"sha": "d72cb093f4ae86f37521bae8e7932403d90e8365", "url": "https://api.github.com/repos/rust-lang/rust/commits/d72cb093f4ae86f37521bae8e7932403d90e8365", "html_url": "https://github.com/rust-lang/rust/commit/d72cb093f4ae86f37521bae8e7932403d90e8365"}], "stats": {"total": 307, "additions": 151, "deletions": 156}, "files": [{"sha": "cb1e3d4d1d37ffd3e0b920e0d89aa353abd82567", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/188ab5c976a5696ac710b7ba78849ef5dcf0235a/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/188ab5c976a5696ac710b7ba78849ef5dcf0235a/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=188ab5c976a5696ac710b7ba78849ef5dcf0235a", "patch": "@@ -2848,7 +2848,6 @@ dependencies = [\n  \"cc 1.0.35 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"memmap 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num_cpus 1.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-demangle 0.1.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_llvm 0.0.0\",\n  \"tempfile 3.0.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]"}, {"sha": "b2702902956935b86d2f805cfb5582434379a395", "filename": "src/libcore/iter/adapters/mod.rs", "status": "modified", "additions": 37, "deletions": 109, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/188ab5c976a5696ac710b7ba78849ef5dcf0235a/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/188ab5c976a5696ac710b7ba78849ef5dcf0235a/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs?ref=188ab5c976a5696ac710b7ba78849ef5dcf0235a", "patch": "@@ -2180,137 +2180,65 @@ impl<I: ExactSizeIterator, F> ExactSizeIterator for Inspect<I, F>\n impl<I: FusedIterator, F> FusedIterator for Inspect<I, F>\n     where F: FnMut(&I::Item) {}\n \n-/// An iterator adapter that produces output as long as the underlying\n-/// iterator produces `Option::Some` values.\n-pub(crate) struct OptionShunt<I> {\n-    iter: I,\n-    exited_early: bool,\n-}\n-\n-impl<I, T> OptionShunt<I>\n-where\n-    I: Iterator<Item = Option<T>>,\n-{\n-    /// Process the given iterator as if it yielded a `T` instead of a\n-    /// `Option<T>`. Any `None` value will stop the inner iterator and\n-    /// the overall result will be a `None`.\n-    pub fn process<F, U>(iter: I, mut f: F) -> Option<U>\n-    where\n-        F: FnMut(&mut Self) -> U,\n-    {\n-        let mut shunt = OptionShunt::new(iter);\n-        let value = f(shunt.by_ref());\n-        shunt.reconstruct(value)\n-    }\n-\n-    fn new(iter: I) -> Self {\n-        OptionShunt {\n-            iter,\n-            exited_early: false,\n-        }\n-    }\n-\n-    /// Consume the adapter and rebuild a `Option` value.\n-    fn reconstruct<U>(self, val: U) -> Option<U> {\n-        if self.exited_early {\n-            None\n-        } else {\n-            Some(val)\n-        }\n-    }\n-}\n-\n-impl<I, T> Iterator for OptionShunt<I>\n-where\n-    I: Iterator<Item = Option<T>>,\n-{\n-    type Item = T;\n-\n-    fn next(&mut self) -> Option<Self::Item> {\n-        match self.iter.next() {\n-            Some(Some(v)) => Some(v),\n-            Some(None) => {\n-                self.exited_early = true;\n-                None\n-            }\n-            None => None,\n-        }\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        if self.exited_early {\n-            (0, Some(0))\n-        } else {\n-            let (_, upper) = self.iter.size_hint();\n-            (0, upper)\n-        }\n-    }\n-}\n-\n /// An iterator adapter that produces output as long as the underlying\n /// iterator produces `Result::Ok` values.\n ///\n /// If an error is encountered, the iterator stops and the error is\n-/// stored. The error may be recovered later via `reconstruct`.\n-pub(crate) struct ResultShunt<I, E> {\n+/// stored.\n+pub(crate) struct ResultShunt<'a, I, E> {\n     iter: I,\n-    error: Option<E>,\n+    error: &'a mut Result<(), E>,\n }\n \n-impl<I, T, E> ResultShunt<I, E>\n-    where I: Iterator<Item = Result<T, E>>\n+/// Process the given iterator as if it yielded a `T` instead of a\n+/// `Result<T, _>`. Any errors will stop the inner iterator and\n+/// the overall result will be an error.\n+pub(crate) fn process_results<I, T, E, F, U>(iter: I, mut f: F) -> Result<U, E>\n+where\n+    I: Iterator<Item = Result<T, E>>,\n+    for<'a> F: FnMut(ResultShunt<'a, I, E>) -> U,\n {\n-    /// Process the given iterator as if it yielded a `T` instead of a\n-    /// `Result<T, _>`. Any errors will stop the inner iterator and\n-    /// the overall result will be an error.\n-    pub fn process<F, U>(iter: I, mut f: F) -> Result<U, E>\n-        where F: FnMut(&mut Self) -> U\n-    {\n-        let mut shunt = ResultShunt::new(iter);\n-        let value = f(shunt.by_ref());\n-        shunt.reconstruct(value)\n-    }\n-\n-    fn new(iter: I) -> Self {\n-        ResultShunt {\n-            iter,\n-            error: None,\n-        }\n-    }\n-\n-    /// Consume the adapter and rebuild a `Result` value. This should\n-    /// *always* be called, otherwise any potential error would be\n-    /// lost.\n-    fn reconstruct<U>(self, val: U) -> Result<U, E> {\n-        match self.error {\n-            None => Ok(val),\n-            Some(e) => Err(e),\n-        }\n-    }\n+    let mut error = Ok(());\n+    let shunt = ResultShunt {\n+        iter,\n+        error: &mut error,\n+    };\n+    let value = f(shunt);\n+    error.map(|()| value)\n }\n \n-impl<I, T, E> Iterator for ResultShunt<I, E>\n+impl<I, T, E> Iterator for ResultShunt<'_, I, E>\n     where I: Iterator<Item = Result<T, E>>\n {\n     type Item = T;\n \n     fn next(&mut self) -> Option<Self::Item> {\n-        match self.iter.next() {\n-            Some(Ok(v)) => Some(v),\n-            Some(Err(e)) => {\n-                self.error = Some(e);\n-                None\n-            }\n-            None => None,\n-        }\n+        self.find(|_| true)\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        if self.error.is_some() {\n+        if self.error.is_err() {\n             (0, Some(0))\n         } else {\n             let (_, upper) = self.iter.size_hint();\n             (0, upper)\n         }\n     }\n+\n+    fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R\n+    where\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Ok = B>,\n+    {\n+        let error = &mut *self.error;\n+        self.iter\n+            .try_fold(init, |acc, x| match x {\n+                Ok(x) => LoopState::from_try(f(acc, x)),\n+                Err(e) => {\n+                    *error = Err(e);\n+                    LoopState::Break(Try::from_ok(acc))\n+                }\n+            })\n+            .into_try()\n+    }\n }"}, {"sha": "aba8e84d58be553566165846b39eb2990f2da84b", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/188ab5c976a5696ac710b7ba78849ef5dcf0235a/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/188ab5c976a5696ac710b7ba78849ef5dcf0235a/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=188ab5c976a5696ac710b7ba78849ef5dcf0235a", "patch": "@@ -360,7 +360,7 @@ pub use self::adapters::Flatten;\n #[stable(feature = \"iter_copied\", since = \"1.36.0\")]\n pub use self::adapters::Copied;\n \n-pub(crate) use self::adapters::{TrustedRandomAccess, OptionShunt, ResultShunt};\n+pub(crate) use self::adapters::{TrustedRandomAccess, process_results};\n \n mod range;\n mod sources;"}, {"sha": "812463e77f9767476c4ae42b474db34a8e88b339", "filename": "src/libcore/iter/traits/accum.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/188ab5c976a5696ac710b7ba78849ef5dcf0235a/src%2Flibcore%2Fiter%2Ftraits%2Faccum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/188ab5c976a5696ac710b7ba78849ef5dcf0235a/src%2Flibcore%2Fiter%2Ftraits%2Faccum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Faccum.rs?ref=188ab5c976a5696ac710b7ba78849ef5dcf0235a", "patch": "@@ -1,6 +1,6 @@\n use crate::ops::{Mul, Add};\n use crate::num::Wrapping;\n-use crate::iter::adapters::{OptionShunt, ResultShunt};\n+use crate::iter;\n \n /// Trait to represent types that can be created by summing up an iterator.\n ///\n@@ -139,7 +139,7 @@ impl<T, U, E> Sum<Result<U, E>> for Result<T, E>\n     fn sum<I>(iter: I) -> Result<T, E>\n         where I: Iterator<Item = Result<U, E>>,\n     {\n-        ResultShunt::process(iter, |i| i.sum())\n+        iter::process_results(iter, |i| i.sum())\n     }\n }\n \n@@ -153,7 +153,7 @@ impl<T, U, E> Product<Result<U, E>> for Result<T, E>\n     fn product<I>(iter: I) -> Result<T, E>\n         where I: Iterator<Item = Result<U, E>>,\n     {\n-        ResultShunt::process(iter, |i| i.product())\n+        iter::process_results(iter, |i| i.product())\n     }\n }\n \n@@ -180,7 +180,7 @@ where\n     where\n         I: Iterator<Item = Option<U>>,\n     {\n-        OptionShunt::process(iter, |i| i.sum())\n+        iter.map(|x| x.ok_or(())).sum::<Result<_, _>>().ok()\n     }\n }\n \n@@ -196,6 +196,6 @@ where\n     where\n         I: Iterator<Item = Option<U>>,\n     {\n-        OptionShunt::process(iter, |i| i.product())\n+        iter.map(|x| x.ok_or(())).product::<Result<_, _>>().ok()\n     }\n }"}, {"sha": "ff063759cba627a8d717899e9b35d7b6a347294e", "filename": "src/libcore/mem/maybe_uninit.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/188ab5c976a5696ac710b7ba78849ef5dcf0235a/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/188ab5c976a5696ac710b7ba78849ef5dcf0235a/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs?ref=188ab5c976a5696ac710b7ba78849ef5dcf0235a", "patch": "@@ -51,7 +51,8 @@ use crate::mem::ManuallyDrop;\n ///\n /// On top of that, remember that most types have additional invariants beyond merely\n /// being considered initialized at the type level. For example, a `1`-initialized [`Vec<T>`]\n-/// is considered initialized because the only requirement the compiler knows about it\n+/// is considered initialized (under the current implementation; this does not constitute\n+/// a stable guarantee) because the only requirement the compiler knows about it\n /// is that the data pointer must be non-null. Creating such a `Vec<T>` does not cause\n /// *immediate* undefined behavior, but will cause undefined behavior with most\n /// safe operations (including dropping it).\n@@ -402,6 +403,14 @@ impl<T> MaybeUninit<T> {\n     ///\n     /// [inv]: #initialization-invariant\n     ///\n+    /// On top of that, remember that most types have additional invariants beyond merely\n+    /// being considered initialized at the type level. For example, a `1`-initialized [`Vec<T>`]\n+    /// is considered initialized (under the current implementation; this does not constitute\n+    /// a stable guarantee) because the only requirement the compiler knows about it\n+    /// is that the data pointer must be non-null. Creating such a `Vec<T>` does not cause\n+    /// *immediate* undefined behavior, but will cause undefined behavior with most\n+    /// safe operations (including dropping it).\n+    ///\n     /// # Examples\n     ///\n     /// Correct usage of this method:"}, {"sha": "259ed36c5788530d05333c8158a7ff884fc28e31", "filename": "src/libcore/option.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/188ab5c976a5696ac710b7ba78849ef5dcf0235a/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/188ab5c976a5696ac710b7ba78849ef5dcf0235a/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=188ab5c976a5696ac710b7ba78849ef5dcf0235a", "patch": "@@ -135,7 +135,7 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use crate::iter::{FromIterator, FusedIterator, TrustedLen, OptionShunt};\n+use crate::iter::{FromIterator, FusedIterator, TrustedLen};\n use crate::{convert, fmt, hint, mem, ops::{self, Deref, DerefMut}};\n use crate::pin::Pin;\n \n@@ -1499,7 +1499,10 @@ impl<A, V: FromIterator<A>> FromIterator<Option<A>> for Option<V> {\n         // FIXME(#11084): This could be replaced with Iterator::scan when this\n         // performance bug is closed.\n \n-        OptionShunt::process(iter.into_iter(), |i| i.collect())\n+        iter.into_iter()\n+            .map(|x| x.ok_or(()))\n+            .collect::<Result<_, _>>()\n+            .ok()\n     }\n }\n "}, {"sha": "8c60a9c1b501d0497aec7faea4154e086f89c16e", "filename": "src/libcore/result.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/188ab5c976a5696ac710b7ba78849ef5dcf0235a/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/188ab5c976a5696ac710b7ba78849ef5dcf0235a/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=188ab5c976a5696ac710b7ba78849ef5dcf0235a", "patch": "@@ -231,7 +231,7 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use crate::fmt;\n-use crate::iter::{FromIterator, FusedIterator, TrustedLen, ResultShunt};\n+use crate::iter::{self, FromIterator, FusedIterator, TrustedLen};\n use crate::ops::{self, Deref, DerefMut};\n \n /// `Result` is a type that represents either success ([`Ok`]) or failure ([`Err`]).\n@@ -1343,7 +1343,7 @@ impl<A, E, V: FromIterator<A>> FromIterator<Result<A, E>> for Result<V, E> {\n         // FIXME(#11084): This could be replaced with Iterator::scan when this\n         // performance bug is closed.\n \n-        ResultShunt::process(iter.into_iter(), |i| i.collect())\n+        iter::process_results(iter.into_iter(), |i| i.collect())\n     }\n }\n "}, {"sha": "3615fab791505553843ca616dc8b7e339b08dd7a", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/188ab5c976a5696ac710b7ba78849ef5dcf0235a/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/188ab5c976a5696ac710b7ba78849ef5dcf0235a/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=188ab5c976a5696ac710b7ba78849ef5dcf0235a", "patch": "@@ -1203,6 +1203,23 @@ fn test_iterator_sum_result() {\n     assert_eq!(v.iter().cloned().sum::<Result<i32, _>>(), Ok(10));\n     let v: &[Result<i32, ()>] = &[Ok(1), Err(()), Ok(3), Ok(4)];\n     assert_eq!(v.iter().cloned().sum::<Result<i32, _>>(), Err(()));\n+\n+    #[derive(PartialEq, Debug)]\n+    struct S(Result<i32, ()>);\n+\n+    impl Sum<Result<i32, ()>> for S {\n+        fn sum<I: Iterator<Item = Result<i32, ()>>>(mut iter: I) -> Self {\n+            // takes the sum by repeatedly calling `next` on `iter`,\n+            // thus testing that repeated calls to `ResultShunt::try_fold`\n+            // produce the expected results\n+            Self(iter.by_ref().sum())\n+        }\n+    }\n+\n+    let v: &[Result<i32, ()>] = &[Ok(1), Ok(2), Ok(3), Ok(4)];\n+    assert_eq!(v.iter().cloned().sum::<S>(), S(Ok(10)));\n+    let v: &[Result<i32, ()>] = &[Ok(1), Err(()), Ok(3), Ok(4)];\n+    assert_eq!(v.iter().cloned().sum::<S>(), S(Err(())));\n }\n \n #[test]"}, {"sha": "5e1b0eafdec3672fc842f1bb7334cd5ec03c3e43", "filename": "src/librustc_codegen_llvm/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/188ab5c976a5696ac710b7ba78849ef5dcf0235a/src%2Flibrustc_codegen_llvm%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/188ab5c976a5696ac710b7ba78849ef5dcf0235a/src%2Flibrustc_codegen_llvm%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2FCargo.toml?ref=188ab5c976a5696ac710b7ba78849ef5dcf0235a", "patch": "@@ -14,7 +14,6 @@ test = false\n cc = \"1.0.1\" # Used to locate MSVC\n num_cpus = \"1.0\"\n tempfile = \"3.0\"\n-rustc-demangle = \"0.1.15\"\n rustc_llvm = { path = \"../librustc_llvm\" }\n memmap = \"0.6\"\n "}, {"sha": "653dd8868f47965200c1553e3e2c92a9cc24bac1", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/188ab5c976a5696ac710b7ba78849ef5dcf0235a/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/188ab5c976a5696ac710b7ba78849ef5dcf0235a/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=188ab5c976a5696ac710b7ba78849ef5dcf0235a", "patch": "@@ -25,6 +25,7 @@\n use back::write::{create_target_machine, create_informational_target_machine};\n use syntax_pos::symbol::Symbol;\n \n+extern crate rustc_demangle;\n extern crate flate2;\n #[macro_use] extern crate bitflags;\n extern crate libc;"}, {"sha": "2c56f5fb4523a9ca2a06d89fdfb4706947cb8c70", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 17, "deletions": 24, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/188ab5c976a5696ac710b7ba78849ef5dcf0235a/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/188ab5c976a5696ac710b7ba78849ef5dcf0235a/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=188ab5c976a5696ac710b7ba78849ef5dcf0235a", "patch": "@@ -1771,8 +1771,13 @@ impl<'a> hir::lowering::Resolver for Resolver<'a> {\n         path: &ast::Path,\n         is_value: bool,\n     ) -> Res {\n-        self.resolve_ast_path_cb(path, is_value,\n-                                 |resolver, span, error| resolve_error(resolver, span, error))\n+        match self.resolve_ast_path_inner(path, is_value) {\n+            Ok(r) => r,\n+            Err((span, error)) => {\n+                resolve_error(self, span, error);\n+                Res::Err\n+            }\n+        }\n     }\n \n     fn resolve_str_path(\n@@ -1833,8 +1838,6 @@ impl<'a> Resolver<'a> {\n     /// just that an error occurred.\n     pub fn resolve_str_path_error(&mut self, span: Span, path_str: &str, is_value: bool)\n         -> Result<(ast::Path, Res), ()> {\n-        let mut errored = false;\n-\n         let path = if path_str.starts_with(\"::\") {\n             ast::Path {\n                 span,\n@@ -1855,48 +1858,38 @@ impl<'a> Resolver<'a> {\n                     .collect(),\n             }\n         };\n-        let res = self.resolve_ast_path_cb(&path, is_value, |_, _, _| errored = true);\n-        if errored || res == def::Res::Err {\n-            Err(())\n-        } else {\n-            Ok((path, res))\n-        }\n+        let res = self.resolve_ast_path_inner(&path, is_value).map_err(|_| ())?;\n+        Ok((path, res))\n     }\n \n     /// Like `resolve_ast_path`, but takes a callback in case there was an error.\n-    // FIXME(eddyb) use `Result` or something instead of callbacks.\n-    fn resolve_ast_path_cb<F>(\n+    fn resolve_ast_path_inner(\n         &mut self,\n         path: &ast::Path,\n         is_value: bool,\n-        error_callback: F,\n-    ) -> Res\n-        where F: for<'c, 'b> FnOnce(&'c mut Resolver<'_>, Span, ResolutionError<'b>)\n-    {\n+    ) -> Result<Res, (Span, ResolutionError<'a>)> {\n         let namespace = if is_value { ValueNS } else { TypeNS };\n         let span = path.span;\n         let path = Segment::from_path(&path);\n         // FIXME(Manishearth): intra-doc links won't get warned of epoch changes.\n         match self.resolve_path_without_parent_scope(&path, Some(namespace), true,\n                                                                span, CrateLint::No) {\n             PathResult::Module(ModuleOrUniformRoot::Module(module)) =>\n-                module.res().unwrap(),\n+                Ok(module.res().unwrap()),\n             PathResult::NonModule(path_res) if path_res.unresolved_segments() == 0 =>\n-                path_res.base_res(),\n+                Ok(path_res.base_res()),\n             PathResult::NonModule(..) => {\n-                error_callback(self, span, ResolutionError::FailedToResolve {\n+                Err((span, ResolutionError::FailedToResolve {\n                     label: String::from(\"type-relative paths are not supported in this context\"),\n                     suggestion: None,\n-                });\n-                Res::Err\n+                }))\n             }\n             PathResult::Module(..) | PathResult::Indeterminate => unreachable!(),\n             PathResult::Failed { span, label, suggestion, .. } => {\n-                error_callback(self, span, ResolutionError::FailedToResolve {\n+                Err((span, ResolutionError::FailedToResolve {\n                     label,\n                     suggestion,\n-                });\n-                Res::Err\n+                }))\n             }\n         }\n     }"}, {"sha": "b1cee0182052b88a620d32b45a633c9ebcdfde24", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/188ab5c976a5696ac710b7ba78849ef5dcf0235a/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/188ab5c976a5696ac710b7ba78849ef5dcf0235a/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=188ab5c976a5696ac710b7ba78849ef5dcf0235a", "patch": "@@ -877,15 +877,23 @@ fn write_shared(\n r#\"var themes = document.getElementById(\"theme-choices\");\n var themePicker = document.getElementById(\"theme-picker\");\n \n+function showThemeButtonState() {{\n+    themes.style.display = \"none\";\n+    themePicker.style.borderBottomRightRadius = \"3px\";\n+    themePicker.style.borderBottomLeftRadius = \"3px\";\n+}}\n+\n+function hideThemeButtonState() {{\n+    themes.style.display = \"block\";\n+    themePicker.style.borderBottomRightRadius = \"0\";\n+    themePicker.style.borderBottomLeftRadius = \"0\";\n+}}\n+\n function switchThemeButtonState() {{\n     if (themes.style.display === \"block\") {{\n-        themes.style.display = \"none\";\n-        themePicker.style.borderBottomRightRadius = \"3px\";\n-        themePicker.style.borderBottomLeftRadius = \"3px\";\n+        showThemeButtonState();\n     }} else {{\n-        themes.style.display = \"block\";\n-        themePicker.style.borderBottomRightRadius = \"0\";\n-        themePicker.style.borderBottomLeftRadius = \"0\";\n+        hideThemeButtonState();\n     }}\n }};\n \n@@ -898,7 +906,7 @@ function handleThemeButtonsBlur(e) {{\n         (!related ||\n          (related.id !== \"themePicker\" &&\n           (!related.parentNode || related.parentNode.id !== \"theme-choices\")))) {{\n-        switchThemeButtonState();\n+        hideThemeButtonState();\n     }}\n }}\n \n@@ -4579,12 +4587,13 @@ fn get_methods(\n     i: &clean::Impl,\n     for_deref: bool,\n     used_links: &mut FxHashSet<String>,\n+    deref_mut: bool,\n ) -> Vec<String> {\n     i.items.iter().filter_map(|item| {\n         match item.name {\n             // Maybe check with clean::Visibility::Public as well?\n             Some(ref name) if !name.is_empty() && item.visibility.is_some() && item.is_method() => {\n-                if !for_deref || should_render_item(item, false) {\n+                if !for_deref || should_render_item(item, deref_mut) {\n                     Some(format!(\"<a href=\\\"#{}\\\">{}</a>\",\n                                  get_next_url(used_links, format!(\"method.{}\", name)),\n                                  name))\n@@ -4625,7 +4634,7 @@ fn sidebar_assoc_items(it: &clean::Item) -> String {\n                            .filter(|i| i.inner_impl().trait_.is_none())\n                            .flat_map(move |i| get_methods(i.inner_impl(),\n                                                           false,\n-                                                          &mut used_links_bor.borrow_mut()))\n+                                                          &mut used_links_bor.borrow_mut(), false))\n                            .collect::<Vec<_>>();\n             // We want links' order to be reproducible so we don't use unstable sort.\n             ret.sort();\n@@ -4659,7 +4668,8 @@ fn sidebar_assoc_items(it: &clean::Item) -> String {\n                                            .filter(|i| i.inner_impl().trait_.is_none())\n                                            .flat_map(|i| get_methods(i.inner_impl(),\n                                                                      true,\n-                                                                     &mut used_links))\n+                                                                     &mut used_links,\n+                                                                     true))\n                                            .collect::<Vec<_>>();\n                         // We want links' order to be reproducible so we don't use unstable sort.\n                         ret.sort();"}, {"sha": "84cfdd790b733e8477b7b7eb7da3da6bc48f9ee7", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/188ab5c976a5696ac710b7ba78849ef5dcf0235a/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/188ab5c976a5696ac710b7ba78849ef5dcf0235a/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=188ab5c976a5696ac710b7ba78849ef5dcf0235a", "patch": "@@ -71,6 +71,10 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     resolver.resolve_str_path_error(DUMMY_SP, &path_str, ns == ValueNS)\n                 })\n             });\n+            let result = match result {\n+                Ok((_, Res::Err)) => Err(()),\n+                _ => result,\n+            };\n \n             if let Ok((_, res)) = result {\n                 let res = res.map_id(|_| panic!(\"unexpected node_id\"));\n@@ -134,6 +138,9 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             let (_, ty_res) = cx.enter_resolver(|resolver| resolver.with_scope(node_id, |resolver| {\n                     resolver.resolve_str_path_error(DUMMY_SP, &path, false)\n             }))?;\n+            if let Res::Err = ty_res {\n+                return Err(());\n+            }\n             let ty_res = ty_res.map_id(|_| panic!(\"unexpected node_id\"));\n             match ty_res {\n                 Res::Def(DefKind::Struct, did)"}, {"sha": "0e27fc90b69a6cc69d87ddfeca7413a37e86efb3", "filename": "src/test/rustdoc/deref-mut-methods.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/188ab5c976a5696ac710b7ba78849ef5dcf0235a/src%2Ftest%2Frustdoc%2Fderef-mut-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/188ab5c976a5696ac710b7ba78849ef5dcf0235a/src%2Ftest%2Frustdoc%2Fderef-mut-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fderef-mut-methods.rs?ref=188ab5c976a5696ac710b7ba78849ef5dcf0235a", "patch": "@@ -0,0 +1,29 @@\n+#![crate_name = \"foo\"]\n+\n+use std::ops;\n+\n+pub struct Foo;\n+\n+impl Foo {\n+    pub fn foo(&mut self) {}\n+}\n+\n+// @has foo/struct.Bar.html\n+// @has - '//div[@class=\"sidebar-links\"]/a[@href=\"#method.foo\"]' 'foo'\n+pub struct Bar {\n+    foo: Foo,\n+}\n+\n+impl ops::Deref for Bar {\n+    type Target = Foo;\n+\n+    fn deref(&self) -> &Foo {\n+        &self.foo\n+    }\n+}\n+\n+impl ops::DerefMut for Bar {\n+    fn deref_mut(&mut self) -> &mut Foo {\n+        &mut self.foo\n+    }\n+}"}]}