{"sha": "3a11ddb1b2a0807e1c3dc9a9a6afc1d578286bae", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhMTFkZGIxYjJhMDgwN2UxYzNkYzlhOWE2YWZjMWQ1NzgyODZiYWU=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-05-19T08:51:14Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-05-19T08:51:14Z"}, "message": "Correct tuple Ord impl, add Total{Eq,Ord} impls and add some tests.", "tree": {"sha": "0f09ad7b86d7560104b32d8bae55686044a22240", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f09ad7b86d7560104b32d8bae55686044a22240"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3a11ddb1b2a0807e1c3dc9a9a6afc1d578286bae", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3a11ddb1b2a0807e1c3dc9a9a6afc1d578286bae", "html_url": "https://github.com/rust-lang/rust/commit/3a11ddb1b2a0807e1c3dc9a9a6afc1d578286bae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3a11ddb1b2a0807e1c3dc9a9a6afc1d578286bae/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7103c39dbb32f5bc1452f8abaa3de5d68b47053b", "url": "https://api.github.com/repos/rust-lang/rust/commits/7103c39dbb32f5bc1452f8abaa3de5d68b47053b", "html_url": "https://github.com/rust-lang/rust/commit/7103c39dbb32f5bc1452f8abaa3de5d68b47053b"}], "stats": {"total": 106, "additions": 87, "deletions": 19}, "files": [{"sha": "639df89a3776f8532dfeb16a217d7ac1951eec27", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 87, "deletions": 19, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/3a11ddb1b2a0807e1c3dc9a9a6afc1d578286bae/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a11ddb1b2a0807e1c3dc9a9a6afc1d578286bae/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=3a11ddb1b2a0807e1c3dc9a9a6afc1d578286bae", "patch": "@@ -114,17 +114,17 @@ impl<A:Copy,B:Copy> ExtendedTupleOps<A,B> for (~[A], ~[B]) {\n \n // macro for implementing n-ary tuple functions and operations\n \n-macro_rules! tuple_impls(\n+macro_rules! tuple_impls {\n     ($(\n         ($cloneable_trait:ident, $immutable_trait:ident) {\n             $(($get_fn:ident, $get_ref_fn:ident) -> $T:ident {\n                 $get_pattern:pat => $ret:expr\n             })+\n         }\n-    )+) => (\n+    )+) => {\n         pub mod inner {\n             use clone::Clone;\n-            #[cfg(not(test))] use cmp::{Eq, Ord};\n+            #[cfg(not(test))] use cmp::*;\n \n             $(\n                 pub trait $cloneable_trait<$($T),+> {\n@@ -171,11 +171,19 @@ macro_rules! tuple_impls(\n                     }\n                 }\n \n+                #[cfg(not(test))]\n+                impl<$($T:TotalEq),+> TotalEq for ($($T),+) {\n+                    #[inline(always)]\n+                    fn equals(&self, other: &($($T),+)) -> bool {\n+                        $(self.$get_ref_fn().equals(other.$get_ref_fn()))&&+\n+                    }\n+                }\n+\n                 #[cfg(not(test))]\n                 impl<$($T:Ord),+> Ord for ($($T),+) {\n                     #[inline(always)]\n                     fn lt(&self, other: &($($T),+)) -> bool {\n-                        lexical_lt!($(*self.$get_ref_fn(), *other.$get_ref_fn()),+)\n+                        lexical_lt!($(self.$get_ref_fn(), other.$get_ref_fn()),+)\n                     }\n                     #[inline(always)]\n                     fn le(&self, other: &($($T),+)) -> bool { !(*other).lt(&(*self)) }\n@@ -184,22 +192,44 @@ macro_rules! tuple_impls(\n                     #[inline(always)]\n                     fn gt(&self, other: &($($T),+)) -> bool { (*other).lt(&(*self)) }\n                 }\n+\n+                #[cfg(not(test))]\n+                impl<$($T:TotalOrd),+> TotalOrd for ($($T),+) {\n+                    #[inline]\n+                    fn cmp(&self, other: &($($T),+)) -> Ordering {\n+                        lexical_cmp!($(self.$get_ref_fn(), other.$get_ref_fn()),+)\n+                    }\n+                }\n             )+\n         }\n-    )\n-)\n-\n-// Constructs an expression that performs a lexical less-than ordering.\n-// The values are interleaved, so the macro invocation for\n-// `(a1, a2, a3) < (b1, b2, b3)` would be `lexical_lt!(a1, b1, a2, b2, a3, b3)`\n-macro_rules! lexical_lt(\n-    ($a:expr, $b:expr, $($rest_a:expr, $rest_b:expr),+) => (\n-        if $a < $b { true } else { lexical_lt!($($rest_a, $rest_b),+) }\n-    );\n-    ($a:expr, $b:expr) => ($a < $b);\n-)\n-\n-tuple_impls!(\n+    }\n+}\n+\n+// Constructs an expression that performs a lexical less-than\n+// ordering.  The values are interleaved, so the macro invocation for\n+// `(a1, a2, a3) < (b1, b2, b3)` would be `lexical_lt!(a1, b1, a2, b2,\n+// a3, b3)` (and similarly for `lexical_cmp`)\n+macro_rules! lexical_lt {\n+    ($a:expr, $b:expr, $($rest_a:expr, $rest_b:expr),+) => {\n+        if *$a < *$b { true }\n+        else if !(*$b < *$a) { lexical_lt!($($rest_a, $rest_b),+) }\n+        else { false }\n+    };\n+    ($a:expr, $b:expr) => { *$a < *$b };\n+}\n+\n+macro_rules! lexical_cmp {\n+    ($a:expr, $b:expr, $($rest_a:expr, $rest_b:expr),+) => {\n+        match ($a).cmp($b) {\n+            Equal => lexical_cmp!($($rest_a, $rest_b),+),\n+            ordering   => ordering\n+        }\n+    };\n+    ($a:expr, $b:expr) => { ($a).cmp($b) };\n+}\n+\n+\n+tuple_impls! {\n     (CloneableTuple2, ImmutableTuple2) {\n         (n0, n0_ref) -> A { (ref a,_) => a }\n         (n1, n1_ref) -> B { (_,ref b) => b }\n@@ -309,12 +339,13 @@ tuple_impls!(\n         (n10, n10_ref) -> K { (_,_,_,_,_,_,_,_,_,_,ref k,_) => k }\n         (n11, n11_ref) -> L { (_,_,_,_,_,_,_,_,_,_,_,ref l) => l }\n     }\n-)\n+}\n \n #[cfg(test)]\n mod tests {\n     use super::*;\n     use clone::Clone;\n+    use cmp::*;\n \n     #[test]\n     fn test_tuple_ref() {\n@@ -368,4 +399,41 @@ mod tests {\n         assert_eq!(t.n10_ref(), &10f32);\n         assert_eq!(t.n11_ref(), &11f64);\n     }\n+\n+    #[test]\n+    fn test_tuple_cmp() {\n+        let small = (1u, 2u, 3u), big = (3u, 2u, 1u);\n+\n+        // Eq\n+        assert_eq!(small, small);\n+        assert_eq!(big, big);\n+        assert!(small != big);\n+        assert!(big != small);\n+\n+        // Ord\n+        assert!(small < big);\n+        assert!(!(small < small));\n+        assert!(!(big < small));\n+        assert!(!(big < big));\n+\n+        assert!(small <= small);\n+        assert!(big <= big);\n+\n+        assert!(big > small);\n+        assert!(small >= small);\n+        assert!(big >= small);\n+        assert!(big >= big);\n+\n+        // TotalEq\n+        assert!(small.equals(&small));\n+        assert!(big.equals(&big));\n+        assert!(!small.equals(&big));\n+        assert!(!big.equals(&small));\n+\n+        // TotalOrd\n+        assert_eq!(small.cmp(&small), Equal);\n+        assert_eq!(big.cmp(&big), Equal);\n+        assert_eq!(small.cmp(&big), Less);\n+        assert_eq!(big.cmp(&small), Greater);\n+    }\n }"}]}