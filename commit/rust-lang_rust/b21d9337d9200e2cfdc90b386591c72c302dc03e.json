{"sha": "b21d9337d9200e2cfdc90b386591c72c302dc03e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyMWQ5MzM3ZDkyMDBlMmNmZGM5MGIzODY1OTFjNzJjMzAyZGMwM2U=", "commit": {"author": {"name": "Seivan Heidari", "email": "seivan.heidari@icloud.com", "date": "2019-12-23T14:35:31Z"}, "committer": {"name": "Seivan Heidari", "email": "seivan.heidari@icloud.com", "date": "2019-12-23T14:35:31Z"}, "message": "Merge branch 'master' into feature/themes", "tree": {"sha": "f81f5c08f821115cee26fa4d3ceaae88c7807fd5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f81f5c08f821115cee26fa4d3ceaae88c7807fd5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b21d9337d9200e2cfdc90b386591c72c302dc03e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b21d9337d9200e2cfdc90b386591c72c302dc03e", "html_url": "https://github.com/rust-lang/rust/commit/b21d9337d9200e2cfdc90b386591c72c302dc03e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b21d9337d9200e2cfdc90b386591c72c302dc03e/comments", "author": {"login": "seivan", "id": 55424, "node_id": "MDQ6VXNlcjU1NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/55424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/seivan", "html_url": "https://github.com/seivan", "followers_url": "https://api.github.com/users/seivan/followers", "following_url": "https://api.github.com/users/seivan/following{/other_user}", "gists_url": "https://api.github.com/users/seivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/seivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/seivan/subscriptions", "organizations_url": "https://api.github.com/users/seivan/orgs", "repos_url": "https://api.github.com/users/seivan/repos", "events_url": "https://api.github.com/users/seivan/events{/privacy}", "received_events_url": "https://api.github.com/users/seivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "seivan", "id": 55424, "node_id": "MDQ6VXNlcjU1NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/55424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/seivan", "html_url": "https://github.com/seivan", "followers_url": "https://api.github.com/users/seivan/followers", "following_url": "https://api.github.com/users/seivan/following{/other_user}", "gists_url": "https://api.github.com/users/seivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/seivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/seivan/subscriptions", "organizations_url": "https://api.github.com/users/seivan/orgs", "repos_url": "https://api.github.com/users/seivan/repos", "events_url": "https://api.github.com/users/seivan/events{/privacy}", "received_events_url": "https://api.github.com/users/seivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "html_url": "https://github.com/rust-lang/rust/commit/18a0937585b836ec5ed054b9ae48e0156ab6d9ef"}, {"sha": "ce07a2daa9e53aa86a769f8641b14c2878444fbc", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce07a2daa9e53aa86a769f8641b14c2878444fbc", "html_url": "https://github.com/rust-lang/rust/commit/ce07a2daa9e53aa86a769f8641b14c2878444fbc"}], "stats": {"total": 25645, "additions": 14882, "deletions": 10763}, "files": [{"sha": "cb397ae14ae5a5085eb000955c867477efd6a6ca", "filename": ".github/workflows/ci.yaml", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/.github%2Fworkflows%2Fci.yaml", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/.github%2Fworkflows%2Fci.yaml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yaml?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -14,6 +14,7 @@ jobs:\n     env:\n       RUSTFLAGS: -D warnings\n       CARGO_INCREMENTAL: 0\n+      RUN_SLOW_TESTS: 1\n     steps:\n \n       - name: Checkout repository\n@@ -46,9 +47,10 @@ jobs:\n \n       - name: Prepare build directory for cache\n         run: |\n-          find ./target/debug -maxdepth 1 -type f -delete && \\\n-          rm -fr ./target/debug/{deps,.fingerprint}/{*ra_*,*heavy_test*,*gen_lsp*,*thread_worker*} && \\\n-          rm -f  ./target/.rustc_info.json\n+          find ./target/debug -maxdepth 1 -type f -delete \\\n+          && rm -fr ./target/debug/{deps,.fingerprint}/{*ra_*,*heavy_test*,*gen_lsp*,*thread_worker*} \\\n+          && rm -f  ./target/.rustc_info.json \\\n+          && rm ./target/.slow_tests_cookie\n \n   type-script:\n     name: TypeScript"}, {"sha": "0cf3984a9a4330052ac88c57398142cefc67405d", "filename": ".vscode/launch.json", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/.vscode%2Flaunch.json", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/.vscode%2Flaunch.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.vscode%2Flaunch.json?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -16,7 +16,7 @@\n       \"env\": {\n         \"__RA_LSP_SERVER_DEBUG\": \"${workspaceFolder}/target/debug/ra_lsp_server\"\n       },\n-      \"outFiles\": [\"${workspaceFolder}/editors/code/out/**/*.js\"],\n+      \"outFiles\": [\"${workspaceFolder}/editors/code/bundle/**/*.js\"],\n       \"preLaunchTask\": \"Build All\"\n     },\n     {"}, {"sha": "e724c1a76b77fcb6456bcb45a62a63b8982d7f02", "filename": "Cargo.lock", "status": "modified", "additions": 158, "deletions": 203, "changes": 361, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -10,7 +10,12 @@ dependencies = [\n \n [[package]]\n name = \"anyhow\"\n-version = \"1.0.24\"\n+version = \"1.0.25\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"anymap\"\n+version = \"0.12.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -23,7 +28,7 @@ name = \"atty\"\n version = \"0.2.13\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.65 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.66 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -39,7 +44,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"backtrace-sys 0.1.32 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"cfg-if 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.65 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.66 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-demangle 0.1.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -48,8 +53,8 @@ name = \"backtrace-sys\"\n version = \"0.1.32\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"cc 1.0.47 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.65 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cc 1.0.48 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.66 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -101,18 +106,18 @@ dependencies = [\n \n [[package]]\n name = \"cargo_metadata\"\n-version = \"0.9.0\"\n+version = \"0.9.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"semver 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.103 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_derive 1.0.103 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_json 1.0.42 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.104 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.104 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_json 1.0.44 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"cc\"\n-version = \"1.0.47\"\n+version = \"1.0.48\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -123,87 +128,76 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n [[package]]\n name = \"chalk-derive\"\n version = \"0.1.0\"\n-source = \"git+https://github.com/jackh726/chalk.git?rev=095cd38a4f16337913bba487f2055b9ca0179f30#095cd38a4f16337913bba487f2055b9ca0179f30\"\n+source = \"git+https://github.com/rust-lang/chalk.git?rev=ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5#ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5\"\n dependencies = [\n  \"proc-macro2 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quote 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"syn 1.0.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syn 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"chalk-engine\"\n version = \"0.9.0\"\n-source = \"git+https://github.com/jackh726/chalk.git?rev=095cd38a4f16337913bba487f2055b9ca0179f30#095cd38a4f16337913bba487f2055b9ca0179f30\"\n+source = \"git+https://github.com/rust-lang/chalk.git?rev=ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5#ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5\"\n dependencies = [\n- \"chalk-macros 0.1.1 (git+https://github.com/jackh726/chalk.git?rev=095cd38a4f16337913bba487f2055b9ca0179f30)\",\n+ \"chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5)\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"stacker 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"chalk-ir\"\n version = \"0.1.0\"\n-source = \"git+https://github.com/jackh726/chalk.git?rev=095cd38a4f16337913bba487f2055b9ca0179f30#095cd38a4f16337913bba487f2055b9ca0179f30\"\n+source = \"git+https://github.com/rust-lang/chalk.git?rev=ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5#ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5\"\n dependencies = [\n- \"chalk-derive 0.1.0 (git+https://github.com/jackh726/chalk.git?rev=095cd38a4f16337913bba487f2055b9ca0179f30)\",\n- \"chalk-engine 0.9.0 (git+https://github.com/jackh726/chalk.git?rev=095cd38a4f16337913bba487f2055b9ca0179f30)\",\n- \"chalk-macros 0.1.1 (git+https://github.com/jackh726/chalk.git?rev=095cd38a4f16337913bba487f2055b9ca0179f30)\",\n+ \"chalk-derive 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5)\",\n+ \"chalk-engine 0.9.0 (git+https://github.com/rust-lang/chalk.git?rev=ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5)\",\n+ \"chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5)\",\n  \"lalrpop-intern 0.15.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"chalk-macros\"\n version = \"0.1.1\"\n-source = \"git+https://github.com/jackh726/chalk.git?rev=095cd38a4f16337913bba487f2055b9ca0179f30#095cd38a4f16337913bba487f2055b9ca0179f30\"\n+source = \"git+https://github.com/rust-lang/chalk.git?rev=ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5#ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5\"\n dependencies = [\n  \"lazy_static 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"chalk-rust-ir\"\n version = \"0.1.0\"\n-source = \"git+https://github.com/jackh726/chalk.git?rev=095cd38a4f16337913bba487f2055b9ca0179f30#095cd38a4f16337913bba487f2055b9ca0179f30\"\n+source = \"git+https://github.com/rust-lang/chalk.git?rev=ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5#ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5\"\n dependencies = [\n- \"chalk-derive 0.1.0 (git+https://github.com/jackh726/chalk.git?rev=095cd38a4f16337913bba487f2055b9ca0179f30)\",\n- \"chalk-engine 0.9.0 (git+https://github.com/jackh726/chalk.git?rev=095cd38a4f16337913bba487f2055b9ca0179f30)\",\n- \"chalk-ir 0.1.0 (git+https://github.com/jackh726/chalk.git?rev=095cd38a4f16337913bba487f2055b9ca0179f30)\",\n- \"chalk-macros 0.1.1 (git+https://github.com/jackh726/chalk.git?rev=095cd38a4f16337913bba487f2055b9ca0179f30)\",\n+ \"chalk-derive 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5)\",\n+ \"chalk-engine 0.9.0 (git+https://github.com/rust-lang/chalk.git?rev=ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5)\",\n+ \"chalk-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5)\",\n+ \"chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5)\",\n ]\n \n [[package]]\n name = \"chalk-solve\"\n version = \"0.1.0\"\n-source = \"git+https://github.com/jackh726/chalk.git?rev=095cd38a4f16337913bba487f2055b9ca0179f30#095cd38a4f16337913bba487f2055b9ca0179f30\"\n+source = \"git+https://github.com/rust-lang/chalk.git?rev=ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5#ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5\"\n dependencies = [\n- \"chalk-derive 0.1.0 (git+https://github.com/jackh726/chalk.git?rev=095cd38a4f16337913bba487f2055b9ca0179f30)\",\n- \"chalk-engine 0.9.0 (git+https://github.com/jackh726/chalk.git?rev=095cd38a4f16337913bba487f2055b9ca0179f30)\",\n- \"chalk-ir 0.1.0 (git+https://github.com/jackh726/chalk.git?rev=095cd38a4f16337913bba487f2055b9ca0179f30)\",\n- \"chalk-macros 0.1.1 (git+https://github.com/jackh726/chalk.git?rev=095cd38a4f16337913bba487f2055b9ca0179f30)\",\n- \"chalk-rust-ir 0.1.0 (git+https://github.com/jackh726/chalk.git?rev=095cd38a4f16337913bba487f2055b9ca0179f30)\",\n+ \"chalk-derive 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5)\",\n+ \"chalk-engine 0.9.0 (git+https://github.com/rust-lang/chalk.git?rev=ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5)\",\n+ \"chalk-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5)\",\n+ \"chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5)\",\n+ \"chalk-rust-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5)\",\n  \"ena 0.13.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"itertools 0.8.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"petgraph 0.4.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n-[[package]]\n-name = \"chrono\"\n-version = \"0.4.10\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"num-integer 0.1.41 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"num-traits 0.2.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"time 0.1.42 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n [[package]]\n name = \"clicolors-control\"\n version = \"1.0.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"atty 0.2.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.65 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.66 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -223,7 +217,7 @@ dependencies = [\n  \"clicolors-control 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"encode_unicode 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.65 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.66 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex 1.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"termios 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -323,13 +317,22 @@ name = \"encode_unicode\"\n version = \"0.3.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"env_logger\"\n+version = \"0.7.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"humantime 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"filetime\"\n version = \"0.2.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"cfg-if 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.65 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.66 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"redox_syscall 0.1.56 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -339,18 +342,6 @@ name = \"fixedbitset\"\n version = \"0.1.9\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n-[[package]]\n-name = \"flexi_logger\"\n-version = \"0.14.5\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"chrono 0.4.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"glob 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex 1.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"yansi 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n [[package]]\n name = \"fnv\"\n version = \"1.0.6\"\n@@ -380,7 +371,7 @@ name = \"fsevent-sys\"\n version = \"2.0.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.65 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.66 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -416,15 +407,10 @@ version = \"0.1.13\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"cfg-if 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.65 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.66 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"wasi 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n-[[package]]\n-name = \"glob\"\n-version = \"0.3.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n [[package]]\n name = \"globset\"\n version = \"0.4.4\"\n@@ -447,10 +433,18 @@ dependencies = [\n \n [[package]]\n name = \"hermit-abi\"\n-version = \"0.1.3\"\n+version = \"0.1.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.65 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.66 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"humantime\"\n+version = \"1.3.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"quick-error 1.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -478,15 +472,15 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"bitflags 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"inotify-sys 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.65 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.66 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"inotify-sys\"\n version = \"0.1.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.65 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.66 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -497,8 +491,8 @@ dependencies = [\n  \"console 0.9.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"difference 2.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.103 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_json 1.0.42 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.104 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_json 1.0.44 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_yaml 0.8.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"uuid 0.8.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -508,7 +502,7 @@ name = \"iovec\"\n version = \"0.1.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.65 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.66 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -530,7 +524,7 @@ version = \"0.3.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"jemalloc-sys 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.65 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.66 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"paste 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -539,9 +533,9 @@ name = \"jemalloc-sys\"\n version = \"0.3.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"cc 1.0.47 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cc 1.0.48 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"fs_extra 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.65 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.66 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -550,7 +544,7 @@ version = \"0.3.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"jemalloc-sys 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.65 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.66 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -589,7 +583,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.65\"\n+version = \"0.2.66\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -620,18 +614,18 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"crossbeam-channel 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.103 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_json 1.0.42 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.104 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_json 1.0.44 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"lsp-types\"\n-version = \"0.61.0\"\n+version = \"0.66.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"bitflags 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.103 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_json 1.0.42 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.104 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_json 1.0.44 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_repr 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"url 2.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -664,7 +658,7 @@ dependencies = [\n  \"fuchsia-zircon-sys 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"iovec 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.65 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.66 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"miow 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"net2 0.2.33 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -674,7 +668,7 @@ dependencies = [\n \n [[package]]\n name = \"mio-extras\"\n-version = \"2.0.5\"\n+version = \"2.0.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"lazycell 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -700,7 +694,7 @@ version = \"0.2.33\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"cfg-if 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.65 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.66 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -715,22 +709,13 @@ dependencies = [\n  \"fsevent-sys 2.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"inotify 0.6.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.65 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.66 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"mio 0.6.21 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"mio-extras 2.0.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"mio-extras 2.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"walkdir 2.2.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n-[[package]]\n-name = \"num-integer\"\n-version = \"0.1.41\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"autocfg 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"num-traits 0.2.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n [[package]]\n name = \"num-traits\"\n version = \"0.2.10\"\n@@ -744,8 +729,8 @@ name = \"num_cpus\"\n version = \"1.11.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"hermit-abi 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.65 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"hermit-abi 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.66 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -774,9 +759,9 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"cfg-if 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"cloudabi 0.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.65 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.66 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"redox_syscall 0.1.56 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"smallvec 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"smallvec 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -797,7 +782,7 @@ dependencies = [\n  \"proc-macro-hack 0.5.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"proc-macro2 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quote 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"syn 1.0.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syn 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -831,7 +816,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"proc-macro2 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quote 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"syn 1.0.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syn 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -859,14 +844,6 @@ dependencies = [\n  \"regex-syntax 0.6.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n-[[package]]\n-name = \"psm\"\n-version = \"0.1.6\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"cc 1.0.47 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n [[package]]\n name = \"quick-error\"\n version = \"1.2.2\"\n@@ -928,11 +905,13 @@ dependencies = [\n name = \"ra_cli\"\n version = \"0.1.0\"\n dependencies = [\n- \"flexi_logger 0.14.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"env_logger 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pico-args 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_batch 0.1.0\",\n  \"ra_db 0.1.0\",\n  \"ra_hir 0.1.0\",\n+ \"ra_hir_def 0.1.0\",\n+ \"ra_hir_ty 0.1.0\",\n  \"ra_ide 0.1.0\",\n  \"ra_prof 0.1.0\",\n  \"ra_syntax 0.1.0\",\n@@ -963,11 +942,13 @@ dependencies = [\n name = \"ra_hir\"\n version = \"0.1.0\"\n dependencies = [\n+ \"either 1.5.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_db 0.1.0\",\n  \"ra_hir_def 0.1.0\",\n  \"ra_hir_expand 0.1.0\",\n  \"ra_hir_ty 0.1.0\",\n+ \"ra_prof 0.1.0\",\n  \"ra_syntax 0.1.0\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -976,6 +957,9 @@ dependencies = [\n name = \"ra_hir_def\"\n version = \"0.1.0\"\n dependencies = [\n+ \"anymap 0.12.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"drop_bomb 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"either 1.5.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"insta 0.12.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"once_cell 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -995,6 +979,7 @@ dependencies = [\n name = \"ra_hir_expand\"\n version = \"0.1.0\"\n dependencies = [\n+ \"either 1.5.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_arena 0.1.0\",\n  \"ra_db 0.1.0\",\n@@ -1010,9 +995,9 @@ name = \"ra_hir_ty\"\n version = \"0.1.0\"\n dependencies = [\n  \"arrayvec 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"chalk-ir 0.1.0 (git+https://github.com/jackh726/chalk.git?rev=095cd38a4f16337913bba487f2055b9ca0179f30)\",\n- \"chalk-rust-ir 0.1.0 (git+https://github.com/jackh726/chalk.git?rev=095cd38a4f16337913bba487f2055b9ca0179f30)\",\n- \"chalk-solve 0.1.0 (git+https://github.com/jackh726/chalk.git?rev=095cd38a4f16337913bba487f2055b9ca0179f30)\",\n+ \"chalk-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5)\",\n+ \"chalk-rust-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5)\",\n+ \"chalk-solve 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5)\",\n  \"ena 0.13.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"insta 0.12.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lalrpop-intern 0.15.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1031,6 +1016,7 @@ dependencies = [\n name = \"ra_ide\"\n version = \"0.1.0\"\n dependencies = [\n+ \"either 1.5.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"format-buf 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"fst 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"insta 0.12.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1060,11 +1046,11 @@ name = \"ra_lsp_server\"\n version = \"0.1.0\"\n dependencies = [\n  \"crossbeam-channel 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"flexi_logger 0.14.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"env_logger 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"jod-thread 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lsp-server 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"lsp-types 0.61.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lsp-types 0.66.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_ide 0.1.0\",\n  \"ra_prof 0.1.0\",\n@@ -1075,8 +1061,8 @@ dependencies = [\n  \"ra_vfs_glob 0.1.0\",\n  \"relative-path 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.103 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_json 1.0.42 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.104 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_json 1.0.44 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"tempfile 3.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"test_utils 0.1.0\",\n  \"threadpool 1.7.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1091,7 +1077,7 @@ dependencies = [\n  \"ra_syntax 0.1.0\",\n  \"ra_tt 0.1.0\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"smallvec 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"smallvec 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"test_utils 0.1.0\",\n ]\n \n@@ -1117,14 +1103,14 @@ dependencies = [\n name = \"ra_project_model\"\n version = \"0.1.0\"\n dependencies = [\n- \"cargo_metadata 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cargo_metadata 0.9.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_arena 0.1.0\",\n  \"ra_cfg 0.1.0\",\n  \"ra_db 0.1.0\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.103 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_json 1.0.42 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.104 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_json 1.0.44 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1136,9 +1122,10 @@ dependencies = [\n  \"once_cell 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_parser 0.1.0\",\n  \"ra_text_edit 0.1.0\",\n- \"rowan 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rowan 0.8.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_lexer 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.104 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"smol_str 0.1.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"test_utils 0.1.0\",\n  \"walkdir 2.2.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1189,7 +1176,7 @@ version = \"0.6.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"autocfg 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.65 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.66 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rand_chacha 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rand_core 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rand_hc 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1207,7 +1194,7 @@ version = \"0.7.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"getrandom 0.1.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.65 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.66 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rand_chacha 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rand_core 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rand_hc 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1282,7 +1269,7 @@ name = \"rand_jitter\"\n version = \"0.1.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.65 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.66 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rand_core 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -1294,7 +1281,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"cloudabi 0.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"fuchsia-cprng 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.65 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.66 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rand_core 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rdrand 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1396,12 +1383,12 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"base64 0.10.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"bitflags 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.103 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.104 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"rowan\"\n-version = \"0.7.1\"\n+version = \"0.8.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1456,7 +1443,7 @@ dependencies = [\n  \"rand 0.7.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"salsa-macros 0.14.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"smallvec 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"smallvec 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1467,7 +1454,7 @@ dependencies = [\n  \"heck 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"proc-macro2 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quote 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"syn 1.0.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syn 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1489,7 +1476,7 @@ version = \"0.9.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"semver-parser 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.103 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.104 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1499,30 +1486,30 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"serde\"\n-version = \"1.0.103\"\n+version = \"1.0.104\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"serde_derive 1.0.103 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.104 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"serde_derive\"\n-version = \"1.0.103\"\n+version = \"1.0.104\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"proc-macro2 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quote 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"syn 1.0.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syn 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"serde_json\"\n-version = \"1.0.42\"\n+version = \"1.0.44\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"itoa 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ryu 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.103 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.104 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1532,7 +1519,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"proc-macro2 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quote 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"syn 1.0.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syn 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1542,7 +1529,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"dtoa 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"linked-hash-map 0.5.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.103 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.104 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"yaml-rust 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -1553,27 +1540,15 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"smallvec\"\n-version = \"1.0.0\"\n+version = \"1.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"smol_str\"\n version = \"0.1.15\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"serde 1.0.103 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"stacker\"\n-version = \"0.1.6\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"cc 1.0.47 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"cfg-if 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.65 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"psm 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"winapi 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.104 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1583,7 +1558,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"syn\"\n-version = \"1.0.8\"\n+version = \"1.0.11\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"proc-macro2 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1597,7 +1572,7 @@ version = \"3.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"cfg-if 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.65 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.66 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rand 0.7.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"redox_syscall 0.1.56 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"remove_dir_all 0.5.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1609,15 +1584,15 @@ name = \"termios\"\n version = \"0.3.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.65 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.66 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"test_utils\"\n version = \"0.1.0\"\n dependencies = [\n  \"difference 2.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_json 1.0.42 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_json 1.0.44 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"text_unit 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -1647,16 +1622,6 @@ dependencies = [\n  \"num_cpus 1.11.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n-[[package]]\n-name = \"time\"\n-version = \"0.1.42\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"libc 0.2.65 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"redox_syscall 0.1.56 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"winapi 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n [[package]]\n name = \"unicase\"\n version = \"2.6.0\"\n@@ -1678,7 +1643,7 @@ name = \"unicode-normalization\"\n version = \"0.1.11\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"smallvec 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"smallvec 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1699,7 +1664,7 @@ dependencies = [\n  \"idna 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"matches 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"percent-encoding 2.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.103 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.104 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1708,7 +1673,7 @@ version = \"0.8.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"rand 0.7.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.103 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.104 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1781,12 +1746,12 @@ dependencies = [\n name = \"xtask\"\n version = \"0.1.0\"\n dependencies = [\n- \"anyhow 1.0.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"anyhow 1.0.25 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pico-args 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"proc-macro2 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quote 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ron 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.103 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.104 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"walkdir 2.2.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -1798,14 +1763,10 @@ dependencies = [\n  \"linked-hash-map 0.5.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n-[[package]]\n-name = \"yansi\"\n-version = \"0.5.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n [metadata]\n \"checksum aho-corasick 0.7.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"58fb5e95d83b38284460a5fda7d6470aa0b8844d283a0b614b8535e880800d2d\"\n-\"checksum anyhow 1.0.24 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b412394828b7ca486b362f300b762d8e43dafd6f0d727b63f1cd2ade207c6cef\"\n+\"checksum anyhow 1.0.25 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9267dff192e68f3399525901e709a48c1d3982c9c072fa32f2127a0cb0babf14\"\n+\"checksum anymap 0.12.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"33954243bd79057c2de7338850b85983a44588021f8a5fee574a8888c6de4344\"\n \"checksum arrayvec 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cff77d8686867eceff3105329d4698d96c2391c176d5d03adc90c7389162b5b8\"\n \"checksum atty 0.2.13 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1803c647a3ec87095e7ae7acfca019e98de5ec9a7d01343f611cf3152ed71a90\"\n \"checksum autocfg 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1d49d90015b3c36167a20fe2810c5cd875ad504b39cff3d4eae7977e6b7c1cb2\"\n@@ -1818,16 +1779,15 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum bstr 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8d6c2c5b58ab920a4f5aeaaca34b4488074e8cc7596af94e6f8c6ff247c60245\"\n \"checksum byteorder 1.3.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a7c3dd8985a7111efc5c80b44e23ecdd8c007de8ade3b96595387e812b957cf5\"\n \"checksum c2-chacha 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"214238caa1bf3a496ec3392968969cab8549f96ff30652c9e56885329315f6bb\"\n-\"checksum cargo_metadata 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8d2d1617e838936c0d2323a65cc151e03ae19a7678dd24f72bccf27119b90a5d\"\n-\"checksum cc 1.0.47 (registry+https://github.com/rust-lang/crates.io-index)\" = \"aa87058dce70a3ff5621797f1506cb837edd02ac4c0ae642b4542dce802908b8\"\n+\"checksum cargo_metadata 0.9.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"46e3374c604fb39d1a2f35ed5e4a4e30e60d01fab49446e08f1b3e9a90aef202\"\n+\"checksum cc 1.0.48 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f52a465a666ca3d838ebbf08b241383421412fe7ebb463527bba275526d89f76\"\n \"checksum cfg-if 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4785bdd1c96b2a846b2bd7cc02e86b6b3dbf14e7e53446c4f54c92a361040822\"\n-\"checksum chalk-derive 0.1.0 (git+https://github.com/jackh726/chalk.git?rev=095cd38a4f16337913bba487f2055b9ca0179f30)\" = \"<none>\"\n-\"checksum chalk-engine 0.9.0 (git+https://github.com/jackh726/chalk.git?rev=095cd38a4f16337913bba487f2055b9ca0179f30)\" = \"<none>\"\n-\"checksum chalk-ir 0.1.0 (git+https://github.com/jackh726/chalk.git?rev=095cd38a4f16337913bba487f2055b9ca0179f30)\" = \"<none>\"\n-\"checksum chalk-macros 0.1.1 (git+https://github.com/jackh726/chalk.git?rev=095cd38a4f16337913bba487f2055b9ca0179f30)\" = \"<none>\"\n-\"checksum chalk-rust-ir 0.1.0 (git+https://github.com/jackh726/chalk.git?rev=095cd38a4f16337913bba487f2055b9ca0179f30)\" = \"<none>\"\n-\"checksum chalk-solve 0.1.0 (git+https://github.com/jackh726/chalk.git?rev=095cd38a4f16337913bba487f2055b9ca0179f30)\" = \"<none>\"\n-\"checksum chrono 0.4.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"31850b4a4d6bae316f7a09e691c944c28299298837edc0a03f755618c23cbc01\"\n+\"checksum chalk-derive 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5)\" = \"<none>\"\n+\"checksum chalk-engine 0.9.0 (git+https://github.com/rust-lang/chalk.git?rev=ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5)\" = \"<none>\"\n+\"checksum chalk-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5)\" = \"<none>\"\n+\"checksum chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5)\" = \"<none>\"\n+\"checksum chalk-rust-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5)\" = \"<none>\"\n+\"checksum chalk-solve 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5)\" = \"<none>\"\n \"checksum clicolors-control 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"90082ee5dcdd64dc4e9e0d37fbf3ee325419e39c0092191e0393df65518f741e\"\n \"checksum cloudabi 0.0.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ddfc5b9aa5d4507acaf872de71051dfd0e309860e88966e1051e462a077aac4f\"\n \"checksum console 0.9.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f5d540c2d34ac9dd0deb5f3b5f54c36c79efa78f6b3ad19106a554d07a7b5d9f\"\n@@ -1843,9 +1803,9 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum either 1.5.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bb1f6b1ce1c140482ea30ddd3335fc0024ac7ee112895426e0a629a6c20adfe3\"\n \"checksum ena 0.13.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8944dc8fa28ce4a38f778bd46bf7d923fe73eed5a439398507246c8e017e6f36\"\n \"checksum encode_unicode 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a357d28ed41a50f9c765dbfe56cbc04a64e53e5fc58ba79fbc34c10ef3df831f\"\n+\"checksum env_logger 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"44533bbbb3bb3c1fa17d9f2e4e38bbbaf8396ba82193c4cb1b6445d711445d36\"\n \"checksum filetime 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1ff6d4dab0aa0c8e6346d46052e93b13a16cf847b54ed357087c35011048cc7d\"\n \"checksum fixedbitset 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"86d4de0081402f5e88cdac65c8dcdcc73118c1a7a465e2a05f0da05843a8ea33\"\n-\"checksum flexi_logger 0.14.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a13ea6b8a4debecf47bf3966d56db0e21366bc3a3649ba159e1a9e6fdd36a4f4\"\n \"checksum fnv 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2fad85553e09a6f881f739c29f0b00b0f01357c743266d478b68951ce23285f3\"\n \"checksum format-buf 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f7aea5a5909a74969507051a3b17adc84737e31a5f910559892aedce026f4d53\"\n \"checksum fs_extra 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5f2a4a2034423744d2cc7ca2068453168dcdb82c438419e639a26bd87839c674\"\n@@ -1856,10 +1816,10 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum fuchsia-zircon 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2e9763c69ebaae630ba35f74888db465e49e259ba1bc0eda7d06f4a067615d82\"\n \"checksum fuchsia-zircon-sys 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3dcaa9ae7725d12cdb85b3ad99a434db70b468c09ded17e012d86b5c1010f7a7\"\n \"checksum getrandom 0.1.13 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e7db7ca94ed4cd01190ceee0d8a8052f08a247aa1b469a7f68c6a3b71afcf407\"\n-\"checksum glob 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9b919933a397b79c37e33b77bb2aa3dc8eb6e165ad809e58ff75bc7db2e34574\"\n \"checksum globset 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"925aa2cac82d8834e2b2a4415b6f6879757fb5c0928fc445ae76461a12eed8f2\"\n \"checksum heck 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"20564e78d53d2bb135c343b3f47714a56af2061f1c928fdb541dc7b9fdd94205\"\n-\"checksum hermit-abi 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"307c3c9f937f38e3534b1d6447ecf090cafcc9744e4a6360e8b037b2cf5af120\"\n+\"checksum hermit-abi 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f629dc602392d3ec14bfc8a09b5e644d7ffd725102b48b81e59f90f2633621d7\"\n+\"checksum humantime 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"df004cfca50ef23c36850aaaa59ad52cc70d0e90243c3c7737a4dd32dc7a3c4f\"\n \"checksum idna 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"02e2673c30ee86b5b96a9cb52ad15718aa1f966f5ab9ad54a8b95d5ca33120a9\"\n \"checksum indexmap 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"712d7b3ea5827fcb9d4fda14bf4da5f136f0db2ae9c8f4bd4e2d1c6fde4e6db2\"\n \"checksum inotify 0.6.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"40b54539f3910d6f84fbf9a643efd6e3aa6e4f001426c0329576128255994718\"\n@@ -1877,21 +1837,20 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum lalrpop-intern 0.15.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cc4fd87be4a815fd373e02773983940f0d75fb26fde8c098e9e45f7af03154c0\"\n \"checksum lazy_static 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e2abad23fbc42b3700f2f279844dc832adb2b2eb069b2df918f455c4e18cc646\"\n \"checksum lazycell 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b294d6fa9ee409a054354afc4352b0b9ef7ca222c69b8812cbea9e7d2bf3783f\"\n-\"checksum libc 0.2.65 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1a31a0627fdf1f6a39ec0dd577e101440b7db22672c0901fe00a9a6fbb5c24e8\"\n+\"checksum libc 0.2.66 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d515b1f41455adea1313a4a2ac8a8a477634fbae63cc6100e3aebb207ce61558\"\n \"checksum linked-hash-map 0.5.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ae91b68aebc4ddb91978b11a1b02ddd8602a05ec19002801c5666000e05e0f83\"\n \"checksum lock_api 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e57b3997725d2b60dbec1297f6c2e2957cc383db1cebd6be812163f969c7d586\"\n \"checksum log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"14b6052be84e6b71ab17edffc2eeabf5c2c3ae1fdb464aae35ac50c67a44e1f7\"\n \"checksum lsp-server 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0ba36405bd742139ab79c246ca5adb7fde2fe1a0f495e2c8e2f607b607dedb12\"\n-\"checksum lsp-types 0.61.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"fa3268fbe8beb2795c2fb327bf44f4f3d24f5fe9ebc18d7e2980afd444d72bcf\"\n+\"checksum lsp-types 0.66.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"49a2dddfe2791cbf4b5eff5a581e45becf47a24b128a62de80e7cc135bf50064\"\n \"checksum matches 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7ffc5c5338469d4d3ea17d269fa8ea3512ad247247c30bd2df69e68309ed0a08\"\n \"checksum memchr 2.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"88579771288728879b57485cc7d6b07d648c9f0141eb955f8ab7f9d45394468e\"\n \"checksum memoffset 0.5.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"75189eb85871ea5c2e2c15abbdd541185f63b408415e5051f5cac122d8c774b9\"\n \"checksum mio 0.6.21 (registry+https://github.com/rust-lang/crates.io-index)\" = \"302dec22bcf6bae6dfb69c647187f4b4d0fb6f535521f7bc022430ce8e12008f\"\n-\"checksum mio-extras 2.0.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"46e73a04c2fa6250b8d802134d56d554a9ec2922bf977777c805ea5def61ce40\"\n+\"checksum mio-extras 2.0.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"52403fe290012ce777c4626790c8951324a2b9e3316b3143779c72b029742f19\"\n \"checksum miow 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8c1f2f3b1cf331de6896aabf6e9d55dca90356cc9960cca7eaaf408a355ae919\"\n \"checksum net2 0.2.33 (registry+https://github.com/rust-lang/crates.io-index)\" = \"42550d9fb7b6684a6d404d9fa7250c2eb2646df731d1c06afc06dcee9e1bcf88\"\n \"checksum notify 4.0.14 (registry+https://github.com/rust-lang/crates.io-index)\" = \"199628fc33b21bc767baa057490b00b382ecbae030803a7b36292422d15b778b\"\n-\"checksum num-integer 0.1.41 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b85e541ef8255f6cf42bbfe4ef361305c6c135d10919ecc26126c4e5ae94bc09\"\n \"checksum num-traits 0.2.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d4c81ffc11c212fa327657cb19dd85eb7419e163b5b076bede2bdb5c974c07e4\"\n \"checksum num_cpus 1.11.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"76dac5ed2a876980778b8b85f75a71b6cbf0db0b1232ee12f826bccb00d09d72\"\n \"checksum once_cell 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"891f486f630e5c5a4916c7e16c4b24a53e78c860b646e9f8e005e4f16847bfed\"\n@@ -1907,7 +1866,6 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum proc-macro-hack 0.5.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ecd45702f76d6d3c75a80564378ae228a85f0b59d2f3ed43c91b4a69eb2ebfc5\"\n \"checksum proc-macro2 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9c9e470a8dc4aeae2dee2f335e8f533e2d4b347e1434e5671afc49b054592f27\"\n \"checksum proptest 0.9.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cf147e022eacf0c8a054ab864914a7602618adba841d800a9a9868a5237a529f\"\n-\"checksum psm 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b14fc68b454f875abc8354c2555e1d56596f74833ddc0f77f87f4871ed6a30e0\"\n \"checksum quick-error 1.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9274b940887ce9addde99c4eee6b5c44cc494b182b97e73dc8ffdcb3397fd3f0\"\n \"checksum quote 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"053a8c8bcc71fcce321828dc897a98ab9760bef03a4fc36693c231e5b3216cfe\"\n \"checksum ra_vfs 0.5.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bc898f237e4b4498959ae0100c688793a23e77624d44ef710ba70094217f98e0\"\n@@ -1935,7 +1893,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum relative-path 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bedde000f40f2921ce439ea165c9c53fd629bfa115140c72e22aceacb4a21954\"\n \"checksum remove_dir_all 0.5.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4a83fa3702a688b9359eccba92d153ac33fd2e8462f9e0e3fdf155239ea7792e\"\n \"checksum ron 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2ece421e0c4129b90e4a35b6f625e472e96c552136f5093a2f4fa2bbb75a62d5\"\n-\"checksum rowan 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ca620bbf9c48c92b5cef19f96354a309ac36b7d8ef7c591e66117335c8b1988b\"\n+\"checksum rowan 0.8.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3eb10a10a48f0f809a217bcf074b85a03dcf79831bae80e7f1a043d0897463e2\"\n \"checksum rustc-demangle 0.1.16 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4c691c0e608126e00913e33f0ccf3727d5fc84573623b8d65b2df340b5201783\"\n \"checksum rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7540fc8b0c49f096ee9c961cda096467dce8084bec6bdca2fc83895fd9b28cb8\"\n \"checksum rustc_lexer 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c86aae0c77166108c01305ee1a36a1e77289d7dc6ca0a3cd91ff4992de2d16a5\"\n@@ -1947,24 +1905,22 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum scopeguard 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b42e15e59b18a828bbf5c58ea01debb36b9b096346de35d941dcb89009f24a0d\"\n \"checksum semver 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1d7eb9ef2c18661902cc47e535f9bc51b78acd254da71d375c2f6720d9a40403\"\n \"checksum semver-parser 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"388a1df253eca08550bef6c72392cfe7c30914bf41df5269b68cbd6ff8f570a3\"\n-\"checksum serde 1.0.103 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1217f97ab8e8904b57dd22eb61cde455fa7446a9c1cf43966066da047c1f3702\"\n-\"checksum serde_derive 1.0.103 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a8c6faef9a2e64b0064f48570289b4bf8823b7581f1d6157c1b52152306651d0\"\n-\"checksum serde_json 1.0.42 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1a3351dcbc1f067e2c92ab7c3c1f288ad1a4cffc470b5aaddb4c2e0a3ae80043\"\n+\"checksum serde 1.0.104 (registry+https://github.com/rust-lang/crates.io-index)\" = \"414115f25f818d7dfccec8ee535d76949ae78584fc4f79a6f45a904bf8ab4449\"\n+\"checksum serde_derive 1.0.104 (registry+https://github.com/rust-lang/crates.io-index)\" = \"128f9e303a5a29922045a830221b8f78ec74a5f544944f3d5984f8ec3895ef64\"\n+\"checksum serde_json 1.0.44 (registry+https://github.com/rust-lang/crates.io-index)\" = \"48c575e0cc52bdd09b47f330f646cf59afc586e9c4e3ccd6fc1f625b8ea1dad7\"\n \"checksum serde_repr 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cd02c7587ec314570041b2754829f84d873ced14a96d1fd1823531e11db40573\"\n \"checksum serde_yaml 0.8.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"691b17f19fc1ec9d94ec0b5864859290dff279dbd7b03f017afda54eb36c3c35\"\n \"checksum slab 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c111b5bd5695e56cffe5129854aa230b39c93a305372fdbb2668ca2394eea9f8\"\n-\"checksum smallvec 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4ecf3b85f68e8abaa7555aa5abdb1153079387e60b718283d732f03897fcfc86\"\n+\"checksum smallvec 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"44e59e0c9fa00817912ae6e4e6e3c4fe04455e75699d06eedc7d85917ed8e8f4\"\n \"checksum smol_str 0.1.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"34836c9a295c62c2ce3514471117c5cb269891e8421b2aafdd910050576c4d8b\"\n-\"checksum stacker 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d96fc4f13a0ac088e9a3cd9af1cc8c5cc1ab5deb2145cef661267dfc9c542f8a\"\n \"checksum superslice 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ab16ced94dbd8a46c82fd81e3ed9a8727dac2977ea869d217bcc4ea1f122e81f\"\n-\"checksum syn 1.0.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"661641ea2aa15845cddeb97dad000d22070bb5c1fb456b96c1cba883ec691e92\"\n+\"checksum syn 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dff0acdb207ae2fe6d5976617f887eb1e35a2ba52c13c7234c790960cdad9238\"\n \"checksum tempfile 3.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7a6e24d9338a0a5be79593e2fa15a648add6138caa803e2d5bc782c371732ca9\"\n \"checksum termios 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"72b620c5ea021d75a735c943269bb07d30c9b77d6ac6b236bc8b5c496ef05625\"\n \"checksum text_unit 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e08bbcb7a3adbda0eb23431206b653bdad3d8dea311e72d36bf2215e27a42579\"\n \"checksum thin-dst 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c52fd98a9e4913c466d83381a59245691875d2f3e04611fca57f964bd8aa96e1\"\n \"checksum thread_local 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c6b53e329000edc2b34dbe8545fd20e55a333362d0a321909685a19bd28c3f1b\"\n \"checksum threadpool 1.7.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e2f0c90a5f3459330ac8bc0d2f879c693bb7a2f59689c1083fc4ef83834da865\"\n-\"checksum time 0.1.42 (registry+https://github.com/rust-lang/crates.io-index)\" = \"db8dcfca086c1143c9270ac42a2bbd8a7ee477b78ac8e45b19abfb0cbede4b6f\"\n \"checksum unicase 2.6.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"50f37be617794602aabbeee0be4f259dc1778fabe05e2d67ee8f79326d5cb4f6\"\n \"checksum unicode-bidi 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"49f2bd0c6468a8230e1db229cff8029217cf623c767ea5d60bfbd42729ea54d5\"\n \"checksum unicode-normalization 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b561e267b2326bb4cebfc0ef9e68355c7abe6c6f522aeac2f5bf95d56c59bdcf\"\n@@ -1983,4 +1939,3 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum winapi-x86_64-pc-windows-gnu 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f\"\n \"checksum ws2_32-sys 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d59cefebd0c892fa2dd6de581e937301d8552cb44489cdff035c6187cb63fa5e\"\n \"checksum yaml-rust 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"65923dd1784f44da1d2c3dbbc5e822045628c590ba72123e1c73d3c230c4434d\"\n-\"checksum yansi 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9fc79f4a1e39857fc00c3f662cbf2651c771f00e9c15fe2abc341806bd46bd71\""}, {"sha": "97508c57b4f6e0de73c9b0aaab5fd6cd4f3824b7", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -11,3 +11,4 @@ incremental = true\n debug = 0 # set this to 1 or 2 to get more useful backtraces in debugger\n \n [patch.'crates-io']\n+# rowan = { path = \"../rowan\" }\n\\ No newline at end of file"}, {"sha": "deaa147ba915bdcc930b3b89011c2042079bd69b", "filename": "README.md", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -37,7 +37,8 @@ $ cargo xtask install\n $ cargo xtask install --server\n ```\n \n-For non-standard setup of VS Code and other editors, see [./docs/user](./docs/user).\n+For non-standard setup of VS Code and other editors, or if the language server\n+cannot start, see [./docs/user](./docs/user).\n \n ## Documentation\n \n@@ -57,7 +58,7 @@ https://rust-lang.zulipchat.com/#narrow/stream/185405-t-compiler.2Frls-2.2E0\n ## Quick Links\n \n * API docs: https://rust-analyzer.github.io/rust-analyzer/ra_ide/\n-\n+* Website: https://rust-analyzer.github.io/\n \n ## License\n "}, {"sha": "993aebc478a0665f139727630a059c18e2937edd", "filename": "crates/ra_assists/src/assist_ctx.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -1,5 +1,5 @@\n //! This module defines `AssistCtx` -- the API surface that is exposed to assists.\n-use hir::{db::HirDatabase, SourceAnalyzer};\n+use hir::{db::HirDatabase, InFile, SourceAnalyzer};\n use ra_db::FileRange;\n use ra_fmt::{leading_indent, reindent};\n use ra_syntax::{\n@@ -117,7 +117,7 @@ impl<'a, DB: HirDatabase> AssistCtx<'a, DB> {\n         node: &SyntaxNode,\n         offset: Option<TextUnit>,\n     ) -> SourceAnalyzer {\n-        SourceAnalyzer::new(self.db, hir::Source::new(self.frange.file_id.into(), node), offset)\n+        SourceAnalyzer::new(self.db, InFile::new(self.frange.file_id.into(), node), offset)\n     }\n \n     pub(crate) fn covering_node_for_range(&self, range: TextRange) -> SyntaxElement {"}, {"sha": "037306fd67d237e7a90385c6b967599694b92b5c", "filename": "crates/ra_assists/src/assists/add_custom_impl.rs", "status": "added", "additions": 206, "deletions": 0, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_custom_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_custom_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_custom_impl.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -0,0 +1,206 @@\n+//! FIXME: write short doc here\n+\n+use crate::{Assist, AssistCtx, AssistId};\n+use hir::db::HirDatabase;\n+use join_to_string::join;\n+use ra_syntax::{\n+    ast::{self, AstNode},\n+    Direction, SmolStr,\n+    SyntaxKind::{IDENT, WHITESPACE},\n+    TextRange, TextUnit,\n+};\n+\n+const DERIVE_TRAIT: &'static str = \"derive\";\n+\n+// Assist: add_custom_impl\n+//\n+// Adds impl block for derived trait.\n+//\n+// ```\n+// #[derive(Deb<|>ug, Display)]\n+// struct S;\n+// ```\n+// ->\n+// ```\n+// #[derive(Display)]\n+// struct S;\n+//\n+// impl Debug for S {\n+//\n+// }\n+// ```\n+pub(crate) fn add_custom_impl(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+    let input = ctx.find_node_at_offset::<ast::AttrInput>()?;\n+    let attr = input.syntax().parent().and_then(ast::Attr::cast)?;\n+\n+    let attr_name = attr\n+        .syntax()\n+        .descendants_with_tokens()\n+        .filter(|t| t.kind() == IDENT)\n+        .find_map(|i| i.into_token())\n+        .filter(|t| *t.text() == DERIVE_TRAIT)?\n+        .text()\n+        .clone();\n+\n+    let trait_token =\n+        ctx.token_at_offset().filter(|t| t.kind() == IDENT && *t.text() != attr_name).next()?;\n+\n+    let annotated = attr.syntax().siblings(Direction::Next).find_map(|s| ast::Name::cast(s))?;\n+    let annotated_name = annotated.syntax().text().to_string();\n+    let start_offset = annotated.syntax().parent()?.text_range().end();\n+\n+    ctx.add_assist(AssistId(\"add_custom_impl\"), \"add custom impl\", |edit| {\n+        edit.target(attr.syntax().text_range());\n+\n+        let new_attr_input = input\n+            .syntax()\n+            .descendants_with_tokens()\n+            .filter(|t| t.kind() == IDENT)\n+            .filter_map(|t| t.into_token().map(|t| t.text().clone()))\n+            .filter(|t| t != trait_token.text())\n+            .collect::<Vec<SmolStr>>();\n+        let has_more_derives = new_attr_input.len() > 0;\n+        let new_attr_input =\n+            join(new_attr_input.iter()).separator(\", \").surround_with(\"(\", \")\").to_string();\n+        let new_attr_input_len = new_attr_input.len();\n+\n+        let mut buf = String::new();\n+        buf.push_str(\"\\n\\nimpl \");\n+        buf.push_str(trait_token.text().as_str());\n+        buf.push_str(\" for \");\n+        buf.push_str(annotated_name.as_str());\n+        buf.push_str(\" {\\n\");\n+\n+        let cursor_delta = if has_more_derives {\n+            edit.replace(input.syntax().text_range(), new_attr_input);\n+            input.syntax().text_range().len() - TextUnit::from_usize(new_attr_input_len)\n+        } else {\n+            let attr_range = attr.syntax().text_range();\n+            edit.delete(attr_range);\n+\n+            let line_break_range = attr\n+                .syntax()\n+                .next_sibling_or_token()\n+                .filter(|t| t.kind() == WHITESPACE)\n+                .map(|t| t.text_range())\n+                .unwrap_or(TextRange::from_to(TextUnit::from(0), TextUnit::from(0)));\n+            edit.delete(line_break_range);\n+\n+            attr_range.len() + line_break_range.len()\n+        };\n+\n+        edit.set_cursor(start_offset + TextUnit::of_str(&buf) - cursor_delta);\n+        buf.push_str(\"\\n}\");\n+        edit.insert(start_offset, buf);\n+    })\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use crate::helpers::{check_assist, check_assist_not_applicable};\n+\n+    #[test]\n+    fn add_custom_impl_for_unique_input() {\n+        check_assist(\n+            add_custom_impl,\n+            \"\n+#[derive(Debu<|>g)]\n+struct Foo {\n+    bar: String,\n+}\n+            \",\n+            \"\n+struct Foo {\n+    bar: String,\n+}\n+\n+impl Debug for Foo {\n+<|>\n+}\n+            \",\n+        )\n+    }\n+\n+    #[test]\n+    fn add_custom_impl_for_with_visibility_modifier() {\n+        check_assist(\n+            add_custom_impl,\n+            \"\n+#[derive(Debug<|>)]\n+pub struct Foo {\n+    bar: String,\n+}\n+            \",\n+            \"\n+pub struct Foo {\n+    bar: String,\n+}\n+\n+impl Debug for Foo {\n+<|>\n+}\n+            \",\n+        )\n+    }\n+\n+    #[test]\n+    fn add_custom_impl_when_multiple_inputs() {\n+        check_assist(\n+            add_custom_impl,\n+            \"\n+#[derive(Display, Debug<|>, Serialize)]\n+struct Foo {}\n+            \",\n+            \"\n+#[derive(Display, Serialize)]\n+struct Foo {}\n+\n+impl Debug for Foo {\n+<|>\n+}\n+            \",\n+        )\n+    }\n+\n+    #[test]\n+    fn test_ignore_derive_macro_without_input() {\n+        check_assist_not_applicable(\n+            add_custom_impl,\n+            \"\n+#[derive(<|>)]\n+struct Foo {}\n+            \",\n+        )\n+    }\n+\n+    #[test]\n+    fn test_ignore_if_cursor_on_param() {\n+        check_assist_not_applicable(\n+            add_custom_impl,\n+            \"\n+#[derive<|>(Debug)]\n+struct Foo {}\n+            \",\n+        );\n+\n+        check_assist_not_applicable(\n+            add_custom_impl,\n+            \"\n+#[derive(Debug)<|>]\n+struct Foo {}\n+            \",\n+        )\n+    }\n+\n+    #[test]\n+    fn test_ignore_if_not_derive() {\n+        check_assist_not_applicable(\n+            add_custom_impl,\n+            \"\n+#[allow(non_camel_<|>case_types)]\n+struct Foo {}\n+            \",\n+        )\n+    }\n+}"}, {"sha": "b8752cbad52aea70267acf22dd0e79a7f257aec9", "filename": "crates/ra_assists/src/assists/add_import.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_import.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -578,17 +578,21 @@ fn apply_auto_import(\n \n fn collect_hir_path_segments(path: &hir::Path) -> Option<Vec<SmolStr>> {\n     let mut ps = Vec::<SmolStr>::with_capacity(10);\n-    match path.kind {\n+    match path.kind() {\n         hir::PathKind::Abs => ps.push(\"\".into()),\n         hir::PathKind::Crate => ps.push(\"crate\".into()),\n         hir::PathKind::Plain => {}\n-        hir::PathKind::Self_ => ps.push(\"self\".into()),\n-        hir::PathKind::Super => ps.push(\"super\".into()),\n-        hir::PathKind::Type(_) | hir::PathKind::DollarCrate(_) => return None,\n-    }\n-    for s in path.segments.iter() {\n-        ps.push(s.name.to_string().into());\n+        hir::PathKind::Super(0) => ps.push(\"self\".into()),\n+        hir::PathKind::Super(lvl) => {\n+            let mut chain = \"super\".to_string();\n+            for _ in 0..*lvl {\n+                chain += \"::super\";\n+            }\n+            ps.push(chain.into());\n+        }\n+        hir::PathKind::DollarCrate(_) => return None,\n     }\n+    ps.extend(path.segments().iter().map(|it| it.name.to_string().into()));\n     Some(ps)\n }\n "}, {"sha": "b2f946fac36b144413f2ddc9954f3c9cce08ed8e", "filename": "crates/ra_assists/src/assists/add_new.rs", "status": "modified", "additions": 40, "deletions": 46, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_new.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -1,5 +1,5 @@\n use format_buf::format;\n-use hir::{db::HirDatabase, FromSource};\n+use hir::{db::HirDatabase, FromSource, InFile};\n use join_to_string::join;\n use ra_syntax::{\n     ast::{\n@@ -56,42 +56,39 @@ pub(crate) fn add_new(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n         let vis = vis.as_ref().map(String::as_str).unwrap_or(\"\");\n         write!(&mut buf, \"    {}fn new(\", vis).unwrap();\n \n-        join(field_list.fields().map(|f| {\n-            format!(\n-                \"{}: {}\",\n-                f.name().unwrap().syntax().text(),\n-                f.ascribed_type().unwrap().syntax().text()\n-            )\n+        join(field_list.fields().filter_map(|f| {\n+            Some(format!(\"{}: {}\", f.name()?.syntax().text(), f.ascribed_type()?.syntax().text()))\n         }))\n         .separator(\", \")\n         .to_buf(&mut buf);\n \n         buf.push_str(\") -> Self { Self {\");\n \n-        join(field_list.fields().map(|f| f.name().unwrap().syntax().text()))\n+        join(field_list.fields().filter_map(|f| Some(f.name()?.syntax().text())))\n             .separator(\", \")\n             .surround_with(\" \", \" \")\n             .to_buf(&mut buf);\n \n         buf.push_str(\"} }\");\n \n-        let (start_offset, end_offset) = if let Some(impl_block) = impl_block {\n-            buf.push('\\n');\n-            let start = impl_block\n-                .syntax()\n-                .descendants_with_tokens()\n-                .find(|t| t.kind() == T!['{'])\n-                .unwrap()\n-                .text_range()\n-                .end();\n-\n-            (start, TextUnit::from_usize(1))\n-        } else {\n-            buf = generate_impl_text(&strukt, &buf);\n-            let start = strukt.syntax().text_range().end();\n-\n-            (start, TextUnit::from_usize(3))\n-        };\n+        let (start_offset, end_offset) = impl_block\n+            .and_then(|impl_block| {\n+                buf.push('\\n');\n+                let start = impl_block\n+                    .syntax()\n+                    .descendants_with_tokens()\n+                    .find(|t| t.kind() == T!['{'])?\n+                    .text_range()\n+                    .end();\n+\n+                Some((start, TextUnit::from_usize(1)))\n+            })\n+            .unwrap_or_else(|| {\n+                buf = generate_impl_text(&strukt, &buf);\n+                let start = strukt.syntax().text_range().end();\n+\n+                (start, TextUnit::from_usize(3))\n+            });\n \n         edit.set_cursor(start_offset + TextUnit::of_str(&buf) - end_offset);\n         edit.insert(start_offset, buf);\n@@ -141,44 +138,41 @@ fn find_struct_impl(\n     })?;\n \n     let struct_ty = {\n-        let src = hir::Source { file_id: ctx.frange.file_id.into(), value: strukt.clone() };\n-        hir::Struct::from_source(db, src).unwrap().ty(db)\n+        let src = InFile { file_id: ctx.frange.file_id.into(), value: strukt.clone() };\n+        hir::Struct::from_source(db, src)?.ty(db)\n     };\n \n-    let mut found_new_fn = false;\n-\n-    let block = module.descendants().filter_map(ast::ImplBlock::cast).find(|impl_blk| {\n-        if found_new_fn {\n-            return false;\n-        }\n-\n-        let src = hir::Source { file_id: ctx.frange.file_id.into(), value: impl_blk.clone() };\n-        let blk = hir::ImplBlock::from_source(db, src).unwrap();\n+    let block = module.descendants().filter_map(ast::ImplBlock::cast).find_map(|impl_blk| {\n+        let src = InFile { file_id: ctx.frange.file_id.into(), value: impl_blk.clone() };\n+        let blk = hir::ImplBlock::from_source(db, src)?;\n \n         let same_ty = blk.target_ty(db) == struct_ty;\n         let not_trait_impl = blk.target_trait(db).is_none();\n \n         if !(same_ty && not_trait_impl) {\n-            return false;\n+            None\n+        } else {\n+            Some(impl_blk)\n         }\n-\n-        found_new_fn = has_new_fn(impl_blk);\n-        true\n     });\n \n-    if found_new_fn {\n-        None\n-    } else {\n-        Some(block)\n+    if let Some(ref impl_blk) = block {\n+        if has_new_fn(impl_blk) {\n+            return None;\n+        }\n     }\n+\n+    Some(block)\n }\n \n fn has_new_fn(imp: &ast::ImplBlock) -> bool {\n     if let Some(il) = imp.item_list() {\n         for item in il.impl_items() {\n             if let ast::ImplItem::FnDef(f) = item {\n-                if f.name().unwrap().text().eq_ignore_ascii_case(\"new\") {\n-                    return true;\n+                if let Some(name) = f.name() {\n+                    if name.text().eq_ignore_ascii_case(\"new\") {\n+                        return true;\n+                    }\n                 }\n             }\n         }"}, {"sha": "023917aca7b1d717e3ad94d49624a54d5f7e2972", "filename": "crates/ra_assists/src/assists/early_return.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_assists%2Fsrc%2Fassists%2Fearly_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_assists%2Fsrc%2Fassists%2Fearly_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fearly_return.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -83,8 +83,8 @@ pub(crate) fn convert_to_guarded_return(ctx: AssistCtx<impl HirDatabase>) -> Opt\n     let parent_container = parent_block.syntax().parent()?.parent()?;\n \n     let early_expression: ast::Expr = match parent_container.kind() {\n-        WHILE_EXPR | LOOP_EXPR => make::expr_continue().into(),\n-        FN_DEF => make::expr_return().into(),\n+        WHILE_EXPR | LOOP_EXPR => make::expr_continue(),\n+        FN_DEF => make::expr_return(),\n         _ => return None,\n     };\n \n@@ -116,21 +116,21 @@ pub(crate) fn convert_to_guarded_return(ctx: AssistCtx<impl HirDatabase>) -> Opt\n                             )\n                             .into(),\n                         ),\n-                        make::expr_path(make::path_from_name_ref(make::name_ref(\"it\"))).into(),\n+                        make::expr_path(make::path_from_name_ref(make::name_ref(\"it\"))),\n                     );\n \n                     let sad_arm = make::match_arm(\n                         // FIXME: would be cool to use `None` or `Err(_)` if appropriate\n                         once(make::placeholder_pat().into()),\n-                        early_expression.into(),\n+                        early_expression,\n                     );\n \n                     make::expr_match(cond_expr, make::match_arm_list(vec![happy_arm, sad_arm]))\n                 };\n \n                 let let_stmt = make::let_stmt(\n                     make::bind_pat(make::name(&bound_ident.syntax().to_string())).into(),\n-                    Some(match_expr.into()),\n+                    Some(match_expr),\n                 );\n                 let let_stmt = if_indent_level.increase_indent(let_stmt);\n                 replace(let_stmt.syntax(), &then_block, &parent_block, &if_expr)"}, {"sha": "4586eeb5923fe5a9cc39b714da98d5220934d895", "filename": "crates/ra_assists/src/doc_tests/generated.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_assists%2Fsrc%2Fdoc_tests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_assists%2Fsrc%2Fdoc_tests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fdoc_tests%2Fgenerated.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -2,6 +2,25 @@\n \n use super::check;\n \n+#[test]\n+fn doctest_add_custom_impl() {\n+    check(\n+        \"add_custom_impl\",\n+        r#####\"\n+#[derive(Deb<|>ug, Display)]\n+struct S;\n+\"#####,\n+        r#####\"\n+#[derive(Display)]\n+struct S;\n+\n+impl Debug for S {\n+\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_add_derive() {\n     check("}, {"sha": "98fb20b227f98f0e4b32029ec4d7396a64872754", "filename": "crates/ra_assists/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Flib.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -95,6 +95,7 @@ mod assists {\n     mod add_derive;\n     mod add_explicit_type;\n     mod add_impl;\n+    mod add_custom_impl;\n     mod add_new;\n     mod apply_demorgan;\n     mod invert_if;\n@@ -121,6 +122,7 @@ mod assists {\n             add_derive::add_derive,\n             add_explicit_type::add_explicit_type,\n             add_impl::add_impl,\n+            add_custom_impl::add_custom_impl,\n             add_new::add_new,\n             apply_demorgan::apply_demorgan,\n             invert_if::invert_if,"}, {"sha": "d5249f3088597a484f04f491bb26f2c66f3ba8af", "filename": "crates/ra_assists/src/test_db.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_assists%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_assists%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Ftest_db.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -43,5 +43,3 @@ impl FileLoader for TestDB {\n         FileLoaderDelegate(self).relevant_crates(file_id)\n     }\n }\n-\n-impl hir::debug::HirDebugHelper for TestDB {}"}, {"sha": "7744ba85a2402ccfbb63fa45b6bbed466e6f7f30", "filename": "crates/ra_batch/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_batch%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_batch%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_batch%2Fsrc%2Flib.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -22,7 +22,7 @@ fn vfs_root_to_id(r: ra_vfs::VfsRoot) -> SourceRootId {\n \n pub fn load_cargo(root: &Path) -> Result<(AnalysisHost, FxHashMap<SourceRootId, PackageRoot>)> {\n     let root = std::env::current_dir()?.join(root);\n-    let ws = ProjectWorkspace::discover(root.as_ref())?;\n+    let ws = ProjectWorkspace::discover(root.as_ref(), &Default::default())?;\n     let project_roots = ws.to_roots();\n     let (sender, receiver) = unbounded();\n     let sender = Box::new(move |t| sender.send(t).unwrap());"}, {"sha": "12af075f7df06219f9d045bb5d5a30724bb2dca0", "filename": "crates/ra_cli/Cargo.toml", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_cli%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_cli%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cli%2FCargo.toml?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -7,12 +7,14 @@ publish = false\n \n [dependencies]\n pico-args = \"0.3.0\"\n-flexi_logger = \"0.14.0\"\n+env_logger = { version = \"0.7.1\", default-features = false, features = [\"humantime\"] }\n \n ra_syntax = { path = \"../ra_syntax\" }\n ra_ide = { path = \"../ra_ide\" }\n ra_batch = { path = \"../ra_batch\" }\n-ra_hir = { path = \"../ra_hir\" }\n+hir = { path = \"../ra_hir\", package = \"ra_hir\" }\n+hir_ty = { path = \"../ra_hir_ty\", package = \"ra_hir_ty\" }\n+hir_def = { path = \"../ra_hir_def\", package = \"ra_hir_def\" }\n ra_db = { path = \"../ra_db\" }\n \n [dependencies.ra_prof]"}, {"sha": "ac65415a5e7ed207166b7bec497812a3933d6377", "filename": "crates/ra_cli/src/analysis_stats.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_cli%2Fsrc%2Fanalysis_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_cli%2Fsrc%2Fanalysis_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cli%2Fsrc%2Fanalysis_stats.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -2,8 +2,13 @@\n \n use std::{collections::HashSet, fmt::Write, path::Path, time::Instant};\n \n+use hir::{\n+    db::{DefDatabase, HirDatabase},\n+    AssocItem, Crate, HasSource, HirDisplay, ModuleDef,\n+};\n+use hir_def::FunctionId;\n+use hir_ty::{Ty, TypeWalk};\n use ra_db::SourceDatabaseExt;\n-use ra_hir::{AssocItem, Crate, HasSource, HirDisplay, ModuleDef, Ty, TypeWalk};\n use ra_syntax::AstNode;\n \n use crate::{progress_report::ProgressReport, Result, Verbosity};\n@@ -101,8 +106,9 @@ pub fn run(\n                 continue;\n             }\n         }\n-        let body = f.body(db);\n-        let inference_result = f.infer(db);\n+        let f_id = FunctionId::from(f);\n+        let body = db.body(f_id.into());\n+        let inference_result = db.infer(f_id.into());\n         for (expr_id, _) in body.exprs.iter() {\n             let ty = &inference_result[expr_id];\n             num_exprs += 1;\n@@ -122,7 +128,8 @@ pub fn run(\n             if let Some(mismatch) = inference_result.type_mismatch_for_expr(expr_id) {\n                 num_type_mismatches += 1;\n                 if verbosity.is_verbose() {\n-                    let src = f.body_source_map(db).expr_syntax(expr_id);\n+                    let (_, sm) = db.body_with_source_map(f_id.into());\n+                    let src = sm.expr_syntax(expr_id);\n                     if let Some(src) = src {\n                         // FIXME: it might be nice to have a function (on Analysis?) that goes from Source<T> -> (LineCol, LineCol) directly\n                         let original_file = src.file_id.original_file(db);"}, {"sha": "3808590abe5ce253111f87f07c07db4aabb35ae5", "filename": "crates/ra_cli/src/main.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_cli%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_cli%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cli%2Fsrc%2Fmain.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -7,7 +7,6 @@ mod progress_report;\n \n use std::{error::Error, fmt::Write, io::Read};\n \n-use flexi_logger::Logger;\n use pico_args::Arguments;\n use ra_ide::{file_structure, Analysis};\n use ra_prof::profile;\n@@ -32,7 +31,7 @@ impl Verbosity {\n }\n \n fn main() -> Result<()> {\n-    Logger::with_env_or_str(\"error\").start()?;\n+    env_logger::try_init()?;\n \n     let subcommand = match std::env::args_os().nth(1) {\n         None => {"}, {"sha": "2a7ed20d1ce91b89a198cc15a7e1b15ed7af39f5", "filename": "crates/ra_db/src/input.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_db%2Fsrc%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_db%2Fsrc%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Finput.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -235,6 +235,15 @@ impl FromStr for Edition {\n     }\n }\n \n+impl fmt::Display for Edition {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.write_str(match self {\n+            Edition::Edition2015 => \"2015\",\n+            Edition::Edition2018 => \"2018\",\n+        })\n+    }\n+}\n+\n impl Dependency {\n     pub fn crate_id(&self) -> CrateId {\n         self.crate_id"}, {"sha": "7dc31ad3cbdefe7a67c1ffb2f723523e27796ad8", "filename": "crates/ra_hir/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2FCargo.toml?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -10,9 +10,11 @@ doctest = false\n [dependencies]\n log = \"0.4.5\"\n rustc-hash = \"1.0\"\n+either = \"1.5\"\n \n ra_syntax = { path = \"../ra_syntax\" }\n ra_db = { path = \"../ra_db\" }\n+ra_prof = { path = \"../ra_prof\" }\n hir_expand = { path = \"../ra_hir_expand\", package = \"ra_hir_expand\" }\n hir_def = { path = \"../ra_hir_def\", package = \"ra_hir_def\" }\n hir_ty = { path = \"../ra_hir_ty\", package = \"ra_hir_ty\" }"}, {"sha": "bcfc0d03eca920dc1d42c37a52e7a602276f587e", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 109, "deletions": 300, "changes": 409, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -1,44 +1,43 @@\n //! FIXME: write short doc here\n-\n-pub(crate) mod src;\n-\n use std::sync::Arc;\n \n+use either::Either;\n use hir_def::{\n     adt::VariantData,\n-    body::{Body, BodySourceMap},\n     builtin_type::BuiltinType,\n     docs::Documentation,\n     expr::{BindingAnnotation, Pat, PatId},\n+    nameres::ModuleSource,\n     per_ns::PerNs,\n     resolver::HasResolver,\n     type_ref::{Mutability, TypeRef},\n-    AdtId, AstItemDef, ConstId, ContainerId, DefWithBodyId, EnumId, FunctionId, GenericDefId,\n-    HasModule, ImplId, LocalEnumVariantId, LocalImportId, LocalModuleId, LocalStructFieldId,\n-    Lookup, ModuleId, StaticId, StructId, TraitId, TypeAliasId, UnionId,\n+    AdtId, ConstId, DefWithBodyId, EnumId, FunctionId, HasModule, ImplId, LocalEnumVariantId,\n+    LocalModuleId, LocalStructFieldId, Lookup, ModuleId, StaticId, StructId, TraitId, TypeAliasId,\n+    TypeParamId, UnionId,\n };\n use hir_expand::{\n     diagnostics::DiagnosticSink,\n-    name::{self, AsName},\n-    AstId, MacroDefId,\n+    name::{name, AsName},\n+    MacroDefId,\n+};\n+use hir_ty::{\n+    autoderef, display::HirFormatter, expr::ExprValidator, ApplicationTy, Canonical, InEnvironment,\n+    TraitEnvironment, Ty, TyDefId, TypeCtor, TypeWalk,\n };\n-use hir_ty::expr::ExprValidator;\n-use ra_db::{CrateId, Edition, FileId, FilePosition};\n-use ra_syntax::{ast, AstNode, SyntaxNode};\n+use ra_db::{CrateId, Edition, FileId};\n+use ra_syntax::ast;\n \n use crate::{\n     db::{DefDatabase, HirDatabase},\n-    ty::display::HirFormatter,\n-    ty::{self, InEnvironment, InferenceResult, TraitEnvironment, Ty, TyDefId, TypeCtor, TypeWalk},\n-    CallableDef, Either, HirDisplay, Name, Source,\n+    CallableDef, HirDisplay, InFile, Name,\n };\n \n /// hir::Crate describes a single crate. It's the main interface with which\n /// a crate's dependencies interact. Mostly, it should be just a proxy for the\n /// root module.\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct Crate {\n-    pub(crate) crate_id: CrateId,\n+    pub(crate) id: CrateId,\n }\n \n #[derive(Debug)]\n@@ -48,91 +47,43 @@ pub struct CrateDependency {\n }\n \n impl Crate {\n-    pub fn crate_id(self) -> CrateId {\n-        self.crate_id\n-    }\n-\n     pub fn dependencies(self, db: &impl DefDatabase) -> Vec<CrateDependency> {\n         db.crate_graph()\n-            .dependencies(self.crate_id)\n+            .dependencies(self.id)\n             .map(|dep| {\n-                let krate = Crate { crate_id: dep.crate_id() };\n+                let krate = Crate { id: dep.crate_id() };\n                 let name = dep.as_name();\n                 CrateDependency { krate, name }\n             })\n             .collect()\n     }\n \n-    pub fn root_module(self, db: &impl DefDatabase) -> Option<Module> {\n-        let module_id = db.crate_def_map(self.crate_id).root;\n-        Some(Module::new(self, module_id))\n-    }\n-\n-    pub fn edition(self, db: &impl DefDatabase) -> Edition {\n+    // FIXME: add `transitive_reverse_dependencies`.\n+    pub fn reverse_dependencies(self, db: &impl DefDatabase) -> Vec<Crate> {\n         let crate_graph = db.crate_graph();\n-        crate_graph.edition(self.crate_id)\n-    }\n-\n-    pub fn all(db: &impl DefDatabase) -> Vec<Crate> {\n-        db.crate_graph().iter().map(|crate_id| Crate { crate_id }).collect()\n+        crate_graph\n+            .iter()\n+            .filter(|&krate| crate_graph.dependencies(krate).any(|it| it.crate_id == self.id))\n+            .map(|id| Crate { id })\n+            .collect()\n     }\n-}\n-\n-pub enum ModuleSource {\n-    SourceFile(ast::SourceFile),\n-    Module(ast::Module),\n-}\n \n-impl ModuleSource {\n-    pub fn new(\n-        db: &impl DefDatabase,\n-        file_id: Option<FileId>,\n-        decl_id: Option<AstId<ast::Module>>,\n-    ) -> ModuleSource {\n-        match (file_id, decl_id) {\n-            (Some(file_id), _) => {\n-                let source_file = db.parse(file_id).tree();\n-                ModuleSource::SourceFile(source_file)\n-            }\n-            (None, Some(item_id)) => {\n-                let module = item_id.to_node(db);\n-                assert!(module.item_list().is_some(), \"expected inline module\");\n-                ModuleSource::Module(module)\n-            }\n-            (None, None) => panic!(),\n-        }\n+    pub fn root_module(self, db: &impl DefDatabase) -> Option<Module> {\n+        let module_id = db.crate_def_map(self.id).root;\n+        Some(Module::new(self, module_id))\n     }\n \n-    // FIXME: this methods do not belong here\n-    pub fn from_position(db: &impl DefDatabase, position: FilePosition) -> ModuleSource {\n-        let parse = db.parse(position.file_id);\n-        match &ra_syntax::algo::find_node_at_offset::<ast::Module>(\n-            parse.tree().syntax(),\n-            position.offset,\n-        ) {\n-            Some(m) if !m.has_semi() => ModuleSource::Module(m.clone()),\n-            _ => {\n-                let source_file = parse.tree();\n-                ModuleSource::SourceFile(source_file)\n-            }\n-        }\n+    pub fn root_file(self, db: &impl DefDatabase) -> FileId {\n+        db.crate_graph().crate_root(self.id)\n     }\n \n-    pub fn from_child_node(db: &impl DefDatabase, child: Source<&SyntaxNode>) -> ModuleSource {\n-        if let Some(m) =\n-            child.value.ancestors().filter_map(ast::Module::cast).find(|it| !it.has_semi())\n-        {\n-            ModuleSource::Module(m)\n-        } else {\n-            let file_id = child.file_id.original_file(db);\n-            let source_file = db.parse(file_id).tree();\n-            ModuleSource::SourceFile(source_file)\n-        }\n+    pub fn edition(self, db: &impl DefDatabase) -> Edition {\n+        let crate_graph = db.crate_graph();\n+        crate_graph.edition(self.id)\n     }\n \n-    pub fn from_file_id(db: &impl DefDatabase, file_id: FileId) -> ModuleSource {\n-        let source_file = db.parse(file_id).tree();\n-        ModuleSource::SourceFile(source_file)\n+    pub fn all(db: &impl DefDatabase) -> Vec<Crate> {\n+        db.crate_graph().iter().map(|id| Crate { id }).collect()\n     }\n }\n \n@@ -171,7 +122,7 @@ pub use hir_def::attr::Attrs;\n \n impl Module {\n     pub(crate) fn new(krate: Crate, crate_module_id: LocalModuleId) -> Module {\n-        Module { id: ModuleId { krate: krate.crate_id, local_id: crate_module_id } }\n+        Module { id: ModuleId { krate: krate.id, local_id: crate_module_id } }\n     }\n \n     /// Name of this module.\n@@ -189,7 +140,7 @@ impl Module {\n \n     /// Returns the crate this module is part of.\n     pub fn krate(self) -> Crate {\n-        Crate { crate_id: self.id.krate }\n+        Crate { id: self.id.krate }\n     }\n \n     /// Topmost parent of this module. Every module has a `crate_root`, but some\n@@ -200,13 +151,6 @@ impl Module {\n         self.with_module_id(def_map.root)\n     }\n \n-    /// Finds a child module with the specified name.\n-    pub fn child(self, db: &impl DefDatabase, name: &Name) -> Option<Module> {\n-        let def_map = db.crate_def_map(self.id.krate);\n-        let child_id = def_map[self.id.local_id].children.get(name)?;\n-        Some(self.with_module_id(*child_id))\n-    }\n-\n     /// Iterates over all child modules.\n     pub fn children(self, db: &impl DefDatabase) -> impl Iterator<Item = Module> {\n         let def_map = db.crate_def_map(self.id.krate);\n@@ -236,13 +180,11 @@ impl Module {\n     }\n \n     /// Returns a `ModuleScope`: a set of items, visible in this module.\n-    pub fn scope(self, db: &impl HirDatabase) -> Vec<(Name, ScopeDef, Option<Import>)> {\n+    pub fn scope(self, db: &impl HirDatabase) -> Vec<(Name, ScopeDef)> {\n         db.crate_def_map(self.id.krate)[self.id.local_id]\n             .scope\n             .entries()\n-            .map(|(name, res)| {\n-                (name.clone(), res.def.into(), res.import.map(|id| Import { parent: self, id }))\n-            })\n+            .map(|(name, def)| (name.clone(), def.into()))\n             .collect()\n     }\n \n@@ -277,19 +219,14 @@ impl Module {\n \n     pub fn impl_blocks(self, db: &impl DefDatabase) -> Vec<ImplBlock> {\n         let def_map = db.crate_def_map(self.id.krate);\n-        def_map[self.id.local_id].impls.iter().copied().map(ImplBlock::from).collect()\n+        def_map[self.id.local_id].scope.impls().map(ImplBlock::from).collect()\n     }\n \n-    fn with_module_id(self, module_id: LocalModuleId) -> Module {\n+    pub(crate) fn with_module_id(self, module_id: LocalModuleId) -> Module {\n         Module::new(self.krate(), module_id)\n     }\n }\n \n-pub struct Import {\n-    pub(crate) parent: Module,\n-    pub(crate) id: LocalImportId,\n-}\n-\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct StructField {\n     pub(crate) parent: VariantDef,\n@@ -307,8 +244,10 @@ impl StructField {\n         self.parent.variant_data(db).fields()[self.id].name.clone()\n     }\n \n-    pub fn ty(&self, db: &impl HirDatabase) -> Ty {\n-        db.field_types(self.parent.into())[self.id].clone()\n+    pub fn ty(&self, db: &impl HirDatabase) -> Type {\n+        let var_id = self.parent.into();\n+        let ty = db.field_types(var_id)[self.id].clone();\n+        Type::new(db, self.parent.module(db).id.krate.into(), var_id, ty)\n     }\n \n     pub fn parent_def(&self, _db: &impl HirDatabase) -> VariantDef {\n@@ -323,7 +262,7 @@ pub struct Struct {\n \n impl Struct {\n     pub fn module(self, db: &impl DefDatabase) -> Module {\n-        Module { id: self.id.module(db) }\n+        Module { id: self.id.lookup(db).container.module(db) }\n     }\n \n     pub fn krate(self, db: &impl DefDatabase) -> Option<Crate> {\n@@ -343,21 +282,8 @@ impl Struct {\n             .collect()\n     }\n \n-    pub fn field(self, db: &impl HirDatabase, name: &Name) -> Option<StructField> {\n-        db.struct_data(self.id.into())\n-            .variant_data\n-            .fields()\n-            .iter()\n-            .find(|(_id, data)| data.name == *name)\n-            .map(|(id, _)| StructField { parent: self.into(), id })\n-    }\n-\n     pub fn ty(self, db: &impl HirDatabase) -> Type {\n-        Type::from_def(db, self.id.module(db).krate, self.id)\n-    }\n-\n-    pub fn constructor_ty(self, db: &impl HirDatabase) -> Ty {\n-        db.value_ty(self.id.into())\n+        Type::from_def(db, self.id.lookup(db).container.module(db).krate, self.id)\n     }\n \n     fn variant_data(self, db: &impl DefDatabase) -> Arc<VariantData> {\n@@ -376,11 +302,11 @@ impl Union {\n     }\n \n     pub fn module(self, db: &impl DefDatabase) -> Module {\n-        Module { id: self.id.module(db) }\n+        Module { id: self.id.lookup(db).container.module(db) }\n     }\n \n     pub fn ty(self, db: &impl HirDatabase) -> Type {\n-        Type::from_def(db, self.id.module(db).krate, self.id)\n+        Type::from_def(db, self.id.lookup(db).container.module(db).krate, self.id)\n     }\n \n     pub fn fields(self, db: &impl HirDatabase) -> Vec<StructField> {\n@@ -392,15 +318,6 @@ impl Union {\n             .collect()\n     }\n \n-    pub fn field(self, db: &impl HirDatabase, name: &Name) -> Option<StructField> {\n-        db.union_data(self.id)\n-            .variant_data\n-            .fields()\n-            .iter()\n-            .find(|(_id, data)| data.name == *name)\n-            .map(|(id, _)| StructField { parent: self.into(), id })\n-    }\n-\n     fn variant_data(self, db: &impl DefDatabase) -> Arc<VariantData> {\n         db.union_data(self.id).variant_data.clone()\n     }\n@@ -413,7 +330,7 @@ pub struct Enum {\n \n impl Enum {\n     pub fn module(self, db: &impl DefDatabase) -> Module {\n-        Module { id: self.id.module(db) }\n+        Module { id: self.id.lookup(db).container.module(db) }\n     }\n \n     pub fn krate(self, db: &impl DefDatabase) -> Option<Crate> {\n@@ -432,13 +349,8 @@ impl Enum {\n             .collect()\n     }\n \n-    pub fn variant(self, db: &impl DefDatabase, name: &Name) -> Option<EnumVariant> {\n-        let id = db.enum_data(self.id).variant(name)?;\n-        Some(EnumVariant { parent: self, id })\n-    }\n-\n     pub fn ty(self, db: &impl HirDatabase) -> Type {\n-        Type::from_def(db, self.id.module(db).krate, self.id)\n+        Type::from_def(db, self.id.lookup(db).container.module(db).krate, self.id)\n     }\n }\n \n@@ -468,14 +380,6 @@ impl EnumVariant {\n             .collect()\n     }\n \n-    pub fn field(self, db: &impl HirDatabase, name: &Name) -> Option<StructField> {\n-        self.variant_data(db)\n-            .fields()\n-            .iter()\n-            .find(|(_id, data)| data.name == *name)\n-            .map(|(id, _)| StructField { parent: self.into(), id })\n-    }\n-\n     pub(crate) fn variant_data(self, db: &impl DefDatabase) -> Arc<VariantData> {\n         db.enum_data(self.parent.id).variants[self.id].variant_data.clone()\n     }\n@@ -593,48 +497,8 @@ impl Function {\n         db.function_data(self.id).params.clone()\n     }\n \n-    pub fn body_source_map(self, db: &impl HirDatabase) -> Arc<BodySourceMap> {\n-        db.body_with_source_map(self.id.into()).1\n-    }\n-\n-    pub fn body(self, db: &impl HirDatabase) -> Arc<Body> {\n-        db.body(self.id.into())\n-    }\n-\n-    pub fn ty(self, db: &impl HirDatabase) -> Ty {\n-        db.value_ty(self.id.into())\n-    }\n-\n-    pub fn infer(self, db: &impl HirDatabase) -> Arc<InferenceResult> {\n-        db.infer(self.id.into())\n-    }\n-\n-    /// The containing impl block, if this is a method.\n-    pub fn impl_block(self, db: &impl DefDatabase) -> Option<ImplBlock> {\n-        match self.container(db) {\n-            Some(Container::ImplBlock(it)) => Some(it),\n-            _ => None,\n-        }\n-    }\n-\n-    /// The containing trait, if this is a trait method definition.\n-    pub fn parent_trait(self, db: &impl DefDatabase) -> Option<Trait> {\n-        match self.container(db) {\n-            Some(Container::Trait(it)) => Some(it),\n-            _ => None,\n-        }\n-    }\n-\n-    pub fn container(self, db: &impl DefDatabase) -> Option<Container> {\n-        match self.id.lookup(db).container {\n-            ContainerId::TraitId(it) => Some(Container::Trait(it.into())),\n-            ContainerId::ImplId(it) => Some(Container::ImplBlock(it.into())),\n-            ContainerId::ModuleId(_) => None,\n-        }\n-    }\n-\n     pub fn diagnostics(self, db: &impl HirDatabase, sink: &mut DiagnosticSink) {\n-        let infer = self.infer(db);\n+        let infer = db.infer(self.id.into());\n         infer.add_diagnostics(db, self.id, sink);\n         let mut validator = ExprValidator::new(self.id, infer, sink);\n         validator.validate_body(db);\n@@ -658,34 +522,6 @@ impl Const {\n     pub fn name(self, db: &impl HirDatabase) -> Option<Name> {\n         db.const_data(self.id).name.clone()\n     }\n-\n-    pub fn infer(self, db: &impl HirDatabase) -> Arc<InferenceResult> {\n-        db.infer(self.id.into())\n-    }\n-\n-    /// The containing impl block, if this is a type alias.\n-    pub fn impl_block(self, db: &impl DefDatabase) -> Option<ImplBlock> {\n-        match self.container(db) {\n-            Some(Container::ImplBlock(it)) => Some(it),\n-            _ => None,\n-        }\n-    }\n-\n-    /// The containing trait, if this is a trait type alias definition.\n-    pub fn parent_trait(self, db: &impl DefDatabase) -> Option<Trait> {\n-        match self.container(db) {\n-            Some(Container::Trait(it)) => Some(it),\n-            _ => None,\n-        }\n-    }\n-\n-    pub fn container(self, db: &impl DefDatabase) -> Option<Container> {\n-        match self.id.lookup(db).container {\n-            ContainerId::TraitId(it) => Some(Container::Trait(it.into())),\n-            ContainerId::ImplId(it) => Some(Container::ImplBlock(it.into())),\n-            ContainerId::ModuleId(_) => None,\n-        }\n-    }\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -701,10 +537,6 @@ impl Static {\n     pub fn krate(self, db: &impl DefDatabase) -> Option<Crate> {\n         Some(self.module(db).krate())\n     }\n-\n-    pub fn infer(self, db: &impl HirDatabase) -> Arc<InferenceResult> {\n-        db.infer(self.id.into())\n-    }\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -714,7 +546,7 @@ pub struct Trait {\n \n impl Trait {\n     pub fn module(self, db: &impl DefDatabase) -> Module {\n-        Module { id: self.id.module(db) }\n+        Module { id: self.id.lookup(db).container.module(db) }\n     }\n \n     pub fn name(self, db: &impl DefDatabase) -> Name {\n@@ -749,30 +581,6 @@ impl TypeAlias {\n         Some(self.module(db).krate())\n     }\n \n-    /// The containing impl block, if this is a type alias.\n-    pub fn impl_block(self, db: &impl DefDatabase) -> Option<ImplBlock> {\n-        match self.container(db) {\n-            Some(Container::ImplBlock(it)) => Some(it),\n-            _ => None,\n-        }\n-    }\n-\n-    /// The containing trait, if this is a trait type alias definition.\n-    pub fn parent_trait(self, db: &impl DefDatabase) -> Option<Trait> {\n-        match self.container(db) {\n-            Some(Container::Trait(it)) => Some(it),\n-            _ => None,\n-        }\n-    }\n-\n-    pub fn container(self, db: &impl DefDatabase) -> Option<Container> {\n-        match self.id.lookup(db).container {\n-            ContainerId::TraitId(it) => Some(Container::Trait(it.into())),\n-            ContainerId::ImplId(it) => Some(Container::ImplBlock(it.into())),\n-            ContainerId::ModuleId(_) => None,\n-        }\n-    }\n-\n     pub fn type_ref(self, db: &impl DefDatabase) -> Option<TypeRef> {\n         db.type_alias_data(self.id).type_ref.clone()\n     }\n@@ -791,14 +599,6 @@ pub struct MacroDef {\n     pub(crate) id: MacroDefId,\n }\n \n-impl MacroDef {}\n-\n-pub enum Container {\n-    Trait(Trait),\n-    ImplBlock(ImplBlock),\n-}\n-impl_froms!(Container: Trait, ImplBlock);\n-\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub enum AssocItem {\n     Function(Function),\n@@ -819,15 +619,6 @@ impl AssocItem {\n             AssocItem::TypeAlias(t) => t.module(db),\n         }\n     }\n-\n-    pub fn container(self, db: &impl DefDatabase) -> Container {\n-        match self {\n-            AssocItem::Function(f) => f.container(db),\n-            AssocItem::Const(c) => c.container(db),\n-            AssocItem::TypeAlias(t) => t.container(db),\n-        }\n-        .expect(\"AssocItem without container\")\n-    }\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, Debug, Hash)]\n@@ -869,7 +660,7 @@ impl Local {\n     }\n \n     pub fn is_self(self, db: &impl HirDatabase) -> bool {\n-        self.name(db) == Some(name::SELF_PARAM)\n+        self.name(db) == Some(name![self])\n     }\n \n     pub fn is_mut(self, db: &impl HirDatabase) -> bool {\n@@ -901,18 +692,30 @@ impl Local {\n         Type { krate, ty: InEnvironment { value: ty, environment } }\n     }\n \n-    pub fn source(self, db: &impl HirDatabase) -> Source<Either<ast::BindPat, ast::SelfParam>> {\n+    pub fn source(self, db: &impl HirDatabase) -> InFile<Either<ast::BindPat, ast::SelfParam>> {\n         let (_body, source_map) = db.body_with_source_map(self.parent.into());\n         let src = source_map.pat_syntax(self.pat_id).unwrap(); // Hmm...\n         let root = src.file_syntax(db);\n-        src.map(|ast| ast.map(|it| it.cast().unwrap().to_node(&root), |it| it.to_node(&root)))\n+        src.map(|ast| {\n+            ast.map_left(|it| it.cast().unwrap().to_node(&root)).map_right(|it| it.to_node(&root))\n+        })\n     }\n }\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n-pub struct GenericParam {\n-    pub(crate) parent: GenericDefId,\n-    pub(crate) idx: u32,\n+pub struct TypeParam {\n+    pub(crate) id: TypeParamId,\n+}\n+\n+impl TypeParam {\n+    pub fn name(self, db: &impl HirDatabase) -> Name {\n+        let params = db.generic_params(self.id.parent);\n+        params.types[self.id.local_id].name.clone()\n+    }\n+\n+    pub fn module(self, db: &impl HirDatabase) -> Module {\n+        self.id.parent.module(db).into()\n+    }\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -922,11 +725,11 @@ pub struct ImplBlock {\n \n impl ImplBlock {\n     pub fn all_in_crate(db: &impl HirDatabase, krate: Crate) -> Vec<ImplBlock> {\n-        let impls = db.impls_in_crate(krate.crate_id);\n+        let impls = db.impls_in_crate(krate.id);\n         impls.all_impls().map(Self::from).collect()\n     }\n     pub fn for_trait(db: &impl HirDatabase, krate: Crate, trait_: Trait) -> Vec<ImplBlock> {\n-        let impls = db.impls_in_crate(krate.crate_id);\n+        let impls = db.impls_in_crate(krate.id);\n         impls.lookup_impl_blocks_for_trait(trait_.id).map(Self::from).collect()\n     }\n \n@@ -943,7 +746,10 @@ impl ImplBlock {\n         let resolver = self.id.resolver(db);\n         let environment = TraitEnvironment::lower(db, &resolver);\n         let ty = Ty::from_hir(db, &resolver, &impl_data.target_type);\n-        Type { krate: self.id.module(db).krate, ty: InEnvironment { value: ty, environment } }\n+        Type {\n+            krate: self.id.lookup(db).container.module(db).krate,\n+            ty: InEnvironment { value: ty, environment },\n+        }\n     }\n \n     pub fn items(&self, db: &impl DefDatabase) -> Vec<AssocItem> {\n@@ -955,11 +761,11 @@ impl ImplBlock {\n     }\n \n     pub fn module(&self, db: &impl DefDatabase) -> Module {\n-        self.id.module(db).into()\n+        self.id.lookup(db).container.module(db).into()\n     }\n \n     pub fn krate(&self, db: &impl DefDatabase) -> Crate {\n-        Crate { crate_id: self.module(db).id.krate }\n+        Crate { id: self.module(db).id.krate }\n     }\n }\n \n@@ -970,15 +776,19 @@ pub struct Type {\n }\n \n impl Type {\n+    fn new(db: &impl HirDatabase, krate: CrateId, lexical_env: impl HasResolver, ty: Ty) -> Type {\n+        let resolver = lexical_env.resolver(db);\n+        let environment = TraitEnvironment::lower(db, &resolver);\n+        Type { krate, ty: InEnvironment { value: ty, environment } }\n+    }\n+\n     fn from_def(\n         db: &impl HirDatabase,\n         krate: CrateId,\n         def: impl HasResolver + Into<TyDefId>,\n     ) -> Type {\n-        let resolver = def.resolver(db);\n-        let environment = TraitEnvironment::lower(db, &resolver);\n         let ty = db.ty(def.into());\n-        Type { krate, ty: InEnvironment { value: ty, environment } }\n+        Type::new(db, krate, def, ty)\n     }\n \n     pub fn is_bool(&self) -> bool {\n@@ -1028,7 +838,7 @@ impl Type {\n     pub fn fields(&self, db: &impl HirDatabase) -> Vec<(StructField, Type)> {\n         if let Ty::Apply(a_ty) = &self.ty.value {\n             match a_ty.ctor {\n-                ty::TypeCtor::Adt(AdtId::StructId(s)) => {\n+                TypeCtor::Adt(AdtId::StructId(s)) => {\n                     let var_def = s.into();\n                     return db\n                         .field_types(var_def)\n@@ -1050,7 +860,7 @@ impl Type {\n         let mut res = Vec::new();\n         if let Ty::Apply(a_ty) = &self.ty.value {\n             match a_ty.ctor {\n-                ty::TypeCtor::Tuple { .. } => {\n+                TypeCtor::Tuple { .. } => {\n                     for ty in a_ty.parameters.iter() {\n                         let ty = ty.clone().subst(&a_ty.parameters);\n                         res.push(self.derived(ty));\n@@ -1069,22 +879,27 @@ impl Type {\n     ) -> Vec<(StructField, Type)> {\n         // FIXME: check that ty and def match\n         match &self.ty.value {\n-            Ty::Apply(a_ty) => def\n-                .fields(db)\n-                .into_iter()\n-                .map(|it| (it, self.derived(it.ty(db).subst(&a_ty.parameters))))\n-                .collect(),\n+            Ty::Apply(a_ty) => {\n+                let field_types = db.field_types(def.into());\n+                def.fields(db)\n+                    .into_iter()\n+                    .map(|it| {\n+                        let ty = field_types[it.id].clone().subst(&a_ty.parameters);\n+                        (it, self.derived(ty))\n+                    })\n+                    .collect()\n+            }\n             _ => Vec::new(),\n         }\n     }\n \n     pub fn autoderef<'a>(&'a self, db: &'a impl HirDatabase) -> impl Iterator<Item = Type> + 'a {\n         // There should be no inference vars in types passed here\n         // FIXME check that?\n-        let canonical = crate::ty::Canonical { value: self.ty.value.clone(), num_vars: 0 };\n+        let canonical = Canonical { value: self.ty.value.clone(), num_vars: 0 };\n         let environment = self.ty.environment.clone();\n         let ty = InEnvironment { value: canonical, environment: environment.clone() };\n-        ty::autoderef(db, Some(self.krate), ty)\n+        autoderef(db, Some(self.krate), ty)\n             .map(|canonical| canonical.value)\n             .map(move |ty| self.derived(ty))\n     }\n@@ -1097,7 +912,7 @@ impl Type {\n         krate: Crate,\n         mut callback: impl FnMut(AssocItem) -> Option<T>,\n     ) -> Option<T> {\n-        for krate in self.ty.value.def_crates(db, krate.crate_id)? {\n+        for krate in self.ty.value.def_crates(db, krate.id)? {\n             let impls = db.impls_in_crate(krate);\n \n             for impl_block in impls.lookup_impl_blocks(&self.ty.value) {\n@@ -1111,11 +926,6 @@ impl Type {\n         None\n     }\n \n-    // FIXME: remove\n-    pub fn into_ty(self) -> Ty {\n-        self.ty.value\n-    }\n-\n     pub fn as_adt(&self) -> Option<Adt> {\n         let (adt, _subst) = self.ty.value.as_adt()?;\n         Some(adt.into())\n@@ -1124,15 +934,14 @@ impl Type {\n     // FIXME: provide required accessors such that it becomes implementable from outside.\n     pub fn is_equal_for_find_impls(&self, other: &Type) -> bool {\n         match (&self.ty.value, &other.ty.value) {\n-            (Ty::Apply(a_original_ty), Ty::Apply(ty::ApplicationTy { ctor, parameters })) => {\n-                match ctor {\n-                    TypeCtor::Ref(..) => match parameters.as_single() {\n-                        Ty::Apply(a_ty) => a_original_ty.ctor == a_ty.ctor,\n-                        _ => false,\n-                    },\n-                    _ => a_original_ty.ctor == *ctor,\n-                }\n-            }\n+            (Ty::Apply(a_original_ty), Ty::Apply(ApplicationTy { ctor, parameters })) => match ctor\n+            {\n+                TypeCtor::Ref(..) => match parameters.as_single() {\n+                    Ty::Apply(a_ty) => a_original_ty.ctor == a_ty.ctor,\n+                    _ => false,\n+                },\n+                _ => a_original_ty.ctor == *ctor,\n+            },\n             _ => false,\n         }\n     }\n@@ -1155,7 +964,7 @@ impl HirDisplay for Type {\n pub enum ScopeDef {\n     ModuleDef(ModuleDef),\n     MacroDef(MacroDef),\n-    GenericParam(GenericParam),\n+    GenericParam(TypeParam),\n     ImplSelfType(ImplBlock),\n     AdtSelfType(Adt),\n     Local(Local),"}, {"sha": "bf3ee08341e64ccef45b7fe8ddbfc6f12b8795c5", "filename": "crates/ra_hir/src/code_model/src.rs", "status": "removed", "additions": 0, "deletions": 128, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fsrc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fsrc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fsrc.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -1,128 +0,0 @@\n-//! FIXME: write short doc here\n-\n-use hir_def::{AstItemDef, HasChildSource, HasSource as _, Lookup, VariantId};\n-use hir_expand::either::Either;\n-use ra_syntax::ast;\n-\n-use crate::{\n-    db::DefDatabase, Const, Enum, EnumVariant, FieldSource, Function, ImplBlock, Import, MacroDef,\n-    Module, ModuleSource, Static, Struct, StructField, Trait, TypeAlias, Union,\n-};\n-\n-pub use hir_expand::Source;\n-\n-pub trait HasSource {\n-    type Ast;\n-    fn source(self, db: &impl DefDatabase) -> Source<Self::Ast>;\n-}\n-\n-/// NB: Module is !HasSource, because it has two source nodes at the same time:\n-/// definition and declaration.\n-impl Module {\n-    /// Returns a node which defines this module. That is, a file or a `mod foo {}` with items.\n-    pub fn definition_source(self, db: &impl DefDatabase) -> Source<ModuleSource> {\n-        let def_map = db.crate_def_map(self.id.krate);\n-        let src = def_map[self.id.local_id].definition_source(db);\n-        src.map(|it| match it {\n-            Either::A(it) => ModuleSource::SourceFile(it),\n-            Either::B(it) => ModuleSource::Module(it),\n-        })\n-    }\n-\n-    /// Returns a node which declares this module, either a `mod foo;` or a `mod foo {}`.\n-    /// `None` for the crate root.\n-    pub fn declaration_source(self, db: &impl DefDatabase) -> Option<Source<ast::Module>> {\n-        let def_map = db.crate_def_map(self.id.krate);\n-        def_map[self.id.local_id].declaration_source(db)\n-    }\n-}\n-\n-impl HasSource for StructField {\n-    type Ast = FieldSource;\n-    fn source(self, db: &impl DefDatabase) -> Source<FieldSource> {\n-        let var = VariantId::from(self.parent);\n-        let src = var.child_source(db);\n-        src.map(|it| match it[self.id].clone() {\n-            Either::A(it) => FieldSource::Pos(it),\n-            Either::B(it) => FieldSource::Named(it),\n-        })\n-    }\n-}\n-impl HasSource for Struct {\n-    type Ast = ast::StructDef;\n-    fn source(self, db: &impl DefDatabase) -> Source<ast::StructDef> {\n-        self.id.source(db)\n-    }\n-}\n-impl HasSource for Union {\n-    type Ast = ast::UnionDef;\n-    fn source(self, db: &impl DefDatabase) -> Source<ast::UnionDef> {\n-        self.id.source(db)\n-    }\n-}\n-impl HasSource for Enum {\n-    type Ast = ast::EnumDef;\n-    fn source(self, db: &impl DefDatabase) -> Source<ast::EnumDef> {\n-        self.id.source(db)\n-    }\n-}\n-impl HasSource for EnumVariant {\n-    type Ast = ast::EnumVariant;\n-    fn source(self, db: &impl DefDatabase) -> Source<ast::EnumVariant> {\n-        self.parent.id.child_source(db).map(|map| map[self.id].clone())\n-    }\n-}\n-impl HasSource for Function {\n-    type Ast = ast::FnDef;\n-    fn source(self, db: &impl DefDatabase) -> Source<ast::FnDef> {\n-        self.id.lookup(db).source(db)\n-    }\n-}\n-impl HasSource for Const {\n-    type Ast = ast::ConstDef;\n-    fn source(self, db: &impl DefDatabase) -> Source<ast::ConstDef> {\n-        self.id.lookup(db).source(db)\n-    }\n-}\n-impl HasSource for Static {\n-    type Ast = ast::StaticDef;\n-    fn source(self, db: &impl DefDatabase) -> Source<ast::StaticDef> {\n-        self.id.lookup(db).source(db)\n-    }\n-}\n-impl HasSource for Trait {\n-    type Ast = ast::TraitDef;\n-    fn source(self, db: &impl DefDatabase) -> Source<ast::TraitDef> {\n-        self.id.source(db)\n-    }\n-}\n-impl HasSource for TypeAlias {\n-    type Ast = ast::TypeAliasDef;\n-    fn source(self, db: &impl DefDatabase) -> Source<ast::TypeAliasDef> {\n-        self.id.lookup(db).source(db)\n-    }\n-}\n-impl HasSource for MacroDef {\n-    type Ast = ast::MacroCall;\n-    fn source(self, db: &impl DefDatabase) -> Source<ast::MacroCall> {\n-        Source { file_id: self.id.ast_id.file_id(), value: self.id.ast_id.to_node(db) }\n-    }\n-}\n-impl HasSource for ImplBlock {\n-    type Ast = ast::ImplBlock;\n-    fn source(self, db: &impl DefDatabase) -> Source<ast::ImplBlock> {\n-        self.id.source(db)\n-    }\n-}\n-impl HasSource for Import {\n-    type Ast = Either<ast::UseTree, ast::ExternCrateItem>;\n-\n-    /// Returns the syntax of the last path segment corresponding to this import\n-    fn source(self, db: &impl DefDatabase) -> Source<Self::Ast> {\n-        let src = self.parent.definition_source(db);\n-        let (_, source_map) = db.raw_items_with_source_map(src.file_id);\n-        let root = db.parse_or_expand(src.file_id).unwrap();\n-        let ptr = source_map.get(self.id);\n-        src.with_value(ptr.map(|it| it.to_node(&root), |it| it.to_node(&root)))\n-    }\n-}"}, {"sha": "f5ffd64fa7b17622250d204d26ebf855fad4295b", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -4,8 +4,8 @@ pub use hir_def::db::{\n     BodyQuery, BodyWithSourceMapQuery, ConstDataQuery, CrateDefMapQuery, CrateLangItemsQuery,\n     DefDatabase, DefDatabaseStorage, DocumentationQuery, EnumDataQuery, ExprScopesQuery,\n     FunctionDataQuery, GenericParamsQuery, ImplDataQuery, InternDatabase, InternDatabaseStorage,\n-    LangItemQuery, ModuleLangItemsQuery, RawItemsQuery, RawItemsWithSourceMapQuery,\n-    StaticDataQuery, StructDataQuery, TraitDataQuery, TypeAliasDataQuery,\n+    LangItemQuery, ModuleLangItemsQuery, RawItemsQuery, StaticDataQuery, StructDataQuery,\n+    TraitDataQuery, TypeAliasDataQuery,\n };\n pub use hir_expand::db::{\n     AstDatabase, AstDatabaseStorage, AstIdMapQuery, MacroArgQuery, MacroDefQuery, MacroExpandQuery,"}, {"sha": "7a2810f71aff1d227b197fdc908bfd666dfecf90", "filename": "crates/ra_hir/src/debug.rs", "status": "removed", "additions": 0, "deletions": 94, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir%2Fsrc%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir%2Fsrc%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdebug.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -1,94 +0,0 @@\n-//! XXX: This does not work at the moment.\n-//!\n-//! printf debugging infrastructure for rust-analyzer.\n-//!\n-//! When you print a hir type, like a module, using `eprintln!(\"{:?}\", module)`,\n-//! you usually get back a numeric ID, which doesn't tell you much:\n-//! `Module(92)`.\n-//!\n-//! This module adds convenience `debug` methods to various types, which resolve\n-//! the id to a human-readable location info:\n-//!\n-//! ```not_rust\n-//! eprintln!(\"{:?}\", module.debug(db));\n-//! =>\n-//! Module { name: collections, path: \"liballoc/collections/mod.rs\" }\n-//! ```\n-//!\n-//! Note that to get this info, we might need to execute queries! So\n-//!\n-//! * don't use the `debug` methods for logging\n-//! * when debugging, be aware that interference is possible.\n-\n-use std::fmt;\n-\n-use hir_expand::HirFileId;\n-use ra_db::{CrateId, FileId};\n-\n-use crate::{db::HirDatabase, Crate, Module, Name};\n-\n-impl Crate {\n-    pub fn debug(self, db: &impl HirDebugDatabase) -> impl fmt::Debug + '_ {\n-        debug_fn(move |fmt| db.debug_crate(self, fmt))\n-    }\n-}\n-\n-impl Module {\n-    pub fn debug(self, db: &impl HirDebugDatabase) -> impl fmt::Debug + '_ {\n-        debug_fn(move |fmt| db.debug_module(self, fmt))\n-    }\n-}\n-\n-pub trait HirDebugHelper: HirDatabase {\n-    fn crate_name(&self, _krate: CrateId) -> Option<String> {\n-        None\n-    }\n-    fn file_path(&self, _file_id: FileId) -> Option<String> {\n-        None\n-    }\n-}\n-\n-pub trait HirDebugDatabase {\n-    fn debug_crate(&self, krate: Crate, fmt: &mut fmt::Formatter<'_>) -> fmt::Result;\n-    fn debug_module(&self, module: Module, fmt: &mut fmt::Formatter<'_>) -> fmt::Result;\n-    fn debug_hir_file_id(&self, file_id: HirFileId, fmt: &mut fmt::Formatter<'_>) -> fmt::Result;\n-}\n-\n-impl<DB: HirDebugHelper> HirDebugDatabase for DB {\n-    fn debug_crate(&self, krate: Crate, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let mut builder = fmt.debug_tuple(\"Crate\");\n-        match self.crate_name(krate.crate_id) {\n-            Some(name) => builder.field(&name),\n-            None => builder.field(&krate.crate_id),\n-        }\n-        .finish()\n-    }\n-\n-    fn debug_module(&self, module: Module, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let file_id = module.definition_source(self).file_id.original_file(self);\n-        let path = self.file_path(file_id).unwrap_or_else(|| \"N/A\".to_string());\n-        fmt.debug_struct(\"Module\")\n-            .field(\"name\", &module.name(self).unwrap_or_else(Name::missing))\n-            .field(\"path\", &path)\n-            .finish()\n-    }\n-\n-    fn debug_hir_file_id(&self, file_id: HirFileId, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let original = file_id.original_file(self);\n-        let path = self.file_path(original).unwrap_or_else(|| \"N/A\".to_string());\n-        let is_macro = file_id != original.into();\n-        fmt.debug_struct(\"HirFileId\").field(\"path\", &path).field(\"macro\", &is_macro).finish()\n-    }\n-}\n-\n-fn debug_fn(f: impl Fn(&mut fmt::Formatter<'_>) -> fmt::Result) -> impl fmt::Debug {\n-    struct DebugFn<F>(F);\n-\n-    impl<F: Fn(&mut fmt::Formatter<'_>) -> fmt::Result> fmt::Debug for DebugFn<F> {\n-        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-            (&self.0)(fmt)\n-        }\n-    }\n-\n-    DebugFn(f)\n-}"}, {"sha": "75a1a77722102e94893af81f4f4f33adc1e35882", "filename": "crates/ra_hir/src/from_id.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -9,27 +9,27 @@ use hir_def::{\n };\n \n use crate::{\n-    Adt, AssocItem, AttrDef, Crate, DefWithBody, EnumVariant, GenericDef, ModuleDef, StructField,\n+    Adt, AssocItem, AttrDef, DefWithBody, EnumVariant, GenericDef, ModuleDef, StructField,\n     VariantDef,\n };\n \n-impl From<ra_db::CrateId> for Crate {\n-    fn from(crate_id: ra_db::CrateId) -> Self {\n-        Crate { crate_id }\n-    }\n-}\n-\n macro_rules! from_id {\n     ($(($id:path, $ty:path)),*) => {$(\n         impl From<$id> for $ty {\n             fn from(id: $id) -> $ty {\n                 $ty { id }\n             }\n         }\n+        impl From<$ty> for $id {\n+            fn from(ty: $ty) -> $id {\n+                ty.id\n+            }\n+        }\n     )*}\n }\n \n from_id![\n+    (ra_db::CrateId, crate::Crate),\n     (hir_def::ModuleId, crate::Module),\n     (hir_def::StructId, crate::Struct),\n     (hir_def::UnionId, crate::Union),"}, {"sha": "6314be8d4c68fee9f62acfcd5da125dee4ec5462", "filename": "crates/ra_hir/src/from_source.rs", "status": "modified", "additions": 150, "deletions": 212, "changes": 362, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -1,219 +1,140 @@\n-//! FIXME: write short doc here\n+//! Finds a corresponding hir data structure for a syntax node in a specific\n+//! file.\n \n-use hir_def::{AstItemDef, LocationCtx, ModuleId};\n+use hir_def::{\n+    child_by_source::ChildBySource, dyn_map::DynMap, keys, keys::Key, nameres::ModuleSource,\n+    ConstId, DefWithBodyId, EnumId, EnumVariantId, FunctionId, GenericDefId, ImplId, ModuleId,\n+    StaticId, StructId, TraitId, TypeAliasId, UnionId, VariantId,\n+};\n use hir_expand::{name::AsName, AstId, MacroDefId, MacroDefKind};\n+use ra_db::FileId;\n+use ra_prof::profile;\n use ra_syntax::{\n     ast::{self, AstNode, NameOwner},\n-    match_ast, AstPtr, SyntaxNode,\n+    match_ast, SyntaxNode,\n };\n \n use crate::{\n-    db::{AstDatabase, DefDatabase, HirDatabase},\n-    AssocItem, Const, DefWithBody, Enum, EnumVariant, FieldSource, Function, HasSource, ImplBlock,\n-    Local, MacroDef, Module, ModuleDef, ModuleSource, Source, Static, Struct, StructField, Trait,\n-    TypeAlias, Union, VariantDef,\n+    db::{DefDatabase, HirDatabase},\n+    Const, DefWithBody, Enum, EnumVariant, FieldSource, Function, ImplBlock, InFile, Local,\n+    MacroDef, Module, Static, Struct, StructField, Trait, TypeAlias, TypeParam, Union,\n };\n \n pub trait FromSource: Sized {\n     type Ast;\n-    fn from_source(db: &(impl DefDatabase + AstDatabase), src: Source<Self::Ast>) -> Option<Self>;\n+    fn from_source(db: &impl DefDatabase, src: InFile<Self::Ast>) -> Option<Self>;\n }\n \n-impl FromSource for Struct {\n-    type Ast = ast::StructDef;\n-    fn from_source(db: &(impl DefDatabase + AstDatabase), src: Source<Self::Ast>) -> Option<Self> {\n-        let id = from_source(db, src)?;\n-        Some(Struct { id })\n-    }\n-}\n-impl FromSource for Union {\n-    type Ast = ast::UnionDef;\n-    fn from_source(db: &(impl DefDatabase + AstDatabase), src: Source<Self::Ast>) -> Option<Self> {\n-        let id = from_source(db, src)?;\n-        Some(Union { id })\n-    }\n-}\n-impl FromSource for Enum {\n-    type Ast = ast::EnumDef;\n-    fn from_source(db: &(impl DefDatabase + AstDatabase), src: Source<Self::Ast>) -> Option<Self> {\n-        let id = from_source(db, src)?;\n-        Some(Enum { id })\n-    }\n-}\n-impl FromSource for Trait {\n-    type Ast = ast::TraitDef;\n-    fn from_source(db: &(impl DefDatabase + AstDatabase), src: Source<Self::Ast>) -> Option<Self> {\n-        let id = from_source(db, src)?;\n-        Some(Trait { id })\n-    }\n-}\n-impl FromSource for Function {\n-    type Ast = ast::FnDef;\n-    fn from_source(db: &(impl DefDatabase + AstDatabase), src: Source<Self::Ast>) -> Option<Self> {\n-        let items = match Container::find(db, src.as_ref().map(|it| it.syntax()))? {\n-            Container::Trait(it) => it.items(db),\n-            Container::ImplBlock(it) => it.items(db),\n-            Container::Module(m) => {\n-                return m\n-                    .declarations(db)\n-                    .into_iter()\n-                    .filter_map(|it| match it {\n-                        ModuleDef::Function(it) => Some(it),\n-                        _ => None,\n-                    })\n-                    .find(|it| same_source(&it.source(db), &src))\n-            }\n-        };\n-        items\n-            .into_iter()\n-            .filter_map(|it| match it {\n-                AssocItem::Function(it) => Some(it),\n-                _ => None,\n-            })\n-            .find(|it| same_source(&it.source(db), &src))\n-    }\n+pub trait FromSourceByContainer: Sized {\n+    type Ast: AstNode + 'static;\n+    type Id: Copy + 'static;\n+    const KEY: Key<Self::Ast, Self::Id>;\n }\n \n-impl FromSource for Const {\n-    type Ast = ast::ConstDef;\n-    fn from_source(db: &(impl DefDatabase + AstDatabase), src: Source<Self::Ast>) -> Option<Self> {\n-        let items = match Container::find(db, src.as_ref().map(|it| it.syntax()))? {\n-            Container::Trait(it) => it.items(db),\n-            Container::ImplBlock(it) => it.items(db),\n-            Container::Module(m) => {\n-                return m\n-                    .declarations(db)\n-                    .into_iter()\n-                    .filter_map(|it| match it {\n-                        ModuleDef::Const(it) => Some(it),\n-                        _ => None,\n-                    })\n-                    .find(|it| same_source(&it.source(db), &src))\n-            }\n-        };\n-        items\n-            .into_iter()\n-            .filter_map(|it| match it {\n-                AssocItem::Const(it) => Some(it),\n-                _ => None,\n-            })\n-            .find(|it| same_source(&it.source(db), &src))\n-    }\n-}\n-impl FromSource for Static {\n-    type Ast = ast::StaticDef;\n-    fn from_source(db: &(impl DefDatabase + AstDatabase), src: Source<Self::Ast>) -> Option<Self> {\n-        let module = match Container::find(db, src.as_ref().map(|it| it.syntax()))? {\n-            Container::Module(it) => it,\n-            Container::Trait(_) | Container::ImplBlock(_) => return None,\n-        };\n-        module\n-            .declarations(db)\n-            .into_iter()\n-            .filter_map(|it| match it {\n-                ModuleDef::Static(it) => Some(it),\n-                _ => None,\n-            })\n-            .find(|it| same_source(&it.source(db), &src))\n+impl<T: FromSourceByContainer> FromSource for T\n+where\n+    T: From<<T as FromSourceByContainer>::Id>,\n+{\n+    type Ast = <T as FromSourceByContainer>::Ast;\n+    fn from_source(db: &impl DefDatabase, src: InFile<Self::Ast>) -> Option<Self> {\n+        analyze_container(db, src.as_ref().map(|it| it.syntax()))[T::KEY]\n+            .get(&src)\n+            .copied()\n+            .map(Self::from)\n     }\n }\n \n-impl FromSource for TypeAlias {\n-    type Ast = ast::TypeAliasDef;\n-    fn from_source(db: &(impl DefDatabase + AstDatabase), src: Source<Self::Ast>) -> Option<Self> {\n-        let items = match Container::find(db, src.as_ref().map(|it| it.syntax()))? {\n-            Container::Trait(it) => it.items(db),\n-            Container::ImplBlock(it) => it.items(db),\n-            Container::Module(m) => {\n-                return m\n-                    .declarations(db)\n-                    .into_iter()\n-                    .filter_map(|it| match it {\n-                        ModuleDef::TypeAlias(it) => Some(it),\n-                        _ => None,\n-                    })\n-                    .find(|it| same_source(&it.source(db), &src))\n-            }\n-        };\n-        items\n-            .into_iter()\n-            .filter_map(|it| match it {\n-                AssocItem::TypeAlias(it) => Some(it),\n-                _ => None,\n-            })\n-            .find(|it| same_source(&it.source(db), &src))\n-    }\n+macro_rules! from_source_by_container_impls {\n+    ($(($hir:ident, $id:ident, $ast:path, $key:path)),* ,) => {$(\n+        impl FromSourceByContainer for $hir {\n+            type Ast = $ast;\n+            type Id = $id;\n+            const KEY: Key<Self::Ast, Self::Id> = $key;\n+        }\n+    )*}\n }\n \n+from_source_by_container_impls![\n+    (Struct, StructId, ast::StructDef, keys::STRUCT),\n+    (Union, UnionId, ast::UnionDef, keys::UNION),\n+    (Enum, EnumId, ast::EnumDef, keys::ENUM),\n+    (Trait, TraitId, ast::TraitDef, keys::TRAIT),\n+    (Function, FunctionId, ast::FnDef, keys::FUNCTION),\n+    (Static, StaticId, ast::StaticDef, keys::STATIC),\n+    (Const, ConstId, ast::ConstDef, keys::CONST),\n+    (TypeAlias, TypeAliasId, ast::TypeAliasDef, keys::TYPE_ALIAS),\n+    (ImplBlock, ImplId, ast::ImplBlock, keys::IMPL),\n+];\n+\n impl FromSource for MacroDef {\n     type Ast = ast::MacroCall;\n-    fn from_source(db: &(impl DefDatabase + AstDatabase), src: Source<Self::Ast>) -> Option<Self> {\n+    fn from_source(db: &impl DefDatabase, src: InFile<Self::Ast>) -> Option<Self> {\n         let kind = MacroDefKind::Declarative;\n \n         let module_src = ModuleSource::from_child_node(db, src.as_ref().map(|it| it.syntax()));\n-        let module = Module::from_definition(db, Source::new(src.file_id, module_src))?;\n-        let krate = module.krate().crate_id();\n+        let module = Module::from_definition(db, InFile::new(src.file_id, module_src))?;\n+        let krate = Some(module.krate().id);\n \n-        let ast_id = AstId::new(src.file_id, db.ast_id_map(src.file_id).ast_id(&src.value));\n+        let ast_id = Some(AstId::new(src.file_id, db.ast_id_map(src.file_id).ast_id(&src.value)));\n \n         let id: MacroDefId = MacroDefId { krate, ast_id, kind };\n         Some(MacroDef { id })\n     }\n }\n \n-impl FromSource for ImplBlock {\n-    type Ast = ast::ImplBlock;\n-    fn from_source(db: &(impl DefDatabase + AstDatabase), src: Source<Self::Ast>) -> Option<Self> {\n-        let id = from_source(db, src)?;\n-        Some(ImplBlock { id })\n-    }\n-}\n-\n impl FromSource for EnumVariant {\n     type Ast = ast::EnumVariant;\n-    fn from_source(db: &(impl DefDatabase + AstDatabase), src: Source<Self::Ast>) -> Option<Self> {\n+    fn from_source(db: &impl DefDatabase, src: InFile<Self::Ast>) -> Option<Self> {\n         let parent_enum = src.value.parent_enum();\n-        let src_enum = Source { file_id: src.file_id, value: parent_enum };\n-        let variants = Enum::from_source(db, src_enum)?.variants(db);\n-        variants.into_iter().find(|v| same_source(&v.source(db), &src))\n+        let src_enum = InFile { file_id: src.file_id, value: parent_enum };\n+        let parent_enum = Enum::from_source(db, src_enum)?;\n+        parent_enum.id.child_by_source(db)[keys::ENUM_VARIANT]\n+            .get(&src)\n+            .copied()\n+            .map(EnumVariant::from)\n     }\n }\n \n impl FromSource for StructField {\n     type Ast = FieldSource;\n-    fn from_source(db: &(impl DefDatabase + AstDatabase), src: Source<Self::Ast>) -> Option<Self> {\n-        let variant_def: VariantDef = match src.value {\n-            FieldSource::Named(ref field) => {\n+    fn from_source(db: &impl DefDatabase, src: InFile<Self::Ast>) -> Option<Self> {\n+        let src = src.as_ref();\n+\n+        // FIXME this is buggy\n+        let variant_id: VariantId = match src.value {\n+            FieldSource::Named(field) => {\n                 let value = field.syntax().ancestors().find_map(ast::StructDef::cast)?;\n-                let src = Source { file_id: src.file_id, value };\n+                let src = InFile { file_id: src.file_id, value };\n                 let def = Struct::from_source(db, src)?;\n-                VariantDef::from(def)\n+                def.id.into()\n             }\n-            FieldSource::Pos(ref field) => {\n+            FieldSource::Pos(field) => {\n                 let value = field.syntax().ancestors().find_map(ast::EnumVariant::cast)?;\n-                let src = Source { file_id: src.file_id, value };\n+                let src = InFile { file_id: src.file_id, value };\n                 let def = EnumVariant::from_source(db, src)?;\n-                VariantDef::from(def)\n+                EnumVariantId::from(def).into()\n             }\n         };\n-        variant_def\n-            .variant_data(db)\n-            .fields()\n-            .iter()\n-            .map(|(id, _)| StructField { parent: variant_def, id })\n-            .find(|f| f.source(db) == src)\n+\n+        let dyn_map = variant_id.child_by_source(db);\n+        match src.value {\n+            FieldSource::Pos(it) => dyn_map[keys::TUPLE_FIELD].get(&src.with_value(it.clone())),\n+            FieldSource::Named(it) => dyn_map[keys::RECORD_FIELD].get(&src.with_value(it.clone())),\n+        }\n+        .copied()\n+        .map(StructField::from)\n     }\n }\n \n impl Local {\n-    pub fn from_source(db: &impl HirDatabase, src: Source<ast::BindPat>) -> Option<Self> {\n+    pub fn from_source(db: &impl HirDatabase, src: InFile<ast::BindPat>) -> Option<Self> {\n         let file_id = src.file_id;\n         let parent: DefWithBody = src.value.syntax().ancestors().find_map(|it| {\n             let res = match_ast! {\n                 match it {\n-                    ast::ConstDef(value) => { Const::from_source(db, Source { value, file_id})?.into() },\n-                    ast::StaticDef(value) => { Static::from_source(db, Source { value, file_id})?.into() },\n-                    ast::FnDef(value) => { Function::from_source(db, Source { value, file_id})?.into() },\n+                    ast::ConstDef(value) => { Const::from_source(db, InFile { value, file_id})?.into() },\n+                    ast::StaticDef(value) => { Static::from_source(db, InFile { value, file_id})?.into() },\n+                    ast::FnDef(value) => { Function::from_source(db, InFile { value, file_id})?.into() },\n                     _ => return None,\n                 }\n             };\n@@ -226,84 +147,111 @@ impl Local {\n     }\n }\n \n+impl TypeParam {\n+    pub fn from_source(db: &impl HirDatabase, src: InFile<ast::TypeParam>) -> Option<Self> {\n+        let file_id = src.file_id;\n+        let parent: GenericDefId = src.value.syntax().ancestors().find_map(|it| {\n+            let res = match_ast! {\n+                match it {\n+                    ast::FnDef(value) => { Function::from_source(db, InFile { value, file_id})?.id.into() },\n+                    ast::StructDef(value) => { Struct::from_source(db, InFile { value, file_id})?.id.into() },\n+                    ast::EnumDef(value) => { Enum::from_source(db, InFile { value, file_id})?.id.into() },\n+                    ast::TraitDef(value) => { Trait::from_source(db, InFile { value, file_id})?.id.into() },\n+                    ast::TypeAliasDef(value) => { TypeAlias::from_source(db, InFile { value, file_id})?.id.into() },\n+                    ast::ImplBlock(value) => { ImplBlock::from_source(db, InFile { value, file_id})?.id.into() },\n+                    _ => return None,\n+                }\n+            };\n+            Some(res)\n+        })?;\n+        let &id = parent.child_by_source(db)[keys::TYPE_PARAM].get(&src)?;\n+        Some(TypeParam { id })\n+    }\n+}\n+\n impl Module {\n-    pub fn from_declaration(db: &impl DefDatabase, src: Source<ast::Module>) -> Option<Self> {\n+    pub fn from_declaration(db: &impl DefDatabase, src: InFile<ast::Module>) -> Option<Self> {\n+        let _p = profile(\"Module::from_declaration\");\n         let parent_declaration = src.value.syntax().ancestors().skip(1).find_map(ast::Module::cast);\n \n         let parent_module = match parent_declaration {\n             Some(parent_declaration) => {\n-                let src_parent = Source { file_id: src.file_id, value: parent_declaration };\n+                let src_parent = InFile { file_id: src.file_id, value: parent_declaration };\n                 Module::from_declaration(db, src_parent)\n             }\n-            _ => {\n-                let src_parent = Source {\n-                    file_id: src.file_id,\n-                    value: ModuleSource::new(db, Some(src.file_id.original_file(db)), None),\n-                };\n+            None => {\n+                let source_file = db.parse(src.file_id.original_file(db)).tree();\n+                let src_parent =\n+                    InFile { file_id: src.file_id, value: ModuleSource::SourceFile(source_file) };\n                 Module::from_definition(db, src_parent)\n             }\n         }?;\n \n-        let child_name = src.value.name()?;\n-        parent_module.child(db, &child_name.as_name())\n+        let child_name = src.value.name()?.as_name();\n+        let def_map = db.crate_def_map(parent_module.id.krate);\n+        let child_id = def_map[parent_module.id.local_id].children.get(&child_name)?;\n+        Some(parent_module.with_module_id(*child_id))\n     }\n \n-    pub fn from_definition(db: &impl DefDatabase, src: Source<ModuleSource>) -> Option<Self> {\n+    pub fn from_definition(db: &impl DefDatabase, src: InFile<ModuleSource>) -> Option<Self> {\n+        let _p = profile(\"Module::from_definition\");\n         match src.value {\n             ModuleSource::Module(ref module) => {\n                 assert!(!module.has_semi());\n                 return Module::from_declaration(\n                     db,\n-                    Source { file_id: src.file_id, value: module.clone() },\n+                    InFile { file_id: src.file_id, value: module.clone() },\n                 );\n             }\n             ModuleSource::SourceFile(_) => (),\n         };\n \n         let original_file = src.file_id.original_file(db);\n+        Module::from_file(db, original_file)\n+    }\n \n-        let (krate, local_id) = db.relevant_crates(original_file).iter().find_map(|&crate_id| {\n+    fn from_file(db: &impl DefDatabase, file: FileId) -> Option<Self> {\n+        let _p = profile(\"Module::from_file\");\n+        let (krate, local_id) = db.relevant_crates(file).iter().find_map(|&crate_id| {\n             let crate_def_map = db.crate_def_map(crate_id);\n-            let local_id = crate_def_map.modules_for_file(original_file).next()?;\n+            let local_id = crate_def_map.modules_for_file(file).next()?;\n             Some((crate_id, local_id))\n         })?;\n         Some(Module { id: ModuleId { krate, local_id } })\n     }\n }\n \n-fn from_source<N, DEF>(db: &(impl DefDatabase + AstDatabase), src: Source<N>) -> Option<DEF>\n-where\n-    N: AstNode,\n-    DEF: AstItemDef<N>,\n-{\n-    let module_src = ModuleSource::from_child_node(db, src.as_ref().map(|it| it.syntax()));\n-    let module = Module::from_definition(db, Source::new(src.file_id, module_src))?;\n-    let ctx = LocationCtx::new(db, module.id, src.file_id);\n-    let items = db.ast_id_map(src.file_id);\n-    let item_id = items.ast_id(&src.value);\n-    Some(DEF::from_ast_id(ctx, item_id))\n-}\n-\n-enum Container {\n-    Trait(Trait),\n-    ImplBlock(ImplBlock),\n-    Module(Module),\n-}\n+fn analyze_container(db: &impl DefDatabase, src: InFile<&SyntaxNode>) -> DynMap {\n+    let _p = profile(\"analyze_container\");\n+    return child_by_source(db, src).unwrap_or_default();\n \n-impl Container {\n-    fn find(db: &impl DefDatabase, src: Source<&SyntaxNode>) -> Option<Container> {\n-        // FIXME: this doesn't try to handle nested declarations\n-        for container in src.value.ancestors() {\n+    fn child_by_source(db: &impl DefDatabase, src: InFile<&SyntaxNode>) -> Option<DynMap> {\n+        for container in src.value.ancestors().skip(1) {\n             let res = match_ast! {\n                 match container {\n                     ast::TraitDef(it) => {\n-                        let c = Trait::from_source(db, src.with_value(it))?;\n-                        Container::Trait(c)\n+                        let def = Trait::from_source(db, src.with_value(it))?;\n+                        def.id.child_by_source(db)\n                     },\n                     ast::ImplBlock(it) => {\n-                        let c = ImplBlock::from_source(db, src.with_value(it))?;\n-                        Container::ImplBlock(c)\n-                     },\n+                        let def = ImplBlock::from_source(db, src.with_value(it))?;\n+                        def.id.child_by_source(db)\n+                    },\n+                    ast::FnDef(it) => {\n+                        let def = Function::from_source(db, src.with_value(it))?;\n+                        DefWithBodyId::from(def.id)\n+                            .child_by_source(db)\n+                    },\n+                    ast::StaticDef(it) => {\n+                        let def = Static::from_source(db, src.with_value(it))?;\n+                        DefWithBodyId::from(def.id)\n+                            .child_by_source(db)\n+                    },\n+                    ast::ConstDef(it) => {\n+                        let def = Const::from_source(db, src.with_value(it))?;\n+                        DefWithBodyId::from(def.id)\n+                            .child_by_source(db)\n+                    },\n                     _ => { continue },\n                 }\n             };\n@@ -312,16 +260,6 @@ impl Container {\n \n         let module_source = ModuleSource::from_child_node(db, src);\n         let c = Module::from_definition(db, src.with_value(module_source))?;\n-        Some(Container::Module(c))\n+        Some(c.id.child_by_source(db))\n     }\n }\n-\n-/// XXX: AST Nodes and SyntaxNodes have identity equality semantics: nodes are\n-/// equal if they point to exactly the same object.\n-///\n-/// In general, we do not guarantee that we have exactly one instance of a\n-/// syntax tree for each file. We probably should add such guarantee, but, for\n-/// the time being, we will use identity-less AstPtr comparison.\n-fn same_source<N: AstNode>(s1: &Source<N>, s2: &Source<N>) -> bool {\n-    s1.as_ref().map(AstPtr::new) == s2.as_ref().map(AstPtr::new)\n-}"}, {"sha": "5541266e2b1e0f534909313d9d630ee7c1b71087", "filename": "crates/ra_hir/src/has_source.rs", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir%2Fsrc%2Fhas_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir%2Fsrc%2Fhas_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fhas_source.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -0,0 +1,127 @@\n+//! FIXME: write short doc here\n+\n+use either::Either;\n+use hir_def::{\n+    nameres::ModuleSource,\n+    src::{HasChildSource, HasSource as _},\n+    Lookup, VariantId,\n+};\n+use ra_syntax::ast;\n+\n+use crate::{\n+    db::DefDatabase, Const, Enum, EnumVariant, FieldSource, Function, ImplBlock, MacroDef, Module,\n+    Static, Struct, StructField, Trait, TypeAlias, TypeParam, Union,\n+};\n+\n+pub use hir_expand::InFile;\n+\n+pub trait HasSource {\n+    type Ast;\n+    fn source(self, db: &impl DefDatabase) -> InFile<Self::Ast>;\n+}\n+\n+/// NB: Module is !HasSource, because it has two source nodes at the same time:\n+/// definition and declaration.\n+impl Module {\n+    /// Returns a node which defines this module. That is, a file or a `mod foo {}` with items.\n+    pub fn definition_source(self, db: &impl DefDatabase) -> InFile<ModuleSource> {\n+        let def_map = db.crate_def_map(self.id.krate);\n+        def_map[self.id.local_id].definition_source(db)\n+    }\n+\n+    /// Returns a node which declares this module, either a `mod foo;` or a `mod foo {}`.\n+    /// `None` for the crate root.\n+    pub fn declaration_source(self, db: &impl DefDatabase) -> Option<InFile<ast::Module>> {\n+        let def_map = db.crate_def_map(self.id.krate);\n+        def_map[self.id.local_id].declaration_source(db)\n+    }\n+}\n+\n+impl HasSource for StructField {\n+    type Ast = FieldSource;\n+    fn source(self, db: &impl DefDatabase) -> InFile<FieldSource> {\n+        let var = VariantId::from(self.parent);\n+        let src = var.child_source(db);\n+        src.map(|it| match it[self.id].clone() {\n+            Either::Left(it) => FieldSource::Pos(it),\n+            Either::Right(it) => FieldSource::Named(it),\n+        })\n+    }\n+}\n+impl HasSource for Struct {\n+    type Ast = ast::StructDef;\n+    fn source(self, db: &impl DefDatabase) -> InFile<ast::StructDef> {\n+        self.id.lookup(db).source(db)\n+    }\n+}\n+impl HasSource for Union {\n+    type Ast = ast::UnionDef;\n+    fn source(self, db: &impl DefDatabase) -> InFile<ast::UnionDef> {\n+        self.id.lookup(db).source(db)\n+    }\n+}\n+impl HasSource for Enum {\n+    type Ast = ast::EnumDef;\n+    fn source(self, db: &impl DefDatabase) -> InFile<ast::EnumDef> {\n+        self.id.lookup(db).source(db)\n+    }\n+}\n+impl HasSource for EnumVariant {\n+    type Ast = ast::EnumVariant;\n+    fn source(self, db: &impl DefDatabase) -> InFile<ast::EnumVariant> {\n+        self.parent.id.child_source(db).map(|map| map[self.id].clone())\n+    }\n+}\n+impl HasSource for Function {\n+    type Ast = ast::FnDef;\n+    fn source(self, db: &impl DefDatabase) -> InFile<ast::FnDef> {\n+        self.id.lookup(db).source(db)\n+    }\n+}\n+impl HasSource for Const {\n+    type Ast = ast::ConstDef;\n+    fn source(self, db: &impl DefDatabase) -> InFile<ast::ConstDef> {\n+        self.id.lookup(db).source(db)\n+    }\n+}\n+impl HasSource for Static {\n+    type Ast = ast::StaticDef;\n+    fn source(self, db: &impl DefDatabase) -> InFile<ast::StaticDef> {\n+        self.id.lookup(db).source(db)\n+    }\n+}\n+impl HasSource for Trait {\n+    type Ast = ast::TraitDef;\n+    fn source(self, db: &impl DefDatabase) -> InFile<ast::TraitDef> {\n+        self.id.lookup(db).source(db)\n+    }\n+}\n+impl HasSource for TypeAlias {\n+    type Ast = ast::TypeAliasDef;\n+    fn source(self, db: &impl DefDatabase) -> InFile<ast::TypeAliasDef> {\n+        self.id.lookup(db).source(db)\n+    }\n+}\n+impl HasSource for MacroDef {\n+    type Ast = ast::MacroCall;\n+    fn source(self, db: &impl DefDatabase) -> InFile<ast::MacroCall> {\n+        InFile {\n+            file_id: self.id.ast_id.expect(\"MacroDef without ast_id\").file_id,\n+            value: self.id.ast_id.expect(\"MacroDef without ast_id\").to_node(db),\n+        }\n+    }\n+}\n+impl HasSource for ImplBlock {\n+    type Ast = ast::ImplBlock;\n+    fn source(self, db: &impl DefDatabase) -> InFile<ast::ImplBlock> {\n+        self.id.lookup(db).source(db)\n+    }\n+}\n+\n+impl HasSource for TypeParam {\n+    type Ast = Either<ast::TraitDef, ast::TypeParam>;\n+    fn source(self, db: &impl DefDatabase) -> InFile<Self::Ast> {\n+        let child_source = self.id.parent.child_source(db);\n+        child_source.map(|it| it[self.id.local_id].clone())\n+    }\n+}"}, {"sha": "0008a8858fc44a45813fe5f96830c90594c2c6c4", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -26,42 +26,38 @@ macro_rules! impl_froms {\n     }\n }\n \n-pub mod debug;\n-\n pub mod db;\n pub mod source_binder;\n \n-mod ty;\n pub mod diagnostics;\n \n mod from_id;\n mod code_model;\n \n-pub mod from_source;\n+mod has_source;\n+mod from_source;\n \n pub use crate::{\n     code_model::{\n-        src::HasSource, Adt, AssocItem, AttrDef, Const, Container, Crate, CrateDependency,\n-        DefWithBody, Docs, Enum, EnumVariant, FieldSource, Function, GenericDef, GenericParam,\n-        HasAttrs, ImplBlock, Import, Local, MacroDef, Module, ModuleDef, ModuleSource, ScopeDef,\n-        Static, Struct, StructField, Trait, Type, TypeAlias, Union, VariantDef,\n+        Adt, AssocItem, AttrDef, Const, Crate, CrateDependency, DefWithBody, Docs, Enum,\n+        EnumVariant, FieldSource, Function, GenericDef, HasAttrs, ImplBlock, Local, MacroDef,\n+        Module, ModuleDef, ScopeDef, Static, Struct, StructField, Trait, Type, TypeAlias,\n+        TypeParam, Union, VariantDef,\n     },\n     from_source::FromSource,\n+    has_source::HasSource,\n     source_binder::{PathResolution, ScopeEntryWithSyntax, SourceAnalyzer},\n-    ty::{\n-        display::HirDisplay,\n-        primitive::{FloatBitness, FloatTy, IntBitness, IntTy, Signedness, Uncertain},\n-        ApplicationTy, CallableDef, Substs, TraitRef, Ty, TypeCtor, TypeWalk,\n-    },\n };\n \n pub use hir_def::{\n     body::scope::ExprScopes,\n     builtin_type::BuiltinType,\n     docs::Documentation,\n-    path::{Path, PathKind},\n+    nameres::ModuleSource,\n+    path::{ModPath, Path, PathKind},\n     type_ref::Mutability,\n };\n pub use hir_expand::{\n-    either::Either, name::Name, HirFileId, MacroCallId, MacroCallLoc, MacroDefId, MacroFile, Source,\n+    name::Name, HirFileId, InFile, MacroCallId, MacroCallLoc, MacroDefId, MacroFile, Origin,\n };\n+pub use hir_ty::{display::HirDisplay, CallableDef};"}, {"sha": "85b378483c65540003c3a454c2695871b26c605e", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 90, "deletions": 123, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -7,19 +7,26 @@\n //! purely for \"IDE needs\".\n use std::sync::Arc;\n \n+use either::Either;\n use hir_def::{\n     body::{\n         scope::{ExprScopes, ScopeId},\n         BodySourceMap,\n     },\n     expr::{ExprId, PatId},\n-    path::known,\n+    nameres::ModuleSource,\n+    path::path,\n     resolver::{self, resolver_for_scope, HasResolver, Resolver, TypeNs, ValueNs},\n     AssocItemId, DefWithBodyId,\n };\n use hir_expand::{\n-    hygiene::Hygiene, name::AsName, AstId, HirFileId, MacroCallId, MacroFileKind, Source,\n+    hygiene::Hygiene, name::AsName, AstId, HirFileId, InFile, MacroCallId, MacroCallKind,\n };\n+use hir_ty::{\n+    method_resolution::{self, implements_trait},\n+    Canonical, InEnvironment, InferenceResult, TraitEnvironment, Ty,\n+};\n+use ra_prof::profile;\n use ra_syntax::{\n     ast::{self, AstNode},\n     match_ast, AstPtr,\n@@ -28,24 +35,20 @@ use ra_syntax::{\n };\n \n use crate::{\n-    db::HirDatabase,\n-    ty::{\n-        method_resolution::{self, implements_trait},\n-        InEnvironment, TraitEnvironment, Ty,\n-    },\n-    Adt, AssocItem, Const, DefWithBody, Either, Enum, EnumVariant, FromSource, Function,\n-    GenericParam, Local, MacroDef, Name, Path, ScopeDef, Static, Struct, Trait, Type, TypeAlias,\n+    db::HirDatabase, Adt, AssocItem, Const, DefWithBody, Enum, EnumVariant, FromSource, Function,\n+    ImplBlock, Local, MacroDef, Name, Path, ScopeDef, Static, Struct, Trait, Type, TypeAlias,\n+    TypeParam,\n };\n \n-fn try_get_resolver_for_node(db: &impl HirDatabase, node: Source<&SyntaxNode>) -> Option<Resolver> {\n+fn try_get_resolver_for_node(db: &impl HirDatabase, node: InFile<&SyntaxNode>) -> Option<Resolver> {\n     match_ast! {\n         match (node.value) {\n             ast::Module(it) => {\n                 let src = node.with_value(it);\n                 Some(crate::Module::from_declaration(db, src)?.id.resolver(db))\n             },\n              ast::SourceFile(it) => {\n-                let src = node.with_value(crate::ModuleSource::SourceFile(it));\n+                let src = node.with_value(ModuleSource::SourceFile(it));\n                 Some(crate::Module::from_definition(db, src)?.id.resolver(db))\n             },\n             ast::StructDef(it) => {\n@@ -56,6 +59,14 @@ fn try_get_resolver_for_node(db: &impl HirDatabase, node: Source<&SyntaxNode>) -\n                 let src = node.with_value(it);\n                 Some(Enum::from_source(db, src)?.id.resolver(db))\n             },\n+            ast::ImplBlock(it) => {\n+                let src = node.with_value(it);\n+                Some(ImplBlock::from_source(db, src)?.id.resolver(db))\n+            },\n+            ast::TraitDef(it) => {\n+                let src = node.with_value(it);\n+                Some(Trait::from_source(db, src)?.id.resolver(db))\n+            },\n             _ => match node.value.kind() {\n                 FN_DEF | CONST_DEF | STATIC_DEF => {\n                     let def = def_with_body_from_child_node(db, node)?;\n@@ -71,14 +82,16 @@ fn try_get_resolver_for_node(db: &impl HirDatabase, node: Source<&SyntaxNode>) -\n \n fn def_with_body_from_child_node(\n     db: &impl HirDatabase,\n-    child: Source<&SyntaxNode>,\n+    child: InFile<&SyntaxNode>,\n ) -> Option<DefWithBody> {\n-    child.value.ancestors().find_map(|node| {\n+    let _p = profile(\"def_with_body_from_child_node\");\n+    child.cloned().ancestors_with_macros(db).find_map(|node| {\n+        let n = &node.value;\n         match_ast! {\n-            match node {\n-                ast::FnDef(def)  => { return Function::from_source(db, child.with_value(def)).map(DefWithBody::from); },\n-                ast::ConstDef(def) => { return Const::from_source(db, child.with_value(def)).map(DefWithBody::from); },\n-                ast::StaticDef(def) => { return Static::from_source(db, child.with_value(def)).map(DefWithBody::from); },\n+            match n {\n+                ast::FnDef(def)  => { return Function::from_source(db, node.with_value(def)).map(DefWithBody::from); },\n+                ast::ConstDef(def) => { return Const::from_source(db, node.with_value(def)).map(DefWithBody::from); },\n+                ast::StaticDef(def) => { return Static::from_source(db, node.with_value(def)).map(DefWithBody::from); },\n                 _ => { None },\n             }\n         }\n@@ -93,7 +106,7 @@ pub struct SourceAnalyzer {\n     resolver: Resolver,\n     body_owner: Option<DefWithBody>,\n     body_source_map: Option<Arc<BodySourceMap>>,\n-    infer: Option<Arc<crate::ty::InferenceResult>>,\n+    infer: Option<Arc<InferenceResult>>,\n     scopes: Option<Arc<ExprScopes>>,\n }\n \n@@ -104,7 +117,7 @@ pub enum PathResolution {\n     /// A local binding (only value namespace)\n     Local(Local),\n     /// A generic parameter\n-    GenericParam(GenericParam),\n+    TypeParam(TypeParam),\n     SelfType(crate::ImplBlock),\n     Macro(MacroDef),\n     AssocItem(crate::AssocItem),\n@@ -132,32 +145,33 @@ pub struct ReferenceDescriptor {\n     pub name: String,\n }\n \n+#[derive(Debug)]\n pub struct Expansion {\n-    macro_file_kind: MacroFileKind,\n     macro_call_id: MacroCallId,\n }\n \n impl Expansion {\n     pub fn map_token_down(\n         &self,\n         db: &impl HirDatabase,\n-        token: Source<&SyntaxToken>,\n-    ) -> Option<Source<SyntaxToken>> {\n+        token: InFile<&SyntaxToken>,\n+    ) -> Option<InFile<SyntaxToken>> {\n         let exp_info = self.file_id().expansion_info(db)?;\n         exp_info.map_token_down(token)\n     }\n \n     pub fn file_id(&self) -> HirFileId {\n-        self.macro_call_id.as_file(self.macro_file_kind)\n+        self.macro_call_id.as_file()\n     }\n }\n \n impl SourceAnalyzer {\n     pub fn new(\n         db: &impl HirDatabase,\n-        node: Source<&SyntaxNode>,\n+        node: InFile<&SyntaxNode>,\n         offset: Option<TextUnit>,\n     ) -> SourceAnalyzer {\n+        let _p = profile(\"SourceAnalyzer::new\");\n         let def_with_body = def_with_body_from_child_node(db, node);\n         if let Some(def) = def_with_body {\n             let (_body, source_map) = db.body_with_source_map(def.into());\n@@ -192,12 +206,12 @@ impl SourceAnalyzer {\n     }\n \n     fn expr_id(&self, expr: &ast::Expr) -> Option<ExprId> {\n-        let src = Source { file_id: self.file_id, value: expr };\n+        let src = InFile { file_id: self.file_id, value: expr };\n         self.body_source_map.as_ref()?.node_expr(src)\n     }\n \n     fn pat_id(&self, pat: &ast::Pat) -> Option<PatId> {\n-        let src = Source { file_id: self.file_id, value: pat };\n+        let src = InFile { file_id: self.file_id, value: pat };\n         self.body_source_map.as_ref()?.node_pat(src)\n     }\n \n@@ -226,7 +240,13 @@ impl SourceAnalyzer {\n     }\n \n     pub fn resolve_record_field(&self, field: &ast::RecordField) -> Option<crate::StructField> {\n-        let expr_id = self.expr_id(&field.expr()?)?;\n+        let expr_id = match field.expr() {\n+            Some(it) => self.expr_id(&it)?,\n+            None => {\n+                let src = InFile { file_id: self.file_id, value: field };\n+                self.body_source_map.as_ref()?.field_init_shorthand_expr(src)?\n+            }\n+        };\n         self.infer.as_ref()?.record_field_resolution(expr_id).map(|it| it.into())\n     }\n \n@@ -243,55 +263,54 @@ impl SourceAnalyzer {\n     pub fn resolve_macro_call(\n         &self,\n         db: &impl HirDatabase,\n-        macro_call: Source<&ast::MacroCall>,\n+        macro_call: InFile<&ast::MacroCall>,\n     ) -> Option<MacroDef> {\n         let hygiene = Hygiene::new(db, macro_call.file_id);\n         let path = macro_call.value.path().and_then(|ast| Path::from_src(ast, &hygiene))?;\n-        self.resolver.resolve_path_as_macro(db, &path).map(|it| it.into())\n+        self.resolver.resolve_path_as_macro(db, path.mod_path()).map(|it| it.into())\n     }\n \n     pub fn resolve_hir_path(\n         &self,\n         db: &impl HirDatabase,\n         path: &crate::Path,\n     ) -> Option<PathResolution> {\n-        let types = self.resolver.resolve_path_in_type_ns_fully(db, &path).map(|ty| match ty {\n-            TypeNs::SelfType(it) => PathResolution::SelfType(it.into()),\n-            TypeNs::GenericParam(idx) => PathResolution::GenericParam(GenericParam {\n-                parent: self.resolver.generic_def().unwrap(),\n-                idx,\n-            }),\n-            TypeNs::AdtSelfType(it) | TypeNs::AdtId(it) => {\n-                PathResolution::Def(Adt::from(it).into())\n-            }\n-            TypeNs::EnumVariantId(it) => PathResolution::Def(EnumVariant::from(it).into()),\n-            TypeNs::TypeAliasId(it) => PathResolution::Def(TypeAlias::from(it).into()),\n-            TypeNs::BuiltinType(it) => PathResolution::Def(it.into()),\n-            TypeNs::TraitId(it) => PathResolution::Def(Trait::from(it).into()),\n-        });\n-        let values = self.resolver.resolve_path_in_value_ns_fully(db, &path).and_then(|val| {\n-            let res = match val {\n-                ValueNs::LocalBinding(pat_id) => {\n-                    let var = Local { parent: self.body_owner?, pat_id };\n-                    PathResolution::Local(var)\n+        let types =\n+            self.resolver.resolve_path_in_type_ns_fully(db, path.mod_path()).map(|ty| match ty {\n+                TypeNs::SelfType(it) => PathResolution::SelfType(it.into()),\n+                TypeNs::GenericParam(id) => PathResolution::TypeParam(TypeParam { id }),\n+                TypeNs::AdtSelfType(it) | TypeNs::AdtId(it) => {\n+                    PathResolution::Def(Adt::from(it).into())\n                 }\n-                ValueNs::FunctionId(it) => PathResolution::Def(Function::from(it).into()),\n-                ValueNs::ConstId(it) => PathResolution::Def(Const::from(it).into()),\n-                ValueNs::StaticId(it) => PathResolution::Def(Static::from(it).into()),\n-                ValueNs::StructId(it) => PathResolution::Def(Struct::from(it).into()),\n-                ValueNs::EnumVariantId(it) => PathResolution::Def(EnumVariant::from(it).into()),\n-            };\n-            Some(res)\n-        });\n+                TypeNs::EnumVariantId(it) => PathResolution::Def(EnumVariant::from(it).into()),\n+                TypeNs::TypeAliasId(it) => PathResolution::Def(TypeAlias::from(it).into()),\n+                TypeNs::BuiltinType(it) => PathResolution::Def(it.into()),\n+                TypeNs::TraitId(it) => PathResolution::Def(Trait::from(it).into()),\n+            });\n+        let values =\n+            self.resolver.resolve_path_in_value_ns_fully(db, path.mod_path()).and_then(|val| {\n+                let res = match val {\n+                    ValueNs::LocalBinding(pat_id) => {\n+                        let var = Local { parent: self.body_owner?, pat_id };\n+                        PathResolution::Local(var)\n+                    }\n+                    ValueNs::FunctionId(it) => PathResolution::Def(Function::from(it).into()),\n+                    ValueNs::ConstId(it) => PathResolution::Def(Const::from(it).into()),\n+                    ValueNs::StaticId(it) => PathResolution::Def(Static::from(it).into()),\n+                    ValueNs::StructId(it) => PathResolution::Def(Struct::from(it).into()),\n+                    ValueNs::EnumVariantId(it) => PathResolution::Def(EnumVariant::from(it).into()),\n+                };\n+                Some(res)\n+            });\n \n         let items = self\n             .resolver\n-            .resolve_module_path(db, &path)\n+            .resolve_module_path_in_items(db, path.mod_path())\n             .take_types()\n             .map(|it| PathResolution::Def(it.into()));\n         types.or(values).or(items).or_else(|| {\n             self.resolver\n-                .resolve_path_as_macro(db, &path)\n+                .resolve_path_as_macro(db, path.mod_path())\n                 .map(|def| PathResolution::Macro(def.into()))\n         })\n     }\n@@ -318,7 +337,7 @@ impl SourceAnalyzer {\n         let name = name_ref.as_name();\n         let source_map = self.body_source_map.as_ref()?;\n         let scopes = self.scopes.as_ref()?;\n-        let scope = scope_for(scopes, source_map, Source::new(self.file_id, name_ref.syntax()))?;\n+        let scope = scope_for(scopes, source_map, InFile::new(self.file_id, name_ref.syntax()))?;\n         let entry = scopes.resolve_name_in_scope(scope, &name)?;\n         Some(ScopeEntryWithSyntax {\n             name: entry.name().clone(),\n@@ -332,10 +351,7 @@ impl SourceAnalyzer {\n                 resolver::ScopeDef::PerNs(it) => it.into(),\n                 resolver::ScopeDef::ImplSelfType(it) => ScopeDef::ImplSelfType(it.into()),\n                 resolver::ScopeDef::AdtSelfType(it) => ScopeDef::AdtSelfType(it.into()),\n-                resolver::ScopeDef::GenericParam(idx) => {\n-                    let parent = self.resolver.generic_def().unwrap();\n-                    ScopeDef::GenericParam(GenericParam { parent, idx })\n-                }\n+                resolver::ScopeDef::GenericParam(id) => ScopeDef::GenericParam(TypeParam { id }),\n                 resolver::ScopeDef::Local(pat_id) => {\n                     let parent = self.resolver.body_owner().unwrap().into();\n                     ScopeDef::Local(Local { parent, pat_id })\n@@ -349,7 +365,7 @@ impl SourceAnalyzer {\n     // should switch to general reference search infra there.\n     pub fn find_all_refs(&self, pat: &ast::BindPat) -> Vec<ReferenceDescriptor> {\n         let fn_def = pat.syntax().ancestors().find_map(ast::FnDef::cast).unwrap();\n-        let ptr = Either::A(AstPtr::new(&ast::Pat::from(pat.clone())));\n+        let ptr = Either::Left(AstPtr::new(&ast::Pat::from(pat.clone())));\n         fn_def\n             .syntax()\n             .descendants()\n@@ -375,7 +391,7 @@ impl SourceAnalyzer {\n         // There should be no inference vars in types passed here\n         // FIXME check that?\n         // FIXME replace Unknown by bound vars here\n-        let canonical = crate::ty::Canonical { value: ty.ty.value.clone(), num_vars: 0 };\n+        let canonical = Canonical { value: ty.ty.value.clone(), num_vars: 0 };\n         method_resolution::iterate_method_candidates(\n             &canonical,\n             db,\n@@ -399,7 +415,7 @@ impl SourceAnalyzer {\n         // There should be no inference vars in types passed here\n         // FIXME check that?\n         // FIXME replace Unknown by bound vars here\n-        let canonical = crate::ty::Canonical { value: ty.ty.value.clone(), num_vars: 0 };\n+        let canonical = Canonical { value: ty.ty.value.clone(), num_vars: 0 };\n         method_resolution::iterate_method_candidates(\n             &canonical,\n             db,\n@@ -410,24 +426,10 @@ impl SourceAnalyzer {\n         )\n     }\n \n-    // pub fn autoderef<'a>(\n-    //     &'a self,\n-    //     db: &'a impl HirDatabase,\n-    //     ty: Ty,\n-    // ) -> impl Iterator<Item = Ty> + 'a {\n-    //     // There should be no inference vars in types passed here\n-    //     // FIXME check that?\n-    //     let canonical = crate::ty::Canonical { value: ty, num_vars: 0 };\n-    //     let krate = self.resolver.krate();\n-    //     let environment = TraitEnvironment::lower(db, &self.resolver);\n-    //     let ty = crate::ty::InEnvironment { value: canonical, environment };\n-    //     crate::ty::autoderef(db, krate, ty).map(|canonical| canonical.value)\n-    // }\n-\n     /// Checks that particular type `ty` implements `std::future::Future`.\n     /// This function is used in `.await` syntax completion.\n-    pub fn impls_future(&self, db: &impl HirDatabase, ty: Ty) -> bool {\n-        let std_future_path = known::std_future_future();\n+    pub fn impls_future(&self, db: &impl HirDatabase, ty: Type) -> bool {\n+        let std_future_path = path![std::future::Future];\n \n         let std_future_trait = match self.resolver.resolve_known_trait(db, &std_future_path) {\n             Some(it) => it.into(),\n@@ -439,43 +441,40 @@ impl SourceAnalyzer {\n             _ => return false,\n         };\n \n-        let canonical_ty = crate::ty::Canonical { value: ty, num_vars: 0 };\n+        let canonical_ty = Canonical { value: ty.ty.value, num_vars: 0 };\n         implements_trait(&canonical_ty, db, &self.resolver, krate.into(), std_future_trait)\n     }\n \n     pub fn expand(\n         &self,\n         db: &impl HirDatabase,\n-        macro_call: Source<&ast::MacroCall>,\n+        macro_call: InFile<&ast::MacroCall>,\n     ) -> Option<Expansion> {\n         let def = self.resolve_macro_call(db, macro_call)?.id;\n         let ast_id = AstId::new(\n             macro_call.file_id,\n             db.ast_id_map(macro_call.file_id).ast_id(macro_call.value),\n         );\n-        Some(Expansion {\n-            macro_call_id: def.as_call_id(db, ast_id),\n-            macro_file_kind: to_macro_file_kind(macro_call.value),\n-        })\n+        Some(Expansion { macro_call_id: def.as_call_id(db, MacroCallKind::FnLike(ast_id)) })\n     }\n }\n \n fn scope_for(\n     scopes: &ExprScopes,\n     source_map: &BodySourceMap,\n-    node: Source<&SyntaxNode>,\n+    node: InFile<&SyntaxNode>,\n ) -> Option<ScopeId> {\n     node.value\n         .ancestors()\n         .filter_map(ast::Expr::cast)\n-        .filter_map(|it| source_map.node_expr(Source::new(node.file_id, &it)))\n+        .filter_map(|it| source_map.node_expr(InFile::new(node.file_id, &it)))\n         .find_map(|it| scopes.scope_for(it))\n }\n \n fn scope_for_offset(\n     scopes: &ExprScopes,\n     source_map: &BodySourceMap,\n-    offset: Source<TextUnit>,\n+    offset: InFile<TextUnit>,\n ) -> Option<ScopeId> {\n     scopes\n         .scope_by_expr()\n@@ -540,35 +539,3 @@ fn adjust(\n         })\n         .map(|(_ptr, scope)| *scope)\n }\n-\n-/// Given a `ast::MacroCall`, return what `MacroKindFile` it belongs to.\n-/// FIXME: Not completed\n-fn to_macro_file_kind(macro_call: &ast::MacroCall) -> MacroFileKind {\n-    let syn = macro_call.syntax();\n-    let parent = match syn.parent() {\n-        Some(it) => it,\n-        None => {\n-            // FIXME:\n-            // If it is root, which means the parent HirFile\n-            // MacroKindFile must be non-items\n-            // return expr now.\n-            return MacroFileKind::Expr;\n-        }\n-    };\n-\n-    match parent.kind() {\n-        MACRO_ITEMS | SOURCE_FILE => MacroFileKind::Items,\n-        LET_STMT => {\n-            // FIXME: Handle Pattern\n-            MacroFileKind::Expr\n-        }\n-        EXPR_STMT => MacroFileKind::Statements,\n-        BLOCK => MacroFileKind::Statements,\n-        ARG_LIST => MacroFileKind::Expr,\n-        TRY_EXPR => MacroFileKind::Expr,\n-        _ => {\n-            // Unknown , Just guess it is `Items`\n-            MacroFileKind::Items\n-        }\n-    }\n-}"}, {"sha": "4ed69c00dc4f8a951429b7d1f6071800a90762fb", "filename": "crates/ra_hir/src/ty.rs", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -1,4 +0,0 @@\n-//! The type system. We currently use this to infer types for completion, hover\n-//! information and various assists.\n-\n-pub use hir_ty::*;"}, {"sha": "2c368f690b1bd0d71c5d433d81425121165ccab7", "filename": "crates/ra_hir_def/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2FCargo.toml?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -11,6 +11,9 @@ doctest = false\n log = \"0.4.5\"\n once_cell = \"1.0.1\"\n rustc-hash = \"1.0\"\n+either = \"1.5\"\n+anymap = \"0.12\"\n+drop_bomb = \"0.1.4\"\n \n ra_arena = { path = \"../ra_arena\" }\n ra_db = { path = \"../ra_db\" }"}, {"sha": "d9ea693e343d9d3b72d25e398c3dda039a614ae1", "filename": "crates/ra_hir_def/src/adt.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fadt.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -2,17 +2,18 @@\n \n use std::sync::Arc;\n \n+use either::Either;\n use hir_expand::{\n-    either::Either,\n     name::{AsName, Name},\n-    Source,\n+    InFile,\n };\n use ra_arena::{map::ArenaMap, Arena};\n+use ra_prof::profile;\n use ra_syntax::ast::{self, NameOwner, TypeAscriptionOwner};\n \n use crate::{\n-    db::DefDatabase, trace::Trace, type_ref::TypeRef, AstItemDef, EnumId, HasChildSource,\n-    LocalEnumVariantId, LocalStructFieldId, StructId, UnionId, VariantId,\n+    db::DefDatabase, src::HasChildSource, src::HasSource, trace::Trace, type_ref::TypeRef, EnumId,\n+    LocalEnumVariantId, LocalStructFieldId, Lookup, StructId, UnionId, VariantId,\n };\n \n /// Note that we use `StructData` for unions as well!\n@@ -50,14 +51,14 @@ pub struct StructFieldData {\n \n impl StructData {\n     pub(crate) fn struct_data_query(db: &impl DefDatabase, id: StructId) -> Arc<StructData> {\n-        let src = id.source(db);\n+        let src = id.lookup(db).source(db);\n         let name = src.value.name().map_or_else(Name::missing, |n| n.as_name());\n         let variant_data = VariantData::new(src.value.kind());\n         let variant_data = Arc::new(variant_data);\n         Arc::new(StructData { name, variant_data })\n     }\n     pub(crate) fn union_data_query(db: &impl DefDatabase, id: UnionId) -> Arc<StructData> {\n-        let src = id.source(db);\n+        let src = id.lookup(db).source(db);\n         let name = src.value.name().map_or_else(Name::missing, |n| n.as_name());\n         let variant_data = VariantData::new(\n             src.value\n@@ -72,7 +73,8 @@ impl StructData {\n \n impl EnumData {\n     pub(crate) fn enum_data_query(db: &impl DefDatabase, e: EnumId) -> Arc<EnumData> {\n-        let src = e.source(db);\n+        let _p = profile(\"enum_data_query\");\n+        let src = e.lookup(db).source(db);\n         let name = src.value.name().map_or_else(Name::missing, |n| n.as_name());\n         let mut trace = Trace::new_for_arena();\n         lower_enum(&mut trace, &src.value);\n@@ -88,8 +90,8 @@ impl EnumData {\n impl HasChildSource for EnumId {\n     type ChildId = LocalEnumVariantId;\n     type Value = ast::EnumVariant;\n-    fn child_source(&self, db: &impl DefDatabase) -> Source<ArenaMap<Self::ChildId, Self::Value>> {\n-        let src = self.source(db);\n+    fn child_source(&self, db: &impl DefDatabase) -> InFile<ArenaMap<Self::ChildId, Self::Value>> {\n+        let src = self.lookup(db).source(db);\n         let mut trace = Trace::new_for_map();\n         lower_enum(&mut trace, &src.value);\n         src.with_value(trace.into_map())\n@@ -145,16 +147,16 @@ impl HasChildSource for VariantId {\n     type ChildId = LocalStructFieldId;\n     type Value = Either<ast::TupleFieldDef, ast::RecordFieldDef>;\n \n-    fn child_source(&self, db: &impl DefDatabase) -> Source<ArenaMap<Self::ChildId, Self::Value>> {\n+    fn child_source(&self, db: &impl DefDatabase) -> InFile<ArenaMap<Self::ChildId, Self::Value>> {\n         let src = match self {\n             VariantId::EnumVariantId(it) => {\n                 // I don't really like the fact that we call into parent source\n                 // here, this might add to more queries then necessary.\n                 let src = it.parent.child_source(db);\n                 src.map(|map| map[it.local_id].kind())\n             }\n-            VariantId::StructId(it) => it.source(db).map(|it| it.kind()),\n-            VariantId::UnionId(it) => it.source(db).map(|it| {\n+            VariantId::StructId(it) => it.lookup(db).source(db).map(|it| it.kind()),\n+            VariantId::UnionId(it) => it.lookup(db).source(db).map(|it| {\n                 it.record_field_def_list()\n                     .map(ast::StructKind::Record)\n                     .unwrap_or(ast::StructKind::Unit)\n@@ -184,7 +186,7 @@ fn lower_struct(\n         ast::StructKind::Tuple(fl) => {\n             for (i, fd) in fl.fields().enumerate() {\n                 trace.alloc(\n-                    || Either::A(fd.clone()),\n+                    || Either::Left(fd.clone()),\n                     || StructFieldData {\n                         name: Name::new_tuple_field(i),\n                         type_ref: TypeRef::from_ast_opt(fd.type_ref()),\n@@ -196,7 +198,7 @@ fn lower_struct(\n         ast::StructKind::Record(fl) => {\n             for fd in fl.fields() {\n                 trace.alloc(\n-                    || Either::B(fd.clone()),\n+                    || Either::Right(fd.clone()),\n                     || StructFieldData {\n                         name: fd.name().map(|n| n.as_name()).unwrap_or_else(Name::missing),\n                         type_ref: TypeRef::from_ast_opt(fd.ascribed_type()),"}, {"sha": "9efa4970c11c66984f2bed149fa026ba129532b0", "filename": "crates/ra_hir_def/src/attr.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fattr.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -2,7 +2,8 @@\n \n use std::{ops, sync::Arc};\n \n-use hir_expand::{either::Either, hygiene::Hygiene, AstId, Source};\n+use either::Either;\n+use hir_expand::{hygiene::Hygiene, AstId, InFile};\n use mbe::ast_to_token_tree;\n use ra_syntax::{\n     ast::{self, AstNode, AttrsOwner},\n@@ -11,7 +12,7 @@ use ra_syntax::{\n use tt::Subtree;\n \n use crate::{\n-    db::DefDatabase, path::Path, AdtId, AstItemDef, AttrDefId, HasChildSource, HasSource, Lookup,\n+    db::DefDatabase, path::ModPath, src::HasChildSource, src::HasSource, AdtId, AttrDefId, Lookup,\n };\n \n #[derive(Default, Debug, Clone, PartialEq, Eq)]\n@@ -44,8 +45,8 @@ impl Attrs {\n             AttrDefId::StructFieldId(it) => {\n                 let src = it.parent.child_source(db);\n                 match &src.value[it.local_id] {\n-                    Either::A(_tuple) => Attrs::default(),\n-                    Either::B(record) => Attrs::from_attrs_owner(db, src.with_value(record)),\n+                    Either::Left(_tuple) => Attrs::default(),\n+                    Either::Right(record) => Attrs::from_attrs_owner(db, src.with_value(record)),\n                 }\n             }\n             AttrDefId::EnumVariantId(var_id) => {\n@@ -54,21 +55,23 @@ impl Attrs {\n                 Attrs::from_attrs_owner(db, src.map(|it| it as &dyn AttrsOwner))\n             }\n             AttrDefId::AdtId(it) => match it {\n-                AdtId::StructId(it) => attrs_from_ast(it.lookup_intern(db).ast_id, db),\n-                AdtId::EnumId(it) => attrs_from_ast(it.lookup_intern(db).ast_id, db),\n-                AdtId::UnionId(it) => attrs_from_ast(it.lookup_intern(db).ast_id, db),\n+                AdtId::StructId(it) => attrs_from_loc(it.lookup(db), db),\n+                AdtId::EnumId(it) => attrs_from_loc(it.lookup(db), db),\n+                AdtId::UnionId(it) => attrs_from_loc(it.lookup(db), db),\n             },\n-            AttrDefId::TraitId(it) => attrs_from_ast(it.lookup_intern(db).ast_id, db),\n-            AttrDefId::MacroDefId(it) => attrs_from_ast(it.ast_id, db),\n-            AttrDefId::ImplId(it) => attrs_from_ast(it.lookup_intern(db).ast_id, db),\n+            AttrDefId::TraitId(it) => attrs_from_loc(it.lookup(db), db),\n+            AttrDefId::MacroDefId(it) => {\n+                it.ast_id.map_or_else(Default::default, |ast_id| attrs_from_ast(ast_id, db))\n+            }\n+            AttrDefId::ImplId(it) => attrs_from_loc(it.lookup(db), db),\n             AttrDefId::ConstId(it) => attrs_from_loc(it.lookup(db), db),\n             AttrDefId::StaticId(it) => attrs_from_loc(it.lookup(db), db),\n             AttrDefId::FunctionId(it) => attrs_from_loc(it.lookup(db), db),\n             AttrDefId::TypeAliasId(it) => attrs_from_loc(it.lookup(db), db),\n         }\n     }\n \n-    fn from_attrs_owner(db: &impl DefDatabase, owner: Source<&dyn AttrsOwner>) -> Attrs {\n+    fn from_attrs_owner(db: &impl DefDatabase, owner: InFile<&dyn AttrsOwner>) -> Attrs {\n         let hygiene = Hygiene::new(db, owner.file_id);\n         Attrs::new(owner.value, &hygiene)\n     }\n@@ -91,7 +94,7 @@ impl Attrs {\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct Attr {\n-    pub(crate) path: Path,\n+    pub(crate) path: ModPath,\n     pub(crate) input: Option<AttrInput>,\n }\n \n@@ -103,7 +106,7 @@ pub enum AttrInput {\n \n impl Attr {\n     fn from_src(ast: ast::Attr, hygiene: &Hygiene) -> Option<Attr> {\n-        let path = Path::from_src(ast.path()?, hygiene)?;\n+        let path = ModPath::from_src(ast.path()?, hygiene)?;\n         let input = match ast.input() {\n             None => None,\n             Some(ast::AttrInput::Literal(lit)) => {\n@@ -157,7 +160,7 @@ where\n     N: ast::AttrsOwner,\n     D: DefDatabase,\n {\n-    let src = Source::new(src.file_id(), src.to_node(db));\n+    let src = InFile::new(src.file_id, src.to_node(db));\n     Attrs::from_attrs_owner(db, src.as_ref().map(|it| it as &dyn AttrsOwner))\n }\n "}, {"sha": "d3e4c50ae0608825b01f766b0e9007b8ec7efbc8", "filename": "crates/ra_hir_def/src/body.rs", "status": "modified", "additions": 70, "deletions": 38, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -3,58 +3,75 @@\n mod lower;\n pub mod scope;\n \n-use std::{ops::Index, sync::Arc};\n+use std::{mem, ops::Index, sync::Arc};\n \n+use drop_bomb::DropBomb;\n+use either::Either;\n use hir_expand::{\n-    either::Either, hygiene::Hygiene, AstId, HirFileId, MacroDefId, MacroFileKind, Source,\n+    ast_id_map::AstIdMap, hygiene::Hygiene, AstId, HirFileId, InFile, MacroCallKind, MacroDefId,\n };\n use ra_arena::{map::ArenaMap, Arena};\n+use ra_prof::profile;\n use ra_syntax::{ast, AstNode, AstPtr};\n use rustc_hash::FxHashMap;\n \n use crate::{\n     db::DefDatabase,\n     expr::{Expr, ExprId, Pat, PatId},\n+    item_scope::BuiltinShadowMode,\n+    item_scope::ItemScope,\n     nameres::CrateDefMap,\n-    path::Path,\n-    DefWithBodyId, HasModule, HasSource, Lookup, ModuleId,\n+    path::{ModPath, Path},\n+    src::HasSource,\n+    DefWithBodyId, HasModule, Lookup, ModuleId,\n };\n \n-struct Expander {\n+pub(crate) struct Expander {\n     crate_def_map: Arc<CrateDefMap>,\n     current_file_id: HirFileId,\n     hygiene: Hygiene,\n+    ast_id_map: Arc<AstIdMap>,\n     module: ModuleId,\n }\n \n impl Expander {\n-    fn new(db: &impl DefDatabase, current_file_id: HirFileId, module: ModuleId) -> Expander {\n+    pub(crate) fn new(\n+        db: &impl DefDatabase,\n+        current_file_id: HirFileId,\n+        module: ModuleId,\n+    ) -> Expander {\n         let crate_def_map = db.crate_def_map(module.krate);\n         let hygiene = Hygiene::new(db, current_file_id);\n-        Expander { crate_def_map, current_file_id, hygiene, module }\n+        let ast_id_map = db.ast_id_map(current_file_id);\n+        Expander { crate_def_map, current_file_id, hygiene, ast_id_map, module }\n     }\n \n-    fn enter_expand(\n+    pub(crate) fn enter_expand<T: ast::AstNode, DB: DefDatabase>(\n         &mut self,\n-        db: &impl DefDatabase,\n+        db: &DB,\n         macro_call: ast::MacroCall,\n-    ) -> Option<(Mark, ast::Expr)> {\n+    ) -> Option<(Mark, T)> {\n         let ast_id = AstId::new(\n             self.current_file_id,\n             db.ast_id_map(self.current_file_id).ast_id(&macro_call),\n         );\n \n-        if let Some(path) = macro_call.path().and_then(|path| self.parse_path(path)) {\n+        if let Some(path) = macro_call.path().and_then(|path| self.parse_mod_path(path)) {\n             if let Some(def) = self.resolve_path_as_macro(db, &path) {\n-                let call_id = def.as_call_id(db, ast_id);\n-                let file_id = call_id.as_file(MacroFileKind::Expr);\n+                let call_id = def.as_call_id(db, MacroCallKind::FnLike(ast_id));\n+                let file_id = call_id.as_file();\n                 if let Some(node) = db.parse_or_expand(file_id) {\n-                    if let Some(expr) = ast::Expr::cast(node) {\n+                    if let Some(expr) = T::cast(node) {\n                         log::debug!(\"macro expansion {:#?}\", expr.syntax());\n \n-                        let mark = Mark { file_id: self.current_file_id };\n+                        let mark = Mark {\n+                            file_id: self.current_file_id,\n+                            ast_id_map: mem::take(&mut self.ast_id_map),\n+                            bomb: DropBomb::new(\"expansion mark dropped\"),\n+                        };\n                         self.hygiene = Hygiene::new(db, file_id);\n                         self.current_file_id = file_id;\n+                        self.ast_id_map = db.ast_id_map(file_id);\n \n                         return Some((mark, expr));\n                     }\n@@ -67,37 +84,44 @@ impl Expander {\n         None\n     }\n \n-    fn exit(&mut self, db: &impl DefDatabase, mark: Mark) {\n+    pub(crate) fn exit(&mut self, db: &impl DefDatabase, mut mark: Mark) {\n         self.hygiene = Hygiene::new(db, mark.file_id);\n         self.current_file_id = mark.file_id;\n-        std::mem::forget(mark);\n+        self.ast_id_map = mem::take(&mut mark.ast_id_map);\n+        mark.bomb.defuse();\n     }\n \n-    fn to_source<T>(&self, value: T) -> Source<T> {\n-        Source { file_id: self.current_file_id, value }\n+    pub(crate) fn to_source<T>(&self, value: T) -> InFile<T> {\n+        InFile { file_id: self.current_file_id, value }\n     }\n \n     fn parse_path(&mut self, path: ast::Path) -> Option<Path> {\n         Path::from_src(path, &self.hygiene)\n     }\n \n-    fn resolve_path_as_macro(&self, db: &impl DefDatabase, path: &Path) -> Option<MacroDefId> {\n-        self.crate_def_map.resolve_path(db, self.module.local_id, path).0.take_macros()\n+    fn parse_mod_path(&mut self, path: ast::Path) -> Option<ModPath> {\n+        ModPath::from_src(path, &self.hygiene)\n     }\n-}\n \n-struct Mark {\n-    file_id: HirFileId,\n-}\n+    fn resolve_path_as_macro(&self, db: &impl DefDatabase, path: &ModPath) -> Option<MacroDefId> {\n+        self.crate_def_map\n+            .resolve_path(db, self.module.local_id, path, BuiltinShadowMode::Other)\n+            .0\n+            .take_macros()\n+    }\n \n-impl Drop for Mark {\n-    fn drop(&mut self) {\n-        if !std::thread::panicking() {\n-            panic!(\"dropped mark\")\n-        }\n+    fn ast_id<N: AstNode>(&self, item: &N) -> AstId<N> {\n+        let file_local_id = self.ast_id_map.ast_id(item);\n+        AstId::new(self.current_file_id, file_local_id)\n     }\n }\n \n+pub(crate) struct Mark {\n+    file_id: HirFileId,\n+    ast_id_map: Arc<AstIdMap>,\n+    bomb: DropBomb,\n+}\n+\n /// The body of an item (function, const etc.).\n #[derive(Debug, Eq, PartialEq)]\n pub struct Body {\n@@ -112,13 +136,14 @@ pub struct Body {\n     pub params: Vec<PatId>,\n     /// The `ExprId` of the actual body expression.\n     pub body_expr: ExprId,\n+    pub item_scope: ItemScope,\n }\n \n pub type ExprPtr = Either<AstPtr<ast::Expr>, AstPtr<ast::RecordField>>;\n-pub type ExprSource = Source<ExprPtr>;\n+pub type ExprSource = InFile<ExprPtr>;\n \n pub type PatPtr = Either<AstPtr<ast::Pat>, AstPtr<ast::SelfParam>>;\n-pub type PatSource = Source<PatPtr>;\n+pub type PatSource = InFile<PatPtr>;\n \n /// An item body together with the mapping from syntax nodes to HIR expression\n /// IDs. This is needed to go from e.g. a position in a file to the HIR\n@@ -145,6 +170,7 @@ impl Body {\n         db: &impl DefDatabase,\n         def: DefWithBodyId,\n     ) -> (Arc<Body>, Arc<BodySourceMap>) {\n+        let _p = profile(\"body_with_source_map_query\");\n         let mut params = None;\n \n         let (file_id, module, body) = match def {\n@@ -166,7 +192,7 @@ impl Body {\n             }\n         };\n         let expander = Expander::new(db, file_id, module);\n-        let (body, source_map) = Body::new(db, expander, params, body);\n+        let (body, source_map) = Body::new(db, def, expander, params, body);\n         (Arc::new(body), Arc::new(source_map))\n     }\n \n@@ -176,11 +202,12 @@ impl Body {\n \n     fn new(\n         db: &impl DefDatabase,\n+        def: DefWithBodyId,\n         expander: Expander,\n         params: Option<ast::ParamList>,\n         body: Option<ast::Expr>,\n     ) -> (Body, BodySourceMap) {\n-        lower::lower(db, expander, params, body)\n+        lower::lower(db, def, expander, params, body)\n     }\n }\n \n@@ -205,17 +232,22 @@ impl BodySourceMap {\n         self.expr_map_back.get(expr).copied()\n     }\n \n-    pub fn node_expr(&self, node: Source<&ast::Expr>) -> Option<ExprId> {\n-        let src = node.map(|it| Either::A(AstPtr::new(it)));\n+    pub fn node_expr(&self, node: InFile<&ast::Expr>) -> Option<ExprId> {\n+        let src = node.map(|it| Either::Left(AstPtr::new(it)));\n+        self.expr_map.get(&src).cloned()\n+    }\n+\n+    pub fn field_init_shorthand_expr(&self, node: InFile<&ast::RecordField>) -> Option<ExprId> {\n+        let src = node.map(|it| Either::Right(AstPtr::new(it)));\n         self.expr_map.get(&src).cloned()\n     }\n \n     pub fn pat_syntax(&self, pat: PatId) -> Option<PatSource> {\n         self.pat_map_back.get(pat).copied()\n     }\n \n-    pub fn node_pat(&self, node: Source<&ast::Pat>) -> Option<PatId> {\n-        let src = node.map(|it| Either::A(AstPtr::new(it)));\n+    pub fn node_pat(&self, node: InFile<&ast::Pat>) -> Option<PatId> {\n+        let src = node.map(|it| Either::Left(AstPtr::new(it)));\n         self.pat_map.get(&src).cloned()\n     }\n "}, {"sha": "5323af097236c71c9319fc98dbf702517d340871", "filename": "crates/ra_hir_def/src/body/lower.rs", "status": "modified", "additions": 91, "deletions": 17, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -1,14 +1,13 @@\n //! Transforms `ast::Expr` into an equivalent `hir_def::expr::Expr`\n //! representation.\n \n-use hir_expand::{\n-    either::Either,\n-    name::{self, AsName, Name},\n-};\n+use either::Either;\n+\n+use hir_expand::name::{name, AsName, Name};\n use ra_arena::Arena;\n use ra_syntax::{\n     ast::{\n-        self, ArgListOwner, ArrayExprKind, LiteralKind, LoopBodyOwner, NameOwner,\n+        self, ArgListOwner, ArrayExprKind, LiteralKind, LoopBodyOwner, ModuleItemOwner, NameOwner,\n         TypeAscriptionOwner,\n     },\n     AstNode, AstPtr,\n@@ -26,30 +25,36 @@ use crate::{\n     path::GenericArgs,\n     path::Path,\n     type_ref::{Mutability, TypeRef},\n+    ConstLoc, ContainerId, DefWithBodyId, EnumLoc, FunctionLoc, Intern, ModuleDefId, StaticLoc,\n+    StructLoc, TraitLoc, TypeAliasLoc, UnionLoc,\n };\n \n pub(super) fn lower(\n     db: &impl DefDatabase,\n+    def: DefWithBodyId,\n     expander: Expander,\n     params: Option<ast::ParamList>,\n     body: Option<ast::Expr>,\n ) -> (Body, BodySourceMap) {\n     ExprCollector {\n-        expander,\n         db,\n+        def,\n+        expander,\n         source_map: BodySourceMap::default(),\n         body: Body {\n             exprs: Arena::default(),\n             pats: Arena::default(),\n             params: Vec::new(),\n             body_expr: ExprId::dummy(),\n+            item_scope: Default::default(),\n         },\n     }\n     .collect(params, body)\n }\n \n struct ExprCollector<DB> {\n     db: DB,\n+    def: DefWithBodyId,\n     expander: Expander,\n \n     body: Body,\n@@ -70,11 +75,11 @@ where\n                 let ptr = AstPtr::new(&self_param);\n                 let param_pat = self.alloc_pat(\n                     Pat::Bind {\n-                        name: name::SELF_PARAM,\n+                        name: name![self],\n                         mode: BindingAnnotation::Unannotated,\n                         subpat: None,\n                     },\n-                    Either::B(ptr),\n+                    Either::Right(ptr),\n                 );\n                 self.body.params.push(param_pat);\n             }\n@@ -94,7 +99,7 @@ where\n     }\n \n     fn alloc_expr(&mut self, expr: Expr, ptr: AstPtr<ast::Expr>) -> ExprId {\n-        let ptr = Either::A(ptr);\n+        let ptr = Either::Left(ptr);\n         let id = self.body.exprs.alloc(expr);\n         let src = self.expander.to_source(ptr);\n         self.source_map.expr_map.insert(src, id);\n@@ -107,7 +112,7 @@ where\n         self.body.exprs.alloc(expr)\n     }\n     fn alloc_expr_field_shorthand(&mut self, expr: Expr, ptr: AstPtr<ast::RecordField>) -> ExprId {\n-        let ptr = Either::B(ptr);\n+        let ptr = Either::Right(ptr);\n         let id = self.body.exprs.alloc(expr);\n         let src = self.expander.to_source(ptr);\n         self.source_map.expr_map.insert(src, id);\n@@ -277,7 +282,7 @@ where\n             ast::Expr::ParenExpr(e) => {\n                 let inner = self.collect_expr_opt(e.expr());\n                 // make the paren expr point to the inner expression as well\n-                let src = self.expander.to_source(Either::A(syntax_ptr));\n+                let src = self.expander.to_source(Either::Left(syntax_ptr));\n                 self.source_map.expr_map.insert(src, inner);\n                 inner\n             }\n@@ -367,8 +372,9 @@ where\n                         arg_types.push(type_ref);\n                     }\n                 }\n+                let ret_type = e.ret_type().and_then(|r| r.type_ref()).map(TypeRef::from_ast);\n                 let body = self.collect_expr_opt(e.body());\n-                self.alloc_expr(Expr::Lambda { args, arg_types, body }, syntax_ptr)\n+                self.alloc_expr(Expr::Lambda { args, arg_types, ret_type, body }, syntax_ptr)\n             }\n             ast::Expr::BinExpr(e) => {\n                 let lhs = self.collect_expr_opt(e.lhs());\n@@ -429,10 +435,17 @@ where\n                 let index = self.collect_expr_opt(e.index());\n                 self.alloc_expr(Expr::Index { base, index }, syntax_ptr)\n             }\n-\n-            // FIXME implement HIR for these:\n-            ast::Expr::Label(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n-            ast::Expr::RangeExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n+            ast::Expr::RangeExpr(e) => {\n+                let lhs = e.start().map(|lhs| self.collect_expr(lhs));\n+                let rhs = e.end().map(|rhs| self.collect_expr(rhs));\n+                match e.op_kind() {\n+                    Some(range_type) => {\n+                        self.alloc_expr(Expr::Range { lhs, rhs, range_type }, syntax_ptr)\n+                    }\n+                    None => self.alloc_expr(Expr::Missing, syntax_ptr),\n+                }\n+            }\n+            // FIXME expand to statements in statement position\n             ast::Expr::MacroCall(e) => match self.expander.enter_expand(self.db, e) {\n                 Some((mark, expansion)) => {\n                     let id = self.collect_expr(expansion);\n@@ -441,6 +454,9 @@ where\n                 }\n                 None => self.alloc_expr(Expr::Missing, syntax_ptr),\n             },\n+\n+            // FIXME implement HIR for these:\n+            ast::Expr::Label(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n         }\n     }\n \n@@ -458,6 +474,7 @@ where\n             Some(block) => block,\n             None => return self.alloc_expr(Expr::Missing, syntax_node_ptr),\n         };\n+        self.collect_block_items(&block);\n         let statements = block\n             .statements()\n             .map(|s| match s {\n@@ -474,6 +491,63 @@ where\n         self.alloc_expr(Expr::Block { statements, tail }, syntax_node_ptr)\n     }\n \n+    fn collect_block_items(&mut self, block: &ast::Block) {\n+        let container = ContainerId::DefWithBodyId(self.def);\n+        for item in block.items() {\n+            let (def, name): (ModuleDefId, Option<ast::Name>) = match item {\n+                ast::ModuleItem::FnDef(def) => {\n+                    let ast_id = self.expander.ast_id(&def);\n+                    (\n+                        FunctionLoc { container: container.into(), ast_id }.intern(self.db).into(),\n+                        def.name(),\n+                    )\n+                }\n+                ast::ModuleItem::TypeAliasDef(def) => {\n+                    let ast_id = self.expander.ast_id(&def);\n+                    (\n+                        TypeAliasLoc { container: container.into(), ast_id }.intern(self.db).into(),\n+                        def.name(),\n+                    )\n+                }\n+                ast::ModuleItem::ConstDef(def) => {\n+                    let ast_id = self.expander.ast_id(&def);\n+                    (\n+                        ConstLoc { container: container.into(), ast_id }.intern(self.db).into(),\n+                        def.name(),\n+                    )\n+                }\n+                ast::ModuleItem::StaticDef(def) => {\n+                    let ast_id = self.expander.ast_id(&def);\n+                    (StaticLoc { container, ast_id }.intern(self.db).into(), def.name())\n+                }\n+                ast::ModuleItem::StructDef(def) => {\n+                    let ast_id = self.expander.ast_id(&def);\n+                    (StructLoc { container, ast_id }.intern(self.db).into(), def.name())\n+                }\n+                ast::ModuleItem::EnumDef(def) => {\n+                    let ast_id = self.expander.ast_id(&def);\n+                    (EnumLoc { container, ast_id }.intern(self.db).into(), def.name())\n+                }\n+                ast::ModuleItem::UnionDef(def) => {\n+                    let ast_id = self.expander.ast_id(&def);\n+                    (UnionLoc { container, ast_id }.intern(self.db).into(), def.name())\n+                }\n+                ast::ModuleItem::TraitDef(def) => {\n+                    let ast_id = self.expander.ast_id(&def);\n+                    (TraitLoc { container, ast_id }.intern(self.db).into(), def.name())\n+                }\n+                ast::ModuleItem::ImplBlock(_)\n+                | ast::ModuleItem::UseItem(_)\n+                | ast::ModuleItem::ExternCrateItem(_)\n+                | ast::ModuleItem::Module(_) => continue,\n+            };\n+            self.body.item_scope.define_def(def);\n+            if let Some(name) = name {\n+                self.body.item_scope.push_res(name.as_name(), def.into());\n+            }\n+        }\n+    }\n+\n     fn collect_block_opt(&mut self, expr: Option<ast::BlockExpr>) -> ExprId {\n         if let Some(block) = expr {\n             self.collect_block(block)\n@@ -541,7 +615,7 @@ where\n             ast::Pat::SlicePat(_) | ast::Pat::RangePat(_) => Pat::Missing,\n         };\n         let ptr = AstPtr::new(&pat);\n-        self.alloc_pat(pattern, Either::A(ptr))\n+        self.alloc_pat(pattern, Either::Left(ptr))\n     }\n \n     fn collect_pat_opt(&mut self, pat: Option<ast::Pat>) -> PatId {"}, {"sha": "a6355232750a46e8acac4e2f83362581ef0a9359", "filename": "crates/ra_hir_def/src/body/scope.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Fbody%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Fbody%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Fscope.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -171,7 +171,7 @@ fn compute_expr_scopes(expr: ExprId, body: &Body, scopes: &mut ExprScopes, scope\n \n #[cfg(test)]\n mod tests {\n-    use hir_expand::{name::AsName, Source};\n+    use hir_expand::{name::AsName, InFile};\n     use ra_db::{fixture::WithFixture, FileId, SourceDatabase};\n     use ra_syntax::{algo::find_node_at_offset, ast, AstNode};\n     use test_utils::{assert_eq_text, covers, extract_offset};\n@@ -183,8 +183,8 @@ mod tests {\n         let crate_def_map = db.crate_def_map(krate);\n \n         let module = crate_def_map.modules_for_file(file_id).next().unwrap();\n-        let (_, res) = crate_def_map[module].scope.entries().next().unwrap();\n-        match res.def.take_values().unwrap() {\n+        let (_, def) = crate_def_map[module].scope.entries().next().unwrap();\n+        match def.take_values().unwrap() {\n             ModuleDefId::FunctionId(it) => it,\n             _ => panic!(),\n         }\n@@ -211,7 +211,7 @@ mod tests {\n         let (_body, source_map) = db.body_with_source_map(function.into());\n \n         let expr_id = source_map\n-            .node_expr(Source { file_id: file_id.into(), value: &marker.into() })\n+            .node_expr(InFile { file_id: file_id.into(), value: &marker.into() })\n             .unwrap();\n         let scope = scopes.scope_for(expr_id);\n \n@@ -318,7 +318,7 @@ mod tests {\n         let expr_scope = {\n             let expr_ast = name_ref.syntax().ancestors().find_map(ast::Expr::cast).unwrap();\n             let expr_id =\n-                source_map.node_expr(Source { file_id: file_id.into(), value: &expr_ast }).unwrap();\n+                source_map.node_expr(InFile { file_id: file_id.into(), value: &expr_ast }).unwrap();\n             scopes.scope_for(expr_id).unwrap()\n         };\n "}, {"sha": "d14901a9b49f8b809094d0d78f6c4b49d982c2b7", "filename": "crates/ra_hir_def/src/builtin_type.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Fbuiltin_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Fbuiltin_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbuiltin_type.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -5,7 +5,7 @@\n \n use std::fmt;\n \n-use hir_expand::name::{self, Name};\n+use hir_expand::name::{name, Name};\n \n #[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]\n pub enum Signedness {\n@@ -52,26 +52,26 @@ pub enum BuiltinType {\n impl BuiltinType {\n     #[rustfmt::skip]\n     pub const ALL: &'static [(Name, BuiltinType)] = &[\n-        (name::CHAR, BuiltinType::Char),\n-        (name::BOOL, BuiltinType::Bool),\n-        (name::STR,  BuiltinType::Str ),\n-\n-        (name::ISIZE, BuiltinType::Int(BuiltinInt::ISIZE)),\n-        (name::I8,    BuiltinType::Int(BuiltinInt::I8)),\n-        (name::I16,   BuiltinType::Int(BuiltinInt::I16)),\n-        (name::I32,   BuiltinType::Int(BuiltinInt::I32)),\n-        (name::I64,   BuiltinType::Int(BuiltinInt::I64)),\n-        (name::I128,  BuiltinType::Int(BuiltinInt::I128)),\n-\n-        (name::USIZE, BuiltinType::Int(BuiltinInt::USIZE)),\n-        (name::U8,    BuiltinType::Int(BuiltinInt::U8)),\n-        (name::U16,   BuiltinType::Int(BuiltinInt::U16)),\n-        (name::U32,   BuiltinType::Int(BuiltinInt::U32)),\n-        (name::U64,   BuiltinType::Int(BuiltinInt::U64)),\n-        (name::U128,  BuiltinType::Int(BuiltinInt::U128)),\n-\n-        (name::F32, BuiltinType::Float(BuiltinFloat::F32)),\n-        (name::F64, BuiltinType::Float(BuiltinFloat::F64)),\n+        (name![char], BuiltinType::Char),\n+        (name![bool], BuiltinType::Bool),\n+        (name![str],  BuiltinType::Str),\n+\n+        (name![isize], BuiltinType::Int(BuiltinInt::ISIZE)),\n+        (name![i8],    BuiltinType::Int(BuiltinInt::I8)),\n+        (name![i16],   BuiltinType::Int(BuiltinInt::I16)),\n+        (name![i32],   BuiltinType::Int(BuiltinInt::I32)),\n+        (name![i64],   BuiltinType::Int(BuiltinInt::I64)),\n+        (name![i128],  BuiltinType::Int(BuiltinInt::I128)),\n+\n+        (name![usize], BuiltinType::Int(BuiltinInt::USIZE)),\n+        (name![u8],    BuiltinType::Int(BuiltinInt::U8)),\n+        (name![u16],   BuiltinType::Int(BuiltinInt::U16)),\n+        (name![u32],   BuiltinType::Int(BuiltinInt::U32)),\n+        (name![u64],   BuiltinType::Int(BuiltinInt::U64)),\n+        (name![u128],  BuiltinType::Int(BuiltinInt::U128)),\n+\n+        (name![f32], BuiltinType::Float(BuiltinFloat::F32)),\n+        (name![f64], BuiltinType::Float(BuiltinFloat::F64)),\n     ];\n }\n "}, {"sha": "8b6c773eeb5f6e2ca18f6772390a2f17eeef84db", "filename": "crates/ra_hir_def/src/child_by_source.rs", "status": "added", "additions": 177, "deletions": 0, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Fchild_by_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Fchild_by_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fchild_by_source.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -0,0 +1,177 @@\n+//! When *constructing* `hir`, we start at some parent syntax node and recursively\n+//! lower the children.\n+//!\n+//! This modules allows one to go in the opposite direction: start with a syntax\n+//! node for a *child*, and get its hir.\n+\n+use either::Either;\n+\n+use crate::{\n+    db::DefDatabase,\n+    dyn_map::DynMap,\n+    item_scope::ItemScope,\n+    keys,\n+    src::{HasChildSource, HasSource},\n+    AdtId, AssocItemId, DefWithBodyId, EnumId, EnumVariantId, ImplId, Lookup, ModuleDefId,\n+    ModuleId, StructFieldId, TraitId, VariantId,\n+};\n+\n+pub trait ChildBySource {\n+    fn child_by_source(&self, db: &impl DefDatabase) -> DynMap;\n+}\n+\n+impl ChildBySource for TraitId {\n+    fn child_by_source(&self, db: &impl DefDatabase) -> DynMap {\n+        let mut res = DynMap::default();\n+\n+        let data = db.trait_data(*self);\n+        for (_name, item) in data.items.iter() {\n+            match *item {\n+                AssocItemId::FunctionId(func) => {\n+                    let src = func.lookup(db).source(db);\n+                    res[keys::FUNCTION].insert(src, func)\n+                }\n+                AssocItemId::ConstId(konst) => {\n+                    let src = konst.lookup(db).source(db);\n+                    res[keys::CONST].insert(src, konst)\n+                }\n+                AssocItemId::TypeAliasId(ty) => {\n+                    let src = ty.lookup(db).source(db);\n+                    res[keys::TYPE_ALIAS].insert(src, ty)\n+                }\n+            }\n+        }\n+\n+        res\n+    }\n+}\n+\n+impl ChildBySource for ImplId {\n+    fn child_by_source(&self, db: &impl DefDatabase) -> DynMap {\n+        let mut res = DynMap::default();\n+\n+        let data = db.impl_data(*self);\n+        for &item in data.items.iter() {\n+            match item {\n+                AssocItemId::FunctionId(func) => {\n+                    let src = func.lookup(db).source(db);\n+                    res[keys::FUNCTION].insert(src, func)\n+                }\n+                AssocItemId::ConstId(konst) => {\n+                    let src = konst.lookup(db).source(db);\n+                    res[keys::CONST].insert(src, konst)\n+                }\n+                AssocItemId::TypeAliasId(ty) => {\n+                    let src = ty.lookup(db).source(db);\n+                    res[keys::TYPE_ALIAS].insert(src, ty)\n+                }\n+            }\n+        }\n+\n+        res\n+    }\n+}\n+\n+impl ChildBySource for ModuleId {\n+    fn child_by_source(&self, db: &impl DefDatabase) -> DynMap {\n+        let crate_def_map = db.crate_def_map(self.krate);\n+        let module_data = &crate_def_map[self.local_id];\n+        module_data.scope.child_by_source(db)\n+    }\n+}\n+\n+impl ChildBySource for ItemScope {\n+    fn child_by_source(&self, db: &impl DefDatabase) -> DynMap {\n+        let mut res = DynMap::default();\n+        self.declarations().for_each(|item| add_module_def(db, &mut res, item));\n+        self.impls().for_each(|imp| add_impl(db, &mut res, imp));\n+        return res;\n+\n+        fn add_module_def(db: &impl DefDatabase, map: &mut DynMap, item: ModuleDefId) {\n+            match item {\n+                ModuleDefId::FunctionId(func) => {\n+                    let src = func.lookup(db).source(db);\n+                    map[keys::FUNCTION].insert(src, func)\n+                }\n+                ModuleDefId::ConstId(konst) => {\n+                    let src = konst.lookup(db).source(db);\n+                    map[keys::CONST].insert(src, konst)\n+                }\n+                ModuleDefId::StaticId(statik) => {\n+                    let src = statik.lookup(db).source(db);\n+                    map[keys::STATIC].insert(src, statik)\n+                }\n+                ModuleDefId::TypeAliasId(ty) => {\n+                    let src = ty.lookup(db).source(db);\n+                    map[keys::TYPE_ALIAS].insert(src, ty)\n+                }\n+                ModuleDefId::TraitId(trait_) => {\n+                    let src = trait_.lookup(db).source(db);\n+                    map[keys::TRAIT].insert(src, trait_)\n+                }\n+                ModuleDefId::AdtId(adt) => match adt {\n+                    AdtId::StructId(strukt) => {\n+                        let src = strukt.lookup(db).source(db);\n+                        map[keys::STRUCT].insert(src, strukt)\n+                    }\n+                    AdtId::UnionId(union_) => {\n+                        let src = union_.lookup(db).source(db);\n+                        map[keys::UNION].insert(src, union_)\n+                    }\n+                    AdtId::EnumId(enum_) => {\n+                        let src = enum_.lookup(db).source(db);\n+                        map[keys::ENUM].insert(src, enum_)\n+                    }\n+                },\n+                _ => (),\n+            }\n+        }\n+        fn add_impl(db: &impl DefDatabase, map: &mut DynMap, imp: ImplId) {\n+            let src = imp.lookup(db).source(db);\n+            map[keys::IMPL].insert(src, imp)\n+        }\n+    }\n+}\n+\n+impl ChildBySource for VariantId {\n+    fn child_by_source(&self, db: &impl DefDatabase) -> DynMap {\n+        let mut res = DynMap::default();\n+\n+        let arena_map = self.child_source(db);\n+        let arena_map = arena_map.as_ref();\n+        for (local_id, source) in arena_map.value.iter() {\n+            let id = StructFieldId { parent: *self, local_id };\n+            match source {\n+                Either::Left(source) => {\n+                    res[keys::TUPLE_FIELD].insert(arena_map.with_value(source.clone()), id)\n+                }\n+                Either::Right(source) => {\n+                    res[keys::RECORD_FIELD].insert(arena_map.with_value(source.clone()), id)\n+                }\n+            }\n+        }\n+        res\n+    }\n+}\n+\n+impl ChildBySource for EnumId {\n+    fn child_by_source(&self, db: &impl DefDatabase) -> DynMap {\n+        let mut res = DynMap::default();\n+\n+        let arena_map = self.child_source(db);\n+        let arena_map = arena_map.as_ref();\n+        for (local_id, source) in arena_map.value.iter() {\n+            let id = EnumVariantId { parent: *self, local_id };\n+            res[keys::ENUM_VARIANT].insert(arena_map.with_value(source.clone()), id)\n+        }\n+\n+        res\n+    }\n+}\n+\n+impl ChildBySource for DefWithBodyId {\n+    fn child_by_source(&self, db: &impl DefDatabase) -> DynMap {\n+        let body = db.body(*self);\n+        body.item_scope.child_by_source(db)\n+    }\n+}"}, {"sha": "1aa9a9b7d7df474e08d5291d9b1d443edd624499", "filename": "crates/ra_hir_def/src/data.rs", "status": "modified", "additions": 111, "deletions": 43, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdata.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -3,16 +3,17 @@\n use std::sync::Arc;\n \n use hir_expand::{\n-    name::{self, AsName, Name},\n-    AstId,\n+    name::{name, AsName, Name},\n+    AstId, InFile,\n };\n-use ra_syntax::ast::{self, NameOwner, TypeAscriptionOwner};\n+use ra_syntax::ast::{self, AstNode, ImplItem, ModuleItemOwner, NameOwner, TypeAscriptionOwner};\n \n use crate::{\n     db::DefDatabase,\n+    src::HasSource,\n     type_ref::{Mutability, TypeRef},\n-    AssocItemId, AstItemDef, ConstId, ConstLoc, ContainerId, FunctionId, FunctionLoc, HasSource,\n-    ImplId, Intern, Lookup, StaticId, TraitId, TypeAliasId, TypeAliasLoc,\n+    AssocContainerId, AssocItemId, ConstId, ConstLoc, Expander, FunctionId, FunctionLoc, HasModule,\n+    ImplId, Intern, Lookup, ModuleId, StaticId, TraitId, TypeAliasId, TypeAliasLoc,\n };\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -36,7 +37,7 @@ impl FunctionData {\n                 let self_type = if let Some(type_ref) = self_param.ascribed_type() {\n                     TypeRef::from_ast(type_ref)\n                 } else {\n-                    let self_type = TypeRef::Path(name::SELF_TYPE.into());\n+                    let self_type = TypeRef::Path(name![Self].into());\n                     match self_param.kind() {\n                         ast::SelfParamKind::Owned => self_type,\n                         ast::SelfParamKind::Ref => {\n@@ -93,12 +94,12 @@ pub struct TraitData {\n \n impl TraitData {\n     pub(crate) fn trait_data_query(db: &impl DefDatabase, tr: TraitId) -> Arc<TraitData> {\n-        let src = tr.source(db);\n+        let src = tr.lookup(db).source(db);\n         let name = src.value.name().map_or_else(Name::missing, |n| n.as_name());\n         let auto = src.value.is_auto();\n         let ast_id_map = db.ast_id_map(src.file_id);\n \n-        let container = ContainerId::TraitId(tr);\n+        let container = AssocContainerId::TraitId(tr);\n         let items = if let Some(item_list) = src.value.item_list() {\n             item_list\n                 .impl_items()\n@@ -166,46 +167,24 @@ pub struct ImplData {\n \n impl ImplData {\n     pub(crate) fn impl_data_query(db: &impl DefDatabase, id: ImplId) -> Arc<ImplData> {\n-        let src = id.source(db);\n-        let items = db.ast_id_map(src.file_id);\n+        let impl_loc = id.lookup(db);\n+        let src = impl_loc.source(db);\n \n         let target_trait = src.value.target_trait().map(TypeRef::from_ast);\n         let target_type = TypeRef::from_ast_opt(src.value.target_type());\n         let is_negative = src.value.is_negative();\n+        let module_id = impl_loc.container.module(db);\n \n-        let items = if let Some(item_list) = src.value.item_list() {\n-            item_list\n-                .impl_items()\n-                .map(|item_node| match item_node {\n-                    ast::ImplItem::FnDef(it) => {\n-                        let def = FunctionLoc {\n-                            container: ContainerId::ImplId(id),\n-                            ast_id: AstId::new(src.file_id, items.ast_id(&it)),\n-                        }\n-                        .intern(db);\n-                        def.into()\n-                    }\n-                    ast::ImplItem::ConstDef(it) => {\n-                        let def = ConstLoc {\n-                            container: ContainerId::ImplId(id),\n-                            ast_id: AstId::new(src.file_id, items.ast_id(&it)),\n-                        }\n-                        .intern(db);\n-                        def.into()\n-                    }\n-                    ast::ImplItem::TypeAliasDef(it) => {\n-                        let def = TypeAliasLoc {\n-                            container: ContainerId::ImplId(id),\n-                            ast_id: AstId::new(src.file_id, items.ast_id(&it)),\n-                        }\n-                        .intern(db);\n-                        def.into()\n-                    }\n-                })\n-                .collect()\n-        } else {\n-            Vec::new()\n-        };\n+        let mut items = Vec::new();\n+        if let Some(item_list) = src.value.item_list() {\n+            items.extend(collect_impl_items(db, item_list.impl_items(), src.file_id, id));\n+            items.extend(collect_impl_items_in_macros(\n+                db,\n+                module_id,\n+                &src.with_value(item_list),\n+                id,\n+            ));\n+        }\n \n         let res = ImplData { target_trait, target_type, items, is_negative };\n         Arc::new(res)\n@@ -236,3 +215,92 @@ impl ConstData {\n         ConstData { name, type_ref }\n     }\n }\n+\n+fn collect_impl_items_in_macros(\n+    db: &impl DefDatabase,\n+    module_id: ModuleId,\n+    impl_block: &InFile<ast::ItemList>,\n+    id: ImplId,\n+) -> Vec<AssocItemId> {\n+    let mut expander = Expander::new(db, impl_block.file_id, module_id);\n+    let mut res = Vec::new();\n+\n+    // We set a limit to protect against infinite recursion\n+    let limit = 100;\n+\n+    for m in impl_block.value.syntax().children().filter_map(ast::MacroCall::cast) {\n+        res.extend(collect_impl_items_in_macro(db, &mut expander, m, id, limit))\n+    }\n+\n+    res\n+}\n+\n+fn collect_impl_items_in_macro(\n+    db: &impl DefDatabase,\n+    expander: &mut Expander,\n+    m: ast::MacroCall,\n+    id: ImplId,\n+    limit: usize,\n+) -> Vec<AssocItemId> {\n+    if limit == 0 {\n+        return Vec::new();\n+    }\n+\n+    if let Some((mark, items)) = expander.enter_expand(db, m) {\n+        let items: InFile<ast::MacroItems> = expander.to_source(items);\n+        let mut res = collect_impl_items(\n+            db,\n+            items.value.items().filter_map(|it| ImplItem::cast(it.syntax().clone())),\n+            items.file_id,\n+            id,\n+        );\n+        // Recursive collect macros\n+        // Note that ast::ModuleItem do not include ast::MacroCall\n+        // We cannot use ModuleItemOwner::items here\n+        for it in items.value.syntax().children().filter_map(ast::MacroCall::cast) {\n+            res.extend(collect_impl_items_in_macro(db, expander, it, id, limit - 1))\n+        }\n+        expander.exit(db, mark);\n+        res\n+    } else {\n+        Vec::new()\n+    }\n+}\n+\n+fn collect_impl_items(\n+    db: &impl DefDatabase,\n+    impl_items: impl Iterator<Item = ImplItem>,\n+    file_id: crate::HirFileId,\n+    id: ImplId,\n+) -> Vec<AssocItemId> {\n+    let items = db.ast_id_map(file_id);\n+\n+    impl_items\n+        .map(|item_node| match item_node {\n+            ast::ImplItem::FnDef(it) => {\n+                let def = FunctionLoc {\n+                    container: AssocContainerId::ImplId(id),\n+                    ast_id: AstId::new(file_id, items.ast_id(&it)),\n+                }\n+                .intern(db);\n+                def.into()\n+            }\n+            ast::ImplItem::ConstDef(it) => {\n+                let def = ConstLoc {\n+                    container: AssocContainerId::ImplId(id),\n+                    ast_id: AstId::new(file_id, items.ast_id(&it)),\n+                }\n+                .intern(db);\n+                def.into()\n+            }\n+            ast::ImplItem::TypeAliasDef(it) => {\n+                let def = TypeAliasLoc {\n+                    container: AssocContainerId::ImplId(id),\n+                    ast_id: AstId::new(file_id, items.ast_id(&it)),\n+                }\n+                .intern(db);\n+                def.into()\n+            }\n+        })\n+        .collect()\n+}"}, {"sha": "c55fd411107f9baca6fa9d569c6318a7aebbaa35", "filename": "crates/ra_hir_def/src/db.rs", "status": "modified", "additions": 10, "deletions": 19, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdb.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -3,7 +3,7 @@ use std::sync::Arc;\n \n use hir_expand::{db::AstDatabase, HirFileId};\n use ra_db::{salsa, CrateId, SourceDatabase};\n-use ra_syntax::{ast, SmolStr};\n+use ra_syntax::SmolStr;\n \n use crate::{\n     adt::{EnumData, StructData},\n@@ -13,45 +13,36 @@ use crate::{\n     docs::Documentation,\n     generics::GenericParams,\n     lang_item::{LangItemTarget, LangItems},\n-    nameres::{\n-        raw::{ImportSourceMap, RawItems},\n-        CrateDefMap,\n-    },\n-    AttrDefId, ConstId, ConstLoc, DefWithBodyId, EnumId, FunctionId, FunctionLoc, GenericDefId,\n-    ImplId, ItemLoc, ModuleId, StaticId, StaticLoc, StructId, TraitId, TypeAliasId, TypeAliasLoc,\n-    UnionId,\n+    nameres::{raw::RawItems, CrateDefMap},\n+    AttrDefId, ConstId, ConstLoc, DefWithBodyId, EnumId, EnumLoc, FunctionId, FunctionLoc,\n+    GenericDefId, ImplId, ImplLoc, ModuleId, StaticId, StaticLoc, StructId, StructLoc, TraitId,\n+    TraitLoc, TypeAliasId, TypeAliasLoc, UnionId, UnionLoc,\n };\n \n #[salsa::query_group(InternDatabaseStorage)]\n pub trait InternDatabase: SourceDatabase {\n     #[salsa::interned]\n     fn intern_function(&self, loc: FunctionLoc) -> FunctionId;\n     #[salsa::interned]\n-    fn intern_struct(&self, loc: ItemLoc<ast::StructDef>) -> StructId;\n+    fn intern_struct(&self, loc: StructLoc) -> StructId;\n     #[salsa::interned]\n-    fn intern_union(&self, loc: ItemLoc<ast::UnionDef>) -> UnionId;\n+    fn intern_union(&self, loc: UnionLoc) -> UnionId;\n     #[salsa::interned]\n-    fn intern_enum(&self, loc: ItemLoc<ast::EnumDef>) -> EnumId;\n+    fn intern_enum(&self, loc: EnumLoc) -> EnumId;\n     #[salsa::interned]\n     fn intern_const(&self, loc: ConstLoc) -> ConstId;\n     #[salsa::interned]\n     fn intern_static(&self, loc: StaticLoc) -> StaticId;\n     #[salsa::interned]\n-    fn intern_trait(&self, loc: ItemLoc<ast::TraitDef>) -> TraitId;\n+    fn intern_trait(&self, loc: TraitLoc) -> TraitId;\n     #[salsa::interned]\n     fn intern_type_alias(&self, loc: TypeAliasLoc) -> TypeAliasId;\n     #[salsa::interned]\n-    fn intern_impl(&self, loc: ItemLoc<ast::ImplBlock>) -> ImplId;\n+    fn intern_impl(&self, loc: ImplLoc) -> ImplId;\n }\n \n #[salsa::query_group(DefDatabaseStorage)]\n pub trait DefDatabase: InternDatabase + AstDatabase {\n-    #[salsa::invoke(RawItems::raw_items_with_source_map_query)]\n-    fn raw_items_with_source_map(\n-        &self,\n-        file_id: HirFileId,\n-    ) -> (Arc<RawItems>, Arc<ImportSourceMap>);\n-\n     #[salsa::invoke(RawItems::raw_items_query)]\n     fn raw_items(&self, file_id: HirFileId) -> Arc<RawItems>;\n "}, {"sha": "09549842986d95286fb1ae9232fb50a76aef7efa", "filename": "crates/ra_hir_def/src/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdiagnostics.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -6,7 +6,7 @@ use hir_expand::diagnostics::Diagnostic;\n use ra_db::RelativePathBuf;\n use ra_syntax::{ast, AstPtr, SyntaxNodePtr};\n \n-use hir_expand::{HirFileId, Source};\n+use hir_expand::{HirFileId, InFile};\n \n #[derive(Debug)]\n pub struct UnresolvedModule {\n@@ -19,8 +19,8 @@ impl Diagnostic for UnresolvedModule {\n     fn message(&self) -> String {\n         \"unresolved module\".to_string()\n     }\n-    fn source(&self) -> Source<SyntaxNodePtr> {\n-        Source { file_id: self.file, value: self.decl.into() }\n+    fn source(&self) -> InFile<SyntaxNodePtr> {\n+        InFile { file_id: self.file, value: self.decl.into() }\n     }\n     fn as_any(&self) -> &(dyn Any + Send + 'static) {\n         self"}, {"sha": "b29f142e3307c67440cff861738fe90c25ef2159", "filename": "crates/ra_hir_def/src/docs.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Fdocs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Fdocs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdocs.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -5,10 +5,14 @@\n \n use std::sync::Arc;\n \n-use hir_expand::either::Either;\n+use either::Either;\n use ra_syntax::ast;\n \n-use crate::{db::DefDatabase, AdtId, AstItemDef, AttrDefId, HasChildSource, HasSource, Lookup};\n+use crate::{\n+    db::DefDatabase,\n+    src::{HasChildSource, HasSource},\n+    AdtId, AttrDefId, Lookup,\n+};\n \n /// Holds documentation\n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -42,21 +46,21 @@ impl Documentation {\n             AttrDefId::StructFieldId(it) => {\n                 let src = it.parent.child_source(db);\n                 match &src.value[it.local_id] {\n-                    Either::A(_tuple) => None,\n-                    Either::B(record) => docs_from_ast(record),\n+                    Either::Left(_tuple) => None,\n+                    Either::Right(record) => docs_from_ast(record),\n                 }\n             }\n             AttrDefId::AdtId(it) => match it {\n-                AdtId::StructId(it) => docs_from_ast(&it.source(db).value),\n-                AdtId::EnumId(it) => docs_from_ast(&it.source(db).value),\n-                AdtId::UnionId(it) => docs_from_ast(&it.source(db).value),\n+                AdtId::StructId(it) => docs_from_ast(&it.lookup(db).source(db).value),\n+                AdtId::EnumId(it) => docs_from_ast(&it.lookup(db).source(db).value),\n+                AdtId::UnionId(it) => docs_from_ast(&it.lookup(db).source(db).value),\n             },\n             AttrDefId::EnumVariantId(it) => {\n                 let src = it.parent.child_source(db);\n                 docs_from_ast(&src.value[it.local_id])\n             }\n-            AttrDefId::TraitId(it) => docs_from_ast(&it.source(db).value),\n-            AttrDefId::MacroDefId(it) => docs_from_ast(&it.ast_id.to_node(db)),\n+            AttrDefId::TraitId(it) => docs_from_ast(&it.lookup(db).source(db).value),\n+            AttrDefId::MacroDefId(it) => docs_from_ast(&it.ast_id?.to_node(db)),\n             AttrDefId::ConstId(it) => docs_from_ast(&it.lookup(db).source(db).value),\n             AttrDefId::StaticId(it) => docs_from_ast(&it.lookup(db).source(db).value),\n             AttrDefId::FunctionId(it) => docs_from_ast(&it.lookup(db).source(db).value),"}, {"sha": "6f269d7b01fec1645d62e7f79bef846b9f57af6f", "filename": "crates/ra_hir_def/src/dyn_map.rs", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Fdyn_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Fdyn_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdyn_map.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -0,0 +1,108 @@\n+//! This module defines a `DynMap` -- a container for heterogeneous maps.\n+//!\n+//! This means that `DynMap` stores a bunch of hash maps inside, and those maps\n+//! can be of different types.\n+//!\n+//! It is used like this:\n+//!\n+//! ```\n+//! // keys define submaps of a `DynMap`\n+//! const STRING_TO_U32: Key<String, u32> = Key::new();\n+//! const U32_TO_VEC: Key<u32, Vec<bool>> = Key::new();\n+//!\n+//! // Note: concrete type, no type params!\n+//! let mut map = DynMap::new();\n+//!\n+//! // To access a specific map, index the `DynMap` by `Key`:\n+//! map[STRING_TO_U32].insert(\"hello\".to_string(), 92);\n+//! let value = map[U32_TO_VEC].get(92);\n+//! assert!(value.is_none());\n+//! ```\n+//!\n+//! This is a work of fiction. Any similarities to Kotlin's `BindingContext` are\n+//! a coincidence.\n+use std::{\n+    hash::Hash,\n+    marker::PhantomData,\n+    ops::{Index, IndexMut},\n+};\n+\n+use anymap::Map;\n+use rustc_hash::FxHashMap;\n+\n+pub struct Key<K, V, P = (K, V)> {\n+    _phantom: PhantomData<(K, V, P)>,\n+}\n+\n+impl<K, V, P> Key<K, V, P> {\n+    pub(crate) const fn new() -> Key<K, V, P> {\n+        Key { _phantom: PhantomData }\n+    }\n+}\n+\n+impl<K, V, P> Copy for Key<K, V, P> {}\n+\n+impl<K, V, P> Clone for Key<K, V, P> {\n+    fn clone(&self) -> Key<K, V, P> {\n+        *self\n+    }\n+}\n+\n+pub trait Policy {\n+    type K;\n+    type V;\n+\n+    fn insert(map: &mut DynMap, key: Self::K, value: Self::V);\n+    fn get<'a>(map: &'a DynMap, key: &Self::K) -> Option<&'a Self::V>;\n+}\n+\n+impl<K: Hash + Eq + 'static, V: 'static> Policy for (K, V) {\n+    type K = K;\n+    type V = V;\n+    fn insert(map: &mut DynMap, key: K, value: V) {\n+        map.map.entry::<FxHashMap<K, V>>().or_insert_with(Default::default).insert(key, value);\n+    }\n+    fn get<'a>(map: &'a DynMap, key: &K) -> Option<&'a V> {\n+        map.map.get::<FxHashMap<K, V>>()?.get(key)\n+    }\n+}\n+\n+pub struct DynMap {\n+    pub(crate) map: Map,\n+}\n+\n+impl Default for DynMap {\n+    fn default() -> Self {\n+        DynMap { map: Map::new() }\n+    }\n+}\n+\n+#[repr(transparent)]\n+pub struct KeyMap<KEY> {\n+    map: DynMap,\n+    _phantom: PhantomData<KEY>,\n+}\n+\n+impl<P: Policy> KeyMap<Key<P::K, P::V, P>> {\n+    pub fn insert(&mut self, key: P::K, value: P::V) {\n+        P::insert(&mut self.map, key, value)\n+    }\n+    pub fn get(&self, key: &P::K) -> Option<&P::V> {\n+        P::get(&self.map, key)\n+    }\n+}\n+\n+impl<P: Policy> Index<Key<P::K, P::V, P>> for DynMap {\n+    type Output = KeyMap<Key<P::K, P::V, P>>;\n+    fn index(&self, _key: Key<P::K, P::V, P>) -> &Self::Output {\n+        // Safe due to `#[repr(transparent)]`.\n+        unsafe { std::mem::transmute::<&DynMap, &KeyMap<Key<P::K, P::V, P>>>(self) }\n+    }\n+}\n+\n+impl<P: Policy> IndexMut<Key<P::K, P::V, P>> for DynMap {\n+    fn index_mut(&mut self, _key: Key<P::K, P::V, P>) -> &mut Self::Output {\n+        // Safe due to `#[repr(transparent)]`.\n+        unsafe { std::mem::transmute::<&mut DynMap, &mut KeyMap<Key<P::K, P::V, P>>>(self) }\n+    }\n+}"}, {"sha": "a75ef9970d80c62209ad42089b84304557ffa139", "filename": "crates/ra_hir_def/src/expr.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fexpr.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -14,6 +14,7 @@\n \n use hir_expand::name::Name;\n use ra_arena::{impl_arena_id, RawId};\n+use ra_syntax::ast::RangeOp;\n \n use crate::{\n     builtin_type::{BuiltinFloat, BuiltinInt},\n@@ -130,13 +131,19 @@ pub enum Expr {\n         rhs: ExprId,\n         op: Option<BinaryOp>,\n     },\n+    Range {\n+        lhs: Option<ExprId>,\n+        rhs: Option<ExprId>,\n+        range_type: RangeOp,\n+    },\n     Index {\n         base: ExprId,\n         index: ExprId,\n     },\n     Lambda {\n         args: Vec<PatId>,\n         arg_types: Vec<Option<TypeRef>>,\n+        ret_type: Option<TypeRef>,\n         body: ExprId,\n     },\n     Tuple {\n@@ -288,6 +295,14 @@ impl Expr {\n                 f(*lhs);\n                 f(*rhs);\n             }\n+            Expr::Range { lhs, rhs, .. } => {\n+                if let Some(lhs) = rhs {\n+                    f(*lhs);\n+                }\n+                if let Some(rhs) = lhs {\n+                    f(*rhs);\n+                }\n+            }\n             Expr::Index { base, index } => {\n                 f(*base);\n                 f(*index);"}, {"sha": "e9c28c7309e673104249a2e83dcd822f6a017008", "filename": "crates/ra_hir_def/src/generics.rs", "status": "modified", "additions": 97, "deletions": 77, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fgenerics.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -4,29 +4,38 @@\n //! in rustc.\n use std::sync::Arc;\n \n-use hir_expand::name::{self, AsName, Name};\n+use either::Either;\n+use hir_expand::{\n+    name::{name, AsName, Name},\n+    InFile,\n+};\n+use ra_arena::{map::ArenaMap, Arena};\n+use ra_db::FileId;\n use ra_syntax::ast::{self, NameOwner, TypeBoundsOwner, TypeParamsOwner};\n \n use crate::{\n+    child_by_source::ChildBySource,\n     db::DefDatabase,\n+    dyn_map::DynMap,\n+    keys,\n+    src::HasChildSource,\n+    src::HasSource,\n     type_ref::{TypeBound, TypeRef},\n-    AdtId, AstItemDef, ContainerId, GenericDefId, HasSource, Lookup,\n+    AdtId, GenericDefId, LocalTypeParamId, Lookup, TypeParamId,\n };\n \n /// Data about a generic parameter (to a function, struct, impl, ...).\n #[derive(Clone, PartialEq, Eq, Debug)]\n-pub struct GenericParam {\n-    // FIXME: give generic params proper IDs\n-    pub idx: u32,\n+pub struct TypeParamData {\n     pub name: Name,\n     pub default: Option<TypeRef>,\n }\n \n /// Data about the generic parameters of a function, struct, impl, etc.\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct GenericParams {\n-    pub parent_params: Option<Arc<GenericParams>>,\n-    pub params: Vec<GenericParam>,\n+    pub types: Arena<LocalTypeParamId, TypeParamData>,\n+    // lifetimes: Arena<LocalLifetimeParamId, LifetimeParamData>,\n     pub where_predicates: Vec<WherePredicate>,\n }\n \n@@ -40,77 +49,102 @@ pub struct WherePredicate {\n     pub bound: TypeBound,\n }\n \n+type SourceMap = ArenaMap<LocalTypeParamId, Either<ast::TraitDef, ast::TypeParam>>;\n+\n impl GenericParams {\n     pub(crate) fn generic_params_query(\n         db: &impl DefDatabase,\n         def: GenericDefId,\n     ) -> Arc<GenericParams> {\n-        let parent_generics = parent_generic_def(db, def).map(|it| db.generic_params(it));\n-        Arc::new(GenericParams::new(db, def.into(), parent_generics))\n+        let (params, _source_map) = GenericParams::new(db, def.into());\n+        Arc::new(params)\n     }\n \n-    fn new(\n-        db: &impl DefDatabase,\n-        def: GenericDefId,\n-        parent_params: Option<Arc<GenericParams>>,\n-    ) -> GenericParams {\n-        let mut generics =\n-            GenericParams { params: Vec::new(), parent_params, where_predicates: Vec::new() };\n-        let start = generics.parent_params.as_ref().map(|p| p.params.len()).unwrap_or(0) as u32;\n+    fn new(db: &impl DefDatabase, def: GenericDefId) -> (GenericParams, InFile<SourceMap>) {\n+        let mut generics = GenericParams { types: Arena::default(), where_predicates: Vec::new() };\n+        let mut sm = ArenaMap::default();\n         // FIXME: add `: Sized` bound for everything except for `Self` in traits\n-        match def {\n-            GenericDefId::FunctionId(it) => generics.fill(&it.lookup(db).source(db).value, start),\n-            GenericDefId::AdtId(AdtId::StructId(it)) => generics.fill(&it.source(db).value, start),\n-            GenericDefId::AdtId(AdtId::UnionId(it)) => generics.fill(&it.source(db).value, start),\n-            GenericDefId::AdtId(AdtId::EnumId(it)) => generics.fill(&it.source(db).value, start),\n+        let file_id = match def {\n+            GenericDefId::FunctionId(it) => {\n+                let src = it.lookup(db).source(db);\n+                generics.fill(&mut sm, &src.value);\n+                src.file_id\n+            }\n+            GenericDefId::AdtId(AdtId::StructId(it)) => {\n+                let src = it.lookup(db).source(db);\n+                generics.fill(&mut sm, &src.value);\n+                src.file_id\n+            }\n+            GenericDefId::AdtId(AdtId::UnionId(it)) => {\n+                let src = it.lookup(db).source(db);\n+                generics.fill(&mut sm, &src.value);\n+                src.file_id\n+            }\n+            GenericDefId::AdtId(AdtId::EnumId(it)) => {\n+                let src = it.lookup(db).source(db);\n+                generics.fill(&mut sm, &src.value);\n+                src.file_id\n+            }\n             GenericDefId::TraitId(it) => {\n+                let src = it.lookup(db).source(db);\n+\n                 // traits get the Self type as an implicit first type parameter\n-                generics.params.push(GenericParam {\n-                    idx: start,\n-                    name: name::SELF_TYPE,\n-                    default: None,\n-                });\n-                generics.fill(&it.source(db).value, start + 1);\n+                let self_param_id =\n+                    generics.types.alloc(TypeParamData { name: name![Self], default: None });\n+                sm.insert(self_param_id, Either::Left(src.value.clone()));\n                 // add super traits as bounds on Self\n                 // i.e., trait Foo: Bar is equivalent to trait Foo where Self: Bar\n-                let self_param = TypeRef::Path(name::SELF_TYPE.into());\n-                generics.fill_bounds(&it.source(db).value, self_param);\n+                let self_param = TypeRef::Path(name![Self].into());\n+                generics.fill_bounds(&src.value, self_param);\n+\n+                generics.fill(&mut sm, &src.value);\n+                src.file_id\n+            }\n+            GenericDefId::TypeAliasId(it) => {\n+                let src = it.lookup(db).source(db);\n+                generics.fill(&mut sm, &src.value);\n+                src.file_id\n             }\n-            GenericDefId::TypeAliasId(it) => generics.fill(&it.lookup(db).source(db).value, start),\n             // Note that we don't add `Self` here: in `impl`s, `Self` is not a\n             // type-parameter, but rather is a type-alias for impl's target\n             // type, so this is handled by the resolver.\n-            GenericDefId::ImplId(it) => generics.fill(&it.source(db).value, start),\n-            GenericDefId::EnumVariantId(_) | GenericDefId::ConstId(_) => {}\n-        }\n+            GenericDefId::ImplId(it) => {\n+                let src = it.lookup(db).source(db);\n+                generics.fill(&mut sm, &src.value);\n+                src.file_id\n+            }\n+            // We won't be using this ID anyway\n+            GenericDefId::EnumVariantId(_) | GenericDefId::ConstId(_) => FileId(!0).into(),\n+        };\n \n-        generics\n+        (generics, InFile::new(file_id, sm))\n     }\n \n-    fn fill(&mut self, node: &impl TypeParamsOwner, start: u32) {\n+    fn fill(&mut self, sm: &mut SourceMap, node: &dyn TypeParamsOwner) {\n         if let Some(params) = node.type_param_list() {\n-            self.fill_params(params, start)\n+            self.fill_params(sm, params)\n         }\n         if let Some(where_clause) = node.where_clause() {\n             self.fill_where_predicates(where_clause);\n         }\n     }\n \n-    fn fill_bounds(&mut self, node: &impl ast::TypeBoundsOwner, type_ref: TypeRef) {\n+    fn fill_bounds(&mut self, node: &dyn ast::TypeBoundsOwner, type_ref: TypeRef) {\n         for bound in\n             node.type_bound_list().iter().flat_map(|type_bound_list| type_bound_list.bounds())\n         {\n             self.add_where_predicate_from_bound(bound, type_ref.clone());\n         }\n     }\n \n-    fn fill_params(&mut self, params: ast::TypeParamList, start: u32) {\n-        for (idx, type_param) in params.type_params().enumerate() {\n+    fn fill_params(&mut self, sm: &mut SourceMap, params: ast::TypeParamList) {\n+        for type_param in params.type_params() {\n             let name = type_param.name().map_or_else(Name::missing, |it| it.as_name());\n             // FIXME: Use `Path::from_src`\n             let default = type_param.default_type().map(TypeRef::from_ast);\n-            let param = GenericParam { idx: idx as u32 + start, name: name.clone(), default };\n-            self.params.push(param);\n+            let param = TypeParamData { name: name.clone(), default };\n+            let param_id = self.types.alloc(param);\n+            sm.insert(param_id, Either::Right(type_param.clone()));\n \n             let type_ref = TypeRef::Path(name.into());\n             self.fill_bounds(&type_param, type_ref);\n@@ -139,45 +173,31 @@ impl GenericParams {\n         self.where_predicates.push(WherePredicate { type_ref, bound });\n     }\n \n-    pub fn find_by_name(&self, name: &Name) -> Option<&GenericParam> {\n-        self.params.iter().find(|p| &p.name == name)\n-    }\n-\n-    pub fn count_parent_params(&self) -> usize {\n-        self.parent_params.as_ref().map(|p| p.count_params_including_parent()).unwrap_or(0)\n-    }\n-\n-    pub fn count_params_including_parent(&self) -> usize {\n-        let parent_count = self.count_parent_params();\n-        parent_count + self.params.len()\n-    }\n-\n-    fn for_each_param<'a>(&'a self, f: &mut impl FnMut(&'a GenericParam)) {\n-        if let Some(parent) = &self.parent_params {\n-            parent.for_each_param(f);\n-        }\n-        self.params.iter().for_each(f);\n+    pub fn find_by_name(&self, name: &Name) -> Option<LocalTypeParamId> {\n+        self.types.iter().find_map(|(id, p)| if &p.name == name { Some(id) } else { None })\n     }\n+}\n \n-    pub fn params_including_parent(&self) -> Vec<&GenericParam> {\n-        let mut vec = Vec::with_capacity(self.count_params_including_parent());\n-        self.for_each_param(&mut |p| vec.push(p));\n-        vec\n+impl HasChildSource for GenericDefId {\n+    type ChildId = LocalTypeParamId;\n+    type Value = Either<ast::TraitDef, ast::TypeParam>;\n+    fn child_source(&self, db: &impl DefDatabase) -> InFile<SourceMap> {\n+        let (_, sm) = GenericParams::new(db, *self);\n+        sm\n     }\n }\n \n-fn parent_generic_def(db: &impl DefDatabase, def: GenericDefId) -> Option<GenericDefId> {\n-    let container = match def {\n-        GenericDefId::FunctionId(it) => it.lookup(db).container,\n-        GenericDefId::TypeAliasId(it) => it.lookup(db).container,\n-        GenericDefId::ConstId(it) => it.lookup(db).container,\n-        GenericDefId::EnumVariantId(it) => return Some(it.parent.into()),\n-        GenericDefId::AdtId(_) | GenericDefId::TraitId(_) | GenericDefId::ImplId(_) => return None,\n-    };\n-\n-    match container {\n-        ContainerId::ImplId(it) => Some(it.into()),\n-        ContainerId::TraitId(it) => Some(it.into()),\n-        ContainerId::ModuleId(_) => None,\n+impl ChildBySource for GenericDefId {\n+    fn child_by_source(&self, db: &impl DefDatabase) -> DynMap {\n+        let mut res = DynMap::default();\n+        let arena_map = self.child_source(db);\n+        let arena_map = arena_map.as_ref();\n+        for (local_id, src) in arena_map.value.iter() {\n+            let id = TypeParamId { parent: *self, local_id };\n+            if let Either::Right(type_param) = src {\n+                res[keys::TYPE_PARAM].insert(arena_map.with_value(type_param.clone()), id)\n+            }\n+        }\n+        res\n     }\n }"}, {"sha": "b0288ee8dbec834beafc46d6742f60c95d42842a", "filename": "crates/ra_hir_def/src/item_scope.rs", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -0,0 +1,172 @@\n+//! Describes items defined or visible (ie, imported) in a certain scope.\n+//! This is shared between modules and blocks.\n+\n+use hir_expand::name::Name;\n+use once_cell::sync::Lazy;\n+use rustc_hash::FxHashMap;\n+\n+use crate::{per_ns::PerNs, AdtId, BuiltinType, ImplId, MacroDefId, ModuleDefId, TraitId};\n+\n+#[derive(Debug, Default, PartialEq, Eq)]\n+pub struct ItemScope {\n+    visible: FxHashMap<Name, PerNs>,\n+    defs: Vec<ModuleDefId>,\n+    impls: Vec<ImplId>,\n+    /// Macros visible in current module in legacy textual scope\n+    ///\n+    /// For macros invoked by an unqualified identifier like `bar!()`, `legacy_macros` will be searched in first.\n+    /// If it yields no result, then it turns to module scoped `macros`.\n+    /// It macros with name qualified with a path like `crate::foo::bar!()`, `legacy_macros` will be skipped,\n+    /// and only normal scoped `macros` will be searched in.\n+    ///\n+    /// Note that this automatically inherit macros defined textually before the definition of module itself.\n+    ///\n+    /// Module scoped macros will be inserted into `items` instead of here.\n+    // FIXME: Macro shadowing in one module is not properly handled. Non-item place macros will\n+    // be all resolved to the last one defined if shadowing happens.\n+    legacy_macros: FxHashMap<Name, MacroDefId>,\n+}\n+\n+static BUILTIN_SCOPE: Lazy<FxHashMap<Name, PerNs>> = Lazy::new(|| {\n+    BuiltinType::ALL\n+        .iter()\n+        .map(|(name, ty)| (name.clone(), PerNs::types(ty.clone().into())))\n+        .collect()\n+});\n+\n+/// Shadow mode for builtin type which can be shadowed by module.\n+#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n+pub(crate) enum BuiltinShadowMode {\n+    // Prefer Module\n+    Module,\n+    // Prefer Other Types\n+    Other,\n+}\n+\n+/// Legacy macros can only be accessed through special methods like `get_legacy_macros`.\n+/// Other methods will only resolve values, types and module scoped macros only.\n+impl ItemScope {\n+    pub fn entries<'a>(&'a self) -> impl Iterator<Item = (&'a Name, PerNs)> + 'a {\n+        //FIXME: shadowing\n+        self.visible.iter().chain(BUILTIN_SCOPE.iter()).map(|(n, def)| (n, *def))\n+    }\n+\n+    pub fn entries_without_primitives<'a>(\n+        &'a self,\n+    ) -> impl Iterator<Item = (&'a Name, PerNs)> + 'a {\n+        self.visible.iter().map(|(n, def)| (n, *def))\n+    }\n+\n+    pub fn declarations(&self) -> impl Iterator<Item = ModuleDefId> + '_ {\n+        self.defs.iter().copied()\n+    }\n+\n+    pub fn impls(&self) -> impl Iterator<Item = ImplId> + ExactSizeIterator + '_ {\n+        self.impls.iter().copied()\n+    }\n+\n+    /// Iterate over all module scoped macros\n+    pub(crate) fn macros<'a>(&'a self) -> impl Iterator<Item = (&'a Name, MacroDefId)> + 'a {\n+        self.visible.iter().filter_map(|(name, def)| def.take_macros().map(|macro_| (name, macro_)))\n+    }\n+\n+    /// Iterate over all legacy textual scoped macros visible at the end of the module\n+    pub(crate) fn legacy_macros<'a>(&'a self) -> impl Iterator<Item = (&'a Name, MacroDefId)> + 'a {\n+        self.legacy_macros.iter().map(|(name, def)| (name, *def))\n+    }\n+\n+    /// Get a name from current module scope, legacy macros are not included\n+    pub(crate) fn get(&self, name: &Name, shadow: BuiltinShadowMode) -> PerNs {\n+        match shadow {\n+            BuiltinShadowMode::Module => self\n+                .visible\n+                .get(name)\n+                .or_else(|| BUILTIN_SCOPE.get(name))\n+                .copied()\n+                .unwrap_or_else(PerNs::none),\n+            BuiltinShadowMode::Other => {\n+                let item = self.visible.get(name).copied();\n+                if let Some(def) = item {\n+                    if let Some(ModuleDefId::ModuleId(_)) = def.take_types() {\n+                        return BUILTIN_SCOPE\n+                            .get(name)\n+                            .copied()\n+                            .or(item)\n+                            .unwrap_or_else(PerNs::none);\n+                    }\n+                }\n+\n+                item.or_else(|| BUILTIN_SCOPE.get(name).copied()).unwrap_or_else(PerNs::none)\n+            }\n+        }\n+    }\n+\n+    pub(crate) fn traits<'a>(&'a self) -> impl Iterator<Item = TraitId> + 'a {\n+        self.visible.values().filter_map(|def| match def.take_types() {\n+            Some(ModuleDefId::TraitId(t)) => Some(t),\n+            _ => None,\n+        })\n+    }\n+\n+    pub(crate) fn define_def(&mut self, def: ModuleDefId) {\n+        self.defs.push(def)\n+    }\n+\n+    pub(crate) fn get_legacy_macro(&self, name: &Name) -> Option<MacroDefId> {\n+        self.legacy_macros.get(name).copied()\n+    }\n+\n+    pub(crate) fn define_impl(&mut self, imp: ImplId) {\n+        self.impls.push(imp)\n+    }\n+\n+    pub(crate) fn define_legacy_macro(&mut self, name: Name, mac: MacroDefId) {\n+        self.legacy_macros.insert(name, mac);\n+    }\n+\n+    pub(crate) fn push_res(&mut self, name: Name, def: PerNs) -> bool {\n+        let mut changed = false;\n+        let existing = self.visible.entry(name.clone()).or_default();\n+\n+        if existing.types.is_none() && def.types.is_some() {\n+            existing.types = def.types;\n+            changed = true;\n+        }\n+        if existing.values.is_none() && def.values.is_some() {\n+            existing.values = def.values;\n+            changed = true;\n+        }\n+        if existing.macros.is_none() && def.macros.is_some() {\n+            existing.macros = def.macros;\n+            changed = true;\n+        }\n+\n+        changed\n+    }\n+\n+    pub(crate) fn collect_resolutions(&self) -> Vec<(Name, PerNs)> {\n+        self.visible.iter().map(|(name, res)| (name.clone(), res.clone())).collect()\n+    }\n+\n+    pub(crate) fn collect_legacy_macros(&self) -> FxHashMap<Name, MacroDefId> {\n+        self.legacy_macros.clone()\n+    }\n+}\n+\n+impl From<ModuleDefId> for PerNs {\n+    fn from(def: ModuleDefId) -> PerNs {\n+        match def {\n+            ModuleDefId::ModuleId(_) => PerNs::types(def),\n+            ModuleDefId::FunctionId(_) => PerNs::values(def),\n+            ModuleDefId::AdtId(adt) => match adt {\n+                AdtId::StructId(_) | AdtId::UnionId(_) => PerNs::both(def, def),\n+                AdtId::EnumId(_) => PerNs::types(def),\n+            },\n+            ModuleDefId::EnumVariantId(_) => PerNs::both(def, def),\n+            ModuleDefId::ConstId(_) | ModuleDefId::StaticId(_) => PerNs::values(def),\n+            ModuleDefId::TraitId(_) => PerNs::types(def),\n+            ModuleDefId::TypeAliasId(_) => PerNs::types(def),\n+            ModuleDefId::BuiltinType(_) => PerNs::types(def),\n+        }\n+    }\n+}"}, {"sha": "d844f7a627c5b0ca79a4eac78456b8499f7378ac", "filename": "crates/ra_hir_def/src/keys.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fkeys.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -0,0 +1,56 @@\n+//! keys to be used with `DynMap`\n+\n+use std::marker::PhantomData;\n+\n+use hir_expand::InFile;\n+use ra_syntax::{ast, AstNode, AstPtr};\n+use rustc_hash::FxHashMap;\n+\n+use crate::{\n+    dyn_map::{DynMap, Policy},\n+    ConstId, EnumId, EnumVariantId, FunctionId, ImplId, StaticId, StructFieldId, StructId, TraitId,\n+    TypeAliasId, TypeParamId, UnionId,\n+};\n+\n+pub type Key<K, V> = crate::dyn_map::Key<InFile<K>, V, AstPtrPolicy<K, V>>;\n+\n+pub const FUNCTION: Key<ast::FnDef, FunctionId> = Key::new();\n+pub const CONST: Key<ast::ConstDef, ConstId> = Key::new();\n+pub const STATIC: Key<ast::StaticDef, StaticId> = Key::new();\n+pub const TYPE_ALIAS: Key<ast::TypeAliasDef, TypeAliasId> = Key::new();\n+pub const IMPL: Key<ast::ImplBlock, ImplId> = Key::new();\n+pub const TRAIT: Key<ast::TraitDef, TraitId> = Key::new();\n+pub const STRUCT: Key<ast::StructDef, StructId> = Key::new();\n+pub const UNION: Key<ast::UnionDef, UnionId> = Key::new();\n+pub const ENUM: Key<ast::EnumDef, EnumId> = Key::new();\n+\n+pub const ENUM_VARIANT: Key<ast::EnumVariant, EnumVariantId> = Key::new();\n+pub const TUPLE_FIELD: Key<ast::TupleFieldDef, StructFieldId> = Key::new();\n+pub const RECORD_FIELD: Key<ast::RecordFieldDef, StructFieldId> = Key::new();\n+pub const TYPE_PARAM: Key<ast::TypeParam, TypeParamId> = Key::new();\n+\n+/// XXX: AST Nodes and SyntaxNodes have identity equality semantics: nodes are\n+/// equal if they point to exactly the same object.\n+///\n+/// In general, we do not guarantee that we have exactly one instance of a\n+/// syntax tree for each file. We probably should add such guarantee, but, for\n+/// the time being, we will use identity-less AstPtr comparison.\n+pub struct AstPtrPolicy<AST, ID> {\n+    _phantom: PhantomData<(AST, ID)>,\n+}\n+\n+impl<AST: AstNode + 'static, ID: 'static> Policy for AstPtrPolicy<AST, ID> {\n+    type K = InFile<AST>;\n+    type V = ID;\n+    fn insert(map: &mut DynMap, key: InFile<AST>, value: ID) {\n+        let key = key.as_ref().map(AstPtr::new);\n+        map.map\n+            .entry::<FxHashMap<InFile<AstPtr<AST>>, ID>>()\n+            .or_insert_with(Default::default)\n+            .insert(key, value);\n+    }\n+    fn get<'a>(map: &'a DynMap, key: &InFile<AST>) -> Option<&'a ID> {\n+        let key = key.as_ref().map(AstPtr::new);\n+        map.map.get::<FxHashMap<InFile<AstPtr<AST>>, ID>>()?.get(&key)\n+    }\n+}"}, {"sha": "cef061837b6f9df804ecacf51902668f8425ee85", "filename": "crates/ra_hir_def/src/lang_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Flang_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Flang_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Flang_item.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -81,7 +81,7 @@ impl LangItems {\n         // Look for impl targets\n         let def_map = db.crate_def_map(module.krate);\n         let module_data = &def_map[module.local_id];\n-        for &impl_block in module_data.impls.iter() {\n+        for impl_block in module_data.scope.impls() {\n             self.collect_lang_item(db, impl_block, LangItemTarget::ImplBlockId)\n         }\n "}, {"sha": "f6c7f38d171c2e06812bc79f8de962672966951c", "filename": "crates/ra_hir_def/src/lib.rs", "status": "modified", "additions": 96, "deletions": 250, "changes": 346, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Flib.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -15,6 +15,10 @@ pub mod type_ref;\n pub mod builtin_type;\n pub mod diagnostics;\n pub mod per_ns;\n+pub mod item_scope;\n+\n+pub mod dyn_map;\n+pub mod keys;\n \n pub mod adt;\n pub mod data;\n@@ -29,23 +33,23 @@ pub mod resolver;\n mod trace;\n pub mod nameres;\n \n+pub mod src;\n+pub mod child_by_source;\n+\n #[cfg(test)]\n mod test_db;\n #[cfg(test)]\n mod marks;\n \n-use std::hash::{Hash, Hasher};\n+use std::hash::Hash;\n \n-use hir_expand::{ast_id_map::FileAstId, db::AstDatabase, AstId, HirFileId, MacroDefId, Source};\n-use ra_arena::{impl_arena_id, map::ArenaMap, RawId};\n+use hir_expand::{ast_id_map::FileAstId, AstId, HirFileId, InFile, MacroDefId};\n+use ra_arena::{impl_arena_id, RawId};\n use ra_db::{impl_intern_key, salsa, CrateId};\n use ra_syntax::{ast, AstNode};\n \n-use crate::{builtin_type::BuiltinType, db::InternDatabase};\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct LocalImportId(RawId);\n-impl_arena_id!(LocalImportId);\n+use crate::body::Expander;\n+use crate::builtin_type::BuiltinType;\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct ModuleId {\n@@ -59,122 +63,57 @@ pub struct ModuleId {\n pub struct LocalModuleId(RawId);\n impl_arena_id!(LocalModuleId);\n \n-#[derive(Debug)]\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ItemLoc<N: AstNode> {\n-    pub(crate) module: ModuleId,\n-    ast_id: AstId<N>,\n-}\n-\n-impl<N: AstNode> PartialEq for ItemLoc<N> {\n-    fn eq(&self, other: &Self) -> bool {\n-        self.module == other.module && self.ast_id == other.ast_id\n-    }\n-}\n-impl<N: AstNode> Eq for ItemLoc<N> {}\n-impl<N: AstNode> Hash for ItemLoc<N> {\n-    fn hash<H: Hasher>(&self, hasher: &mut H) {\n-        self.module.hash(hasher);\n-        self.ast_id.hash(hasher);\n-    }\n-}\n-\n-impl<N: AstNode> Clone for ItemLoc<N> {\n-    fn clone(&self) -> ItemLoc<N> {\n-        ItemLoc { module: self.module, ast_id: self.ast_id }\n-    }\n+    pub container: ContainerId,\n+    pub ast_id: AstId<N>,\n }\n \n-#[derive(Clone, Copy)]\n-pub struct LocationCtx<DB> {\n-    db: DB,\n-    module: ModuleId,\n-    file_id: HirFileId,\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct AssocItemLoc<N: AstNode> {\n+    pub container: AssocContainerId,\n+    pub ast_id: AstId<N>,\n }\n \n-impl<'a, DB> LocationCtx<&'a DB> {\n-    pub fn new(db: &'a DB, module: ModuleId, file_id: HirFileId) -> LocationCtx<&'a DB> {\n-        LocationCtx { db, module, file_id }\n-    }\n-}\n+macro_rules! impl_intern {\n+    ($id:ident, $loc:ident, $intern:ident, $lookup:ident) => {\n+        impl_intern_key!($id);\n \n-pub trait AstItemDef<N: AstNode>: salsa::InternKey + Clone {\n-    fn intern(db: &impl InternDatabase, loc: ItemLoc<N>) -> Self;\n-    fn lookup_intern(self, db: &impl InternDatabase) -> ItemLoc<N>;\n+        impl Intern for $loc {\n+            type ID = $id;\n+            fn intern(self, db: &impl db::DefDatabase) -> $id {\n+                db.$intern(self)\n+            }\n+        }\n \n-    fn from_ast_id(ctx: LocationCtx<&impl InternDatabase>, ast_id: FileAstId<N>) -> Self {\n-        let loc = ItemLoc { module: ctx.module, ast_id: AstId::new(ctx.file_id, ast_id) };\n-        Self::intern(ctx.db, loc)\n-    }\n-    fn source(self, db: &(impl AstDatabase + InternDatabase)) -> Source<N> {\n-        let loc = self.lookup_intern(db);\n-        let value = loc.ast_id.to_node(db);\n-        Source { file_id: loc.ast_id.file_id(), value }\n-    }\n-    fn module(self, db: &impl InternDatabase) -> ModuleId {\n-        let loc = self.lookup_intern(db);\n-        loc.module\n-    }\n+        impl Lookup for $id {\n+            type Data = $loc;\n+            fn lookup(&self, db: &impl db::DefDatabase) -> $loc {\n+                db.$lookup(*self)\n+            }\n+        }\n+    };\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct FunctionId(salsa::InternId);\n-impl_intern_key!(FunctionId);\n-\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct FunctionLoc {\n-    pub container: ContainerId,\n-    pub ast_id: AstId<ast::FnDef>,\n-}\n-\n-impl Intern for FunctionLoc {\n-    type ID = FunctionId;\n-    fn intern(self, db: &impl db::DefDatabase) -> FunctionId {\n-        db.intern_function(self)\n-    }\n-}\n-\n-impl Lookup for FunctionId {\n-    type Data = FunctionLoc;\n-    fn lookup(&self, db: &impl db::DefDatabase) -> FunctionLoc {\n-        db.lookup_intern_function(*self)\n-    }\n-}\n+type FunctionLoc = AssocItemLoc<ast::FnDef>;\n+impl_intern!(FunctionId, FunctionLoc, intern_function, lookup_intern_function);\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct StructId(salsa::InternId);\n-impl_intern_key!(StructId);\n-impl AstItemDef<ast::StructDef> for StructId {\n-    fn intern(db: &impl InternDatabase, loc: ItemLoc<ast::StructDef>) -> Self {\n-        db.intern_struct(loc)\n-    }\n-    fn lookup_intern(self, db: &impl InternDatabase) -> ItemLoc<ast::StructDef> {\n-        db.lookup_intern_struct(self)\n-    }\n-}\n+type StructLoc = ItemLoc<ast::StructDef>;\n+impl_intern!(StructId, StructLoc, intern_struct, lookup_intern_struct);\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct UnionId(salsa::InternId);\n-impl_intern_key!(UnionId);\n-impl AstItemDef<ast::UnionDef> for UnionId {\n-    fn intern(db: &impl InternDatabase, loc: ItemLoc<ast::UnionDef>) -> Self {\n-        db.intern_union(loc)\n-    }\n-    fn lookup_intern(self, db: &impl InternDatabase) -> ItemLoc<ast::UnionDef> {\n-        db.lookup_intern_union(self)\n-    }\n-}\n+pub type UnionLoc = ItemLoc<ast::UnionDef>;\n+impl_intern!(UnionId, UnionLoc, intern_union, lookup_intern_union);\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct EnumId(salsa::InternId);\n-impl_intern_key!(EnumId);\n-impl AstItemDef<ast::EnumDef> for EnumId {\n-    fn intern(db: &impl InternDatabase, loc: ItemLoc<ast::EnumDef>) -> Self {\n-        db.intern_enum(loc)\n-    }\n-    fn lookup_intern(self, db: &impl InternDatabase) -> ItemLoc<ast::EnumDef> {\n-        db.lookup_intern_enum(self)\n-    }\n-}\n+pub type EnumLoc = ItemLoc<ast::EnumDef>;\n+impl_intern!(EnumId, EnumLoc, intern_enum, lookup_intern_enum);\n \n // FIXME: rename to `VariantId`, only enums can ave variants\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -199,98 +138,38 @@ impl_arena_id!(LocalStructFieldId);\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct ConstId(salsa::InternId);\n-impl_intern_key!(ConstId);\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct ConstLoc {\n-    pub container: ContainerId,\n-    pub ast_id: AstId<ast::ConstDef>,\n-}\n-\n-impl Intern for ConstLoc {\n-    type ID = ConstId;\n-    fn intern(self, db: &impl db::DefDatabase) -> ConstId {\n-        db.intern_const(self)\n-    }\n-}\n-\n-impl Lookup for ConstId {\n-    type Data = ConstLoc;\n-    fn lookup(&self, db: &impl db::DefDatabase) -> ConstLoc {\n-        db.lookup_intern_const(*self)\n-    }\n-}\n+type ConstLoc = AssocItemLoc<ast::ConstDef>;\n+impl_intern!(ConstId, ConstLoc, intern_const, lookup_intern_const);\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct StaticId(salsa::InternId);\n-impl_intern_key!(StaticId);\n-\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct StaticLoc {\n-    pub container: ModuleId,\n-    pub ast_id: AstId<ast::StaticDef>,\n-}\n-\n-impl Intern for StaticLoc {\n-    type ID = StaticId;\n-    fn intern(self, db: &impl db::DefDatabase) -> StaticId {\n-        db.intern_static(self)\n-    }\n-}\n-\n-impl Lookup for StaticId {\n-    type Data = StaticLoc;\n-    fn lookup(&self, db: &impl db::DefDatabase) -> StaticLoc {\n-        db.lookup_intern_static(*self)\n-    }\n-}\n+pub type StaticLoc = ItemLoc<ast::StaticDef>;\n+impl_intern!(StaticId, StaticLoc, intern_static, lookup_intern_static);\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct TraitId(salsa::InternId);\n-impl_intern_key!(TraitId);\n-impl AstItemDef<ast::TraitDef> for TraitId {\n-    fn intern(db: &impl InternDatabase, loc: ItemLoc<ast::TraitDef>) -> Self {\n-        db.intern_trait(loc)\n-    }\n-    fn lookup_intern(self, db: &impl InternDatabase) -> ItemLoc<ast::TraitDef> {\n-        db.lookup_intern_trait(self)\n-    }\n-}\n+pub type TraitLoc = ItemLoc<ast::TraitDef>;\n+impl_intern!(TraitId, TraitLoc, intern_trait, lookup_intern_trait);\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct TypeAliasId(salsa::InternId);\n-impl_intern_key!(TypeAliasId);\n-\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct TypeAliasLoc {\n-    pub container: ContainerId,\n-    pub ast_id: AstId<ast::TypeAliasDef>,\n-}\n+type TypeAliasLoc = AssocItemLoc<ast::TypeAliasDef>;\n+impl_intern!(TypeAliasId, TypeAliasLoc, intern_type_alias, lookup_intern_type_alias);\n \n-impl Intern for TypeAliasLoc {\n-    type ID = TypeAliasId;\n-    fn intern(self, db: &impl db::DefDatabase) -> TypeAliasId {\n-        db.intern_type_alias(self)\n-    }\n-}\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct ImplId(salsa::InternId);\n+type ImplLoc = ItemLoc<ast::ImplBlock>;\n+impl_intern!(ImplId, ImplLoc, intern_impl, lookup_intern_impl);\n \n-impl Lookup for TypeAliasId {\n-    type Data = TypeAliasLoc;\n-    fn lookup(&self, db: &impl db::DefDatabase) -> TypeAliasLoc {\n-        db.lookup_intern_type_alias(*self)\n-    }\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct TypeParamId {\n+    pub parent: GenericDefId,\n+    pub local_id: LocalTypeParamId,\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct ImplId(salsa::InternId);\n-impl_intern_key!(ImplId);\n-impl AstItemDef<ast::ImplBlock> for ImplId {\n-    fn intern(db: &impl InternDatabase, loc: ItemLoc<ast::ImplBlock>) -> Self {\n-        db.intern_impl(loc)\n-    }\n-    fn lookup_intern(self, db: &impl InternDatabase) -> ItemLoc<ast::ImplBlock> {\n-        db.lookup_intern_impl(self)\n-    }\n-}\n+pub struct LocalTypeParamId(RawId);\n+impl_arena_id!(LocalTypeParamId);\n \n macro_rules! impl_froms {\n     ($e:ident: $($v:ident $(($($sv:ident),*))?),*) => {\n@@ -314,9 +193,16 @@ macro_rules! impl_froms {\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub enum ContainerId {\n     ModuleId(ModuleId),\n+    DefWithBodyId(DefWithBodyId),\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub enum AssocContainerId {\n+    ContainerId(ContainerId),\n     ImplId(ImplId),\n     TraitId(TraitId),\n }\n+impl_froms!(AssocContainerId: ContainerId);\n \n /// A Data Type\n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n@@ -459,43 +345,39 @@ pub trait HasModule {\n     fn module(&self, db: &impl db::DefDatabase) -> ModuleId;\n }\n \n-impl HasModule for FunctionLoc {\n+impl HasModule for ContainerId {\n     fn module(&self, db: &impl db::DefDatabase) -> ModuleId {\n-        match self.container {\n+        match *self {\n             ContainerId::ModuleId(it) => it,\n-            ContainerId::ImplId(it) => it.module(db),\n-            ContainerId::TraitId(it) => it.module(db),\n+            ContainerId::DefWithBodyId(it) => it.module(db),\n         }\n     }\n }\n \n-impl HasModule for TypeAliasLoc {\n+impl HasModule for AssocContainerId {\n     fn module(&self, db: &impl db::DefDatabase) -> ModuleId {\n-        match self.container {\n-            ContainerId::ModuleId(it) => it,\n-            ContainerId::ImplId(it) => it.module(db),\n-            ContainerId::TraitId(it) => it.module(db),\n+        match *self {\n+            AssocContainerId::ContainerId(it) => it.module(db),\n+            AssocContainerId::ImplId(it) => it.lookup(db).container.module(db),\n+            AssocContainerId::TraitId(it) => it.lookup(db).container.module(db),\n         }\n     }\n }\n \n-impl HasModule for ConstLoc {\n+impl<N: AstNode> HasModule for AssocItemLoc<N> {\n     fn module(&self, db: &impl db::DefDatabase) -> ModuleId {\n-        match self.container {\n-            ContainerId::ModuleId(it) => it,\n-            ContainerId::ImplId(it) => it.module(db),\n-            ContainerId::TraitId(it) => it.module(db),\n-        }\n+        self.container.module(db)\n     }\n }\n \n impl HasModule for AdtId {\n     fn module(&self, db: &impl db::DefDatabase) -> ModuleId {\n         match self {\n-            AdtId::StructId(it) => it.module(db),\n-            AdtId::UnionId(it) => it.module(db),\n-            AdtId::EnumId(it) => it.module(db),\n+            AdtId::StructId(it) => it.lookup(db).container,\n+            AdtId::UnionId(it) => it.lookup(db).container,\n+            AdtId::EnumId(it) => it.lookup(db).container,\n         }\n+        .module(db)\n     }\n }\n \n@@ -509,58 +391,22 @@ impl HasModule for DefWithBodyId {\n     }\n }\n \n-impl HasModule for StaticLoc {\n-    fn module(&self, _db: &impl db::DefDatabase) -> ModuleId {\n-        self.container\n-    }\n-}\n-\n-pub trait HasSource {\n-    type Value;\n-    fn source(&self, db: &impl db::DefDatabase) -> Source<Self::Value>;\n-}\n-\n-impl HasSource for FunctionLoc {\n-    type Value = ast::FnDef;\n-\n-    fn source(&self, db: &impl db::DefDatabase) -> Source<ast::FnDef> {\n-        let node = self.ast_id.to_node(db);\n-        Source::new(self.ast_id.file_id(), node)\n-    }\n-}\n-\n-impl HasSource for TypeAliasLoc {\n-    type Value = ast::TypeAliasDef;\n-\n-    fn source(&self, db: &impl db::DefDatabase) -> Source<ast::TypeAliasDef> {\n-        let node = self.ast_id.to_node(db);\n-        Source::new(self.ast_id.file_id(), node)\n-    }\n-}\n-\n-impl HasSource for ConstLoc {\n-    type Value = ast::ConstDef;\n-\n-    fn source(&self, db: &impl db::DefDatabase) -> Source<ast::ConstDef> {\n-        let node = self.ast_id.to_node(db);\n-        Source::new(self.ast_id.file_id(), node)\n+impl HasModule for GenericDefId {\n+    fn module(&self, db: &impl db::DefDatabase) -> ModuleId {\n+        match self {\n+            GenericDefId::FunctionId(it) => it.lookup(db).module(db),\n+            GenericDefId::AdtId(it) => it.module(db),\n+            GenericDefId::TraitId(it) => it.lookup(db).container.module(db),\n+            GenericDefId::TypeAliasId(it) => it.lookup(db).module(db),\n+            GenericDefId::ImplId(it) => it.lookup(db).container.module(db),\n+            GenericDefId::EnumVariantId(it) => it.parent.lookup(db).container.module(db),\n+            GenericDefId::ConstId(it) => it.lookup(db).module(db),\n+        }\n     }\n }\n \n-impl HasSource for StaticLoc {\n-    type Value = ast::StaticDef;\n-\n-    fn source(&self, db: &impl db::DefDatabase) -> Source<ast::StaticDef> {\n-        let node = self.ast_id.to_node(db);\n-        Source::new(self.ast_id.file_id(), node)\n+impl HasModule for StaticLoc {\n+    fn module(&self, db: &impl db::DefDatabase) -> ModuleId {\n+        self.container.module(db)\n     }\n }\n-\n-pub trait HasChildSource {\n-    type ChildId;\n-    type Value;\n-    fn child_source(\n-        &self,\n-        db: &impl db::DefDatabase,\n-    ) -> Source<ArenaMap<Self::ChildId, Self::Value>>;\n-}"}, {"sha": "457ba4abec05b1737cdd06e2ead1ecb4c9213684", "filename": "crates/ra_hir_def/src/marks.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fmarks.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -5,6 +5,7 @@ test_utils::marks!(\n     name_res_works_for_broken_modules\n     can_import_enum_variant\n     glob_enum\n+    glob_enum_group\n     glob_across_crates\n     std_prelude\n     macro_rules_from_other_crates_are_visible_with_macro_use"}, {"sha": "5d4ca73a398855f3f07816bd2473c56e4fe880b5", "filename": "crates/ra_hir_def/src/nameres.rs", "status": "modified", "additions": 111, "deletions": 113, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -57,24 +57,23 @@ mod tests;\n \n use std::sync::Arc;\n \n-use hir_expand::{\n-    ast_id_map::FileAstId, diagnostics::DiagnosticSink, either::Either, name::Name, MacroDefId,\n-    Source,\n-};\n-use once_cell::sync::Lazy;\n+use hir_expand::{diagnostics::DiagnosticSink, name::Name, InFile};\n use ra_arena::Arena;\n-use ra_db::{CrateId, Edition, FileId};\n+use ra_db::{CrateId, Edition, FileId, FilePosition};\n use ra_prof::profile;\n-use ra_syntax::ast;\n+use ra_syntax::{\n+    ast::{self, AstNode},\n+    SyntaxNode,\n+};\n use rustc_hash::FxHashMap;\n \n use crate::{\n-    builtin_type::BuiltinType,\n     db::DefDatabase,\n+    item_scope::{BuiltinShadowMode, ItemScope},\n     nameres::{diagnostics::DefDiagnostic, path_resolution::ResolveMode},\n-    path::Path,\n+    path::ModPath,\n     per_ns::PerNs,\n-    AstId, FunctionId, ImplId, LocalImportId, LocalModuleId, ModuleDefId, ModuleId, TraitId,\n+    AstId, LocalModuleId, ModuleDefId, ModuleId,\n };\n \n /// Contains all top-level defs from a macro-expanded crate\n@@ -100,106 +99,76 @@ impl std::ops::Index<LocalModuleId> for CrateDefMap {\n     }\n }\n \n-#[derive(Default, Debug, PartialEq, Eq)]\n-pub struct ModuleData {\n-    pub parent: Option<LocalModuleId>,\n-    pub children: FxHashMap<Name, LocalModuleId>,\n-    pub scope: ModuleScope,\n-\n-    //  FIXME: these can't be both null, we need a three-state enum here.\n-    /// None for root\n-    pub declaration: Option<AstId<ast::Module>>,\n-    /// None for inline modules.\n-    ///\n+#[derive(Debug, PartialEq, Eq, Clone, Copy, Hash)]\n+pub enum ModuleOrigin {\n+    CrateRoot {\n+        definition: FileId,\n+    },\n     /// Note that non-inline modules, by definition, live inside non-macro file.\n-    pub definition: Option<FileId>,\n-\n-    pub impls: Vec<ImplId>,\n-}\n-\n-#[derive(Default, Debug, PartialEq, Eq)]\n-pub(crate) struct Declarations {\n-    fns: FxHashMap<FileAstId<ast::FnDef>, FunctionId>,\n+    File {\n+        declaration: AstId<ast::Module>,\n+        definition: FileId,\n+    },\n+    Inline {\n+        definition: AstId<ast::Module>,\n+    },\n }\n \n-#[derive(Debug, Default, PartialEq, Eq)]\n-pub struct ModuleScope {\n-    items: FxHashMap<Name, Resolution>,\n-    /// Macros visable in current module in legacy textual scope\n-    ///\n-    /// For macros invoked by an unquatified identifier like `bar!()`, `legacy_macros` will be searched in first.\n-    /// If it yields no result, then it turns to module scoped `macros`.\n-    /// It macros with name quatified with a path like `crate::foo::bar!()`, `legacy_macros` will be skipped,\n-    /// and only normal scoped `macros` will be searched in.\n-    ///\n-    /// Note that this automatically inherit macros defined textually before the definition of module itself.\n-    ///\n-    /// Module scoped macros will be inserted into `items` instead of here.\n-    // FIXME: Macro shadowing in one module is not properly handled. Non-item place macros will\n-    // be all resolved to the last one defined if shadowing happens.\n-    legacy_macros: FxHashMap<Name, MacroDefId>,\n-}\n-\n-static BUILTIN_SCOPE: Lazy<FxHashMap<Name, Resolution>> = Lazy::new(|| {\n-    BuiltinType::ALL\n-        .iter()\n-        .map(|(name, ty)| {\n-            (name.clone(), Resolution { def: PerNs::types(ty.clone().into()), import: None })\n-        })\n-        .collect()\n-});\n-\n-/// Legacy macros can only be accessed through special methods like `get_legacy_macros`.\n-/// Other methods will only resolve values, types and module scoped macros only.\n-impl ModuleScope {\n-    pub fn entries<'a>(&'a self) -> impl Iterator<Item = (&'a Name, &'a Resolution)> + 'a {\n-        //FIXME: shadowing\n-        self.items.iter().chain(BUILTIN_SCOPE.iter())\n-    }\n-\n-    pub fn declarations(&self) -> impl Iterator<Item = ModuleDefId> + '_ {\n-        self.entries()\n-            .filter_map(|(_name, res)| if res.import.is_none() { Some(res.def) } else { None })\n-            .flat_map(|per_ns| {\n-                per_ns.take_types().into_iter().chain(per_ns.take_values().into_iter())\n-            })\n-    }\n-\n-    /// Iterate over all module scoped macros\n-    pub fn macros<'a>(&'a self) -> impl Iterator<Item = (&'a Name, MacroDefId)> + 'a {\n-        self.items\n-            .iter()\n-            .filter_map(|(name, res)| res.def.take_macros().map(|macro_| (name, macro_)))\n+impl Default for ModuleOrigin {\n+    fn default() -> Self {\n+        ModuleOrigin::CrateRoot { definition: FileId(0) }\n     }\n+}\n \n-    /// Iterate over all legacy textual scoped macros visable at the end of the module\n-    pub fn legacy_macros<'a>(&'a self) -> impl Iterator<Item = (&'a Name, MacroDefId)> + 'a {\n-        self.legacy_macros.iter().map(|(name, def)| (name, *def))\n+impl ModuleOrigin {\n+    pub(crate) fn not_sure_file(file: Option<FileId>, declaration: AstId<ast::Module>) -> Self {\n+        match file {\n+            None => ModuleOrigin::Inline { definition: declaration },\n+            Some(definition) => ModuleOrigin::File { declaration, definition },\n+        }\n     }\n \n-    /// Get a name from current module scope, legacy macros are not included\n-    pub fn get(&self, name: &Name) -> Option<&Resolution> {\n-        self.items.get(name).or_else(|| BUILTIN_SCOPE.get(name))\n+    fn declaration(&self) -> Option<AstId<ast::Module>> {\n+        match self {\n+            ModuleOrigin::File { declaration: module, .. }\n+            | ModuleOrigin::Inline { definition: module, .. } => Some(*module),\n+            ModuleOrigin::CrateRoot { .. } => None,\n+        }\n     }\n \n-    pub fn traits<'a>(&'a self) -> impl Iterator<Item = TraitId> + 'a {\n-        self.items.values().filter_map(|r| match r.def.take_types() {\n-            Some(ModuleDefId::TraitId(t)) => Some(t),\n+    pub fn file_id(&self) -> Option<FileId> {\n+        match self {\n+            ModuleOrigin::File { definition, .. } | ModuleOrigin::CrateRoot { definition } => {\n+                Some(*definition)\n+            }\n             _ => None,\n-        })\n+        }\n     }\n \n-    fn get_legacy_macro(&self, name: &Name) -> Option<MacroDefId> {\n-        self.legacy_macros.get(name).copied()\n+    /// Returns a node which defines this module.\n+    /// That is, a file or a `mod foo {}` with items.\n+    fn definition_source(&self, db: &impl DefDatabase) -> InFile<ModuleSource> {\n+        match self {\n+            ModuleOrigin::File { definition, .. } | ModuleOrigin::CrateRoot { definition } => {\n+                let file_id = *definition;\n+                let sf = db.parse(file_id).tree();\n+                return InFile::new(file_id.into(), ModuleSource::SourceFile(sf));\n+            }\n+            ModuleOrigin::Inline { definition } => {\n+                InFile::new(definition.file_id, ModuleSource::Module(definition.to_node(db)))\n+            }\n+        }\n     }\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq, Default)]\n-pub struct Resolution {\n-    /// None for unresolved\n-    pub def: PerNs,\n-    /// ident by which this is imported into local scope.\n-    pub import: Option<LocalImportId>,\n+#[derive(Default, Debug, PartialEq, Eq)]\n+pub struct ModuleData {\n+    pub parent: Option<LocalModuleId>,\n+    pub children: FxHashMap<Name, LocalModuleId>,\n+    pub scope: ItemScope,\n+\n+    /// Where does this module come from?\n+    pub origin: ModuleOrigin,\n }\n \n impl CrateDefMap {\n@@ -241,41 +210,70 @@ impl CrateDefMap {\n     pub fn modules_for_file(&self, file_id: FileId) -> impl Iterator<Item = LocalModuleId> + '_ {\n         self.modules\n             .iter()\n-            .filter(move |(_id, data)| data.definition == Some(file_id))\n+            .filter(move |(_id, data)| data.origin.file_id() == Some(file_id))\n             .map(|(id, _data)| id)\n     }\n \n     pub(crate) fn resolve_path(\n         &self,\n         db: &impl DefDatabase,\n         original_module: LocalModuleId,\n-        path: &Path,\n+        path: &ModPath,\n+        shadow: BuiltinShadowMode,\n     ) -> (PerNs, Option<usize>) {\n-        let res = self.resolve_path_fp_with_macro(db, ResolveMode::Other, original_module, path);\n+        let res =\n+            self.resolve_path_fp_with_macro(db, ResolveMode::Other, original_module, path, shadow);\n         (res.resolved_def, res.segment_index)\n     }\n }\n \n impl ModuleData {\n     /// Returns a node which defines this module. That is, a file or a `mod foo {}` with items.\n-    pub fn definition_source(\n-        &self,\n-        db: &impl DefDatabase,\n-    ) -> Source<Either<ast::SourceFile, ast::Module>> {\n-        if let Some(file_id) = self.definition {\n-            let sf = db.parse(file_id).tree();\n-            return Source::new(file_id.into(), Either::A(sf));\n-        }\n-        let decl = self.declaration.unwrap();\n-        Source::new(decl.file_id(), Either::B(decl.to_node(db)))\n+    pub fn definition_source(&self, db: &impl DefDatabase) -> InFile<ModuleSource> {\n+        self.origin.definition_source(db)\n     }\n \n     /// Returns a node which declares this module, either a `mod foo;` or a `mod foo {}`.\n-    /// `None` for the crate root.\n-    pub fn declaration_source(&self, db: &impl DefDatabase) -> Option<Source<ast::Module>> {\n-        let decl = self.declaration?;\n+    /// `None` for the crate root or block.\n+    pub fn declaration_source(&self, db: &impl DefDatabase) -> Option<InFile<ast::Module>> {\n+        let decl = self.origin.declaration()?;\n         let value = decl.to_node(db);\n-        Some(Source { file_id: decl.file_id(), value })\n+        Some(InFile { file_id: decl.file_id, value })\n+    }\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub enum ModuleSource {\n+    SourceFile(ast::SourceFile),\n+    Module(ast::Module),\n+}\n+\n+impl ModuleSource {\n+    // FIXME: this methods do not belong here\n+    pub fn from_position(db: &impl DefDatabase, position: FilePosition) -> ModuleSource {\n+        let parse = db.parse(position.file_id);\n+        match &ra_syntax::algo::find_node_at_offset::<ast::Module>(\n+            parse.tree().syntax(),\n+            position.offset,\n+        ) {\n+            Some(m) if !m.has_semi() => ModuleSource::Module(m.clone()),\n+            _ => {\n+                let source_file = parse.tree();\n+                ModuleSource::SourceFile(source_file)\n+            }\n+        }\n+    }\n+\n+    pub fn from_child_node(db: &impl DefDatabase, child: InFile<&SyntaxNode>) -> ModuleSource {\n+        if let Some(m) =\n+            child.value.ancestors().filter_map(ast::Module::cast).find(|it| !it.has_semi())\n+        {\n+            ModuleSource::Module(m)\n+        } else {\n+            let file_id = child.file_id.original_file(db);\n+            let source_file = db.parse(file_id).tree();\n+            ModuleSource::SourceFile(source_file)\n+        }\n     }\n }\n \n@@ -309,7 +307,7 @@ mod diagnostics {\n                     }\n                     let decl = declaration.to_node(db);\n                     sink.push(UnresolvedModule {\n-                        file: declaration.file_id(),\n+                        file: declaration.file_id,\n                         decl: AstPtr::new(&decl),\n                         candidate: candidate.clone(),\n                     })"}, {"sha": "b9f40d3dd996a6f5a8771715bb1e4aa258ec6c26", "filename": "crates/ra_hir_def/src/nameres/collector.rs", "status": "modified", "additions": 322, "deletions": 315, "changes": 637, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -4,28 +4,28 @@\n //! resolves imports and expands macros.\n \n use hir_expand::{\n+    builtin_derive::find_builtin_derive,\n     builtin_macro::find_builtin_macro,\n-    name::{self, AsName, Name},\n-    HirFileId, MacroCallId, MacroDefId, MacroDefKind, MacroFileKind,\n+    name::{name, AsName, Name},\n+    HirFileId, MacroCallId, MacroCallKind, MacroDefId, MacroDefKind,\n };\n use ra_cfg::CfgOptions;\n use ra_db::{CrateId, FileId};\n use ra_syntax::ast;\n-use rustc_hash::{FxHashMap, FxHashSet};\n+use rustc_hash::FxHashMap;\n use test_utils::tested_by;\n \n use crate::{\n     attr::Attrs,\n     db::DefDatabase,\n     nameres::{\n         diagnostics::DefDiagnostic, mod_resolution::ModDir, path_resolution::ReachedFixedPoint,\n-        raw, CrateDefMap, ModuleData, Resolution, ResolveMode,\n+        raw, BuiltinShadowMode, CrateDefMap, ModuleData, ModuleOrigin, ResolveMode,\n     },\n-    path::{Path, PathKind},\n+    path::{ModPath, PathKind},\n     per_ns::PerNs,\n-    AdtId, AstId, AstItemDef, ConstLoc, ContainerId, EnumId, EnumVariantId, FunctionLoc, ImplId,\n-    Intern, LocalImportId, LocalModuleId, LocationCtx, ModuleDefId, ModuleId, StaticLoc, StructId,\n-    TraitId, TypeAliasLoc, UnionId,\n+    AdtId, AstId, ConstLoc, ContainerId, EnumLoc, EnumVariantId, FunctionLoc, ImplLoc, Intern,\n+    LocalModuleId, ModuleDefId, ModuleId, StaticLoc, StructLoc, TraitLoc, TypeAliasLoc, UnionLoc,\n };\n \n pub(super) fn collect_defs(db: &impl DefDatabase, mut def_map: CrateDefMap) -> CrateDefMap {\n@@ -57,68 +57,63 @@ pub(super) fn collect_defs(db: &impl DefDatabase, mut def_map: CrateDefMap) -> C\n         def_map,\n         glob_imports: FxHashMap::default(),\n         unresolved_imports: Vec::new(),\n+        resolved_imports: Vec::new(),\n+\n         unexpanded_macros: Vec::new(),\n+        unexpanded_attribute_macros: Vec::new(),\n         mod_dirs: FxHashMap::default(),\n-        macro_stack_monitor: MacroStackMonitor::default(),\n-        poison_macros: FxHashSet::default(),\n         cfg_options,\n     };\n     collector.collect();\n     collector.finish()\n }\n \n-#[derive(Default)]\n-struct MacroStackMonitor {\n-    counts: FxHashMap<MacroDefId, u32>,\n-\n-    /// Mainly use for test\n-    validator: Option<Box<dyn Fn(u32) -> bool>>,\n+#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n+enum PartialResolvedImport {\n+    /// None of any namespaces is resolved\n+    Unresolved,\n+    /// One of namespaces is resolved\n+    Indeterminate(PerNs),\n+    /// All namespaces are resolved, OR it is came from other crate\n+    Resolved(PerNs),\n }\n \n-impl MacroStackMonitor {\n-    fn increase(&mut self, macro_def_id: MacroDefId) {\n-        *self.counts.entry(macro_def_id).or_default() += 1;\n-    }\n-\n-    fn decrease(&mut self, macro_def_id: MacroDefId) {\n-        *self.counts.entry(macro_def_id).or_default() -= 1;\n+impl PartialResolvedImport {\n+    fn namespaces(&self) -> PerNs {\n+        match self {\n+            PartialResolvedImport::Unresolved => PerNs::none(),\n+            PartialResolvedImport::Indeterminate(ns) => *ns,\n+            PartialResolvedImport::Resolved(ns) => *ns,\n+        }\n     }\n+}\n \n-    fn is_poison(&self, macro_def_id: MacroDefId) -> bool {\n-        let cur = *self.counts.get(&macro_def_id).unwrap_or(&0);\n+#[derive(Clone, Debug, Eq, PartialEq)]\n+struct ImportDirective {\n+    module_id: LocalModuleId,\n+    import_id: raw::Import,\n+    import: raw::ImportData,\n+    status: PartialResolvedImport,\n+}\n \n-        if let Some(validator) = &self.validator {\n-            validator(cur)\n-        } else {\n-            cur > 100\n-        }\n-    }\n+#[derive(Clone, Debug, Eq, PartialEq)]\n+struct MacroDirective {\n+    module_id: LocalModuleId,\n+    ast_id: AstId<ast::MacroCall>,\n+    path: ModPath,\n+    legacy: Option<MacroCallId>,\n }\n \n /// Walks the tree of module recursively\n struct DefCollector<'a, DB> {\n     db: &'a DB,\n     def_map: CrateDefMap,\n-    glob_imports: FxHashMap<LocalModuleId, Vec<(LocalModuleId, LocalImportId)>>,\n-    unresolved_imports: Vec<(LocalModuleId, LocalImportId, raw::ImportData)>,\n-    unexpanded_macros: Vec<(LocalModuleId, AstId<ast::MacroCall>, Path)>,\n+    glob_imports: FxHashMap<LocalModuleId, Vec<(LocalModuleId, raw::Import)>>,\n+    unresolved_imports: Vec<ImportDirective>,\n+    resolved_imports: Vec<ImportDirective>,\n+    unexpanded_macros: Vec<MacroDirective>,\n+    unexpanded_attribute_macros: Vec<(LocalModuleId, AstId<ast::ModuleItem>, ModPath)>,\n     mod_dirs: FxHashMap<LocalModuleId, ModDir>,\n-\n-    /// Some macro use `$tt:tt which mean we have to handle the macro perfectly\n-    /// To prevent stack overflow, we add a deep counter here for prevent that.\n-    macro_stack_monitor: MacroStackMonitor,\n-    /// Some macros are not well-behavior, which leads to infinite loop\n-    /// e.g. macro_rules! foo { ($ty:ty) => { foo!($ty); } }\n-    /// We mark it down and skip it in collector\n-    ///\n-    /// FIXME:\n-    /// Right now it only handle a poison macro in a single crate,\n-    /// such that if other crate try to call that macro,\n-    /// the whole process will do again until it became poisoned in that crate.\n-    /// We should handle this macro set globally\n-    /// However, do we want to put it as a global variable?\n-    poison_macros: FxHashSet<MacroDefId>,\n-\n     cfg_options: &'a CfgOptions,\n }\n \n@@ -131,7 +126,7 @@ where\n         let file_id = crate_graph.crate_root(self.def_map.krate);\n         let raw_items = self.db.raw_items(file_id.into());\n         let module_id = self.def_map.root;\n-        self.def_map.modules[module_id].definition = Some(file_id);\n+        self.def_map.modules[module_id].origin = ModuleOrigin::CrateRoot { definition: file_id };\n         ModCollector {\n             def_collector: &mut *self,\n             module_id,\n@@ -145,20 +140,38 @@ where\n         let mut i = 0;\n         loop {\n             self.db.check_canceled();\n-            match (self.resolve_imports(), self.resolve_macros()) {\n-                (ReachedFixedPoint::Yes, ReachedFixedPoint::Yes) => break,\n-                _ => i += 1,\n+            self.resolve_imports();\n+\n+            match self.resolve_macros() {\n+                ReachedFixedPoint::Yes => break,\n+                ReachedFixedPoint::No => i += 1,\n             }\n             if i == 1000 {\n                 log::error!(\"name resolution is stuck\");\n                 break;\n             }\n         }\n \n+        // Resolve all indeterminate resolved imports again\n+        // As some of the macros will expand newly import shadowing partial resolved imports\n+        // FIXME: We maybe could skip this, if we handle the Indetermine imports in `resolve_imports`\n+        // correctly\n+        let partial_resolved = self.resolved_imports.iter().filter_map(|directive| {\n+            if let PartialResolvedImport::Indeterminate(_) = directive.status {\n+                let mut directive = directive.clone();\n+                directive.status = PartialResolvedImport::Unresolved;\n+                Some(directive)\n+            } else {\n+                None\n+            }\n+        });\n+        self.unresolved_imports.extend(partial_resolved);\n+        self.resolve_imports();\n+\n         let unresolved_imports = std::mem::replace(&mut self.unresolved_imports, Vec::new());\n         // show unresolved imports in completion, etc\n-        for (module_id, import, import_data) in unresolved_imports {\n-            self.record_resolved_import(module_id, PerNs::none(), import, &import_data)\n+        for directive in unresolved_imports {\n+            self.record_resolved_import(&directive)\n         }\n     }\n \n@@ -201,24 +214,20 @@ where\n         // In Rust, `#[macro_export]` macros are unconditionally visible at the\n         // crate root, even if the parent modules is **not** visible.\n         if export {\n-            self.update(\n-                self.def_map.root,\n-                None,\n-                &[(name, Resolution { def: PerNs::macros(macro_), import: None })],\n-            );\n+            self.update(self.def_map.root, &[(name, PerNs::macros(macro_))]);\n         }\n     }\n \n     /// Define a legacy textual scoped macro in module\n     ///\n-    /// We use a map `legacy_macros` to store all legacy textual scoped macros visable per module.\n+    /// We use a map `legacy_macros` to store all legacy textual scoped macros visible per module.\n     /// It will clone all macros from parent legacy scope, whose definition is prior to\n     /// the definition of current module.\n-    /// And also, `macro_use` on a module will import all legacy macros visable inside to\n+    /// And also, `macro_use` on a module will import all legacy macros visible inside to\n     /// current legacy scope, with possible shadowing.\n-    fn define_legacy_macro(&mut self, module_id: LocalModuleId, name: Name, macro_: MacroDefId) {\n+    fn define_legacy_macro(&mut self, module_id: LocalModuleId, name: Name, mac: MacroDefId) {\n         // Always shadowing\n-        self.def_map.modules[module_id].scope.legacy_macros.insert(name, macro_);\n+        self.def_map.modules[module_id].scope.define_legacy_macro(name, mac);\n     }\n \n     /// Import macros from `#[macro_use] extern crate`.\n@@ -259,31 +268,43 @@ where\n         }\n     }\n \n-    fn resolve_imports(&mut self) -> ReachedFixedPoint {\n-        let mut imports = std::mem::replace(&mut self.unresolved_imports, Vec::new());\n-        let mut resolved = Vec::new();\n-        imports.retain(|(module_id, import, import_data)| {\n-            let (def, fp) = self.resolve_import(*module_id, import_data);\n-            if fp == ReachedFixedPoint::Yes {\n-                resolved.push((*module_id, def, *import, import_data.clone()))\n+    /// Import resolution\n+    ///\n+    /// This is a fix point algorithm. We resolve imports until no forward\n+    /// progress in resolving imports is made\n+    fn resolve_imports(&mut self) {\n+        let mut n_previous_unresolved = self.unresolved_imports.len() + 1;\n+\n+        while self.unresolved_imports.len() < n_previous_unresolved {\n+            n_previous_unresolved = self.unresolved_imports.len();\n+            let imports = std::mem::replace(&mut self.unresolved_imports, Vec::new());\n+            for mut directive in imports {\n+                directive.status = self.resolve_import(directive.module_id, &directive.import);\n+\n+                match directive.status {\n+                    PartialResolvedImport::Indeterminate(_) => {\n+                        self.record_resolved_import(&directive);\n+                        // FIXME: For avoid performance regression,\n+                        // we consider an imported resolved if it is indeterminate (i.e not all namespace resolved)\n+                        self.resolved_imports.push(directive)\n+                    }\n+                    PartialResolvedImport::Resolved(_) => {\n+                        self.record_resolved_import(&directive);\n+                        self.resolved_imports.push(directive)\n+                    }\n+                    PartialResolvedImport::Unresolved => {\n+                        self.unresolved_imports.push(directive);\n+                    }\n+                }\n             }\n-            fp == ReachedFixedPoint::No\n-        });\n-        self.unresolved_imports = imports;\n-        // Resolves imports, filling-in module scopes\n-        let result =\n-            if resolved.is_empty() { ReachedFixedPoint::Yes } else { ReachedFixedPoint::No };\n-        for (module_id, def, import, import_data) in resolved {\n-            self.record_resolved_import(module_id, def, import, &import_data)\n         }\n-        result\n     }\n \n     fn resolve_import(\n         &self,\n         module_id: LocalModuleId,\n         import: &raw::ImportData,\n-    ) -> (PerNs, ReachedFixedPoint) {\n+    ) -> PartialResolvedImport {\n         log::debug!(\"resolving import: {:?} ({:?})\", import, self.def_map.edition);\n         if import.is_extern_crate {\n             let res = self.def_map.resolve_name_in_extern_prelude(\n@@ -292,26 +313,45 @@ where\n                     .as_ident()\n                     .expect(\"extern crate should have been desugared to one-element path\"),\n             );\n-            (res, ReachedFixedPoint::Yes)\n+            PartialResolvedImport::Resolved(res)\n         } else {\n             let res = self.def_map.resolve_path_fp_with_macro(\n                 self.db,\n                 ResolveMode::Import,\n                 module_id,\n                 &import.path,\n+                BuiltinShadowMode::Module,\n             );\n \n-            (res.resolved_def, res.reached_fixedpoint)\n+            let def = res.resolved_def;\n+            if res.reached_fixedpoint == ReachedFixedPoint::No {\n+                return PartialResolvedImport::Unresolved;\n+            }\n+\n+            if let Some(krate) = res.krate {\n+                if krate != self.def_map.krate {\n+                    return PartialResolvedImport::Resolved(def);\n+                }\n+            }\n+\n+            // Check whether all namespace is resolved\n+            if def.take_types().is_some()\n+                && def.take_values().is_some()\n+                && def.take_macros().is_some()\n+            {\n+                PartialResolvedImport::Resolved(def)\n+            } else {\n+                PartialResolvedImport::Indeterminate(def)\n+            }\n         }\n     }\n \n-    fn record_resolved_import(\n-        &mut self,\n-        module_id: LocalModuleId,\n-        def: PerNs,\n-        import_id: LocalImportId,\n-        import: &raw::ImportData,\n-    ) {\n+    fn record_resolved_import(&mut self, directive: &ImportDirective) {\n+        let module_id = directive.module_id;\n+        let import_id = directive.import_id;\n+        let import = &directive.import;\n+        let def = directive.status.namespaces();\n+\n         if import.is_glob {\n             log::debug!(\"glob import: {:?}\", import);\n             match def.take_types() {\n@@ -326,32 +366,24 @@ where\n                         let scope = &item_map[m.local_id].scope;\n \n                         // Module scoped macros is included\n-                        let items = scope\n-                            .items\n-                            .iter()\n-                            .map(|(name, res)| (name.clone(), res.clone()))\n-                            .collect::<Vec<_>>();\n+                        let items = scope.collect_resolutions();\n \n-                        self.update(module_id, Some(import_id), &items);\n+                        self.update(module_id, &items);\n                     } else {\n                         // glob import from same crate => we do an initial\n                         // import, and then need to propagate any further\n                         // additions\n                         let scope = &self.def_map[m.local_id].scope;\n \n                         // Module scoped macros is included\n-                        let items = scope\n-                            .items\n-                            .iter()\n-                            .map(|(name, res)| (name.clone(), res.clone()))\n-                            .collect::<Vec<_>>();\n+                        let items = scope.collect_resolutions();\n \n-                        self.update(module_id, Some(import_id), &items);\n+                        self.update(module_id, &items);\n                         // record the glob import in case we add further items\n-                        self.glob_imports\n-                            .entry(m.local_id)\n-                            .or_default()\n-                            .push((module_id, import_id));\n+                        let glob = self.glob_imports.entry(m.local_id).or_default();\n+                        if !glob.iter().any(|it| *it == (module_id, import_id)) {\n+                            glob.push((module_id, import_id));\n+                        }\n                     }\n                 }\n                 Some(ModuleDefId::AdtId(AdtId::EnumId(e))) => {\n@@ -361,17 +393,14 @@ where\n                     let resolutions = enum_data\n                         .variants\n                         .iter()\n-                        .filter_map(|(local_id, variant_data)| {\n+                        .map(|(local_id, variant_data)| {\n                             let name = variant_data.name.clone();\n                             let variant = EnumVariantId { parent: e, local_id };\n-                            let res = Resolution {\n-                                def: PerNs::both(variant.into(), variant.into()),\n-                                import: Some(import_id),\n-                            };\n-                            Some((name, res))\n+                            let res = PerNs::both(variant.into(), variant.into());\n+                            (name, res)\n                         })\n                         .collect::<Vec<_>>();\n-                    self.update(module_id, Some(import_id), &resolutions);\n+                    self.update(module_id, &resolutions);\n                 }\n                 Some(d) => {\n                     log::debug!(\"glob import {:?} from non-module/enum {:?}\", import, d);\n@@ -383,7 +412,7 @@ where\n         } else {\n             match import.path.segments.last() {\n                 Some(last_segment) => {\n-                    let name = import.alias.clone().unwrap_or_else(|| last_segment.name.clone());\n+                    let name = import.alias.clone().unwrap_or_else(|| last_segment.clone());\n                     log::debug!(\"resolved import {:?} ({:?}) to {:?}\", name, import, def);\n \n                     // extern crates in the crate root are special-cased to insert entries into the extern prelude: rust-lang/rust#54658\n@@ -393,62 +422,31 @@ where\n                         }\n                     }\n \n-                    let resolution = Resolution { def, import: Some(import_id) };\n-                    self.update(module_id, Some(import_id), &[(name, resolution)]);\n+                    self.update(module_id, &[(name, def)]);\n                 }\n                 None => tested_by!(bogus_paths),\n             }\n         }\n     }\n \n-    fn update(\n-        &mut self,\n-        module_id: LocalModuleId,\n-        import: Option<LocalImportId>,\n-        resolutions: &[(Name, Resolution)],\n-    ) {\n-        self.update_recursive(module_id, import, resolutions, 0)\n+    fn update(&mut self, module_id: LocalModuleId, resolutions: &[(Name, PerNs)]) {\n+        self.update_recursive(module_id, resolutions, 0)\n     }\n \n     fn update_recursive(\n         &mut self,\n         module_id: LocalModuleId,\n-        import: Option<LocalImportId>,\n-        resolutions: &[(Name, Resolution)],\n+        resolutions: &[(Name, PerNs)],\n         depth: usize,\n     ) {\n         if depth > 100 {\n             // prevent stack overflows (but this shouldn't be possible)\n             panic!(\"infinite recursion in glob imports!\");\n         }\n-        let module_items = &mut self.def_map.modules[module_id].scope;\n+        let scope = &mut self.def_map.modules[module_id].scope;\n         let mut changed = false;\n         for (name, res) in resolutions {\n-            let existing = module_items.items.entry(name.clone()).or_default();\n-\n-            if existing.def.types.is_none() && res.def.types.is_some() {\n-                existing.def.types = res.def.types;\n-                existing.import = import.or(res.import);\n-                changed = true;\n-            }\n-            if existing.def.values.is_none() && res.def.values.is_some() {\n-                existing.def.values = res.def.values;\n-                existing.import = import.or(res.import);\n-                changed = true;\n-            }\n-            if existing.def.macros.is_none() && res.def.macros.is_some() {\n-                existing.def.macros = res.def.macros;\n-                existing.import = import.or(res.import);\n-                changed = true;\n-            }\n-\n-            if existing.def.is_none()\n-                && res.def.is_none()\n-                && existing.import.is_none()\n-                && res.import.is_some()\n-            {\n-                existing.import = res.import;\n-            }\n+            changed |= scope.push_res(name.clone(), *res);\n         }\n \n         if !changed {\n@@ -461,27 +459,48 @@ where\n             .flat_map(|v| v.iter())\n             .cloned()\n             .collect::<Vec<_>>();\n-        for (glob_importing_module, glob_import) in glob_imports {\n+        for (glob_importing_module, _glob_import) in glob_imports {\n             // We pass the glob import so that the tracked import in those modules is that glob import\n-            self.update_recursive(glob_importing_module, Some(glob_import), resolutions, depth + 1);\n+            self.update_recursive(glob_importing_module, resolutions, depth + 1);\n         }\n     }\n \n     fn resolve_macros(&mut self) -> ReachedFixedPoint {\n         let mut macros = std::mem::replace(&mut self.unexpanded_macros, Vec::new());\n+        let mut attribute_macros =\n+            std::mem::replace(&mut self.unexpanded_attribute_macros, Vec::new());\n         let mut resolved = Vec::new();\n         let mut res = ReachedFixedPoint::Yes;\n-        macros.retain(|(module_id, ast_id, path)| {\n+        macros.retain(|directive| {\n+            if let Some(call_id) = directive.legacy {\n+                res = ReachedFixedPoint::No;\n+                resolved.push((directive.module_id, call_id));\n+                return false;\n+            }\n+\n             let resolved_res = self.def_map.resolve_path_fp_with_macro(\n                 self.db,\n                 ResolveMode::Other,\n-                *module_id,\n-                path,\n+                directive.module_id,\n+                &directive.path,\n+                BuiltinShadowMode::Module,\n             );\n \n             if let Some(def) = resolved_res.resolved_def.take_macros() {\n-                let call_id = def.as_call_id(self.db, *ast_id);\n-                resolved.push((*module_id, call_id, def));\n+                let call_id = def.as_call_id(self.db, MacroCallKind::FnLike(directive.ast_id));\n+                resolved.push((directive.module_id, call_id));\n+                res = ReachedFixedPoint::No;\n+                return false;\n+            }\n+\n+            true\n+        });\n+        attribute_macros.retain(|(module_id, ast_id, path)| {\n+            let resolved_res = self.resolve_attribute_macro(path);\n+\n+            if let Some(def) = resolved_res {\n+                let call_id = def.as_call_id(self.db, MacroCallKind::Attr(*ast_id));\n+                resolved.push((*module_id, call_id));\n                 res = ReachedFixedPoint::No;\n                 return false;\n             }\n@@ -490,44 +509,41 @@ where\n         });\n \n         self.unexpanded_macros = macros;\n+        self.unexpanded_attribute_macros = attribute_macros;\n \n-        for (module_id, macro_call_id, macro_def_id) in resolved {\n-            self.collect_macro_expansion(module_id, macro_call_id, macro_def_id);\n+        for (module_id, macro_call_id) in resolved {\n+            self.collect_macro_expansion(module_id, macro_call_id);\n         }\n \n         res\n     }\n \n-    fn collect_macro_expansion(\n-        &mut self,\n-        module_id: LocalModuleId,\n-        macro_call_id: MacroCallId,\n-        macro_def_id: MacroDefId,\n-    ) {\n-        if self.poison_macros.contains(&macro_def_id) {\n-            return;\n-        }\n-\n-        self.macro_stack_monitor.increase(macro_def_id);\n-\n-        if !self.macro_stack_monitor.is_poison(macro_def_id) {\n-            let file_id: HirFileId = macro_call_id.as_file(MacroFileKind::Items);\n-            let raw_items = self.db.raw_items(file_id);\n-            let mod_dir = self.mod_dirs[&module_id].clone();\n-            ModCollector {\n-                def_collector: &mut *self,\n-                file_id,\n-                module_id,\n-                raw_items: &raw_items,\n-                mod_dir,\n+    fn resolve_attribute_macro(&self, path: &ModPath) -> Option<MacroDefId> {\n+        // FIXME this is currently super hacky, just enough to support the\n+        // built-in derives\n+        if let Some(name) = path.as_ident() {\n+            // FIXME this should actually be handled with the normal name\n+            // resolution; the std lib defines built-in stubs for the derives,\n+            // but these are new-style `macro`s, which we don't support yet\n+            if let Some(def_id) = find_builtin_derive(name) {\n+                return Some(def_id);\n             }\n-            .collect(raw_items.items());\n-        } else {\n-            log::error!(\"Too deep macro expansion: {:?}\", macro_call_id);\n-            self.poison_macros.insert(macro_def_id);\n         }\n+        None\n+    }\n \n-        self.macro_stack_monitor.decrease(macro_def_id);\n+    fn collect_macro_expansion(&mut self, module_id: LocalModuleId, macro_call_id: MacroCallId) {\n+        let file_id: HirFileId = macro_call_id.as_file();\n+        let raw_items = self.db.raw_items(file_id);\n+        let mod_dir = self.mod_dirs[&module_id].clone();\n+        ModCollector {\n+            def_collector: &mut *self,\n+            file_id,\n+            module_id,\n+            raw_items: &raw_items,\n+            mod_dir,\n+        }\n+        .collect(raw_items.items());\n     }\n \n     fn finish(self) -> CrateDefMap {\n@@ -581,20 +597,31 @@ where\n                     raw::RawItemKind::Module(m) => {\n                         self.collect_module(&self.raw_items[m], &item.attrs)\n                     }\n-                    raw::RawItemKind::Import(import_id) => self\n-                        .def_collector\n-                        .unresolved_imports\n-                        .push((self.module_id, import_id, self.raw_items[import_id].clone())),\n-                    raw::RawItemKind::Def(def) => self.define_def(&self.raw_items[def]),\n+                    raw::RawItemKind::Import(import_id) => {\n+                        self.def_collector.unresolved_imports.push(ImportDirective {\n+                            module_id: self.module_id,\n+                            import_id,\n+                            import: self.raw_items[import_id].clone(),\n+                            status: PartialResolvedImport::Unresolved,\n+                        })\n+                    }\n+                    raw::RawItemKind::Def(def) => {\n+                        self.define_def(&self.raw_items[def], &item.attrs)\n+                    }\n                     raw::RawItemKind::Macro(mac) => self.collect_macro(&self.raw_items[mac]),\n                     raw::RawItemKind::Impl(imp) => {\n                         let module = ModuleId {\n                             krate: self.def_collector.def_map.krate,\n                             local_id: self.module_id,\n                         };\n-                        let ctx = LocationCtx::new(self.def_collector.db, module, self.file_id);\n-                        let imp_id = ImplId::from_ast_id(ctx, self.raw_items[imp].ast_id);\n-                        self.def_collector.def_map.modules[self.module_id].impls.push(imp_id)\n+                        let container = ContainerId::ModuleId(module);\n+                        let ast_id = self.raw_items[imp].ast_id;\n+                        let impl_id =\n+                            ImplLoc { container, ast_id: AstId::new(self.file_id, ast_id) }\n+                                .intern(self.def_collector.db);\n+                        self.def_collector.def_map.modules[self.module_id]\n+                            .scope\n+                            .define_impl(impl_id)\n                     }\n                 }\n             }\n@@ -667,72 +694,91 @@ where\n         let modules = &mut self.def_collector.def_map.modules;\n         let res = modules.alloc(ModuleData::default());\n         modules[res].parent = Some(self.module_id);\n-        modules[res].declaration = Some(declaration);\n-        modules[res].definition = definition;\n-        modules[res].scope.legacy_macros = modules[self.module_id].scope.legacy_macros.clone();\n+        modules[res].origin = ModuleOrigin::not_sure_file(definition, declaration);\n+        for (name, mac) in modules[self.module_id].scope.collect_legacy_macros() {\n+            modules[res].scope.define_legacy_macro(name, mac)\n+        }\n         modules[self.module_id].children.insert(name.clone(), res);\n-        let resolution = Resolution {\n-            def: PerNs::types(\n-                ModuleId { krate: self.def_collector.def_map.krate, local_id: res }.into(),\n-            ),\n-            import: None,\n-        };\n-        self.def_collector.update(self.module_id, None, &[(name, resolution)]);\n+        let module = ModuleId { krate: self.def_collector.def_map.krate, local_id: res };\n+        let def: ModuleDefId = module.into();\n+        self.def_collector.def_map.modules[self.module_id].scope.define_def(def);\n+        self.def_collector.update(self.module_id, &[(name, def.into())]);\n         res\n     }\n \n-    fn define_def(&mut self, def: &raw::DefData) {\n+    fn define_def(&mut self, def: &raw::DefData, attrs: &Attrs) {\n         let module = ModuleId { krate: self.def_collector.def_map.krate, local_id: self.module_id };\n-        let ctx = LocationCtx::new(self.def_collector.db, module, self.file_id);\n+        // FIXME: check attrs to see if this is an attribute macro invocation;\n+        // in which case we don't add the invocation, just a single attribute\n+        // macro invocation\n \n-        let name = def.name.clone();\n-        let def: PerNs = match def.kind {\n-            raw::DefKind::Function(ast_id) => {\n-                let def = FunctionLoc {\n-                    container: ContainerId::ModuleId(module),\n-                    ast_id: AstId::new(self.file_id, ast_id),\n-                }\n-                .intern(self.def_collector.db);\n+        self.collect_derives(attrs, def);\n \n-                PerNs::values(def.into())\n+        let name = def.name.clone();\n+        let container = ContainerId::ModuleId(module);\n+        let def: ModuleDefId = match def.kind {\n+            raw::DefKind::Function(ast_id) => FunctionLoc {\n+                container: container.into(),\n+                ast_id: AstId::new(self.file_id, ast_id),\n             }\n+            .intern(self.def_collector.db)\n+            .into(),\n             raw::DefKind::Struct(ast_id) => {\n-                let id = StructId::from_ast_id(ctx, ast_id).into();\n-                PerNs::both(id, id)\n+                StructLoc { container, ast_id: AstId::new(self.file_id, ast_id) }\n+                    .intern(self.def_collector.db)\n+                    .into()\n             }\n             raw::DefKind::Union(ast_id) => {\n-                let id = UnionId::from_ast_id(ctx, ast_id).into();\n-                PerNs::both(id, id)\n+                UnionLoc { container, ast_id: AstId::new(self.file_id, ast_id) }\n+                    .intern(self.def_collector.db)\n+                    .into()\n+            }\n+            raw::DefKind::Enum(ast_id) => {\n+                EnumLoc { container, ast_id: AstId::new(self.file_id, ast_id) }\n+                    .intern(self.def_collector.db)\n+                    .into()\n             }\n-            raw::DefKind::Enum(ast_id) => PerNs::types(EnumId::from_ast_id(ctx, ast_id).into()),\n             raw::DefKind::Const(ast_id) => {\n-                let def = ConstLoc {\n-                    container: ContainerId::ModuleId(module),\n-                    ast_id: AstId::new(self.file_id, ast_id),\n-                }\n-                .intern(self.def_collector.db);\n-\n-                PerNs::values(def.into())\n+                ConstLoc { container: container.into(), ast_id: AstId::new(self.file_id, ast_id) }\n+                    .intern(self.def_collector.db)\n+                    .into()\n             }\n             raw::DefKind::Static(ast_id) => {\n-                let def = StaticLoc { container: module, ast_id: AstId::new(self.file_id, ast_id) }\n-                    .intern(self.def_collector.db);\n-\n-                PerNs::values(def.into())\n+                StaticLoc { container, ast_id: AstId::new(self.file_id, ast_id) }\n+                    .intern(self.def_collector.db)\n+                    .into()\n             }\n-            raw::DefKind::Trait(ast_id) => PerNs::types(TraitId::from_ast_id(ctx, ast_id).into()),\n-            raw::DefKind::TypeAlias(ast_id) => {\n-                let def = TypeAliasLoc {\n-                    container: ContainerId::ModuleId(module),\n-                    ast_id: AstId::new(self.file_id, ast_id),\n-                }\n-                .intern(self.def_collector.db);\n-\n-                PerNs::types(def.into())\n+            raw::DefKind::Trait(ast_id) => {\n+                TraitLoc { container, ast_id: AstId::new(self.file_id, ast_id) }\n+                    .intern(self.def_collector.db)\n+                    .into()\n             }\n+            raw::DefKind::TypeAlias(ast_id) => TypeAliasLoc {\n+                container: container.into(),\n+                ast_id: AstId::new(self.file_id, ast_id),\n+            }\n+            .intern(self.def_collector.db)\n+            .into(),\n         };\n-        let resolution = Resolution { def, import: None };\n-        self.def_collector.update(self.module_id, None, &[(name, resolution)])\n+        self.def_collector.def_map.modules[self.module_id].scope.define_def(def);\n+        self.def_collector.update(self.module_id, &[(name, def.into())])\n+    }\n+\n+    fn collect_derives(&mut self, attrs: &Attrs, def: &raw::DefData) {\n+        for derive_subtree in attrs.by_key(\"derive\").tt_values() {\n+            // for #[derive(Copy, Clone)], `derive_subtree` is the `(Copy, Clone)` subtree\n+            for tt in &derive_subtree.token_trees {\n+                let ident = match &tt {\n+                    tt::TokenTree::Leaf(tt::Leaf::Ident(ident)) => ident,\n+                    tt::TokenTree::Leaf(tt::Leaf::Punct(_)) => continue, // , is ok\n+                    _ => continue, // anything else would be an error (which we currently ignore)\n+                };\n+                let path = ModPath::from_tt_ident(ident);\n+\n+                let ast_id = AstId::new(self.file_id, def.kind.ast_id());\n+                self.def_collector.unexpanded_attribute_macros.push((self.module_id, ast_id, path));\n+            }\n+        }\n     }\n \n     fn collect_macro(&mut self, mac: &raw::MacroData) {\n@@ -758,37 +804,49 @@ where\n         if is_macro_rules(&mac.path) {\n             if let Some(name) = &mac.name {\n                 let macro_id = MacroDefId {\n-                    ast_id,\n-                    krate: self.def_collector.def_map.krate,\n+                    ast_id: Some(ast_id),\n+                    krate: Some(self.def_collector.def_map.krate),\n                     kind: MacroDefKind::Declarative,\n                 };\n                 self.def_collector.define_macro(self.module_id, name.clone(), macro_id, mac.export);\n             }\n             return;\n         }\n \n-        // Case 2: try to resolve in legacy scope and expand macro_rules, triggering\n-        // recursive item collection.\n+        // Case 2: try to resolve in legacy scope and expand macro_rules\n         if let Some(macro_def) = mac.path.as_ident().and_then(|name| {\n             self.def_collector.def_map[self.module_id].scope.get_legacy_macro(&name)\n         }) {\n-            let macro_call_id = macro_def.as_call_id(self.def_collector.db, ast_id);\n+            let macro_call_id =\n+                macro_def.as_call_id(self.def_collector.db, MacroCallKind::FnLike(ast_id));\n+\n+            self.def_collector.unexpanded_macros.push(MacroDirective {\n+                module_id: self.module_id,\n+                path: mac.path.clone(),\n+                ast_id,\n+                legacy: Some(macro_call_id),\n+            });\n \n-            self.def_collector.collect_macro_expansion(self.module_id, macro_call_id, macro_def);\n             return;\n         }\n \n         // Case 3: resolve in module scope, expand during name resolution.\n         // We rewrite simple path `macro_name` to `self::macro_name` to force resolve in module scope only.\n         let mut path = mac.path.clone();\n         if path.is_ident() {\n-            path.kind = PathKind::Self_;\n+            path.kind = PathKind::Super(0);\n         }\n-        self.def_collector.unexpanded_macros.push((self.module_id, ast_id, path));\n+\n+        self.def_collector.unexpanded_macros.push(MacroDirective {\n+            module_id: self.module_id,\n+            path,\n+            ast_id,\n+            legacy: None,\n+        });\n     }\n \n     fn import_all_legacy_macros(&mut self, module_id: LocalModuleId) {\n-        let macros = self.def_collector.def_map[module_id].scope.legacy_macros.clone();\n+        let macros = self.def_collector.def_map[module_id].scope.collect_legacy_macros();\n         for (name, macro_) in macros {\n             self.def_collector.define_legacy_macro(self.module_id, name.clone(), macro_);\n         }\n@@ -803,45 +861,35 @@ where\n     }\n }\n \n-fn is_macro_rules(path: &Path) -> bool {\n-    path.as_ident() == Some(&name::MACRO_RULES)\n+fn is_macro_rules(path: &ModPath) -> bool {\n+    path.as_ident() == Some(&name![macro_rules])\n }\n \n #[cfg(test)]\n mod tests {\n+    use crate::{db::DefDatabase, test_db::TestDB};\n     use ra_arena::Arena;\n     use ra_db::{fixture::WithFixture, SourceDatabase};\n-    use rustc_hash::FxHashSet;\n-\n-    use crate::{db::DefDatabase, test_db::TestDB};\n \n     use super::*;\n \n-    fn do_collect_defs(\n-        db: &impl DefDatabase,\n-        def_map: CrateDefMap,\n-        monitor: MacroStackMonitor,\n-    ) -> (CrateDefMap, FxHashSet<MacroDefId>) {\n+    fn do_collect_defs(db: &impl DefDatabase, def_map: CrateDefMap) -> CrateDefMap {\n         let mut collector = DefCollector {\n             db,\n             def_map,\n             glob_imports: FxHashMap::default(),\n             unresolved_imports: Vec::new(),\n+            resolved_imports: Vec::new(),\n             unexpanded_macros: Vec::new(),\n+            unexpanded_attribute_macros: Vec::new(),\n             mod_dirs: FxHashMap::default(),\n-            macro_stack_monitor: monitor,\n-            poison_macros: FxHashSet::default(),\n             cfg_options: &CfgOptions::default(),\n         };\n         collector.collect();\n-        (collector.def_map, collector.poison_macros)\n+        collector.def_map\n     }\n \n-    fn do_limited_resolve(\n-        code: &str,\n-        limit: u32,\n-        poison_limit: u32,\n-    ) -> (CrateDefMap, FxHashSet<MacroDefId>) {\n+    fn do_resolve(code: &str) -> CrateDefMap {\n         let (db, _file_id) = TestDB::with_single_file(&code);\n         let krate = db.test_crate();\n \n@@ -859,59 +907,18 @@ mod tests {\n                 diagnostics: Vec::new(),\n             }\n         };\n-\n-        let mut monitor = MacroStackMonitor::default();\n-        monitor.validator = Some(Box::new(move |count| {\n-            assert!(count < limit);\n-            count >= poison_limit\n-        }));\n-\n-        do_collect_defs(&db, def_map, monitor)\n+        do_collect_defs(&db, def_map)\n     }\n \n     #[test]\n-    fn test_macro_expand_limit_width() {\n-        do_limited_resolve(\n+    fn test_macro_expand_will_stop() {\n+        do_resolve(\n             r#\"\n         macro_rules! foo {\n             ($($ty:ty)*) => { foo!($($ty)*, $($ty)*); }\n         }\n foo!(KABOOM);\n         \"#,\n-            16,\n-            1000,\n         );\n     }\n-\n-    #[test]\n-    fn test_macro_expand_poisoned() {\n-        let (_, poison_macros) = do_limited_resolve(\n-            r#\"\n-        macro_rules! foo {\n-            ($ty:ty) => { foo!($ty); }\n-        }\n-foo!(KABOOM);\n-        \"#,\n-            100,\n-            16,\n-        );\n-\n-        assert_eq!(poison_macros.len(), 1);\n-    }\n-\n-    #[test]\n-    fn test_macro_expand_normal() {\n-        let (_, poison_macros) = do_limited_resolve(\n-            r#\"\n-        macro_rules! foo {\n-            ($ident:ident) => { struct $ident {} }\n-        }\n-foo!(Bar);\n-        \"#,\n-            16,\n-            16,\n-        );\n-\n-        assert_eq!(poison_macros.len(), 0);\n-    }\n }"}, {"sha": "695014c7bb95dcea74065020110cce2d6e77e77e", "filename": "crates/ra_hir_def/src/nameres/path_resolution.rs", "status": "modified", "additions": 61, "deletions": 44, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -10,16 +10,18 @@\n //!\n //! `ReachedFixedPoint` signals about this.\n \n+use std::iter::successors;\n+\n use hir_expand::name::Name;\n use ra_db::Edition;\n use test_utils::tested_by;\n \n use crate::{\n     db::DefDatabase,\n-    nameres::CrateDefMap,\n-    path::{Path, PathKind},\n+    nameres::{BuiltinShadowMode, CrateDefMap},\n+    path::{ModPath, PathKind},\n     per_ns::PerNs,\n-    AdtId, EnumVariantId, LocalModuleId, ModuleDefId, ModuleId,\n+    AdtId, CrateId, EnumVariantId, LocalModuleId, ModuleDefId, ModuleId,\n };\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n@@ -39,19 +41,21 @@ pub(super) struct ResolvePathResult {\n     pub(super) resolved_def: PerNs,\n     pub(super) segment_index: Option<usize>,\n     pub(super) reached_fixedpoint: ReachedFixedPoint,\n+    pub(super) krate: Option<CrateId>,\n }\n \n impl ResolvePathResult {\n     fn empty(reached_fixedpoint: ReachedFixedPoint) -> ResolvePathResult {\n-        ResolvePathResult::with(PerNs::none(), reached_fixedpoint, None)\n+        ResolvePathResult::with(PerNs::none(), reached_fixedpoint, None, None)\n     }\n \n     fn with(\n         resolved_def: PerNs,\n         reached_fixedpoint: ReachedFixedPoint,\n         segment_index: Option<usize>,\n+        krate: Option<CrateId>,\n     ) -> ResolvePathResult {\n-        ResolvePathResult { resolved_def, reached_fixedpoint, segment_index }\n+        ResolvePathResult { resolved_def, reached_fixedpoint, segment_index, krate }\n     }\n }\n \n@@ -67,8 +71,18 @@ impl CrateDefMap {\n         db: &impl DefDatabase,\n         mode: ResolveMode,\n         original_module: LocalModuleId,\n-        path: &Path,\n+        path: &ModPath,\n+        shadow: BuiltinShadowMode,\n     ) -> ResolvePathResult {\n+        // if it is not the last segment, we prefer the module to the builtin\n+        let prefer_module = |index| {\n+            if index == path.segments.len() - 1 {\n+                shadow\n+            } else {\n+                BuiltinShadowMode::Module\n+            }\n+        };\n+\n         let mut segments = path.segments.iter().enumerate();\n         let mut curr_per_ns: PerNs = match path.kind {\n             PathKind::DollarCrate(krate) => {\n@@ -85,9 +99,6 @@ impl CrateDefMap {\n             PathKind::Crate => {\n                 PerNs::types(ModuleId { krate: self.krate, local_id: self.root }.into())\n             }\n-            PathKind::Self_ => {\n-                PerNs::types(ModuleId { krate: self.krate, local_id: original_module }.into())\n-            }\n             // plain import or absolute path in 2015: crate-relative with\n             // fallback to extern prelude (with the simplification in\n             // rust-lang/rust#57745)\n@@ -96,24 +107,26 @@ impl CrateDefMap {\n                 if self.edition == Edition::Edition2015\n                     && (path.kind == PathKind::Abs || mode == ResolveMode::Import) =>\n             {\n-                let segment = match segments.next() {\n-                    Some((_, segment)) => segment,\n+                let (idx, segment) = match segments.next() {\n+                    Some((idx, segment)) => (idx, segment),\n                     None => return ResolvePathResult::empty(ReachedFixedPoint::Yes),\n                 };\n                 log::debug!(\"resolving {:?} in crate root (+ extern prelude)\", segment);\n-                self.resolve_name_in_crate_root_or_extern_prelude(&segment.name)\n+                self.resolve_name_in_crate_root_or_extern_prelude(&segment, prefer_module(idx))\n             }\n             PathKind::Plain => {\n-                let segment = match segments.next() {\n-                    Some((_, segment)) => segment,\n+                let (idx, segment) = match segments.next() {\n+                    Some((idx, segment)) => (idx, segment),\n                     None => return ResolvePathResult::empty(ReachedFixedPoint::Yes),\n                 };\n                 log::debug!(\"resolving {:?} in module\", segment);\n-                self.resolve_name_in_module(db, original_module, &segment.name)\n+                self.resolve_name_in_module(db, original_module, &segment, prefer_module(idx))\n             }\n-            PathKind::Super => {\n-                if let Some(p) = self.modules[original_module].parent {\n-                    PerNs::types(ModuleId { krate: self.krate, local_id: p }.into())\n+            PathKind::Super(lvl) => {\n+                let m = successors(Some(original_module), |m| self.modules[*m].parent)\n+                    .nth(lvl as usize);\n+                if let Some(local_id) = m {\n+                    PerNs::types(ModuleId { krate: self.krate, local_id }.into())\n                 } else {\n                     log::debug!(\"super path in root module\");\n                     return ResolvePathResult::empty(ReachedFixedPoint::Yes);\n@@ -125,18 +138,13 @@ impl CrateDefMap {\n                     Some((_, segment)) => segment,\n                     None => return ResolvePathResult::empty(ReachedFixedPoint::Yes),\n                 };\n-                if let Some(def) = self.extern_prelude.get(&segment.name) {\n+                if let Some(def) = self.extern_prelude.get(&segment) {\n                     log::debug!(\"absolute path {:?} resolved to crate {:?}\", path, def);\n                     PerNs::types(*def)\n                 } else {\n                     return ResolvePathResult::empty(ReachedFixedPoint::No); // extern crate declarations can add to the extern prelude\n                 }\n             }\n-            PathKind::Type(_) => {\n-                // This is handled in `infer::infer_path_expr`\n-                // The result returned here does not matter\n-                return ResolvePathResult::empty(ReachedFixedPoint::Yes);\n-            }\n         };\n \n         for (i, segment) in segments {\n@@ -156,32 +164,29 @@ impl CrateDefMap {\n             curr_per_ns = match curr {\n                 ModuleDefId::ModuleId(module) => {\n                     if module.krate != self.krate {\n-                        let path =\n-                            Path { segments: path.segments[i..].to_vec(), kind: PathKind::Self_ };\n+                        let path = ModPath {\n+                            segments: path.segments[i..].to_vec(),\n+                            kind: PathKind::Super(0),\n+                        };\n                         log::debug!(\"resolving {:?} in other crate\", path);\n                         let defp_map = db.crate_def_map(module.krate);\n-                        let (def, s) = defp_map.resolve_path(db, module.local_id, &path);\n+                        let (def, s) = defp_map.resolve_path(db, module.local_id, &path, shadow);\n                         return ResolvePathResult::with(\n                             def,\n                             ReachedFixedPoint::Yes,\n                             s.map(|s| s + i),\n+                            Some(module.krate),\n                         );\n                     }\n \n                     // Since it is a qualified path here, it should not contains legacy macros\n-                    match self[module.local_id].scope.get(&segment.name) {\n-                        Some(res) => res.def,\n-                        _ => {\n-                            log::debug!(\"path segment {:?} not found\", segment.name);\n-                            return ResolvePathResult::empty(ReachedFixedPoint::No);\n-                        }\n-                    }\n+                    self[module.local_id].scope.get(&segment, prefer_module(i))\n                 }\n                 ModuleDefId::AdtId(AdtId::EnumId(e)) => {\n                     // enum variant\n                     tested_by!(can_import_enum_variant);\n                     let enum_data = db.enum_data(e);\n-                    match enum_data.variant(&segment.name) {\n+                    match enum_data.variant(&segment) {\n                         Some(local_id) => {\n                             let variant = EnumVariantId { parent: e, local_id };\n                             PerNs::both(variant.into(), variant.into())\n@@ -191,6 +196,7 @@ impl CrateDefMap {\n                                 PerNs::types(e.into()),\n                                 ReachedFixedPoint::Yes,\n                                 Some(i),\n+                                Some(self.krate),\n                             );\n                         }\n                     }\n@@ -200,26 +206,29 @@ impl CrateDefMap {\n                     // (`Struct::method`), or some other kind of associated item\n                     log::debug!(\n                         \"path segment {:?} resolved to non-module {:?}, but is not last\",\n-                        segment.name,\n+                        segment,\n                         curr,\n                     );\n \n                     return ResolvePathResult::with(\n                         PerNs::types(s),\n                         ReachedFixedPoint::Yes,\n                         Some(i),\n+                        Some(self.krate),\n                     );\n                 }\n             };\n         }\n-        ResolvePathResult::with(curr_per_ns, ReachedFixedPoint::Yes, None)\n+\n+        ResolvePathResult::with(curr_per_ns, ReachedFixedPoint::Yes, None, Some(self.krate))\n     }\n \n     fn resolve_name_in_module(\n         &self,\n         db: &impl DefDatabase,\n         module: LocalModuleId,\n         name: &Name,\n+        shadow: BuiltinShadowMode,\n     ) -> PerNs {\n         // Resolve in:\n         //  - legacy scope of macro\n@@ -228,23 +237,31 @@ impl CrateDefMap {\n         //  - std prelude\n         let from_legacy_macro =\n             self[module].scope.get_legacy_macro(name).map_or_else(PerNs::none, PerNs::macros);\n-        let from_scope = self[module].scope.get(name).map_or_else(PerNs::none, |res| res.def);\n+        let from_scope = self[module].scope.get(name, shadow);\n         let from_extern_prelude =\n             self.extern_prelude.get(name).map_or(PerNs::none(), |&it| PerNs::types(it));\n-        let from_prelude = self.resolve_in_prelude(db, name);\n+        let from_prelude = self.resolve_in_prelude(db, name, shadow);\n \n         from_legacy_macro.or(from_scope).or(from_extern_prelude).or(from_prelude)\n     }\n \n-    fn resolve_name_in_crate_root_or_extern_prelude(&self, name: &Name) -> PerNs {\n-        let from_crate_root =\n-            self[self.root].scope.get(name).map_or_else(PerNs::none, |res| res.def);\n+    fn resolve_name_in_crate_root_or_extern_prelude(\n+        &self,\n+        name: &Name,\n+        shadow: BuiltinShadowMode,\n+    ) -> PerNs {\n+        let from_crate_root = self[self.root].scope.get(name, shadow);\n         let from_extern_prelude = self.resolve_name_in_extern_prelude(name);\n \n         from_crate_root.or(from_extern_prelude)\n     }\n \n-    fn resolve_in_prelude(&self, db: &impl DefDatabase, name: &Name) -> PerNs {\n+    fn resolve_in_prelude(\n+        &self,\n+        db: &impl DefDatabase,\n+        name: &Name,\n+        shadow: BuiltinShadowMode,\n+    ) -> PerNs {\n         if let Some(prelude) = self.prelude {\n             let keep;\n             let def_map = if prelude.krate == self.krate {\n@@ -254,7 +271,7 @@ impl CrateDefMap {\n                 keep = db.crate_def_map(prelude.krate);\n                 &keep\n             };\n-            def_map[prelude.local_id].scope.get(name).map_or_else(PerNs::none, |res| res.def)\n+            def_map[prelude.local_id].scope.get(name, shadow)\n         } else {\n             PerNs::none()\n         }"}, {"sha": "73dc0874595312a1426361ce0c8d9562472e201c", "filename": "crates/ra_hir_def/src/nameres/raw.rs", "status": "modified", "additions": 43, "deletions": 62, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -10,21 +10,18 @@ use std::{ops::Index, sync::Arc};\n use hir_expand::{\n     ast_id_map::AstIdMap,\n     db::AstDatabase,\n-    either::Either,\n     hygiene::Hygiene,\n     name::{AsName, Name},\n };\n-use ra_arena::{impl_arena_id, map::ArenaMap, Arena, RawId};\n+use ra_arena::{impl_arena_id, Arena, RawId};\n+use ra_prof::profile;\n use ra_syntax::{\n     ast::{self, AttrsOwner, NameOwner},\n-    AstNode, AstPtr,\n+    AstNode,\n };\n use test_utils::tested_by;\n \n-use crate::{\n-    attr::Attrs, db::DefDatabase, path::Path, trace::Trace, FileAstId, HirFileId, LocalImportId,\n-    Source,\n-};\n+use crate::{attr::Attrs, db::DefDatabase, path::ModPath, FileAstId, HirFileId, InFile};\n \n /// `RawItems` is a set of top-level items in a file (except for impls).\n ///\n@@ -33,43 +30,23 @@ use crate::{\n #[derive(Debug, Default, PartialEq, Eq)]\n pub struct RawItems {\n     modules: Arena<Module, ModuleData>,\n-    imports: Arena<LocalImportId, ImportData>,\n+    imports: Arena<Import, ImportData>,\n     defs: Arena<Def, DefData>,\n     macros: Arena<Macro, MacroData>,\n     impls: Arena<Impl, ImplData>,\n     /// items for top-level module\n     items: Vec<RawItem>,\n }\n \n-#[derive(Debug, Default, PartialEq, Eq)]\n-pub struct ImportSourceMap {\n-    map: ArenaMap<LocalImportId, ImportSourcePtr>,\n-}\n-\n-type ImportSourcePtr = Either<AstPtr<ast::UseTree>, AstPtr<ast::ExternCrateItem>>;\n-\n-impl ImportSourceMap {\n-    pub fn get(&self, import: LocalImportId) -> ImportSourcePtr {\n-        self.map[import].clone()\n-    }\n-}\n-\n impl RawItems {\n     pub(crate) fn raw_items_query(\n         db: &(impl DefDatabase + AstDatabase),\n         file_id: HirFileId,\n     ) -> Arc<RawItems> {\n-        db.raw_items_with_source_map(file_id).0\n-    }\n-\n-    pub(crate) fn raw_items_with_source_map_query(\n-        db: &(impl DefDatabase + AstDatabase),\n-        file_id: HirFileId,\n-    ) -> (Arc<RawItems>, Arc<ImportSourceMap>) {\n+        let _p = profile(\"raw_items_query\");\n         let mut collector = RawItemsCollector {\n             raw_items: RawItems::default(),\n             source_ast_id_map: db.ast_id_map(file_id),\n-            imports: Trace::new(),\n             file_id,\n             hygiene: Hygiene::new(db, file_id),\n         };\n@@ -80,11 +57,8 @@ impl RawItems {\n                 collector.process_module(None, item_list);\n             }\n         }\n-        let mut raw_items = collector.raw_items;\n-        let (arena, map) = collector.imports.into_arena_and_map();\n-        raw_items.imports = arena;\n-        let source_map = ImportSourceMap { map };\n-        (Arc::new(raw_items), Arc::new(source_map))\n+        let raw_items = collector.raw_items;\n+        Arc::new(raw_items)\n     }\n \n     pub(super) fn items(&self) -> &[RawItem] {\n@@ -99,9 +73,9 @@ impl Index<Module> for RawItems {\n     }\n }\n \n-impl Index<LocalImportId> for RawItems {\n+impl Index<Import> for RawItems {\n     type Output = ImportData;\n-    fn index(&self, idx: LocalImportId) -> &ImportData {\n+    fn index(&self, idx: Import) -> &ImportData {\n         &self.imports[idx]\n     }\n }\n@@ -136,7 +110,7 @@ pub(super) struct RawItem {\n #[derive(Debug, PartialEq, Eq, Clone, Copy)]\n pub(super) enum RawItemKind {\n     Module(Module),\n-    Import(LocalImportId),\n+    Import(Import),\n     Def(Def),\n     Macro(Macro),\n     Impl(Impl),\n@@ -152,9 +126,13 @@ pub(super) enum ModuleData {\n     Definition { name: Name, ast_id: FileAstId<ast::Module>, items: Vec<RawItem> },\n }\n \n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub(crate) struct Import(RawId);\n+impl_arena_id!(Import);\n+\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct ImportData {\n-    pub(super) path: Path,\n+    pub(super) path: ModPath,\n     pub(super) alias: Option<Name>,\n     pub(super) is_glob: bool,\n     pub(super) is_prelude: bool,\n@@ -184,14 +162,29 @@ pub(super) enum DefKind {\n     TypeAlias(FileAstId<ast::TypeAliasDef>),\n }\n \n+impl DefKind {\n+    pub fn ast_id(&self) -> FileAstId<ast::ModuleItem> {\n+        match self {\n+            DefKind::Function(it) => it.upcast(),\n+            DefKind::Struct(it) => it.upcast(),\n+            DefKind::Union(it) => it.upcast(),\n+            DefKind::Enum(it) => it.upcast(),\n+            DefKind::Const(it) => it.upcast(),\n+            DefKind::Static(it) => it.upcast(),\n+            DefKind::Trait(it) => it.upcast(),\n+            DefKind::TypeAlias(it) => it.upcast(),\n+        }\n+    }\n+}\n+\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub(super) struct Macro(RawId);\n impl_arena_id!(Macro);\n \n #[derive(Debug, PartialEq, Eq)]\n pub(super) struct MacroData {\n     pub(super) ast_id: FileAstId<ast::MacroCall>,\n-    pub(super) path: Path,\n+    pub(super) path: ModPath,\n     pub(super) name: Option<Name>,\n     pub(super) export: bool,\n     pub(super) builtin: bool,\n@@ -208,7 +201,6 @@ pub(super) struct ImplData {\n \n struct RawItemsCollector {\n     raw_items: RawItems,\n-    imports: Trace<LocalImportId, ImportData, ImportSourcePtr>,\n     source_ast_id_map: Arc<AstIdMap>,\n     file_id: HirFileId,\n     hygiene: Hygiene,\n@@ -312,10 +304,10 @@ impl RawItemsCollector {\n         let attrs = self.parse_attrs(&use_item);\n \n         let mut buf = Vec::new();\n-        Path::expand_use_item(\n-            Source { value: use_item, file_id: self.file_id },\n+        ModPath::expand_use_item(\n+            InFile { value: use_item, file_id: self.file_id },\n             &self.hygiene,\n-            |path, use_tree, is_glob, alias| {\n+            |path, _use_tree, is_glob, alias| {\n                 let import_data = ImportData {\n                     path,\n                     alias,\n@@ -324,11 +316,11 @@ impl RawItemsCollector {\n                     is_extern_crate: false,\n                     is_macro_use: false,\n                 };\n-                buf.push((import_data, Either::A(AstPtr::new(use_tree))));\n+                buf.push(import_data);\n             },\n         );\n-        for (import_data, ptr) in buf {\n-            self.push_import(current_module, attrs.clone(), import_data, ptr);\n+        for import_data in buf {\n+            self.push_import(current_module, attrs.clone(), import_data);\n         }\n     }\n \n@@ -338,7 +330,7 @@ impl RawItemsCollector {\n         extern_crate: ast::ExternCrateItem,\n     ) {\n         if let Some(name_ref) = extern_crate.name_ref() {\n-            let path = Path::from_name_ref(&name_ref);\n+            let path = ModPath::from_name_ref(&name_ref);\n             let alias = extern_crate.alias().and_then(|a| a.name()).map(|it| it.as_name());\n             let attrs = self.parse_attrs(&extern_crate);\n             // FIXME: cfg_attr\n@@ -351,18 +343,13 @@ impl RawItemsCollector {\n                 is_extern_crate: true,\n                 is_macro_use,\n             };\n-            self.push_import(\n-                current_module,\n-                attrs,\n-                import_data,\n-                Either::B(AstPtr::new(&extern_crate)),\n-            );\n+            self.push_import(current_module, attrs, import_data);\n         }\n     }\n \n     fn add_macro(&mut self, current_module: Option<Module>, m: ast::MacroCall) {\n         let attrs = self.parse_attrs(&m);\n-        let path = match m.path().and_then(|path| Path::from_src(path, &self.hygiene)) {\n+        let path = match m.path().and_then(|path| ModPath::from_src(path, &self.hygiene)) {\n             Some(it) => it,\n             _ => return,\n         };\n@@ -387,14 +374,8 @@ impl RawItemsCollector {\n         self.push_item(current_module, attrs, RawItemKind::Impl(imp))\n     }\n \n-    fn push_import(\n-        &mut self,\n-        current_module: Option<Module>,\n-        attrs: Attrs,\n-        data: ImportData,\n-        source: ImportSourcePtr,\n-    ) {\n-        let import = self.imports.alloc(|| source, || data);\n+    fn push_import(&mut self, current_module: Option<Module>, attrs: Attrs, data: ImportData) {\n+        let import = self.raw_items.imports.alloc(data);\n         self.push_item(current_module, attrs, RawItemKind::Import(import))\n     }\n "}, {"sha": "ff474b53b01eee6669bcbadf6ffd4ef9b2cf9c63", "filename": "crates/ra_hir_def/src/nameres/tests.rs", "status": "modified", "additions": 40, "deletions": 13, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -32,27 +32,22 @@ fn render_crate_def_map(map: &CrateDefMap) -> String {\n         *buf += path;\n         *buf += \"\\n\";\n \n-        let mut entries = map.modules[module]\n-            .scope\n-            .items\n-            .iter()\n-            .map(|(name, res)| (name, res.def))\n-            .collect::<Vec<_>>();\n-        entries.sort_by_key(|(name, _)| *name);\n-\n-        for (name, res) in entries {\n+        let mut entries = map.modules[module].scope.collect_resolutions();\n+        entries.sort_by_key(|(name, _)| name.clone());\n+\n+        for (name, def) in entries {\n             *buf += &format!(\"{}:\", name);\n \n-            if res.types.is_some() {\n+            if def.types.is_some() {\n                 *buf += \" t\";\n             }\n-            if res.values.is_some() {\n+            if def.values.is_some() {\n                 *buf += \" v\";\n             }\n-            if res.macros.is_some() {\n+            if def.macros.is_some() {\n                 *buf += \" m\";\n             }\n-            if res.is_none() {\n+            if def.is_none() {\n                 *buf += \" _\";\n             }\n \n@@ -558,3 +553,35 @@ fn cfg_test() {\n         \u22eeFoo: t v\n     \"###);\n }\n+\n+#[test]\n+fn infer_multiple_namespace() {\n+    let map = def_map(\n+        r#\"\n+//- /main.rs\n+mod a {\n+    pub type T = ();\n+    pub use crate::b::*;\n+}\n+\n+use crate::a::T;\n+\n+mod b {\n+    pub const T: () = ();\n+}\n+\"#,\n+    );\n+\n+    assert_snapshot!(map, @r###\"\n+    \u22eecrate\n+    \u22eeT: t v\n+    \u22eea: t\n+    \u22eeb: t\n+    \u22ee\n+    \u22eecrate::b\n+    \u22eeT: v\n+    \u22ee\n+    \u22eecrate::a\n+    \u22eeT: t v\n+\"###);\n+}"}, {"sha": "5e24cb94d64dc97fcb141557979c3b7bda5ce97d", "filename": "crates/ra_hir_def/src/nameres/tests/globs.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fglobs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fglobs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fglobs.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -112,3 +112,24 @@ fn glob_enum() {\n     \"###\n     );\n }\n+\n+#[test]\n+fn glob_enum_group() {\n+    covers!(glob_enum_group);\n+    let map = def_map(\n+        \"\n+        //- /lib.rs\n+        enum Foo {\n+            Bar, Baz\n+        }\n+        use self::Foo::{*};\n+        \",\n+    );\n+    assert_snapshot!(map, @r###\"\n+   \u22eecrate\n+   \u22eeBar: t v\n+   \u22eeBaz: t v\n+   \u22eeFoo: t\n+    \"###\n+    );\n+}"}, {"sha": "ef2e9435cf64b4f57926e25d65d0167accde5afd", "filename": "crates/ra_hir_def/src/nameres/tests/incremental.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -116,7 +116,7 @@ fn typing_inside_a_macro_should_not_invalidate_def_map() {\n         let events = db.log_executed(|| {\n             let crate_def_map = db.crate_def_map(krate);\n             let (_, module_data) = crate_def_map.modules.iter().last().unwrap();\n-            assert_eq!(module_data.scope.items.len(), 1);\n+            assert_eq!(module_data.scope.collect_resolutions().len(), 1);\n         });\n         assert!(format!(\"{:?}\", events).contains(\"crate_def_map\"), \"{:#?}\", events)\n     }\n@@ -126,7 +126,7 @@ fn typing_inside_a_macro_should_not_invalidate_def_map() {\n         let events = db.log_executed(|| {\n             let crate_def_map = db.crate_def_map(krate);\n             let (_, module_data) = crate_def_map.modules.iter().last().unwrap();\n-            assert_eq!(module_data.scope.items.len(), 1);\n+            assert_eq!(module_data.scope.collect_resolutions().len(), 1);\n         });\n         assert!(!format!(\"{:?}\", events).contains(\"crate_def_map\"), \"{:#?}\", events)\n     }"}, {"sha": "d104f5993fe3aecd71f29df183a3744a43a62fa0", "filename": "crates/ra_hir_def/src/nameres/tests/macros.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -600,3 +600,27 @@ fn macro_dollar_crate_is_correct_in_indirect_deps() {\n         \u22eebar: t v\n     \"###);\n }\n+\n+#[test]\n+fn expand_derive() {\n+    let map = compute_crate_def_map(\n+        \"\n+        //- /main.rs\n+        #[derive(Clone)]\n+        struct Foo;\n+        \",\n+    );\n+    assert_eq!(map.modules[map.root].scope.impls().len(), 1);\n+}\n+\n+#[test]\n+fn expand_multiple_derive() {\n+    let map = compute_crate_def_map(\n+        \"\n+        //- /main.rs\n+        #[derive(Copy, Clone)]\n+        struct Foo;\n+        \",\n+    );\n+    assert_eq!(map.modules[map.root].scope.impls().len(), 2);\n+}"}, {"sha": "e800cc68e4e43a31b3800397f50028e862821911", "filename": "crates/ra_hir_def/src/nameres/tests/mod_resolution.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -668,15 +668,15 @@ fn unresolved_module_diagnostics() {\n             module: LocalModuleId(\n                 0,\n             ),\n-            declaration: AstId {\n+            declaration: InFile {\n                 file_id: HirFileId(\n                     FileId(\n                         FileId(\n                             0,\n                         ),\n                     ),\n                 ),\n-                file_ast_id: FileAstId {\n+                value: FileAstId {\n                     raw: ErasedFileAstId(\n                         1,\n                     ),"}, {"sha": "8e12942011c547148e8e7fd57e7398497263d065", "filename": "crates/ra_hir_def/src/path.rs", "status": "modified", "additions": 190, "deletions": 337, "changes": 527, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fpath.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -1,35 +1,97 @@\n //! A desugared representation of paths like `crate::foo` or `<Type as Trait>::bar`.\n+mod lower;\n \n use std::{iter, sync::Arc};\n \n use hir_expand::{\n-    either::Either,\n     hygiene::Hygiene,\n-    name::{self, AsName, Name},\n+    name::{AsName, Name},\n };\n use ra_db::CrateId;\n-use ra_syntax::{\n-    ast::{self, NameOwner, TypeAscriptionOwner},\n-    AstNode,\n-};\n+use ra_syntax::ast;\n \n-use crate::{type_ref::TypeRef, Source};\n+use crate::{type_ref::TypeRef, InFile};\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Path {\n+pub struct ModPath {\n     pub kind: PathKind,\n-    pub segments: Vec<PathSegment>,\n+    pub segments: Vec<Name>,\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct PathSegment {\n-    pub name: Name,\n-    pub args_and_bindings: Option<Arc<GenericArgs>>,\n+pub enum PathKind {\n+    Plain,\n+    /// `self::` is `Super(0)`\n+    Super(u8),\n+    Crate,\n+    /// Absolute path (::foo)\n+    Abs,\n+    /// `$crate` from macro expansion\n+    DollarCrate(CrateId),\n+}\n+\n+impl ModPath {\n+    pub fn from_src(path: ast::Path, hygiene: &Hygiene) -> Option<ModPath> {\n+        lower::lower_path(path, hygiene).map(|it| it.mod_path)\n+    }\n+\n+    pub fn from_simple_segments(\n+        kind: PathKind,\n+        segments: impl IntoIterator<Item = Name>,\n+    ) -> ModPath {\n+        let segments = segments.into_iter().collect::<Vec<_>>();\n+        ModPath { kind, segments }\n+    }\n+\n+    pub(crate) fn from_name_ref(name_ref: &ast::NameRef) -> ModPath {\n+        name_ref.as_name().into()\n+    }\n+\n+    /// Converts an `tt::Ident` into a single-identifier `Path`.\n+    pub(crate) fn from_tt_ident(ident: &tt::Ident) -> ModPath {\n+        ident.as_name().into()\n+    }\n+\n+    /// Calls `cb` with all paths, represented by this use item.\n+    pub(crate) fn expand_use_item(\n+        item_src: InFile<ast::UseItem>,\n+        hygiene: &Hygiene,\n+        mut cb: impl FnMut(ModPath, &ast::UseTree, /* is_glob */ bool, Option<Name>),\n+    ) {\n+        if let Some(tree) = item_src.value.use_tree() {\n+            lower::lower_use_tree(None, tree, hygiene, &mut cb);\n+        }\n+    }\n+\n+    pub fn is_ident(&self) -> bool {\n+        self.kind == PathKind::Plain && self.segments.len() == 1\n+    }\n+\n+    pub fn is_self(&self) -> bool {\n+        self.kind == PathKind::Super(0) && self.segments.is_empty()\n+    }\n+\n+    /// If this path is a single identifier, like `foo`, return its name.\n+    pub fn as_ident(&self) -> Option<&Name> {\n+        if self.kind != PathKind::Plain || self.segments.len() > 1 {\n+            return None;\n+        }\n+        self.segments.first()\n+    }\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Path {\n+    /// Type based path like `<T>::foo`.\n+    /// Note that paths like `<Type as Trait>::foo` are desugard to `Trait::<Self=Type>::foo`.\n+    type_anchor: Option<Box<TypeRef>>,\n+    mod_path: ModPath,\n+    /// Invariant: the same len as self.path.segments\n+    generic_args: Vec<Option<Arc<GenericArgs>>>,\n }\n \n /// Generic arguments to a path segment (e.g. the `i32` in `Option<i32>`). This\n-/// can (in the future) also include bindings of associated types, like in\n-/// `Iterator<Item = Foo>`.\n+/// also includes bindings of associated types, like in `Iterator<Item = Foo>`.\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct GenericArgs {\n     pub args: Vec<GenericArg>,\n@@ -50,234 +112,111 @@ pub enum GenericArg {\n     // or lifetime...\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub enum PathKind {\n-    Plain,\n-    Self_,\n-    Super,\n-    Crate,\n-    // Absolute path\n-    Abs,\n-    // Type based path like `<T>::foo`\n-    Type(Box<TypeRef>),\n-    // `$crate` from macro expansion\n-    DollarCrate(CrateId),\n-}\n-\n impl Path {\n-    /// Calls `cb` with all paths, represented by this use item.\n-    pub(crate) fn expand_use_item(\n-        item_src: Source<ast::UseItem>,\n-        hygiene: &Hygiene,\n-        mut cb: impl FnMut(Path, &ast::UseTree, bool, Option<Name>),\n-    ) {\n-        if let Some(tree) = item_src.value.use_tree() {\n-            expand_use_tree(None, tree, hygiene, &mut cb);\n-        }\n-    }\n-\n-    pub(crate) fn from_simple_segments(\n-        kind: PathKind,\n-        segments: impl IntoIterator<Item = Name>,\n-    ) -> Path {\n-        Path {\n-            kind,\n-            segments: segments\n-                .into_iter()\n-                .map(|name| PathSegment { name, args_and_bindings: None })\n-                .collect(),\n-        }\n-    }\n-\n     /// Converts an `ast::Path` to `Path`. Works with use trees.\n     /// DEPRECATED: It does not handle `$crate` from macro call.\n     pub fn from_ast(path: ast::Path) -> Option<Path> {\n-        Path::from_src(path, &Hygiene::new_unhygienic())\n+        lower::lower_path(path, &Hygiene::new_unhygienic())\n     }\n \n     /// Converts an `ast::Path` to `Path`. Works with use trees.\n     /// It correctly handles `$crate` based path from macro call.\n-    pub fn from_src(mut path: ast::Path, hygiene: &Hygiene) -> Option<Path> {\n-        let mut kind = PathKind::Plain;\n-        let mut segments = Vec::new();\n-        loop {\n-            let segment = path.segment()?;\n-\n-            if segment.has_colon_colon() {\n-                kind = PathKind::Abs;\n-            }\n-\n-            match segment.kind()? {\n-                ast::PathSegmentKind::Name(name_ref) => {\n-                    // FIXME: this should just return name\n-                    match hygiene.name_ref_to_name(name_ref) {\n-                        Either::A(name) => {\n-                            let args = segment\n-                                .type_arg_list()\n-                                .and_then(GenericArgs::from_ast)\n-                                .or_else(|| {\n-                                    GenericArgs::from_fn_like_path_ast(\n-                                        segment.param_list(),\n-                                        segment.ret_type(),\n-                                    )\n-                                })\n-                                .map(Arc::new);\n-                            let segment = PathSegment { name, args_and_bindings: args };\n-                            segments.push(segment);\n-                        }\n-                        Either::B(crate_id) => {\n-                            kind = PathKind::DollarCrate(crate_id);\n-                            break;\n-                        }\n-                    }\n-                }\n-                ast::PathSegmentKind::Type { type_ref, trait_ref } => {\n-                    assert!(path.qualifier().is_none()); // this can only occur at the first segment\n-\n-                    let self_type = TypeRef::from_ast(type_ref?);\n-\n-                    match trait_ref {\n-                        // <T>::foo\n-                        None => {\n-                            kind = PathKind::Type(Box::new(self_type));\n-                        }\n-                        // <T as Trait<A>>::Foo desugars to Trait<Self=T, A>::Foo\n-                        Some(trait_ref) => {\n-                            let path = Path::from_src(trait_ref.path()?, hygiene)?;\n-                            kind = path.kind;\n-                            let mut prefix_segments = path.segments;\n-                            prefix_segments.reverse();\n-                            segments.extend(prefix_segments);\n-                            // Insert the type reference (T in the above example) as Self parameter for the trait\n-                            let mut last_segment = segments.last_mut()?;\n-                            if last_segment.args_and_bindings.is_none() {\n-                                last_segment.args_and_bindings =\n-                                    Some(Arc::new(GenericArgs::empty()));\n-                            };\n-                            let args = last_segment.args_and_bindings.as_mut().unwrap();\n-                            let mut args_inner = Arc::make_mut(args);\n-                            args_inner.has_self_type = true;\n-                            args_inner.args.insert(0, GenericArg::Type(self_type));\n-                        }\n-                    }\n-                }\n-                ast::PathSegmentKind::CrateKw => {\n-                    kind = PathKind::Crate;\n-                    break;\n-                }\n-                ast::PathSegmentKind::SelfKw => {\n-                    kind = PathKind::Self_;\n-                    break;\n-                }\n-                ast::PathSegmentKind::SuperKw => {\n-                    kind = PathKind::Super;\n-                    break;\n-                }\n-            }\n-            path = match qualifier(&path) {\n-                Some(it) => it,\n-                None => break,\n-            };\n-        }\n-        segments.reverse();\n-        return Some(Path { kind, segments });\n-\n-        fn qualifier(path: &ast::Path) -> Option<ast::Path> {\n-            if let Some(q) = path.qualifier() {\n-                return Some(q);\n-            }\n-            // FIXME: this bottom up traversal is not too precise.\n-            // Should we handle do a top-down analysis, recording results?\n-            let use_tree_list = path.syntax().ancestors().find_map(ast::UseTreeList::cast)?;\n-            let use_tree = use_tree_list.parent_use_tree();\n-            use_tree.path()\n-        }\n+    pub fn from_src(path: ast::Path, hygiene: &Hygiene) -> Option<Path> {\n+        lower::lower_path(path, hygiene)\n     }\n \n     /// Converts an `ast::NameRef` into a single-identifier `Path`.\n     pub(crate) fn from_name_ref(name_ref: &ast::NameRef) -> Path {\n-        name_ref.as_name().into()\n+        Path { type_anchor: None, mod_path: name_ref.as_name().into(), generic_args: vec![None] }\n     }\n \n-    /// `true` is this path is a single identifier, like `foo`\n-    pub fn is_ident(&self) -> bool {\n-        self.kind == PathKind::Plain && self.segments.len() == 1\n+    pub fn kind(&self) -> &PathKind {\n+        &self.mod_path.kind\n     }\n \n-    /// `true` if this path is just a standalone `self`\n-    pub fn is_self(&self) -> bool {\n-        self.kind == PathKind::Self_ && self.segments.is_empty()\n+    pub fn type_anchor(&self) -> Option<&TypeRef> {\n+        self.type_anchor.as_deref()\n     }\n \n-    /// If this path is a single identifier, like `foo`, return its name.\n-    pub fn as_ident(&self) -> Option<&Name> {\n-        if self.kind != PathKind::Plain || self.segments.len() > 1 {\n-            return None;\n+    pub fn segments(&self) -> PathSegments<'_> {\n+        PathSegments {\n+            segments: self.mod_path.segments.as_slice(),\n+            generic_args: self.generic_args.as_slice(),\n         }\n-        self.segments.first().map(|s| &s.name)\n     }\n \n-    pub fn expand_macro_expr(&self) -> Option<Name> {\n-        self.as_ident().and_then(|name| Some(name.clone()))\n+    pub fn mod_path(&self) -> &ModPath {\n+        &self.mod_path\n     }\n \n-    pub fn is_type_relative(&self) -> bool {\n-        match self.kind {\n-            PathKind::Type(_) => true,\n-            _ => false,\n+    pub fn qualifier(&self) -> Option<Path> {\n+        if self.mod_path.is_ident() {\n+            return None;\n         }\n+        let res = Path {\n+            type_anchor: self.type_anchor.clone(),\n+            mod_path: ModPath {\n+                kind: self.mod_path.kind.clone(),\n+                segments: self.mod_path.segments[..self.mod_path.segments.len() - 1].to_vec(),\n+            },\n+            generic_args: self.generic_args[..self.generic_args.len() - 1].to_vec(),\n+        };\n+        Some(res)\n     }\n }\n \n-impl GenericArgs {\n-    pub(crate) fn from_ast(node: ast::TypeArgList) -> Option<GenericArgs> {\n-        let mut args = Vec::new();\n-        for type_arg in node.type_args() {\n-            let type_ref = TypeRef::from_ast_opt(type_arg.type_ref());\n-            args.push(GenericArg::Type(type_ref));\n-        }\n-        // lifetimes ignored for now\n-        let mut bindings = Vec::new();\n-        for assoc_type_arg in node.assoc_type_args() {\n-            if let Some(name_ref) = assoc_type_arg.name_ref() {\n-                let name = name_ref.as_name();\n-                let type_ref = TypeRef::from_ast_opt(assoc_type_arg.type_ref());\n-                bindings.push((name, type_ref));\n-            }\n-        }\n-        if args.is_empty() && bindings.is_empty() {\n-            None\n-        } else {\n-            Some(GenericArgs { args, has_self_type: false, bindings })\n-        }\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct PathSegment<'a> {\n+    pub name: &'a Name,\n+    pub args_and_bindings: Option<&'a GenericArgs>,\n+}\n+\n+pub struct PathSegments<'a> {\n+    segments: &'a [Name],\n+    generic_args: &'a [Option<Arc<GenericArgs>>],\n+}\n+\n+impl<'a> PathSegments<'a> {\n+    pub const EMPTY: PathSegments<'static> = PathSegments { segments: &[], generic_args: &[] };\n+    pub fn is_empty(&self) -> bool {\n+        self.len() == 0\n+    }\n+    pub fn len(&self) -> usize {\n+        self.segments.len()\n+    }\n+    pub fn first(&self) -> Option<PathSegment<'a>> {\n+        self.get(0)\n+    }\n+    pub fn last(&self) -> Option<PathSegment<'a>> {\n+        self.get(self.len().checked_sub(1)?)\n+    }\n+    pub fn get(&self, idx: usize) -> Option<PathSegment<'a>> {\n+        assert_eq!(self.segments.len(), self.generic_args.len());\n+        let res = PathSegment {\n+            name: self.segments.get(idx)?,\n+            args_and_bindings: self.generic_args.get(idx).unwrap().as_ref().map(|it| &**it),\n+        };\n+        Some(res)\n+    }\n+    pub fn skip(&self, len: usize) -> PathSegments<'a> {\n+        assert_eq!(self.segments.len(), self.generic_args.len());\n+        PathSegments { segments: &self.segments[len..], generic_args: &self.generic_args[len..] }\n+    }\n+    pub fn take(&self, len: usize) -> PathSegments<'a> {\n+        assert_eq!(self.segments.len(), self.generic_args.len());\n+        PathSegments { segments: &self.segments[..len], generic_args: &self.generic_args[..len] }\n+    }\n+    pub fn iter(&self) -> impl Iterator<Item = PathSegment<'a>> {\n+        self.segments.iter().zip(self.generic_args.iter()).map(|(name, args)| PathSegment {\n+            name,\n+            args_and_bindings: args.as_ref().map(|it| &**it),\n+        })\n     }\n+}\n \n-    /// Collect `GenericArgs` from the parts of a fn-like path, i.e. `Fn(X, Y)\n-    /// -> Z` (which desugars to `Fn<(X, Y), Output=Z>`).\n-    pub(crate) fn from_fn_like_path_ast(\n-        params: Option<ast::ParamList>,\n-        ret_type: Option<ast::RetType>,\n-    ) -> Option<GenericArgs> {\n-        let mut args = Vec::new();\n-        let mut bindings = Vec::new();\n-        if let Some(params) = params {\n-            let mut param_types = Vec::new();\n-            for param in params.params() {\n-                let type_ref = TypeRef::from_ast_opt(param.ascribed_type());\n-                param_types.push(type_ref);\n-            }\n-            let arg = GenericArg::Type(TypeRef::Tuple(param_types));\n-            args.push(arg);\n-        }\n-        if let Some(ret_type) = ret_type {\n-            let type_ref = TypeRef::from_ast_opt(ret_type.type_ref());\n-            bindings.push((name::OUTPUT_TYPE, type_ref))\n-        }\n-        if args.is_empty() && bindings.is_empty() {\n-            None\n-        } else {\n-            Some(GenericArgs { args, has_self_type: false, bindings })\n-        }\n+impl GenericArgs {\n+    pub(crate) fn from_ast(node: ast::TypeArgList) -> Option<GenericArgs> {\n+        lower::lower_generic_args(node)\n     }\n \n     pub(crate) fn empty() -> GenericArgs {\n@@ -287,137 +226,51 @@ impl GenericArgs {\n \n impl From<Name> for Path {\n     fn from(name: Name) -> Path {\n-        Path::from_simple_segments(PathKind::Plain, iter::once(name))\n+        Path {\n+            type_anchor: None,\n+            mod_path: ModPath::from_simple_segments(PathKind::Plain, iter::once(name)),\n+            generic_args: vec![None],\n+        }\n     }\n }\n \n-fn expand_use_tree(\n-    prefix: Option<Path>,\n-    tree: ast::UseTree,\n-    hygiene: &Hygiene,\n-    cb: &mut dyn FnMut(Path, &ast::UseTree, bool, Option<Name>),\n-) {\n-    if let Some(use_tree_list) = tree.use_tree_list() {\n-        let prefix = match tree.path() {\n-            // E.g. use something::{{{inner}}};\n-            None => prefix,\n-            // E.g. `use something::{inner}` (prefix is `None`, path is `something`)\n-            // or `use something::{path::{inner::{innerer}}}` (prefix is `something::path`, path is `inner`)\n-            Some(path) => match convert_path(prefix, path, hygiene) {\n-                Some(it) => Some(it),\n-                None => return, // FIXME: report errors somewhere\n-            },\n-        };\n-        for child_tree in use_tree_list.use_trees() {\n-            expand_use_tree(prefix.clone(), child_tree, hygiene, cb);\n-        }\n-    } else {\n-        let alias = tree.alias().and_then(|a| a.name()).map(|a| a.as_name());\n-        if let Some(ast_path) = tree.path() {\n-            // Handle self in a path.\n-            // E.g. `use something::{self, <...>}`\n-            if ast_path.qualifier().is_none() {\n-                if let Some(segment) = ast_path.segment() {\n-                    if segment.kind() == Some(ast::PathSegmentKind::SelfKw) {\n-                        if let Some(prefix) = prefix {\n-                            cb(prefix, &tree, false, alias);\n-                            return;\n-                        }\n-                    }\n-                }\n-            }\n-            if let Some(path) = convert_path(prefix, ast_path, hygiene) {\n-                let is_glob = tree.has_star();\n-                cb(path, &tree, is_glob, alias)\n-            }\n-            // FIXME: report errors somewhere\n-            // We get here if we do\n-        }\n+impl From<Name> for ModPath {\n+    fn from(name: Name) -> ModPath {\n+        ModPath::from_simple_segments(PathKind::Plain, iter::once(name))\n     }\n }\n \n-fn convert_path(prefix: Option<Path>, path: ast::Path, hygiene: &Hygiene) -> Option<Path> {\n-    let prefix = if let Some(qual) = path.qualifier() {\n-        Some(convert_path(prefix, qual, hygiene)?)\n-    } else {\n-        prefix\n-    };\n-\n-    let segment = path.segment()?;\n-    let res = match segment.kind()? {\n-        ast::PathSegmentKind::Name(name_ref) => {\n-            match hygiene.name_ref_to_name(name_ref) {\n-                Either::A(name) => {\n-                    // no type args in use\n-                    let mut res = prefix.unwrap_or_else(|| Path {\n-                        kind: PathKind::Plain,\n-                        segments: Vec::with_capacity(1),\n-                    });\n-                    res.segments.push(PathSegment {\n-                        name,\n-                        args_and_bindings: None, // no type args in use\n-                    });\n-                    res\n-                }\n-                Either::B(crate_id) => {\n-                    return Some(Path::from_simple_segments(\n-                        PathKind::DollarCrate(crate_id),\n-                        iter::empty(),\n-                    ))\n-                }\n-            }\n-        }\n-        ast::PathSegmentKind::CrateKw => {\n-            if prefix.is_some() {\n-                return None;\n-            }\n-            Path::from_simple_segments(PathKind::Crate, iter::empty())\n-        }\n-        ast::PathSegmentKind::SelfKw => {\n-            if prefix.is_some() {\n-                return None;\n-            }\n-            Path::from_simple_segments(PathKind::Self_, iter::empty())\n-        }\n-        ast::PathSegmentKind::SuperKw => {\n-            if prefix.is_some() {\n-                return None;\n-            }\n-            Path::from_simple_segments(PathKind::Super, iter::empty())\n-        }\n-        ast::PathSegmentKind::Type { .. } => {\n-            // not allowed in imports\n-            return None;\n-        }\n+pub use hir_expand::name as __name;\n+\n+#[macro_export]\n+macro_rules! __known_path {\n+    (std::iter::IntoIterator) => {};\n+    (std::result::Result) => {};\n+    (std::ops::Range) => {};\n+    (std::ops::RangeFrom) => {};\n+    (std::ops::RangeFull) => {};\n+    (std::ops::RangeTo) => {};\n+    (std::ops::RangeToInclusive) => {};\n+    (std::ops::RangeInclusive) => {};\n+    (std::boxed::Box) => {};\n+    (std::future::Future) => {};\n+    (std::ops::Try) => {};\n+    (std::ops::Neg) => {};\n+    (std::ops::Not) => {};\n+    (std::ops::Index) => {};\n+    ($path:path) => {\n+        compile_error!(\"Please register your known path in the path module\")\n     };\n-    Some(res)\n }\n \n-pub mod known {\n-    use hir_expand::name;\n-\n-    use super::{Path, PathKind};\n-\n-    pub fn std_iter_into_iterator() -> Path {\n-        Path::from_simple_segments(\n-            PathKind::Abs,\n-            vec![name::STD, name::ITER, name::INTO_ITERATOR_TYPE],\n-        )\n-    }\n-\n-    pub fn std_ops_try() -> Path {\n-        Path::from_simple_segments(PathKind::Abs, vec![name::STD, name::OPS, name::TRY_TYPE])\n-    }\n-\n-    pub fn std_result_result() -> Path {\n-        Path::from_simple_segments(PathKind::Abs, vec![name::STD, name::RESULT, name::RESULT_TYPE])\n-    }\n-\n-    pub fn std_future_future() -> Path {\n-        Path::from_simple_segments(PathKind::Abs, vec![name::STD, name::FUTURE, name::FUTURE_TYPE])\n-    }\n-\n-    pub fn std_boxed_box() -> Path {\n-        Path::from_simple_segments(PathKind::Abs, vec![name::STD, name::BOXED, name::BOX_TYPE])\n-    }\n+#[macro_export]\n+macro_rules! __path {\n+    ($start:ident $(:: $seg:ident)*) => ({\n+        $crate::__known_path!($start $(:: $seg)*);\n+        $crate::path::ModPath::from_simple_segments($crate::path::PathKind::Abs, vec![\n+            $crate::path::__name![$start], $($crate::path::__name![$seg],)*\n+        ])\n+    });\n }\n+\n+pub use crate::__path as path;"}, {"sha": "62aafd508e14651d3bde1cd0e2d8fad9b9a36e4d", "filename": "crates/ra_hir_def/src/path/lower.rs", "status": "added", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -0,0 +1,178 @@\n+//! Transforms syntax into `Path` objects, ideally with accounting for hygiene\n+\n+mod lower_use;\n+\n+use std::sync::Arc;\n+\n+use either::Either;\n+use hir_expand::{\n+    hygiene::Hygiene,\n+    name::{name, AsName},\n+};\n+use ra_syntax::ast::{self, AstNode, TypeAscriptionOwner};\n+\n+use crate::{\n+    path::{GenericArg, GenericArgs, ModPath, Path, PathKind},\n+    type_ref::TypeRef,\n+};\n+\n+pub(super) use lower_use::lower_use_tree;\n+\n+/// Converts an `ast::Path` to `Path`. Works with use trees.\n+/// It correctly handles `$crate` based path from macro call.\n+pub(super) fn lower_path(mut path: ast::Path, hygiene: &Hygiene) -> Option<Path> {\n+    let mut kind = PathKind::Plain;\n+    let mut type_anchor = None;\n+    let mut segments = Vec::new();\n+    let mut generic_args = Vec::new();\n+    loop {\n+        let segment = path.segment()?;\n+\n+        if segment.has_colon_colon() {\n+            kind = PathKind::Abs;\n+        }\n+\n+        match segment.kind()? {\n+            ast::PathSegmentKind::Name(name_ref) => {\n+                // FIXME: this should just return name\n+                match hygiene.name_ref_to_name(name_ref) {\n+                    Either::Left(name) => {\n+                        let args = segment\n+                            .type_arg_list()\n+                            .and_then(lower_generic_args)\n+                            .or_else(|| {\n+                                lower_generic_args_from_fn_path(\n+                                    segment.param_list(),\n+                                    segment.ret_type(),\n+                                )\n+                            })\n+                            .map(Arc::new);\n+                        segments.push(name);\n+                        generic_args.push(args)\n+                    }\n+                    Either::Right(crate_id) => {\n+                        kind = PathKind::DollarCrate(crate_id);\n+                        break;\n+                    }\n+                }\n+            }\n+            ast::PathSegmentKind::Type { type_ref, trait_ref } => {\n+                assert!(path.qualifier().is_none()); // this can only occur at the first segment\n+\n+                let self_type = TypeRef::from_ast(type_ref?);\n+\n+                match trait_ref {\n+                    // <T>::foo\n+                    None => {\n+                        type_anchor = Some(Box::new(self_type));\n+                        kind = PathKind::Plain;\n+                    }\n+                    // <T as Trait<A>>::Foo desugars to Trait<Self=T, A>::Foo\n+                    Some(trait_ref) => {\n+                        let path = Path::from_src(trait_ref.path()?, hygiene)?;\n+                        kind = path.mod_path.kind;\n+\n+                        let mut prefix_segments = path.mod_path.segments;\n+                        prefix_segments.reverse();\n+                        segments.extend(prefix_segments);\n+\n+                        let mut prefix_args = path.generic_args;\n+                        prefix_args.reverse();\n+                        generic_args.extend(prefix_args);\n+\n+                        // Insert the type reference (T in the above example) as Self parameter for the trait\n+                        let last_segment = generic_args.last_mut()?;\n+                        if last_segment.is_none() {\n+                            *last_segment = Some(Arc::new(GenericArgs::empty()));\n+                        };\n+                        let args = last_segment.as_mut().unwrap();\n+                        let mut args_inner = Arc::make_mut(args);\n+                        args_inner.has_self_type = true;\n+                        args_inner.args.insert(0, GenericArg::Type(self_type));\n+                    }\n+                }\n+            }\n+            ast::PathSegmentKind::CrateKw => {\n+                kind = PathKind::Crate;\n+                break;\n+            }\n+            ast::PathSegmentKind::SelfKw => {\n+                kind = PathKind::Super(0);\n+                break;\n+            }\n+            ast::PathSegmentKind::SuperKw => {\n+                kind = PathKind::Super(1);\n+                break;\n+            }\n+        }\n+        path = match qualifier(&path) {\n+            Some(it) => it,\n+            None => break,\n+        };\n+    }\n+    segments.reverse();\n+    generic_args.reverse();\n+    let mod_path = ModPath { kind, segments };\n+    return Some(Path { type_anchor, mod_path, generic_args });\n+\n+    fn qualifier(path: &ast::Path) -> Option<ast::Path> {\n+        if let Some(q) = path.qualifier() {\n+            return Some(q);\n+        }\n+        // FIXME: this bottom up traversal is not too precise.\n+        // Should we handle do a top-down analysis, recording results?\n+        let use_tree_list = path.syntax().ancestors().find_map(ast::UseTreeList::cast)?;\n+        let use_tree = use_tree_list.parent_use_tree();\n+        use_tree.path()\n+    }\n+}\n+\n+pub(super) fn lower_generic_args(node: ast::TypeArgList) -> Option<GenericArgs> {\n+    let mut args = Vec::new();\n+    for type_arg in node.type_args() {\n+        let type_ref = TypeRef::from_ast_opt(type_arg.type_ref());\n+        args.push(GenericArg::Type(type_ref));\n+    }\n+    // lifetimes ignored for now\n+    let mut bindings = Vec::new();\n+    for assoc_type_arg in node.assoc_type_args() {\n+        if let Some(name_ref) = assoc_type_arg.name_ref() {\n+            let name = name_ref.as_name();\n+            let type_ref = TypeRef::from_ast_opt(assoc_type_arg.type_ref());\n+            bindings.push((name, type_ref));\n+        }\n+    }\n+    if args.is_empty() && bindings.is_empty() {\n+        None\n+    } else {\n+        Some(GenericArgs { args, has_self_type: false, bindings })\n+    }\n+}\n+\n+/// Collect `GenericArgs` from the parts of a fn-like path, i.e. `Fn(X, Y)\n+/// -> Z` (which desugars to `Fn<(X, Y), Output=Z>`).\n+fn lower_generic_args_from_fn_path(\n+    params: Option<ast::ParamList>,\n+    ret_type: Option<ast::RetType>,\n+) -> Option<GenericArgs> {\n+    let mut args = Vec::new();\n+    let mut bindings = Vec::new();\n+    if let Some(params) = params {\n+        let mut param_types = Vec::new();\n+        for param in params.params() {\n+            let type_ref = TypeRef::from_ast_opt(param.ascribed_type());\n+            param_types.push(type_ref);\n+        }\n+        let arg = GenericArg::Type(TypeRef::Tuple(param_types));\n+        args.push(arg);\n+    }\n+    if let Some(ret_type) = ret_type {\n+        let type_ref = TypeRef::from_ast_opt(ret_type.type_ref());\n+        bindings.push((name![Output], type_ref))\n+    }\n+    if args.is_empty() && bindings.is_empty() {\n+        None\n+    } else {\n+        Some(GenericArgs { args, has_self_type: false, bindings })\n+    }\n+}"}, {"sha": "3218eaf0a28c4fe07affcec7d07ab7c734691bb0", "filename": "crates/ra_hir_def/src/path/lower/lower_use.rs", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower%2Flower_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower%2Flower_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower%2Flower_use.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -0,0 +1,118 @@\n+//! Lowers a single complex use like `use foo::{bar, baz};` into a list of paths like\n+//! `foo::bar`, `foo::baz`;\n+\n+use std::iter;\n+\n+use either::Either;\n+use hir_expand::{\n+    hygiene::Hygiene,\n+    name::{AsName, Name},\n+};\n+use ra_syntax::ast::{self, NameOwner};\n+use test_utils::tested_by;\n+\n+use crate::path::{ModPath, PathKind};\n+\n+pub(crate) fn lower_use_tree(\n+    prefix: Option<ModPath>,\n+    tree: ast::UseTree,\n+    hygiene: &Hygiene,\n+    cb: &mut dyn FnMut(ModPath, &ast::UseTree, bool, Option<Name>),\n+) {\n+    if let Some(use_tree_list) = tree.use_tree_list() {\n+        let prefix = match tree.path() {\n+            // E.g. use something::{{{inner}}};\n+            None => prefix,\n+            // E.g. `use something::{inner}` (prefix is `None`, path is `something`)\n+            // or `use something::{path::{inner::{innerer}}}` (prefix is `something::path`, path is `inner`)\n+            Some(path) => match convert_path(prefix, path, hygiene) {\n+                Some(it) => Some(it),\n+                None => return, // FIXME: report errors somewhere\n+            },\n+        };\n+        for child_tree in use_tree_list.use_trees() {\n+            lower_use_tree(prefix.clone(), child_tree, hygiene, cb);\n+        }\n+    } else {\n+        let alias = tree.alias().and_then(|a| a.name()).map(|a| a.as_name());\n+        let is_glob = tree.has_star();\n+        if let Some(ast_path) = tree.path() {\n+            // Handle self in a path.\n+            // E.g. `use something::{self, <...>}`\n+            if ast_path.qualifier().is_none() {\n+                if let Some(segment) = ast_path.segment() {\n+                    if segment.kind() == Some(ast::PathSegmentKind::SelfKw) {\n+                        if let Some(prefix) = prefix {\n+                            cb(prefix, &tree, false, alias);\n+                            return;\n+                        }\n+                    }\n+                }\n+            }\n+            if let Some(path) = convert_path(prefix, ast_path, hygiene) {\n+                cb(path, &tree, is_glob, alias)\n+            }\n+        // FIXME: report errors somewhere\n+        // We get here if we do\n+        } else if is_glob {\n+            tested_by!(glob_enum_group);\n+            if let Some(prefix) = prefix {\n+                cb(prefix, &tree, is_glob, None)\n+            }\n+        }\n+    }\n+}\n+\n+fn convert_path(prefix: Option<ModPath>, path: ast::Path, hygiene: &Hygiene) -> Option<ModPath> {\n+    let prefix = if let Some(qual) = path.qualifier() {\n+        Some(convert_path(prefix, qual, hygiene)?)\n+    } else {\n+        prefix\n+    };\n+\n+    let segment = path.segment()?;\n+    let res = match segment.kind()? {\n+        ast::PathSegmentKind::Name(name_ref) => {\n+            match hygiene.name_ref_to_name(name_ref) {\n+                Either::Left(name) => {\n+                    // no type args in use\n+                    let mut res = prefix.unwrap_or_else(|| ModPath {\n+                        kind: PathKind::Plain,\n+                        segments: Vec::with_capacity(1),\n+                    });\n+                    res.segments.push(name);\n+                    res\n+                }\n+                Either::Right(crate_id) => {\n+                    return Some(ModPath::from_simple_segments(\n+                        PathKind::DollarCrate(crate_id),\n+                        iter::empty(),\n+                    ))\n+                }\n+            }\n+        }\n+        ast::PathSegmentKind::CrateKw => {\n+            if prefix.is_some() {\n+                return None;\n+            }\n+            ModPath::from_simple_segments(PathKind::Crate, iter::empty())\n+        }\n+        ast::PathSegmentKind::SelfKw => {\n+            if prefix.is_some() {\n+                return None;\n+            }\n+            ModPath::from_simple_segments(PathKind::Super(0), iter::empty())\n+        }\n+        ast::PathSegmentKind::SuperKw => {\n+            if prefix.is_some() {\n+                return None;\n+            }\n+            ModPath::from_simple_segments(PathKind::Super(1), iter::empty())\n+        }\n+        ast::PathSegmentKind::Type { .. } => {\n+            // not allowed in imports\n+            return None;\n+        }\n+    };\n+    Some(res)\n+}"}, {"sha": "3a5105028f875726f664497b64d9a6c47324e316", "filename": "crates/ra_hir_def/src/per_ns.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Fper_ns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Fper_ns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fper_ns.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -11,8 +11,6 @@ use crate::ModuleDefId;\n pub struct PerNs {\n     pub types: Option<ModuleDefId>,\n     pub values: Option<ModuleDefId>,\n-    /// Since macros has different type, many methods simply ignore it.\n-    /// We can only use special method like `get_macros` to access it.\n     pub macros: Option<MacroDefId>,\n }\n "}, {"sha": "cf3c33d7888ecc3811ee5adec06749c4fd750884", "filename": "crates/ra_hir_def/src/resolver.rs", "status": "modified", "additions": 191, "deletions": 105, "changes": 296, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -2,28 +2,31 @@\n use std::sync::Arc;\n \n use hir_expand::{\n-    name::{self, Name},\n+    name::{name, Name},\n     MacroDefId,\n };\n use ra_db::CrateId;\n use rustc_hash::FxHashSet;\n \n use crate::{\n     body::scope::{ExprScopes, ScopeId},\n+    body::Body,\n     builtin_type::BuiltinType,\n     db::DefDatabase,\n     expr::{ExprId, PatId},\n     generics::GenericParams,\n+    item_scope::BuiltinShadowMode,\n     nameres::CrateDefMap,\n-    path::{Path, PathKind},\n+    path::{ModPath, PathKind},\n     per_ns::PerNs,\n-    AdtId, AstItemDef, ConstId, ContainerId, DefWithBodyId, EnumId, EnumVariantId, FunctionId,\n-    GenericDefId, HasModule, ImplId, LocalModuleId, Lookup, ModuleDefId, ModuleId, StaticId,\n-    StructId, TraitId, TypeAliasId,\n+    AdtId, AssocContainerId, ConstId, ContainerId, DefWithBodyId, EnumId, EnumVariantId,\n+    FunctionId, GenericDefId, HasModule, ImplId, LocalModuleId, Lookup, ModuleDefId, ModuleId,\n+    StaticId, StructId, TraitId, TypeAliasId, TypeParamId, VariantId,\n };\n \n #[derive(Debug, Clone, Default)]\n pub struct Resolver {\n+    // FIXME: all usages generally call `.rev`, so maybe reverse once in consturciton?\n     scopes: Vec<Scope>,\n }\n \n@@ -53,12 +56,14 @@ enum Scope {\n     AdtScope(AdtId),\n     /// Local bindings\n     ExprScope(ExprScope),\n+    /// Temporary hack to support local items.\n+    LocalItemsScope(Arc<Body>),\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum TypeNs {\n     SelfType(ImplId),\n-    GenericParam(u32),\n+    GenericParam(TypeParamId),\n     AdtId(AdtId),\n     AdtSelfType(AdtId),\n     // Yup, enum variants are added to the types ns, but any usage of variant as\n@@ -90,105 +95,134 @@ pub enum ValueNs {\n \n impl Resolver {\n     /// Resolve known trait from std, like `std::futures::Future`\n-    pub fn resolve_known_trait(&self, db: &impl DefDatabase, path: &Path) -> Option<TraitId> {\n-        let res = self.resolve_module_path(db, path).take_types()?;\n+    pub fn resolve_known_trait(&self, db: &impl DefDatabase, path: &ModPath) -> Option<TraitId> {\n+        let res = self.resolve_module_path(db, path, BuiltinShadowMode::Other).take_types()?;\n         match res {\n             ModuleDefId::TraitId(it) => Some(it),\n             _ => None,\n         }\n     }\n \n     /// Resolve known struct from std, like `std::boxed::Box`\n-    pub fn resolve_known_struct(&self, db: &impl DefDatabase, path: &Path) -> Option<StructId> {\n-        let res = self.resolve_module_path(db, path).take_types()?;\n+    pub fn resolve_known_struct(&self, db: &impl DefDatabase, path: &ModPath) -> Option<StructId> {\n+        let res = self.resolve_module_path(db, path, BuiltinShadowMode::Other).take_types()?;\n         match res {\n             ModuleDefId::AdtId(AdtId::StructId(it)) => Some(it),\n             _ => None,\n         }\n     }\n \n     /// Resolve known enum from std, like `std::result::Result`\n-    pub fn resolve_known_enum(&self, db: &impl DefDatabase, path: &Path) -> Option<EnumId> {\n-        let res = self.resolve_module_path(db, path).take_types()?;\n+    pub fn resolve_known_enum(&self, db: &impl DefDatabase, path: &ModPath) -> Option<EnumId> {\n+        let res = self.resolve_module_path(db, path, BuiltinShadowMode::Other).take_types()?;\n         match res {\n             ModuleDefId::AdtId(AdtId::EnumId(it)) => Some(it),\n             _ => None,\n         }\n     }\n \n-    /// pub only for source-binder\n-    pub fn resolve_module_path(&self, db: &impl DefDatabase, path: &Path) -> PerNs {\n+    fn resolve_module_path(\n+        &self,\n+        db: &impl DefDatabase,\n+        path: &ModPath,\n+        shadow: BuiltinShadowMode,\n+    ) -> PerNs {\n         let (item_map, module) = match self.module() {\n             Some(it) => it,\n             None => return PerNs::none(),\n         };\n-        let (module_res, segment_index) = item_map.resolve_path(db, module, path);\n+        let (module_res, segment_index) = item_map.resolve_path(db, module, &path, shadow);\n         if segment_index.is_some() {\n             return PerNs::none();\n         }\n         module_res\n     }\n \n+    pub fn resolve_module_path_in_items(&self, db: &impl DefDatabase, path: &ModPath) -> PerNs {\n+        self.resolve_module_path(db, path, BuiltinShadowMode::Module)\n+    }\n+\n     pub fn resolve_path_in_type_ns(\n         &self,\n         db: &impl DefDatabase,\n-        path: &Path,\n+        path: &ModPath,\n     ) -> Option<(TypeNs, Option<usize>)> {\n-        if path.is_type_relative() {\n-            return None;\n-        }\n-        let first_name = &path.segments.first()?.name;\n+        let first_name = path.segments.first()?;\n         let skip_to_mod = path.kind != PathKind::Plain;\n         for scope in self.scopes.iter().rev() {\n             match scope {\n                 Scope::ExprScope(_) => continue,\n-                Scope::GenericParams { .. } | Scope::ImplBlockScope(_) if skip_to_mod => continue,\n+                Scope::GenericParams { .. }\n+                | Scope::ImplBlockScope(_)\n+                | Scope::LocalItemsScope(_)\n+                    if skip_to_mod =>\n+                {\n+                    continue\n+                }\n \n-                Scope::GenericParams { params, .. } => {\n-                    if let Some(param) = params.find_by_name(first_name) {\n+                Scope::GenericParams { params, def } => {\n+                    if let Some(local_id) = params.find_by_name(first_name) {\n                         let idx = if path.segments.len() == 1 { None } else { Some(1) };\n-                        return Some((TypeNs::GenericParam(param.idx), idx));\n+                        return Some((\n+                            TypeNs::GenericParam(TypeParamId { local_id, parent: *def }),\n+                            idx,\n+                        ));\n                     }\n                 }\n                 Scope::ImplBlockScope(impl_) => {\n-                    if first_name == &name::SELF_TYPE {\n+                    if first_name == &name![Self] {\n                         let idx = if path.segments.len() == 1 { None } else { Some(1) };\n                         return Some((TypeNs::SelfType(*impl_), idx));\n                     }\n                 }\n                 Scope::AdtScope(adt) => {\n-                    if first_name == &name::SELF_TYPE {\n+                    if first_name == &name![Self] {\n                         let idx = if path.segments.len() == 1 { None } else { Some(1) };\n                         return Some((TypeNs::AdtSelfType(*adt), idx));\n                     }\n                 }\n                 Scope::ModuleScope(m) => {\n-                    let (module_def, idx) = m.crate_def_map.resolve_path(db, m.module_id, path);\n-                    let res = match module_def.take_types()? {\n-                        ModuleDefId::AdtId(it) => TypeNs::AdtId(it),\n-                        ModuleDefId::EnumVariantId(it) => TypeNs::EnumVariantId(it),\n-\n-                        ModuleDefId::TypeAliasId(it) => TypeNs::TypeAliasId(it),\n-                        ModuleDefId::BuiltinType(it) => TypeNs::BuiltinType(it),\n-\n-                        ModuleDefId::TraitId(it) => TypeNs::TraitId(it),\n-\n-                        ModuleDefId::FunctionId(_)\n-                        | ModuleDefId::ConstId(_)\n-                        | ModuleDefId::StaticId(_)\n-                        | ModuleDefId::ModuleId(_) => return None,\n-                    };\n+                    let (module_def, idx) = m.crate_def_map.resolve_path(\n+                        db,\n+                        m.module_id,\n+                        &path,\n+                        BuiltinShadowMode::Other,\n+                    );\n+                    let res = to_type_ns(module_def)?;\n                     return Some((res, idx));\n                 }\n+                Scope::LocalItemsScope(body) => {\n+                    let def = body.item_scope.get(first_name, BuiltinShadowMode::Other);\n+                    if let Some(res) = to_type_ns(def) {\n+                        return Some((res, None));\n+                    }\n+                }\n             }\n         }\n-        None\n+        return None;\n+        fn to_type_ns(per_ns: PerNs) -> Option<TypeNs> {\n+            let res = match per_ns.take_types()? {\n+                ModuleDefId::AdtId(it) => TypeNs::AdtId(it),\n+                ModuleDefId::EnumVariantId(it) => TypeNs::EnumVariantId(it),\n+\n+                ModuleDefId::TypeAliasId(it) => TypeNs::TypeAliasId(it),\n+                ModuleDefId::BuiltinType(it) => TypeNs::BuiltinType(it),\n+\n+                ModuleDefId::TraitId(it) => TypeNs::TraitId(it),\n+\n+                ModuleDefId::FunctionId(_)\n+                | ModuleDefId::ConstId(_)\n+                | ModuleDefId::StaticId(_)\n+                | ModuleDefId::ModuleId(_) => return None,\n+            };\n+            Some(res)\n+        }\n     }\n \n     pub fn resolve_path_in_type_ns_fully(\n         &self,\n         db: &impl DefDatabase,\n-        path: &Path,\n+        path: &ModPath,\n     ) -> Option<TypeNs> {\n         let (res, unresolved) = self.resolve_path_in_type_ns(db, path)?;\n         if unresolved.is_some() {\n@@ -197,24 +231,22 @@ impl Resolver {\n         Some(res)\n     }\n \n-    pub fn resolve_path_in_value_ns<'p>(\n+    pub fn resolve_path_in_value_ns(\n         &self,\n         db: &impl DefDatabase,\n-        path: &'p Path,\n+        path: &ModPath,\n     ) -> Option<ResolveValueResult> {\n-        if path.is_type_relative() {\n-            return None;\n-        }\n         let n_segments = path.segments.len();\n-        let tmp = name::SELF_PARAM;\n-        let first_name = if path.is_self() { &tmp } else { &path.segments.first()?.name };\n+        let tmp = name![self];\n+        let first_name = if path.is_self() { &tmp } else { &path.segments.first()? };\n         let skip_to_mod = path.kind != PathKind::Plain && !path.is_self();\n         for scope in self.scopes.iter().rev() {\n             match scope {\n                 Scope::AdtScope(_)\n                 | Scope::ExprScope(_)\n                 | Scope::GenericParams { .. }\n                 | Scope::ImplBlockScope(_)\n+                | Scope::LocalItemsScope(_)\n                     if skip_to_mod =>\n                 {\n                     continue\n@@ -233,46 +265,38 @@ impl Resolver {\n                 }\n                 Scope::ExprScope(_) => continue,\n \n-                Scope::GenericParams { params, .. } if n_segments > 1 => {\n-                    if let Some(param) = params.find_by_name(first_name) {\n-                        let ty = TypeNs::GenericParam(param.idx);\n+                Scope::GenericParams { params, def } if n_segments > 1 => {\n+                    if let Some(local_id) = params.find_by_name(first_name) {\n+                        let ty = TypeNs::GenericParam(TypeParamId { local_id, parent: *def });\n                         return Some(ResolveValueResult::Partial(ty, 1));\n                     }\n                 }\n                 Scope::GenericParams { .. } => continue,\n \n                 Scope::ImplBlockScope(impl_) if n_segments > 1 => {\n-                    if first_name == &name::SELF_TYPE {\n+                    if first_name == &name![Self] {\n                         let ty = TypeNs::SelfType(*impl_);\n                         return Some(ResolveValueResult::Partial(ty, 1));\n                     }\n                 }\n                 Scope::AdtScope(adt) if n_segments > 1 => {\n-                    if first_name == &name::SELF_TYPE {\n+                    if first_name == &name![Self] {\n                         let ty = TypeNs::AdtSelfType(*adt);\n                         return Some(ResolveValueResult::Partial(ty, 1));\n                     }\n                 }\n                 Scope::ImplBlockScope(_) | Scope::AdtScope(_) => continue,\n \n                 Scope::ModuleScope(m) => {\n-                    let (module_def, idx) = m.crate_def_map.resolve_path(db, m.module_id, path);\n+                    let (module_def, idx) = m.crate_def_map.resolve_path(\n+                        db,\n+                        m.module_id,\n+                        &path,\n+                        BuiltinShadowMode::Other,\n+                    );\n                     return match idx {\n                         None => {\n-                            let value = match module_def.take_values()? {\n-                                ModuleDefId::FunctionId(it) => ValueNs::FunctionId(it),\n-                                ModuleDefId::AdtId(AdtId::StructId(it)) => ValueNs::StructId(it),\n-                                ModuleDefId::EnumVariantId(it) => ValueNs::EnumVariantId(it),\n-                                ModuleDefId::ConstId(it) => ValueNs::ConstId(it),\n-                                ModuleDefId::StaticId(it) => ValueNs::StaticId(it),\n-\n-                                ModuleDefId::AdtId(AdtId::EnumId(_))\n-                                | ModuleDefId::AdtId(AdtId::UnionId(_))\n-                                | ModuleDefId::TraitId(_)\n-                                | ModuleDefId::TypeAliasId(_)\n-                                | ModuleDefId::BuiltinType(_)\n-                                | ModuleDefId::ModuleId(_) => return None,\n-                            };\n+                            let value = to_value_ns(module_def)?;\n                             Some(ResolveValueResult::ValueNs(value))\n                         }\n                         Some(idx) => {\n@@ -292,25 +316,53 @@ impl Resolver {\n                         }\n                     };\n                 }\n+                Scope::LocalItemsScope(body) => {\n+                    let def = body.item_scope.get(first_name, BuiltinShadowMode::Other);\n+                    if let Some(res) = to_value_ns(def) {\n+                        return Some(ResolveValueResult::ValueNs(res));\n+                    }\n+                }\n             }\n         }\n-        None\n+        return None;\n+\n+        fn to_value_ns(per_ns: PerNs) -> Option<ValueNs> {\n+            let res = match per_ns.take_values()? {\n+                ModuleDefId::FunctionId(it) => ValueNs::FunctionId(it),\n+                ModuleDefId::AdtId(AdtId::StructId(it)) => ValueNs::StructId(it),\n+                ModuleDefId::EnumVariantId(it) => ValueNs::EnumVariantId(it),\n+                ModuleDefId::ConstId(it) => ValueNs::ConstId(it),\n+                ModuleDefId::StaticId(it) => ValueNs::StaticId(it),\n+\n+                ModuleDefId::AdtId(AdtId::EnumId(_))\n+                | ModuleDefId::AdtId(AdtId::UnionId(_))\n+                | ModuleDefId::TraitId(_)\n+                | ModuleDefId::TypeAliasId(_)\n+                | ModuleDefId::BuiltinType(_)\n+                | ModuleDefId::ModuleId(_) => return None,\n+            };\n+            Some(res)\n+        }\n     }\n \n     pub fn resolve_path_in_value_ns_fully(\n         &self,\n         db: &impl DefDatabase,\n-        path: &Path,\n+        path: &ModPath,\n     ) -> Option<ValueNs> {\n         match self.resolve_path_in_value_ns(db, path)? {\n             ResolveValueResult::ValueNs(it) => Some(it),\n             ResolveValueResult::Partial(..) => None,\n         }\n     }\n \n-    pub fn resolve_path_as_macro(&self, db: &impl DefDatabase, path: &Path) -> Option<MacroDefId> {\n+    pub fn resolve_path_as_macro(\n+        &self,\n+        db: &impl DefDatabase,\n+        path: &ModPath,\n+    ) -> Option<MacroDefId> {\n         let (item_map, module) = self.module()?;\n-        item_map.resolve_path(db, module, path).0.take_macros()\n+        item_map.resolve_path(db, module, &path, BuiltinShadowMode::Other).0.take_macros()\n     }\n \n     pub fn process_all_names(&self, db: &impl DefDatabase, f: &mut dyn FnMut(Name, ScopeDef)) {\n@@ -350,6 +402,7 @@ impl Resolver {\n     ) -> impl Iterator<Item = &'a crate::generics::WherePredicate> + 'a {\n         self.scopes\n             .iter()\n+            .rev()\n             .filter_map(|scope| match scope {\n                 Scope::GenericParams { params, .. } => Some(params),\n                 _ => None,\n@@ -358,14 +411,14 @@ impl Resolver {\n     }\n \n     pub fn generic_def(&self) -> Option<GenericDefId> {\n-        self.scopes.iter().find_map(|scope| match scope {\n+        self.scopes.iter().rev().find_map(|scope| match scope {\n             Scope::GenericParams { def, .. } => Some(*def),\n             _ => None,\n         })\n     }\n \n     pub fn body_owner(&self) -> Option<DefWithBodyId> {\n-        self.scopes.iter().find_map(|scope| match scope {\n+        self.scopes.iter().rev().find_map(|scope| match scope {\n             Scope::ExprScope(it) => Some(it.owner),\n             _ => None,\n         })\n@@ -376,7 +429,7 @@ pub enum ScopeDef {\n     PerNs(PerNs),\n     ImplSelfType(ImplId),\n     AdtSelfType(AdtId),\n-    GenericParam(u32),\n+    GenericParam(TypeParamId),\n     Local(PatId),\n }\n \n@@ -391,8 +444,8 @@ impl Scope {\n                 //         def: m.module.into(),\n                 //     }),\n                 // );\n-                m.crate_def_map[m.module_id].scope.entries().for_each(|(name, res)| {\n-                    f(name.clone(), ScopeDef::PerNs(res.def));\n+                m.crate_def_map[m.module_id].scope.entries().for_each(|(name, def)| {\n+                    f(name.clone(), ScopeDef::PerNs(def));\n                 });\n                 m.crate_def_map[m.module_id].scope.legacy_macros().for_each(|(name, macro_)| {\n                     f(name.clone(), ScopeDef::PerNs(PerNs::macros(macro_)));\n@@ -402,21 +455,29 @@ impl Scope {\n                 });\n                 if let Some(prelude) = m.crate_def_map.prelude {\n                     let prelude_def_map = db.crate_def_map(prelude.krate);\n-                    prelude_def_map[prelude.local_id].scope.entries().for_each(|(name, res)| {\n-                        f(name.clone(), ScopeDef::PerNs(res.def));\n+                    prelude_def_map[prelude.local_id].scope.entries().for_each(|(name, def)| {\n+                        f(name.clone(), ScopeDef::PerNs(def));\n                     });\n                 }\n             }\n-            Scope::GenericParams { params, .. } => {\n-                for param in params.params.iter() {\n-                    f(param.name.clone(), ScopeDef::GenericParam(param.idx))\n+            Scope::LocalItemsScope(body) => {\n+                body.item_scope.entries_without_primitives().for_each(|(name, def)| {\n+                    f(name.clone(), ScopeDef::PerNs(def));\n+                })\n+            }\n+            Scope::GenericParams { params, def } => {\n+                for (local_id, param) in params.types.iter() {\n+                    f(\n+                        param.name.clone(),\n+                        ScopeDef::GenericParam(TypeParamId { local_id, parent: *def }),\n+                    )\n                 }\n             }\n             Scope::ImplBlockScope(i) => {\n-                f(name::SELF_TYPE, ScopeDef::ImplSelfType((*i).into()));\n+                f(name![Self], ScopeDef::ImplSelfType((*i).into()));\n             }\n             Scope::AdtScope(i) => {\n-                f(name::SELF_TYPE, ScopeDef::AdtSelfType((*i).into()));\n+                f(name![Self], ScopeDef::AdtSelfType((*i).into()));\n             }\n             Scope::ExprScope(scope) => {\n                 scope.expr_scopes.entries(scope.scope_id).iter().for_each(|e| {\n@@ -439,6 +500,7 @@ pub fn resolver_for_scope(\n     scope_id: Option<ScopeId>,\n ) -> Resolver {\n     let mut r = owner.resolver(db);\n+    r = r.push_local_items_scope(db.body(owner));\n     let scopes = db.expr_scopes(owner);\n     let scope_chain = scopes.scope_chain(scope_id).collect::<Vec<_>>();\n     for scope in scope_chain.into_iter().rev() {\n@@ -455,7 +517,7 @@ impl Resolver {\n \n     fn push_generic_params_scope(self, db: &impl DefDatabase, def: GenericDefId) -> Resolver {\n         let params = db.generic_params(def);\n-        if params.params.is_empty() {\n+        if params.types.is_empty() {\n             self\n         } else {\n             self.push_scope(Scope::GenericParams { def, params })\n@@ -474,6 +536,10 @@ impl Resolver {\n         self.push_scope(Scope::ModuleScope(ModuleItemMap { crate_def_map, module_id }))\n     }\n \n+    fn push_local_items_scope(self, body: Arc<Body>) -> Resolver {\n+        self.push_scope(Scope::LocalItemsScope(body))\n+    }\n+\n     fn push_expr_scope(\n         self,\n         owner: DefWithBodyId,\n@@ -498,7 +564,7 @@ impl HasResolver for ModuleId {\n \n impl HasResolver for TraitId {\n     fn resolver(self, db: &impl DefDatabase) -> Resolver {\n-        self.module(db).resolver(db).push_generic_params_scope(db, self.into())\n+        self.lookup(db).container.resolver(db).push_generic_params_scope(db, self.into())\n     }\n }\n \n@@ -518,16 +584,6 @@ impl HasResolver for FunctionId {\n     }\n }\n \n-impl HasResolver for DefWithBodyId {\n-    fn resolver(self, db: &impl DefDatabase) -> Resolver {\n-        match self {\n-            DefWithBodyId::ConstId(c) => c.resolver(db),\n-            DefWithBodyId::FunctionId(f) => f.resolver(db),\n-            DefWithBodyId::StaticId(s) => s.resolver(db),\n-        }\n-    }\n-}\n-\n impl HasResolver for ConstId {\n     fn resolver(self, db: &impl DefDatabase) -> Resolver {\n         self.lookup(db).container.resolver(db)\n@@ -546,12 +602,41 @@ impl HasResolver for TypeAliasId {\n     }\n }\n \n+impl HasResolver for ImplId {\n+    fn resolver(self, db: &impl DefDatabase) -> Resolver {\n+        self.lookup(db)\n+            .container\n+            .resolver(db)\n+            .push_generic_params_scope(db, self.into())\n+            .push_impl_block_scope(self)\n+    }\n+}\n+\n+impl HasResolver for DefWithBodyId {\n+    fn resolver(self, db: &impl DefDatabase) -> Resolver {\n+        match self {\n+            DefWithBodyId::ConstId(c) => c.resolver(db),\n+            DefWithBodyId::FunctionId(f) => f.resolver(db),\n+            DefWithBodyId::StaticId(s) => s.resolver(db),\n+        }\n+    }\n+}\n+\n impl HasResolver for ContainerId {\n     fn resolver(self, db: &impl DefDatabase) -> Resolver {\n         match self {\n-            ContainerId::TraitId(it) => it.resolver(db),\n-            ContainerId::ImplId(it) => it.resolver(db),\n             ContainerId::ModuleId(it) => it.resolver(db),\n+            ContainerId::DefWithBodyId(it) => it.resolver(db),\n+        }\n+    }\n+}\n+\n+impl HasResolver for AssocContainerId {\n+    fn resolver(self, db: &impl DefDatabase) -> Resolver {\n+        match self {\n+            AssocContainerId::ContainerId(it) => it.resolver(db),\n+            AssocContainerId::TraitId(it) => it.resolver(db),\n+            AssocContainerId::ImplId(it) => it.resolver(db),\n         }\n     }\n }\n@@ -570,11 +655,12 @@ impl HasResolver for GenericDefId {\n     }\n }\n \n-impl HasResolver for ImplId {\n+impl HasResolver for VariantId {\n     fn resolver(self, db: &impl DefDatabase) -> Resolver {\n-        self.module(db)\n-            .resolver(db)\n-            .push_generic_params_scope(db, self.into())\n-            .push_impl_block_scope(self)\n+        match self {\n+            VariantId::EnumVariantId(it) => it.parent.resolver(db),\n+            VariantId::StructId(it) => it.resolver(db),\n+            VariantId::UnionId(it) => it.resolver(db),\n+        }\n     }\n }"}, {"sha": "499375b803fc2af85f6b82d5421b4df3cb43937e", "filename": "crates/ra_hir_def/src/src.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Fsrc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Fsrc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fsrc.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -0,0 +1,36 @@\n+//! Utilities for mapping between hir IDs and the surface syntax.\n+\n+use hir_expand::InFile;\n+use ra_arena::map::ArenaMap;\n+use ra_syntax::AstNode;\n+\n+use crate::{db::DefDatabase, AssocItemLoc, ItemLoc};\n+\n+pub trait HasSource {\n+    type Value;\n+    fn source(&self, db: &impl DefDatabase) -> InFile<Self::Value>;\n+}\n+\n+impl<N: AstNode> HasSource for AssocItemLoc<N> {\n+    type Value = N;\n+\n+    fn source(&self, db: &impl DefDatabase) -> InFile<N> {\n+        let node = self.ast_id.to_node(db);\n+        InFile::new(self.ast_id.file_id, node)\n+    }\n+}\n+\n+impl<N: AstNode> HasSource for ItemLoc<N> {\n+    type Value = N;\n+\n+    fn source(&self, db: &impl DefDatabase) -> InFile<N> {\n+        let node = self.ast_id.to_node(db);\n+        InFile::new(self.ast_id.file_id, node)\n+    }\n+}\n+\n+pub trait HasChildSource {\n+    type ChildId;\n+    type Value;\n+    fn child_source(&self, db: &impl DefDatabase) -> InFile<ArenaMap<Self::ChildId, Self::Value>>;\n+}"}, {"sha": "9769e88df583779c035a9d8a33c7d4d7df574814", "filename": "crates/ra_hir_def/src/trace.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_def%2Fsrc%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Ftrace.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -18,10 +18,6 @@ pub(crate) struct Trace<ID: ArenaId, T, V> {\n }\n \n impl<ID: ra_arena::ArenaId + Copy, T, V> Trace<ID, T, V> {\n-    pub(crate) fn new() -> Trace<ID, T, V> {\n-        Trace { arena: Some(Arena::default()), map: Some(ArenaMap::default()), len: 0 }\n-    }\n-\n     pub(crate) fn new_for_arena() -> Trace<ID, T, V> {\n         Trace { arena: Some(Arena::default()), map: None, len: 0 }\n     }\n@@ -52,8 +48,4 @@ impl<ID: ra_arena::ArenaId + Copy, T, V> Trace<ID, T, V> {\n     pub(crate) fn into_map(mut self) -> ArenaMap<ID, V> {\n         self.map.take().unwrap()\n     }\n-\n-    pub(crate) fn into_arena_and_map(mut self) -> (Arena<ID, T>, ArenaMap<ID, V>) {\n-        (self.arena.take().unwrap(), self.map.take().unwrap())\n-    }\n }"}, {"sha": "3ae4376dc7036ebfd6b50c5c1a9379f755c64feb", "filename": "crates/ra_hir_expand/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_expand%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_expand%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2FCargo.toml?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -9,6 +9,7 @@ doctest = false\n \n [dependencies]\n log = \"0.4.5\"\n+either = \"1.5\"\n \n ra_arena = { path = \"../ra_arena\" }\n ra_db = { path = \"../ra_db\" }"}, {"sha": "a764bdf24e57f42ef3287928e1155caf6286eb96", "filename": "crates/ra_hir_expand/src/ast_id_map.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_expand%2Fsrc%2Fast_id_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_expand%2Fsrc%2Fast_id_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fast_id_map.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -39,6 +39,16 @@ impl<N: AstNode> Hash for FileAstId<N> {\n     }\n }\n \n+impl<N: AstNode> FileAstId<N> {\n+    // Can't make this a From implementation because of coherence\n+    pub fn upcast<M: AstNode>(self) -> FileAstId<M>\n+    where\n+        M: From<N>,\n+    {\n+        FileAstId { raw: self.raw, _ty: PhantomData }\n+    }\n+}\n+\n #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n struct ErasedFileAstId(RawId);\n impl_arena_id!(ErasedFileAstId);\n@@ -53,7 +63,7 @@ impl AstIdMap {\n     pub(crate) fn from_source(node: &SyntaxNode) -> AstIdMap {\n         assert!(node.parent().is_none());\n         let mut res = AstIdMap { arena: Arena::default() };\n-        // By walking the tree in bread-first order we make sure that parents\n+        // By walking the tree in breadth-first order we make sure that parents\n         // get lower ids then children. That is, adding a new child does not\n         // change parent's id. This means that, say, adding a new function to a\n         // trait does not change ids of top-level items, which helps caching."}, {"sha": "62c60e336cec21c58fcda496b1cb0cfe9a630a8e", "filename": "crates/ra_hir_expand/src/builtin_derive.rs", "status": "added", "additions": 321, "deletions": 0, "changes": 321, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_derive.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -0,0 +1,321 @@\n+//! Builtin derives.\n+\n+use log::debug;\n+\n+use ra_parser::FragmentKind;\n+use ra_syntax::{\n+    ast::{self, AstNode, ModuleItemOwner, NameOwner, TypeParamsOwner},\n+    match_ast,\n+};\n+\n+use crate::db::AstDatabase;\n+use crate::{name, quote, MacroCallId, MacroDefId, MacroDefKind};\n+\n+macro_rules! register_builtin {\n+    ( $($trait:ident => $expand:ident),* ) => {\n+        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+        pub enum BuiltinDeriveExpander {\n+            $($trait),*\n+        }\n+\n+        impl BuiltinDeriveExpander {\n+            pub fn expand(\n+                &self,\n+                db: &dyn AstDatabase,\n+                id: MacroCallId,\n+                tt: &tt::Subtree,\n+            ) -> Result<tt::Subtree, mbe::ExpandError> {\n+                let expander = match *self {\n+                    $( BuiltinDeriveExpander::$trait => $expand, )*\n+                };\n+                expander(db, id, tt)\n+            }\n+        }\n+\n+        pub fn find_builtin_derive(ident: &name::Name) -> Option<MacroDefId> {\n+            let kind = match ident {\n+                $( id if id == &name::name![$trait] => BuiltinDeriveExpander::$trait, )*\n+                 _ => return None,\n+            };\n+\n+            Some(MacroDefId { krate: None, ast_id: None, kind: MacroDefKind::BuiltInDerive(kind) })\n+        }\n+    };\n+}\n+\n+register_builtin! {\n+    Copy => copy_expand,\n+    Clone => clone_expand,\n+    Default => default_expand,\n+    Debug => debug_expand,\n+    Hash => hash_expand,\n+    Ord => ord_expand,\n+    PartialOrd => partial_ord_expand,\n+    Eq => eq_expand,\n+    PartialEq => partial_eq_expand\n+}\n+\n+struct BasicAdtInfo {\n+    name: tt::Ident,\n+    type_params: usize,\n+}\n+\n+fn parse_adt(tt: &tt::Subtree) -> Result<BasicAdtInfo, mbe::ExpandError> {\n+    let (parsed, token_map) = mbe::token_tree_to_syntax_node(tt, FragmentKind::Items)?; // FragmentKind::Items doesn't parse attrs?\n+    let macro_items = ast::MacroItems::cast(parsed.syntax_node()).ok_or_else(|| {\n+        debug!(\"derive node didn't parse\");\n+        mbe::ExpandError::UnexpectedToken\n+    })?;\n+    let item = macro_items.items().next().ok_or_else(|| {\n+        debug!(\"no module item parsed\");\n+        mbe::ExpandError::NoMatchingRule\n+    })?;\n+    let node = item.syntax();\n+    let (name, params) = match_ast! {\n+        match node {\n+            ast::StructDef(it) => { (it.name(), it.type_param_list()) },\n+            ast::EnumDef(it) => { (it.name(), it.type_param_list()) },\n+            ast::UnionDef(it) => { (it.name(), it.type_param_list()) },\n+            _ => {\n+                debug!(\"unexpected node is {:?}\", node);\n+                return Err(mbe::ExpandError::ConversionError)\n+            },\n+        }\n+    };\n+    let name = name.ok_or_else(|| {\n+        debug!(\"parsed item has no name\");\n+        mbe::ExpandError::NoMatchingRule\n+    })?;\n+    let name_token_id = token_map.token_by_range(name.syntax().text_range()).ok_or_else(|| {\n+        debug!(\"name token not found\");\n+        mbe::ExpandError::ConversionError\n+    })?;\n+    let name_token = tt::Ident { id: name_token_id, text: name.text().clone() };\n+    let type_params = params.map_or(0, |type_param_list| type_param_list.type_params().count());\n+    Ok(BasicAdtInfo { name: name_token, type_params })\n+}\n+\n+fn make_type_args(n: usize, bound: Vec<tt::TokenTree>) -> Vec<tt::TokenTree> {\n+    let mut result = Vec::<tt::TokenTree>::new();\n+    result.push(\n+        tt::Leaf::Punct(tt::Punct {\n+            char: '<',\n+            spacing: tt::Spacing::Alone,\n+            id: tt::TokenId::unspecified(),\n+        })\n+        .into(),\n+    );\n+    for i in 0..n {\n+        if i > 0 {\n+            result.push(\n+                tt::Leaf::Punct(tt::Punct {\n+                    char: ',',\n+                    spacing: tt::Spacing::Alone,\n+                    id: tt::TokenId::unspecified(),\n+                })\n+                .into(),\n+            );\n+        }\n+        result.push(\n+            tt::Leaf::Ident(tt::Ident {\n+                id: tt::TokenId::unspecified(),\n+                text: format!(\"T{}\", i).into(),\n+            })\n+            .into(),\n+        );\n+        result.extend(bound.iter().cloned());\n+    }\n+    result.push(\n+        tt::Leaf::Punct(tt::Punct {\n+            char: '>',\n+            spacing: tt::Spacing::Alone,\n+            id: tt::TokenId::unspecified(),\n+        })\n+        .into(),\n+    );\n+    result\n+}\n+\n+fn expand_simple_derive(\n+    tt: &tt::Subtree,\n+    trait_path: tt::Subtree,\n+) -> Result<tt::Subtree, mbe::ExpandError> {\n+    let info = parse_adt(tt)?;\n+    let name = info.name;\n+    let trait_path_clone = trait_path.token_trees.clone();\n+    let bound = (quote! { : ##trait_path_clone }).token_trees;\n+    let type_params = make_type_args(info.type_params, bound);\n+    let type_args = make_type_args(info.type_params, Vec::new());\n+    let trait_path = trait_path.token_trees;\n+    let expanded = quote! {\n+        impl ##type_params ##trait_path for #name ##type_args {}\n+    };\n+    Ok(expanded)\n+}\n+\n+fn copy_expand(\n+    _db: &dyn AstDatabase,\n+    _id: MacroCallId,\n+    tt: &tt::Subtree,\n+) -> Result<tt::Subtree, mbe::ExpandError> {\n+    expand_simple_derive(tt, quote! { std::marker::Copy })\n+}\n+\n+fn clone_expand(\n+    _db: &dyn AstDatabase,\n+    _id: MacroCallId,\n+    tt: &tt::Subtree,\n+) -> Result<tt::Subtree, mbe::ExpandError> {\n+    expand_simple_derive(tt, quote! { std::clone::Clone })\n+}\n+\n+fn default_expand(\n+    _db: &dyn AstDatabase,\n+    _id: MacroCallId,\n+    tt: &tt::Subtree,\n+) -> Result<tt::Subtree, mbe::ExpandError> {\n+    expand_simple_derive(tt, quote! { std::default::Default })\n+}\n+\n+fn debug_expand(\n+    _db: &dyn AstDatabase,\n+    _id: MacroCallId,\n+    tt: &tt::Subtree,\n+) -> Result<tt::Subtree, mbe::ExpandError> {\n+    expand_simple_derive(tt, quote! { std::fmt::Debug })\n+}\n+\n+fn hash_expand(\n+    _db: &dyn AstDatabase,\n+    _id: MacroCallId,\n+    tt: &tt::Subtree,\n+) -> Result<tt::Subtree, mbe::ExpandError> {\n+    expand_simple_derive(tt, quote! { std::hash::Hash })\n+}\n+\n+fn eq_expand(\n+    _db: &dyn AstDatabase,\n+    _id: MacroCallId,\n+    tt: &tt::Subtree,\n+) -> Result<tt::Subtree, mbe::ExpandError> {\n+    expand_simple_derive(tt, quote! { std::cmp::Eq })\n+}\n+\n+fn partial_eq_expand(\n+    _db: &dyn AstDatabase,\n+    _id: MacroCallId,\n+    tt: &tt::Subtree,\n+) -> Result<tt::Subtree, mbe::ExpandError> {\n+    expand_simple_derive(tt, quote! { std::cmp::PartialEq })\n+}\n+\n+fn ord_expand(\n+    _db: &dyn AstDatabase,\n+    _id: MacroCallId,\n+    tt: &tt::Subtree,\n+) -> Result<tt::Subtree, mbe::ExpandError> {\n+    expand_simple_derive(tt, quote! { std::cmp::Ord })\n+}\n+\n+fn partial_ord_expand(\n+    _db: &dyn AstDatabase,\n+    _id: MacroCallId,\n+    tt: &tt::Subtree,\n+) -> Result<tt::Subtree, mbe::ExpandError> {\n+    expand_simple_derive(tt, quote! { std::cmp::PartialOrd })\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use crate::{test_db::TestDB, AstId, MacroCallKind, MacroCallLoc};\n+    use ra_db::{fixture::WithFixture, SourceDatabase};\n+\n+    fn expand_builtin_derive(s: &str, expander: BuiltinDeriveExpander) -> String {\n+        let (db, file_id) = TestDB::with_single_file(&s);\n+        let parsed = db.parse(file_id);\n+        let items: Vec<_> =\n+            parsed.syntax_node().descendants().filter_map(|it| ast::ModuleItem::cast(it)).collect();\n+\n+        let ast_id_map = db.ast_id_map(file_id.into());\n+\n+        // the first one should be a macro_rules\n+        let def =\n+            MacroDefId { krate: None, ast_id: None, kind: MacroDefKind::BuiltInDerive(expander) };\n+\n+        let loc = MacroCallLoc {\n+            def,\n+            kind: MacroCallKind::Attr(AstId::new(file_id.into(), ast_id_map.ast_id(&items[0]))),\n+        };\n+\n+        let id = db.intern_macro(loc);\n+        let parsed = db.parse_or_expand(id.as_file()).unwrap();\n+\n+        // FIXME text() for syntax nodes parsed from token tree looks weird\n+        // because there's no whitespace, see below\n+        parsed.text().to_string()\n+    }\n+\n+    #[test]\n+    fn test_copy_expand_simple() {\n+        let expanded = expand_builtin_derive(\n+            r#\"\n+        #[derive(Copy)]\n+        struct Foo;\n+\"#,\n+            BuiltinDeriveExpander::Copy,\n+        );\n+\n+        assert_eq!(expanded, \"impl <>std::marker::CopyforFoo <>{}\");\n+    }\n+\n+    #[test]\n+    fn test_copy_expand_with_type_params() {\n+        let expanded = expand_builtin_derive(\n+            r#\"\n+        #[derive(Copy)]\n+        struct Foo<A, B>;\n+\"#,\n+            BuiltinDeriveExpander::Copy,\n+        );\n+\n+        assert_eq!(\n+            expanded,\n+            \"impl<T0:std::marker::Copy,T1:std::marker::Copy>std::marker::CopyforFoo<T0,T1>{}\"\n+        );\n+    }\n+\n+    #[test]\n+    fn test_copy_expand_with_lifetimes() {\n+        let expanded = expand_builtin_derive(\n+            r#\"\n+        #[derive(Copy)]\n+        struct Foo<A, B, 'a, 'b>;\n+\"#,\n+            BuiltinDeriveExpander::Copy,\n+        );\n+\n+        // We currently just ignore lifetimes\n+\n+        assert_eq!(\n+            expanded,\n+            \"impl<T0:std::marker::Copy,T1:std::marker::Copy>std::marker::CopyforFoo<T0,T1>{}\"\n+        );\n+    }\n+\n+    #[test]\n+    fn test_clone_expand() {\n+        let expanded = expand_builtin_derive(\n+            r#\"\n+        #[derive(Clone)]\n+        struct Foo<A, B>;\n+\"#,\n+            BuiltinDeriveExpander::Clone,\n+        );\n+\n+        assert_eq!(\n+            expanded,\n+            \"impl<T0:std::clone::Clone,T1:std::clone::Clone>std::clone::CloneforFoo<T0,T1>{}\"\n+        );\n+    }\n+}"}, {"sha": "2c119269c13de2d57b932871126a76ac7c263859", "filename": "crates/ra_hir_expand/src/builtin_macro.rs", "status": "modified", "additions": 180, "deletions": 64, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_macro.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -2,8 +2,7 @@\n use crate::db::AstDatabase;\n use crate::{\n     ast::{self, AstNode},\n-    name, AstId, CrateId, HirFileId, MacroCallId, MacroDefId, MacroDefKind, MacroFileKind,\n-    TextUnit,\n+    name, AstId, CrateId, HirFileId, MacroCallId, MacroDefId, MacroDefKind, TextUnit,\n };\n \n use crate::quote;\n@@ -27,29 +26,39 @@ macro_rules! register_builtin {\n                 };\n                 expander(db, id, tt)\n             }\n+\n+            fn by_name(ident: &name::Name) -> Option<BuiltinFnLikeExpander> {\n+                match ident {\n+                    $( id if id == &name::name![$name] => Some(BuiltinFnLikeExpander::$kind), )*\n+                    _ => return None,\n+                }\n+            }\n         }\n \n         pub fn find_builtin_macro(\n             ident: &name::Name,\n             krate: CrateId,\n             ast_id: AstId<ast::MacroCall>,\n         ) -> Option<MacroDefId> {\n-            let kind = match ident {\n-                 $( id if id == &name::$name => BuiltinFnLikeExpander::$kind, )*\n-                 _ => return None,\n-            };\n+            let kind = BuiltinFnLikeExpander::by_name(ident)?;\n \n-            Some(MacroDefId { krate, ast_id, kind: MacroDefKind::BuiltIn(kind) })\n+            Some(MacroDefId { krate: Some(krate), ast_id: Some(ast_id), kind: MacroDefKind::BuiltIn(kind) })\n         }\n     };\n }\n \n register_builtin! {\n-    (COLUMN_MACRO, Column) => column_expand,\n-    (COMPILE_ERROR_MACRO, CompileError) => compile_error_expand,\n-    (FILE_MACRO, File) => file_expand,\n-    (LINE_MACRO, Line) => line_expand,\n-    (STRINGIFY_MACRO, Stringify) => stringify_expand\n+    (column, Column) => column_expand,\n+    (compile_error, CompileError) => compile_error_expand,\n+    (file, File) => file_expand,\n+    (line, Line) => line_expand,\n+    (stringify, Stringify) => stringify_expand,\n+    (format_args, FormatArgs) => format_args_expand,\n+    (env, Env) => env_expand,\n+    (option_env, OptionEnv) => option_env_expand,\n+    // format_args_nl only differs in that it adds a newline in the end,\n+    // so we use the same stub expansion for now\n+    (format_args_nl, FormatArgsNl) => format_args_expand\n }\n \n fn to_line_number(db: &dyn AstDatabase, file: HirFileId, pos: TextUnit) -> usize {\n@@ -82,12 +91,11 @@ fn line_expand(\n     _tt: &tt::Subtree,\n ) -> Result<tt::Subtree, mbe::ExpandError> {\n     let loc = db.lookup_intern_macro(id);\n-    let macro_call = loc.ast_id.to_node(db);\n \n-    let arg = macro_call.token_tree().ok_or_else(|| mbe::ExpandError::UnexpectedToken)?;\n-    let arg_start = arg.syntax().text_range().start();\n+    let arg = loc.kind.arg(db).ok_or_else(|| mbe::ExpandError::UnexpectedToken)?;\n+    let arg_start = arg.text_range().start();\n \n-    let file = id.as_file(MacroFileKind::Expr);\n+    let file = id.as_file();\n     let line_num = to_line_number(db, file, arg_start);\n \n     let expanded = quote! {\n@@ -103,11 +111,10 @@ fn stringify_expand(\n     _tt: &tt::Subtree,\n ) -> Result<tt::Subtree, mbe::ExpandError> {\n     let loc = db.lookup_intern_macro(id);\n-    let macro_call = loc.ast_id.to_node(db);\n \n     let macro_content = {\n-        let arg = macro_call.token_tree().ok_or_else(|| mbe::ExpandError::UnexpectedToken)?;\n-        let macro_args = arg.syntax().clone();\n+        let arg = loc.kind.arg(db).ok_or_else(|| mbe::ExpandError::UnexpectedToken)?;\n+        let macro_args = arg;\n         let text = macro_args.text();\n         let without_parens = TextUnit::of_char('(')..text.len() - TextUnit::of_char(')');\n         text.slice(without_parens).to_string()\n@@ -120,6 +127,28 @@ fn stringify_expand(\n     Ok(expanded)\n }\n \n+fn env_expand(\n+    _db: &dyn AstDatabase,\n+    _id: MacroCallId,\n+    _tt: &tt::Subtree,\n+) -> Result<tt::Subtree, mbe::ExpandError> {\n+    // dummy implementation for type-checking purposes\n+    let expanded = quote! { \"\" };\n+\n+    Ok(expanded)\n+}\n+\n+fn option_env_expand(\n+    _db: &dyn AstDatabase,\n+    _id: MacroCallId,\n+    _tt: &tt::Subtree,\n+) -> Result<tt::Subtree, mbe::ExpandError> {\n+    // dummy implementation for type-checking purposes\n+    let expanded = quote! { std::option::Option::None::<&str> };\n+\n+    Ok(expanded)\n+}\n+\n fn to_col_number(db: &dyn AstDatabase, file: HirFileId, pos: TextUnit) -> usize {\n     // FIXME: Use expansion info\n     let file_id = file.original_file(db);\n@@ -137,7 +166,7 @@ fn to_col_number(db: &dyn AstDatabase, file: HirFileId, pos: TextUnit) -> usize\n         if c == '\\n' {\n             break;\n         }\n-        col_num = col_num + 1;\n+        col_num += 1;\n     }\n     col_num\n }\n@@ -148,12 +177,15 @@ fn column_expand(\n     _tt: &tt::Subtree,\n ) -> Result<tt::Subtree, mbe::ExpandError> {\n     let loc = db.lookup_intern_macro(id);\n-    let macro_call = loc.ast_id.to_node(db);\n+    let macro_call = match loc.kind {\n+        crate::MacroCallKind::FnLike(ast_id) => ast_id.to_node(db),\n+        _ => panic!(\"column macro called as attr\"),\n+    };\n \n     let _arg = macro_call.token_tree().ok_or_else(|| mbe::ExpandError::UnexpectedToken)?;\n     let col_start = macro_call.syntax().text_range().start();\n \n-    let file = id.as_file(MacroFileKind::Expr);\n+    let file = id.as_file();\n     let col_num = to_col_number(db, file, col_start);\n \n     let expanded = quote! {\n@@ -164,15 +196,10 @@ fn column_expand(\n }\n \n fn file_expand(\n-    db: &dyn AstDatabase,\n-    id: MacroCallId,\n+    _db: &dyn AstDatabase,\n+    _id: MacroCallId,\n     _tt: &tt::Subtree,\n ) -> Result<tt::Subtree, mbe::ExpandError> {\n-    let loc = db.lookup_intern_macro(id);\n-    let macro_call = loc.ast_id.to_node(db);\n-\n-    let _ = macro_call.token_tree().ok_or_else(|| mbe::ExpandError::UnexpectedToken)?;\n-\n     // FIXME: RA purposefully lacks knowledge of absolute file names\n     // so just return \"\".\n     let file_name = \"\";\n@@ -204,34 +231,83 @@ fn compile_error_expand(\n     Err(mbe::ExpandError::BindingError(\"Must be a string\".into()))\n }\n \n+fn format_args_expand(\n+    _db: &dyn AstDatabase,\n+    _id: MacroCallId,\n+    tt: &tt::Subtree,\n+) -> Result<tt::Subtree, mbe::ExpandError> {\n+    // We expand `format_args!(\"\", a1, a2)` to\n+    // ```\n+    // std::fmt::Arguments::new_v1(&[], &[\n+    //   std::fmt::ArgumentV1::new(&arg1,std::fmt::Display::fmt),\n+    //   std::fmt::ArgumentV1::new(&arg2,std::fmt::Display::fmt),\n+    // ])\n+    // ```,\n+    // which is still not really correct, but close enough for now\n+    let mut args = Vec::new();\n+    let mut current = Vec::new();\n+    for tt in tt.token_trees.iter().cloned() {\n+        match tt {\n+            tt::TokenTree::Leaf(tt::Leaf::Punct(p)) if p.char == ',' => {\n+                args.push(current);\n+                current = Vec::new();\n+            }\n+            _ => {\n+                current.push(tt);\n+            }\n+        }\n+    }\n+    if !current.is_empty() {\n+        args.push(current);\n+    }\n+    if args.is_empty() {\n+        return Err(mbe::ExpandError::NoMatchingRule);\n+    }\n+    let _format_string = args.remove(0);\n+    let arg_tts = args.into_iter().flat_map(|arg| {\n+        quote! { std::fmt::ArgumentV1::new(&(##arg), std::fmt::Display::fmt), }\n+    }.token_trees).collect::<Vec<_>>();\n+    let expanded = quote! {\n+        std::fmt::Arguments::new_v1(&[], &[##arg_tts])\n+    };\n+    Ok(expanded)\n+}\n+\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use crate::{test_db::TestDB, MacroCallLoc};\n+    use crate::{name::AsName, test_db::TestDB, MacroCallKind, MacroCallLoc};\n     use ra_db::{fixture::WithFixture, SourceDatabase};\n+    use ra_syntax::ast::NameOwner;\n \n-    fn expand_builtin_macro(s: &str, expander: BuiltinFnLikeExpander) -> String {\n+    fn expand_builtin_macro(s: &str) -> String {\n         let (db, file_id) = TestDB::with_single_file(&s);\n         let parsed = db.parse(file_id);\n         let macro_calls: Vec<_> =\n             parsed.syntax_node().descendants().filter_map(|it| ast::MacroCall::cast(it)).collect();\n \n         let ast_id_map = db.ast_id_map(file_id.into());\n \n+        let expander =\n+            BuiltinFnLikeExpander::by_name(&macro_calls[0].name().unwrap().as_name()).unwrap();\n+\n         // the first one should be a macro_rules\n         let def = MacroDefId {\n-            krate: CrateId(0),\n-            ast_id: AstId::new(file_id.into(), ast_id_map.ast_id(&macro_calls[0])),\n+            krate: Some(CrateId(0)),\n+            ast_id: Some(AstId::new(file_id.into(), ast_id_map.ast_id(&macro_calls[0]))),\n             kind: MacroDefKind::BuiltIn(expander),\n         };\n \n         let loc = MacroCallLoc {\n             def,\n-            ast_id: AstId::new(file_id.into(), ast_id_map.ast_id(&macro_calls[1])),\n+            kind: MacroCallKind::FnLike(AstId::new(\n+                file_id.into(),\n+                ast_id_map.ast_id(&macro_calls[1]),\n+            )),\n         };\n \n         let id = db.intern_macro(loc);\n-        let parsed = db.parse_or_expand(id.as_file(MacroFileKind::Expr)).unwrap();\n+        let parsed = db.parse_or_expand(id.as_file()).unwrap();\n \n         parsed.text().to_string()\n     }\n@@ -240,25 +316,23 @@ mod tests {\n     fn test_column_expand() {\n         let expanded = expand_builtin_macro(\n             r#\"\n-        #[rustc_builtin_macro]\n-        macro_rules! column {() => {}}\n-        column!()\n-\"#,\n-            BuiltinFnLikeExpander::Column,\n+            #[rustc_builtin_macro]\n+            macro_rules! column {() => {}}\n+            column!()\n+            \"#,\n         );\n \n-        assert_eq!(expanded, \"9\");\n+        assert_eq!(expanded, \"13\");\n     }\n \n     #[test]\n     fn test_line_expand() {\n         let expanded = expand_builtin_macro(\n             r#\"\n-        #[rustc_builtin_macro]\n-        macro_rules! line {() => {}}\n-        line!()\n-\"#,\n-            BuiltinFnLikeExpander::Line,\n+            #[rustc_builtin_macro]\n+            macro_rules! line {() => {}}\n+            line!()\n+            \"#,\n         );\n \n         assert_eq!(expanded, \"4\");\n@@ -268,25 +342,49 @@ mod tests {\n     fn test_stringify_expand() {\n         let expanded = expand_builtin_macro(\n             r#\"\n-        #[rustc_builtin_macro]\n-        macro_rules! stringify {() => {}}\n-        stringify!(a b c)\n-\"#,\n-            BuiltinFnLikeExpander::Stringify,\n+            #[rustc_builtin_macro]\n+            macro_rules! stringify {() => {}}\n+            stringify!(a b c)\n+            \"#,\n         );\n \n         assert_eq!(expanded, \"\\\"a b c\\\"\");\n     }\n \n+    #[test]\n+    fn test_env_expand() {\n+        let expanded = expand_builtin_macro(\n+            r#\"\n+            #[rustc_builtin_macro]\n+            macro_rules! env {() => {}}\n+            env!(\"TEST_ENV_VAR\")\n+            \"#,\n+        );\n+\n+        assert_eq!(expanded, \"\\\"\\\"\");\n+    }\n+\n+    #[test]\n+    fn test_option_env_expand() {\n+        let expanded = expand_builtin_macro(\n+            r#\"\n+            #[rustc_builtin_macro]\n+            macro_rules! option_env {() => {}}\n+            option_env!(\"TEST_ENV_VAR\")\n+            \"#,\n+        );\n+\n+        assert_eq!(expanded, \"std::option::Option::None:: <&str>\");\n+    }\n+\n     #[test]\n     fn test_file_expand() {\n         let expanded = expand_builtin_macro(\n             r#\"\n-        #[rustc_builtin_macro]\n-        macro_rules! file {() => {}}\n-        file!()\n-\"#,\n-            BuiltinFnLikeExpander::File,\n+            #[rustc_builtin_macro]\n+            macro_rules! file {() => {}}\n+            file!()\n+            \"#,\n         );\n \n         assert_eq!(expanded, \"\\\"\\\"\");\n@@ -296,16 +394,34 @@ mod tests {\n     fn test_compile_error_expand() {\n         let expanded = expand_builtin_macro(\n             r#\"\n-        #[rustc_builtin_macro]\n-        macro_rules! compile_error {\n-            ($msg:expr) => ({ /* compiler built-in */ });\n-            ($msg:expr,) => ({ /* compiler built-in */ })\n-        }\n-        compile_error!(\"error!\");\n-\"#,\n-            BuiltinFnLikeExpander::CompileError,\n+            #[rustc_builtin_macro]\n+            macro_rules! compile_error {\n+                ($msg:expr) => ({ /* compiler built-in */ });\n+                ($msg:expr,) => ({ /* compiler built-in */ })\n+            }\n+            compile_error!(\"error!\");\n+            \"#,\n         );\n \n         assert_eq!(expanded, r#\"loop{\"error!\"}\"#);\n     }\n+\n+    #[test]\n+    fn test_format_args_expand() {\n+        let expanded = expand_builtin_macro(\n+            r#\"\n+            #[rustc_builtin_macro]\n+            macro_rules! format_args {\n+                ($fmt:expr) => ({ /* compiler built-in */ });\n+                ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ })\n+            }\n+            format_args!(\"{} {:?}\", arg1(a, b, c), arg2);\n+            \"#,\n+        );\n+\n+        assert_eq!(\n+            expanded,\n+            r#\"std::fmt::Arguments::new_v1(&[] ,&[std::fmt::ArgumentV1::new(&(arg1(a,b,c)),std::fmt::Display::fmt),std::fmt::ArgumentV1::new(&(arg2),std::fmt::Display::fmt),])\"#\n+        );\n+    }\n }"}, {"sha": "2e12e126f74a909e796e7a0c6b0c0d58a9df768e", "filename": "crates/ra_hir_expand/src/db.rs", "status": "modified", "additions": 52, "deletions": 14, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -6,17 +6,18 @@ use mbe::MacroRules;\n use ra_db::{salsa, SourceDatabase};\n use ra_parser::FragmentKind;\n use ra_prof::profile;\n-use ra_syntax::{AstNode, Parse, SyntaxNode};\n+use ra_syntax::{AstNode, Parse, SyntaxKind::*, SyntaxNode};\n \n use crate::{\n-    ast_id_map::AstIdMap, BuiltinFnLikeExpander, HirFileId, HirFileIdRepr, MacroCallId,\n-    MacroCallLoc, MacroDefId, MacroDefKind, MacroFile, MacroFileKind,\n+    ast_id_map::AstIdMap, BuiltinDeriveExpander, BuiltinFnLikeExpander, HirFileId, HirFileIdRepr,\n+    MacroCallId, MacroCallLoc, MacroDefId, MacroDefKind, MacroFile,\n };\n \n #[derive(Debug, Clone, Eq, PartialEq)]\n pub enum TokenExpander {\n     MacroRules(mbe::MacroRules),\n     Builtin(BuiltinFnLikeExpander),\n+    BuiltinDerive(BuiltinDeriveExpander),\n }\n \n impl TokenExpander {\n@@ -29,20 +30,23 @@ impl TokenExpander {\n         match self {\n             TokenExpander::MacroRules(it) => it.expand(tt),\n             TokenExpander::Builtin(it) => it.expand(db, id, tt),\n+            TokenExpander::BuiltinDerive(it) => it.expand(db, id, tt),\n         }\n     }\n \n     pub fn map_id_down(&self, id: tt::TokenId) -> tt::TokenId {\n         match self {\n             TokenExpander::MacroRules(it) => it.map_id_down(id),\n             TokenExpander::Builtin(..) => id,\n+            TokenExpander::BuiltinDerive(..) => id,\n         }\n     }\n \n     pub fn map_id_up(&self, id: tt::TokenId) -> (tt::TokenId, mbe::Origin) {\n         match self {\n             TokenExpander::MacroRules(it) => it.map_id_up(id),\n-            TokenExpander::Builtin(..) => (id, mbe::Origin::Def),\n+            TokenExpander::Builtin(..) => (id, mbe::Origin::Call),\n+            TokenExpander::BuiltinDerive(..) => (id, mbe::Origin::Call),\n         }\n     }\n }\n@@ -76,7 +80,7 @@ pub(crate) fn macro_def(\n ) -> Option<Arc<(TokenExpander, mbe::TokenMap)>> {\n     match id.kind {\n         MacroDefKind::Declarative => {\n-            let macro_call = id.ast_id.to_node(db);\n+            let macro_call = id.ast_id?.to_node(db);\n             let arg = macro_call.token_tree()?;\n             let (tt, tmap) = mbe::ast_to_token_tree(&arg).or_else(|| {\n                 log::warn!(\"fail on macro_def to token tree: {:#?}\", arg);\n@@ -89,7 +93,10 @@ pub(crate) fn macro_def(\n             Some(Arc::new((TokenExpander::MacroRules(rules), tmap)))\n         }\n         MacroDefKind::BuiltIn(expander) => {\n-            Some(Arc::new((TokenExpander::Builtin(expander.clone()), mbe::TokenMap::default())))\n+            Some(Arc::new((TokenExpander::Builtin(expander), mbe::TokenMap::default())))\n+        }\n+        MacroDefKind::BuiltInDerive(expander) => {\n+            Some(Arc::new((TokenExpander::BuiltinDerive(expander), mbe::TokenMap::default())))\n         }\n     }\n }\n@@ -99,9 +106,8 @@ pub(crate) fn macro_arg(\n     id: MacroCallId,\n ) -> Option<Arc<(tt::Subtree, mbe::TokenMap)>> {\n     let loc = db.lookup_intern_macro(id);\n-    let macro_call = loc.ast_id.to_node(db);\n-    let arg = macro_call.token_tree()?;\n-    let (tt, tmap) = mbe::ast_to_token_tree(&arg)?;\n+    let arg = loc.kind.arg(db)?;\n+    let (tt, tmap) = mbe::syntax_node_to_token_tree(&arg)?;\n     Some(Arc::new((tt, tmap)))\n }\n \n@@ -148,11 +154,43 @@ pub(crate) fn parse_macro(\n         })\n         .ok()?;\n \n-    let fragment_kind = match macro_file.macro_file_kind {\n-        MacroFileKind::Items => FragmentKind::Items,\n-        MacroFileKind::Expr => FragmentKind::Expr,\n-        MacroFileKind::Statements => FragmentKind::Statements,\n-    };\n+    let fragment_kind = to_fragment_kind(db, macro_call_id);\n+\n     let (parse, rev_token_map) = mbe::token_tree_to_syntax_node(&tt, fragment_kind).ok()?;\n     Some((parse, Arc::new(rev_token_map)))\n }\n+\n+/// Given a `MacroCallId`, return what `FragmentKind` it belongs to.\n+/// FIXME: Not completed\n+fn to_fragment_kind(db: &dyn AstDatabase, macro_call_id: MacroCallId) -> FragmentKind {\n+    let syn = db.lookup_intern_macro(macro_call_id).kind.node(db).value;\n+\n+    let parent = match syn.parent() {\n+        Some(it) => it,\n+        None => {\n+            // FIXME:\n+            // If it is root, which means the parent HirFile\n+            // MacroKindFile must be non-items\n+            // return expr now.\n+            return FragmentKind::Expr;\n+        }\n+    };\n+\n+    match parent.kind() {\n+        MACRO_ITEMS | SOURCE_FILE => FragmentKind::Items,\n+        LET_STMT => {\n+            // FIXME: Handle Pattern\n+            FragmentKind::Expr\n+        }\n+        // FIXME: Expand to statements in appropriate positions; HIR lowering needs to handle that\n+        EXPR_STMT | BLOCK => FragmentKind::Expr,\n+        ARG_LIST => FragmentKind::Expr,\n+        TRY_EXPR => FragmentKind::Expr,\n+        TUPLE_EXPR => FragmentKind::Expr,\n+        ITEM_LIST => FragmentKind::Items,\n+        _ => {\n+            // Unknown , Just guess it is `Items`\n+            FragmentKind::Items\n+        }\n+    }\n+}"}, {"sha": "108c1e38c6d3d91bd49d59a84131801c28f8e05b", "filename": "crates/ra_hir_expand/src/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_expand%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_expand%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fdiagnostics.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -18,11 +18,11 @@ use std::{any::Any, fmt};\n \n use ra_syntax::{SyntaxNode, SyntaxNodePtr, TextRange};\n \n-use crate::{db::AstDatabase, Source};\n+use crate::{db::AstDatabase, InFile};\n \n pub trait Diagnostic: Any + Send + Sync + fmt::Debug + 'static {\n     fn message(&self) -> String;\n-    fn source(&self) -> Source<SyntaxNodePtr>;\n+    fn source(&self) -> InFile<SyntaxNodePtr>;\n     fn highlight_range(&self) -> TextRange {\n         self.source().value.range()\n     }"}, {"sha": "83583ef8bd3ca81e587a106e6bb60053f1deb3e9", "filename": "crates/ra_hir_expand/src/either.rs", "status": "removed", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_expand%2Fsrc%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_expand%2Fsrc%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Feither.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -1,54 +0,0 @@\n-//! FIXME: write short doc here\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub enum Either<A, B> {\n-    A(A),\n-    B(B),\n-}\n-\n-impl<A, B> Either<A, B> {\n-    pub fn either<R, F1, F2>(self, f1: F1, f2: F2) -> R\n-    where\n-        F1: FnOnce(A) -> R,\n-        F2: FnOnce(B) -> R,\n-    {\n-        match self {\n-            Either::A(a) => f1(a),\n-            Either::B(b) => f2(b),\n-        }\n-    }\n-    pub fn map<U, V, F1, F2>(self, f1: F1, f2: F2) -> Either<U, V>\n-    where\n-        F1: FnOnce(A) -> U,\n-        F2: FnOnce(B) -> V,\n-    {\n-        match self {\n-            Either::A(a) => Either::A(f1(a)),\n-            Either::B(b) => Either::B(f2(b)),\n-        }\n-    }\n-    pub fn map_a<U, F>(self, f: F) -> Either<U, B>\n-    where\n-        F: FnOnce(A) -> U,\n-    {\n-        self.map(f, |it| it)\n-    }\n-    pub fn a(self) -> Option<A> {\n-        match self {\n-            Either::A(it) => Some(it),\n-            Either::B(_) => None,\n-        }\n-    }\n-    pub fn b(self) -> Option<B> {\n-        match self {\n-            Either::A(_) => None,\n-            Either::B(it) => Some(it),\n-        }\n-    }\n-    pub fn as_ref(&self) -> Either<&A, &B> {\n-        match self {\n-            Either::A(it) => Either::A(it),\n-            Either::B(it) => Either::B(it),\n-        }\n-    }\n-}"}, {"sha": "2e8a533f70499c86190dcab3ae2fdd645fd250ec", "filename": "crates/ra_hir_expand/src/hygiene.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_expand%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_expand%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fhygiene.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -2,12 +2,12 @@\n //!\n //! Specifically, `ast` + `Hygiene` allows you to create a `Name`. Note that, at\n //! this moment, this is horribly incomplete and handles only `$crate`.\n+use either::Either;\n use ra_db::CrateId;\n use ra_syntax::ast;\n \n use crate::{\n     db::AstDatabase,\n-    either::Either,\n     name::{AsName, Name},\n     HirFileId, HirFileIdRepr, MacroDefKind,\n };\n@@ -25,8 +25,9 @@ impl Hygiene {\n             HirFileIdRepr::MacroFile(macro_file) => {\n                 let loc = db.lookup_intern_macro(macro_file.macro_call_id);\n                 match loc.def.kind {\n-                    MacroDefKind::Declarative => Some(loc.def.krate),\n+                    MacroDefKind::Declarative => loc.def.krate,\n                     MacroDefKind::BuiltIn(_) => None,\n+                    MacroDefKind::BuiltInDerive(_) => None,\n                 }\n             }\n         };\n@@ -41,9 +42,9 @@ impl Hygiene {\n     pub fn name_ref_to_name(&self, name_ref: ast::NameRef) -> Either<Name, CrateId> {\n         if let Some(def_crate) = self.def_crate {\n             if name_ref.text() == \"$crate\" {\n-                return Either::B(def_crate);\n+                return Either::Right(def_crate);\n             }\n         }\n-        Either::A(name_ref.as_name())\n+        Either::Left(name_ref.as_name())\n     }\n }"}, {"sha": "2fa5d51402bc6f8828e1f1147fb6cb76df4f32f6", "filename": "crates/ra_hir_expand/src/lib.rs", "status": "modified", "additions": 126, "deletions": 91, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Flib.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -6,14 +6,14 @@\n \n pub mod db;\n pub mod ast_id_map;\n-pub mod either;\n pub mod name;\n pub mod hygiene;\n pub mod diagnostics;\n+pub mod builtin_derive;\n pub mod builtin_macro;\n pub mod quote;\n \n-use std::hash::{Hash, Hasher};\n+use std::hash::Hash;\n use std::sync::Arc;\n \n use ra_db::{salsa, CrateId, FileId};\n@@ -24,6 +24,7 @@ use ra_syntax::{\n };\n \n use crate::ast_id_map::FileAstId;\n+use crate::builtin_derive::BuiltinDeriveExpander;\n use crate::builtin_macro::BuiltinFnLikeExpander;\n \n #[cfg(test)]\n@@ -70,7 +71,18 @@ impl HirFileId {\n             HirFileIdRepr::FileId(file_id) => file_id,\n             HirFileIdRepr::MacroFile(macro_file) => {\n                 let loc = db.lookup_intern_macro(macro_file.macro_call_id);\n-                loc.ast_id.file_id().original_file(db)\n+                loc.kind.file_id().original_file(db)\n+            }\n+        }\n+    }\n+\n+    /// If this is a macro call, returns the syntax node of the call.\n+    pub fn call_node(self, db: &dyn db::AstDatabase) -> Option<InFile<SyntaxNode>> {\n+        match self.0 {\n+            HirFileIdRepr::FileId(_) => None,\n+            HirFileIdRepr::MacroFile(macro_file) => {\n+                let loc = db.lookup_intern_macro(macro_file.macro_call_id);\n+                Some(loc.kind.node(db))\n             }\n         }\n     }\n@@ -82,17 +94,17 @@ impl HirFileId {\n             HirFileIdRepr::MacroFile(macro_file) => {\n                 let loc: MacroCallLoc = db.lookup_intern_macro(macro_file.macro_call_id);\n \n-                let arg_tt = loc.ast_id.to_node(db).token_tree()?;\n-                let def_tt = loc.def.ast_id.to_node(db).token_tree()?;\n+                let arg_tt = loc.kind.arg(db)?;\n+                let def_tt = loc.def.ast_id?.to_node(db).token_tree()?;\n \n                 let macro_def = db.macro_def(loc.def)?;\n                 let (parse, exp_map) = db.parse_macro(macro_file)?;\n                 let macro_arg = db.macro_arg(macro_file.macro_call_id)?;\n \n                 Some(ExpansionInfo {\n-                    expanded: Source::new(self, parse.syntax_node()),\n-                    arg: Source::new(loc.ast_id.file_id, arg_tt),\n-                    def: Source::new(loc.ast_id.file_id, def_tt),\n+                    expanded: InFile::new(self, parse.syntax_node()),\n+                    arg: InFile::new(loc.kind.file_id(), arg_tt),\n+                    def: InFile::new(loc.def.ast_id?.file_id, def_tt),\n                     macro_arg,\n                     macro_def,\n                     exp_map,\n@@ -105,14 +117,6 @@ impl HirFileId {\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct MacroFile {\n     macro_call_id: MacroCallId,\n-    macro_file_kind: MacroFileKind,\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub enum MacroFileKind {\n-    Items,\n-    Expr,\n-    Statements,\n }\n \n /// `MacroCallId` identifies a particular macro invocation, like\n@@ -130,160 +134,191 @@ impl salsa::InternKey for MacroCallId {\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct MacroDefId {\n-    pub krate: CrateId,\n-    pub ast_id: AstId<ast::MacroCall>,\n+    // FIXME: krate and ast_id are currently optional because we don't have a\n+    // definition location for built-in derives. There is one, though: the\n+    // standard library defines them. The problem is that it uses the new\n+    // `macro` syntax for this, which we don't support yet. As soon as we do\n+    // (which will probably require touching this code), we can instead use\n+    // that (and also remove the hacks for resolving built-in derives).\n+    pub krate: Option<CrateId>,\n+    pub ast_id: Option<AstId<ast::MacroCall>>,\n     pub kind: MacroDefKind,\n }\n \n impl MacroDefId {\n-    pub fn as_call_id(\n-        self,\n-        db: &dyn db::AstDatabase,\n-        ast_id: AstId<ast::MacroCall>,\n-    ) -> MacroCallId {\n-        db.intern_macro(MacroCallLoc { def: self, ast_id })\n+    pub fn as_call_id(self, db: &dyn db::AstDatabase, kind: MacroCallKind) -> MacroCallId {\n+        db.intern_macro(MacroCallLoc { def: self, kind })\n     }\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub enum MacroDefKind {\n     Declarative,\n     BuiltIn(BuiltinFnLikeExpander),\n+    // FIXME: maybe just Builtin and rename BuiltinFnLikeExpander to BuiltinExpander\n+    BuiltInDerive(BuiltinDeriveExpander),\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MacroCallLoc {\n     pub(crate) def: MacroDefId,\n-    pub(crate) ast_id: AstId<ast::MacroCall>,\n+    pub(crate) kind: MacroCallKind,\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub enum MacroCallKind {\n+    FnLike(AstId<ast::MacroCall>),\n+    Attr(AstId<ast::ModuleItem>),\n+}\n+\n+impl MacroCallKind {\n+    pub fn file_id(&self) -> HirFileId {\n+        match self {\n+            MacroCallKind::FnLike(ast_id) => ast_id.file_id,\n+            MacroCallKind::Attr(ast_id) => ast_id.file_id,\n+        }\n+    }\n+\n+    pub fn node(&self, db: &dyn db::AstDatabase) -> InFile<SyntaxNode> {\n+        match self {\n+            MacroCallKind::FnLike(ast_id) => ast_id.with_value(ast_id.to_node(db).syntax().clone()),\n+            MacroCallKind::Attr(ast_id) => ast_id.with_value(ast_id.to_node(db).syntax().clone()),\n+        }\n+    }\n+\n+    pub fn arg(&self, db: &dyn db::AstDatabase) -> Option<SyntaxNode> {\n+        match self {\n+            MacroCallKind::FnLike(ast_id) => {\n+                Some(ast_id.to_node(db).token_tree()?.syntax().clone())\n+            }\n+            MacroCallKind::Attr(ast_id) => Some(ast_id.to_node(db).syntax().clone()),\n+        }\n+    }\n }\n \n impl MacroCallId {\n-    pub fn as_file(self, kind: MacroFileKind) -> HirFileId {\n-        let macro_file = MacroFile { macro_call_id: self, macro_file_kind: kind };\n-        macro_file.into()\n+    pub fn as_file(self) -> HirFileId {\n+        MacroFile { macro_call_id: self }.into()\n     }\n }\n \n /// ExpansionInfo mainly describes how to map text range between src and expanded macro\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct ExpansionInfo {\n-    expanded: Source<SyntaxNode>,\n-    arg: Source<ast::TokenTree>,\n-    def: Source<ast::TokenTree>,\n+    expanded: InFile<SyntaxNode>,\n+    arg: InFile<SyntaxNode>,\n+    def: InFile<ast::TokenTree>,\n \n     macro_def: Arc<(db::TokenExpander, mbe::TokenMap)>,\n     macro_arg: Arc<(tt::Subtree, mbe::TokenMap)>,\n     exp_map: Arc<mbe::TokenMap>,\n }\n \n+pub use mbe::Origin;\n+\n impl ExpansionInfo {\n-    pub fn map_token_down(&self, token: Source<&SyntaxToken>) -> Option<Source<SyntaxToken>> {\n+    pub fn call_node(&self) -> Option<InFile<SyntaxNode>> {\n+        Some(self.arg.with_value(self.arg.value.parent()?))\n+    }\n+\n+    pub fn map_token_down(&self, token: InFile<&SyntaxToken>) -> Option<InFile<SyntaxToken>> {\n         assert_eq!(token.file_id, self.arg.file_id);\n-        let range =\n-            token.value.text_range().checked_sub(self.arg.value.syntax().text_range().start())?;\n+        let range = token.value.text_range().checked_sub(self.arg.value.text_range().start())?;\n         let token_id = self.macro_arg.1.token_by_range(range)?;\n         let token_id = self.macro_def.0.map_id_down(token_id);\n \n-        let range = self.exp_map.range_by_token(token_id)?;\n+        let range = self.exp_map.range_by_token(token_id)?.by_kind(token.value.kind())?;\n \n         let token = algo::find_covering_element(&self.expanded.value, range).into_token()?;\n \n         Some(self.expanded.with_value(token))\n     }\n \n-    pub fn map_token_up(&self, token: Source<&SyntaxToken>) -> Option<Source<SyntaxToken>> {\n+    pub fn map_token_up(\n+        &self,\n+        token: InFile<&SyntaxToken>,\n+    ) -> Option<(InFile<SyntaxToken>, Origin)> {\n         let token_id = self.exp_map.token_by_range(token.value.text_range())?;\n \n         let (token_id, origin) = self.macro_def.0.map_id_up(token_id);\n         let (token_map, tt) = match origin {\n-            mbe::Origin::Call => (&self.macro_arg.1, &self.arg),\n-            mbe::Origin::Def => (&self.macro_def.1, &self.def),\n+            mbe::Origin::Call => (&self.macro_arg.1, self.arg.clone()),\n+            mbe::Origin::Def => {\n+                (&self.macro_def.1, self.def.as_ref().map(|tt| tt.syntax().clone()))\n+            }\n         };\n \n-        let range = token_map.range_by_token(token_id)?;\n-        let token = algo::find_covering_element(\n-            tt.value.syntax(),\n-            range + tt.value.syntax().text_range().start(),\n-        )\n-        .into_token()?;\n-        Some(tt.with_value(token))\n+        let range = token_map.range_by_token(token_id)?.by_kind(token.value.kind())?;\n+        let token = algo::find_covering_element(&tt.value, range + tt.value.text_range().start())\n+            .into_token()?;\n+        Some((tt.with_value(token), origin))\n     }\n }\n \n /// `AstId` points to an AST node in any file.\n ///\n /// It is stable across reparses, and can be used as salsa key/value.\n // FIXME: isn't this just a `Source<FileAstId<N>>` ?\n-#[derive(Debug)]\n-pub struct AstId<N: AstNode> {\n-    file_id: HirFileId,\n-    file_ast_id: FileAstId<N>,\n-}\n-\n-impl<N: AstNode> Clone for AstId<N> {\n-    fn clone(&self) -> AstId<N> {\n-        *self\n-    }\n-}\n-impl<N: AstNode> Copy for AstId<N> {}\n-\n-impl<N: AstNode> PartialEq for AstId<N> {\n-    fn eq(&self, other: &Self) -> bool {\n-        (self.file_id, self.file_ast_id) == (other.file_id, other.file_ast_id)\n-    }\n-}\n-impl<N: AstNode> Eq for AstId<N> {}\n-impl<N: AstNode> Hash for AstId<N> {\n-    fn hash<H: Hasher>(&self, hasher: &mut H) {\n-        (self.file_id, self.file_ast_id).hash(hasher);\n-    }\n-}\n+pub type AstId<N> = InFile<FileAstId<N>>;\n \n impl<N: AstNode> AstId<N> {\n-    pub fn new(file_id: HirFileId, file_ast_id: FileAstId<N>) -> AstId<N> {\n-        AstId { file_id, file_ast_id }\n-    }\n-\n-    pub fn file_id(&self) -> HirFileId {\n-        self.file_id\n-    }\n-\n     pub fn to_node(&self, db: &dyn db::AstDatabase) -> N {\n         let root = db.parse_or_expand(self.file_id).unwrap();\n-        db.ast_id_map(self.file_id).get(self.file_ast_id).to_node(&root)\n+        db.ast_id_map(self.file_id).get(self.value).to_node(&root)\n     }\n }\n \n-/// `Source<T>` stores a value of `T` inside a particular file/syntax tree.\n+/// `InFile<T>` stores a value of `T` inside a particular file/syntax tree.\n ///\n /// Typical usages are:\n ///\n-/// * `Source<SyntaxNode>` -- syntax node in a file\n-/// * `Source<ast::FnDef>` -- ast node in a file\n-/// * `Source<TextUnit>` -- offset in a file\n+/// * `InFile<SyntaxNode>` -- syntax node in a file\n+/// * `InFile<ast::FnDef>` -- ast node in a file\n+/// * `InFile<TextUnit>` -- offset in a file\n #[derive(Debug, PartialEq, Eq, Clone, Copy, Hash)]\n-pub struct Source<T> {\n+pub struct InFile<T> {\n     pub file_id: HirFileId,\n     pub value: T,\n }\n \n-impl<T> Source<T> {\n-    pub fn new(file_id: HirFileId, value: T) -> Source<T> {\n-        Source { file_id, value }\n+impl<T> InFile<T> {\n+    pub fn new(file_id: HirFileId, value: T) -> InFile<T> {\n+        InFile { file_id, value }\n     }\n \n     // Similarly, naming here is stupid...\n-    pub fn with_value<U>(&self, value: U) -> Source<U> {\n-        Source::new(self.file_id, value)\n+    pub fn with_value<U>(&self, value: U) -> InFile<U> {\n+        InFile::new(self.file_id, value)\n     }\n \n-    pub fn map<F: FnOnce(T) -> U, U>(self, f: F) -> Source<U> {\n-        Source::new(self.file_id, f(self.value))\n+    pub fn map<F: FnOnce(T) -> U, U>(self, f: F) -> InFile<U> {\n+        InFile::new(self.file_id, f(self.value))\n     }\n-    pub fn as_ref(&self) -> Source<&T> {\n+    pub fn as_ref(&self) -> InFile<&T> {\n         self.with_value(&self.value)\n     }\n     pub fn file_syntax(&self, db: &impl db::AstDatabase) -> SyntaxNode {\n         db.parse_or_expand(self.file_id).expect(\"source created from invalid file\")\n     }\n }\n+\n+impl<T: Clone> InFile<&T> {\n+    pub fn cloned(&self) -> InFile<T> {\n+        self.with_value(self.value.clone())\n+    }\n+}\n+\n+impl InFile<SyntaxNode> {\n+    pub fn ancestors_with_macros<'a>(\n+        self,\n+        db: &'a impl crate::db::AstDatabase,\n+    ) -> impl Iterator<Item = InFile<SyntaxNode>> + 'a {\n+        std::iter::successors(Some(self), move |node| match node.value.parent() {\n+            Some(parent) => Some(node.with_value(parent)),\n+            None => {\n+                let parent_node = node.file_id.call_node(db)?;\n+                Some(parent_node)\n+            }\n+        })\n+    }\n+}"}, {"sha": "e62693b6852397b12cc07a34e078251fe5c2cc16", "filename": "crates/ra_hir_expand/src/name.rs", "status": "modified", "additions": 107, "deletions": 51, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_expand%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_expand%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fname.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -38,8 +38,8 @@ impl Name {\n     }\n \n     /// Shortcut to create inline plain text name\n-    const fn new_inline_ascii(len: usize, text: &[u8]) -> Name {\n-        Name::new_text(SmolStr::new_inline_from_ascii(len, text))\n+    const fn new_inline_ascii(text: &[u8]) -> Name {\n+        Name::new_text(SmolStr::new_inline_from_ascii(text.len(), text))\n     }\n \n     /// Resolve a name from the text of token.\n@@ -83,6 +83,12 @@ impl AsName for ast::Name {\n     }\n }\n \n+impl AsName for tt::Ident {\n+    fn as_name(&self) -> Name {\n+        Name::resolve(&self.text)\n+    }\n+}\n+\n impl AsName for ast::FieldKind {\n     fn as_name(&self) -> Name {\n         match self {\n@@ -98,52 +104,102 @@ impl AsName for ra_db::Dependency {\n     }\n }\n \n-// Primitives\n-pub const ISIZE: Name = Name::new_inline_ascii(5, b\"isize\");\n-pub const I8: Name = Name::new_inline_ascii(2, b\"i8\");\n-pub const I16: Name = Name::new_inline_ascii(3, b\"i16\");\n-pub const I32: Name = Name::new_inline_ascii(3, b\"i32\");\n-pub const I64: Name = Name::new_inline_ascii(3, b\"i64\");\n-pub const I128: Name = Name::new_inline_ascii(4, b\"i128\");\n-pub const USIZE: Name = Name::new_inline_ascii(5, b\"usize\");\n-pub const U8: Name = Name::new_inline_ascii(2, b\"u8\");\n-pub const U16: Name = Name::new_inline_ascii(3, b\"u16\");\n-pub const U32: Name = Name::new_inline_ascii(3, b\"u32\");\n-pub const U64: Name = Name::new_inline_ascii(3, b\"u64\");\n-pub const U128: Name = Name::new_inline_ascii(4, b\"u128\");\n-pub const F32: Name = Name::new_inline_ascii(3, b\"f32\");\n-pub const F64: Name = Name::new_inline_ascii(3, b\"f64\");\n-pub const BOOL: Name = Name::new_inline_ascii(4, b\"bool\");\n-pub const CHAR: Name = Name::new_inline_ascii(4, b\"char\");\n-pub const STR: Name = Name::new_inline_ascii(3, b\"str\");\n-\n-// Special names\n-pub const SELF_PARAM: Name = Name::new_inline_ascii(4, b\"self\");\n-pub const SELF_TYPE: Name = Name::new_inline_ascii(4, b\"Self\");\n-pub const MACRO_RULES: Name = Name::new_inline_ascii(11, b\"macro_rules\");\n-\n-// Components of known path (value or mod name)\n-pub const STD: Name = Name::new_inline_ascii(3, b\"std\");\n-pub const ITER: Name = Name::new_inline_ascii(4, b\"iter\");\n-pub const OPS: Name = Name::new_inline_ascii(3, b\"ops\");\n-pub const FUTURE: Name = Name::new_inline_ascii(6, b\"future\");\n-pub const RESULT: Name = Name::new_inline_ascii(6, b\"result\");\n-pub const BOXED: Name = Name::new_inline_ascii(5, b\"boxed\");\n-\n-// Components of known path (type name)\n-pub const INTO_ITERATOR_TYPE: Name = Name::new_inline_ascii(12, b\"IntoIterator\");\n-pub const ITEM_TYPE: Name = Name::new_inline_ascii(4, b\"Item\");\n-pub const TRY_TYPE: Name = Name::new_inline_ascii(3, b\"Try\");\n-pub const OK_TYPE: Name = Name::new_inline_ascii(2, b\"Ok\");\n-pub const FUTURE_TYPE: Name = Name::new_inline_ascii(6, b\"Future\");\n-pub const RESULT_TYPE: Name = Name::new_inline_ascii(6, b\"Result\");\n-pub const OUTPUT_TYPE: Name = Name::new_inline_ascii(6, b\"Output\");\n-pub const TARGET_TYPE: Name = Name::new_inline_ascii(6, b\"Target\");\n-pub const BOX_TYPE: Name = Name::new_inline_ascii(3, b\"Box\");\n-\n-// Builtin Macros\n-pub const FILE_MACRO: Name = Name::new_inline_ascii(4, b\"file\");\n-pub const COLUMN_MACRO: Name = Name::new_inline_ascii(6, b\"column\");\n-pub const COMPILE_ERROR_MACRO: Name = Name::new_inline_ascii(13, b\"compile_error\");\n-pub const LINE_MACRO: Name = Name::new_inline_ascii(4, b\"line\");\n-pub const STRINGIFY_MACRO: Name = Name::new_inline_ascii(9, b\"stringify\");\n+pub mod known {\n+    macro_rules! known_names {\n+        ($($ident:ident),* $(,)?) => {\n+            $(\n+                #[allow(bad_style)]\n+                pub const $ident: super::Name =\n+                    super::Name::new_inline_ascii(stringify!($ident).as_bytes());\n+            )*\n+        };\n+    }\n+\n+    known_names!(\n+        // Primitives\n+        isize,\n+        i8,\n+        i16,\n+        i32,\n+        i64,\n+        i128,\n+        usize,\n+        u8,\n+        u16,\n+        u32,\n+        u64,\n+        u128,\n+        f32,\n+        f64,\n+        bool,\n+        char,\n+        str,\n+        // Special names\n+        macro_rules,\n+        // Components of known path (value or mod name)\n+        std,\n+        iter,\n+        ops,\n+        future,\n+        result,\n+        boxed,\n+        // Components of known path (type name)\n+        IntoIterator,\n+        Item,\n+        Try,\n+        Ok,\n+        Future,\n+        Result,\n+        Output,\n+        Target,\n+        Box,\n+        RangeFrom,\n+        RangeFull,\n+        RangeInclusive,\n+        RangeToInclusive,\n+        RangeTo,\n+        Range,\n+        Neg,\n+        Not,\n+        Index,\n+        // Builtin macros\n+        file,\n+        column,\n+        compile_error,\n+        line,\n+        stringify,\n+        format_args,\n+        format_args_nl,\n+        env,\n+        option_env,\n+        // Builtin derives\n+        Copy,\n+        Clone,\n+        Default,\n+        Debug,\n+        Hash,\n+        Ord,\n+        PartialOrd,\n+        Eq,\n+        PartialEq,\n+    );\n+\n+    // self/Self cannot be used as an identifier\n+    pub const SELF_PARAM: super::Name = super::Name::new_inline_ascii(b\"self\");\n+    pub const SELF_TYPE: super::Name = super::Name::new_inline_ascii(b\"Self\");\n+\n+    #[macro_export]\n+    macro_rules! name {\n+        (self) => {\n+            $crate::name::known::SELF_PARAM\n+        };\n+        (Self) => {\n+            $crate::name::known::SELF_TYPE\n+        };\n+        ($ident:ident) => {\n+            $crate::name::known::$ident\n+        };\n+    }\n+}\n+\n+pub use crate::name;"}, {"sha": "4de219ce463e39df243f4f5fd5eabc9c99fd3a30", "filename": "crates/ra_hir_expand/src/quote.rs", "status": "modified", "additions": 32, "deletions": 8, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_expand%2Fsrc%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_expand%2Fsrc%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fquote.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -16,7 +16,10 @@ macro_rules! __quote {\n         {\n             let children = $crate::__quote!($($tt)*);\n             let subtree = tt::Subtree {\n-                delimiter: tt::Delimiter::$delim,\n+                delimiter: Some(tt::Delimiter {\n+                    kind: tt::DelimiterKind::$delim,\n+                    id: tt::TokenId::unspecified(),\n+                }),\n                 token_trees: $crate::quote::IntoTt::to_tokens(children),\n             };\n             subtree\n@@ -29,6 +32,7 @@ macro_rules! __quote {\n                 tt::Leaf::Punct(tt::Punct {\n                     char: $first,\n                     spacing: tt::Spacing::Alone,\n+                    id: tt::TokenId::unspecified(),\n                 }).into()\n             ]\n         }\n@@ -40,10 +44,12 @@ macro_rules! __quote {\n                 tt::Leaf::Punct(tt::Punct {\n                     char: $first,\n                     spacing: tt::Spacing::Joint,\n+                    id: tt::TokenId::unspecified(),\n                 }).into(),\n                 tt::Leaf::Punct(tt::Punct {\n                     char: $sec,\n                     spacing: tt::Spacing::Alone,\n+                    id: tt::TokenId::unspecified(),\n                 }).into()\n             ]\n         }\n@@ -60,6 +66,15 @@ macro_rules! __quote {\n         }\n     };\n \n+    ( ## $first:ident $($tail:tt)* ) => {\n+        {\n+            let mut tokens = $first.into_iter().map($crate::quote::ToTokenTree::to_token).collect::<Vec<tt::TokenTree>>();\n+            let mut tail_tokens = $crate::quote::IntoTt::to_tokens($crate::__quote!($($tail)*));\n+            tokens.append(&mut tail_tokens);\n+            tokens\n+        }\n+    };\n+\n     // Brace\n     ( { $($tt:tt)* } ) => { $crate::__quote!(@SUBTREE Brace $($tt)*) };\n     // Bracket\n@@ -85,7 +100,10 @@ macro_rules! __quote {\n     ( & ) => {$crate::__quote!(@PUNCT '&')};\n     ( , ) => {$crate::__quote!(@PUNCT ',')};\n     ( : ) => {$crate::__quote!(@PUNCT ':')};\n+    ( :: ) => {$crate::__quote!(@PUNCT ':', ':')};\n     ( . ) => {$crate::__quote!(@PUNCT '.')};\n+    ( < ) => {$crate::__quote!(@PUNCT '<')};\n+    ( > ) => {$crate::__quote!(@PUNCT '>')};\n \n     ( $first:tt $($tail:tt)+ ) => {\n         {\n@@ -114,7 +132,7 @@ pub(crate) trait IntoTt {\n \n impl IntoTt for Vec<tt::TokenTree> {\n     fn to_subtree(self) -> tt::Subtree {\n-        tt::Subtree { delimiter: tt::Delimiter::None, token_trees: self }\n+        tt::Subtree { delimiter: None, token_trees: self }\n     }\n \n     fn to_tokens(self) -> Vec<tt::TokenTree> {\n@@ -169,15 +187,15 @@ macro_rules! impl_to_to_tokentrees {\n }\n \n impl_to_to_tokentrees! {\n-    u32 => self { tt::Literal{text: self.to_string().into()} };\n-    usize => self { tt::Literal{text: self.to_string().into()}};\n-    i32 => self { tt::Literal{text: self.to_string().into()}};\n+    u32 => self { tt::Literal{text: self.to_string().into(), id: tt::TokenId::unspecified()} };\n+    usize => self { tt::Literal{text: self.to_string().into(), id: tt::TokenId::unspecified()}};\n+    i32 => self { tt::Literal{text: self.to_string().into(), id: tt::TokenId::unspecified()}};\n     tt::Leaf => self { self };\n     tt::Literal => self { self };\n     tt::Ident => self { self };\n     tt::Punct => self { self };\n-    &str => self { tt::Literal{text: format!(\"{:?}\", self.escape_default().to_string()).into()}};\n-    String => self { tt::Literal{text: format!(\"{:?}\", self.escape_default().to_string()).into()}}\n+    &str => self { tt::Literal{text: format!(\"{:?}\", self.escape_default().to_string()).into(), id: tt::TokenId::unspecified()}};\n+    String => self { tt::Literal{text: format!(\"{:?}\", self.escape_default().to_string()).into(), id: tt::TokenId::unspecified()}}\n }\n \n #[cfg(test)]\n@@ -244,7 +262,13 @@ mod tests {\n         let fields =\n             fields.iter().map(|it| quote!(#it: self.#it.clone(), ).token_trees.clone()).flatten();\n \n-        let list = tt::Subtree { delimiter: tt::Delimiter::Brace, token_trees: fields.collect() };\n+        let list = tt::Subtree {\n+            delimiter: Some(tt::Delimiter {\n+                kind: tt::DelimiterKind::Brace,\n+                id: tt::TokenId::unspecified(),\n+            }),\n+            token_trees: fields.collect(),\n+        };\n \n         let quoted = quote! {\n             impl Clone for #struct_name {"}, {"sha": "60793db442511b31c42b363f37ecb62145e174ee", "filename": "crates/ra_hir_ty/Cargo.toml", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_ty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_ty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2FCargo.toml?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -21,10 +21,9 @@ ra_prof = { path = \"../ra_prof\" }\n ra_syntax = { path = \"../ra_syntax\" }\n test_utils = { path = \"../test_utils\" }\n \n-# https://github.com/rust-lang/chalk/pull/294\n-chalk-solve =   { git = \"https://github.com/jackh726/chalk.git\", rev = \"095cd38a4f16337913bba487f2055b9ca0179f30\" }\n-chalk-rust-ir = { git = \"https://github.com/jackh726/chalk.git\", rev = \"095cd38a4f16337913bba487f2055b9ca0179f30\" }\n-chalk-ir =      { git = \"https://github.com/jackh726/chalk.git\", rev = \"095cd38a4f16337913bba487f2055b9ca0179f30\" }\n+chalk-solve =   { git = \"https://github.com/rust-lang/chalk.git\", rev = \"ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5\" }\n+chalk-rust-ir = { git = \"https://github.com/rust-lang/chalk.git\", rev = \"ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5\" }\n+chalk-ir =      { git = \"https://github.com/rust-lang/chalk.git\", rev = \"ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5\" }\n \n lalrpop-intern = \"0.15.1\"\n "}, {"sha": "f32d5786af9589eeab8263fbbbc5b26fa5e2a179", "filename": "crates/ra_hir_ty/src/autoderef.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_ty%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_ty%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fautoderef.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -6,14 +6,14 @@\n use std::iter::successors;\n \n use hir_def::lang_item::LangItemTarget;\n-use hir_expand::name;\n+use hir_expand::name::name;\n use log::{info, warn};\n use ra_db::CrateId;\n \n-use crate::db::HirDatabase;\n-\n-use super::{\n+use crate::{\n+    db::HirDatabase,\n     traits::{InEnvironment, Solution},\n+    utils::generics,\n     Canonical, Substs, Ty, TypeWalk,\n };\n \n@@ -48,14 +48,14 @@ fn deref_by_trait(\n     krate: CrateId,\n     ty: InEnvironment<&Canonical<Ty>>,\n ) -> Option<Canonical<Ty>> {\n-    let deref_trait = match db.lang_item(krate.into(), \"deref\".into())? {\n+    let deref_trait = match db.lang_item(krate, \"deref\".into())? {\n         LangItemTarget::TraitId(it) => it,\n         _ => return None,\n     };\n-    let target = db.trait_data(deref_trait).associated_type_by_name(&name::TARGET_TYPE)?;\n+    let target = db.trait_data(deref_trait).associated_type_by_name(&name![Target])?;\n \n-    let generic_params = db.generic_params(target.into());\n-    if generic_params.count_params_including_parent() != 1 {\n+    let generic_params = generics(db, target.into());\n+    if generic_params.len() != 1 {\n         // the Target type + Deref trait should only have one generic parameter,\n         // namely Deref's Self type\n         return None;\n@@ -78,7 +78,7 @@ fn deref_by_trait(\n \n     let canonical = super::Canonical { num_vars: 1 + ty.value.num_vars, value: in_env };\n \n-    let solution = db.trait_solve(krate.into(), canonical)?;\n+    let solution = db.trait_solve(krate, canonical)?;\n \n     match &solution {\n         Solution::Unique(vars) => {"}, {"sha": "d52f65b83634204019e4c82d3e6fe77e572b9457", "filename": "crates/ra_hir_ty/src/db.rs", "status": "modified", "additions": 19, "deletions": 28, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_ty%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_ty%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdb.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -10,8 +10,8 @@ use ra_db::{salsa, CrateId};\n \n use crate::{\n     method_resolution::CrateImplBlocks,\n-    traits::{AssocTyValue, Impl},\n-    CallableDef, FnSig, GenericPredicate, ImplTy, InferenceResult, Substs, Ty, TyDefId, TypeCtor,\n+    traits::{chalk, AssocTyValue, Impl},\n+    CallableDef, FnSig, GenericPredicate, InferenceResult, Substs, TraitRef, Ty, TyDefId, TypeCtor,\n     ValueTyDefId,\n };\n \n@@ -22,13 +22,18 @@ pub trait HirDatabase: DefDatabase {\n     fn infer(&self, def: DefWithBodyId) -> Arc<InferenceResult>;\n \n     #[salsa::invoke(crate::lower::ty_query)]\n+    #[salsa::cycle(crate::lower::ty_recover)]\n     fn ty(&self, def: TyDefId) -> Ty;\n \n     #[salsa::invoke(crate::lower::value_ty_query)]\n     fn value_ty(&self, def: ValueTyDefId) -> Ty;\n \n-    #[salsa::invoke(crate::lower::impl_ty_query)]\n-    fn impl_ty(&self, def: ImplId) -> ImplTy;\n+    #[salsa::invoke(crate::lower::impl_self_ty_query)]\n+    #[salsa::cycle(crate::lower::impl_self_ty_recover)]\n+    fn impl_self_ty(&self, def: ImplId) -> Ty;\n+\n+    #[salsa::invoke(crate::lower::impl_trait_query)]\n+    fn impl_trait(&self, def: ImplId) -> Option<TraitRef>;\n \n     #[salsa::invoke(crate::lower::field_types_query)]\n     fn field_types(&self, var: VariantId) -> Arc<ArenaMap<LocalStructFieldId, Ty>>;\n@@ -37,6 +42,7 @@ pub trait HirDatabase: DefDatabase {\n     fn callable_item_signature(&self, def: CallableDef) -> FnSig;\n \n     #[salsa::invoke(crate::lower::generic_predicates_for_param_query)]\n+    #[salsa::cycle(crate::lower::generic_predicates_for_param_recover)]\n     fn generic_predicates_for_param(\n         &self,\n         def: GenericDefId,\n@@ -71,39 +77,24 @@ pub trait HirDatabase: DefDatabase {\n     #[salsa::interned]\n     fn intern_assoc_ty_value(&self, assoc_ty_value: AssocTyValue) -> crate::traits::AssocTyValueId;\n \n-    #[salsa::invoke(crate::traits::chalk::associated_ty_data_query)]\n-    fn associated_ty_data(\n-        &self,\n-        id: chalk_ir::TypeId,\n-    ) -> Arc<chalk_rust_ir::AssociatedTyDatum<chalk_ir::family::ChalkIr>>;\n+    #[salsa::invoke(chalk::associated_ty_data_query)]\n+    fn associated_ty_data(&self, id: chalk::AssocTypeId) -> Arc<chalk::AssociatedTyDatum>;\n \n-    #[salsa::invoke(crate::traits::chalk::trait_datum_query)]\n-    fn trait_datum(\n-        &self,\n-        krate: CrateId,\n-        trait_id: chalk_ir::TraitId,\n-    ) -> Arc<chalk_rust_ir::TraitDatum<chalk_ir::family::ChalkIr>>;\n+    #[salsa::invoke(chalk::trait_datum_query)]\n+    fn trait_datum(&self, krate: CrateId, trait_id: chalk::TraitId) -> Arc<chalk::TraitDatum>;\n \n-    #[salsa::invoke(crate::traits::chalk::struct_datum_query)]\n-    fn struct_datum(\n-        &self,\n-        krate: CrateId,\n-        struct_id: chalk_ir::StructId,\n-    ) -> Arc<chalk_rust_ir::StructDatum<chalk_ir::family::ChalkIr>>;\n+    #[salsa::invoke(chalk::struct_datum_query)]\n+    fn struct_datum(&self, krate: CrateId, struct_id: chalk::StructId) -> Arc<chalk::StructDatum>;\n \n     #[salsa::invoke(crate::traits::chalk::impl_datum_query)]\n-    fn impl_datum(\n-        &self,\n-        krate: CrateId,\n-        impl_id: chalk_ir::ImplId,\n-    ) -> Arc<chalk_rust_ir::ImplDatum<chalk_ir::family::ChalkIr>>;\n+    fn impl_datum(&self, krate: CrateId, impl_id: chalk::ImplId) -> Arc<chalk::ImplDatum>;\n \n     #[salsa::invoke(crate::traits::chalk::associated_ty_value_query)]\n     fn associated_ty_value(\n         &self,\n         krate: CrateId,\n-        id: chalk_rust_ir::AssociatedTyValueId,\n-    ) -> Arc<chalk_rust_ir::AssociatedTyValue<chalk_ir::family::ChalkIr>>;\n+        id: chalk::AssociatedTyValueId,\n+    ) -> Arc<chalk::AssociatedTyValue>;\n \n     #[salsa::invoke(crate::traits::trait_solve_query)]\n     fn trait_solve("}, {"sha": "5054189cc1041d624086b9dcb8eeff6bf649e56b", "filename": "crates/ra_hir_ty/src/diagnostics.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -2,7 +2,7 @@\n \n use std::any::Any;\n \n-use hir_expand::{db::AstDatabase, name::Name, HirFileId, Source};\n+use hir_expand::{db::AstDatabase, name::Name, HirFileId, InFile};\n use ra_syntax::{ast, AstNode, AstPtr, SyntaxNodePtr};\n \n pub use hir_def::diagnostics::UnresolvedModule;\n@@ -19,8 +19,8 @@ impl Diagnostic for NoSuchField {\n         \"no such field\".to_string()\n     }\n \n-    fn source(&self) -> Source<SyntaxNodePtr> {\n-        Source { file_id: self.file, value: self.field.into() }\n+    fn source(&self) -> InFile<SyntaxNodePtr> {\n+        InFile { file_id: self.file, value: self.field.into() }\n     }\n \n     fn as_any(&self) -> &(dyn Any + Send + 'static) {\n@@ -44,8 +44,8 @@ impl Diagnostic for MissingFields {\n         }\n         message\n     }\n-    fn source(&self) -> Source<SyntaxNodePtr> {\n-        Source { file_id: self.file, value: self.field_list.into() }\n+    fn source(&self) -> InFile<SyntaxNodePtr> {\n+        InFile { file_id: self.file, value: self.field_list.into() }\n     }\n     fn as_any(&self) -> &(dyn Any + Send + 'static) {\n         self\n@@ -72,8 +72,8 @@ impl Diagnostic for MissingOkInTailExpr {\n     fn message(&self) -> String {\n         \"wrap return expression in Ok\".to_string()\n     }\n-    fn source(&self) -> Source<SyntaxNodePtr> {\n-        Source { file_id: self.file, value: self.expr.into() }\n+    fn source(&self) -> InFile<SyntaxNodePtr> {\n+        InFile { file_id: self.file, value: self.expr.into() }\n     }\n     fn as_any(&self) -> &(dyn Any + Send + 'static) {\n         self"}, {"sha": "dcca1bace6f3d09f9c501e6883d7af253ee61f56", "filename": "crates/ra_hir_ty/src/display.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdisplay.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -10,6 +10,7 @@ pub struct HirFormatter<'a, 'b, DB> {\n     buf: String,\n     curr_size: usize,\n     max_size: Option<usize>,\n+    should_display_default_types: bool,\n }\n \n pub trait HirDisplay {\n@@ -19,7 +20,7 @@ pub trait HirDisplay {\n     where\n         Self: Sized,\n     {\n-        HirDisplayWrapper(db, self, None)\n+        HirDisplayWrapper(db, self, None, true)\n     }\n \n     fn display_truncated<'a, DB>(\n@@ -30,7 +31,7 @@ pub trait HirDisplay {\n     where\n         Self: Sized,\n     {\n-        HirDisplayWrapper(db, self, max_size)\n+        HirDisplayWrapper(db, self, max_size, false)\n     }\n }\n \n@@ -72,9 +73,13 @@ where\n             false\n         }\n     }\n+\n+    pub fn should_display_default_types(&self) -> bool {\n+        self.should_display_default_types\n+    }\n }\n \n-pub struct HirDisplayWrapper<'a, DB, T>(&'a DB, &'a T, Option<usize>);\n+pub struct HirDisplayWrapper<'a, DB, T>(&'a DB, &'a T, Option<usize>, bool);\n \n impl<'a, DB, T> fmt::Display for HirDisplayWrapper<'a, DB, T>\n where\n@@ -88,6 +93,7 @@ where\n             buf: String::with_capacity(20),\n             curr_size: 0,\n             max_size: self.2,\n+            should_display_default_types: self.3,\n         })\n     }\n }"}, {"sha": "f752a9f09ae7cc96d5f2c44c0639364042e7c1d1", "filename": "crates/ra_hir_ty/src/expr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -3,7 +3,7 @@\n use std::sync::Arc;\n \n use hir_def::{\n-    path::{known, Path},\n+    path::{path, Path},\n     resolver::HasResolver,\n     AdtId, FunctionId,\n };\n@@ -97,7 +97,7 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n         let (_, source_map) = db.body_with_source_map(self.func.into());\n \n         if let Some(source_ptr) = source_map.expr_syntax(id) {\n-            if let Some(expr) = source_ptr.value.a() {\n+            if let Some(expr) = source_ptr.value.left() {\n                 let root = source_ptr.file_syntax(db);\n                 if let ast::Expr::RecordLit(record_lit) = expr.to_node(&root) {\n                     if let Some(field_list) = record_lit.record_field_list() {\n@@ -124,7 +124,7 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n             None => return,\n         };\n \n-        let std_result_path = known::std_result_result();\n+        let std_result_path = path![std::result::Result];\n \n         let resolver = self.func.resolver(db);\n         let std_result_enum = match resolver.resolve_known_enum(db, &std_result_path) {\n@@ -142,7 +142,7 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n             let (_, source_map) = db.body_with_source_map(self.func.into());\n \n             if let Some(source_ptr) = source_map.expr_syntax(id) {\n-                if let Some(expr) = source_ptr.value.a() {\n+                if let Some(expr) = source_ptr.value.left() {\n                     self.sink.push(MissingOkInTailExpr { file: source_ptr.file_id, expr });\n                 }\n             }"}, {"sha": "e97b8147395b4e1efa1ab27628797a821c121040", "filename": "crates/ra_hir_ty/src/infer.rs", "status": "modified", "additions": 133, "deletions": 228, "changes": 361, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -18,19 +18,18 @@ use std::mem;\n use std::ops::Index;\n use std::sync::Arc;\n \n-use ena::unify::{InPlaceUnificationTable, NoError, UnifyKey, UnifyValue};\n use rustc_hash::FxHashMap;\n \n use hir_def::{\n     body::Body,\n     data::{ConstData, FunctionData},\n     expr::{BindingAnnotation, ExprId, PatId},\n-    path::{known, Path},\n+    path::{path, Path},\n     resolver::{HasResolver, Resolver, TypeNs},\n     type_ref::{Mutability, TypeRef},\n     AdtId, AssocItemId, DefWithBodyId, FunctionId, StructFieldId, TypeAliasId, VariantId,\n };\n-use hir_expand::{diagnostics::DiagnosticSink, name};\n+use hir_expand::{diagnostics::DiagnosticSink, name::name};\n use ra_arena::map::ArenaMap;\n use ra_prof::profile;\n use test_utils::tested_by;\n@@ -43,6 +42,8 @@ use super::{\n };\n use crate::{db::HirDatabase, infer::diagnostics::InferenceDiagnostic};\n \n+pub(crate) use unify::unify;\n+\n macro_rules! ty_app {\n     ($ctor:pat, $param:pat) => {\n         crate::Ty::Apply(crate::ApplicationTy { ctor: $ctor, parameters: $param })\n@@ -191,11 +192,16 @@ struct InferenceContext<'a, D: HirDatabase> {\n     owner: DefWithBodyId,\n     body: Arc<Body>,\n     resolver: Resolver,\n-    var_unification_table: InPlaceUnificationTable<TypeVarId>,\n+    table: unify::InferenceTable,\n     trait_env: Arc<TraitEnvironment>,\n     obligations: Vec<Obligation>,\n     result: InferenceResult,\n-    /// The return type of the function being inferred.\n+    /// The return type of the function being inferred, or the closure if we're\n+    /// currently within one.\n+    ///\n+    /// We might consider using a nested inference context for checking\n+    /// closures, but currently this is the only field that will change there,\n+    /// so it doesn't make sense.\n     return_ty: Ty,\n \n     /// Impls of `CoerceUnsized` used in coercion.\n@@ -209,7 +215,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     fn new(db: &'a D, owner: DefWithBodyId, resolver: Resolver) -> Self {\n         InferenceContext {\n             result: InferenceResult::default(),\n-            var_unification_table: InPlaceUnificationTable::new(),\n+            table: unify::InferenceTable::new(),\n             obligations: Vec::default(),\n             return_ty: Ty::Unknown, // set in collect_fn_signature\n             trait_env: TraitEnvironment::lower(db, &resolver),\n@@ -224,13 +230,12 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     fn resolve_all(mut self) -> InferenceResult {\n         // FIXME resolve obligations as well (use Guidance if necessary)\n         let mut result = mem::replace(&mut self.result, InferenceResult::default());\n-        let mut tv_stack = Vec::new();\n         for ty in result.type_of_expr.values_mut() {\n-            let resolved = self.resolve_ty_completely(&mut tv_stack, mem::replace(ty, Ty::Unknown));\n+            let resolved = self.table.resolve_ty_completely(mem::replace(ty, Ty::Unknown));\n             *ty = resolved;\n         }\n         for ty in result.type_of_pat.values_mut() {\n-            let resolved = self.resolve_ty_completely(&mut tv_stack, mem::replace(ty, Ty::Unknown));\n+            let resolved = self.table.resolve_ty_completely(mem::replace(ty, Ty::Unknown));\n             *ty = resolved;\n         }\n         result\n@@ -275,96 +280,38 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         self.normalize_associated_types_in(ty)\n     }\n \n-    fn unify_substs(&mut self, substs1: &Substs, substs2: &Substs, depth: usize) -> bool {\n-        substs1.0.iter().zip(substs2.0.iter()).all(|(t1, t2)| self.unify_inner(t1, t2, depth))\n-    }\n-\n-    fn unify(&mut self, ty1: &Ty, ty2: &Ty) -> bool {\n-        self.unify_inner(ty1, ty2, 0)\n-    }\n-\n-    fn unify_inner(&mut self, ty1: &Ty, ty2: &Ty, depth: usize) -> bool {\n-        if depth > 1000 {\n-            // prevent stackoverflows\n-            panic!(\"infinite recursion in unification\");\n-        }\n-        if ty1 == ty2 {\n-            return true;\n-        }\n-        // try to resolve type vars first\n-        let ty1 = self.resolve_ty_shallow(ty1);\n-        let ty2 = self.resolve_ty_shallow(ty2);\n-        match (&*ty1, &*ty2) {\n-            (Ty::Apply(a_ty1), Ty::Apply(a_ty2)) if a_ty1.ctor == a_ty2.ctor => {\n-                self.unify_substs(&a_ty1.parameters, &a_ty2.parameters, depth + 1)\n-            }\n-            _ => self.unify_inner_trivial(&ty1, &ty2),\n-        }\n-    }\n-\n-    fn unify_inner_trivial(&mut self, ty1: &Ty, ty2: &Ty) -> bool {\n-        match (ty1, ty2) {\n-            (Ty::Unknown, _) | (_, Ty::Unknown) => true,\n-\n-            (Ty::Infer(InferTy::TypeVar(tv1)), Ty::Infer(InferTy::TypeVar(tv2)))\n-            | (Ty::Infer(InferTy::IntVar(tv1)), Ty::Infer(InferTy::IntVar(tv2)))\n-            | (Ty::Infer(InferTy::FloatVar(tv1)), Ty::Infer(InferTy::FloatVar(tv2)))\n-            | (\n-                Ty::Infer(InferTy::MaybeNeverTypeVar(tv1)),\n-                Ty::Infer(InferTy::MaybeNeverTypeVar(tv2)),\n-            ) => {\n-                // both type vars are unknown since we tried to resolve them\n-                self.var_unification_table.union(*tv1, *tv2);\n-                true\n-            }\n-\n-            // The order of MaybeNeverTypeVar matters here.\n-            // Unifying MaybeNeverTypeVar and TypeVar will let the latter become MaybeNeverTypeVar.\n-            // Unifying MaybeNeverTypeVar and other concrete type will let the former become it.\n-            (Ty::Infer(InferTy::TypeVar(tv)), other)\n-            | (other, Ty::Infer(InferTy::TypeVar(tv)))\n-            | (Ty::Infer(InferTy::MaybeNeverTypeVar(tv)), other)\n-            | (other, Ty::Infer(InferTy::MaybeNeverTypeVar(tv)))\n-            | (Ty::Infer(InferTy::IntVar(tv)), other @ ty_app!(TypeCtor::Int(_)))\n-            | (other @ ty_app!(TypeCtor::Int(_)), Ty::Infer(InferTy::IntVar(tv)))\n-            | (Ty::Infer(InferTy::FloatVar(tv)), other @ ty_app!(TypeCtor::Float(_)))\n-            | (other @ ty_app!(TypeCtor::Float(_)), Ty::Infer(InferTy::FloatVar(tv))) => {\n-                // the type var is unknown since we tried to resolve it\n-                self.var_unification_table.union_value(*tv, TypeVarValue::Known(other.clone()));\n-                true\n+    /// Replaces `impl Trait` in `ty` by type variables and obligations for\n+    /// those variables. This is done for function arguments when calling a\n+    /// function, and for return types when inside the function body, i.e. in\n+    /// the cases where the `impl Trait` is 'transparent'. In other cases, `impl\n+    /// Trait` is represented by `Ty::Opaque`.\n+    fn insert_vars_for_impl_trait(&mut self, ty: Ty) -> Ty {\n+        ty.fold(&mut |ty| match ty {\n+            Ty::Opaque(preds) => {\n+                tested_by!(insert_vars_for_impl_trait);\n+                let var = self.table.new_type_var();\n+                let var_subst = Substs::builder(1).push(var.clone()).build();\n+                self.obligations.extend(\n+                    preds\n+                        .iter()\n+                        .map(|pred| pred.clone().subst_bound_vars(&var_subst))\n+                        .filter_map(Obligation::from_predicate),\n+                );\n+                var\n             }\n-\n-            _ => false,\n-        }\n-    }\n-\n-    fn new_type_var(&mut self) -> Ty {\n-        Ty::Infer(InferTy::TypeVar(self.var_unification_table.new_key(TypeVarValue::Unknown)))\n-    }\n-\n-    fn new_integer_var(&mut self) -> Ty {\n-        Ty::Infer(InferTy::IntVar(self.var_unification_table.new_key(TypeVarValue::Unknown)))\n-    }\n-\n-    fn new_float_var(&mut self) -> Ty {\n-        Ty::Infer(InferTy::FloatVar(self.var_unification_table.new_key(TypeVarValue::Unknown)))\n-    }\n-\n-    fn new_maybe_never_type_var(&mut self) -> Ty {\n-        Ty::Infer(InferTy::MaybeNeverTypeVar(\n-            self.var_unification_table.new_key(TypeVarValue::Unknown),\n-        ))\n+            _ => ty,\n+        })\n     }\n \n     /// Replaces Ty::Unknown by a new type var, so we can maybe still infer it.\n     fn insert_type_vars_shallow(&mut self, ty: Ty) -> Ty {\n         match ty {\n-            Ty::Unknown => self.new_type_var(),\n+            Ty::Unknown => self.table.new_type_var(),\n             Ty::Apply(ApplicationTy { ctor: TypeCtor::Int(Uncertain::Unknown), .. }) => {\n-                self.new_integer_var()\n+                self.table.new_integer_var()\n             }\n             Ty::Apply(ApplicationTy { ctor: TypeCtor::Float(Uncertain::Unknown), .. }) => {\n-                self.new_float_var()\n+                self.table.new_float_var()\n             }\n             _ => ty,\n         }\n@@ -402,64 +349,52 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         }\n     }\n \n+    fn unify(&mut self, ty1: &Ty, ty2: &Ty) -> bool {\n+        self.table.unify(ty1, ty2)\n+    }\n+\n     /// Resolves the type as far as currently possible, replacing type variables\n     /// by their known types. All types returned by the infer_* functions should\n     /// be resolved as far as possible, i.e. contain no type variables with\n     /// known type.\n-    fn resolve_ty_as_possible(&mut self, tv_stack: &mut Vec<TypeVarId>, ty: Ty) -> Ty {\n+    fn resolve_ty_as_possible(&mut self, ty: Ty) -> Ty {\n         self.resolve_obligations_as_possible();\n \n-        ty.fold(&mut |ty| match ty {\n-            Ty::Infer(tv) => {\n-                let inner = tv.to_inner();\n-                if tv_stack.contains(&inner) {\n-                    tested_by!(type_var_cycles_resolve_as_possible);\n-                    // recursive type\n-                    return tv.fallback_value();\n-                }\n-                if let Some(known_ty) =\n-                    self.var_unification_table.inlined_probe_value(inner).known()\n-                {\n-                    // known_ty may contain other variables that are known by now\n-                    tv_stack.push(inner);\n-                    let result = self.resolve_ty_as_possible(tv_stack, known_ty.clone());\n-                    tv_stack.pop();\n-                    result\n-                } else {\n-                    ty\n-                }\n-            }\n-            _ => ty,\n-        })\n+        self.table.resolve_ty_as_possible(ty)\n     }\n \n-    /// If `ty` is a type variable with known type, returns that type;\n-    /// otherwise, return ty.\n     fn resolve_ty_shallow<'b>(&mut self, ty: &'b Ty) -> Cow<'b, Ty> {\n-        let mut ty = Cow::Borrowed(ty);\n-        // The type variable could resolve to a int/float variable. Hence try\n-        // resolving up to three times; each type of variable shouldn't occur\n-        // more than once\n-        for i in 0..3 {\n-            if i > 0 {\n-                tested_by!(type_var_resolves_to_int_var);\n-            }\n-            match &*ty {\n-                Ty::Infer(tv) => {\n-                    let inner = tv.to_inner();\n-                    match self.var_unification_table.inlined_probe_value(inner).known() {\n-                        Some(known_ty) => {\n-                            // The known_ty can't be a type var itself\n-                            ty = Cow::Owned(known_ty.clone());\n-                        }\n-                        _ => return ty,\n-                    }\n-                }\n-                _ => return ty,\n+        self.table.resolve_ty_shallow(ty)\n+    }\n+\n+    fn resolve_associated_type(&mut self, inner_ty: Ty, assoc_ty: Option<TypeAliasId>) -> Ty {\n+        self.resolve_associated_type_with_params(inner_ty, assoc_ty, &[])\n+    }\n+\n+    fn resolve_associated_type_with_params(\n+        &mut self,\n+        inner_ty: Ty,\n+        assoc_ty: Option<TypeAliasId>,\n+        params: &[Ty],\n+    ) -> Ty {\n+        match assoc_ty {\n+            Some(res_assoc_ty) => {\n+                let ty = self.table.new_type_var();\n+                let builder = Substs::build_for_def(self.db, res_assoc_ty)\n+                    .push(inner_ty)\n+                    .fill(params.iter().cloned());\n+                let projection = ProjectionPredicate {\n+                    ty: ty.clone(),\n+                    projection_ty: ProjectionTy {\n+                        associated_ty: res_assoc_ty,\n+                        parameters: builder.build(),\n+                    },\n+                };\n+                self.obligations.push(Obligation::Projection(projection));\n+                self.resolve_ty_as_possible(ty)\n             }\n+            None => Ty::Unknown,\n         }\n-        log::error!(\"Inference variable still not resolved: {:?}\", ty);\n-        ty\n     }\n \n     /// Recurses through the given type, normalizing associated types mentioned\n@@ -469,48 +404,21 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     /// call). `make_ty` handles this already, but e.g. for field types we need\n     /// to do it as well.\n     fn normalize_associated_types_in(&mut self, ty: Ty) -> Ty {\n-        let ty = self.resolve_ty_as_possible(&mut vec![], ty);\n+        let ty = self.resolve_ty_as_possible(ty);\n         ty.fold(&mut |ty| match ty {\n             Ty::Projection(proj_ty) => self.normalize_projection_ty(proj_ty),\n             _ => ty,\n         })\n     }\n \n     fn normalize_projection_ty(&mut self, proj_ty: ProjectionTy) -> Ty {\n-        let var = self.new_type_var();\n+        let var = self.table.new_type_var();\n         let predicate = ProjectionPredicate { projection_ty: proj_ty, ty: var.clone() };\n         let obligation = Obligation::Projection(predicate);\n         self.obligations.push(obligation);\n         var\n     }\n \n-    /// Resolves the type completely; type variables without known type are\n-    /// replaced by Ty::Unknown.\n-    fn resolve_ty_completely(&mut self, tv_stack: &mut Vec<TypeVarId>, ty: Ty) -> Ty {\n-        ty.fold(&mut |ty| match ty {\n-            Ty::Infer(tv) => {\n-                let inner = tv.to_inner();\n-                if tv_stack.contains(&inner) {\n-                    tested_by!(type_var_cycles_resolve_completely);\n-                    // recursive type\n-                    return tv.fallback_value();\n-                }\n-                if let Some(known_ty) =\n-                    self.var_unification_table.inlined_probe_value(inner).known()\n-                {\n-                    // known_ty may contain other variables that are known by now\n-                    tv_stack.push(inner);\n-                    let result = self.resolve_ty_completely(tv_stack, known_ty.clone());\n-                    tv_stack.pop();\n-                    result\n-                } else {\n-                    tv.fallback_value()\n-                }\n-            }\n-            _ => ty,\n-        })\n-    }\n-\n     fn resolve_variant(&mut self, path: Option<&Path>) -> (Ty, Option<VariantId>) {\n         let path = match path {\n             Some(path) => path,\n@@ -519,7 +427,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         let resolver = &self.resolver;\n         // FIXME: this should resolve assoc items as well, see this example:\n         // https://play.rust-lang.org/?gist=087992e9e22495446c01c0d4e2d69521\n-        match resolver.resolve_path_in_type_ns_fully(self.db, &path) {\n+        match resolver.resolve_path_in_type_ns_fully(self.db, path.mod_path()) {\n             Some(TypeNs::AdtId(AdtId::StructId(strukt))) => {\n                 let substs = Ty::substs_from_path(self.db, resolver, path, strukt.into());\n                 let ty = self.db.ty(strukt.into());\n@@ -547,93 +455,90 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n             self.infer_pat(*pat, &ty, BindingMode::default());\n         }\n-        self.return_ty = self.make_ty(&data.ret_type);\n+        let return_ty = self.make_ty(&data.ret_type);\n+        self.return_ty = self.insert_vars_for_impl_trait(return_ty);\n     }\n \n     fn infer_body(&mut self) {\n-        self.infer_expr(self.body.body_expr, &Expectation::has_type(self.return_ty.clone()));\n+        self.infer_expr_coerce(self.body.body_expr, &Expectation::has_type(self.return_ty.clone()));\n     }\n \n     fn resolve_into_iter_item(&self) -> Option<TypeAliasId> {\n-        let path = known::std_iter_into_iterator();\n+        let path = path![std::iter::IntoIterator];\n         let trait_ = self.resolver.resolve_known_trait(self.db, &path)?;\n-        self.db.trait_data(trait_).associated_type_by_name(&name::ITEM_TYPE)\n+        self.db.trait_data(trait_).associated_type_by_name(&name![Item])\n     }\n \n     fn resolve_ops_try_ok(&self) -> Option<TypeAliasId> {\n-        let path = known::std_ops_try();\n+        let path = path![std::ops::Try];\n+        let trait_ = self.resolver.resolve_known_trait(self.db, &path)?;\n+        self.db.trait_data(trait_).associated_type_by_name(&name![Ok])\n+    }\n+\n+    fn resolve_ops_neg_output(&self) -> Option<TypeAliasId> {\n+        let path = path![std::ops::Neg];\n+        let trait_ = self.resolver.resolve_known_trait(self.db, &path)?;\n+        self.db.trait_data(trait_).associated_type_by_name(&name![Output])\n+    }\n+\n+    fn resolve_ops_not_output(&self) -> Option<TypeAliasId> {\n+        let path = path![std::ops::Not];\n         let trait_ = self.resolver.resolve_known_trait(self.db, &path)?;\n-        self.db.trait_data(trait_).associated_type_by_name(&name::OK_TYPE)\n+        self.db.trait_data(trait_).associated_type_by_name(&name![Output])\n     }\n \n     fn resolve_future_future_output(&self) -> Option<TypeAliasId> {\n-        let path = known::std_future_future();\n+        let path = path![std::future::Future];\n         let trait_ = self.resolver.resolve_known_trait(self.db, &path)?;\n-        self.db.trait_data(trait_).associated_type_by_name(&name::OUTPUT_TYPE)\n+        self.db.trait_data(trait_).associated_type_by_name(&name![Output])\n     }\n \n     fn resolve_boxed_box(&self) -> Option<AdtId> {\n-        let path = known::std_boxed_box();\n+        let path = path![std::boxed::Box];\n         let struct_ = self.resolver.resolve_known_struct(self.db, &path)?;\n         Some(struct_.into())\n     }\n-}\n-\n-/// The ID of a type variable.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n-pub struct TypeVarId(pub(super) u32);\n-\n-impl UnifyKey for TypeVarId {\n-    type Value = TypeVarValue;\n \n-    fn index(&self) -> u32 {\n-        self.0\n+    fn resolve_range_full(&self) -> Option<AdtId> {\n+        let path = path![std::ops::RangeFull];\n+        let struct_ = self.resolver.resolve_known_struct(self.db, &path)?;\n+        Some(struct_.into())\n     }\n \n-    fn from_index(i: u32) -> Self {\n-        TypeVarId(i)\n+    fn resolve_range(&self) -> Option<AdtId> {\n+        let path = path![std::ops::Range];\n+        let struct_ = self.resolver.resolve_known_struct(self.db, &path)?;\n+        Some(struct_.into())\n     }\n \n-    fn tag() -> &'static str {\n-        \"TypeVarId\"\n+    fn resolve_range_inclusive(&self) -> Option<AdtId> {\n+        let path = path![std::ops::RangeInclusive];\n+        let struct_ = self.resolver.resolve_known_struct(self.db, &path)?;\n+        Some(struct_.into())\n     }\n-}\n-\n-/// The value of a type variable: either we already know the type, or we don't\n-/// know it yet.\n-#[derive(Clone, PartialEq, Eq, Debug)]\n-pub enum TypeVarValue {\n-    Known(Ty),\n-    Unknown,\n-}\n \n-impl TypeVarValue {\n-    fn known(&self) -> Option<&Ty> {\n-        match self {\n-            TypeVarValue::Known(ty) => Some(ty),\n-            TypeVarValue::Unknown => None,\n-        }\n+    fn resolve_range_from(&self) -> Option<AdtId> {\n+        let path = path![std::ops::RangeFrom];\n+        let struct_ = self.resolver.resolve_known_struct(self.db, &path)?;\n+        Some(struct_.into())\n     }\n-}\n \n-impl UnifyValue for TypeVarValue {\n-    type Error = NoError;\n-\n-    fn unify_values(value1: &Self, value2: &Self) -> Result<Self, NoError> {\n-        match (value1, value2) {\n-            // We should never equate two type variables, both of which have\n-            // known types. Instead, we recursively equate those types.\n-            (TypeVarValue::Known(t1), TypeVarValue::Known(t2)) => panic!(\n-                \"equating two type variables, both of which have known types: {:?} and {:?}\",\n-                t1, t2\n-            ),\n+    fn resolve_range_to(&self) -> Option<AdtId> {\n+        let path = path![std::ops::RangeTo];\n+        let struct_ = self.resolver.resolve_known_struct(self.db, &path)?;\n+        Some(struct_.into())\n+    }\n \n-            // If one side is known, prefer that one.\n-            (TypeVarValue::Known(..), TypeVarValue::Unknown) => Ok(value1.clone()),\n-            (TypeVarValue::Unknown, TypeVarValue::Known(..)) => Ok(value2.clone()),\n+    fn resolve_range_to_inclusive(&self) -> Option<AdtId> {\n+        let path = path![std::ops::RangeToInclusive];\n+        let struct_ = self.resolver.resolve_known_struct(self.db, &path)?;\n+        Some(struct_.into())\n+    }\n \n-            (TypeVarValue::Unknown, TypeVarValue::Unknown) => Ok(TypeVarValue::Unknown),\n-        }\n+    fn resolve_ops_index_output(&self) -> Option<TypeAliasId> {\n+        let path = path![std::ops::Index];\n+        let trait_ = self.resolver.resolve_known_trait(self.db, &path)?;\n+        self.db.trait_data(trait_).associated_type_by_name(&name![Output])\n     }\n }\n \n@@ -643,14 +548,14 @@ impl UnifyValue for TypeVarValue {\n /// several integer types).\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n pub enum InferTy {\n-    TypeVar(TypeVarId),\n-    IntVar(TypeVarId),\n-    FloatVar(TypeVarId),\n-    MaybeNeverTypeVar(TypeVarId),\n+    TypeVar(unify::TypeVarId),\n+    IntVar(unify::TypeVarId),\n+    FloatVar(unify::TypeVarId),\n+    MaybeNeverTypeVar(unify::TypeVarId),\n }\n \n impl InferTy {\n-    fn to_inner(self) -> TypeVarId {\n+    fn to_inner(self) -> unify::TypeVarId {\n         match self {\n             InferTy::TypeVar(ty)\n             | InferTy::IntVar(ty)\n@@ -693,7 +598,7 @@ impl Expectation {\n }\n \n mod diagnostics {\n-    use hir_def::{expr::ExprId, FunctionId, HasSource, Lookup};\n+    use hir_def::{expr::ExprId, src::HasSource, FunctionId, Lookup};\n     use hir_expand::diagnostics::DiagnosticSink;\n \n     use crate::{db::HirDatabase, diagnostics::NoSuchField};"}, {"sha": "83c0c2c3f334cba765ac75b6384a3ccac54be83e", "filename": "crates/ra_hir_ty/src/infer/coerce.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -8,9 +8,9 @@ use hir_def::{lang_item::LangItemTarget, resolver::Resolver, type_ref::Mutabilit\n use rustc_hash::FxHashMap;\n use test_utils::tested_by;\n \n-use crate::{autoderef, db::HirDatabase, ImplTy, Substs, Ty, TypeCtor, TypeWalk};\n+use crate::{autoderef, db::HirDatabase, Substs, Ty, TypeCtor, TypeWalk};\n \n-use super::{InEnvironment, InferTy, InferenceContext, TypeVarValue};\n+use super::{unify::TypeVarValue, InEnvironment, InferTy, InferenceContext};\n \n impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     /// Unify two types, but may coerce the first one to the second one\n@@ -54,10 +54,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         impls\n             .iter()\n             .filter_map(|&impl_id| {\n-                let trait_ref = match db.impl_ty(impl_id) {\n-                    ImplTy::TraitRef(it) => it,\n-                    ImplTy::Inherent(_) => return None,\n-                };\n+                let trait_ref = db.impl_trait(impl_id)?;\n \n                 // `CoerseUnsized` has one generic parameter for the target type.\n                 let cur_from_ty = trait_ref.substs.0.get(0)?;\n@@ -88,16 +85,16 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         match (&from_ty, to_ty) {\n             // Never type will make type variable to fallback to Never Type instead of Unknown.\n             (ty_app!(TypeCtor::Never), Ty::Infer(InferTy::TypeVar(tv))) => {\n-                let var = self.new_maybe_never_type_var();\n-                self.var_unification_table.union_value(*tv, TypeVarValue::Known(var));\n+                let var = self.table.new_maybe_never_type_var();\n+                self.table.var_unification_table.union_value(*tv, TypeVarValue::Known(var));\n                 return true;\n             }\n             (ty_app!(TypeCtor::Never), _) => return true,\n \n             // Trivial cases, this should go after `never` check to\n             // avoid infer result type to be never\n             _ => {\n-                if self.unify_inner_trivial(&from_ty, &to_ty) {\n+                if self.table.unify_inner_trivial(&from_ty, &to_ty) {\n                     return true;\n                 }\n             }\n@@ -137,6 +134,10 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 }\n             }\n \n+            (ty_app!(TypeCtor::Closure { .. }, params), ty_app!(TypeCtor::FnPtr { .. })) => {\n+                from_ty = params[0].clone();\n+            }\n+\n             _ => {}\n         }\n \n@@ -333,9 +334,13 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 // Stop when constructor matches.\n                 (ty_app!(from_ctor, st1), ty_app!(to_ctor, st2)) if from_ctor == to_ctor => {\n                     // It will not recurse to `coerce`.\n-                    return self.unify_substs(st1, st2, 0);\n+                    return self.table.unify_substs(st1, st2, 0);\n+                }\n+                _ => {\n+                    if self.table.unify_inner_trivial(&derefed_ty, &to_ty) {\n+                        return true;\n+                    }\n                 }\n-                _ => {}\n             }\n         }\n "}, {"sha": "3af05394c6b86254bf6f2ef7911fafba5884ea43", "filename": "crates/ra_hir_ty/src/infer/expr.rs", "status": "modified", "additions": 133, "deletions": 114, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -6,17 +6,21 @@ use std::sync::Arc;\n use hir_def::{\n     builtin_type::Signedness,\n     expr::{Array, BinaryOp, Expr, ExprId, Literal, Statement, UnaryOp},\n-    generics::GenericParams,\n     path::{GenericArg, GenericArgs},\n     resolver::resolver_for_expr,\n-    AdtId, ContainerId, Lookup, StructFieldId,\n+    AdtId, AssocContainerId, Lookup, StructFieldId,\n };\n-use hir_expand::name::{self, Name};\n+use hir_expand::name::{name, Name};\n+use ra_syntax::ast::RangeOp;\n \n use crate::{\n-    autoderef, db::HirDatabase, method_resolution, op, traits::InEnvironment, utils::variant_data,\n-    CallableDef, InferTy, IntTy, Mutability, Obligation, ProjectionPredicate, ProjectionTy, Substs,\n-    TraitRef, Ty, TypeCtor, TypeWalk, Uncertain,\n+    autoderef,\n+    db::HirDatabase,\n+    method_resolution, op,\n+    traits::InEnvironment,\n+    utils::{generics, variant_data, Generics},\n+    ApplicationTy, CallableDef, InferTy, IntTy, Mutability, Obligation, Substs, TraitRef, Ty,\n+    TypeCtor, TypeWalk, Uncertain,\n };\n \n use super::{BindingMode, Expectation, InferenceContext, InferenceDiagnostic, TypeMismatch};\n@@ -31,13 +35,13 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 TypeMismatch { expected: expected.ty.clone(), actual: ty.clone() },\n             );\n         }\n-        let ty = self.resolve_ty_as_possible(&mut vec![], ty);\n+        let ty = self.resolve_ty_as_possible(ty);\n         ty\n     }\n \n     /// Infer type of expression with possibly implicit coerce to the expected type.\n     /// Return the type after possible coercion.\n-    fn infer_expr_coerce(&mut self, expr: ExprId, expected: &Expectation) -> Ty {\n+    pub(super) fn infer_expr_coerce(&mut self, expr: ExprId, expected: &Expectation) -> Ty {\n         let ty = self.infer_expr_inner(expr, &expected);\n         let ty = if !self.coerce(&ty, &expected.ty) {\n             self.result\n@@ -52,7 +56,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             expected.ty.clone()\n         };\n \n-        self.resolve_ty_as_possible(&mut vec![], ty)\n+        self.resolve_ty_as_possible(ty)\n     }\n \n     fn infer_expr_inner(&mut self, tgt_expr: ExprId, expected: &Expectation) -> Ty {\n@@ -91,27 +95,14 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             Expr::For { iterable, body, pat } => {\n                 let iterable_ty = self.infer_expr(*iterable, &Expectation::none());\n \n-                let pat_ty = match self.resolve_into_iter_item() {\n-                    Some(into_iter_item_alias) => {\n-                        let pat_ty = self.new_type_var();\n-                        let projection = ProjectionPredicate {\n-                            ty: pat_ty.clone(),\n-                            projection_ty: ProjectionTy {\n-                                associated_ty: into_iter_item_alias,\n-                                parameters: Substs::single(iterable_ty),\n-                            },\n-                        };\n-                        self.obligations.push(Obligation::Projection(projection));\n-                        self.resolve_ty_as_possible(&mut vec![], pat_ty)\n-                    }\n-                    None => Ty::Unknown,\n-                };\n+                let pat_ty =\n+                    self.resolve_associated_type(iterable_ty, self.resolve_into_iter_item());\n \n                 self.infer_pat(*pat, &pat_ty, BindingMode::default());\n                 self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n                 Ty::unit()\n             }\n-            Expr::Lambda { body, args, arg_types } => {\n+            Expr::Lambda { body, args, ret_type, arg_types } => {\n                 assert_eq!(args.len(), arg_types.len());\n \n                 let mut sig_tys = Vec::new();\n@@ -127,7 +118,10 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 }\n \n                 // add return type\n-                let ret_ty = self.new_type_var();\n+                let ret_ty = match ret_type {\n+                    Some(type_ref) => self.make_ty(type_ref),\n+                    None => self.table.new_type_var(),\n+                };\n                 sig_tys.push(ret_ty.clone());\n                 let sig_ty = Ty::apply(\n                     TypeCtor::FnPtr { num_args: sig_tys.len() as u16 - 1 },\n@@ -143,7 +137,12 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 // infer the body.\n                 self.coerce(&closure_ty, &expected.ty);\n \n-                self.infer_expr(*body, &Expectation::has_type(ret_ty));\n+                let prev_ret_ty = std::mem::replace(&mut self.return_ty, ret_ty.clone());\n+\n+                self.infer_expr_coerce(*body, &Expectation::has_type(ret_ty));\n+\n+                self.return_ty = prev_ret_ty;\n+\n                 closure_ty\n             }\n             Expr::Call { callee, args } => {\n@@ -166,7 +165,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             Expr::Match { expr, arms } => {\n                 let input_ty = self.infer_expr(*expr, &Expectation::none());\n \n-                let mut result_ty = self.new_maybe_never_type_var();\n+                let mut result_ty = self.table.new_maybe_never_type_var();\n \n                 for arm in arms {\n                     for &pat in &arm.pats {\n@@ -200,7 +199,10 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             }\n             Expr::Return { expr } => {\n                 if let Some(expr) = expr {\n-                    self.infer_expr(*expr, &Expectation::has_type(self.return_ty.clone()));\n+                    self.infer_expr_coerce(*expr, &Expectation::has_type(self.return_ty.clone()));\n+                } else {\n+                    let unit = Ty::unit();\n+                    self.coerce(&unit, &self.return_ty.clone());\n                 }\n                 Ty::simple(TypeCtor::Never)\n             }\n@@ -244,7 +246,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 ty\n             }\n             Expr::Field { expr, name } => {\n-                let receiver_ty = self.infer_expr(*expr, &Expectation::none());\n+                let receiver_ty = self.infer_expr_inner(*expr, &Expectation::none());\n                 let canonicalized = self.canonicalizer().canonicalize_ty(receiver_ty);\n                 let ty = autoderef::autoderef(\n                     self.db,\n@@ -279,45 +281,18 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 self.normalize_associated_types_in(ty)\n             }\n             Expr::Await { expr } => {\n-                let inner_ty = self.infer_expr(*expr, &Expectation::none());\n-                let ty = match self.resolve_future_future_output() {\n-                    Some(future_future_output_alias) => {\n-                        let ty = self.new_type_var();\n-                        let projection = ProjectionPredicate {\n-                            ty: ty.clone(),\n-                            projection_ty: ProjectionTy {\n-                                associated_ty: future_future_output_alias,\n-                                parameters: Substs::single(inner_ty),\n-                            },\n-                        };\n-                        self.obligations.push(Obligation::Projection(projection));\n-                        self.resolve_ty_as_possible(&mut vec![], ty)\n-                    }\n-                    None => Ty::Unknown,\n-                };\n+                let inner_ty = self.infer_expr_inner(*expr, &Expectation::none());\n+                let ty =\n+                    self.resolve_associated_type(inner_ty, self.resolve_future_future_output());\n                 ty\n             }\n             Expr::Try { expr } => {\n-                let inner_ty = self.infer_expr(*expr, &Expectation::none());\n-                let ty = match self.resolve_ops_try_ok() {\n-                    Some(ops_try_ok_alias) => {\n-                        let ty = self.new_type_var();\n-                        let projection = ProjectionPredicate {\n-                            ty: ty.clone(),\n-                            projection_ty: ProjectionTy {\n-                                associated_ty: ops_try_ok_alias,\n-                                parameters: Substs::single(inner_ty),\n-                            },\n-                        };\n-                        self.obligations.push(Obligation::Projection(projection));\n-                        self.resolve_ty_as_possible(&mut vec![], ty)\n-                    }\n-                    None => Ty::Unknown,\n-                };\n+                let inner_ty = self.infer_expr_inner(*expr, &Expectation::none());\n+                let ty = self.resolve_associated_type(inner_ty, self.resolve_ops_try_ok());\n                 ty\n             }\n             Expr::Cast { expr, type_ref } => {\n-                let _inner_ty = self.infer_expr(*expr, &Expectation::none());\n+                let _inner_ty = self.infer_expr_inner(*expr, &Expectation::none());\n                 let cast_ty = self.make_ty(type_ref);\n                 // FIXME check the cast...\n                 cast_ty\n@@ -333,20 +308,19 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     } else {\n                         Expectation::none()\n                     };\n-                // FIXME reference coercions etc.\n-                let inner_ty = self.infer_expr(*expr, &expectation);\n+                let inner_ty = self.infer_expr_inner(*expr, &expectation);\n                 Ty::apply_one(TypeCtor::Ref(*mutability), inner_ty)\n             }\n             Expr::Box { expr } => {\n-                let inner_ty = self.infer_expr(*expr, &Expectation::none());\n+                let inner_ty = self.infer_expr_inner(*expr, &Expectation::none());\n                 if let Some(box_) = self.resolve_boxed_box() {\n                     Ty::apply_one(TypeCtor::Adt(box_), inner_ty)\n                 } else {\n                     Ty::Unknown\n                 }\n             }\n             Expr::UnaryOp { expr, op } => {\n-                let inner_ty = self.infer_expr(*expr, &Expectation::none());\n+                let inner_ty = self.infer_expr_inner(*expr, &Expectation::none());\n                 match op {\n                     UnaryOp::Deref => match self.resolver.krate() {\n                         Some(krate) => {\n@@ -369,31 +343,36 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     },\n                     UnaryOp::Neg => {\n                         match &inner_ty {\n-                            Ty::Apply(a_ty) => match a_ty.ctor {\n-                                TypeCtor::Int(Uncertain::Unknown)\n-                                | TypeCtor::Int(Uncertain::Known(IntTy {\n-                                    signedness: Signedness::Signed,\n-                                    ..\n-                                }))\n-                                | TypeCtor::Float(..) => inner_ty,\n-                                _ => Ty::Unknown,\n-                            },\n-                            Ty::Infer(InferTy::IntVar(..)) | Ty::Infer(InferTy::FloatVar(..)) => {\n-                                inner_ty\n-                            }\n-                            // FIXME: resolve ops::Neg trait\n-                            _ => Ty::Unknown,\n+                            // Fast path for builtins\n+                            Ty::Apply(ApplicationTy {\n+                                ctor:\n+                                    TypeCtor::Int(Uncertain::Known(IntTy {\n+                                        signedness: Signedness::Signed,\n+                                        ..\n+                                    })),\n+                                ..\n+                            })\n+                            | Ty::Apply(ApplicationTy {\n+                                ctor: TypeCtor::Int(Uncertain::Unknown),\n+                                ..\n+                            })\n+                            | Ty::Apply(ApplicationTy { ctor: TypeCtor::Float(_), .. })\n+                            | Ty::Infer(InferTy::IntVar(..))\n+                            | Ty::Infer(InferTy::FloatVar(..)) => inner_ty,\n+                            // Otherwise we resolve via the std::ops::Neg trait\n+                            _ => self\n+                                .resolve_associated_type(inner_ty, self.resolve_ops_neg_output()),\n                         }\n                     }\n                     UnaryOp::Not => {\n                         match &inner_ty {\n-                            Ty::Apply(a_ty) => match a_ty.ctor {\n-                                TypeCtor::Bool | TypeCtor::Int(_) => inner_ty,\n-                                _ => Ty::Unknown,\n-                            },\n-                            Ty::Infer(InferTy::IntVar(..)) => inner_ty,\n-                            // FIXME: resolve ops::Not trait for inner_ty\n-                            _ => Ty::Unknown,\n+                            // Fast path for builtins\n+                            Ty::Apply(ApplicationTy { ctor: TypeCtor::Bool, .. })\n+                            | Ty::Apply(ApplicationTy { ctor: TypeCtor::Int(_), .. })\n+                            | Ty::Infer(InferTy::IntVar(..)) => inner_ty,\n+                            // Otherwise we resolve via the std::ops::Not trait\n+                            _ => self\n+                                .resolve_associated_type(inner_ty, self.resolve_ops_not_output()),\n                         }\n                     }\n                 }\n@@ -415,21 +394,63 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 }\n                 _ => Ty::Unknown,\n             },\n+            Expr::Range { lhs, rhs, range_type } => {\n+                let lhs_ty = lhs.map(|e| self.infer_expr_inner(e, &Expectation::none()));\n+                let rhs_expect = lhs_ty\n+                    .as_ref()\n+                    .map_or_else(Expectation::none, |ty| Expectation::has_type(ty.clone()));\n+                let rhs_ty = rhs.map(|e| self.infer_expr(e, &rhs_expect));\n+                match (range_type, lhs_ty, rhs_ty) {\n+                    (RangeOp::Exclusive, None, None) => match self.resolve_range_full() {\n+                        Some(adt) => Ty::simple(TypeCtor::Adt(adt)),\n+                        None => Ty::Unknown,\n+                    },\n+                    (RangeOp::Exclusive, None, Some(ty)) => match self.resolve_range_to() {\n+                        Some(adt) => Ty::apply_one(TypeCtor::Adt(adt), ty),\n+                        None => Ty::Unknown,\n+                    },\n+                    (RangeOp::Inclusive, None, Some(ty)) => {\n+                        match self.resolve_range_to_inclusive() {\n+                            Some(adt) => Ty::apply_one(TypeCtor::Adt(adt), ty),\n+                            None => Ty::Unknown,\n+                        }\n+                    }\n+                    (RangeOp::Exclusive, Some(_), Some(ty)) => match self.resolve_range() {\n+                        Some(adt) => Ty::apply_one(TypeCtor::Adt(adt), ty),\n+                        None => Ty::Unknown,\n+                    },\n+                    (RangeOp::Inclusive, Some(_), Some(ty)) => {\n+                        match self.resolve_range_inclusive() {\n+                            Some(adt) => Ty::apply_one(TypeCtor::Adt(adt), ty),\n+                            None => Ty::Unknown,\n+                        }\n+                    }\n+                    (RangeOp::Exclusive, Some(ty), None) => match self.resolve_range_from() {\n+                        Some(adt) => Ty::apply_one(TypeCtor::Adt(adt), ty),\n+                        None => Ty::Unknown,\n+                    },\n+                    (RangeOp::Inclusive, _, None) => Ty::Unknown,\n+                }\n+            }\n             Expr::Index { base, index } => {\n-                let _base_ty = self.infer_expr(*base, &Expectation::none());\n-                let _index_ty = self.infer_expr(*index, &Expectation::none());\n-                // FIXME: use `std::ops::Index::Output` to figure out the real return type\n-                Ty::Unknown\n+                let base_ty = self.infer_expr_inner(*base, &Expectation::none());\n+                let index_ty = self.infer_expr(*index, &Expectation::none());\n+\n+                self.resolve_associated_type_with_params(\n+                    base_ty,\n+                    self.resolve_ops_index_output(),\n+                    &[index_ty],\n+                )\n             }\n             Expr::Tuple { exprs } => {\n                 let mut tys = match &expected.ty {\n                     ty_app!(TypeCtor::Tuple { .. }, st) => st\n                         .iter()\n                         .cloned()\n-                        .chain(repeat_with(|| self.new_type_var()))\n+                        .chain(repeat_with(|| self.table.new_type_var()))\n                         .take(exprs.len())\n                         .collect::<Vec<_>>(),\n-                    _ => (0..exprs.len()).map(|_| self.new_type_var()).collect(),\n+                    _ => (0..exprs.len()).map(|_| self.table.new_type_var()).collect(),\n                 };\n \n                 for (expr, ty) in exprs.iter().zip(tys.iter_mut()) {\n@@ -443,7 +464,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     ty_app!(TypeCtor::Array, st) | ty_app!(TypeCtor::Slice, st) => {\n                         st.as_single().clone()\n                     }\n-                    _ => self.new_type_var(),\n+                    _ => self.table.new_type_var(),\n                 };\n \n                 match array {\n@@ -485,7 +506,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         };\n         // use a new type variable if we got Ty::Unknown here\n         let ty = self.insert_type_vars_shallow(ty);\n-        let ty = self.resolve_ty_as_possible(&mut vec![], ty);\n+        let ty = self.resolve_ty_as_possible(ty);\n         self.write_expr_ty(tgt_expr, ty.clone());\n         ty\n     }\n@@ -514,7 +535,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                         }\n                     }\n \n-                    let ty = self.resolve_ty_as_possible(&mut vec![], ty);\n+                    let ty = self.resolve_ty_as_possible(ty);\n                     self.infer_pat(*pat, &ty, BindingMode::default());\n                 }\n                 Statement::Expr(expr) => {\n@@ -558,7 +579,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             Some((ty, func)) => {\n                 let ty = canonicalized_receiver.decanonicalize_ty(ty);\n                 self.write_method_resolution(tgt_expr, func);\n-                (ty, self.db.value_ty(func.into()), Some(self.db.generic_params(func.into())))\n+                (ty, self.db.value_ty(func.into()), Some(generics(self.db, func.into())))\n             }\n             None => (receiver_ty, Ty::Unknown, None),\n         };\n@@ -607,6 +628,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     continue;\n                 }\n \n+                let param_ty = self.insert_vars_for_impl_trait(param_ty);\n                 let param_ty = self.normalize_associated_types_in(param_ty);\n                 self.infer_expr_coerce(arg, &Expectation::has_type(param_ty.clone()));\n             }\n@@ -615,17 +637,17 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n     fn substs_for_method_call(\n         &mut self,\n-        def_generics: Option<Arc<GenericParams>>,\n+        def_generics: Option<Generics>,\n         generic_args: Option<&GenericArgs>,\n         receiver_ty: &Ty,\n     ) -> Substs {\n-        let (parent_param_count, param_count) =\n-            def_generics.as_ref().map_or((0, 0), |g| (g.count_parent_params(), g.params.len()));\n-        let mut substs = Vec::with_capacity(parent_param_count + param_count);\n+        let (total_len, _parent_len, child_len) =\n+            def_generics.as_ref().map_or((0, 0, 0), |g| g.len_split());\n+        let mut substs = Vec::with_capacity(total_len);\n         // Parent arguments are unknown, except for the receiver type\n-        if let Some(parent_generics) = def_generics.and_then(|p| p.parent_params.clone()) {\n-            for param in &parent_generics.params {\n-                if param.name == name::SELF_TYPE {\n+        if let Some(parent_generics) = def_generics.as_ref().map(|p| p.iter_parent()) {\n+            for (_id, param) in parent_generics {\n+                if param.name == name![Self] {\n                     substs.push(receiver_ty.clone());\n                 } else {\n                     substs.push(Ty::Unknown);\n@@ -635,7 +657,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         // handle provided type arguments\n         if let Some(generic_args) = generic_args {\n             // if args are provided, it should be all of them, but we can't rely on that\n-            for arg in generic_args.args.iter().take(param_count) {\n+            for arg in generic_args.args.iter().take(child_len) {\n                 match arg {\n                     GenericArg::Type(type_ref) => {\n                         let ty = self.make_ty(type_ref);\n@@ -645,10 +667,10 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             }\n         };\n         let supplied_params = substs.len();\n-        for _ in supplied_params..parent_param_count + param_count {\n+        for _ in supplied_params..total_len {\n             substs.push(Ty::Unknown);\n         }\n-        assert_eq!(substs.len(), parent_param_count + param_count);\n+        assert_eq!(substs.len(), total_len);\n         Substs(substs.into())\n     }\n \n@@ -665,13 +687,10 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 // add obligation for trait implementation, if this is a trait method\n                 match def {\n                     CallableDef::FunctionId(f) => {\n-                        if let ContainerId::TraitId(trait_) = f.lookup(self.db).container {\n+                        if let AssocContainerId::TraitId(trait_) = f.lookup(self.db).container {\n                             // construct a TraitDef\n-                            let substs = a_ty.parameters.prefix(\n-                                self.db\n-                                    .generic_params(trait_.into())\n-                                    .count_params_including_parent(),\n-                            );\n+                            let substs =\n+                                a_ty.parameters.prefix(generics(self.db, trait_.into()).len());\n                             self.obligations.push(Obligation::Trait(TraitRef {\n                                 trait_: trait_.into(),\n                                 substs,"}, {"sha": "a14662884458c9fe05307b582f2200c06d863b0c", "filename": "crates/ra_hir_ty/src/infer/pat.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpat.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -170,7 +170,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     }\n                     BindingMode::Move => inner_ty.clone(),\n                 };\n-                let bound_ty = self.resolve_ty_as_possible(&mut vec![], bound_ty);\n+                let bound_ty = self.resolve_ty_as_possible(bound_ty);\n                 self.write_pat_ty(pat, bound_ty);\n                 return inner_ty;\n             }\n@@ -179,7 +179,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         // use a new type variable if we got Ty::Unknown here\n         let ty = self.insert_type_vars_shallow(ty);\n         self.unify(&ty, expected);\n-        let ty = self.resolve_ty_as_possible(&mut vec![], ty);\n+        let ty = self.resolve_ty_as_possible(ty);\n         self.write_pat_ty(pat, ty.clone());\n         ty\n     }"}, {"sha": "ffd3583675f842f2f59241d1a00cc36a2f57e784", "filename": "crates/ra_hir_ty/src/infer/path.rs", "status": "modified", "additions": 33, "deletions": 53, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpath.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -1,9 +1,11 @@\n //! Path expression resolution.\n \n+use std::iter;\n+\n use hir_def::{\n-    path::{Path, PathKind, PathSegment},\n+    path::{Path, PathSegment},\n     resolver::{ResolveValueResult, Resolver, TypeNs, ValueNs},\n-    AssocItemId, ContainerId, Lookup,\n+    AssocContainerId, AssocItemId, Lookup,\n };\n use hir_expand::name::Name;\n \n@@ -30,21 +32,21 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         path: &Path,\n         id: ExprOrPatId,\n     ) -> Option<Ty> {\n-        let (value, self_subst) = if let PathKind::Type(type_ref) = &path.kind {\n-            if path.segments.is_empty() {\n+        let (value, self_subst) = if let Some(type_ref) = path.type_anchor() {\n+            if path.segments().is_empty() {\n                 // This can't actually happen syntax-wise\n                 return None;\n             }\n             let ty = self.make_ty(type_ref);\n-            let remaining_segments_for_ty = &path.segments[..path.segments.len() - 1];\n+            let remaining_segments_for_ty = path.segments().take(path.segments().len() - 1);\n             let ty = Ty::from_type_relative_path(self.db, resolver, ty, remaining_segments_for_ty);\n             self.resolve_ty_assoc_item(\n                 ty,\n-                &path.segments.last().expect(\"path had at least one segment\").name,\n+                &path.segments().last().expect(\"path had at least one segment\").name,\n                 id,\n             )?\n         } else {\n-            let value_or_partial = resolver.resolve_path_in_value_ns(self.db, &path)?;\n+            let value_or_partial = resolver.resolve_path_in_value_ns(self.db, path.mod_path())?;\n \n             match value_or_partial {\n                 ResolveValueResult::ValueNs(it) => (it, None),\n@@ -57,7 +59,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         let typable: ValueTyDefId = match value {\n             ValueNs::LocalBinding(pat) => {\n                 let ty = self.result.type_of_pat.get(pat)?.clone();\n-                let ty = self.resolve_ty_as_possible(&mut vec![], ty);\n+                let ty = self.resolve_ty_as_possible(ty);\n                 return Some(ty);\n             }\n             ValueNs::FunctionId(it) => it.into(),\n@@ -83,13 +85,13 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         remaining_index: usize,\n         id: ExprOrPatId,\n     ) -> Option<(ValueNs, Option<Substs>)> {\n-        assert!(remaining_index < path.segments.len());\n+        assert!(remaining_index < path.segments().len());\n         // there may be more intermediate segments between the resolved one and\n         // the end. Only the last segment needs to be resolved to a value; from\n         // the segments before that, we need to get either a type or a trait ref.\n \n-        let resolved_segment = &path.segments[remaining_index - 1];\n-        let remaining_segments = &path.segments[remaining_index..];\n+        let resolved_segment = path.segments().get(remaining_index - 1).unwrap();\n+        let remaining_segments = path.segments().skip(remaining_index);\n         let is_before_last = remaining_segments.len() == 1;\n \n         match (def, is_before_last) {\n@@ -110,7 +112,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 // trait but it's not the last segment, so the next segment\n                 // should resolve to an associated type of that trait (e.g. `<T\n                 // as Iterator>::Item::default`)\n-                let remaining_segments_for_ty = &remaining_segments[..remaining_segments.len() - 1];\n+                let remaining_segments_for_ty =\n+                    remaining_segments.take(remaining_segments.len() - 1);\n                 let ty = Ty::from_partly_resolved_hir_path(\n                     self.db,\n                     &self.resolver,\n@@ -136,7 +139,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     fn resolve_trait_assoc_item(\n         &mut self,\n         trait_ref: TraitRef,\n-        segment: &PathSegment,\n+        segment: PathSegment<'_>,\n         id: ExprOrPatId,\n     ) -> Option<(ValueNs, Option<Substs>)> {\n         let trait_ = trait_ref.trait_;\n@@ -148,15 +151,15 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             .map(|(_name, id)| (*id).into())\n             .find_map(|item| match item {\n                 AssocItemId::FunctionId(func) => {\n-                    if segment.name == self.db.function_data(func).name {\n+                    if segment.name == &self.db.function_data(func).name {\n                         Some(AssocItemId::FunctionId(func))\n                     } else {\n                         None\n                     }\n                 }\n \n                 AssocItemId::ConstId(konst) => {\n-                    if self.db.const_data(konst).name.as_ref().map_or(false, |n| n == &segment.name)\n+                    if self.db.const_data(konst).name.as_ref().map_or(false, |n| n == segment.name)\n                     {\n                         Some(AssocItemId::ConstId(konst))\n                     } else {\n@@ -206,12 +209,23 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     AssocItemId::TypeAliasId(_) => unreachable!(),\n                 };\n                 let substs = match container {\n-                    ContainerId::ImplId(_) => self.find_self_types(&def, ty.clone()),\n-                    ContainerId::TraitId(trait_) => {\n+                    AssocContainerId::ImplId(impl_id) => {\n+                        let impl_substs = Substs::build_for_def(self.db, impl_id)\n+                            .fill(iter::repeat_with(|| self.table.new_type_var()))\n+                            .build();\n+                        let impl_self_ty = self.db.impl_self_ty(impl_id).subst(&impl_substs);\n+                        let substs = Substs::build_for_def(self.db, item)\n+                            .use_parent_substs(&impl_substs)\n+                            .fill_with_params()\n+                            .build();\n+                        self.unify(&impl_self_ty, &ty);\n+                        Some(substs)\n+                    }\n+                    AssocContainerId::TraitId(trait_) => {\n                         // we're picking this method\n                         let trait_substs = Substs::build_for_def(self.db, trait_)\n                             .push(ty.clone())\n-                            .fill(std::iter::repeat_with(|| self.new_type_var()))\n+                            .fill(std::iter::repeat_with(|| self.table.new_type_var()))\n                             .build();\n                         let substs = Substs::build_for_def(self.db, item)\n                             .use_parent_substs(&trait_substs)\n@@ -223,46 +237,12 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                         }));\n                         Some(substs)\n                     }\n-                    ContainerId::ModuleId(_) => None,\n+                    AssocContainerId::ContainerId(_) => None,\n                 };\n \n                 self.write_assoc_resolution(id, item.into());\n                 Some((def, substs))\n             },\n         )\n     }\n-\n-    fn find_self_types(&self, def: &ValueNs, actual_def_ty: Ty) -> Option<Substs> {\n-        if let ValueNs::FunctionId(func) = *def {\n-            // We only do the infer if parent has generic params\n-            let gen = self.db.generic_params(func.into());\n-            if gen.count_parent_params() == 0 {\n-                return None;\n-            }\n-\n-            let impl_id = match func.lookup(self.db).container {\n-                ContainerId::ImplId(it) => it,\n-                _ => return None,\n-            };\n-            let self_ty = self.db.impl_ty(impl_id).self_type().clone();\n-            let self_ty_substs = self_ty.substs()?;\n-            let actual_substs = actual_def_ty.substs()?;\n-\n-            let mut new_substs = vec![Ty::Unknown; gen.count_parent_params()];\n-\n-            // The following code *link up* the function actual parma type\n-            // and impl_block type param index\n-            self_ty_substs.iter().zip(actual_substs.iter()).for_each(|(param, pty)| {\n-                if let Ty::Param { idx, .. } = param {\n-                    if let Some(s) = new_substs.get_mut(*idx as usize) {\n-                        *s = pty.clone();\n-                    }\n-                }\n-            });\n-\n-            Some(Substs(new_substs.into()))\n-        } else {\n-            None\n-        }\n-    }\n }"}, {"sha": "fe05642ae3d8e4c6f11a427e0e5a58f2bf25f9e9", "filename": "crates/ra_hir_ty/src/infer/unify.rs", "status": "modified", "additions": 270, "deletions": 6, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Funify.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -1,9 +1,15 @@\n //! Unification and canonicalization logic.\n \n+use std::borrow::Cow;\n+\n+use ena::unify::{InPlaceUnificationTable, NoError, UnifyKey, UnifyValue};\n+\n+use test_utils::tested_by;\n+\n use super::{InferenceContext, Obligation};\n use crate::{\n     db::HirDatabase, utils::make_mut_slice, Canonical, InEnvironment, InferTy, ProjectionPredicate,\n-    ProjectionTy, Substs, TraitRef, Ty, TypeWalk,\n+    ProjectionTy, Substs, TraitRef, Ty, TypeCtor, TypeWalk,\n };\n \n impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n@@ -24,7 +30,7 @@ where\n     /// A stack of type variables that is used to detect recursive types (which\n     /// are an error, but we need to protect against them to avoid stack\n     /// overflows).\n-    var_stack: Vec<super::TypeVarId>,\n+    var_stack: Vec<TypeVarId>,\n }\n \n pub(super) struct Canonicalized<T> {\n@@ -53,14 +59,14 @@ where\n                     return tv.fallback_value();\n                 }\n                 if let Some(known_ty) =\n-                    self.ctx.var_unification_table.inlined_probe_value(inner).known()\n+                    self.ctx.table.var_unification_table.inlined_probe_value(inner).known()\n                 {\n                     self.var_stack.push(inner);\n                     let result = self.do_canonicalize_ty(known_ty.clone());\n                     self.var_stack.pop();\n                     result\n                 } else {\n-                    let root = self.ctx.var_unification_table.find(inner);\n+                    let root = self.ctx.table.var_unification_table.find(inner);\n                     let free_var = match tv {\n                         InferTy::TypeVar(_) => InferTy::TypeVar(root),\n                         InferTy::IntVar(_) => InferTy::IntVar(root),\n@@ -153,10 +159,268 @@ impl<T> Canonicalized<T> {\n         solution: Canonical<Vec<Ty>>,\n     ) {\n         // the solution may contain new variables, which we need to convert to new inference vars\n-        let new_vars = Substs((0..solution.num_vars).map(|_| ctx.new_type_var()).collect());\n+        let new_vars = Substs((0..solution.num_vars).map(|_| ctx.table.new_type_var()).collect());\n         for (i, ty) in solution.value.into_iter().enumerate() {\n             let var = self.free_vars[i];\n-            ctx.unify(&Ty::Infer(var), &ty.subst_bound_vars(&new_vars));\n+            ctx.table.unify(&Ty::Infer(var), &ty.subst_bound_vars(&new_vars));\n+        }\n+    }\n+}\n+\n+pub fn unify(ty1: &Canonical<Ty>, ty2: &Canonical<Ty>) -> Option<Substs> {\n+    let mut table = InferenceTable::new();\n+    let vars =\n+        Substs::builder(ty1.num_vars).fill(std::iter::repeat_with(|| table.new_type_var())).build();\n+    let ty_with_vars = ty1.value.clone().subst_bound_vars(&vars);\n+    if !table.unify(&ty_with_vars, &ty2.value) {\n+        return None;\n+    }\n+    Some(\n+        Substs::builder(ty1.num_vars)\n+            .fill(vars.iter().map(|v| table.resolve_ty_completely(v.clone())))\n+            .build(),\n+    )\n+}\n+\n+#[derive(Clone, Debug)]\n+pub(crate) struct InferenceTable {\n+    pub(super) var_unification_table: InPlaceUnificationTable<TypeVarId>,\n+}\n+\n+impl InferenceTable {\n+    pub fn new() -> Self {\n+        InferenceTable { var_unification_table: InPlaceUnificationTable::new() }\n+    }\n+\n+    pub fn new_type_var(&mut self) -> Ty {\n+        Ty::Infer(InferTy::TypeVar(self.var_unification_table.new_key(TypeVarValue::Unknown)))\n+    }\n+\n+    pub fn new_integer_var(&mut self) -> Ty {\n+        Ty::Infer(InferTy::IntVar(self.var_unification_table.new_key(TypeVarValue::Unknown)))\n+    }\n+\n+    pub fn new_float_var(&mut self) -> Ty {\n+        Ty::Infer(InferTy::FloatVar(self.var_unification_table.new_key(TypeVarValue::Unknown)))\n+    }\n+\n+    pub fn new_maybe_never_type_var(&mut self) -> Ty {\n+        Ty::Infer(InferTy::MaybeNeverTypeVar(\n+            self.var_unification_table.new_key(TypeVarValue::Unknown),\n+        ))\n+    }\n+\n+    pub fn resolve_ty_completely(&mut self, ty: Ty) -> Ty {\n+        self.resolve_ty_completely_inner(&mut Vec::new(), ty)\n+    }\n+\n+    pub fn resolve_ty_as_possible(&mut self, ty: Ty) -> Ty {\n+        self.resolve_ty_as_possible_inner(&mut Vec::new(), ty)\n+    }\n+\n+    pub fn unify(&mut self, ty1: &Ty, ty2: &Ty) -> bool {\n+        self.unify_inner(ty1, ty2, 0)\n+    }\n+\n+    pub fn unify_substs(&mut self, substs1: &Substs, substs2: &Substs, depth: usize) -> bool {\n+        substs1.0.iter().zip(substs2.0.iter()).all(|(t1, t2)| self.unify_inner(t1, t2, depth))\n+    }\n+\n+    fn unify_inner(&mut self, ty1: &Ty, ty2: &Ty, depth: usize) -> bool {\n+        if depth > 1000 {\n+            // prevent stackoverflows\n+            panic!(\"infinite recursion in unification\");\n+        }\n+        if ty1 == ty2 {\n+            return true;\n+        }\n+        // try to resolve type vars first\n+        let ty1 = self.resolve_ty_shallow(ty1);\n+        let ty2 = self.resolve_ty_shallow(ty2);\n+        match (&*ty1, &*ty2) {\n+            (Ty::Apply(a_ty1), Ty::Apply(a_ty2)) if a_ty1.ctor == a_ty2.ctor => {\n+                self.unify_substs(&a_ty1.parameters, &a_ty2.parameters, depth + 1)\n+            }\n+            _ => self.unify_inner_trivial(&ty1, &ty2),\n+        }\n+    }\n+\n+    pub(super) fn unify_inner_trivial(&mut self, ty1: &Ty, ty2: &Ty) -> bool {\n+        match (ty1, ty2) {\n+            (Ty::Unknown, _) | (_, Ty::Unknown) => true,\n+\n+            (Ty::Infer(InferTy::TypeVar(tv1)), Ty::Infer(InferTy::TypeVar(tv2)))\n+            | (Ty::Infer(InferTy::IntVar(tv1)), Ty::Infer(InferTy::IntVar(tv2)))\n+            | (Ty::Infer(InferTy::FloatVar(tv1)), Ty::Infer(InferTy::FloatVar(tv2)))\n+            | (\n+                Ty::Infer(InferTy::MaybeNeverTypeVar(tv1)),\n+                Ty::Infer(InferTy::MaybeNeverTypeVar(tv2)),\n+            ) => {\n+                // both type vars are unknown since we tried to resolve them\n+                self.var_unification_table.union(*tv1, *tv2);\n+                true\n+            }\n+\n+            // The order of MaybeNeverTypeVar matters here.\n+            // Unifying MaybeNeverTypeVar and TypeVar will let the latter become MaybeNeverTypeVar.\n+            // Unifying MaybeNeverTypeVar and other concrete type will let the former become it.\n+            (Ty::Infer(InferTy::TypeVar(tv)), other)\n+            | (other, Ty::Infer(InferTy::TypeVar(tv)))\n+            | (Ty::Infer(InferTy::MaybeNeverTypeVar(tv)), other)\n+            | (other, Ty::Infer(InferTy::MaybeNeverTypeVar(tv)))\n+            | (Ty::Infer(InferTy::IntVar(tv)), other @ ty_app!(TypeCtor::Int(_)))\n+            | (other @ ty_app!(TypeCtor::Int(_)), Ty::Infer(InferTy::IntVar(tv)))\n+            | (Ty::Infer(InferTy::FloatVar(tv)), other @ ty_app!(TypeCtor::Float(_)))\n+            | (other @ ty_app!(TypeCtor::Float(_)), Ty::Infer(InferTy::FloatVar(tv))) => {\n+                // the type var is unknown since we tried to resolve it\n+                self.var_unification_table.union_value(*tv, TypeVarValue::Known(other.clone()));\n+                true\n+            }\n+\n+            _ => false,\n+        }\n+    }\n+\n+    /// If `ty` is a type variable with known type, returns that type;\n+    /// otherwise, return ty.\n+    pub fn resolve_ty_shallow<'b>(&mut self, ty: &'b Ty) -> Cow<'b, Ty> {\n+        let mut ty = Cow::Borrowed(ty);\n+        // The type variable could resolve to a int/float variable. Hence try\n+        // resolving up to three times; each type of variable shouldn't occur\n+        // more than once\n+        for i in 0..3 {\n+            if i > 0 {\n+                tested_by!(type_var_resolves_to_int_var);\n+            }\n+            match &*ty {\n+                Ty::Infer(tv) => {\n+                    let inner = tv.to_inner();\n+                    match self.var_unification_table.inlined_probe_value(inner).known() {\n+                        Some(known_ty) => {\n+                            // The known_ty can't be a type var itself\n+                            ty = Cow::Owned(known_ty.clone());\n+                        }\n+                        _ => return ty,\n+                    }\n+                }\n+                _ => return ty,\n+            }\n+        }\n+        log::error!(\"Inference variable still not resolved: {:?}\", ty);\n+        ty\n+    }\n+\n+    /// Resolves the type as far as currently possible, replacing type variables\n+    /// by their known types. All types returned by the infer_* functions should\n+    /// be resolved as far as possible, i.e. contain no type variables with\n+    /// known type.\n+    fn resolve_ty_as_possible_inner(&mut self, tv_stack: &mut Vec<TypeVarId>, ty: Ty) -> Ty {\n+        ty.fold(&mut |ty| match ty {\n+            Ty::Infer(tv) => {\n+                let inner = tv.to_inner();\n+                if tv_stack.contains(&inner) {\n+                    tested_by!(type_var_cycles_resolve_as_possible);\n+                    // recursive type\n+                    return tv.fallback_value();\n+                }\n+                if let Some(known_ty) =\n+                    self.var_unification_table.inlined_probe_value(inner).known()\n+                {\n+                    // known_ty may contain other variables that are known by now\n+                    tv_stack.push(inner);\n+                    let result = self.resolve_ty_as_possible_inner(tv_stack, known_ty.clone());\n+                    tv_stack.pop();\n+                    result\n+                } else {\n+                    ty\n+                }\n+            }\n+            _ => ty,\n+        })\n+    }\n+\n+    /// Resolves the type completely; type variables without known type are\n+    /// replaced by Ty::Unknown.\n+    fn resolve_ty_completely_inner(&mut self, tv_stack: &mut Vec<TypeVarId>, ty: Ty) -> Ty {\n+        ty.fold(&mut |ty| match ty {\n+            Ty::Infer(tv) => {\n+                let inner = tv.to_inner();\n+                if tv_stack.contains(&inner) {\n+                    tested_by!(type_var_cycles_resolve_completely);\n+                    // recursive type\n+                    return tv.fallback_value();\n+                }\n+                if let Some(known_ty) =\n+                    self.var_unification_table.inlined_probe_value(inner).known()\n+                {\n+                    // known_ty may contain other variables that are known by now\n+                    tv_stack.push(inner);\n+                    let result = self.resolve_ty_completely_inner(tv_stack, known_ty.clone());\n+                    tv_stack.pop();\n+                    result\n+                } else {\n+                    tv.fallback_value()\n+                }\n+            }\n+            _ => ty,\n+        })\n+    }\n+}\n+\n+/// The ID of a type variable.\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+pub struct TypeVarId(pub(super) u32);\n+\n+impl UnifyKey for TypeVarId {\n+    type Value = TypeVarValue;\n+\n+    fn index(&self) -> u32 {\n+        self.0\n+    }\n+\n+    fn from_index(i: u32) -> Self {\n+        TypeVarId(i)\n+    }\n+\n+    fn tag() -> &'static str {\n+        \"TypeVarId\"\n+    }\n+}\n+\n+/// The value of a type variable: either we already know the type, or we don't\n+/// know it yet.\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub enum TypeVarValue {\n+    Known(Ty),\n+    Unknown,\n+}\n+\n+impl TypeVarValue {\n+    fn known(&self) -> Option<&Ty> {\n+        match self {\n+            TypeVarValue::Known(ty) => Some(ty),\n+            TypeVarValue::Unknown => None,\n+        }\n+    }\n+}\n+\n+impl UnifyValue for TypeVarValue {\n+    type Error = NoError;\n+\n+    fn unify_values(value1: &Self, value2: &Self) -> Result<Self, NoError> {\n+        match (value1, value2) {\n+            // We should never equate two type variables, both of which have\n+            // known types. Instead, we recursively equate those types.\n+            (TypeVarValue::Known(t1), TypeVarValue::Known(t2)) => panic!(\n+                \"equating two type variables, both of which have known types: {:?} and {:?}\",\n+                t1, t2\n+            ),\n+\n+            // If one side is known, prefer that one.\n+            (TypeVarValue::Known(..), TypeVarValue::Unknown) => Ok(value1.clone()),\n+            (TypeVarValue::Unknown, TypeVarValue::Known(..)) => Ok(value2.clone()),\n+\n+            (TypeVarValue::Unknown, TypeVarValue::Unknown) => Ok(TypeVarValue::Unknown),\n         }\n     }\n }"}, {"sha": "48abf97c92f205a215eae5a459851e0eb681250e", "filename": "crates/ra_hir_ty/src/lib.rs", "status": "modified", "additions": 51, "deletions": 45, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flib.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -44,16 +44,16 @@ use std::sync::Arc;\n use std::{fmt, iter, mem};\n \n use hir_def::{\n-    expr::ExprId, generics::GenericParams, type_ref::Mutability, AdtId, ContainerId, DefWithBodyId,\n-    GenericDefId, HasModule, Lookup, TraitId, TypeAliasId,\n+    expr::ExprId, type_ref::Mutability, AdtId, AssocContainerId, DefWithBodyId, GenericDefId,\n+    HasModule, Lookup, TraitId, TypeAliasId,\n };\n use hir_expand::name::Name;\n use ra_db::{impl_intern_key, salsa, CrateId};\n \n use crate::{\n     db::HirDatabase,\n     primitive::{FloatTy, IntTy, Uncertain},\n-    utils::make_mut_slice,\n+    utils::{generics, make_mut_slice, Generics},\n };\n use display::{HirDisplay, HirFormatter};\n \n@@ -166,16 +166,16 @@ impl TypeCtor {\n             | TypeCtor::Closure { .. } // 1 param representing the signature of the closure\n             => 1,\n             TypeCtor::Adt(adt) => {\n-                let generic_params = db.generic_params(AdtId::from(adt).into());\n-                generic_params.count_params_including_parent()\n+                let generic_params = generics(db, AdtId::from(adt).into());\n+                generic_params.len()\n             }\n             TypeCtor::FnDef(callable) => {\n-                let generic_params = db.generic_params(callable.into());\n-                generic_params.count_params_including_parent()\n+                let generic_params = generics(db, callable.into());\n+                generic_params.len()\n             }\n             TypeCtor::AssociatedType(type_alias) => {\n-                let generic_params = db.generic_params(type_alias.into());\n-                generic_params.count_params_including_parent()\n+                let generic_params = generics(db, type_alias.into());\n+                generic_params.len()\n             }\n             TypeCtor::FnPtr { num_args } => num_args as usize + 1,\n             TypeCtor::Tuple { cardinality } => cardinality as usize,\n@@ -251,7 +251,7 @@ impl ProjectionTy {\n \n     fn trait_(&self, db: &impl HirDatabase) -> TraitId {\n         match self.associated_ty.lookup(db).container {\n-            ContainerId::TraitId(it) => it,\n+            AssocContainerId::TraitId(it) => it,\n             _ => panic!(\"projection ty without parent trait\"),\n         }\n     }\n@@ -364,36 +364,26 @@ impl Substs {\n     }\n \n     /// Return Substs that replace each parameter by itself (i.e. `Ty::Param`).\n-    pub fn identity(generic_params: &GenericParams) -> Substs {\n+    pub(crate) fn identity(generic_params: &Generics) -> Substs {\n         Substs(\n-            generic_params\n-                .params_including_parent()\n-                .into_iter()\n-                .map(|p| Ty::Param { idx: p.idx, name: p.name.clone() })\n-                .collect(),\n+            generic_params.iter().map(|(idx, p)| Ty::Param { idx, name: p.name.clone() }).collect(),\n         )\n     }\n \n     /// Return Substs that replace each parameter by a bound variable.\n-    pub fn bound_vars(generic_params: &GenericParams) -> Substs {\n-        Substs(\n-            generic_params\n-                .params_including_parent()\n-                .into_iter()\n-                .map(|p| Ty::Bound(p.idx))\n-                .collect(),\n-        )\n+    pub(crate) fn bound_vars(generic_params: &Generics) -> Substs {\n+        Substs(generic_params.iter().map(|(idx, _p)| Ty::Bound(idx)).collect())\n     }\n \n     pub fn build_for_def(db: &impl HirDatabase, def: impl Into<GenericDefId>) -> SubstsBuilder {\n         let def = def.into();\n-        let params = db.generic_params(def);\n-        let param_count = params.count_params_including_parent();\n+        let params = generics(db, def);\n+        let param_count = params.len();\n         Substs::builder(param_count)\n     }\n \n-    pub fn build_for_generics(generic_params: &GenericParams) -> SubstsBuilder {\n-        Substs::builder(generic_params.count_params_including_parent())\n+    pub(crate) fn build_for_generics(generic_params: &Generics) -> SubstsBuilder {\n+        Substs::builder(generic_params.len())\n     }\n \n     pub fn build_for_type_ctor(db: &impl HirDatabase, type_ctor: TypeCtor) -> SubstsBuilder {\n@@ -486,21 +476,6 @@ impl TypeWalk for TraitRef {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, Debug)]\n-pub enum ImplTy {\n-    Inherent(Ty),\n-    TraitRef(TraitRef),\n-}\n-\n-impl ImplTy {\n-    pub(crate) fn self_type(&self) -> &Ty {\n-        match self {\n-            ImplTy::Inherent(it) => it,\n-            ImplTy::TraitRef(tr) => &tr.substs[0],\n-        }\n-    }\n-}\n-\n /// Like `generics::WherePredicate`, but with resolved types: A condition on the\n /// parameters of a generic item.\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -931,13 +906,44 @@ impl HirDisplay for ApplicationTy {\n                 write!(f, \"{}\", name)?;\n                 if self.parameters.len() > 0 {\n                     write!(f, \"<\")?;\n-                    f.write_joined(&*self.parameters.0, \", \")?;\n+\n+                    let mut non_default_parameters = Vec::with_capacity(self.parameters.len());\n+                    let parameters_to_write = if f.should_display_default_types() {\n+                        self.parameters.0.as_ref()\n+                    } else {\n+                        match self\n+                            .ctor\n+                            .as_generic_def()\n+                            .map(|generic_def_id| f.db.generic_defaults(generic_def_id))\n+                            .filter(|defaults| !defaults.is_empty())\n+                        {\n+                            Option::None => self.parameters.0.as_ref(),\n+                            Option::Some(default_parameters) => {\n+                                for (i, parameter) in self.parameters.iter().enumerate() {\n+                                    match (parameter, default_parameters.get(i)) {\n+                                        (&Ty::Unknown, _) | (_, None) => {\n+                                            non_default_parameters.push(parameter.clone())\n+                                        }\n+                                        (_, Some(default_parameter))\n+                                            if parameter != default_parameter =>\n+                                        {\n+                                            non_default_parameters.push(parameter.clone())\n+                                        }\n+                                        _ => (),\n+                                    }\n+                                }\n+                                &non_default_parameters\n+                            }\n+                        }\n+                    };\n+\n+                    f.write_joined(parameters_to_write, \", \")?;\n                     write!(f, \">\")?;\n                 }\n             }\n             TypeCtor::AssociatedType(type_alias) => {\n                 let trait_ = match type_alias.lookup(f.db).container {\n-                    ContainerId::TraitId(it) => it,\n+                    AssocContainerId::TraitId(it) => it,\n                     _ => panic!(\"not an associated type\"),\n                 };\n                 let trait_name = f.db.trait_data(trait_).name.clone();"}, {"sha": "af3db2e1d7c4f7b21fa08c6716f2b8bf3f26231f", "filename": "crates/ra_hir_ty/src/lower.rs", "status": "modified", "additions": 98, "deletions": 76, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flower.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -11,10 +11,10 @@ use std::sync::Arc;\n use hir_def::{\n     builtin_type::BuiltinType,\n     generics::WherePredicate,\n-    path::{GenericArg, Path, PathKind, PathSegment},\n+    path::{GenericArg, Path, PathSegment, PathSegments},\n     resolver::{HasResolver, Resolver, TypeNs},\n     type_ref::{TypeBound, TypeRef},\n-    AdtId, AstItemDef, ConstId, EnumId, EnumVariantId, FunctionId, GenericDefId, HasModule, ImplId,\n+    AdtId, ConstId, EnumId, EnumVariantId, FunctionId, GenericDefId, HasModule, ImplId,\n     LocalStructFieldId, Lookup, StaticId, StructId, TraitId, TypeAliasId, UnionId, VariantId,\n };\n use ra_arena::map::ArenaMap;\n@@ -24,11 +24,11 @@ use crate::{\n     db::HirDatabase,\n     primitive::{FloatTy, IntTy},\n     utils::{\n-        all_super_traits, associated_type_by_name_including_super_traits, make_mut_slice,\n+        all_super_traits, associated_type_by_name_including_super_traits, generics, make_mut_slice,\n         variant_data,\n     },\n-    FnSig, GenericPredicate, ImplTy, ProjectionPredicate, ProjectionTy, Substs, TraitEnvironment,\n-    TraitRef, Ty, TypeCtor, TypeWalk,\n+    FnSig, GenericPredicate, ProjectionPredicate, ProjectionTy, Substs, TraitEnvironment, TraitRef,\n+    Ty, TypeCtor, TypeWalk,\n };\n \n impl Ty {\n@@ -101,17 +101,19 @@ impl Ty {\n             TypeRef::Path(path) => path,\n             _ => return None,\n         };\n-        if let PathKind::Type(_) = &path.kind {\n+        if path.type_anchor().is_some() {\n             return None;\n         }\n-        if path.segments.len() > 1 {\n+        if path.segments().len() > 1 {\n             return None;\n         }\n-        let resolution = match resolver.resolve_path_in_type_ns(db, path) {\n+        let resolution = match resolver.resolve_path_in_type_ns(db, path.mod_path()) {\n             Some((it, None)) => it,\n             _ => return None,\n         };\n-        if let TypeNs::GenericParam(idx) = resolution {\n+        if let TypeNs::GenericParam(param_id) = resolution {\n+            let generics = generics(db, resolver.generic_def().expect(\"generics in scope\"));\n+            let idx = generics.param_idx(param_id);\n             Some(idx)\n         } else {\n             None\n@@ -122,11 +124,11 @@ impl Ty {\n         db: &impl HirDatabase,\n         resolver: &Resolver,\n         ty: Ty,\n-        remaining_segments: &[PathSegment],\n+        remaining_segments: PathSegments<'_>,\n     ) -> Ty {\n         if remaining_segments.len() == 1 {\n             // resolve unselected assoc types\n-            let segment = &remaining_segments[0];\n+            let segment = remaining_segments.first().unwrap();\n             Ty::select_associated_type(db, resolver, ty, segment)\n         } else if remaining_segments.len() > 1 {\n             // FIXME report error (ambiguous associated type)\n@@ -140,15 +142,15 @@ impl Ty {\n         db: &impl HirDatabase,\n         resolver: &Resolver,\n         resolution: TypeNs,\n-        resolved_segment: &PathSegment,\n-        remaining_segments: &[PathSegment],\n+        resolved_segment: PathSegment<'_>,\n+        remaining_segments: PathSegments<'_>,\n     ) -> Ty {\n         let ty = match resolution {\n             TypeNs::TraitId(trait_) => {\n                 let trait_ref =\n                     TraitRef::from_resolved_path(db, resolver, trait_, resolved_segment, None);\n                 return if remaining_segments.len() == 1 {\n-                    let segment = &remaining_segments[0];\n+                    let segment = remaining_segments.first().unwrap();\n                     let associated_ty = associated_type_by_name_including_super_traits(\n                         db,\n                         trait_ref.trait_,\n@@ -174,12 +176,14 @@ impl Ty {\n                     Ty::Dyn(Arc::new([GenericPredicate::Implemented(trait_ref)]))\n                 };\n             }\n-            TypeNs::GenericParam(idx) => {\n+            TypeNs::GenericParam(param_id) => {\n+                let generics = generics(db, resolver.generic_def().expect(\"generics in scope\"));\n+                let idx = generics.param_idx(param_id);\n                 // FIXME: maybe return name in resolution?\n-                let name = resolved_segment.name.clone();\n+                let name = generics.param_name(param_id);\n                 Ty::Param { idx, name }\n             }\n-            TypeNs::SelfType(impl_id) => db.impl_ty(impl_id).self_type().clone(),\n+            TypeNs::SelfType(impl_id) => db.impl_self_ty(impl_id).clone(),\n             TypeNs::AdtSelfType(adt) => db.ty(adt.into()),\n \n             TypeNs::AdtId(it) => Ty::from_hir_path_inner(db, resolver, resolved_segment, it.into()),\n@@ -198,21 +202,21 @@ impl Ty {\n \n     pub(crate) fn from_hir_path(db: &impl HirDatabase, resolver: &Resolver, path: &Path) -> Ty {\n         // Resolve the path (in type namespace)\n-        if let PathKind::Type(type_ref) = &path.kind {\n+        if let Some(type_ref) = path.type_anchor() {\n             let ty = Ty::from_hir(db, resolver, &type_ref);\n-            let remaining_segments = &path.segments[..];\n-            return Ty::from_type_relative_path(db, resolver, ty, remaining_segments);\n+            return Ty::from_type_relative_path(db, resolver, ty, path.segments());\n         }\n-        let (resolution, remaining_index) = match resolver.resolve_path_in_type_ns(db, path) {\n-            Some(it) => it,\n-            None => return Ty::Unknown,\n-        };\n+        let (resolution, remaining_index) =\n+            match resolver.resolve_path_in_type_ns(db, path.mod_path()) {\n+                Some(it) => it,\n+                None => return Ty::Unknown,\n+            };\n         let (resolved_segment, remaining_segments) = match remaining_index {\n             None => (\n-                path.segments.last().expect(\"resolved path has at least one element\"),\n-                &[] as &[PathSegment],\n+                path.segments().last().expect(\"resolved path has at least one element\"),\n+                PathSegments::EMPTY,\n             ),\n-            Some(i) => (&path.segments[i - 1], &path.segments[i..]),\n+            Some(i) => (path.segments().get(i - 1).unwrap(), path.segments().skip(i)),\n         };\n         Ty::from_partly_resolved_hir_path(\n             db,\n@@ -227,7 +231,7 @@ impl Ty {\n         db: &impl HirDatabase,\n         resolver: &Resolver,\n         self_ty: Ty,\n-        segment: &PathSegment,\n+        segment: PathSegment<'_>,\n     ) -> Ty {\n         let param_idx = match self_ty {\n             Ty::Param { idx, .. } => idx,\n@@ -257,7 +261,7 @@ impl Ty {\n     fn from_hir_path_inner(\n         db: &impl HirDatabase,\n         resolver: &Resolver,\n-        segment: &PathSegment,\n+        segment: PathSegment<'_>,\n         typable: TyDefId,\n     ) -> Ty {\n         let generic_def = match typable {\n@@ -280,7 +284,7 @@ impl Ty {\n         // special-case enum variants\n         resolved: ValueTyDefId,\n     ) -> Substs {\n-        let last = path.segments.last().expect(\"path should have at least one segment\");\n+        let last = path.segments().last().expect(\"path should have at least one segment\");\n         let (segment, generic_def) = match resolved {\n             ValueTyDefId::FunctionId(it) => (last, Some(it.into())),\n             ValueTyDefId::StructId(it) => (last, Some(it.into())),\n@@ -292,13 +296,11 @@ impl Ty {\n                 // referring to the variant. So `Option::<T>::None` and\n                 // `Option::None::<T>` are both allowed (though the former is\n                 // preferred). See also `def_ids_for_path_segments` in rustc.\n-                let len = path.segments.len();\n-                let segment = if len >= 2 && path.segments[len - 2].args_and_bindings.is_some() {\n-                    // Option::<T>::None\n-                    &path.segments[len - 2]\n-                } else {\n-                    // Option::None::<T>\n-                    last\n+                let len = path.segments().len();\n+                let penultimate = if len >= 2 { path.segments().get(len - 2) } else { None };\n+                let segment = match penultimate {\n+                    Some(segment) if segment.args_and_bindings.is_some() => segment,\n+                    _ => last,\n                 };\n                 (segment, Some(var.parent.into()))\n             }\n@@ -310,16 +312,15 @@ impl Ty {\n pub(super) fn substs_from_path_segment(\n     db: &impl HirDatabase,\n     resolver: &Resolver,\n-    segment: &PathSegment,\n+    segment: PathSegment<'_>,\n     def_generic: Option<GenericDefId>,\n     add_self_param: bool,\n ) -> Substs {\n     let mut substs = Vec::new();\n-    let def_generics = def_generic.map(|def| db.generic_params(def.into()));\n+    let def_generics = def_generic.map(|def| generics(db, def.into()));\n \n-    let (parent_param_count, param_count) =\n-        def_generics.map_or((0, 0), |g| (g.count_parent_params(), g.params.len()));\n-    substs.extend(iter::repeat(Ty::Unknown).take(parent_param_count));\n+    let (total_len, parent_len, child_len) = def_generics.map_or((0, 0, 0), |g| g.len_split());\n+    substs.extend(iter::repeat(Ty::Unknown).take(parent_len));\n     if add_self_param {\n         // FIXME this add_self_param argument is kind of a hack: Traits have the\n         // Self type as an implicit first type parameter, but it can't be\n@@ -330,8 +331,8 @@ pub(super) fn substs_from_path_segment(\n     if let Some(generic_args) = &segment.args_and_bindings {\n         // if args are provided, it should be all of them, but we can't rely on that\n         let self_param_correction = if add_self_param { 1 } else { 0 };\n-        let param_count = param_count - self_param_correction;\n-        for arg in generic_args.args.iter().take(param_count) {\n+        let child_len = child_len + self_param_correction;\n+        for arg in generic_args.args.iter().take(child_len) {\n             match arg {\n                 GenericArg::Type(type_ref) => {\n                     let ty = Ty::from_hir(db, resolver, type_ref);\n@@ -342,10 +343,10 @@ pub(super) fn substs_from_path_segment(\n     }\n     // add placeholders for args that were not provided\n     let supplied_params = substs.len();\n-    for _ in supplied_params..parent_param_count + param_count {\n+    for _ in supplied_params..total_len {\n         substs.push(Ty::Unknown);\n     }\n-    assert_eq!(substs.len(), parent_param_count + param_count);\n+    assert_eq!(substs.len(), total_len);\n \n     // handle defaults\n     if let Some(def_generic) = def_generic {\n@@ -369,19 +370,19 @@ impl TraitRef {\n         path: &Path,\n         explicit_self_ty: Option<Ty>,\n     ) -> Option<Self> {\n-        let resolved = match resolver.resolve_path_in_type_ns_fully(db, &path)? {\n+        let resolved = match resolver.resolve_path_in_type_ns_fully(db, path.mod_path())? {\n             TypeNs::TraitId(tr) => tr,\n             _ => return None,\n         };\n-        let segment = path.segments.last().expect(\"path should have at least one segment\");\n+        let segment = path.segments().last().expect(\"path should have at least one segment\");\n         Some(TraitRef::from_resolved_path(db, resolver, resolved.into(), segment, explicit_self_ty))\n     }\n \n     pub(crate) fn from_resolved_path(\n         db: &impl HirDatabase,\n         resolver: &Resolver,\n         resolved: TraitId,\n-        segment: &PathSegment,\n+        segment: PathSegment<'_>,\n         explicit_self_ty: Option<Ty>,\n     ) -> Self {\n         let mut substs = TraitRef::substs_from_path(db, resolver, segment, resolved);\n@@ -407,7 +408,7 @@ impl TraitRef {\n     fn substs_from_path(\n         db: &impl HirDatabase,\n         resolver: &Resolver,\n-        segment: &PathSegment,\n+        segment: PathSegment<'_>,\n         resolved: TraitId,\n     ) -> Substs {\n         let has_self_param =\n@@ -461,12 +462,12 @@ fn assoc_type_bindings_from_type_bound<'a>(\n     trait_ref: TraitRef,\n ) -> impl Iterator<Item = GenericPredicate> + 'a {\n     let last_segment = match bound {\n-        TypeBound::Path(path) => path.segments.last(),\n+        TypeBound::Path(path) => path.segments().last(),\n         TypeBound::Error => None,\n     };\n     last_segment\n         .into_iter()\n-        .flat_map(|segment| segment.args_and_bindings.iter())\n+        .flat_map(|segment| segment.args_and_bindings.into_iter())\n         .flat_map(|args_and_bindings| args_and_bindings.bindings.iter())\n         .map(move |(name, type_ref)| {\n             let associated_ty =\n@@ -532,6 +533,15 @@ pub(crate) fn generic_predicates_for_param_query(\n         .collect()\n }\n \n+pub(crate) fn generic_predicates_for_param_recover(\n+    _db: &impl HirDatabase,\n+    _cycle: &[String],\n+    _def: &GenericDefId,\n+    _param_idx: &u32,\n+) -> Arc<[GenericPredicate]> {\n+    Arc::new([])\n+}\n+\n impl TraitEnvironment {\n     pub fn lower(db: &impl HirDatabase, resolver: &Resolver) -> Arc<TraitEnvironment> {\n         let predicates = resolver\n@@ -558,12 +568,11 @@ pub(crate) fn generic_predicates_query(\n /// Resolve the default type params from generics\n pub(crate) fn generic_defaults_query(db: &impl HirDatabase, def: GenericDefId) -> Substs {\n     let resolver = def.resolver(db);\n-    let generic_params = db.generic_params(def.into());\n+    let generic_params = generics(db, def.into());\n \n     let defaults = generic_params\n-        .params_including_parent()\n-        .into_iter()\n-        .map(|p| p.default.as_ref().map_or(Ty::Unknown, |t| Ty::from_hir(db, &resolver, t)))\n+        .iter()\n+        .map(|(_idx, p)| p.default.as_ref().map_or(Ty::Unknown, |t| Ty::from_hir(db, &resolver, t)))\n         .collect();\n \n     Substs(defaults)\n@@ -580,7 +589,7 @@ fn fn_sig_for_fn(db: &impl HirDatabase, def: FunctionId) -> FnSig {\n /// Build the declared type of a function. This should not need to look at the\n /// function body.\n fn type_for_fn(db: &impl HirDatabase, def: FunctionId) -> Ty {\n-    let generics = db.generic_params(def.into());\n+    let generics = generics(db, def.into());\n     let substs = Substs::identity(&generics);\n     Ty::apply(TypeCtor::FnDef(def.into()), substs)\n }\n@@ -630,7 +639,7 @@ fn type_for_struct_constructor(db: &impl HirDatabase, def: StructId) -> Ty {\n     if struct_data.variant_data.is_unit() {\n         return type_for_adt(db, def.into()); // Unit struct\n     }\n-    let generics = db.generic_params(def.into());\n+    let generics = generics(db, def.into());\n     let substs = Substs::identity(&generics);\n     Ty::apply(TypeCtor::FnDef(def.into()), substs)\n }\n@@ -644,7 +653,7 @@ fn fn_sig_for_enum_variant_constructor(db: &impl HirDatabase, def: EnumVariantId\n         .iter()\n         .map(|(_, field)| Ty::from_hir(db, &resolver, &field.type_ref))\n         .collect::<Vec<_>>();\n-    let generics = db.generic_params(def.parent.into());\n+    let generics = generics(db, def.parent.into());\n     let substs = Substs::identity(&generics);\n     let ret = type_for_adt(db, def.parent.into()).subst(&substs);\n     FnSig::from_params_and_return(params, ret)\n@@ -657,18 +666,18 @@ fn type_for_enum_variant_constructor(db: &impl HirDatabase, def: EnumVariantId)\n     if var_data.is_unit() {\n         return type_for_adt(db, def.parent.into()); // Unit variant\n     }\n-    let generics = db.generic_params(def.parent.into());\n+    let generics = generics(db, def.parent.into());\n     let substs = Substs::identity(&generics);\n     Ty::apply(TypeCtor::FnDef(EnumVariantId::from(def).into()), substs)\n }\n \n fn type_for_adt(db: &impl HirDatabase, adt: AdtId) -> Ty {\n-    let generics = db.generic_params(adt.into());\n+    let generics = generics(db, adt.into());\n     Ty::apply(TypeCtor::Adt(adt), Substs::identity(&generics))\n }\n \n fn type_for_type_alias(db: &impl HirDatabase, t: TypeAliasId) -> Ty {\n-    let generics = db.generic_params(t.into());\n+    let generics = generics(db, t.into());\n     let resolver = t.resolver(db);\n     let type_ref = &db.type_alias_data(t).type_ref;\n     let substs = Substs::identity(&generics);\n@@ -687,10 +696,11 @@ impl_froms!(CallableDef: FunctionId, StructId, EnumVariantId);\n impl CallableDef {\n     pub fn krate(self, db: &impl HirDatabase) -> CrateId {\n         match self {\n-            CallableDef::FunctionId(f) => f.lookup(db).module(db).krate,\n-            CallableDef::StructId(s) => s.module(db).krate,\n-            CallableDef::EnumVariantId(e) => e.parent.module(db).krate,\n+            CallableDef::FunctionId(f) => f.lookup(db).module(db),\n+            CallableDef::StructId(s) => s.lookup(db).container.module(db),\n+            CallableDef::EnumVariantId(e) => e.parent.lookup(db).container.module(db),\n         }\n+        .krate\n     }\n }\n \n@@ -733,6 +743,11 @@ pub(crate) fn ty_query(db: &impl HirDatabase, def: TyDefId) -> Ty {\n         TyDefId::TypeAliasId(it) => type_for_type_alias(db, it),\n     }\n }\n+\n+pub(crate) fn ty_recover(_db: &impl HirDatabase, _cycle: &[String], _def: &TyDefId) -> Ty {\n+    Ty::Unknown\n+}\n+\n pub(crate) fn value_ty_query(db: &impl HirDatabase, def: ValueTyDefId) -> Ty {\n     match def {\n         ValueTyDefId::FunctionId(it) => type_for_fn(db, it),\n@@ -743,17 +758,24 @@ pub(crate) fn value_ty_query(db: &impl HirDatabase, def: ValueTyDefId) -> Ty {\n     }\n }\n \n-pub(crate) fn impl_ty_query(db: &impl HirDatabase, impl_id: ImplId) -> ImplTy {\n+pub(crate) fn impl_self_ty_query(db: &impl HirDatabase, impl_id: ImplId) -> Ty {\n     let impl_data = db.impl_data(impl_id);\n     let resolver = impl_id.resolver(db);\n-    let self_ty = Ty::from_hir(db, &resolver, &impl_data.target_type);\n-    match impl_data.target_trait.as_ref() {\n-        Some(trait_ref) => {\n-            match TraitRef::from_hir(db, &resolver, trait_ref, Some(self_ty.clone())) {\n-                Some(it) => ImplTy::TraitRef(it),\n-                None => ImplTy::Inherent(self_ty),\n-            }\n-        }\n-        None => ImplTy::Inherent(self_ty),\n-    }\n+    Ty::from_hir(db, &resolver, &impl_data.target_type)\n+}\n+\n+pub(crate) fn impl_self_ty_recover(\n+    _db: &impl HirDatabase,\n+    _cycle: &[String],\n+    _impl_id: &ImplId,\n+) -> Ty {\n+    Ty::Unknown\n+}\n+\n+pub(crate) fn impl_trait_query(db: &impl HirDatabase, impl_id: ImplId) -> Option<TraitRef> {\n+    let impl_data = db.impl_data(impl_id);\n+    let resolver = impl_id.resolver(db);\n+    let self_ty = db.impl_self_ty(impl_id);\n+    let target_trait = impl_data.target_trait.as_ref()?;\n+    TraitRef::from_hir(db, &resolver, target_trait, Some(self_ty.clone()))\n }"}, {"sha": "fe74acf119b80a953ecf925ae3efce683ff06425", "filename": "crates/ra_hir_ty/src/marks.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_ty%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_ty%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fmarks.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -6,4 +6,5 @@ test_utils::marks!(\n     type_var_resolves_to_int_var\n     match_ergonomics_ref\n     coerce_merge_fail_fallback\n+    insert_vars_for_impl_trait\n );"}, {"sha": "888dc311662758c9ee9eb229fc3e656985a08478", "filename": "crates/ra_hir_ty/src/method_resolution.rs", "status": "modified", "additions": 193, "deletions": 45, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -6,20 +6,21 @@ use std::sync::Arc;\n \n use arrayvec::ArrayVec;\n use hir_def::{\n-    lang_item::LangItemTarget, resolver::Resolver, type_ref::Mutability, AssocItemId, AstItemDef,\n-    FunctionId, HasModule, ImplId, TraitId,\n+    lang_item::LangItemTarget, resolver::Resolver, type_ref::Mutability, AssocContainerId,\n+    AssocItemId, FunctionId, HasModule, ImplId, Lookup, TraitId,\n };\n use hir_expand::name::Name;\n use ra_db::CrateId;\n use ra_prof::profile;\n use rustc_hash::FxHashMap;\n \n+use super::Substs;\n use crate::{\n     autoderef,\n     db::HirDatabase,\n     primitive::{FloatBitness, Uncertain},\n     utils::all_super_traits,\n-    Canonical, ImplTy, InEnvironment, TraitEnvironment, TraitRef, Ty, TypeCtor,\n+    Canonical, InEnvironment, TraitEnvironment, TraitRef, Ty, TypeCtor, TypeWalk,\n };\n \n /// This is used as a key for indexing impls.\n@@ -57,12 +58,13 @@ impl CrateImplBlocks {\n \n         let crate_def_map = db.crate_def_map(krate);\n         for (_module_id, module_data) in crate_def_map.modules.iter() {\n-            for &impl_id in module_data.impls.iter() {\n-                match db.impl_ty(impl_id) {\n-                    ImplTy::TraitRef(tr) => {\n+            for impl_id in module_data.scope.impls() {\n+                match db.impl_trait(impl_id) {\n+                    Some(tr) => {\n                         res.impls_by_trait.entry(tr.trait_).or_default().push(impl_id);\n                     }\n-                    ImplTy::Inherent(self_ty) => {\n+                    None => {\n+                        let self_ty = db.impl_self_ty(impl_id);\n                         if let Some(self_ty_fp) = TyFingerprint::for_impl(&self_ty) {\n                             res.impls.entry(self_ty_fp).or_default().push(impl_id);\n                         }\n@@ -132,7 +134,7 @@ impl Ty {\n                 LangItemTarget::ImplBlockId(it) => Some(it),\n                 _ => None,\n             })\n-            .map(|it| it.module(db).krate)\n+            .map(|it| it.lookup(db).container.module(db).krate)\n             .collect();\n         Some(res)\n     }\n@@ -175,7 +177,6 @@ pub fn iterate_method_candidates<T>(\n     mode: LookupMode,\n     mut callback: impl FnMut(&Ty, AssocItemId) -> Option<T>,\n ) -> Option<T> {\n-    let krate = resolver.krate()?;\n     match mode {\n         LookupMode::MethodCall => {\n             // For method calls, rust first does any number of autoderef, and then one\n@@ -188,57 +189,159 @@ pub fn iterate_method_candidates<T>(\n             // rustc does an autoderef and then autoref again).\n             let environment = TraitEnvironment::lower(db, resolver);\n             let ty = InEnvironment { value: ty.clone(), environment };\n-            for derefed_ty in autoderef::autoderef(db, resolver.krate(), ty) {\n-                if let Some(result) =\n-                    iterate_inherent_methods(&derefed_ty, db, name, mode, krate, &mut callback)\n-                {\n-                    return Some(result);\n-                }\n-                if let Some(result) = iterate_trait_method_candidates(\n-                    &derefed_ty,\n+            let krate = resolver.krate()?;\n+\n+            // We have to be careful about the order we're looking at candidates\n+            // in here. Consider the case where we're resolving `x.clone()`\n+            // where `x: &Vec<_>`. This resolves to the clone method with self\n+            // type `Vec<_>`, *not* `&_`. I.e. we need to consider methods where\n+            // the receiver type exactly matches before cases where we have to\n+            // do autoref. But in the autoderef steps, the `&_` self type comes\n+            // up *before* the `Vec<_>` self type.\n+            //\n+            // On the other hand, we don't want to just pick any by-value method\n+            // before any by-autoref method; it's just that we need to consider\n+            // the methods by autoderef order of *receiver types*, not *self\n+            // types*.\n+\n+            let deref_chain: Vec<_> = autoderef::autoderef(db, Some(krate), ty.clone()).collect();\n+            for i in 0..deref_chain.len() {\n+                if let Some(result) = iterate_method_candidates_with_autoref(\n+                    &deref_chain[i..],\n                     db,\n                     resolver,\n                     name,\n-                    mode,\n                     &mut callback,\n                 ) {\n                     return Some(result);\n                 }\n             }\n+            None\n         }\n         LookupMode::Path => {\n             // No autoderef for path lookups\n-            if let Some(result) =\n-                iterate_inherent_methods(&ty, db, name, mode, krate.into(), &mut callback)\n-            {\n-                return Some(result);\n-            }\n-            if let Some(result) =\n-                iterate_trait_method_candidates(&ty, db, resolver, name, mode, &mut callback)\n-            {\n-                return Some(result);\n-            }\n+            iterate_method_candidates_for_self_ty(&ty, db, resolver, name, &mut callback)\n+        }\n+    }\n+}\n+\n+fn iterate_method_candidates_with_autoref<T>(\n+    deref_chain: &[Canonical<Ty>],\n+    db: &impl HirDatabase,\n+    resolver: &Resolver,\n+    name: Option<&Name>,\n+    mut callback: impl FnMut(&Ty, AssocItemId) -> Option<T>,\n+) -> Option<T> {\n+    if let Some(result) = iterate_method_candidates_by_receiver(\n+        &deref_chain[0],\n+        &deref_chain[1..],\n+        db,\n+        resolver,\n+        name,\n+        &mut callback,\n+    ) {\n+        return Some(result);\n+    }\n+    let refed = Canonical {\n+        num_vars: deref_chain[0].num_vars,\n+        value: Ty::apply_one(TypeCtor::Ref(Mutability::Shared), deref_chain[0].value.clone()),\n+    };\n+    if let Some(result) = iterate_method_candidates_by_receiver(\n+        &refed,\n+        deref_chain,\n+        db,\n+        resolver,\n+        name,\n+        &mut callback,\n+    ) {\n+        return Some(result);\n+    }\n+    let ref_muted = Canonical {\n+        num_vars: deref_chain[0].num_vars,\n+        value: Ty::apply_one(TypeCtor::Ref(Mutability::Mut), deref_chain[0].value.clone()),\n+    };\n+    if let Some(result) = iterate_method_candidates_by_receiver(\n+        &ref_muted,\n+        deref_chain,\n+        db,\n+        resolver,\n+        name,\n+        &mut callback,\n+    ) {\n+        return Some(result);\n+    }\n+    None\n+}\n+\n+fn iterate_method_candidates_by_receiver<T>(\n+    receiver_ty: &Canonical<Ty>,\n+    rest_of_deref_chain: &[Canonical<Ty>],\n+    db: &impl HirDatabase,\n+    resolver: &Resolver,\n+    name: Option<&Name>,\n+    mut callback: impl FnMut(&Ty, AssocItemId) -> Option<T>,\n+) -> Option<T> {\n+    // We're looking for methods with *receiver* type receiver_ty. These could\n+    // be found in any of the derefs of receiver_ty, so we have to go through\n+    // that.\n+    let krate = resolver.krate()?;\n+    for self_ty in std::iter::once(receiver_ty).chain(rest_of_deref_chain) {\n+        if let Some(result) =\n+            iterate_inherent_methods(self_ty, db, name, Some(receiver_ty), krate, &mut callback)\n+        {\n+            return Some(result);\n+        }\n+    }\n+    for self_ty in std::iter::once(receiver_ty).chain(rest_of_deref_chain) {\n+        if let Some(result) = iterate_trait_method_candidates(\n+            self_ty,\n+            db,\n+            resolver,\n+            name,\n+            Some(receiver_ty),\n+            &mut callback,\n+        ) {\n+            return Some(result);\n         }\n     }\n     None\n }\n \n+fn iterate_method_candidates_for_self_ty<T>(\n+    self_ty: &Canonical<Ty>,\n+    db: &impl HirDatabase,\n+    resolver: &Resolver,\n+    name: Option<&Name>,\n+    mut callback: impl FnMut(&Ty, AssocItemId) -> Option<T>,\n+) -> Option<T> {\n+    let krate = resolver.krate()?;\n+    if let Some(result) = iterate_inherent_methods(self_ty, db, name, None, krate, &mut callback) {\n+        return Some(result);\n+    }\n+    if let Some(result) =\n+        iterate_trait_method_candidates(self_ty, db, resolver, name, None, &mut callback)\n+    {\n+        return Some(result);\n+    }\n+    None\n+}\n+\n fn iterate_trait_method_candidates<T>(\n-    ty: &Canonical<Ty>,\n+    self_ty: &Canonical<Ty>,\n     db: &impl HirDatabase,\n     resolver: &Resolver,\n     name: Option<&Name>,\n-    mode: LookupMode,\n+    receiver_ty: Option<&Canonical<Ty>>,\n     mut callback: impl FnMut(&Ty, AssocItemId) -> Option<T>,\n ) -> Option<T> {\n     let krate = resolver.krate()?;\n     // FIXME: maybe put the trait_env behind a query (need to figure out good input parameters for that)\n     let env = TraitEnvironment::lower(db, resolver);\n     // if ty is `impl Trait` or `dyn Trait`, the trait doesn't need to be in scope\n-    let inherent_trait = ty.value.inherent_trait().into_iter();\n+    let inherent_trait = self_ty.value.inherent_trait().into_iter();\n     // if we have `T: Trait` in the param env, the trait doesn't need to be in scope\n     let traits_from_env = env\n-        .trait_predicates_for_self_ty(&ty.value)\n+        .trait_predicates_for_self_ty(&self_ty.value)\n         .map(|tr| tr.trait_)\n         .flat_map(|t| all_super_traits(db, t));\n     let traits =\n@@ -251,17 +354,17 @@ fn iterate_trait_method_candidates<T>(\n         // iteration\n         let mut known_implemented = false;\n         for (_name, item) in data.items.iter() {\n-            if !is_valid_candidate(db, name, mode, (*item).into()) {\n+            if !is_valid_candidate(db, name, receiver_ty, (*item).into(), self_ty) {\n                 continue;\n             }\n             if !known_implemented {\n-                let goal = generic_implements_goal(db, env.clone(), t, ty.clone());\n+                let goal = generic_implements_goal(db, env.clone(), t, self_ty.clone());\n                 if db.trait_solve(krate.into(), goal).is_none() {\n                     continue 'traits;\n                 }\n             }\n             known_implemented = true;\n-            if let Some(result) = callback(&ty.value, (*item).into()) {\n+            if let Some(result) = callback(&self_ty.value, (*item).into()) {\n                 return Some(result);\n             }\n         }\n@@ -270,22 +373,22 @@ fn iterate_trait_method_candidates<T>(\n }\n \n fn iterate_inherent_methods<T>(\n-    ty: &Canonical<Ty>,\n+    self_ty: &Canonical<Ty>,\n     db: &impl HirDatabase,\n     name: Option<&Name>,\n-    mode: LookupMode,\n+    receiver_ty: Option<&Canonical<Ty>>,\n     krate: CrateId,\n     mut callback: impl FnMut(&Ty, AssocItemId) -> Option<T>,\n ) -> Option<T> {\n-    for krate in ty.value.def_crates(db, krate)? {\n+    for krate in self_ty.value.def_crates(db, krate)? {\n         let impls = db.impls_in_crate(krate);\n \n-        for impl_block in impls.lookup_impl_blocks(&ty.value) {\n+        for impl_block in impls.lookup_impl_blocks(&self_ty.value) {\n             for &item in db.impl_data(impl_block).items.iter() {\n-                if !is_valid_candidate(db, name, mode, item) {\n+                if !is_valid_candidate(db, name, receiver_ty, item, self_ty) {\n                     continue;\n                 }\n-                if let Some(result) = callback(&ty.value, item.into()) {\n+                if let Some(result) = callback(&self_ty.value, item) {\n                     return Some(result);\n                 }\n             }\n@@ -297,23 +400,68 @@ fn iterate_inherent_methods<T>(\n fn is_valid_candidate(\n     db: &impl HirDatabase,\n     name: Option<&Name>,\n-    mode: LookupMode,\n+    receiver_ty: Option<&Canonical<Ty>>,\n     item: AssocItemId,\n+    self_ty: &Canonical<Ty>,\n ) -> bool {\n     match item {\n         AssocItemId::FunctionId(m) => {\n             let data = db.function_data(m);\n-            name.map_or(true, |name| &data.name == name)\n-                && (data.has_self_param || mode == LookupMode::Path)\n+            if let Some(name) = name {\n+                if &data.name != name {\n+                    return false;\n+                }\n+            }\n+            if let Some(receiver_ty) = receiver_ty {\n+                if !data.has_self_param {\n+                    return false;\n+                }\n+                let transformed_receiver_ty = match transform_receiver_ty(db, m, self_ty) {\n+                    Some(ty) => ty,\n+                    None => return false,\n+                };\n+                if transformed_receiver_ty != receiver_ty.value {\n+                    return false;\n+                }\n+            }\n+            true\n         }\n         AssocItemId::ConstId(c) => {\n             let data = db.const_data(c);\n-            name.map_or(true, |name| data.name.as_ref() == Some(name)) && (mode == LookupMode::Path)\n+            name.map_or(true, |name| data.name.as_ref() == Some(name)) && receiver_ty.is_none()\n         }\n         _ => false,\n     }\n }\n \n+pub(crate) fn inherent_impl_substs(\n+    db: &impl HirDatabase,\n+    impl_id: ImplId,\n+    self_ty: &Canonical<Ty>,\n+) -> Option<Substs> {\n+    let vars = Substs::build_for_def(db, impl_id).fill_with_bound_vars(0).build();\n+    let self_ty_with_vars = db.impl_self_ty(impl_id).subst(&vars);\n+    let self_ty_with_vars = Canonical { num_vars: vars.len(), value: self_ty_with_vars };\n+    super::infer::unify(&self_ty_with_vars, self_ty)\n+}\n+\n+fn transform_receiver_ty(\n+    db: &impl HirDatabase,\n+    function_id: FunctionId,\n+    self_ty: &Canonical<Ty>,\n+) -> Option<Ty> {\n+    let substs = match function_id.lookup(db).container {\n+        AssocContainerId::TraitId(_) => Substs::build_for_def(db, function_id)\n+            .push(self_ty.value.clone())\n+            .fill_with_unknown()\n+            .build(),\n+        AssocContainerId::ImplId(impl_id) => inherent_impl_substs(db, impl_id, &self_ty)?,\n+        AssocContainerId::ContainerId(_) => unreachable!(),\n+    };\n+    let sig = db.callable_item_signature(function_id.into());\n+    Some(sig.params()[0].clone().subst(&substs))\n+}\n+\n pub fn implements_trait(\n     ty: &Canonical<Ty>,\n     db: &impl HirDatabase,"}, {"sha": "1a31b587bbc3b4bb5b1e5cc04afe2ddbe5a4a08f", "filename": "crates/ra_hir_ty/src/test_db.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_ty%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_ty%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftest_db.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -74,7 +74,7 @@ impl TestDB {\n         for &krate in self.relevant_crates(file_id).iter() {\n             let crate_def_map = self.crate_def_map(krate);\n             for (local_id, data) in crate_def_map.modules.iter() {\n-                if data.definition == Some(file_id) {\n+                if data.origin.file_id() == Some(file_id) {\n                     return ModuleId { krate, local_id };\n                 }\n             }\n@@ -98,7 +98,7 @@ impl TestDB {\n                     }\n                 }\n \n-                for &impl_id in crate_def_map[module_id].impls.iter() {\n+                for impl_id in crate_def_map[module_id].scope.impls() {\n                     let impl_data = self.impl_data(impl_id);\n                     for item in impl_data.items.iter() {\n                         if let AssocItemId::FunctionId(f) = item {"}, {"sha": "d447b4571832c5e9cf6a3b5ad07ba2b6cc9330ea", "filename": "crates/ra_hir_ty/src/tests.rs", "status": "modified", "additions": 46, "deletions": 4721, "changes": 4767, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "7e99a42edc459e913900eb5f08765ae789a82731", "filename": "crates/ra_hir_ty/src/tests/coercion.rs", "status": "modified", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -1,3 +1,4 @@\n+use super::infer_with_mismatches;\n use insta::assert_snapshot;\n use test_utils::covers;\n \n@@ -367,3 +368,161 @@ fn test() {\n     \"###\n     );\n }\n+\n+#[test]\n+fn return_coerce_unknown() {\n+    assert_snapshot!(\n+        infer_with_mismatches(r#\"\n+fn foo() -> u32 {\n+    return unknown;\n+}\n+\"#, true),\n+        @r###\"\n+    [17; 40) '{     ...own; }': !\n+    [23; 37) 'return unknown': !\n+    [30; 37) 'unknown': u32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn coerce_autoderef() {\n+    assert_snapshot!(\n+        infer_with_mismatches(r#\"\n+struct Foo;\n+fn takes_ref_foo(x: &Foo) {}\n+fn test() {\n+    takes_ref_foo(&Foo);\n+    takes_ref_foo(&&Foo);\n+    takes_ref_foo(&&&Foo);\n+}\n+\"#, true),\n+        @r###\"\n+    [30; 31) 'x': &Foo\n+    [39; 41) '{}': ()\n+    [52; 133) '{     ...oo); }': ()\n+    [58; 71) 'takes_ref_foo': fn takes_ref_foo(&Foo) -> ()\n+    [58; 77) 'takes_...(&Foo)': ()\n+    [72; 76) '&Foo': &Foo\n+    [73; 76) 'Foo': Foo\n+    [83; 96) 'takes_ref_foo': fn takes_ref_foo(&Foo) -> ()\n+    [83; 103) 'takes_...&&Foo)': ()\n+    [97; 102) '&&Foo': &&Foo\n+    [98; 102) '&Foo': &Foo\n+    [99; 102) 'Foo': Foo\n+    [109; 122) 'takes_ref_foo': fn takes_ref_foo(&Foo) -> ()\n+    [109; 130) 'takes_...&&Foo)': ()\n+    [123; 129) '&&&Foo': &&&Foo\n+    [124; 129) '&&Foo': &&Foo\n+    [125; 129) '&Foo': &Foo\n+    [126; 129) 'Foo': Foo\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn coerce_autoderef_generic() {\n+    assert_snapshot!(\n+        infer_with_mismatches(r#\"\n+struct Foo;\n+fn takes_ref<T>(x: &T) -> T { *x }\n+fn test() {\n+    takes_ref(&Foo);\n+    takes_ref(&&Foo);\n+    takes_ref(&&&Foo);\n+}\n+\"#, true),\n+        @r###\"\n+    [29; 30) 'x': &T\n+    [41; 47) '{ *x }': T\n+    [43; 45) '*x': T\n+    [44; 45) 'x': &T\n+    [58; 127) '{     ...oo); }': ()\n+    [64; 73) 'takes_ref': fn takes_ref<Foo>(&T) -> T\n+    [64; 79) 'takes_ref(&Foo)': Foo\n+    [74; 78) '&Foo': &Foo\n+    [75; 78) 'Foo': Foo\n+    [85; 94) 'takes_ref': fn takes_ref<&Foo>(&T) -> T\n+    [85; 101) 'takes_...&&Foo)': &Foo\n+    [95; 100) '&&Foo': &&Foo\n+    [96; 100) '&Foo': &Foo\n+    [97; 100) 'Foo': Foo\n+    [107; 116) 'takes_ref': fn takes_ref<&&Foo>(&T) -> T\n+    [107; 124) 'takes_...&&Foo)': &&Foo\n+    [117; 123) '&&&Foo': &&&Foo\n+    [118; 123) '&&Foo': &&Foo\n+    [119; 123) '&Foo': &Foo\n+    [120; 123) 'Foo': Foo\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn closure_return_coerce() {\n+    assert_snapshot!(\n+        infer_with_mismatches(r#\"\n+fn foo() {\n+    let x = || {\n+        if true {\n+            return &1u32;\n+        }\n+        &&1u32\n+    };\n+}\n+\"#, true),\n+        @r###\"\n+    [10; 106) '{     ...  }; }': ()\n+    [20; 21) 'x': || -> &u32\n+    [24; 103) '|| {  ...     }': || -> &u32\n+    [27; 103) '{     ...     }': &u32\n+    [37; 82) 'if tru...     }': ()\n+    [40; 44) 'true': bool\n+    [45; 82) '{     ...     }': !\n+    [59; 71) 'return &1u32': !\n+    [66; 71) '&1u32': &u32\n+    [67; 71) '1u32': u32\n+    [91; 97) '&&1u32': &&u32\n+    [92; 97) '&1u32': &u32\n+    [93; 97) '1u32': u32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn coerce_fn_item_to_fn_ptr() {\n+    assert_snapshot!(\n+        infer_with_mismatches(r#\"\n+fn foo(x: u32) -> isize { 1 }\n+fn test() {\n+    let f: fn(u32) -> isize = foo;\n+}\n+\"#, true),\n+        @r###\"\n+    [8; 9) 'x': u32\n+    [25; 30) '{ 1 }': isize\n+    [27; 28) '1': isize\n+    [41; 79) '{     ...foo; }': ()\n+    [51; 52) 'f': fn(u32) -> isize\n+    [73; 76) 'foo': fn foo(u32) -> isize\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn coerce_closure_to_fn_ptr() {\n+    assert_snapshot!(\n+        infer_with_mismatches(r#\"\n+fn test() {\n+    let f: fn(u32) -> isize = |x| { 1 };\n+}\n+\"#, true),\n+        @r###\"\n+    [11; 55) '{     ...1 }; }': ()\n+    [21; 22) 'f': fn(u32) -> isize\n+    [43; 52) '|x| { 1 }': |u32| -> isize\n+    [44; 45) 'x': u32\n+    [47; 52) '{ 1 }': isize\n+    [49; 50) '1': isize\n+    \"###\n+    );\n+}"}, {"sha": "69c695cc8f10edf6d8f1051d45e0b345fbcb62df", "filename": "crates/ra_hir_ty/src/tests/macros.rs", "status": "added", "additions": 390, "deletions": 0, "changes": 390, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmacros.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -0,0 +1,390 @@\n+use super::{infer, type_at, type_at_pos};\n+use crate::test_db::TestDB;\n+use insta::assert_snapshot;\n+use ra_db::fixture::WithFixture;\n+\n+#[test]\n+fn cfg_impl_block() {\n+    let (db, pos) = TestDB::with_position(\n+        r#\"\n+//- /main.rs crate:main deps:foo cfg:test\n+use foo::S as T;\n+struct S;\n+\n+#[cfg(test)]\n+impl S {\n+    fn foo1(&self) -> i32 { 0 }\n+}\n+\n+#[cfg(not(test))]\n+impl S {\n+    fn foo2(&self) -> i32 { 0 }\n+}\n+\n+fn test() {\n+    let t = (S.foo1(), S.foo2(), T.foo3(), T.foo4());\n+    t<|>;\n+}\n+\n+//- /foo.rs crate:foo\n+struct S;\n+\n+#[cfg(not(test))]\n+impl S {\n+    fn foo3(&self) -> i32 { 0 }\n+}\n+\n+#[cfg(test)]\n+impl S {\n+    fn foo4(&self) -> i32 { 0 }\n+}\n+\"#,\n+    );\n+    assert_eq!(\"(i32, {unknown}, i32, {unknown})\", type_at_pos(&db, pos));\n+}\n+\n+#[test]\n+fn infer_macros_expanded() {\n+    assert_snapshot!(\n+        infer(r#\"\n+struct Foo(Vec<i32>);\n+\n+macro_rules! foo {\n+    ($($item:expr),*) => {\n+            {\n+                Foo(vec![$($item,)*])\n+            }\n+    };\n+}\n+\n+fn main() {\n+    let x = foo!(1,2);\n+}\n+\"#),\n+        @r###\"\n+    ![0; 17) '{Foo(v...,2,])}': Foo\n+    ![1; 4) 'Foo': Foo({unknown}) -> Foo\n+    ![1; 16) 'Foo(vec![1,2,])': Foo\n+    ![5; 15) 'vec![1,2,]': {unknown}\n+    [156; 182) '{     ...,2); }': ()\n+    [166; 167) 'x': Foo\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_legacy_textual_scoped_macros_expanded() {\n+    assert_snapshot!(\n+        infer(r#\"\n+struct Foo(Vec<i32>);\n+\n+#[macro_use]\n+mod m {\n+    macro_rules! foo {\n+        ($($item:expr),*) => {\n+            {\n+                Foo(vec![$($item,)*])\n+            }\n+        };\n+    }\n+}\n+\n+fn main() {\n+    let x = foo!(1,2);\n+    let y = crate::foo!(1,2);\n+}\n+\"#),\n+        @r###\"\n+    ![0; 17) '{Foo(v...,2,])}': Foo\n+    ![1; 4) 'Foo': Foo({unknown}) -> Foo\n+    ![1; 16) 'Foo(vec![1,2,])': Foo\n+    ![5; 15) 'vec![1,2,]': {unknown}\n+    [195; 251) '{     ...,2); }': ()\n+    [205; 206) 'x': Foo\n+    [228; 229) 'y': {unknown}\n+    [232; 248) 'crate:...!(1,2)': {unknown}\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_path_qualified_macros_expanded() {\n+    assert_snapshot!(\n+        infer(r#\"\n+#[macro_export]\n+macro_rules! foo {\n+    () => { 42i32 }\n+}\n+\n+mod m {\n+    pub use super::foo as bar;\n+}\n+\n+fn main() {\n+    let x = crate::foo!();\n+    let y = m::bar!();\n+}\n+\"#),\n+        @r###\"\n+    ![0; 5) '42i32': i32\n+    ![0; 5) '42i32': i32\n+    [111; 164) '{     ...!(); }': ()\n+    [121; 122) 'x': i32\n+    [148; 149) 'y': i32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_type_value_macro_having_same_name() {\n+    assert_snapshot!(\n+        infer(r#\"\n+#[macro_export]\n+macro_rules! foo {\n+    () => {\n+        mod foo {\n+            pub use super::foo;\n+        }\n+    };\n+    ($x:tt) => {\n+        $x\n+    };\n+}\n+\n+foo!();\n+\n+fn foo() {\n+    let foo = foo::foo!(42i32);\n+}\n+\"#),\n+        @r###\"\n+    ![0; 5) '42i32': i32\n+    [171; 206) '{     ...32); }': ()\n+    [181; 184) 'foo': i32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn processes_impls_generated_by_macros() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+macro_rules! m {\n+    ($ident:ident) => (impl Trait for $ident {})\n+}\n+trait Trait { fn foo(self) -> u128 {} }\n+struct S;\n+m!(S);\n+fn test() { S.foo()<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"u128\");\n+}\n+\n+#[test]\n+fn infer_impl_items_generated_by_macros() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+macro_rules! m {\n+    () => (fn foo(&self) -> u128 {0})\n+}\n+struct S;\n+impl S {\n+    m!();\n+}\n+\n+fn test() { S.foo()<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"u128\");\n+}\n+\n+#[test]\n+fn infer_impl_items_generated_by_macros_chain() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+macro_rules! m_inner {\n+    () => {fn foo(&self) -> u128 {0}}\n+}\n+macro_rules! m {\n+    () => {m_inner!();}\n+}\n+\n+struct S;\n+impl S {\n+    m!();\n+}\n+\n+fn test() { S.foo()<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"u128\");\n+}\n+\n+#[test]\n+fn infer_macro_with_dollar_crate_is_correct_in_expr() {\n+    let (db, pos) = TestDB::with_position(\n+        r#\"\n+//- /main.rs crate:main deps:foo\n+fn test() {\n+    let x = (foo::foo!(1), foo::foo!(2));\n+    x<|>;\n+}\n+\n+//- /lib.rs crate:foo\n+#[macro_export]\n+macro_rules! foo {\n+    (1) => { $crate::bar!() };\n+    (2) => { 1 + $crate::baz() };\n+}\n+\n+#[macro_export]\n+macro_rules! bar {\n+    () => { 42 }\n+}\n+\n+pub fn baz() -> usize { 31usize }\n+\"#,\n+    );\n+    assert_eq!(\"(i32, usize)\", type_at_pos(&db, pos));\n+}\n+\n+#[test]\n+fn infer_type_value_non_legacy_macro_use_as() {\n+    assert_snapshot!(\n+        infer(r#\"\n+mod m {\n+    macro_rules! _foo {\n+        ($x:ident) => { type $x = u64; }\n+    }\n+    pub(crate) use _foo as foo;\n+}\n+\n+m::foo!(foo);\n+use foo as bar;\n+fn f() -> bar { 0 }\n+fn main() {  \n+    let _a  = f();\n+}\n+\"#),\n+        @r###\"\n+        [159; 164) '{ 0 }': u64\n+        [161; 162) '0': u64\n+        [175; 199) '{     ...f(); }': ()\n+        [187; 189) '_a': u64\n+        [193; 194) 'f': fn f() -> u64\n+        [193; 196) 'f()': u64        \n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_builtin_macros_line() {\n+    assert_snapshot!(\n+        infer(r#\"\n+#[rustc_builtin_macro]\n+macro_rules! line {() => {}}\n+\n+fn main() {\n+    let x = line!();\n+}\n+\"#),\n+        @r###\"\n+    ![0; 1) '6': i32\n+    [64; 88) '{     ...!(); }': ()\n+    [74; 75) 'x': i32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_builtin_macros_file() {\n+    assert_snapshot!(\n+        infer(r#\"\n+#[rustc_builtin_macro]\n+macro_rules! file {() => {}}\n+\n+fn main() {\n+    let x = file!();\n+}\n+\"#),\n+        @r###\"\n+    ![0; 2) '\"\"': &str\n+    [64; 88) '{     ...!(); }': ()\n+    [74; 75) 'x': &str\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_builtin_macros_column() {\n+    assert_snapshot!(\n+        infer(r#\"\n+#[rustc_builtin_macro]\n+macro_rules! column {() => {}}\n+\n+fn main() {\n+    let x = column!();\n+}\n+\"#),\n+        @r###\"\n+    ![0; 2) '13': i32\n+    [66; 92) '{     ...!(); }': ()\n+    [76; 77) 'x': i32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_derive_clone_simple() {\n+    let (db, pos) = TestDB::with_position(\n+        r#\"\n+//- /main.rs crate:main deps:std\n+#[derive(Clone)]\n+struct S;\n+fn test() {\n+    S.clone()<|>;\n+}\n+\n+//- /lib.rs crate:std\n+#[prelude_import]\n+use clone::*;\n+mod clone {\n+    trait Clone {\n+        fn clone(&self) -> Self;\n+    }\n+}\n+\"#,\n+    );\n+    assert_eq!(\"S\", type_at_pos(&db, pos));\n+}\n+\n+#[test]\n+fn infer_derive_clone_with_params() {\n+    let (db, pos) = TestDB::with_position(\n+        r#\"\n+//- /main.rs crate:main deps:std\n+#[derive(Clone)]\n+struct S;\n+#[derive(Clone)]\n+struct Wrapper<T>(T);\n+struct NonClone;\n+fn test() {\n+    (Wrapper(S).clone(), Wrapper(NonClone).clone())<|>;\n+}\n+\n+//- /lib.rs crate:std\n+#[prelude_import]\n+use clone::*;\n+mod clone {\n+    trait Clone {\n+        fn clone(&self) -> Self;\n+    }\n+}\n+\"#,\n+    );\n+    assert_eq!(\"(Wrapper<S>, {unknown})\", type_at_pos(&db, pos));\n+}"}, {"sha": "ce9a06fde4b94bec40f1f438dbcaf698d5e68f1d", "filename": "crates/ra_hir_ty/src/tests/method_resolution.rs", "status": "added", "additions": 1005, "deletions": 0, "changes": 1005, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -0,0 +1,1005 @@\n+use super::{infer, type_at, type_at_pos};\n+use crate::test_db::TestDB;\n+use insta::assert_snapshot;\n+use ra_db::fixture::WithFixture;\n+\n+#[test]\n+fn infer_slice_method() {\n+    assert_snapshot!(\n+        infer(r#\"\n+#[lang = \"slice\"]\n+impl<T> [T] {\n+    fn foo(&self) -> T {\n+        loop {}\n+    }\n+}\n+\n+#[lang = \"slice_alloc\"]\n+impl<T> [T] {}\n+\n+fn test() {\n+    <[_]>::foo(b\"foo\");\n+}\n+\"#),\n+        @r###\"\n+    [45; 49) 'self': &[T]\n+    [56; 79) '{     ...     }': T\n+    [66; 73) 'loop {}': !\n+    [71; 73) '{}': ()\n+    [133; 160) '{     ...o\"); }': ()\n+    [139; 149) '<[_]>::foo': fn foo<u8>(&[T]) -> T\n+    [139; 157) '<[_]>:...\"foo\")': u8\n+    [150; 156) 'b\"foo\"': &[u8]\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_associated_method_struct() {\n+    assert_snapshot!(\n+        infer(r#\"\n+struct A { x: u32 }\n+\n+impl A {\n+    fn new() -> A {\n+        A { x: 0 }\n+    }\n+}\n+fn test() {\n+    let a = A::new();\n+    a.x;\n+}\n+\"#),\n+        @r###\"\n+    [49; 75) '{     ...     }': A\n+    [59; 69) 'A { x: 0 }': A\n+    [66; 67) '0': u32\n+    [88; 122) '{     ...a.x; }': ()\n+    [98; 99) 'a': A\n+    [102; 108) 'A::new': fn new() -> A\n+    [102; 110) 'A::new()': A\n+    [116; 117) 'a': A\n+    [116; 119) 'a.x': u32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_associated_method_enum() {\n+    assert_snapshot!(\n+        infer(r#\"\n+enum A { B, C }\n+\n+impl A {\n+    pub fn b() -> A {\n+        A::B\n+    }\n+    pub fn c() -> A {\n+        A::C\n+    }\n+}\n+fn test() {\n+    let a = A::b();\n+    a;\n+    let c = A::c();\n+    c;\n+}\n+\"#),\n+        @r###\"\n+    [47; 67) '{     ...     }': A\n+    [57; 61) 'A::B': A\n+    [88; 108) '{     ...     }': A\n+    [98; 102) 'A::C': A\n+    [121; 178) '{     ...  c; }': ()\n+    [131; 132) 'a': A\n+    [135; 139) 'A::b': fn b() -> A\n+    [135; 141) 'A::b()': A\n+    [147; 148) 'a': A\n+    [158; 159) 'c': A\n+    [162; 166) 'A::c': fn c() -> A\n+    [162; 168) 'A::c()': A\n+    [174; 175) 'c': A\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_associated_method_with_modules() {\n+    assert_snapshot!(\n+        infer(r#\"\n+mod a {\n+    struct A;\n+    impl A { pub fn thing() -> A { A {} }}\n+}\n+\n+mod b {\n+    struct B;\n+    impl B { pub fn thing() -> u32 { 99 }}\n+\n+    mod c {\n+        struct C;\n+        impl C { pub fn thing() -> C { C {} }}\n+    }\n+}\n+use b::c;\n+\n+fn test() {\n+    let x = a::A::thing();\n+    let y = b::B::thing();\n+    let z = c::C::thing();\n+}\n+\"#),\n+        @r###\"\n+    [56; 64) '{ A {} }': A\n+    [58; 62) 'A {}': A\n+    [126; 132) '{ 99 }': u32\n+    [128; 130) '99': u32\n+    [202; 210) '{ C {} }': C\n+    [204; 208) 'C {}': C\n+    [241; 325) '{     ...g(); }': ()\n+    [251; 252) 'x': A\n+    [255; 266) 'a::A::thing': fn thing() -> A\n+    [255; 268) 'a::A::thing()': A\n+    [278; 279) 'y': u32\n+    [282; 293) 'b::B::thing': fn thing() -> u32\n+    [282; 295) 'b::B::thing()': u32\n+    [305; 306) 'z': C\n+    [309; 320) 'c::C::thing': fn thing() -> C\n+    [309; 322) 'c::C::thing()': C\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_associated_method_generics() {\n+    assert_snapshot!(\n+        infer(r#\"\n+struct Gen<T> {\n+    val: T\n+}\n+\n+impl<T> Gen<T> {\n+    pub fn make(val: T) -> Gen<T> {\n+        Gen { val }\n+    }\n+}\n+\n+fn test() {\n+    let a = Gen::make(0u32);\n+}\n+\"#),\n+        @r###\"\n+    [64; 67) 'val': T\n+    [82; 109) '{     ...     }': Gen<T>\n+    [92; 103) 'Gen { val }': Gen<T>\n+    [98; 101) 'val': T\n+    [123; 155) '{     ...32); }': ()\n+    [133; 134) 'a': Gen<u32>\n+    [137; 146) 'Gen::make': fn make<u32>(T) -> Gen<T>\n+    [137; 152) 'Gen::make(0u32)': Gen<u32>\n+    [147; 151) '0u32': u32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_associated_method_generics_with_default_param() {\n+    assert_snapshot!(\n+        infer(r#\"\n+struct Gen<T=u32> {\n+    val: T\n+}\n+\n+impl<T> Gen<T> {\n+    pub fn make() -> Gen<T> {\n+        loop { }\n+    }\n+}\n+\n+fn test() {\n+    let a = Gen::make();\n+}\n+\"#),\n+        @r###\"\n+    [80; 104) '{     ...     }': Gen<T>\n+    [90; 98) 'loop { }': !\n+    [95; 98) '{ }': ()\n+    [118; 146) '{     ...e(); }': ()\n+    [128; 129) 'a': Gen<u32>\n+    [132; 141) 'Gen::make': fn make<u32>() -> Gen<T>\n+    [132; 143) 'Gen::make()': Gen<u32>\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_associated_method_generics_with_default_tuple_param() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+struct Gen<T=()> {\n+    val: T\n+}\n+\n+impl<T> Gen<T> {\n+    pub fn make() -> Gen<T> {\n+        loop { }\n+    }\n+}\n+\n+fn test() {\n+    let a = Gen::make();\n+    a.val<|>;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"()\");\n+}\n+\n+#[test]\n+fn infer_associated_method_generics_without_args() {\n+    assert_snapshot!(\n+        infer(r#\"\n+struct Gen<T> {\n+    val: T\n+}\n+\n+impl<T> Gen<T> {\n+    pub fn make() -> Gen<T> {\n+        loop { }\n+    }\n+}\n+\n+fn test() {\n+    let a = Gen::<u32>::make();\n+}\n+\"#),\n+        @r###\"\n+    [76; 100) '{     ...     }': Gen<T>\n+    [86; 94) 'loop { }': !\n+    [91; 94) '{ }': ()\n+    [114; 149) '{     ...e(); }': ()\n+    [124; 125) 'a': Gen<u32>\n+    [128; 144) 'Gen::<...::make': fn make<u32>() -> Gen<T>\n+    [128; 146) 'Gen::<...make()': Gen<u32>\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_associated_method_generics_2_type_params_without_args() {\n+    assert_snapshot!(\n+        infer(r#\"\n+struct Gen<T, U> {\n+    val: T,\n+    val2: U,\n+}\n+\n+impl<T> Gen<u32, T> {\n+    pub fn make() -> Gen<u32,T> {\n+        loop { }\n+    }\n+}\n+\n+fn test() {\n+    let a = Gen::<u32, u64>::make();\n+}\n+\"#),\n+        @r###\"\n+    [102; 126) '{     ...     }': Gen<u32, T>\n+    [112; 120) 'loop { }': !\n+    [117; 120) '{ }': ()\n+    [140; 180) '{     ...e(); }': ()\n+    [150; 151) 'a': Gen<u32, u64>\n+    [154; 175) 'Gen::<...::make': fn make<u64>() -> Gen<u32, T>\n+    [154; 177) 'Gen::<...make()': Gen<u32, u64>\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn cross_crate_associated_method_call() {\n+    let (db, pos) = TestDB::with_position(\n+        r#\"\n+//- /main.rs crate:main deps:other_crate\n+fn test() {\n+    let x = other_crate::foo::S::thing();\n+    x<|>;\n+}\n+\n+//- /lib.rs crate:other_crate\n+mod foo {\n+    struct S;\n+    impl S {\n+        fn thing() -> i128 {}\n+    }\n+}\n+\"#,\n+    );\n+    assert_eq!(\"i128\", type_at_pos(&db, pos));\n+}\n+\n+#[test]\n+fn infer_trait_method_simple() {\n+    // the trait implementation is intentionally incomplete -- it shouldn't matter\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Trait1 {\n+    fn method(&self) -> u32;\n+}\n+struct S1;\n+impl Trait1 for S1 {}\n+trait Trait2 {\n+    fn method(&self) -> i128;\n+}\n+struct S2;\n+impl Trait2 for S2 {}\n+fn test() {\n+    S1.method(); // -> u32\n+    S2.method(); // -> i128\n+}\n+\"#),\n+        @r###\"\n+    [31; 35) 'self': &Self\n+    [110; 114) 'self': &Self\n+    [170; 228) '{     ...i128 }': ()\n+    [176; 178) 'S1': S1\n+    [176; 187) 'S1.method()': u32\n+    [203; 205) 'S2': S2\n+    [203; 214) 'S2.method()': i128\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_trait_method_scoped() {\n+    // the trait implementation is intentionally incomplete -- it shouldn't matter\n+    assert_snapshot!(\n+        infer(r#\"\n+struct S;\n+mod foo {\n+    pub trait Trait1 {\n+        fn method(&self) -> u32;\n+    }\n+    impl Trait1 for super::S {}\n+}\n+mod bar {\n+    pub trait Trait2 {\n+        fn method(&self) -> i128;\n+    }\n+    impl Trait2 for super::S {}\n+}\n+\n+mod foo_test {\n+    use super::S;\n+    use super::foo::Trait1;\n+    fn test() {\n+        S.method(); // -> u32\n+    }\n+}\n+\n+mod bar_test {\n+    use super::S;\n+    use super::bar::Trait2;\n+    fn test() {\n+        S.method(); // -> i128\n+    }\n+}\n+\"#),\n+        @r###\"\n+    [63; 67) 'self': &Self\n+    [169; 173) 'self': &Self\n+    [300; 337) '{     ...     }': ()\n+    [310; 311) 'S': S\n+    [310; 320) 'S.method()': u32\n+    [416; 454) '{     ...     }': ()\n+    [426; 427) 'S': S\n+    [426; 436) 'S.method()': i128\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_trait_method_generic_1() {\n+    // the trait implementation is intentionally incomplete -- it shouldn't matter\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Trait<T> {\n+    fn method(&self) -> T;\n+}\n+struct S;\n+impl Trait<u32> for S {}\n+fn test() {\n+    S.method();\n+}\n+\"#),\n+        @r###\"\n+    [33; 37) 'self': &Self\n+    [92; 111) '{     ...d(); }': ()\n+    [98; 99) 'S': S\n+    [98; 108) 'S.method()': u32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_trait_method_generic_more_params() {\n+    // the trait implementation is intentionally incomplete -- it shouldn't matter\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Trait<T1, T2, T3> {\n+    fn method1(&self) -> (T1, T2, T3);\n+    fn method2(&self) -> (T3, T2, T1);\n+}\n+struct S1;\n+impl Trait<u8, u16, u32> for S1 {}\n+struct S2;\n+impl<T> Trait<i8, i16, T> for S2 {}\n+fn test() {\n+    S1.method1(); // u8, u16, u32\n+    S1.method2(); // u32, u16, u8\n+    S2.method1(); // i8, i16, {unknown}\n+    S2.method2(); // {unknown}, i16, i8\n+}\n+\"#),\n+        @r###\"\n+    [43; 47) 'self': &Self\n+    [82; 86) 'self': &Self\n+    [210; 361) '{     ..., i8 }': ()\n+    [216; 218) 'S1': S1\n+    [216; 228) 'S1.method1()': (u8, u16, u32)\n+    [250; 252) 'S1': S1\n+    [250; 262) 'S1.method2()': (u32, u16, u8)\n+    [284; 286) 'S2': S2\n+    [284; 296) 'S2.method1()': (i8, i16, {unknown})\n+    [324; 326) 'S2': S2\n+    [324; 336) 'S2.method2()': ({unknown}, i16, i8)\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_trait_method_generic_2() {\n+    // the trait implementation is intentionally incomplete -- it shouldn't matter\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Trait<T> {\n+    fn method(&self) -> T;\n+}\n+struct S<T>(T);\n+impl<U> Trait<U> for S<U> {}\n+fn test() {\n+    S(1u32).method();\n+}\n+\"#),\n+        @r###\"\n+    [33; 37) 'self': &Self\n+    [102; 127) '{     ...d(); }': ()\n+    [108; 109) 'S': S<u32>(T) -> S<T>\n+    [108; 115) 'S(1u32)': S<u32>\n+    [108; 124) 'S(1u32...thod()': u32\n+    [110; 114) '1u32': u32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_trait_assoc_method() {\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Default {\n+    fn default() -> Self;\n+}\n+struct S;\n+impl Default for S {}\n+fn test() {\n+    let s1: S = Default::default();\n+    let s2 = S::default();\n+    let s3 = <S as Default>::default();\n+}\n+\"#),\n+        @r###\"\n+    [87; 193) '{     ...t(); }': ()\n+    [97; 99) 's1': S\n+    [105; 121) 'Defaul...efault': fn default<S>() -> Self\n+    [105; 123) 'Defaul...ault()': S\n+    [133; 135) 's2': S\n+    [138; 148) 'S::default': fn default<S>() -> Self\n+    [138; 150) 'S::default()': S\n+    [160; 162) 's3': S\n+    [165; 188) '<S as ...efault': fn default<S>() -> Self\n+    [165; 190) '<S as ...ault()': S\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_trait_assoc_method_generics_1() {\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Trait<T> {\n+    fn make() -> T;\n+}\n+struct S;\n+impl Trait<u32> for S {}\n+struct G<T>;\n+impl<T> Trait<T> for G<T> {}\n+fn test() {\n+    let a = S::make();\n+    let b = G::<u64>::make();\n+    let c: f64 = G::make();\n+}\n+\"#),\n+        @r###\"\n+    [127; 211) '{     ...e(); }': ()\n+    [137; 138) 'a': u32\n+    [141; 148) 'S::make': fn make<S, u32>() -> T\n+    [141; 150) 'S::make()': u32\n+    [160; 161) 'b': u64\n+    [164; 178) 'G::<u64>::make': fn make<G<u64>, u64>() -> T\n+    [164; 180) 'G::<u6...make()': u64\n+    [190; 191) 'c': f64\n+    [199; 206) 'G::make': fn make<G<f64>, f64>() -> T\n+    [199; 208) 'G::make()': f64\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_trait_assoc_method_generics_2() {\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Trait<T> {\n+    fn make<U>() -> (T, U);\n+}\n+struct S;\n+impl Trait<u32> for S {}\n+struct G<T>;\n+impl<T> Trait<T> for G<T> {}\n+fn test() {\n+    let a = S::make::<i64>();\n+    let b: (_, i64) = S::make();\n+    let c = G::<u32>::make::<i64>();\n+    let d: (u32, _) = G::make::<i64>();\n+    let e: (u32, i64) = G::make();\n+}\n+\"#),\n+        @r###\"\n+    [135; 313) '{     ...e(); }': ()\n+    [145; 146) 'a': (u32, i64)\n+    [149; 163) 'S::make::<i64>': fn make<S, u32, i64>() -> (T, U)\n+    [149; 165) 'S::mak...i64>()': (u32, i64)\n+    [175; 176) 'b': (u32, i64)\n+    [189; 196) 'S::make': fn make<S, u32, i64>() -> (T, U)\n+    [189; 198) 'S::make()': (u32, i64)\n+    [208; 209) 'c': (u32, i64)\n+    [212; 233) 'G::<u3...:<i64>': fn make<G<u32>, u32, i64>() -> (T, U)\n+    [212; 235) 'G::<u3...i64>()': (u32, i64)\n+    [245; 246) 'd': (u32, i64)\n+    [259; 273) 'G::make::<i64>': fn make<G<u32>, u32, i64>() -> (T, U)\n+    [259; 275) 'G::mak...i64>()': (u32, i64)\n+    [285; 286) 'e': (u32, i64)\n+    [301; 308) 'G::make': fn make<G<u32>, u32, i64>() -> (T, U)\n+    [301; 310) 'G::make()': (u32, i64)\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_trait_assoc_method_generics_3() {\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Trait<T> {\n+    fn make() -> (Self, T);\n+}\n+struct S<T>;\n+impl Trait<i64> for S<i32> {}\n+fn test() {\n+    let a = S::make();\n+}\n+\"#),\n+        @r###\"\n+    [101; 127) '{     ...e(); }': ()\n+    [111; 112) 'a': (S<i32>, i64)\n+    [115; 122) 'S::make': fn make<S<i32>, i64>() -> (Self, T)\n+    [115; 124) 'S::make()': (S<i32>, i64)\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_trait_assoc_method_generics_4() {\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Trait<T> {\n+    fn make() -> (Self, T);\n+}\n+struct S<T>;\n+impl Trait<i64> for S<u64> {}\n+impl Trait<i32> for S<u32> {}\n+fn test() {\n+    let a: (S<u64>, _) = S::make();\n+    let b: (_, i32) = S::make();\n+}\n+\"#),\n+        @r###\"\n+    [131; 203) '{     ...e(); }': ()\n+    [141; 142) 'a': (S<u64>, i64)\n+    [158; 165) 'S::make': fn make<S<u64>, i64>() -> (Self, T)\n+    [158; 167) 'S::make()': (S<u64>, i64)\n+    [177; 178) 'b': (S<u32>, i32)\n+    [191; 198) 'S::make': fn make<S<u32>, i32>() -> (Self, T)\n+    [191; 200) 'S::make()': (S<u32>, i32)\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_trait_assoc_method_generics_5() {\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Trait<T> {\n+    fn make<U>() -> (Self, T, U);\n+}\n+struct S<T>;\n+impl Trait<i64> for S<u64> {}\n+fn test() {\n+    let a = <S as Trait<i64>>::make::<u8>();\n+    let b: (S<u64>, _, _) = Trait::<i64>::make::<u8>();\n+}\n+\"#),\n+        @r###\"\n+    [107; 211) '{     ...>(); }': ()\n+    [117; 118) 'a': (S<u64>, i64, u8)\n+    [121; 150) '<S as ...::<u8>': fn make<S<u64>, i64, u8>() -> (Self, T, U)\n+    [121; 152) '<S as ...<u8>()': (S<u64>, i64, u8)\n+    [162; 163) 'b': (S<u64>, i64, u8)\n+    [182; 206) 'Trait:...::<u8>': fn make<S<u64>, i64, u8>() -> (Self, T, U)\n+    [182; 208) 'Trait:...<u8>()': (S<u64>, i64, u8)\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_call_trait_method_on_generic_param_1() {\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Trait {\n+    fn method(&self) -> u32;\n+}\n+fn test<T: Trait>(t: T) {\n+    t.method();\n+}\n+\"#),\n+        @r###\"\n+    [30; 34) 'self': &Self\n+    [64; 65) 't': T\n+    [70; 89) '{     ...d(); }': ()\n+    [76; 77) 't': T\n+    [76; 86) 't.method()': u32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_call_trait_method_on_generic_param_2() {\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Trait<T> {\n+    fn method(&self) -> T;\n+}\n+fn test<U, T: Trait<U>>(t: T) {\n+    t.method();\n+}\n+\"#),\n+        @r###\"\n+    [33; 37) 'self': &Self\n+    [71; 72) 't': T\n+    [77; 96) '{     ...d(); }': ()\n+    [83; 84) 't': T\n+    [83; 93) 't.method()': [missing name]\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_with_multiple_trait_impls() {\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Into<T> {\n+    fn into(self) -> T;\n+}\n+struct S;\n+impl Into<u32> for S {}\n+impl Into<u64> for S {}\n+fn test() {\n+    let x: u32 = S.into();\n+    let y: u64 = S.into();\n+    let z = Into::<u64>::into(S);\n+}\n+\"#),\n+        @r###\"\n+    [29; 33) 'self': Self\n+    [111; 202) '{     ...(S); }': ()\n+    [121; 122) 'x': u32\n+    [130; 131) 'S': S\n+    [130; 138) 'S.into()': u32\n+    [148; 149) 'y': u64\n+    [157; 158) 'S': S\n+    [157; 165) 'S.into()': u64\n+    [175; 176) 'z': u64\n+    [179; 196) 'Into::...::into': fn into<S, u64>(Self) -> T\n+    [179; 199) 'Into::...nto(S)': u64\n+    [197; 198) 'S': S\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn method_resolution_unify_impl_self_type() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+struct S<T>;\n+impl S<u32> { fn foo(&self) -> u8 {} }\n+impl S<i32> { fn foo(&self) -> i8 {} }\n+fn test() { (S::<u32>.foo(), S::<i32>.foo())<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"(u8, i8)\");\n+}\n+\n+#[test]\n+fn method_resolution_trait_before_autoref() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Trait { fn foo(self) -> u128; }\n+struct S;\n+impl S { fn foo(&self) -> i8 { 0 } }\n+impl Trait for S { fn foo(self) -> u128 { 0 } }\n+fn test() { S.foo()<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"u128\");\n+}\n+\n+#[test]\n+fn method_resolution_by_value_before_autoref() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Clone { fn clone(&self) -> Self; }\n+struct S;\n+impl Clone for S {}\n+impl Clone for &S {}\n+fn test() { (S.clone(), (&S).clone(), (&&S).clone())<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"(S, S, &S)\");\n+}\n+\n+#[test]\n+fn method_resolution_trait_before_autoderef() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Trait { fn foo(self) -> u128; }\n+struct S;\n+impl S { fn foo(self) -> i8 { 0 } }\n+impl Trait for &S { fn foo(self) -> u128 { 0 } }\n+fn test() { (&S).foo()<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"u128\");\n+}\n+\n+#[test]\n+fn method_resolution_impl_before_trait() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Trait { fn foo(self) -> u128; }\n+struct S;\n+impl S { fn foo(self) -> i8 { 0 } }\n+impl Trait for S { fn foo(self) -> u128 { 0 } }\n+fn test() { S.foo()<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"i8\");\n+}\n+\n+#[test]\n+fn method_resolution_impl_ref_before_trait() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Trait { fn foo(self) -> u128; }\n+struct S;\n+impl S { fn foo(&self) -> i8 { 0 } }\n+impl Trait for &S { fn foo(self) -> u128 { 0 } }\n+fn test() { S.foo()<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"i8\");\n+}\n+\n+#[test]\n+fn method_resolution_trait_autoderef() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Trait { fn foo(self) -> u128; }\n+struct S;\n+impl Trait for S { fn foo(self) -> u128 { 0 } }\n+fn test() { (&S).foo()<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"u128\");\n+}\n+\n+#[test]\n+fn method_resolution_trait_from_prelude() {\n+    let (db, pos) = TestDB::with_position(\n+        r#\"\n+//- /main.rs crate:main deps:other_crate\n+struct S;\n+impl Clone for S {}\n+\n+fn test() {\n+    S.clone()<|>;\n+}\n+\n+//- /lib.rs crate:other_crate\n+#[prelude_import] use foo::*;\n+\n+mod foo {\n+    trait Clone {\n+        fn clone(&self) -> Self;\n+    }\n+}\n+\"#,\n+    );\n+    assert_eq!(\"S\", type_at_pos(&db, pos));\n+}\n+\n+#[test]\n+fn method_resolution_where_clause_for_unknown_trait() {\n+    // The blanket impl currently applies because we ignore the unresolved where clause\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Trait { fn foo(self) -> u128; }\n+struct S;\n+impl<T> Trait for T where T: UnknownTrait {}\n+fn test() { (&S).foo()<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"u128\");\n+}\n+\n+#[test]\n+fn method_resolution_where_clause_not_met() {\n+    // The blanket impl shouldn't apply because we can't prove S: Clone\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Clone {}\n+trait Trait { fn foo(self) -> u128; }\n+struct S;\n+impl<T> Trait for T where T: Clone {}\n+fn test() { (&S).foo()<|>; }\n+\"#,\n+    );\n+    // This is also to make sure that we don't resolve to the foo method just\n+    // because that's the only method named foo we can find, which would make\n+    // the below tests not work\n+    assert_eq!(t, \"{unknown}\");\n+}\n+\n+#[test]\n+fn method_resolution_where_clause_inline_not_met() {\n+    // The blanket impl shouldn't apply because we can't prove S: Clone\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Clone {}\n+trait Trait { fn foo(self) -> u128; }\n+struct S;\n+impl<T: Clone> Trait for T {}\n+fn test() { (&S).foo()<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"{unknown}\");\n+}\n+\n+#[test]\n+fn method_resolution_where_clause_1() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Clone {}\n+trait Trait { fn foo(self) -> u128; }\n+struct S;\n+impl Clone for S {}\n+impl<T> Trait for T where T: Clone {}\n+fn test() { S.foo()<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"u128\");\n+}\n+\n+#[test]\n+fn method_resolution_where_clause_2() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Into<T> { fn into(self) -> T; }\n+trait From<T> { fn from(other: T) -> Self; }\n+struct S1;\n+struct S2;\n+impl From<S2> for S1 {}\n+impl<T, U> Into<U> for T where U: From<T> {}\n+fn test() { S2.into()<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"{unknown}\");\n+}\n+\n+#[test]\n+fn method_resolution_where_clause_inline() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Into<T> { fn into(self) -> T; }\n+trait From<T> { fn from(other: T) -> Self; }\n+struct S1;\n+struct S2;\n+impl From<S2> for S1 {}\n+impl<T, U: From<T>> Into<U> for T {}\n+fn test() { S2.into()<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"{unknown}\");\n+}\n+\n+#[test]\n+fn method_resolution_encountering_fn_type() {\n+    type_at(\n+        r#\"\n+//- /main.rs\n+fn foo() {}\n+trait FnOnce { fn call(self); }\n+fn test() { foo.call()<|>; }\n+\"#,\n+    );\n+}\n+\n+#[test]\n+fn method_resolution_slow() {\n+    // this can get quite slow if we set the solver size limit too high\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait SendX {}\n+\n+struct S1; impl SendX for S1 {}\n+struct S2; impl SendX for S2 {}\n+struct U1;\n+\n+trait Trait { fn method(self); }\n+\n+struct X1<A, B> {}\n+impl<A, B> SendX for X1<A, B> where A: SendX, B: SendX {}\n+\n+struct S<B, C> {}\n+\n+trait FnX {}\n+\n+impl<B, C> Trait for S<B, C> where C: FnX, B: SendX {}\n+\n+fn test() { (S {}).method()<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"()\");\n+}"}, {"sha": "cb3890b42396ae018650d155329968e1180f1080", "filename": "crates/ra_hir_ty/src/tests/patterns.rs", "status": "added", "additions": 238, "deletions": 0, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fpatterns.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -0,0 +1,238 @@\n+use super::infer;\n+use insta::assert_snapshot;\n+use test_utils::covers;\n+\n+#[test]\n+fn infer_pattern() {\n+    assert_snapshot!(\n+        infer(r#\"\n+fn test(x: &i32) {\n+    let y = x;\n+    let &z = x;\n+    let a = z;\n+    let (c, d) = (1, \"hello\");\n+\n+    for (e, f) in some_iter {\n+        let g = e;\n+    }\n+\n+    if let [val] = opt {\n+        let h = val;\n+    }\n+\n+    let lambda = |a: u64, b, c: i32| { a + b; c };\n+\n+    let ref ref_to_x = x;\n+    let mut mut_x = x;\n+    let ref mut mut_ref_to_x = x;\n+    let k = mut_ref_to_x;\n+}\n+\"#),\n+        @r###\"\n+    [9; 10) 'x': &i32\n+    [18; 369) '{     ...o_x; }': ()\n+    [28; 29) 'y': &i32\n+    [32; 33) 'x': &i32\n+    [43; 45) '&z': &i32\n+    [44; 45) 'z': i32\n+    [48; 49) 'x': &i32\n+    [59; 60) 'a': i32\n+    [63; 64) 'z': i32\n+    [74; 80) '(c, d)': (i32, &str)\n+    [75; 76) 'c': i32\n+    [78; 79) 'd': &str\n+    [83; 95) '(1, \"hello\")': (i32, &str)\n+    [84; 85) '1': i32\n+    [87; 94) '\"hello\"': &str\n+    [102; 152) 'for (e...     }': ()\n+    [106; 112) '(e, f)': ({unknown}, {unknown})\n+    [107; 108) 'e': {unknown}\n+    [110; 111) 'f': {unknown}\n+    [116; 125) 'some_iter': {unknown}\n+    [126; 152) '{     ...     }': ()\n+    [140; 141) 'g': {unknown}\n+    [144; 145) 'e': {unknown}\n+    [158; 205) 'if let...     }': ()\n+    [165; 170) '[val]': {unknown}\n+    [173; 176) 'opt': {unknown}\n+    [177; 205) '{     ...     }': ()\n+    [191; 192) 'h': {unknown}\n+    [195; 198) 'val': {unknown}\n+    [215; 221) 'lambda': |u64, u64, i32| -> i32\n+    [224; 256) '|a: u6...b; c }': |u64, u64, i32| -> i32\n+    [225; 226) 'a': u64\n+    [233; 234) 'b': u64\n+    [236; 237) 'c': i32\n+    [244; 256) '{ a + b; c }': i32\n+    [246; 247) 'a': u64\n+    [246; 251) 'a + b': u64\n+    [250; 251) 'b': u64\n+    [253; 254) 'c': i32\n+    [267; 279) 'ref ref_to_x': &&i32\n+    [282; 283) 'x': &i32\n+    [293; 302) 'mut mut_x': &i32\n+    [305; 306) 'x': &i32\n+    [316; 336) 'ref mu...f_to_x': &mut &i32\n+    [339; 340) 'x': &i32\n+    [350; 351) 'k': &mut &i32\n+    [354; 366) 'mut_ref_to_x': &mut &i32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_pattern_match_ergonomics() {\n+    assert_snapshot!(\n+        infer(r#\"\n+struct A<T>(T);\n+\n+fn test() {\n+    let A(n) = &A(1);\n+    let A(n) = &mut A(1);\n+}\n+\"#),\n+    @r###\"\n+    [28; 79) '{     ...(1); }': ()\n+    [38; 42) 'A(n)': A<i32>\n+    [40; 41) 'n': &i32\n+    [45; 50) '&A(1)': &A<i32>\n+    [46; 47) 'A': A<i32>(T) -> A<T>\n+    [46; 50) 'A(1)': A<i32>\n+    [48; 49) '1': i32\n+    [60; 64) 'A(n)': A<i32>\n+    [62; 63) 'n': &mut i32\n+    [67; 76) '&mut A(1)': &mut A<i32>\n+    [72; 73) 'A': A<i32>(T) -> A<T>\n+    [72; 76) 'A(1)': A<i32>\n+    [74; 75) '1': i32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_pattern_match_ergonomics_ref() {\n+    covers!(match_ergonomics_ref);\n+    assert_snapshot!(\n+        infer(r#\"\n+fn test() {\n+    let v = &(1, &2);\n+    let (_, &w) = v;\n+}\n+\"#),\n+    @r###\"\n+    [11; 57) '{     ...= v; }': ()\n+    [21; 22) 'v': &(i32, &i32)\n+    [25; 33) '&(1, &2)': &(i32, &i32)\n+    [26; 33) '(1, &2)': (i32, &i32)\n+    [27; 28) '1': i32\n+    [30; 32) '&2': &i32\n+    [31; 32) '2': i32\n+    [43; 50) '(_, &w)': (i32, &i32)\n+    [44; 45) '_': i32\n+    [47; 49) '&w': &i32\n+    [48; 49) 'w': i32\n+    [53; 54) 'v': &(i32, &i32)\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_adt_pattern() {\n+    assert_snapshot!(\n+        infer(r#\"\n+enum E {\n+    A { x: usize },\n+    B\n+}\n+\n+struct S(u32, E);\n+\n+fn test() {\n+    let e = E::A { x: 3 };\n+\n+    let S(y, z) = foo;\n+    let E::A { x: new_var } = e;\n+\n+    match e {\n+        E::A { x } => x,\n+        E::B if foo => 1,\n+        E::B => 10,\n+    };\n+\n+    let ref d @ E::A { .. } = e;\n+    d;\n+}\n+\"#),\n+        @r###\"\n+    [68; 289) '{     ...  d; }': ()\n+    [78; 79) 'e': E\n+    [82; 95) 'E::A { x: 3 }': E\n+    [92; 93) '3': usize\n+    [106; 113) 'S(y, z)': S\n+    [108; 109) 'y': u32\n+    [111; 112) 'z': E\n+    [116; 119) 'foo': S\n+    [129; 148) 'E::A {..._var }': E\n+    [139; 146) 'new_var': usize\n+    [151; 152) 'e': E\n+    [159; 245) 'match ...     }': usize\n+    [165; 166) 'e': E\n+    [177; 187) 'E::A { x }': E\n+    [184; 185) 'x': usize\n+    [191; 192) 'x': usize\n+    [202; 206) 'E::B': E\n+    [210; 213) 'foo': bool\n+    [217; 218) '1': usize\n+    [228; 232) 'E::B': E\n+    [236; 238) '10': usize\n+    [256; 275) 'ref d ...{ .. }': &E\n+    [264; 275) 'E::A { .. }': E\n+    [278; 279) 'e': E\n+    [285; 286) 'd': &E\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_generics_in_patterns() {\n+    assert_snapshot!(\n+        infer(r#\"\n+struct A<T> {\n+    x: T,\n+}\n+\n+enum Option<T> {\n+    Some(T),\n+    None,\n+}\n+\n+fn test(a1: A<u32>, o: Option<u64>) {\n+    let A { x: x2 } = a1;\n+    let A::<i64> { x: x3 } = A { x: 1 };\n+    match o {\n+        Option::Some(t) => t,\n+        _ => 1,\n+    };\n+}\n+\"#),\n+        @r###\"\n+    [79; 81) 'a1': A<u32>\n+    [91; 92) 'o': Option<u64>\n+    [107; 244) '{     ...  }; }': ()\n+    [117; 128) 'A { x: x2 }': A<u32>\n+    [124; 126) 'x2': u32\n+    [131; 133) 'a1': A<u32>\n+    [143; 161) 'A::<i6...: x3 }': A<i64>\n+    [157; 159) 'x3': i64\n+    [164; 174) 'A { x: 1 }': A<i64>\n+    [171; 172) '1': i64\n+    [180; 241) 'match ...     }': u64\n+    [186; 187) 'o': Option<u64>\n+    [198; 213) 'Option::Some(t)': Option<u64>\n+    [211; 212) 't': u64\n+    [217; 218) 't': u64\n+    [228; 229) '_': Option<u64>\n+    [233; 234) '1': u64\n+    \"###\n+    );\n+}"}, {"sha": "09d684ac2af58e3e4244c66b86d4bf11d1df8ff8", "filename": "crates/ra_hir_ty/src/tests/regression.rs", "status": "added", "additions": 333, "deletions": 0, "changes": 333, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fregression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fregression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fregression.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -0,0 +1,333 @@\n+use super::infer;\n+use insta::assert_snapshot;\n+use test_utils::covers;\n+\n+#[test]\n+fn bug_484() {\n+    assert_snapshot!(\n+        infer(r#\"\n+fn test() {\n+   let x = if true {};\n+}\n+\"#),\n+        @r###\"\n+    [11; 37) '{    l... {}; }': ()\n+    [20; 21) 'x': ()\n+    [24; 34) 'if true {}': ()\n+    [27; 31) 'true': bool\n+    [32; 34) '{}': ()\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn no_panic_on_field_of_enum() {\n+    assert_snapshot!(\n+        infer(r#\"\n+enum X {}\n+\n+fn test(x: X) {\n+    x.some_field;\n+}\n+\"#),\n+        @r###\"\n+    [20; 21) 'x': X\n+    [26; 47) '{     ...eld; }': ()\n+    [32; 33) 'x': X\n+    [32; 44) 'x.some_field': {unknown}\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn bug_585() {\n+    assert_snapshot!(\n+        infer(r#\"\n+fn test() {\n+    X {};\n+    match x {\n+        A::B {} => (),\n+        A::Y() => (),\n+    }\n+}\n+\"#),\n+        @r###\"\n+    [11; 89) '{     ...   } }': ()\n+    [17; 21) 'X {}': {unknown}\n+    [27; 87) 'match ...     }': ()\n+    [33; 34) 'x': {unknown}\n+    [45; 52) 'A::B {}': {unknown}\n+    [56; 58) '()': ()\n+    [68; 74) 'A::Y()': {unknown}\n+    [78; 80) '()': ()\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn bug_651() {\n+    assert_snapshot!(\n+        infer(r#\"\n+fn quux() {\n+    let y = 92;\n+    1 + y;\n+}\n+\"#),\n+        @r###\"\n+    [11; 41) '{     ...+ y; }': ()\n+    [21; 22) 'y': i32\n+    [25; 27) '92': i32\n+    [33; 34) '1': i32\n+    [33; 38) '1 + y': i32\n+    [37; 38) 'y': i32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn recursive_vars() {\n+    covers!(type_var_cycles_resolve_completely);\n+    covers!(type_var_cycles_resolve_as_possible);\n+    assert_snapshot!(\n+        infer(r#\"\n+fn test() {\n+    let y = unknown;\n+    [y, &y];\n+}\n+\"#),\n+        @r###\"\n+    [11; 48) '{     ...&y]; }': ()\n+    [21; 22) 'y': &{unknown}\n+    [25; 32) 'unknown': &{unknown}\n+    [38; 45) '[y, &y]': [&&{unknown};_]\n+    [39; 40) 'y': &{unknown}\n+    [42; 44) '&y': &&{unknown}\n+    [43; 44) 'y': &{unknown}\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn recursive_vars_2() {\n+    covers!(type_var_cycles_resolve_completely);\n+    covers!(type_var_cycles_resolve_as_possible);\n+    assert_snapshot!(\n+        infer(r#\"\n+fn test() {\n+    let x = unknown;\n+    let y = unknown;\n+    [(x, y), (&y, &x)];\n+}\n+\"#),\n+        @r###\"\n+    [11; 80) '{     ...x)]; }': ()\n+    [21; 22) 'x': &&{unknown}\n+    [25; 32) 'unknown': &&{unknown}\n+    [42; 43) 'y': &&{unknown}\n+    [46; 53) 'unknown': &&{unknown}\n+    [59; 77) '[(x, y..., &x)]': [(&&&{unknown}, &&&{unknown});_]\n+    [60; 66) '(x, y)': (&&&{unknown}, &&&{unknown})\n+    [61; 62) 'x': &&{unknown}\n+    [64; 65) 'y': &&{unknown}\n+    [68; 76) '(&y, &x)': (&&&{unknown}, &&&{unknown})\n+    [69; 71) '&y': &&&{unknown}\n+    [70; 71) 'y': &&{unknown}\n+    [73; 75) '&x': &&&{unknown}\n+    [74; 75) 'x': &&{unknown}\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_std_crash_1() {\n+    // caused stack overflow, taken from std\n+    assert_snapshot!(\n+        infer(r#\"\n+enum Maybe<T> {\n+    Real(T),\n+    Fake,\n+}\n+\n+fn write() {\n+    match something_unknown {\n+        Maybe::Real(ref mut something) => (),\n+    }\n+}\n+\"#),\n+        @r###\"\n+    [54; 139) '{     ...   } }': ()\n+    [60; 137) 'match ...     }': ()\n+    [66; 83) 'someth...nknown': Maybe<{unknown}>\n+    [94; 124) 'Maybe:...thing)': Maybe<{unknown}>\n+    [106; 123) 'ref mu...ething': &mut {unknown}\n+    [128; 130) '()': ()\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_std_crash_2() {\n+    covers!(type_var_resolves_to_int_var);\n+    // caused \"equating two type variables, ...\", taken from std\n+    assert_snapshot!(\n+        infer(r#\"\n+fn test_line_buffer() {\n+    &[0, b'\\n', 1, b'\\n'];\n+}\n+\"#),\n+        @r###\"\n+    [23; 53) '{     ...n']; }': ()\n+    [29; 50) '&[0, b...b'\\n']': &[u8;_]\n+    [30; 50) '[0, b'...b'\\n']': [u8;_]\n+    [31; 32) '0': u8\n+    [34; 39) 'b'\\n'': u8\n+    [41; 42) '1': u8\n+    [44; 49) 'b'\\n'': u8\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_std_crash_3() {\n+    // taken from rustc\n+    assert_snapshot!(\n+        infer(r#\"\n+pub fn compute() {\n+    match nope!() {\n+        SizeSkeleton::Pointer { non_zero: true, tail } => {}\n+    }\n+}\n+\"#),\n+        @r###\"\n+    [18; 108) '{     ...   } }': ()\n+    [24; 106) 'match ...     }': ()\n+    [30; 37) 'nope!()': {unknown}\n+    [48; 94) 'SizeSk...tail }': {unknown}\n+    [82; 86) 'true': {unknown}\n+    [88; 92) 'tail': {unknown}\n+    [98; 100) '{}': ()\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_std_crash_4() {\n+    // taken from rustc\n+    assert_snapshot!(\n+        infer(r#\"\n+pub fn primitive_type() {\n+    match *self {\n+        BorrowedRef { type_: Primitive(p), ..} => {},\n+    }\n+}\n+\"#),\n+        @r###\"\n+    [25; 106) '{     ...   } }': ()\n+    [31; 104) 'match ...     }': ()\n+    [37; 42) '*self': {unknown}\n+    [38; 42) 'self': {unknown}\n+    [53; 91) 'Borrow...), ..}': {unknown}\n+    [74; 86) 'Primitive(p)': {unknown}\n+    [84; 85) 'p': {unknown}\n+    [95; 97) '{}': ()\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_std_crash_5() {\n+    // taken from rustc\n+    assert_snapshot!(\n+        infer(r#\"\n+fn extra_compiler_flags() {\n+    for content in doesnt_matter {\n+        let name = if doesnt_matter {\n+            first\n+        } else {\n+            &content\n+        };\n+\n+        let content = if ICE_REPORT_COMPILER_FLAGS_STRIP_VALUE.contains(&name) {\n+            name\n+        } else {\n+            content\n+        };\n+    }\n+}\n+\"#),\n+        @r###\"\n+    [27; 323) '{     ...   } }': ()\n+    [33; 321) 'for co...     }': ()\n+    [37; 44) 'content': &{unknown}\n+    [48; 61) 'doesnt_matter': {unknown}\n+    [62; 321) '{     ...     }': ()\n+    [76; 80) 'name': &&{unknown}\n+    [83; 167) 'if doe...     }': &&{unknown}\n+    [86; 99) 'doesnt_matter': bool\n+    [100; 129) '{     ...     }': &&{unknown}\n+    [114; 119) 'first': &&{unknown}\n+    [135; 167) '{     ...     }': &&{unknown}\n+    [149; 157) '&content': &&{unknown}\n+    [150; 157) 'content': &{unknown}\n+    [182; 189) 'content': &{unknown}\n+    [192; 314) 'if ICE...     }': &{unknown}\n+    [195; 232) 'ICE_RE..._VALUE': {unknown}\n+    [195; 248) 'ICE_RE...&name)': bool\n+    [242; 247) '&name': &&&{unknown}\n+    [243; 247) 'name': &&{unknown}\n+    [249; 277) '{     ...     }': &&{unknown}\n+    [263; 267) 'name': &&{unknown}\n+    [283; 314) '{     ...     }': &{unknown}\n+    [297; 304) 'content': &{unknown}\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_nested_generics_crash() {\n+    // another crash found typechecking rustc\n+    assert_snapshot!(\n+        infer(r#\"\n+struct Canonical<V> {\n+    value: V,\n+}\n+struct QueryResponse<V> {\n+    value: V,\n+}\n+fn test<R>(query_response: Canonical<QueryResponse<R>>) {\n+    &query_response.value;\n+}\n+\"#),\n+        @r###\"\n+    [92; 106) 'query_response': Canonical<QueryResponse<R>>\n+    [137; 167) '{     ...lue; }': ()\n+    [143; 164) '&query....value': &QueryResponse<R>\n+    [144; 158) 'query_response': Canonical<QueryResponse<R>>\n+    [144; 164) 'query_....value': QueryResponse<R>\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn bug_1030() {\n+    assert_snapshot!(infer(r#\"\n+struct HashSet<T, H>;\n+struct FxHasher;\n+type FxHashSet<T> = HashSet<T, FxHasher>;\n+\n+impl<T, H> HashSet<T, H> {\n+    fn default() -> HashSet<T, H> {}\n+}\n+\n+pub fn main_loop() {\n+    FxHashSet::default();\n+}\n+\"#),\n+    @r###\"\n+    [144; 146) '{}': ()\n+    [169; 198) '{     ...t(); }': ()\n+    [175; 193) 'FxHash...efault': fn default<{unknown}, FxHasher>() -> HashSet<T, H>\n+    [175; 195) 'FxHash...ault()': HashSet<{unknown}, FxHasher>\n+    \"###\n+    );\n+}"}, {"sha": "3e5e163e3486c55c8896cf5ae0035b4691dd0952", "filename": "crates/ra_hir_ty/src/tests/simple.rs", "status": "added", "additions": 1663, "deletions": 0, "changes": 1663, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fsimple.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -0,0 +1,1663 @@\n+use super::{infer, type_at, type_at_pos};\n+use crate::test_db::TestDB;\n+use insta::assert_snapshot;\n+use ra_db::fixture::WithFixture;\n+\n+#[test]\n+fn infer_box() {\n+    let (db, pos) = TestDB::with_position(\n+        r#\"\n+//- /main.rs crate:main deps:std\n+\n+fn test() {\n+    let x = box 1;\n+    let t = (x, box x, box &1, box [1]);\n+    t<|>;\n+}\n+\n+//- /std.rs crate:std\n+#[prelude_import] use prelude::*;\n+mod prelude {}\n+\n+mod boxed {\n+    pub struct Box<T: ?Sized> {\n+        inner: *mut T,\n+    }\n+}\n+\n+\"#,\n+    );\n+    assert_eq!(\"(Box<i32>, Box<Box<i32>>, Box<&i32>, Box<[i32;_]>)\", type_at_pos(&db, pos));\n+}\n+\n+#[test]\n+fn infer_adt_self() {\n+    let (db, pos) = TestDB::with_position(\n+        r#\"\n+//- /main.rs\n+enum Nat { Succ(Self), Demo(Nat), Zero }\n+\n+fn test() {\n+    let foo: Nat = Nat::Zero;\n+    if let Nat::Succ(x) = foo {\n+        x<|>\n+    }\n+}\n+\n+\"#,\n+    );\n+    assert_eq!(\"Nat\", type_at_pos(&db, pos));\n+}\n+\n+#[test]\n+fn infer_ranges() {\n+    let (db, pos) = TestDB::with_position(\n+        r#\"\n+//- /main.rs crate:main deps:std\n+fn test() {\n+    let a = ..;\n+    let b = 1..;\n+    let c = ..2u32;\n+    let d = 1..2usize;\n+    let e = ..=10;\n+    let f = 'a'..='z';\n+\n+    let t = (a, b, c, d, e, f);\n+    t<|>;\n+}\n+\n+//- /std.rs crate:std\n+#[prelude_import] use prelude::*;\n+mod prelude {}\n+\n+pub mod ops {\n+    pub struct Range<Idx> {\n+        pub start: Idx,\n+        pub end: Idx,\n+    }\n+    pub struct RangeFrom<Idx> {\n+        pub start: Idx,\n+    }\n+    struct RangeFull;\n+    pub struct RangeInclusive<Idx> {\n+        start: Idx,\n+        end: Idx,\n+        is_empty: u8,\n+    }\n+    pub struct RangeTo<Idx> {\n+        pub end: Idx,\n+    }\n+    pub struct RangeToInclusive<Idx> {\n+        pub end: Idx,\n+    }\n+}\n+\"#,\n+    );\n+    assert_eq!(\n+        \"(RangeFull, RangeFrom<i32>, RangeTo<u32>, Range<usize>, RangeToInclusive<i32>, RangeInclusive<char>)\",\n+        type_at_pos(&db, pos),\n+    );\n+}\n+\n+#[test]\n+fn infer_while_let() {\n+    let (db, pos) = TestDB::with_position(\n+        r#\"\n+//- /main.rs\n+enum Option<T> { Some(T), None }\n+\n+fn test() {\n+    let foo: Option<f32> = None;\n+    while let Option::Some(x) = foo {\n+        <|>x\n+    }\n+}\n+\n+\"#,\n+    );\n+    assert_eq!(\"f32\", type_at_pos(&db, pos));\n+}\n+\n+#[test]\n+fn infer_basics() {\n+    assert_snapshot!(\n+        infer(r#\"\n+fn test(a: u32, b: isize, c: !, d: &str) {\n+    a;\n+    b;\n+    c;\n+    d;\n+    1usize;\n+    1isize;\n+    \"test\";\n+    1.0f32;\n+}\"#),\n+        @r###\"\n+    [9; 10) 'a': u32\n+    [17; 18) 'b': isize\n+    [27; 28) 'c': !\n+    [33; 34) 'd': &str\n+    [42; 121) '{     ...f32; }': !\n+    [48; 49) 'a': u32\n+    [55; 56) 'b': isize\n+    [62; 63) 'c': !\n+    [69; 70) 'd': &str\n+    [76; 82) '1usize': usize\n+    [88; 94) '1isize': isize\n+    [100; 106) '\"test\"': &str\n+    [112; 118) '1.0f32': f32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_let() {\n+    assert_snapshot!(\n+        infer(r#\"\n+fn test() {\n+    let a = 1isize;\n+    let b: usize = 1;\n+    let c = b;\n+    let d: u32;\n+    let e;\n+    let f: i32 = e;\n+}\n+\"#),\n+        @r###\"\n+    [11; 118) '{     ...= e; }': ()\n+    [21; 22) 'a': isize\n+    [25; 31) '1isize': isize\n+    [41; 42) 'b': usize\n+    [52; 53) '1': usize\n+    [63; 64) 'c': usize\n+    [67; 68) 'b': usize\n+    [78; 79) 'd': u32\n+    [94; 95) 'e': i32\n+    [105; 106) 'f': i32\n+    [114; 115) 'e': i32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_paths() {\n+    assert_snapshot!(\n+        infer(r#\"\n+fn a() -> u32 { 1 }\n+\n+mod b {\n+    fn c() -> u32 { 1 }\n+}\n+\n+fn test() {\n+    a();\n+    b::c();\n+}\n+\"#),\n+        @r###\"\n+    [15; 20) '{ 1 }': u32\n+    [17; 18) '1': u32\n+    [48; 53) '{ 1 }': u32\n+    [50; 51) '1': u32\n+    [67; 91) '{     ...c(); }': ()\n+    [73; 74) 'a': fn a() -> u32\n+    [73; 76) 'a()': u32\n+    [82; 86) 'b::c': fn c() -> u32\n+    [82; 88) 'b::c()': u32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_path_type() {\n+    assert_snapshot!(\n+        infer(r#\"\n+struct S;\n+\n+impl S {\n+    fn foo() -> i32 { 1 }\n+}\n+\n+fn test() {\n+    S::foo();\n+    <S>::foo();\n+}\n+\"#),\n+        @r###\"\n+    [41; 46) '{ 1 }': i32\n+    [43; 44) '1': i32\n+    [60; 93) '{     ...o(); }': ()\n+    [66; 72) 'S::foo': fn foo() -> i32\n+    [66; 74) 'S::foo()': i32\n+    [80; 88) '<S>::foo': fn foo() -> i32\n+    [80; 90) '<S>::foo()': i32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_struct() {\n+    assert_snapshot!(\n+        infer(r#\"\n+struct A {\n+    b: B,\n+    c: C,\n+}\n+struct B;\n+struct C(usize);\n+\n+fn test() {\n+    let c = C(1);\n+    B;\n+    let a: A = A { b: B, c: C(1) };\n+    a.b;\n+    a.c;\n+}\n+\"#),\n+        @r###\"\n+    [72; 154) '{     ...a.c; }': ()\n+    [82; 83) 'c': C\n+    [86; 87) 'C': C(usize) -> C\n+    [86; 90) 'C(1)': C\n+    [88; 89) '1': usize\n+    [96; 97) 'B': B\n+    [107; 108) 'a': A\n+    [114; 133) 'A { b:...C(1) }': A\n+    [121; 122) 'B': B\n+    [127; 128) 'C': C(usize) -> C\n+    [127; 131) 'C(1)': C\n+    [129; 130) '1': usize\n+    [139; 140) 'a': A\n+    [139; 142) 'a.b': B\n+    [148; 149) 'a': A\n+    [148; 151) 'a.c': C\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_enum() {\n+    assert_snapshot!(\n+        infer(r#\"\n+enum E {\n+  V1 { field: u32 },\n+  V2\n+}\n+fn test() {\n+  E::V1 { field: 1 };\n+  E::V2;\n+}\"#),\n+        @r###\"\n+    [48; 82) '{   E:...:V2; }': ()\n+    [52; 70) 'E::V1 ...d: 1 }': E\n+    [67; 68) '1': u32\n+    [74; 79) 'E::V2': E\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_refs() {\n+    assert_snapshot!(\n+        infer(r#\"\n+fn test(a: &u32, b: &mut u32, c: *const u32, d: *mut u32) {\n+    a;\n+    *a;\n+    &a;\n+    &mut a;\n+    b;\n+    *b;\n+    &b;\n+    c;\n+    *c;\n+    d;\n+    *d;\n+}\n+\"#),\n+        @r###\"\n+    [9; 10) 'a': &u32\n+    [18; 19) 'b': &mut u32\n+    [31; 32) 'c': *const u32\n+    [46; 47) 'd': *mut u32\n+    [59; 150) '{     ... *d; }': ()\n+    [65; 66) 'a': &u32\n+    [72; 74) '*a': u32\n+    [73; 74) 'a': &u32\n+    [80; 82) '&a': &&u32\n+    [81; 82) 'a': &u32\n+    [88; 94) '&mut a': &mut &u32\n+    [93; 94) 'a': &u32\n+    [100; 101) 'b': &mut u32\n+    [107; 109) '*b': u32\n+    [108; 109) 'b': &mut u32\n+    [115; 117) '&b': &&mut u32\n+    [116; 117) 'b': &mut u32\n+    [123; 124) 'c': *const u32\n+    [130; 132) '*c': u32\n+    [131; 132) 'c': *const u32\n+    [138; 139) 'd': *mut u32\n+    [145; 147) '*d': u32\n+    [146; 147) 'd': *mut u32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_literals() {\n+    assert_snapshot!(\n+        infer(r##\"\n+fn test() {\n+    5i32;\n+    5f32;\n+    5f64;\n+    \"hello\";\n+    b\"bytes\";\n+    'c';\n+    b'b';\n+    3.14;\n+    5000;\n+    false;\n+    true;\n+    r#\"\n+        //! doc\n+        // non-doc\n+        mod foo {}\n+        \"#;\n+    br#\"yolo\"#;\n+}\n+\"##),\n+        @r###\"\n+    [11; 221) '{     ...o\"#; }': ()\n+    [17; 21) '5i32': i32\n+    [27; 31) '5f32': f32\n+    [37; 41) '5f64': f64\n+    [47; 54) '\"hello\"': &str\n+    [60; 68) 'b\"bytes\"': &[u8]\n+    [74; 77) ''c'': char\n+    [83; 87) 'b'b'': u8\n+    [93; 97) '3.14': f64\n+    [103; 107) '5000': i32\n+    [113; 118) 'false': bool\n+    [124; 128) 'true': bool\n+    [134; 202) 'r#\"   ...    \"#': &str\n+    [208; 218) 'br#\"yolo\"#': &[u8]\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_unary_op() {\n+    assert_snapshot!(\n+        infer(r#\"\n+enum SomeType {}\n+\n+fn test(x: SomeType) {\n+    let b = false;\n+    let c = !b;\n+    let a = 100;\n+    let d: i128 = -a;\n+    let e = -100;\n+    let f = !!!true;\n+    let g = !42;\n+    let h = !10u32;\n+    let j = !a;\n+    -3.14;\n+    !3;\n+    -x;\n+    !x;\n+    -\"hello\";\n+    !\"hello\";\n+}\n+\"#),\n+        @r###\"\n+    [27; 28) 'x': SomeType\n+    [40; 272) '{     ...lo\"; }': ()\n+    [50; 51) 'b': bool\n+    [54; 59) 'false': bool\n+    [69; 70) 'c': bool\n+    [73; 75) '!b': bool\n+    [74; 75) 'b': bool\n+    [85; 86) 'a': i128\n+    [89; 92) '100': i128\n+    [102; 103) 'd': i128\n+    [112; 114) '-a': i128\n+    [113; 114) 'a': i128\n+    [124; 125) 'e': i32\n+    [128; 132) '-100': i32\n+    [129; 132) '100': i32\n+    [142; 143) 'f': bool\n+    [146; 153) '!!!true': bool\n+    [147; 153) '!!true': bool\n+    [148; 153) '!true': bool\n+    [149; 153) 'true': bool\n+    [163; 164) 'g': i32\n+    [167; 170) '!42': i32\n+    [168; 170) '42': i32\n+    [180; 181) 'h': u32\n+    [184; 190) '!10u32': u32\n+    [185; 190) '10u32': u32\n+    [200; 201) 'j': i128\n+    [204; 206) '!a': i128\n+    [205; 206) 'a': i128\n+    [212; 217) '-3.14': f64\n+    [213; 217) '3.14': f64\n+    [223; 225) '!3': i32\n+    [224; 225) '3': i32\n+    [231; 233) '-x': {unknown}\n+    [232; 233) 'x': SomeType\n+    [239; 241) '!x': {unknown}\n+    [240; 241) 'x': SomeType\n+    [247; 255) '-\"hello\"': {unknown}\n+    [248; 255) '\"hello\"': &str\n+    [261; 269) '!\"hello\"': {unknown}\n+    [262; 269) '\"hello\"': &str\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_backwards() {\n+    assert_snapshot!(\n+        infer(r#\"\n+fn takes_u32(x: u32) {}\n+\n+struct S { i32_field: i32 }\n+\n+fn test() -> &mut &f64 {\n+    let a = unknown_function();\n+    takes_u32(a);\n+    let b = unknown_function();\n+    S { i32_field: b };\n+    let c = unknown_function();\n+    &mut &c\n+}\n+\"#),\n+        @r###\"\n+    [14; 15) 'x': u32\n+    [22; 24) '{}': ()\n+    [78; 231) '{     ...t &c }': &mut &f64\n+    [88; 89) 'a': u32\n+    [92; 108) 'unknow...nction': {unknown}\n+    [92; 110) 'unknow...tion()': u32\n+    [116; 125) 'takes_u32': fn takes_u32(u32) -> ()\n+    [116; 128) 'takes_u32(a)': ()\n+    [126; 127) 'a': u32\n+    [138; 139) 'b': i32\n+    [142; 158) 'unknow...nction': {unknown}\n+    [142; 160) 'unknow...tion()': i32\n+    [166; 184) 'S { i3...d: b }': S\n+    [181; 182) 'b': i32\n+    [194; 195) 'c': f64\n+    [198; 214) 'unknow...nction': {unknown}\n+    [198; 216) 'unknow...tion()': f64\n+    [222; 229) '&mut &c': &mut &f64\n+    [227; 229) '&c': &f64\n+    [228; 229) 'c': f64\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_self() {\n+    assert_snapshot!(\n+        infer(r#\"\n+struct S;\n+\n+impl S {\n+    fn test(&self) {\n+        self;\n+    }\n+    fn test2(self: &Self) {\n+        self;\n+    }\n+    fn test3() -> Self {\n+        S {}\n+    }\n+    fn test4() -> Self {\n+        Self {}\n+    }\n+}\n+\"#),\n+        @r###\"\n+    [34; 38) 'self': &S\n+    [40; 61) '{     ...     }': ()\n+    [50; 54) 'self': &S\n+    [75; 79) 'self': &S\n+    [88; 109) '{     ...     }': ()\n+    [98; 102) 'self': &S\n+    [133; 153) '{     ...     }': S\n+    [143; 147) 'S {}': S\n+    [177; 200) '{     ...     }': S\n+    [187; 194) 'Self {}': S\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_binary_op() {\n+    assert_snapshot!(\n+        infer(r#\"\n+fn f(x: bool) -> i32 {\n+    0i32\n+}\n+\n+fn test() -> bool {\n+    let x = a && b;\n+    let y = true || false;\n+    let z = x == y;\n+    let t = x != y;\n+    let minus_forty: isize = -40isize;\n+    let h = minus_forty <= CONST_2;\n+    let c = f(z || y) + 5;\n+    let d = b;\n+    let g = minus_forty ^= i;\n+    let ten: usize = 10;\n+    let ten_is_eleven = ten == some_num;\n+\n+    ten < 3\n+}\n+\"#),\n+        @r###\"\n+    [6; 7) 'x': bool\n+    [22; 34) '{     0i32 }': i32\n+    [28; 32) '0i32': i32\n+    [54; 370) '{     ... < 3 }': bool\n+    [64; 65) 'x': bool\n+    [68; 69) 'a': bool\n+    [68; 74) 'a && b': bool\n+    [73; 74) 'b': bool\n+    [84; 85) 'y': bool\n+    [88; 92) 'true': bool\n+    [88; 101) 'true || false': bool\n+    [96; 101) 'false': bool\n+    [111; 112) 'z': bool\n+    [115; 116) 'x': bool\n+    [115; 121) 'x == y': bool\n+    [120; 121) 'y': bool\n+    [131; 132) 't': bool\n+    [135; 136) 'x': bool\n+    [135; 141) 'x != y': bool\n+    [140; 141) 'y': bool\n+    [151; 162) 'minus_forty': isize\n+    [172; 180) '-40isize': isize\n+    [173; 180) '40isize': isize\n+    [190; 191) 'h': bool\n+    [194; 205) 'minus_forty': isize\n+    [194; 216) 'minus_...ONST_2': bool\n+    [209; 216) 'CONST_2': isize\n+    [226; 227) 'c': i32\n+    [230; 231) 'f': fn f(bool) -> i32\n+    [230; 239) 'f(z || y)': i32\n+    [230; 243) 'f(z || y) + 5': i32\n+    [232; 233) 'z': bool\n+    [232; 238) 'z || y': bool\n+    [237; 238) 'y': bool\n+    [242; 243) '5': i32\n+    [253; 254) 'd': {unknown}\n+    [257; 258) 'b': {unknown}\n+    [268; 269) 'g': ()\n+    [272; 283) 'minus_forty': isize\n+    [272; 288) 'minus_...y ^= i': ()\n+    [287; 288) 'i': isize\n+    [298; 301) 'ten': usize\n+    [311; 313) '10': usize\n+    [323; 336) 'ten_is_eleven': bool\n+    [339; 342) 'ten': usize\n+    [339; 354) 'ten == some_num': bool\n+    [346; 354) 'some_num': usize\n+    [361; 364) 'ten': usize\n+    [361; 368) 'ten < 3': bool\n+    [367; 368) '3': usize\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_field_autoderef() {\n+    assert_snapshot!(\n+        infer(r#\"\n+struct A {\n+    b: B,\n+}\n+struct B;\n+\n+fn test1(a: A) {\n+    let a1 = a;\n+    a1.b;\n+    let a2 = &a;\n+    a2.b;\n+    let a3 = &mut a;\n+    a3.b;\n+    let a4 = &&&&&&&a;\n+    a4.b;\n+    let a5 = &mut &&mut &&mut a;\n+    a5.b;\n+}\n+\n+fn test2(a1: *const A, a2: *mut A) {\n+    a1.b;\n+    a2.b;\n+}\n+\"#),\n+        @r###\"\n+    [44; 45) 'a': A\n+    [50; 213) '{     ...5.b; }': ()\n+    [60; 62) 'a1': A\n+    [65; 66) 'a': A\n+    [72; 74) 'a1': A\n+    [72; 76) 'a1.b': B\n+    [86; 88) 'a2': &A\n+    [91; 93) '&a': &A\n+    [92; 93) 'a': A\n+    [99; 101) 'a2': &A\n+    [99; 103) 'a2.b': B\n+    [113; 115) 'a3': &mut A\n+    [118; 124) '&mut a': &mut A\n+    [123; 124) 'a': A\n+    [130; 132) 'a3': &mut A\n+    [130; 134) 'a3.b': B\n+    [144; 146) 'a4': &&&&&&&A\n+    [149; 157) '&&&&&&&a': &&&&&&&A\n+    [150; 157) '&&&&&&a': &&&&&&A\n+    [151; 157) '&&&&&a': &&&&&A\n+    [152; 157) '&&&&a': &&&&A\n+    [153; 157) '&&&a': &&&A\n+    [154; 157) '&&a': &&A\n+    [155; 157) '&a': &A\n+    [156; 157) 'a': A\n+    [163; 165) 'a4': &&&&&&&A\n+    [163; 167) 'a4.b': B\n+    [177; 179) 'a5': &mut &&mut &&mut A\n+    [182; 200) '&mut &...&mut a': &mut &&mut &&mut A\n+    [187; 200) '&&mut &&mut a': &&mut &&mut A\n+    [188; 200) '&mut &&mut a': &mut &&mut A\n+    [193; 200) '&&mut a': &&mut A\n+    [194; 200) '&mut a': &mut A\n+    [199; 200) 'a': A\n+    [206; 208) 'a5': &mut &&mut &&mut A\n+    [206; 210) 'a5.b': B\n+    [224; 226) 'a1': *const A\n+    [238; 240) 'a2': *mut A\n+    [250; 273) '{     ...2.b; }': ()\n+    [256; 258) 'a1': *const A\n+    [256; 260) 'a1.b': B\n+    [266; 268) 'a2': *mut A\n+    [266; 270) 'a2.b': B\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_argument_autoderef() {\n+    assert_snapshot!(\n+        infer(r#\"\n+#[lang = \"deref\"]\n+pub trait Deref {\n+    type Target;\n+    fn deref(&self) -> &Self::Target;\n+}\n+\n+struct A<T>(T);\n+\n+impl<T> A<T> {\n+    fn foo(&self) -> &T {\n+        &self.0\n+    }\n+}\n+\n+struct B<T>(T);\n+\n+impl<T> Deref for B<T> {\n+    type Target = T;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+\n+fn test() {\n+    let t = A::foo(&&B(B(A(42))));\n+}\n+\"#),\n+        @r###\"\n+    [68; 72) 'self': &Self\n+    [139; 143) 'self': &A<T>\n+    [151; 174) '{     ...     }': &T\n+    [161; 168) '&self.0': &T\n+    [162; 166) 'self': &A<T>\n+    [162; 168) 'self.0': T\n+    [255; 259) 'self': &B<T>\n+    [278; 301) '{     ...     }': &T\n+    [288; 295) '&self.0': &T\n+    [289; 293) 'self': &B<T>\n+    [289; 295) 'self.0': T\n+    [315; 353) '{     ...))); }': ()\n+    [325; 326) 't': &i32\n+    [329; 335) 'A::foo': fn foo<i32>(&A<T>) -> &T\n+    [329; 350) 'A::foo...42))))': &i32\n+    [336; 349) '&&B(B(A(42)))': &&B<B<A<i32>>>\n+    [337; 349) '&B(B(A(42)))': &B<B<A<i32>>>\n+    [338; 339) 'B': B<B<A<i32>>>(T) -> B<T>\n+    [338; 349) 'B(B(A(42)))': B<B<A<i32>>>\n+    [340; 341) 'B': B<A<i32>>(T) -> B<T>\n+    [340; 348) 'B(A(42))': B<A<i32>>\n+    [342; 343) 'A': A<i32>(T) -> A<T>\n+    [342; 347) 'A(42)': A<i32>\n+    [344; 346) '42': i32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_method_argument_autoderef() {\n+    assert_snapshot!(\n+        infer(r#\"\n+#[lang = \"deref\"]\n+pub trait Deref {\n+    type Target;\n+    fn deref(&self) -> &Self::Target;\n+}\n+\n+struct A<T>(*mut T);\n+\n+impl<T> A<T> {\n+    fn foo(&self, x: &A<T>) -> &T {\n+        &*x.0\n+    }\n+}\n+\n+struct B<T>(T);\n+\n+impl<T> Deref for B<T> {\n+    type Target = T;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+\n+fn test(a: A<i32>) {\n+    let t = A(0 as *mut _).foo(&&B(B(a)));\n+}\n+\"#),\n+        @r###\"\n+    [68; 72) 'self': &Self\n+    [144; 148) 'self': &A<T>\n+    [150; 151) 'x': &A<T>\n+    [166; 187) '{     ...     }': &T\n+    [176; 181) '&*x.0': &T\n+    [177; 181) '*x.0': T\n+    [178; 179) 'x': &A<T>\n+    [178; 181) 'x.0': *mut T\n+    [268; 272) 'self': &B<T>\n+    [291; 314) '{     ...     }': &T\n+    [301; 308) '&self.0': &T\n+    [302; 306) 'self': &B<T>\n+    [302; 308) 'self.0': T\n+    [326; 327) 'a': A<i32>\n+    [337; 383) '{     ...))); }': ()\n+    [347; 348) 't': &i32\n+    [351; 352) 'A': A<i32>(*mut T) -> A<T>\n+    [351; 365) 'A(0 as *mut _)': A<i32>\n+    [351; 380) 'A(0 as...B(a)))': &i32\n+    [353; 354) '0': i32\n+    [353; 364) '0 as *mut _': *mut i32\n+    [370; 379) '&&B(B(a))': &&B<B<A<i32>>>\n+    [371; 379) '&B(B(a))': &B<B<A<i32>>>\n+    [372; 373) 'B': B<B<A<i32>>>(T) -> B<T>\n+    [372; 379) 'B(B(a))': B<B<A<i32>>>\n+    [374; 375) 'B': B<A<i32>>(T) -> B<T>\n+    [374; 378) 'B(a)': B<A<i32>>\n+    [376; 377) 'a': A<i32>\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_in_elseif() {\n+    assert_snapshot!(\n+        infer(r#\"\n+struct Foo { field: i32 }\n+fn main(foo: Foo) {\n+    if true {\n+\n+    } else if false {\n+        foo.field\n+    }\n+}\n+\"#),\n+        @r###\"\n+    [35; 38) 'foo': Foo\n+    [45; 109) '{     ...   } }': ()\n+    [51; 107) 'if tru...     }': ()\n+    [54; 58) 'true': bool\n+    [59; 67) '{      }': ()\n+    [73; 107) 'if fal...     }': ()\n+    [76; 81) 'false': bool\n+    [82; 107) '{     ...     }': i32\n+    [92; 95) 'foo': Foo\n+    [92; 101) 'foo.field': i32\n+    \"###\n+    )\n+}\n+\n+#[test]\n+fn infer_if_match_with_return() {\n+    assert_snapshot!(\n+        infer(r#\"\n+fn foo() {\n+    let _x1 = if true {\n+        1\n+    } else {\n+        return;\n+    };\n+    let _x2 = if true {\n+        2\n+    } else {\n+        return\n+    };\n+    let _x3 = match true {\n+        true => 3,\n+        _ => {\n+            return;\n+        }\n+    };\n+    let _x4 = match true {\n+        true => 4,\n+        _ => return\n+    };\n+}\"#),\n+        @r###\"\n+    [10; 323) '{     ...  }; }': ()\n+    [20; 23) '_x1': i32\n+    [26; 80) 'if tru...     }': i32\n+    [29; 33) 'true': bool\n+    [34; 51) '{     ...     }': i32\n+    [44; 45) '1': i32\n+    [57; 80) '{     ...     }': !\n+    [67; 73) 'return': !\n+    [90; 93) '_x2': i32\n+    [96; 149) 'if tru...     }': i32\n+    [99; 103) 'true': bool\n+    [104; 121) '{     ...     }': i32\n+    [114; 115) '2': i32\n+    [127; 149) '{     ...     }': !\n+    [137; 143) 'return': !\n+    [159; 162) '_x3': i32\n+    [165; 247) 'match ...     }': i32\n+    [171; 175) 'true': bool\n+    [186; 190) 'true': bool\n+    [194; 195) '3': i32\n+    [205; 206) '_': bool\n+    [210; 241) '{     ...     }': !\n+    [224; 230) 'return': !\n+    [257; 260) '_x4': i32\n+    [263; 320) 'match ...     }': i32\n+    [269; 273) 'true': bool\n+    [284; 288) 'true': bool\n+    [292; 293) '4': i32\n+    [303; 304) '_': bool\n+    [308; 314) 'return': !\n+    \"###\n+    )\n+}\n+\n+#[test]\n+fn infer_inherent_method() {\n+    assert_snapshot!(\n+        infer(r#\"\n+struct A;\n+\n+impl A {\n+    fn foo(self, x: u32) -> i32 {}\n+}\n+\n+mod b {\n+    impl super::A {\n+        fn bar(&self, x: u64) -> i64 {}\n+    }\n+}\n+\n+fn test(a: A) {\n+    a.foo(1);\n+    (&a).bar(1);\n+    a.bar(1);\n+}\n+\"#),\n+        @r###\"\n+    [32; 36) 'self': A\n+    [38; 39) 'x': u32\n+    [53; 55) '{}': ()\n+    [103; 107) 'self': &A\n+    [109; 110) 'x': u64\n+    [124; 126) '{}': ()\n+    [144; 145) 'a': A\n+    [150; 198) '{     ...(1); }': ()\n+    [156; 157) 'a': A\n+    [156; 164) 'a.foo(1)': i32\n+    [162; 163) '1': u32\n+    [170; 181) '(&a).bar(1)': i64\n+    [171; 173) '&a': &A\n+    [172; 173) 'a': A\n+    [179; 180) '1': u64\n+    [187; 188) 'a': A\n+    [187; 195) 'a.bar(1)': i64\n+    [193; 194) '1': u64\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_inherent_method_str() {\n+    assert_snapshot!(\n+        infer(r#\"\n+#[lang = \"str\"]\n+impl str {\n+    fn foo(&self) -> i32 {}\n+}\n+\n+fn test() {\n+    \"foo\".foo();\n+}\n+\"#),\n+        @r###\"\n+    [40; 44) 'self': &str\n+    [53; 55) '{}': ()\n+    [69; 89) '{     ...o(); }': ()\n+    [75; 80) '\"foo\"': &str\n+    [75; 86) '\"foo\".foo()': i32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_tuple() {\n+    assert_snapshot!(\n+        infer(r#\"\n+fn test(x: &str, y: isize) {\n+    let a: (u32, &str) = (1, \"a\");\n+    let b = (a, x);\n+    let c = (y, x);\n+    let d = (c, x);\n+    let e = (1, \"e\");\n+    let f = (e, \"d\");\n+}\n+\"#),\n+        @r###\"\n+    [9; 10) 'x': &str\n+    [18; 19) 'y': isize\n+    [28; 170) '{     ...d\"); }': ()\n+    [38; 39) 'a': (u32, &str)\n+    [55; 63) '(1, \"a\")': (u32, &str)\n+    [56; 57) '1': u32\n+    [59; 62) '\"a\"': &str\n+    [73; 74) 'b': ((u32, &str), &str)\n+    [77; 83) '(a, x)': ((u32, &str), &str)\n+    [78; 79) 'a': (u32, &str)\n+    [81; 82) 'x': &str\n+    [93; 94) 'c': (isize, &str)\n+    [97; 103) '(y, x)': (isize, &str)\n+    [98; 99) 'y': isize\n+    [101; 102) 'x': &str\n+    [113; 114) 'd': ((isize, &str), &str)\n+    [117; 123) '(c, x)': ((isize, &str), &str)\n+    [118; 119) 'c': (isize, &str)\n+    [121; 122) 'x': &str\n+    [133; 134) 'e': (i32, &str)\n+    [137; 145) '(1, \"e\")': (i32, &str)\n+    [138; 139) '1': i32\n+    [141; 144) '\"e\"': &str\n+    [155; 156) 'f': ((i32, &str), &str)\n+    [159; 167) '(e, \"d\")': ((i32, &str), &str)\n+    [160; 161) 'e': (i32, &str)\n+    [163; 166) '\"d\"': &str\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_array() {\n+    assert_snapshot!(\n+        infer(r#\"\n+fn test(x: &str, y: isize) {\n+    let a = [x];\n+    let b = [a, a];\n+    let c = [b, b];\n+\n+    let d = [y, 1, 2, 3];\n+    let d = [1, y, 2, 3];\n+    let e = [y];\n+    let f = [d, d];\n+    let g = [e, e];\n+\n+    let h = [1, 2];\n+    let i = [\"a\", \"b\"];\n+\n+    let b = [a, [\"b\"]];\n+    let x: [u8; 0] = [];\n+}\n+\"#),\n+        @r###\"\n+    [9; 10) 'x': &str\n+    [18; 19) 'y': isize\n+    [28; 293) '{     ... []; }': ()\n+    [38; 39) 'a': [&str;_]\n+    [42; 45) '[x]': [&str;_]\n+    [43; 44) 'x': &str\n+    [55; 56) 'b': [[&str;_];_]\n+    [59; 65) '[a, a]': [[&str;_];_]\n+    [60; 61) 'a': [&str;_]\n+    [63; 64) 'a': [&str;_]\n+    [75; 76) 'c': [[[&str;_];_];_]\n+    [79; 85) '[b, b]': [[[&str;_];_];_]\n+    [80; 81) 'b': [[&str;_];_]\n+    [83; 84) 'b': [[&str;_];_]\n+    [96; 97) 'd': [isize;_]\n+    [100; 112) '[y, 1, 2, 3]': [isize;_]\n+    [101; 102) 'y': isize\n+    [104; 105) '1': isize\n+    [107; 108) '2': isize\n+    [110; 111) '3': isize\n+    [122; 123) 'd': [isize;_]\n+    [126; 138) '[1, y, 2, 3]': [isize;_]\n+    [127; 128) '1': isize\n+    [130; 131) 'y': isize\n+    [133; 134) '2': isize\n+    [136; 137) '3': isize\n+    [148; 149) 'e': [isize;_]\n+    [152; 155) '[y]': [isize;_]\n+    [153; 154) 'y': isize\n+    [165; 166) 'f': [[isize;_];_]\n+    [169; 175) '[d, d]': [[isize;_];_]\n+    [170; 171) 'd': [isize;_]\n+    [173; 174) 'd': [isize;_]\n+    [185; 186) 'g': [[isize;_];_]\n+    [189; 195) '[e, e]': [[isize;_];_]\n+    [190; 191) 'e': [isize;_]\n+    [193; 194) 'e': [isize;_]\n+    [206; 207) 'h': [i32;_]\n+    [210; 216) '[1, 2]': [i32;_]\n+    [211; 212) '1': i32\n+    [214; 215) '2': i32\n+    [226; 227) 'i': [&str;_]\n+    [230; 240) '[\"a\", \"b\"]': [&str;_]\n+    [231; 234) '\"a\"': &str\n+    [236; 239) '\"b\"': &str\n+    [251; 252) 'b': [[&str;_];_]\n+    [255; 265) '[a, [\"b\"]]': [[&str;_];_]\n+    [256; 257) 'a': [&str;_]\n+    [259; 264) '[\"b\"]': [&str;_]\n+    [260; 263) '\"b\"': &str\n+    [275; 276) 'x': [u8;_]\n+    [288; 290) '[]': [u8;_]\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_struct_generics() {\n+    assert_snapshot!(\n+        infer(r#\"\n+struct A<T> {\n+    x: T,\n+}\n+\n+fn test(a1: A<u32>, i: i32) {\n+    a1.x;\n+    let a2 = A { x: i };\n+    a2.x;\n+    let a3 = A::<i128> { x: 1 };\n+    a3.x;\n+}\n+\"#),\n+        @r###\"\n+    [36; 38) 'a1': A<u32>\n+    [48; 49) 'i': i32\n+    [56; 147) '{     ...3.x; }': ()\n+    [62; 64) 'a1': A<u32>\n+    [62; 66) 'a1.x': u32\n+    [76; 78) 'a2': A<i32>\n+    [81; 91) 'A { x: i }': A<i32>\n+    [88; 89) 'i': i32\n+    [97; 99) 'a2': A<i32>\n+    [97; 101) 'a2.x': i32\n+    [111; 113) 'a3': A<i128>\n+    [116; 134) 'A::<i1...x: 1 }': A<i128>\n+    [131; 132) '1': i128\n+    [140; 142) 'a3': A<i128>\n+    [140; 144) 'a3.x': i128\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_tuple_struct_generics() {\n+    assert_snapshot!(\n+        infer(r#\"\n+struct A<T>(T);\n+enum Option<T> { Some(T), None }\n+use Option::*;\n+\n+fn test() {\n+    A(42);\n+    A(42u128);\n+    Some(\"x\");\n+    Option::Some(\"x\");\n+    None;\n+    let x: Option<i64> = None;\n+}\n+\"#),\n+        @r###\"\n+    [76; 184) '{     ...one; }': ()\n+    [82; 83) 'A': A<i32>(T) -> A<T>\n+    [82; 87) 'A(42)': A<i32>\n+    [84; 86) '42': i32\n+    [93; 94) 'A': A<u128>(T) -> A<T>\n+    [93; 102) 'A(42u128)': A<u128>\n+    [95; 101) '42u128': u128\n+    [108; 112) 'Some': Some<&str>(T) -> Option<T>\n+    [108; 117) 'Some(\"x\")': Option<&str>\n+    [113; 116) '\"x\"': &str\n+    [123; 135) 'Option::Some': Some<&str>(T) -> Option<T>\n+    [123; 140) 'Option...e(\"x\")': Option<&str>\n+    [136; 139) '\"x\"': &str\n+    [146; 150) 'None': Option<{unknown}>\n+    [160; 161) 'x': Option<i64>\n+    [177; 181) 'None': Option<i64>\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_function_generics() {\n+    assert_snapshot!(\n+        infer(r#\"\n+fn id<T>(t: T) -> T { t }\n+\n+fn test() {\n+    id(1u32);\n+    id::<i128>(1);\n+    let x: u64 = id(1);\n+}\n+\"#),\n+        @r###\"\n+    [10; 11) 't': T\n+    [21; 26) '{ t }': T\n+    [23; 24) 't': T\n+    [38; 98) '{     ...(1); }': ()\n+    [44; 46) 'id': fn id<u32>(T) -> T\n+    [44; 52) 'id(1u32)': u32\n+    [47; 51) '1u32': u32\n+    [58; 68) 'id::<i128>': fn id<i128>(T) -> T\n+    [58; 71) 'id::<i128>(1)': i128\n+    [69; 70) '1': i128\n+    [81; 82) 'x': u64\n+    [90; 92) 'id': fn id<u64>(T) -> T\n+    [90; 95) 'id(1)': u64\n+    [93; 94) '1': u64\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_impl_generics() {\n+    assert_snapshot!(\n+        infer(r#\"\n+struct A<T1, T2> {\n+    x: T1,\n+    y: T2,\n+}\n+impl<Y, X> A<X, Y> {\n+    fn x(self) -> X {\n+        self.x\n+    }\n+    fn y(self) -> Y {\n+        self.y\n+    }\n+    fn z<T>(self, t: T) -> (X, Y, T) {\n+        (self.x, self.y, t)\n+    }\n+}\n+\n+fn test() -> i128 {\n+    let a = A { x: 1u64, y: 1i64 };\n+    a.x();\n+    a.y();\n+    a.z(1i128);\n+    a.z::<u128>(1);\n+}\n+\"#),\n+        @r###\"\n+    [74; 78) 'self': A<X, Y>\n+    [85; 107) '{     ...     }': X\n+    [95; 99) 'self': A<X, Y>\n+    [95; 101) 'self.x': X\n+    [117; 121) 'self': A<X, Y>\n+    [128; 150) '{     ...     }': Y\n+    [138; 142) 'self': A<X, Y>\n+    [138; 144) 'self.y': Y\n+    [163; 167) 'self': A<X, Y>\n+    [169; 170) 't': T\n+    [188; 223) '{     ...     }': (X, Y, T)\n+    [198; 217) '(self.....y, t)': (X, Y, T)\n+    [199; 203) 'self': A<X, Y>\n+    [199; 205) 'self.x': X\n+    [207; 211) 'self': A<X, Y>\n+    [207; 213) 'self.y': Y\n+    [215; 216) 't': T\n+    [245; 342) '{     ...(1); }': ()\n+    [255; 256) 'a': A<u64, i64>\n+    [259; 281) 'A { x:...1i64 }': A<u64, i64>\n+    [266; 270) '1u64': u64\n+    [275; 279) '1i64': i64\n+    [287; 288) 'a': A<u64, i64>\n+    [287; 292) 'a.x()': u64\n+    [298; 299) 'a': A<u64, i64>\n+    [298; 303) 'a.y()': i64\n+    [309; 310) 'a': A<u64, i64>\n+    [309; 319) 'a.z(1i128)': (u64, i64, i128)\n+    [313; 318) '1i128': i128\n+    [325; 326) 'a': A<u64, i64>\n+    [325; 339) 'a.z::<u128>(1)': (u64, i64, u128)\n+    [337; 338) '1': u128\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_impl_generics_with_autoderef() {\n+    assert_snapshot!(\n+        infer(r#\"\n+enum Option<T> {\n+    Some(T),\n+    None,\n+}\n+impl<T> Option<T> {\n+    fn as_ref(&self) -> Option<&T> {}\n+}\n+fn test(o: Option<u32>) {\n+    (&o).as_ref();\n+    o.as_ref();\n+}\n+\"#),\n+        @r###\"\n+    [78; 82) 'self': &Option<T>\n+    [98; 100) '{}': ()\n+    [111; 112) 'o': Option<u32>\n+    [127; 165) '{     ...f(); }': ()\n+    [133; 146) '(&o).as_ref()': Option<&u32>\n+    [134; 136) '&o': &Option<u32>\n+    [135; 136) 'o': Option<u32>\n+    [152; 153) 'o': Option<u32>\n+    [152; 162) 'o.as_ref()': Option<&u32>\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_generic_chain() {\n+    assert_snapshot!(\n+        infer(r#\"\n+struct A<T> {\n+    x: T,\n+}\n+impl<T2> A<T2> {\n+    fn x(self) -> T2 {\n+        self.x\n+    }\n+}\n+fn id<T>(t: T) -> T { t }\n+\n+fn test() -> i128 {\n+     let x = 1;\n+     let y = id(x);\n+     let a = A { x: id(y) };\n+     let z = id(a.x);\n+     let b = A { x: z };\n+     b.x()\n+}\n+\"#),\n+        @r###\"\n+    [53; 57) 'self': A<T2>\n+    [65; 87) '{     ...     }': T2\n+    [75; 79) 'self': A<T2>\n+    [75; 81) 'self.x': T2\n+    [99; 100) 't': T\n+    [110; 115) '{ t }': T\n+    [112; 113) 't': T\n+    [135; 261) '{     ....x() }': i128\n+    [146; 147) 'x': i128\n+    [150; 151) '1': i128\n+    [162; 163) 'y': i128\n+    [166; 168) 'id': fn id<i128>(T) -> T\n+    [166; 171) 'id(x)': i128\n+    [169; 170) 'x': i128\n+    [182; 183) 'a': A<i128>\n+    [186; 200) 'A { x: id(y) }': A<i128>\n+    [193; 195) 'id': fn id<i128>(T) -> T\n+    [193; 198) 'id(y)': i128\n+    [196; 197) 'y': i128\n+    [211; 212) 'z': i128\n+    [215; 217) 'id': fn id<i128>(T) -> T\n+    [215; 222) 'id(a.x)': i128\n+    [218; 219) 'a': A<i128>\n+    [218; 221) 'a.x': i128\n+    [233; 234) 'b': A<i128>\n+    [237; 247) 'A { x: z }': A<i128>\n+    [244; 245) 'z': i128\n+    [254; 255) 'b': A<i128>\n+    [254; 259) 'b.x()': i128\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_associated_const() {\n+    assert_snapshot!(\n+        infer(r#\"\n+struct Struct;\n+\n+impl Struct {\n+    const FOO: u32 = 1;\n+}\n+\n+enum Enum {}\n+\n+impl Enum {\n+    const BAR: u32 = 2;\n+}\n+\n+trait Trait {\n+    const ID: u32;\n+}\n+\n+struct TraitTest;\n+\n+impl Trait for TraitTest {\n+    const ID: u32 = 5;\n+}\n+\n+fn test() {\n+    let x = Struct::FOO;\n+    let y = Enum::BAR;\n+    let z = TraitTest::ID;\n+}\n+\"#),\n+        @r###\"\n+    [52; 53) '1': u32\n+    [105; 106) '2': u32\n+    [213; 214) '5': u32\n+    [229; 307) '{     ...:ID; }': ()\n+    [239; 240) 'x': u32\n+    [243; 254) 'Struct::FOO': u32\n+    [264; 265) 'y': u32\n+    [268; 277) 'Enum::BAR': u32\n+    [287; 288) 'z': u32\n+    [291; 304) 'TraitTest::ID': u32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_type_alias() {\n+    assert_snapshot!(\n+        infer(r#\"\n+struct A<X, Y> { x: X, y: Y }\n+type Foo = A<u32, i128>;\n+type Bar<T> = A<T, u128>;\n+type Baz<U, V> = A<V, U>;\n+fn test(x: Foo, y: Bar<&str>, z: Baz<i8, u8>) {\n+    x.x;\n+    x.y;\n+    y.x;\n+    y.y;\n+    z.x;\n+    z.y;\n+}\n+\"#),\n+        @r###\"\n+    [116; 117) 'x': A<u32, i128>\n+    [124; 125) 'y': A<&str, u128>\n+    [138; 139) 'z': A<u8, i8>\n+    [154; 211) '{     ...z.y; }': ()\n+    [160; 161) 'x': A<u32, i128>\n+    [160; 163) 'x.x': u32\n+    [169; 170) 'x': A<u32, i128>\n+    [169; 172) 'x.y': i128\n+    [178; 179) 'y': A<&str, u128>\n+    [178; 181) 'y.x': &str\n+    [187; 188) 'y': A<&str, u128>\n+    [187; 190) 'y.y': u128\n+    [196; 197) 'z': A<u8, i8>\n+    [196; 199) 'z.x': u8\n+    [205; 206) 'z': A<u8, i8>\n+    [205; 208) 'z.y': i8\n+    \"###\n+    )\n+}\n+\n+#[test]\n+fn recursive_type_alias() {\n+    assert_snapshot!(\n+        infer(r#\"\n+struct A<X> {}\n+type Foo = Foo;\n+type Bar = A<Bar>;\n+fn test(x: Foo) {}\n+\"#),\n+        @r###\"\n+    [59; 60) 'x': {unknown}\n+    [67; 69) '{}': ()\n+    \"###\n+    )\n+}\n+\n+#[test]\n+fn infer_type_param() {\n+    assert_snapshot!(\n+        infer(r#\"\n+fn id<T>(x: T) -> T {\n+    x\n+}\n+\n+fn clone<T>(x: &T) -> T {\n+    *x\n+}\n+\n+fn test() {\n+    let y = 10u32;\n+    id(y);\n+    let x: bool = clone(z);\n+    id::<i128>(1);\n+}\n+\"#),\n+        @r###\"\n+    [10; 11) 'x': T\n+    [21; 30) '{     x }': T\n+    [27; 28) 'x': T\n+    [44; 45) 'x': &T\n+    [56; 66) '{     *x }': T\n+    [62; 64) '*x': T\n+    [63; 64) 'x': &T\n+    [78; 158) '{     ...(1); }': ()\n+    [88; 89) 'y': u32\n+    [92; 97) '10u32': u32\n+    [103; 105) 'id': fn id<u32>(T) -> T\n+    [103; 108) 'id(y)': u32\n+    [106; 107) 'y': u32\n+    [118; 119) 'x': bool\n+    [128; 133) 'clone': fn clone<bool>(&T) -> T\n+    [128; 136) 'clone(z)': bool\n+    [134; 135) 'z': &bool\n+    [142; 152) 'id::<i128>': fn id<i128>(T) -> T\n+    [142; 155) 'id::<i128>(1)': i128\n+    [153; 154) '1': i128\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_const() {\n+    assert_snapshot!(\n+        infer(r#\"\n+struct Foo;\n+impl Foo { const ASSOC_CONST: u32 = 0; }\n+const GLOBAL_CONST: u32 = 101;\n+fn test() {\n+    const LOCAL_CONST: u32 = 99;\n+    let x = LOCAL_CONST;\n+    let z = GLOBAL_CONST;\n+    let id = Foo::ASSOC_CONST;\n+}\n+\"#),\n+        @r###\"\n+    [49; 50) '0': u32\n+    [80; 83) '101': u32\n+    [95; 213) '{     ...NST; }': ()\n+    [138; 139) 'x': u32\n+    [142; 153) 'LOCAL_CONST': u32\n+    [163; 164) 'z': u32\n+    [167; 179) 'GLOBAL_CONST': u32\n+    [189; 191) 'id': u32\n+    [194; 210) 'Foo::A..._CONST': u32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_static() {\n+    assert_snapshot!(\n+        infer(r#\"\n+static GLOBAL_STATIC: u32 = 101;\n+static mut GLOBAL_STATIC_MUT: u32 = 101;\n+fn test() {\n+    static LOCAL_STATIC: u32 = 99;\n+    static mut LOCAL_STATIC_MUT: u32 = 99;\n+    let x = LOCAL_STATIC;\n+    let y = LOCAL_STATIC_MUT;\n+    let z = GLOBAL_STATIC;\n+    let w = GLOBAL_STATIC_MUT;\n+}\n+\"#),\n+        @r###\"\n+    [29; 32) '101': u32\n+    [70; 73) '101': u32\n+    [85; 280) '{     ...MUT; }': ()\n+    [173; 174) 'x': u32\n+    [177; 189) 'LOCAL_STATIC': u32\n+    [199; 200) 'y': u32\n+    [203; 219) 'LOCAL_...IC_MUT': u32\n+    [229; 230) 'z': u32\n+    [233; 246) 'GLOBAL_STATIC': u32\n+    [256; 257) 'w': u32\n+    [260; 277) 'GLOBAL...IC_MUT': u32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn shadowing_primitive() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+struct i32;\n+struct Foo;\n+\n+impl i32 { fn foo(&self) -> Foo { Foo } }\n+\n+fn main() {\n+    let x: i32 = i32;\n+    x.foo()<|>;\n+}\"#,\n+    );\n+    assert_eq!(t, \"Foo\");\n+}\n+\n+#[test]\n+fn not_shadowing_primitive_by_module() {\n+    let t = type_at(\n+        r#\"\n+//- /str.rs\n+fn foo() {}\n+\n+//- /main.rs\n+mod str;\n+fn foo() -> &'static str { \"\" }\n+\n+fn main() {\n+    foo()<|>;\n+}\"#,\n+    );\n+    assert_eq!(t, \"&str\");\n+}\n+\n+#[test]\n+fn not_shadowing_module_by_primitive() {\n+    let t = type_at(\n+        r#\"\n+//- /str.rs\n+fn foo() -> u32 {0}\n+\n+//- /main.rs\n+mod str;\n+fn foo() -> &'static str { \"\" }\n+\n+fn main() {\n+    str::foo()<|>;\n+}\"#,\n+    );\n+    assert_eq!(t, \"u32\");\n+}\n+\n+#[test]\n+fn closure_return() {\n+    assert_snapshot!(\n+        infer(r#\"\n+fn foo() -> u32 {\n+    let x = || -> usize { return 1; };\n+}\n+\"#),\n+        @r###\"\n+    [17; 59) '{     ...; }; }': ()\n+    [27; 28) 'x': || -> usize\n+    [31; 56) '|| -> ...n 1; }': || -> usize\n+    [43; 56) '{ return 1; }': !\n+    [45; 53) 'return 1': !\n+    [52; 53) '1': usize\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn closure_return_unit() {\n+    assert_snapshot!(\n+        infer(r#\"\n+fn foo() -> u32 {\n+    let x = || { return; };\n+}\n+\"#),\n+        @r###\"\n+    [17; 48) '{     ...; }; }': ()\n+    [27; 28) 'x': || -> ()\n+    [31; 45) '|| { return; }': || -> ()\n+    [34; 45) '{ return; }': !\n+    [36; 42) 'return': !\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn closure_return_inferred() {\n+    assert_snapshot!(\n+        infer(r#\"\n+fn foo() -> u32 {\n+    let x = || { \"test\" };\n+}\n+\"#),\n+        @r###\"\n+    [17; 47) '{     ...\" }; }': ()\n+    [27; 28) 'x': || -> &str\n+    [31; 44) '|| { \"test\" }': || -> &str\n+    [34; 44) '{ \"test\" }': &str\n+    [36; 42) '\"test\"': &str\n+    \"###\n+    );\n+}"}, {"sha": "ae316922bdea8a3df540c06642e0b4c48ca82544", "filename": "crates/ra_hir_ty/src/tests/traits.rs", "status": "added", "additions": 1598, "deletions": 0, "changes": 1598, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -0,0 +1,1598 @@\n+use insta::assert_snapshot;\n+\n+use ra_db::fixture::WithFixture;\n+use test_utils::covers;\n+\n+use super::{infer, infer_with_mismatches, type_at, type_at_pos};\n+use crate::test_db::TestDB;\n+\n+#[test]\n+fn infer_await() {\n+    let (db, pos) = TestDB::with_position(\n+        r#\"\n+//- /main.rs crate:main deps:std\n+\n+struct IntFuture;\n+\n+impl Future for IntFuture {\n+    type Output = u64;\n+}\n+\n+fn test() {\n+    let r = IntFuture;\n+    let v = r.await;\n+    v<|>;\n+}\n+\n+//- /std.rs crate:std\n+#[prelude_import] use future::*;\n+mod future {\n+    trait Future {\n+        type Output;\n+    }\n+}\n+\n+\"#,\n+    );\n+    assert_eq!(\"u64\", type_at_pos(&db, pos));\n+}\n+\n+#[test]\n+fn infer_try() {\n+    let (db, pos) = TestDB::with_position(\n+        r#\"\n+//- /main.rs crate:main deps:std\n+\n+fn test() {\n+    let r: Result<i32, u64> = Result::Ok(1);\n+    let v = r?;\n+    v<|>;\n+}\n+\n+//- /std.rs crate:std\n+\n+#[prelude_import] use ops::*;\n+mod ops {\n+    trait Try {\n+        type Ok;\n+        type Error;\n+    }\n+}\n+\n+#[prelude_import] use result::*;\n+mod result {\n+    enum Result<O, E> {\n+        Ok(O),\n+        Err(E)\n+    }\n+\n+    impl<O, E> crate::ops::Try for Result<O, E> {\n+        type Ok = O;\n+        type Error = E;\n+    }\n+}\n+\n+\"#,\n+    );\n+    assert_eq!(\"i32\", type_at_pos(&db, pos));\n+}\n+\n+#[test]\n+fn infer_for_loop() {\n+    let (db, pos) = TestDB::with_position(\n+        r#\"\n+//- /main.rs crate:main deps:std\n+\n+use std::collections::Vec;\n+\n+fn test() {\n+    let v = Vec::new();\n+    v.push(\"foo\");\n+    for x in v {\n+        x<|>;\n+    }\n+}\n+\n+//- /std.rs crate:std\n+\n+#[prelude_import] use iter::*;\n+mod iter {\n+    trait IntoIterator {\n+        type Item;\n+    }\n+}\n+\n+mod collections {\n+    struct Vec<T> {}\n+    impl<T> Vec<T> {\n+        fn new() -> Self { Vec {} }\n+        fn push(&mut self, t: T) { }\n+    }\n+\n+    impl<T> crate::iter::IntoIterator for Vec<T> {\n+        type Item=T;\n+    }\n+}\n+\"#,\n+    );\n+    assert_eq!(\"&str\", type_at_pos(&db, pos));\n+}\n+\n+#[test]\n+fn infer_ops_neg() {\n+    let (db, pos) = TestDB::with_position(\n+        r#\"\n+//- /main.rs crate:main deps:std\n+\n+struct Bar;\n+struct Foo;\n+\n+impl std::ops::Neg for Bar {\n+    type Output = Foo;\n+}\n+\n+fn test() {\n+    let a = Bar;\n+    let b = -a;\n+    b<|>;\n+}\n+\n+//- /std.rs crate:std\n+\n+#[prelude_import] use ops::*;\n+mod ops {\n+    pub trait Neg {\n+        type Output;\n+    }\n+}\n+\"#,\n+    );\n+    assert_eq!(\"Foo\", type_at_pos(&db, pos));\n+}\n+\n+#[test]\n+fn infer_ops_not() {\n+    let (db, pos) = TestDB::with_position(\n+        r#\"\n+//- /main.rs crate:main deps:std\n+\n+struct Bar;\n+struct Foo;\n+\n+impl std::ops::Not for Bar {\n+    type Output = Foo;\n+}\n+\n+fn test() {\n+    let a = Bar;\n+    let b = !a;\n+    b<|>;\n+}\n+\n+//- /std.rs crate:std\n+\n+#[prelude_import] use ops::*;\n+mod ops {\n+    pub trait Not {\n+        type Output;\n+    }\n+}\n+\"#,\n+    );\n+    assert_eq!(\"Foo\", type_at_pos(&db, pos));\n+}\n+\n+#[test]\n+fn infer_from_bound_1() {\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Trait<T> {}\n+struct S<T>(T);\n+impl<U> Trait<U> for S<U> {}\n+fn foo<T: Trait<u32>>(t: T) {}\n+fn test() {\n+    let s = S(unknown);\n+    foo(s);\n+}\n+\"#),\n+        @r###\"\n+    [86; 87) 't': T\n+    [92; 94) '{}': ()\n+    [105; 144) '{     ...(s); }': ()\n+    [115; 116) 's': S<u32>\n+    [119; 120) 'S': S<u32>(T) -> S<T>\n+    [119; 129) 'S(unknown)': S<u32>\n+    [121; 128) 'unknown': u32\n+    [135; 138) 'foo': fn foo<S<u32>>(T) -> ()\n+    [135; 141) 'foo(s)': ()\n+    [139; 140) 's': S<u32>\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_from_bound_2() {\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Trait<T> {}\n+struct S<T>(T);\n+impl<U> Trait<U> for S<U> {}\n+fn foo<U, T: Trait<U>>(t: T) -> U {}\n+fn test() {\n+    let s = S(unknown);\n+    let x: u32 = foo(s);\n+}\n+\"#),\n+        @r###\"\n+    [87; 88) 't': T\n+    [98; 100) '{}': ()\n+    [111; 163) '{     ...(s); }': ()\n+    [121; 122) 's': S<u32>\n+    [125; 126) 'S': S<u32>(T) -> S<T>\n+    [125; 135) 'S(unknown)': S<u32>\n+    [127; 134) 'unknown': u32\n+    [145; 146) 'x': u32\n+    [154; 157) 'foo': fn foo<u32, S<u32>>(T) -> U\n+    [154; 160) 'foo(s)': u32\n+    [158; 159) 's': S<u32>\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_project_associated_type() {\n+    // y, z, a don't yet work because of https://github.com/rust-lang/chalk/issues/234\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Iterable {\n+   type Item;\n+}\n+struct S;\n+impl Iterable for S { type Item = u32; }\n+fn test<T: Iterable>() {\n+    let x: <S as Iterable>::Item = 1;\n+    let y: <T as Iterable>::Item = no_matter;\n+    let z: T::Item = no_matter;\n+    let a: <T>::Item = no_matter;\n+}\n+\"#),\n+        @r###\"\n+    [108; 261) '{     ...ter; }': ()\n+    [118; 119) 'x': u32\n+    [145; 146) '1': u32\n+    [156; 157) 'y': {unknown}\n+    [183; 192) 'no_matter': {unknown}\n+    [202; 203) 'z': {unknown}\n+    [215; 224) 'no_matter': {unknown}\n+    [234; 235) 'a': {unknown}\n+    [249; 258) 'no_matter': {unknown}\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_return_associated_type() {\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Iterable {\n+   type Item;\n+}\n+struct S;\n+impl Iterable for S { type Item = u32; }\n+fn foo1<T: Iterable>(t: T) -> T::Item {}\n+fn foo2<T: Iterable>(t: T) -> <T as Iterable>::Item {}\n+fn foo3<T: Iterable>(t: T) -> <T>::Item {}\n+fn test() {\n+    let x = foo1(S);\n+    let y = foo2(S);\n+    let z = foo3(S);\n+}\n+\"#),\n+        @r###\"\n+    [106; 107) 't': T\n+    [123; 125) '{}': ()\n+    [147; 148) 't': T\n+    [178; 180) '{}': ()\n+    [202; 203) 't': T\n+    [221; 223) '{}': ()\n+    [234; 300) '{     ...(S); }': ()\n+    [244; 245) 'x': u32\n+    [248; 252) 'foo1': fn foo1<S>(T) -> <T as Iterable>::Item\n+    [248; 255) 'foo1(S)': u32\n+    [253; 254) 'S': S\n+    [265; 266) 'y': u32\n+    [269; 273) 'foo2': fn foo2<S>(T) -> <T as Iterable>::Item\n+    [269; 276) 'foo2(S)': u32\n+    [274; 275) 'S': S\n+    [286; 287) 'z': u32\n+    [290; 294) 'foo3': fn foo3<S>(T) -> <T as Iterable>::Item\n+    [290; 297) 'foo3(S)': u32\n+    [295; 296) 'S': S\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_associated_type_bound() {\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Iterable {\n+   type Item;\n+}\n+fn test<T: Iterable<Item=u32>>() {\n+    let y: T::Item = unknown;\n+}\n+\"#),\n+        @r###\"\n+    [67; 100) '{     ...own; }': ()\n+    [77; 78) 'y': {unknown}\n+    [90; 97) 'unknown': {unknown}\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_const_body() {\n+    assert_snapshot!(\n+        infer(r#\"\n+const A: u32 = 1 + 1;\n+static B: u64 = { let x = 1; x };\n+\"#),\n+        @r###\"\n+    [16; 17) '1': u32\n+    [16; 21) '1 + 1': u32\n+    [20; 21) '1': u32\n+    [39; 55) '{ let ...1; x }': u64\n+    [45; 46) 'x': u64\n+    [49; 50) '1': u64\n+    [52; 53) 'x': u64\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn tuple_struct_fields() {\n+    assert_snapshot!(\n+        infer(r#\"\n+struct S(i32, u64);\n+fn test() -> u64 {\n+    let a = S(4, 6);\n+    let b = a.0;\n+    a.1\n+}\n+\"#),\n+        @r###\"\n+    [38; 87) '{     ... a.1 }': u64\n+    [48; 49) 'a': S\n+    [52; 53) 'S': S(i32, u64) -> S\n+    [52; 59) 'S(4, 6)': S\n+    [54; 55) '4': i32\n+    [57; 58) '6': u64\n+    [69; 70) 'b': i32\n+    [73; 74) 'a': S\n+    [73; 76) 'a.0': i32\n+    [82; 83) 'a': S\n+    [82; 85) 'a.1': u64\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn tuple_struct_with_fn() {\n+    assert_snapshot!(\n+        infer(r#\"\n+struct S(fn(u32) -> u64);\n+fn test() -> u64 {\n+    let a = S(|i| 2*i);\n+    let b = a.0(4);\n+    a.0(2)\n+}\n+\"#),\n+        @r###\"\n+    [44; 102) '{     ...0(2) }': u64\n+    [54; 55) 'a': S\n+    [58; 59) 'S': S(fn(u32) -> u64) -> S\n+    [58; 68) 'S(|i| 2*i)': S\n+    [60; 67) '|i| 2*i': |u32| -> u64\n+    [61; 62) 'i': u32\n+    [64; 65) '2': u32\n+    [64; 67) '2*i': u32\n+    [66; 67) 'i': u32\n+    [78; 79) 'b': u64\n+    [82; 83) 'a': S\n+    [82; 85) 'a.0': fn(u32) -> u64\n+    [82; 88) 'a.0(4)': u64\n+    [86; 87) '4': u32\n+    [94; 95) 'a': S\n+    [94; 97) 'a.0': fn(u32) -> u64\n+    [94; 100) 'a.0(2)': u64\n+    [98; 99) '2': u32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn indexing_arrays() {\n+    assert_snapshot!(\n+        infer(\"fn main() { &mut [9][2]; }\"),\n+        @r###\"\n+    [10; 26) '{ &mut...[2]; }': ()\n+    [12; 23) '&mut [9][2]': &mut {unknown}\n+    [17; 20) '[9]': [i32;_]\n+    [17; 23) '[9][2]': {unknown}\n+    [18; 19) '9': i32\n+    [21; 22) '2': i32\n+    \"###\n+    )\n+}\n+\n+#[test]\n+fn infer_ops_index() {\n+    let (db, pos) = TestDB::with_position(\n+        r#\"\n+//- /main.rs crate:main deps:std\n+\n+struct Bar;\n+struct Foo;\n+\n+impl std::ops::Index<u32> for Bar {\n+    type Output = Foo;\n+}\n+\n+fn test() {\n+    let a = Bar;\n+    let b = a[1];\n+    b<|>;\n+}\n+\n+//- /std.rs crate:std\n+\n+#[prelude_import] use ops::*;\n+mod ops {\n+    pub trait Index<Idx> {\n+        type Output;\n+    }\n+}\n+\"#,\n+    );\n+    assert_eq!(\"Foo\", type_at_pos(&db, pos));\n+}\n+\n+#[test]\n+fn deref_trait() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+#[lang = \"deref\"]\n+trait Deref {\n+    type Target;\n+    fn deref(&self) -> &Self::Target;\n+}\n+\n+struct Arc<T>;\n+impl<T> Deref for Arc<T> {\n+    type Target = T;\n+}\n+\n+struct S;\n+impl S {\n+    fn foo(&self) -> u128 {}\n+}\n+\n+fn test(s: Arc<S>) {\n+    (*s, s.foo())<|>;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"(S, u128)\");\n+}\n+\n+#[test]\n+fn deref_trait_with_inference_var() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+#[lang = \"deref\"]\n+trait Deref {\n+    type Target;\n+    fn deref(&self) -> &Self::Target;\n+}\n+\n+struct Arc<T>;\n+fn new_arc<T>() -> Arc<T> {}\n+impl<T> Deref for Arc<T> {\n+    type Target = T;\n+}\n+\n+struct S;\n+fn foo(a: Arc<S>) {}\n+\n+fn test() {\n+    let a = new_arc();\n+    let b = (*a)<|>;\n+    foo(a);\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"S\");\n+}\n+\n+#[test]\n+fn deref_trait_infinite_recursion() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+#[lang = \"deref\"]\n+trait Deref {\n+    type Target;\n+    fn deref(&self) -> &Self::Target;\n+}\n+\n+struct S;\n+\n+impl Deref for S {\n+    type Target = S;\n+}\n+\n+fn test(s: S) {\n+    s.foo()<|>;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"{unknown}\");\n+}\n+\n+#[test]\n+fn deref_trait_with_question_mark_size() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+#[lang = \"deref\"]\n+trait Deref {\n+    type Target;\n+    fn deref(&self) -> &Self::Target;\n+}\n+\n+struct Arc<T>;\n+impl<T> Deref for Arc<T> {\n+    type Target = T;\n+}\n+\n+struct S;\n+impl S {\n+    fn foo(&self) -> u128 {}\n+}\n+\n+fn test(s: Arc<S>) {\n+    (*s, s.foo())<|>;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"(S, u128)\");\n+}\n+\n+#[test]\n+fn obligation_from_function_clause() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+struct S;\n+\n+trait Trait<T> {}\n+impl Trait<u32> for S {}\n+\n+fn foo<T: Trait<U>, U>(t: T) -> U {}\n+\n+fn test(s: S) {\n+    foo(s)<|>;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"u32\");\n+}\n+\n+#[test]\n+fn obligation_from_method_clause() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+struct S;\n+\n+trait Trait<T> {}\n+impl Trait<isize> for S {}\n+\n+struct O;\n+impl O {\n+    fn foo<T: Trait<U>, U>(&self, t: T) -> U {}\n+}\n+\n+fn test() {\n+    O.foo(S)<|>;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"isize\");\n+}\n+\n+#[test]\n+fn obligation_from_self_method_clause() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+struct S;\n+\n+trait Trait<T> {}\n+impl Trait<i64> for S {}\n+\n+impl S {\n+    fn foo<U>(&self) -> U where Self: Trait<U> {}\n+}\n+\n+fn test() {\n+    S.foo()<|>;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"i64\");\n+}\n+\n+#[test]\n+fn obligation_from_impl_clause() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+struct S;\n+\n+trait Trait<T> {}\n+impl Trait<&str> for S {}\n+\n+struct O<T>;\n+impl<U, T: Trait<U>> O<T> {\n+    fn foo(&self) -> U {}\n+}\n+\n+fn test(o: O<S>) {\n+    o.foo()<|>;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"&str\");\n+}\n+\n+#[test]\n+fn generic_param_env_1() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Clone {}\n+trait Trait { fn foo(self) -> u128; }\n+struct S;\n+impl Clone for S {}\n+impl<T> Trait for T where T: Clone {}\n+fn test<T: Clone>(t: T) { t.foo()<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"u128\");\n+}\n+\n+#[test]\n+fn generic_param_env_1_not_met() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Clone {}\n+trait Trait { fn foo(self) -> u128; }\n+struct S;\n+impl Clone for S {}\n+impl<T> Trait for T where T: Clone {}\n+fn test<T>(t: T) { t.foo()<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"{unknown}\");\n+}\n+\n+#[test]\n+fn generic_param_env_2() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Trait { fn foo(self) -> u128; }\n+struct S;\n+impl Trait for S {}\n+fn test<T: Trait>(t: T) { t.foo()<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"u128\");\n+}\n+\n+#[test]\n+fn generic_param_env_2_not_met() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Trait { fn foo(self) -> u128; }\n+struct S;\n+impl Trait for S {}\n+fn test<T>(t: T) { t.foo()<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"{unknown}\");\n+}\n+\n+#[test]\n+fn generic_param_env_deref() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+#[lang = \"deref\"]\n+trait Deref {\n+    type Target;\n+}\n+trait Trait {}\n+impl<T> Deref for T where T: Trait {\n+    type Target = i128;\n+}\n+fn test<T: Trait>(t: T) { (*t)<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"i128\");\n+}\n+\n+#[test]\n+fn associated_type_placeholder() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+pub trait ApplyL {\n+    type Out;\n+}\n+\n+pub struct RefMutL<T>;\n+\n+impl<T> ApplyL for RefMutL<T> {\n+    type Out = <T as ApplyL>::Out;\n+}\n+\n+fn test<T: ApplyL>() {\n+    let y: <RefMutL<T> as ApplyL>::Out = no_matter;\n+    y<|>;\n+}\n+\"#,\n+    );\n+    // inside the generic function, the associated type gets normalized to a placeholder `ApplL::Out<T>` [https://rust-lang.github.io/rustc-guide/traits/associated-types.html#placeholder-associated-types].\n+    // FIXME: fix type parameter names going missing when going through Chalk\n+    assert_eq!(t, \"ApplyL::Out<[missing name]>\");\n+}\n+\n+#[test]\n+fn associated_type_placeholder_2() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+pub trait ApplyL {\n+    type Out;\n+}\n+fn foo<T: ApplyL>(t: T) -> <T as ApplyL>::Out;\n+\n+fn test<T: ApplyL>(t: T) {\n+    let y = foo(t);\n+    y<|>;\n+}\n+\"#,\n+    );\n+    // FIXME here Chalk doesn't normalize the type to a placeholder. I think we\n+    // need to add a rule like Normalize(<T as ApplyL>::Out -> ApplyL::Out<T>)\n+    // to the trait env ourselves here; probably Chalk can't do this by itself.\n+    // assert_eq!(t, \"ApplyL::Out<[missing name]>\");\n+    assert_eq!(t, \"{unknown}\");\n+}\n+\n+#[test]\n+fn impl_trait() {\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Trait<T> {\n+    fn foo(&self) -> T;\n+    fn foo2(&self) -> i64;\n+}\n+fn bar() -> impl Trait<u64> {}\n+\n+fn test(x: impl Trait<u64>, y: &impl Trait<u64>) {\n+    x;\n+    y;\n+    let z = bar();\n+    x.foo();\n+    y.foo();\n+    z.foo();\n+    x.foo2();\n+    y.foo2();\n+    z.foo2();\n+}\n+\"#),\n+        @r###\"\n+    [30; 34) 'self': &Self\n+    [55; 59) 'self': &Self\n+    [99; 101) '{}': ()\n+    [111; 112) 'x': impl Trait<u64>\n+    [131; 132) 'y': &impl Trait<u64>\n+    [152; 269) '{     ...2(); }': ()\n+    [158; 159) 'x': impl Trait<u64>\n+    [165; 166) 'y': &impl Trait<u64>\n+    [176; 177) 'z': impl Trait<u64>\n+    [180; 183) 'bar': fn bar() -> impl Trait<u64>\n+    [180; 185) 'bar()': impl Trait<u64>\n+    [191; 192) 'x': impl Trait<u64>\n+    [191; 198) 'x.foo()': u64\n+    [204; 205) 'y': &impl Trait<u64>\n+    [204; 211) 'y.foo()': u64\n+    [217; 218) 'z': impl Trait<u64>\n+    [217; 224) 'z.foo()': u64\n+    [230; 231) 'x': impl Trait<u64>\n+    [230; 238) 'x.foo2()': i64\n+    [244; 245) 'y': &impl Trait<u64>\n+    [244; 252) 'y.foo2()': i64\n+    [258; 259) 'z': impl Trait<u64>\n+    [258; 266) 'z.foo2()': i64\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn dyn_trait() {\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Trait<T> {\n+    fn foo(&self) -> T;\n+    fn foo2(&self) -> i64;\n+}\n+fn bar() -> dyn Trait<u64> {}\n+\n+fn test(x: dyn Trait<u64>, y: &dyn Trait<u64>) {\n+    x;\n+    y;\n+    let z = bar();\n+    x.foo();\n+    y.foo();\n+    z.foo();\n+    x.foo2();\n+    y.foo2();\n+    z.foo2();\n+}\n+\"#),\n+        @r###\"\n+    [30; 34) 'self': &Self\n+    [55; 59) 'self': &Self\n+    [98; 100) '{}': ()\n+    [110; 111) 'x': dyn Trait<u64>\n+    [129; 130) 'y': &dyn Trait<u64>\n+    [149; 266) '{     ...2(); }': ()\n+    [155; 156) 'x': dyn Trait<u64>\n+    [162; 163) 'y': &dyn Trait<u64>\n+    [173; 174) 'z': dyn Trait<u64>\n+    [177; 180) 'bar': fn bar() -> dyn Trait<u64>\n+    [177; 182) 'bar()': dyn Trait<u64>\n+    [188; 189) 'x': dyn Trait<u64>\n+    [188; 195) 'x.foo()': u64\n+    [201; 202) 'y': &dyn Trait<u64>\n+    [201; 208) 'y.foo()': u64\n+    [214; 215) 'z': dyn Trait<u64>\n+    [214; 221) 'z.foo()': u64\n+    [227; 228) 'x': dyn Trait<u64>\n+    [227; 235) 'x.foo2()': i64\n+    [241; 242) 'y': &dyn Trait<u64>\n+    [241; 249) 'y.foo2()': i64\n+    [255; 256) 'z': dyn Trait<u64>\n+    [255; 263) 'z.foo2()': i64\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn dyn_trait_bare() {\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Trait {\n+    fn foo(&self) -> u64;\n+}\n+fn bar() -> Trait {}\n+\n+fn test(x: Trait, y: &Trait) -> u64 {\n+    x;\n+    y;\n+    let z = bar();\n+    x.foo();\n+    y.foo();\n+    z.foo();\n+}\n+\"#),\n+        @r###\"\n+    [27; 31) 'self': &Self\n+    [61; 63) '{}': ()\n+    [73; 74) 'x': dyn Trait\n+    [83; 84) 'y': &dyn Trait\n+    [101; 176) '{     ...o(); }': ()\n+    [107; 108) 'x': dyn Trait\n+    [114; 115) 'y': &dyn Trait\n+    [125; 126) 'z': dyn Trait\n+    [129; 132) 'bar': fn bar() -> dyn Trait\n+    [129; 134) 'bar()': dyn Trait\n+    [140; 141) 'x': dyn Trait\n+    [140; 147) 'x.foo()': u64\n+    [153; 154) 'y': &dyn Trait\n+    [153; 160) 'y.foo()': u64\n+    [166; 167) 'z': dyn Trait\n+    [166; 173) 'z.foo()': u64\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn weird_bounds() {\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Trait {}\n+fn test() {\n+    let a: impl Trait + 'lifetime = foo;\n+    let b: impl 'lifetime = foo;\n+    let b: impl (Trait) = foo;\n+    let b: impl ('lifetime) = foo;\n+    let d: impl ?Sized = foo;\n+    let e: impl Trait + ?Sized = foo;\n+}\n+\"#),\n+        @r###\"\n+    [26; 237) '{     ...foo; }': ()\n+    [36; 37) 'a': impl Trait + {error}\n+    [64; 67) 'foo': impl Trait + {error}\n+    [77; 78) 'b': impl {error}\n+    [97; 100) 'foo': impl {error}\n+    [110; 111) 'b': impl Trait\n+    [128; 131) 'foo': impl Trait\n+    [141; 142) 'b': impl {error}\n+    [163; 166) 'foo': impl {error}\n+    [176; 177) 'd': impl {error}\n+    [193; 196) 'foo': impl {error}\n+    [206; 207) 'e': impl Trait + {error}\n+    [231; 234) 'foo': impl Trait + {error}\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn error_bound_chalk() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Trait {\n+    fn foo(&self) -> u32 {}\n+}\n+\n+fn test(x: (impl Trait + UnknownTrait)) {\n+    x.foo()<|>;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"u32\");\n+}\n+\n+#[test]\n+fn assoc_type_bindings() {\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Trait {\n+    type Type;\n+}\n+\n+fn get<T: Trait>(t: T) -> <T as Trait>::Type {}\n+fn get2<U, T: Trait<Type = U>>(t: T) -> U {}\n+fn set<T: Trait<Type = u64>>(t: T) -> T {t}\n+\n+struct S<T>;\n+impl<T> Trait for S<T> { type Type = T; }\n+\n+fn test<T: Trait<Type = u32>>(x: T, y: impl Trait<Type = i64>) {\n+    get(x);\n+    get2(x);\n+    get(y);\n+    get2(y);\n+    get(set(S));\n+    get2(set(S));\n+    get2(S::<str>);\n+}\n+\"#),\n+        @r###\"\n+    [50; 51) 't': T\n+    [78; 80) '{}': ()\n+    [112; 113) 't': T\n+    [123; 125) '{}': ()\n+    [155; 156) 't': T\n+    [166; 169) '{t}': T\n+    [167; 168) 't': T\n+    [257; 258) 'x': T\n+    [263; 264) 'y': impl Trait<Type = i64>\n+    [290; 398) '{     ...r>); }': ()\n+    [296; 299) 'get': fn get<T>(T) -> <T as Trait>::Type\n+    [296; 302) 'get(x)': {unknown}\n+    [300; 301) 'x': T\n+    [308; 312) 'get2': fn get2<{unknown}, T>(T) -> U\n+    [308; 315) 'get2(x)': {unknown}\n+    [313; 314) 'x': T\n+    [321; 324) 'get': fn get<impl Trait<Type = i64>>(T) -> <T as Trait>::Type\n+    [321; 327) 'get(y)': {unknown}\n+    [325; 326) 'y': impl Trait<Type = i64>\n+    [333; 337) 'get2': fn get2<{unknown}, impl Trait<Type = i64>>(T) -> U\n+    [333; 340) 'get2(y)': {unknown}\n+    [338; 339) 'y': impl Trait<Type = i64>\n+    [346; 349) 'get': fn get<S<u64>>(T) -> <T as Trait>::Type\n+    [346; 357) 'get(set(S))': u64\n+    [350; 353) 'set': fn set<S<u64>>(T) -> T\n+    [350; 356) 'set(S)': S<u64>\n+    [354; 355) 'S': S<u64>\n+    [363; 367) 'get2': fn get2<u64, S<u64>>(T) -> U\n+    [363; 375) 'get2(set(S))': u64\n+    [368; 371) 'set': fn set<S<u64>>(T) -> T\n+    [368; 374) 'set(S)': S<u64>\n+    [372; 373) 'S': S<u64>\n+    [381; 385) 'get2': fn get2<str, S<str>>(T) -> U\n+    [381; 395) 'get2(S::<str>)': str\n+    [386; 394) 'S::<str>': S<str>\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn impl_trait_assoc_binding_projection_bug() {\n+    let (db, pos) = TestDB::with_position(\n+        r#\"\n+//- /main.rs crate:main deps:std\n+pub trait Language {\n+    type Kind;\n+}\n+pub enum RustLanguage {}\n+impl Language for RustLanguage {\n+    type Kind = SyntaxKind;\n+}\n+struct SyntaxNode<L> {}\n+fn foo() -> impl Iterator<Item = SyntaxNode<RustLanguage>> {}\n+\n+trait Clone {\n+    fn clone(&self) -> Self;\n+}\n+\n+fn api_walkthrough() {\n+    for node in foo() {\n+        node.clone()<|>;\n+    }\n+}\n+\n+//- /std.rs crate:std\n+#[prelude_import] use iter::*;\n+mod iter {\n+    trait IntoIterator {\n+        type Item;\n+    }\n+    trait Iterator {\n+        type Item;\n+    }\n+    impl<T: Iterator> IntoIterator for T {\n+        type Item = <T as Iterator>::Item;\n+    }\n+}\n+\"#,\n+    );\n+    assert_eq!(\"{unknown}\", type_at_pos(&db, pos));\n+}\n+\n+#[test]\n+fn projection_eq_within_chalk() {\n+    // std::env::set_var(\"CHALK_DEBUG\", \"1\");\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Trait1 {\n+    type Type;\n+}\n+trait Trait2<T> {\n+    fn foo(self) -> T;\n+}\n+impl<T, U> Trait2<T> for U where U: Trait1<Type = T> {}\n+\n+fn test<T: Trait1<Type = u32>>(x: T) {\n+    x.foo();\n+}\n+\"#),\n+        @r###\"\n+    [62; 66) 'self': Self\n+    [164; 165) 'x': T\n+    [170; 186) '{     ...o(); }': ()\n+    [176; 177) 'x': T\n+    [176; 183) 'x.foo()': {unknown}\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn where_clause_trait_in_scope_for_method_resolution() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+mod foo {\n+    trait Trait {\n+        fn foo(&self) -> u32 {}\n+    }\n+}\n+\n+fn test<T: foo::Trait>(x: T) {\n+    x.foo()<|>;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"u32\");\n+}\n+\n+#[test]\n+fn super_trait_method_resolution() {\n+    assert_snapshot!(\n+        infer(r#\"\n+mod foo {\n+    trait SuperTrait {\n+        fn foo(&self) -> u32 {}\n+    }\n+}\n+trait Trait1: foo::SuperTrait {}\n+trait Trait2 where Self: foo::SuperTrait {}\n+\n+fn test<T: Trait1, U: Trait2>(x: T, y: U) {\n+    x.foo();\n+    y.foo();\n+}\n+\"#),\n+        @r###\"\n+    [50; 54) 'self': &Self\n+    [63; 65) '{}': ()\n+    [182; 183) 'x': T\n+    [188; 189) 'y': U\n+    [194; 223) '{     ...o(); }': ()\n+    [200; 201) 'x': T\n+    [200; 207) 'x.foo()': u32\n+    [213; 214) 'y': U\n+    [213; 220) 'y.foo()': u32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn super_trait_cycle() {\n+    // This just needs to not crash\n+    assert_snapshot!(\n+        infer(r#\"\n+trait A: B {}\n+trait B: A {}\n+\n+fn test<T: A>(x: T) {\n+    x.foo();\n+}\n+\"#),\n+        @r###\"\n+    [44; 45) 'x': T\n+    [50; 66) '{     ...o(); }': ()\n+    [56; 57) 'x': T\n+    [56; 63) 'x.foo()': {unknown}\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn super_trait_assoc_type_bounds() {\n+    assert_snapshot!(\n+        infer(r#\"\n+trait SuperTrait { type Type; }\n+trait Trait where Self: SuperTrait {}\n+\n+fn get2<U, T: Trait<Type = U>>(t: T) -> U {}\n+fn set<T: Trait<Type = u64>>(t: T) -> T {t}\n+\n+struct S<T>;\n+impl<T> SuperTrait for S<T> { type Type = T; }\n+impl<T> Trait for S<T> {}\n+\n+fn test() {\n+    get2(set(S));\n+}\n+\"#),\n+        @r###\"\n+    [103; 104) 't': T\n+    [114; 116) '{}': ()\n+    [146; 147) 't': T\n+    [157; 160) '{t}': T\n+    [158; 159) 't': T\n+    [259; 280) '{     ...S)); }': ()\n+    [265; 269) 'get2': fn get2<u64, S<u64>>(T) -> U\n+    [265; 277) 'get2(set(S))': u64\n+    [270; 273) 'set': fn set<S<u64>>(T) -> T\n+    [270; 276) 'set(S)': S<u64>\n+    [274; 275) 'S': S<u64>\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn fn_trait() {\n+    assert_snapshot!(\n+        infer(r#\"\n+trait FnOnce<Args> {\n+    type Output;\n+\n+    fn call_once(self, args: Args) -> <Self as FnOnce<Args>>::Output;\n+}\n+\n+fn test<F: FnOnce(u32, u64) -> u128>(f: F) {\n+    f.call_once((1, 2));\n+}\n+\"#),\n+        @r###\"\n+    [57; 61) 'self': Self\n+    [63; 67) 'args': Args\n+    [150; 151) 'f': F\n+    [156; 184) '{     ...2)); }': ()\n+    [162; 163) 'f': F\n+    [162; 181) 'f.call...1, 2))': {unknown}\n+    [174; 180) '(1, 2)': (u32, u64)\n+    [175; 176) '1': u32\n+    [178; 179) '2': u64\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn closure_1() {\n+    assert_snapshot!(\n+        infer(r#\"\n+#[lang = \"fn_once\"]\n+trait FnOnce<Args> {\n+    type Output;\n+}\n+\n+enum Option<T> { Some(T), None }\n+impl<T> Option<T> {\n+    fn map<U, F: FnOnce(T) -> U>(self, f: F) -> Option<U> {}\n+}\n+\n+fn test() {\n+    let x = Option::Some(1u32);\n+    x.map(|v| v + 1);\n+    x.map(|_v| 1u64);\n+    let y: Option<i64> = x.map(|_v| 1);\n+}\n+\"#),\n+        @r###\"\n+    [148; 152) 'self': Option<T>\n+    [154; 155) 'f': F\n+    [173; 175) '{}': ()\n+    [189; 308) '{     ... 1); }': ()\n+    [199; 200) 'x': Option<u32>\n+    [203; 215) 'Option::Some': Some<u32>(T) -> Option<T>\n+    [203; 221) 'Option...(1u32)': Option<u32>\n+    [216; 220) '1u32': u32\n+    [227; 228) 'x': Option<u32>\n+    [227; 243) 'x.map(...v + 1)': Option<u32>\n+    [233; 242) '|v| v + 1': |u32| -> u32\n+    [234; 235) 'v': u32\n+    [237; 238) 'v': u32\n+    [237; 242) 'v + 1': u32\n+    [241; 242) '1': u32\n+    [249; 250) 'x': Option<u32>\n+    [249; 265) 'x.map(... 1u64)': Option<u64>\n+    [255; 264) '|_v| 1u64': |u32| -> u64\n+    [256; 258) '_v': u32\n+    [260; 264) '1u64': u64\n+    [275; 276) 'y': Option<i64>\n+    [292; 293) 'x': Option<u32>\n+    [292; 305) 'x.map(|_v| 1)': Option<i64>\n+    [298; 304) '|_v| 1': |u32| -> i64\n+    [299; 301) '_v': u32\n+    [303; 304) '1': i64\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn closure_2() {\n+    assert_snapshot!(\n+        infer(r#\"\n+trait FnOnce<Args> {\n+    type Output;\n+}\n+\n+fn test<F: FnOnce(u32) -> u64>(f: F) {\n+    f(1);\n+    let g = |v| v + 1;\n+    g(1u64);\n+    let h = |v| 1u128 + v;\n+}\n+\"#),\n+        @r###\"\n+    [73; 74) 'f': F\n+    [79; 155) '{     ...+ v; }': ()\n+    [85; 86) 'f': F\n+    [85; 89) 'f(1)': {unknown}\n+    [87; 88) '1': i32\n+    [99; 100) 'g': |u64| -> i32\n+    [103; 112) '|v| v + 1': |u64| -> i32\n+    [104; 105) 'v': u64\n+    [107; 108) 'v': u64\n+    [107; 112) 'v + 1': i32\n+    [111; 112) '1': i32\n+    [118; 119) 'g': |u64| -> i32\n+    [118; 125) 'g(1u64)': i32\n+    [120; 124) '1u64': u64\n+    [135; 136) 'h': |u128| -> u128\n+    [139; 152) '|v| 1u128 + v': |u128| -> u128\n+    [140; 141) 'v': u128\n+    [143; 148) '1u128': u128\n+    [143; 152) '1u128 + v': u128\n+    [151; 152) 'v': u128\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn closure_as_argument_inference_order() {\n+    assert_snapshot!(\n+        infer(r#\"\n+#[lang = \"fn_once\"]\n+trait FnOnce<Args> {\n+    type Output;\n+}\n+\n+fn foo1<T, U, F: FnOnce(T) -> U>(x: T, f: F) -> U {}\n+fn foo2<T, U, F: FnOnce(T) -> U>(f: F, x: T) -> U {}\n+\n+struct S;\n+impl S {\n+    fn method(self) -> u64;\n+\n+    fn foo1<T, U, F: FnOnce(T) -> U>(self, x: T, f: F) -> U {}\n+    fn foo2<T, U, F: FnOnce(T) -> U>(self, f: F, x: T) -> U {}\n+}\n+\n+fn test() {\n+    let x1 = foo1(S, |s| s.method());\n+    let x2 = foo2(|s| s.method(), S);\n+    let x3 = S.foo1(S, |s| s.method());\n+    let x4 = S.foo2(|s| s.method(), S);\n+}\n+\"#),\n+        @r###\"\n+    [95; 96) 'x': T\n+    [101; 102) 'f': F\n+    [112; 114) '{}': ()\n+    [148; 149) 'f': F\n+    [154; 155) 'x': T\n+    [165; 167) '{}': ()\n+    [202; 206) 'self': S\n+    [254; 258) 'self': S\n+    [260; 261) 'x': T\n+    [266; 267) 'f': F\n+    [277; 279) '{}': ()\n+    [317; 321) 'self': S\n+    [323; 324) 'f': F\n+    [329; 330) 'x': T\n+    [340; 342) '{}': ()\n+    [356; 515) '{     ... S); }': ()\n+    [366; 368) 'x1': u64\n+    [371; 375) 'foo1': fn foo1<S, u64, |S| -> u64>(T, F) -> U\n+    [371; 394) 'foo1(S...hod())': u64\n+    [376; 377) 'S': S\n+    [379; 393) '|s| s.method()': |S| -> u64\n+    [380; 381) 's': S\n+    [383; 384) 's': S\n+    [383; 393) 's.method()': u64\n+    [404; 406) 'x2': u64\n+    [409; 413) 'foo2': fn foo2<S, u64, |S| -> u64>(F, T) -> U\n+    [409; 432) 'foo2(|...(), S)': u64\n+    [414; 428) '|s| s.method()': |S| -> u64\n+    [415; 416) 's': S\n+    [418; 419) 's': S\n+    [418; 428) 's.method()': u64\n+    [430; 431) 'S': S\n+    [442; 444) 'x3': u64\n+    [447; 448) 'S': S\n+    [447; 472) 'S.foo1...hod())': u64\n+    [454; 455) 'S': S\n+    [457; 471) '|s| s.method()': |S| -> u64\n+    [458; 459) 's': S\n+    [461; 462) 's': S\n+    [461; 471) 's.method()': u64\n+    [482; 484) 'x4': u64\n+    [487; 488) 'S': S\n+    [487; 512) 'S.foo2...(), S)': u64\n+    [494; 508) '|s| s.method()': |S| -> u64\n+    [495; 496) 's': S\n+    [498; 499) 's': S\n+    [498; 508) 's.method()': u64\n+    [510; 511) 'S': S\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn unselected_projection_in_trait_env_1() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Trait {\n+    type Item;\n+}\n+\n+trait Trait2 {\n+    fn foo(&self) -> u32;\n+}\n+\n+fn test<T: Trait>() where T::Item: Trait2 {\n+    let x: T::Item = no_matter;\n+    x.foo()<|>;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"u32\");\n+}\n+\n+#[test]\n+fn unselected_projection_in_trait_env_2() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Trait<T> {\n+    type Item;\n+}\n+\n+trait Trait2 {\n+    fn foo(&self) -> u32;\n+}\n+\n+fn test<T, U>() where T::Item: Trait2, T: Trait<U::Item>, U: Trait<()> {\n+    let x: T::Item = no_matter;\n+    x.foo()<|>;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"u32\");\n+}\n+\n+#[test]\n+fn trait_impl_self_ty() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Trait<T> {\n+   fn foo(&self);\n+}\n+\n+struct S;\n+\n+impl Trait<Self> for S {}\n+\n+fn test() {\n+    S.foo()<|>;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"()\");\n+}\n+\n+#[test]\n+fn trait_impl_self_ty_cycle() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Trait {\n+   fn foo(&self);\n+}\n+\n+struct S<T>;\n+\n+impl Trait for S<Self> {}\n+\n+fn test() {\n+    S.foo()<|>;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"{unknown}\");\n+}\n+\n+#[test]\n+fn unselected_projection_in_trait_env_cycle_1() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Trait {\n+    type Item;\n+}\n+\n+trait Trait2<T> {}\n+\n+fn test<T: Trait>() where T: Trait2<T::Item> {\n+    let x: T::Item = no_matter<|>;\n+}\n+\"#,\n+    );\n+    // this is a legitimate cycle\n+    assert_eq!(t, \"{unknown}\");\n+}\n+\n+#[test]\n+fn unselected_projection_in_trait_env_cycle_2() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Trait<T> {\n+    type Item;\n+}\n+\n+fn test<T, U>() where T: Trait<U::Item>, U: Trait<T::Item> {\n+    let x: T::Item = no_matter<|>;\n+}\n+\"#,\n+    );\n+    // this is a legitimate cycle\n+    assert_eq!(t, \"{unknown}\");\n+}\n+\n+#[test]\n+fn unify_impl_trait() {\n+    covers!(insert_vars_for_impl_trait);\n+    assert_snapshot!(\n+        infer_with_mismatches(r#\"\n+trait Trait<T> {}\n+\n+fn foo(x: impl Trait<u32>) { loop {} }\n+fn bar<T>(x: impl Trait<T>) -> T { loop {} }\n+\n+struct S<T>(T);\n+impl<T> Trait<T> for S<T> {}\n+\n+fn default<T>() -> T { loop {} }\n+\n+fn test() -> impl Trait<i32> {\n+    let s1 = S(default());\n+    foo(s1);\n+    let x: i32 = bar(S(default()));\n+    S(default())\n+}\n+\"#, true),\n+        @r###\"\n+    [27; 28) 'x': impl Trait<u32>\n+    [47; 58) '{ loop {} }': ()\n+    [49; 56) 'loop {}': !\n+    [54; 56) '{}': ()\n+    [69; 70) 'x': impl Trait<T>\n+    [92; 103) '{ loop {} }': T\n+    [94; 101) 'loop {}': !\n+    [99; 101) '{}': ()\n+    [172; 183) '{ loop {} }': T\n+    [174; 181) 'loop {}': !\n+    [179; 181) '{}': ()\n+    [214; 310) '{     ...t()) }': S<i32>\n+    [224; 226) 's1': S<u32>\n+    [229; 230) 'S': S<u32>(T) -> S<T>\n+    [229; 241) 'S(default())': S<u32>\n+    [231; 238) 'default': fn default<u32>() -> T\n+    [231; 240) 'default()': u32\n+    [247; 250) 'foo': fn foo(impl Trait<u32>) -> ()\n+    [247; 254) 'foo(s1)': ()\n+    [251; 253) 's1': S<u32>\n+    [264; 265) 'x': i32\n+    [273; 276) 'bar': fn bar<i32>(impl Trait<T>) -> T\n+    [273; 290) 'bar(S(...lt()))': i32\n+    [277; 278) 'S': S<i32>(T) -> S<T>\n+    [277; 289) 'S(default())': S<i32>\n+    [279; 286) 'default': fn default<i32>() -> T\n+    [279; 288) 'default()': i32\n+    [296; 297) 'S': S<i32>(T) -> S<T>\n+    [296; 308) 'S(default())': S<i32>\n+    [298; 305) 'default': fn default<i32>() -> T\n+    [298; 307) 'default()': i32\n+    \"###\n+    );\n+}"}, {"sha": "c4dc857bc7b9cbe3ad61b1a885fb53188114f2d2", "filename": "crates/ra_hir_ty/src/traits.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -1,7 +1,7 @@\n //! Trait solving using Chalk.\n use std::sync::{Arc, Mutex};\n \n-use chalk_ir::{cast::Cast, family::ChalkIr};\n+use chalk_ir::cast::Cast;\n use hir_def::{expr::ExprId, DefWithBodyId, ImplId, TraitId, TypeAliasId};\n use log::debug;\n use ra_db::{impl_intern_key, salsa, CrateId};\n@@ -12,14 +12,15 @@ use crate::db::HirDatabase;\n \n use super::{Canonical, GenericPredicate, HirDisplay, ProjectionTy, TraitRef, Ty, TypeWalk};\n \n-use self::chalk::{from_chalk, ToChalk};\n+use self::chalk::{from_chalk, ToChalk, TypeFamily};\n \n pub(crate) mod chalk;\n+mod builtin;\n \n #[derive(Debug, Clone)]\n pub struct TraitSolver {\n     krate: CrateId,\n-    inner: Arc<Mutex<chalk_solve::Solver<ChalkIr>>>,\n+    inner: Arc<Mutex<chalk_solve::Solver<TypeFamily>>>,\n }\n \n /// We need eq for salsa\n@@ -35,8 +36,8 @@ impl TraitSolver {\n     fn solve(\n         &self,\n         db: &impl HirDatabase,\n-        goal: &chalk_ir::UCanonical<chalk_ir::InEnvironment<chalk_ir::Goal<ChalkIr>>>,\n-    ) -> Option<chalk_solve::Solution<ChalkIr>> {\n+        goal: &chalk_ir::UCanonical<chalk_ir::InEnvironment<chalk_ir::Goal<TypeFamily>>>,\n+    ) -> Option<chalk_solve::Solution<TypeFamily>> {\n         let context = ChalkContext { db, krate: self.krate };\n         debug!(\"solve goal: {:?}\", goal);\n         let mut solver = match self.inner.lock() {\n@@ -200,17 +201,17 @@ pub(crate) fn trait_solve_query(\n \n fn solution_from_chalk(\n     db: &impl HirDatabase,\n-    solution: chalk_solve::Solution<ChalkIr>,\n+    solution: chalk_solve::Solution<TypeFamily>,\n ) -> Solution {\n-    let convert_subst = |subst: chalk_ir::Canonical<chalk_ir::Substitution<ChalkIr>>| {\n+    let convert_subst = |subst: chalk_ir::Canonical<chalk_ir::Substitution<TypeFamily>>| {\n         let value = subst\n             .value\n             .parameters\n             .into_iter()\n             .map(|p| {\n-                let ty = match p {\n-                    chalk_ir::Parameter(chalk_ir::ParameterKind::Ty(ty)) => from_chalk(db, ty),\n-                    chalk_ir::Parameter(chalk_ir::ParameterKind::Lifetime(_)) => unimplemented!(),\n+                let ty = match p.ty() {\n+                    Some(ty) => from_chalk(db, ty.clone()),\n+                    None => unimplemented!(),\n                 };\n                 ty\n             })\n@@ -290,7 +291,7 @@ impl FnTrait {\n     }\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct ClosureFnTraitImplData {\n     def: DefWithBodyId,\n     expr: ExprId,\n@@ -299,7 +300,7 @@ pub struct ClosureFnTraitImplData {\n \n /// An impl. Usually this comes from an impl block, but some built-in types get\n /// synthetic impls.\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub enum Impl {\n     /// A normal impl from an impl block.\n     ImplBlock(ImplId),"}, {"sha": "dd41176f0df66469b8bf4d5cb150bb8acd1721ca", "filename": "crates/ra_hir_ty/src/traits/builtin.rs", "status": "added", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fbuiltin.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "patch": "@@ -0,0 +1,178 @@\n+//! This module provides the built-in trait implementations, e.g. to make\n+//! closures implement `Fn`.\n+use hir_def::{expr::Expr, lang_item::LangItemTarget, TraitId, TypeAliasId};\n+use hir_expand::name::name;\n+use ra_db::CrateId;\n+\n+use super::{AssocTyValue, Impl};\n+use crate::{db::HirDatabase, ApplicationTy, Substs, TraitRef, Ty, TypeCtor};\n+\n+pub(super) struct BuiltinImplData {\n+    pub num_vars: usize,\n+    pub trait_ref: TraitRef,\n+    pub where_clauses: Vec<super::GenericPredicate>,\n+    pub assoc_ty_values: Vec<AssocTyValue>,\n+}\n+\n+pub(super) struct BuiltinImplAssocTyValueData {\n+    pub impl_: Impl,\n+    pub assoc_ty_id: TypeAliasId,\n+    pub num_vars: usize,\n+    pub value: Ty,\n+}\n+\n+pub(super) fn get_builtin_impls(\n+    db: &impl HirDatabase,\n+    krate: CrateId,\n+    ty: &Ty,\n+    trait_: TraitId,\n+    mut callback: impl FnMut(Impl),\n+) {\n+    // Note: since impl_datum needs to be infallible, we need to make sure here\n+    // that we have all prerequisites to build the respective impls.\n+    if let Ty::Apply(ApplicationTy { ctor: TypeCtor::Closure { def, expr }, .. }) = ty {\n+        for &fn_trait in [super::FnTrait::FnOnce, super::FnTrait::FnMut, super::FnTrait::Fn].iter()\n+        {\n+            if let Some(actual_trait) = get_fn_trait(db, krate, fn_trait) {\n+                if trait_ == actual_trait {\n+                    let impl_ = super::ClosureFnTraitImplData { def: *def, expr: *expr, fn_trait };\n+                    if check_closure_fn_trait_impl_prerequisites(db, krate, impl_) {\n+                        callback(Impl::ClosureFnTraitImpl(impl_));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+pub(super) fn impl_datum(db: &impl HirDatabase, krate: CrateId, impl_: Impl) -> BuiltinImplData {\n+    match impl_ {\n+        Impl::ImplBlock(_) => unreachable!(),\n+        Impl::ClosureFnTraitImpl(data) => closure_fn_trait_impl_datum(db, krate, data),\n+    }\n+}\n+\n+pub(super) fn associated_ty_value(\n+    db: &impl HirDatabase,\n+    krate: CrateId,\n+    data: AssocTyValue,\n+) -> BuiltinImplAssocTyValueData {\n+    match data {\n+        AssocTyValue::TypeAlias(_) => unreachable!(),\n+        AssocTyValue::ClosureFnTraitImplOutput(data) => {\n+            closure_fn_trait_output_assoc_ty_value(db, krate, data)\n+        }\n+    }\n+}\n+\n+fn check_closure_fn_trait_impl_prerequisites(\n+    db: &impl HirDatabase,\n+    krate: CrateId,\n+    data: super::ClosureFnTraitImplData,\n+) -> bool {\n+    // the respective Fn/FnOnce/FnMut trait needs to exist\n+    if get_fn_trait(db, krate, data.fn_trait).is_none() {\n+        return false;\n+    }\n+\n+    // FIXME: there are more assumptions that we should probably check here:\n+    // the traits having no type params, FnOnce being a supertrait\n+\n+    // the FnOnce trait needs to exist and have an assoc type named Output\n+    let fn_once_trait = match get_fn_trait(db, krate, super::FnTrait::FnOnce) {\n+        Some(t) => t,\n+        None => return false,\n+    };\n+    db.trait_data(fn_once_trait).associated_type_by_name(&name![Output]).is_some()\n+}\n+\n+fn closure_fn_trait_impl_datum(\n+    db: &impl HirDatabase,\n+    krate: CrateId,\n+    data: super::ClosureFnTraitImplData,\n+) -> BuiltinImplData {\n+    // for some closure |X, Y| -> Z:\n+    // impl<T, U, V> Fn<(T, U)> for closure<fn(T, U) -> V> { Output = V }\n+\n+    let trait_ = get_fn_trait(db, krate, data.fn_trait) // get corresponding fn trait\n+        // the existence of the Fn trait has been checked before\n+        .expect(\"fn trait for closure impl missing\");\n+\n+    let num_args: u16 = match &db.body(data.def.into())[data.expr] {\n+        Expr::Lambda { args, .. } => args.len() as u16,\n+        _ => {\n+            log::warn!(\"closure for closure type {:?} not found\", data);\n+            0\n+        }\n+    };\n+\n+    let arg_ty = Ty::apply(\n+        TypeCtor::Tuple { cardinality: num_args },\n+        Substs::builder(num_args as usize).fill_with_bound_vars(0).build(),\n+    );\n+    let sig_ty = Ty::apply(\n+        TypeCtor::FnPtr { num_args },\n+        Substs::builder(num_args as usize + 1).fill_with_bound_vars(0).build(),\n+    );\n+\n+    let self_ty = Ty::apply_one(TypeCtor::Closure { def: data.def, expr: data.expr }, sig_ty);\n+\n+    let trait_ref = TraitRef {\n+        trait_: trait_.into(),\n+        substs: Substs::build_for_def(db, trait_).push(self_ty).push(arg_ty).build(),\n+    };\n+\n+    let output_ty_id = AssocTyValue::ClosureFnTraitImplOutput(data.clone());\n+\n+    BuiltinImplData {\n+        num_vars: num_args as usize + 1,\n+        trait_ref,\n+        where_clauses: Vec::new(),\n+        assoc_ty_values: vec![output_ty_id],\n+    }\n+}\n+\n+fn closure_fn_trait_output_assoc_ty_value(\n+    db: &impl HirDatabase,\n+    krate: CrateId,\n+    data: super::ClosureFnTraitImplData,\n+) -> BuiltinImplAssocTyValueData {\n+    let impl_ = Impl::ClosureFnTraitImpl(data.clone());\n+\n+    let num_args: u16 = match &db.body(data.def.into())[data.expr] {\n+        Expr::Lambda { args, .. } => args.len() as u16,\n+        _ => {\n+            log::warn!(\"closure for closure type {:?} not found\", data);\n+            0\n+        }\n+    };\n+\n+    let output_ty = Ty::Bound(num_args.into());\n+\n+    let fn_once_trait =\n+        get_fn_trait(db, krate, super::FnTrait::FnOnce).expect(\"assoc ty value should not exist\");\n+\n+    let output_ty_id = db\n+        .trait_data(fn_once_trait)\n+        .associated_type_by_name(&name![Output])\n+        .expect(\"assoc ty value should not exist\");\n+\n+    BuiltinImplAssocTyValueData {\n+        impl_,\n+        assoc_ty_id: output_ty_id,\n+        num_vars: num_args as usize + 1,\n+        value: output_ty,\n+    }\n+}\n+\n+fn get_fn_trait(\n+    db: &impl HirDatabase,\n+    krate: CrateId,\n+    fn_trait: super::FnTrait,\n+) -> Option<TraitId> {\n+    let target = db.lang_item(krate, fn_trait.lang_item_name().into())?;\n+    match target {\n+        LangItemTarget::TraitId(t) => Some(t),\n+        _ => None,\n+    }\n+}"}, {"sha": "555930c9bfa12afbdec21d679f39bc63b42ed8c4", "filename": "crates/ra_hir_ty/src/traits/chalk.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "0b1806a84fd40faa15e896910d2b60c5443e22b3", "filename": "crates/ra_hir_ty/src/utils.rs", "status": "modified", "additions": 84, "deletions": 6, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_ty%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_hir_ty%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Futils.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "e3439ae3134ca94f5b918881e4ad403977209b34", "filename": "crates/ra_ide/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_ide%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_ide%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2FCargo.toml?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "2c2b6fa48910463731657630cc619d1c7caf9605", "filename": "crates/ra_ide/src/call_info.rs", "status": "modified", "additions": 33, "deletions": 10, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_ide%2Fsrc%2Fcall_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_ide%2Fsrc%2Fcall_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcall_info.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "387a9cafb65751833f6335248c3f2325121e4657", "filename": "crates/ra_ide/src/change.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_ide%2Fsrc%2Fchange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_ide%2Fsrc%2Fchange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fchange.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "294964887a81a39dcfc5ac57ccfd70735573eccd", "filename": "crates/ra_ide/src/completion/complete_dot.rs", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "cc1f7c830528c455e95ab2fa8a84d32749ee5aa4", "filename": "crates/ra_ide/src/completion/complete_path.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_path.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "5470dc291fa4c4f2a52b8335356afb10065e9dc8", "filename": "crates/ra_ide/src/completion/complete_postfix.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_postfix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_postfix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_postfix.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "458d7525ec9f6d93977da9dc1ef2927750a87bc3", "filename": "crates/ra_ide/src/completion/complete_scope.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_scope.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "48d69f7e54f5bb1670cd0b1d24603f99cc0332e2", "filename": "crates/ra_ide/src/completion/completion_context.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "47d0aed6fb59426733e58241b698769efaa0c518", "filename": "crates/ra_ide/src/db.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_ide%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_ide%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdb.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "c50a70d9900ee4072a4e5f0880e3ddd13f18e09f", "filename": "crates/ra_ide/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "fbe89841b02111ae8ec3b0680c33cf4a527a5c2a", "filename": "crates/ra_ide/src/display.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_ide%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_ide%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdisplay.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "b9ae67828481943903eb794fc799f35b830b430d", "filename": "crates/ra_ide/src/display/navigation_target.rs", "status": "modified", "additions": 46, "deletions": 38, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_ide%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_ide%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdisplay%2Fnavigation_target.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "7a22bb0a4e232f257403ffb89598796ca47cb310", "filename": "crates/ra_ide/src/expand.rs", "status": "modified", "additions": 59, "deletions": 30, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_ide%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_ide%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fexpand.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "bdbc31704b01626c5650299de59fc08bfa0d276f", "filename": "crates/ra_ide/src/expand_macro.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_ide%2Fsrc%2Fexpand_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_ide%2Fsrc%2Fexpand_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fexpand_macro.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "1ec41a117bdf25808a9c8a2c9754bc2a2d7aa917", "filename": "crates/ra_ide/src/extend_selection.rs", "status": "modified", "additions": 67, "deletions": 13, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_ide%2Fsrc%2Fextend_selection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_ide%2Fsrc%2Fextend_selection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fextend_selection.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "79d332e8cea6f4aa180596968fb321fcc854c349", "filename": "crates/ra_ide/src/goto_definition.rs", "status": "modified", "additions": 314, "deletions": 79, "changes": 393, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_ide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_ide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fgoto_definition.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "ce8b6c72a1ae5f5ab6c92b1b98dc90001bd7c1a4", "filename": "crates/ra_ide/src/goto_type_definition.rs", "status": "modified", "additions": 41, "deletions": 2, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_ide%2Fsrc%2Fgoto_type_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_ide%2Fsrc%2Fgoto_type_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fgoto_type_definition.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "35e39f965241f5c24b56c0d20083d9ec6d1ad97b", "filename": "crates/ra_ide/src/hover.rs", "status": "modified", "additions": 64, "deletions": 62, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_ide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_ide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fhover.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "9b165ee2aa065adfc2d20768a28fe9d848ce94ce", "filename": "crates/ra_ide/src/impls.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_ide%2Fsrc%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_ide%2Fsrc%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fimpls.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "c5e406977395fae9e143c557843c1e131a227d7b", "filename": "crates/ra_ide/src/inlay_hints.rs", "status": "modified", "additions": 49, "deletions": 19, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "779a81b2c0aa0d9ee9a47a02081d05311fa6da8d", "filename": "crates/ra_ide/src/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_ide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_ide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Flib.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "077a44473b86e83f81af18053d11668f86593bcf", "filename": "crates/ra_ide/src/marks.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_ide%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_ide%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fmarks.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "f5a788c07cff07b6f3a1032ff5458e6c1a56b599", "filename": "crates/ra_ide/src/parent_module.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_ide%2Fsrc%2Fparent_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_ide%2Fsrc%2Fparent_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fparent_module.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "e3ecde50dd8073544a520d2173c5ae6b64fdd6c2", "filename": "crates/ra_ide/src/references.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_ide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_ide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "3483a7176c362772c0fa21ab352a4eabf5ba02c7", "filename": "crates/ra_ide/src/references/classify.rs", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_ide%2Fsrc%2Freferences%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_ide%2Fsrc%2Freferences%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences%2Fclassify.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "8c67c88639f9b48ea028e91a495d2de6f5704d10", "filename": "crates/ra_ide/src/references/name_definition.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_ide%2Fsrc%2Freferences%2Fname_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_ide%2Fsrc%2Freferences%2Fname_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences%2Fname_definition.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "b804d5f6dac2098f0ead08ccfaa133c16a82a122", "filename": "crates/ra_ide/src/references/rename.rs", "status": "modified", "additions": 52, "deletions": 2, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_ide%2Fsrc%2Freferences%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_ide%2Fsrc%2Freferences%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences%2Frename.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "241dd358f9a61d134d5bc7c3ac36c6d326e6c0b1", "filename": "crates/ra_ide/src/references/search_scope.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_ide%2Fsrc%2Freferences%2Fsearch_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_ide%2Fsrc%2Freferences%2Fsearch_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences%2Fsearch_scope.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "e213e1a06d2bdc5ed41aeffa1c18575754cdc68a", "filename": "crates/ra_ide/src/runnables.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_ide%2Fsrc%2Frunnables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_ide%2Fsrc%2Frunnables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Frunnables.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "a097cf8e84dfa55738853a0d72ac6f5f022be91e", "filename": "crates/ra_ide/src/snapshots/highlighting.html", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlighting.html", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlighting.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlighting.html?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "110556c0921272024db9fa6cd4add86b390a7db0", "filename": "crates/ra_ide/src/snapshots/rainbow_highlighting.html", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Frainbow_highlighting.html", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Frainbow_highlighting.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Frainbow_highlighting.html?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "0228ee7e90f6bb53f27162bf41d4cc47a719b5f9", "filename": "crates/ra_ide/src/syntax_highlighting.rs", "status": "modified", "additions": 85, "deletions": 44, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "60cbc38a95d476e565b4e84ae7fa033f7a4fbda7", "filename": "crates/ra_lsp_server/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_lsp_server%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_lsp_server%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2FCargo.toml?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "05f9772c0410221640961dedfdb45e3f56fd748a", "filename": "crates/ra_lsp_server/build.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_lsp_server%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_lsp_server%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fbuild.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "eeca67ee190957adcc8e4a5aa04ac3f224aa0fbd", "filename": "crates/ra_lsp_server/src/caps.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_lsp_server%2Fsrc%2Fcaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_lsp_server%2Fsrc%2Fcaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fcaps.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "67942aa4147cd1f6bd273d87fe369dfdf04e142b", "filename": "crates/ra_lsp_server/src/config.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_lsp_server%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_lsp_server%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fconfig.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "e93d4ea33d59d810d069745ef650386bb692a579", "filename": "crates/ra_lsp_server/src/conv.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_lsp_server%2Fsrc%2Fconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_lsp_server%2Fsrc%2Fconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fconv.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "cdd925c9f3efd1ff9759ebff4c6571cf7ce659d3", "filename": "crates/ra_lsp_server/src/main.rs", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_lsp_server%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_lsp_server%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "dda318e43eb80bf96146b1dd8f05af83333ad062", "filename": "crates/ra_lsp_server/src/main_loop.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "39eb3df3e55acf72dae02b9e4a4433f40d245d9b", "filename": "crates/ra_lsp_server/src/main_loop/handlers.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "2d221346418d20c82914c4b6d5ce2f3f93aa33d5", "filename": "crates/ra_lsp_server/src/main_loop/pending_requests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fpending_requests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fpending_requests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fpending_requests.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "b0bae90f5c10af930a1a4b128440e636d01ce9d4", "filename": "crates/ra_lsp_server/src/main_loop/subscriptions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fsubscriptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fsubscriptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fsubscriptions.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "76bef45ccc2041d716ccd311825e91ca6179a4f3", "filename": "crates/ra_lsp_server/src/markdown.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_lsp_server%2Fsrc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_lsp_server%2Fsrc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmarkdown.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "b34e6f9b89b1da791d5f5fbcd7fb723ec84e2fff", "filename": "crates/ra_lsp_server/src/req.rs", "status": "modified", "additions": 4, "deletions": 25, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_lsp_server%2Fsrc%2Freq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_lsp_server%2Fsrc%2Freq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Freq.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "79431e7e6f62087e72635528e3c0190362d2eecd", "filename": "crates/ra_lsp_server/src/world.rs", "status": "modified", "additions": 69, "deletions": 6, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_lsp_server%2Fsrc%2Fworld.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_lsp_server%2Fsrc%2Fworld.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fworld.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "dff63a12d44398d96362e1cf08f52076f4ad56e6", "filename": "crates/ra_lsp_server/tests/heavy_tests/main.rs", "status": "modified", "additions": 116, "deletions": 2, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_lsp_server%2Ftests%2Fheavy_tests%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_lsp_server%2Ftests%2Fheavy_tests%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Ftests%2Fheavy_tests%2Fmain.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "d5ea52fa95b4829a1e95a347b2dd70307208deb9", "filename": "crates/ra_lsp_server/tests/heavy_tests/support.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_lsp_server%2Ftests%2Fheavy_tests%2Fsupport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_lsp_server%2Ftests%2Fheavy_tests%2Fsupport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Ftests%2Fheavy_tests%2Fsupport.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "2c6ae565896b6ba1f8a7629f526d0485288f0aaa", "filename": "crates/ra_mbe/src/lib.rs", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_mbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_mbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Flib.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "e36b5a412b903dc65487b61e1a010d9f94cbed35", "filename": "crates/ra_mbe/src/mbe_expander/matcher.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Fmatcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Fmatcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Fmatcher.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "eda66cd506ebe2f6928011ee20877e10e339f900", "filename": "crates/ra_mbe/src/mbe_expander/transcriber.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Ftranscriber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Ftranscriber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Ftranscriber.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "b841c39d31440aa54c45c70873ad9d2c3cd621a2", "filename": "crates/ra_mbe/src/subtree_source.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_mbe%2Fsrc%2Fsubtree_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_mbe%2Fsrc%2Fsubtree_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsubtree_source.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "ea2cac069e6432c6b985a714b5fbf4eb254c44c5", "filename": "crates/ra_mbe/src/syntax_bridge.rs", "status": "modified", "additions": 171, "deletions": 71, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "e640d115b4513eefc8211432f1f21be4d9d2b1b8", "filename": "crates/ra_mbe/src/tests.rs", "status": "modified", "additions": 316, "deletions": 368, "changes": 684, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_mbe%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_mbe%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Ftests.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "22f64a9f4addede1a7219dec317424be281552fa", "filename": "crates/ra_parser/src/grammar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_parser%2Fsrc%2Fgrammar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_parser%2Fsrc%2Fgrammar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "4ac1d6334a0e64447c61ca9651b68ae1d4af7c3c", "filename": "crates/ra_parser/src/grammar/expressions/atom.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "6e23d9b72d60487890dcfa1be969154660db058f", "filename": "crates/ra_parser/src/grammar/items.rs", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "422a4e3dc175b176a8fdd7bb90900f090a7cc12c", "filename": "crates/ra_parser/src/grammar/patterns.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fpatterns.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "50e4900c31a7ee7a13df387d1d594db047f3fad5", "filename": "crates/ra_parser/src/grammar/type_params.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_parser%2Fsrc%2Fgrammar%2Ftype_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_parser%2Fsrc%2Fgrammar%2Ftype_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Ftype_params.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "65134277e128af487e358ca5af9248958dc6c2f5", "filename": "crates/ra_parser/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_parser%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_parser%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Flib.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "1071c46dc8eb00006b59f3d1a71e9bc65aae15e0", "filename": "crates/ra_parser/src/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_parser%2Fsrc%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_parser%2Fsrc%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fparser.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "af2945f571ee0437678504dc15201c44cdc4c4c1", "filename": "crates/ra_parser/src/syntax_kind/generated.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_parser%2Fsrc%2Fsyntax_kind%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_parser%2Fsrc%2Fsyntax_kind%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fsyntax_kind%2Fgenerated.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "994017acfd4409b2912313a9fb5cda9e3eb45ae6", "filename": "crates/ra_parser/src/token_set.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_parser%2Fsrc%2Ftoken_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_parser%2Fsrc%2Ftoken_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Ftoken_set.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "f260c40a321c6a6a201c0d93e383ee8595eff3a2", "filename": "crates/ra_prof/src/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_prof%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_prof%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_prof%2Fsrc%2Flib.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "c862d3912c3529d0715805ae0cb91d15e47f9c22", "filename": "crates/ra_project_model/src/cargo_workspace.rs", "status": "modified", "additions": 35, "deletions": 2, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "d71b7031a8a70825d77e53a6f9f170248d751e55", "filename": "crates/ra_project_model/src/lib.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_project_model%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_project_model%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Flib.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "b6ebb129d07a9e7af5a71e0770de1dfc277ca5c0", "filename": "crates/ra_syntax/Cargo.toml", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_syntax%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_syntax%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2FCargo.toml?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "e4061e994705194806ccae5c8243125c8d054728", "filename": "crates/ra_syntax/src/algo.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_syntax%2Fsrc%2Falgo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_syntax%2Fsrc%2Falgo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Falgo.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "ae5d639276ea72f741b2cdb2af6cfd79bd046f67", "filename": "crates/ra_syntax/src/ast/edit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "9f9d6e63cb610da083a141278fd874d877f0b578", "filename": "crates/ra_syntax/src/ast/generated.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "04a5408fefafc12c803242968fe4d70607fb86eb", "filename": "crates/ra_syntax/src/ast/make.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "08aafb610d61b4417f398f95c8d492e355d04892", "filename": "crates/ra_syntax/src/grammar.ron", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "db6230aab969843956012a244f9f8d64b028394c", "filename": "crates/ra_syntax/src/ptr.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_syntax%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_syntax%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fptr.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "041c6ea8d6359d86372ad691c6c2cabee3f0fb11", "filename": "crates/ra_syntax/src/syntax_node.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_syntax%2Fsrc%2Fsyntax_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_syntax%2Fsrc%2Fsyntax_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fsyntax_node.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "c5be73a5a08e8108a749fa7a33dde038e6725933", "filename": "crates/ra_syntax/test_data/parser/err/0028_macro_2.0.txt", "status": "removed", "additions": 0, "deletions": 328, "changes": 328, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0028_macro_2.0.txt", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0028_macro_2.0.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0028_macro_2.0.txt?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef"}, {"sha": "a2f74bd879aeed9abea8525930a0a08e4520397c", "filename": "crates/ra_syntax/test_data/parser/err/0039_lambda_recovery.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0039_lambda_recovery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0039_lambda_recovery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0039_lambda_recovery.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "d1544634ce89305c105d2bfd01f35879b4f48442", "filename": "crates/ra_syntax/test_data/parser/err/0039_lambda_recovery.txt", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0039_lambda_recovery.txt", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0039_lambda_recovery.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0039_lambda_recovery.txt?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "b05ccc0ed5735736d208c55a5db25cd416d5fe62", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0129_marco_pat.txt", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0129_marco_pat.txt", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0129_marco_pat.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0129_marco_pat.txt?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "8cdb3b7036788e6606fdbe09f7df095e4240c919", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0147_const_param.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0147_const_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0147_const_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0147_const_param.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "f81de7bac7caf79b47da46489e25e8e81086390a", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0147_const_param.txt", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0147_const_param.txt", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0147_const_param.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0147_const_param.txt?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "319a4e2aad2e91497293708be9b147e5a4a1539e", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0147_macro_def.rs", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0147_macro_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0147_macro_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0147_macro_def.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "3556099bd0943d617d5317d9125b5001b5e1bec0", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0147_macro_def.txt", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0147_macro_def.txt", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0147_macro_def.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0147_macro_def.txt?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "3b2be597fd85232a558395cb85aa0993389a73ff", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0148_pub_macro_def.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0148_pub_macro_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0148_pub_macro_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0148_pub_macro_def.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "cfd79d9c26fbfa784e58d310e6656a130baebafc", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0148_pub_macro_def.txt", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0148_pub_macro_def.txt", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0148_pub_macro_def.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0148_pub_macro_def.txt?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "781047ba19a986616bca685fcf95cade2f9c8744", "filename": "crates/ra_syntax/test_data/parser/ok/0062_macro_2.0.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0062_macro_2.0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0062_macro_2.0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0062_macro_2.0.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e", "previous_filename": "crates/ra_syntax/test_data/parser/err/0028_macro_2.0.rs"}, {"sha": "2be523fc3578852d4c2a9efd6baff19663c3a5c4", "filename": "crates/ra_syntax/test_data/parser/ok/0062_macro_2.0.txt", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0062_macro_2.0.txt", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0062_macro_2.0.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0062_macro_2.0.txt?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "10f424aae96c645cecae2b7f5e411c61d24a79c0", "filename": "crates/ra_tt/src/lib.rs", "status": "modified", "additions": 27, "deletions": 16, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_tt%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Fra_tt%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_tt%2Fsrc%2Flib.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "659f77b71a1cef23a47c8d896f2a44e71539a2ca", "filename": "crates/test_utils/src/lib.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Ftest_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/crates%2Ftest_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Flib.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "2f6215d6bb469c333bc2cd2ac3c3256909062e8a", "filename": "docs/dev/README.md", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/docs%2Fdev%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/docs%2Fdev%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2FREADME.md?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "968d2e34c8040096c39df4ba2fd9f92c0d344fdf", "filename": "docs/user/README.md", "status": "modified", "additions": 39, "deletions": 24, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/docs%2Fuser%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/docs%2Fuser%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2FREADME.md?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "334ba450f5a17e3feda99287683cbd5052ac1c4a", "filename": "docs/user/assists.md", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/docs%2Fuser%2Fassists.md", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/docs%2Fuser%2Fassists.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Fassists.md?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "4c5c13646c781793b27144b286cbdf525c8d2774", "filename": "editors/code/package-lock.json", "status": "modified", "additions": 328, "deletions": 403, "changes": 731, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fpackage-lock.json", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fpackage-lock.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fpackage-lock.json?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "8e7046418b0f8b3398cfb8b83a7af88da0e24587", "filename": "editors/code/package.json", "status": "modified", "additions": 125, "deletions": 16, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fpackage.json?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "1b222bbe78056374d07c9a55156f0acebd1cac82", "filename": "editors/code/rollup.config.js", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Frollup.config.js", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Frollup.config.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Frollup.config.js?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "2777ced2479f5b14d3c4a618cb95baa90f4a47f5", "filename": "editors/code/src/commands/analyzer_status.ts", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fsrc%2Fcommands%2Fanalyzer_status.ts", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fsrc%2Fcommands%2Fanalyzer_status.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fcommands%2Fanalyzer_status.ts?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "8167398b1ce0339ff0fd3b8c113b2570e04db5b2", "filename": "editors/code/src/commands/apply_source_change.ts", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fsrc%2Fcommands%2Fapply_source_change.ts", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fsrc%2Fcommands%2Fapply_source_change.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fcommands%2Fapply_source_change.ts?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "ac62bdd48d20144951c6c67cfa86d470c610581e", "filename": "editors/code/src/commands/cargo_watch.ts", "status": "modified", "additions": 28, "deletions": 21, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fsrc%2Fcommands%2Fcargo_watch.ts", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fsrc%2Fcommands%2Fcargo_watch.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fcommands%2Fcargo_watch.ts?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "17c78280a89a5fc4c09973407090160bbfd342df", "filename": "editors/code/src/commands/expand_macro.ts", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fsrc%2Fcommands%2Fexpand_macro.ts", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fsrc%2Fcommands%2Fexpand_macro.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fcommands%2Fexpand_macro.ts?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "13a696758b44a392f2c08e925e1d98ff0c7bd2dd", "filename": "editors/code/src/commands/index.ts", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fsrc%2Fcommands%2Findex.ts", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fsrc%2Fcommands%2Findex.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fcommands%2Findex.ts?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "ac7dcce604b4250d7a659a3a346373e01298be30", "filename": "editors/code/src/commands/inlay_hints.ts", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fsrc%2Fcommands%2Finlay_hints.ts", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fsrc%2Fcommands%2Finlay_hints.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fcommands%2Finlay_hints.ts?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "134ddc80164daf6e387c97bb265464ee3bb151f5", "filename": "editors/code/src/commands/join_lines.ts", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fsrc%2Fcommands%2Fjoin_lines.ts", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fsrc%2Fcommands%2Fjoin_lines.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fcommands%2Fjoin_lines.ts?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "364208cc75801d361cecb10de6f4be8cd816a362", "filename": "editors/code/src/commands/matching_brace.ts", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fsrc%2Fcommands%2Fmatching_brace.ts", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fsrc%2Fcommands%2Fmatching_brace.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fcommands%2Fmatching_brace.ts?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "772c64b3c78e6b009f7dd222620d3307cac83d33", "filename": "editors/code/src/commands/on_enter.ts", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fsrc%2Fcommands%2Fon_enter.ts", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fsrc%2Fcommands%2Fon_enter.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fcommands%2Fon_enter.ts?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "ad49e1bdbbfae7ea618135d8d702e76dd96f6118", "filename": "editors/code/src/commands/parent_module.ts", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fsrc%2Fcommands%2Fparent_module.ts", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fsrc%2Fcommands%2Fparent_module.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fcommands%2Fparent_module.ts?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "cf980e257854796d121765309238392c5c145ae3", "filename": "editors/code/src/commands/runnables.ts", "status": "modified", "additions": 27, "deletions": 25, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fsrc%2Fcommands%2Frunnables.ts", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fsrc%2Fcommands%2Frunnables.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fcommands%2Frunnables.ts?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "89a80550cee08aafa083f64dbcc2e393a23b2c91", "filename": "editors/code/src/commands/syntaxTree.ts", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fsrc%2Fcommands%2FsyntaxTree.ts", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fsrc%2Fcommands%2FsyntaxTree.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fcommands%2FsyntaxTree.ts?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "8d64394c7b696795a7164a94a9153ac305c5a060", "filename": "editors/code/src/commands/watch_status.ts", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fsrc%2Fcommands%2Fwatch_status.ts", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fsrc%2Fcommands%2Fwatch_status.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fcommands%2Fwatch_status.ts?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "c06dddb1c63ef8d2d393ac82172a9f719f5ba62f", "filename": "editors/code/src/config.ts", "status": "modified", "additions": 89, "deletions": 24, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fsrc%2Fconfig.ts", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fsrc%2Fconfig.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fconfig.ts?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "74b91bd48712be1e968ea8b0ec1631d409c6eb09", "filename": "editors/code/src/events/change_active_text_editor.ts", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fsrc%2Fevents%2Fchange_active_text_editor.ts", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fsrc%2Fevents%2Fchange_active_text_editor.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fevents%2Fchange_active_text_editor.ts?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "2e998e889ba17db5e22a59ad805e7e2eca1c702b", "filename": "editors/code/src/events/change_text_document.ts", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fsrc%2Fevents%2Fchange_text_document.ts", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fsrc%2Fevents%2Fchange_text_document.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fevents%2Fchange_text_document.ts?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "815f3692c0236e11f4dc30f5b3cc14289a2bc19c", "filename": "editors/code/src/extension.ts", "status": "modified", "additions": 39, "deletions": 34, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fsrc%2Fextension.ts", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fsrc%2Fextension.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fextension.ts?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "68eae094199a7a221fbbb63ef95049c6cd201cd7", "filename": "editors/code/src/highlighting.ts", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fsrc%2Fhighlighting.ts", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fsrc%2Fhighlighting.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fhighlighting.ts?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "f23e286ad5d9fe4d5082176f5a9d2b31f0cd2ab5", "filename": "editors/code/src/notifications/publish_decorations.ts", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fsrc%2Fnotifications%2Fpublish_decorations.ts", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fsrc%2Fnotifications%2Fpublish_decorations.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fnotifications%2Fpublish_decorations.ts?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "5ace1d0faeb4c2b794e59276cc249748f84c6e43", "filename": "editors/code/src/server.ts", "status": "modified", "additions": 26, "deletions": 13, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fsrc%2Fserver.ts", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fsrc%2Fserver.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fserver.ts?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "bfef33c7de786dd8f8dfd2a5a415b96767ac62bf", "filename": "editors/code/src/test/fixtures/rust-diagnostics/error/E0277.json", "status": "added", "additions": 261, "deletions": 0, "changes": 261, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fsrc%2Ftest%2Ffixtures%2Frust-diagnostics%2Ferror%2FE0277.json", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fsrc%2Ftest%2Ffixtures%2Frust-diagnostics%2Ferror%2FE0277.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Ftest%2Ffixtures%2Frust-diagnostics%2Ferror%2FE0277.json?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "2b25eb705dd35743f432df559326249c34ba4244", "filename": "editors/code/src/test/utils/diagnotics/SuggestedFix.test.ts", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fsrc%2Ftest%2Futils%2Fdiagnotics%2FSuggestedFix.test.ts", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fsrc%2Ftest%2Futils%2Fdiagnotics%2FSuggestedFix.test.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Ftest%2Futils%2Fdiagnotics%2FSuggestedFix.test.ts?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "ef09013f413040e763c942dad1bc006a118a1312", "filename": "editors/code/src/test/utils/diagnotics/SuggestedFixCollection.test.ts", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fsrc%2Ftest%2Futils%2Fdiagnotics%2FSuggestedFixCollection.test.ts", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fsrc%2Ftest%2Futils%2Fdiagnotics%2FSuggestedFixCollection.test.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Ftest%2Futils%2Fdiagnotics%2FSuggestedFixCollection.test.ts?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "358325cc8dde6082cb0eda52f1fbdbe38483bf34", "filename": "editors/code/src/test/utils/diagnotics/rust.test.ts", "status": "modified", "additions": 64, "deletions": 28, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fsrc%2Ftest%2Futils%2Fdiagnotics%2Frust.test.ts", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fsrc%2Ftest%2Futils%2Fdiagnotics%2Frust.test.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Ftest%2Futils%2Fdiagnotics%2Frust.test.ts?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "4944dd0328ce3ff6000c300a90d5e9687b2fa7a3", "filename": "editors/code/src/test/utils/diagnotics/vscode.test.ts", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fsrc%2Ftest%2Futils%2Fdiagnotics%2Fvscode.test.ts", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fsrc%2Ftest%2Futils%2Fdiagnotics%2Fvscode.test.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Ftest%2Futils%2Fdiagnotics%2Fvscode.test.ts?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "9927daaf6ae78f0fd8136cee9e6a3fd5339739f4", "filename": "editors/code/src/test/utils/index.ts", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fsrc%2Ftest%2Futils%2Findex.ts", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fsrc%2Ftest%2Futils%2Findex.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Ftest%2Futils%2Findex.ts?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "6e660bb61d95517f4476512019c88addb9b7e861", "filename": "editors/code/src/utils/diagnostics/SuggestedFix.ts", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fsrc%2Futils%2Fdiagnostics%2FSuggestedFix.ts", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fsrc%2Futils%2Fdiagnostics%2FSuggestedFix.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Futils%2Fdiagnostics%2FSuggestedFix.ts?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "57c9856cfa3cb7ebdad64c3d78622e296d9c7aa5", "filename": "editors/code/src/utils/diagnostics/SuggestedFixCollection.ts", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fsrc%2Futils%2Fdiagnostics%2FSuggestedFixCollection.ts", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fsrc%2Futils%2Fdiagnostics%2FSuggestedFixCollection.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Futils%2Fdiagnostics%2FSuggestedFixCollection.ts?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "1f0c0d3e4057a85d6dcca373474b421f177c53be", "filename": "editors/code/src/utils/diagnostics/rust.ts", "status": "modified", "additions": 48, "deletions": 10, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fsrc%2Futils%2Fdiagnostics%2Frust.ts", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fsrc%2Futils%2Fdiagnostics%2Frust.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Futils%2Fdiagnostics%2Frust.ts?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "f4a5450e2b8c19bc946f2fc6a4488d8797ef583f", "filename": "editors/code/src/utils/diagnostics/vscode.ts", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fsrc%2Futils%2Fdiagnostics%2Fvscode.ts", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fsrc%2Futils%2Fdiagnostics%2Fvscode.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Futils%2Fdiagnostics%2Fvscode.ts?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "a1d6b7eafbc8f30eb07a5b5a5eb30d2ca48091b1", "filename": "editors/code/src/utils/processes.ts", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fsrc%2Futils%2Fprocesses.ts", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Fsrc%2Futils%2Fprocesses.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Futils%2Fprocesses.ts?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "5e11c37751201d2b8e57fa3e88293695cbd8b29a", "filename": "editors/code/tsconfig.json", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Ftsconfig.json", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Ftsconfig.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Ftsconfig.json?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "f06fa5fab76790a272ccf331a9cf068fa957292e", "filename": "editors/code/tslint.json", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Ftslint.json", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/editors%2Fcode%2Ftslint.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Ftslint.json?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "40a6682be995b98e1af323ab4bc1eddccd109093", "filename": "xtask/src/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/xtask%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/xtask%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Flib.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}, {"sha": "4201c6a6a758b4bc4b8e9302afa96b03f844c0ed", "filename": "xtask/src/main.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b21d9337d9200e2cfdc90b386591c72c302dc03e/xtask%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21d9337d9200e2cfdc90b386591c72c302dc03e/xtask%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fmain.rs?ref=b21d9337d9200e2cfdc90b386591c72c302dc03e"}]}