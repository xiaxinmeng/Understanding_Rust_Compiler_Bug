{"sha": "a0adf53bc97d6e79c8c2e9b3f8a548bc65c7adf6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwYWRmNTNiYzk3ZDZlNzljOGMyZTliM2Y4YTU0OGJjNjVjN2FkZjY=", "commit": {"author": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2020-02-12T15:47:43Z"}, "committer": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2020-05-18T13:39:54Z"}, "message": "Implement asm! in librustc_builtin_macros", "tree": {"sha": "773aa499e291a93e8d1536a806fee779c42b9b24", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/773aa499e291a93e8d1536a806fee779c42b9b24"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a0adf53bc97d6e79c8c2e9b3f8a548bc65c7adf6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a0adf53bc97d6e79c8c2e9b3f8a548bc65c7adf6", "html_url": "https://github.com/rust-lang/rust/commit/a0adf53bc97d6e79c8c2e9b3f8a548bc65c7adf6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a0adf53bc97d6e79c8c2e9b3f8a548bc65c7adf6/comments", "author": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "813a9fc4f121d808c48ebee47a25a773120edd45", "url": "https://api.github.com/repos/rust-lang/rust/commits/813a9fc4f121d808c48ebee47a25a773120edd45", "html_url": "https://github.com/rust-lang/rust/commit/813a9fc4f121d808c48ebee47a25a773120edd45"}], "stats": {"total": 832, "additions": 712, "deletions": 120}, "files": [{"sha": "677c027f17b54c65480db41e57d50c5132730931", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 152, "deletions": 3, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/a0adf53bc97d6e79c8c2e9b3f8a548bc65c7adf6/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0adf53bc97d6e79c8c2e9b3f8a548bc65c7adf6/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=a0adf53bc97d6e79c8c2e9b3f8a548bc65c7adf6", "patch": "@@ -27,6 +27,15 @@ use std::string;\n \n use rustc_span::{InnerSpan, Symbol};\n \n+/// The type of format string that we are parsing.\n+#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n+pub enum ParseMode {\n+    /// A normal format string as per `format_args!`.\n+    Format,\n+    /// An inline assembly template string for `asm!`.\n+    InlineAsm,\n+}\n+\n #[derive(Copy, Clone)]\n struct InnerOffset(usize);\n \n@@ -163,6 +172,7 @@ pub struct ParseError {\n /// This is a recursive-descent parser for the sake of simplicity, and if\n /// necessary there's probably lots of room for improvement performance-wise.\n pub struct Parser<'a> {\n+    mode: ParseMode,\n     input: &'a str,\n     cur: iter::Peekable<str::CharIndices<'a>>,\n     /// Error messages accumulated during parsing\n@@ -179,6 +189,8 @@ pub struct Parser<'a> {\n     last_opening_brace: Option<InnerSpan>,\n     /// Whether the source string is comes from `println!` as opposed to `format!` or `print!`\n     append_newline: bool,\n+    /// Whether this formatting string is a literal or it comes from a macro.\n+    is_literal: bool,\n }\n \n impl<'a> Iterator for Parser<'a> {\n@@ -201,7 +213,9 @@ impl<'a> Iterator for Parser<'a> {\n                         if let Some(end) = self.must_consume('}') {\n                             let start = self.to_span_index(pos);\n                             let end = self.to_span_index(end + 1);\n-                            self.arg_places.push(start.to(end));\n+                            if self.is_literal {\n+                                self.arg_places.push(start.to(end));\n+                            }\n                         }\n                         Some(NextArgument(arg))\n                     }\n@@ -235,10 +249,13 @@ impl<'a> Parser<'a> {\n     pub fn new(\n         s: &'a str,\n         style: Option<usize>,\n-        skips: Vec<usize>,\n+        snippet: Option<string::String>,\n         append_newline: bool,\n+        mode: ParseMode,\n     ) -> Parser<'a> {\n+        let (skips, is_literal) = find_skips_from_snippet(snippet, style);\n         Parser {\n+            mode,\n             input: s,\n             cur: s.char_indices().peekable(),\n             errors: vec![],\n@@ -248,6 +265,7 @@ impl<'a> Parser<'a> {\n             skips,\n             last_opening_brace: None,\n             append_newline,\n+            is_literal,\n         }\n     }\n \n@@ -426,7 +444,10 @@ impl<'a> Parser<'a> {\n     /// Parses an `Argument` structure, or what's contained within braces inside the format string.\n     fn argument(&mut self) -> Argument<'a> {\n         let pos = self.position();\n-        let format = self.format();\n+        let format = match self.mode {\n+            ParseMode::Format => self.format(),\n+            ParseMode::InlineAsm => self.inline_asm(),\n+        };\n \n         // Resolve position after parsing format spec.\n         let pos = match pos {\n@@ -574,6 +595,36 @@ impl<'a> Parser<'a> {\n         spec\n     }\n \n+    /// Parses an inline assembly template modifier at the current position, returning the modifier\n+    /// in the `ty` field of the `FormatSpec` struct.\n+    fn inline_asm(&mut self) -> FormatSpec<'a> {\n+        let mut spec = FormatSpec {\n+            fill: None,\n+            align: AlignUnknown,\n+            flags: 0,\n+            precision: CountImplied,\n+            precision_span: None,\n+            width: CountImplied,\n+            width_span: None,\n+            ty: &self.input[..0],\n+            ty_span: None,\n+        };\n+        if !self.consume(':') {\n+            return spec;\n+        }\n+\n+        let ty_span_start = self.cur.peek().map(|(pos, _)| *pos);\n+        spec.ty = self.word();\n+        let ty_span_end = self.cur.peek().map(|(pos, _)| *pos);\n+        if !spec.ty.is_empty() {\n+            spec.ty_span = ty_span_start\n+                .and_then(|s| ty_span_end.map(|e| (s, e)))\n+                .map(|(start, end)| self.to_span_index(start).to(self.to_span_index(end)));\n+        }\n+\n+        spec\n+    }\n+\n     /// Parses a `Count` parameter at the current position. This does not check\n     /// for 'CountIsNextParam' because that is only used in precision, not\n     /// width.\n@@ -652,5 +703,103 @@ impl<'a> Parser<'a> {\n     }\n }\n \n+/// Finds the indices of all characters that have been processed and differ between the actual\n+/// written code (code snippet) and the `InternedString` that gets processed in the `Parser`\n+/// in order to properly synthethise the intra-string `Span`s for error diagnostics.\n+fn find_skips_from_snippet(\n+    snippet: Option<string::String>,\n+    str_style: Option<usize>,\n+) -> (Vec<usize>, bool) {\n+    let snippet = match snippet {\n+        Some(ref s) if s.starts_with('\"') || s.starts_with(\"r#\") => s,\n+        _ => return (vec![], false),\n+    };\n+\n+    fn find_skips(snippet: &str, is_raw: bool) -> Vec<usize> {\n+        let mut eat_ws = false;\n+        let mut s = snippet.chars().enumerate().peekable();\n+        let mut skips = vec![];\n+        while let Some((pos, c)) = s.next() {\n+            match (c, s.peek()) {\n+                // skip whitespace and empty lines ending in '\\\\'\n+                ('\\\\', Some((next_pos, '\\n'))) if !is_raw => {\n+                    eat_ws = true;\n+                    skips.push(pos);\n+                    skips.push(*next_pos);\n+                    let _ = s.next();\n+                }\n+                ('\\\\', Some((next_pos, '\\n' | 'n' | 't'))) if eat_ws => {\n+                    skips.push(pos);\n+                    skips.push(*next_pos);\n+                    let _ = s.next();\n+                }\n+                (' ' | '\\n' | '\\t', _) if eat_ws => {\n+                    skips.push(pos);\n+                }\n+                ('\\\\', Some((next_pos, 'n' | 't' | '0' | '\\\\' | '\\'' | '\\\"'))) => {\n+                    skips.push(*next_pos);\n+                    let _ = s.next();\n+                }\n+                ('\\\\', Some((_, 'x'))) if !is_raw => {\n+                    for _ in 0..3 {\n+                        // consume `\\xAB` literal\n+                        if let Some((pos, _)) = s.next() {\n+                            skips.push(pos);\n+                        } else {\n+                            break;\n+                        }\n+                    }\n+                }\n+                ('\\\\', Some((_, 'u'))) if !is_raw => {\n+                    if let Some((pos, _)) = s.next() {\n+                        skips.push(pos);\n+                    }\n+                    if let Some((next_pos, next_c)) = s.next() {\n+                        if next_c == '{' {\n+                            skips.push(next_pos);\n+                            let mut i = 0; // consume up to 6 hexanumeric chars + closing `}`\n+                            while let (Some((next_pos, c)), true) = (s.next(), i < 7) {\n+                                if c.is_digit(16) {\n+                                    skips.push(next_pos);\n+                                } else if c == '}' {\n+                                    skips.push(next_pos);\n+                                    break;\n+                                } else {\n+                                    break;\n+                                }\n+                                i += 1;\n+                            }\n+                        } else if next_c.is_digit(16) {\n+                            skips.push(next_pos);\n+                            // We suggest adding `{` and `}` when appropriate, accept it here as if\n+                            // it were correct\n+                            let mut i = 0; // consume up to 6 hexanumeric chars\n+                            while let (Some((next_pos, c)), _) = (s.next(), i < 6) {\n+                                if c.is_digit(16) {\n+                                    skips.push(next_pos);\n+                                } else {\n+                                    break;\n+                                }\n+                                i += 1;\n+                            }\n+                        }\n+                    }\n+                }\n+                _ if eat_ws => {\n+                    // `take_while(|c| c.is_whitespace())`\n+                    eat_ws = false;\n+                }\n+                _ => {}\n+            }\n+        }\n+        skips\n+    }\n+\n+    let r_start = str_style.map(|r| r + 1).unwrap_or(0);\n+    let r_end = str_style.map(|r| r).unwrap_or(0);\n+    let s = &snippet[r_start + 1..snippet.len() - r_end - 1];\n+    (find_skips(s, str_style.is_some()), true)\n+}\n+\n #[cfg(test)]\n mod tests;"}, {"sha": "a0cef78f924d6dc05b15ab4e5315b1acfc79bcf4", "filename": "src/libfmt_macros/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a0adf53bc97d6e79c8c2e9b3f8a548bc65c7adf6/src%2Flibfmt_macros%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0adf53bc97d6e79c8c2e9b3f8a548bc65c7adf6/src%2Flibfmt_macros%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Ftests.rs?ref=a0adf53bc97d6e79c8c2e9b3f8a548bc65c7adf6", "patch": "@@ -1,7 +1,7 @@\n use super::*;\n \n fn same(fmt: &'static str, p: &[Piece<'static>]) {\n-    let parser = Parser::new(fmt, None, vec![], false);\n+    let parser = Parser::new(fmt, None, vec![], false, ParseMode::Format);\n     assert_eq!(parser.collect::<Vec<Piece<'static>>>(), p);\n }\n \n@@ -20,7 +20,7 @@ fn fmtdflt() -> FormatSpec<'static> {\n }\n \n fn musterr(s: &str) {\n-    let mut p = Parser::new(s, None, vec![], false);\n+    let mut p = Parser::new(s, None, vec![], false, ParseMode::Format);\n     p.next();\n     assert!(!p.errors.is_empty());\n }"}, {"sha": "943ed42e2021483e4ece991e63d2907aca6e2930", "filename": "src/librustc_builtin_macros/asm.rs", "status": "added", "additions": 527, "deletions": 0, "changes": 527, "blob_url": "https://github.com/rust-lang/rust/blob/a0adf53bc97d6e79c8c2e9b3f8a548bc65c7adf6/src%2Flibrustc_builtin_macros%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0adf53bc97d6e79c8c2e9b3f8a548bc65c7adf6/src%2Flibrustc_builtin_macros%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fasm.rs?ref=a0adf53bc97d6e79c8c2e9b3f8a548bc65c7adf6", "patch": "@@ -0,0 +1,527 @@\n+use fmt_macros as parse;\n+\n+use rustc_ast::ast;\n+use rustc_ast::ptr::P;\n+use rustc_ast::token;\n+use rustc_ast::tokenstream::TokenStream;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_errors::{Applicability, DiagnosticBuilder};\n+use rustc_expand::base::{self, *};\n+use rustc_parse::parser::Parser;\n+use rustc_span::symbol::{kw, sym, Symbol};\n+use rustc_span::{InnerSpan, Span};\n+use rustc_target::asm::{InlineAsmOptions, InlineAsmTemplatePiece};\n+\n+struct AsmArgs {\n+    template: P<ast::Expr>,\n+    operands: Vec<(ast::InlineAsmOperand, Span)>,\n+    named_args: FxHashMap<Symbol, usize>,\n+    reg_args: FxHashSet<usize>,\n+    options: InlineAsmOptions,\n+    options_span: Option<Span>,\n+}\n+\n+fn parse_args<'a>(\n+    ecx: &mut ExtCtxt<'a>,\n+    sp: Span,\n+    tts: TokenStream,\n+) -> Result<AsmArgs, DiagnosticBuilder<'a>> {\n+    let mut p = ecx.new_parser_from_tts(tts);\n+\n+    if p.token == token::Eof {\n+        return Err(ecx.struct_span_err(sp, \"requires at least a template string argument\"));\n+    }\n+\n+    // Detect use of the legacy llvm_asm! syntax (which used to be called asm!)\n+    if p.look_ahead(1, |t| *t == token::Colon || *t == token::ModSep) {\n+        let mut err = ecx.struct_span_err(sp, \"legacy asm! syntax is no longer supported\");\n+\n+        // Find the span of the \"asm!\" so that we can offer an automatic suggestion\n+        let asm_span = sp.from_inner(InnerSpan::new(0, 4));\n+        if let Ok(s) = ecx.source_map().span_to_snippet(asm_span) {\n+            if s == \"asm!\" {\n+                err.span_suggestion(\n+                    asm_span,\n+                    \"replace with\",\n+                    \"llvm_asm!\".into(),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        }\n+        return Err(err);\n+    }\n+\n+    let template = p.parse_expr()?;\n+    let mut args = AsmArgs {\n+        template,\n+        operands: vec![],\n+        named_args: FxHashMap::default(),\n+        reg_args: FxHashSet::default(),\n+        options: InlineAsmOptions::empty(),\n+        options_span: None,\n+    };\n+\n+    let mut first = true;\n+    while p.token != token::Eof {\n+        if !p.eat(&token::Comma) {\n+            if first {\n+                // After `asm!(\"\"` we always expect *only* a comma...\n+                let mut err = ecx.struct_span_err(p.token.span, \"expected token: `,`\");\n+                err.span_label(p.token.span, \"expected `,`\");\n+                p.maybe_annotate_with_ascription(&mut err, false);\n+                return Err(err);\n+            } else {\n+                // ...after that delegate to `expect` to also include the other expected tokens.\n+                return Err(p.expect(&token::Comma).err().unwrap());\n+            }\n+        }\n+        first = false;\n+        if p.token == token::Eof {\n+            break;\n+        } // accept trailing commas\n+\n+        let span_start = p.token.span;\n+\n+        // Parse options\n+        if p.eat(&token::Ident(sym::options, false)) {\n+            p.expect(&token::OpenDelim(token::DelimToken::Paren))?;\n+\n+            while !p.eat(&token::CloseDelim(token::DelimToken::Paren)) {\n+                if p.eat(&token::Ident(sym::pure, false)) {\n+                    args.options |= InlineAsmOptions::PURE;\n+                } else if p.eat(&token::Ident(sym::nomem, false)) {\n+                    args.options |= InlineAsmOptions::NOMEM;\n+                } else if p.eat(&token::Ident(sym::readonly, false)) {\n+                    args.options |= InlineAsmOptions::READONLY;\n+                } else if p.eat(&token::Ident(sym::preserves_flags, false)) {\n+                    args.options |= InlineAsmOptions::PRESERVES_FLAGS;\n+                } else if p.eat(&token::Ident(sym::noreturn, false)) {\n+                    args.options |= InlineAsmOptions::NORETURN;\n+                } else {\n+                    p.expect(&token::Ident(sym::nostack, false))?;\n+                    args.options |= InlineAsmOptions::NOSTACK;\n+                }\n+\n+                // Allow trailing commas\n+                if p.eat(&token::CloseDelim(token::DelimToken::Paren)) {\n+                    break;\n+                }\n+                p.expect(&token::Comma)?;\n+            }\n+\n+            let new_span = span_start.to(p.prev_token.span);\n+            if let Some(options_span) = args.options_span {\n+                ecx.struct_span_err(new_span, \"asm options cannot be specified twice\")\n+                    .span_label(options_span, \"previously here\")\n+                    .span_label(new_span, \"duplicate options\")\n+                    .emit();\n+            } else {\n+                args.options_span = Some(new_span);\n+            }\n+            continue;\n+        }\n+\n+        // Parse operand names\n+        let name = if p.token.is_ident() && p.look_ahead(1, |t| *t == token::Eq) {\n+            let (ident, _) = p.token.ident().unwrap();\n+            p.bump();\n+            p.expect(&token::Eq)?;\n+            Some(ident.name)\n+        } else {\n+            None\n+        };\n+\n+        fn parse_reg<'a>(\n+            p: &mut Parser<'a>,\n+            explicit_reg: &mut bool,\n+        ) -> Result<ast::InlineAsmRegOrRegClass, DiagnosticBuilder<'a>> {\n+            p.expect(&token::OpenDelim(token::DelimToken::Paren))?;\n+            let result = match p.token.kind {\n+                token::Ident(name, false) => ast::InlineAsmRegOrRegClass::RegClass(name),\n+                token::Literal(token::Lit { kind: token::LitKind::Str, symbol, suffix: _ }) => {\n+                    *explicit_reg = true;\n+                    ast::InlineAsmRegOrRegClass::Reg(symbol)\n+                }\n+                _ => {\n+                    return Err(p.struct_span_err(\n+                        p.token.span,\n+                        \"expected register class or explicit register\",\n+                    ));\n+                }\n+            };\n+            p.bump();\n+            p.expect(&token::CloseDelim(token::DelimToken::Paren))?;\n+            Ok(result)\n+        };\n+\n+        let mut explicit_reg = false;\n+        let op = if p.eat(&token::Ident(kw::In, false)) {\n+            let reg = parse_reg(&mut p, &mut explicit_reg)?;\n+            let expr = p.parse_expr()?;\n+            ast::InlineAsmOperand::In { reg, expr }\n+        } else if p.eat(&token::Ident(sym::out, false)) {\n+            let reg = parse_reg(&mut p, &mut explicit_reg)?;\n+            let expr = if p.eat_keyword(kw::Underscore) { None } else { Some(p.parse_expr()?) };\n+            ast::InlineAsmOperand::Out { reg, expr, late: false }\n+        } else if p.eat(&token::Ident(sym::lateout, false)) {\n+            let reg = parse_reg(&mut p, &mut explicit_reg)?;\n+            let expr = if p.eat_keyword(kw::Underscore) { None } else { Some(p.parse_expr()?) };\n+            ast::InlineAsmOperand::Out { reg, expr, late: true }\n+        } else if p.eat(&token::Ident(sym::inout, false)) {\n+            let reg = parse_reg(&mut p, &mut explicit_reg)?;\n+            let expr = p.parse_expr()?;\n+            if p.eat(&token::FatArrow) {\n+                let out_expr =\n+                    if p.eat_keyword(kw::Underscore) { None } else { Some(p.parse_expr()?) };\n+                ast::InlineAsmOperand::SplitInOut { reg, in_expr: expr, out_expr, late: false }\n+            } else {\n+                ast::InlineAsmOperand::InOut { reg, expr, late: false }\n+            }\n+        } else if p.eat(&token::Ident(sym::inlateout, false)) {\n+            let reg = parse_reg(&mut p, &mut explicit_reg)?;\n+            let expr = p.parse_expr()?;\n+            if p.eat(&token::FatArrow) {\n+                let out_expr =\n+                    if p.eat_keyword(kw::Underscore) { None } else { Some(p.parse_expr()?) };\n+                ast::InlineAsmOperand::SplitInOut { reg, in_expr: expr, out_expr, late: true }\n+            } else {\n+                ast::InlineAsmOperand::InOut { reg, expr, late: true }\n+            }\n+        } else if p.eat(&token::Ident(kw::Const, false)) {\n+            let expr = p.parse_expr()?;\n+            ast::InlineAsmOperand::Const { expr }\n+        } else {\n+            p.expect(&token::Ident(sym::sym, false))?;\n+            let expr = p.parse_expr()?;\n+            match expr.kind {\n+                ast::ExprKind::Path(..) => {}\n+                _ => {\n+                    let err = ecx\n+                        .struct_span_err(expr.span, \"argument to `sym` must be a path expression\");\n+                    return Err(err);\n+                }\n+            }\n+            ast::InlineAsmOperand::Sym { expr }\n+        };\n+\n+        let span = span_start.to(p.prev_token.span);\n+        let slot = args.operands.len();\n+        args.operands.push((op, span));\n+\n+        // Validate the order of named, positional & explicit register operands and options. We do\n+        // this at the end once we have the full span of the argument available.\n+        if let Some(options_span) = args.options_span {\n+            ecx.struct_span_err(span, \"arguments are not allowed after options\")\n+                .span_label(options_span, \"previous options\")\n+                .span_label(span, \"argument\")\n+                .emit();\n+        }\n+        if explicit_reg {\n+            if name.is_some() {\n+                ecx.struct_span_err(span, \"explicit register arguments cannot have names\").emit();\n+            }\n+            args.reg_args.insert(slot);\n+        } else if let Some(name) = name {\n+            if let Some(&prev) = args.named_args.get(&name) {\n+                ecx.struct_span_err(span, &format!(\"duplicate argument named `{}`\", name))\n+                    .span_label(args.operands[prev].1, \"previously here\")\n+                    .span_label(span, \"duplicate argument\")\n+                    .emit();\n+                continue;\n+            }\n+            if !args.reg_args.is_empty() {\n+                let mut err = ecx.struct_span_err(\n+                    span,\n+                    \"named arguments cannot follow explicit register arguments\",\n+                );\n+                err.span_label(span, \"named argument\");\n+                for pos in &args.reg_args {\n+                    err.span_label(args.operands[*pos].1, \"explicit register argument\");\n+                }\n+                err.emit();\n+            }\n+            args.named_args.insert(name, slot);\n+        } else {\n+            if !args.named_args.is_empty() || !args.reg_args.is_empty() {\n+                let mut err = ecx.struct_span_err(\n+                    span,\n+                    \"positional arguments cannot follow named arguments \\\n+                     or explicit register arguments\",\n+                );\n+                err.span_label(span, \"positional argument\");\n+                for pos in args.named_args.values() {\n+                    err.span_label(args.operands[*pos].1, \"named argument\");\n+                }\n+                for pos in &args.reg_args {\n+                    err.span_label(args.operands[*pos].1, \"explicit register argument\");\n+                }\n+                err.emit();\n+            }\n+        }\n+    }\n+\n+    if args.options.contains(InlineAsmOptions::NOMEM)\n+        && args.options.contains(InlineAsmOptions::READONLY)\n+    {\n+        let span = args.options_span.unwrap();\n+        ecx.struct_span_err(span, \"the `nomem` and `readonly` options are mutually exclusive\")\n+            .emit();\n+    }\n+    if args.options.contains(InlineAsmOptions::PURE)\n+        && args.options.contains(InlineAsmOptions::NORETURN)\n+    {\n+        let span = args.options_span.unwrap();\n+        ecx.struct_span_err(span, \"the `pure` and `noreturn` options are mutually exclusive\")\n+            .emit();\n+    }\n+    if args.options.contains(InlineAsmOptions::PURE)\n+        && !args.options.intersects(InlineAsmOptions::NOMEM | InlineAsmOptions::READONLY)\n+    {\n+        let span = args.options_span.unwrap();\n+        ecx.struct_span_err(\n+            span,\n+            \"the `pure` option must be combined with either `nomem` or `readonly`\",\n+        )\n+        .emit();\n+    }\n+\n+    let mut have_real_output = false;\n+    let mut outputs_sp = vec![];\n+    for (op, op_sp) in &args.operands {\n+        match op {\n+            ast::InlineAsmOperand::Out { expr, .. }\n+            | ast::InlineAsmOperand::SplitInOut { out_expr: expr, .. } => {\n+                outputs_sp.push(*op_sp);\n+                have_real_output |= expr.is_some();\n+            }\n+            ast::InlineAsmOperand::InOut { .. } => {\n+                outputs_sp.push(*op_sp);\n+                have_real_output = true;\n+            }\n+            _ => {}\n+        }\n+    }\n+    if args.options.contains(InlineAsmOptions::PURE) && !have_real_output {\n+        ecx.struct_span_err(\n+            args.options_span.unwrap(),\n+            \"asm with `pure` option must have at least one output\",\n+        )\n+        .emit();\n+    }\n+    if args.options.contains(InlineAsmOptions::NORETURN) && !outputs_sp.is_empty() {\n+        let err = ecx\n+            .struct_span_err(outputs_sp, \"asm outputs are not allowed with the `noreturn` option\");\n+\n+        // Bail out now since this is likely to confuse MIR\n+        return Err(err);\n+    }\n+\n+    Ok(args)\n+}\n+\n+fn expand_preparsed_asm(ecx: &mut ExtCtxt<'_>, sp: Span, args: AsmArgs) -> P<ast::Expr> {\n+    let msg = \"asm template must be a string literal\";\n+    let template_sp = args.template.span;\n+    let (template_str, template_style, template_span) =\n+        match expr_to_spanned_string(ecx, args.template, msg) {\n+            Ok(template) => template,\n+            Err(err) => {\n+                if let Some(mut err) = err {\n+                    err.emit();\n+                }\n+                return DummyResult::raw_expr(sp, true);\n+            }\n+        };\n+\n+    let str_style = match template_style {\n+        ast::StrStyle::Cooked => None,\n+        ast::StrStyle::Raw(raw) => Some(raw as usize),\n+    };\n+\n+    let template_str = &template_str.as_str();\n+    let template_snippet = ecx.source_map().span_to_snippet(template_sp).ok();\n+    let mut parser = parse::Parser::new(\n+        template_str,\n+        str_style,\n+        template_snippet,\n+        false,\n+        parse::ParseMode::InlineAsm,\n+    );\n+\n+    let mut unverified_pieces = Vec::new();\n+    while let Some(piece) = parser.next() {\n+        if !parser.errors.is_empty() {\n+            break;\n+        } else {\n+            unverified_pieces.push(piece);\n+        }\n+    }\n+\n+    if !parser.errors.is_empty() {\n+        let err = parser.errors.remove(0);\n+        let err_sp = template_span.from_inner(err.span);\n+        let mut e = ecx\n+            .struct_span_err(err_sp, &format!(\"invalid asm template string: {}\", err.description));\n+        e.span_label(err_sp, err.label + \" in asm template string\");\n+        if let Some(note) = err.note {\n+            e.note(&note);\n+        }\n+        if let Some((label, span)) = err.secondary_label {\n+            let err_sp = template_span.from_inner(span);\n+            e.span_label(err_sp, label);\n+        }\n+        e.emit();\n+        return DummyResult::raw_expr(sp, true);\n+    }\n+\n+    // Register operands are implicitly used since they are not allowed to be\n+    // referenced in the template string.\n+    let mut used = vec![false; args.operands.len()];\n+    for pos in &args.reg_args {\n+        used[*pos] = true;\n+    }\n+\n+    let named_pos: FxHashSet<usize> = args.named_args.values().cloned().collect();\n+    let mut arg_spans = parser.arg_places.iter().map(|span| template_span.from_inner(*span));\n+    let mut template = vec![];\n+    for piece in unverified_pieces {\n+        match piece {\n+            parse::Piece::String(s) => template.push(InlineAsmTemplatePiece::String(s.to_string())),\n+            parse::Piece::NextArgument(arg) => {\n+                let span = arg_spans.next().unwrap_or(template_sp);\n+\n+                let operand_idx = match arg.position {\n+                    parse::ArgumentIs(idx) | parse::ArgumentImplicitlyIs(idx) => {\n+                        if idx >= args.operands.len()\n+                            || named_pos.contains(&idx)\n+                            || args.reg_args.contains(&idx)\n+                        {\n+                            let msg = format!(\"invalid reference to argument at index {}\", idx);\n+                            let mut err = ecx.struct_span_err(span, &msg);\n+                            err.span_label(span, \"from here\");\n+\n+                            let positional_args =\n+                                args.operands.len() - args.named_args.len() - args.reg_args.len();\n+                            let positional = if positional_args != args.operands.len() {\n+                                \"positional \"\n+                            } else {\n+                                \"\"\n+                            };\n+                            let msg = match positional_args {\n+                                0 => format!(\"no {}arguments were given\", positional),\n+                                1 => format!(\"there is 1 {}argument\", positional),\n+                                x => format!(\"there are {} {}arguments\", x, positional),\n+                            };\n+                            err.note(&msg);\n+\n+                            if named_pos.contains(&idx) {\n+                                err.span_label(args.operands[idx].1, \"named argument\");\n+                                err.span_note(\n+                                    args.operands[idx].1,\n+                                    \"named arguments cannot be referenced by position\",\n+                                );\n+                            } else if args.reg_args.contains(&idx) {\n+                                err.span_label(args.operands[idx].1, \"explicit register argument\");\n+                                err.span_note(\n+                                    args.operands[idx].1,\n+                                    \"explicit register arguments cannot be used in the asm template\",\n+                                );\n+                            }\n+                            err.emit();\n+                            None\n+                        } else {\n+                            Some(idx)\n+                        }\n+                    }\n+                    parse::ArgumentNamed(name) => match args.named_args.get(&name) {\n+                        Some(&idx) => Some(idx),\n+                        None => {\n+                            let msg = format!(\"there is no argument named `{}`\", name);\n+                            ecx.struct_span_err(span, &msg[..]).emit();\n+                            None\n+                        }\n+                    },\n+                };\n+\n+                let mut chars = arg.format.ty.chars();\n+                let mut modifier = chars.next();\n+                if !chars.next().is_none() {\n+                    let span = arg\n+                        .format\n+                        .ty_span\n+                        .map(|sp| template_sp.from_inner(sp))\n+                        .unwrap_or(template_sp);\n+                    ecx.struct_span_err(span, \"asm template modifier must be a single character\")\n+                        .emit();\n+                    modifier = None;\n+                }\n+\n+                if let Some(operand_idx) = operand_idx {\n+                    used[operand_idx] = true;\n+                    template.push(InlineAsmTemplatePiece::Placeholder {\n+                        operand_idx,\n+                        modifier,\n+                        span,\n+                    });\n+                }\n+            }\n+        }\n+    }\n+\n+    let operands = args.operands;\n+    let unused_operands: Vec<_> = used\n+        .into_iter()\n+        .enumerate()\n+        .filter(|&(_, used)| !used)\n+        .map(|(idx, _)| {\n+            if named_pos.contains(&idx) {\n+                // named argument\n+                (operands[idx].1, \"named argument never used\")\n+            } else {\n+                // positional argument\n+                (operands[idx].1, \"argument never used\")\n+            }\n+        })\n+        .collect();\n+    match unused_operands.len() {\n+        0 => {}\n+        1 => {\n+            let (sp, msg) = unused_operands.into_iter().next().unwrap();\n+            let mut err = ecx.struct_span_err(sp, msg);\n+            err.span_label(sp, msg);\n+            err.emit();\n+        }\n+        _ => {\n+            let mut err = ecx.struct_span_err(\n+                unused_operands.iter().map(|&(sp, _)| sp).collect::<Vec<Span>>(),\n+                \"multiple unused asm arguments\",\n+            );\n+            for (sp, msg) in unused_operands {\n+                err.span_label(sp, msg);\n+            }\n+            err.emit();\n+        }\n+    }\n+\n+    let inline_asm = ast::InlineAsm { template, operands, options: args.options };\n+    P(ast::Expr {\n+        id: ast::DUMMY_NODE_ID,\n+        kind: ast::ExprKind::InlineAsm(inline_asm),\n+        span: sp,\n+        attrs: ast::AttrVec::new(),\n+    })\n+}\n+\n+pub fn expand_asm<'cx>(\n+    ecx: &'cx mut ExtCtxt<'_>,\n+    sp: Span,\n+    tts: TokenStream,\n+) -> Box<dyn base::MacResult + 'cx> {\n+    match parse_args(ecx, sp, tts) {\n+        Ok(args) => MacEager::expr(expand_preparsed_asm(ecx, sp, args)),\n+        Err(mut err) => {\n+            err.emit();\n+            DummyResult::any(sp)\n+        }\n+    }\n+}"}, {"sha": "eed01b262bf0c10cf5a9bb74acc075b9e485fb1c", "filename": "src/librustc_builtin_macros/format.rs", "status": "modified", "additions": 11, "deletions": 108, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/a0adf53bc97d6e79c8c2e9b3f8a548bc65c7adf6/src%2Flibrustc_builtin_macros%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0adf53bc97d6e79c8c2e9b3f8a548bc65c7adf6/src%2Flibrustc_builtin_macros%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fformat.rs?ref=a0adf53bc97d6e79c8c2e9b3f8a548bc65c7adf6", "patch": "@@ -108,8 +108,6 @@ struct Context<'a, 'b> {\n     arg_spans: Vec<Span>,\n     /// All the formatting arguments that have formatting flags set, in order for diagnostics.\n     arg_with_formatting: Vec<parse::FormatSpec<'a>>,\n-    /// Whether this formatting string is a literal or it comes from a macro.\n-    is_literal: bool,\n }\n \n /// Parses the arguments from the given list of tokens, returning the diagnostic\n@@ -324,7 +322,7 @@ impl<'a, 'b> Context<'a, 'b> {\n     /// format string.\n     fn report_invalid_references(&self, numbered_position_args: bool) {\n         let mut e;\n-        let sp = if self.is_literal {\n+        let sp = if !self.arg_spans.is_empty() {\n             // Point at the formatting arguments.\n             MultiSpan::from_spans(self.arg_spans.clone())\n         } else {\n@@ -372,7 +370,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                 let reg = refs.pop().unwrap();\n                 (format!(\"arguments {head} and {tail}\", head = refs.join(\", \"), tail = reg,), pos)\n             };\n-            if !self.is_literal {\n+            if self.arg_spans.is_empty() {\n                 sp = MultiSpan::from_span(self.fmtsp);\n             }\n \n@@ -502,11 +500,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                     }\n                     None => {\n                         let msg = format!(\"there is no argument named `{}`\", name);\n-                        let sp = if self.is_literal {\n-                            *self.arg_spans.get(self.curpiece).unwrap_or(&self.fmtsp)\n-                        } else {\n-                            self.fmtsp\n-                        };\n+                        let sp = *self.arg_spans.get(self.curpiece).unwrap_or(&self.fmtsp);\n                         let mut err = self.ecx.struct_span_err(sp, &msg[..]);\n                         err.emit();\n                     }\n@@ -892,110 +886,20 @@ pub fn expand_preparsed_format_args(\n         }\n     };\n \n-    let (is_literal, fmt_snippet) = match ecx.source_map().span_to_snippet(fmt_sp) {\n-        Ok(s) => (s.starts_with('\"') || s.starts_with(\"r#\"), Some(s)),\n-        _ => (false, None),\n-    };\n-\n     let str_style = match fmt_style {\n         ast::StrStyle::Cooked => None,\n         ast::StrStyle::Raw(raw) => Some(raw as usize),\n     };\n \n-    /// Finds the indices of all characters that have been processed and differ between the actual\n-    /// written code (code snippet) and the `InternedString` that gets processed in the `Parser`\n-    /// in order to properly synthethise the intra-string `Span`s for error diagnostics.\n-    fn find_skips(snippet: &str, is_raw: bool) -> Vec<usize> {\n-        let mut eat_ws = false;\n-        let mut s = snippet.chars().enumerate().peekable();\n-        let mut skips = vec![];\n-        while let Some((pos, c)) = s.next() {\n-            match (c, s.peek()) {\n-                // skip whitespace and empty lines ending in '\\\\'\n-                ('\\\\', Some((next_pos, '\\n'))) if !is_raw => {\n-                    eat_ws = true;\n-                    skips.push(pos);\n-                    skips.push(*next_pos);\n-                    let _ = s.next();\n-                }\n-                ('\\\\', Some((next_pos, '\\n' | 'n' | 't'))) if eat_ws => {\n-                    skips.push(pos);\n-                    skips.push(*next_pos);\n-                    let _ = s.next();\n-                }\n-                (' ' | '\\n' | '\\t', _) if eat_ws => {\n-                    skips.push(pos);\n-                }\n-                ('\\\\', Some((next_pos, 'n' | 't' | '0' | '\\\\' | '\\'' | '\\\"'))) => {\n-                    skips.push(*next_pos);\n-                    let _ = s.next();\n-                }\n-                ('\\\\', Some((_, 'x'))) if !is_raw => {\n-                    for _ in 0..3 {\n-                        // consume `\\xAB` literal\n-                        if let Some((pos, _)) = s.next() {\n-                            skips.push(pos);\n-                        } else {\n-                            break;\n-                        }\n-                    }\n-                }\n-                ('\\\\', Some((_, 'u'))) if !is_raw => {\n-                    if let Some((pos, _)) = s.next() {\n-                        skips.push(pos);\n-                    }\n-                    if let Some((next_pos, next_c)) = s.next() {\n-                        if next_c == '{' {\n-                            skips.push(next_pos);\n-                            let mut i = 0; // consume up to 6 hexanumeric chars + closing `}`\n-                            while let (Some((next_pos, c)), true) = (s.next(), i < 7) {\n-                                if c.is_digit(16) {\n-                                    skips.push(next_pos);\n-                                } else if c == '}' {\n-                                    skips.push(next_pos);\n-                                    break;\n-                                } else {\n-                                    break;\n-                                }\n-                                i += 1;\n-                            }\n-                        } else if next_c.is_digit(16) {\n-                            skips.push(next_pos);\n-                            // We suggest adding `{` and `}` when appropriate, accept it here as if\n-                            // it were correct\n-                            let mut i = 0; // consume up to 6 hexanumeric chars\n-                            while let (Some((next_pos, c)), _) = (s.next(), i < 6) {\n-                                if c.is_digit(16) {\n-                                    skips.push(next_pos);\n-                                } else {\n-                                    break;\n-                                }\n-                                i += 1;\n-                            }\n-                        }\n-                    }\n-                }\n-                _ if eat_ws => {\n-                    // `take_while(|c| c.is_whitespace())`\n-                    eat_ws = false;\n-                }\n-                _ => {}\n-            }\n-        }\n-        skips\n-    }\n-\n-    let skips = if let (true, Some(ref snippet)) = (is_literal, fmt_snippet.as_ref()) {\n-        let r_start = str_style.map(|r| r + 1).unwrap_or(0);\n-        let r_end = str_style.map(|r| r).unwrap_or(0);\n-        let s = &snippet[r_start + 1..snippet.len() - r_end - 1];\n-        find_skips(s, str_style.is_some())\n-    } else {\n-        vec![]\n-    };\n-\n     let fmt_str = &fmt_str.as_str(); // for the suggestions below\n-    let mut parser = parse::Parser::new(fmt_str, str_style, skips, append_newline);\n+    let fmt_snippet = ecx.source_map().span_to_snippet(fmt_sp).ok();\n+    let mut parser = parse::Parser::new(\n+        fmt_str,\n+        str_style,\n+        fmt_snippet,\n+        append_newline,\n+        parse::ParseMode::Format,\n+    );\n \n     let mut unverified_pieces = Vec::new();\n     while let Some(piece) = parser.next() {\n@@ -1048,7 +952,6 @@ pub fn expand_preparsed_format_args(\n         invalid_refs: Vec::new(),\n         arg_spans,\n         arg_with_formatting: Vec::new(),\n-        is_literal,\n     };\n \n     // This needs to happen *after* the Parser has consumed all pieces to create all the spans"}, {"sha": "a0f82d65618f460d8313510c5f38683711fdf8d0", "filename": "src/librustc_builtin_macros/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a0adf53bc97d6e79c8c2e9b3f8a548bc65c7adf6/src%2Flibrustc_builtin_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0adf53bc97d6e79c8c2e9b3f8a548bc65c7adf6/src%2Flibrustc_builtin_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Flib.rs?ref=a0adf53bc97d6e79c8c2e9b3f8a548bc65c7adf6", "patch": "@@ -19,6 +19,7 @@ use rustc_expand::proc_macro::BangProcMacro;\n use rustc_span::edition::Edition;\n use rustc_span::symbol::{sym, Ident};\n \n+mod asm;\n mod assert;\n mod cfg;\n mod cfg_accessible;\n@@ -61,7 +62,7 @@ pub fn register_builtin_macros(resolver: &mut dyn Resolver, edition: Edition) {\n     }\n \n     register_bang! {\n-        asm: llvm_asm::expand_llvm_asm,\n+        asm: asm::expand_asm,\n         assert: assert::expand_assert,\n         cfg: cfg::expand_cfg,\n         column: source_util::expand_column,"}, {"sha": "1f0764b06b057b86668aad9bcab286f76f871524", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a0adf53bc97d6e79c8c2e9b3f8a548bc65c7adf6/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0adf53bc97d6e79c8c2e9b3f8a548bc65c7adf6/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=a0adf53bc97d6e79c8c2e9b3f8a548bc65c7adf6", "patch": "@@ -376,6 +376,8 @@ symbols! {\n         if_let,\n         if_while_or_patterns,\n         ignore,\n+        inlateout,\n+        inout,\n         impl_header_lifetime_elision,\n         impl_lint_pass,\n         impl_trait_in_bindings,\n@@ -411,6 +413,7 @@ symbols! {\n         label_break_value,\n         lang,\n         lang_items,\n+        lateout,\n         let_chains,\n         lhs,\n         lib,\n@@ -495,12 +498,15 @@ symbols! {\n         no_link,\n         no_main,\n         no_mangle,\n+        nomem,\n         non_ascii_idents,\n         None,\n         non_exhaustive,\n         non_modrs_mods,\n-        no_sanitize,\n+        noreturn,\n         no_niche,\n+        no_sanitize,\n+        nostack,\n         no_stack_check,\n         no_start,\n         no_std,\n@@ -519,11 +525,13 @@ symbols! {\n         option,\n         Option,\n         option_env,\n+        options,\n         opt_out_copy,\n         or,\n         or_patterns,\n         Ord,\n         Ordering,\n+        out,\n         Output,\n         overlapping_marker_traits,\n         packed,\n@@ -556,6 +564,7 @@ symbols! {\n         pref_align_of,\n         prelude,\n         prelude_import,\n+        preserves_flags,\n         primitive,\n         proc_dash_macro: \"proc-macro\",\n         proc_macro,\n@@ -572,6 +581,7 @@ symbols! {\n         profiler_runtime,\n         ptr_offset_from,\n         pub_restricted,\n+        pure,\n         pushpop_unsafe,\n         quad_precision_float,\n         question_mark,\n@@ -586,6 +596,7 @@ symbols! {\n         raw_identifiers,\n         raw_ref_op,\n         Rc,\n+        readonly,\n         Ready,\n         reason,\n         recursion_limit,\n@@ -723,6 +734,7 @@ symbols! {\n         sty,\n         sub_with_overflow,\n         suggestion,\n+        sym,\n         sync_trait,\n         target_feature,\n         target_feature_11,\n@@ -1187,8 +1199,8 @@ pub mod sym {\n     // have a static symbol and therefore are fast.\n     pub fn integer<N: TryInto<usize> + Copy + ToString>(n: N) -> Symbol {\n         if let Result::Ok(idx) = n.try_into() {\n-            if let Option::Some(&sym) = digits_array.get(idx) {\n-                return sym;\n+            if let Option::Some(&sym_) = digits_array.get(idx) {\n+                return sym_;\n             }\n         }\n         Symbol::intern(&n.to_string())"}, {"sha": "7e66e08f7e6a663194efcc4b7145e1263b05caee", "filename": "src/librustc_trait_selection/traits/on_unimplemented.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a0adf53bc97d6e79c8c2e9b3f8a548bc65c7adf6/src%2Flibrustc_trait_selection%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0adf53bc97d6e79c8c2e9b3f8a548bc65c7adf6/src%2Flibrustc_trait_selection%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fon_unimplemented.rs?ref=a0adf53bc97d6e79c8c2e9b3f8a548bc65c7adf6", "patch": "@@ -1,4 +1,4 @@\n-use fmt_macros::{Parser, Piece, Position};\n+use fmt_macros::{ParseMode, Parser, Piece, Position};\n \n use rustc_ast::ast::{MetaItem, NestedMetaItem};\n use rustc_attr as attr;\n@@ -272,7 +272,7 @@ impl<'tcx> OnUnimplementedFormatString {\n         let name = tcx.item_name(trait_def_id);\n         let generics = tcx.generics_of(trait_def_id);\n         let s = self.0.as_str();\n-        let parser = Parser::new(&s, None, vec![], false);\n+        let parser = Parser::new(&s, None, None, false, ParseMode::Format);\n         let mut result = Ok(());\n         for token in parser {\n             match token {\n@@ -350,7 +350,7 @@ impl<'tcx> OnUnimplementedFormatString {\n         let empty_string = String::new();\n \n         let s = self.0.as_str();\n-        let parser = Parser::new(&s, None, vec![], false);\n+        let parser = Parser::new(&s, None, None, false, ParseMode::Format);\n         let item_context = (options.get(&sym::item_context)).unwrap_or(&empty_string);\n         parser\n             .map(|p| match p {"}]}