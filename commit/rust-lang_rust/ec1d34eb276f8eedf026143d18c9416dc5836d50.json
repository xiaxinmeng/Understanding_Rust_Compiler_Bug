{"sha": "ec1d34eb276f8eedf026143d18c9416dc5836d50", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjMWQzNGViMjc2ZjhlZWRmMDI2MTQzZDE4Yzk0MTZkYzU4MzZkNTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-16T05:36:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-16T05:36:14Z"}, "message": "auto merge of #16513 : sfackler/rust/io-util-cleanup, r=alexcrichton\n\n* Fix `LimitReader`'s `Buffer::consume` impl to avoid limit underflow\r\n* Make `MultiWriter` fail fast instead of always running through each\r\n    `Writer`. This may or may not be what we want, but it at least\r\n    doesn't throw any errors encountered in later `Writer`s into oblivion.\r\n* Prevent `IterReader`'s `Reader::read` impl from returning EOF if given\r\n    an empty buffer.\r\n\r\n[breaking-change]", "tree": {"sha": "16304df2558af1c5a5608873a24a9b0fb381487a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/16304df2558af1c5a5608873a24a9b0fb381487a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec1d34eb276f8eedf026143d18c9416dc5836d50", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec1d34eb276f8eedf026143d18c9416dc5836d50", "html_url": "https://github.com/rust-lang/rust/commit/ec1d34eb276f8eedf026143d18c9416dc5836d50", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec1d34eb276f8eedf026143d18c9416dc5836d50/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d30001d04d2006645468d3c194c9e3ae6ddc4b52", "url": "https://api.github.com/repos/rust-lang/rust/commits/d30001d04d2006645468d3c194c9e3ae6ddc4b52", "html_url": "https://github.com/rust-lang/rust/commit/d30001d04d2006645468d3c194c9e3ae6ddc4b52"}, {"sha": "89a0060997479de770be0a63731423e2a305beda", "url": "https://api.github.com/repos/rust-lang/rust/commits/89a0060997479de770be0a63731423e2a305beda", "html_url": "https://github.com/rust-lang/rust/commit/89a0060997479de770be0a63731423e2a305beda"}], "stats": {"total": 56, "additions": 38, "deletions": 18}, "files": [{"sha": "c3cd2faf773b58930bd624086880bf559c13e520", "filename": "src/libstd/io/util.rs", "status": "modified", "additions": 38, "deletions": 18, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/ec1d34eb276f8eedf026143d18c9416dc5836d50/src%2Flibstd%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec1d34eb276f8eedf026143d18c9416dc5836d50/src%2Flibstd%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Futil.rs?ref=ec1d34eb276f8eedf026143d18c9416dc5836d50", "patch": "@@ -48,10 +48,12 @@ impl<R: Reader> Reader for LimitReader<R> {\n         }\n \n         let len = cmp::min(self.limit, buf.len());\n-        self.inner.read(buf.mut_slice_to(len)).map(|len| {\n-            self.limit -= len;\n-            len\n-        })\n+        let res = self.inner.read(buf.mut_slice_to(len));\n+        match res {\n+            Ok(len) => self.limit -= len,\n+            _ => {}\n+        }\n+        res\n     }\n }\n \n@@ -67,6 +69,8 @@ impl<R: Buffer> Buffer for LimitReader<R> {\n     }\n \n     fn consume(&mut self, amt: uint) {\n+        // Don't let callers reset the limit by passing an overlarge value\n+        let amt = cmp::min(amt, self.limit);\n         self.limit -= amt;\n         self.inner.consume(amt);\n     }\n@@ -97,6 +101,7 @@ impl Buffer for ZeroReader {\n         static DATA: [u8, ..64] = [0, ..64];\n         Ok(DATA.as_slice())\n     }\n+\n     fn consume(&mut self, _amt: uint) {}\n }\n \n@@ -117,7 +122,10 @@ impl Buffer for NullReader {\n     fn consume(&mut self, _amt: uint) {}\n }\n \n-/// A `Writer` which multiplexes writes to a set of `Writers`.\n+/// A `Writer` which multiplexes writes to a set of `Writer`s.\n+///\n+/// The `Writer`s are delegated to in order. If any `Writer` returns an error,\n+/// that error is returned immediately and remaining `Writer`s are not called.\n pub struct MultiWriter {\n     writers: Vec<Box<Writer>>\n }\n@@ -132,24 +140,22 @@ impl MultiWriter {\n impl Writer for MultiWriter {\n     #[inline]\n     fn write(&mut self, buf: &[u8]) -> io::IoResult<()> {\n-        let mut ret = Ok(());\n         for writer in self.writers.mut_iter() {\n-            ret = ret.and(writer.write(buf));\n+            try!(writer.write(buf));\n         }\n-        return ret;\n+        Ok(())\n     }\n \n     #[inline]\n     fn flush(&mut self) -> io::IoResult<()> {\n-        let mut ret = Ok(());\n         for writer in self.writers.mut_iter() {\n-            ret = ret.and(writer.flush());\n+            try!(writer.flush());\n         }\n-        return ret;\n+        Ok(())\n     }\n }\n \n-/// A `Reader` which chains input from multiple `Readers`, reading each to\n+/// A `Reader` which chains input from multiple `Reader`s, reading each to\n /// completion before moving onto the next.\n pub struct ChainedReader<I, R> {\n     readers: I,\n@@ -229,17 +235,16 @@ pub fn copy<R: Reader, W: Writer>(r: &mut R, w: &mut W) -> io::IoResult<()> {\n     }\n }\n \n-/// A `Reader` which converts an `Iterator<u8>` into a `Reader`.\n+/// An adaptor converting an `Iterator<u8>` to a `Reader`.\n pub struct IterReader<T> {\n     iter: T,\n }\n \n impl<T: Iterator<u8>> IterReader<T> {\n-    /// Create a new `IterReader` which will read from the specified `Iterator`.\n+    /// Creates a new `IterReader` which will read from the specified\n+    /// `Iterator`.\n     pub fn new(iter: T) -> IterReader<T> {\n-        IterReader {\n-            iter: iter,\n-        }\n+        IterReader { iter: iter }\n     }\n }\n \n@@ -251,7 +256,7 @@ impl<T: Iterator<u8>> Reader for IterReader<T> {\n             *slot = elt;\n             len += 1;\n         }\n-        if len == 0 {\n+        if len == 0 && buf.len() != 0 {\n             Err(io::standard_error(io::EndOfFile))\n         } else {\n             Ok(len)\n@@ -297,6 +302,14 @@ mod test {\n         assert_eq!(0, r.limit());\n     }\n \n+    #[test]\n+    fn test_limit_reader_overlong_consume() {\n+        let mut r = MemReader::new(vec![0, 1, 2, 3, 4, 5]);\n+        let mut r = LimitReader::new(r.by_ref(), 1);\n+        r.consume(2);\n+        assert_eq!(vec![], r.read_to_end().unwrap());\n+    }\n+\n     #[test]\n     fn test_null_writer() {\n         let mut s = NullWriter;\n@@ -415,4 +428,11 @@ mod test {\n \n         assert_eq!(r.read(buf).unwrap_err().kind, io::EndOfFile);\n     }\n+\n+    #[test]\n+    fn iter_reader_zero_length() {\n+        let mut r = IterReader::new(range(0u8, 8));\n+        let mut buf = [];\n+        assert_eq!(Ok(0), r.read(buf));\n+    }\n }"}]}