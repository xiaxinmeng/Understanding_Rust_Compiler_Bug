{"sha": "d327e6e681d320d990f65951b7143f2f6a4139a7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzMjdlNmU2ODFkMzIwZDk5MGY2NTk1MWI3MTQzZjJmNmE0MTM5YTc=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-05-22T16:08:24Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-05-22T16:08:24Z"}, "message": "Rollup merge of #61034 - eddyb:soa-metadata-prereq, r=michaelwoerister\n\nrustc_metadata: parametrize schema::CrateRoot by 'tcx and rip out old unused incremental infra.\n\nThese are the first two commits of #59953, already reviewed and approved by @michaelwoerister.\n\nr? @michaelwoerister", "tree": {"sha": "9eeeb98567e1a6f4578ea766080e3a4d1483d62e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9eeeb98567e1a6f4578ea766080e3a4d1483d62e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d327e6e681d320d990f65951b7143f2f6a4139a7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJc5XP4CRBK7hj4Ov3rIwAAdHIIAE+ya17WuVcxcZco7GBSJJ+d\ntFn1Og3OEmLx536B4jsjhBl/vEdr+I2SyxpNATz/v1wfiahDHkVcUEU4z57Sm4Qp\nyUaSmV7VmZXibVvqkktzlYcEILs7hACFRAB/Lg3l+66+Xw/G65eexOMesbHNrrps\nY8bwIpEiH+3sX8Xsn3gD3ca7E5pm+cX7rxJcnGA8bL2uhvt/eqy7wdUL/4aAVAuL\nerChBaoQlrzwnL2joJEp9mr1C9EMhT5r+75xBGRgUA4MiuEmXfeaHQ8T2yOfM89J\nDyOSeMBeUY7I0mX+0HN3u5OQNFF+evPzcYKFTJD0r784i68vM9npG6jMzmNEgps=\n=nH/z\n-----END PGP SIGNATURE-----\n", "payload": "tree 9eeeb98567e1a6f4578ea766080e3a4d1483d62e\nparent 21ba9310c129b29a83f5328440b406c2cd65f0e3\nparent 7327768a75621df3f4cec4229a0812eceb7c5adb\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1558541304 +0200\ncommitter GitHub <noreply@github.com> 1558541304 +0200\n\nRollup merge of #61034 - eddyb:soa-metadata-prereq, r=michaelwoerister\n\nrustc_metadata: parametrize schema::CrateRoot by 'tcx and rip out old unused incremental infra.\n\nThese are the first two commits of #59953, already reviewed and approved by @michaelwoerister.\n\nr? @michaelwoerister\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d327e6e681d320d990f65951b7143f2f6a4139a7", "html_url": "https://github.com/rust-lang/rust/commit/d327e6e681d320d990f65951b7143f2f6a4139a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d327e6e681d320d990f65951b7143f2f6a4139a7/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "21ba9310c129b29a83f5328440b406c2cd65f0e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/21ba9310c129b29a83f5328440b406c2cd65f0e3", "html_url": "https://github.com/rust-lang/rust/commit/21ba9310c129b29a83f5328440b406c2cd65f0e3"}, {"sha": "7327768a75621df3f4cec4229a0812eceb7c5adb", "url": "https://api.github.com/repos/rust-lang/rust/commits/7327768a75621df3f4cec4229a0812eceb7c5adb", "html_url": "https://github.com/rust-lang/rust/commit/7327768a75621df3f4cec4229a0812eceb7c5adb"}], "stats": {"total": 822, "additions": 157, "deletions": 665}, "files": [{"sha": "991bebc647d0f7ca48822c1af358f2010ba1c2e7", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d327e6e681d320d990f65951b7143f2f6a4139a7/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d327e6e681d320d990f65951b7143f2f6a4139a7/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=d327e6e681d320d990f65951b7143f2f6a4139a7", "patch": "@@ -162,7 +162,7 @@ impl<'a> CrateLoader<'a> {\n \n     fn verify_no_symbol_conflicts(&self,\n                                   span: Span,\n-                                  root: &CrateRoot) {\n+                                  root: &CrateRoot<'_>) {\n         // Check for (potential) conflicts with the local crate\n         if self.local_crate_name == root.name &&\n            self.sess.local_crate_disambiguator() == root.disambiguator {\n@@ -476,7 +476,7 @@ impl<'a> CrateLoader<'a> {\n     // Go through the crate metadata and load any crates that it references\n     fn resolve_crate_deps(&mut self,\n                           root: &Option<CratePaths>,\n-                          crate_root: &CrateRoot,\n+                          crate_root: &CrateRoot<'_>,\n                           metadata: &MetadataBlob,\n                           krate: CrateNum,\n                           span: Span,\n@@ -582,7 +582,7 @@ impl<'a> CrateLoader<'a> {\n     /// implemented as dynamic libraries, but we have a possible future where\n     /// custom derive (and other macro-1.1 style features) are implemented via\n     /// executables and custom IPC.\n-    fn load_derive_macros(&mut self, root: &CrateRoot, dylib: Option<PathBuf>, span: Span)\n+    fn load_derive_macros(&mut self, root: &CrateRoot<'_>, dylib: Option<PathBuf>, span: Span)\n                           -> Vec<(ast::Name, Lrc<SyntaxExtension>)> {\n         use std::{env, mem};\n         use crate::dynamic_lib::DynamicLibrary;"}, {"sha": "5d8fabc7e69aeac1d01c3fc74c311948d3d2078a", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d327e6e681d320d990f65951b7143f2f6a4139a7/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d327e6e681d320d990f65951b7143f2f6a4139a7/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=d327e6e681d320d990f65951b7143f2f6a4139a7", "patch": "@@ -64,7 +64,11 @@ pub struct CrateMetadata {\n     /// Used for decoding interpret::AllocIds in a cached & thread-safe manner.\n     pub alloc_decoding_state: AllocDecodingState,\n \n-    pub root: schema::CrateRoot,\n+    // NOTE(eddyb) we pass `'static` to a `'tcx` parameter because this\n+    // lifetime is only used behind `Lazy` / `LazySeq`, and therefore\n+    // acts like an universal (`for<'tcx>`), that is paired up with\n+    // whichever `TyCtxt` is being used to decode those values.\n+    pub root: schema::CrateRoot<'static>,\n \n     /// For each public item in this crate, we encode a key. When the\n     /// crate is loaded, we read all the keys and put them in this"}, {"sha": "49f93c4014dc06ad40724f724d9372bb346820dc", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d327e6e681d320d990f65951b7143f2f6a4139a7/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d327e6e681d320d990f65951b7143f2f6a4139a7/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=d327e6e681d320d990f65951b7143f2f6a4139a7", "patch": "@@ -246,12 +246,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n \n     used_crate_source => { Lrc::new(cdata.source.clone()) }\n \n-    exported_symbols => {\n-        let cnum = cdata.cnum;\n-        assert!(cnum != LOCAL_CRATE);\n-\n-        Arc::new(cdata.exported_symbols(tcx))\n-    }\n+    exported_symbols => { Arc::new(cdata.exported_symbols(tcx)) }\n }\n \n pub fn provide<'tcx>(providers: &mut Providers<'tcx>) {"}, {"sha": "a89cfe42eaaf45f96a604c2a48107ee35eae6b88", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d327e6e681d320d990f65951b7143f2f6a4139a7/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d327e6e681d320d990f65951b7143f2f6a4139a7/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=d327e6e681d320d990f65951b7143f2f6a4139a7", "patch": "@@ -365,7 +365,7 @@ for DecodeContext<'a, 'tcx> {\n \n implement_ty_decoder!( DecodeContext<'a, 'tcx> );\n \n-impl<'a, 'tcx> MetadataBlob {\n+impl<'tcx> MetadataBlob {\n     pub fn is_compatible(&self) -> bool {\n         self.raw_bytes().starts_with(METADATA_HEADER)\n     }\n@@ -374,7 +374,7 @@ impl<'a, 'tcx> MetadataBlob {\n         Lazy::with_position(METADATA_HEADER.len() + 4).decode(self)\n     }\n \n-    pub fn get_root(&self) -> CrateRoot {\n+    pub fn get_root(&self) -> CrateRoot<'tcx> {\n         let slice = self.raw_bytes();\n         let offset = METADATA_HEADER.len();\n         let pos = (((slice[offset + 0] as u32) << 24) | ((slice[offset + 1] as u32) << 16) |\n@@ -444,7 +444,7 @@ impl<'tcx> EntryKind<'tcx> {\n ///  |- proc macro #0 (DefIndex 1:N)\n ///  |- proc macro #1 (DefIndex 1:N+1)\n ///  \\- ...\n-crate fn proc_macro_def_path_table(crate_root: &CrateRoot,\n+crate fn proc_macro_def_path_table(crate_root: &CrateRoot<'_>,\n                                    proc_macros: &[(ast::Name, Lrc<SyntaxExtension>)])\n                                    -> DefPathTable\n {\n@@ -475,7 +475,7 @@ impl<'a, 'tcx> CrateMetadata {\n \n     fn maybe_entry(&self, item_id: DefIndex) -> Option<Lazy<Entry<'tcx>>> {\n         assert!(!self.is_proc_macro(item_id));\n-        self.root.index.lookup(self.blob.raw_bytes(), item_id)\n+        self.root.entries_index.lookup(self.blob.raw_bytes(), item_id)\n     }\n \n     fn entry(&self, item_id: DefIndex) -> Entry<'tcx> {\n@@ -1126,10 +1126,7 @@ impl<'a, 'tcx> CrateMetadata {\n             // link those in so we skip those crates.\n             vec![]\n         } else {\n-            let lazy_seq: LazySeq<(ExportedSymbol<'tcx>, SymbolExportLevel)> =\n-                LazySeq::with_position_and_length(self.root.exported_symbols.position,\n-                                                  self.root.exported_symbols.len);\n-            lazy_seq.decode((self, tcx)).collect()\n+            self.root.exported_symbols.decode((self, tcx)).collect()\n         }\n     }\n "}, {"sha": "6711e54053a178a8575d1d13a20d68731b554130", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 127, "deletions": 162, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/d327e6e681d320d990f65951b7143f2f6a4139a7/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d327e6e681d320d990f65951b7143f2f6a4139a7/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=d327e6e681d320d990f65951b7143f2f6a4139a7", "patch": "@@ -1,6 +1,4 @@\n use crate::index::Index;\n-use crate::index_builder::{FromId, IndexBuilder, Untracked};\n-use crate::isolated_encoder::IsolatedEncoder;\n use crate::schema::*;\n \n use rustc::middle::cstore::{LinkagePreference, NativeLibrary,\n@@ -46,6 +44,8 @@ pub struct EncodeContext<'a, 'tcx: 'a> {\n     opaque: opaque::Encoder,\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n+    entries_index: Index<'tcx>,\n+\n     lazy_state: LazyState,\n     type_shorthands: FxHashMap<Ty<'tcx>, usize>,\n     predicate_shorthands: FxHashMap<ty::Predicate<'tcx>, usize>,\n@@ -300,28 +300,34 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         })\n     }\n \n-    // Encodes something that corresponds to a single DepNode::GlobalMetaData\n-    // and registers the Fingerprint in the `metadata_hashes` map.\n-    pub fn tracked<'x, DATA, R>(&'x mut self,\n-                                op: fn(&mut IsolatedEncoder<'x, 'a, 'tcx>, DATA) -> R,\n-                                data: DATA)\n-                                -> R {\n-        op(&mut IsolatedEncoder::new(self), data)\n+    /// Emit the data for a `DefId` to the metadata. The function to\n+    /// emit the data is `op`, and it will be given `data` as\n+    /// arguments. This `record` function will call `op` to generate\n+    /// the `Entry` (which may point to other encoded information)\n+    /// and will then record the `Lazy<Entry>` for use in the index.\n+    // FIXME(eddyb) remove this.\n+    pub fn record<DATA>(&mut self,\n+                        id: DefId,\n+                        op: impl FnOnce(&mut Self, DATA) -> Entry<'tcx>,\n+                        data: DATA)\n+    {\n+        assert!(id.is_local());\n+\n+        let entry = op(self, data);\n+        let entry = self.lazy(&entry);\n+        self.entries_index.record(id, entry);\n     }\n \n-    fn encode_info_for_items(&mut self) -> Index {\n+    fn encode_info_for_items(&mut self) {\n         let krate = self.tcx.hir().krate();\n-        let mut index = IndexBuilder::new(self);\n         let vis = Spanned { span: syntax_pos::DUMMY_SP, node: hir::VisibilityKind::Public };\n-        index.record(DefId::local(CRATE_DEF_INDEX),\n-                     IsolatedEncoder::encode_info_for_mod,\n-                     FromId(hir::CRATE_HIR_ID, (&krate.module, &krate.attrs, &vis)));\n-        let mut visitor = EncodeVisitor { index };\n-        krate.visit_all_item_likes(&mut visitor.as_deep_visitor());\n+        self.record(DefId::local(CRATE_DEF_INDEX),\n+                     EncodeContext::encode_info_for_mod,\n+                     (hir::CRATE_HIR_ID, &krate.module, &krate.attrs, &vis));\n+        krate.visit_all_item_likes(&mut self.as_deep_visitor());\n         for macro_def in &krate.exported_macros {\n-            visitor.visit_macro_def(macro_def);\n+            self.visit_macro_def(macro_def);\n         }\n-        visitor.index.into_items()\n     }\n \n     fn encode_def_path_table(&mut self) -> Lazy<DefPathTable> {\n@@ -371,38 +377,30 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         self.lazy_seq_ref(adapted.iter().map(|rc| &**rc))\n     }\n \n-    fn encode_crate_root(&mut self) -> Lazy<CrateRoot> {\n+    fn encode_crate_root(&mut self) -> Lazy<CrateRoot<'tcx>> {\n         let mut i = self.position();\n \n-        let crate_deps = self.tracked(IsolatedEncoder::encode_crate_deps, ());\n-        let dylib_dependency_formats = self.tracked(\n-            IsolatedEncoder::encode_dylib_dependency_formats,\n-            ());\n+        let crate_deps = self.encode_crate_deps();\n+        let dylib_dependency_formats = self.encode_dylib_dependency_formats();\n         let dep_bytes = self.position() - i;\n \n         // Encode the lib features.\n         i = self.position();\n-        let lib_features = self.tracked(IsolatedEncoder::encode_lib_features, ());\n+        let lib_features = self.encode_lib_features();\n         let lib_feature_bytes = self.position() - i;\n \n         // Encode the language items.\n         i = self.position();\n-        let lang_items = self.tracked(IsolatedEncoder::encode_lang_items, ());\n-        let lang_items_missing = self.tracked(\n-            IsolatedEncoder::encode_lang_items_missing,\n-            ());\n+        let lang_items = self.encode_lang_items();\n+        let lang_items_missing = self.encode_lang_items_missing();\n         let lang_item_bytes = self.position() - i;\n \n         // Encode the native libraries used\n         i = self.position();\n-        let native_libraries = self.tracked(\n-            IsolatedEncoder::encode_native_libraries,\n-            ());\n+        let native_libraries = self.encode_native_libraries();\n         let native_lib_bytes = self.position() - i;\n \n-        let foreign_modules = self.tracked(\n-            IsolatedEncoder::encode_foreign_modules,\n-            ());\n+        let foreign_modules = self.encode_foreign_modules();\n \n         // Encode source_map\n         i = self.position();\n@@ -416,22 +414,20 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         // Encode the def IDs of impls, for coherence checking.\n         i = self.position();\n-        let impls = self.tracked(IsolatedEncoder::encode_impls, ());\n+        let impls = self.encode_impls();\n         let impl_bytes = self.position() - i;\n \n         // Encode exported symbols info.\n         i = self.position();\n         let exported_symbols = self.tcx.exported_symbols(LOCAL_CRATE);\n-        let exported_symbols = self.tracked(\n-            IsolatedEncoder::encode_exported_symbols,\n-            &exported_symbols);\n+        let exported_symbols = self.encode_exported_symbols(&exported_symbols);\n         let exported_symbols_bytes = self.position() - i;\n \n         let tcx = self.tcx;\n \n         // Encode the items.\n         i = self.position();\n-        let items = self.encode_info_for_items();\n+        self.encode_info_for_items();\n         let item_bytes = self.position() - i;\n \n         // Encode the allocation index\n@@ -462,10 +458,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             self.lazy_seq(interpret_alloc_index)\n         };\n \n-        // Index the items\n         i = self.position();\n-        let index = items.write_index(&mut self.opaque);\n-        let index_bytes = self.position() - i;\n+        let entries_index = self.entries_index.write_index(&mut self.opaque);\n+        let entries_index_bytes = self.position() - i;\n \n         let attrs = tcx.hir().krate_attrs();\n         let is_proc_macro = tcx.sess.crate_types.borrow().contains(&CrateType::ProcMacro);\n@@ -516,7 +511,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             impls,\n             exported_symbols,\n             interpret_alloc_index,\n-            index,\n+            entries_index,\n         });\n \n         let total_bytes = self.position();\n@@ -539,7 +534,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             println!(\"    exp. symbols bytes: {}\", exported_symbols_bytes);\n             println!(\"  def-path table bytes: {}\", def_path_table_bytes);\n             println!(\"            item bytes: {}\", item_bytes);\n-            println!(\"           index bytes: {}\", index_bytes);\n+            println!(\"   entries index bytes: {}\", entries_index_bytes);\n             println!(\"            zero bytes: {}\", zero_bytes);\n             println!(\"           total bytes: {}\", total_bytes);\n         }\n@@ -548,40 +543,29 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     }\n }\n \n-// These are methods for encoding various things. They are meant to be used with\n-// IndexBuilder::record() and EncodeContext::tracked(). They actually\n-// would not have to be methods of IsolatedEncoder (free standing functions\n-// taking IsolatedEncoder as first argument would be just fine) but by making\n-// them methods we don't have to repeat the lengthy `<'a, 'b: 'a, 'tcx: 'b>`\n-// clause again and again.\n-impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n+impl EncodeContext<'_, 'tcx> {\n     fn encode_variances_of(&mut self, def_id: DefId) -> LazySeq<ty::Variance> {\n-        debug!(\"IsolatedEncoder::encode_variances_of({:?})\", def_id);\n+        debug!(\"EncodeContext::encode_variances_of({:?})\", def_id);\n         let tcx = self.tcx;\n-        self.lazy_seq_from_slice(&tcx.variances_of(def_id))\n+        self.lazy_seq_ref(&tcx.variances_of(def_id)[..])\n     }\n \n     fn encode_item_type(&mut self, def_id: DefId) -> Lazy<Ty<'tcx>> {\n         let tcx = self.tcx;\n         let ty = tcx.type_of(def_id);\n-        debug!(\"IsolatedEncoder::encode_item_type({:?}) => {:?}\", def_id, ty);\n+        debug!(\"EncodeContext::encode_item_type({:?}) => {:?}\", def_id, ty);\n         self.lazy(&ty)\n     }\n \n-    /// Encode data for the given variant of the given ADT. The\n-    /// index of the variant is untracked: this is ok because we\n-    /// will have to lookup the adt-def by its id, and that gives us\n-    /// the right to access any information in the adt-def (including,\n-    /// e.g., the length of the various vectors).\n     fn encode_enum_variant_info(\n         &mut self,\n-        (enum_did, Untracked(index)): (DefId, Untracked<VariantIdx>),\n+        (enum_did, index): (DefId, VariantIdx),\n     ) -> Entry<'tcx> {\n         let tcx = self.tcx;\n         let def = tcx.adt_def(enum_did);\n         let variant = &def.variants[index];\n         let def_id = variant.def_id;\n-        debug!(\"IsolatedEncoder::encode_enum_variant_info({:?})\", def_id);\n+        debug!(\"EncodeContext::encode_enum_variant_info({:?})\", def_id);\n \n         let data = VariantData {\n             ctor_kind: variant.ctor_kind,\n@@ -625,17 +609,15 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n         }\n     }\n \n-    /// Encode the constructor for the given variant of the given ADT. See\n-    /// `encode_enum_variant_info` for an explanation about why the index is untracked.\n     fn encode_enum_variant_ctor(\n         &mut self,\n-        (enum_did, Untracked(index)): (DefId, Untracked<VariantIdx>),\n+        (enum_did, index): (DefId, VariantIdx),\n     ) -> Entry<'tcx> {\n         let tcx = self.tcx;\n         let def = tcx.adt_def(enum_did);\n         let variant = &def.variants[index];\n         let def_id = variant.ctor_def_id.unwrap();\n-        debug!(\"IsolatedEncoder::encode_enum_variant_ctor({:?})\", def_id);\n+        debug!(\"EncodeContext::encode_enum_variant_ctor({:?})\", def_id);\n \n         let data = VariantData {\n             ctor_kind: variant.ctor_kind,\n@@ -681,18 +663,17 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n         }\n     }\n \n-    fn encode_info_for_mod(&mut self,\n-                           FromId(id, (md, attrs, vis)): FromId<(&hir::Mod,\n-                                                                 &[ast::Attribute],\n-                                                                 &hir::Visibility)>)\n-                           -> Entry<'tcx> {\n+    fn encode_info_for_mod(\n+        &mut self,\n+        (id, md, attrs, vis): (hir::HirId, &hir::Mod, &[ast::Attribute], &hir::Visibility),\n+    ) -> Entry<'tcx> {\n         let tcx = self.tcx;\n         let def_id = tcx.hir().local_def_id_from_hir_id(id);\n-        debug!(\"IsolatedEncoder::encode_info_for_mod({:?})\", def_id);\n+        debug!(\"EncodeContext::encode_info_for_mod({:?})\", def_id);\n \n         let data = ModData {\n             reexports: match tcx.module_exports(def_id) {\n-                Some(ref exports) => self.lazy_seq_from_slice(exports.as_slice()),\n+                Some(ref exports) => self.lazy_seq_ref(&exports[..]),\n                 _ => LazySeq::empty(),\n             },\n         };\n@@ -719,23 +700,16 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n         }\n     }\n \n-    /// Encode data for the given field of the given variant of the\n-    /// given ADT. The indices of the variant/field are untracked:\n-    /// this is ok because we will have to lookup the adt-def by its\n-    /// id, and that gives us the right to access any information in\n-    /// the adt-def (including, e.g., the length of the various\n-    /// vectors).\n-    fn encode_field(&mut self,\n-                    (adt_def_id, Untracked((variant_index, field_index))): (DefId,\n-                                                                            Untracked<(VariantIdx,\n-                                                                                       usize)>))\n-                    -> Entry<'tcx> {\n+    fn encode_field(\n+        &mut self,\n+        (adt_def_id, variant_index, field_index): (DefId, VariantIdx, usize),\n+    ) -> Entry<'tcx> {\n         let tcx = self.tcx;\n         let variant = &tcx.adt_def(adt_def_id).variants[variant_index];\n         let field = &variant.fields[field_index];\n \n         let def_id = field.did;\n-        debug!(\"IsolatedEncoder::encode_field({:?})\", def_id);\n+        debug!(\"EncodeContext::encode_field({:?})\", def_id);\n \n         let variant_id = tcx.hir().as_local_hir_id(variant.def_id).unwrap();\n         let variant_data = tcx.hir().expect_variant_data(variant_id);\n@@ -761,7 +735,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n     }\n \n     fn encode_struct_ctor(&mut self, (adt_def_id, def_id): (DefId, DefId)) -> Entry<'tcx> {\n-        debug!(\"IsolatedEncoder::encode_struct_ctor({:?})\", def_id);\n+        debug!(\"EncodeContext::encode_struct_ctor({:?})\", def_id);\n         let tcx = self.tcx;\n         let adt_def = tcx.adt_def(adt_def_id);\n         let variant = adt_def.non_enum_variant();\n@@ -821,25 +795,25 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n     }\n \n     fn encode_generics(&mut self, def_id: DefId) -> Lazy<ty::Generics> {\n-        debug!(\"IsolatedEncoder::encode_generics({:?})\", def_id);\n+        debug!(\"EncodeContext::encode_generics({:?})\", def_id);\n         let tcx = self.tcx;\n         self.lazy(tcx.generics_of(def_id))\n     }\n \n     fn encode_predicates(&mut self, def_id: DefId) -> Lazy<ty::GenericPredicates<'tcx>> {\n-        debug!(\"IsolatedEncoder::encode_predicates({:?})\", def_id);\n+        debug!(\"EncodeContext::encode_predicates({:?})\", def_id);\n         let tcx = self.tcx;\n         self.lazy(&tcx.predicates_of(def_id))\n     }\n \n     fn encode_predicates_defined_on(&mut self, def_id: DefId) -> Lazy<ty::GenericPredicates<'tcx>> {\n-        debug!(\"IsolatedEncoder::encode_predicates_defined_on({:?})\", def_id);\n+        debug!(\"EncodeContext::encode_predicates_defined_on({:?})\", def_id);\n         let tcx = self.tcx;\n         self.lazy(&tcx.predicates_defined_on(def_id))\n     }\n \n     fn encode_info_for_trait_item(&mut self, def_id: DefId) -> Entry<'tcx> {\n-        debug!(\"IsolatedEncoder::encode_info_for_trait_item({:?})\", def_id);\n+        debug!(\"EncodeContext::encode_info_for_trait_item({:?})\", def_id);\n         let tcx = self.tcx;\n \n         let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n@@ -949,7 +923,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n     }\n \n     fn encode_info_for_impl_item(&mut self, def_id: DefId) -> Entry<'tcx> {\n-        debug!(\"IsolatedEncoder::encode_info_for_impl_item({:?})\", def_id);\n+        debug!(\"EncodeContext::encode_info_for_impl_item({:?})\", def_id);\n         let tcx = self.tcx;\n \n         let hir_id = self.tcx.hir().as_local_hir_id(def_id).unwrap();\n@@ -1064,7 +1038,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n \n     // Encodes the inherent implementations of a structure, enumeration, or trait.\n     fn encode_inherent_implementations(&mut self, def_id: DefId) -> LazySeq<DefIndex> {\n-        debug!(\"IsolatedEncoder::encode_inherent_implementations({:?})\", def_id);\n+        debug!(\"EncodeContext::encode_inherent_implementations({:?})\", def_id);\n         let implementations = self.tcx.inherent_impls(def_id);\n         if implementations.is_empty() {\n             LazySeq::empty()\n@@ -1077,12 +1051,12 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n     }\n \n     fn encode_stability(&mut self, def_id: DefId) -> Option<Lazy<attr::Stability>> {\n-        debug!(\"IsolatedEncoder::encode_stability({:?})\", def_id);\n+        debug!(\"EncodeContext::encode_stability({:?})\", def_id);\n         self.tcx.lookup_stability(def_id).map(|stab| self.lazy(stab))\n     }\n \n     fn encode_deprecation(&mut self, def_id: DefId) -> Option<Lazy<attr::Deprecation>> {\n-        debug!(\"IsolatedEncoder::encode_deprecation({:?})\", def_id);\n+        debug!(\"EncodeContext::encode_deprecation({:?})\", def_id);\n         self.tcx.lookup_deprecation(def_id).map(|depr| self.lazy(&depr))\n     }\n \n@@ -1096,7 +1070,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n     fn encode_info_for_item(&mut self, (def_id, item): (DefId, &'tcx hir::Item)) -> Entry<'tcx> {\n         let tcx = self.tcx;\n \n-        debug!(\"IsolatedEncoder::encode_info_for_item({:?})\", def_id);\n+        debug!(\"EncodeContext::encode_info_for_item({:?})\", def_id);\n \n         let kind = match item.node {\n             hir::ItemKind::Static(_, hir::MutMutable, _) => EntryKind::MutStatic,\n@@ -1118,7 +1092,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                 EntryKind::Fn(self.lazy(&data))\n             }\n             hir::ItemKind::Mod(ref m) => {\n-                return self.encode_info_for_mod(FromId(item.hir_id, (m, &item.attrs, &item.vis)));\n+                return self.encode_info_for_mod((item.hir_id, m, &item.attrs, &item.vis));\n             }\n             hir::ItemKind::ForeignMod(_) => EntryKind::ForeignMod,\n             hir::ItemKind::GlobalAsm(..) => EntryKind::GlobalAsm,\n@@ -1391,22 +1365,22 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n \n     fn encode_info_for_ty_param(\n         &mut self,\n-        (def_id, Untracked(encode_type)): (DefId, Untracked<bool>),\n+        (def_id, encode_type): (DefId, bool),\n     ) -> Entry<'tcx> {\n-        debug!(\"IsolatedEncoder::encode_info_for_ty_param({:?})\", def_id);\n+        debug!(\"EncodeContext::encode_info_for_ty_param({:?})\", def_id);\n         self.encode_info_for_generic_param(def_id, EntryKind::TypeParam, encode_type)\n     }\n \n     fn encode_info_for_const_param(\n         &mut self,\n         def_id: DefId,\n     ) -> Entry<'tcx> {\n-        debug!(\"IsolatedEncoder::encode_info_for_const_param({:?})\", def_id);\n+        debug!(\"EncodeContext::encode_info_for_const_param({:?})\", def_id);\n         self.encode_info_for_generic_param(def_id, EntryKind::ConstParam, true)\n     }\n \n     fn encode_info_for_closure(&mut self, def_id: DefId) -> Entry<'tcx> {\n-        debug!(\"IsolatedEncoder::encode_info_for_closure({:?})\", def_id);\n+        debug!(\"EncodeContext::encode_info_for_closure({:?})\", def_id);\n         let tcx = self.tcx;\n \n         let tables = self.tcx.typeck_tables_of(def_id);\n@@ -1450,7 +1424,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n     }\n \n     fn encode_info_for_anon_const(&mut self, def_id: DefId) -> Entry<'tcx> {\n-        debug!(\"IsolatedEncoder::encode_info_for_anon_const({:?})\", def_id);\n+        debug!(\"EncodeContext::encode_info_for_anon_const({:?})\", def_id);\n         let tcx = self.tcx;\n         let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n         let body_id = tcx.hir().body_owned_by(id);\n@@ -1478,23 +1452,20 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n     }\n \n     fn encode_attributes(&mut self, attrs: &[ast::Attribute]) -> LazySeq<ast::Attribute> {\n-        // NOTE: This must use lazy_seq_from_slice(), not lazy_seq() because\n-        //       we rely on the HashStable specialization for [Attribute]\n-        //       to properly filter things out.\n-        self.lazy_seq_from_slice(attrs)\n+        self.lazy_seq_ref(attrs)\n     }\n \n-    fn encode_native_libraries(&mut self, _: ()) -> LazySeq<NativeLibrary> {\n+    fn encode_native_libraries(&mut self) -> LazySeq<NativeLibrary> {\n         let used_libraries = self.tcx.native_libraries(LOCAL_CRATE);\n         self.lazy_seq(used_libraries.iter().cloned())\n     }\n \n-    fn encode_foreign_modules(&mut self, _: ()) -> LazySeq<ForeignModule> {\n+    fn encode_foreign_modules(&mut self) -> LazySeq<ForeignModule> {\n         let foreign_modules = self.tcx.foreign_modules(LOCAL_CRATE);\n         self.lazy_seq(foreign_modules.iter().cloned())\n     }\n \n-    fn encode_crate_deps(&mut self, _: ()) -> LazySeq<CrateDep> {\n+    fn encode_crate_deps(&mut self) -> LazySeq<CrateDep> {\n         let crates = self.tcx.crates();\n \n         let mut deps = crates\n@@ -1528,13 +1499,13 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n         self.lazy_seq_ref(deps.iter().map(|&(_, ref dep)| dep))\n     }\n \n-    fn encode_lib_features(&mut self, _: ()) -> LazySeq<(ast::Name, Option<ast::Name>)> {\n+    fn encode_lib_features(&mut self) -> LazySeq<(ast::Name, Option<ast::Name>)> {\n         let tcx = self.tcx;\n         let lib_features = tcx.lib_features();\n         self.lazy_seq(lib_features.to_vec())\n     }\n \n-    fn encode_lang_items(&mut self, _: ()) -> LazySeq<(DefIndex, usize)> {\n+    fn encode_lang_items(&mut self) -> LazySeq<(DefIndex, usize)> {\n         let tcx = self.tcx;\n         let lang_items = tcx.lang_items();\n         let lang_items = lang_items.items().iter();\n@@ -1548,14 +1519,14 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n         }))\n     }\n \n-    fn encode_lang_items_missing(&mut self, _: ()) -> LazySeq<lang_items::LangItem> {\n+    fn encode_lang_items_missing(&mut self) -> LazySeq<lang_items::LangItem> {\n         let tcx = self.tcx;\n         self.lazy_seq_ref(&tcx.lang_items().missing)\n     }\n \n     /// Encodes an index, mapping each trait to its (local) implementations.\n-    fn encode_impls(&mut self, _: ()) -> LazySeq<TraitImpls> {\n-        debug!(\"IsolatedEncoder::encode_impls()\");\n+    fn encode_impls(&mut self) -> LazySeq<TraitImpls> {\n+        debug!(\"EncodeContext::encode_impls()\");\n         let tcx = self.tcx;\n         let mut visitor = ImplVisitor {\n             tcx,\n@@ -1580,12 +1551,12 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n \n                 TraitImpls {\n                     trait_id: (trait_def_id.krate.as_u32(), trait_def_id.index),\n-                    impls: self.lazy_seq_from_slice(&impls[..]),\n+                    impls: self.lazy_seq_ref(&impls),\n                 }\n             })\n             .collect();\n \n-        self.lazy_seq_from_slice(&all_impls[..])\n+        self.lazy_seq_ref(&all_impls)\n     }\n \n     // Encodes all symbols exported from this crate into the metadata.\n@@ -1595,13 +1566,13 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n     // symbol associated with them (they weren't translated) or if they're an FFI\n     // definition (as that's not defined in this crate).\n     fn encode_exported_symbols(&mut self,\n-                               exported_symbols: &[(ExportedSymbol<'_>, SymbolExportLevel)])\n-                               -> EncodedExportedSymbols {\n+                               exported_symbols: &[(ExportedSymbol<'tcx>, SymbolExportLevel)])\n+                               -> LazySeq<(ExportedSymbol<'tcx>, SymbolExportLevel)> {\n         // The metadata symbol name is special. It should not show up in\n         // downstream crates.\n         let metadata_symbol_name = SymbolName::new(&metadata_symbol_name(self.tcx));\n \n-        let lazy_seq = self.lazy_seq(exported_symbols\n+        self.lazy_seq(exported_symbols\n             .iter()\n             .filter(|&&(ref exported_symbol, _)| {\n                 match *exported_symbol {\n@@ -1611,15 +1582,10 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                     _ => true,\n                 }\n             })\n-            .cloned());\n-\n-        EncodedExportedSymbols {\n-            len: lazy_seq.len,\n-            position: lazy_seq.position,\n-        }\n+            .cloned())\n     }\n \n-    fn encode_dylib_dependency_formats(&mut self, _: ()) -> LazySeq<Option<LinkagePreference>> {\n+    fn encode_dylib_dependency_formats(&mut self) -> LazySeq<Option<LinkagePreference>> {\n         match self.tcx.sess.dependency_formats.borrow().get(&config::CrateType::Dylib) {\n             Some(arr) => {\n                 self.lazy_seq(arr.iter().map(|slot| {\n@@ -1641,7 +1607,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                                     -> Entry<'tcx> {\n         let tcx = self.tcx;\n \n-        debug!(\"IsolatedEncoder::encode_info_for_foreign_item({:?})\", def_id);\n+        debug!(\"EncodeContext::encode_info_for_foreign_item({:?})\", def_id);\n \n         let kind = match nitem.node {\n             hir::ForeignItemKind::Fn(_, ref names, _) => {\n@@ -1681,33 +1647,29 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n     }\n }\n \n-struct EncodeVisitor<'a, 'b: 'a, 'tcx: 'b> {\n-    index: IndexBuilder<'a, 'b, 'tcx>,\n-}\n-\n-impl<'a, 'b, 'tcx> Visitor<'tcx> for EncodeVisitor<'a, 'b, 'tcx> {\n+impl Visitor<'tcx> for EncodeContext<'_, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.index.tcx.hir())\n+        NestedVisitorMap::OnlyBodies(&self.tcx.hir())\n     }\n     fn visit_expr(&mut self, ex: &'tcx hir::Expr) {\n         intravisit::walk_expr(self, ex);\n-        self.index.encode_info_for_expr(ex);\n+        self.encode_info_for_expr(ex);\n     }\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         intravisit::walk_item(self, item);\n-        let def_id = self.index.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n+        let def_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n         match item.node {\n             hir::ItemKind::ExternCrate(_) |\n-            hir::ItemKind::Use(..) => (), // ignore these\n-            _ => self.index.record(def_id, IsolatedEncoder::encode_info_for_item, (def_id, item)),\n+            hir::ItemKind::Use(..) => {} // ignore these\n+            _ => self.record(def_id, EncodeContext::encode_info_for_item, (def_id, item)),\n         }\n-        self.index.encode_addl_info_for_item(item);\n+        self.encode_addl_info_for_item(item);\n     }\n     fn visit_foreign_item(&mut self, ni: &'tcx hir::ForeignItem) {\n         intravisit::walk_foreign_item(self, ni);\n-        let def_id = self.index.tcx.hir().local_def_id_from_hir_id(ni.hir_id);\n-        self.index.record(def_id,\n-                          IsolatedEncoder::encode_info_for_foreign_item,\n+        let def_id = self.tcx.hir().local_def_id_from_hir_id(ni.hir_id);\n+        self.record(def_id,\n+                          EncodeContext::encode_info_for_foreign_item,\n                           (def_id, ni));\n     }\n     fn visit_variant(&mut self,\n@@ -1717,32 +1679,32 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for EncodeVisitor<'a, 'b, 'tcx> {\n         intravisit::walk_variant(self, v, g, id);\n \n         if let Some(ref discr) = v.node.disr_expr {\n-            let def_id = self.index.tcx.hir().local_def_id_from_hir_id(discr.hir_id);\n-            self.index.record(def_id, IsolatedEncoder::encode_info_for_anon_const, def_id);\n+            let def_id = self.tcx.hir().local_def_id_from_hir_id(discr.hir_id);\n+            self.record(def_id, EncodeContext::encode_info_for_anon_const, def_id);\n         }\n     }\n     fn visit_generics(&mut self, generics: &'tcx hir::Generics) {\n         intravisit::walk_generics(self, generics);\n-        self.index.encode_info_for_generics(generics);\n+        self.encode_info_for_generics(generics);\n     }\n     fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n         intravisit::walk_ty(self, ty);\n-        self.index.encode_info_for_ty(ty);\n+        self.encode_info_for_ty(ty);\n     }\n     fn visit_macro_def(&mut self, macro_def: &'tcx hir::MacroDef) {\n-        let def_id = self.index.tcx.hir().local_def_id_from_hir_id(macro_def.hir_id);\n-        self.index.record(def_id, IsolatedEncoder::encode_info_for_macro_def, macro_def);\n+        let def_id = self.tcx.hir().local_def_id_from_hir_id(macro_def.hir_id);\n+        self.record(def_id, EncodeContext::encode_info_for_macro_def, macro_def);\n     }\n }\n \n-impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n+impl EncodeContext<'_, 'tcx> {\n     fn encode_fields(&mut self, adt_def_id: DefId) {\n         let def = self.tcx.adt_def(adt_def_id);\n         for (variant_index, variant) in def.variants.iter_enumerated() {\n             for (field_index, field) in variant.fields.iter().enumerate() {\n                 self.record(field.did,\n-                            IsolatedEncoder::encode_field,\n-                            (adt_def_id, Untracked((variant_index, field_index))));\n+                            EncodeContext::encode_field,\n+                            (adt_def_id, variant_index, field_index));\n             }\n         }\n     }\n@@ -1755,12 +1717,12 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n                 GenericParamKind::Type { ref default, .. } => {\n                     self.record(\n                         def_id,\n-                        IsolatedEncoder::encode_info_for_ty_param,\n-                        (def_id, Untracked(default.is_some())),\n+                        EncodeContext::encode_info_for_ty_param,\n+                        (def_id, default.is_some()),\n                     );\n                 }\n                 GenericParamKind::Const { .. } => {\n-                    self.record(def_id, IsolatedEncoder::encode_info_for_const_param, def_id);\n+                    self.record(def_id, EncodeContext::encode_info_for_const_param, def_id);\n                 }\n             }\n         }\n@@ -1770,7 +1732,7 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n         match ty.node {\n             hir::TyKind::Array(_, ref length) => {\n                 let def_id = self.tcx.hir().local_def_id_from_hir_id(length.hir_id);\n-                self.record(def_id, IsolatedEncoder::encode_info_for_anon_const, def_id);\n+                self.record(def_id, EncodeContext::encode_info_for_anon_const, def_id);\n             }\n             _ => {}\n         }\n@@ -1780,7 +1742,7 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n         match expr.node {\n             hir::ExprKind::Closure(..) => {\n                 let def_id = self.tcx.hir().local_def_id_from_hir_id(expr.hir_id);\n-                self.record(def_id, IsolatedEncoder::encode_info_for_closure, def_id);\n+                self.record(def_id, EncodeContext::encode_info_for_closure, def_id);\n             }\n             _ => {}\n         }\n@@ -1812,13 +1774,13 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n                 let def = self.tcx.adt_def(def_id);\n                 for (i, variant) in def.variants.iter_enumerated() {\n                     self.record(variant.def_id,\n-                                IsolatedEncoder::encode_enum_variant_info,\n-                                (def_id, Untracked(i)));\n+                                EncodeContext::encode_enum_variant_info,\n+                                (def_id, i));\n \n                     if let Some(ctor_def_id) = variant.ctor_def_id {\n                         self.record(ctor_def_id,\n-                                    IsolatedEncoder::encode_enum_variant_ctor,\n-                                    (def_id, Untracked(i)));\n+                                    EncodeContext::encode_enum_variant_ctor,\n+                                    (def_id, i));\n                     }\n                 }\n             }\n@@ -1829,7 +1791,7 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n                 if let Some(ctor_hir_id) = struct_def.ctor_hir_id() {\n                     let ctor_def_id = self.tcx.hir().local_def_id_from_hir_id(ctor_hir_id);\n                     self.record(ctor_def_id,\n-                                IsolatedEncoder::encode_struct_ctor,\n+                                EncodeContext::encode_struct_ctor,\n                                 (def_id, ctor_def_id));\n                 }\n             }\n@@ -1839,14 +1801,14 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n             hir::ItemKind::Impl(..) => {\n                 for &trait_item_def_id in self.tcx.associated_item_def_ids(def_id).iter() {\n                     self.record(trait_item_def_id,\n-                                IsolatedEncoder::encode_info_for_impl_item,\n+                                EncodeContext::encode_info_for_impl_item,\n                                 trait_item_def_id);\n                 }\n             }\n             hir::ItemKind::Trait(..) => {\n                 for &item_def_id in self.tcx.associated_item_def_ids(def_id).iter() {\n                     self.record(item_def_id,\n-                                IsolatedEncoder::encode_info_for_trait_item,\n+                                EncodeContext::encode_info_for_trait_item,\n                                 item_def_id);\n                 }\n             }\n@@ -1911,10 +1873,13 @@ pub fn encode_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n     // Will be filled with the root position after encoding everything.\n     encoder.emit_raw_bytes(&[0, 0, 0, 0]);\n \n-    let (root, mut result) = {\n+    // Since encoding metadata is not in a query, and nothing is cached,\n+    // there's no need to do dep-graph tracking for any of it.\n+    let (root, mut result) = tcx.dep_graph.with_ignore(move || {\n         let mut ecx = EncodeContext {\n             opaque: encoder,\n             tcx,\n+            entries_index: Index::new(tcx.hir().definitions().def_index_count()),\n             lazy_state: LazyState::NoNode,\n             type_shorthands: Default::default(),\n             predicate_shorthands: Default::default(),\n@@ -1930,7 +1895,7 @@ pub fn encode_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n         // culminating in the `CrateRoot` which points to all of it.\n         let root = ecx.encode_crate_root();\n         (root, ecx.opaque.into_inner())\n-    };\n+    });\n \n     // Encode the root position.\n     let header = METADATA_HEADER.len();"}, {"sha": "dd2f59922ef9238ca34d6276dce219ab8fed9f03", "filename": "src/librustc_metadata/index.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d327e6e681d320d990f65951b7143f2f6a4139a7/src%2Flibrustc_metadata%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d327e6e681d320d990f65951b7143f2f6a4139a7/src%2Flibrustc_metadata%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex.rs?ref=d327e6e681d320d990f65951b7143f2f6a4139a7", "patch": "@@ -2,6 +2,7 @@ use crate::schema::*;\n \n use rustc::hir::def_id::{DefId, DefIndex};\n use rustc_serialize::opaque::Encoder;\n+use std::marker::PhantomData;\n use std::u32;\n use log::debug;\n \n@@ -74,23 +75,25 @@ impl FixedSizeEncoding for u32 {\n /// `u32::MAX`. Whenever an index is visited, we fill in the\n /// appropriate spot by calling `record_position`. We should never\n /// visit the same index twice.\n-pub struct Index {\n+pub struct Index<'tcx> {\n     positions: Vec<u8>,\n+    _marker: PhantomData<&'tcx ()>,\n }\n \n-impl Index {\n-    pub fn new(max_index: usize) -> Index {\n+impl Index<'tcx> {\n+    pub fn new(max_index: usize) -> Self {\n         Index {\n             positions: vec![0xff; max_index * 4],\n+            _marker: PhantomData,\n         }\n     }\n \n-    pub fn record(&mut self, def_id: DefId, entry: Lazy<Entry<'_>>) {\n+    pub fn record(&mut self, def_id: DefId, entry: Lazy<Entry<'tcx>>) {\n         assert!(def_id.is_local());\n         self.record_index(def_id.index, entry);\n     }\n \n-    pub fn record_index(&mut self, item: DefIndex, entry: Lazy<Entry<'_>>) {\n+    pub fn record_index(&mut self, item: DefIndex, entry: Lazy<Entry<'tcx>>) {\n         assert!(entry.position < (u32::MAX as usize));\n         let position = entry.position as u32;\n         let array_index = item.index();\n@@ -105,7 +108,7 @@ impl Index {\n         position.write_to_bytes_at(positions, array_index)\n     }\n \n-    pub fn write_index(&self, buf: &mut Encoder) -> LazySeq<Index> {\n+    pub fn write_index(&self, buf: &mut Encoder) -> LazySeq<Self> {\n         let pos = buf.position();\n \n         // First we write the length of the lower range ...\n@@ -116,7 +119,7 @@ impl Index {\n     }\n }\n \n-impl<'tcx> LazySeq<Index> {\n+impl LazySeq<Index<'tcx>> {\n     /// Given the metadata, extract out the offset of a particular\n     /// DefIndex (if any).\n     #[inline(never)]"}, {"sha": "e780693a5a92dda349899727efea5fc4424fa8bf", "filename": "src/librustc_metadata/index_builder.rs", "status": "removed", "additions": 0, "deletions": 224, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/21ba9310c129b29a83f5328440b406c2cd65f0e3/src%2Flibrustc_metadata%2Findex_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ba9310c129b29a83f5328440b406c2cd65f0e3/src%2Flibrustc_metadata%2Findex_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex_builder.rs?ref=21ba9310c129b29a83f5328440b406c2cd65f0e3", "patch": "@@ -1,224 +0,0 @@\n-//! Builder types for generating the \"item data\" section of the\n-//! metadata. This section winds up looking like this:\n-//!\n-//! ```\n-//! <common::data> // big list of item-like things...\n-//!    <common::data_item> // ...for most `DefId`s, there is an entry.\n-//!    </common::data_item>\n-//! </common::data>\n-//! ```\n-//!\n-//! As we generate this listing, we collect the offset of each\n-//! `data_item` entry and store it in an index. Then, when we load the\n-//! metadata, we can skip right to the metadata for a particular item.\n-//!\n-//! In addition to the offset, we need to track the data that was used\n-//! to generate the contents of each `data_item`. This is so that we\n-//! can figure out which HIR nodes contributed to that data for\n-//! incremental compilation purposes.\n-//!\n-//! The `IndexBuilder` facilitates both of these. It is created\n-//! with an `EncodingContext` (`ecx`), which it encapsulates.\n-//! It has one main method, `record()`. You invoke `record`\n-//! like so to create a new `data_item` element in the list:\n-//!\n-//! ```\n-//! index.record(some_def_id, callback_fn, data)\n-//! ```\n-//!\n-//! What record will do is to (a) record the current offset, (b) emit\n-//! the `common::data_item` tag, and then call `callback_fn` with the\n-//! given data as well as the `EncodingContext`. Once `callback_fn`\n-//! returns, the `common::data_item` tag will be closed.\n-//!\n-//! `EncodingContext` does not offer the `record` method, so that we\n-//! can ensure that `common::data_item` elements are never nested.\n-//!\n-//! In addition, while the `callback_fn` is executing, we will push a\n-//! task `MetaData(some_def_id)`, which can then observe the\n-//! reads/writes that occur in the task. For this reason, the `data`\n-//! argument that is given to the `callback_fn` must implement the\n-//! trait `DepGraphRead`, which indicates how to register reads on the\n-//! data in this new task (note that many types of data, such as\n-//! `DefId`, do not currently require any reads to be registered,\n-//! since they are not derived from a HIR node). This is also why we\n-//! give a callback fn, rather than taking a closure: it allows us to\n-//! easily control precisely what data is given to that fn.\n-\n-use crate::encoder::EncodeContext;\n-use crate::index::Index;\n-use crate::schema::*;\n-use crate::isolated_encoder::IsolatedEncoder;\n-\n-use rustc::hir;\n-use rustc::hir::def_id::DefId;\n-use rustc::ty::TyCtxt;\n-use syntax::ast;\n-\n-use std::ops::{Deref, DerefMut};\n-\n-/// Builder that can encode new items, adding them into the index.\n-/// Item encoding cannot be nested.\n-pub struct IndexBuilder<'a, 'b: 'a, 'tcx: 'b> {\n-    items: Index,\n-    pub ecx: &'a mut EncodeContext<'b, 'tcx>,\n-}\n-\n-impl<'a, 'b, 'tcx> Deref for IndexBuilder<'a, 'b, 'tcx> {\n-    type Target = EncodeContext<'b, 'tcx>;\n-    fn deref(&self) -> &Self::Target {\n-        self.ecx\n-    }\n-}\n-\n-impl<'a, 'b, 'tcx> DerefMut for IndexBuilder<'a, 'b, 'tcx> {\n-    fn deref_mut(&mut self) -> &mut Self::Target {\n-        self.ecx\n-    }\n-}\n-\n-impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n-    pub fn new(ecx: &'a mut EncodeContext<'b, 'tcx>) -> Self {\n-        IndexBuilder {\n-            items: Index::new(ecx.tcx.hir().definitions().def_index_count()),\n-            ecx,\n-        }\n-    }\n-\n-    /// Emit the data for a `DefId` to the metadata. The function to\n-    /// emit the data is `op`, and it will be given `data` as\n-    /// arguments. This `record` function will call `op` to generate\n-    /// the `Entry` (which may point to other encoded information)\n-    /// and will then record the `Lazy<Entry>` for use in the index.\n-    ///\n-    /// In addition, it will setup a dep-graph task to track what data\n-    /// `op` accesses to generate the metadata, which is later used by\n-    /// incremental compilation to compute a hash for the metadata and\n-    /// track changes.\n-    ///\n-    /// The reason that `op` is a function pointer, and not a closure,\n-    /// is that we want to be able to completely track all data it has\n-    /// access to, so that we can be sure that `DATA: DepGraphRead`\n-    /// holds, and that it is therefore not gaining \"secret\" access to\n-    /// bits of HIR or other state that would not be trackd by the\n-    /// content system.\n-    pub fn record<'x, DATA>(&'x mut self,\n-                            id: DefId,\n-                            op: fn(&mut IsolatedEncoder<'x, 'b, 'tcx>, DATA) -> Entry<'tcx>,\n-                            data: DATA)\n-        where DATA: DepGraphRead\n-    {\n-        assert!(id.is_local());\n-\n-        // We don't track this since we are explicitly computing the incr. comp.\n-        // hashes anyway. In theory we could do some tracking here and use it to\n-        // avoid rehashing things (and instead cache the hashes) but it's\n-        // unclear whether that would be a win since hashing is cheap enough.\n-        self.ecx.tcx.dep_graph.with_ignore(move || {\n-            let mut entry_builder = IsolatedEncoder::new(self.ecx);\n-            let entry = op(&mut entry_builder, data);\n-            let entry = entry_builder.lazy(&entry);\n-\n-            self.items.record(id, entry);\n-        })\n-    }\n-\n-    pub fn into_items(self) -> Index {\n-        self.items\n-    }\n-}\n-\n-/// Trait used for data that can be passed from outside a dep-graph\n-/// task. The data must either be of some safe type, such as a\n-/// `DefId` index, or implement the `read` method so that it can add\n-/// a read of whatever dep-graph nodes are appropriate.\n-pub trait DepGraphRead {\n-    fn read(&self, tcx: TyCtxt<'_, '_, '_>);\n-}\n-\n-impl DepGraphRead for DefId {\n-    fn read(&self, _tcx: TyCtxt<'_, '_, '_>) {}\n-}\n-\n-impl DepGraphRead for ast::NodeId {\n-    fn read(&self, _tcx: TyCtxt<'_, '_, '_>) {}\n-}\n-\n-impl<T> DepGraphRead for Option<T>\n-    where T: DepGraphRead\n-{\n-    fn read(&self, tcx: TyCtxt<'_, '_, '_>) {\n-        match *self {\n-            Some(ref v) => v.read(tcx),\n-            None => (),\n-        }\n-    }\n-}\n-\n-impl<T> DepGraphRead for [T]\n-    where T: DepGraphRead\n-{\n-    fn read(&self, tcx: TyCtxt<'_, '_, '_>) {\n-        for i in self {\n-            i.read(tcx);\n-        }\n-    }\n-}\n-\n-macro_rules! read_tuple {\n-    ($($name:ident),*) => {\n-        impl<$($name),*> DepGraphRead for ($($name),*)\n-            where $($name: DepGraphRead),*\n-        {\n-            #[allow(non_snake_case)]\n-            fn read(&self, tcx: TyCtxt<'_, '_, '_>) {\n-                let &($(ref $name),*) = self;\n-                $($name.read(tcx);)*\n-            }\n-        }\n-    }\n-}\n-read_tuple!(A, B);\n-read_tuple!(A, B, C);\n-\n-macro_rules! read_hir {\n-    ($t:ty) => {\n-        impl<'tcx> DepGraphRead for &'tcx $t {\n-            fn read(&self, tcx: TyCtxt<'_, '_, '_>) {\n-                tcx.hir().read(self.hir_id);\n-            }\n-        }\n-    }\n-}\n-read_hir!(hir::Item);\n-read_hir!(hir::ImplItem);\n-read_hir!(hir::TraitItem);\n-read_hir!(hir::ForeignItem);\n-read_hir!(hir::MacroDef);\n-\n-/// Leaks access to a value of type T without any tracking. This is\n-/// suitable for ambiguous types like `usize`, which *could* represent\n-/// tracked data (e.g., if you read it out of a HIR node) or might not\n-/// (e.g., if it's an index). Adding in an `Untracked` is an\n-/// assertion, essentially, that the data does not need to be tracked\n-/// (or that read edges will be added by some other way).\n-///\n-/// A good idea is to add to each use of `Untracked` an explanation of\n-/// why this value is ok.\n-pub struct Untracked<T>(pub T);\n-\n-impl<T> DepGraphRead for Untracked<T> {\n-    fn read(&self, _tcx: TyCtxt<'_, '_, '_>) {}\n-}\n-\n-/// Newtype that can be used to package up misc data extracted from a\n-/// HIR node that doesn't carry its own ID. This will allow an\n-/// arbitrary `T` to be passed in, but register a read on the given\n-/// `NodeId`.\n-pub struct FromId<T>(pub hir::HirId, pub T);\n-\n-impl<T> DepGraphRead for FromId<T> {\n-    fn read(&self, tcx: TyCtxt<'_, '_, '_>) {\n-        tcx.hir().read(self.0);\n-    }\n-}"}, {"sha": "e879a73e650bb026b0e9c902a703c4185a6f9544", "filename": "src/librustc_metadata/isolated_encoder.rs", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/21ba9310c129b29a83f5328440b406c2cd65f0e3/src%2Flibrustc_metadata%2Fisolated_encoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ba9310c129b29a83f5328440b406c2cd65f0e3/src%2Flibrustc_metadata%2Fisolated_encoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fisolated_encoder.rs?ref=21ba9310c129b29a83f5328440b406c2cd65f0e3", "patch": "@@ -1,48 +0,0 @@\n-use crate::encoder::EncodeContext;\n-use crate::schema::{Lazy, LazySeq};\n-use rustc::ty::TyCtxt;\n-use rustc_serialize::Encodable;\n-\n-/// The IsolatedEncoder provides facilities to write to crate metadata while\n-/// making sure that anything going through it is also feed into an ICH hasher.\n-pub struct IsolatedEncoder<'a, 'b: 'a, 'tcx: 'b> {\n-    pub tcx: TyCtxt<'b, 'tcx, 'tcx>,\n-    ecx: &'a mut EncodeContext<'b, 'tcx>,\n-}\n-\n-impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n-\n-    pub fn new(ecx: &'a mut EncodeContext<'b, 'tcx>) -> Self {\n-        let tcx = ecx.tcx;\n-        IsolatedEncoder {\n-            tcx,\n-            ecx,\n-        }\n-    }\n-\n-    pub fn lazy<T>(&mut self, value: &T) -> Lazy<T>\n-        where T: Encodable\n-    {\n-        self.ecx.lazy(value)\n-    }\n-\n-    pub fn lazy_seq<I, T>(&mut self, iter: I) -> LazySeq<T>\n-        where I: IntoIterator<Item = T>,\n-              T: Encodable\n-    {\n-        self.ecx.lazy_seq(iter)\n-    }\n-\n-    pub fn lazy_seq_ref<'x, I, T>(&mut self, iter: I) -> LazySeq<T>\n-        where I: IntoIterator<Item = &'x T>,\n-              T: 'x + Encodable\n-    {\n-        self.ecx.lazy_seq_ref(iter)\n-    }\n-\n-    pub fn lazy_seq_from_slice<T>(&mut self, slice: &[T]) -> LazySeq<T>\n-        where T: Encodable\n-    {\n-        self.ecx.lazy_seq_ref(slice.iter())\n-    }\n-}"}, {"sha": "e0b92341575cc98252776ec0609a6f175739f485", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d327e6e681d320d990f65951b7143f2f6a4139a7/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d327e6e681d320d990f65951b7143f2f6a4139a7/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=d327e6e681d320d990f65951b7143f2f6a4139a7", "patch": "@@ -2,6 +2,7 @@\n \n #![feature(box_patterns)]\n #![feature(drain_filter)]\n+#![feature(in_band_lifetimes)]\n #![feature(libc)]\n #![feature(nll)]\n #![feature(proc_macro_internals)]\n@@ -28,12 +29,10 @@ extern crate rustc_data_structures;\n \n mod error_codes;\n \n-mod index_builder;\n mod index;\n mod encoder;\n mod decoder;\n mod cstore_impl;\n-mod isolated_encoder;\n mod schema;\n mod native_libs;\n mod link_args;"}, {"sha": "0ad3251540716306a31594dde118597f6e190e42", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 5, "deletions": 204, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/d327e6e681d320d990f65951b7143f2f6a4139a7/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d327e6e681d320d990f65951b7143f2f6a4139a7/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=d327e6e681d320d990f65951b7143f2f6a4139a7", "patch": "@@ -2,8 +2,8 @@ use crate::index;\n \n use rustc::hir;\n use rustc::hir::def::{self, CtorKind};\n-use rustc::hir::def_id::{DefIndex, DefId, CrateNum};\n-use rustc::ich::StableHashingContext;\n+use rustc::hir::def_id::{DefIndex, DefId};\n+use rustc::middle::exported_symbols::{ExportedSymbol, SymbolExportLevel};\n use rustc::middle::cstore::{DepKind, LinkagePreference, NativeLibrary, ForeignModule};\n use rustc::middle::lang_items;\n use rustc::mir;\n@@ -19,10 +19,6 @@ use syntax::symbol::Symbol;\n use syntax_pos::{self, Span};\n \n use std::marker::PhantomData;\n-use std::mem;\n-\n-use rustc_data_structures::stable_hasher::{StableHasher, HashStable,\n-                                           StableHasherResult};\n \n pub fn rustc_version() -> String {\n     format!(\"rustc {}\",\n@@ -91,15 +87,6 @@ impl<T> Clone for Lazy<T> {\n impl<T> serialize::UseSpecializedEncodable for Lazy<T> {}\n impl<T> serialize::UseSpecializedDecodable for Lazy<T> {}\n \n-impl<CTX, T> HashStable<CTX> for Lazy<T> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          _: &mut CTX,\n-                                          _: &mut StableHasher<W>) {\n-        // There's nothing to do. Whatever got encoded within this Lazy<>\n-        // wrapper has already been hashed.\n-    }\n-}\n-\n /// A sequence of type T referred to by its absolute position\n /// in the metadata and length, and which can be decoded lazily.\n /// The sequence is a single node for the purposes of `Lazy`.\n@@ -148,15 +135,6 @@ impl<T> Clone for LazySeq<T> {\n impl<T> serialize::UseSpecializedEncodable for LazySeq<T> {}\n impl<T> serialize::UseSpecializedDecodable for LazySeq<T> {}\n \n-impl<CTX, T> HashStable<CTX> for LazySeq<T> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          _: &mut CTX,\n-                                          _: &mut StableHasher<W>) {\n-        // There's nothing to do. Whatever got encoded within this Lazy<>\n-        // wrapper has already been hashed.\n-    }\n-}\n-\n /// Encoding / decoding state for `Lazy` and `LazySeq`.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum LazyState {\n@@ -174,7 +152,7 @@ pub enum LazyState {\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct CrateRoot {\n+pub struct CrateRoot<'tcx> {\n     pub name: Symbol,\n     pub triple: TargetTriple,\n     pub extra_filename: String,\n@@ -199,10 +177,10 @@ pub struct CrateRoot {\n     pub source_map: LazySeq<syntax_pos::SourceFile>,\n     pub def_path_table: Lazy<hir::map::definitions::DefPathTable>,\n     pub impls: LazySeq<TraitImpls>,\n-    pub exported_symbols: EncodedExportedSymbols,\n+    pub exported_symbols: LazySeq<(ExportedSymbol<'tcx>, SymbolExportLevel)>,\n     pub interpret_alloc_index: LazySeq<u32>,\n \n-    pub index: LazySeq<index::Index>,\n+    pub entries_index: LazySeq<index::Index<'tcx>>,\n \n     pub compiler_builtins: bool,\n     pub needs_allocator: bool,\n@@ -221,36 +199,12 @@ pub struct CrateDep {\n     pub extra_filename: String,\n }\n \n-impl_stable_hash_for!(struct CrateDep {\n-    name,\n-    hash,\n-    kind,\n-    extra_filename\n-});\n-\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct TraitImpls {\n     pub trait_id: (u32, DefIndex),\n     pub impls: LazySeq<DefIndex>,\n }\n \n-impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for TraitImpls {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let TraitImpls {\n-            trait_id: (krate, def_index),\n-            ref impls,\n-        } = *self;\n-\n-        DefId {\n-            krate: CrateNum::from_u32(krate),\n-            index: def_index\n-        }.hash_stable(hcx, hasher);\n-        impls.hash_stable(hcx, hasher);\n-    }\n-}\n-\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct Entry<'tcx> {\n     pub kind: EntryKind<'tcx>,\n@@ -271,23 +225,6 @@ pub struct Entry<'tcx> {\n     pub mir: Option<Lazy<mir::Mir<'tcx>>>,\n }\n \n-impl_stable_hash_for!(struct Entry<'tcx> {\n-    kind,\n-    visibility,\n-    span,\n-    attributes,\n-    children,\n-    stability,\n-    deprecation,\n-    ty,\n-    inherent_impls,\n-    variances,\n-    generics,\n-    predicates,\n-    predicates_defined_on,\n-    mir\n-});\n-\n #[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n pub enum EntryKind<'tcx> {\n     Const(ConstQualif, Lazy<RenderedConst>),\n@@ -322,129 +259,36 @@ pub enum EntryKind<'tcx> {\n     TraitAlias(Lazy<TraitAliasData<'tcx>>),\n }\n \n-impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for EntryKind<'gcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match *self {\n-            EntryKind::ImmStatic        |\n-            EntryKind::MutStatic        |\n-            EntryKind::ForeignImmStatic |\n-            EntryKind::ForeignMutStatic |\n-            EntryKind::ForeignMod       |\n-            EntryKind::GlobalAsm        |\n-            EntryKind::ForeignType      |\n-            EntryKind::Field |\n-            EntryKind::Existential |\n-            EntryKind::Type |\n-            EntryKind::TypeParam |\n-            EntryKind::ConstParam => {\n-                // Nothing else to hash here.\n-            }\n-            EntryKind::Const(qualif, ref const_data) => {\n-                qualif.hash_stable(hcx, hasher);\n-                const_data.hash_stable(hcx, hasher);\n-            }\n-            EntryKind::Enum(ref repr_options) => {\n-                repr_options.hash_stable(hcx, hasher);\n-            }\n-            EntryKind::Variant(ref variant_data) => {\n-                variant_data.hash_stable(hcx, hasher);\n-            }\n-            EntryKind::Struct(ref variant_data, ref repr_options) |\n-            EntryKind::Union(ref variant_data, ref repr_options)  => {\n-                variant_data.hash_stable(hcx, hasher);\n-                repr_options.hash_stable(hcx, hasher);\n-            }\n-            EntryKind::Fn(ref fn_data) |\n-            EntryKind::ForeignFn(ref fn_data) => {\n-                fn_data.hash_stable(hcx, hasher);\n-            }\n-            EntryKind::Mod(ref mod_data) => {\n-                mod_data.hash_stable(hcx, hasher);\n-            }\n-            EntryKind::MacroDef(ref macro_def) => {\n-                macro_def.hash_stable(hcx, hasher);\n-            }\n-            EntryKind::Generator(data) => {\n-                data.hash_stable(hcx, hasher);\n-            }\n-            EntryKind::Closure(closure_data) => {\n-                closure_data.hash_stable(hcx, hasher);\n-            }\n-            EntryKind::Trait(ref trait_data) => {\n-                trait_data.hash_stable(hcx, hasher);\n-            }\n-            EntryKind::TraitAlias(ref trait_alias_data) => {\n-                trait_alias_data.hash_stable(hcx, hasher);\n-            }\n-            EntryKind::Impl(ref impl_data) => {\n-                impl_data.hash_stable(hcx, hasher);\n-            }\n-            EntryKind::Method(ref method_data) => {\n-                method_data.hash_stable(hcx, hasher);\n-            }\n-            EntryKind::AssociatedExistential(associated_container) |\n-            EntryKind::AssociatedType(associated_container) => {\n-                associated_container.hash_stable(hcx, hasher);\n-            }\n-            EntryKind::AssociatedConst(associated_container, qualif, ref const_data) => {\n-                associated_container.hash_stable(hcx, hasher);\n-                qualif.hash_stable(hcx, hasher);\n-                const_data.hash_stable(hcx, hasher);\n-            }\n-        }\n-    }\n-}\n-\n /// Additional data for EntryKind::Const and EntryKind::AssociatedConst\n #[derive(Clone, Copy, RustcEncodable, RustcDecodable)]\n pub struct ConstQualif {\n     pub mir: u8,\n     pub ast_promotable: bool,\n }\n \n-impl_stable_hash_for!(struct ConstQualif { mir, ast_promotable });\n-\n /// Contains a constant which has been rendered to a String.\n /// Used by rustdoc.\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct RenderedConst(pub String);\n \n-impl<'a> HashStable<StableHashingContext<'a>> for RenderedConst {\n-    #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        self.0.hash_stable(hcx, hasher);\n-    }\n-}\n-\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct ModData {\n     pub reexports: LazySeq<def::Export<hir::HirId>>,\n }\n \n-impl_stable_hash_for!(struct ModData { reexports });\n-\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct MacroDef {\n     pub body: String,\n     pub legacy: bool,\n }\n \n-impl_stable_hash_for!(struct MacroDef { body, legacy });\n-\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct FnData<'tcx> {\n     pub constness: hir::Constness,\n     pub arg_names: LazySeq<ast::Name>,\n     pub sig: Lazy<ty::PolyFnSig<'tcx>>,\n }\n \n-impl_stable_hash_for!(struct FnData<'tcx> { constness, arg_names, sig });\n-\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct VariantData<'tcx> {\n     pub ctor_kind: CtorKind,\n@@ -456,13 +300,6 @@ pub struct VariantData<'tcx> {\n     pub ctor_sig: Option<Lazy<ty::PolyFnSig<'tcx>>>,\n }\n \n-impl_stable_hash_for!(struct VariantData<'tcx> {\n-    ctor_kind,\n-    discr,\n-    ctor,\n-    ctor_sig\n-});\n-\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct TraitData<'tcx> {\n     pub unsafety: hir::Unsafety,\n@@ -472,23 +309,11 @@ pub struct TraitData<'tcx> {\n     pub super_predicates: Lazy<ty::GenericPredicates<'tcx>>,\n }\n \n-impl_stable_hash_for!(struct TraitData<'tcx> {\n-    unsafety,\n-    paren_sugar,\n-    has_auto_impl,\n-    is_marker,\n-    super_predicates\n-});\n-\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct TraitAliasData<'tcx> {\n     pub super_predicates: Lazy<ty::GenericPredicates<'tcx>>,\n }\n \n-impl_stable_hash_for!(struct TraitAliasData<'tcx> {\n-    super_predicates\n-});\n-\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct ImplData<'tcx> {\n     pub polarity: hir::ImplPolarity,\n@@ -500,14 +325,6 @@ pub struct ImplData<'tcx> {\n     pub trait_ref: Option<Lazy<ty::TraitRef<'tcx>>>,\n }\n \n-impl_stable_hash_for!(struct ImplData<'tcx> {\n-    polarity,\n-    defaultness,\n-    parent_impl,\n-    coerce_unsized_info,\n-    trait_ref\n-});\n-\n \n /// Describes whether the container of an associated item\n /// is a trait or an impl and whether, in a trait, it has\n@@ -520,13 +337,6 @@ pub enum AssociatedContainer {\n     ImplFinal,\n }\n \n-impl_stable_hash_for!(enum crate::schema::AssociatedContainer {\n-    TraitRequired,\n-    TraitWithDefault,\n-    ImplDefault,\n-    ImplFinal\n-});\n-\n impl AssociatedContainer {\n     pub fn with_def_id(&self, def_id: DefId) -> ty::AssociatedItemContainer {\n         match *self {\n@@ -560,26 +370,17 @@ pub struct MethodData<'tcx> {\n     pub container: AssociatedContainer,\n     pub has_self: bool,\n }\n-impl_stable_hash_for!(struct MethodData<'tcx> { fn_data, container, has_self });\n \n #[derive(RustcEncodable, RustcDecodable)]\n pub struct ClosureData<'tcx> {\n     pub sig: Lazy<ty::PolyFnSig<'tcx>>,\n }\n-impl_stable_hash_for!(struct ClosureData<'tcx> { sig });\n \n #[derive(RustcEncodable, RustcDecodable)]\n pub struct GeneratorData<'tcx> {\n     pub layout: mir::GeneratorLayout<'tcx>,\n }\n-impl_stable_hash_for!(struct GeneratorData<'tcx> { layout });\n \n // Tags used for encoding Spans:\n pub const TAG_VALID_SPAN: u8 = 0;\n pub const TAG_INVALID_SPAN: u8 = 1;\n-\n-#[derive(RustcEncodable, RustcDecodable)]\n-pub struct EncodedExportedSymbols {\n-    pub position: usize,\n-    pub len: usize,\n-}"}]}