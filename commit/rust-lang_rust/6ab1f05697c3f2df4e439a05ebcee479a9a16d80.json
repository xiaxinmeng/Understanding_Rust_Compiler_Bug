{"sha": "6ab1f05697c3f2df4e439a05ebcee479a9a16d80", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhYjFmMDU2OTdjM2YyZGY0ZTQzOWEwNWViY2VlNDc5YTlhMTZkODA=", "commit": {"author": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-09-08T04:07:40Z"}, "committer": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-11-29T18:40:08Z"}, "message": "Fix intra-doc links for `Self` on primitives\n\n- Remove the difference between `parent_item` and `current_item`; these\n  should never have been different.\n- Remove `current_item` from `resolve` and `variant_field` so that\n  `Self` is only substituted in one place at the very start.\n- Resolve the current item as a `DefId`, not a `HirId`. This is what\n  actually fixed the bug.\n\nHacks:\n- `clean` uses `TypedefItem` when it _really_ should be\n  `AssociatedTypeItem`. I tried fixing this without success and hacked\n  around it instead (see comments)\n- This stringifies DefIds, then resolves them a second time. This is\n  really silly and rustdoc should just use DefIds throughout. Fixing\n  this is a larger task than I want to take on right now.", "tree": {"sha": "8984ae64a2a5a81da8a7d102a43b4b933abfe4cc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8984ae64a2a5a81da8a7d102a43b4b933abfe4cc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ab1f05697c3f2df4e439a05ebcee479a9a16d80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ab1f05697c3f2df4e439a05ebcee479a9a16d80", "html_url": "https://github.com/rust-lang/rust/commit/6ab1f05697c3f2df4e439a05ebcee479a9a16d80", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ab1f05697c3f2df4e439a05ebcee479a9a16d80/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e37f25aa3f356546ab851e394d5598fc575eabda", "url": "https://api.github.com/repos/rust-lang/rust/commits/e37f25aa3f356546ab851e394d5598fc575eabda", "html_url": "https://github.com/rust-lang/rust/commit/e37f25aa3f356546ab851e394d5598fc575eabda"}], "stats": {"total": 221, "additions": 98, "deletions": 123}, "files": [{"sha": "c1fbf6d9f5884bff7c8bba65bc01daa17fa59b0d", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 62, "deletions": 123, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/6ab1f05697c3f2df4e439a05ebcee479a9a16d80/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ab1f05697c3f2df4e439a05ebcee479a9a16d80/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=6ab1f05697c3f2df4e439a05ebcee479a9a16d80", "patch": "@@ -31,7 +31,7 @@ use std::cell::Cell;\n use std::mem;\n use std::ops::Range;\n \n-use crate::clean::{self, Crate, GetDefId, Import, Item, ItemLink, PrimitiveType};\n+use crate::clean::{self, Crate, GetDefId, Item, ItemLink, PrimitiveType};\n use crate::core::DocContext;\n use crate::fold::DocFolder;\n use crate::html::markdown::markdown_links;\n@@ -195,7 +195,6 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n     fn variant_field(\n         &self,\n         path_str: &'path str,\n-        current_item: &Option<String>,\n         module_id: DefId,\n     ) -> Result<(Res, Option<String>), ErrorKind<'path>> {\n         let cx = self.cx;\n@@ -218,14 +217,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             split.next().map(|f| (f, Symbol::intern(f))).ok_or_else(no_res)?;\n         let path = split\n             .next()\n-            .map(|f| {\n-                if f == \"self\" || f == \"Self\" {\n-                    if let Some(name) = current_item.as_ref() {\n-                        return name.clone();\n-                    }\n-                }\n-                f.to_owned()\n-            })\n+            .map(|f| f.to_owned())\n             // If there's no third component, we saw `[a::b]` before and it failed to resolve.\n             // So there's no partial res.\n             .ok_or_else(no_res)?;\n@@ -405,8 +397,6 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         &self,\n         path_str: &'path str,\n         ns: Namespace,\n-        // FIXME(#76467): This is for `Self`, and it's wrong.\n-        current_item: &Option<String>,\n         module_id: DefId,\n         extra_fragment: &Option<String>,\n     ) -> Result<(Res, Option<String>), ErrorKind<'path>> {\n@@ -449,14 +439,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         let (item_str, item_name) = split.next().map(|i| (i, Symbol::intern(i))).unwrap();\n         let path_root = split\n             .next()\n-            .map(|f| {\n-                if f == \"self\" || f == \"Self\" {\n-                    if let Some(name) = current_item.as_ref() {\n-                        return name.clone();\n-                    }\n-                }\n-                f.to_owned()\n-            })\n+            .map(|f| f.to_owned())\n             // If there's no `::`, it's not an associated item.\n             // So we can be sure that `rustc_resolve` was accurate when it said it wasn't resolved.\n             .ok_or_else(|| {\n@@ -477,7 +460,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         } else {\n             // FIXME: this is duplicated on the end of this function.\n             return if ns == Namespace::ValueNS {\n-                self.variant_field(path_str, current_item, module_id)\n+                self.variant_field(path_str, module_id)\n             } else {\n                 Err(ResolutionFailure::NotResolved {\n                     module_id,\n@@ -617,7 +600,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         };\n         res.unwrap_or_else(|| {\n             if ns == Namespace::ValueNS {\n-                self.variant_field(path_str, current_item, module_id)\n+                self.variant_field(path_str, module_id)\n             } else {\n                 Err(ResolutionFailure::NotResolved {\n                     module_id,\n@@ -640,15 +623,14 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         ns: Namespace,\n         path_str: &str,\n         module_id: DefId,\n-        current_item: &Option<String>,\n         extra_fragment: &Option<String>,\n     ) -> Option<Res> {\n         // resolve() can't be used for macro namespace\n         let result = match ns {\n             Namespace::MacroNS => self.resolve_macro(path_str, module_id).map_err(ErrorKind::from),\n-            Namespace::TypeNS | Namespace::ValueNS => self\n-                .resolve(path_str, ns, current_item, module_id, extra_fragment)\n-                .map(|(res, _)| res),\n+            Namespace::TypeNS | Namespace::ValueNS => {\n+                self.resolve(path_str, ns, module_id, extra_fragment).map(|(res, _)| res)\n+            }\n         };\n \n         let res = match result {\n@@ -839,77 +821,55 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n             trace!(\"got parent node for {:?} {:?}, id {:?}\", item.type_(), item.name, item.def_id);\n         }\n \n-        let current_item = match item.kind {\n-            clean::ModuleItem(..) => {\n-                if item.attrs.inner_docs {\n-                    if item.def_id.is_top_level_module() { item.name.clone() } else { None }\n-                } else {\n-                    match parent_node.or(self.mod_ids.last().copied()) {\n-                        Some(parent) if !parent.is_top_level_module() => {\n-                            Some(self.cx.tcx.item_name(parent).to_string())\n-                        }\n-                        _ => None,\n-                    }\n-                }\n-            }\n-            clean::ImplItem(clean::Impl { ref for_, .. }) => {\n-                for_.def_id().map(|did| self.cx.tcx.item_name(did).to_string())\n-            }\n-            // we don't display docs on `extern crate` items anyway, so don't process them.\n-            clean::ExternCrateItem(..) => {\n-                debug!(\"ignoring extern crate item {:?}\", item.def_id);\n-                return Some(self.fold_item_recur(item));\n-            }\n-            clean::ImportItem(Import { kind: clean::ImportKind::Simple(ref name, ..), .. }) => {\n-                Some(name.clone())\n-            }\n-            clean::MacroItem(..) => None,\n-            _ => item.name.clone(),\n+        // find item's parent to resolve `Self` in item's docs below\n+        debug!(\"looking for the `Self` type\");\n+        let self_id = if item.is_fake() {\n+            None\n+        } else if matches!(\n+            self.cx.tcx.def_kind(item.def_id),\n+            DefKind::AssocConst\n+                | DefKind::AssocFn\n+                | DefKind::AssocTy\n+                | DefKind::Variant\n+                | DefKind::Field\n+        ) {\n+            self.cx.tcx.parent(item.def_id)\n+        // HACK(jynelson): `clean` marks associated types as `TypedefItem`, not as `AssocTypeItem`.\n+        // Fixing this breaks `fn render_deref_methods`.\n+        // As a workaround, see if the parent of the item is an `impl`; if so this must be an associated item,\n+        // regardless of what rustdoc wants to call it.\n+        } else if let Some(parent) = self.cx.tcx.parent(item.def_id) {\n+            let parent_kind = self.cx.tcx.def_kind(parent);\n+            Some(if parent_kind == DefKind::Impl { parent } else { item.def_id })\n+        } else {\n+            Some(item.def_id)\n         };\n \n+        // FIXME(jynelson): this shouldn't go through stringification, rustdoc should just use the DefId directly\n+        let self_name = self_id.and_then(|self_id| {\n+            use ty::TyKind;\n+            if matches!(self.cx.tcx.def_kind(self_id), DefKind::Impl) {\n+                // using `ty.to_string()` directly has issues with shortening paths\n+                // FIXME: this is a hack, isn't there a better way?\n+                let ty = self.cx.tcx.type_of(self_id);\n+                let name = match ty.kind() {\n+                    TyKind::Adt(def, _) => Some(self.cx.tcx.item_name(def.did).to_string()),\n+                    other if other.is_primitive() => Some(ty.to_string()),\n+                    _ => None,\n+                };\n+                debug!(\"using type_of(): {:?}\", name);\n+                name\n+            } else {\n+                let name = self.cx.tcx.opt_item_name(self_id).map(|sym| sym.to_string());\n+                debug!(\"using item_name(): {:?}\", name);\n+                name\n+            }\n+        });\n+\n         if item.is_mod() && item.attrs.inner_docs {\n             self.mod_ids.push(item.def_id);\n         }\n \n-        // find item's parent to resolve `Self` in item's docs below\n-        // FIXME(#76467, #75809): this is a mess and doesn't handle cross-crate\n-        // re-exports\n-        let parent_name = self.cx.as_local_hir_id(item.def_id).and_then(|item_hir| {\n-            let parent_hir = self.cx.tcx.hir().get_parent_item(item_hir);\n-            let item_parent = self.cx.tcx.hir().find(parent_hir);\n-            match item_parent {\n-                Some(hir::Node::Item(hir::Item {\n-                    kind:\n-                        hir::ItemKind::Impl {\n-                            self_ty:\n-                                hir::Ty {\n-                                    kind:\n-                                        hir::TyKind::Path(hir::QPath::Resolved(\n-                                            _,\n-                                            hir::Path { segments, .. },\n-                                        )),\n-                                    ..\n-                                },\n-                            ..\n-                        },\n-                    ..\n-                })) => segments.first().map(|seg| seg.ident.to_string()),\n-                Some(hir::Node::Item(hir::Item {\n-                    ident, kind: hir::ItemKind::Enum(..), ..\n-                }))\n-                | Some(hir::Node::Item(hir::Item {\n-                    ident, kind: hir::ItemKind::Struct(..), ..\n-                }))\n-                | Some(hir::Node::Item(hir::Item {\n-                    ident, kind: hir::ItemKind::Union(..), ..\n-                }))\n-                | Some(hir::Node::Item(hir::Item {\n-                    ident, kind: hir::ItemKind::Trait(..), ..\n-                })) => Some(ident.to_string()),\n-                _ => None,\n-            }\n-        });\n-\n         // We want to resolve in the lexical scope of the documentation.\n         // In the presence of re-exports, this is not the same as the module of the item.\n         // Rather than merging all documentation into one, resolve it one attribute at a time\n@@ -945,9 +905,8 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                 let link = self.resolve_link(\n                     &item,\n                     &combined_docs,\n-                    &current_item,\n+                    &self_name,\n                     parent_node,\n-                    &parent_name,\n                     krate,\n                     ori_link,\n                     link_range,\n@@ -980,9 +939,8 @@ impl LinkCollector<'_, '_> {\n         &self,\n         item: &Item,\n         dox: &str,\n-        current_item: &Option<String>,\n+        self_name: &Option<String>,\n         parent_node: Option<DefId>,\n-        parent_name: &Option<String>,\n         krate: CrateNum,\n         ori_link: String,\n         link_range: Option<Range<usize>>,\n@@ -1069,7 +1027,7 @@ impl LinkCollector<'_, '_> {\n         let resolved_self;\n         // replace `Self` with suitable item's parent name\n         if path_str.starts_with(\"Self::\") {\n-            if let Some(ref name) = parent_name {\n+            if let Some(ref name) = self_name {\n                 resolved_self = format!(\"{}::{}\", name, &path_str[6..]);\n                 path_str = &resolved_self;\n             }\n@@ -1122,7 +1080,6 @@ impl LinkCollector<'_, '_> {\n             item,\n             dox,\n             path_str,\n-            current_item,\n             module_id,\n             extra_fragment,\n             &ori_link,\n@@ -1243,15 +1200,14 @@ impl LinkCollector<'_, '_> {\n         item: &Item,\n         dox: &str,\n         path_str: &str,\n-        current_item: &Option<String>,\n         base_node: DefId,\n         extra_fragment: Option<String>,\n         ori_link: &str,\n         link_range: Option<Range<usize>>,\n     ) -> Option<(Res, Option<String>)> {\n         match disambiguator.map(Disambiguator::ns) {\n             Some(ns @ (ValueNS | TypeNS)) => {\n-                match self.resolve(path_str, ns, &current_item, base_node, &extra_fragment) {\n+                match self.resolve(path_str, ns, base_node, &extra_fragment) {\n                     Ok(res) => Some(res),\n                     Err(ErrorKind::Resolve(box mut kind)) => {\n                         // We only looked in one namespace. Try to give a better error if possible.\n@@ -1264,7 +1220,6 @@ impl LinkCollector<'_, '_> {\n                                     new_ns,\n                                     path_str,\n                                     base_node,\n-                                    &current_item,\n                                     &extra_fragment,\n                                 ) {\n                                     kind = ResolutionFailure::WrongNamespace(res, ns);\n@@ -1298,13 +1253,7 @@ impl LinkCollector<'_, '_> {\n                     macro_ns: self\n                         .resolve_macro(path_str, base_node)\n                         .map(|res| (res, extra_fragment.clone())),\n-                    type_ns: match self.resolve(\n-                        path_str,\n-                        TypeNS,\n-                        &current_item,\n-                        base_node,\n-                        &extra_fragment,\n-                    ) {\n+                    type_ns: match self.resolve(path_str, TypeNS, base_node, &extra_fragment) {\n                         Ok(res) => {\n                             debug!(\"got res in TypeNS: {:?}\", res);\n                             Ok(res)\n@@ -1315,13 +1264,7 @@ impl LinkCollector<'_, '_> {\n                         }\n                         Err(ErrorKind::Resolve(box kind)) => Err(kind),\n                     },\n-                    value_ns: match self.resolve(\n-                        path_str,\n-                        ValueNS,\n-                        &current_item,\n-                        base_node,\n-                        &extra_fragment,\n-                    ) {\n+                    value_ns: match self.resolve(path_str, ValueNS, base_node, &extra_fragment) {\n                         Ok(res) => Ok(res),\n                         Err(ErrorKind::AnchorFailure(msg)) => {\n                             anchor_failure(self.cx, &item, ori_link, dox, link_range, msg);\n@@ -1389,13 +1332,9 @@ impl LinkCollector<'_, '_> {\n                     Err(mut kind) => {\n                         // `resolve_macro` only looks in the macro namespace. Try to give a better error if possible.\n                         for &ns in &[TypeNS, ValueNS] {\n-                            if let Some(res) = self.check_full_res(\n-                                ns,\n-                                path_str,\n-                                base_node,\n-                                &current_item,\n-                                &extra_fragment,\n-                            ) {\n+                            if let Some(res) =\n+                                self.check_full_res(ns, path_str, base_node, &extra_fragment)\n+                            {\n                                 kind = ResolutionFailure::WrongNamespace(res, MacroNS);\n                                 break;\n                             }\n@@ -1734,7 +1673,7 @@ fn resolution_failure(\n                         name = start;\n                         for &ns in &[TypeNS, ValueNS, MacroNS] {\n                             if let Some(res) =\n-                                collector.check_full_res(ns, &start, module_id, &None, &None)\n+                                collector.check_full_res(ns, &start, module_id, &None)\n                             {\n                                 debug!(\"found partial_res={:?}\", res);\n                                 *partial_res = Some(res);\n@@ -2131,7 +2070,7 @@ fn strip_generics_from_path(path_str: &str) -> Result<String, ResolutionFailure<\n             }\n             _ => segment.push(chr),\n         }\n-        debug!(\"raw segment: {:?}\", segment);\n+        trace!(\"raw segment: {:?}\", segment);\n     }\n \n     if !segment.is_empty() {"}, {"sha": "1189d266c536e72edade4540b15896af7a79d1c8", "filename": "src/test/rustdoc/intra-link-prim-self.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6ab1f05697c3f2df4e439a05ebcee479a9a16d80/src%2Ftest%2Frustdoc%2Fintra-link-prim-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ab1f05697c3f2df4e439a05ebcee479a9a16d80/src%2Ftest%2Frustdoc%2Fintra-link-prim-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-link-prim-self.rs?ref=6ab1f05697c3f2df4e439a05ebcee479a9a16d80", "patch": "@@ -0,0 +1,36 @@\n+// ignore-tidy-linelength\n+#![deny(broken_intra_doc_links)]\n+#![feature(lang_items)]\n+#![feature(no_core)]\n+#![no_core]\n+\n+#[lang = \"usize\"]\n+/// [Self::f]\n+/// [Self::MAX]\n+// @has intra_link_prim_self/primitive.usize.html\n+// @has - '//a[@href=\"https://doc.rust-lang.org/nightly/std/primitive.usize.html#method.f\"]' 'Self::f'\n+// @has - '//a[@href=\"https://doc.rust-lang.org/nightly/std/primitive.usize.html#associatedconstant.MAX\"]' 'Self::MAX'\n+impl usize {\n+    /// Some docs\n+    pub fn f() {}\n+\n+    /// 10 and 2^32 are basically the same.\n+    pub const MAX: usize = 10;\n+\n+    // FIXME(#8995) uncomment this when associated types in inherent impls are supported\n+    // @ has - '//a[@href=\"https://doc.rust-lang.org/nightly/std/primitive.usize.html#associatedtype.ME\"]' 'Self::ME'\n+    // / [Self::ME]\n+    //pub type ME = usize;\n+}\n+\n+#[doc(primitive = \"usize\")]\n+/// This has some docs.\n+mod usize {}\n+\n+/// [S::f]\n+/// [Self::f]\n+pub struct S;\n+\n+impl S {\n+    pub fn f() {}\n+}"}]}