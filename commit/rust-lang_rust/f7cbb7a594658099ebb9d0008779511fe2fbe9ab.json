{"sha": "f7cbb7a594658099ebb9d0008779511fe2fbe9ab", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3Y2JiN2E1OTQ2NTgwOTllYmI5ZDAwMDg3Nzk1MTFmZTJmYmU5YWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-27T07:26:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-27T07:26:32Z"}, "message": "Auto merge of #72784 - csmoe:issue-61076, r=estebank\n\nAwait on mismatched future types\n\nCloses #61076\nThis PR suggests to `await` on:\n1. `async_fn().bar() => async_fn().await.bar()`\n2. `async_fn().field => async_fn().await.field`\n3. ` if let x = async() {} => if let x = async().await {}`\n\nr? @tmandry @estebank", "tree": {"sha": "cec33661a7609e6d6e2d44428918a36dfa4f7b91", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cec33661a7609e6d6e2d44428918a36dfa4f7b91"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f7cbb7a594658099ebb9d0008779511fe2fbe9ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f7cbb7a594658099ebb9d0008779511fe2fbe9ab", "html_url": "https://github.com/rust-lang/rust/commit/f7cbb7a594658099ebb9d0008779511fe2fbe9ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f7cbb7a594658099ebb9d0008779511fe2fbe9ab/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e701afd84e4500bb7a4800f187284c1e1bf01ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e701afd84e4500bb7a4800f187284c1e1bf01ee", "html_url": "https://github.com/rust-lang/rust/commit/4e701afd84e4500bb7a4800f187284c1e1bf01ee"}, {"sha": "7cfcefd1fbbbfefbdc88feb7359e6364d7c0bf8a", "url": "https://api.github.com/repos/rust-lang/rust/commits/7cfcefd1fbbbfefbdc88feb7359e6364d7c0bf8a", "html_url": "https://github.com/rust-lang/rust/commit/7cfcefd1fbbbfefbdc88feb7359e6364d7c0bf8a"}], "stats": {"total": 306, "additions": 299, "deletions": 7}, "files": [{"sha": "d72ed72e3a8aceaa19e070b0e4d08b52678cb6c1", "filename": "src/librustc_infer/infer/error_reporting/mod.rs", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/f7cbb7a594658099ebb9d0008779511fe2fbe9ab/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7cbb7a594658099ebb9d0008779511fe2fbe9ab/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs?ref=f7cbb7a594658099ebb9d0008779511fe2fbe9ab", "patch": "@@ -50,6 +50,7 @@ use super::region_constraints::GenericKind;\n use super::{InferCtxt, RegionVariableOrigin, SubregionOrigin, TypeTrace, ValuePairs};\n \n use crate::infer;\n+use crate::infer::OriginalQueryValues;\n use crate::traits::error_reporting::report_object_safety_error;\n use crate::traits::{\n     IfExpressionCause, MatchExpressionArmCause, ObligationCause, ObligationCauseCode,\n@@ -60,8 +61,10 @@ use rustc_errors::{pluralize, struct_span_err};\n use rustc_errors::{Applicability, DiagnosticBuilder, DiagnosticStyledString};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n+use rustc_hir::lang_items::LangItem;\n use rustc_hir::{Item, ItemKind, Node};\n use rustc_middle::ty::error::TypeError;\n+use rustc_middle::ty::ParamEnvAnd;\n use rustc_middle::ty::{\n     self,\n     subst::{Subst, SubstsRef},\n@@ -1529,6 +1532,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         };\n         if let Some(exp_found) = exp_found {\n             self.suggest_as_ref_where_appropriate(span, &exp_found, diag);\n+            self.suggest_await_on_expect_found(cause, span, &exp_found, diag);\n         }\n \n         // In some (most?) cases cause.body_id points to actual body, but in some cases\n@@ -1547,6 +1551,62 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.note_error_origin(diag, cause, exp_found);\n     }\n \n+    fn suggest_await_on_expect_found(\n+        &self,\n+        cause: &ObligationCause<'tcx>,\n+        exp_span: Span,\n+        exp_found: &ty::error::ExpectedFound<Ty<'tcx>>,\n+        diag: &mut DiagnosticBuilder<'tcx>,\n+    ) {\n+        debug!(\n+            \"suggest_await_on_expect_found: exp_span={:?}, expected_ty={:?}, found_ty={:?}\",\n+            exp_span, exp_found.expected, exp_found.found\n+        );\n+\n+        if let ty::Opaque(def_id, _) = exp_found.expected.kind {\n+            let future_trait = self.tcx.require_lang_item(LangItem::Future, None);\n+            // Future::Output\n+            let item_def_id = self\n+                .tcx\n+                .associated_items(future_trait)\n+                .in_definition_order()\n+                .next()\n+                .unwrap()\n+                .def_id;\n+\n+            let projection_ty = self.tcx.projection_ty_from_predicates((def_id, item_def_id));\n+            if let Some(projection_ty) = projection_ty {\n+                let projection_query = self.canonicalize_query(\n+                    &ParamEnvAnd { param_env: self.tcx.param_env(def_id), value: projection_ty },\n+                    &mut OriginalQueryValues::default(),\n+                );\n+                if let Ok(resp) = self.tcx.normalize_projection_ty(projection_query) {\n+                    let normalized_ty = resp.value.value.normalized_ty;\n+                    debug!(\"suggest_await_on_expect_found: normalized={:?}\", normalized_ty);\n+                    if ty::TyS::same_type(normalized_ty, exp_found.found) {\n+                        let span = if let ObligationCauseCode::Pattern {\n+                            span,\n+                            origin_expr: _,\n+                            root_ty: _,\n+                        } = cause.code\n+                        {\n+                            // scrutinee's span\n+                            span.unwrap_or(exp_span)\n+                        } else {\n+                            exp_span\n+                        };\n+                        diag.span_suggestion_verbose(\n+                            span.shrink_to_hi(),\n+                            \"consider awaiting on the future\",\n+                            \".await\".to_string(),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     /// When encountering a case where `.as_ref()` on a `Result` or `Option` would be appropriate,\n     /// suggests it.\n     fn suggest_as_ref_where_appropriate("}, {"sha": "e05752f08f631d299c8c150c36fe196c1e5da8f0", "filename": "src/librustc_middle/query/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f7cbb7a594658099ebb9d0008779511fe2fbe9ab/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7cbb7a594658099ebb9d0008779511fe2fbe9ab/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fquery%2Fmod.rs?ref=f7cbb7a594658099ebb9d0008779511fe2fbe9ab", "patch": "@@ -173,6 +173,10 @@ rustc_queries! {\n             desc { |tcx| \"finding projection predicates for `{}`\", tcx.def_path_str(key) }\n         }\n \n+        query projection_ty_from_predicates(key: (DefId, DefId)) -> Option<ty::ProjectionTy<'tcx>> {\n+            desc { |tcx| \"finding projection type inside predicates of `{}`\", tcx.def_path_str(key.0) }\n+        }\n+\n         query native_libraries(_: CrateNum) -> Lrc<Vec<NativeLib>> {\n             desc { \"looking up the native libraries of a linked crate\" }\n         }"}, {"sha": "afd4413069ee10df5879f1eae2fb6aaba4198ab8", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f7cbb7a594658099ebb9d0008779511fe2fbe9ab/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7cbb7a594658099ebb9d0008779511fe2fbe9ab/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=f7cbb7a594658099ebb9d0008779511fe2fbe9ab", "patch": "@@ -28,7 +28,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         };\n \n         // Type check the descriminant and get its type.\n-        let scrut_ty = if force_scrutinee_bool {\n+        let scrutinee_ty = if force_scrutinee_bool {\n             // Here we want to ensure:\n             //\n             // 1. That default match bindings are *not* accepted in the condition of an\n@@ -55,7 +55,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // #55810: Type check patterns first so we get types for all bindings.\n         for arm in arms {\n-            self.check_pat_top(&arm.pat, scrut_ty, Some(scrut.span), true);\n+            self.check_pat_top(&arm.pat, scrutinee_ty, Some(scrut.span), true);\n         }\n \n         // Now typecheck the blocks."}, {"sha": "ad4418ddca74a4fd243bc531f6a4ae1f8120709d", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 56, "deletions": 1, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/f7cbb7a594658099ebb9d0008779511fe2fbe9ab/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7cbb7a594658099ebb9d0008779511fe2fbe9ab/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=f7cbb7a594658099ebb9d0008779511fe2fbe9ab", "patch": "@@ -37,7 +37,7 @@ use rustc_middle::ty::{AdtKind, Visibility};\n use rustc_span::hygiene::DesugaringKind;\n use rustc_span::source_map::Span;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n-use rustc_trait_selection::traits::{self, ObligationCauseCode};\n+use rustc_trait_selection::traits::{self, ObligationCauseCode, SelectionContext};\n \n use std::fmt::Display;\n \n@@ -1509,13 +1509,65 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.tcx().ty_error()\n     }\n \n+    fn suggest_await_on_field_access(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        field_ident: Ident,\n+        base: &'tcx hir::Expr<'tcx>,\n+        expr: &'tcx hir::Expr<'tcx>,\n+        def_id: DefId,\n+    ) {\n+        let param_env = self.tcx().param_env(def_id);\n+        let future_trait = self.tcx.require_lang_item(LangItem::Future, None);\n+        // Future::Output\n+        let item_def_id =\n+            self.tcx.associated_items(future_trait).in_definition_order().next().unwrap().def_id;\n+\n+        let projection_ty = self.tcx.projection_ty_from_predicates((def_id, item_def_id));\n+        debug!(\"suggest_await_on_field_access: projection_ty={:?}\", projection_ty);\n+\n+        let cause = self.misc(expr.span);\n+        let mut selcx = SelectionContext::new(&self.infcx);\n+\n+        let mut obligations = vec![];\n+        if let Some(projection_ty) = projection_ty {\n+            let normalized_ty = rustc_trait_selection::traits::normalize_projection_type(\n+                &mut selcx,\n+                param_env,\n+                projection_ty,\n+                cause,\n+                0,\n+                &mut obligations,\n+            );\n+            debug!(\n+                \"suggest_await_on_field_access: normalized_ty={:?}, ty_kind={:?}\",\n+                self.resolve_vars_if_possible(&normalized_ty),\n+                normalized_ty.kind,\n+            );\n+            if let ty::Adt(def, _) = normalized_ty.kind {\n+                if def.non_enum_variant().fields.iter().any(|field| field.ident == field_ident) {\n+                    err.span_suggestion_verbose(\n+                        base.span.shrink_to_hi(),\n+                        \"consider awaiting before field access\",\n+                        \".await\".to_string(),\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+            }\n+        }\n+    }\n+\n     fn ban_nonexisting_field(\n         &self,\n         field: Ident,\n         base: &'tcx hir::Expr<'tcx>,\n         expr: &'tcx hir::Expr<'tcx>,\n         expr_t: Ty<'tcx>,\n     ) {\n+        debug!(\n+            \"ban_nonexisting_field: field={:?}, base={:?}, expr={:?}, expr_ty={:?}\",\n+            field, base, expr, expr_t\n+        );\n         let mut err = self.no_such_field_err(field.span, field, expr_t);\n \n         match expr_t.peel_refs().kind {\n@@ -1531,6 +1583,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ty::Param(param_ty) => {\n                 self.point_at_param_definition(&mut err, param_ty);\n             }\n+            ty::Opaque(def_id, _) => {\n+                self.suggest_await_on_field_access(&mut err, field, base, expr, def_id);\n+            }\n             _ => {}\n         }\n "}, {"sha": "5cae66bc5dac6e3635d2eebc4f8039f5bc20cd1b", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/f7cbb7a594658099ebb9d0008779511fe2fbe9ab/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7cbb7a594658099ebb9d0008779511fe2fbe9ab/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=f7cbb7a594658099ebb9d0008779511fe2fbe9ab", "patch": "@@ -21,6 +21,7 @@ use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::{source_map, FileName, Span};\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n use rustc_trait_selection::traits::Obligation;\n+use rustc_trait_selection::traits::SelectionContext;\n \n use std::cmp::Ordering;\n \n@@ -392,6 +393,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             actual.prefix_string(),\n                             ty_str,\n                         );\n+                        if let Mode::MethodCall = mode {\n+                            if let SelfSource::MethodCall(call) = source {\n+                                self.suggest_await_before_method(\n+                                    &mut err, item_name, actual, call, span,\n+                                );\n+                            }\n+                        }\n                         if let Some(span) =\n                             tcx.sess.confused_type_with_std_module.borrow().get(&span)\n                         {\n@@ -854,6 +862,57 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n+    fn suggest_await_before_method(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        item_name: Ident,\n+        ty: Ty<'tcx>,\n+        call: &hir::Expr<'_>,\n+        span: Span,\n+    ) {\n+        if let ty::Opaque(def_id, _) = ty.kind {\n+            let future_trait = self.tcx.require_lang_item(LangItem::Future, None);\n+            // Future::Output\n+            let item_def_id = self\n+                .tcx\n+                .associated_items(future_trait)\n+                .in_definition_order()\n+                .next()\n+                .unwrap()\n+                .def_id;\n+\n+            let projection_ty = self.tcx.projection_ty_from_predicates((def_id, item_def_id));\n+            let cause = self.misc(span);\n+            let mut selcx = SelectionContext::new(&self.infcx);\n+            let mut obligations = vec![];\n+            if let Some(projection_ty) = projection_ty {\n+                let normalized_ty = rustc_trait_selection::traits::normalize_projection_type(\n+                    &mut selcx,\n+                    self.param_env,\n+                    projection_ty,\n+                    cause,\n+                    0,\n+                    &mut obligations,\n+                );\n+                debug!(\n+                    \"suggest_await_before_method: normalized_ty={:?}, ty_kind={:?}\",\n+                    self.resolve_vars_if_possible(&normalized_ty),\n+                    normalized_ty.kind,\n+                );\n+                let method_exists = self.method_exists(item_name, normalized_ty, call.hir_id, true);\n+                debug!(\"suggest_await_before_method: is_method_exist={}\", method_exists);\n+                if method_exists {\n+                    err.span_suggestion_verbose(\n+                        span.shrink_to_lo(),\n+                        \"consider awaiting before this method call\",\n+                        \"await.\".to_string(),\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+            }\n+        }\n+    }\n+\n     fn suggest_use_candidates(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,"}, {"sha": "7a3f7ec56a2ce78d6fd043334882ea0e60eaa28b", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f7cbb7a594658099ebb9d0008779511fe2fbe9ab/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7cbb7a594658099ebb9d0008779511fe2fbe9ab/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=f7cbb7a594658099ebb9d0008779511fe2fbe9ab", "patch": "@@ -70,6 +70,7 @@ pub fn provide(providers: &mut Providers) {\n         generics_of,\n         predicates_of,\n         predicates_defined_on,\n+        projection_ty_from_predicates,\n         explicit_predicates_of,\n         super_predicates_of,\n         type_param_predicates,\n@@ -2051,6 +2052,28 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n     result\n }\n \n+fn projection_ty_from_predicates(\n+    tcx: TyCtxt<'tcx>,\n+    key: (\n+        // ty_def_id\n+        DefId,\n+        // def_id of `N` in `<T as Trait>::N`\n+        DefId,\n+    ),\n+) -> Option<ty::ProjectionTy<'tcx>> {\n+    let (ty_def_id, item_def_id) = key;\n+    let mut projection_ty = None;\n+    for (predicate, _) in tcx.predicates_of(ty_def_id).predicates {\n+        if let ty::PredicateAtom::Projection(projection_predicate) = predicate.skip_binders() {\n+            if item_def_id == projection_predicate.projection_ty.item_def_id {\n+                projection_ty = Some(projection_predicate.projection_ty);\n+                break;\n+            }\n+        }\n+    }\n+    projection_ty\n+}\n+\n fn trait_associated_item_predicates(\n     tcx: TyCtxt<'tcx>,\n     def_id: DefId,"}, {"sha": "e383a9126f7bc2b065285b356d754ec97f78f195", "filename": "src/test/ui/async-await/issue-61076.rs", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/f7cbb7a594658099ebb9d0008779511fe2fbe9ab/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7cbb7a594658099ebb9d0008779511fe2fbe9ab/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.rs?ref=f7cbb7a594658099ebb9d0008779511fe2fbe9ab", "patch": "@@ -6,6 +6,26 @@ use core::task::{Context, Poll};\n \n struct T;\n \n+struct Tuple(i32);\n+\n+struct Struct {\n+    a: i32\n+}\n+\n+impl Struct {\n+    fn method(&self) {}\n+}\n+\n+impl Future for Struct {\n+    type Output = Struct;\n+    fn poll(self: Pin<&mut Self>, _: &mut Context<'_>) -> Poll<Self::Output> { Poll::Pending }\n+}\n+\n+impl Future for Tuple {\n+    type Output = Tuple;\n+    fn poll(self: Pin<&mut Self>, _: &mut Context<'_>) -> Poll<Self::Output> { Poll::Pending }\n+}\n+\n impl Future for T {\n     type Output = Result<(), ()>;\n \n@@ -23,10 +43,31 @@ async fn bar() -> Result<(), ()> {\n     Ok(())\n }\n \n+async fn struct_() -> Struct {\n+    Struct { a: 1 }\n+}\n+\n+async fn tuple() -> Tuple {\n+    Tuple(1i32)\n+}\n+\n async fn baz() -> Result<(), ()> {\n     let t = T;\n     t?; //~ ERROR the `?` operator can only be applied to values that implement `std::ops::Try`\n+\n+    let _: i32 = tuple().0; //~ ERROR no field `0`\n+\n+    let _: i32 = struct_().a; //~ ERROR no field `a`\n+\n+    struct_().method(); //~ ERROR no method named\n+\n     Ok(())\n }\n \n+async fn match_() {\n+    match tuple() {\n+        Tuple(_) => {} //~ ERROR mismatched types\n+    }\n+}\n+\n fn main() {}"}, {"sha": "69b6e8c3cf5699ff8039c570dd4ad4f5ff63467c", "filename": "src/test/ui/async-await/issue-61076.stderr", "status": "modified", "additions": 54, "deletions": 4, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/f7cbb7a594658099ebb9d0008779511fe2fbe9ab/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f7cbb7a594658099ebb9d0008779511fe2fbe9ab/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.stderr?ref=f7cbb7a594658099ebb9d0008779511fe2fbe9ab", "patch": "@@ -1,5 +1,5 @@\n error[E0277]: the `?` operator can only be applied to values that implement `std::ops::Try`\n-  --> $DIR/issue-61076.rs:22:5\n+  --> $DIR/issue-61076.rs:42:5\n    |\n LL |     foo()?;\n    |     ^^^^^^\n@@ -11,7 +11,7 @@ LL |     foo()?;\n    = note: required by `std::ops::Try::into_result`\n \n error[E0277]: the `?` operator can only be applied to values that implement `std::ops::Try`\n-  --> $DIR/issue-61076.rs:28:5\n+  --> $DIR/issue-61076.rs:56:5\n    |\n LL |     t?;\n    |     ^^\n@@ -22,6 +22,56 @@ LL |     t?;\n    = help: the trait `std::ops::Try` is not implemented for `T`\n    = note: required by `std::ops::Try::into_result`\n \n-error: aborting due to 2 previous errors\n+error[E0609]: no field `0` on type `impl std::future::Future`\n+  --> $DIR/issue-61076.rs:58:26\n+   |\n+LL |     let _: i32 = tuple().0;\n+   |                          ^\n+   |\n+help: consider awaiting before field access\n+   |\n+LL |     let _: i32 = tuple().await.0;\n+   |                         ^^^^^^\n+\n+error[E0609]: no field `a` on type `impl std::future::Future`\n+  --> $DIR/issue-61076.rs:60:28\n+   |\n+LL |     let _: i32 = struct_().a;\n+   |                            ^\n+   |\n+help: consider awaiting before field access\n+   |\n+LL |     let _: i32 = struct_().await.a;\n+   |                           ^^^^^^\n+\n+error[E0599]: no method named `method` found for opaque type `impl std::future::Future` in the current scope\n+  --> $DIR/issue-61076.rs:62:15\n+   |\n+LL |     struct_().method();\n+   |               ^^^^^^ method not found in `impl std::future::Future`\n+   |\n+help: consider awaiting before this method call\n+   |\n+LL |     struct_().await.method();\n+   |               ^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-61076.rs:69:9\n+   |\n+LL | async fn tuple() -> Tuple {\n+   |                     ----- the `Output` of this `async fn`'s expected opaque type\n+...\n+LL |         Tuple(_) => {}\n+   |         ^^^^^^^^ expected opaque type, found struct `Tuple`\n+   |\n+   = note: expected opaque type `impl std::future::Future`\n+                   found struct `Tuple`\n+help: consider awaiting on the future\n+   |\n+LL |     match tuple().await {\n+   |                  ^^^^^^\n+\n+error: aborting due to 6 previous errors\n \n-For more information about this error, try `rustc --explain E0277`.\n+Some errors have detailed explanations: E0277, E0308, E0599, E0609.\n+For more information about an error, try `rustc --explain E0277`."}]}