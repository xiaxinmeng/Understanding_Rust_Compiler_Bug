{"sha": "3c31cf25b18a1300d723e7a3b155810b23d4b472", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjMzFjZjI1YjE4YTEzMDBkNzIzZTdhM2IxNTU4MTBiMjNkNGI0NzI=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-09-10T22:42:01Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-09-16T17:44:01Z"}, "message": "fix handling of function attributes\n\nThe `noalias` attributes were being set only on function definitions,\nnot on all declarations. This is harmless for `noalias`, but prevented\nsome optimization opportunities and is *not* harmless for other\nattributes like `sret` with ABI implications.\n\nCloses #9104", "tree": {"sha": "c25891ae9ff48d562e0942979143dad4cbf01711", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c25891ae9ff48d562e0942979143dad4cbf01711"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3c31cf25b18a1300d723e7a3b155810b23d4b472", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3c31cf25b18a1300d723e7a3b155810b23d4b472", "html_url": "https://github.com/rust-lang/rust/commit/3c31cf25b18a1300d723e7a3b155810b23d4b472", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3c31cf25b18a1300d723e7a3b155810b23d4b472/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6bc48b63f376439801d43820f6df0990797b8787", "url": "https://api.github.com/repos/rust-lang/rust/commits/6bc48b63f376439801d43820f6df0990797b8787", "html_url": "https://github.com/rust-lang/rust/commit/6bc48b63f376439801d43820f6df0990797b8787"}], "stats": {"total": 199, "additions": 119, "deletions": 80}, "files": [{"sha": "e88080accaa43f930b534a619fd716a8a7ebec4c", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 96, "deletions": 61, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/3c31cf25b18a1300d723e7a3b155810b23d4b472/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c31cf25b18a1300d723e7a3b155810b23d4b472/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=3c31cf25b18a1300d723e7a3b155810b23d4b472", "patch": "@@ -174,6 +174,7 @@ impl<'self> Drop for StatRecorder<'self> {\n     }\n }\n \n+// only use this for foreign function ABIs and glue, use `decl_rust_fn` for Rust functions\n pub fn decl_fn(llmod: ModuleRef, name: &str, cc: lib::llvm::CallConv, ty: Type) -> ValueRef {\n     let llfn: ValueRef = do name.with_c_str |buf| {\n         unsafe {\n@@ -185,18 +186,12 @@ pub fn decl_fn(llmod: ModuleRef, name: &str, cc: lib::llvm::CallConv, ty: Type)\n     return llfn;\n }\n \n+// only use this for foreign function ABIs and glue, use `decl_rust_fn` for Rust functions\n pub fn decl_cdecl_fn(llmod: ModuleRef, name: &str, ty: Type) -> ValueRef {\n     return decl_fn(llmod, name, lib::llvm::CCallConv, ty);\n }\n \n-// Only use this if you are going to actually define the function. It's\n-// not valid to simply declare a function as internal.\n-pub fn decl_internal_cdecl_fn(llmod: ModuleRef, name: &str, ty: Type) -> ValueRef {\n-    let llfn = decl_cdecl_fn(llmod, name, ty);\n-    lib::llvm::SetLinkage(llfn, lib::llvm::InternalLinkage);\n-    return llfn;\n-}\n-\n+// only use this for foreign function ABIs and glue, use `get_extern_rust_fn` for Rust functions\n pub fn get_extern_fn(externs: &mut ExternMap, llmod: ModuleRef, name: &str,\n                      cc: lib::llvm::CallConv, ty: Type) -> ValueRef {\n     match externs.find_equiv(&name) {\n@@ -205,7 +200,62 @@ pub fn get_extern_fn(externs: &mut ExternMap, llmod: ModuleRef, name: &str,\n     }\n     let f = decl_fn(llmod, name, cc, ty);\n     externs.insert(name.to_owned(), f);\n-    return f;\n+    f\n+}\n+\n+pub fn get_extern_rust_fn(ccx: &mut CrateContext, inputs: &[ty::t], output: ty::t,\n+                          name: &str) -> ValueRef {\n+    match ccx.externs.find_equiv(&name) {\n+        Some(n) => return *n,\n+        None => ()\n+    }\n+    let f = decl_rust_fn(ccx, inputs, output, name);\n+    ccx.externs.insert(name.to_owned(), f);\n+    f\n+}\n+\n+pub fn decl_rust_fn(ccx: &mut CrateContext, inputs: &[ty::t], output: ty::t,\n+                    name: &str) -> ValueRef {\n+    let llfty = type_of_rust_fn(ccx, inputs, output);\n+    let llfn = decl_cdecl_fn(ccx.llmod, name, llfty);\n+\n+    match ty::get(output).sty {\n+        // `~` pointer return values never alias because ownership is transferred\n+        ty::ty_uniq(*) |\n+        ty::ty_evec(_, ty::vstore_uniq) => {\n+            unsafe {\n+                llvm::LLVMAddReturnAttribute(llfn, lib::llvm::NoAliasAttribute as c_uint);\n+            }\n+        }\n+        _ => ()\n+    }\n+\n+    let uses_outptr = type_of::return_uses_outptr(ccx.tcx, output);\n+    let offset = if uses_outptr { 2 } else { 1 };\n+\n+    for (i, &arg_ty) in inputs.iter().enumerate() {\n+        let llarg = unsafe { llvm::LLVMGetParam(llfn, (offset + i) as c_uint) };\n+        match ty::get(arg_ty).sty {\n+            // `~` pointer parameters never alias because ownership is transferred\n+            ty::ty_uniq(*) |\n+            ty::ty_evec(_, ty::vstore_uniq) |\n+            ty::ty_closure(ty::ClosureTy {sigil: ast::OwnedSigil, _}) => {\n+                unsafe {\n+                    llvm::LLVMAddAttribute(llarg, lib::llvm::NoAliasAttribute as c_uint);\n+                }\n+            }\n+            _ => ()\n+        }\n+    }\n+\n+    llfn\n+}\n+\n+pub fn decl_internal_rust_fn(ccx: &mut CrateContext, inputs: &[ty::t], output: ty::t,\n+                             name: &str) -> ValueRef {\n+    let llfn = decl_rust_fn(ccx, inputs, output, name);\n+    lib::llvm::SetLinkage(llfn, lib::llvm::InternalLinkage);\n+    llfn\n }\n \n pub fn get_extern_const(externs: &mut ExternMap, llmod: ModuleRef,\n@@ -809,33 +859,30 @@ pub fn null_env_ptr(ccx: &CrateContext) -> ValueRef {\n     C_null(Type::opaque_box(ccx).ptr_to())\n }\n \n-pub fn trans_external_path(ccx: &mut CrateContext, did: ast::DefId, t: ty::t)\n-    -> ValueRef {\n+pub fn trans_external_path(ccx: &mut CrateContext, did: ast::DefId, t: ty::t) -> ValueRef {\n     let name = csearch::get_symbol(ccx.sess.cstore, did);\n     match ty::get(t).sty {\n         ty::ty_bare_fn(ref fn_ty) => {\n-            // Currently llvm_calling_convention triggers unimpl/bug on\n-            // Rust/RustIntrinsic, so those two are handled specially here.\n-            let cconv = match fn_ty.abis.for_arch(ccx.sess.targ_cfg.arch) {\n-                Some(Rust) | Some(RustIntrinsic) => lib::llvm::CCallConv,\n+            match fn_ty.abis.for_arch(ccx.sess.targ_cfg.arch) {\n+                Some(Rust) | Some(RustIntrinsic) => {\n+                    get_extern_rust_fn(ccx, fn_ty.sig.inputs, fn_ty.sig.output, name)\n+                }\n                 Some(*) | None => {\n                     let c = foreign::llvm_calling_convention(ccx, fn_ty.abis);\n-                    c.unwrap_or(lib::llvm::CCallConv)\n+                    let cconv = c.unwrap_or(lib::llvm::CCallConv);\n+                    let llty = type_of_fn_from_ty(ccx, t);\n+                    get_extern_fn(&mut ccx.externs, ccx.llmod, name, cconv, llty)\n                 }\n-            };\n-            let llty = type_of_fn_from_ty(ccx, t);\n-            return get_extern_fn(&mut ccx.externs, ccx.llmod, name, cconv, llty);\n+            }\n         }\n-        ty::ty_closure(_) => {\n-            let llty = type_of_fn_from_ty(ccx, t);\n-            return get_extern_fn(&mut ccx.externs, ccx.llmod, name,\n-            lib::llvm::CCallConv, llty);\n+        ty::ty_closure(ref f) => {\n+            get_extern_rust_fn(ccx, f.sig.inputs, f.sig.output, name)\n         }\n         _ => {\n             let llty = type_of(ccx, t);\n-            return get_extern_const(&mut ccx.externs, ccx.llmod, name, llty);\n+            get_extern_const(&mut ccx.externs, ccx.llmod, name, llty)\n         }\n-    };\n+    }\n }\n \n pub fn invoke(bcx: @mut Block, llfn: ValueRef, llargs: ~[ValueRef],\n@@ -1707,8 +1754,7 @@ pub fn new_fn_ctxt(ccx: @mut CrateContext,\n // field of the fn_ctxt with\n pub fn create_llargs_for_fn_args(cx: @mut FunctionContext,\n                                  self_arg: self_arg,\n-                                 args: &[ast::arg],\n-                                 arg_tys: &[ty::t])\n+                                 args: &[ast::arg])\n                               -> ~[ValueRef] {\n     let _icx = push_ctxt(\"create_llargs_for_fn_args\");\n \n@@ -1726,23 +1772,7 @@ pub fn create_llargs_for_fn_args(cx: @mut FunctionContext,\n     // Return an array containing the ValueRefs that we get from\n     // llvm::LLVMGetParam for each argument.\n     do vec::from_fn(args.len()) |i| {\n-        let arg_n = cx.arg_pos(i);\n-        let arg_ty = arg_tys[i];\n-        let llarg = unsafe {llvm::LLVMGetParam(cx.llfn, arg_n as c_uint) };\n-\n-        match ty::get(arg_ty).sty {\n-            // `~` pointer parameters never alias because ownership is transferred\n-            ty::ty_uniq(*) |\n-            ty::ty_evec(_, ty::vstore_uniq) |\n-            ty::ty_closure(ty::ClosureTy {sigil: ast::OwnedSigil, _}) => {\n-                unsafe {\n-                    llvm::LLVMAddAttribute(llarg, lib::llvm::NoAliasAttribute as c_uint);\n-                }\n-            }\n-            _ => ()\n-        }\n-\n-        llarg\n+        unsafe { llvm::LLVMGetParam(cx.llfn, cx.arg_pos(i) as c_uint) }\n     }\n }\n \n@@ -1896,8 +1926,7 @@ pub fn trans_closure(ccx: @mut CrateContext,\n \n     // Set up arguments to the function.\n     let arg_tys = ty::ty_fn_args(node_id_type(bcx, id));\n-    let raw_llargs = create_llargs_for_fn_args(fcx, self_arg,\n-                                               decl.inputs, arg_tys);\n+    let raw_llargs = create_llargs_for_fn_args(fcx, self_arg, decl.inputs);\n \n     // Set the fixed stack segment flag if necessary.\n     if attr::contains_name(attributes, \"fixed_stack_segment\") {\n@@ -1961,18 +1990,6 @@ pub fn trans_fn(ccx: @mut CrateContext,\n            param_substs.repr(ccx.tcx));\n     let _icx = push_ctxt(\"trans_fn\");\n     let output_type = ty::ty_fn_ret(ty::node_id_to_type(ccx.tcx, id));\n-\n-    match ty::get(output_type).sty {\n-        // `~` pointer return values never alias because ownership is transferred\n-        ty::ty_uniq(*) |\n-        ty::ty_evec(_, ty::vstore_uniq) => {\n-            unsafe {\n-                llvm::LLVMAddReturnAttribute(llfndecl, lib::llvm::NoAliasAttribute as c_uint);\n-            }\n-        }\n-        _ => ()\n-    }\n-\n     trans_closure(ccx,\n                   path.clone(),\n                   decl,\n@@ -2120,7 +2137,7 @@ pub fn trans_enum_variant_or_tuple_like_struct<A:IdAndTy>(\n \n     let arg_tys = ty::ty_fn_args(ctor_ty);\n \n-    let raw_llargs = create_llargs_for_fn_args(fcx, no_self, fn_args, arg_tys);\n+    let raw_llargs = create_llargs_for_fn_args(fcx, no_self, fn_args);\n \n     let bcx = fcx.entry_bcx.unwrap();\n \n@@ -2298,10 +2315,28 @@ pub fn register_fn(ccx: @mut CrateContext,\n                    node_id: ast::NodeId,\n                    node_type: ty::t)\n                    -> ValueRef {\n-    let llfty = type_of_fn_from_ty(ccx, node_type);\n-    register_fn_llvmty(ccx, sp, sym, node_id, lib::llvm::CCallConv, llfty)\n+    let f = match ty::get(node_type).sty {\n+        ty::ty_bare_fn(ref f) => {\n+            assert!(f.abis.is_rust() || f.abis.is_intrinsic());\n+            f\n+        }\n+        _ => fail!(\"expected bare rust fn or an intrinsic\")\n+    };\n+\n+    let llfn = decl_rust_fn(ccx, f.sig.inputs, f.sig.output, sym);\n+    ccx.item_symbols.insert(node_id, sym);\n+\n+    // FIXME #4404 android JNI hacks\n+    let is_entry = is_entry_fn(&ccx.sess, node_id) && (!*ccx.sess.building_library ||\n+                      (*ccx.sess.building_library &&\n+                       ccx.sess.targ_cfg.os == session::OsAndroid));\n+    if is_entry {\n+        create_entry_wrapper(ccx, sp, llfn);\n+    }\n+    llfn\n }\n \n+// only use this for foreign function ABIs and glue, use `register_fn` for Rust functions\n pub fn register_fn_llvmty(ccx: @mut CrateContext,\n                           sp: Span,\n                           sym: ~str,"}, {"sha": "605032dc20c8fa0609361a1e7b3fa61976239795", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3c31cf25b18a1300d723e7a3b155810b23d4b472/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c31cf25b18a1300d723e7a3b155810b23d4b472/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=3c31cf25b18a1300d723e7a3b155810b23d4b472", "patch": "@@ -381,16 +381,18 @@ pub fn trans_expr_fn(bcx: @mut Block,\n \n     let ccx = bcx.ccx();\n     let fty = node_id_type(bcx, outer_id);\n-\n-    let llfnty = type_of_fn_from_ty(ccx, fty);\n+    let f = match ty::get(fty).sty {\n+        ty::ty_closure(ref f) => f,\n+        _ => fail!(\"expected closure\")\n+    };\n \n     let sub_path = vec::append_one(bcx.fcx.path.clone(),\n                                    path_name(special_idents::anon));\n     // XXX: Bad copy.\n     let s = mangle_internal_name_by_path_and_seq(ccx,\n                                                  sub_path.clone(),\n                                                  \"expr_fn\");\n-    let llfn = decl_internal_cdecl_fn(ccx.llmod, s, llfnty);\n+    let llfn = decl_internal_rust_fn(ccx, f.sig.inputs, f.sig.output, s);\n \n     // set an inline hint for all closures\n     set_inline_hint(llfn);"}, {"sha": "cfed6e883c82d4e89e2b5cc09a405af72d558991", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3c31cf25b18a1300d723e7a3b155810b23d4b472/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c31cf25b18a1300d723e7a3b155810b23d4b472/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=3c31cf25b18a1300d723e7a3b155810b23d4b472", "patch": "@@ -21,7 +21,6 @@ use middle::trans::cabi;\n use middle::trans::build::*;\n use middle::trans::builder::noname;\n use middle::trans::common::*;\n-use middle::trans::llrepr::LlvmRepr;\n use middle::trans::type_of::*;\n use middle::trans::type_of;\n use middle::ty;\n@@ -406,13 +405,12 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @mut CrateContext,\n                 special_idents::clownshoe_abi\n             )));\n \n-        // Compute the LLVM type that the function would have if it\n-        // were just a normal Rust function. This will be the type of\n-        // the wrappee fn.\n-        let llty = match ty::get(t).sty {\n+        // Compute the type that the function would have if it were just a\n+        // normal Rust function. This will be the type of the wrappee fn.\n+        let f = match ty::get(t).sty {\n             ty::ty_bare_fn(ref f) => {\n                 assert!(!f.abis.is_rust() && !f.abis.is_intrinsic());\n-                type_of_rust_fn(ccx, f.sig.inputs, f.sig.output)\n+                f\n             }\n             _ => {\n                 ccx.sess.bug(fmt!(\"build_rust_fn: extern fn %s has ty %s, \\\n@@ -422,13 +420,12 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @mut CrateContext,\n             }\n         };\n \n-        debug!(\"build_rust_fn: path=%s id=%? t=%s llty=%s\",\n+        debug!(\"build_rust_fn: path=%s id=%? t=%s\",\n                path.repr(tcx),\n                id,\n-               t.repr(tcx),\n-               llty.llrepr(ccx));\n+               t.repr(tcx));\n \n-        let llfndecl = base::decl_internal_cdecl_fn(ccx.llmod, ps, llty);\n+        let llfndecl = base::decl_internal_rust_fn(ccx, f.sig.inputs, f.sig.output, ps);\n         base::trans_fn(ccx,\n                        (*path).clone(),\n                        decl,"}, {"sha": "ef055a52468c89be55e964653bf7fe9cb7289f99", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3c31cf25b18a1300d723e7a3b155810b23d4b472/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c31cf25b18a1300d723e7a3b155810b23d4b472/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=3c31cf25b18a1300d723e7a3b155810b23d4b472", "patch": "@@ -14,14 +14,13 @@ use driver::session;\n use lib::llvm::ValueRef;\n use middle::trans::base::{set_llvm_fn_attrs, set_inline_hint};\n use middle::trans::base::{trans_enum_variant,push_ctxt};\n-use middle::trans::base::{trans_fn, decl_internal_cdecl_fn};\n+use middle::trans::base::{trans_fn, decl_internal_rust_fn};\n use middle::trans::base::{get_item_val, no_self};\n use middle::trans::base;\n use middle::trans::common::*;\n use middle::trans::datum;\n use middle::trans::machine;\n use middle::trans::meth;\n-use middle::trans::type_of::type_of_fn_from_ty;\n use middle::trans::type_of;\n use middle::trans::type_use;\n use middle::trans::intrinsic;\n@@ -177,7 +176,14 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n             ty::subst_tps(ccx.tcx, substs, None, llitem_ty)\n         }\n     };\n-    let llfty = type_of_fn_from_ty(ccx, mono_ty);\n+\n+    let f = match ty::get(mono_ty).sty {\n+        ty::ty_bare_fn(ref f) => {\n+            assert!(f.abis.is_rust() || f.abis.is_intrinsic());\n+            f\n+        }\n+        _ => fail!(\"expected bare rust fn or an intrinsic\")\n+    };\n \n     ccx.stats.n_monos += 1;\n \n@@ -200,7 +206,7 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n     debug!(\"monomorphize_fn mangled to %s\", s);\n \n     let mk_lldecl = || {\n-        let lldecl = decl_internal_cdecl_fn(ccx.llmod, s, llfty);\n+        let lldecl = decl_internal_rust_fn(ccx, f.sig.inputs, f.sig.output, s);\n         ccx.monomorphized.insert(hash_id, lldecl);\n         lldecl\n     };"}, {"sha": "23b87c63d6a2c5bb1ee02117eb586d42d484e5f3", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3c31cf25b18a1300d723e7a3b155810b23d4b472/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c31cf25b18a1300d723e7a3b155810b23d4b472/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=3c31cf25b18a1300d723e7a3b155810b23d4b472", "patch": "@@ -293,8 +293,7 @@ impl Reflector {\n                                                                sub_path,\n                                                                \"get_disr\");\n \n-                let llfty = type_of_rust_fn(ccx, [opaqueptrty], ty::mk_int());\n-                let llfdecl = decl_internal_cdecl_fn(ccx.llmod, sym, llfty);\n+                let llfdecl = decl_internal_rust_fn(ccx, [opaqueptrty], ty::mk_int(), sym);\n                 let fcx = new_fn_ctxt(ccx,\n                                       ~[],\n                                       llfdecl,"}]}