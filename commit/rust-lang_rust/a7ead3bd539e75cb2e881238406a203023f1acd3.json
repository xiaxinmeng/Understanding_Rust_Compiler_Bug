{"sha": "a7ead3bd539e75cb2e881238406a203023f1acd3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE3ZWFkM2JkNTM5ZTc1Y2IyZTg4MTIzODQwNmEyMDMwMjNmMWFjZDM=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-06-23T17:18:06Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-10-06T10:18:45Z"}, "message": "Move item_bounds to typeck::collect", "tree": {"sha": "753253596f7c0cf064dd04fc039bc53004b56f57", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/753253596f7c0cf064dd04fc039bc53004b56f57"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a7ead3bd539e75cb2e881238406a203023f1acd3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a7ead3bd539e75cb2e881238406a203023f1acd3", "html_url": "https://github.com/rust-lang/rust/commit/a7ead3bd539e75cb2e881238406a203023f1acd3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a7ead3bd539e75cb2e881238406a203023f1acd3/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0eb87ed55fa76e11777254c77ff7f11c74aa2bfa", "url": "https://api.github.com/repos/rust-lang/rust/commits/0eb87ed55fa76e11777254c77ff7f11c74aa2bfa", "html_url": "https://github.com/rust-lang/rust/commit/0eb87ed55fa76e11777254c77ff7f11c74aa2bfa"}], "stats": {"total": 253, "additions": 129, "deletions": 124}, "files": [{"sha": "1f21d9488a454b720dd79319b0d95820d7c8c07d", "filename": "compiler/rustc_ty/src/ty.rs", "status": "modified", "additions": 1, "deletions": 124, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/a7ead3bd539e75cb2e881238406a203023f1acd3/compiler%2Frustc_ty%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7ead3bd539e75cb2e881238406a203023f1acd3/compiler%2Frustc_ty%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty%2Fsrc%2Fty.rs?ref=a7ead3bd539e75cb2e881238406a203023f1acd3", "patch": "@@ -1,11 +1,9 @@\n use rustc_data_structures::fx::FxIndexSet;\n use rustc_data_structures::svh::Svh;\n use rustc_hir as hir;\n-use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n-use rustc_infer::traits::util;\n use rustc_middle::hir::map as hir_map;\n-use rustc_middle::ty::subst::{InternalSubsts, Subst};\n+use rustc_middle::ty::subst::Subst;\n use rustc_middle::ty::{\n     self, Binder, Predicate, PredicateAtom, PredicateKind, ToPredicate, Ty, TyCtxt, WithConstness,\n };\n@@ -492,126 +490,6 @@ fn asyncness(tcx: TyCtxt<'_>, def_id: DefId) -> hir::IsAsync {\n     fn_like.asyncness()\n }\n \n-/// For associated types we allow bounds written on the associated type\n-/// (`type X: Trait`) to be used as candidates. We also allow the same bounds\n-/// when desugared as bounds on the trait `where Self::X: Trait`.\n-///\n-/// Note that this filtering is done with the items identity substs to\n-/// simplify checking that these bounds are met in impls. This means that\n-/// a bound such as `for<'b> <Self as X<'b>>::U: Clone` can't be used, as in\n-/// `hr-associated-type-bound-1.rs`.\n-fn associated_type_bounds(\n-    tcx: TyCtxt<'_>,\n-    assoc_item_def_id: DefId,\n-) -> &'_ ty::List<ty::Predicate<'_>> {\n-    let generic_trait_bounds = tcx.predicates_of(assoc_item_def_id);\n-    // We include predicates from the trait as well to handle\n-    // `where Self::X: Trait`.\n-    let item_bounds = generic_trait_bounds.instantiate_identity(tcx);\n-    let item_predicates = util::elaborate_predicates(tcx, item_bounds.predicates.into_iter());\n-\n-    let assoc_item_ty = ty::ProjectionTy {\n-        item_def_id: assoc_item_def_id,\n-        substs: InternalSubsts::identity_for_item(tcx, assoc_item_def_id),\n-    };\n-\n-    let predicates = item_predicates.filter_map(|obligation| {\n-        let pred = obligation.predicate;\n-        match pred.skip_binders() {\n-            ty::PredicateAtom::Trait(tr, _) => {\n-                if let ty::Projection(p) = *tr.self_ty().kind() {\n-                    if p == assoc_item_ty {\n-                        return Some(pred);\n-                    }\n-                }\n-            }\n-            ty::PredicateAtom::Projection(proj) => {\n-                if let ty::Projection(p) = *proj.projection_ty.self_ty().kind() {\n-                    if p == assoc_item_ty {\n-                        return Some(pred);\n-                    }\n-                }\n-            }\n-            ty::PredicateAtom::TypeOutlives(outlives) => {\n-                if let ty::Projection(p) = *outlives.0.kind() {\n-                    if p == assoc_item_ty {\n-                        return Some(pred);\n-                    }\n-                }\n-            }\n-            _ => {}\n-        }\n-        None\n-    });\n-\n-    let result = tcx.mk_predicates(predicates);\n-    debug!(\"associated_type_bounds({}) = {:?}\", tcx.def_path_str(assoc_item_def_id), result);\n-    result\n-}\n-\n-/// Opaque types don't have the same issues as associated types: the only\n-/// predicates on an opaque type (excluding those it inherits from its parent\n-/// item) should be of the form we're expecting.\n-fn opaque_type_bounds(tcx: TyCtxt<'_>, def_id: DefId) -> &'_ ty::List<ty::Predicate<'_>> {\n-    let substs = InternalSubsts::identity_for_item(tcx, def_id);\n-\n-    let bounds = tcx.predicates_of(def_id);\n-    let predicates =\n-        util::elaborate_predicates(tcx, bounds.predicates.iter().map(|&(pred, _)| pred));\n-\n-    let filtered_predicates = predicates.filter_map(|obligation| {\n-        let pred = obligation.predicate;\n-        match pred.skip_binders() {\n-            ty::PredicateAtom::Trait(tr, _) => {\n-                if let ty::Opaque(opaque_def_id, opaque_substs) = *tr.self_ty().kind() {\n-                    if opaque_def_id == def_id && opaque_substs == substs {\n-                        return Some(pred);\n-                    }\n-                }\n-            }\n-            ty::PredicateAtom::Projection(proj) => {\n-                if let ty::Opaque(opaque_def_id, opaque_substs) =\n-                    *proj.projection_ty.self_ty().kind()\n-                {\n-                    if opaque_def_id == def_id && opaque_substs == substs {\n-                        return Some(pred);\n-                    }\n-                }\n-            }\n-            ty::PredicateAtom::TypeOutlives(outlives) => {\n-                if let ty::Opaque(opaque_def_id, opaque_substs) = *outlives.0.kind() {\n-                    if opaque_def_id == def_id && opaque_substs == substs {\n-                        return Some(pred);\n-                    }\n-                } else {\n-                    // These can come from elaborating other predicates\n-                    return None;\n-                }\n-            }\n-            // These can come from elaborating other predicates\n-            ty::PredicateAtom::RegionOutlives(_) => return None,\n-            _ => {}\n-        }\n-        tcx.sess.delay_span_bug(\n-            obligation.cause.span(tcx),\n-            &format!(\"unexpected predicate {:?} on opaque type\", pred),\n-        );\n-        None\n-    });\n-\n-    let result = tcx.mk_predicates(filtered_predicates);\n-    debug!(\"opaque_type_bounds({}) = {:?}\", tcx.def_path_str(def_id), result);\n-    result\n-}\n-\n-fn item_bounds(tcx: TyCtxt<'_>, def_id: DefId) -> &'_ ty::List<ty::Predicate<'_>> {\n-    match tcx.def_kind(def_id) {\n-        DefKind::AssocTy => associated_type_bounds(tcx, def_id),\n-        DefKind::OpaqueTy => opaque_type_bounds(tcx, def_id),\n-        k => bug!(\"item_bounds called on {}\", k.descr(def_id)),\n-    }\n-}\n-\n pub fn provide(providers: &mut ty::query::Providers) {\n     *providers = ty::query::Providers {\n         asyncness,\n@@ -629,7 +507,6 @@ pub fn provide(providers: &mut ty::query::Providers) {\n         instance_def_size_estimate,\n         issue33140_self_ty,\n         impl_defaultness,\n-        item_bounds,\n         ..*providers\n     };\n }"}, {"sha": "b4ce3ac74e67e752579b430408bdb41cb8be0154", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7ead3bd539e75cb2e881238406a203023f1acd3/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7ead3bd539e75cb2e881238406a203023f1acd3/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=a7ead3bd539e75cb2e881238406a203023f1acd3", "patch": "@@ -50,6 +50,7 @@ use rustc_span::{Span, DUMMY_SP};\n use rustc_target::spec::abi;\n use rustc_trait_selection::traits::error_reporting::suggestions::NextTypeParamName;\n \n+mod item_bounds;\n mod type_of;\n \n struct OnlySelfBounds(bool);\n@@ -68,6 +69,7 @@ pub fn provide(providers: &mut Providers) {\n     *providers = Providers {\n         opt_const_param_of: type_of::opt_const_param_of,\n         type_of: type_of::type_of,\n+        item_bounds: item_bounds::item_bounds,\n         generics_of,\n         predicates_of,\n         predicates_defined_on,"}, {"sha": "c43f830787dba0f36d4405b23e7f890e176a0fe9", "filename": "compiler/rustc_typeck/src/collect/item_bounds.rs", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/a7ead3bd539e75cb2e881238406a203023f1acd3/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Fitem_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7ead3bd539e75cb2e881238406a203023f1acd3/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Fitem_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Fitem_bounds.rs?ref=a7ead3bd539e75cb2e881238406a203023f1acd3", "patch": "@@ -0,0 +1,126 @@\n+use rustc_hir::def::DefKind;\n+use rustc_infer::traits::util;\n+use rustc_middle::ty::subst::InternalSubsts;\n+use rustc_middle::ty::{self, TyCtxt};\n+use rustc_span::def_id::DefId;\n+\n+/// For associated types we allow bounds written on the associated type\n+/// (`type X: Trait`) to be used as candidates. We also allow the same bounds\n+/// when desugared as bounds on the trait `where Self::X: Trait`.\n+///\n+/// Note that this filtering is done with the items identity substs to\n+/// simplify checking that these bounds are met in impls. This means that\n+/// a bound such as `for<'b> <Self as X<'b>>::U: Clone` can't be used, as in\n+/// `hr-associated-type-bound-1.rs`.\n+fn associated_type_bounds(\n+    tcx: TyCtxt<'_>,\n+    assoc_item_def_id: DefId,\n+) -> &'_ ty::List<ty::Predicate<'_>> {\n+    let generic_trait_bounds = tcx.predicates_of(assoc_item_def_id);\n+    // We include predicates from the trait as well to handle\n+    // `where Self::X: Trait`.\n+    let item_bounds = generic_trait_bounds.instantiate_identity(tcx);\n+    let item_predicates = util::elaborate_predicates(tcx, item_bounds.predicates.into_iter());\n+\n+    let assoc_item_ty = ty::ProjectionTy {\n+        item_def_id: assoc_item_def_id,\n+        substs: InternalSubsts::identity_for_item(tcx, assoc_item_def_id),\n+    };\n+\n+    let predicates = item_predicates.filter_map(|obligation| {\n+        let pred = obligation.predicate;\n+        match pred.kind() {\n+            ty::PredicateKind::Trait(tr, _) => {\n+                if let ty::Projection(p) = *tr.skip_binder().self_ty().kind() {\n+                    if p == assoc_item_ty {\n+                        return Some(pred);\n+                    }\n+                }\n+            }\n+            ty::PredicateKind::Projection(proj) => {\n+                if let ty::Projection(p) = *proj.skip_binder().projection_ty.self_ty().kind() {\n+                    if p == assoc_item_ty {\n+                        return Some(pred);\n+                    }\n+                }\n+            }\n+            ty::PredicateKind::TypeOutlives(outlives) => {\n+                if let ty::Projection(p) = *outlives.skip_binder().0.kind() {\n+                    if p == assoc_item_ty {\n+                        return Some(pred);\n+                    }\n+                }\n+            }\n+            _ => {}\n+        }\n+        None\n+    });\n+\n+    let result = tcx.mk_predicates(predicates);\n+    debug!(\"associated_type_bounds({}) = {:?}\", tcx.def_path_str(assoc_item_def_id), result);\n+    result\n+}\n+\n+/// Opaque types don't have the same issues as associated types: the only\n+/// predicates on an opaque type (excluding those it inherits from its parent\n+/// item) should be of the form we're expecting.\n+fn opaque_type_bounds(tcx: TyCtxt<'_>, def_id: DefId) -> &'_ ty::List<ty::Predicate<'_>> {\n+    let substs = InternalSubsts::identity_for_item(tcx, def_id);\n+\n+    let bounds = tcx.predicates_of(def_id);\n+    let predicates =\n+        util::elaborate_predicates(tcx, bounds.predicates.iter().map(|&(pred, _)| pred));\n+\n+    let filtered_predicates = predicates.filter_map(|obligation| {\n+        let pred = obligation.predicate;\n+        match pred.kind() {\n+            ty::PredicateKind::Trait(tr, _) => {\n+                if let ty::Opaque(opaque_def_id, opaque_substs) = *tr.skip_binder().self_ty().kind()\n+                {\n+                    if opaque_def_id == def_id && opaque_substs == substs {\n+                        return Some(pred);\n+                    }\n+                }\n+            }\n+            ty::PredicateKind::Projection(proj) => {\n+                if let ty::Opaque(opaque_def_id, opaque_substs) =\n+                    *proj.skip_binder().projection_ty.self_ty().kind()\n+                {\n+                    if opaque_def_id == def_id && opaque_substs == substs {\n+                        return Some(pred);\n+                    }\n+                }\n+            }\n+            ty::PredicateKind::TypeOutlives(outlives) => {\n+                if let ty::Opaque(opaque_def_id, opaque_substs) = *outlives.skip_binder().0.kind() {\n+                    if opaque_def_id == def_id && opaque_substs == substs {\n+                        return Some(pred);\n+                    }\n+                } else {\n+                    // These can come from elaborating other predicates\n+                    return None;\n+                }\n+            }\n+            // These can come from elaborating other predicates\n+            ty::PredicateKind::RegionOutlives(_) => return None,\n+            _ => {}\n+        }\n+        tcx.sess.delay_span_bug(\n+            obligation.cause.span(tcx),\n+            &format!(\"unexpected predicate {:?} on opaque type\", pred),\n+        );\n+        None\n+    });\n+\n+    let result = tcx.mk_predicates(filtered_predicates);\n+    debug!(\"opaque_type_bounds({}) = {:?}\", tcx.def_path_str(def_id), result);\n+    result\n+}\n+\n+pub(super) fn item_bounds(tcx: TyCtxt<'_>, def_id: DefId) -> &'_ ty::List<ty::Predicate<'_>> {\n+    match tcx.def_kind(def_id) {\n+        DefKind::AssocTy => associated_type_bounds(tcx, def_id),\n+        DefKind::OpaqueTy => opaque_type_bounds(tcx, def_id),\n+        k => bug!(\"item_bounds called on {}\", k.descr(def_id)),\n+    }\n+}"}]}