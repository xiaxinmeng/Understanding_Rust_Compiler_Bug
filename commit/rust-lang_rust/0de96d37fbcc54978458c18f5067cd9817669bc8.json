{"sha": "0de96d37fbcc54978458c18f5067cd9817669bc8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkZTk2ZDM3ZmJjYzU0OTc4NDU4YzE4ZjUwNjdjZDk4MTc2NjliYzg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-19T11:33:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-19T11:33:00Z"}, "message": "Auto merge of #67419 - Centril:rollup-v7b0ypv, r=Centril\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #67189 (Unify binop wording)\n - #67270 (std: Implement `LineWriter::write_vectored`)\n - #67286 (Fix the configure.py TOML field for a couple LLVM options)\n - #67321 (make htons const fn)\n - #67382 (Remove some unnecessary `ATTR_*` constants.)\n - #67389 (Remove `SO_NOSIGPIPE` dummy variable on platforms that don't use it.)\n - #67394 (Remove outdated references to @T from comments)\n - #67406 (Suggest associated type when the specified one cannot be found)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "9fb998a8d7f0d19bc4ad5a7e37ee1fa694e27de6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9fb998a8d7f0d19bc4ad5a7e37ee1fa694e27de6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0de96d37fbcc54978458c18f5067cd9817669bc8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0de96d37fbcc54978458c18f5067cd9817669bc8", "html_url": "https://github.com/rust-lang/rust/commit/0de96d37fbcc54978458c18f5067cd9817669bc8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0de96d37fbcc54978458c18f5067cd9817669bc8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c605199e89572e586a5f37bc698c48b6a10896fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/c605199e89572e586a5f37bc698c48b6a10896fb", "html_url": "https://github.com/rust-lang/rust/commit/c605199e89572e586a5f37bc698c48b6a10896fb"}, {"sha": "06985c68592112ef256eb08140f38a30b602d35c", "url": "https://api.github.com/repos/rust-lang/rust/commits/06985c68592112ef256eb08140f38a30b602d35c", "html_url": "https://github.com/rust-lang/rust/commit/06985c68592112ef256eb08140f38a30b602d35c"}], "stats": {"total": 652, "additions": 435, "deletions": 217}, "files": [{"sha": "7cfc5385e2104987ec773c0e1876f2b1eced09e1", "filename": "src/bootstrap/configure.py", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Fbootstrap%2Fconfigure.py", "raw_url": "https://github.com/rust-lang/rust/raw/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Fbootstrap%2Fconfigure.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfigure.py?ref=0de96d37fbcc54978458c18f5067cd9817669bc8", "patch": "@@ -59,13 +59,13 @@ def v(*args):\n o(\"lld\", \"rust.lld\", \"build lld\")\n o(\"lldb\", \"rust.lldb\", \"build lldb\")\n o(\"missing-tools\", \"dist.missing-tools\", \"allow failures when building tools\")\n-o(\"use-libcxx\", \"llvm.use_libcxx\", \"build LLVM with libc++\")\n+o(\"use-libcxx\", \"llvm.use-libcxx\", \"build LLVM with libc++\")\n \n o(\"cflags\", \"llvm.cflags\", \"build LLVM with these extra compiler flags\")\n o(\"cxxflags\", \"llvm.cxxflags\", \"build LLVM with these extra compiler flags\")\n o(\"ldflags\", \"llvm.ldflags\", \"build LLVM with these extra linker flags\")\n \n-o(\"llvm-libunwind\", \"rust.llvm_libunwind\", \"use LLVM libunwind\")\n+o(\"llvm-libunwind\", \"rust.llvm-libunwind\", \"use LLVM libunwind\")\n \n # Optimization and debugging options. These may be overridden by the release\n # channel, etc."}, {"sha": "cd2e32de9d5c4e438810a48f2d190e5bbdfc0abe", "filename": "src/librustc/ich/mod.rs", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Flibrustc%2Fich%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Flibrustc%2Fich%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fmod.rs?ref=0de96d37fbcc54978458c18f5067cd9817669bc8", "patch": "@@ -12,21 +12,13 @@ mod impls_hir;\n mod impls_ty;\n mod impls_syntax;\n \n-pub const ATTR_DIRTY: Symbol = sym::rustc_dirty;\n-pub const ATTR_CLEAN: Symbol = sym::rustc_clean;\n-pub const ATTR_IF_THIS_CHANGED: Symbol = sym::rustc_if_this_changed;\n-pub const ATTR_THEN_THIS_WOULD_NEED: Symbol = sym::rustc_then_this_would_need;\n-pub const ATTR_PARTITION_REUSED: Symbol = sym::rustc_partition_reused;\n-pub const ATTR_PARTITION_CODEGENED: Symbol = sym::rustc_partition_codegened;\n-pub const ATTR_EXPECTED_CGU_REUSE: Symbol = sym::rustc_expected_cgu_reuse;\n-\n pub const IGNORED_ATTRIBUTES: &[Symbol] = &[\n     sym::cfg,\n-    ATTR_IF_THIS_CHANGED,\n-    ATTR_THEN_THIS_WOULD_NEED,\n-    ATTR_DIRTY,\n-    ATTR_CLEAN,\n-    ATTR_PARTITION_REUSED,\n-    ATTR_PARTITION_CODEGENED,\n-    ATTR_EXPECTED_CGU_REUSE,\n+    sym::rustc_if_this_changed,\n+    sym::rustc_then_this_would_need,\n+    sym::rustc_dirty,\n+    sym::rustc_clean,\n+    sym::rustc_partition_reused,\n+    sym::rustc_partition_codegened,\n+    sym::rustc_expected_cgu_reuse,\n ];"}, {"sha": "e3e3b0b17483ece87a87443462949e2dc2cb3679", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=0de96d37fbcc54978458c18f5067cd9817669bc8", "patch": "@@ -44,11 +44,10 @@ use rustc_data_structures::graph::implementation::{\n };\n use rustc::hir;\n use rustc::hir::intravisit::{self, NestedVisitorMap, Visitor};\n-use rustc::ich::{ATTR_IF_THIS_CHANGED, ATTR_THEN_THIS_WOULD_NEED};\n use std::env;\n use std::fs::{self, File};\n use std::io::Write;\n-use syntax::ast;\n+use syntax::{ast, symbol::sym};\n use syntax_pos::Span;\n \n pub fn assert_dep_graph(tcx: TyCtxt<'_>) {\n@@ -78,7 +77,7 @@ pub fn assert_dep_graph(tcx: TyCtxt<'_>) {\n             assert!(tcx.sess.opts.debugging_opts.query_dep_graph,\n                     \"cannot use the `#[{}]` or `#[{}]` annotations \\\n                     without supplying `-Z query-dep-graph`\",\n-                    ATTR_IF_THIS_CHANGED, ATTR_THEN_THIS_WOULD_NEED);\n+                    sym::rustc_if_this_changed, sym::rustc_then_this_would_need);\n         }\n \n         // Check paths.\n@@ -114,7 +113,7 @@ impl IfThisChanged<'tcx> {\n         let def_id = self.tcx.hir().local_def_id(hir_id);\n         let def_path_hash = self.tcx.def_path_hash(def_id);\n         for attr in attrs {\n-            if attr.check_name(ATTR_IF_THIS_CHANGED) {\n+            if attr.check_name(sym::rustc_if_this_changed) {\n                 let dep_node_interned = self.argument(attr);\n                 let dep_node = match dep_node_interned {\n                     None => def_path_hash.to_dep_node(DepKind::Hir),\n@@ -130,7 +129,7 @@ impl IfThisChanged<'tcx> {\n                     }\n                 };\n                 self.if_this_changed.push((attr.span, def_id, dep_node));\n-            } else if attr.check_name(ATTR_THEN_THIS_WOULD_NEED) {\n+            } else if attr.check_name(sym::rustc_then_this_would_need) {\n                 let dep_node_interned = self.argument(attr);\n                 let dep_node = match dep_node_interned {\n                     Some(n) => {"}, {"sha": "1a675ea002cda1cabc93a833bcf8046319ea5c61", "filename": "src/librustc_incremental/assert_module_sources.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_module_sources.rs?ref=0de96d37fbcc54978458c18f5067cd9817669bc8", "patch": "@@ -28,8 +28,6 @@ use rustc::ty::TyCtxt;\n use std::collections::BTreeSet;\n use syntax::ast;\n use syntax::symbol::{Symbol, sym};\n-use rustc::ich::{ATTR_PARTITION_REUSED, ATTR_PARTITION_CODEGENED,\n-                 ATTR_EXPECTED_CGU_REUSE};\n \n pub fn assert_module_sources(tcx: TyCtxt<'_>) {\n     tcx.dep_graph.with_ignore(|| {\n@@ -62,11 +60,11 @@ struct AssertModuleSource<'tcx> {\n \n impl AssertModuleSource<'tcx> {\n     fn check_attr(&self, attr: &ast::Attribute) {\n-        let (expected_reuse, comp_kind) = if attr.check_name(ATTR_PARTITION_REUSED) {\n+        let (expected_reuse, comp_kind) = if attr.check_name(sym::rustc_partition_reused) {\n             (CguReuse::PreLto, ComparisonKind::AtLeast)\n-        } else if attr.check_name(ATTR_PARTITION_CODEGENED) {\n+        } else if attr.check_name(sym::rustc_partition_codegened) {\n             (CguReuse::No, ComparisonKind::Exact)\n-        } else if attr.check_name(ATTR_EXPECTED_CGU_REUSE) {\n+        } else if attr.check_name(sym::rustc_expected_cgu_reuse) {\n             match &*self.field(attr, sym::kind).as_str() {\n                 \"no\" => (CguReuse::No, ComparisonKind::Exact),\n                 \"pre-lto\" => (CguReuse::PreLto, ComparisonKind::Exact),"}, {"sha": "c919db070a6bb422087198aee8b4319ea07c2d7b", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=0de96d37fbcc54978458c18f5067cd9817669bc8", "patch": "@@ -22,7 +22,6 @@ use rustc::hir::Node as HirNode;\n use rustc::hir::def_id::DefId;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::intravisit;\n-use rustc::ich::{ATTR_DIRTY, ATTR_CLEAN};\n use rustc::ty::TyCtxt;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashSet;\n@@ -224,7 +223,7 @@ pub fn check_dirty_clean_annotations(tcx: TyCtxt<'_>) {\n \n         let mut all_attrs = FindAllAttrs {\n             tcx,\n-            attr_names: vec![ATTR_DIRTY, ATTR_CLEAN],\n+            attr_names: vec![sym::rustc_dirty, sym::rustc_clean],\n             found_attrs: vec![],\n         };\n         intravisit::walk_crate(&mut all_attrs, krate);\n@@ -246,9 +245,9 @@ impl DirtyCleanVisitor<'tcx> {\n     fn assertion_maybe(&mut self, item_id: hir::HirId, attr: &Attribute)\n         -> Option<Assertion>\n     {\n-        let is_clean = if attr.check_name(ATTR_DIRTY) {\n+        let is_clean = if attr.check_name(sym::rustc_dirty) {\n             false\n-        } else if attr.check_name(ATTR_CLEAN) {\n+        } else if attr.check_name(sym::rustc_clean) {\n             true\n         } else {\n             // skip: not rustc_clean/dirty"}, {"sha": "290f86d626e6cbf948b4fdbb1ca0f5760bacdc3a", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 72, "deletions": 31, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=0de96d37fbcc54978458c18f5067cd9817669bc8", "patch": "@@ -1145,11 +1145,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         } else {\n             // Otherwise, we have to walk through the supertraits to find\n             // those that do.\n-            let candidates = traits::supertraits(tcx, trait_ref).filter(|r| {\n-                self.trait_defines_associated_type_named(r.def_id(), binding.item_name)\n-            });\n             self.one_bound_for_assoc_type(\n-                candidates,\n+                || traits::supertraits(tcx, trait_ref),\n                 &trait_ref.print_only_trait_path().to_string(),\n                 binding.item_name,\n                 binding.span\n@@ -1531,50 +1528,48 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         debug!(\"find_bound_for_assoc_item: predicates={:#?}\", predicates);\n \n-        let bounds = predicates.iter().filter_map(|(p, _)| p.to_opt_poly_trait_ref());\n-\n-        // Check that there is exactly one way to find an associated type with the\n-        // correct name.\n-        let suitable_bounds = traits::transitive_bounds(tcx, bounds)\n-            .filter(|b| self.trait_defines_associated_type_named(b.def_id(), assoc_name));\n-\n         let param_hir_id = tcx.hir().as_local_hir_id(ty_param_def_id).unwrap();\n         let param_name = tcx.hir().ty_param_name(param_hir_id);\n-        self.one_bound_for_assoc_type(suitable_bounds,\n-                                      &param_name.as_str(),\n-                                      assoc_name,\n-                                      span)\n+        self.one_bound_for_assoc_type(\n+            || traits::transitive_bounds(tcx, predicates\n+                .iter().filter_map(|(p, _)| p.to_opt_poly_trait_ref())),\n+            &param_name.as_str(),\n+            assoc_name,\n+            span,\n+        )\n     }\n \n-    // Checks that `bounds` contains exactly one element and reports appropriate\n-    // errors otherwise.\n     fn one_bound_for_assoc_type<I>(&self,\n-                                   mut bounds: I,\n+                                   all_candidates: impl Fn() -> I,\n                                    ty_param_name: &str,\n                                    assoc_name: ast::Ident,\n                                    span: Span)\n         -> Result<ty::PolyTraitRef<'tcx>, ErrorReported>\n         where I: Iterator<Item = ty::PolyTraitRef<'tcx>>\n     {\n-        let bound = match bounds.next() {\n+        let mut matching_candidates = all_candidates().filter(|r| {\n+            self.trait_defines_associated_type_named(r.def_id(), assoc_name)\n+        });\n+\n+        let bound = match matching_candidates.next() {\n             Some(bound) => bound,\n             None => {\n-                struct_span_err!(self.tcx().sess, span, E0220,\n-                                 \"associated type `{}` not found for `{}`\",\n-                                 assoc_name,\n-                                 ty_param_name)\n-                    .span_label(span, format!(\"associated type `{}` not found\", assoc_name))\n-                    .emit();\n+                self.complain_about_assoc_type_not_found(\n+                    all_candidates,\n+                    ty_param_name,\n+                    assoc_name,\n+                    span\n+                );\n                 return Err(ErrorReported);\n             }\n         };\n \n         debug!(\"one_bound_for_assoc_type: bound = {:?}\", bound);\n \n-        if let Some(bound2) = bounds.next() {\n+        if let Some(bound2) = matching_candidates.next() {\n             debug!(\"one_bound_for_assoc_type: bound2 = {:?}\", bound2);\n \n-            let bounds = iter::once(bound).chain(iter::once(bound2)).chain(bounds);\n+            let bounds = iter::once(bound).chain(iter::once(bound2)).chain(matching_candidates);\n             let mut err = struct_span_err!(\n                 self.tcx().sess, span, E0221,\n                 \"ambiguous associated type `{}` in bounds of `{}`\",\n@@ -1606,6 +1601,50 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         return Ok(bound);\n     }\n \n+    fn complain_about_assoc_type_not_found<I>(&self,\n+                                              all_candidates: impl Fn() -> I,\n+                                              ty_param_name: &str,\n+                                              assoc_name: ast::Ident,\n+                                              span: Span)\n+    where I: Iterator<Item = ty::PolyTraitRef<'tcx>> {\n+        let mut err = struct_span_err!(self.tcx().sess, span, E0220,\n+                                 \"associated type `{}` not found for `{}`\",\n+                                 assoc_name,\n+                                 ty_param_name);\n+\n+        let all_candidate_names: Vec<_> = all_candidates()\n+            .map(|r| self.tcx().associated_items(r.def_id()))\n+            .flatten()\n+            .filter_map(|item|\n+                if item.kind == ty::AssocKind::Type {\n+                    Some(item.ident.name)\n+                } else {\n+                    None\n+                }\n+            )\n+            .collect();\n+\n+        if let Some(suggested_name) = find_best_match_for_name(\n+            all_candidate_names.iter(),\n+            &assoc_name.as_str(),\n+            None,\n+        ) {\n+            err.span_suggestion(\n+                span,\n+                \"there is an associated type with a similar name\",\n+                suggested_name.to_string(),\n+                Applicability::MaybeIncorrect,\n+            );\n+        } else {\n+            err.span_label(\n+                span,\n+                format!(\"associated type `{}` not found\", assoc_name)\n+            );\n+        }\n+\n+        err.emit();\n+    }\n+\n     // Create a type from a path to an associated type.\n     // For a path `A::B::C::D`, `qself_ty` and `qself_def` are the type and def for `A::B::C`\n     // and item_segment is the path segment for `D`. We return a type and a def for\n@@ -1660,10 +1699,12 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     }\n                 };\n \n-                let candidates = traits::supertraits(tcx, ty::Binder::bind(trait_ref))\n-                    .filter(|r| self.trait_defines_associated_type_named(r.def_id(), assoc_ident));\n-\n-                self.one_bound_for_assoc_type(candidates, \"Self\", assoc_ident, span)?\n+                self.one_bound_for_assoc_type(\n+                    || traits::supertraits(tcx, ty::Binder::bind(trait_ref)),\n+                    \"Self\",\n+                    assoc_ident,\n+                    span\n+                )?\n             }\n             (&ty::Param(_), Res::SelfTy(Some(param_did), None)) |\n             (&ty::Param(_), Res::Def(DefKind::TyParam, param_did)) => {"}, {"sha": "4f20a91e4b0136b227c267561d8af59f42ae47df", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 63, "deletions": 22, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=0de96d37fbcc54978458c18f5067cd9817669bc8", "patch": "@@ -334,10 +334,70 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             err.emit();\n                         }\n                         IsAssign::No => {\n+                            let (message, missing_trait) = match op.node {\n+                                hir::BinOpKind::Add    => {\n+                                    (format!(\"cannot add `{}` to `{}`\", rhs_ty, lhs_ty),\n+                                    Some(\"std::ops::Add\"))\n+                                },\n+                                hir::BinOpKind::Sub    => {\n+                                    (format!(\"cannot substract `{}` from `{}`\", rhs_ty, lhs_ty),\n+                                    Some(\"std::ops::Sub\"))\n+                                },\n+                                hir::BinOpKind::Mul    => {\n+                                    (format!(\"cannot multiply `{}` to `{}`\", rhs_ty, lhs_ty),\n+                                    Some(\"std::ops::Mul\"))\n+                                },\n+                                hir::BinOpKind::Div    => {\n+                                    (format!(\"cannot divide `{}` by `{}`\", lhs_ty, rhs_ty),\n+                                    Some(\"std::ops::Div\"))\n+                                },\n+                                hir::BinOpKind::Rem    => {\n+                                    (format!(\"cannot mod `{}` by `{}`\", lhs_ty, rhs_ty),\n+                                    Some(\"std::ops::Rem\"))\n+                                },\n+                                hir::BinOpKind::BitAnd => {\n+                                    (format!(\"no implementation for `{} & {}`\", lhs_ty, rhs_ty),\n+                                    Some(\"std::ops::BitAnd\"))\n+                                },\n+                                hir::BinOpKind::BitXor => {\n+                                    (format!(\"no implementation for `{} ^ {}`\", lhs_ty, rhs_ty),\n+                                    Some(\"std::ops::BitXor\"))\n+                                },\n+                                hir::BinOpKind::BitOr  => {\n+                                    (format!(\"no implementation for `{} | {}`\", lhs_ty, rhs_ty),\n+                                    Some(\"std::ops::BitOr\"))\n+                                },\n+                                hir::BinOpKind::Shl    => {\n+                                    (format!(\"no implementation for `{} << {}`\", lhs_ty, rhs_ty),\n+                                    Some(\"std::ops::Shl\"))\n+                                },\n+                                hir::BinOpKind::Shr    => {\n+                                    (format!(\"no implementation for `{} >> {}`\", lhs_ty, rhs_ty),\n+                                    Some(\"std::ops::Shr\"))\n+                                },\n+                                hir::BinOpKind::Eq |\n+                                hir::BinOpKind::Ne     => {\n+                                    (format!(\n+                                            \"binary operation `{}` cannot be applied to type `{}`\",\n+                                            op.node.as_str(), lhs_ty),\n+                                    Some(\"std::cmp::PartialEq\"))\n+                                },\n+                                hir::BinOpKind::Lt |\n+                                hir::BinOpKind::Le |\n+                                hir::BinOpKind::Gt |\n+                                hir::BinOpKind::Ge     => {\n+                                    (format!(\n+                                            \"binary operation `{}` cannot be applied to type `{}`\",\n+                                            op.node.as_str(), lhs_ty),\n+                                    Some(\"std::cmp::PartialOrd\"))\n+                                }\n+                                _ => (format!(\n+                                        \"binary operation `{}` cannot be applied to type `{}`\",\n+                                        op.node.as_str(), lhs_ty),\n+                                    None)\n+                            };\n                             let mut err = struct_span_err!(self.tcx.sess, op.span, E0369,\n-                                \"binary operation `{}` cannot be applied to type `{}`\",\n-                                op.node.as_str(),\n-                                lhs_ty);\n+                                \"{}\", message.as_str());\n \n                             let mut involves_fn = false;\n                             if !lhs_expr.span.eq(&rhs_expr.span) {\n@@ -382,25 +442,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     }\n                                 }\n                             }\n-                            let missing_trait = match op.node {\n-                                hir::BinOpKind::Add    => Some(\"std::ops::Add\"),\n-                                hir::BinOpKind::Sub    => Some(\"std::ops::Sub\"),\n-                                hir::BinOpKind::Mul    => Some(\"std::ops::Mul\"),\n-                                hir::BinOpKind::Div    => Some(\"std::ops::Div\"),\n-                                hir::BinOpKind::Rem    => Some(\"std::ops::Rem\"),\n-                                hir::BinOpKind::BitAnd => Some(\"std::ops::BitAnd\"),\n-                                hir::BinOpKind::BitXor => Some(\"std::ops::BitXor\"),\n-                                hir::BinOpKind::BitOr  => Some(\"std::ops::BitOr\"),\n-                                hir::BinOpKind::Shl    => Some(\"std::ops::Shl\"),\n-                                hir::BinOpKind::Shr    => Some(\"std::ops::Shr\"),\n-                                hir::BinOpKind::Eq |\n-                                hir::BinOpKind::Ne => Some(\"std::cmp::PartialEq\"),\n-                                hir::BinOpKind::Lt |\n-                                hir::BinOpKind::Le |\n-                                hir::BinOpKind::Gt |\n-                                hir::BinOpKind::Ge => Some(\"std::cmp::PartialOrd\"),\n-                                _ => None\n-                            };\n                             if let Some(missing_trait) = missing_trait {\n                                 if op.node == hir::BinOpKind::Add &&\n                                     self.check_str_addition("}, {"sha": "df259dc2f56d7cf9587dec57160da47a99d1fb48", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 171, "deletions": 1, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=0de96d37fbcc54978458c18f5067cd9817669bc8", "patch": "@@ -989,6 +989,68 @@ impl<W: Write> Write for LineWriter<W> {\n         }\n     }\n \n+    // Vectored writes are very similar to the writes above, but adjusted for\n+    // the list of buffers that we have to write.\n+    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n+        if self.need_flush {\n+            self.flush()?;\n+        }\n+\n+        // Find the last newline, and failing that write the whole buffer\n+        let last_newline = bufs\n+            .iter()\n+            .enumerate()\n+            .rev()\n+            .filter_map(|(i, buf)| {\n+                let pos = memchr::memrchr(b'\\n', buf)?;\n+                Some((i, pos))\n+            })\n+            .next();\n+        let (i, j) = match last_newline {\n+            Some(pair) => pair,\n+            None => return self.inner.write_vectored(bufs),\n+        };\n+        let (prefix, suffix) = bufs.split_at(i);\n+        let (buf, suffix) = suffix.split_at(1);\n+        let buf = &buf[0];\n+\n+        // Write everything up to the last newline, flushing afterwards. Note\n+        // that only if we finished our entire `write_vectored` do we try the\n+        // subsequent\n+        // `write`\n+        let mut n = 0;\n+        let prefix_amt = prefix.iter().map(|i| i.len()).sum();\n+        if prefix_amt > 0 {\n+            n += self.inner.write_vectored(prefix)?;\n+            self.need_flush = true;\n+        }\n+        if n == prefix_amt {\n+            match self.inner.write(&buf[..=j]) {\n+                Ok(m) => n += m,\n+                Err(e) if n == 0 => return Err(e),\n+                Err(_) => return Ok(n),\n+            }\n+            self.need_flush = true;\n+        }\n+        if self.flush().is_err() || n != j + 1 + prefix_amt {\n+            return Ok(n);\n+        }\n+\n+        // ... and now write out everything remaining\n+        match self.inner.write(&buf[j + 1..]) {\n+            Ok(i) => n += i,\n+            Err(_) => return Ok(n),\n+        }\n+\n+        if suffix.iter().map(|s| s.len()).sum::<usize>() == 0 {\n+            return Ok(n)\n+        }\n+        match self.inner.write_vectored(suffix) {\n+            Ok(i) => Ok(n + i),\n+            Err(_) => Ok(n),\n+        }\n+    }\n+\n     fn flush(&mut self) -> io::Result<()> {\n         self.inner.flush()?;\n         self.need_flush = false;\n@@ -1015,7 +1077,7 @@ where\n #[cfg(test)]\n mod tests {\n     use crate::io::prelude::*;\n-    use crate::io::{self, BufReader, BufWriter, LineWriter, SeekFrom};\n+    use crate::io::{self, BufReader, BufWriter, LineWriter, SeekFrom, IoSlice};\n     use crate::sync::atomic::{AtomicUsize, Ordering};\n     use crate::thread;\n \n@@ -1483,4 +1545,112 @@ mod tests {\n \n         assert_eq!(l.write(b\"a\").unwrap_err().kind(), io::ErrorKind::Other)\n     }\n+\n+    #[test]\n+    fn line_vectored() {\n+        let mut a = LineWriter::new(Vec::new());\n+        assert_eq!(\n+            a.write_vectored(&[\n+                IoSlice::new(&[]),\n+                IoSlice::new(b\"\\n\"),\n+                IoSlice::new(&[]),\n+                IoSlice::new(b\"a\"),\n+            ])\n+            .unwrap(),\n+            2,\n+        );\n+        assert_eq!(a.get_ref(), b\"\\n\");\n+\n+        assert_eq!(\n+            a.write_vectored(&[\n+                IoSlice::new(&[]),\n+                IoSlice::new(b\"b\"),\n+                IoSlice::new(&[]),\n+                IoSlice::new(b\"a\"),\n+                IoSlice::new(&[]),\n+                IoSlice::new(b\"c\"),\n+            ])\n+            .unwrap(),\n+            3,\n+        );\n+        assert_eq!(a.get_ref(), b\"\\n\");\n+        a.flush().unwrap();\n+        assert_eq!(a.get_ref(), b\"\\nabac\");\n+        assert_eq!(a.write_vectored(&[]).unwrap(), 0);\n+        assert_eq!(\n+            a.write_vectored(&[\n+                IoSlice::new(&[]),\n+                IoSlice::new(&[]),\n+                IoSlice::new(&[]),\n+                IoSlice::new(&[]),\n+            ])\n+            .unwrap(),\n+            0,\n+        );\n+        assert_eq!(a.write_vectored(&[IoSlice::new(b\"a\\nb\"),]).unwrap(), 3);\n+        assert_eq!(a.get_ref(), b\"\\nabaca\\n\");\n+    }\n+\n+    #[test]\n+    fn line_vectored_partial_and_errors() {\n+        enum Call {\n+            Write { inputs: Vec<&'static [u8]>, output: io::Result<usize> },\n+            Flush { output: io::Result<()> },\n+        }\n+        struct Writer {\n+            calls: Vec<Call>,\n+        }\n+\n+        impl Write for Writer {\n+            fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+                self.write_vectored(&[IoSlice::new(buf)])\n+            }\n+\n+            fn write_vectored(&mut self, buf: &[IoSlice<'_>]) -> io::Result<usize> {\n+                match self.calls.pop().unwrap() {\n+                    Call::Write { inputs, output } => {\n+                        assert_eq!(inputs, buf.iter().map(|b| &**b).collect::<Vec<_>>());\n+                        output\n+                    }\n+                    _ => panic!(\"unexpected call to write\"),\n+                }\n+            }\n+\n+            fn flush(&mut self) -> io::Result<()> {\n+                match self.calls.pop().unwrap() {\n+                    Call::Flush { output } => output,\n+                    _ => panic!(\"unexpected call to flush\"),\n+                }\n+            }\n+        }\n+\n+        impl Drop for Writer {\n+            fn drop(&mut self) {\n+                if !thread::panicking() {\n+                    assert_eq!(self.calls.len(), 0);\n+                }\n+            }\n+        }\n+\n+        // partial writes keep going\n+        let mut a = LineWriter::new(Writer { calls: Vec::new() });\n+        a.write_vectored(&[IoSlice::new(&[]), IoSlice::new(b\"abc\")]).unwrap();\n+        a.get_mut().calls.push(Call::Flush { output: Ok(()) });\n+        a.get_mut().calls.push(Call::Write { inputs: vec![b\"bcx\\n\"], output: Ok(4) });\n+        a.get_mut().calls.push(Call::Write { inputs: vec![b\"abcx\\n\"], output: Ok(1) });\n+        a.write_vectored(&[IoSlice::new(b\"x\"), IoSlice::new(b\"\\n\")]).unwrap();\n+        a.get_mut().calls.push(Call::Flush { output: Ok(()) });\n+        a.flush().unwrap();\n+\n+        // erroneous writes stop and don't write more\n+        a.get_mut().calls.push(Call::Write { inputs: vec![b\"x\\n\"], output: Err(err()) });\n+        assert_eq!(a.write_vectored(&[IoSlice::new(b\"x\"), IoSlice::new(b\"\\na\")]).unwrap(), 2);\n+        a.get_mut().calls.push(Call::Flush { output: Ok(()) });\n+        a.get_mut().calls.push(Call::Write { inputs: vec![b\"x\\n\"], output: Ok(2) });\n+        a.flush().unwrap();\n+\n+        fn err() -> io::Error {\n+            io::Error::new(io::ErrorKind::Other, \"x\")\n+        }\n+    }\n }"}, {"sha": "a9d88370c612fa1afa826b9510e0e536162b125f", "filename": "src/libstd/net/addr.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Flibstd%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Flibstd%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Faddr.rs?ref=0de96d37fbcc54978458c18f5067cd9817669bc8", "patch": "@@ -4,7 +4,7 @@ use crate::hash;\n use crate::io;\n use crate::iter;\n use crate::mem;\n-use crate::net::{hton, ntoh, IpAddr, Ipv4Addr, Ipv6Addr};\n+use crate::net::{htons, ntohs, IpAddr, Ipv4Addr, Ipv6Addr};\n use crate::option;\n use crate::slice;\n use crate::sys::net::netc as c;\n@@ -276,7 +276,7 @@ impl SocketAddrV4 {\n         SocketAddrV4 {\n             inner: c::sockaddr_in {\n                 sin_family: c::AF_INET as c::sa_family_t,\n-                sin_port: hton(port),\n+                sin_port: htons(port),\n                 sin_addr: *ip.as_inner(),\n                 ..unsafe { mem::zeroed() }\n             },\n@@ -326,7 +326,7 @@ impl SocketAddrV4 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn port(&self) -> u16 {\n-        ntoh(self.inner.sin_port)\n+        ntohs(self.inner.sin_port)\n     }\n \n     /// Changes the port number associated with this socket address.\n@@ -342,7 +342,7 @@ impl SocketAddrV4 {\n     /// ```\n     #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n     pub fn set_port(&mut self, new_port: u16) {\n-        self.inner.sin_port = hton(new_port);\n+        self.inner.sin_port = htons(new_port);\n     }\n }\n \n@@ -368,7 +368,7 @@ impl SocketAddrV6 {\n         SocketAddrV6 {\n             inner: c::sockaddr_in6 {\n                 sin6_family: c::AF_INET6 as c::sa_family_t,\n-                sin6_port: hton(port),\n+                sin6_port: htons(port),\n                 sin6_addr: *ip.as_inner(),\n                 sin6_flowinfo: flowinfo,\n                 sin6_scope_id: scope_id,\n@@ -420,7 +420,7 @@ impl SocketAddrV6 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn port(&self) -> u16 {\n-        ntoh(self.inner.sin6_port)\n+        ntohs(self.inner.sin6_port)\n     }\n \n     /// Changes the port number associated with this socket address.\n@@ -436,7 +436,7 @@ impl SocketAddrV6 {\n     /// ```\n     #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n     pub fn set_port(&mut self, new_port: u16) {\n-        self.inner.sin6_port = hton(new_port);\n+        self.inner.sin6_port = htons(new_port);\n     }\n \n     /// Returns the flow information associated with this address."}, {"sha": "8652ed8b046bbee60d9f12b016df7baad6a50c30", "filename": "src/libstd/net/mod.rs", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Flibstd%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Flibstd%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fmod.rs?ref=0de96d37fbcc54978458c18f5067cd9817669bc8", "patch": "@@ -85,21 +85,10 @@ pub enum Shutdown {\n     Both,\n }\n \n-#[doc(hidden)]\n-trait NetInt {\n-    fn from_be(i: Self) -> Self;\n-    fn to_be(&self) -> Self;\n-}\n-macro_rules! doit {\n-    ($($t:ident)*) => ($(impl NetInt for $t {\n-        fn from_be(i: Self) -> Self { <$t>::from_be(i) }\n-        fn to_be(&self) -> Self { <$t>::to_be(*self) }\n-    })*)\n-}\n-doit! { i8 i16 i32 i64 isize u8 u16 u32 u64 usize }\n-\n-fn hton<I: NetInt>(i: I) -> I { i.to_be() }\n-fn ntoh<I: NetInt>(i: I) -> I { I::from_be(i) }\n+#[inline]\n+const fn htons(i: u16) -> u16 { i.to_be() }\n+#[inline]\n+const fn ntohs(i: u16) -> u16 { u16::from_be(i) }\n \n fn each_addr<A: ToSocketAddrs, F, T>(addr: A, mut f: F) -> io::Result<T>\n     where F: FnMut(io::Result<&SocketAddr>) -> io::Result<T>"}, {"sha": "5d101ed1f2e2bc84efee1bd110319d59408be2c0", "filename": "src/libstd/sys/unix/net.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fnet.rs?ref=0de96d37fbcc54978458c18f5067cd9817669bc8", "patch": "@@ -28,14 +28,6 @@ use libc::SOCK_CLOEXEC;\n #[cfg(not(target_os = \"linux\"))]\n const SOCK_CLOEXEC: c_int = 0;\n \n-// Another conditional constant for name resolution: Macos et iOS use\n-// SO_NOSIGPIPE as a setsockopt flag to disable SIGPIPE emission on socket.\n-// Other platforms do otherwise.\n-#[cfg(target_vendor = \"apple\")]\n-use libc::SO_NOSIGPIPE;\n-#[cfg(not(target_vendor = \"apple\"))]\n-const SO_NOSIGPIPE: c_int = 0;\n-\n pub struct Socket(FileDesc);\n \n pub fn init() {}\n@@ -89,9 +81,12 @@ impl Socket {\n             let fd = FileDesc::new(fd);\n             fd.set_cloexec()?;\n             let socket = Socket(fd);\n-            if cfg!(target_vendor = \"apple\") {\n-                setsockopt(&socket, libc::SOL_SOCKET, SO_NOSIGPIPE, 1)?;\n-            }\n+\n+            // macOS and iOS use `SO_NOSIGPIPE` as a `setsockopt`\n+            // flag to disable `SIGPIPE` emission on socket.\n+            #[cfg(target_vendor = \"apple\")]\n+            setsockopt(&socket, libc::SOL_SOCKET, libc::SO_NOSIGPIPE, 1)?;\n+\n             Ok(socket)\n         }\n     }"}, {"sha": "54466ff2c2e07851ae3c2bc4e0cb4940d649cd06", "filename": "src/libstd/sys/vxworks/net.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Flibstd%2Fsys%2Fvxworks%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Flibstd%2Fsys%2Fvxworks%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fnet.rs?ref=0de96d37fbcc54978458c18f5067cd9817669bc8", "patch": "@@ -19,7 +19,6 @@ pub extern crate libc as netc;\n pub type wrlen_t = size_t;\n \n const SOCK_CLOEXEC: c_int = 0;\n-const SO_NOSIGPIPE: c_int = 0;\n \n pub struct Socket(FileDesc);\n "}, {"sha": "e75cc8b1756d15cbac9260e0ee2066cedad00ebc", "filename": "src/libsyntax/ptr.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Flibsyntax%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Flibsyntax%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fptr.rs?ref=0de96d37fbcc54978458c18f5067cd9817669bc8", "patch": "@@ -1,17 +1,12 @@\n //! The AST pointer.\n //!\n-//! Provides `P<T>`, a frozen owned smart pointer, as a replacement for `@T` in\n-//! the AST.\n+//! Provides `P<T>`, a frozen owned smart pointer.\n //!\n //! # Motivations and benefits\n //!\n //! * **Identity**: sharing AST nodes is problematic for the various analysis\n //!   passes (e.g., one may be able to bypass the borrow checker with a shared\n-//!   `ExprKind::AddrOf` node taking a mutable borrow). The only reason `@T` in the\n-//!   AST hasn't caused issues is because of inefficient folding passes which\n-//!   would always deduplicate any such shared nodes. Even if the AST were to\n-//!   switch to an arena, this would still hold, i.e., it couldn't use `&'a T`,\n-//!   but rather a wrapper like `P<'a, T>`.\n+//!   `ExprKind::AddrOf` node taking a mutable borrow).\n //!\n //! * **Immutability**: `P<T>` disallows mutating its inner `T`, unlike `Box<T>`\n //!   (unless it contains an `Unsafe` interior, but that may be denied later)."}, {"sha": "4bef1012e33deb8895c125f6ccb0a7d840fc56da", "filename": "src/test/ui/autoderef-full-lval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fautoderef-full-lval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fautoderef-full-lval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fautoderef-full-lval.rs?ref=0de96d37fbcc54978458c18f5067cd9817669bc8", "patch": "@@ -13,13 +13,13 @@ fn main() {\n     let a: Clam = Clam{x: box 1, y: box 2};\n     let b: Clam = Clam{x: box 10, y: box 20};\n     let z: isize = a.x + b.y;\n-    //~^ ERROR binary operation `+` cannot be applied to type `std::boxed::Box<isize>`\n+    //~^ ERROR cannot add `std::boxed::Box<isize>` to `std::boxed::Box<isize>`\n     println!(\"{}\", z);\n     assert_eq!(z, 21);\n     let forty: Fish = Fish{a: box 40};\n     let two: Fish = Fish{a: box 2};\n     let answer: isize = forty.a + two.a;\n-    //~^ ERROR binary operation `+` cannot be applied to type `std::boxed::Box<isize>`\n+    //~^ ERROR cannot add `std::boxed::Box<isize>` to `std::boxed::Box<isize>`\n     println!(\"{}\", answer);\n     assert_eq!(answer, 42);\n }"}, {"sha": "e2870ef8062d36be12d5b5febaa76697afe0d203", "filename": "src/test/ui/autoderef-full-lval.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fautoderef-full-lval.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fautoderef-full-lval.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fautoderef-full-lval.stderr?ref=0de96d37fbcc54978458c18f5067cd9817669bc8", "patch": "@@ -1,4 +1,4 @@\n-error[E0369]: binary operation `+` cannot be applied to type `std::boxed::Box<isize>`\n+error[E0369]: cannot add `std::boxed::Box<isize>` to `std::boxed::Box<isize>`\n   --> $DIR/autoderef-full-lval.rs:15:24\n    |\n LL |     let z: isize = a.x + b.y;\n@@ -8,7 +8,7 @@ LL |     let z: isize = a.x + b.y;\n    |\n    = note: an implementation of `std::ops::Add` might be missing for `std::boxed::Box<isize>`\n \n-error[E0369]: binary operation `+` cannot be applied to type `std::boxed::Box<isize>`\n+error[E0369]: cannot add `std::boxed::Box<isize>` to `std::boxed::Box<isize>`\n   --> $DIR/autoderef-full-lval.rs:21:33\n    |\n LL |     let answer: isize = forty.a + two.a;"}, {"sha": "67e01b9327db1ec904673ca293afe7cfffb6daa3", "filename": "src/test/ui/binary-op-on-double-ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fbinary-op-on-double-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fbinary-op-on-double-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinary-op-on-double-ref.rs?ref=0de96d37fbcc54978458c18f5067cd9817669bc8", "patch": "@@ -2,7 +2,7 @@ fn main() {\n     let v = vec![1, 2, 3, 4, 5, 6, 7, 8, 9];\n     let vr = v.iter().filter(|x| {\n         x % 2 == 0\n-        //~^ ERROR binary operation `%` cannot be applied to type `&&{integer}`\n+        //~^ ERROR cannot mod `&&{integer}` by `{integer}`\n     });\n     println!(\"{:?}\", vr);\n }"}, {"sha": "6c405333ec681e06f95ca1f7ce65e7bc75cf988b", "filename": "src/test/ui/binary-op-on-double-ref.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fbinary-op-on-double-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fbinary-op-on-double-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinary-op-on-double-ref.stderr?ref=0de96d37fbcc54978458c18f5067cd9817669bc8", "patch": "@@ -1,4 +1,4 @@\n-error[E0369]: binary operation `%` cannot be applied to type `&&{integer}`\n+error[E0369]: cannot mod `&&{integer}` by `{integer}`\n   --> $DIR/binary-op-on-double-ref.rs:4:11\n    |\n LL |         x % 2 == 0"}, {"sha": "e98ea4df97defc71fe5dee49a36e714823fd30bf", "filename": "src/test/ui/binop/binop-bitxor-str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fbinop%2Fbinop-bitxor-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fbinop%2Fbinop-bitxor-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinop%2Fbinop-bitxor-str.rs?ref=0de96d37fbcc54978458c18f5067cd9817669bc8", "patch": "@@ -1,3 +1,3 @@\n-// error-pattern:`^` cannot be applied to type `std::string::String`\n+// error-pattern:no implementation for `std::string::String ^ std::string::String`\n \n fn main() { let x = \"a\".to_string() ^ \"b\".to_string(); }"}, {"sha": "9a0d301d86356e0911a30975e0a5c1c408bc96e9", "filename": "src/test/ui/binop/binop-bitxor-str.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fbinop%2Fbinop-bitxor-str.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fbinop%2Fbinop-bitxor-str.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinop%2Fbinop-bitxor-str.stderr?ref=0de96d37fbcc54978458c18f5067cd9817669bc8", "patch": "@@ -1,4 +1,4 @@\n-error[E0369]: binary operation `^` cannot be applied to type `std::string::String`\n+error[E0369]: no implementation for `std::string::String ^ std::string::String`\n   --> $DIR/binop-bitxor-str.rs:3:37\n    |\n LL | fn main() { let x = \"a\".to_string() ^ \"b\".to_string(); }"}, {"sha": "27b2f8bb3ff3009ba6c55c705b7cc8ccb58f8a45", "filename": "src/test/ui/binop/binop-mul-bool.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fbinop%2Fbinop-mul-bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fbinop%2Fbinop-mul-bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinop%2Fbinop-mul-bool.rs?ref=0de96d37fbcc54978458c18f5067cd9817669bc8", "patch": "@@ -1,3 +1,3 @@\n-// error-pattern:`*` cannot be applied to type `bool`\n+// error-pattern:cannot multiply `bool` to `bool`\n \n fn main() { let x = true * false; }"}, {"sha": "ade220255893402315547b415f721f48b398e138", "filename": "src/test/ui/binop/binop-mul-bool.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fbinop%2Fbinop-mul-bool.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fbinop%2Fbinop-mul-bool.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinop%2Fbinop-mul-bool.stderr?ref=0de96d37fbcc54978458c18f5067cd9817669bc8", "patch": "@@ -1,4 +1,4 @@\n-error[E0369]: binary operation `*` cannot be applied to type `bool`\n+error[E0369]: cannot multiply `bool` to `bool`\n   --> $DIR/binop-mul-bool.rs:3:26\n    |\n LL | fn main() { let x = true * false; }"}, {"sha": "812fe95db4e57dcf045135cb6e144ca38058277c", "filename": "src/test/ui/binop/binop-typeck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fbinop%2Fbinop-typeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fbinop%2Fbinop-typeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinop%2Fbinop-typeck.rs?ref=0de96d37fbcc54978458c18f5067cd9817669bc8", "patch": "@@ -4,5 +4,5 @@ fn main() {\n     let x = true;\n     let y = 1;\n     let z = x + y;\n-    //~^ ERROR binary operation `+` cannot be applied to type `bool`\n+    //~^ ERROR cannot add `{integer}` to `bool`\n }"}, {"sha": "ebf82079ef2e8b044c731d8f6318f9464a6ee3ad", "filename": "src/test/ui/binop/binop-typeck.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fbinop%2Fbinop-typeck.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fbinop%2Fbinop-typeck.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinop%2Fbinop-typeck.stderr?ref=0de96d37fbcc54978458c18f5067cd9817669bc8", "patch": "@@ -1,4 +1,4 @@\n-error[E0369]: binary operation `+` cannot be applied to type `bool`\n+error[E0369]: cannot add `{integer}` to `bool`\n   --> $DIR/binop-typeck.rs:6:15\n    |\n LL |     let z = x + y;"}, {"sha": "8d9fc20f0d0d6ef0dd5189e4fd45d8895c49b2f3", "filename": "src/test/ui/for/for-loop-type-error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Ffor%2Ffor-loop-type-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Ffor%2Ffor-loop-type-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffor%2Ffor-loop-type-error.rs?ref=0de96d37fbcc54978458c18f5067cd9817669bc8", "patch": "@@ -1,5 +1,5 @@\n pub fn main() {\n-    let x = () + (); //~ ERROR binary operation\n+    let x = () + (); //~ ERROR cannot add `()` to `()`\n \n     // this shouldn't have a flow-on error:\n     for _ in x {}"}, {"sha": "0ed26384f40643f84f44506f9c9eddb7e10a20db", "filename": "src/test/ui/for/for-loop-type-error.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Ffor%2Ffor-loop-type-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Ffor%2Ffor-loop-type-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffor%2Ffor-loop-type-error.stderr?ref=0de96d37fbcc54978458c18f5067cd9817669bc8", "patch": "@@ -1,4 +1,4 @@\n-error[E0369]: binary operation `+` cannot be applied to type `()`\n+error[E0369]: cannot add `()` to `()`\n   --> $DIR/for-loop-type-error.rs:2:16\n    |\n LL |     let x = () + ();"}, {"sha": "4acb51a4e50fa6ff08281ea6faedf4da716b7445", "filename": "src/test/ui/issues/issue-14915.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fissues%2Fissue-14915.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fissues%2Fissue-14915.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-14915.rs?ref=0de96d37fbcc54978458c18f5067cd9817669bc8", "patch": "@@ -4,5 +4,5 @@ fn main() {\n     let x: Box<isize> = box 0;\n \n     println!(\"{}\", x + 1);\n-    //~^ ERROR binary operation `+` cannot be applied to type `std::boxed::Box<isize>`\n+    //~^ ERROR cannot add `{integer}` to `std::boxed::Box<isize>`\n }"}, {"sha": "00b9909af59791c09ebbd198f01d0b8d2bad05a7", "filename": "src/test/ui/issues/issue-14915.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fissues%2Fissue-14915.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fissues%2Fissue-14915.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-14915.stderr?ref=0de96d37fbcc54978458c18f5067cd9817669bc8", "patch": "@@ -1,4 +1,4 @@\n-error[E0369]: binary operation `+` cannot be applied to type `std::boxed::Box<isize>`\n+error[E0369]: cannot add `{integer}` to `std::boxed::Box<isize>`\n   --> $DIR/issue-14915.rs:6:22\n    |\n LL |     println!(\"{}\", x + 1);"}, {"sha": "34726fba9c66a58323410c5b3be2db6ea8a9a3b4", "filename": "src/test/ui/issues/issue-24363.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fissues%2Fissue-24363.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fissues%2Fissue-24363.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-24363.rs?ref=0de96d37fbcc54978458c18f5067cd9817669bc8", "patch": "@@ -1,6 +1,6 @@\n fn main() {\n     1.create_a_type_error[ //~ `{integer}` is a primitive type and therefore doesn't have fields\n-        ()+() //~ ERROR binary operation `+` cannot be applied\n+        ()+() //~ ERROR cannot add\n               //   ^ ensure that we typeck the inner expression ^\n     ];\n }"}, {"sha": "a60fb24ec1209febc5da490b33aa475ac43db2f5", "filename": "src/test/ui/issues/issue-24363.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fissues%2Fissue-24363.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fissues%2Fissue-24363.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-24363.stderr?ref=0de96d37fbcc54978458c18f5067cd9817669bc8", "patch": "@@ -4,7 +4,7 @@ error[E0610]: `{integer}` is a primitive type and therefore doesn't have fields\n LL |     1.create_a_type_error[\n    |       ^^^^^^^^^^^^^^^^^^^\n \n-error[E0369]: binary operation `+` cannot be applied to type `()`\n+error[E0369]: cannot add `()` to `()`\n   --> $DIR/issue-24363.rs:3:11\n    |\n LL |         ()+()"}, {"sha": "438a4c521b198f8dcfeaa185f07f826eb77fc8f9", "filename": "src/test/ui/issues/issue-28837.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fissues%2Fissue-28837.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fissues%2Fissue-28837.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-28837.rs?ref=0de96d37fbcc54978458c18f5067cd9817669bc8", "patch": "@@ -3,23 +3,23 @@ struct A;\n fn main() {\n     let a = A;\n \n-    a + a; //~ ERROR binary operation `+` cannot be applied to type `A`\n+    a + a; //~ ERROR cannot add `A` to `A`\n \n-    a - a; //~ ERROR binary operation `-` cannot be applied to type `A`\n+    a - a; //~ ERROR cannot substract `A` from `A`\n \n-    a * a; //~ ERROR binary operation `*` cannot be applied to type `A`\n+    a * a; //~ ERROR cannot multiply `A` to `A`\n \n-    a / a; //~ ERROR binary operation `/` cannot be applied to type `A`\n+    a / a; //~ ERROR cannot divide `A` by `A`\n \n-    a % a; //~ ERROR binary operation `%` cannot be applied to type `A`\n+    a % a; //~ ERROR cannot mod `A` by `A`\n \n-    a & a; //~ ERROR binary operation `&` cannot be applied to type `A`\n+    a & a; //~ ERROR no implementation for `A & A`\n \n-    a | a; //~ ERROR binary operation `|` cannot be applied to type `A`\n+    a | a; //~ ERROR no implementation for `A | A`\n \n-    a << a; //~ ERROR binary operation `<<` cannot be applied to type `A`\n+    a << a; //~ ERROR no implementation for `A << A`\n \n-    a >> a; //~ ERROR binary operation `>>` cannot be applied to type `A`\n+    a >> a; //~ ERROR no implementation for `A >> A`\n \n     a == a; //~ ERROR binary operation `==` cannot be applied to type `A`\n "}, {"sha": "2ef571b576f891377cd5c6fe3532c590a9197f9a", "filename": "src/test/ui/issues/issue-28837.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fissues%2Fissue-28837.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fissues%2Fissue-28837.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-28837.stderr?ref=0de96d37fbcc54978458c18f5067cd9817669bc8", "patch": "@@ -1,4 +1,4 @@\n-error[E0369]: binary operation `+` cannot be applied to type `A`\n+error[E0369]: cannot add `A` to `A`\n   --> $DIR/issue-28837.rs:6:7\n    |\n LL |     a + a;\n@@ -8,7 +8,7 @@ LL |     a + a;\n    |\n    = note: an implementation of `std::ops::Add` might be missing for `A`\n \n-error[E0369]: binary operation `-` cannot be applied to type `A`\n+error[E0369]: cannot substract `A` from `A`\n   --> $DIR/issue-28837.rs:8:7\n    |\n LL |     a - a;\n@@ -18,7 +18,7 @@ LL |     a - a;\n    |\n    = note: an implementation of `std::ops::Sub` might be missing for `A`\n \n-error[E0369]: binary operation `*` cannot be applied to type `A`\n+error[E0369]: cannot multiply `A` to `A`\n   --> $DIR/issue-28837.rs:10:7\n    |\n LL |     a * a;\n@@ -28,7 +28,7 @@ LL |     a * a;\n    |\n    = note: an implementation of `std::ops::Mul` might be missing for `A`\n \n-error[E0369]: binary operation `/` cannot be applied to type `A`\n+error[E0369]: cannot divide `A` by `A`\n   --> $DIR/issue-28837.rs:12:7\n    |\n LL |     a / a;\n@@ -38,7 +38,7 @@ LL |     a / a;\n    |\n    = note: an implementation of `std::ops::Div` might be missing for `A`\n \n-error[E0369]: binary operation `%` cannot be applied to type `A`\n+error[E0369]: cannot mod `A` by `A`\n   --> $DIR/issue-28837.rs:14:7\n    |\n LL |     a % a;\n@@ -48,7 +48,7 @@ LL |     a % a;\n    |\n    = note: an implementation of `std::ops::Rem` might be missing for `A`\n \n-error[E0369]: binary operation `&` cannot be applied to type `A`\n+error[E0369]: no implementation for `A & A`\n   --> $DIR/issue-28837.rs:16:7\n    |\n LL |     a & a;\n@@ -58,7 +58,7 @@ LL |     a & a;\n    |\n    = note: an implementation of `std::ops::BitAnd` might be missing for `A`\n \n-error[E0369]: binary operation `|` cannot be applied to type `A`\n+error[E0369]: no implementation for `A | A`\n   --> $DIR/issue-28837.rs:18:7\n    |\n LL |     a | a;\n@@ -68,7 +68,7 @@ LL |     a | a;\n    |\n    = note: an implementation of `std::ops::BitOr` might be missing for `A`\n \n-error[E0369]: binary operation `<<` cannot be applied to type `A`\n+error[E0369]: no implementation for `A << A`\n   --> $DIR/issue-28837.rs:20:7\n    |\n LL |     a << a;\n@@ -78,7 +78,7 @@ LL |     a << a;\n    |\n    = note: an implementation of `std::ops::Shl` might be missing for `A`\n \n-error[E0369]: binary operation `>>` cannot be applied to type `A`\n+error[E0369]: no implementation for `A >> A`\n   --> $DIR/issue-28837.rs:22:7\n    |\n LL |     a >> a;"}, {"sha": "f9c35526ec3423ac371430bcaeb943ff0b896bf5", "filename": "src/test/ui/issues/issue-31076.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fissues%2Fissue-31076.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fissues%2Fissue-31076.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-31076.rs?ref=0de96d37fbcc54978458c18f5067cd9817669bc8", "patch": "@@ -11,7 +11,7 @@ impl Add<i32> for i32 {}\n \n fn main() {\n     let x = 5 + 6;\n-    //~^ ERROR binary operation `+` cannot be applied to type `{integer}`\n+    //~^ ERROR cannot add `{integer}` to `{integer}`\n     let y = 5i32 + 6i32;\n-    //~^ ERROR binary operation `+` cannot be applied to type `i32`\n+    //~^ ERROR cannot add `i32` to `i32`\n }"}, {"sha": "5d65734cd230a784b5e565d04c2c1acae4a6bb4c", "filename": "src/test/ui/issues/issue-31076.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fissues%2Fissue-31076.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fissues%2Fissue-31076.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-31076.stderr?ref=0de96d37fbcc54978458c18f5067cd9817669bc8", "patch": "@@ -1,4 +1,4 @@\n-error[E0369]: binary operation `+` cannot be applied to type `{integer}`\n+error[E0369]: cannot add `{integer}` to `{integer}`\n   --> $DIR/issue-31076.rs:13:15\n    |\n LL |     let x = 5 + 6;\n@@ -8,7 +8,7 @@ LL |     let x = 5 + 6;\n    |\n    = note: an implementation of `std::ops::Add` might be missing for `{integer}`\n \n-error[E0369]: binary operation `+` cannot be applied to type `i32`\n+error[E0369]: cannot add `i32` to `i32`\n   --> $DIR/issue-31076.rs:15:18\n    |\n LL |     let y = 5i32 + 6i32;"}, {"sha": "6f6dfb00f86b71f89fd45361279c5a611b35203e", "filename": "src/test/ui/issues/issue-35668.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fissues%2Fissue-35668.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fissues%2Fissue-35668.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-35668.rs?ref=0de96d37fbcc54978458c18f5067cd9817669bc8", "patch": "@@ -1,6 +1,6 @@\n fn func<'a, T>(a: &'a [T]) -> impl Iterator<Item=&'a T> {\n     a.iter().map(|a| a*a)\n-    //~^ ERROR binary operation `*` cannot be applied to type `&T`\n+    //~^ ERROR cannot multiply `&T` to `&T`\n }\n \n fn main() {"}, {"sha": "9d5796a5eefed079a5790a80e96aca76f5cb8102", "filename": "src/test/ui/issues/issue-35668.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fissues%2Fissue-35668.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fissues%2Fissue-35668.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-35668.stderr?ref=0de96d37fbcc54978458c18f5067cd9817669bc8", "patch": "@@ -1,4 +1,4 @@\n-error[E0369]: binary operation `*` cannot be applied to type `&T`\n+error[E0369]: cannot multiply `&T` to `&T`\n   --> $DIR/issue-35668.rs:2:23\n    |\n LL |     a.iter().map(|a| a*a)"}, {"sha": "c090654623206b85b75f097bc6e269fe88457b05", "filename": "src/test/ui/issues/issue-3820.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fissues%2Fissue-3820.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fissues%2Fissue-3820.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-3820.rs?ref=0de96d37fbcc54978458c18f5067cd9817669bc8", "patch": "@@ -11,5 +11,5 @@ impl Thing {\n fn main() {\n     let u = Thing {x: 2};\n     let _v = u.mul(&3); // This is ok\n-    let w = u * 3; //~ ERROR binary operation `*` cannot be applied to type `Thing`\n+    let w = u * 3; //~ ERROR cannot multiply `{integer}` to `Thing`\n }"}, {"sha": "8cc768237a9486d0542cac2d90588b4ff8ce2487", "filename": "src/test/ui/issues/issue-3820.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fissues%2Fissue-3820.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fissues%2Fissue-3820.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-3820.stderr?ref=0de96d37fbcc54978458c18f5067cd9817669bc8", "patch": "@@ -1,4 +1,4 @@\n-error[E0369]: binary operation `*` cannot be applied to type `Thing`\n+error[E0369]: cannot multiply `{integer}` to `Thing`\n   --> $DIR/issue-3820.rs:14:15\n    |\n LL |     let w = u * 3;"}, {"sha": "c01233605b57cbbfffada4bccdcf327012b87af9", "filename": "src/test/ui/issues/issue-40610.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fissues%2Fissue-40610.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fissues%2Fissue-40610.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-40610.rs?ref=0de96d37fbcc54978458c18f5067cd9817669bc8", "patch": "@@ -2,5 +2,5 @@ fn f(_: &[f32]) {}\n \n fn main() {\n     () + f(&[1.0]);\n-    //~^ ERROR binary operation `+` cannot be applied to type `()`\n+    //~^ ERROR cannot add `()` to `()`\n }"}, {"sha": "95f45c168e1222d3cdb825a24b00513368b41d04", "filename": "src/test/ui/issues/issue-40610.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fissues%2Fissue-40610.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fissues%2Fissue-40610.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-40610.stderr?ref=0de96d37fbcc54978458c18f5067cd9817669bc8", "patch": "@@ -1,4 +1,4 @@\n-error[E0369]: binary operation `+` cannot be applied to type `()`\n+error[E0369]: cannot add `()` to `()`\n   --> $DIR/issue-40610.rs:4:8\n    |\n LL |     () + f(&[1.0]);"}, {"sha": "64873ac35a00213e78fc7479e75ba180f5029a34", "filename": "src/test/ui/issues/issue-41394.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fissues%2Fissue-41394.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fissues%2Fissue-41394.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-41394.rs?ref=0de96d37fbcc54978458c18f5067cd9817669bc8", "patch": "@@ -1,6 +1,6 @@\n enum Foo {\n     A = \"\" + 1\n-    //~^ ERROR binary operation `+` cannot be applied to type `&str`\n+    //~^ ERROR cannot add `{integer}` to `&str`\n }\n \n enum Bar {"}, {"sha": "3f60ea4bbf73a1cc38107520779b81ec2c442616", "filename": "src/test/ui/issues/issue-41394.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fissues%2Fissue-41394.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fissues%2Fissue-41394.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-41394.stderr?ref=0de96d37fbcc54978458c18f5067cd9817669bc8", "patch": "@@ -1,4 +1,4 @@\n-error[E0369]: binary operation `+` cannot be applied to type `&str`\n+error[E0369]: cannot add `{integer}` to `&str`\n   --> $DIR/issue-41394.rs:2:12\n    |\n LL |     A = \"\" + 1"}, {"sha": "5f785679c5587791799534f2a6dc19e76a72dc70", "filename": "src/test/ui/issues/issue-47377.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fissues%2Fissue-47377.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fissues%2Fissue-47377.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-47377.stderr?ref=0de96d37fbcc54978458c18f5067cd9817669bc8", "patch": "@@ -1,4 +1,4 @@\n-error[E0369]: binary operation `+` cannot be applied to type `&str`\n+error[E0369]: cannot add `&str` to `&str`\n   --> $DIR/issue-47377.rs:4:14\n    |\n LL |      let _a = b + \", World!\";"}, {"sha": "216e32ddae4115e4bbc7bd65e919a1b2a98a9ba1", "filename": "src/test/ui/issues/issue-47380.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fissues%2Fissue-47380.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fissues%2Fissue-47380.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-47380.stderr?ref=0de96d37fbcc54978458c18f5067cd9817669bc8", "patch": "@@ -1,4 +1,4 @@\n-error[E0369]: binary operation `+` cannot be applied to type `&str`\n+error[E0369]: cannot add `&str` to `&str`\n   --> $DIR/issue-47380.rs:3:35\n    |\n LL |     println!(\"\ud83e\udd80\ud83e\udd80\ud83e\udd80\ud83e\udd80\ud83e\udd80\"); let _a = b + \", World!\";"}, {"sha": "ce6836f30f9461e4ed3e8d12e5b0b0bf107011b0", "filename": "src/test/ui/or-patterns/or-patterns-syntactic-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-fail.rs?ref=0de96d37fbcc54978458c18f5067cd9817669bc8", "patch": "@@ -21,7 +21,7 @@ use E::*;\n \n fn no_top_level_or_patterns() {\n     // We do *not* allow or-patterns at the top level of lambdas...\n-    let _ = |A | B: E| (); //~ ERROR binary operation `|` cannot be applied to type `E`\n+    let _ = |A | B: E| (); //~ ERROR no implementation for `E | ()`\n     //           -------- This looks like an or-pattern but is in fact `|A| (B: E | ())`.\n \n     // ...and for now neither do we allow or-patterns at the top level of functions."}, {"sha": "e77d92e8b07d9d1138fb9b2529be5a1b801564bb", "filename": "src/test/ui/or-patterns/or-patterns-syntactic-fail.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-fail.stderr?ref=0de96d37fbcc54978458c18f5067cd9817669bc8", "patch": "@@ -104,7 +104,7 @@ LL | #![feature(or_patterns)]\n    |\n    = note: `#[warn(incomplete_features)]` on by default\n \n-error[E0369]: binary operation `|` cannot be applied to type `E`\n+error[E0369]: no implementation for `E | ()`\n   --> $DIR/or-patterns-syntactic-fail.rs:24:22\n    |\n LL |     let _ = |A | B: E| ();"}, {"sha": "4c6d515b86af348166d1aed9bf4538cf3c6bcb61", "filename": "src/test/ui/pattern/pattern-tyvar-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fpattern%2Fpattern-tyvar-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fpattern%2Fpattern-tyvar-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fpattern-tyvar-2.rs?ref=0de96d37fbcc54978458c18f5067cd9817669bc8", "patch": "@@ -1,6 +1,6 @@\n enum Bar { T1((), Option<Vec<isize>>), T2, }\n \n fn foo(t: Bar) -> isize { match t { Bar::T1(_, Some(x)) => { return x * 3; } _ => { panic!(); } } }\n-//~^ ERROR binary operation `*` cannot be applied to\n+//~^ ERROR cannot multiply `{integer}` to `std::vec::Vec<isize>`\n \n fn main() { }"}, {"sha": "bb3e61017d4876d05eb83ca414e510c3002bdc94", "filename": "src/test/ui/pattern/pattern-tyvar-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fpattern%2Fpattern-tyvar-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fpattern%2Fpattern-tyvar-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fpattern-tyvar-2.stderr?ref=0de96d37fbcc54978458c18f5067cd9817669bc8", "patch": "@@ -1,4 +1,4 @@\n-error[E0369]: binary operation `*` cannot be applied to type `std::vec::Vec<isize>`\n+error[E0369]: cannot multiply `{integer}` to `std::vec::Vec<isize>`\n   --> $DIR/pattern-tyvar-2.rs:3:71\n    |\n LL | fn foo(t: Bar) -> isize { match t { Bar::T1(_, Some(x)) => { return x * 3; } _ => { panic!(); } } }"}, {"sha": "b6db4008db0d76e634b3e5b2fe4e727a1c3b0920", "filename": "src/test/ui/span/issue-39018.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fspan%2Fissue-39018.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fspan%2Fissue-39018.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-39018.rs?ref=0de96d37fbcc54978458c18f5067cd9817669bc8", "patch": "@@ -1,15 +1,15 @@\n pub fn main() {\n     let x = \"Hello \" + \"World!\";\n-    //~^ ERROR cannot be applied to type\n+    //~^ ERROR cannot add\n \n     // Make sure that the span outputs a warning\n     // for not having an implementation for std::ops::Add\n     // that won't output for the above string concatenation\n     let y = World::Hello + World::Goodbye;\n-    //~^ ERROR cannot be applied to type\n+    //~^ ERROR cannot add\n \n     let x = \"Hello \" + \"World!\".to_owned();\n-    //~^ ERROR cannot be applied to type\n+    //~^ ERROR cannot add\n }\n \n enum World {\n@@ -23,16 +23,16 @@ fn foo() {\n     let c = \"\";\n     let d = \"\";\n     let e = &a;\n-    let _ = &a + &b; //~ ERROR binary operation\n-    let _ = &a + b; //~ ERROR binary operation\n+    let _ = &a + &b; //~ ERROR cannot add\n+    let _ = &a + b; //~ ERROR cannot add\n     let _ = a + &b; // ok\n     let _ = a + b; //~ ERROR mismatched types\n-    let _ = e + b; //~ ERROR binary operation\n-    let _ = e + &b; //~ ERROR binary operation\n-    let _ = e + d; //~ ERROR binary operation\n-    let _ = e + &d; //~ ERROR binary operation\n-    let _ = &c + &d; //~ ERROR binary operation\n-    let _ = &c + d; //~ ERROR binary operation\n-    let _ = c + &d; //~ ERROR binary operation\n-    let _ = c + d; //~ ERROR binary operation\n+    let _ = e + b; //~ ERROR cannot add\n+    let _ = e + &b; //~ ERROR cannot add\n+    let _ = e + d; //~ ERROR cannot add\n+    let _ = e + &d; //~ ERROR cannot add\n+    let _ = &c + &d; //~ ERROR cannot add\n+    let _ = &c + d; //~ ERROR cannot add\n+    let _ = c + &d; //~ ERROR cannot add\n+    let _ = c + d; //~ ERROR cannot add\n }"}, {"sha": "8a32561bd01db44beed7fb96549b79b9be66bdef", "filename": "src/test/ui/span/issue-39018.stderr", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fspan%2Fissue-39018.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fspan%2Fissue-39018.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-39018.stderr?ref=0de96d37fbcc54978458c18f5067cd9817669bc8", "patch": "@@ -1,4 +1,4 @@\n-error[E0369]: binary operation `+` cannot be applied to type `&str`\n+error[E0369]: cannot add `&str` to `&str`\n   --> $DIR/issue-39018.rs:2:22\n    |\n LL |     let x = \"Hello \" + \"World!\";\n@@ -12,7 +12,7 @@ help: `to_owned()` can be used to create an owned `String` from a string referen\n LL |     let x = \"Hello \".to_owned() + \"World!\";\n    |             ^^^^^^^^^^^^^^^^^^^\n \n-error[E0369]: binary operation `+` cannot be applied to type `World`\n+error[E0369]: cannot add `World` to `World`\n   --> $DIR/issue-39018.rs:8:26\n    |\n LL |     let y = World::Hello + World::Goodbye;\n@@ -22,7 +22,7 @@ LL |     let y = World::Hello + World::Goodbye;\n    |\n    = note: an implementation of `std::ops::Add` might be missing for `World`\n \n-error[E0369]: binary operation `+` cannot be applied to type `&str`\n+error[E0369]: cannot add `std::string::String` to `&str`\n   --> $DIR/issue-39018.rs:11:22\n    |\n LL |     let x = \"Hello \" + \"World!\".to_owned();\n@@ -36,7 +36,7 @@ help: `to_owned()` can be used to create an owned `String` from a string referen\n LL |     let x = \"Hello \".to_owned() + &\"World!\".to_owned();\n    |             ^^^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^^^^^^^^^^\n \n-error[E0369]: binary operation `+` cannot be applied to type `&std::string::String`\n+error[E0369]: cannot add `&std::string::String` to `&std::string::String`\n   --> $DIR/issue-39018.rs:26:16\n    |\n LL |     let _ = &a + &b;\n@@ -50,7 +50,7 @@ help: String concatenation appends the string on the right to the string on the\n LL |     let _ = a + &b;\n    |             ^\n \n-error[E0369]: binary operation `+` cannot be applied to type `&std::string::String`\n+error[E0369]: cannot add `std::string::String` to `&std::string::String`\n   --> $DIR/issue-39018.rs:27:16\n    |\n LL |     let _ = &a + b;\n@@ -73,7 +73,7 @@ LL |     let _ = a + b;\n    |                 expected `&str`, found struct `std::string::String`\n    |                 help: consider borrowing here: `&b`\n \n-error[E0369]: binary operation `+` cannot be applied to type `&std::string::String`\n+error[E0369]: cannot add `std::string::String` to `&std::string::String`\n   --> $DIR/issue-39018.rs:30:15\n    |\n LL |     let _ = e + b;\n@@ -87,7 +87,7 @@ help: `to_owned()` can be used to create an owned `String` from a string referen\n LL |     let _ = e.to_owned() + &b;\n    |             ^^^^^^^^^^^^   ^^\n \n-error[E0369]: binary operation `+` cannot be applied to type `&std::string::String`\n+error[E0369]: cannot add `&std::string::String` to `&std::string::String`\n   --> $DIR/issue-39018.rs:31:15\n    |\n LL |     let _ = e + &b;\n@@ -101,7 +101,7 @@ help: `to_owned()` can be used to create an owned `String` from a string referen\n LL |     let _ = e.to_owned() + &b;\n    |             ^^^^^^^^^^^^\n \n-error[E0369]: binary operation `+` cannot be applied to type `&std::string::String`\n+error[E0369]: cannot add `&str` to `&std::string::String`\n   --> $DIR/issue-39018.rs:32:15\n    |\n LL |     let _ = e + d;\n@@ -115,7 +115,7 @@ help: `to_owned()` can be used to create an owned `String` from a string referen\n LL |     let _ = e.to_owned() + d;\n    |             ^^^^^^^^^^^^\n \n-error[E0369]: binary operation `+` cannot be applied to type `&std::string::String`\n+error[E0369]: cannot add `&&str` to `&std::string::String`\n   --> $DIR/issue-39018.rs:33:15\n    |\n LL |     let _ = e + &d;\n@@ -129,7 +129,7 @@ help: `to_owned()` can be used to create an owned `String` from a string referen\n LL |     let _ = e.to_owned() + &d;\n    |             ^^^^^^^^^^^^\n \n-error[E0369]: binary operation `+` cannot be applied to type `&&str`\n+error[E0369]: cannot add `&&str` to `&&str`\n   --> $DIR/issue-39018.rs:34:16\n    |\n LL |     let _ = &c + &d;\n@@ -139,7 +139,7 @@ LL |     let _ = &c + &d;\n    |\n    = note: an implementation of `std::ops::Add` might be missing for `&&str`\n \n-error[E0369]: binary operation `+` cannot be applied to type `&&str`\n+error[E0369]: cannot add `&str` to `&&str`\n   --> $DIR/issue-39018.rs:35:16\n    |\n LL |     let _ = &c + d;\n@@ -149,7 +149,7 @@ LL |     let _ = &c + d;\n    |\n    = note: an implementation of `std::ops::Add` might be missing for `&&str`\n \n-error[E0369]: binary operation `+` cannot be applied to type `&str`\n+error[E0369]: cannot add `&&str` to `&str`\n   --> $DIR/issue-39018.rs:36:15\n    |\n LL |     let _ = c + &d;\n@@ -163,7 +163,7 @@ help: `to_owned()` can be used to create an owned `String` from a string referen\n LL |     let _ = c.to_owned() + &d;\n    |             ^^^^^^^^^^^^\n \n-error[E0369]: binary operation `+` cannot be applied to type `&str`\n+error[E0369]: cannot add `&str` to `&str`\n   --> $DIR/issue-39018.rs:37:15\n    |\n LL |     let _ = c + d;"}, {"sha": "c3e954555325e915bbd692120a391edd7ad410d6", "filename": "src/test/ui/span/type-binding.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fspan%2Ftype-binding.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fspan%2Ftype-binding.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Ftype-binding.stderr?ref=0de96d37fbcc54978458c18f5067cd9817669bc8", "patch": "@@ -2,7 +2,7 @@ error[E0220]: associated type `Trget` not found for `std::ops::Deref`\n   --> $DIR/type-binding.rs:6:20\n    |\n LL | fn homura<T: Deref<Trget = i32>>(_: T) {}\n-   |                    ^^^^^^^^^^^ associated type `Trget` not found\n+   |                    ^^^^^^^^^^^ help: there is an associated type with a similar name: `Target`\n \n error: aborting due to previous error\n "}, {"sha": "23e5f8920622e7247625230d74d10f4fb3e5f16f", "filename": "src/test/ui/str/str-concat-on-double-ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fstr%2Fstr-concat-on-double-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fstr%2Fstr-concat-on-double-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstr%2Fstr-concat-on-double-ref.rs?ref=0de96d37fbcc54978458c18f5067cd9817669bc8", "patch": "@@ -2,6 +2,6 @@ fn main() {\n     let a: &String = &\"1\".to_owned();\n     let b: &str = &\"2\";\n     let c = a + b;\n-    //~^ ERROR binary operation `+` cannot be applied to type `&std::string::String`\n+    //~^ ERROR cannot add `&str` to `&std::string::String`\n     println!(\"{:?}\", c);\n }"}, {"sha": "d77e0d8f242d7fec00d6217c5a56c68cabf4920d", "filename": "src/test/ui/str/str-concat-on-double-ref.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fstr%2Fstr-concat-on-double-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fstr%2Fstr-concat-on-double-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstr%2Fstr-concat-on-double-ref.stderr?ref=0de96d37fbcc54978458c18f5067cd9817669bc8", "patch": "@@ -1,4 +1,4 @@\n-error[E0369]: binary operation `+` cannot be applied to type `&std::string::String`\n+error[E0369]: cannot add `&str` to `&std::string::String`\n   --> $DIR/str-concat-on-double-ref.rs:4:15\n    |\n LL |     let c = a + b;"}, {"sha": "1989ea8863592038e57e42fb4a0015ac448cccfb", "filename": "src/test/ui/terminal-width/non-1-width-unicode-multiline-label.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fterminal-width%2Fnon-1-width-unicode-multiline-label.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fterminal-width%2Fnon-1-width-unicode-multiline-label.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fterminal-width%2Fnon-1-width-unicode-multiline-label.rs?ref=0de96d37fbcc54978458c18f5067cd9817669bc8", "patch": "@@ -3,5 +3,5 @@\n fn main() {\n     let unicode_is_fun = \"\u0601\u2031\u0bb9\u0bf8\u0bf5\ua9c4.\u102a\ua9c5\u2e3b\ud808\ude19\ud809\udc2b\ufdfd\ud808\udf04\ud808\ude1f\ud808\udf7c\ud808\udc4e\ud808\udc31\ud808\udf27\ud808\udd43 \ud808\ude13\ud808\udf59\ud808\ude8e\ud808\udd21\ud808\udd4c\ud808\udc4f\ud808\udc30\ud809\udc2a\ud809\udc29\ud808\ude19\ud809\udc2b\ud869\udea5\";\n     let _ = \"\u0f00\u0f01\u0f02\u0f03\u0f04\u0f05\u0f06\u0f07\u0f08\u0f09\u0f0a\u0f0b\u0f0c\u0f0d\u0f0e\u0f0f\u0f10\u0f11\u0f12\u0f13\u0f14\u0f15\u0f16\u0f17\u0f18\u0f19\u0f1a\u0f1b\u0f1c\u0f1d\u0f1e\u0f1f\u0f20\u0f21\u0f22\u0f23\u0f24\u0f25\u0f26\u0f27\u0f28\u0f29\u0f2a\u0f2b\u0f2c\u0f2d\u0f2e\u0f2f\u0f30\u0f31\u0f32\u0f33\u0f34\u0f35\u0f36\u0f37\u0f38\u0f39\u0f3a\u0f3b\u0f3c\u0f3d\u0f3e\u0f3f\u0f40\u0f41\u0f42\u0f43\u0f44\u0f45\u0f46\u0f47\u0f48\u0f49\u0f4a\u0f4b\u0f4c\u0f4d\u0f4e\u0f4f\u0f50\u0f51\u0f52\u0f53\u0f54\u0f55\u0f56\u0f57\u0f58\u0f59\u0f5a\u0f5b\u0f5c\u0f5d\u0f5e\u0f5f\u0f60\u0f61\u0f62\u0f63\u0f64\u0f65\u0f66\u0f67\u0f68\u0f69\u0f6a\u0f6b\u0f6c\u0f6d\u0f6e\u0f6f\u0f70\u0f71\u0f72\u0f73\u0f74\u0f75\u0f76\u0f77\u0f78\u0f79\u0f7a\u0f7b\u0f7c\u0f7d\u0f7e\u0f7f\u0f80\u0f81\u0f82\u0f83\u0f84\u0f85\u0f86\u0f87\u0f88\u0f89\u0f8a\u0f8b\u0f8c\u0f8d\u0f8e\u0f8f\u0f90\u0f91\u0f92\u0f93\u0f94\u0f95\u0f96\u0f97\u0f98\u0f99\u0f9a\u0f9b\u0f9c\u0f9d\u0f9e\u0f9f\u0fa0\u0fa1\u0fa2\u0fa3\u0fa4\u0fa5\u0fa6\u0fa7\u0fa8\u0fa9\u0faa\u0fab\u0fac\u0fad\u0fae\u0faf\u0fb0\u0fb1\u0fb2\u0fb3\u0fb4\u0fb5\u0fb6\u0fb7\u0fb8\u0fb9\u0fba\u0fbb\u0fbc\u0fbd\u0fbe\u0fbf\u0fc0\u0fc1\u0fc2\u0fc3\u0fc4\u0fc5\u0fc6\u0fc7\u0fc8\u0fc9\u0fca\u0fcb\u0fcc\u0fcd\u0fce\u0fcf\u0fd0\u0fd1\u0fd2\u0fd3\u0fd4\u0fd5\u0fd6\u0fd7\u0fd8\u0fd9\u0fda\"; let _a = unicode_is_fun + \" really fun!\";\n-    //~^ ERROR binary operation `+` cannot be applied to type `&str`\n+    //~^ ERROR cannot add `&str` to `&str`\n }"}, {"sha": "69daa93412a3a40829586072f48a70ad13ad4cdf", "filename": "src/test/ui/terminal-width/non-1-width-unicode-multiline-label.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fterminal-width%2Fnon-1-width-unicode-multiline-label.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fterminal-width%2Fnon-1-width-unicode-multiline-label.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fterminal-width%2Fnon-1-width-unicode-multiline-label.stderr?ref=0de96d37fbcc54978458c18f5067cd9817669bc8", "patch": "@@ -1,4 +1,4 @@\n-error[E0369]: binary operation `+` cannot be applied to type `&str`\n+error[E0369]: cannot add `&str` to `&str`\n   --> $DIR/non-1-width-unicode-multiline-label.rs:5:260\n    |\n LL | ...\u0f7d\u0f7e\u0f7f\u0f80\u0f81\u0f82\u0f83\u0f84\u0f85\u0f86\u0f87\u0f88\u0f89\u0f8a\u0f8b\u0f8c\u0f8d\u0f8e\u0f8f\u0f90\u0f91\u0f92\u0f93\u0f94\u0f95\u0f96\u0f97\u0f98\u0f99\u0f9a\u0f9b\u0f9c\u0f9d\u0f9e\u0f9f\u0fa0\u0fa1\u0fa2\u0fa3\u0fa4\u0fa5\u0fa6\u0fa7\u0fa8\u0fa9\u0faa\u0fab\u0fac\u0fad\u0fae\u0faf\u0fb0\u0fb1\u0fb2\u0fb3\u0fb4\u0fb5\u0fb6\u0fb7\u0fb8\u0fb9\u0fba\u0fbb\u0fbc\u0fbd\u0fbe\u0fbf\u0fc0\u0fc1\u0fc2\u0fc3\u0fc4\u0fc5\u0fc6\u0fc7...\u0fcb\u0fcc\u0fcd\u0fce\u0fcf\u0fd0\u0fd1\u0fd2\u0fd3\u0fd4\u0fd5\u0fd6\u0fd7\u0fd8\u0fd9\u0fda\"; let _a = unicode_is_fun + \" really fun!\";"}, {"sha": "286776985168f78ef5e2f11e0a158efc20b2646c", "filename": "src/test/ui/traits/trait-resolution-in-overloaded-op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Ftraits%2Ftrait-resolution-in-overloaded-op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Ftraits%2Ftrait-resolution-in-overloaded-op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-resolution-in-overloaded-op.rs?ref=0de96d37fbcc54978458c18f5067cd9817669bc8", "patch": "@@ -5,7 +5,7 @@ trait MyMul<Rhs, Res> {\n }\n \n fn foo<T: MyMul<f64, f64>>(a: &T, b: f64) -> f64 {\n-    a * b //~ ERROR binary operation `*` cannot be applied to type `&T`\n+    a * b //~ ERROR cannot multiply `f64` to `&T`\n }\n \n fn main() {}"}, {"sha": "8d7ba36c665b31d19d4cd9ef3af43ba7bdf17f28", "filename": "src/test/ui/traits/trait-resolution-in-overloaded-op.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Ftraits%2Ftrait-resolution-in-overloaded-op.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Ftraits%2Ftrait-resolution-in-overloaded-op.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-resolution-in-overloaded-op.stderr?ref=0de96d37fbcc54978458c18f5067cd9817669bc8", "patch": "@@ -1,4 +1,4 @@\n-error[E0369]: binary operation `*` cannot be applied to type `&T`\n+error[E0369]: cannot multiply `f64` to `&T`\n   --> $DIR/trait-resolution-in-overloaded-op.rs:8:7\n    |\n LL |     a * b"}, {"sha": "f61ada3f63ff9a1a9e7afafd4e80526099b9207c", "filename": "src/test/ui/type/type-check/missing_trait_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fmissing_trait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fmissing_trait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fmissing_trait_impl.rs?ref=0de96d37fbcc54978458c18f5067cd9817669bc8", "patch": "@@ -2,7 +2,7 @@ fn main() {\n }\n \n fn foo<T>(x: T, y: T) {\n-    let z = x + y; //~ ERROR binary operation `+` cannot be applied to type `T`\n+    let z = x + y; //~ ERROR cannot add `T` to `T`\n }\n \n fn bar<T>(x: T) {"}, {"sha": "7186d6a542dc9db031b8228708f03e52747dff02", "filename": "src/test/ui/type/type-check/missing_trait_impl.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fmissing_trait_impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fmissing_trait_impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fmissing_trait_impl.stderr?ref=0de96d37fbcc54978458c18f5067cd9817669bc8", "patch": "@@ -1,4 +1,4 @@\n-error[E0369]: binary operation `+` cannot be applied to type `T`\n+error[E0369]: cannot add `T` to `T`\n   --> $DIR/missing_trait_impl.rs:5:15\n    |\n LL |     let z = x + y;"}, {"sha": "4785178fb2575e825093fe77cd6644d174d1bca4", "filename": "src/test/ui/vec/vec-res-add.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fvec%2Fvec-res-add.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fvec%2Fvec-res-add.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fvec%2Fvec-res-add.rs?ref=0de96d37fbcc54978458c18f5067cd9817669bc8", "patch": "@@ -14,6 +14,6 @@ fn main() {\n     let i = vec![r(0)];\n     let j = vec![r(1)];\n     let k = i + j;\n-    //~^ ERROR binary operation `+` cannot be applied to type\n+    //~^ ERROR cannot add `std::vec::Vec<R>` to `std::vec::Vec<R>`\n     println!(\"{:?}\", j);\n }"}, {"sha": "1cc12a222e50bae2d131809b60e4f0e062979149", "filename": "src/test/ui/vec/vec-res-add.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fvec%2Fvec-res-add.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0de96d37fbcc54978458c18f5067cd9817669bc8/src%2Ftest%2Fui%2Fvec%2Fvec-res-add.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fvec%2Fvec-res-add.stderr?ref=0de96d37fbcc54978458c18f5067cd9817669bc8", "patch": "@@ -1,4 +1,4 @@\n-error[E0369]: binary operation `+` cannot be applied to type `std::vec::Vec<R>`\n+error[E0369]: cannot add `std::vec::Vec<R>` to `std::vec::Vec<R>`\n   --> $DIR/vec-res-add.rs:16:15\n    |\n LL |     let k = i + j;"}]}