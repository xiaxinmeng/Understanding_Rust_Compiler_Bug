{"sha": "63f500b0ee55443a52f078060004c911a7532a14", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzZjUwMGIwZWU1NTQ0M2E1MmYwNzgwNjAwMDRjOTExYTc1MzJhMTQ=", "commit": {"author": {"name": "David Lattimore", "email": "dml@google.com", "date": "2020-07-22T04:01:21Z"}, "committer": {"name": "David Lattimore", "email": "dml@google.com", "date": "2020-07-24T11:34:00Z"}, "message": "SSR: Use Definition::find_usages to speed up matching.\n\nWhen the search pattern contains a path, this substantially speeds up finding matches, especially if the path references a private item.", "tree": {"sha": "7944b776eea1eb69e4d822f5c004d5f082acd9b8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7944b776eea1eb69e4d822f5c004d5f082acd9b8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/63f500b0ee55443a52f078060004c911a7532a14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/63f500b0ee55443a52f078060004c911a7532a14", "html_url": "https://github.com/rust-lang/rust/commit/63f500b0ee55443a52f078060004c911a7532a14", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/63f500b0ee55443a52f078060004c911a7532a14/comments", "author": {"login": "davidlattimore", "id": 8983542, "node_id": "MDQ6VXNlcjg5ODM1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/8983542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidlattimore", "html_url": "https://github.com/davidlattimore", "followers_url": "https://api.github.com/users/davidlattimore/followers", "following_url": "https://api.github.com/users/davidlattimore/following{/other_user}", "gists_url": "https://api.github.com/users/davidlattimore/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidlattimore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidlattimore/subscriptions", "organizations_url": "https://api.github.com/users/davidlattimore/orgs", "repos_url": "https://api.github.com/users/davidlattimore/repos", "events_url": "https://api.github.com/users/davidlattimore/events{/privacy}", "received_events_url": "https://api.github.com/users/davidlattimore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidlattimore", "id": 8983542, "node_id": "MDQ6VXNlcjg5ODM1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/8983542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidlattimore", "html_url": "https://github.com/davidlattimore", "followers_url": "https://api.github.com/users/davidlattimore/followers", "following_url": "https://api.github.com/users/davidlattimore/following{/other_user}", "gists_url": "https://api.github.com/users/davidlattimore/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidlattimore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidlattimore/subscriptions", "organizations_url": "https://api.github.com/users/davidlattimore/orgs", "repos_url": "https://api.github.com/users/davidlattimore/repos", "events_url": "https://api.github.com/users/davidlattimore/events{/privacy}", "received_events_url": "https://api.github.com/users/davidlattimore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "757f755c29e041fd319af466d7d0418f54cb090a", "url": "https://api.github.com/repos/rust-lang/rust/commits/757f755c29e041fd319af466d7d0418f54cb090a", "html_url": "https://github.com/rust-lang/rust/commit/757f755c29e041fd319af466d7d0418f54cb090a"}], "stats": {"total": 181, "additions": 157, "deletions": 24}, "files": [{"sha": "f391a8e43213945689c56600af2216a19b68cd67", "filename": "crates/ra_ide_db/src/defs.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/63f500b0ee55443a52f078060004c911a7532a14/crates%2Fra_ide_db%2Fsrc%2Fdefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63f500b0ee55443a52f078060004c911a7532a14/crates%2Fra_ide_db%2Fsrc%2Fdefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fdefs.rs?ref=63f500b0ee55443a52f078060004c911a7532a14", "patch": "@@ -290,20 +290,25 @@ pub fn classify_name_ref(\n \n     let path = name_ref.syntax().ancestors().find_map(ast::Path::cast)?;\n     let resolved = sema.resolve_path(&path)?;\n-    let res = match resolved {\n-        PathResolution::Def(def) => Definition::ModuleDef(def),\n-        PathResolution::AssocItem(item) => {\n-            let def = match item {\n-                hir::AssocItem::Function(it) => it.into(),\n-                hir::AssocItem::Const(it) => it.into(),\n-                hir::AssocItem::TypeAlias(it) => it.into(),\n-            };\n-            Definition::ModuleDef(def)\n+    Some(NameRefClass::Definition(resolved.into()))\n+}\n+\n+impl From<PathResolution> for Definition {\n+    fn from(path_resolution: PathResolution) -> Self {\n+        match path_resolution {\n+            PathResolution::Def(def) => Definition::ModuleDef(def),\n+            PathResolution::AssocItem(item) => {\n+                let def = match item {\n+                    hir::AssocItem::Function(it) => it.into(),\n+                    hir::AssocItem::Const(it) => it.into(),\n+                    hir::AssocItem::TypeAlias(it) => it.into(),\n+                };\n+                Definition::ModuleDef(def)\n+            }\n+            PathResolution::Local(local) => Definition::Local(local),\n+            PathResolution::TypeParam(par) => Definition::TypeParam(par),\n+            PathResolution::Macro(def) => Definition::Macro(def),\n+            PathResolution::SelfType(impl_def) => Definition::SelfType(impl_def),\n         }\n-        PathResolution::Local(local) => Definition::Local(local),\n-        PathResolution::TypeParam(par) => Definition::TypeParam(par),\n-        PathResolution::Macro(def) => Definition::Macro(def),\n-        PathResolution::SelfType(impl_def) => Definition::SelfType(impl_def),\n-    };\n-    Some(NameRefClass::Definition(res))\n+    }\n }"}, {"sha": "a7cae37b0c86eed05db09e3b501cf8ee9afd56d7", "filename": "crates/ra_ide_db/src/search.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/63f500b0ee55443a52f078060004c911a7532a14/crates%2Fra_ide_db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63f500b0ee55443a52f078060004c911a7532a14/crates%2Fra_ide_db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fsearch.rs?ref=63f500b0ee55443a52f078060004c911a7532a14", "patch": "@@ -60,6 +60,10 @@ impl SearchScope {\n         SearchScope::new(std::iter::once((file, None)).collect())\n     }\n \n+    pub fn files(files: &[FileId]) -> SearchScope {\n+        SearchScope::new(files.iter().map(|f| (*f, None)).collect())\n+    }\n+\n     pub fn intersection(&self, other: &SearchScope) -> SearchScope {\n         let (mut small, mut large) = (&self.entries, &other.entries);\n         if small.len() > large.len() {"}, {"sha": "5a71d4f31a1b19f0051c30d9a05a25fc26194d6e", "filename": "crates/ra_ssr/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/63f500b0ee55443a52f078060004c911a7532a14/crates%2Fra_ssr%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63f500b0ee55443a52f078060004c911a7532a14/crates%2Fra_ssr%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Flib.rs?ref=63f500b0ee55443a52f078060004c911a7532a14", "patch": "@@ -151,8 +151,9 @@ impl<'db> MatchFinder<'db> {\n     /// Returns matches for all added rules.\n     pub fn matches(&self) -> SsrMatches {\n         let mut matches = Vec::new();\n+        let mut usage_cache = search::UsageCache::default();\n         for rule in &self.rules {\n-            self.find_matches_for_rule(rule, &mut matches);\n+            self.find_matches_for_rule(rule, &mut usage_cache, &mut matches);\n         }\n         nester::nest_and_remove_collisions(matches, &self.sema)\n     }"}, {"sha": "63fd217ce1291c288828cee2ac5c8dad48ca737e", "filename": "crates/ra_ssr/src/resolving.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/63f500b0ee55443a52f078060004c911a7532a14/crates%2Fra_ssr%2Fsrc%2Fresolving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63f500b0ee55443a52f078060004c911a7532a14/crates%2Fra_ssr%2Fsrc%2Fresolving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Fresolving.rs?ref=63f500b0ee55443a52f078060004c911a7532a14", "patch": "@@ -22,6 +22,7 @@ pub(crate) struct ResolvedPattern {\n \n pub(crate) struct ResolvedPath {\n     pub(crate) resolution: hir::PathResolution,\n+    pub(crate) depth: u32,\n }\n \n impl ResolvedRule {\n@@ -62,7 +63,7 @@ struct Resolver<'a, 'db> {\n impl Resolver<'_, '_> {\n     fn resolve_pattern_tree(&self, pattern: SyntaxNode) -> Result<ResolvedPattern, SsrError> {\n         let mut resolved_paths = FxHashMap::default();\n-        self.resolve(pattern.clone(), &mut resolved_paths)?;\n+        self.resolve(pattern.clone(), 0, &mut resolved_paths)?;\n         Ok(ResolvedPattern {\n             node: pattern,\n             resolved_paths,\n@@ -73,6 +74,7 @@ impl Resolver<'_, '_> {\n     fn resolve(\n         &self,\n         node: SyntaxNode,\n+        depth: u32,\n         resolved_paths: &mut FxHashMap<SyntaxNode, ResolvedPath>,\n     ) -> Result<(), SsrError> {\n         use ra_syntax::ast::AstNode;\n@@ -86,12 +88,12 @@ impl Resolver<'_, '_> {\n                 let resolution = self\n                     .resolve_path(&path)\n                     .ok_or_else(|| error!(\"Failed to resolve path `{}`\", node.text()))?;\n-                resolved_paths.insert(node, ResolvedPath { resolution });\n+                resolved_paths.insert(node, ResolvedPath { resolution, depth });\n                 return Ok(());\n             }\n         }\n         for node in node.children() {\n-            self.resolve(node, resolved_paths)?;\n+            self.resolve(node, depth + 1, resolved_paths)?;\n         }\n         Ok(())\n     }"}, {"sha": "9a4e35e96d5ad6e27d8414ed78631d39ea3a5d32", "filename": "crates/ra_ssr/src/search.rs", "status": "modified", "additions": 126, "deletions": 5, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/63f500b0ee55443a52f078060004c911a7532a14/crates%2Fra_ssr%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63f500b0ee55443a52f078060004c911a7532a14/crates%2Fra_ssr%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Fsearch.rs?ref=63f500b0ee55443a52f078060004c911a7532a14", "patch": "@@ -1,17 +1,106 @@\n //! Searching for matches.\n \n-use crate::{matching, resolving::ResolvedRule, Match, MatchFinder};\n+use crate::{\n+    matching,\n+    resolving::{ResolvedPath, ResolvedPattern, ResolvedRule},\n+    Match, MatchFinder,\n+};\n use ra_db::FileRange;\n+use ra_ide_db::{\n+    defs::Definition,\n+    search::{Reference, SearchScope},\n+};\n use ra_syntax::{ast, AstNode, SyntaxNode};\n \n+/// A cache for the results of find_usages. This is for when we have multiple patterns that have the\n+/// same path. e.g. if the pattern was `foo::Bar` that can parse as a path, an expression, a type\n+/// and as a pattern. In each, the usages of `foo::Bar` are the same and we'd like to avoid finding\n+/// them more than once.\n+#[derive(Default)]\n+pub(crate) struct UsageCache {\n+    usages: Vec<(Definition, Vec<Reference>)>,\n+}\n+\n impl<'db> MatchFinder<'db> {\n     /// Adds all matches for `rule` to `matches_out`. Matches may overlap in ways that make\n     /// replacement impossible, so further processing is required in order to properly nest matches\n     /// and remove overlapping matches. This is done in the `nesting` module.\n-    pub(crate) fn find_matches_for_rule(&self, rule: &ResolvedRule, matches_out: &mut Vec<Match>) {\n-        // FIXME: Use resolved paths in the pattern to find places to search instead of always\n-        // scanning every node.\n-        self.slow_scan(rule, matches_out);\n+    pub(crate) fn find_matches_for_rule(\n+        &self,\n+        rule: &ResolvedRule,\n+        usage_cache: &mut UsageCache,\n+        matches_out: &mut Vec<Match>,\n+    ) {\n+        if pick_path_for_usages(&rule.pattern).is_none() {\n+            self.slow_scan(rule, matches_out);\n+            return;\n+        }\n+        self.find_matches_for_pattern_tree(rule, &rule.pattern, usage_cache, matches_out);\n+    }\n+\n+    fn find_matches_for_pattern_tree(\n+        &self,\n+        rule: &ResolvedRule,\n+        pattern: &ResolvedPattern,\n+        usage_cache: &mut UsageCache,\n+        matches_out: &mut Vec<Match>,\n+    ) {\n+        if let Some(first_path) = pick_path_for_usages(pattern) {\n+            let definition: Definition = first_path.resolution.clone().into();\n+            for reference in self.find_usages(usage_cache, definition) {\n+                let file = self.sema.parse(reference.file_range.file_id);\n+                if let Some(path) = self.sema.find_node_at_offset_with_descend::<ast::Path>(\n+                    file.syntax(),\n+                    reference.file_range.range.start(),\n+                ) {\n+                    if let Some(node_to_match) = self\n+                        .sema\n+                        .ancestors_with_macros(path.syntax().clone())\n+                        .skip(first_path.depth as usize)\n+                        .next()\n+                    {\n+                        if let Ok(m) =\n+                            matching::get_match(false, rule, &node_to_match, &None, &self.sema)\n+                        {\n+                            matches_out.push(m);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn find_usages<'a>(\n+        &self,\n+        usage_cache: &'a mut UsageCache,\n+        definition: Definition,\n+    ) -> &'a [Reference] {\n+        // Logically if a lookup succeeds we should just return it. Unfortunately returning it would\n+        // extend the lifetime of the borrow, then we wouldn't be able to do the insertion on a\n+        // cache miss. This is a limitation of NLL and is fixed with Polonius. For now we do two\n+        // lookups in the case of a cache hit.\n+        if usage_cache.find(&definition).is_none() {\n+            let usages = definition.find_usages(&self.sema, Some(self.search_scope()));\n+            usage_cache.usages.push((definition, usages));\n+            return &usage_cache.usages.last().unwrap().1;\n+        }\n+        usage_cache.find(&definition).unwrap()\n+    }\n+\n+    /// Returns the scope within which we want to search. We don't want un unrestricted search\n+    /// scope, since we don't want to find references in external dependencies.\n+    fn search_scope(&self) -> SearchScope {\n+        // FIXME: We should ideally have a test that checks that we edit local roots and not library\n+        // roots. This probably would require some changes to fixtures, since currently everything\n+        // seems to get put into a single source root.\n+        use ra_db::SourceDatabaseExt;\n+        use ra_ide_db::symbol_index::SymbolsDatabase;\n+        let mut files = Vec::new();\n+        for &root in self.sema.db.local_roots().iter() {\n+            let sr = self.sema.db.source_root(root);\n+            files.extend(sr.iter());\n+        }\n+        SearchScope::files(&files)\n     }\n \n     fn slow_scan(&self, rule: &ResolvedRule, matches_out: &mut Vec<Match>) {\n@@ -59,3 +148,35 @@ impl<'db> MatchFinder<'db> {\n         }\n     }\n }\n+\n+impl UsageCache {\n+    fn find(&mut self, definition: &Definition) -> Option<&[Reference]> {\n+        // We expect a very small number of cache entries (generally 1), so a linear scan should be\n+        // fast enough and avoids the need to implement Hash for Definition.\n+        for (d, refs) in &self.usages {\n+            if d == definition {\n+                return Some(refs);\n+            }\n+        }\n+        None\n+    }\n+}\n+\n+/// Returns a path that's suitable for path resolution. We exclude builtin types, since they aren't\n+/// something that we can find references to. We then somewhat arbitrarily pick the path that is the\n+/// longest as this is hopefully more likely to be less common, making it faster to find.\n+fn pick_path_for_usages(pattern: &ResolvedPattern) -> Option<&ResolvedPath> {\n+    // FIXME: Take the scope of the resolved path into account. e.g. if there are any paths that are\n+    // private to the current module, then we definitely would want to pick them over say a path\n+    // from std. Possibly we should go further than this and intersect the search scopes for all\n+    // resolved paths then search only in that scope.\n+    pattern\n+        .resolved_paths\n+        .iter()\n+        .filter(|(_, p)| {\n+            !matches!(p.resolution, hir::PathResolution::Def(hir::ModuleDef::BuiltinType(_)))\n+        })\n+        .map(|(node, resolved)| (node.text().len(), resolved))\n+        .max_by(|(a, _), (b, _)| a.cmp(b))\n+        .map(|(_, resolved)| resolved)\n+}"}]}