{"sha": "9a4c669867765d42bdd13fc09eb9a32b7a667a43", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhNGM2Njk4Njc3NjVkNDJiZGQxM2ZjMDllYjlhMzJiN2E2NjdhNDM=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-12-13T01:08:09Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-12-13T01:08:09Z"}, "message": "syntax: remove remaining #syntaxext machinery. Close #3516.", "tree": {"sha": "64a4ba0ae49ece9b0a1b29c112d0a5b21fba7efe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/64a4ba0ae49ece9b0a1b29c112d0a5b21fba7efe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9a4c669867765d42bdd13fc09eb9a32b7a667a43", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9a4c669867765d42bdd13fc09eb9a32b7a667a43", "html_url": "https://github.com/rust-lang/rust/commit/9a4c669867765d42bdd13fc09eb9a32b7a667a43", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9a4c669867765d42bdd13fc09eb9a32b7a667a43/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e24ae85025e40aa17915f6c604d89aefbca274bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/e24ae85025e40aa17915f6c604d89aefbca274bd", "html_url": "https://github.com/rust-lang/rust/commit/e24ae85025e40aa17915f6c604d89aefbca274bd"}], "stats": {"total": 422, "additions": 150, "deletions": 272}, "files": [{"sha": "c21aa7d248ea0c50d16dc4ada4db26e4b6f46d1d", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9a4c669867765d42bdd13fc09eb9a32b7a667a43/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4c669867765d42bdd13fc09eb9a32b7a667a43/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=9a4c669867765d42bdd13fc09eb9a32b7a667a43", "patch": "@@ -831,14 +831,6 @@ enum matcher_ {\n \n type mac = spanned<mac_>;\n \n-type mac_arg = Option<@expr>;\n-\n-#[auto_serialize]\n-#[auto_deserialize]\n-type mac_body_ = {span: span};\n-\n-type mac_body = Option<mac_body_>;\n-\n #[auto_serialize]\n #[auto_deserialize]\n enum mac_ {"}, {"sha": "a5ed1f5e101895b0249e3ea18f64bee52dbf554d", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 49, "deletions": 102, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/9a4c669867765d42bdd13fc09eb9a32b7a667a43/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4c669867765d42bdd13fc09eb9a32b7a667a43/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=9a4c669867765d42bdd13fc09eb9a32b7a667a43", "patch": "@@ -13,11 +13,8 @@ use parse::parser;\n use diagnostic::span_handler;\n use codemap::{CodeMap, span, ExpnInfo, ExpandedFrom};\n use ast_util::dummy_sp;\n+use parse::token;\n \n-// obsolete old-style #macro code:\n-//\n-//    syntax_expander, normal, builtin\n-//\n // new-style macro! tt code:\n //\n //    syntax_expander_tt, syntax_expander_tt_item, mac_result,\n@@ -27,12 +24,6 @@ use ast_util::dummy_sp;\n // is now probably a redundant AST node, can be merged with\n // ast::mac_invoc_tt.\n \n-// second argument is the span to blame for general argument problems\n-type syntax_expander_ =\n-    fn@(ext_ctxt, span, ast::mac_arg, ast::mac_body) -> @ast::expr;\n-// second argument is the origin of the macro, if user-defined\n-type syntax_expander = {expander: syntax_expander_, span: Option<span>};\n-\n type macro_def = {name: ~str, ext: syntax_extension};\n \n type item_decorator =\n@@ -56,10 +47,7 @@ enum mac_result {\n \n enum syntax_extension {\n \n-    // normal() is obsolete, remove when #old_macros go away.\n-    normal(syntax_expander),\n-\n-    // #[auto_serialize] and such. will probably survive death of #old_macros\n+    // #[auto_serialize] and such\n     item_decorator(item_decorator),\n \n     // Token-tree expanders\n@@ -73,8 +61,6 @@ enum syntax_extension {\n // A temporary hard-coded map of methods for expanding syntax extension\n // AST nodes into full ASTs\n fn syntax_expander_table() -> HashMap<~str, syntax_extension> {\n-    fn builtin(f: syntax_expander_) -> syntax_extension\n-        {normal({expander: f, span: None})}\n     fn builtin_normal_tt(f: syntax_expander_tt_) -> syntax_extension {\n         normal_tt({expander: f, span: None})\n     }\n@@ -85,18 +71,19 @@ fn syntax_expander_table() -> HashMap<~str, syntax_extension> {\n     syntax_expanders.insert(~\"macro_rules\",\n                             builtin_item_tt(\n                                 ext::tt::macro_rules::add_new_extension));\n-    syntax_expanders.insert(~\"fmt\", builtin(ext::fmt::expand_syntax_ext));\n+    syntax_expanders.insert(~\"fmt\",\n+                            builtin_normal_tt(ext::fmt::expand_syntax_ext));\n     syntax_expanders.insert(\n         ~\"auto_serialize\",\n         item_decorator(ext::auto_serialize::expand_auto_serialize));\n     syntax_expanders.insert(\n         ~\"auto_deserialize\",\n         item_decorator(ext::auto_serialize::expand_auto_deserialize));\n-    syntax_expanders.insert(~\"env\", builtin(ext::env::expand_syntax_ext));\n+    syntax_expanders.insert(~\"env\",\n+                            builtin_normal_tt(ext::env::expand_syntax_ext));\n     syntax_expanders.insert(~\"concat_idents\",\n-                            builtin(ext::concat_idents::expand_syntax_ext));\n-    syntax_expanders.insert(~\"ident_to_str\",\n-                            builtin(ext::ident_to_str::expand_syntax_ext));\n+                            builtin_normal_tt(\n+                                ext::concat_idents::expand_syntax_ext));\n     syntax_expanders.insert(~\"log_syntax\",\n                             builtin_normal_tt(\n                                 ext::log_syntax::expand_syntax_ext));\n@@ -122,21 +109,29 @@ fn syntax_expander_table() -> HashMap<~str, syntax_extension> {\n                             builtin_normal_tt(ext::quote::expand_quote_stmt));\n \n     syntax_expanders.insert(~\"line\",\n-                            builtin(ext::source_util::expand_line));\n+                            builtin_normal_tt(\n+                                ext::source_util::expand_line));\n     syntax_expanders.insert(~\"col\",\n-                            builtin(ext::source_util::expand_col));\n+                            builtin_normal_tt(\n+                                ext::source_util::expand_col));\n     syntax_expanders.insert(~\"file\",\n-                            builtin(ext::source_util::expand_file));\n+                            builtin_normal_tt(\n+                                ext::source_util::expand_file));\n     syntax_expanders.insert(~\"stringify\",\n-                            builtin(ext::source_util::expand_stringify));\n+                            builtin_normal_tt(\n+                                ext::source_util::expand_stringify));\n     syntax_expanders.insert(~\"include\",\n-                            builtin(ext::source_util::expand_include));\n+                            builtin_normal_tt(\n+                                ext::source_util::expand_include));\n     syntax_expanders.insert(~\"include_str\",\n-                            builtin(ext::source_util::expand_include_str));\n+                            builtin_normal_tt(\n+                                ext::source_util::expand_include_str));\n     syntax_expanders.insert(~\"include_bin\",\n-                            builtin(ext::source_util::expand_include_bin));\n+                            builtin_normal_tt(\n+                                ext::source_util::expand_include_bin));\n     syntax_expanders.insert(~\"module_path\",\n-                            builtin(ext::source_util::expand_mod));\n+                            builtin_normal_tt(\n+                                ext::source_util::expand_mod));\n     syntax_expanders.insert(~\"proto\",\n                             builtin_item_tt(ext::pipes::expand_proto));\n     syntax_expanders.insert(\n@@ -292,87 +287,39 @@ fn expr_to_ident(cx: ext_ctxt,\n     }\n }\n \n-fn get_mac_args_no_max(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n-                       min: uint, name: ~str) -> ~[@ast::expr] {\n-    return get_mac_args(cx, sp, arg, min, None, name);\n+fn check_zero_tts(cx: ext_ctxt, sp: span, tts: &[ast::token_tree],\n+                  name: &str) {\n+    if tts.len() != 0 {\n+        cx.span_fatal(sp, fmt!(\"%s takes no arguments\", name));\n+    }\n }\n \n-fn get_mac_args(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n-                min: uint, max: Option<uint>, name: ~str) -> ~[@ast::expr] {\n-    match arg {\n-      Some(expr) => match expr.node {\n-        ast::expr_vec(elts, _) => {\n-            let elts_len = vec::len(elts);\n-              match max {\n-                Some(max) if ! (min <= elts_len && elts_len <= max) => {\n-                  cx.span_fatal(sp,\n-                                fmt!(\"%s! takes between %u and %u arguments.\",\n-                                     name, min, max));\n-                }\n-                None if ! (min <= elts_len) => {\n-                  cx.span_fatal(sp, fmt!(\"%s! needs at least %u arguments.\",\n-                                         name, min));\n-                }\n-                _ => return elts /* we are good */\n-              }\n-          }\n-        _ => {\n-            cx.span_fatal(sp, fmt!(\"%s!: malformed invocation\", name))\n-        }\n-      },\n-      None => cx.span_fatal(sp, fmt!(\"%s!: missing arguments\", name))\n+fn get_single_str_from_tts(cx: ext_ctxt, sp: span, tts: &[ast::token_tree],\n+                           name: &str) -> ~str {\n+    if tts.len() != 1 {\n+        cx.span_fatal(sp, fmt!(\"%s takes 1 argument.\", name));\n     }\n-}\n \n-fn get_mac_body(cx: ext_ctxt, sp: span, args: ast::mac_body)\n-    -> ast::mac_body_\n-{\n-    match (args) {\n-      Some(body) => body,\n-      None => cx.span_fatal(sp, ~\"missing macro body\")\n+    match tts[0] {\n+        ast::tt_tok(_, token::LIT_STR(ident)) => cx.str_of(ident),\n+        _ =>\n+        cx.span_fatal(sp, fmt!(\"%s requires a string.\", name))\n     }\n }\n \n-// Massage syntactic form of new-style arguments to internal representation\n-// of old-style macro args, such that old-style macro can be run and invoked\n-// using new syntax. This will be obsolete when #old_macros go away.\n-fn tt_args_to_original_flavor(cx: ext_ctxt, sp: span, arg: ~[ast::token_tree])\n-    -> ast::mac_arg {\n-    use ast::{matcher, matcher_, match_tok, match_seq, match_nonterminal};\n-    use parse::lexer::{new_tt_reader, reader};\n-    use tt::macro_parser::{parse_or_else, matched_seq,\n-                              matched_nonterminal};\n-\n-    // these spans won't matter, anyways\n-    fn ms(m: matcher_) -> matcher {\n-        {node: m, span: dummy_sp()}\n+fn get_exprs_from_tts(cx: ext_ctxt, tts: ~[ast::token_tree])\n+    -> ~[@ast::expr] {\n+    let p = parse::new_parser_from_tts(cx.parse_sess(),\n+                                       cx.cfg(),\n+                                       tts);\n+    let mut es = ~[];\n+    while p.token != token::EOF {\n+        if es.len() != 0 {\n+            p.eat(token::COMMA);\n+        }\n+        es.push(p.parse_expr());\n     }\n-    let arg_nm = cx.parse_sess().interner.gensym(@~\"arg\");\n-\n-    let argument_gram = ~[ms(match_seq(~[\n-        ms(match_nonterminal(arg_nm, parse::token::special_idents::expr, 0u))\n-    ], Some(parse::token::COMMA), true, 0u, 1u))];\n-\n-    let arg_reader = new_tt_reader(cx.parse_sess().span_diagnostic,\n-                                   cx.parse_sess().interner, None, arg);\n-    let args =\n-        match parse_or_else(cx.parse_sess(), cx.cfg(), arg_reader as reader,\n-                          argument_gram).get(arg_nm) {\n-          @matched_seq(s, _) => {\n-            do s.map() |lf| {\n-                match *lf {\n-                  @matched_nonterminal(parse::token::nt_expr(arg)) =>\n-                    arg, /* whew! list of exprs, here we come! */\n-                  _ => fail ~\"badly-structured parse result\"\n-                }\n-            }\n-          },\n-          _ => fail ~\"badly-structured parse result\"\n-        };\n-\n-    return Some(@{id: parse::next_node_id(cx.parse_sess()),\n-               callee_id: parse::next_node_id(cx.parse_sess()),\n-               node: ast::expr_vec(args, ast::m_imm), span: sp});\n+    es\n }\n \n //"}, {"sha": "a47b64bea3af109f50c49819d9fce81317fcc3a0", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/9a4c669867765d42bdd13fc09eb9a32b7a667a43/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4c669867765d42bdd13fc09eb9a32b7a667a43/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=9a4c669867765d42bdd13fc09eb9a32b7a667a43", "patch": "@@ -10,19 +10,32 @@\n \n use base::*;\n \n-fn expand_syntax_ext(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n-                     _body: ast::mac_body) -> @ast::expr {\n-    let args = get_mac_args_no_max(cx,sp,arg,1u,~\"concat_idents\");\n+fn expand_syntax_ext(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n+    -> base::mac_result {\n     let mut res_str = ~\"\";\n-    for args.each |e| {\n-        res_str += *cx.parse_sess().interner.get(\n-            expr_to_ident(cx, *e, ~\"expected an ident\"));\n+    for tts.eachi |i, e| {\n+        if i & 1 == 1 {\n+            match *e {\n+                ast::tt_tok(_, token::COMMA) => (),\n+                _ => cx.span_fatal(sp, ~\"concat_idents! \\\n+                                         expecting comma.\")\n+            }\n+        } else {\n+            match *e {\n+                ast::tt_tok(_, token::IDENT(ident,_)) =>\n+                res_str += cx.str_of(ident),\n+                _ => cx.span_fatal(sp, ~\"concat_idents! \\\n+                                         requires ident args.\")\n+            }\n+        }\n     }\n     let res = cx.parse_sess().interner.intern(@res_str);\n \n-    return @{id: cx.next_id(),\n-          callee_id: cx.next_id(),\n-          node: ast::expr_path(@{span: sp, global: false, idents: ~[res],\n-                                 rp: None, types: ~[]}),\n-          span: sp};\n+    let e = @{id: cx.next_id(),\n+              callee_id: cx.next_id(),\n+              node: ast::expr_path(@{span: sp, global: false,\n+                                     idents: ~[res],\n+                                     rp: None, types: ~[]}),\n+              span: sp};\n+    mr_expr(e)\n }"}, {"sha": "68db1b41781e40f6041d53518443eb4f09a33803", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9a4c669867765d42bdd13fc09eb9a32b7a667a43/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4c669867765d42bdd13fc09eb9a32b7a667a43/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=9a4c669867765d42bdd13fc09eb9a32b7a667a43", "patch": "@@ -18,18 +18,19 @@ use base::*;\n use build::mk_uniq_str;\n export expand_syntax_ext;\n \n-fn expand_syntax_ext(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n-                     _body: ast::mac_body) -> @ast::expr {\n-    let args = get_mac_args(cx, sp, arg, 1u, option::Some(1u), ~\"env\");\n+fn expand_syntax_ext(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n+    -> base::mac_result {\n+\n+    let var = get_single_str_from_tts(cx, sp, tts, \"env!\");\n \n     // FIXME (#2248): if this was more thorough it would manufacture an\n     // Option<str> rather than just an maybe-empty string.\n \n-    let var = expr_to_str(cx, args[0], ~\"env! requires a string\");\n-    match os::getenv(var) {\n-      option::None => return mk_uniq_str(cx, sp, ~\"\"),\n-      option::Some(ref s) => return mk_uniq_str(cx, sp, (*s))\n-    }\n+    let e = match os::getenv(var) {\n+      option::None => mk_uniq_str(cx, sp, ~\"\"),\n+      option::Some(ref s) => mk_uniq_str(cx, sp, (*s))\n+    };\n+    mr_expr(e)\n }\n \n //"}, {"sha": "a35f351451bdc6ee8c5b66af9e0769611befdaaa", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 34, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/9a4c669867765d42bdd13fc09eb9a32b7a667a43/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4c669867765d42bdd13fc09eb9a32b7a667a43/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=9a4c669867765d42bdd13fc09eb9a32b7a667a43", "patch": "@@ -62,21 +62,6 @@ fn expand_expr(exts: HashMap<~str, syntax_extension>, cx: ext_ctxt,\n \n                     (fully_expanded, s)\n                   }\n-                  Some(normal({expander: exp, span: exp_sp})) => {\n-                    cx.bt_push(ExpandedFrom({call_site: s,\n-                                callie: {name: *extname, span: exp_sp}}));\n-\n-                    //convert the new-style invoc for the old-style macro\n-                    let arg = base::tt_args_to_original_flavor(cx, pth.span,\n-                                                               (*tts));\n-                    let expanded = exp(cx, (*mac).span, arg, None);\n-\n-                    //keep going, outside-in\n-                    let fully_expanded = fld.fold_expr(expanded).node;\n-                    cx.bt_pop();\n-\n-                    (fully_expanded, s)\n-                  }\n                   _ => {\n                     cx.span_fatal(pth.span,\n                                   fmt!(\"'%s' is not a tt-style macro\",\n@@ -119,8 +104,7 @@ fn expand_mod_items(exts: HashMap<~str, syntax_extension>, cx: ext_ctxt,\n               ast::meta_list(ref n, _) => (*n)\n             };\n             match exts.find(mname) {\n-              None | Some(normal(_))\n-                | Some(normal_tt(_)) | Some(item_tt(*)) => items,\n+              None | Some(normal_tt(_)) | Some(item_tt(*)) => items,\n               Some(item_decorator(dec_fn)) => {\n                   cx.bt_push(ExpandedFrom({call_site: attr.span,\n                                            callie: {name: copy mname,\n@@ -262,23 +246,6 @@ fn expand_stmt(exts: HashMap<~str, syntax_extension>, cx: ext_ctxt,\n             (fully_expanded, sp)\n         }\n \n-        Some(normal({expander: exp, span: exp_sp})) => {\n-            cx.bt_push(ExpandedFrom({call_site: sp,\n-                                      callie: {name: *extname,\n-                                               span: exp_sp}}));\n-            //convert the new-style invoc for the old-style macro\n-            let arg = base::tt_args_to_original_flavor(cx, pth.span, tts);\n-            let exp_expr = exp(cx, mac.span, arg, None);\n-            let expanded = @{node: stmt_expr(exp_expr, cx.next_id()),\n-                             span: exp_expr.span};\n-\n-            //keep going, outside-in\n-            let fully_expanded = fld.fold_stmt(expanded).node;\n-            cx.bt_pop();\n-\n-            (fully_expanded, sp)\n-        }\n-\n         _ => {\n             cx.span_fatal(pth.span,\n                           fmt!(\"'%s' is not a tt-style macro\", *extname))"}, {"sha": "46003624a76e512155bf65f3f693f06b521b3007", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9a4c669867765d42bdd13fc09eb9a32b7a667a43/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4c669867765d42bdd13fc09eb9a32b7a667a43/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=9a4c669867765d42bdd13fc09eb9a32b7a667a43", "patch": "@@ -21,9 +21,12 @@ use codemap::span;\n use ext::build::*;\n export expand_syntax_ext;\n \n-fn expand_syntax_ext(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n-                     _body: ast::mac_body) -> @ast::expr {\n-    let args = get_mac_args_no_max(cx, sp, arg, 1u, ~\"fmt\");\n+fn expand_syntax_ext(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n+    -> base::mac_result {\n+    let args = get_exprs_from_tts(cx, copy tts);\n+    if args.len() == 0 {\n+        cx.span_fatal(sp, \"fmt! takes at least 1 argument.\");\n+    }\n     let fmt =\n         expr_to_str(cx, args[0],\n                     ~\"first argument to fmt! must be a string literal.\");\n@@ -37,7 +40,7 @@ fn expand_syntax_ext(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n         parse_fmt_err_(cx, fmtspan, s)\n     };\n     let pieces = parse_fmt_string(fmt, parse_fmt_err);\n-    return pieces_to_expr(cx, sp, pieces, args);\n+    mr_expr(pieces_to_expr(cx, sp, pieces, args))\n }\n \n // FIXME (#2249): A lot of these functions for producing expressions can"}, {"sha": "ededc1a5f7ffc7263ce106884e8852b79ae1da9b", "filename": "src/libsyntax/ext/ident_to_str.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e24ae85025e40aa17915f6c604d89aefbca274bd/src%2Flibsyntax%2Fext%2Fident_to_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e24ae85025e40aa17915f6c604d89aefbca274bd/src%2Flibsyntax%2Fext%2Fident_to_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fident_to_str.rs?ref=e24ae85025e40aa17915f6c604d89aefbca274bd", "patch": "@@ -1,20 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use base::*;\n-use build::mk_uniq_str;\n-\n-fn expand_syntax_ext(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n-                     _body: ast::mac_body) -> @ast::expr {\n-    let args = get_mac_args(cx,sp,arg,1u,option::Some(1u),~\"ident_to_str\");\n-\n-    return mk_uniq_str(cx, sp, *cx.parse_sess().interner.get(\n-        expr_to_ident(cx, args[0u], ~\"expected an ident\")));\n-}"}, {"sha": "8d2b9163f152fd7800c245424bba77f82812d63e", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 34, "deletions": 42, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/9a4c669867765d42bdd13fc09eb9a32b7a667a43/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4c669867765d42bdd13fc09eb9a32b7a667a43/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=9a4c669867765d42bdd13fc09eb9a32b7a667a43", "patch": "@@ -23,63 +23,58 @@ export expand_include_str;\n export expand_include_bin;\n \n /* line!(): expands to the current line number */\n-fn expand_line(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n-               _body: ast::mac_body) -> @ast::expr {\n-    get_mac_args(cx, sp, arg, 0u, option::Some(0u), ~\"line\");\n+fn expand_line(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n+    -> base::mac_result {\n+    base::check_zero_tts(cx, sp, tts, \"line!\");\n     let loc = cx.codemap().lookup_char_pos(sp.lo);\n-    return mk_uint(cx, sp, loc.line);\n+    base::mr_expr(mk_uint(cx, sp, loc.line))\n }\n \n /* col!(): expands to the current column number */\n-fn expand_col(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n-              _body: ast::mac_body) -> @ast::expr {\n-    get_mac_args(cx, sp, arg, 0u, option::Some(0u), ~\"col\");\n+fn expand_col(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n+    -> base::mac_result {\n+    base::check_zero_tts(cx, sp, tts, \"col!\");\n     let loc = cx.codemap().lookup_char_pos(sp.lo);\n-    return mk_uint(cx, sp, loc.col.to_uint());\n+    base::mr_expr(mk_uint(cx, sp, loc.col.to_uint()))\n }\n \n /* file!(): expands to the current filename */\n /* The filemap (`loc.file`) contains a bunch more information we could spit\n  * out if we wanted. */\n-fn expand_file(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n-               _body: ast::mac_body) -> @ast::expr {\n-    get_mac_args(cx, sp, arg, 0u, option::Some(0u), ~\"file\");\n+fn expand_file(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n+    -> base::mac_result {\n+    base::check_zero_tts(cx, sp, tts, \"file!\");\n     let Loc { file: @FileMap { name: filename, _ }, _ } =\n         cx.codemap().lookup_char_pos(sp.lo);\n-    return mk_uniq_str(cx, sp, filename);\n+    base::mr_expr(mk_uniq_str(cx, sp, filename))\n }\n \n-fn expand_stringify(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n-                    _body: ast::mac_body) -> @ast::expr {\n-    let args = get_mac_args(cx, sp, arg, 1u, option::Some(1u), ~\"stringify\");\n-    let s = pprust::expr_to_str(args[0], cx.parse_sess().interner);\n-    return mk_uniq_str(cx, sp, s);\n+fn expand_stringify(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n+    -> base::mac_result {\n+    let s = pprust::tts_to_str(tts, cx.parse_sess().interner);\n+    base::mr_expr(mk_uniq_str(cx, sp, s))\n }\n \n-fn expand_mod(cx: ext_ctxt, sp: span, arg: ast::mac_arg, _body: ast::mac_body)\n-    -> @ast::expr {\n-    get_mac_args(cx, sp, arg, 0u, option::Some(0u), ~\"file\");\n-    return mk_uniq_str(cx, sp,\n-                       str::connect(cx.mod_path().map(\n-                           |x| cx.str_of(*x)), ~\"::\"));\n+fn expand_mod(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n+    -> base::mac_result {\n+    base::check_zero_tts(cx, sp, tts, \"module_path!\");\n+    base::mr_expr(mk_uniq_str(cx, sp,\n+                              str::connect(cx.mod_path().map(\n+                                  |x| cx.str_of(*x)), ~\"::\")))\n }\n \n-fn expand_include(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n-                  _body: ast::mac_body) -> @ast::expr {\n-    let args = get_mac_args(cx, sp, arg, 1u, option::Some(1u), ~\"include\");\n-    let file = expr_to_str(cx, args[0], ~\"include_str! requires a string\");\n+fn expand_include(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n+    -> base::mac_result {\n+    let file = get_single_str_from_tts(cx, sp, tts, \"include!\");\n     let p = parse::new_sub_parser_from_file(\n         cx.parse_sess(), cx.cfg(),\n         &res_rel_file(cx, sp, &Path(file)), sp);\n-    return p.parse_expr();\n+    base::mr_expr(p.parse_expr())\n }\n \n-fn expand_include_str(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n-                      _body: ast::mac_body) -> @ast::expr {\n-    let args = get_mac_args(cx,sp,arg,1u,option::Some(1u),~\"include_str\");\n-\n-    let file = expr_to_str(cx, args[0], ~\"include_str! requires a string\");\n-\n+fn expand_include_str(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n+    -> base::mac_result {\n+    let file = get_single_str_from_tts(cx, sp, tts, \"include_str!\");\n     let res = io::read_whole_file_str(&res_rel_file(cx, sp, &Path(file)));\n     match res {\n       result::Ok(_) => { /* Continue. */ }\n@@ -88,21 +83,18 @@ fn expand_include_str(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n       }\n     }\n \n-    return mk_uniq_str(cx, sp, result::unwrap(res));\n+    base::mr_expr(mk_uniq_str(cx, sp, result::unwrap(res)))\n }\n \n-fn expand_include_bin(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n-                      _body: ast::mac_body) -> @ast::expr {\n-    let args = get_mac_args(cx,sp,arg,1u,option::Some(1u),~\"include_bin\");\n-\n-    let file = expr_to_str(cx, args[0], ~\"include_bin! requires a string\");\n-\n+fn expand_include_bin(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n+    -> base::mac_result {\n+    let file = get_single_str_from_tts(cx, sp, tts, \"include_bin!\");\n     match io::read_whole_file(&res_rel_file(cx, sp, &Path(file))) {\n       result::Ok(src) => {\n         let u8_exprs = vec::map(src, |char| {\n             mk_u8(cx, sp, *char)\n         });\n-        return mk_base_vec_e(cx, sp, u8_exprs);\n+        base::mr_expr(mk_base_vec_e(cx, sp, u8_exprs))\n       }\n       result::Err(ref e) => {\n         cx.parse_sess().span_diagnostic.handler().fatal((*e))"}, {"sha": "d90341254cc3404e93b1d9d76052da86e7e56d5b", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a4c669867765d42bdd13fc09eb9a32b7a667a43/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4c669867765d42bdd13fc09eb9a32b7a667a43/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=9a4c669867765d42bdd13fc09eb9a32b7a667a43", "patch": "@@ -154,8 +154,7 @@ fn mk_printer(out: io::Writer, linewidth: uint) -> printer {\n                mut top: 0,\n                mut bottom: 0,\n                print_stack: DVec(),\n-               mut pending_indentation: 0,\n-               mut token_tree_last_was_ident: false})\n+               mut pending_indentation: 0 })\n }\n \n \n@@ -261,7 +260,6 @@ type printer_ = {\n     print_stack: DVec<print_stack_elt>,\n     // buffered indentation to avoid writing trailing whitespace\n     mut pending_indentation: int,\n-    mut token_tree_last_was_ident: bool\n };\n \n enum printer {"}, {"sha": "fa384341fb9734f1199721a7ebd16a4f4f2c9924", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/9a4c669867765d42bdd13fc09eb9a32b7a667a43/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4c669867765d42bdd13fc09eb9a32b7a667a43/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=9a4c669867765d42bdd13fc09eb9a32b7a667a43", "patch": "@@ -118,6 +118,10 @@ fn tt_to_str(tt: ast::token_tree, intr: @ident_interner) -> ~str {\n     to_str(tt, print_tt, intr)\n }\n \n+fn tts_to_str(tts: &[ast::token_tree], intr: @ident_interner) -> ~str {\n+    to_str(tts, print_tts, intr)\n+}\n+\n fn stmt_to_str(s: ast::stmt, intr: @ident_interner) -> ~str {\n     to_str(s, print_stmt, intr)\n }\n@@ -584,9 +588,7 @@ fn print_item(s: ps, &&item: @ast::item) {\n         print_ident(s, item.ident);\n         cbox(s, indent_unit);\n         popen(s);\n-        for (*tts).each |tt| {\n-            print_tt(s, *tt);\n-        }\n+        print_tts(s, *tts);\n         pclose(s);\n         end(s);\n       }\n@@ -736,17 +738,9 @@ fn print_struct(s: ps, struct_def: @ast::struct_def, tps: ~[ast::ty_param],\n /// expression arguments as expressions). It can be done! I think.\n fn print_tt(s: ps, tt: ast::token_tree) {\n     match tt {\n-      ast::tt_delim(ref tts) =>\n-        for (*tts).each() |tt_elt| { print_tt(s, *tt_elt); },\n+      ast::tt_delim(ref tts) => print_tts(s, *tts),\n       ast::tt_tok(_, ref tk) => {\n-        match (*tk) {\n-          parse::token::IDENT(*) => { // don't let idents run together\n-            if s.s.token_tree_last_was_ident { word(s.s, ~\" \") }\n-            s.s.token_tree_last_was_ident = true;\n-          }\n-          _ => { s.s.token_tree_last_was_ident = false; }\n-        }\n-        word(s.s, parse::token::to_str(s.intr, (*tk)));\n+          word(s.s, parse::token::to_str(s.intr, (*tk)));\n       }\n       ast::tt_seq(_, ref tts, ref sep, zerok) => {\n         word(s.s, ~\"$(\");\n@@ -757,16 +751,25 @@ fn print_tt(s: ps, tt: ast::token_tree) {\n           None => ()\n         }\n         word(s.s, if zerok { ~\"*\" } else { ~\"+\" });\n-        s.s.token_tree_last_was_ident = false;\n       }\n       ast::tt_nonterminal(_, name) => {\n         word(s.s, ~\"$\");\n         print_ident(s, name);\n-        s.s.token_tree_last_was_ident = true;\n       }\n     }\n }\n \n+fn print_tts(s: ps, &&tts: &[ast::token_tree]) {\n+    ibox(s, 0);\n+    for tts.eachi |i, tt| {\n+        if i != 0 {\n+            space(s.s);\n+        }\n+        print_tt(s, *tt);\n+    }\n+    end(s);\n+}\n+\n fn print_variant(s: ps, v: ast::variant) {\n     print_visibility(s, v.node.vis);\n     match v.node.kind {\n@@ -1001,7 +1004,7 @@ fn print_mac(s: ps, m: ast::mac) {\n         print_path(s, pth, false);\n         word(s.s, ~\"!\");\n         popen(s);\n-        for (*tts).each() |tt| { print_tt(s, *tt); }\n+        print_tts(s, *tts);\n         pclose(s);\n       }\n     }"}, {"sha": "fbc5f10fcd6f9e794d7a9fc45814756faf9f05c9", "filename": "src/libsyntax/syntax.rc", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9a4c669867765d42bdd13fc09eb9a32b7a667a43/src%2Flibsyntax%2Fsyntax.rc", "raw_url": "https://github.com/rust-lang/rust/raw/9a4c669867765d42bdd13fc09eb9a32b7a667a43/src%2Flibsyntax%2Fsyntax.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsyntax.rc?ref=9a4c669867765d42bdd13fc09eb9a32b7a667a43", "patch": "@@ -109,9 +109,6 @@ mod ext {\n     #[path = \"ext/concat_idents.rs\"]\n     mod concat_idents;\n     #[legacy_exports]\n-    #[path = \"ext/ident_to_str.rs\"]\n-    mod ident_to_str;\n-    #[legacy_exports]\n     #[path = \"ext/log_syntax.rs\"]\n     mod log_syntax;\n     #[legacy_exports]"}, {"sha": "bf6bcd6f0817d9635f91d9e66f64b6c622da2e22", "filename": "src/test/compile-fail/ext-noname.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e24ae85025e40aa17915f6c604d89aefbca274bd/src%2Ftest%2Fcompile-fail%2Fext-noname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e24ae85025e40aa17915f6c604d89aefbca274bd/src%2Ftest%2Fcompile-fail%2Fext-noname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fext-noname.rs?ref=e24ae85025e40aa17915f6c604d89aefbca274bd", "patch": "@@ -1,15 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern:expected a syntax expander name\n-\n-fn main() {\n-  #();\n-}"}, {"sha": "7ff1357dcf3c90845f777375540918c60710c0c6", "filename": "src/test/compile-fail/extenv-no-args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a4c669867765d42bdd13fc09eb9a32b7a667a43/src%2Ftest%2Fcompile-fail%2Fextenv-no-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4c669867765d42bdd13fc09eb9a32b7a667a43/src%2Ftest%2Fcompile-fail%2Fextenv-no-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextenv-no-args.rs?ref=9a4c669867765d42bdd13fc09eb9a32b7a667a43", "patch": "@@ -8,6 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: env! takes between 1 and 1 arguments\n+// error-pattern: env! takes 1 argument\n \n fn main() { env!(); }"}, {"sha": "b1b2001abc35874dc140d66fb442b5d75968c27a", "filename": "src/test/compile-fail/extenv-too-many-args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a4c669867765d42bdd13fc09eb9a32b7a667a43/src%2Ftest%2Fcompile-fail%2Fextenv-too-many-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4c669867765d42bdd13fc09eb9a32b7a667a43/src%2Ftest%2Fcompile-fail%2Fextenv-too-many-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextenv-too-many-args.rs?ref=9a4c669867765d42bdd13fc09eb9a32b7a667a43", "patch": "@@ -8,6 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: env! takes between 1 and 1 arguments\n+// error-pattern: env! takes 1 argument\n \n fn main() { env!(\"one\", \"two\"); }"}, {"sha": "cd9308e7b3f25f562b4261dd2a0e787657cae82e", "filename": "src/test/compile-fail/extfmt-no-args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a4c669867765d42bdd13fc09eb9a32b7a667a43/src%2Ftest%2Fcompile-fail%2Fextfmt-no-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4c669867765d42bdd13fc09eb9a32b7a667a43/src%2Ftest%2Fcompile-fail%2Fextfmt-no-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-no-args.rs?ref=9a4c669867765d42bdd13fc09eb9a32b7a667a43", "patch": "@@ -8,6 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:fmt! needs at least 1 arguments\n+// error-pattern:fmt! takes at least 1 argument\n \n fn main() { fmt!(); }"}, {"sha": "ef3a82d1e2b699e7b44c74281beedff0ab4b0052", "filename": "src/test/run-pass/class-attributes-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a4c669867765d42bdd13fc09eb9a32b7a667a43/src%2Ftest%2Frun-pass%2Fclass-attributes-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4c669867765d42bdd13fc09eb9a32b7a667a43/src%2Ftest%2Frun-pass%2Fclass-attributes-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-attributes-1.rs?ref=9a4c669867765d42bdd13fc09eb9a32b7a667a43", "patch": "@@ -16,7 +16,7 @@ struct cat {\n \n impl cat: Drop {\n     #[cat_dropper]\n-    fn finalize(&self) { error!(\"%s landed on hir feet\",self.name); }\n+    fn finalize(&self) { error!(\"%s landed on hir feet\" , self . name); }\n }\n \n "}, {"sha": "aafd71d9162c838391e8ef4691286d34e5cf90fc", "filename": "src/test/run-pass/syntax-extension-minor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a4c669867765d42bdd13fc09eb9a32b7a667a43/src%2Ftest%2Frun-pass%2Fsyntax-extension-minor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4c669867765d42bdd13fc09eb9a32b7a667a43/src%2Ftest%2Frun-pass%2Fsyntax-extension-minor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsyntax-extension-minor.rs?ref=9a4c669867765d42bdd13fc09eb9a32b7a667a43", "patch": "@@ -13,6 +13,6 @@ fn main() {\n     let asdf_fdsa = ~\"<.<\";\n     assert (concat_idents!(asd, f_f, dsa) == ~\"<.<\");\n \n-    assert (ident_to_str!(use_mention_distinction) ==\n+    assert (stringify!(use_mention_distinction) ==\n                 ~\"use_mention_distinction\");\n }"}, {"sha": "0d7174370a084d18225eb0e9cebd96941ba4869c", "filename": "src/test/run-pass/syntax-extension-source-utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a4c669867765d42bdd13fc09eb9a32b7a667a43/src%2Ftest%2Frun-pass%2Fsyntax-extension-source-utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4c669867765d42bdd13fc09eb9a32b7a667a43/src%2Ftest%2Frun-pass%2Fsyntax-extension-source-utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsyntax-extension-source-utils.rs?ref=9a4c669867765d42bdd13fc09eb9a32b7a667a43", "patch": "@@ -24,7 +24,7 @@ fn main() {\n     assert(line!() == 24);\n     assert(col!() == 11);\n     assert(file!().ends_with(~\"syntax-extension-source-utils.rs\"));\n-    assert(stringify!((2*3) + 5) == ~\"(2 * 3) + 5\");\n+    assert(stringify!((2*3) + 5) == ~\"( 2 * 3 ) + 5\");\n     assert(include!(\"syntax-extension-source-utils-files/includeme.fragment\")\n            == ~\"victory robot 6\");\n "}]}