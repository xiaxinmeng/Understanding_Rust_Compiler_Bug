{"sha": "2ba0d2acbd6cb01fb07619628882120d5b66bd59", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiYTBkMmFjYmQ2Y2IwMWZiMDc2MTk2Mjg4ODIxMjBkNWI2NmJkNTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-29T22:51:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-29T22:51:02Z"}, "message": "Auto merge of #66942 - cjgillot:hirene-ty, r=Zoxc\n\nAllocate HIR on an arena 3/4 -- Ty\n\nThis is the third PR in the series started by #66931 and #66936\n\nOnce again, commits don't really make sense on their own.\nThey are mostly split by type of compile error.\n\nThe additional diff is here: https://github.com/cjgillot/rust/compare/hirene-expr...hirene-ty", "tree": {"sha": "8c3c08d9dd15c50869f1101f4e16d7b35e229ad5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c3c08d9dd15c50869f1101f4e16d7b35e229ad5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2ba0d2acbd6cb01fb07619628882120d5b66bd59", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2ba0d2acbd6cb01fb07619628882120d5b66bd59", "html_url": "https://github.com/rust-lang/rust/commit/2ba0d2acbd6cb01fb07619628882120d5b66bd59", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2ba0d2acbd6cb01fb07619628882120d5b66bd59/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "da3629b05f8f1b425a738bfe9fe9aedd47c5417a", "url": "https://api.github.com/repos/rust-lang/rust/commits/da3629b05f8f1b425a738bfe9fe9aedd47c5417a", "html_url": "https://github.com/rust-lang/rust/commit/da3629b05f8f1b425a738bfe9fe9aedd47c5417a"}, {"sha": "71f745852a1e22602bf4964a3d8308043ac46171", "url": "https://api.github.com/repos/rust-lang/rust/commits/71f745852a1e22602bf4964a3d8308043ac46171", "html_url": "https://github.com/rust-lang/rust/commit/71f745852a1e22602bf4964a3d8308043ac46171"}], "stats": {"total": 1881, "additions": 965, "deletions": 916}, "files": [{"sha": "f551d9e31a6583a80ee2b8c94d89279bb7110d3f", "filename": "src/librustc/arena.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Farena.rs?ref=2ba0d2acbd6cb01fb07619628882120d5b66bd59", "patch": "@@ -128,26 +128,34 @@ macro_rules! arena_types {\n             [] arm: rustc::hir::Arm<$tcx>,\n             [] attribute: syntax::ast::Attribute,\n             [] block: rustc::hir::Block<$tcx>,\n+            [] bare_fn_ty: rustc::hir::BareFnTy<$tcx>,\n             [few] global_asm: rustc::hir::GlobalAsm,\n+            [] generic_arg: rustc::hir::GenericArg<$tcx>,\n+            [] generic_args: rustc::hir::GenericArgs<$tcx>,\n+            [] generic_bound: rustc::hir::GenericBound<$tcx>,\n+            [] generic_param: rustc::hir::GenericParam<$tcx>,\n             [] expr: rustc::hir::Expr<$tcx>,\n             [] field: rustc::hir::Field<$tcx>,\n             [] field_pat: rustc::hir::FieldPat<$tcx>,\n-            [] fn_decl: rustc::hir::FnDecl,\n+            [] fn_decl: rustc::hir::FnDecl<$tcx>,\n             [] foreign_item: rustc::hir::ForeignItem<$tcx>,\n-            [] impl_item_ref: rustc::hir::ImplItemRef,\n+            [] impl_item_ref: rustc::hir::ImplItemRef<$tcx>,\n             [] inline_asm: rustc::hir::InlineAsm<$tcx>,\n             [] local: rustc::hir::Local<$tcx>,\n             [few] macro_def: rustc::hir::MacroDef<$tcx>,\n             [] param: rustc::hir::Param<$tcx>,\n             [] pat: rustc::hir::Pat<$tcx>,\n-            [] path: rustc::hir::Path,\n-            [] path_segment: rustc::hir::PathSegment,\n-            [] qpath: rustc::hir::QPath,\n+            [] path: rustc::hir::Path<$tcx>,\n+            [] path_segment: rustc::hir::PathSegment<$tcx>,\n+            [] poly_trait_ref: rustc::hir::PolyTraitRef<$tcx>,\n+            [] qpath: rustc::hir::QPath<$tcx>,\n             [] stmt: rustc::hir::Stmt<$tcx>,\n             [] struct_field: rustc::hir::StructField<$tcx>,\n             [] trait_item_ref: rustc::hir::TraitItemRef,\n-            [] ty: rustc::hir::Ty,\n+            [] ty: rustc::hir::Ty<$tcx>,\n+            [] type_binding: rustc::hir::TypeBinding<$tcx>,\n             [] variant: rustc::hir::Variant<$tcx>,\n+            [] where_predicate: rustc::hir::WherePredicate<$tcx>,\n         ], $tcx);\n     )\n }"}, {"sha": "c265b53b37d52c9e1287edf950ee36be13e156ea", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 75, "deletions": 66, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=2ba0d2acbd6cb01fb07619628882120d5b66bd59", "patch": "@@ -42,10 +42,10 @@ use syntax_pos::Span;\n #[derive(Copy, Clone)]\n pub enum FnKind<'a> {\n     /// `#[xxx] pub async/const/extern \"Abi\" fn foo()`\n-    ItemFn(Ident, &'a Generics, FnHeader, &'a Visibility, &'a [Attribute]),\n+    ItemFn(Ident, &'a Generics<'a>, FnHeader, &'a Visibility<'a>, &'a [Attribute]),\n \n     /// `fn foo(&self)`\n-    Method(Ident, &'a FnSig, Option<&'a Visibility>, &'a [Attribute]),\n+    Method(Ident, &'a FnSig<'a>, Option<&'a Visibility<'a>>, &'a [Attribute]),\n \n     /// `|x, y| {}`\n     Closure(&'a [Attribute]),\n@@ -274,25 +274,25 @@ pub trait Visitor<'v>: Sized {\n     fn visit_expr(&mut self, ex: &'v Expr<'v>) {\n         walk_expr(self, ex)\n     }\n-    fn visit_ty(&mut self, t: &'v Ty) {\n+    fn visit_ty(&mut self, t: &'v Ty<'v>) {\n         walk_ty(self, t)\n     }\n-    fn visit_generic_param(&mut self, p: &'v GenericParam) {\n+    fn visit_generic_param(&mut self, p: &'v GenericParam<'v>) {\n         walk_generic_param(self, p)\n     }\n-    fn visit_generics(&mut self, g: &'v Generics) {\n+    fn visit_generics(&mut self, g: &'v Generics<'v>) {\n         walk_generics(self, g)\n     }\n-    fn visit_where_predicate(&mut self, predicate: &'v WherePredicate) {\n+    fn visit_where_predicate(&mut self, predicate: &'v WherePredicate<'v>) {\n         walk_where_predicate(self, predicate)\n     }\n-    fn visit_fn_decl(&mut self, fd: &'v FnDecl) {\n+    fn visit_fn_decl(&mut self, fd: &'v FnDecl<'v>) {\n         walk_fn_decl(self, fd)\n     }\n-    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl, b: BodyId, s: Span, id: HirId) {\n+    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl<'v>, b: BodyId, s: Span, id: HirId) {\n         walk_fn(self, fk, fd, b, s, id)\n     }\n-    fn visit_use(&mut self, path: &'v Path, hir_id: HirId) {\n+    fn visit_use(&mut self, path: &'v Path<'v>, hir_id: HirId) {\n         walk_use(self, path, hir_id)\n     }\n     fn visit_trait_item(&mut self, ti: &'v TraitItem<'v>) {\n@@ -304,23 +304,23 @@ pub trait Visitor<'v>: Sized {\n     fn visit_impl_item(&mut self, ii: &'v ImplItem<'v>) {\n         walk_impl_item(self, ii)\n     }\n-    fn visit_impl_item_ref(&mut self, ii: &'v ImplItemRef) {\n+    fn visit_impl_item_ref(&mut self, ii: &'v ImplItemRef<'v>) {\n         walk_impl_item_ref(self, ii)\n     }\n-    fn visit_trait_ref(&mut self, t: &'v TraitRef) {\n+    fn visit_trait_ref(&mut self, t: &'v TraitRef<'v>) {\n         walk_trait_ref(self, t)\n     }\n-    fn visit_param_bound(&mut self, bounds: &'v GenericBound) {\n+    fn visit_param_bound(&mut self, bounds: &'v GenericBound<'v>) {\n         walk_param_bound(self, bounds)\n     }\n-    fn visit_poly_trait_ref(&mut self, t: &'v PolyTraitRef, m: TraitBoundModifier) {\n+    fn visit_poly_trait_ref(&mut self, t: &'v PolyTraitRef<'v>, m: TraitBoundModifier) {\n         walk_poly_trait_ref(self, t, m)\n     }\n     fn visit_variant_data(\n         &mut self,\n         s: &'v VariantData<'v>,\n         _: Name,\n-        _: &'v Generics,\n+        _: &'v Generics<'v>,\n         _parent_id: HirId,\n         _: Span,\n     ) {\n@@ -332,19 +332,19 @@ pub trait Visitor<'v>: Sized {\n     fn visit_enum_def(\n         &mut self,\n         enum_definition: &'v EnumDef<'v>,\n-        generics: &'v Generics,\n+        generics: &'v Generics<'v>,\n         item_id: HirId,\n         _: Span,\n     ) {\n         walk_enum_def(self, enum_definition, generics, item_id)\n     }\n-    fn visit_variant(&mut self, v: &'v Variant<'v>, g: &'v Generics, item_id: HirId) {\n+    fn visit_variant(&mut self, v: &'v Variant<'v>, g: &'v Generics<'v>, item_id: HirId) {\n         walk_variant(self, v, g, item_id)\n     }\n     fn visit_label(&mut self, label: &'v Label) {\n         walk_label(self, label)\n     }\n-    fn visit_generic_arg(&mut self, generic_arg: &'v GenericArg) {\n+    fn visit_generic_arg(&mut self, generic_arg: &'v GenericArg<'v>) {\n         match generic_arg {\n             GenericArg::Lifetime(lt) => self.visit_lifetime(lt),\n             GenericArg::Type(ty) => self.visit_ty(ty),\n@@ -354,26 +354,26 @@ pub trait Visitor<'v>: Sized {\n     fn visit_lifetime(&mut self, lifetime: &'v Lifetime) {\n         walk_lifetime(self, lifetime)\n     }\n-    fn visit_qpath(&mut self, qpath: &'v QPath, id: HirId, span: Span) {\n+    fn visit_qpath(&mut self, qpath: &'v QPath<'v>, id: HirId, span: Span) {\n         walk_qpath(self, qpath, id, span)\n     }\n-    fn visit_path(&mut self, path: &'v Path, _id: HirId) {\n+    fn visit_path(&mut self, path: &'v Path<'v>, _id: HirId) {\n         walk_path(self, path)\n     }\n-    fn visit_path_segment(&mut self, path_span: Span, path_segment: &'v PathSegment) {\n+    fn visit_path_segment(&mut self, path_span: Span, path_segment: &'v PathSegment<'v>) {\n         walk_path_segment(self, path_span, path_segment)\n     }\n-    fn visit_generic_args(&mut self, path_span: Span, generic_args: &'v GenericArgs) {\n+    fn visit_generic_args(&mut self, path_span: Span, generic_args: &'v GenericArgs<'v>) {\n         walk_generic_args(self, path_span, generic_args)\n     }\n-    fn visit_assoc_type_binding(&mut self, type_binding: &'v TypeBinding) {\n+    fn visit_assoc_type_binding(&mut self, type_binding: &'v TypeBinding<'v>) {\n         walk_assoc_type_binding(self, type_binding)\n     }\n     fn visit_attribute(&mut self, _attr: &'v Attribute) {}\n     fn visit_macro_def(&mut self, macro_def: &'v MacroDef<'v>) {\n         walk_macro_def(self, macro_def)\n     }\n-    fn visit_vis(&mut self, vis: &'v Visibility) {\n+    fn visit_vis(&mut self, vis: &'v Visibility<'v>) {\n         walk_vis(self, vis)\n     }\n     fn visit_associated_item_kind(&mut self, kind: &'v AssocItemKind) {\n@@ -445,16 +445,16 @@ pub fn walk_lifetime<'v, V: Visitor<'v>>(visitor: &mut V, lifetime: &'v Lifetime\n \n pub fn walk_poly_trait_ref<'v, V>(\n     visitor: &mut V,\n-    trait_ref: &'v PolyTraitRef,\n+    trait_ref: &'v PolyTraitRef<'v>,\n     _modifier: TraitBoundModifier,\n ) where\n     V: Visitor<'v>,\n {\n-    walk_list!(visitor, visit_generic_param, &trait_ref.bound_generic_params);\n+    walk_list!(visitor, visit_generic_param, trait_ref.bound_generic_params);\n     visitor.visit_trait_ref(&trait_ref.trait_ref);\n }\n \n-pub fn walk_trait_ref<'v, V>(visitor: &mut V, trait_ref: &'v TraitRef)\n+pub fn walk_trait_ref<'v, V>(visitor: &mut V, trait_ref: &'v TraitRef<'v>)\n where\n     V: Visitor<'v>,\n {\n@@ -509,7 +509,7 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item<'v>) {\n             visitor.visit_ty(ty);\n             visitor.visit_generics(generics)\n         }\n-        ItemKind::OpaqueTy(OpaqueTy { ref generics, ref bounds, .. }) => {\n+        ItemKind::OpaqueTy(OpaqueTy { ref generics, bounds, .. }) => {\n             visitor.visit_id(item.hir_id);\n             walk_generics(visitor, generics);\n             walk_list!(visitor, visit_param_bound, bounds);\n@@ -538,13 +538,13 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item<'v>) {\n                 item.span,\n             );\n         }\n-        ItemKind::Trait(.., ref generics, ref bounds, trait_item_refs) => {\n+        ItemKind::Trait(.., ref generics, bounds, trait_item_refs) => {\n             visitor.visit_id(item.hir_id);\n             visitor.visit_generics(generics);\n             walk_list!(visitor, visit_param_bound, bounds);\n             walk_list!(visitor, visit_trait_item_ref, trait_item_refs);\n         }\n-        ItemKind::TraitAlias(ref generics, ref bounds) => {\n+        ItemKind::TraitAlias(ref generics, bounds) => {\n             visitor.visit_id(item.hir_id);\n             visitor.visit_generics(generics);\n             walk_list!(visitor, visit_param_bound, bounds);\n@@ -553,15 +553,15 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item<'v>) {\n     walk_list!(visitor, visit_attribute, item.attrs);\n }\n \n-pub fn walk_use<'v, V: Visitor<'v>>(visitor: &mut V, path: &'v Path, hir_id: HirId) {\n+pub fn walk_use<'v, V: Visitor<'v>>(visitor: &mut V, path: &'v Path<'v>, hir_id: HirId) {\n     visitor.visit_id(hir_id);\n     visitor.visit_path(path, hir_id);\n }\n \n pub fn walk_enum_def<'v, V: Visitor<'v>>(\n     visitor: &mut V,\n     enum_definition: &'v EnumDef<'v>,\n-    generics: &'v Generics,\n+    generics: &'v Generics<'v>,\n     item_id: HirId,\n ) {\n     visitor.visit_id(item_id);\n@@ -571,7 +571,7 @@ pub fn walk_enum_def<'v, V: Visitor<'v>>(\n pub fn walk_variant<'v, V: Visitor<'v>>(\n     visitor: &mut V,\n     variant: &'v Variant<'v>,\n-    generics: &'v Generics,\n+    generics: &'v Generics<'v>,\n     parent_item_id: HirId,\n ) {\n     visitor.visit_ident(variant.ident);\n@@ -587,7 +587,7 @@ pub fn walk_variant<'v, V: Visitor<'v>>(\n     walk_list!(visitor, visit_attribute, variant.attrs);\n }\n \n-pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n+pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty<'v>) {\n     visitor.visit_id(typ.hir_id);\n \n     match typ.kind {\n@@ -598,25 +598,25 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n             visitor.visit_ty(&mutable_type.ty)\n         }\n         TyKind::Never => {}\n-        TyKind::Tup(ref tuple_element_types) => {\n+        TyKind::Tup(tuple_element_types) => {\n             walk_list!(visitor, visit_ty, tuple_element_types);\n         }\n         TyKind::BareFn(ref function_declaration) => {\n-            walk_list!(visitor, visit_generic_param, &function_declaration.generic_params);\n+            walk_list!(visitor, visit_generic_param, function_declaration.generic_params);\n             visitor.visit_fn_decl(&function_declaration.decl);\n         }\n         TyKind::Path(ref qpath) => {\n             visitor.visit_qpath(qpath, typ.hir_id, typ.span);\n         }\n-        TyKind::Def(item_id, ref lifetimes) => {\n+        TyKind::Def(item_id, lifetimes) => {\n             visitor.visit_nested_item(item_id);\n             walk_list!(visitor, visit_generic_arg, lifetimes);\n         }\n         TyKind::Array(ref ty, ref length) => {\n             visitor.visit_ty(ty);\n             visitor.visit_anon_const(length)\n         }\n-        TyKind::TraitObject(ref bounds, ref lifetime) => {\n+        TyKind::TraitObject(bounds, ref lifetime) => {\n             for bound in bounds {\n                 visitor.visit_poly_trait_ref(bound, TraitBoundModifier::None);\n             }\n@@ -627,7 +627,12 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n     }\n }\n \n-pub fn walk_qpath<'v, V: Visitor<'v>>(visitor: &mut V, qpath: &'v QPath, id: HirId, span: Span) {\n+pub fn walk_qpath<'v, V: Visitor<'v>>(\n+    visitor: &mut V,\n+    qpath: &'v QPath<'v>,\n+    id: HirId,\n+    span: Span,\n+) {\n     match *qpath {\n         QPath::Resolved(ref maybe_qself, ref path) => {\n             if let Some(ref qself) = *maybe_qself {\n@@ -642,16 +647,16 @@ pub fn walk_qpath<'v, V: Visitor<'v>>(visitor: &mut V, qpath: &'v QPath, id: Hir\n     }\n }\n \n-pub fn walk_path<'v, V: Visitor<'v>>(visitor: &mut V, path: &'v Path) {\n-    for segment in &path.segments {\n+pub fn walk_path<'v, V: Visitor<'v>>(visitor: &mut V, path: &'v Path<'v>) {\n+    for segment in path.segments {\n         visitor.visit_path_segment(path.span, segment);\n     }\n }\n \n pub fn walk_path_segment<'v, V: Visitor<'v>>(\n     visitor: &mut V,\n     path_span: Span,\n-    segment: &'v PathSegment,\n+    segment: &'v PathSegment<'v>,\n ) {\n     visitor.visit_ident(segment.ident);\n     if let Some(id) = segment.hir_id {\n@@ -665,20 +670,23 @@ pub fn walk_path_segment<'v, V: Visitor<'v>>(\n pub fn walk_generic_args<'v, V: Visitor<'v>>(\n     visitor: &mut V,\n     _path_span: Span,\n-    generic_args: &'v GenericArgs,\n+    generic_args: &'v GenericArgs<'v>,\n ) {\n     walk_list!(visitor, visit_generic_arg, &generic_args.args);\n-    walk_list!(visitor, visit_assoc_type_binding, &generic_args.bindings);\n+    walk_list!(visitor, visit_assoc_type_binding, generic_args.bindings);\n }\n \n-pub fn walk_assoc_type_binding<'v, V: Visitor<'v>>(visitor: &mut V, type_binding: &'v TypeBinding) {\n+pub fn walk_assoc_type_binding<'v, V: Visitor<'v>>(\n+    visitor: &mut V,\n+    type_binding: &'v TypeBinding<'v>,\n+) {\n     visitor.visit_id(type_binding.hir_id);\n     visitor.visit_ident(type_binding.ident);\n     match type_binding.kind {\n         TypeBindingKind::Equality { ref ty } => {\n             visitor.visit_ty(ty);\n         }\n-        TypeBindingKind::Constraint { ref bounds } => {\n+        TypeBindingKind::Constraint { bounds } => {\n             walk_list!(visitor, visit_param_bound, bounds);\n         }\n     }\n@@ -747,7 +755,7 @@ pub fn walk_foreign_item<'v, V: Visitor<'v>>(visitor: &mut V, foreign_item: &'v\n     walk_list!(visitor, visit_attribute, foreign_item.attrs);\n }\n \n-pub fn walk_param_bound<'v, V: Visitor<'v>>(visitor: &mut V, bound: &'v GenericBound) {\n+pub fn walk_param_bound<'v, V: Visitor<'v>>(visitor: &mut V, bound: &'v GenericBound<'v>) {\n     match *bound {\n         GenericBound::Trait(ref typ, modifier) => {\n             visitor.visit_poly_trait_ref(typ, modifier);\n@@ -756,9 +764,9 @@ pub fn walk_param_bound<'v, V: Visitor<'v>>(visitor: &mut V, bound: &'v GenericB\n     }\n }\n \n-pub fn walk_generic_param<'v, V: Visitor<'v>>(visitor: &mut V, param: &'v GenericParam) {\n+pub fn walk_generic_param<'v, V: Visitor<'v>>(visitor: &mut V, param: &'v GenericParam<'v>) {\n     visitor.visit_id(param.hir_id);\n-    walk_list!(visitor, visit_attribute, &param.attrs);\n+    walk_list!(visitor, visit_attribute, param.attrs);\n     match param.name {\n         ParamName::Plain(ident) => visitor.visit_ident(ident),\n         ParamName::Error | ParamName::Fresh(_) => {}\n@@ -768,29 +776,30 @@ pub fn walk_generic_param<'v, V: Visitor<'v>>(visitor: &mut V, param: &'v Generi\n         GenericParamKind::Type { ref default, .. } => walk_list!(visitor, visit_ty, default),\n         GenericParamKind::Const { ref ty } => visitor.visit_ty(ty),\n     }\n-    walk_list!(visitor, visit_param_bound, &param.bounds);\n+    walk_list!(visitor, visit_param_bound, param.bounds);\n }\n \n-pub fn walk_generics<'v, V: Visitor<'v>>(visitor: &mut V, generics: &'v Generics) {\n+pub fn walk_generics<'v, V: Visitor<'v>>(visitor: &mut V, generics: &'v Generics<'v>) {\n     walk_list!(visitor, visit_generic_param, &generics.params);\n-    walk_list!(visitor, visit_where_predicate, &generics.where_clause.predicates);\n+    walk_list!(visitor, visit_where_predicate, generics.where_clause.predicates);\n }\n \n-pub fn walk_where_predicate<'v, V: Visitor<'v>>(visitor: &mut V, predicate: &'v WherePredicate) {\n+pub fn walk_where_predicate<'v, V: Visitor<'v>>(\n+    visitor: &mut V,\n+    predicate: &'v WherePredicate<'v>,\n+) {\n     match predicate {\n         &WherePredicate::BoundPredicate(WhereBoundPredicate {\n             ref bounded_ty,\n-            ref bounds,\n-            ref bound_generic_params,\n+            bounds,\n+            bound_generic_params,\n             ..\n         }) => {\n             visitor.visit_ty(bounded_ty);\n             walk_list!(visitor, visit_param_bound, bounds);\n             walk_list!(visitor, visit_generic_param, bound_generic_params);\n         }\n-        &WherePredicate::RegionPredicate(WhereRegionPredicate {\n-            ref lifetime, ref bounds, ..\n-        }) => {\n+        &WherePredicate::RegionPredicate(WhereRegionPredicate { ref lifetime, bounds, .. }) => {\n             visitor.visit_lifetime(lifetime);\n             walk_list!(visitor, visit_param_bound, bounds);\n         }\n@@ -804,14 +813,14 @@ pub fn walk_where_predicate<'v, V: Visitor<'v>>(visitor: &mut V, predicate: &'v\n     }\n }\n \n-pub fn walk_fn_ret_ty<'v, V: Visitor<'v>>(visitor: &mut V, ret_ty: &'v FunctionRetTy) {\n+pub fn walk_fn_ret_ty<'v, V: Visitor<'v>>(visitor: &mut V, ret_ty: &'v FunctionRetTy<'v>) {\n     if let Return(ref output_ty) = *ret_ty {\n         visitor.visit_ty(output_ty)\n     }\n }\n \n-pub fn walk_fn_decl<'v, V: Visitor<'v>>(visitor: &mut V, function_declaration: &'v FnDecl) {\n-    for ty in &function_declaration.inputs {\n+pub fn walk_fn_decl<'v, V: Visitor<'v>>(visitor: &mut V, function_declaration: &'v FnDecl<'v>) {\n+    for ty in function_declaration.inputs {\n         visitor.visit_ty(ty)\n     }\n     walk_fn_ret_ty(visitor, &function_declaration.output)\n@@ -829,7 +838,7 @@ pub fn walk_fn_kind<'v, V: Visitor<'v>>(visitor: &mut V, function_kind: FnKind<'\n pub fn walk_fn<'v, V: Visitor<'v>>(\n     visitor: &mut V,\n     function_kind: FnKind<'v>,\n-    function_declaration: &'v FnDecl,\n+    function_declaration: &'v FnDecl<'v>,\n     body_id: BodyId,\n     _span: Span,\n     id: HirId,\n@@ -850,7 +859,7 @@ pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v Trai\n             visitor.visit_ty(ty);\n             walk_list!(visitor, visit_nested_body, default);\n         }\n-        TraitItemKind::Method(ref sig, TraitMethod::Required(ref param_names)) => {\n+        TraitItemKind::Method(ref sig, TraitMethod::Required(param_names)) => {\n             visitor.visit_id(trait_item.hir_id);\n             visitor.visit_fn_decl(&sig.decl);\n             for &param_name in param_names {\n@@ -866,7 +875,7 @@ pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v Trai\n                 trait_item.hir_id,\n             );\n         }\n-        TraitItemKind::Type(ref bounds, ref default) => {\n+        TraitItemKind::Type(bounds, ref default) => {\n             visitor.visit_id(trait_item.hir_id);\n             walk_list!(visitor, visit_param_bound, bounds);\n             walk_list!(visitor, visit_ty, default);\n@@ -920,14 +929,14 @@ pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplIt\n             visitor.visit_id(impl_item.hir_id);\n             visitor.visit_ty(ty);\n         }\n-        ImplItemKind::OpaqueTy(ref bounds) => {\n+        ImplItemKind::OpaqueTy(bounds) => {\n             visitor.visit_id(impl_item.hir_id);\n             walk_list!(visitor, visit_param_bound, bounds);\n         }\n     }\n }\n \n-pub fn walk_impl_item_ref<'v, V: Visitor<'v>>(visitor: &mut V, impl_item_ref: &'v ImplItemRef) {\n+pub fn walk_impl_item_ref<'v, V: Visitor<'v>>(visitor: &mut V, impl_item_ref: &'v ImplItemRef<'v>) {\n     // N.B., deliberately force a compilation error if/when new fields are added.\n     let ImplItemRef { id, ident, ref kind, span: _, ref vis, ref defaultness } = *impl_item_ref;\n     visitor.visit_nested_impl_item(id);\n@@ -1099,7 +1108,7 @@ pub fn walk_arm<'v, V: Visitor<'v>>(visitor: &mut V, arm: &'v Arm<'v>) {\n     walk_list!(visitor, visit_attribute, arm.attrs);\n }\n \n-pub fn walk_vis<'v, V: Visitor<'v>>(visitor: &mut V, vis: &'v Visibility) {\n+pub fn walk_vis<'v, V: Visitor<'v>>(visitor: &mut V, vis: &'v Visibility<'v>) {\n     if let VisibilityKind::Restricted { ref path, hir_id } = vis.node {\n         visitor.visit_id(hir_id);\n         visitor.visit_path(path, hir_id)"}, {"sha": "dda25c9ba18ec368762fb68e9dd9b924d1a620e3", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 216, "deletions": 188, "changes": 404, "blob_url": "https://github.com/rust-lang/rust/blob/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=2ba0d2acbd6cb01fb07619628882120d5b66bd59", "patch": "@@ -46,6 +46,7 @@ use crate::lint::builtin::{self, ELIDED_LIFETIMES_IN_PATHS};\n use crate::middle::cstore::CrateStore;\n use crate::session::config::nightly_options;\n use crate::session::Session;\n+use crate::util::captures::Captures;\n use crate::util::common::FN_OUTPUT_NAME;\n use crate::util::nodemap::{DefIdMap, NodeMap};\n use errors::Applicability;\n@@ -207,13 +208,13 @@ type NtToTokenstream = fn(&Nonterminal, &ParseSess, Span) -> TokenStream;\n /// Context of `impl Trait` in code, which determines whether it is allowed in an HIR subtree,\n /// and if so, what meaning it has.\n #[derive(Debug)]\n-enum ImplTraitContext<'a> {\n+enum ImplTraitContext<'b, 'a> {\n     /// Treat `impl Trait` as shorthand for a new universal generic parameter.\n     /// Example: `fn foo(x: impl Debug)`, where `impl Debug` is conceptually\n     /// equivalent to a fresh universal parameter like `fn foo<T: Debug>(x: T)`.\n     ///\n     /// Newly generated parameters should be inserted into the given `Vec`.\n-    Universal(&'a mut Vec<hir::GenericParam>),\n+    Universal(&'b mut Vec<hir::GenericParam<'a>>),\n \n     /// Treat `impl Trait` as shorthand for a new opaque type.\n     /// Example: `fn foo() -> impl Debug`, where `impl Debug` is conceptually\n@@ -238,13 +239,13 @@ enum ImplTraitPosition {\n     Other,\n }\n \n-impl<'a> ImplTraitContext<'a> {\n+impl<'b, 'a> ImplTraitContext<'b, 'a> {\n     #[inline]\n     fn disallowed() -> Self {\n         ImplTraitContext::Disallowed(ImplTraitPosition::Other)\n     }\n \n-    fn reborrow(&'b mut self) -> ImplTraitContext<'b> {\n+    fn reborrow(&'c mut self) -> ImplTraitContext<'c, 'a> {\n         use self::ImplTraitContext::*;\n         match self {\n             Universal(params) => Universal(params),\n@@ -741,9 +742,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         parent_id: DefId,\n         anonymous_lifetime_mode: AnonymousLifetimeMode,\n         f: F,\n-    ) -> (Vec<hir::GenericParam>, T)\n+    ) -> (Vec<hir::GenericParam<'hir>>, T)\n     where\n-        F: FnOnce(&mut LoweringContext<'_, '_>) -> (Vec<hir::GenericParam>, T),\n+        F: FnOnce(&mut Self) -> (Vec<hir::GenericParam<'hir>>, T),\n     {\n         assert!(!self.is_collecting_in_band_lifetimes);\n         assert!(self.lifetimes_to_define.is_empty());\n@@ -774,7 +775,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         span: Span,\n         hir_name: ParamName,\n         parent_index: DefIndex,\n-    ) -> hir::GenericParam {\n+    ) -> hir::GenericParam<'hir> {\n         let node_id = self.resolver.next_node_id();\n \n         // Get the name we'll use to make the def-path. Note\n@@ -798,8 +799,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         hir::GenericParam {\n             hir_id: self.lower_node_id(node_id),\n             name: hir_name,\n-            attrs: hir_vec![],\n-            bounds: hir_vec![],\n+            attrs: &[],\n+            bounds: &[],\n             span,\n             pure_wrt_drop: false,\n             kind: hir::GenericParamKind::Lifetime { kind },\n@@ -849,7 +850,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     // for them.\n     fn with_in_scope_lifetime_defs<T, F>(&mut self, params: &[GenericParam], f: F) -> T\n     where\n-        F: FnOnce(&mut LoweringContext<'_, 'hir>) -> T,\n+        F: FnOnce(&mut Self) -> T,\n     {\n         let old_len = self.in_scope_lifetimes.len();\n         let lt_def_names = params.iter().filter_map(|param| match param.kind {\n@@ -876,9 +877,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         parent_id: DefId,\n         anonymous_lifetime_mode: AnonymousLifetimeMode,\n         f: F,\n-    ) -> (hir::Generics, T)\n+    ) -> (hir::Generics<'hir>, T)\n     where\n-        F: FnOnce(&mut LoweringContext<'_, '_>, &mut Vec<hir::GenericParam>) -> T,\n+        F: FnOnce(&mut Self, &mut Vec<hir::GenericParam<'hir>>) -> T,\n     {\n         let (in_band_defs, (mut lowered_generics, res)) =\n             self.with_in_scope_lifetime_defs(&generics.params, |this| {\n@@ -918,7 +919,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n     fn with_dyn_type_scope<T, F>(&mut self, in_scope: bool, f: F) -> T\n     where\n-        F: FnOnce(&mut LoweringContext<'_, '_>) -> T,\n+        F: FnOnce(&mut Self) -> T,\n     {\n         let was_in_dyn_type = self.is_in_dyn_type;\n         self.is_in_dyn_type = in_scope;\n@@ -1027,8 +1028,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_assoc_ty_constraint(\n         &mut self,\n         constraint: &AssocTyConstraint,\n-        itctx: ImplTraitContext<'_>,\n-    ) -> hir::TypeBinding {\n+        itctx: ImplTraitContext<'_, 'hir>,\n+    ) -> hir::TypeBinding<'hir> {\n         debug!(\"lower_assoc_ty_constraint(constraint={:?}, itctx={:?})\", constraint, itctx);\n \n         let kind = match constraint.kind {\n@@ -1124,8 +1125,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_generic_arg(\n         &mut self,\n         arg: &ast::GenericArg,\n-        itctx: ImplTraitContext<'_>,\n-    ) -> hir::GenericArg {\n+        itctx: ImplTraitContext<'_, 'hir>,\n+    ) -> hir::GenericArg<'hir> {\n         match arg {\n             ast::GenericArg::Lifetime(lt) => GenericArg::Lifetime(self.lower_lifetime(&lt)),\n             ast::GenericArg::Type(ty) => {\n@@ -1180,8 +1181,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         }\n     }\n \n-    fn lower_ty(&mut self, t: &Ty, itctx: ImplTraitContext<'_>) -> P<hir::Ty> {\n-        P(self.lower_ty_direct(t, itctx))\n+    fn lower_ty(&mut self, t: &Ty, itctx: ImplTraitContext<'_, 'hir>) -> &'hir hir::Ty<'hir> {\n+        self.arena.alloc(self.lower_ty_direct(t, itctx))\n     }\n \n     fn lower_path_ty(\n@@ -1190,8 +1191,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         qself: &Option<QSelf>,\n         path: &Path,\n         param_mode: ParamMode,\n-        itctx: ImplTraitContext<'_>,\n-    ) -> hir::Ty {\n+        itctx: ImplTraitContext<'_, 'hir>,\n+    ) -> hir::Ty<'hir> {\n         let id = self.lower_node_id(t.id);\n         let qpath = self.lower_qpath(t.id, qself, path, param_mode, itctx);\n         let ty = self.ty_path(id, t.span, qpath);\n@@ -1201,15 +1202,15 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         ty\n     }\n \n-    fn ty(&mut self, span: Span, kind: hir::TyKind) -> hir::Ty {\n+    fn ty(&mut self, span: Span, kind: hir::TyKind<'hir>) -> hir::Ty<'hir> {\n         hir::Ty { hir_id: self.next_id(), kind, span }\n     }\n \n-    fn ty_tup(&mut self, span: Span, tys: HirVec<hir::Ty>) -> hir::Ty {\n+    fn ty_tup(&mut self, span: Span, tys: &'hir [hir::Ty<'hir>]) -> hir::Ty<'hir> {\n         self.ty(span, hir::TyKind::Tup(tys))\n     }\n \n-    fn lower_ty_direct(&mut self, t: &Ty, mut itctx: ImplTraitContext<'_>) -> hir::Ty {\n+    fn lower_ty_direct(&mut self, t: &Ty, mut itctx: ImplTraitContext<'_, 'hir>) -> hir::Ty<'hir> {\n         let kind = match t.kind {\n             TyKind::Infer => hir::TyKind::Infer,\n             TyKind::Err => hir::TyKind::Err,\n@@ -1225,23 +1226,32 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             }\n             TyKind::BareFn(ref f) => self.with_in_scope_lifetime_defs(&f.generic_params, |this| {\n                 this.with_anonymous_lifetime_mode(AnonymousLifetimeMode::PassThrough, |this| {\n-                    hir::TyKind::BareFn(P(hir::BareFnTy {\n-                        generic_params: this.lower_generic_params(\n-                            &f.generic_params,\n-                            &NodeMap::default(),\n-                            ImplTraitContext::disallowed(),\n-                        ),\n-                        unsafety: f.unsafety,\n-                        abi: this.lower_extern(f.ext),\n-                        decl: this.lower_fn_decl(&f.decl, None, false, None),\n-                        param_names: this.lower_fn_params_to_names(&f.decl),\n-                    }))\n+                    hir::TyKind::BareFn(\n+                        this.arena.alloc(hir::BareFnTy {\n+                            generic_params: this.arena.alloc_from_iter(\n+                                this.lower_generic_params(\n+                                    &f.generic_params,\n+                                    &NodeMap::default(),\n+                                    ImplTraitContext::disallowed(),\n+                                )\n+                                .into_iter(),\n+                            ),\n+                            unsafety: f.unsafety,\n+                            abi: this.lower_extern(f.ext),\n+                            decl: this.lower_fn_decl(&f.decl, None, false, None),\n+                            param_names: this.arena.alloc_from_iter(\n+                                this.lower_fn_params_to_names(&f.decl).into_iter(),\n+                            ),\n+                        }),\n+                    )\n                 })\n             }),\n             TyKind::Never => hir::TyKind::Never,\n-            TyKind::Tup(ref tys) => hir::TyKind::Tup(\n-                tys.iter().map(|ty| self.lower_ty_direct(ty, itctx.reborrow())).collect(),\n-            ),\n+            TyKind::Tup(ref tys) => {\n+                hir::TyKind::Tup(self.arena.alloc_from_iter(\n+                    tys.iter().map(|ty| self.lower_ty_direct(ty, itctx.reborrow())),\n+                ))\n+            }\n             TyKind::Paren(ref ty) => {\n                 return self.lower_ty_direct(ty, itctx);\n             }\n@@ -1253,11 +1263,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 let res = self.lower_res(res);\n                 hir::TyKind::Path(hir::QPath::Resolved(\n                     None,\n-                    P(hir::Path {\n+                    self.arena.alloc(hir::Path {\n                         res,\n-                        segments: hir_vec![hir::PathSegment::from_ident(Ident::with_dummy_span(\n-                            kw::SelfUpper\n-                        ))],\n+                        segments: arena_vec![self; hir::PathSegment::from_ident(\n+                            Ident::with_dummy_span(kw::SelfUpper)\n+                        )],\n                         span: t.span,\n                     }),\n                 ))\n@@ -1269,21 +1279,21 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             TyKind::TraitObject(ref bounds, kind) => {\n                 let mut lifetime_bound = None;\n                 let (bounds, lifetime_bound) = self.with_dyn_type_scope(true, |this| {\n-                    let bounds = bounds\n-                        .iter()\n-                        .filter_map(|bound| match *bound {\n-                            GenericBound::Trait(ref ty, TraitBoundModifier::None) => {\n-                                Some(this.lower_poly_trait_ref(ty, itctx.reborrow()))\n-                            }\n-                            GenericBound::Trait(_, TraitBoundModifier::Maybe) => None,\n-                            GenericBound::Outlives(ref lifetime) => {\n-                                if lifetime_bound.is_none() {\n-                                    lifetime_bound = Some(this.lower_lifetime(lifetime));\n+                    let bounds =\n+                        this.arena.alloc_from_iter(bounds.iter().filter_map(\n+                            |bound| match *bound {\n+                                GenericBound::Trait(ref ty, TraitBoundModifier::None) => {\n+                                    Some(this.lower_poly_trait_ref(ty, itctx.reborrow()))\n                                 }\n-                                None\n-                            }\n-                        })\n-                        .collect();\n+                                GenericBound::Trait(_, TraitBoundModifier::Maybe) => None,\n+                                GenericBound::Outlives(ref lifetime) => {\n+                                    if lifetime_bound.is_none() {\n+                                        lifetime_bound = Some(this.lower_lifetime(lifetime));\n+                                    }\n+                                    None\n+                                }\n+                            },\n+                        ));\n                     let lifetime_bound =\n                         lifetime_bound.unwrap_or_else(|| this.elided_dyn_bound(t.span));\n                     (bounds, lifetime_bound)\n@@ -1316,7 +1326,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             hir_id: self.lower_node_id(def_node_id),\n                             name: ParamName::Plain(ident),\n                             pure_wrt_drop: false,\n-                            attrs: hir_vec![],\n+                            attrs: &[],\n                             bounds: hir_bounds,\n                             span,\n                             kind: hir::GenericParamKind::Type {\n@@ -1327,10 +1337,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n                         hir::TyKind::Path(hir::QPath::Resolved(\n                             None,\n-                            P(hir::Path {\n+                            self.arena.alloc(hir::Path {\n                                 span,\n                                 res: Res::Def(DefKind::TyParam, DefId::local(def_index)),\n-                                segments: hir_vec![hir::PathSegment::from_ident(ident)],\n+                                segments: arena_vec![self; hir::PathSegment::from_ident(ident)],\n                             }),\n                         ))\n                     }\n@@ -1378,8 +1388,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         span: Span,\n         fn_def_id: Option<DefId>,\n         opaque_ty_node_id: NodeId,\n-        lower_bounds: impl FnOnce(&mut LoweringContext<'_, '_>) -> hir::GenericBounds,\n-    ) -> hir::TyKind {\n+        lower_bounds: impl FnOnce(&mut Self) -> hir::GenericBounds<'hir>,\n+    ) -> hir::TyKind<'hir> {\n         debug!(\n             \"lower_opaque_impl_trait(fn_def_id={:?}, opaque_ty_node_id={:?}, span={:?})\",\n             fn_def_id, opaque_ty_node_id, span,\n@@ -1413,7 +1423,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             let opaque_ty_item = hir::OpaqueTy {\n                 generics: hir::Generics {\n                     params: lifetime_defs,\n-                    where_clause: hir::WhereClause { predicates: hir_vec![], span },\n+                    where_clause: hir::WhereClause { predicates: &[], span },\n                     span,\n                 },\n                 bounds: hir_bounds,\n@@ -1435,7 +1445,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn generate_opaque_type(\n         &mut self,\n         opaque_ty_node_id: NodeId,\n-        opaque_ty_item: hir::OpaqueTy,\n+        opaque_ty_item: hir::OpaqueTy<'hir>,\n         span: Span,\n         opaque_ty_span: Span,\n     ) -> hir::HirId {\n@@ -1463,8 +1473,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         &mut self,\n         opaque_ty_id: NodeId,\n         parent_index: DefIndex,\n-        bounds: &hir::GenericBounds,\n-    ) -> (HirVec<hir::GenericArg>, HirVec<hir::GenericParam>) {\n+        bounds: hir::GenericBounds<'hir>,\n+    ) -> (&'hir [hir::GenericArg<'hir>], HirVec<hir::GenericParam<'hir>>) {\n         debug!(\n             \"lifetimes_from_impl_trait_bounds(opaque_ty_id={:?}, \\\n              parent_index={:?}, \\\n@@ -1482,8 +1492,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             collect_elided_lifetimes: bool,\n             currently_bound_lifetimes: Vec<hir::LifetimeName>,\n             already_defined_lifetimes: FxHashSet<hir::LifetimeName>,\n-            output_lifetimes: Vec<hir::GenericArg>,\n-            output_lifetime_params: Vec<hir::GenericParam>,\n+            output_lifetimes: Vec<hir::GenericArg<'hir>>,\n+            output_lifetime_params: Vec<hir::GenericParam<'hir>>,\n         }\n \n         impl<'r, 'a, 'v, 'hir> hir::intravisit::Visitor<'v> for ImplTraitLifetimeCollector<'r, 'a, 'hir> {\n@@ -1493,7 +1503,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 hir::intravisit::NestedVisitorMap::None\n             }\n \n-            fn visit_generic_args(&mut self, span: Span, parameters: &'v hir::GenericArgs) {\n+            fn visit_generic_args(&mut self, span: Span, parameters: &'v hir::GenericArgs<'v>) {\n                 // Don't collect elided lifetimes used inside of `Fn()` syntax.\n                 if parameters.parenthesized {\n                     let old_collect_elided_lifetimes = self.collect_elided_lifetimes;\n@@ -1505,7 +1515,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 }\n             }\n \n-            fn visit_ty(&mut self, t: &'v hir::Ty) {\n+            fn visit_ty(&mut self, t: &'v hir::Ty<'v>) {\n                 // Don't collect elided lifetimes used inside of `fn()` syntax.\n                 if let hir::TyKind::BareFn(_) = t.kind {\n                     let old_collect_elided_lifetimes = self.collect_elided_lifetimes;\n@@ -1525,7 +1535,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n             fn visit_poly_trait_ref(\n                 &mut self,\n-                trait_ref: &'v hir::PolyTraitRef,\n+                trait_ref: &'v hir::PolyTraitRef<'v>,\n                 modifier: hir::TraitBoundModifier,\n             ) {\n                 // Record the \"stack height\" of `for<'a>` lifetime bindings\n@@ -1535,7 +1545,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 self.currently_bound_lifetimes.truncate(old_len);\n             }\n \n-            fn visit_generic_param(&mut self, param: &'v hir::GenericParam) {\n+            fn visit_generic_param(&mut self, param: &'v hir::GenericParam<'v>) {\n                 // Record the introduction of 'a in `for<'a> ...`.\n                 if let hir::GenericParamKind::Lifetime { .. } = param.kind {\n                     // Introduce lifetimes one at a time so that we can handle\n@@ -1605,8 +1615,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         name,\n                         span: lifetime.span,\n                         pure_wrt_drop: false,\n-                        attrs: hir_vec![],\n-                        bounds: hir_vec![],\n+                        attrs: &[],\n+                        bounds: &[],\n                         kind: hir::GenericParamKind::Lifetime { kind },\n                     });\n                 }\n@@ -1628,10 +1638,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             hir::intravisit::walk_param_bound(&mut lifetime_collector, &bound);\n         }\n \n-        (\n-            lifetime_collector.output_lifetimes.into(),\n-            lifetime_collector.output_lifetime_params.into(),\n-        )\n+        let ImplTraitLifetimeCollector { output_lifetimes, output_lifetime_params, .. } =\n+            lifetime_collector;\n+\n+        (self.arena.alloc_from_iter(output_lifetimes), output_lifetime_params.into())\n     }\n \n     fn lower_qpath(\n@@ -1640,21 +1650,19 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         qself: &Option<QSelf>,\n         p: &Path,\n         param_mode: ParamMode,\n-        mut itctx: ImplTraitContext<'_>,\n-    ) -> hir::QPath {\n+        mut itctx: ImplTraitContext<'_, 'hir>,\n+    ) -> hir::QPath<'hir> {\n         let qself_position = qself.as_ref().map(|q| q.position);\n         let qself = qself.as_ref().map(|q| self.lower_ty(&q.ty, itctx.reborrow()));\n \n         let partial_res =\n             self.resolver.get_partial_res(id).unwrap_or_else(|| PartialRes::new(Res::Err));\n \n         let proj_start = p.segments.len() - partial_res.unresolved_segments();\n-        let path = P(hir::Path {\n+        let path = self.arena.alloc(hir::Path {\n             res: self.lower_res(partial_res.base_res()),\n-            segments: p.segments[..proj_start]\n-                .iter()\n-                .enumerate()\n-                .map(|(i, segment)| {\n+            segments: self.arena.alloc_from_iter(p.segments[..proj_start].iter().enumerate().map(\n+                |(i, segment)| {\n                     let param_mode = match (qself_position, param_mode) {\n                         (Some(j), ParamMode::Optional) if i < j => {\n                             // This segment is part of the trait path in a\n@@ -1730,8 +1738,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         itctx.reborrow(),\n                         None,\n                     )\n-                })\n-                .collect(),\n+                },\n+            )),\n             span: p.span,\n         });\n \n@@ -1751,7 +1759,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             // e.g., `Vec` in `Vec::new` or `<I as Iterator>::Item` in\n             // `<I as Iterator>::Item::default`.\n             let new_id = self.next_id();\n-            P(self.ty_path(new_id, p.span, hir::QPath::Resolved(qself, path)))\n+            self.arena.alloc(self.ty_path(new_id, p.span, hir::QPath::Resolved(qself, path)))\n         };\n \n         // Anything after the base path are associated \"extensions\",\n@@ -1765,7 +1773,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         //   3. `<<std::vec::Vec<T>>::IntoIter>::Item`\n         // * final path is `<<<std::vec::Vec<T>>::IntoIter>::Item>::clone`\n         for (i, segment) in p.segments.iter().enumerate().skip(proj_start) {\n-            let segment = P(self.lower_path_segment(\n+            let segment = self.arena.alloc(self.lower_path_segment(\n                 p.span,\n                 segment,\n                 param_mode,\n@@ -1783,7 +1791,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n             // Wrap the associated extension in another type node.\n             let new_id = self.next_id();\n-            ty = P(self.ty_path(new_id, p.span, qpath));\n+            ty = self.arena.alloc(self.ty_path(new_id, p.span, qpath));\n         }\n \n         // We should've returned in the for loop above.\n@@ -1801,29 +1809,25 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         p: &Path,\n         param_mode: ParamMode,\n         explicit_owner: Option<NodeId>,\n-    ) -> hir::Path {\n+    ) -> hir::Path<'hir> {\n         hir::Path {\n             res,\n-            segments: p\n-                .segments\n-                .iter()\n-                .map(|segment| {\n-                    self.lower_path_segment(\n-                        p.span,\n-                        segment,\n-                        param_mode,\n-                        0,\n-                        ParenthesizedGenericArgs::Err,\n-                        ImplTraitContext::disallowed(),\n-                        explicit_owner,\n-                    )\n-                })\n-                .collect(),\n+            segments: self.arena.alloc_from_iter(p.segments.iter().map(|segment| {\n+                self.lower_path_segment(\n+                    p.span,\n+                    segment,\n+                    param_mode,\n+                    0,\n+                    ParenthesizedGenericArgs::Err,\n+                    ImplTraitContext::disallowed(),\n+                    explicit_owner,\n+                )\n+            })),\n             span: p.span,\n         }\n     }\n \n-    fn lower_path(&mut self, id: NodeId, p: &Path, param_mode: ParamMode) -> hir::Path {\n+    fn lower_path(&mut self, id: NodeId, p: &Path, param_mode: ParamMode) -> hir::Path<'hir> {\n         let res = self.expect_full_res(id);\n         let res = self.lower_res(res);\n         self.lower_path_extra(res, p, param_mode, None)\n@@ -1836,9 +1840,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         param_mode: ParamMode,\n         expected_lifetimes: usize,\n         parenthesized_generic_args: ParenthesizedGenericArgs,\n-        itctx: ImplTraitContext<'_>,\n+        itctx: ImplTraitContext<'_, 'hir>,\n         explicit_owner: Option<NodeId>,\n-    ) -> hir::PathSegment {\n+    ) -> hir::PathSegment<'hir> {\n         let (mut generic_args, infer_args) = if let Some(ref generic_args) = segment.args {\n             let msg = \"parenthesized type parameters may only be used with a `Fn` trait\";\n             match **generic_args {\n@@ -1969,21 +1973,21 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             segment.ident, segment.id, id,\n         );\n \n-        hir::PathSegment::new(\n-            segment.ident,\n-            Some(id),\n-            Some(self.lower_res(res)),\n-            generic_args,\n+        hir::PathSegment {\n+            ident: segment.ident,\n+            hir_id: Some(id),\n+            res: Some(self.lower_res(res)),\n             infer_args,\n-        )\n+            args: if generic_args.is_empty() { None } else { Some(self.arena.alloc(generic_args)) },\n+        }\n     }\n \n     fn lower_angle_bracketed_parameter_data(\n         &mut self,\n         data: &AngleBracketedArgs,\n         param_mode: ParamMode,\n-        mut itctx: ImplTraitContext<'_>,\n-    ) -> (hir::GenericArgs, bool) {\n+        mut itctx: ImplTraitContext<'_, 'hir>,\n+    ) -> (hir::GenericArgs<'hir>, bool) {\n         let &AngleBracketedArgs { ref args, ref constraints, .. } = data;\n         let has_non_lt_args = args.iter().any(|arg| match arg {\n             ast::GenericArg::Lifetime(_) => false,\n@@ -1993,10 +1997,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         (\n             hir::GenericArgs {\n                 args: args.iter().map(|a| self.lower_generic_arg(a, itctx.reborrow())).collect(),\n-                bindings: constraints\n-                    .iter()\n-                    .map(|b| self.lower_assoc_ty_constraint(b, itctx.reborrow()))\n-                    .collect(),\n+                bindings: self.arena.alloc_from_iter(\n+                    constraints.iter().map(|b| self.lower_assoc_ty_constraint(b, itctx.reborrow())),\n+                ),\n                 parenthesized: false,\n             },\n             !has_non_lt_args && param_mode == ParamMode::Optional,\n@@ -2006,21 +2009,20 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_parenthesized_parameter_data(\n         &mut self,\n         data: &ParenthesizedArgs,\n-    ) -> (hir::GenericArgs, bool) {\n+    ) -> (hir::GenericArgs<'hir>, bool) {\n         // Switch to `PassThrough` mode for anonymous lifetimes; this\n         // means that we permit things like `&Ref<T>`, where `Ref` has\n         // a hidden lifetime parameter. This is needed for backwards\n         // compatibility, even in contexts like an impl header where\n         // we generally don't permit such things (see #51008).\n         self.with_anonymous_lifetime_mode(AnonymousLifetimeMode::PassThrough, |this| {\n             let &ParenthesizedArgs { ref inputs, ref output, span } = data;\n-            let inputs = inputs\n-                .iter()\n-                .map(|ty| this.lower_ty_direct(ty, ImplTraitContext::disallowed()))\n-                .collect();\n+            let inputs = this.arena.alloc_from_iter(\n+                inputs.iter().map(|ty| this.lower_ty_direct(ty, ImplTraitContext::disallowed())),\n+            );\n             let output_ty = match output {\n                 FunctionRetTy::Ty(ty) => this.lower_ty(&ty, ImplTraitContext::disallowed()),\n-                FunctionRetTy::Default(_) => P(this.ty_tup(span, hir::HirVec::new())),\n+                FunctionRetTy::Default(_) => this.arena.alloc(this.ty_tup(span, &[])),\n             };\n             let args = hir_vec![GenericArg::Type(this.ty_tup(span, inputs))];\n             let binding = hir::TypeBinding {\n@@ -2029,7 +2031,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 span: output_ty.span,\n                 kind: hir::TypeBindingKind::Equality { ty: output_ty },\n             };\n-            (hir::GenericArgs { args, bindings: hir_vec![binding], parenthesized: true }, false)\n+            (\n+                hir::GenericArgs { args, bindings: arena_vec![this; binding], parenthesized: true },\n+                false,\n+            )\n         })\n     }\n \n@@ -2052,7 +2057,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 },\n             )\n         });\n-        let ty = ty.map(|ty| &*self.arena.alloc(ty.into_inner()));\n         let init = l.init.as_ref().map(|e| self.lower_expr(e));\n         (\n             hir::Local {\n@@ -2100,10 +2104,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_fn_decl(\n         &mut self,\n         decl: &FnDecl,\n-        mut in_band_ty_params: Option<(DefId, &mut Vec<hir::GenericParam>)>,\n+        mut in_band_ty_params: Option<(DefId, &mut Vec<hir::GenericParam<'hir>>)>,\n         impl_trait_return_allow: bool,\n         make_ret_async: Option<NodeId>,\n-    ) -> P<hir::FnDecl> {\n+    ) -> &'hir hir::FnDecl<'hir> {\n         debug!(\n             \"lower_fn_decl(\\\n             fn_decl: {:?}, \\\n@@ -2133,16 +2137,13 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             if c_variadic {\n                 inputs = &inputs[..inputs.len() - 1];\n             }\n-            inputs\n-                .iter()\n-                .map(|param| {\n-                    if let Some((_, ibty)) = &mut in_band_ty_params {\n-                        this.lower_ty_direct(&param.ty, ImplTraitContext::Universal(ibty))\n-                    } else {\n-                        this.lower_ty_direct(&param.ty, ImplTraitContext::disallowed())\n-                    }\n-                })\n-                .collect::<HirVec<_>>()\n+            this.arena.alloc_from_iter(inputs.iter().map(|param| {\n+                if let Some((_, ibty)) = &mut in_band_ty_params {\n+                    this.lower_ty_direct(&param.ty, ImplTraitContext::Universal(ibty))\n+                } else {\n+                    this.lower_ty_direct(&param.ty, ImplTraitContext::disallowed())\n+                }\n+            }))\n         });\n \n         let output = if let Some(ret_id) = make_ret_async {\n@@ -2163,7 +2164,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             }\n         };\n \n-        P(hir::FnDecl {\n+        self.arena.alloc(hir::FnDecl {\n             inputs,\n             output,\n             c_variadic,\n@@ -2209,7 +2210,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         output: &FunctionRetTy,\n         fn_def_id: DefId,\n         opaque_ty_node_id: NodeId,\n-    ) -> hir::FunctionRetTy {\n+    ) -> hir::FunctionRetTy<'hir> {\n         debug!(\n             \"lower_async_fn_ret_ty(\\\n              output={:?}, \\\n@@ -2311,19 +2312,18 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n             let generic_params = lifetime_params\n                 .iter()\n-                .cloned()\n                 .map(|(span, hir_name)| {\n-                    this.lifetime_to_generic_param(span, hir_name, opaque_ty_def_index)\n+                    this.lifetime_to_generic_param(*span, *hir_name, opaque_ty_def_index)\n                 })\n                 .collect();\n \n             let opaque_ty_item = hir::OpaqueTy {\n                 generics: hir::Generics {\n                     params: generic_params,\n-                    where_clause: hir::WhereClause { predicates: hir_vec![], span },\n+                    where_clause: hir::WhereClause { predicates: &[], span },\n                     span,\n                 },\n-                bounds: hir_vec![future_bound],\n+                bounds: arena_vec![this; future_bound],\n                 impl_trait_fn: Some(fn_def_id),\n                 origin: hir::OpaqueTyOrigin::AsyncFn,\n             };\n@@ -2362,22 +2362,22 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 })\n             })\n             .collect();\n-        generic_args.extend(lifetime_params[input_lifetimes_count..].iter().map(|&(span, _)| {\n+        generic_args.extend(lifetime_params[input_lifetimes_count..].iter().map(|&(span, _)|\n             // Output lifetime like `'_`.\n             GenericArg::Lifetime(hir::Lifetime {\n                 hir_id: self.next_id(),\n                 span,\n                 name: hir::LifetimeName::Implicit,\n-            })\n-        }));\n+            })));\n+        let generic_args = self.arena.alloc_from_iter(generic_args);\n \n         // Create the `Foo<...>` reference itself. Note that the `type\n         // Foo = impl Trait` is, internally, created as a child of the\n         // async fn, so the *type parameters* are inherited.  It's\n         // only the lifetime parameters that we must supply.\n-        let opaque_ty_ref = hir::TyKind::Def(hir::ItemId { id: opaque_ty_id }, generic_args.into());\n+        let opaque_ty_ref = hir::TyKind::Def(hir::ItemId { id: opaque_ty_id }, generic_args);\n         let opaque_ty = self.ty(opaque_ty_span, opaque_ty_ref);\n-        hir::FunctionRetTy::Return(P(opaque_ty))\n+        hir::FunctionRetTy::Return(self.arena.alloc(opaque_ty))\n     }\n \n     /// Transforms `-> T` into `Future<Output = T>`\n@@ -2386,17 +2386,17 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         output: &FunctionRetTy,\n         fn_def_id: DefId,\n         span: Span,\n-    ) -> hir::GenericBound {\n+    ) -> hir::GenericBound<'hir> {\n         // Compute the `T` in `Future<Output = T>` from the return type.\n         let output_ty = match output {\n             FunctionRetTy::Ty(ty) => self.lower_ty(ty, ImplTraitContext::OpaqueTy(Some(fn_def_id))),\n-            FunctionRetTy::Default(ret_ty_span) => P(self.ty_tup(*ret_ty_span, hir_vec![])),\n+            FunctionRetTy::Default(ret_ty_span) => self.arena.alloc(self.ty_tup(*ret_ty_span, &[])),\n         };\n \n         // \"<Output = T>\"\n-        let future_params = P(hir::GenericArgs {\n-            args: hir_vec![],\n-            bindings: hir_vec![hir::TypeBinding {\n+        let future_params = self.arena.alloc(hir::GenericArgs {\n+            args: HirVec::new(),\n+            bindings: arena_vec![self; hir::TypeBinding {\n                 ident: Ident::with_dummy_span(FN_OUTPUT_NAME),\n                 kind: hir::TypeBindingKind::Equality { ty: output_ty },\n                 hir_id: self.next_id(),\n@@ -2406,13 +2406,17 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         });\n \n         // ::std::future::Future<future_params>\n-        let future_path =\n-            P(self.std_path(span, &[sym::future, sym::Future], Some(future_params), false));\n+        let future_path = self.arena.alloc(self.std_path(\n+            span,\n+            &[sym::future, sym::Future],\n+            Some(future_params),\n+            false,\n+        ));\n \n         hir::GenericBound::Trait(\n             hir::PolyTraitRef {\n                 trait_ref: hir::TraitRef { path: future_path, hir_ref_id: self.next_id() },\n-                bound_generic_params: hir_vec![],\n+                bound_generic_params: &[],\n                 span,\n             },\n             hir::TraitBoundModifier::None,\n@@ -2422,8 +2426,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_param_bound(\n         &mut self,\n         tpb: &GenericBound,\n-        itctx: ImplTraitContext<'_>,\n-    ) -> hir::GenericBound {\n+        itctx: ImplTraitContext<'_, 'hir>,\n+    ) -> hir::GenericBound<'hir> {\n         match *tpb {\n             GenericBound::Trait(ref ty, modifier) => hir::GenericBound::Trait(\n                 self.lower_poly_trait_ref(ty, itctx),\n@@ -2474,8 +2478,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         &mut self,\n         params: &[GenericParam],\n         add_bounds: &NodeMap<Vec<GenericBound>>,\n-        mut itctx: ImplTraitContext<'_>,\n-    ) -> hir::HirVec<hir::GenericParam> {\n+        mut itctx: ImplTraitContext<'_, 'hir>,\n+    ) -> HirVec<hir::GenericParam<'hir>> {\n         params\n             .iter()\n             .map(|param| self.lower_generic_param(param, add_bounds, itctx.reborrow()))\n@@ -2486,11 +2490,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         &mut self,\n         param: &GenericParam,\n         add_bounds: &NodeMap<Vec<GenericBound>>,\n-        mut itctx: ImplTraitContext<'_>,\n-    ) -> hir::GenericParam {\n-        let mut bounds = self\n+        mut itctx: ImplTraitContext<'_, 'hir>,\n+    ) -> hir::GenericParam<'hir> {\n+        let mut bounds: Vec<_> = self\n             .with_anonymous_lifetime_mode(AnonymousLifetimeMode::ReportError, |this| {\n-                this.lower_param_bounds(&param.bounds, itctx.reborrow())\n+                this.lower_param_bounds_mut(&param.bounds, itctx.reborrow()).collect()\n             });\n \n         let (name, kind) = match param.kind {\n@@ -2526,8 +2530,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             GenericParamKind::Type { ref default, .. } => {\n                 let add_bounds = add_bounds.get(&param.id).map_or(&[][..], |x| &x);\n                 if !add_bounds.is_empty() {\n-                    let params = self.lower_param_bounds(add_bounds, itctx.reborrow()).into_iter();\n-                    bounds = bounds.into_iter().chain(params).collect();\n+                    let params = self.lower_param_bounds_mut(add_bounds, itctx.reborrow());\n+                    bounds.extend(params);\n                 }\n \n                 let kind = hir::GenericParamKind::Type {\n@@ -2557,13 +2561,17 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             name,\n             span: param.ident.span,\n             pure_wrt_drop: attr::contains_name(&param.attrs, sym::may_dangle),\n-            attrs: self.lower_attrs(&param.attrs),\n-            bounds,\n+            attrs: self.lower_attrs_arena(&param.attrs),\n+            bounds: self.arena.alloc_from_iter(bounds),\n             kind,\n         }\n     }\n \n-    fn lower_trait_ref(&mut self, p: &TraitRef, itctx: ImplTraitContext<'_>) -> hir::TraitRef {\n+    fn lower_trait_ref(\n+        &mut self,\n+        p: &TraitRef,\n+        itctx: ImplTraitContext<'_, 'hir>,\n+    ) -> hir::TraitRef<'hir> {\n         let path = match self.lower_qpath(p.ref_id, &None, &p.path, ParamMode::Explicit, itctx) {\n             hir::QPath::Resolved(None, path) => path,\n             qpath => bug!(\"lower_trait_ref: unexpected QPath `{:?}`\", qpath),\n@@ -2574,8 +2582,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_poly_trait_ref(\n         &mut self,\n         p: &PolyTraitRef,\n-        mut itctx: ImplTraitContext<'_>,\n-    ) -> hir::PolyTraitRef {\n+        mut itctx: ImplTraitContext<'_, 'hir>,\n+    ) -> hir::PolyTraitRef<'hir> {\n         let bound_generic_params = self.lower_generic_params(\n             &p.bound_generic_params,\n             &NodeMap::default(),\n@@ -2585,19 +2593,31 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             this.lower_trait_ref(&p.trait_ref, itctx)\n         });\n \n-        hir::PolyTraitRef { bound_generic_params, trait_ref, span: p.span }\n+        hir::PolyTraitRef {\n+            bound_generic_params: self.arena.alloc_from_iter(bound_generic_params.into_iter()),\n+            trait_ref,\n+            span: p.span,\n+        }\n     }\n \n-    fn lower_mt(&mut self, mt: &MutTy, itctx: ImplTraitContext<'_>) -> hir::MutTy {\n+    fn lower_mt(&mut self, mt: &MutTy, itctx: ImplTraitContext<'_, 'hir>) -> hir::MutTy<'hir> {\n         hir::MutTy { ty: self.lower_ty(&mt.ty, itctx), mutbl: mt.mutbl }\n     }\n \n     fn lower_param_bounds(\n         &mut self,\n         bounds: &[GenericBound],\n-        mut itctx: ImplTraitContext<'_>,\n-    ) -> hir::GenericBounds {\n-        bounds.iter().map(|bound| self.lower_param_bound(bound, itctx.reborrow())).collect()\n+        itctx: ImplTraitContext<'_, 'hir>,\n+    ) -> hir::GenericBounds<'hir> {\n+        self.arena.alloc_from_iter(self.lower_param_bounds_mut(bounds, itctx))\n+    }\n+\n+    fn lower_param_bounds_mut<'s>(\n+        &'s mut self,\n+        bounds: &'s [GenericBound],\n+        mut itctx: ImplTraitContext<'s, 'hir>,\n+    ) -> impl Iterator<Item = hir::GenericBound<'hir>> + Captures<'s> + Captures<'a> {\n+        bounds.iter().map(move |bound| self.lower_param_bound(bound, itctx.reborrow()))\n     }\n \n     fn lower_block(&mut self, b: &Block, targeted_by_break: bool) -> &'hir hir::Block<'hir> {\n@@ -2834,10 +2854,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             }\n             Some(res) => hir::PatKind::Path(hir::QPath::Resolved(\n                 None,\n-                P(hir::Path {\n+                self.arena.alloc(hir::Path {\n                     span: ident.span,\n                     res: self.lower_res(res),\n-                    segments: hir_vec![hir::PathSegment::from_ident(ident)],\n+                    segments: arena_vec![self; hir::PathSegment::from_ident(ident)],\n                 }),\n             )),\n         }\n@@ -3033,7 +3053,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         subpats: &'hir [&'hir hir::Pat<'hir>],\n     ) -> &'hir hir::Pat<'hir> {\n         let path = self.std_path(span, components, None, true);\n-        let qpath = hir::QPath::Resolved(None, P(path));\n+        let qpath = hir::QPath::Resolved(None, self.arena.alloc(path));\n         let pt = if subpats.is_empty() {\n             hir::PatKind::Path(qpath)\n         } else {\n@@ -3079,9 +3099,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         &mut self,\n         span: Span,\n         components: &[Symbol],\n-        params: Option<P<hir::GenericArgs>>,\n+        params: Option<&'hir hir::GenericArgs<'hir>>,\n         is_value: bool,\n-    ) -> hir::Path {\n+    ) -> hir::Path<'hir> {\n         let ns = if is_value { Namespace::ValueNS } else { Namespace::TypeNS };\n         let (path, res) = self.resolver.resolve_str_path(span, self.crate_root, components, ns);\n \n@@ -3104,26 +3124,34 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         hir::Path {\n             span,\n             res: res.map_id(|_| panic!(\"unexpected `NodeId`\")),\n-            segments: segments.into(),\n+            segments: self.arena.alloc_from_iter(segments),\n         }\n     }\n \n-    fn ty_path(&mut self, mut hir_id: hir::HirId, span: Span, qpath: hir::QPath) -> hir::Ty {\n+    fn ty_path(\n+        &mut self,\n+        mut hir_id: hir::HirId,\n+        span: Span,\n+        qpath: hir::QPath<'hir>,\n+    ) -> hir::Ty<'hir> {\n         let kind = match qpath {\n             hir::QPath::Resolved(None, path) => {\n                 // Turn trait object paths into `TyKind::TraitObject` instead.\n                 match path.res {\n                     Res::Def(DefKind::Trait, _) | Res::Def(DefKind::TraitAlias, _) => {\n                         let principal = hir::PolyTraitRef {\n-                            bound_generic_params: hir::HirVec::new(),\n+                            bound_generic_params: &[],\n                             trait_ref: hir::TraitRef { path, hir_ref_id: hir_id },\n                             span,\n                         };\n \n                         // The original ID is taken by the `PolyTraitRef`,\n                         // so the `Ty` itself needs a different one.\n                         hir_id = self.next_id();\n-                        hir::TyKind::TraitObject(hir_vec![principal], self.elided_dyn_bound(span))\n+                        hir::TyKind::TraitObject(\n+                            arena_vec![self; principal],\n+                            self.elided_dyn_bound(span),\n+                        )\n                     }\n                     _ => hir::TyKind::Path(hir::QPath::Resolved(None, path)),\n                 }"}, {"sha": "067a076d8298a1ca4e79ba3c09bb3e38efaba3c8", "filename": "src/librustc/hir/lowering/expr.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs?ref=2ba0d2acbd6cb01fb07619628882120d5b66bd59", "patch": "@@ -1,7 +1,6 @@\n use super::{ImplTraitContext, LoweringContext, ParamMode, ParenthesizedGenericArgs};\n use crate::hir;\n use crate::hir::def::Res;\n-use crate::hir::ptr::P;\n \n use rustc_data_structures::thin_vec::ThinVec;\n \n@@ -64,12 +63,12 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             ExprKind::Cast(ref expr, ref ty) => {\n                 let expr = self.lower_expr(expr);\n                 let ty = self.lower_ty(ty, ImplTraitContext::disallowed());\n-                hir::ExprKind::Cast(expr, self.arena.alloc(ty.into_inner()))\n+                hir::ExprKind::Cast(expr, ty)\n             }\n             ExprKind::Type(ref expr, ref ty) => {\n                 let expr = self.lower_expr(expr);\n                 let ty = self.lower_ty(ty, ImplTraitContext::disallowed());\n-                hir::ExprKind::Type(expr, self.arena.alloc(ty.into_inner()))\n+                hir::ExprKind::Type(expr, ty)\n             }\n             ExprKind::AddrOf(k, m, ref ohs) => {\n                 let ohs = self.lower_expr(ohs);\n@@ -490,9 +489,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             None => FunctionRetTy::Default(span),\n         };\n         let ast_decl = FnDecl { inputs: vec![], output };\n-        let decl = self.arena.alloc(\n-            self.lower_fn_decl(&ast_decl, None, /* impl trait allowed */ false, None).into_inner(),\n-        );\n+        let decl = self.lower_fn_decl(&ast_decl, None, /* impl trait allowed */ false, None);\n         let body_id = self.lower_fn_body(&ast_decl, |this| {\n             this.generator_kind = Some(hir::GeneratorKind::Async(async_gen_kind));\n             body(this)\n@@ -686,7 +683,6 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     ) -> hir::ExprKind<'hir> {\n         // Lower outside new scope to preserve `is_in_loop_condition`.\n         let fn_decl = self.lower_fn_decl(decl, None, false, None);\n-        let fn_decl = self.arena.alloc(fn_decl.into_inner());\n \n         self.with_new_scopes(move |this| {\n             let prev = this.current_item;\n@@ -749,7 +745,6 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         // have to conserve the state of being inside a loop condition for the\n         // closure argument types.\n         let fn_decl = self.lower_fn_decl(&outer_decl, None, false, None);\n-        let fn_decl = self.arena.alloc(fn_decl.into_inner());\n \n         self.with_new_scopes(move |this| {\n             // FIXME(cramertj): allow `async` non-`move` closures with arguments.\n@@ -832,7 +827,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let is_unit = fields.is_empty();\n         let struct_path = [sym::ops, path];\n         let struct_path = self.std_path(span, &struct_path, None, is_unit);\n-        let struct_path = hir::QPath::Resolved(None, P(struct_path));\n+        let struct_path = hir::QPath::Resolved(None, self.arena.alloc(struct_path));\n \n         if is_unit {\n             hir::ExprKind::Path(struct_path)\n@@ -1341,9 +1336,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         assoc_fn_name: &str,\n         args: &'hir [hir::Expr<'hir>],\n     ) -> hir::ExprKind<'hir> {\n-        let ty_path = P(self.std_path(span, ty_path_components, None, false));\n-        let ty = P(self.ty_path(ty_path_id, span, hir::QPath::Resolved(None, ty_path)));\n-        let fn_seg = P(hir::PathSegment::from_ident(Ident::from_str(assoc_fn_name)));\n+        let ty_path = self.arena.alloc(self.std_path(span, ty_path_components, None, false));\n+        let ty =\n+            self.arena.alloc(self.ty_path(ty_path_id, span, hir::QPath::Resolved(None, ty_path)));\n+        let fn_seg = self.arena.alloc(hir::PathSegment::from_ident(Ident::from_str(assoc_fn_name)));\n         let fn_path = hir::QPath::TypeRelative(ty, fn_seg);\n         let fn_expr =\n             self.arena.alloc(self.expr(span, hir::ExprKind::Path(fn_path), ThinVec::new()));\n@@ -1354,11 +1350,15 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         &mut self,\n         span: Span,\n         components: &[Symbol],\n-        params: Option<P<hir::GenericArgs>>,\n+        params: Option<&'hir hir::GenericArgs<'hir>>,\n         attrs: AttrVec,\n     ) -> hir::Expr<'hir> {\n         let path = self.std_path(span, components, params, true);\n-        self.expr(span, hir::ExprKind::Path(hir::QPath::Resolved(None, P(path))), attrs)\n+        self.expr(\n+            span,\n+            hir::ExprKind::Path(hir::QPath::Resolved(None, self.arena.alloc(path))),\n+            attrs,\n+        )\n     }\n \n     pub(super) fn expr_ident(\n@@ -1388,10 +1388,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     ) -> hir::Expr<'hir> {\n         let expr_path = hir::ExprKind::Path(hir::QPath::Resolved(\n             None,\n-            P(hir::Path {\n+            self.arena.alloc(hir::Path {\n                 span,\n                 res: Res::Local(binding),\n-                segments: hir_vec![hir::PathSegment::from_ident(ident)],\n+                segments: arena_vec![self; hir::PathSegment::from_ident(ident)],\n             }),\n         ));\n "}, {"sha": "2fd59c4a1b114dd0062acb5d89df3d59680a34e2", "filename": "src/librustc/hir/lowering/item.rs", "status": "modified", "additions": 43, "deletions": 57, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs?ref=2ba0d2acbd6cb01fb07619628882120d5b66bd59", "patch": "@@ -8,7 +8,6 @@ use super::ParamMode;\n use crate::hir;\n use crate::hir::def::{DefKind, Res};\n use crate::hir::def_id::DefId;\n-use crate::hir::ptr::P;\n use crate::util::nodemap::NodeMap;\n \n use rustc_target::spec::abi;\n@@ -258,7 +257,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         id: NodeId,\n         ident: &mut Ident,\n         attrs: &'hir [Attribute],\n-        vis: &mut hir::Visibility,\n+        vis: &mut hir::Visibility<'hir>,\n         i: &ItemKind,\n     ) -> hir::ItemKind<'hir> {\n         match *i {\n@@ -278,11 +277,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         ImplTraitContext::Disallowed(ImplTraitPosition::Binding)\n                     },\n                 );\n-                hir::ItemKind::Static(\n-                    self.arena.alloc(ty.into_inner()),\n-                    m,\n-                    self.lower_const_body(span, Some(e)),\n-                )\n+                hir::ItemKind::Static(ty, m, self.lower_const_body(span, Some(e)))\n             }\n             ItemKind::Const(ref t, ref e) => {\n                 let ty = self.lower_ty(\n@@ -293,10 +288,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         ImplTraitContext::Disallowed(ImplTraitPosition::Binding)\n                     },\n                 );\n-                hir::ItemKind::Const(\n-                    self.arena.alloc(ty.into_inner()),\n-                    self.lower_const_body(span, Some(e)),\n-                )\n+                hir::ItemKind::Const(ty, self.lower_const_body(span, Some(e)))\n             }\n             ItemKind::Fn(FnSig { ref decl, header }, ref generics, ref body) => {\n                 let fn_def_id = self.resolver.definitions().local_def_id(id);\n@@ -334,7 +326,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 None => {\n                     let ty = self.lower_ty(ty, ImplTraitContext::disallowed());\n                     let generics = self.lower_generics(generics, ImplTraitContext::disallowed());\n-                    hir::ItemKind::TyAlias(self.arena.alloc(ty.into_inner()), generics)\n+                    hir::ItemKind::TyAlias(ty, generics)\n                 }\n                 Some(bounds) => {\n                     let ty = hir::OpaqueTy {\n@@ -430,7 +422,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     self.lower_defaultness(defaultness, true /* [1] */),\n                     generics,\n                     trait_ref,\n-                    self.arena.alloc(lowered_ty.into_inner()),\n+                    lowered_ty,\n                     new_impl_items,\n                 )\n             }\n@@ -465,7 +457,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         tree: &UseTree,\n         prefix: &Path,\n         id: NodeId,\n-        vis: &mut hir::Visibility,\n+        vis: &mut hir::Visibility<'hir>,\n         ident: &mut Ident,\n         attrs: &'hir [Attribute],\n     ) -> hir::ItemKind<'hir> {\n@@ -634,30 +626,27 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     /// Paths like the visibility path in `pub(super) use foo::{bar, baz}` are repeated\n     /// many times in the HIR tree; for each occurrence, we need to assign distinct\n     /// `NodeId`s. (See, e.g., #56128.)\n-    fn rebuild_use_path(&mut self, path: &hir::Path) -> hir::Path {\n+    fn rebuild_use_path(&mut self, path: &hir::Path<'hir>) -> hir::Path<'hir> {\n         debug!(\"rebuild_use_path(path = {:?})\", path);\n-        let segments = path\n-            .segments\n-            .iter()\n-            .map(|seg| hir::PathSegment {\n+        let segments =\n+            self.arena.alloc_from_iter(path.segments.iter().map(|seg| hir::PathSegment {\n                 ident: seg.ident,\n                 hir_id: seg.hir_id.map(|_| self.next_id()),\n                 res: seg.res,\n                 args: None,\n                 infer_args: seg.infer_args,\n-            })\n-            .collect();\n+            }));\n         hir::Path { span: path.span, res: path.res, segments }\n     }\n \n-    fn rebuild_vis(&mut self, vis: &hir::Visibility) -> hir::Visibility {\n+    fn rebuild_vis(&mut self, vis: &hir::Visibility<'hir>) -> hir::Visibility<'hir> {\n         let vis_kind = match vis.node {\n             hir::VisibilityKind::Public => hir::VisibilityKind::Public,\n             hir::VisibilityKind::Crate(sugar) => hir::VisibilityKind::Crate(sugar),\n             hir::VisibilityKind::Inherited => hir::VisibilityKind::Inherited,\n             hir::VisibilityKind::Restricted { ref path, hir_id: _ } => {\n                 hir::VisibilityKind::Restricted {\n-                    path: P(self.rebuild_use_path(path)),\n+                    path: self.arena.alloc(self.rebuild_use_path(path)),\n                     hir_id: self.next_id(),\n                 }\n             }\n@@ -685,14 +674,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                             )\n                         },\n                     );\n-                    let fn_dec = self.arena.alloc(fn_dec.into_inner());\n                     let fn_args = self.arena.alloc_from_iter(fn_args.into_iter());\n \n                     hir::ForeignItemKind::Fn(fn_dec, fn_args, generics)\n                 }\n                 ForeignItemKind::Static(ref t, m) => {\n                     let ty = self.lower_ty(t, ImplTraitContext::disallowed());\n-                    hir::ForeignItemKind::Static(self.arena.alloc(ty.into_inner()), m)\n+                    hir::ForeignItemKind::Static(ty, m)\n                 }\n                 ForeignItemKind::Ty => hir::ForeignItemKind::Type,\n                 ForeignItemKind::Macro(_) => panic!(\"macro shouldn't exist here\"),\n@@ -751,8 +739,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             );\n             self.arena.alloc(t)\n         } else {\n-            let t = self.lower_ty(&f.ty, ImplTraitContext::disallowed());\n-            self.arena.alloc(t.into_inner())\n+            self.lower_ty(&f.ty, ImplTraitContext::disallowed())\n         };\n         hir::StructField {\n             span: f.span,\n@@ -775,7 +762,6 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             AssocItemKind::Const(ref ty, ref default) => {\n                 let generics = self.lower_generics(&i.generics, ImplTraitContext::disallowed());\n                 let ty = self.lower_ty(ty, ImplTraitContext::disallowed());\n-                let ty = self.arena.alloc(ty.into_inner());\n                 (\n                     generics,\n                     hir::TraitItemKind::Const(\n@@ -786,6 +772,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             }\n             AssocItemKind::Fn(ref sig, None) => {\n                 let names = self.lower_fn_params_to_names(&sig.decl);\n+                let names: &[Ident] = self.arena.alloc_from_iter(names.into_iter());\n                 let (generics, sig) =\n                     self.lower_method_sig(&i.generics, sig, trait_item_def_id, false, None);\n                 (generics, hir::TraitItemKind::Method(sig, hir::TraitMethod::Required(names)))\n@@ -797,11 +784,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 (generics, hir::TraitItemKind::Method(sig, hir::TraitMethod::Provided(body_id)))\n             }\n             AssocItemKind::TyAlias(ref bounds, ref default) => {\n-                let ty = default.as_ref().map(|x| {\n-                    &*self\n-                        .arena\n-                        .alloc(self.lower_ty(x, ImplTraitContext::disallowed()).into_inner())\n-                });\n+                let ty = default.as_ref().map(|x| self.lower_ty(x, ImplTraitContext::disallowed()));\n                 let generics = self.lower_generics(&i.generics, ImplTraitContext::disallowed());\n                 let kind = hir::TraitItemKind::Type(\n                     self.lower_param_bounds(bounds, ImplTraitContext::disallowed()),\n@@ -853,7 +836,6 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             AssocItemKind::Const(ref ty, ref expr) => {\n                 let generics = self.lower_generics(&i.generics, ImplTraitContext::disallowed());\n                 let ty = self.lower_ty(ty, ImplTraitContext::disallowed());\n-                let ty = self.arena.alloc(ty.into_inner());\n                 (\n                     generics,\n                     hir::ImplItemKind::Const(ty, self.lower_const_body(i.span, expr.as_deref())),\n@@ -888,7 +870,6 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     Some(ty) => match ty.kind.opaque_top_hack() {\n                         None => {\n                             let ty = self.lower_ty(ty, ImplTraitContext::disallowed());\n-                            let ty = self.arena.alloc(ty.into_inner());\n                             hir::ImplItemKind::TyAlias(ty)\n                         }\n                         Some(bs) => {\n@@ -916,7 +897,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         // [1] since `default impl` is not yet implemented, this is always true in impls\n     }\n \n-    fn lower_impl_item_ref(&mut self, i: &AssocItem) -> hir::ImplItemRef {\n+    fn lower_impl_item_ref(&mut self, i: &AssocItem) -> hir::ImplItemRef<'hir> {\n         hir::ImplItemRef {\n             id: hir::ImplItemId { hir_id: self.lower_node_id(i.id) },\n             ident: i.ident,\n@@ -950,7 +931,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         &mut self,\n         v: &Visibility,\n         explicit_owner: Option<NodeId>,\n-    ) -> hir::Visibility {\n+    ) -> hir::Visibility<'hir> {\n         let node = match v.node {\n             VisibilityKind::Public => hir::VisibilityKind::Public,\n             VisibilityKind::Crate(sugar) => hir::VisibilityKind::Crate(sugar),\n@@ -964,7 +945,12 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 let res = self.expect_full_res(id);\n                 let res = self.lower_res(res);\n                 hir::VisibilityKind::Restricted {\n-                    path: P(self.lower_path_extra(res, path, ParamMode::Explicit, explicit_owner)),\n+                    path: self.arena.alloc(self.lower_path_extra(\n+                        res,\n+                        path,\n+                        ParamMode::Explicit,\n+                        explicit_owner,\n+                    )),\n                     hir_id: lowered_id,\n                 }\n             }\n@@ -1253,7 +1239,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         fn_def_id: DefId,\n         impl_trait_return_allow: bool,\n         is_async: Option<NodeId>,\n-    ) -> (hir::Generics, hir::FnSig) {\n+    ) -> (hir::Generics<'hir>, hir::FnSig<'hir>) {\n         let header = self.lower_fn_header(sig.header);\n         let (generics, decl) = self.add_in_band_defs(\n             generics,\n@@ -1312,8 +1298,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     pub(super) fn lower_generics(\n         &mut self,\n         generics: &Generics,\n-        itctx: ImplTraitContext<'_>,\n-    ) -> hir::Generics {\n+        itctx: ImplTraitContext<'_, 'hir>,\n+    ) -> hir::Generics<'hir> {\n         // Collect `?Trait` bounds in where clause and move them to parameter definitions.\n         // FIXME: this could probably be done with less rightward drift. It also looks like two\n         // control paths where `report_error` is called are the only paths that advance to after the\n@@ -1376,20 +1362,18 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         }\n     }\n \n-    fn lower_where_clause(&mut self, wc: &WhereClause) -> hir::WhereClause {\n+    fn lower_where_clause(&mut self, wc: &WhereClause) -> hir::WhereClause<'hir> {\n         self.with_anonymous_lifetime_mode(AnonymousLifetimeMode::ReportError, |this| {\n             hir::WhereClause {\n-                predicates: wc\n-                    .predicates\n-                    .iter()\n-                    .map(|predicate| this.lower_where_predicate(predicate))\n-                    .collect(),\n+                predicates: this.arena.alloc_from_iter(\n+                    wc.predicates.iter().map(|predicate| this.lower_where_predicate(predicate)),\n+                ),\n                 span: wc.span,\n             }\n         })\n     }\n \n-    fn lower_where_predicate(&mut self, pred: &WherePredicate) -> hir::WherePredicate {\n+    fn lower_where_predicate(&mut self, pred: &WherePredicate) -> hir::WherePredicate<'hir> {\n         match *pred {\n             WherePredicate::BoundPredicate(WhereBoundPredicate {\n                 ref bound_generic_params,\n@@ -1399,23 +1383,25 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             }) => {\n                 self.with_in_scope_lifetime_defs(&bound_generic_params, |this| {\n                     hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate {\n-                        bound_generic_params: this.lower_generic_params(\n-                            bound_generic_params,\n-                            &NodeMap::default(),\n-                            ImplTraitContext::disallowed(),\n+                        bound_generic_params: this.arena.alloc_from_iter(\n+                            this.lower_generic_params(\n+                                bound_generic_params,\n+                                &NodeMap::default(),\n+                                ImplTraitContext::disallowed(),\n+                            )\n+                            .into_iter(),\n                         ),\n                         bounded_ty: this.lower_ty(bounded_ty, ImplTraitContext::disallowed()),\n-                        bounds: bounds\n-                            .iter()\n-                            .filter_map(|bound| match *bound {\n+                        bounds: this.arena.alloc_from_iter(bounds.iter().filter_map(|bound| {\n+                            match *bound {\n                                 // Ignore `?Trait` bounds.\n                                 // They were copied into type parameters already.\n                                 GenericBound::Trait(_, TraitBoundModifier::Maybe) => None,\n                                 _ => Some(\n                                     this.lower_param_bound(bound, ImplTraitContext::disallowed()),\n                                 ),\n-                            })\n-                            .collect(),\n+                            }\n+                        })),\n                         span,\n                     })\n                 })"}, {"sha": "1267de4d9786c494c815d42bca7e975977608a8a", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=2ba0d2acbd6cb01fb07619628882120d5b66bd59", "patch": "@@ -109,10 +109,10 @@ impl<'a> Code<'a> {\n /// use when implementing FnLikeNode operations.\n struct ItemFnParts<'a> {\n     ident: Ident,\n-    decl: &'a ast::FnDecl,\n+    decl: &'a ast::FnDecl<'a>,\n     header: ast::FnHeader,\n-    vis: &'a ast::Visibility,\n-    generics: &'a ast::Generics,\n+    vis: &'a ast::Visibility<'a>,\n+    generics: &'a ast::Generics<'a>,\n     body: ast::BodyId,\n     id: ast::HirId,\n     span: Span,\n@@ -122,15 +122,21 @@ struct ItemFnParts<'a> {\n /// These are all the components one can extract from a closure expr\n /// for use when implementing FnLikeNode operations.\n struct ClosureParts<'a> {\n-    decl: &'a FnDecl,\n+    decl: &'a FnDecl<'a>,\n     body: ast::BodyId,\n     id: ast::HirId,\n     span: Span,\n     attrs: &'a [Attribute],\n }\n \n impl<'a> ClosureParts<'a> {\n-    fn new(d: &'a FnDecl, b: ast::BodyId, id: ast::HirId, s: Span, attrs: &'a [Attribute]) -> Self {\n+    fn new(\n+        d: &'a FnDecl<'a>,\n+        b: ast::BodyId,\n+        id: ast::HirId,\n+        s: Span,\n+        attrs: &'a [Attribute],\n+    ) -> Self {\n         ClosureParts { decl: d, body: b, id, span: s, attrs }\n     }\n }\n@@ -151,31 +157,31 @@ impl<'a> FnLikeNode<'a> {\n     pub fn body(self) -> ast::BodyId {\n         self.handle(\n             |i: ItemFnParts<'a>| i.body,\n-            |_, _, _: &'a ast::FnSig, _, body: ast::BodyId, _, _| body,\n+            |_, _, _: &'a ast::FnSig<'a>, _, body: ast::BodyId, _, _| body,\n             |c: ClosureParts<'a>| c.body,\n         )\n     }\n \n-    pub fn decl(self) -> &'a FnDecl {\n+    pub fn decl(self) -> &'a FnDecl<'a> {\n         self.handle(\n             |i: ItemFnParts<'a>| &*i.decl,\n-            |_, _, sig: &'a ast::FnSig, _, _, _, _| &sig.decl,\n+            |_, _, sig: &'a ast::FnSig<'a>, _, _, _, _| &sig.decl,\n             |c: ClosureParts<'a>| c.decl,\n         )\n     }\n \n     pub fn span(self) -> Span {\n         self.handle(\n             |i: ItemFnParts<'_>| i.span,\n-            |_, _, _: &'a ast::FnSig, _, _, span, _| span,\n+            |_, _, _: &'a ast::FnSig<'a>, _, _, span, _| span,\n             |c: ClosureParts<'_>| c.span,\n         )\n     }\n \n     pub fn id(self) -> ast::HirId {\n         self.handle(\n             |i: ItemFnParts<'_>| i.id,\n-            |id, _, _: &'a ast::FnSig, _, _, _, _| id,\n+            |id, _, _: &'a ast::FnSig<'a>, _, _, _, _| id,\n             |c: ClosureParts<'_>| c.id,\n         )\n     }\n@@ -197,7 +203,7 @@ impl<'a> FnLikeNode<'a> {\n             FnKind::ItemFn(p.ident, p.generics, p.header, p.vis, p.attrs)\n         };\n         let closure = |c: ClosureParts<'a>| FnKind::Closure(c.attrs);\n-        let method = |_, ident: Ident, sig: &'a ast::FnSig, vis, _, _, attrs| {\n+        let method = |_, ident: Ident, sig: &'a ast::FnSig<'a>, vis, _, _, attrs| {\n             FnKind::Method(ident, sig, vis, attrs)\n         };\n         self.handle(item, method, closure)\n@@ -209,8 +215,8 @@ impl<'a> FnLikeNode<'a> {\n         M: FnOnce(\n             ast::HirId,\n             Ident,\n-            &'a ast::FnSig,\n-            Option<&'a ast::Visibility>,\n+            &'a ast::FnSig<'a>,\n+            Option<&'a ast::Visibility<'a>>,\n             ast::BodyId,\n             Span,\n             &'a [Attribute],"}, {"sha": "28eff07a494d51a1a28b6e5c7b8969db4e31a5bd", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=2ba0d2acbd6cb01fb07619628882120d5b66bd59", "patch": "@@ -401,7 +401,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         });\n     }\n \n-    fn visit_generic_param(&mut self, param: &'hir GenericParam) {\n+    fn visit_generic_param(&mut self, param: &'hir GenericParam<'hir>) {\n         self.insert(param.span, param.hir_id, Node::GenericParam(param));\n         intravisit::walk_generic_param(self, param);\n     }\n@@ -478,22 +478,22 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         });\n     }\n \n-    fn visit_path_segment(&mut self, path_span: Span, path_segment: &'hir PathSegment) {\n+    fn visit_path_segment(&mut self, path_span: Span, path_segment: &'hir PathSegment<'hir>) {\n         if let Some(hir_id) = path_segment.hir_id {\n             self.insert(path_span, hir_id, Node::PathSegment(path_segment));\n         }\n         intravisit::walk_path_segment(self, path_span, path_segment);\n     }\n \n-    fn visit_ty(&mut self, ty: &'hir Ty) {\n+    fn visit_ty(&mut self, ty: &'hir Ty<'hir>) {\n         self.insert(ty.span, ty.hir_id, Node::Ty(ty));\n \n         self.with_parent(ty.hir_id, |this| {\n             intravisit::walk_ty(this, ty);\n         });\n     }\n \n-    fn visit_trait_ref(&mut self, tr: &'hir TraitRef) {\n+    fn visit_trait_ref(&mut self, tr: &'hir TraitRef<'hir>) {\n         self.insert(tr.path.span, tr.hir_ref_id, Node::TraitRef(tr));\n \n         self.with_parent(tr.hir_ref_id, |this| {\n@@ -504,7 +504,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     fn visit_fn(\n         &mut self,\n         fk: intravisit::FnKind<'hir>,\n-        fd: &'hir FnDecl,\n+        fd: &'hir FnDecl<'hir>,\n         b: BodyId,\n         s: Span,\n         id: HirId,\n@@ -529,7 +529,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         self.insert(lifetime.span, lifetime.hir_id, Node::Lifetime(lifetime));\n     }\n \n-    fn visit_vis(&mut self, visibility: &'hir Visibility) {\n+    fn visit_vis(&mut self, visibility: &'hir Visibility<'hir>) {\n         match visibility.node {\n             VisibilityKind::Public | VisibilityKind::Crate(_) | VisibilityKind::Inherited => {}\n             VisibilityKind::Restricted { hir_id, .. } => {\n@@ -550,7 +550,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         });\n     }\n \n-    fn visit_variant(&mut self, v: &'hir Variant<'hir>, g: &'hir Generics, item_id: HirId) {\n+    fn visit_variant(&mut self, v: &'hir Variant<'hir>, g: &'hir Generics<'hir>, item_id: HirId) {\n         self.insert(v.span, v.id, Node::Variant(v));\n         self.with_parent(v.id, |this| {\n             // Register the constructor of this variant.\n@@ -576,7 +576,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         self.visit_nested_trait_item(id);\n     }\n \n-    fn visit_impl_item_ref(&mut self, ii: &'hir ImplItemRef) {\n+    fn visit_impl_item_ref(&mut self, ii: &'hir ImplItemRef<'hir>) {\n         // Do not visit the duplicate information in ImplItemRef. We want to\n         // map the actual nodes, not the duplicate ones in the *Ref.\n         let ImplItemRef { id, ident: _, kind: _, span: _, vis: _, defaultness: _ } = *ii;"}, {"sha": "a04fc8a562ffa59dd1bd747ebf55044045c310a3", "filename": "src/librustc/hir/map/hir_id_validator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs?ref=2ba0d2acbd6cb01fb07619628882120d5b66bd59", "patch": "@@ -161,7 +161,7 @@ impl<'a, 'hir> intravisit::Visitor<'hir> for HirIdValidator<'a, 'hir> {\n         self.hir_ids_seen.insert(hir_id.local_id);\n     }\n \n-    fn visit_impl_item_ref(&mut self, _: &'hir hir::ImplItemRef) {\n+    fn visit_impl_item_ref(&mut self, _: &'hir hir::ImplItemRef<'hir>) {\n         // Explicitly do nothing here. ImplItemRefs contain hir::Visibility\n         // values that actually belong to an ImplItem instead of the ItemKind::Impl\n         // we are currently in. So for those it's correct that they have a"}, {"sha": "7f7af331b3c301866128ba950037911392ce94a4", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=2ba0d2acbd6cb01fb07619628882120d5b66bd59", "patch": "@@ -43,7 +43,7 @@ impl<'hir> Entry<'hir> {\n         }\n     }\n \n-    fn fn_decl(&self) -> Option<&'hir FnDecl> {\n+    fn fn_decl(&self) -> Option<&'hir FnDecl<'hir>> {\n         match self.node {\n             Node::Item(ref item) => match item.kind {\n                 ItemKind::Fn(ref sig, _, _) => Some(&sig.decl),\n@@ -69,7 +69,7 @@ impl<'hir> Entry<'hir> {\n         }\n     }\n \n-    fn fn_sig(&self) -> Option<&'hir FnSig> {\n+    fn fn_sig(&self) -> Option<&'hir FnSig<'hir>> {\n         match &self.node {\n             Node::Item(item) => match &item.kind {\n                 ItemKind::Fn(sig, _, _) => Some(sig),\n@@ -429,15 +429,15 @@ impl<'hir> Map<'hir> {\n         self.forest.krate.body(id)\n     }\n \n-    pub fn fn_decl_by_hir_id(&self, hir_id: HirId) -> Option<&'hir FnDecl> {\n+    pub fn fn_decl_by_hir_id(&self, hir_id: HirId) -> Option<&'hir FnDecl<'hir>> {\n         if let Some(entry) = self.find_entry(hir_id) {\n             entry.fn_decl()\n         } else {\n             bug!(\"no entry for hir_id `{}`\", hir_id)\n         }\n     }\n \n-    pub fn fn_sig_by_hir_id(&self, hir_id: HirId) -> Option<&'hir FnSig> {\n+    pub fn fn_sig_by_hir_id(&self, hir_id: HirId) -> Option<&'hir FnSig<'hir>> {\n         if let Some(entry) = self.find_entry(hir_id) {\n             entry.fn_sig()\n         } else {\n@@ -584,7 +584,7 @@ impl<'hir> Map<'hir> {\n         self.as_local_hir_id(id).map(|id| self.get(id)) // read recorded by `get`\n     }\n \n-    pub fn get_generics(&self, id: DefId) -> Option<&'hir Generics> {\n+    pub fn get_generics(&self, id: DefId) -> Option<&'hir Generics<'hir>> {\n         self.get_if_local(id).and_then(|node| match node {\n             Node::ImplItem(ref impl_item) => Some(&impl_item.generics),\n             Node::TraitItem(ref trait_item) => Some(&trait_item.generics),"}, {"sha": "13ae89e77b26cc1ad7a75cd5a8a336c22bbf4ec9", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 159, "deletions": 175, "changes": 334, "blob_url": "https://github.com/rust-lang/rust/blob/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=2ba0d2acbd6cb01fb07619628882120d5b66bd59", "patch": "@@ -303,27 +303,27 @@ impl Lifetime {\n /// `std::cmp::PartialEq`. It's represented as a sequence of identifiers,\n /// along with a bunch of supporting information.\n #[derive(RustcEncodable, RustcDecodable, HashStable)]\n-pub struct Path {\n+pub struct Path<'hir> {\n     pub span: Span,\n     /// The resolution for the path.\n     pub res: Res,\n     /// The segments in the path: the things separated by `::`.\n-    pub segments: HirVec<PathSegment>,\n+    pub segments: &'hir [PathSegment<'hir>],\n }\n \n-impl Path {\n+impl Path<'_> {\n     pub fn is_global(&self) -> bool {\n         !self.segments.is_empty() && self.segments[0].ident.name == kw::PathRoot\n     }\n }\n \n-impl fmt::Debug for Path {\n+impl fmt::Debug for Path<'_> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"path({})\", self)\n     }\n }\n \n-impl fmt::Display for Path {\n+impl fmt::Display for Path<'_> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"{}\", print::to_string(print::NO_ANN, |s| s.print_path(self, false)))\n     }\n@@ -332,7 +332,7 @@ impl fmt::Display for Path {\n /// A segment of a path: an identifier, an optional lifetime, and a set of\n /// types.\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct PathSegment {\n+pub struct PathSegment<'hir> {\n     /// The identifier portion of this path segment.\n     #[stable_hasher(project(name))]\n     pub ident: Ident,\n@@ -349,7 +349,7 @@ pub struct PathSegment {\n     /// this is more than just simple syntactic sugar; the use of\n     /// parens affects the region binding rules, so we preserve the\n     /// distinction.\n-    pub args: Option<P<GenericArgs>>,\n+    pub args: Option<&'hir GenericArgs<'hir>>,\n \n     /// Whether to infer remaining type parameters, if any.\n     /// This only applies to expression and pattern paths, and\n@@ -358,33 +358,17 @@ pub struct PathSegment {\n     pub infer_args: bool,\n }\n \n-impl PathSegment {\n+impl<'hir> PathSegment<'hir> {\n     /// Converts an identifier to the corresponding segment.\n-    pub fn from_ident(ident: Ident) -> PathSegment {\n+    pub fn from_ident(ident: Ident) -> PathSegment<'hir> {\n         PathSegment { ident, hir_id: None, res: None, infer_args: true, args: None }\n     }\n \n-    pub fn new(\n-        ident: Ident,\n-        hir_id: Option<HirId>,\n-        res: Option<Res>,\n-        args: GenericArgs,\n-        infer_args: bool,\n-    ) -> Self {\n-        PathSegment {\n-            ident,\n-            hir_id,\n-            res,\n-            infer_args,\n-            args: if args.is_empty() { None } else { Some(P(args)) },\n-        }\n-    }\n-\n-    pub fn generic_args(&self) -> &GenericArgs {\n+    pub fn generic_args(&self) -> &GenericArgs<'hir> {\n         if let Some(ref args) = self.args {\n             args\n         } else {\n-            const DUMMY: &GenericArgs = &GenericArgs::none();\n+            const DUMMY: &GenericArgs<'_> = &GenericArgs::none();\n             DUMMY\n         }\n     }\n@@ -397,13 +381,13 @@ pub struct ConstArg {\n }\n \n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub enum GenericArg {\n+pub enum GenericArg<'hir> {\n     Lifetime(Lifetime),\n-    Type(Ty),\n+    Type(Ty<'hir>),\n     Const(ConstArg),\n }\n \n-impl GenericArg {\n+impl GenericArg<'_> {\n     pub fn span(&self) -> Span {\n         match self {\n             GenericArg::Lifetime(l) => l.span,\n@@ -429,28 +413,28 @@ impl GenericArg {\n }\n \n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct GenericArgs {\n+pub struct GenericArgs<'hir> {\n     /// The generic arguments for this path segment.\n-    pub args: HirVec<GenericArg>,\n+    pub args: HirVec<GenericArg<'hir>>,\n     /// Bindings (equality constraints) on associated types, if present.\n     /// E.g., `Foo<A = Bar>`.\n-    pub bindings: HirVec<TypeBinding>,\n+    pub bindings: &'hir [TypeBinding<'hir>],\n     /// Were arguments written in parenthesized form `Fn(T) -> U`?\n     /// This is required mostly for pretty-printing and diagnostics,\n     /// but also for changing lifetime elision rules to be \"function-like\".\n     pub parenthesized: bool,\n }\n \n-impl GenericArgs {\n+impl GenericArgs<'_> {\n     pub const fn none() -> Self {\n-        Self { args: HirVec::new(), bindings: HirVec::new(), parenthesized: false }\n+        Self { args: HirVec::new(), bindings: &[], parenthesized: false }\n     }\n \n     pub fn is_empty(&self) -> bool {\n         self.args.is_empty() && self.bindings.is_empty() && !self.parenthesized\n     }\n \n-    pub fn inputs(&self) -> &[Ty] {\n+    pub fn inputs(&self) -> &[Ty<'_>] {\n         if self.parenthesized {\n             for arg in &self.args {\n                 match arg {\n@@ -499,12 +483,12 @@ pub enum TraitBoundModifier {\n /// the \"special\" built-in traits (see `middle::lang_items`) and\n /// detects `Copy`, `Send` and `Sync`.\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub enum GenericBound {\n-    Trait(PolyTraitRef, TraitBoundModifier),\n+pub enum GenericBound<'hir> {\n+    Trait(PolyTraitRef<'hir>, TraitBoundModifier),\n     Outlives(Lifetime),\n }\n \n-impl GenericBound {\n+impl GenericBound<'_> {\n     pub fn span(&self) -> Span {\n         match self {\n             &GenericBound::Trait(ref t, ..) => t.span,\n@@ -513,7 +497,7 @@ impl GenericBound {\n     }\n }\n \n-pub type GenericBounds = HirVec<GenericBound>;\n+pub type GenericBounds<'hir> = &'hir [GenericBound<'hir>];\n \n #[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum LifetimeParamKind {\n@@ -535,29 +519,29 @@ pub enum LifetimeParamKind {\n }\n \n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub enum GenericParamKind {\n+pub enum GenericParamKind<'hir> {\n     /// A lifetime definition (e.g., `'a: 'b + 'c + 'd`).\n     Lifetime {\n         kind: LifetimeParamKind,\n     },\n     Type {\n-        default: Option<P<Ty>>,\n+        default: Option<&'hir Ty<'hir>>,\n         synthetic: Option<SyntheticTyParamKind>,\n     },\n     Const {\n-        ty: P<Ty>,\n+        ty: &'hir Ty<'hir>,\n     },\n }\n \n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct GenericParam {\n+pub struct GenericParam<'hir> {\n     pub hir_id: HirId,\n     pub name: ParamName,\n-    pub attrs: HirVec<Attribute>,\n-    pub bounds: GenericBounds,\n+    pub attrs: &'hir [Attribute],\n+    pub bounds: GenericBounds<'hir>,\n     pub span: Span,\n     pub pure_wrt_drop: bool,\n-    pub kind: GenericParamKind,\n+    pub kind: GenericParamKind<'hir>,\n }\n \n #[derive(Default)]\n@@ -570,17 +554,17 @@ pub struct GenericParamCount {\n /// Represents lifetimes and type parameters attached to a declaration\n /// of a function, enum, trait, etc.\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct Generics {\n-    pub params: HirVec<GenericParam>,\n-    pub where_clause: WhereClause,\n+pub struct Generics<'hir> {\n+    pub params: HirVec<GenericParam<'hir>>,\n+    pub where_clause: WhereClause<'hir>,\n     pub span: Span,\n }\n \n-impl Generics {\n-    pub const fn empty() -> Generics {\n+impl Generics<'hir> {\n+    pub const fn empty() -> Generics<'hir> {\n         Generics {\n             params: HirVec::new(),\n-            where_clause: WhereClause { predicates: HirVec::new(), span: DUMMY_SP },\n+            where_clause: WhereClause { predicates: &[], span: DUMMY_SP },\n             span: DUMMY_SP,\n         }\n     }\n@@ -602,7 +586,7 @@ impl Generics {\n         own_counts\n     }\n \n-    pub fn get_named(&self, name: Symbol) -> Option<&GenericParam> {\n+    pub fn get_named(&self, name: Symbol) -> Option<&GenericParam<'_>> {\n         for param in &self.params {\n             if name == param.name.ident().name {\n                 return Some(param);\n@@ -629,13 +613,13 @@ pub enum SyntheticTyParamKind {\n \n /// A where-clause in a definition.\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct WhereClause {\n-    pub predicates: HirVec<WherePredicate>,\n+pub struct WhereClause<'hir> {\n+    pub predicates: &'hir [WherePredicate<'hir>],\n     // Only valid if predicates isn't empty.\n     span: Span,\n }\n \n-impl WhereClause {\n+impl WhereClause<'_> {\n     pub fn span(&self) -> Option<Span> {\n         if self.predicates.is_empty() { None } else { Some(self.span) }\n     }\n@@ -649,16 +633,16 @@ impl WhereClause {\n \n /// A single predicate in a where-clause.\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub enum WherePredicate {\n+pub enum WherePredicate<'hir> {\n     /// A type binding (e.g., `for<'c> Foo: Send + Clone + 'c`).\n-    BoundPredicate(WhereBoundPredicate),\n+    BoundPredicate(WhereBoundPredicate<'hir>),\n     /// A lifetime predicate (e.g., `'a: 'b + 'c`).\n-    RegionPredicate(WhereRegionPredicate),\n+    RegionPredicate(WhereRegionPredicate<'hir>),\n     /// An equality predicate (unsupported).\n-    EqPredicate(WhereEqPredicate),\n+    EqPredicate(WhereEqPredicate<'hir>),\n }\n \n-impl WherePredicate {\n+impl WherePredicate<'_> {\n     pub fn span(&self) -> Span {\n         match self {\n             &WherePredicate::BoundPredicate(ref p) => p.span,\n@@ -670,31 +654,31 @@ impl WherePredicate {\n \n /// A type bound (e.g., `for<'c> Foo: Send + Clone + 'c`).\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct WhereBoundPredicate {\n+pub struct WhereBoundPredicate<'hir> {\n     pub span: Span,\n     /// Any generics from a `for` binding.\n-    pub bound_generic_params: HirVec<GenericParam>,\n+    pub bound_generic_params: &'hir [GenericParam<'hir>],\n     /// The type being bounded.\n-    pub bounded_ty: P<Ty>,\n+    pub bounded_ty: &'hir Ty<'hir>,\n     /// Trait and lifetime bounds (e.g., `Clone + Send + 'static`).\n-    pub bounds: GenericBounds,\n+    pub bounds: GenericBounds<'hir>,\n }\n \n /// A lifetime predicate (e.g., `'a: 'b + 'c`).\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct WhereRegionPredicate {\n+pub struct WhereRegionPredicate<'hir> {\n     pub span: Span,\n     pub lifetime: Lifetime,\n-    pub bounds: GenericBounds,\n+    pub bounds: GenericBounds<'hir>,\n }\n \n /// An equality predicate (e.g., `T = int`); currently unsupported.\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct WhereEqPredicate {\n+pub struct WhereEqPredicate<'hir> {\n     pub hir_id: HirId,\n     pub span: Span,\n-    pub lhs_ty: P<Ty>,\n-    pub rhs_ty: P<Ty>,\n+    pub lhs_ty: &'hir Ty<'hir>,\n+    pub rhs_ty: &'hir Ty<'hir>,\n }\n \n #[derive(RustcEncodable, RustcDecodable, Debug)]\n@@ -820,7 +804,7 @@ impl Crate<'_> {\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct MacroDef<'hir> {\n     pub name: Name,\n-    pub vis: Visibility,\n+    pub vis: Visibility<'hir>,\n     pub attrs: &'hir [Attribute],\n     pub hir_id: HirId,\n     pub span: Span,\n@@ -1003,19 +987,19 @@ pub enum PatKind<'hir> {\n \n     /// A struct or struct variant pattern (e.g., `Variant {x, y, ..}`).\n     /// The `bool` is `true` in the presence of a `..`.\n-    Struct(QPath, &'hir [FieldPat<'hir>], bool),\n+    Struct(QPath<'hir>, &'hir [FieldPat<'hir>], bool),\n \n     /// A tuple struct/variant pattern `Variant(x, y, .., z)`.\n     /// If the `..` pattern fragment is present, then `Option<usize>` denotes its position.\n     /// `0 <= position <= subpats.len()`\n-    TupleStruct(QPath, &'hir [&'hir Pat<'hir>], Option<usize>),\n+    TupleStruct(QPath<'hir>, &'hir [&'hir Pat<'hir>], Option<usize>),\n \n     /// An or-pattern `A | B | C`.\n     /// Invariant: `pats.len() >= 2`.\n     Or(&'hir [&'hir Pat<'hir>]),\n \n     /// A path pattern for an unit struct/variant or a (maybe-associated) constant.\n-    Path(QPath),\n+    Path(QPath<'hir>),\n \n     /// A tuple pattern (e.g., `(a, b)`).\n     /// If the `..` pattern fragment is present, then `Option<usize>` denotes its position.\n@@ -1258,7 +1242,7 @@ impl StmtKind<'hir> {\n pub struct Local<'hir> {\n     pub pat: &'hir Pat<'hir>,\n     /// Type annotation, if any (otherwise the type will be inferred).\n-    pub ty: Option<&'hir Ty>,\n+    pub ty: Option<&'hir Ty<'hir>>,\n     /// Initializer expression to set the value, if any.\n     pub init: Option<&'hir Expr<'hir>>,\n     pub hir_id: HirId,\n@@ -1583,7 +1567,7 @@ pub fn is_range_literal(sm: &SourceMap, expr: &Expr<'_>) -> bool {\n     // Returns whether the given path represents a (desugared) range,\n     // either in std or core, i.e. has either a `::std::ops::Range` or\n     // `::core::ops::Range` prefix.\n-    fn is_range_path(path: &Path) -> bool {\n+    fn is_range_path(path: &Path<'_>) -> bool {\n         let segs: Vec<_> = path.segments.iter().map(|seg| seg.ident.to_string()).collect();\n         let segs: Vec<_> = segs.iter().map(|seg| &**seg).collect();\n \n@@ -1663,7 +1647,7 @@ pub enum ExprKind<'hir> {\n     /// the `hir_id` of the `MethodCall` node itself.\n     ///\n     /// [`type_dependent_def_id`]: ../ty/struct.TypeckTables.html#method.type_dependent_def_id\n-    MethodCall(&'hir PathSegment, Span, &'hir [Expr<'hir>]),\n+    MethodCall(&'hir PathSegment<'hir>, Span, &'hir [Expr<'hir>]),\n     /// A tuple (e.g., `(a, b, c, d)`).\n     Tup(&'hir [Expr<'hir>]),\n     /// A binary operation (e.g., `a + b`, `a * b`).\n@@ -1673,9 +1657,9 @@ pub enum ExprKind<'hir> {\n     /// A literal (e.g., `1`, `\"foo\"`).\n     Lit(Lit),\n     /// A cast (e.g., `foo as f64`).\n-    Cast(&'hir Expr<'hir>, &'hir Ty),\n+    Cast(&'hir Expr<'hir>, &'hir Ty<'hir>),\n     /// A type reference (e.g., `Foo`).\n-    Type(&'hir Expr<'hir>, &'hir Ty),\n+    Type(&'hir Expr<'hir>, &'hir Ty<'hir>),\n     /// Wraps the expression in a terminating scope.\n     /// This makes it semantically equivalent to `{ let _t = expr; _t }`.\n     ///\n@@ -1695,7 +1679,7 @@ pub enum ExprKind<'hir> {\n     ///\n     /// This may also be a generator literal or an `async block` as indicated by the\n     /// `Option<Movability>`.\n-    Closure(CaptureBy, &'hir FnDecl, BodyId, Span, Option<Movability>),\n+    Closure(CaptureBy, &'hir FnDecl<'hir>, BodyId, Span, Option<Movability>),\n     /// A block (e.g., `'label: { ... }`).\n     Block(&'hir Block<'hir>, Option<Label>),\n \n@@ -1711,7 +1695,7 @@ pub enum ExprKind<'hir> {\n     Index(&'hir Expr<'hir>, &'hir Expr<'hir>),\n \n     /// Path to a definition, possibly containing lifetime or type parameters.\n-    Path(QPath),\n+    Path(QPath<'hir>),\n \n     /// A referencing operation (i.e., `&a` or `&mut a`).\n     AddrOf(BorrowKind, Mutability, &'hir Expr<'hir>),\n@@ -1729,7 +1713,7 @@ pub enum ExprKind<'hir> {\n     ///\n     /// E.g., `Foo {x: 1, y: 2}`, or `Foo {x: 1, .. base}`,\n     /// where `base` is the `Option<Expr>`.\n-    Struct(&'hir QPath, &'hir [Field<'hir>], Option<&'hir Expr<'hir>>),\n+    Struct(&'hir QPath<'hir>, &'hir [Field<'hir>], Option<&'hir Expr<'hir>>),\n \n     /// An array literal constructed from one repeated element.\n     ///\n@@ -1750,22 +1734,22 @@ pub enum ExprKind<'hir> {\n ///\n /// [`qpath_res`]: ../ty/struct.TypeckTables.html#method.qpath_res\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub enum QPath {\n+pub enum QPath<'hir> {\n     /// Path to a definition, optionally \"fully-qualified\" with a `Self`\n     /// type, if the path points to an associated item in a trait.\n     ///\n     /// E.g., an unqualified path like `Clone::clone` has `None` for `Self`,\n     /// while `<Vec<T> as Clone>::clone` has `Some(Vec<T>)` for `Self`,\n     /// even though they both have the same two-segment `Clone::clone` `Path`.\n-    Resolved(Option<P<Ty>>, P<Path>),\n+    Resolved(Option<&'hir Ty<'hir>>, &'hir Path<'hir>),\n \n     /// Type-related paths (e.g., `<T>::default` or `<T>::Output`).\n     /// Will be resolved by type-checking to an associated item.\n     ///\n     /// UFCS source paths can desugar into this, with `Vec::new` turning into\n     /// `<Vec>::new`, and `T::X::Y::method` into `<<<T>::X>::Y>::method`,\n     /// the `X` and `Y` nodes each being a `TyKind::Path(QPath::TypeRelative(..))`.\n-    TypeRelative(P<Ty>, P<PathSegment>),\n+    TypeRelative(&'hir Ty<'hir>, &'hir PathSegment<'hir>),\n }\n \n /// Hints at the original code for a let statement.\n@@ -1909,17 +1893,17 @@ impl From<GeneratorKind> for YieldSource {\n // N.B., if you change this, you'll probably want to change the corresponding\n // type structure in middle/ty.rs as well.\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct MutTy {\n-    pub ty: P<Ty>,\n+pub struct MutTy<'hir> {\n+    pub ty: &'hir Ty<'hir>,\n     pub mutbl: Mutability,\n }\n \n /// Represents a function's signature in a trait declaration,\n /// trait implementation, or a free function.\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct FnSig {\n+pub struct FnSig<'hir> {\n     pub header: FnHeader,\n-    pub decl: P<FnDecl>,\n+    pub decl: &'hir FnDecl<'hir>,\n }\n \n // The bodies for items are stored \"out of line\", in a separate\n@@ -1939,16 +1923,16 @@ pub struct TraitItem<'hir> {\n     pub ident: Ident,\n     pub hir_id: HirId,\n     pub attrs: &'hir [Attribute],\n-    pub generics: Generics,\n+    pub generics: Generics<'hir>,\n     pub kind: TraitItemKind<'hir>,\n     pub span: Span,\n }\n \n /// Represents a trait method's body (or just argument names).\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub enum TraitMethod {\n+pub enum TraitMethod<'hir> {\n     /// No default body in the trait, just a signature.\n-    Required(HirVec<Ident>),\n+    Required(&'hir [Ident]),\n \n     /// Both signature and body are provided in the trait.\n     Provided(BodyId),\n@@ -1958,12 +1942,12 @@ pub enum TraitMethod {\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum TraitItemKind<'hir> {\n     /// An associated constant with an optional value (otherwise `impl`s must contain a value).\n-    Const(&'hir Ty, Option<BodyId>),\n+    Const(&'hir Ty<'hir>, Option<BodyId>),\n     /// A method with an optional body.\n-    Method(FnSig, TraitMethod),\n+    Method(FnSig<'hir>, TraitMethod<'hir>),\n     /// An associated type with (possibly empty) bounds and optional concrete\n     /// type.\n-    Type(GenericBounds, Option<&'hir Ty>),\n+    Type(GenericBounds<'hir>, Option<&'hir Ty<'hir>>),\n }\n \n // The bodies for items are stored \"out of line\", in a separate\n@@ -1979,10 +1963,10 @@ pub struct ImplItemId {\n pub struct ImplItem<'hir> {\n     pub ident: Ident,\n     pub hir_id: HirId,\n-    pub vis: Visibility,\n+    pub vis: Visibility<'hir>,\n     pub defaultness: Defaultness,\n     pub attrs: &'hir [Attribute],\n-    pub generics: Generics,\n+    pub generics: Generics<'hir>,\n     pub kind: ImplItemKind<'hir>,\n     pub span: Span,\n }\n@@ -1992,13 +1976,13 @@ pub struct ImplItem<'hir> {\n pub enum ImplItemKind<'hir> {\n     /// An associated constant of the given type, set to the constant result\n     /// of the expression.\n-    Const(&'hir Ty, BodyId),\n+    Const(&'hir Ty<'hir>, BodyId),\n     /// A method implementation with the given signature and body.\n-    Method(FnSig, BodyId),\n+    Method(FnSig<'hir>, BodyId),\n     /// An associated type.\n-    TyAlias(&'hir Ty),\n+    TyAlias(&'hir Ty<'hir>),\n     /// An associated `type = impl Trait`.\n-    OpaqueTy(GenericBounds),\n+    OpaqueTy(GenericBounds<'hir>),\n }\n \n /// Bind a type to an associated type (i.e., `A = Foo`).\n@@ -2017,25 +2001,25 @@ pub enum ImplItemKind<'hir> {\n /// }\n /// ```\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct TypeBinding {\n+pub struct TypeBinding<'hir> {\n     pub hir_id: HirId,\n     #[stable_hasher(project(name))]\n     pub ident: Ident,\n-    pub kind: TypeBindingKind,\n+    pub kind: TypeBindingKind<'hir>,\n     pub span: Span,\n }\n \n // Represents the two kinds of type bindings.\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub enum TypeBindingKind {\n+pub enum TypeBindingKind<'hir> {\n     /// E.g., `Foo<Bar: Send>`.\n-    Constraint { bounds: HirVec<GenericBound> },\n+    Constraint { bounds: &'hir [GenericBound<'hir>] },\n     /// E.g., `Foo<Bar = ()>`.\n-    Equality { ty: P<Ty> },\n+    Equality { ty: &'hir Ty<'hir> },\n }\n \n-impl TypeBinding {\n-    pub fn ty(&self) -> &Ty {\n+impl TypeBinding<'_> {\n+    pub fn ty(&self) -> &Ty<'_> {\n         match self.kind {\n             TypeBindingKind::Equality { ref ty } => ty,\n             _ => bug!(\"expected equality type binding for parenthesized generic args\"),\n@@ -2044,13 +2028,13 @@ impl TypeBinding {\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct Ty {\n+pub struct Ty<'hir> {\n     pub hir_id: HirId,\n-    pub kind: TyKind,\n+    pub kind: TyKind<'hir>,\n     pub span: Span,\n }\n \n-impl fmt::Debug for Ty {\n+impl fmt::Debug for Ty<'_> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"type({})\", print::to_string(print::NO_ANN, |s| s.print_type(self)))\n     }\n@@ -2068,18 +2052,18 @@ pub enum PrimTy {\n }\n \n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct BareFnTy {\n+pub struct BareFnTy<'hir> {\n     pub unsafety: Unsafety,\n     pub abi: Abi,\n-    pub generic_params: HirVec<GenericParam>,\n-    pub decl: P<FnDecl>,\n-    pub param_names: HirVec<Ident>,\n+    pub generic_params: &'hir [GenericParam<'hir>],\n+    pub decl: &'hir FnDecl<'hir>,\n+    pub param_names: &'hir [Ident],\n }\n \n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct OpaqueTy {\n-    pub generics: Generics,\n-    pub bounds: GenericBounds,\n+pub struct OpaqueTy<'hir> {\n+    pub generics: Generics<'hir>,\n+    pub bounds: GenericBounds<'hir>,\n     pub impl_trait_fn: Option<DefId>,\n     pub origin: OpaqueTyOrigin,\n }\n@@ -2097,35 +2081,35 @@ pub enum OpaqueTyOrigin {\n \n /// The various kinds of types recognized by the compiler.\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub enum TyKind {\n+pub enum TyKind<'hir> {\n     /// A variable length slice (i.e., `[T]`).\n-    Slice(P<Ty>),\n+    Slice(&'hir Ty<'hir>),\n     /// A fixed length array (i.e., `[T; n]`).\n-    Array(P<Ty>, AnonConst),\n+    Array(&'hir Ty<'hir>, AnonConst),\n     /// A raw pointer (i.e., `*const T` or `*mut T`).\n-    Ptr(MutTy),\n+    Ptr(MutTy<'hir>),\n     /// A reference (i.e., `&'a T` or `&'a mut T`).\n-    Rptr(Lifetime, MutTy),\n+    Rptr(Lifetime, MutTy<'hir>),\n     /// A bare function (e.g., `fn(usize) -> bool`).\n-    BareFn(P<BareFnTy>),\n+    BareFn(&'hir BareFnTy<'hir>),\n     /// The never type (`!`).\n     Never,\n     /// A tuple (`(A, B, C, D, ...)`).\n-    Tup(HirVec<Ty>),\n+    Tup(&'hir [Ty<'hir>]),\n     /// A path to a type definition (`module::module::...::Type`), or an\n     /// associated type (e.g., `<Vec<T> as Trait>::Type` or `<T>::Target`).\n     ///\n     /// Type parameters may be stored in each `PathSegment`.\n-    Path(QPath),\n+    Path(QPath<'hir>),\n     /// A type definition itself. This is currently only used for the `type Foo = impl Trait`\n     /// item that `impl Trait` in return position desugars to.\n     ///\n     /// The generic argument list contains the lifetimes (and in the future possibly parameters)\n     /// that are actually bound on the `impl Trait`.\n-    Def(ItemId, HirVec<GenericArg>),\n+    Def(ItemId, &'hir [GenericArg<'hir>]),\n     /// A trait object type `Bound1 + Bound2 + Bound3`\n     /// where `Bound` is a trait or a lifetime.\n-    TraitObject(HirVec<PolyTraitRef>, Lifetime),\n+    TraitObject(&'hir [PolyTraitRef<'hir>], Lifetime),\n     /// Unused for now.\n     Typeof(AnonConst),\n     /// `TyKind::Infer` means the type should be inferred instead of it having been\n@@ -2175,12 +2159,12 @@ pub struct Param<'hir> {\n \n /// Represents the header (not the body) of a function declaration.\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct FnDecl {\n+pub struct FnDecl<'hir> {\n     /// The types of the function's parameters.\n     ///\n     /// Additional argument data is stored in the function's [body](Body::parameters).\n-    pub inputs: HirVec<Ty>,\n-    pub output: FunctionRetTy,\n+    pub inputs: &'hir [Ty<'hir>],\n+    pub output: FunctionRetTy<'hir>,\n     pub c_variadic: bool,\n     /// Does the function have an implicit self?\n     pub implicit_self: ImplicitSelfKind,\n@@ -2256,18 +2240,18 @@ impl Defaultness {\n }\n \n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub enum FunctionRetTy {\n+pub enum FunctionRetTy<'hir> {\n     /// Return type is not specified.\n     ///\n     /// Functions default to `()` and\n     /// closures default to inference. Span points to where return\n     /// type would be inserted.\n     DefaultReturn(Span),\n     /// Everything else.\n-    Return(P<Ty>),\n+    Return(&'hir Ty<'hir>),\n }\n \n-impl fmt::Display for FunctionRetTy {\n+impl fmt::Display for FunctionRetTy<'_> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n             Return(ref ty) => print::to_string(print::NO_ANN, |s| s.print_type(ty)).fmt(f),\n@@ -2276,7 +2260,7 @@ impl fmt::Display for FunctionRetTy {\n     }\n }\n \n-impl FunctionRetTy {\n+impl FunctionRetTy<'_> {\n     pub fn span(&self) -> Span {\n         match *self {\n             DefaultReturn(span) => span,\n@@ -2350,14 +2334,14 @@ pub enum UseKind {\n /// trait being referred to but just a unique `HirId` that serves as a key\n /// within the resolution map.\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct TraitRef {\n-    pub path: P<Path>,\n+pub struct TraitRef<'hir> {\n+    pub path: &'hir Path<'hir>,\n     // Don't hash the `ref_id`. It is tracked via the thing it is used to access.\n     #[stable_hasher(ignore)]\n     pub hir_ref_id: HirId,\n }\n \n-impl TraitRef {\n+impl TraitRef<'_> {\n     /// Gets the `DefId` of the referenced trait. It _must_ actually be a trait or trait alias.\n     pub fn trait_def_id(&self) -> DefId {\n         match self.path.res {\n@@ -2372,27 +2356,27 @@ impl TraitRef {\n }\n \n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct PolyTraitRef {\n+pub struct PolyTraitRef<'hir> {\n     /// The `'a` in `<'a> Foo<&'a T>`.\n-    pub bound_generic_params: HirVec<GenericParam>,\n+    pub bound_generic_params: &'hir [GenericParam<'hir>],\n \n     /// The `Foo<&'a T>` in `<'a> Foo<&'a T>`.\n-    pub trait_ref: TraitRef,\n+    pub trait_ref: TraitRef<'hir>,\n \n     pub span: Span,\n }\n \n-pub type Visibility = Spanned<VisibilityKind>;\n+pub type Visibility<'hir> = Spanned<VisibilityKind<'hir>>;\n \n #[derive(RustcEncodable, RustcDecodable, Debug)]\n-pub enum VisibilityKind {\n+pub enum VisibilityKind<'hir> {\n     Public,\n     Crate(CrateSugar),\n-    Restricted { path: P<Path>, hir_id: HirId },\n+    Restricted { path: &'hir Path<'hir>, hir_id: HirId },\n     Inherited,\n }\n \n-impl VisibilityKind {\n+impl VisibilityKind<'_> {\n     pub fn is_pub(&self) -> bool {\n         match *self {\n             VisibilityKind::Public => true,\n@@ -2422,9 +2406,9 @@ pub struct StructField<'hir> {\n     pub span: Span,\n     #[stable_hasher(project(name))]\n     pub ident: Ident,\n-    pub vis: Visibility,\n+    pub vis: Visibility<'hir>,\n     pub hir_id: HirId,\n-    pub ty: &'hir Ty,\n+    pub ty: &'hir Ty<'hir>,\n     pub attrs: &'hir [Attribute],\n }\n \n@@ -2488,7 +2472,7 @@ pub struct Item<'hir> {\n     pub hir_id: HirId,\n     pub attrs: &'hir [Attribute],\n     pub kind: ItemKind<'hir>,\n-    pub vis: Visibility,\n+    pub vis: Visibility<'hir>,\n     pub span: Span,\n }\n \n@@ -2521,44 +2505,44 @@ pub enum ItemKind<'hir> {\n     /// or just\n     ///\n     /// `use foo::bar::baz;` (with `as baz` implicitly on the right).\n-    Use(&'hir Path, UseKind),\n+    Use(&'hir Path<'hir>, UseKind),\n \n     /// A `static` item.\n-    Static(&'hir Ty, Mutability, BodyId),\n+    Static(&'hir Ty<'hir>, Mutability, BodyId),\n     /// A `const` item.\n-    Const(&'hir Ty, BodyId),\n+    Const(&'hir Ty<'hir>, BodyId),\n     /// A function declaration.\n-    Fn(FnSig, Generics, BodyId),\n+    Fn(FnSig<'hir>, Generics<'hir>, BodyId),\n     /// A module.\n     Mod(Mod<'hir>),\n     /// An external module, e.g. `extern { .. }`.\n     ForeignMod(ForeignMod<'hir>),\n     /// Module-level inline assembly (from `global_asm!`).\n     GlobalAsm(&'hir GlobalAsm),\n     /// A type alias, e.g., `type Foo = Bar<u8>`.\n-    TyAlias(&'hir Ty, Generics),\n+    TyAlias(&'hir Ty<'hir>, Generics<'hir>),\n     /// An opaque `impl Trait` type alias, e.g., `type Foo = impl Bar;`.\n-    OpaqueTy(OpaqueTy),\n+    OpaqueTy(OpaqueTy<'hir>),\n     /// An enum definition, e.g., `enum Foo<A, B> {C<A>, D<B>}`.\n-    Enum(EnumDef<'hir>, Generics),\n+    Enum(EnumDef<'hir>, Generics<'hir>),\n     /// A struct definition, e.g., `struct Foo<A> {x: A}`.\n-    Struct(VariantData<'hir>, Generics),\n+    Struct(VariantData<'hir>, Generics<'hir>),\n     /// A union definition, e.g., `union Foo<A, B> {x: A, y: B}`.\n-    Union(VariantData<'hir>, Generics),\n+    Union(VariantData<'hir>, Generics<'hir>),\n     /// A trait definition.\n-    Trait(IsAuto, Unsafety, Generics, GenericBounds, &'hir [TraitItemRef]),\n+    Trait(IsAuto, Unsafety, Generics<'hir>, GenericBounds<'hir>, &'hir [TraitItemRef]),\n     /// A trait alias.\n-    TraitAlias(Generics, GenericBounds),\n+    TraitAlias(Generics<'hir>, GenericBounds<'hir>),\n \n     /// An implementation, e.g., `impl<A> Trait for Foo { .. }`.\n     Impl(\n         Unsafety,\n         ImplPolarity,\n         Defaultness,\n-        Generics,\n-        Option<TraitRef>, // (optional) trait this impl implements\n-        &'hir Ty,         // self\n-        &'hir [ImplItemRef],\n+        Generics<'hir>,\n+        Option<TraitRef<'hir>>, // (optional) trait this impl implements\n+        &'hir Ty<'hir>,         // self\n+        &'hir [ImplItemRef<'hir>],\n     ),\n }\n \n@@ -2593,7 +2577,7 @@ impl ItemKind<'_> {\n         }\n     }\n \n-    pub fn generics(&self) -> Option<&Generics> {\n+    pub fn generics(&self) -> Option<&Generics<'_>> {\n         Some(match *self {\n             ItemKind::Fn(_, ref generics, _)\n             | ItemKind::TyAlias(_, ref generics)\n@@ -2631,13 +2615,13 @@ pub struct TraitItemRef {\n /// passes to find the impl they want without loading the ID (which\n /// means fewer edges in the incremental compilation graph).\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct ImplItemRef {\n+pub struct ImplItemRef<'hir> {\n     pub id: ImplItemId,\n     #[stable_hasher(project(name))]\n     pub ident: Ident,\n     pub kind: AssocItemKind,\n     pub span: Span,\n-    pub vis: Visibility,\n+    pub vis: Visibility<'hir>,\n     pub defaultness: Defaultness,\n }\n \n@@ -2657,16 +2641,16 @@ pub struct ForeignItem<'hir> {\n     pub kind: ForeignItemKind<'hir>,\n     pub hir_id: HirId,\n     pub span: Span,\n-    pub vis: Visibility,\n+    pub vis: Visibility<'hir>,\n }\n \n /// An item within an `extern` block.\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum ForeignItemKind<'hir> {\n     /// A foreign function.\n-    Fn(&'hir FnDecl, &'hir [Ident], Generics),\n+    Fn(&'hir FnDecl<'hir>, &'hir [Ident], Generics<'hir>),\n     /// A foreign static item (`static ext: u8`).\n-    Static(&'hir Ty, Mutability),\n+    Static(&'hir Ty<'hir>, Mutability),\n     /// A foreign type.\n     Type,\n }\n@@ -2837,9 +2821,9 @@ pub enum Node<'hir> {\n     AnonConst(&'hir AnonConst),\n     Expr(&'hir Expr<'hir>),\n     Stmt(&'hir Stmt<'hir>),\n-    PathSegment(&'hir PathSegment),\n-    Ty(&'hir Ty),\n-    TraitRef(&'hir TraitRef),\n+    PathSegment(&'hir PathSegment<'hir>),\n+    Ty(&'hir Ty<'hir>),\n+    TraitRef(&'hir TraitRef<'hir>),\n     Binding(&'hir Pat<'hir>),\n     Pat(&'hir Pat<'hir>),\n     Arm(&'hir Arm<'hir>),\n@@ -2852,8 +2836,8 @@ pub enum Node<'hir> {\n     Ctor(&'hir VariantData<'hir>),\n \n     Lifetime(&'hir Lifetime),\n-    GenericParam(&'hir GenericParam),\n-    Visibility(&'hir Visibility),\n+    GenericParam(&'hir GenericParam<'hir>),\n+    Visibility(&'hir Visibility<'hir>),\n \n     Crate,\n }"}, {"sha": "61afdab3e1cf6dc7f48faceae46bb0592be10d80", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 46, "deletions": 48, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=2ba0d2acbd6cb01fb07619628882120d5b66bd59", "patch": "@@ -10,6 +10,7 @@ use syntax::util::parser::{self, AssocOp, Fixity};\n use syntax_pos::{self, BytePos, FileName};\n \n use crate::hir;\n+use crate::hir::HirVec;\n use crate::hir::{GenericArg, GenericParam, GenericParamKind};\n use crate::hir::{GenericBound, PatKind, RangeEnd, TraitBoundModifier};\n \n@@ -140,7 +141,7 @@ where\n     printer.s.eof()\n }\n \n-pub fn visibility_qualified<S: Into<Cow<'static, str>>>(vis: &hir::Visibility, w: S) -> String {\n+pub fn visibility_qualified<S: Into<Cow<'static, str>>>(vis: &hir::Visibility<'_>, w: S) -> String {\n     to_string(NO_ANN, |s| {\n         s.print_visibility(vis);\n         s.s.word(w)\n@@ -266,7 +267,7 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_type(&mut self, ty: &hir::Ty) {\n+    pub fn print_type(&mut self, ty: &hir::Ty<'_>) {\n         self.maybe_print_comment(ty.span.lo());\n         self.ibox(0);\n         match ty.kind {\n@@ -307,7 +308,7 @@ impl<'a> State<'a> {\n             }\n             hir::TyKind::Def(..) => {}\n             hir::TyKind::Path(ref qpath) => self.print_qpath(qpath, false),\n-            hir::TyKind::TraitObject(ref bounds, ref lifetime) => {\n+            hir::TyKind::TraitObject(bounds, ref lifetime) => {\n                 let mut first = true;\n                 for bound in bounds {\n                     if first {\n@@ -398,9 +399,9 @@ impl<'a> State<'a> {\n     fn print_associated_const(\n         &mut self,\n         ident: ast::Ident,\n-        ty: &hir::Ty,\n+        ty: &hir::Ty<'_>,\n         default: Option<hir::BodyId>,\n-        vis: &hir::Visibility,\n+        vis: &hir::Visibility<'_>,\n     ) {\n         self.s.word(visibility_qualified(vis, \"\"));\n         self.word_space(\"const\");\n@@ -418,8 +419,8 @@ impl<'a> State<'a> {\n     fn print_associated_type(\n         &mut self,\n         ident: ast::Ident,\n-        bounds: Option<&hir::GenericBounds>,\n-        ty: Option<&hir::Ty>,\n+        bounds: Option<hir::GenericBounds<'_>>,\n+        ty: Option<&hir::Ty<'_>>,\n     ) {\n         self.word_space(\"type\");\n         self.print_ident(ident);\n@@ -437,7 +438,7 @@ impl<'a> State<'a> {\n     fn print_item_type(\n         &mut self,\n         item: &hir::Item<'_>,\n-        generics: &hir::Generics,\n+        generics: &hir::Generics<'_>,\n         inner: impl Fn(&mut Self),\n     ) {\n         self.head(visibility_qualified(&item.vis, \"type\"));\n@@ -682,30 +683,30 @@ impl<'a> State<'a> {\n         self.ann.post(self, AnnNode::Item(item))\n     }\n \n-    pub fn print_trait_ref(&mut self, t: &hir::TraitRef) {\n+    pub fn print_trait_ref(&mut self, t: &hir::TraitRef<'_>) {\n         self.print_path(&t.path, false)\n     }\n \n-    fn print_formal_generic_params(&mut self, generic_params: &[hir::GenericParam]) {\n+    fn print_formal_generic_params(&mut self, generic_params: &[hir::GenericParam<'_>]) {\n         if !generic_params.is_empty() {\n             self.s.word(\"for\");\n             self.print_generic_params(generic_params);\n             self.nbsp();\n         }\n     }\n \n-    fn print_poly_trait_ref(&mut self, t: &hir::PolyTraitRef) {\n+    fn print_poly_trait_ref(&mut self, t: &hir::PolyTraitRef<'_>) {\n         self.print_formal_generic_params(&t.bound_generic_params);\n         self.print_trait_ref(&t.trait_ref)\n     }\n \n     pub fn print_enum_def(\n         &mut self,\n         enum_definition: &hir::EnumDef<'_>,\n-        generics: &hir::Generics,\n+        generics: &hir::Generics<'_>,\n         name: ast::Name,\n         span: syntax_pos::Span,\n-        visibility: &hir::Visibility,\n+        visibility: &hir::Visibility<'_>,\n     ) {\n         self.head(visibility_qualified(visibility, \"enum\"));\n         self.print_name(name);\n@@ -730,7 +731,7 @@ impl<'a> State<'a> {\n         self.bclose(span)\n     }\n \n-    pub fn print_visibility(&mut self, vis: &hir::Visibility) {\n+    pub fn print_visibility(&mut self, vis: &hir::Visibility<'_>) {\n         match vis.node {\n             hir::VisibilityKind::Public => self.word_nbsp(\"pub\"),\n             hir::VisibilityKind::Crate(ast::CrateSugar::JustCrate) => self.word_nbsp(\"crate\"),\n@@ -761,7 +762,7 @@ impl<'a> State<'a> {\n     pub fn print_struct(\n         &mut self,\n         struct_def: &hir::VariantData<'_>,\n-        generics: &hir::Generics,\n+        generics: &hir::Generics<'_>,\n         name: ast::Name,\n         span: syntax_pos::Span,\n         print_finalizer: bool,\n@@ -822,9 +823,9 @@ impl<'a> State<'a> {\n     pub fn print_method_sig(\n         &mut self,\n         ident: ast::Ident,\n-        m: &hir::FnSig,\n-        generics: &hir::Generics,\n-        vis: &hir::Visibility,\n+        m: &hir::FnSig<'_>,\n+        generics: &hir::Generics<'_>,\n+        vis: &hir::Visibility<'_>,\n         arg_names: &[ast::Ident],\n         body_id: Option<hir::BodyId>,\n     ) {\n@@ -891,7 +892,7 @@ impl<'a> State<'a> {\n             hir::ImplItemKind::TyAlias(ref ty) => {\n                 self.print_associated_type(ii.ident, None, Some(ty));\n             }\n-            hir::ImplItemKind::OpaqueTy(ref bounds) => {\n+            hir::ImplItemKind::OpaqueTy(bounds) => {\n                 self.word_space(\"type\");\n                 self.print_ident(ii.ident);\n                 self.print_bounds(\"= impl\", bounds);\n@@ -1044,7 +1045,7 @@ impl<'a> State<'a> {\n \n     fn print_expr_struct(\n         &mut self,\n-        qpath: &hir::QPath,\n+        qpath: &hir::QPath<'_>,\n         fields: &[hir::Field<'_>],\n         wth: &Option<&'hir hir::Expr<'_>>,\n     ) {\n@@ -1103,7 +1104,7 @@ impl<'a> State<'a> {\n         self.print_call_post(args)\n     }\n \n-    fn print_expr_method_call(&mut self, segment: &hir::PathSegment, args: &[hir::Expr<'_>]) {\n+    fn print_expr_method_call(&mut self, segment: &hir::PathSegment<'_>, args: &[hir::Expr<'_>]) {\n         let base_args = &args[1..];\n         self.print_expr_maybe_paren(&args[0], parser::PREC_POSTFIX);\n         self.s.word(\".\");\n@@ -1440,7 +1441,7 @@ impl<'a> State<'a> {\n         self.print_expr(coll)\n     }\n \n-    pub fn print_path(&mut self, path: &hir::Path, colons_before_params: bool) {\n+    pub fn print_path(&mut self, path: &hir::Path<'_>, colons_before_params: bool) {\n         self.maybe_print_comment(path.span.lo());\n \n         for (i, segment) in path.segments.iter().enumerate() {\n@@ -1458,14 +1459,14 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_path_segment(&mut self, segment: &hir::PathSegment) {\n+    pub fn print_path_segment(&mut self, segment: &hir::PathSegment<'_>) {\n         if segment.ident.name != kw::PathRoot {\n             self.print_ident(segment.ident);\n             self.print_generic_args(segment.generic_args(), segment.infer_args, false);\n         }\n     }\n \n-    pub fn print_qpath(&mut self, qpath: &hir::QPath, colons_before_params: bool) {\n+    pub fn print_qpath(&mut self, qpath: &hir::QPath<'_>, colons_before_params: bool) {\n         match *qpath {\n             hir::QPath::Resolved(None, ref path) => self.print_path(path, colons_before_params),\n             hir::QPath::Resolved(Some(ref qself), ref path) => {\n@@ -1523,7 +1524,7 @@ impl<'a> State<'a> {\n \n     fn print_generic_args(\n         &mut self,\n-        generic_args: &hir::GenericArgs,\n+        generic_args: &hir::GenericArgs<'_>,\n         infer_args: bool,\n         colons_before_params: bool,\n     ) {\n@@ -1586,7 +1587,7 @@ impl<'a> State<'a> {\n                         self.word_space(\"=\");\n                         self.print_type(ty);\n                     }\n-                    hir::TypeBindingKind::Constraint { ref bounds } => {\n+                    hir::TypeBindingKind::Constraint { bounds } => {\n                         self.print_bounds(\":\", bounds);\n                     }\n                 }\n@@ -1814,11 +1815,11 @@ impl<'a> State<'a> {\n \n     pub fn print_fn(\n         &mut self,\n-        decl: &hir::FnDecl,\n+        decl: &hir::FnDecl<'_>,\n         header: hir::FnHeader,\n         name: Option<ast::Name>,\n-        generics: &hir::Generics,\n-        vis: &hir::Visibility,\n+        generics: &hir::Generics<'_>,\n+        vis: &hir::Visibility<'_>,\n         arg_names: &[ast::Ident],\n         body_id: Option<hir::BodyId>,\n     ) {\n@@ -1858,7 +1859,7 @@ impl<'a> State<'a> {\n         self.print_where_clause(&generics.where_clause)\n     }\n \n-    fn print_closure_params(&mut self, decl: &hir::FnDecl, body_id: hir::BodyId) {\n+    fn print_closure_params(&mut self, decl: &hir::FnDecl<'_>, body_id: hir::BodyId) {\n         self.s.word(\"|\");\n         let mut i = 0;\n         self.commasep(Inconsistent, &decl.inputs, |s, ty| {\n@@ -1903,7 +1904,7 @@ impl<'a> State<'a> {\n     pub fn print_bounds<'b>(\n         &mut self,\n         prefix: &'static str,\n-        bounds: impl IntoIterator<Item = &'b hir::GenericBound>,\n+        bounds: impl IntoIterator<Item = &'b hir::GenericBound<'b>>,\n     ) {\n         let mut first = true;\n         for bound in bounds {\n@@ -1933,7 +1934,7 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_generic_params(&mut self, generic_params: &[GenericParam]) {\n+    pub fn print_generic_params(&mut self, generic_params: &[GenericParam<'_>]) {\n         if !generic_params.is_empty() {\n             self.s.word(\"<\");\n \n@@ -1943,7 +1944,7 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_generic_param(&mut self, param: &GenericParam) {\n+    pub fn print_generic_param(&mut self, param: &GenericParam<'_>) {\n         if let GenericParamKind::Const { .. } = param.kind {\n             self.word_space(\"const\");\n         }\n@@ -1953,9 +1954,9 @@ impl<'a> State<'a> {\n         match param.kind {\n             GenericParamKind::Lifetime { .. } => {\n                 let mut sep = \":\";\n-                for bound in &param.bounds {\n+                for bound in param.bounds {\n                     match bound {\n-                        GenericBound::Outlives(lt) => {\n+                        GenericBound::Outlives(ref lt) => {\n                             self.s.word(sep);\n                             self.print_lifetime(lt);\n                             sep = \"+\";\n@@ -1965,7 +1966,7 @@ impl<'a> State<'a> {\n                 }\n             }\n             GenericParamKind::Type { ref default, .. } => {\n-                self.print_bounds(\":\", &param.bounds);\n+                self.print_bounds(\":\", param.bounds);\n                 match default {\n                     Some(default) => {\n                         self.s.space();\n@@ -1986,7 +1987,7 @@ impl<'a> State<'a> {\n         self.print_ident(lifetime.name.ident())\n     }\n \n-    pub fn print_where_clause(&mut self, where_clause: &hir::WhereClause) {\n+    pub fn print_where_clause(&mut self, where_clause: &hir::WhereClause<'_>) {\n         if where_clause.predicates.is_empty() {\n             return;\n         }\n@@ -2003,7 +2004,7 @@ impl<'a> State<'a> {\n                 &hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate {\n                     ref bound_generic_params,\n                     ref bounded_ty,\n-                    ref bounds,\n+                    bounds,\n                     ..\n                 }) => {\n                     self.print_formal_generic_params(bound_generic_params);\n@@ -2056,12 +2057,12 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_mt(&mut self, mt: &hir::MutTy, print_const: bool) {\n+    pub fn print_mt(&mut self, mt: &hir::MutTy<'_>, print_const: bool) {\n         self.print_mutability(mt.mutbl, print_const);\n         self.print_type(&mt.ty)\n     }\n \n-    pub fn print_fn_output(&mut self, decl: &hir::FnDecl) {\n+    pub fn print_fn_output(&mut self, decl: &hir::FnDecl<'_>) {\n         if let hir::DefaultReturn(..) = decl.output {\n             return;\n         }\n@@ -2085,9 +2086,9 @@ impl<'a> State<'a> {\n         &mut self,\n         abi: Abi,\n         unsafety: hir::Unsafety,\n-        decl: &hir::FnDecl,\n+        decl: &hir::FnDecl<'_>,\n         name: Option<ast::Name>,\n-        generic_params: &[hir::GenericParam],\n+        generic_params: &[hir::GenericParam<'_>],\n         arg_names: &[ast::Ident],\n     ) {\n         self.ibox(INDENT_UNIT);\n@@ -2096,11 +2097,8 @@ impl<'a> State<'a> {\n             self.print_generic_params(generic_params);\n         }\n         let generics = hir::Generics {\n-            params: hir::HirVec::new(),\n-            where_clause: hir::WhereClause {\n-                predicates: hir::HirVec::new(),\n-                span: syntax_pos::DUMMY_SP,\n-            },\n+            params: HirVec::new(),\n+            where_clause: hir::WhereClause { predicates: &[], span: syntax_pos::DUMMY_SP },\n             span: syntax_pos::DUMMY_SP,\n         };\n         self.print_fn(\n@@ -2164,7 +2162,7 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_fn_header_info(&mut self, header: hir::FnHeader, vis: &hir::Visibility) {\n+    pub fn print_fn_header_info(&mut self, header: hir::FnHeader, vis: &hir::Visibility<'_>) {\n         self.s.word(visibility_qualified(vis, \"\"));\n \n         match header.constness {"}, {"sha": "b43817c9601b305b0053125f86444a3235df6962", "filename": "src/librustc/hir/ptr.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc%2Fhir%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc%2Fhir%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fptr.rs?ref=2ba0d2acbd6cb01fb07619628882120d5b66bd59", "patch": "@@ -22,14 +22,6 @@ pub fn P<T: 'static>(value: T) -> P<T> {\n     P { ptr: box value }\n }\n \n-impl<T: 'static> P<T> {\n-    // HACK(eddyb) used by HIR lowering in a few places still.\n-    // NOTE: do not make this more public than `pub(super)`.\n-    pub(super) fn into_inner(self) -> T {\n-        *self.ptr\n-    }\n-}\n-\n impl<T: ?Sized> Deref for P<T> {\n     type Target = T;\n "}, {"sha": "827cf7513944fa235951c3e4af73036faa21eabe", "filename": "src/librustc/hir/upvars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc%2Fhir%2Fupvars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc%2Fhir%2Fupvars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fupvars.rs?ref=2ba0d2acbd6cb01fb07619628882120d5b66bd59", "patch": "@@ -73,7 +73,7 @@ impl Visitor<'tcx> for CaptureCollector<'a, 'tcx> {\n         NestedVisitorMap::None\n     }\n \n-    fn visit_path(&mut self, path: &'tcx hir::Path, _: hir::HirId) {\n+    fn visit_path(&mut self, path: &'tcx hir::Path<'tcx>, _: hir::HirId) {\n         if let Res::Local(var_id) = path.res {\n             self.visit_local_use(var_id, path.span);\n         }"}, {"sha": "214a50456d57609a48e1354fa156d448a93e4a6d", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=2ba0d2acbd6cb01fb07619628882120d5b66bd59", "patch": "@@ -106,7 +106,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::ImplItemId {\n     }\n }\n \n-impl<'a> HashStable<StableHashingContext<'a>> for hir::Ty {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::Ty<'_> {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         hcx.while_hashing_hir_bodies(true, |hcx| {\n             let hir::Ty { hir_id: _, ref kind, ref span } = *self;\n@@ -168,7 +168,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::ImplItem<'_> {\n     }\n }\n \n-impl<'a> HashStable<StableHashingContext<'a>> for hir::VisibilityKind {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::VisibilityKind<'_> {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {"}, {"sha": "5a6d336ee1b926524bad39b46cafdc9e4a537b9e", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=2ba0d2acbd6cb01fb07619628882120d5b66bd59", "patch": "@@ -107,7 +107,7 @@ impl<'a, 'tcx> Visitor<'tcx> for FindLocalByTypeVisitor<'a, 'tcx> {\n fn closure_return_type_suggestion(\n     span: Span,\n     err: &mut DiagnosticBuilder<'_>,\n-    output: &FunctionRetTy,\n+    output: &FunctionRetTy<'_>,\n     body: &Body<'_>,\n     descr: &str,\n     name: &str,\n@@ -460,7 +460,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// needed, suggest annotating the call, otherwise point out the resulting type of the call.\n     fn annotate_method_call(\n         &self,\n-        segment: &hir::PathSegment,\n+        segment: &hir::PathSegment<'_>,\n         e: &Expr<'_>,\n         err: &mut DiagnosticBuilder<'_>,\n     ) {"}, {"sha": "0b226336faca39ea5d4961ad0c457926271ab432", "filename": "src/librustc/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=2ba0d2acbd6cb01fb07619628882120d5b66bd59", "patch": "@@ -25,7 +25,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         &self,\n         region: Region<'tcx>,\n         br: &ty::BoundRegion,\n-    ) -> Option<(&hir::Ty, &hir::FnDecl)> {\n+    ) -> Option<(&hir::Ty<'_>, &hir::FnDecl<'_>)> {\n         if let Some(anon_reg) = self.tcx().is_suitable_region(region) {\n             let def_id = anon_reg.def_id;\n             if let Some(hir_id) = self.tcx().hir().as_local_hir_id(def_id) {\n@@ -57,9 +57,9 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     // to the anonymous region.\n     fn find_component_for_bound_region(\n         &self,\n-        arg: &'tcx hir::Ty,\n+        arg: &'tcx hir::Ty<'tcx>,\n         br: &ty::BoundRegion,\n-    ) -> Option<&'tcx hir::Ty> {\n+    ) -> Option<&'tcx hir::Ty<'tcx>> {\n         let mut nested_visitor = FindNestedTypeVisitor {\n             tcx: self.tcx(),\n             bound_region: *br,\n@@ -85,7 +85,7 @@ struct FindNestedTypeVisitor<'tcx> {\n     bound_region: ty::BoundRegion,\n     // The type where the anonymous lifetime appears\n     // for e.g., Vec<`&u8`> and <`&u8`>\n-    found_type: Option<&'tcx hir::Ty>,\n+    found_type: Option<&'tcx hir::Ty<'tcx>>,\n     current_index: ty::DebruijnIndex,\n }\n \n@@ -94,7 +94,7 @@ impl Visitor<'tcx> for FindNestedTypeVisitor<'tcx> {\n         NestedVisitorMap::OnlyBodies(&self.tcx.hir())\n     }\n \n-    fn visit_ty(&mut self, arg: &'tcx hir::Ty) {\n+    fn visit_ty(&mut self, arg: &'tcx hir::Ty<'tcx>) {\n         match arg.kind {\n             hir::TyKind::BareFn(_) => {\n                 self.current_index.shift_in(1);\n@@ -103,7 +103,7 @@ impl Visitor<'tcx> for FindNestedTypeVisitor<'tcx> {\n                 return;\n             }\n \n-            hir::TyKind::TraitObject(ref bounds, _) => {\n+            hir::TyKind::TraitObject(bounds, _) => {\n                 for bound in bounds {\n                     self.current_index.shift_in(1);\n                     self.visit_poly_trait_ref(bound, hir::TraitBoundModifier::None);\n@@ -250,7 +250,7 @@ impl Visitor<'tcx> for TyPathVisitor<'tcx> {\n         }\n     }\n \n-    fn visit_ty(&mut self, arg: &'tcx hir::Ty) {\n+    fn visit_ty(&mut self, arg: &'tcx hir::Ty<'tcx>) {\n         // ignore nested types\n         //\n         // If you have a type like `Foo<'a, &Ty>` we"}, {"sha": "95feef313c07abbb312b0378fb59eabff7d1d585", "filename": "src/librustc/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=2ba0d2acbd6cb01fb07619628882120d5b66bd59", "patch": "@@ -106,7 +106,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         &self,\n         scope_def_id: DefId,\n         br: ty::BoundRegion,\n-        decl: &hir::FnDecl,\n+        decl: &hir::FnDecl<'_>,\n     ) -> Option<Span> {\n         let ret_ty = self.tcx().type_of(scope_def_id);\n         if let ty::FnDef(_, _) = ret_ty.kind {"}, {"sha": "44258b62ca32f2c2f9bc22052bdf77e93892fe1e", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=2ba0d2acbd6cb01fb07619628882120d5b66bd59", "patch": "@@ -452,7 +452,7 @@ pub struct LateContext<'a, 'tcx> {\n     last_node_with_lint_attrs: hir::HirId,\n \n     /// Generic type parameters in scope for the item we are in.\n-    pub generics: Option<&'tcx hir::Generics>,\n+    pub generics: Option<&'tcx hir::Generics<'tcx>>,\n \n     /// We are only looking at one module\n     only_module: bool,\n@@ -956,7 +956,7 @@ impl<'a, 'tcx, T: LateLintPass<'a, 'tcx>> hir_visit::Visitor<'tcx>\n     fn visit_fn(\n         &mut self,\n         fk: hir_visit::FnKind<'tcx>,\n-        decl: &'tcx hir::FnDecl,\n+        decl: &'tcx hir::FnDecl<'tcx>,\n         body_id: hir::BodyId,\n         span: Span,\n         id: hir::HirId,\n@@ -976,7 +976,7 @@ impl<'a, 'tcx, T: LateLintPass<'a, 'tcx>> hir_visit::Visitor<'tcx>\n         &mut self,\n         s: &'tcx hir::VariantData<'tcx>,\n         _: ast::Name,\n-        _: &'tcx hir::Generics,\n+        _: &'tcx hir::Generics<'tcx>,\n         _: hir::HirId,\n         _: Span,\n     ) {\n@@ -995,7 +995,7 @@ impl<'a, 'tcx, T: LateLintPass<'a, 'tcx>> hir_visit::Visitor<'tcx>\n     fn visit_variant(\n         &mut self,\n         v: &'tcx hir::Variant<'tcx>,\n-        g: &'tcx hir::Generics,\n+        g: &'tcx hir::Generics<'tcx>,\n         item_id: hir::HirId,\n     ) {\n         self.with_lint_attrs(v.id, &v.attrs, |cx| {\n@@ -1005,7 +1005,7 @@ impl<'a, 'tcx, T: LateLintPass<'a, 'tcx>> hir_visit::Visitor<'tcx>\n         })\n     }\n \n-    fn visit_ty(&mut self, t: &'tcx hir::Ty) {\n+    fn visit_ty(&mut self, t: &'tcx hir::Ty<'tcx>) {\n         lint_callback!(self, check_ty, t);\n         hir_visit::walk_ty(self, t);\n     }\n@@ -1038,22 +1038,26 @@ impl<'a, 'tcx, T: LateLintPass<'a, 'tcx>> hir_visit::Visitor<'tcx>\n         hir_visit::walk_arm(self, a);\n     }\n \n-    fn visit_generic_param(&mut self, p: &'tcx hir::GenericParam) {\n+    fn visit_generic_param(&mut self, p: &'tcx hir::GenericParam<'tcx>) {\n         lint_callback!(self, check_generic_param, p);\n         hir_visit::walk_generic_param(self, p);\n     }\n \n-    fn visit_generics(&mut self, g: &'tcx hir::Generics) {\n+    fn visit_generics(&mut self, g: &'tcx hir::Generics<'tcx>) {\n         lint_callback!(self, check_generics, g);\n         hir_visit::walk_generics(self, g);\n     }\n \n-    fn visit_where_predicate(&mut self, p: &'tcx hir::WherePredicate) {\n+    fn visit_where_predicate(&mut self, p: &'tcx hir::WherePredicate<'tcx>) {\n         lint_callback!(self, check_where_predicate, p);\n         hir_visit::walk_where_predicate(self, p);\n     }\n \n-    fn visit_poly_trait_ref(&mut self, t: &'tcx hir::PolyTraitRef, m: hir::TraitBoundModifier) {\n+    fn visit_poly_trait_ref(\n+        &mut self,\n+        t: &'tcx hir::PolyTraitRef<'tcx>,\n+        m: hir::TraitBoundModifier,\n+    ) {\n         lint_callback!(self, check_poly_trait_ref, t, m);\n         hir_visit::walk_poly_trait_ref(self, t, m);\n     }\n@@ -1089,7 +1093,7 @@ impl<'a, 'tcx, T: LateLintPass<'a, 'tcx>> hir_visit::Visitor<'tcx>\n         hir_visit::walk_lifetime(self, lt);\n     }\n \n-    fn visit_path(&mut self, p: &'tcx hir::Path, id: hir::HirId) {\n+    fn visit_path(&mut self, p: &'tcx hir::Path<'tcx>, id: hir::HirId) {\n         lint_callback!(self, check_path, p, id);\n         hir_visit::walk_path(self, p);\n     }"}, {"sha": "bd75eda1879b19b35d78efbba5d554aa89e9ca0a", "filename": "src/librustc/lint/internal.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc%2Flint%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc%2Flint%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Finternal.rs?ref=2ba0d2acbd6cb01fb07619628882120d5b66bd59", "patch": "@@ -76,7 +76,7 @@ declare_lint_pass!(TyTyKind => [\n ]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TyTyKind {\n-    fn check_path(&mut self, cx: &LateContext<'_, '_>, path: &'tcx Path, _: HirId) {\n+    fn check_path(&mut self, cx: &LateContext<'_, '_>, path: &'tcx Path<'tcx>, _: HirId) {\n         let segments = path.segments.iter().rev().skip(1).rev();\n \n         if let Some(last) = segments.last() {\n@@ -94,7 +94,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TyTyKind {\n         }\n     }\n \n-    fn check_ty(&mut self, cx: &LateContext<'_, '_>, ty: &'tcx Ty) {\n+    fn check_ty(&mut self, cx: &LateContext<'_, '_>, ty: &'tcx Ty<'tcx>) {\n         match &ty.kind {\n             TyKind::Path(qpath) => {\n                 if let QPath::Resolved(_, path) = qpath {\n@@ -159,7 +159,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TyTyKind {\n     }\n }\n \n-fn lint_ty_kind_usage(cx: &LateContext<'_, '_>, segment: &PathSegment) -> bool {\n+fn lint_ty_kind_usage(cx: &LateContext<'_, '_>, segment: &PathSegment<'_>) -> bool {\n     if let Some(res) = segment.res {\n         if let Some(did) = res.opt_def_id() {\n             return cx.tcx.is_diagnostic_item(sym::TyKind, did);\n@@ -169,7 +169,7 @@ fn lint_ty_kind_usage(cx: &LateContext<'_, '_>, segment: &PathSegment) -> bool {\n     false\n }\n \n-fn is_ty_or_ty_ctxt(cx: &LateContext<'_, '_>, ty: &Ty) -> Option<String> {\n+fn is_ty_or_ty_ctxt(cx: &LateContext<'_, '_>, ty: &Ty<'_>) -> Option<String> {\n     match &ty.kind {\n         TyKind::Path(qpath) => {\n             if let QPath::Resolved(_, path) = qpath {\n@@ -187,7 +187,7 @@ fn is_ty_or_ty_ctxt(cx: &LateContext<'_, '_>, ty: &Ty) -> Option<String> {\n     None\n }\n \n-fn gen_args(segment: &PathSegment) -> String {\n+fn gen_args(segment: &PathSegment<'_>) -> String {\n     if let Some(args) = &segment.args {\n         let lifetimes = args\n             .args"}, {"sha": "f4684bd52224f1a6a73662609dfe275f8a79c4d5", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=2ba0d2acbd6cb01fb07619628882120d5b66bd59", "patch": "@@ -107,20 +107,20 @@ macro_rules! late_lint_methods {\n             fn check_pat(a: &$hir hir::Pat<$hir>);\n             fn check_expr(a: &$hir hir::Expr<$hir>);\n             fn check_expr_post(a: &$hir hir::Expr<$hir>);\n-            fn check_ty(a: &$hir hir::Ty);\n-            fn check_generic_param(a: &$hir hir::GenericParam);\n-            fn check_generics(a: &$hir hir::Generics);\n-            fn check_where_predicate(a: &$hir hir::WherePredicate);\n-            fn check_poly_trait_ref(a: &$hir hir::PolyTraitRef, b: hir::TraitBoundModifier);\n+            fn check_ty(a: &$hir hir::Ty<$hir>);\n+            fn check_generic_param(a: &$hir hir::GenericParam<$hir>);\n+            fn check_generics(a: &$hir hir::Generics<$hir>);\n+            fn check_where_predicate(a: &$hir hir::WherePredicate<$hir>);\n+            fn check_poly_trait_ref(a: &$hir hir::PolyTraitRef<$hir>, b: hir::TraitBoundModifier);\n             fn check_fn(\n                 a: hir::intravisit::FnKind<$hir>,\n-                b: &$hir hir::FnDecl,\n+                b: &$hir hir::FnDecl<$hir>,\n                 c: &$hir hir::Body<$hir>,\n                 d: Span,\n                 e: hir::HirId);\n             fn check_fn_post(\n                 a: hir::intravisit::FnKind<$hir>,\n-                b: &$hir hir::FnDecl,\n+                b: &$hir hir::FnDecl<$hir>,\n                 c: &$hir hir::Body<$hir>,\n                 d: Span,\n                 e: hir::HirId\n@@ -135,7 +135,7 @@ macro_rules! late_lint_methods {\n             fn check_variant(a: &$hir hir::Variant<$hir>);\n             fn check_variant_post(a: &$hir hir::Variant<$hir>);\n             fn check_lifetime(a: &$hir hir::Lifetime);\n-            fn check_path(a: &$hir hir::Path, b: hir::HirId);\n+            fn check_path(a: &$hir hir::Path<$hir>, b: hir::HirId);\n             fn check_attribute(a: &$hir ast::Attribute);\n \n             /// Called when entering a syntax node that can have lint attributes such\n@@ -643,7 +643,7 @@ impl intravisit::Visitor<'tcx> for LintLevelMapBuilder<'_, 'tcx> {\n     fn visit_variant(\n         &mut self,\n         v: &'tcx hir::Variant<'tcx>,\n-        g: &'tcx hir::Generics,\n+        g: &'tcx hir::Generics<'tcx>,\n         item_id: hir::HirId,\n     ) {\n         self.with_lint_attrs(v.id, &v.attrs, |builder| {"}, {"sha": "29e3bcfe6a15ceca1a1bef3662149b8b5a9c74ec", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 60, "deletions": 48, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=2ba0d2acbd6cb01fb07619628882120d5b66bd59", "patch": "@@ -8,7 +8,6 @@\n use crate::hir::def::{DefKind, Res};\n use crate::hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n use crate::hir::map::Map;\n-use crate::hir::ptr::P;\n use crate::hir::{GenericArg, GenericParam, ItemLocalId, LifetimeName, Node, ParamName, QPath};\n use crate::ty::{self, DefIdTree, GenericParamDefKind, TyCtxt};\n \n@@ -44,7 +43,7 @@ pub enum LifetimeDefOrigin {\n }\n \n impl LifetimeDefOrigin {\n-    fn from_param(param: &GenericParam) -> Self {\n+    fn from_param(param: &GenericParam<'_>) -> Self {\n         match param.kind {\n             GenericParamKind::Lifetime { kind } => match kind {\n                 LifetimeParamKind::InBand => LifetimeDefOrigin::InBand,\n@@ -74,7 +73,7 @@ pub enum Region {\n }\n \n impl Region {\n-    fn early(hir_map: &Map<'_>, index: &mut u32, param: &GenericParam) -> (ParamName, Region) {\n+    fn early(hir_map: &Map<'_>, index: &mut u32, param: &GenericParam<'_>) -> (ParamName, Region) {\n         let i = *index;\n         *index += 1;\n         let def_id = hir_map.local_def_id(param.hir_id);\n@@ -83,7 +82,7 @@ impl Region {\n         (param.name.modern(), Region::EarlyBound(i, def_id, origin))\n     }\n \n-    fn late(hir_map: &Map<'_>, param: &GenericParam) -> (ParamName, Region) {\n+    fn late(hir_map: &Map<'_>, param: &GenericParam<'_>) -> (ParamName, Region) {\n         let depth = ty::INNERMOST;\n         let def_id = hir_map.local_def_id(param.hir_id);\n         let origin = LifetimeDefOrigin::from_param(param);\n@@ -517,7 +516,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n+    fn visit_ty(&mut self, ty: &'tcx hir::Ty<'tcx>) {\n         debug!(\"visit_ty: id={:?} ty={:?}\", ty.hir_id, ty);\n         debug!(\"visit_ty: ty.kind={:?}\", ty.kind);\n         match ty.kind {\n@@ -549,7 +548,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 });\n                 self.is_in_fn_syntax = was_in_fn_syntax;\n             }\n-            hir::TyKind::TraitObject(ref bounds, ref lifetime) => {\n+            hir::TyKind::TraitObject(bounds, ref lifetime) => {\n                 debug!(\"visit_ty: TraitObject(bounds={:?}, lifetime={:?})\", bounds, lifetime);\n                 for bound in bounds {\n                     self.visit_poly_trait_ref(bound, hir::TraitBoundModifier::None);\n@@ -590,7 +589,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 };\n                 self.with(scope, |_, this| this.visit_ty(&mt.ty));\n             }\n-            hir::TyKind::Def(item_id, ref lifetimes) => {\n+            hir::TyKind::Def(item_id, lifetimes) => {\n                 // Resolve the lifetimes in the bounds to the lifetime defs in the generics.\n                 // `fn foo<'a>() -> impl MyTrait<'a> { ... }` desugars to\n                 // `type MyAnonTy<'b> = impl MyTrait<'b>;`\n@@ -604,7 +603,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         return;\n                     }\n                     // RPIT (return position impl trait)\n-                    hir::ItemKind::OpaqueTy(hir::OpaqueTy { ref generics, ref bounds, .. }) => {\n+                    hir::ItemKind::OpaqueTy(hir::OpaqueTy { ref generics, bounds, .. }) => {\n                         (generics, bounds)\n                     }\n                     ref i => bug!(\"`impl Trait` pointed to non-opaque type?? {:#?}\", i),\n@@ -738,7 +737,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     |this| intravisit::walk_trait_item(this, trait_item),\n                 );\n             }\n-            Type(ref bounds, ref ty) => {\n+            Type(bounds, ref ty) => {\n                 let generics = &trait_item.generics;\n                 let mut index = self.next_early_index();\n                 debug!(\"visit_ty: index = {}\", index);\n@@ -823,7 +822,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     this.visit_ty(ty);\n                 });\n             }\n-            OpaqueTy(ref bounds) => {\n+            OpaqueTy(bounds) => {\n                 let generics = &impl_item.generics;\n                 let mut index = self.next_early_index();\n                 let mut next_early_index = index;\n@@ -881,7 +880,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         self.resolve_lifetime_ref(lifetime_ref);\n     }\n \n-    fn visit_path(&mut self, path: &'tcx hir::Path, _: hir::HirId) {\n+    fn visit_path(&mut self, path: &'tcx hir::Path<'tcx>, _: hir::HirId) {\n         for (i, segment) in path.segments.iter().enumerate() {\n             let depth = path.segments.len() - i - 1;\n             if let Some(ref args) = segment.args {\n@@ -890,36 +889,36 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_fn_decl(&mut self, fd: &'tcx hir::FnDecl) {\n+    fn visit_fn_decl(&mut self, fd: &'tcx hir::FnDecl<'tcx>) {\n         let output = match fd.output {\n             hir::DefaultReturn(_) => None,\n             hir::Return(ref ty) => Some(&**ty),\n         };\n         self.visit_fn_like_elision(&fd.inputs, output);\n     }\n \n-    fn visit_generics(&mut self, generics: &'tcx hir::Generics) {\n+    fn visit_generics(&mut self, generics: &'tcx hir::Generics<'tcx>) {\n         check_mixed_explicit_and_in_band_defs(self.tcx, &generics.params);\n         for param in &generics.params {\n             match param.kind {\n                 GenericParamKind::Lifetime { .. } => {}\n                 GenericParamKind::Type { ref default, .. } => {\n-                    walk_list!(self, visit_param_bound, &param.bounds);\n+                    walk_list!(self, visit_param_bound, param.bounds);\n                     if let Some(ref ty) = default {\n                         self.visit_ty(&ty);\n                     }\n                 }\n                 GenericParamKind::Const { ref ty, .. } => {\n-                    walk_list!(self, visit_param_bound, &param.bounds);\n+                    walk_list!(self, visit_param_bound, param.bounds);\n                     self.visit_ty(&ty);\n                 }\n             }\n         }\n-        for predicate in &generics.where_clause.predicates {\n+        for predicate in generics.where_clause.predicates {\n             match predicate {\n                 &hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate {\n                     ref bounded_ty,\n-                    ref bounds,\n+                    bounds,\n                     ref bound_generic_params,\n                     ..\n                 }) => {\n@@ -956,7 +955,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 }\n                 &hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate {\n                     ref lifetime,\n-                    ref bounds,\n+                    bounds,\n                     ..\n                 }) => {\n                     self.visit_lifetime(lifetime);\n@@ -976,7 +975,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n \n     fn visit_poly_trait_ref(\n         &mut self,\n-        trait_ref: &'tcx hir::PolyTraitRef,\n+        trait_ref: &'tcx hir::PolyTraitRef<'tcx>,\n         _modifier: hir::TraitBoundModifier,\n     ) {\n         debug!(\"visit_poly_trait_ref(trait_ref={:?})\", trait_ref);\n@@ -1014,7 +1013,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             };\n             self.with(scope, |old_scope, this| {\n                 this.check_lifetime_params(old_scope, &trait_ref.bound_generic_params);\n-                walk_list!(this, visit_generic_param, &trait_ref.bound_generic_params);\n+                walk_list!(this, visit_generic_param, trait_ref.bound_generic_params);\n                 this.visit_trait_ref(&trait_ref.trait_ref)\n             })\n         } else {\n@@ -1046,7 +1045,7 @@ fn shadower_label(span: Span) -> Shadower {\n fn original_lifetime(span: Span) -> Original {\n     Original { kind: ShadowKind::Lifetime, span: span }\n }\n-fn shadower_lifetime(param: &hir::GenericParam) -> Shadower {\n+fn shadower_lifetime(param: &hir::GenericParam<'_>) -> Shadower {\n     Shadower { kind: ShadowKind::Lifetime, span: param.span }\n }\n \n@@ -1059,7 +1058,7 @@ impl ShadowKind {\n     }\n }\n \n-fn check_mixed_explicit_and_in_band_defs(tcx: TyCtxt<'_>, params: &P<[hir::GenericParam]>) {\n+fn check_mixed_explicit_and_in_band_defs(tcx: TyCtxt<'_>, params: &[hir::GenericParam<'_>]) {\n     let lifetime_params: Vec<_> = params\n         .iter()\n         .filter_map(|param| match param.kind {\n@@ -1252,9 +1251,9 @@ fn compute_object_lifetime_defaults(tcx: TyCtxt<'_>) -> HirIdMap<Vec<ObjectLifet\n /// for each type parameter.\n fn object_lifetime_defaults_for_item(\n     tcx: TyCtxt<'_>,\n-    generics: &hir::Generics,\n+    generics: &hir::Generics<'_>,\n ) -> Vec<ObjectLifetimeDefault> {\n-    fn add_bounds(set: &mut Set1<hir::LifetimeName>, bounds: &[hir::GenericBound]) {\n+    fn add_bounds(set: &mut Set1<hir::LifetimeName>, bounds: &[hir::GenericBound<'_>]) {\n         for bound in bounds {\n             if let hir::GenericBound::Outlives(ref lifetime) = *bound {\n                 set.insert(lifetime.name.modern());\n@@ -1273,7 +1272,7 @@ fn object_lifetime_defaults_for_item(\n                 add_bounds(&mut set, &param.bounds);\n \n                 let param_def_id = tcx.hir().local_def_id(param.hir_id);\n-                for predicate in &generics.where_clause.predicates {\n+                for predicate in generics.where_clause.predicates {\n                     // Look for `type: ...` where clauses.\n                     let data = match *predicate {\n                         hir::WherePredicate::BoundPredicate(ref data) => data,\n@@ -1368,7 +1367,11 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n     /// helper method to determine the span to remove when suggesting the\n     /// deletion of a lifetime\n-    fn lifetime_deletion_span(&self, name: ast::Ident, generics: &hir::Generics) -> Option<Span> {\n+    fn lifetime_deletion_span(\n+        &self,\n+        name: ast::Ident,\n+        generics: &hir::Generics<'_>,\n+    ) -> Option<Span> {\n         generics.params.iter().enumerate().find_map(|(i, param)| {\n             if param.name.ident() == name {\n                 let mut in_band = false;\n@@ -1417,7 +1420,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n         let mut remove_use = None;\n         let mut elide_use = None;\n-        let mut find_arg_use_span = |inputs: &hir::HirVec<hir::Ty>| {\n+        let mut find_arg_use_span = |inputs: &[hir::Ty<'_>]| {\n             for input in inputs {\n                 match input.kind {\n                     hir::TyKind::Rptr(lt, _) => {\n@@ -1459,12 +1462,12 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 match parent {\n                     Node::Item(item) => {\n                         if let hir::ItemKind::Fn(sig, _, _) = &item.kind {\n-                            find_arg_use_span(&sig.decl.inputs);\n+                            find_arg_use_span(sig.decl.inputs);\n                         }\n                     }\n                     Node::ImplItem(impl_item) => {\n                         if let hir::ImplItemKind::Method(sig, _) = &impl_item.kind {\n-                            find_arg_use_span(&sig.decl.inputs);\n+                            find_arg_use_span(sig.decl.inputs);\n                         }\n                     }\n                     _ => {}\n@@ -1656,8 +1659,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     fn visit_early_late<F>(\n         &mut self,\n         parent_id: Option<hir::HirId>,\n-        decl: &'tcx hir::FnDecl,\n-        generics: &'tcx hir::Generics,\n+        decl: &'tcx hir::FnDecl<'tcx>,\n+        generics: &'tcx hir::Generics<'tcx>,\n         walk: F,\n     ) where\n         F: for<'b, 'c> FnOnce(&'b mut LifetimeContext<'c, 'tcx>),\n@@ -1854,7 +1857,12 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_segment_args(&mut self, res: Res, depth: usize, generic_args: &'tcx hir::GenericArgs) {\n+    fn visit_segment_args(\n+        &mut self,\n+        res: Res,\n+        depth: usize,\n+        generic_args: &'tcx hir::GenericArgs<'tcx>,\n+    ) {\n         debug!(\n             \"visit_segment_args(res={:?}, depth={:?}, generic_args={:?})\",\n             res, depth, generic_args,\n@@ -2036,7 +2044,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         });\n \n         // Resolve lifetimes found in the type `XX` from `Item = XX` bindings.\n-        for b in &generic_args.bindings {\n+        for b in generic_args.bindings {\n             let scope = Scope::ObjectLifetimeDefault {\n                 lifetime: if has_lifetime_parameter { None } else { Some(Region::Static) },\n                 s: self.scope,\n@@ -2045,7 +2053,11 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_fn_like_elision(&mut self, inputs: &'tcx [hir::Ty], output: Option<&'tcx hir::Ty>) {\n+    fn visit_fn_like_elision(\n+        &mut self,\n+        inputs: &'tcx [hir::Ty<'tcx>],\n+        output: Option<&'tcx hir::Ty<'tcx>>,\n+    ) {\n         debug!(\"visit_fn_like_elision: enter\");\n         let mut arg_elide = Elide::FreshLateAnon(Cell::new(0));\n         let arg_scope = Scope::Elision { elide: arg_elide.clone(), s: self.scope };\n@@ -2125,7 +2137,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         if has_self {\n             struct SelfVisitor<'a> {\n                 map: &'a NamedRegionMap,\n-                impl_self: Option<&'a hir::TyKind>,\n+                impl_self: Option<&'a hir::TyKind<'a>>,\n                 lifetime: Set1<Region>,\n             }\n \n@@ -2163,7 +2175,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     NestedVisitorMap::None\n                 }\n \n-                fn visit_ty(&mut self, ty: &'a hir::Ty) {\n+                fn visit_ty(&mut self, ty: &'a hir::Ty<'a>) {\n                     if let hir::TyKind::Rptr(lifetime_ref, ref mt) = ty.kind {\n                         if let hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) = mt.ty.kind\n                         {\n@@ -2251,12 +2263,12 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 NestedVisitorMap::None\n             }\n \n-            fn visit_ty(&mut self, ty: &hir::Ty) {\n+            fn visit_ty(&mut self, ty: &hir::Ty<'_>) {\n                 if let hir::TyKind::BareFn(_) = ty.kind {\n                     self.outer_index.shift_in(1);\n                 }\n                 match ty.kind {\n-                    hir::TyKind::TraitObject(ref bounds, ref lifetime) => {\n+                    hir::TyKind::TraitObject(bounds, ref lifetime) => {\n                         for bound in bounds {\n                             self.visit_poly_trait_ref(bound, hir::TraitBoundModifier::None);\n                         }\n@@ -2276,7 +2288,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 }\n             }\n \n-            fn visit_generic_param(&mut self, param: &hir::GenericParam) {\n+            fn visit_generic_param(&mut self, param: &hir::GenericParam<'_>) {\n                 if let hir::GenericParamKind::Lifetime { .. } = param.kind {\n                     // FIXME(eddyb) Do we want this? It only makes a difference\n                     // if this `for<'a>` lifetime parameter is never used.\n@@ -2288,7 +2300,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n             fn visit_poly_trait_ref(\n                 &mut self,\n-                trait_ref: &hir::PolyTraitRef,\n+                trait_ref: &hir::PolyTraitRef<'_>,\n                 modifier: hir::TraitBoundModifier,\n             ) {\n                 self.outer_index.shift_in(1);\n@@ -2523,7 +2535,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     fn check_lifetime_params(\n         &mut self,\n         old_scope: ScopeRef<'_>,\n-        params: &'tcx [hir::GenericParam],\n+        params: &'tcx [hir::GenericParam<'tcx>],\n     ) {\n         let lifetimes: Vec<_> = params\n             .iter()\n@@ -2570,9 +2582,9 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             // It is a soft error to shadow a lifetime within a parent scope.\n             self.check_lifetime_param_for_shadowing(old_scope, &lifetime_i);\n \n-            for bound in &lifetime_i.bounds {\n+            for bound in lifetime_i.bounds {\n                 match bound {\n-                    hir::GenericBound::Outlives(lt) => match lt.name {\n+                    hir::GenericBound::Outlives(ref lt) => match lt.name {\n                         hir::LifetimeName::Underscore => self.tcx.sess.delay_span_bug(\n                             lt.span,\n                             \"use of `'_` in illegal place, but not caught by lowering\",\n@@ -2617,7 +2629,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     fn check_lifetime_param_for_shadowing(\n         &self,\n         mut old_scope: ScopeRef<'_>,\n-        param: &'tcx hir::GenericParam,\n+        param: &'tcx hir::GenericParam<'tcx>,\n     ) {\n         for label in &self.labels_in_fn {\n             // FIXME (#24278): non-hygienic comparison\n@@ -2755,13 +2767,13 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n /// T as Trait<''b>>::Foo` does not constrain `'a` or `'b`.\n fn insert_late_bound_lifetimes(\n     map: &mut NamedRegionMap,\n-    decl: &hir::FnDecl,\n-    generics: &hir::Generics,\n+    decl: &hir::FnDecl<'_>,\n+    generics: &hir::Generics<'_>,\n ) {\n     debug!(\"insert_late_bound_lifetimes(decl={:?}, generics={:?})\", decl, generics);\n \n     let mut constrained_by_input = ConstrainedCollector::default();\n-    for arg_ty in &decl.inputs {\n+    for arg_ty in decl.inputs {\n         constrained_by_input.visit_ty(arg_ty);\n     }\n \n@@ -2840,7 +2852,7 @@ fn insert_late_bound_lifetimes(\n             NestedVisitorMap::None\n         }\n \n-        fn visit_ty(&mut self, ty: &'v hir::Ty) {\n+        fn visit_ty(&mut self, ty: &'v hir::Ty<'v>) {\n             match ty.kind {\n                 hir::TyKind::Path(hir::QPath::Resolved(Some(_), _))\n                 | hir::TyKind::Path(hir::QPath::TypeRelative(..)) => {"}, {"sha": "b692459eb517f2dd707fc5ceebb73b8e6f74c68f", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=2ba0d2acbd6cb01fb07619628882120d5b66bd59", "patch": "@@ -306,7 +306,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n         });\n     }\n \n-    fn visit_variant(&mut self, var: &'tcx Variant<'tcx>, g: &'tcx Generics, item_id: HirId) {\n+    fn visit_variant(&mut self, var: &'tcx Variant<'tcx>, g: &'tcx Generics<'tcx>, item_id: HirId) {\n         self.annotate(var.id, &var.attrs, var.span, AnnotationKind::Required, |v| {\n             if let Some(ctor_hir_id) = var.data.ctor_hir_id() {\n                 v.annotate(ctor_hir_id, &var.attrs, var.span, AnnotationKind::Required, |_| {});\n@@ -381,7 +381,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MissingStabilityAnnotations<'a, 'tcx> {\n         intravisit::walk_impl_item(self, ii);\n     }\n \n-    fn visit_variant(&mut self, var: &'tcx Variant<'tcx>, g: &'tcx Generics, item_id: HirId) {\n+    fn visit_variant(&mut self, var: &'tcx Variant<'tcx>, g: &'tcx Generics<'tcx>, item_id: HirId) {\n         self.check_missing_stability(var.id, var.span, \"variant\");\n         intravisit::walk_variant(self, var, g, item_id);\n     }\n@@ -886,7 +886,7 @@ impl Visitor<'tcx> for Checker<'tcx> {\n         intravisit::walk_item(self, item);\n     }\n \n-    fn visit_path(&mut self, path: &'tcx hir::Path, id: hir::HirId) {\n+    fn visit_path(&mut self, path: &'tcx hir::Path<'tcx>, id: hir::HirId) {\n         if let Some(def_id) = path.res.opt_def_id() {\n             self.tcx.check_stability(def_id, Some(id), path.span)\n         }"}, {"sha": "878675f981259069f6694dfcc91dc87475310e28", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=2ba0d2acbd6cb01fb07619628882120d5b66bd59", "patch": "@@ -1154,7 +1154,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         };\n \n         let suggest_restriction =\n-            |generics: &hir::Generics, msg, err: &mut DiagnosticBuilder<'_>| {\n+            |generics: &hir::Generics<'_>, msg, err: &mut DiagnosticBuilder<'_>| {\n                 let span = generics.where_clause.span_for_predicates_or_empty_place();\n                 if !span.from_expansion() && span.desugaring_kind().is_none() {\n                     err.span_suggestion(\n@@ -2851,7 +2851,7 @@ impl ArgKind {\n \n /// Suggest restricting a type param with a new bound.\n pub fn suggest_constraining_type_param(\n-    generics: &hir::Generics,\n+    generics: &hir::Generics<'_>,\n     err: &mut DiagnosticBuilder<'_>,\n     param_name: &str,\n     constraint: &str,"}, {"sha": "95860397036f49061f03cbbf7fb6d058ef6a0ac5", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=2ba0d2acbd6cb01fb07619628882120d5b66bd59", "patch": "@@ -464,7 +464,7 @@ impl<'tcx> TypeckTables<'tcx> {\n     }\n \n     /// Returns the final resolution of a `QPath` in an `Expr` or `Pat` node.\n-    pub fn qpath_res(&self, qpath: &hir::QPath, id: hir::HirId) -> Res {\n+    pub fn qpath_res(&self, qpath: &hir::QPath<'_>, id: hir::HirId) -> Res {\n         match *qpath {\n             hir::QPath::Resolved(_, ref path) => path.res,\n             hir::QPath::TypeRelative(..) => self"}, {"sha": "2c40c9dc9efbbb7a51df7e4d5b6f605f6a1a78fb", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=2ba0d2acbd6cb01fb07619628882120d5b66bd59", "patch": "@@ -298,7 +298,7 @@ impl<'tcx> DefIdTree for TyCtxt<'tcx> {\n }\n \n impl Visibility {\n-    pub fn from_hir(visibility: &hir::Visibility, id: hir::HirId, tcx: TyCtxt<'_>) -> Self {\n+    pub fn from_hir(visibility: &hir::Visibility<'_>, id: hir::HirId, tcx: TyCtxt<'_>) -> Self {\n         match visibility.node {\n             hir::VisibilityKind::Public => Visibility::Public,\n             hir::VisibilityKind::Crate(_) => Visibility::Restricted(DefId::local(CRATE_DEF_INDEX)),\n@@ -2757,7 +2757,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     fn associated_item_from_trait_item_ref(\n         self,\n         parent_def_id: DefId,\n-        parent_vis: &hir::Visibility,\n+        parent_vis: &hir::Visibility<'_>,\n         trait_item_ref: &hir::TraitItemRef,\n     ) -> AssocItem {\n         let def_id = self.hir().local_def_id(trait_item_ref.id.hir_id);\n@@ -2783,7 +2783,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     fn associated_item_from_impl_item_ref(\n         self,\n         parent_def_id: DefId,\n-        impl_item_ref: &hir::ImplItemRef,\n+        impl_item_ref: &hir::ImplItemRef<'_>,\n     ) -> AssocItem {\n         let def_id = self.hir().local_def_id(impl_item_ref.id.hir_id);\n         let (kind, has_self) = match impl_item_ref.kind {"}, {"sha": "afd1b690232e78ebd6e2261ae969fdd8544bbaaa", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=2ba0d2acbd6cb01fb07619628882120d5b66bd59", "patch": "@@ -694,7 +694,7 @@ pub fn object_region_bounds<'tcx>(\n \n /// Find the span of a generic bound affecting an associated type.\n fn get_generic_bound_spans(\n-    generics: &hir::Generics,\n+    generics: &hir::Generics<'_>,\n     trait_name: Option<&Ident>,\n     assoc_item_name: Ident,\n ) -> Vec<Span> {\n@@ -729,7 +729,7 @@ fn get_generic_bound_spans(\n     bounds\n }\n \n-fn is_self_path(kind: &hir::TyKind) -> bool {\n+fn is_self_path(kind: &hir::TyKind<'_>) -> bool {\n     match kind {\n         hir::TyKind::Path(hir::QPath::Resolved(None, path)) => {\n             let mut s = path.segments.iter();"}, {"sha": "0f7bdaaf582e1cfedbe65a9bec63a966e4c10305", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=2ba0d2acbd6cb01fb07619628882120d5b66bd59", "patch": "@@ -987,7 +987,7 @@ impl UnreachablePub {\n         cx: &LateContext<'_, '_>,\n         what: &str,\n         id: hir::HirId,\n-        vis: &hir::Visibility,\n+        vis: &hir::Visibility<'_>,\n         span: Span,\n         exportable: bool,\n     ) {\n@@ -1069,7 +1069,7 @@ declare_lint_pass!(\n );\n \n impl TypeAliasBounds {\n-    fn is_type_variable_assoc(qpath: &hir::QPath) -> bool {\n+    fn is_type_variable_assoc(qpath: &hir::QPath<'_>) -> bool {\n         match *qpath {\n             hir::QPath::TypeRelative(ref ty, _) => {\n                 // If this is a type variable, we found a `T::Assoc`.\n@@ -1085,7 +1085,7 @@ impl TypeAliasBounds {\n         }\n     }\n \n-    fn suggest_changing_assoc_types(ty: &hir::Ty, err: &mut DiagnosticBuilder<'_>) {\n+    fn suggest_changing_assoc_types(ty: &hir::Ty<'_>, err: &mut DiagnosticBuilder<'_>) {\n         // Access to associates types should use `<T as Bound>::Assoc`, which does not need a\n         // bound.  Let's see if this type does that.\n \n@@ -1099,7 +1099,7 @@ impl TypeAliasBounds {\n                 intravisit::NestedVisitorMap::None\n             }\n \n-            fn visit_qpath(&mut self, qpath: &'v hir::QPath, id: hir::HirId, span: Span) {\n+            fn visit_qpath(&mut self, qpath: &'v hir::QPath<'v>, id: hir::HirId, span: Span) {\n                 if TypeAliasBounds::is_type_variable_assoc(qpath) {\n                     self.err.span_help(\n                         span,\n@@ -1537,7 +1537,7 @@ impl ExplicitOutlivesRequirements {\n \n     fn collect_outlived_lifetimes<'tcx>(\n         &self,\n-        param: &'tcx hir::GenericParam,\n+        param: &'tcx hir::GenericParam<'tcx>,\n         tcx: TyCtxt<'tcx>,\n         inferred_outlives: &'tcx [(ty::Predicate<'tcx>, Span)],\n         ty_generics: &'tcx ty::Generics,\n@@ -1558,7 +1558,7 @@ impl ExplicitOutlivesRequirements {\n     fn collect_outlives_bound_spans<'tcx>(\n         &self,\n         tcx: TyCtxt<'tcx>,\n-        bounds: &hir::GenericBounds,\n+        bounds: &hir::GenericBounds<'_>,\n         inferred_outlives: &[ty::Region<'tcx>],\n         infer_static: bool,\n     ) -> Vec<(usize, Span)> {\n@@ -1589,7 +1589,7 @@ impl ExplicitOutlivesRequirements {\n     fn consolidate_outlives_bound_spans(\n         &self,\n         lo: Span,\n-        bounds: &hir::GenericBounds,\n+        bounds: &hir::GenericBounds<'_>,\n         bound_spans: Vec<(usize, Span)>,\n     ) -> Vec<Span> {\n         if bounds.is_empty() {"}, {"sha": "12e6730e8919e90f481a5be7a740987a73105c46", "filename": "src/librustc_lint/nonstandard_style.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc_lint%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc_lint%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fnonstandard_style.rs?ref=2ba0d2acbd6cb01fb07619628882120d5b66bd59", "patch": "@@ -293,7 +293,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n         }\n     }\n \n-    fn check_generic_param(&mut self, cx: &LateContext<'_, '_>, param: &hir::GenericParam) {\n+    fn check_generic_param(&mut self, cx: &LateContext<'_, '_>, param: &hir::GenericParam<'_>) {\n         if let GenericParamKind::Lifetime { .. } = param.kind {\n             self.check_snake_case(cx, \"lifetime\", &param.name.ident());\n         }\n@@ -303,7 +303,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n         &mut self,\n         cx: &LateContext<'_, '_>,\n         fk: FnKind<'_>,\n-        _: &hir::FnDecl,\n+        _: &hir::FnDecl<'_>,\n         _: &hir::Body<'_>,\n         _: Span,\n         id: hir::HirId,\n@@ -336,7 +336,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'_, '_>, item: &hir::TraitItem<'_>) {\n-        if let hir::TraitItemKind::Method(_, hir::TraitMethod::Required(pnames)) = &item.kind {\n+        if let hir::TraitItemKind::Method(_, hir::TraitMethod::Required(pnames)) = item.kind {\n             self.check_snake_case(cx, \"trait method\", &item.ident);\n             for param_name in pnames {\n                 self.check_snake_case(cx, \"variable\", param_name);\n@@ -425,7 +425,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonUpperCaseGlobals {\n         }\n     }\n \n-    fn check_generic_param(&mut self, cx: &LateContext<'_, '_>, param: &hir::GenericParam) {\n+    fn check_generic_param(&mut self, cx: &LateContext<'_, '_>, param: &hir::GenericParam<'_>) {\n         if let GenericParamKind::Const { .. } = param.kind {\n             NonUpperCaseGlobals::check_upper_case(cx, \"const parameter\", &param.name.ident());\n         }"}, {"sha": "65018194af2d31e2a2b79774248fdb1e1536df66", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=2ba0d2acbd6cb01fb07619628882120d5b66bd59", "patch": "@@ -963,12 +963,12 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn check_foreign_fn(&mut self, id: hir::HirId, decl: &hir::FnDecl) {\n+    fn check_foreign_fn(&mut self, id: hir::HirId, decl: &hir::FnDecl<'_>) {\n         let def_id = self.cx.tcx.hir().local_def_id(id);\n         let sig = self.cx.tcx.fn_sig(def_id);\n         let sig = self.cx.tcx.erase_late_bound_regions(&sig);\n \n-        for (input_ty, input_hir) in sig.inputs().iter().zip(&decl.inputs) {\n+        for (input_ty, input_hir) in sig.inputs().iter().zip(decl.inputs) {\n             self.check_type_for_ffi_and_report_errors(input_hir.span, input_ty, false);\n         }\n "}, {"sha": "0fe53011d4f461daa28a0ee7ddc17d97991ed136", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=2ba0d2acbd6cb01fb07619628882120d5b66bd59", "patch": "@@ -664,7 +664,7 @@ impl EncodeContext<'tcx> {\n         id: hir::HirId,\n         md: &hir::Mod<'_>,\n         attrs: &[ast::Attribute],\n-        vis: &hir::Visibility,\n+        vis: &hir::Visibility<'_>,\n     ) {\n         let tcx = self.tcx;\n         let def_id = tcx.hir().local_def_id(id);\n@@ -1547,7 +1547,7 @@ impl Visitor<'tcx> for EncodeContext<'tcx> {\n         let def_id = self.tcx.hir().local_def_id(ni.hir_id);\n         self.encode_info_for_foreign_item(def_id, ni);\n     }\n-    fn visit_generics(&mut self, generics: &'tcx hir::Generics) {\n+    fn visit_generics(&mut self, generics: &'tcx hir::Generics<'tcx>) {\n         intravisit::walk_generics(self, generics);\n         self.encode_info_for_generics(generics);\n     }\n@@ -1568,7 +1568,7 @@ impl EncodeContext<'tcx> {\n         }\n     }\n \n-    fn encode_info_for_generics(&mut self, generics: &hir::Generics) {\n+    fn encode_info_for_generics(&mut self, generics: &hir::Generics<'tcx>) {\n         for param in &generics.params {\n             let def_id = self.tcx.hir().local_def_id(param.hir_id);\n             match param.kind {"}, {"sha": "37e2b68692d5e7030f70aa42c79a7a924074b905", "filename": "src/librustc_mir/borrow_check/diagnostics/region_name.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs?ref=2ba0d2acbd6cb01fb07619628882120d5b66bd59", "patch": "@@ -410,7 +410,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ) -> Option<RegionName> {\n         let mir_hir_id = infcx.tcx.hir().as_local_hir_id(mir_def_id)?;\n         let fn_decl = infcx.tcx.hir().fn_decl_by_hir_id(mir_hir_id)?;\n-        let argument_hir_ty: &hir::Ty = fn_decl.inputs.get(argument_index)?;\n+        let argument_hir_ty: &hir::Ty<'_> = fn_decl.inputs.get(argument_index)?;\n         match argument_hir_ty.kind {\n             // This indicates a variable with no type annotation, like\n             // `|x|`... in that case, we can't highlight the type but\n@@ -504,10 +504,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         needle_fr: RegionVid,\n         argument_ty: Ty<'tcx>,\n-        argument_hir_ty: &hir::Ty,\n+        argument_hir_ty: &hir::Ty<'_>,\n         renctx: &mut RegionErrorNamingCtx,\n     ) -> Option<RegionName> {\n-        let search_stack: &mut Vec<(Ty<'tcx>, &hir::Ty)> =\n+        let search_stack: &mut Vec<(Ty<'tcx>, &hir::Ty<'_>)> =\n             &mut vec![(argument_ty, argument_hir_ty)];\n \n         while let Some((ty, hir_ty)) = search_stack.pop() {\n@@ -570,7 +570,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 // just worry about trying to match up the rustc type\n                 // with the HIR types:\n                 (ty::Tuple(elem_tys), hir::TyKind::Tup(elem_hir_tys)) => {\n-                    search_stack.extend(elem_tys.iter().map(|k| k.expect_ty()).zip(elem_hir_tys));\n+                    search_stack.extend(elem_tys.iter().map(|k| k.expect_ty()).zip(*elem_hir_tys));\n                 }\n \n                 (ty::Slice(elem_ty), hir::TyKind::Slice(elem_hir_ty))\n@@ -600,9 +600,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &self,\n         substs: SubstsRef<'tcx>,\n         needle_fr: RegionVid,\n-        last_segment: &'hir hir::PathSegment,\n+        last_segment: &'hir hir::PathSegment<'hir>,\n         renctx: &mut RegionErrorNamingCtx,\n-        search_stack: &mut Vec<(Ty<'tcx>, &'hir hir::Ty)>,\n+        search_stack: &mut Vec<(Ty<'tcx>, &'hir hir::Ty<'hir>)>,\n     ) -> Option<RegionName> {\n         // Did the user give explicit arguments? (e.g., `Foo<..>`)\n         let args = last_segment.args.as_ref()?;\n@@ -647,8 +647,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &self,\n         substs: SubstsRef<'tcx>,\n         needle_fr: RegionVid,\n-        args: &'hir hir::GenericArgs,\n-        search_stack: &mut Vec<(Ty<'tcx>, &'hir hir::Ty)>,\n+        args: &'hir hir::GenericArgs<'hir>,\n+        search_stack: &mut Vec<(Ty<'tcx>, &'hir hir::Ty<'hir>)>,\n     ) -> Option<&'hir hir::Lifetime> {\n         for (kind, hir_arg) in substs.iter().zip(&args.args) {\n             match (kind.unpack(), hir_arg) {"}, {"sha": "8cf49edd0a2760eecd951a8ab62ab5e699b737c3", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=2ba0d2acbd6cb01fb07619628882120d5b66bd59", "patch": "@@ -255,7 +255,7 @@ fn const_not_var(\n     err: &mut DiagnosticBuilder<'_>,\n     tcx: TyCtxt<'_>,\n     pat: &Pat<'_>,\n-    path: &hir::Path,\n+    path: &hir::Path<'_>,\n ) {\n     let descr = path.res.descr();\n     err.span_label("}, {"sha": "c782eda917fe2a03f5c3682d7f6cfa436d472c16", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=2ba0d2acbd6cb01fb07619628882120d5b66bd59", "patch": "@@ -732,7 +732,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n     /// Takes a HIR Path. If the path is a constant, evaluates it and feeds\n     /// it to `const_to_pat`. Any other path (like enum variants without fields)\n     /// is converted to the corresponding pattern via `lower_variant_or_leaf`.\n-    fn lower_path(&mut self, qpath: &hir::QPath, id: hir::HirId, span: Span) -> Pat<'tcx> {\n+    fn lower_path(&mut self, qpath: &hir::QPath<'_>, id: hir::HirId, span: Span) -> Pat<'tcx> {\n         let ty = self.tables.node_type(id);\n         let res = self.tables.qpath_res(qpath, id);\n         let is_associated_const = match res {"}, {"sha": "39647b587f56ed77b2f4c6528f6efe94ad1dfa92", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=2ba0d2acbd6cb01fb07619628882120d5b66bd59", "patch": "@@ -77,7 +77,7 @@ fn mir_keys(tcx: TyCtxt<'_>, krate: CrateNum) -> &DefIdSet {\n             &mut self,\n             v: &'tcx hir::VariantData<'tcx>,\n             _: ast::Name,\n-            _: &'tcx hir::Generics,\n+            _: &'tcx hir::Generics<'tcx>,\n             _: hir::HirId,\n             _: Span,\n         ) {"}, {"sha": "09d6d2a1be2510c904dc8634a0c7fb9762d07af9", "filename": "src/librustc_passes/dead.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc_passes%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc_passes%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdead.rs?ref=2ba0d2acbd6cb01fb07619628882120d5b66bd59", "patch": "@@ -229,7 +229,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n         &mut self,\n         def: &'tcx hir::VariantData<'tcx>,\n         _: ast::Name,\n-        _: &hir::Generics,\n+        _: &hir::Generics<'_>,\n         _: hir::HirId,\n         _: syntax_pos::Span,\n     ) {\n@@ -295,12 +295,12 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n         self.in_pat = false;\n     }\n \n-    fn visit_path(&mut self, path: &'tcx hir::Path, _: hir::HirId) {\n+    fn visit_path(&mut self, path: &'tcx hir::Path<'tcx>, _: hir::HirId) {\n         self.handle_res(path.res);\n         intravisit::walk_path(self, path);\n     }\n \n-    fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n+    fn visit_ty(&mut self, ty: &'tcx hir::Ty<'tcx>) {\n         match ty.kind {\n             TyKind::Def(item_id, _) => {\n                 let item = self.tcx.hir().expect_item(item_id.id);\n@@ -619,7 +619,7 @@ impl Visitor<'tcx> for DeadVisitor<'tcx> {\n     fn visit_variant(\n         &mut self,\n         variant: &'tcx hir::Variant<'tcx>,\n-        g: &'tcx hir::Generics,\n+        g: &'tcx hir::Generics<'tcx>,\n         id: hir::HirId,\n     ) {\n         if self.should_warn_about_variant(&variant) {"}, {"sha": "49ec8d01d952df899417c4e0d5a3b6f28152885e", "filename": "src/librustc_passes/hir_stats.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc_passes%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc_passes%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fhir_stats.rs?ref=2ba0d2acbd6cb01fb07619628882120d5b66bd59", "patch": "@@ -160,15 +160,15 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n         hir_visit::walk_expr(self, ex)\n     }\n \n-    fn visit_ty(&mut self, t: &'v hir::Ty) {\n+    fn visit_ty(&mut self, t: &'v hir::Ty<'v>) {\n         self.record(\"Ty\", Id::Node(t.hir_id), t);\n         hir_visit::walk_ty(self, t)\n     }\n \n     fn visit_fn(\n         &mut self,\n         fk: hir_visit::FnKind<'v>,\n-        fd: &'v hir::FnDecl,\n+        fd: &'v hir::FnDecl<'v>,\n         b: hir::BodyId,\n         s: Span,\n         id: hir::HirId,\n@@ -177,7 +177,7 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n         hir_visit::walk_fn(self, fk, fd, b, s, id)\n     }\n \n-    fn visit_where_predicate(&mut self, predicate: &'v hir::WherePredicate) {\n+    fn visit_where_predicate(&mut self, predicate: &'v hir::WherePredicate<'v>) {\n         self.record(\"WherePredicate\", Id::None, predicate);\n         hir_visit::walk_where_predicate(self, predicate)\n     }\n@@ -192,7 +192,7 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n         hir_visit::walk_impl_item(self, ii)\n     }\n \n-    fn visit_param_bound(&mut self, bounds: &'v hir::GenericBound) {\n+    fn visit_param_bound(&mut self, bounds: &'v hir::GenericBound<'v>) {\n         self.record(\"GenericBound\", Id::None, bounds);\n         hir_visit::walk_param_bound(self, bounds)\n     }\n@@ -205,7 +205,7 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n     fn visit_variant(\n         &mut self,\n         v: &'v hir::Variant<'v>,\n-        g: &'v hir::Generics,\n+        g: &'v hir::Generics<'v>,\n         item_id: hir::HirId,\n     ) {\n         self.record(\"Variant\", Id::None, v);\n@@ -217,22 +217,22 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n         hir_visit::walk_lifetime(self, lifetime)\n     }\n \n-    fn visit_qpath(&mut self, qpath: &'v hir::QPath, id: hir::HirId, span: Span) {\n+    fn visit_qpath(&mut self, qpath: &'v hir::QPath<'v>, id: hir::HirId, span: Span) {\n         self.record(\"QPath\", Id::None, qpath);\n         hir_visit::walk_qpath(self, qpath, id, span)\n     }\n \n-    fn visit_path(&mut self, path: &'v hir::Path, _id: hir::HirId) {\n+    fn visit_path(&mut self, path: &'v hir::Path<'v>, _id: hir::HirId) {\n         self.record(\"Path\", Id::None, path);\n         hir_visit::walk_path(self, path)\n     }\n \n-    fn visit_path_segment(&mut self, path_span: Span, path_segment: &'v hir::PathSegment) {\n+    fn visit_path_segment(&mut self, path_span: Span, path_segment: &'v hir::PathSegment<'v>) {\n         self.record(\"PathSegment\", Id::None, path_segment);\n         hir_visit::walk_path_segment(self, path_span, path_segment)\n     }\n \n-    fn visit_assoc_type_binding(&mut self, type_binding: &'v hir::TypeBinding) {\n+    fn visit_assoc_type_binding(&mut self, type_binding: &'v hir::TypeBinding<'v>) {\n         self.record(\"TypeBinding\", Id::Node(type_binding.hir_id), type_binding);\n         hir_visit::walk_assoc_type_binding(self, type_binding)\n     }"}, {"sha": "4f7db91dcdaa6605b13528005ad66b4fe5f3df81", "filename": "src/librustc_passes/liveness.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc_passes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc_passes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fliveness.rs?ref=2ba0d2acbd6cb01fb07619628882120d5b66bd59", "patch": "@@ -162,7 +162,7 @@ impl<'tcx> Visitor<'tcx> for IrMaps<'tcx> {\n     fn visit_fn(\n         &mut self,\n         fk: FnKind<'tcx>,\n-        fd: &'tcx hir::FnDecl,\n+        fd: &'tcx hir::FnDecl<'tcx>,\n         b: hir::BodyId,\n         s: Span,\n         id: HirId,\n@@ -351,7 +351,7 @@ impl IrMaps<'tcx> {\n fn visit_fn<'tcx>(\n     ir: &mut IrMaps<'tcx>,\n     fk: FnKind<'tcx>,\n-    decl: &'tcx hir::FnDecl,\n+    decl: &'tcx hir::FnDecl<'tcx>,\n     body_id: hir::BodyId,\n     sp: Span,\n     id: hir::HirId,\n@@ -1285,7 +1285,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn access_path(\n         &mut self,\n         hir_id: HirId,\n-        path: &hir::Path,\n+        path: &hir::Path<'_>,\n         succ: LiveNode,\n         acc: u32,\n     ) -> LiveNode {"}, {"sha": "c00f5752e1be07650dea0bf96e923713d311a90b", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=2ba0d2acbd6cb01fb07619628882120d5b66bd59", "patch": "@@ -378,7 +378,7 @@ impl Visitor<'tcx> for PubRestrictedVisitor<'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n         NestedVisitorMap::All(&self.tcx.hir())\n     }\n-    fn visit_vis(&mut self, vis: &'tcx hir::Visibility) {\n+    fn visit_vis(&mut self, vis: &'tcx hir::Visibility<'tcx>) {\n         self.has_pub_restricted = self.has_pub_restricted || vis.node.is_pub_restricted();\n     }\n }\n@@ -644,7 +644,10 @@ impl EmbargoVisitor<'tcx> {\n     ///\n     /// FIXME: This solution won't work with glob imports and doesn't respect\n     /// namespaces. See <https://github.com/rust-lang/rust/pull/57922#discussion_r251234202>.\n-    fn update_visibility_of_intermediate_use_statements(&mut self, segments: &[hir::PathSegment]) {\n+    fn update_visibility_of_intermediate_use_statements(\n+        &mut self,\n+        segments: &[hir::PathSegment<'_>],\n+    ) {\n         if let Some([module, segment]) = segments.rchunks_exact(2).next() {\n             if let Some(item) = module\n                 .res\n@@ -1199,7 +1202,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n         self.in_body = orig_in_body;\n     }\n \n-    fn visit_ty(&mut self, hir_ty: &'tcx hir::Ty) {\n+    fn visit_ty(&mut self, hir_ty: &'tcx hir::Ty<'tcx>) {\n         self.span = hir_ty.span;\n         if self.in_body {\n             // Types in bodies.\n@@ -1218,7 +1221,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n         intravisit::walk_ty(self, hir_ty);\n     }\n \n-    fn visit_trait_ref(&mut self, trait_ref: &'tcx hir::TraitRef) {\n+    fn visit_trait_ref(&mut self, trait_ref: &'tcx hir::TraitRef<'tcx>) {\n         self.span = trait_ref.path.span;\n         if !self.in_body {\n             // Avoid calling `hir_trait_to_predicates` in bodies, it will ICE.\n@@ -1282,7 +1285,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n     // we prohibit access to private statics from other crates, this allows to give\n     // more code internal visibility at link time. (Access to private functions\n     // is already prohibited by type privacy for function types.)\n-    fn visit_qpath(&mut self, qpath: &'tcx hir::QPath, id: hir::HirId, span: Span) {\n+    fn visit_qpath(&mut self, qpath: &'tcx hir::QPath<'tcx>, id: hir::HirId, span: Span) {\n         let def = match self.tables.qpath_res(qpath, id) {\n             Res::Def(kind, def_id) => Some((kind, def_id)),\n             _ => None,\n@@ -1397,7 +1400,7 @@ struct ObsoleteCheckTypeForPrivatenessVisitor<'a, 'b, 'tcx> {\n }\n \n impl<'a, 'tcx> ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n-    fn path_is_private_type(&self, path: &hir::Path) -> bool {\n+    fn path_is_private_type(&self, path: &hir::Path<'_>) -> bool {\n         let did = match path.res {\n             Res::PrimTy(..) | Res::SelfTy(..) | Res::Err => return false,\n             res => res.def_id(),\n@@ -1423,15 +1426,15 @@ impl<'a, 'tcx> ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n         self.access_levels.is_public(trait_id)\n     }\n \n-    fn check_generic_bound(&mut self, bound: &hir::GenericBound) {\n+    fn check_generic_bound(&mut self, bound: &hir::GenericBound<'_>) {\n         if let hir::GenericBound::Trait(ref trait_ref, _) = *bound {\n             if self.path_is_private_type(&trait_ref.trait_ref.path) {\n                 self.old_error_set.insert(trait_ref.trait_ref.hir_ref_id);\n             }\n         }\n     }\n \n-    fn item_is_public(&self, id: &hir::HirId, vis: &hir::Visibility) -> bool {\n+    fn item_is_public(&self, id: &hir::HirId, vis: &hir::Visibility<'_>) -> bool {\n         self.access_levels.is_reachable(*id) || vis.node.is_pub()\n     }\n }\n@@ -1441,7 +1444,7 @@ impl<'a, 'b, 'tcx, 'v> Visitor<'v> for ObsoleteCheckTypeForPrivatenessVisitor<'a\n         NestedVisitorMap::None\n     }\n \n-    fn visit_ty(&mut self, ty: &hir::Ty) {\n+    fn visit_ty(&mut self, ty: &hir::Ty<'_>) {\n         if let hir::TyKind::Path(hir::QPath::Resolved(_, ref path)) = ty.kind {\n             if self.inner.path_is_private_type(path) {\n                 self.contains_private = true;\n@@ -1649,13 +1652,13 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n         intravisit::walk_item(self, item);\n     }\n \n-    fn visit_generics(&mut self, generics: &'tcx hir::Generics) {\n+    fn visit_generics(&mut self, generics: &'tcx hir::Generics<'tcx>) {\n         for param in &generics.params {\n-            for bound in &param.bounds {\n+            for bound in param.bounds {\n                 self.check_generic_bound(bound);\n             }\n         }\n-        for predicate in &generics.where_clause.predicates {\n+        for predicate in generics.where_clause.predicates {\n             match predicate {\n                 hir::WherePredicate::BoundPredicate(bound_pred) => {\n                     for bound in bound_pred.bounds.iter() {\n@@ -1676,7 +1679,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_ty(&mut self, t: &'tcx hir::Ty) {\n+    fn visit_ty(&mut self, t: &'tcx hir::Ty<'tcx>) {\n         if let hir::TyKind::Path(hir::QPath::Resolved(_, ref path)) = t.kind {\n             if self.path_is_private_type(path) {\n                 self.old_error_set.insert(t.hir_id);\n@@ -1688,7 +1691,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     fn visit_variant(\n         &mut self,\n         v: &'tcx hir::Variant<'tcx>,\n-        g: &'tcx hir::Generics,\n+        g: &'tcx hir::Generics<'tcx>,\n         item_id: hir::HirId,\n     ) {\n         if self.access_levels.is_reachable(v.id) {"}, {"sha": "f3ac159a3aa2aad59507b821ba916218970ec5d3", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 52, "deletions": 42, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=2ba0d2acbd6cb01fb07619628882120d5b66bd59", "patch": "@@ -85,7 +85,7 @@ pub trait AstConv<'tcx> {\n         &self,\n         span: Span,\n         item_def_id: DefId,\n-        item_segment: &hir::PathSegment,\n+        item_segment: &hir::PathSegment<'_>,\n         poly_trait_ref: ty::PolyTraitRef<'tcx>,\n     ) -> Ty<'tcx>;\n \n@@ -114,7 +114,7 @@ struct ConvertedBinding<'a, 'tcx> {\n \n enum ConvertedBindingKind<'a, 'tcx> {\n     Equality(Ty<'tcx>),\n-    Constraint(&'a [hir::GenericBound]),\n+    Constraint(&'a [hir::GenericBound<'a>]),\n }\n \n #[derive(PartialEq)]\n@@ -186,7 +186,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         &self,\n         span: Span,\n         def_id: DefId,\n-        item_segment: &hir::PathSegment,\n+        item_segment: &hir::PathSegment<'_>,\n     ) -> SubstsRef<'tcx> {\n         let (substs, assoc_bindings, _) = self.create_substs_for_ast_path(\n             span,\n@@ -203,7 +203,11 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     }\n \n     /// Report error if there is an explicit type parameter when using `impl Trait`.\n-    fn check_impl_trait(tcx: TyCtxt<'_>, seg: &hir::PathSegment, generics: &ty::Generics) -> bool {\n+    fn check_impl_trait(\n+        tcx: TyCtxt<'_>,\n+        seg: &hir::PathSegment<'_>,\n+        generics: &ty::Generics,\n+    ) -> bool {\n         let explicit = !seg.infer_args;\n         let impl_trait = generics.params.iter().any(|param| match param.kind {\n             ty::GenericParamDefKind::Type {\n@@ -248,14 +252,11 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         tcx: TyCtxt<'_>,\n         span: Span,\n         def: &ty::Generics,\n-        seg: &hir::PathSegment,\n+        seg: &hir::PathSegment<'_>,\n         is_method_call: bool,\n     ) -> bool {\n-        let empty_args = P(hir::GenericArgs {\n-            args: HirVec::new(),\n-            bindings: HirVec::new(),\n-            parenthesized: false,\n-        });\n+        let empty_args =\n+            P(hir::GenericArgs { args: HirVec::new(), bindings: &[], parenthesized: false });\n         let suppress_mismatch = Self::check_impl_trait(tcx, seg, &def);\n         Self::check_generic_arg_count(\n             tcx,\n@@ -275,7 +276,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         tcx: TyCtxt<'_>,\n         span: Span,\n         def: &ty::Generics,\n-        args: &hir::GenericArgs,\n+        args: &hir::GenericArgs<'_>,\n         position: GenericArgPosition,\n         has_self: bool,\n         infer_args: bool,\n@@ -471,8 +472,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         parent_substs: &[subst::GenericArg<'tcx>],\n         has_self: bool,\n         self_ty: Option<Ty<'tcx>>,\n-        args_for_def_id: impl Fn(DefId) -> (Option<&'b GenericArgs>, bool),\n-        provided_kind: impl Fn(&GenericParamDef, &GenericArg) -> subst::GenericArg<'tcx>,\n+        args_for_def_id: impl Fn(DefId) -> (Option<&'b GenericArgs<'b>>, bool),\n+        provided_kind: impl Fn(&GenericParamDef, &GenericArg<'_>) -> subst::GenericArg<'tcx>,\n         mut inferred_kind: impl FnMut(\n             Option<&[subst::GenericArg<'tcx>]>,\n             &GenericParamDef,\n@@ -619,7 +620,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         span: Span,\n         def_id: DefId,\n         parent_substs: &[subst::GenericArg<'tcx>],\n-        generic_args: &'a hir::GenericArgs,\n+        generic_args: &'a hir::GenericArgs<'_>,\n         infer_args: bool,\n         self_ty: Option<Ty<'tcx>>,\n     ) -> (SubstsRef<'tcx>, Vec<ConvertedBinding<'a, 'tcx>>, Option<Vec<Span>>) {\n@@ -794,7 +795,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         tcx: TyCtxt<'tcx>,\n         span: Span,\n         item_def_id: DefId,\n-        item_segment: &hir::PathSegment,\n+        item_segment: &hir::PathSegment<'_>,\n         parent_substs: SubstsRef<'tcx>,\n     ) -> SubstsRef<'tcx> {\n         if tcx.generics_of(item_def_id).params.is_empty() {\n@@ -895,7 +896,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     /// are disallowed. Otherwise, they are pushed onto the vector given.\n     pub fn instantiate_mono_trait_ref(\n         &self,\n-        trait_ref: &hir::TraitRef,\n+        trait_ref: &hir::TraitRef<'_>,\n         self_ty: Ty<'tcx>,\n     ) -> ty::TraitRef<'tcx> {\n         self.prohibit_generics(trait_ref.path.segments.split_last().unwrap().1);\n@@ -911,7 +912,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     /// The given trait-ref must actually be a trait.\n     pub(super) fn instantiate_poly_trait_ref_inner(\n         &self,\n-        trait_ref: &hir::TraitRef,\n+        trait_ref: &hir::TraitRef<'_>,\n         span: Span,\n         self_ty: Ty<'tcx>,\n         bounds: &mut Bounds<'tcx>,\n@@ -986,7 +987,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     /// however.\n     pub fn instantiate_poly_trait_ref(\n         &self,\n-        poly_trait_ref: &hir::PolyTraitRef,\n+        poly_trait_ref: &hir::PolyTraitRef<'_>,\n         self_ty: Ty<'tcx>,\n         bounds: &mut Bounds<'tcx>,\n     ) -> Option<Vec<Span>> {\n@@ -1004,7 +1005,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         span: Span,\n         trait_def_id: DefId,\n         self_ty: Ty<'tcx>,\n-        trait_segment: &hir::PathSegment,\n+        trait_segment: &hir::PathSegment<'_>,\n     ) -> ty::TraitRef<'tcx> {\n         let (substs, assoc_bindings, _) =\n             self.create_substs_for_ast_trait_ref(span, trait_def_id, self_ty, trait_segment);\n@@ -1018,7 +1019,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         &self,\n         span: Span,\n         trait_def_id: DefId,\n-        trait_segment: &'a hir::PathSegment,\n+        trait_segment: &'a hir::PathSegment<'a>,\n     ) {\n         let trait_def = self.tcx().trait_def(trait_def_id);\n \n@@ -1076,7 +1077,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         span: Span,\n         trait_def_id: DefId,\n         self_ty: Ty<'tcx>,\n-        trait_segment: &'a hir::PathSegment,\n+        trait_segment: &'a hir::PathSegment<'a>,\n     ) -> (SubstsRef<'tcx>, Vec<ConvertedBinding<'a, 'tcx>>, Option<Vec<Span>>) {\n         debug!(\"create_substs_for_ast_trait_ref(trait_segment={:?})\", trait_segment);\n \n@@ -1104,7 +1105,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     }\n \n     // Returns `true` if a bounds list includes `?Sized`.\n-    pub fn is_unsized(&self, ast_bounds: &[hir::GenericBound], span: Span) -> bool {\n+    pub fn is_unsized(&self, ast_bounds: &[hir::GenericBound<'_>], span: Span) -> bool {\n         let tcx = self.tcx();\n \n         // Try to find an unbound in bounds.\n@@ -1168,7 +1169,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     fn add_bounds(\n         &self,\n         param_ty: Ty<'tcx>,\n-        ast_bounds: &[hir::GenericBound],\n+        ast_bounds: &[hir::GenericBound<'_>],\n         bounds: &mut Bounds<'tcx>,\n     ) {\n         let mut trait_bounds = Vec::new();\n@@ -1212,7 +1213,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     pub fn compute_bounds(\n         &self,\n         param_ty: Ty<'tcx>,\n-        ast_bounds: &[hir::GenericBound],\n+        ast_bounds: &[hir::GenericBound<'_>],\n         sized_by_default: SizedByDefault,\n         span: Span,\n     ) -> Bounds<'tcx> {\n@@ -1388,15 +1389,20 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         Ok(())\n     }\n \n-    fn ast_path_to_ty(&self, span: Span, did: DefId, item_segment: &hir::PathSegment) -> Ty<'tcx> {\n+    fn ast_path_to_ty(\n+        &self,\n+        span: Span,\n+        did: DefId,\n+        item_segment: &hir::PathSegment<'_>,\n+    ) -> Ty<'tcx> {\n         let substs = self.ast_path_substs_for_ty(span, did, item_segment);\n         self.normalize_ty(span, self.tcx().at(span).type_of(did).subst(self.tcx(), substs))\n     }\n \n     fn conv_object_ty_poly_trait_ref(\n         &self,\n         span: Span,\n-        trait_bounds: &[hir::PolyTraitRef],\n+        trait_bounds: &[hir::PolyTraitRef<'_>],\n         lifetime: &hir::Lifetime,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx();\n@@ -1617,7 +1623,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         &self,\n         associated_types: FxHashMap<Span, BTreeSet<DefId>>,\n         potential_assoc_types: Vec<Span>,\n-        trait_bounds: &[hir::PolyTraitRef],\n+        trait_bounds: &[hir::PolyTraitRef<'_>],\n     ) {\n         if !associated_types.values().any(|v| v.len() > 0) {\n             return;\n@@ -2046,7 +2052,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         span: Span,\n         qself_ty: Ty<'tcx>,\n         qself_res: Res,\n-        assoc_segment: &hir::PathSegment,\n+        assoc_segment: &hir::PathSegment<'_>,\n         permit_variants: bool,\n     ) -> Result<(Ty<'tcx>, DefKind, DefId), ErrorReported> {\n         let tcx = self.tcx();\n@@ -2204,8 +2210,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         span: Span,\n         opt_self_ty: Option<Ty<'tcx>>,\n         item_def_id: DefId,\n-        trait_segment: &hir::PathSegment,\n-        item_segment: &hir::PathSegment,\n+        trait_segment: &hir::PathSegment<'_>,\n+        item_segment: &hir::PathSegment<'_>,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx();\n \n@@ -2265,7 +2271,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         self.normalize_ty(span, tcx.mk_projection(item_def_id, item_substs))\n     }\n \n-    pub fn prohibit_generics<'a, T: IntoIterator<Item = &'a hir::PathSegment>>(\n+    pub fn prohibit_generics<'a, T: IntoIterator<Item = &'a hir::PathSegment<'a>>>(\n         &self,\n         segments: T,\n     ) -> bool {\n@@ -2311,7 +2317,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     break;\n                 }\n             }\n-            for binding in &segment.generic_args().bindings {\n+            for binding in segment.generic_args().bindings {\n                 has_err = true;\n                 Self::prohibit_assoc_ty_binding(self.tcx(), binding.span);\n                 break;\n@@ -2333,7 +2339,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     // FIXME(eddyb, varkor) handle type paths here too, not just value ones.\n     pub fn def_ids_for_value_path_segments(\n         &self,\n-        segments: &[hir::PathSegment],\n+        segments: &[hir::PathSegment<'_>],\n         self_ty: Option<Ty<'tcx>>,\n         kind: DefKind,\n         def_id: DefId,\n@@ -2461,7 +2467,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     pub fn res_to_ty(\n         &self,\n         opt_self_ty: Option<Ty<'tcx>>,\n-        path: &hir::Path,\n+        path: &hir::Path<'_>,\n         permit_variants: bool,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx();\n@@ -2510,7 +2516,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             }\n             Res::Def(DefKind::TyParam, def_id) => {\n                 assert_eq!(opt_self_ty, None);\n-                self.prohibit_generics(&path.segments);\n+                self.prohibit_generics(path.segments);\n \n                 let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n                 let item_id = tcx.hir().get_parent_node(hir_id);\n@@ -2522,13 +2528,13 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             Res::SelfTy(Some(_), None) => {\n                 // `Self` in trait or type alias.\n                 assert_eq!(opt_self_ty, None);\n-                self.prohibit_generics(&path.segments);\n+                self.prohibit_generics(path.segments);\n                 tcx.types.self_param\n             }\n             Res::SelfTy(_, Some(def_id)) => {\n                 // `Self` in impl (we know the concrete type).\n                 assert_eq!(opt_self_ty, None);\n-                self.prohibit_generics(&path.segments);\n+                self.prohibit_generics(path.segments);\n                 // Try to evaluate any array length constants.\n                 self.normalize_ty(span, tcx.at(span).type_of(def_id))\n             }\n@@ -2545,7 +2551,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             }\n             Res::PrimTy(prim_ty) => {\n                 assert_eq!(opt_self_ty, None);\n-                self.prohibit_generics(&path.segments);\n+                self.prohibit_generics(path.segments);\n                 match prim_ty {\n                     hir::Bool => tcx.types.bool,\n                     hir::Char => tcx.types.char,\n@@ -2565,7 +2571,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n     /// Parses the programmer's textual representation of a type into our\n     /// internal notion of a type.\n-    pub fn ast_ty_to_ty(&self, ast_ty: &hir::Ty) -> Ty<'tcx> {\n+    pub fn ast_ty_to_ty(&self, ast_ty: &hir::Ty<'_>) -> Ty<'tcx> {\n         debug!(\"ast_ty_to_ty(id={:?}, ast_ty={:?} ty_ty={:?})\", ast_ty.hir_id, ast_ty, ast_ty.kind);\n \n         let tcx = self.tcx();\n@@ -2698,7 +2704,11 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         tcx.mk_const(const_)\n     }\n \n-    pub fn impl_trait_ty_to_ty(&self, def_id: DefId, lifetimes: &[hir::GenericArg]) -> Ty<'tcx> {\n+    pub fn impl_trait_ty_to_ty(\n+        &self,\n+        def_id: DefId,\n+        lifetimes: &[hir::GenericArg<'_>],\n+    ) -> Ty<'tcx> {\n         debug!(\"impl_trait_ty_to_ty(def_id={:?}, lifetimes={:?})\", def_id, lifetimes);\n         let tcx = self.tcx();\n \n@@ -2733,7 +2743,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         ty\n     }\n \n-    pub fn ty_of_arg(&self, ty: &hir::Ty, expected_ty: Option<Ty<'tcx>>) -> Ty<'tcx> {\n+    pub fn ty_of_arg(&self, ty: &hir::Ty<'_>, expected_ty: Option<Ty<'tcx>>) -> Ty<'tcx> {\n         match ty.kind {\n             hir::TyKind::Infer if expected_ty.is_some() => {\n                 self.record_ty(ty.hir_id, expected_ty.unwrap(), ty.span);\n@@ -2747,7 +2757,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         &self,\n         unsafety: hir::Unsafety,\n         abi: abi::Abi,\n-        decl: &hir::FnDecl,\n+        decl: &hir::FnDecl<'_>,\n     ) -> ty::PolyFnSig<'tcx> {\n         debug!(\"ty_of_fn\");\n "}, {"sha": "a94a6929450e615b41ac80f179105767cdd199bf", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=2ba0d2acbd6cb01fb07619628882120d5b66bd59", "patch": "@@ -37,7 +37,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         expr: &hir::Expr<'_>,\n         _capture: hir::CaptureBy,\n-        decl: &'tcx hir::FnDecl,\n+        decl: &'tcx hir::FnDecl<'tcx>,\n         body_id: hir::BodyId,\n         gen: Option<hir::Movability>,\n         expected: Expectation<'tcx>,\n@@ -59,7 +59,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         expr: &hir::Expr<'_>,\n         opt_kind: Option<ty::ClosureKind>,\n-        decl: &'tcx hir::FnDecl,\n+        decl: &'tcx hir::FnDecl<'tcx>,\n         body: &'tcx hir::Body<'tcx>,\n         gen: Option<hir::Movability>,\n         expected_sig: Option<ExpectedSig<'tcx>>,\n@@ -282,7 +282,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn sig_of_closure(\n         &self,\n         expr_def_id: DefId,\n-        decl: &hir::FnDecl,\n+        decl: &hir::FnDecl<'_>,\n         body: &hir::Body<'_>,\n         expected_sig: Option<ExpectedSig<'tcx>>,\n     ) -> ClosureSignatures<'tcx> {\n@@ -298,7 +298,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn sig_of_closure_no_expectation(\n         &self,\n         expr_def_id: DefId,\n-        decl: &hir::FnDecl,\n+        decl: &hir::FnDecl<'_>,\n         body: &hir::Body<'_>,\n     ) -> ClosureSignatures<'tcx> {\n         debug!(\"sig_of_closure_no_expectation()\");\n@@ -358,7 +358,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn sig_of_closure_with_expectation(\n         &self,\n         expr_def_id: DefId,\n-        decl: &hir::FnDecl,\n+        decl: &hir::FnDecl<'_>,\n         body: &hir::Body<'_>,\n         expected_sig: ExpectedSig<'tcx>,\n     ) -> ClosureSignatures<'tcx> {\n@@ -413,7 +413,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn sig_of_closure_with_mismatched_number_of_arguments(\n         &self,\n         expr_def_id: DefId,\n-        decl: &hir::FnDecl,\n+        decl: &hir::FnDecl<'_>,\n         body: &hir::Body<'_>,\n         expected_sig: ExpectedSig<'tcx>,\n     ) -> ClosureSignatures<'tcx> {\n@@ -446,7 +446,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn check_supplied_sig_against_expectation(\n         &self,\n         expr_def_id: DefId,\n-        decl: &hir::FnDecl,\n+        decl: &hir::FnDecl<'_>,\n         body: &hir::Body<'_>,\n         expected_sigs: &ClosureSignatures<'tcx>,\n     ) -> InferResult<'tcx, ()> {\n@@ -535,7 +535,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn supplied_sig_of_closure(\n         &self,\n         expr_def_id: DefId,\n-        decl: &hir::FnDecl,\n+        decl: &hir::FnDecl<'_>,\n         body: &hir::Body<'_>,\n     ) -> ty::PolyFnSig<'tcx> {\n         let astconv: &dyn AstConv<'_> = self;\n@@ -687,7 +687,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Converts the types that the user supplied, in case that doing\n     /// so should yield an error, but returns back a signature where\n     /// all parameters are of type `TyErr`.\n-    fn error_sig_of_closure(&self, decl: &hir::FnDecl) -> ty::PolyFnSig<'tcx> {\n+    fn error_sig_of_closure(&self, decl: &hir::FnDecl<'_>) -> ty::PolyFnSig<'tcx> {\n         let astconv: &dyn AstConv<'_> = self;\n \n         let supplied_arguments = decl.inputs.iter().map(|a| {"}, {"sha": "79bad233fd10dbe9341040388d52de2ee4d37a03", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=2ba0d2acbd6cb01fb07619628882120d5b66bd59", "patch": "@@ -873,12 +873,12 @@ fn compare_synthetic_generics<'tcx>(\n                         let impl_m = tcx.hir().as_local_hir_id(impl_m.def_id)?;\n                         let impl_m = tcx.hir().impl_item(hir::ImplItemId { hir_id: impl_m });\n                         let input_tys = match impl_m.kind {\n-                            hir::ImplItemKind::Method(ref sig, _) => &sig.decl.inputs,\n+                            hir::ImplItemKind::Method(ref sig, _) => sig.decl.inputs,\n                             _ => unreachable!(),\n                         };\n                         struct Visitor(Option<Span>, hir::def_id::DefId);\n                         impl<'v> hir::intravisit::Visitor<'v> for Visitor {\n-                            fn visit_ty(&mut self, ty: &'v hir::Ty) {\n+                            fn visit_ty(&mut self, ty: &'v hir::Ty<'v>) {\n                                 hir::intravisit::walk_ty(self, ty);\n                                 if let hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) =\n                                     ty.kind"}, {"sha": "6c4b4ee179806f7dd2c5620979ba08f4a9159cdf", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=2ba0d2acbd6cb01fb07619628882120d5b66bd59", "patch": "@@ -469,7 +469,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn check_expr_path(&self, qpath: &hir::QPath, expr: &'tcx hir::Expr<'tcx>) -> Ty<'tcx> {\n+    fn check_expr_path(&self, qpath: &hir::QPath<'_>, expr: &'tcx hir::Expr<'tcx>) -> Ty<'tcx> {\n         let tcx = self.tcx;\n         let (res, opt_ty, segs) = self.resolve_ty_and_res_ufcs(qpath, expr.hir_id, expr.span);\n         let ty = match res {\n@@ -853,7 +853,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn check_method_call(\n         &self,\n         expr: &'tcx hir::Expr<'tcx>,\n-        segment: &hir::PathSegment,\n+        segment: &hir::PathSegment<'_>,\n         span: Span,\n         args: &'tcx [hir::Expr<'tcx>],\n         expected: Expectation<'tcx>,\n@@ -893,7 +893,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn report_extended_method_error(\n         &self,\n-        segment: &hir::PathSegment,\n+        segment: &hir::PathSegment<'_>,\n         span: Span,\n         args: &'tcx [hir::Expr<'tcx>],\n         rcvr_t: Ty<'tcx>,\n@@ -941,7 +941,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn check_expr_cast(\n         &self,\n         e: &'tcx hir::Expr<'tcx>,\n-        t: &'tcx hir::Ty,\n+        t: &'tcx hir::Ty<'tcx>,\n         expr: &'tcx hir::Expr<'tcx>,\n     ) -> Ty<'tcx> {\n         // Find the type of `e`. Supply hints based on the type we are casting to,\n@@ -1087,7 +1087,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         expr: &hir::Expr<'_>,\n         expected: Expectation<'tcx>,\n-        qpath: &QPath,\n+        qpath: &QPath<'_>,\n         fields: &'tcx [hir::Field<'tcx>],\n         base_expr: &'tcx Option<&'tcx hir::Expr<'tcx>>,\n     ) -> Ty<'tcx> {"}, {"sha": "4b5963af283a0e53ce530c2d207b320bc26b9c75", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=2ba0d2acbd6cb01fb07619628882120d5b66bd59", "patch": "@@ -43,7 +43,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         call_expr: &'tcx hir::Expr<'tcx>,\n         unadjusted_self_ty: Ty<'tcx>,\n         pick: probe::Pick<'tcx>,\n-        segment: &hir::PathSegment,\n+        segment: &hir::PathSegment<'_>,\n     ) -> ConfirmResult<'tcx> {\n         debug!(\n             \"confirm(unadjusted_self_ty={:?}, pick={:?}, generic_args={:?})\",\n@@ -69,7 +69,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         &mut self,\n         unadjusted_self_ty: Ty<'tcx>,\n         pick: probe::Pick<'tcx>,\n-        segment: &hir::PathSegment,\n+        segment: &hir::PathSegment<'_>,\n     ) -> ConfirmResult<'tcx> {\n         // Adjust the self expression the user provided and obtain the adjusted type.\n         let self_ty = self.adjust_self_ty(unadjusted_self_ty, &pick);\n@@ -292,7 +292,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n     fn instantiate_method_substs(\n         &mut self,\n         pick: &probe::Pick<'tcx>,\n-        seg: &hir::PathSegment,\n+        seg: &hir::PathSegment<'_>,\n         parent_substs: SubstsRef<'tcx>,\n     ) -> SubstsRef<'tcx> {\n         // Determine the values for the generic parameters of the method."}, {"sha": "877b1a3cc24c65589d0bad1eabd0322d93ebf751", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=2ba0d2acbd6cb01fb07619628882120d5b66bd59", "patch": "@@ -178,7 +178,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn lookup_method(\n         &self,\n         self_ty: Ty<'tcx>,\n-        segment: &hir::PathSegment,\n+        segment: &hir::PathSegment<'_>,\n         span: Span,\n         call_expr: &'tcx hir::Expr<'tcx>,\n         self_expr: &'tcx hir::Expr<'tcx>,"}, {"sha": "d98a11b879ec64c1add9109253b7ea8347695e32", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=2ba0d2acbd6cb01fb07619628882120d5b66bd59", "patch": "@@ -953,7 +953,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n #[derive(Copy, Clone)]\n pub enum SelfSource<'a> {\n-    QPath(&'a hir::Ty),\n+    QPath(&'a hir::Ty<'a>),\n     MethodCall(&'a hir::Expr<'a> /* rcvr */),\n }\n "}, {"sha": "c6c3ada49e312e267269c1bed4d6cb5279359d3e", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=2ba0d2acbd6cb01fb07619628882120d5b66bd59", "patch": "@@ -784,7 +784,7 @@ fn adt_destructor(tcx: TyCtxt<'_>, def_id: DefId) -> Option<ty::Destructor> {\n fn primary_body_of(\n     tcx: TyCtxt<'_>,\n     id: hir::HirId,\n-) -> Option<(hir::BodyId, Option<&hir::Ty>, Option<&hir::FnHeader>, Option<&hir::FnDecl>)> {\n+) -> Option<(hir::BodyId, Option<&hir::Ty<'_>>, Option<&hir::FnHeader>, Option<&hir::FnDecl<'_>>)> {\n     match tcx.hir().get(id) {\n         Node::Item(item) => match item.kind {\n             hir::ItemKind::Const(ref ty, body) | hir::ItemKind::Static(ref ty, _, body) => {\n@@ -1196,7 +1196,7 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx> {\n     fn visit_fn(\n         &mut self,\n         _: intravisit::FnKind<'tcx>,\n-        _: &'tcx hir::FnDecl,\n+        _: &'tcx hir::FnDecl<'tcx>,\n         _: hir::BodyId,\n         _: Span,\n         _: hir::HirId,\n@@ -1228,7 +1228,7 @@ fn check_fn<'a, 'tcx>(\n     inherited: &'a Inherited<'a, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     fn_sig: ty::FnSig<'tcx>,\n-    decl: &'tcx hir::FnDecl,\n+    decl: &'tcx hir::FnDecl<'tcx>,\n     fn_id: hir::HirId,\n     body: &'tcx hir::Body<'tcx>,\n     can_be_generator: Option<hir::Movability>,\n@@ -1902,7 +1902,7 @@ fn check_impl_items_against_trait<'tcx>(\n     full_impl_span: Span,\n     impl_id: DefId,\n     impl_trait_ref: ty::TraitRef<'tcx>,\n-    impl_item_refs: &[hir::ImplItemRef],\n+    impl_item_refs: &[hir::ImplItemRef<'_>],\n ) {\n     let impl_span = tcx.sess.source_map().def_span(full_impl_span);\n \n@@ -2511,7 +2511,7 @@ pub fn check_enum<'tcx>(\n     check_transparent(tcx, sp, def_id);\n }\n \n-fn report_unexpected_variant_res(tcx: TyCtxt<'_>, res: Res, span: Span, qpath: &QPath) {\n+fn report_unexpected_variant_res(tcx: TyCtxt<'_>, res: Res, span: Span, qpath: &QPath<'_>) {\n     span_err!(\n         tcx.sess,\n         span,\n@@ -2600,7 +2600,7 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n         &self,\n         span: Span,\n         item_def_id: DefId,\n-        item_segment: &hir::PathSegment,\n+        item_segment: &hir::PathSegment<'_>,\n         poly_trait_ref: ty::PolyTraitRef<'tcx>,\n     ) -> Ty<'tcx> {\n         let (trait_ref, _) = self.replace_bound_vars_with_fresh_vars(\n@@ -3105,13 +3105,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn to_ty(&self, ast_t: &hir::Ty) -> Ty<'tcx> {\n+    pub fn to_ty(&self, ast_t: &hir::Ty<'_>) -> Ty<'tcx> {\n         let t = AstConv::ast_ty_to_ty(self, ast_t);\n         self.register_wf_obligation(t, ast_t.span, traits::MiscObligation);\n         t\n     }\n \n-    pub fn to_ty_saving_user_provided_ty(&self, ast_ty: &hir::Ty) -> Ty<'tcx> {\n+    pub fn to_ty_saving_user_provided_ty(&self, ast_ty: &hir::Ty<'_>) -> Ty<'tcx> {\n         let ty = self.to_ty(ast_ty);\n         debug!(\"to_ty_saving_user_provided_ty: ty={:?}\", ty);\n \n@@ -4100,7 +4100,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     pub fn check_struct_path(\n         &self,\n-        qpath: &QPath,\n+        qpath: &QPath<'_>,\n         hir_id: hir::HirId,\n     ) -> Option<(&'tcx ty::VariantDef, Ty<'tcx>)> {\n         let path_span = match *qpath {\n@@ -4159,7 +4159,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     // The newly resolved definition is written into `type_dependent_defs`.\n     fn finish_resolving_struct_path(\n         &self,\n-        qpath: &QPath,\n+        qpath: &QPath<'_>,\n         path_span: Span,\n         hir_id: hir::HirId,\n     ) -> (Res, Ty<'tcx>) {\n@@ -4194,10 +4194,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// resolution. The newly resolved definition is written into `type_dependent_defs`.\n     pub fn resolve_ty_and_res_ufcs<'b>(\n         &self,\n-        qpath: &'b QPath,\n+        qpath: &'b QPath<'b>,\n         hir_id: hir::HirId,\n         span: Span,\n-    ) -> (Res, Option<Ty<'tcx>>, &'b [hir::PathSegment]) {\n+    ) -> (Res, Option<Ty<'tcx>>, &'b [hir::PathSegment<'b>]) {\n         debug!(\"resolve_ty_and_res_ufcs: qpath={:?} hir_id={:?} span={:?}\", qpath, hir_id, span);\n         let (ty, qself, item_segment) = match *qpath {\n             QPath::Resolved(ref opt_qself, ref path) => {\n@@ -4545,13 +4545,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     /// Given a function block's `HirId`, returns its `FnDecl` if it exists, or `None` otherwise.\n-    fn get_parent_fn_decl(&self, blk_id: hir::HirId) -> Option<(&'tcx hir::FnDecl, ast::Ident)> {\n+    fn get_parent_fn_decl(\n+        &self,\n+        blk_id: hir::HirId,\n+    ) -> Option<(&'tcx hir::FnDecl<'tcx>, ast::Ident)> {\n         let parent = self.tcx.hir().get(self.tcx.hir().get_parent_item(blk_id));\n         self.get_node_fn_decl(parent).map(|(fn_decl, ident, _)| (fn_decl, ident))\n     }\n \n     /// Given a function `Node`, return its `FnDecl` if it exists, or `None` otherwise.\n-    fn get_node_fn_decl(&self, node: Node<'tcx>) -> Option<(&'tcx hir::FnDecl, ast::Ident, bool)> {\n+    fn get_node_fn_decl(\n+        &self,\n+        node: Node<'tcx>,\n+    ) -> Option<(&'tcx hir::FnDecl<'tcx>, ast::Ident, bool)> {\n         match node {\n             Node::Item(&hir::Item { ident, kind: hir::ItemKind::Fn(ref sig, ..), .. }) => {\n                 // This is less than ideal, it will not suggest a return type span on any\n@@ -4575,7 +4581,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     /// Given a `HirId`, return the `FnDecl` of the method it is enclosed by and whether a\n     /// suggestion can be made, `None` otherwise.\n-    pub fn get_fn_decl(&self, blk_id: hir::HirId) -> Option<(&'tcx hir::FnDecl, bool)> {\n+    pub fn get_fn_decl(&self, blk_id: hir::HirId) -> Option<(&'tcx hir::FnDecl<'tcx>, bool)> {\n         // Get enclosing Fn, if it is a function or a trait method, unless there's a `loop` or\n         // `while` before reaching it, as block tail returns are not available in them.\n         self.tcx.hir().get_return_block(blk_id).and_then(|blk_id| {\n@@ -4908,7 +4914,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn suggest_missing_return_type(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n-        fn_decl: &hir::FnDecl,\n+        fn_decl: &hir::FnDecl<'_>,\n         expected: Ty<'tcx>,\n         found: Ty<'tcx>,\n         can_suggest: bool,\n@@ -5075,7 +5081,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     // number of type parameters and type.\n     pub fn instantiate_value_path(\n         &self,\n-        segments: &[hir::PathSegment],\n+        segments: &[hir::PathSegment<'_>],\n         self_ty: Option<Ty<'tcx>>,\n         res: Res,\n         span: Span,"}, {"sha": "156126a748a2123664812c067e05239a1574d5b5", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=2ba0d2acbd6cb01fb07619628882120d5b66bd59", "patch": "@@ -554,7 +554,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn check_pat_struct(\n         &self,\n         pat: &'tcx Pat<'tcx>,\n-        qpath: &hir::QPath,\n+        qpath: &hir::QPath<'_>,\n         fields: &'tcx [hir::FieldPat<'tcx>],\n         etc: bool,\n         expected: Ty<'tcx>,\n@@ -587,8 +587,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn check_pat_path(\n         &self,\n         pat: &Pat<'_>,\n-        path_resolution: (Res, Option<Ty<'tcx>>, &'b [hir::PathSegment]),\n-        qpath: &hir::QPath,\n+        path_resolution: (Res, Option<Ty<'tcx>>, &'b [hir::PathSegment<'b>]),\n+        qpath: &hir::QPath<'_>,\n         expected: Ty<'tcx>,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n@@ -622,7 +622,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn check_pat_tuple_struct(\n         &self,\n         pat: &Pat<'_>,\n-        qpath: &hir::QPath,\n+        qpath: &hir::QPath<'_>,\n         subpats: &'tcx [&'tcx Pat<'tcx>],\n         ddpos: Option<usize>,\n         expected: Ty<'tcx>,\n@@ -724,7 +724,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         pat_span: Span,\n         res: Res,\n-        qpath: &hir::QPath,\n+        qpath: &hir::QPath<'_>,\n         subpats: &'tcx [&'tcx Pat<'tcx>],\n         fields: &'tcx [ty::FieldDef],\n         expected: Ty<'tcx>,"}, {"sha": "a42b666f11620cecab155cc55a6591c65abeb9b9", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=2ba0d2acbd6cb01fb07619628882120d5b66bd59", "patch": "@@ -421,7 +421,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionCtxt<'a, 'tcx> {\n     fn visit_fn(\n         &mut self,\n         fk: intravisit::FnKind<'tcx>,\n-        _: &'tcx hir::FnDecl,\n+        _: &'tcx hir::FnDecl<'tcx>,\n         body_id: hir::BodyId,\n         span: Span,\n         hir_id: hir::HirId,"}, {"sha": "fa829d1b990d01d6cb170ed1b6721f3e9989dbf7", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=2ba0d2acbd6cb01fb07619628882120d5b66bd59", "patch": "@@ -194,7 +194,7 @@ fn check_associated_item(\n     tcx: TyCtxt<'_>,\n     item_id: hir::HirId,\n     span: Span,\n-    sig_if_method: Option<&hir::FnSig>,\n+    sig_if_method: Option<&hir::FnSig<'_>>,\n ) {\n     debug!(\"check_associated_item: {:?}\", item_id);\n \n@@ -391,8 +391,8 @@ fn check_item_type(tcx: TyCtxt<'_>, item_id: hir::HirId, ty_span: Span, allow_fo\n fn check_impl<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     item: &'tcx hir::Item<'tcx>,\n-    ast_self_ty: &hir::Ty,\n-    ast_trait_ref: &Option<hir::TraitRef>,\n+    ast_self_ty: &hir::Ty<'_>,\n+    ast_trait_ref: &Option<hir::TraitRef<'_>>,\n ) {\n     debug!(\"check_impl: {:?}\", item);\n \n@@ -774,7 +774,7 @@ const HELP_FOR_SELF_TYPE: &str = \"consider changing to `self`, `&self`, `&mut se\n \n fn check_method_receiver<'fcx, 'tcx>(\n     fcx: &FnCtxt<'fcx, 'tcx>,\n-    fn_sig: &hir::FnSig,\n+    fn_sig: &hir::FnSig<'_>,\n     method: &ty::AssocItem,\n     self_ty: Ty<'tcx>,\n ) {\n@@ -961,7 +961,7 @@ fn receiver_is_implemented(\n fn check_variances_for_type_defn<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     item: &hir::Item<'tcx>,\n-    hir_generics: &hir::Generics,\n+    hir_generics: &hir::Generics<'_>,\n ) {\n     let item_def_id = tcx.hir().local_def_id(item.hir_id);\n     let ty = tcx.type_of(item_def_id);"}, {"sha": "2db6e24be052b3f61a8502ef6fe4b1cab2d20c22", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=2ba0d2acbd6cb01fb07619628882120d5b66bd59", "patch": "@@ -310,7 +310,7 @@ impl<'cx, 'tcx> Visitor<'tcx> for WritebackCx<'cx, 'tcx> {\n         self.write_ty_to_tables(l.hir_id, var_ty);\n     }\n \n-    fn visit_ty(&mut self, hir_ty: &'tcx hir::Ty) {\n+    fn visit_ty(&mut self, hir_ty: &'tcx hir::Ty<'tcx>) {\n         intravisit::walk_ty(self, hir_ty);\n         let ty = self.fcx.node_ty(hir_ty.hir_id);\n         let ty = self.resolve(&ty, &hir_ty.span);"}, {"sha": "eee292c55a8a4ab16110b52c2c0d3d7e5dc544ef", "filename": "src/librustc_typeck/coherence/unsafety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs?ref=2ba0d2acbd6cb01fb07619628882120d5b66bd59", "patch": "@@ -20,7 +20,7 @@ impl UnsafetyChecker<'tcx> {\n     fn check_unsafety_coherence(\n         &mut self,\n         item: &'v hir::Item<'v>,\n-        impl_generics: Option<&hir::Generics>,\n+        impl_generics: Option<&hir::Generics<'_>>,\n         unsafety: hir::Unsafety,\n         polarity: hir::ImplPolarity,\n     ) {"}, {"sha": "9604a9ade929e079057d1246bcc09af880c6230b", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=2ba0d2acbd6cb01fb07619628882120d5b66bd59", "patch": "@@ -116,7 +116,7 @@ impl Visitor<'tcx> for CollectItemTypesVisitor<'tcx> {\n         intravisit::walk_item(self, item);\n     }\n \n-    fn visit_generics(&mut self, generics: &'tcx hir::Generics) {\n+    fn visit_generics(&mut self, generics: &'tcx hir::Generics<'tcx>) {\n         for param in &generics.params {\n             match param.kind {\n                 hir::GenericParamKind::Lifetime { .. } => {}\n@@ -173,7 +173,7 @@ impl ItemCtxt<'tcx> {\n         ItemCtxt { tcx, item_def_id }\n     }\n \n-    pub fn to_ty(&self, ast_ty: &'tcx hir::Ty) -> Ty<'tcx> {\n+    pub fn to_ty(&self, ast_ty: &'tcx hir::Ty<'tcx>) -> Ty<'tcx> {\n         AstConv::ast_ty_to_ty(self, ast_ty)\n     }\n }\n@@ -216,7 +216,7 @@ impl AstConv<'tcx> for ItemCtxt<'tcx> {\n         &self,\n         span: Span,\n         item_def_id: DefId,\n-        item_segment: &hir::PathSegment,\n+        item_segment: &hir::PathSegment<'_>,\n         poly_trait_ref: ty::PolyTraitRef<'tcx>,\n     ) -> Ty<'tcx> {\n         if let Some(trait_ref) = poly_trait_ref.no_bound_vars() {\n@@ -343,7 +343,7 @@ impl ItemCtxt<'tcx> {\n     /// bounds for a type parameter `X` if `X::Foo` is used.\n     fn type_parameter_bounds_in_generics(\n         &self,\n-        ast_generics: &'tcx hir::Generics,\n+        ast_generics: &'tcx hir::Generics<'tcx>,\n         param_id: hir::HirId,\n         ty: Ty<'tcx>,\n         only_self_bounds: OnlySelfBounds,\n@@ -386,7 +386,7 @@ impl ItemCtxt<'tcx> {\n /// parameter with ID `param_id`. We use this so as to avoid running\n /// `ast_ty_to_ty`, because we want to avoid triggering an all-out\n /// conversion of the type to avoid inducing unnecessary cycles.\n-fn is_param(tcx: TyCtxt<'_>, ast_ty: &hir::Ty, param_id: hir::HirId) -> bool {\n+fn is_param(tcx: TyCtxt<'_>, ast_ty: &hir::Ty<'_>, param_id: hir::HirId) -> bool {\n     if let hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) = ast_ty.kind {\n         match path.res {\n             Res::SelfTy(Some(def_id), None) | Res::Def(DefKind::TyParam, def_id) => {\n@@ -803,7 +803,7 @@ fn has_late_bound_regions<'tcx>(tcx: TyCtxt<'tcx>, node: Node<'tcx>) -> Option<S\n             NestedVisitorMap::None\n         }\n \n-        fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n+        fn visit_ty(&mut self, ty: &'tcx hir::Ty<'tcx>) {\n             if self.has_late_bound_regions.is_some() {\n                 return;\n             }\n@@ -819,7 +819,7 @@ fn has_late_bound_regions<'tcx>(tcx: TyCtxt<'tcx>, node: Node<'tcx>) -> Option<S\n \n         fn visit_poly_trait_ref(\n             &mut self,\n-            tr: &'tcx hir::PolyTraitRef,\n+            tr: &'tcx hir::PolyTraitRef<'tcx>,\n             m: hir::TraitBoundModifier,\n         ) {\n             if self.has_late_bound_regions.is_some() {\n@@ -852,8 +852,8 @@ fn has_late_bound_regions<'tcx>(tcx: TyCtxt<'tcx>, node: Node<'tcx>) -> Option<S\n \n     fn has_late_bound_regions<'tcx>(\n         tcx: TyCtxt<'tcx>,\n-        generics: &'tcx hir::Generics,\n-        decl: &'tcx hir::FnDecl,\n+        generics: &'tcx hir::Generics<'tcx>,\n+        decl: &'tcx hir::FnDecl<'tcx>,\n     ) -> Option<Span> {\n         let mut visitor = LateBoundRegionsDetector {\n             tcx,\n@@ -1699,7 +1699,7 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n     }\n }\n \n-pub fn get_infer_ret_ty(output: &'_ hir::FunctionRetTy) -> Option<&hir::Ty> {\n+pub fn get_infer_ret_ty(output: &'hir hir::FunctionRetTy<'hir>) -> Option<&'hir hir::Ty<'hir>> {\n     if let hir::FunctionRetTy::Return(ref ty) = output {\n         if let hir::TyKind::Infer = ty.kind {\n             return Some(&**ty);\n@@ -1841,8 +1841,8 @@ fn impl_polarity(tcx: TyCtxt<'_>, def_id: DefId) -> ty::ImplPolarity {\n /// `resolve_lifetime::early_bound_lifetimes`.\n fn early_bound_lifetimes_from_generics<'a, 'tcx: 'a>(\n     tcx: TyCtxt<'tcx>,\n-    generics: &'a hir::Generics,\n-) -> impl Iterator<Item = &'a hir::GenericParam> + Captures<'tcx> {\n+    generics: &'a hir::Generics<'a>,\n+) -> impl Iterator<Item = &'a hir::GenericParam<'a>> + Captures<'tcx> {\n     generics.params.iter().filter(move |param| match param.kind {\n         GenericParamKind::Lifetime { .. } => !tcx.is_late_bound(param.hir_id),\n         _ => false,\n@@ -1947,7 +1947,7 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n \n     let icx = ItemCtxt::new(tcx, def_id);\n \n-    const NO_GENERICS: &hir::Generics = &hir::Generics::empty();\n+    const NO_GENERICS: &hir::Generics<'_> = &hir::Generics::empty();\n \n     let mut predicates = UniquePredicates::new();\n \n@@ -2116,7 +2116,7 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n \n     // Add in the bounds that appear in the where-clause.\n     let where_clause = &ast_generics.where_clause;\n-    for predicate in &where_clause.predicates {\n+    for predicate in where_clause.predicates {\n         match predicate {\n             &hir::WherePredicate::BoundPredicate(ref bound_pred) => {\n                 let ty = icx.to_ty(&bound_pred.bounded_ty);\n@@ -2323,7 +2323,7 @@ fn associated_item_predicates(\n fn predicates_from_bound<'tcx>(\n     astconv: &dyn AstConv<'tcx>,\n     param_ty: Ty<'tcx>,\n-    bound: &'tcx hir::GenericBound,\n+    bound: &'tcx hir::GenericBound<'tcx>,\n ) -> Vec<(ty::Predicate<'tcx>, Span)> {\n     match *bound {\n         hir::GenericBound::Trait(ref tr, hir::TraitBoundModifier::None) => {\n@@ -2343,7 +2343,7 @@ fn predicates_from_bound<'tcx>(\n fn compute_sig_of_foreign_fn_decl<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     def_id: DefId,\n-    decl: &'tcx hir::FnDecl,\n+    decl: &'tcx hir::FnDecl<'tcx>,\n     abi: abi::Abi,\n ) -> ty::PolyFnSig<'tcx> {\n     let unsafety = if abi == abi::Abi::RustIntrinsic {\n@@ -2359,7 +2359,7 @@ fn compute_sig_of_foreign_fn_decl<'tcx>(\n         && abi != abi::Abi::PlatformIntrinsic\n         && !tcx.features().simd_ffi\n     {\n-        let check = |ast_ty: &hir::Ty, ty: Ty<'_>| {\n+        let check = |ast_ty: &hir::Ty<'_>, ty: Ty<'_>| {\n             if ty.is_simd() {\n                 tcx.sess\n                     .struct_span_err("}, {"sha": "55b2ad44467902cc1fac67a2869df1615100ebf2", "filename": "src/librustc_typeck/impl_wf_check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check.rs?ref=2ba0d2acbd6cb01fb07619628882120d5b66bd59", "patch": "@@ -89,7 +89,7 @@ impl ItemLikeVisitor<'tcx> for ImplWfCheck<'tcx> {\n fn enforce_impl_params_are_constrained(\n     tcx: TyCtxt<'_>,\n     impl_def_id: DefId,\n-    impl_item_refs: &[hir::ImplItemRef],\n+    impl_item_refs: &[hir::ImplItemRef<'_>],\n ) {\n     // Every lifetime used in an associated type must be constrained.\n     let impl_self_ty = tcx.type_of(impl_def_id);\n@@ -201,7 +201,7 @@ fn report_unused_parameter(tcx: TyCtxt<'_>, span: Span, kind: &str, name: &str)\n }\n \n /// Enforce that we do not have two items in an impl with the same name.\n-fn enforce_impl_items_are_distinct(tcx: TyCtxt<'_>, impl_item_refs: &[hir::ImplItemRef]) {\n+fn enforce_impl_items_are_distinct(tcx: TyCtxt<'_>, impl_item_refs: &[hir::ImplItemRef<'_>]) {\n     let mut seen_type_items = FxHashMap::default();\n     let mut seen_value_items = FxHashMap::default();\n     for impl_item_ref in impl_item_refs {"}, {"sha": "d9b7e98ea75c35f0501fbd2d578c1083bcacfde2", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=2ba0d2acbd6cb01fb07619628882120d5b66bd59", "patch": "@@ -119,7 +119,7 @@ pub struct TypeAndSubsts<'tcx> {\n     ty: Ty<'tcx>,\n }\n \n-fn require_c_abi_if_c_variadic(tcx: TyCtxt<'_>, decl: &hir::FnDecl, abi: Abi, span: Span) {\n+fn require_c_abi_if_c_variadic(tcx: TyCtxt<'_>, decl: &hir::FnDecl<'_>, abi: Abi, span: Span) {\n     if decl.c_variadic && !(abi == Abi::C || abi == Abi::Cdecl) {\n         let mut err = struct_span_err!(\n             tcx.sess,\n@@ -356,7 +356,7 @@ pub fn check_crate(tcx: TyCtxt<'_>) -> Result<(), ErrorReported> {\n \n /// A quasi-deprecated helper used in rustdoc and clippy to get\n /// the type from a HIR node.\n-pub fn hir_ty_to_ty<'tcx>(tcx: TyCtxt<'tcx>, hir_ty: &hir::Ty) -> Ty<'tcx> {\n+pub fn hir_ty_to_ty<'tcx>(tcx: TyCtxt<'tcx>, hir_ty: &hir::Ty<'_>) -> Ty<'tcx> {\n     // In case there are any projections, etc., find the \"environment\"\n     // def-ID that will be used to determine the traits/predicates in\n     // scope.  This is derived from the enclosing item-like thing.\n@@ -367,7 +367,10 @@ pub fn hir_ty_to_ty<'tcx>(tcx: TyCtxt<'tcx>, hir_ty: &hir::Ty) -> Ty<'tcx> {\n     astconv::AstConv::ast_ty_to_ty(&item_cx, hir_ty)\n }\n \n-pub fn hir_trait_to_predicates<'tcx>(tcx: TyCtxt<'tcx>, hir_trait: &hir::TraitRef) -> Bounds<'tcx> {\n+pub fn hir_trait_to_predicates<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    hir_trait: &hir::TraitRef<'_>,\n+) -> Bounds<'tcx> {\n     // In case there are any projections, etc., find the \"environment\"\n     // def-ID that will be used to determine the traits/predicates in\n     // scope.  This is derived from the enclosing item-like thing."}, {"sha": "db17d23c910e29bdd16914f39bbebcabdecee24e", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=2ba0d2acbd6cb01fb07619628882120d5b66bd59", "patch": "@@ -306,7 +306,7 @@ impl Clean<Attributes> for [ast::Attribute] {\n     }\n }\n \n-impl Clean<GenericBound> for hir::GenericBound {\n+impl Clean<GenericBound> for hir::GenericBound<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> GenericBound {\n         match *self {\n             hir::GenericBound::Outlives(lt) => GenericBound::Outlives(lt.clean(cx)),\n@@ -406,7 +406,7 @@ impl Clean<Lifetime> for hir::Lifetime {\n     }\n }\n \n-impl Clean<Lifetime> for hir::GenericParam {\n+impl Clean<Lifetime> for hir::GenericParam<'_> {\n     fn clean(&self, _: &DocContext<'_>) -> Lifetime {\n         match self.kind {\n             hir::GenericParamKind::Lifetime { .. } => {\n@@ -469,7 +469,7 @@ impl Clean<Option<Lifetime>> for ty::RegionKind {\n     }\n }\n \n-impl Clean<WherePredicate> for hir::WherePredicate {\n+impl Clean<WherePredicate> for hir::WherePredicate<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> WherePredicate {\n         match *self {\n             hir::WherePredicate::BoundPredicate(ref wbp) => WherePredicate::BoundPredicate {\n@@ -615,7 +615,7 @@ impl Clean<GenericParamDef> for ty::GenericParamDef {\n     }\n }\n \n-impl Clean<GenericParamDef> for hir::GenericParam {\n+impl Clean<GenericParamDef> for hir::GenericParam<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> GenericParamDef {\n         let (name, kind) = match self.kind {\n             hir::GenericParamKind::Lifetime { .. } => {\n@@ -657,12 +657,12 @@ impl Clean<GenericParamDef> for hir::GenericParam {\n     }\n }\n \n-impl Clean<Generics> for hir::Generics {\n+impl Clean<Generics> for hir::Generics<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Generics {\n         // Synthetic type-parameters are inserted after normal ones.\n         // In order for normal parameters to be able to refer to synthetic ones,\n         // scans them first.\n-        fn is_impl_trait(param: &hir::GenericParam) -> bool {\n+        fn is_impl_trait(param: &hir::GenericParam<'_>) -> bool {\n             match param.kind {\n                 hir::GenericParamKind::Type { synthetic, .. } => {\n                     synthetic == Some(hir::SyntheticTyParamKind::ImplTrait)\n@@ -892,7 +892,7 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics, ty::GenericPredicates<'tcx\n }\n \n impl<'a> Clean<Method>\n-    for (&'a hir::FnSig, &'a hir::Generics, hir::BodyId, Option<hir::Defaultness>)\n+    for (&'a hir::FnSig<'a>, &'a hir::Generics<'a>, hir::BodyId, Option<hir::Defaultness>)\n {\n     fn clean(&self, cx: &DocContext<'_>) -> Method {\n         let (generics, decl) =\n@@ -933,7 +933,7 @@ impl Clean<Item> for doctree::Function<'_> {\n     }\n }\n \n-impl<'a> Clean<Arguments> for (&'a [hir::Ty], &'a [ast::Ident]) {\n+impl<'a> Clean<Arguments> for (&'a [hir::Ty<'a>], &'a [ast::Ident]) {\n     fn clean(&self, cx: &DocContext<'_>) -> Arguments {\n         Arguments {\n             values: self\n@@ -953,7 +953,7 @@ impl<'a> Clean<Arguments> for (&'a [hir::Ty], &'a [ast::Ident]) {\n     }\n }\n \n-impl<'a> Clean<Arguments> for (&'a [hir::Ty], hir::BodyId) {\n+impl<'a> Clean<Arguments> for (&'a [hir::Ty<'a>], hir::BodyId) {\n     fn clean(&self, cx: &DocContext<'_>) -> Arguments {\n         let body = cx.tcx.hir().body(self.1);\n \n@@ -971,9 +971,9 @@ impl<'a> Clean<Arguments> for (&'a [hir::Ty], hir::BodyId) {\n     }\n }\n \n-impl<'a, A: Copy> Clean<FnDecl> for (&'a hir::FnDecl, A)\n+impl<'a, A: Copy> Clean<FnDecl> for (&'a hir::FnDecl<'a>, A)\n where\n-    (&'a [hir::Ty], A): Clean<Arguments>,\n+    (&'a [hir::Ty<'a>], A): Clean<Arguments>,\n {\n     fn clean(&self, cx: &DocContext<'_>) -> FnDecl {\n         FnDecl {\n@@ -1013,7 +1013,7 @@ impl<'tcx> Clean<FnDecl> for (DefId, ty::PolyFnSig<'tcx>) {\n     }\n }\n \n-impl Clean<FunctionRetTy> for hir::FunctionRetTy {\n+impl Clean<FunctionRetTy> for hir::FunctionRetTy<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> FunctionRetTy {\n         match *self {\n             hir::Return(ref typ) => Return(typ.clean(cx)),\n@@ -1075,13 +1075,13 @@ impl Clean<bool> for hir::IsAuto {\n     }\n }\n \n-impl Clean<Type> for hir::TraitRef {\n+impl Clean<Type> for hir::TraitRef<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Type {\n         resolve_type(cx, self.path.clean(cx), self.hir_ref_id)\n     }\n }\n \n-impl Clean<PolyTrait> for hir::PolyTraitRef {\n+impl Clean<PolyTrait> for hir::PolyTraitRef<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> PolyTrait {\n         PolyTrait {\n             trait_: self.trait_ref.clean(cx),\n@@ -1324,7 +1324,7 @@ impl Clean<Item> for ty::AssocItem {\n     }\n }\n \n-impl Clean<Type> for hir::Ty {\n+impl Clean<Type> for hir::Ty<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Type {\n         use rustc::hir::*;\n \n@@ -1480,7 +1480,7 @@ impl Clean<Type> for hir::Ty {\n                 if let ty::Projection(proj) = ty.kind {\n                     res = Res::Def(DefKind::Trait, proj.trait_ref(cx.tcx).def_id);\n                 }\n-                let trait_path = hir::Path { span: self.span, res, segments: vec![].into() };\n+                let trait_path = hir::Path { span: self.span, res, segments: &[] };\n                 Type::QPath {\n                     name: segment.ident.name.clean(cx),\n                     self_type: box qself.clean(cx),\n@@ -1760,7 +1760,7 @@ impl Clean<Item> for ty::FieldDef {\n     }\n }\n \n-impl Clean<Visibility> for hir::Visibility {\n+impl Clean<Visibility> for hir::Visibility<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Visibility {\n         match self.node {\n             hir::VisibilityKind::Public => Visibility::Public,\n@@ -1937,7 +1937,7 @@ impl Clean<Span> for syntax_pos::Span {\n     }\n }\n \n-impl Clean<Path> for hir::Path {\n+impl Clean<Path> for hir::Path<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Path {\n         Path {\n             global: self.is_global(),\n@@ -1947,7 +1947,7 @@ impl Clean<Path> for hir::Path {\n     }\n }\n \n-impl Clean<GenericArgs> for hir::GenericArgs {\n+impl Clean<GenericArgs> for hir::GenericArgs<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> GenericArgs {\n         if self.parenthesized {\n             let output = self.bindings[0].ty().clean(cx);\n@@ -1979,7 +1979,7 @@ impl Clean<GenericArgs> for hir::GenericArgs {\n     }\n }\n \n-impl Clean<PathSegment> for hir::PathSegment {\n+impl Clean<PathSegment> for hir::PathSegment<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> PathSegment {\n         PathSegment { name: self.ident.name.clean(cx), args: self.generic_args().clean(cx) }\n     }\n@@ -2038,7 +2038,7 @@ impl Clean<Item> for doctree::OpaqueTy<'_> {\n     }\n }\n \n-impl Clean<BareFunctionDecl> for hir::BareFnTy {\n+impl Clean<BareFunctionDecl> for hir::BareFnTy<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> BareFunctionDecl {\n         let (generic_params, decl) = enter_impl_trait(cx, || {\n             (self.generic_params.clean(cx), (&*self.decl, &self.param_names[..]).clean(cx))\n@@ -2377,13 +2377,13 @@ impl Clean<Deprecation> for attr::Deprecation {\n     }\n }\n \n-impl Clean<TypeBinding> for hir::TypeBinding {\n+impl Clean<TypeBinding> for hir::TypeBinding<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> TypeBinding {\n         TypeBinding { name: self.ident.name.clean(cx), kind: self.kind.clean(cx) }\n     }\n }\n \n-impl Clean<TypeBindingKind> for hir::TypeBindingKind {\n+impl Clean<TypeBindingKind> for hir::TypeBindingKind<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> TypeBindingKind {\n         match *self {\n             hir::TypeBindingKind::Equality { ref ty } => {"}, {"sha": "46eddede0d518c5924667885db820d7c32dfcbed", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba0d2acbd6cb01fb07619628882120d5b66bd59/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=2ba0d2acbd6cb01fb07619628882120d5b66bd59", "patch": "@@ -28,7 +28,7 @@ pub struct Module<'hir> {\n     pub statics: Vec<Static<'hir>>,\n     pub constants: Vec<Constant<'hir>>,\n     pub traits: Vec<Trait<'hir>>,\n-    pub vis: &'hir hir::Visibility,\n+    pub vis: &'hir hir::Visibility<'hir>,\n     pub impls: Vec<Impl<'hir>>,\n     pub foreigns: Vec<ForeignItem<'hir>>,\n     pub macros: Vec<Macro<'hir>>,\n@@ -41,7 +41,7 @@ impl Module<'hir> {\n     pub fn new(\n         name: Option<Name>,\n         attrs: &'hir [ast::Attribute],\n-        vis: &'hir hir::Visibility,\n+        vis: &'hir hir::Visibility<'hir>,\n     ) -> Module<'hir> {\n         Module {\n             name: name,\n@@ -83,31 +83,31 @@ pub enum StructType {\n }\n \n pub struct Struct<'hir> {\n-    pub vis: &'hir hir::Visibility,\n+    pub vis: &'hir hir::Visibility<'hir>,\n     pub id: hir::HirId,\n     pub struct_type: StructType,\n     pub name: Name,\n-    pub generics: &'hir hir::Generics,\n+    pub generics: &'hir hir::Generics<'hir>,\n     pub attrs: &'hir [ast::Attribute],\n     pub fields: &'hir [hir::StructField<'hir>],\n     pub whence: Span,\n }\n \n pub struct Union<'hir> {\n-    pub vis: &'hir hir::Visibility,\n+    pub vis: &'hir hir::Visibility<'hir>,\n     pub id: hir::HirId,\n     pub struct_type: StructType,\n     pub name: Name,\n-    pub generics: &'hir hir::Generics,\n+    pub generics: &'hir hir::Generics<'hir>,\n     pub attrs: &'hir [ast::Attribute],\n     pub fields: &'hir [hir::StructField<'hir>],\n     pub whence: Span,\n }\n \n pub struct Enum<'hir> {\n-    pub vis: &'hir hir::Visibility,\n+    pub vis: &'hir hir::Visibility<'hir>,\n     pub variants: Vec<Variant<'hir>>,\n-    pub generics: &'hir hir::Generics,\n+    pub generics: &'hir hir::Generics<'hir>,\n     pub attrs: &'hir [ast::Attribute],\n     pub id: hir::HirId,\n     pub whence: Span,\n@@ -123,54 +123,54 @@ pub struct Variant<'hir> {\n }\n \n pub struct Function<'hir> {\n-    pub decl: &'hir hir::FnDecl,\n+    pub decl: &'hir hir::FnDecl<'hir>,\n     pub attrs: &'hir [ast::Attribute],\n     pub id: hir::HirId,\n     pub name: Name,\n-    pub vis: &'hir hir::Visibility,\n+    pub vis: &'hir hir::Visibility<'hir>,\n     pub header: hir::FnHeader,\n     pub whence: Span,\n-    pub generics: &'hir hir::Generics,\n+    pub generics: &'hir hir::Generics<'hir>,\n     pub body: hir::BodyId,\n }\n \n pub struct Typedef<'hir> {\n-    pub ty: &'hir hir::Ty,\n-    pub gen: &'hir hir::Generics,\n+    pub ty: &'hir hir::Ty<'hir>,\n+    pub gen: &'hir hir::Generics<'hir>,\n     pub name: Name,\n     pub id: hir::HirId,\n     pub attrs: &'hir [ast::Attribute],\n     pub whence: Span,\n-    pub vis: &'hir hir::Visibility,\n+    pub vis: &'hir hir::Visibility<'hir>,\n }\n \n pub struct OpaqueTy<'hir> {\n-    pub opaque_ty: &'hir hir::OpaqueTy,\n+    pub opaque_ty: &'hir hir::OpaqueTy<'hir>,\n     pub name: Name,\n     pub id: hir::HirId,\n     pub attrs: &'hir [ast::Attribute],\n     pub whence: Span,\n-    pub vis: &'hir hir::Visibility,\n+    pub vis: &'hir hir::Visibility<'hir>,\n }\n \n #[derive(Debug)]\n pub struct Static<'hir> {\n-    pub type_: &'hir hir::Ty,\n+    pub type_: &'hir hir::Ty<'hir>,\n     pub mutability: hir::Mutability,\n     pub expr: hir::BodyId,\n     pub name: Name,\n     pub attrs: &'hir [ast::Attribute],\n-    pub vis: &'hir hir::Visibility,\n+    pub vis: &'hir hir::Visibility<'hir>,\n     pub id: hir::HirId,\n     pub whence: Span,\n }\n \n pub struct Constant<'hir> {\n-    pub type_: &'hir hir::Ty,\n+    pub type_: &'hir hir::Ty<'hir>,\n     pub expr: hir::BodyId,\n     pub name: Name,\n     pub attrs: &'hir [ast::Attribute],\n-    pub vis: &'hir hir::Visibility,\n+    pub vis: &'hir hir::Visibility<'hir>,\n     pub id: hir::HirId,\n     pub whence: Span,\n }\n@@ -180,41 +180,41 @@ pub struct Trait<'hir> {\n     pub unsafety: hir::Unsafety,\n     pub name: Name,\n     pub items: Vec<&'hir hir::TraitItem<'hir>>,\n-    pub generics: &'hir hir::Generics,\n-    pub bounds: &'hir [hir::GenericBound],\n+    pub generics: &'hir hir::Generics<'hir>,\n+    pub bounds: &'hir [hir::GenericBound<'hir>],\n     pub attrs: &'hir [ast::Attribute],\n     pub id: hir::HirId,\n     pub whence: Span,\n-    pub vis: &'hir hir::Visibility,\n+    pub vis: &'hir hir::Visibility<'hir>,\n }\n \n pub struct TraitAlias<'hir> {\n     pub name: Name,\n-    pub generics: &'hir hir::Generics,\n-    pub bounds: &'hir [hir::GenericBound],\n+    pub generics: &'hir hir::Generics<'hir>,\n+    pub bounds: &'hir [hir::GenericBound<'hir>],\n     pub attrs: &'hir [ast::Attribute],\n     pub id: hir::HirId,\n     pub whence: Span,\n-    pub vis: &'hir hir::Visibility,\n+    pub vis: &'hir hir::Visibility<'hir>,\n }\n \n #[derive(Debug)]\n pub struct Impl<'hir> {\n     pub unsafety: hir::Unsafety,\n     pub polarity: hir::ImplPolarity,\n     pub defaultness: hir::Defaultness,\n-    pub generics: &'hir hir::Generics,\n-    pub trait_: &'hir Option<hir::TraitRef>,\n-    pub for_: &'hir hir::Ty,\n+    pub generics: &'hir hir::Generics<'hir>,\n+    pub trait_: &'hir Option<hir::TraitRef<'hir>>,\n+    pub for_: &'hir hir::Ty<'hir>,\n     pub items: Vec<&'hir hir::ImplItem<'hir>>,\n     pub attrs: &'hir [ast::Attribute],\n     pub whence: Span,\n-    pub vis: &'hir hir::Visibility,\n+    pub vis: &'hir hir::Visibility<'hir>,\n     pub id: hir::HirId,\n }\n \n pub struct ForeignItem<'hir> {\n-    pub vis: &'hir hir::Visibility,\n+    pub vis: &'hir hir::Visibility<'hir>,\n     pub id: hir::HirId,\n     pub name: Name,\n     pub kind: &'hir hir::ForeignItemKind<'hir>,\n@@ -238,17 +238,17 @@ pub struct ExternCrate<'hir> {\n     pub name: Name,\n     pub cnum: CrateNum,\n     pub path: Option<String>,\n-    pub vis: &'hir hir::Visibility,\n+    pub vis: &'hir hir::Visibility<'hir>,\n     pub attrs: &'hir [ast::Attribute],\n     pub whence: Span,\n }\n \n pub struct Import<'hir> {\n     pub name: Name,\n     pub id: hir::HirId,\n-    pub vis: &'hir hir::Visibility,\n+    pub vis: &'hir hir::Visibility<'hir>,\n     pub attrs: &'hir [ast::Attribute],\n-    pub path: &'hir hir::Path,\n+    pub path: &'hir hir::Path<'hir>,\n     pub glob: bool,\n     pub whence: Span,\n }"}]}