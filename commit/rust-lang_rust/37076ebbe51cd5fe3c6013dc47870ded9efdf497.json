{"sha": "37076ebbe51cd5fe3c6013dc47870ded9efdf497", "node_id": "C_kwDOAAsO6NoAKDM3MDc2ZWJiZTUxY2Q1ZmUzYzYwMTNkYzQ3ODcwZGVkOWVmZGY0OTc", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-04-28T20:56:45Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-04-28T20:56:45Z"}, "message": "Rollup merge of #110927 - nnethercote:Encoder-Decoder-cleanups, r=scottmcm\n\nEncoder/decoder cleanups\n\nBest reviewed one commit at a time.\n\nr? ``@scottmcm``", "tree": {"sha": "b0b6437b484b9b2a9238a386bbb1f206844a004d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b0b6437b484b9b2a9238a386bbb1f206844a004d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/37076ebbe51cd5fe3c6013dc47870ded9efdf497", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkTDMNCRBK7hj4Ov3rIwAAdCoIADv/5A65HUxqZiVFWdgghdT5\nbaRt5B89H+/1krIhKnTMG5tLN/21l5XlPMXbsoMWhsxyhpdIbP+Qk071Zdx1U3Nu\nuQ2IWUKA4FtMDjlZKdbnTQpzon52nxK8Rh6bRUAplsq6472kmLj7LlGBogzj64b9\nLAxsiMGxot1j6bKq85/KxX4VjXRTvLVhaqN9zsGg/PcxShw7qqpCMLvnvp4bmxRc\nVmLMTepuk4RXgWD08hcvvB64y/7kYx6666j8X1mNdN9OgUE1wevkWr04zHpGq6E5\nhbKYrAt3KVW3ywl4puP9EpsXMo+M/ufnCLPrtWKfvCdKhizLkobRJmmUqJlBCGQ=\n=avYY\n-----END PGP SIGNATURE-----\n", "payload": "tree b0b6437b484b9b2a9238a386bbb1f206844a004d\nparent 4751c85e50bdb3ecf529fba2b50cff20330085ff\nparent 23e91d4d73785f6dfac6b6ac198dc45574cabc88\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1682715405 +0200\ncommitter GitHub <noreply@github.com> 1682715405 +0200\n\nRollup merge of #110927 - nnethercote:Encoder-Decoder-cleanups, r=scottmcm\n\nEncoder/decoder cleanups\n\nBest reviewed one commit at a time.\n\nr? ``@scottmcm``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/37076ebbe51cd5fe3c6013dc47870ded9efdf497", "html_url": "https://github.com/rust-lang/rust/commit/37076ebbe51cd5fe3c6013dc47870ded9efdf497", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/37076ebbe51cd5fe3c6013dc47870ded9efdf497/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4751c85e50bdb3ecf529fba2b50cff20330085ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/4751c85e50bdb3ecf529fba2b50cff20330085ff", "html_url": "https://github.com/rust-lang/rust/commit/4751c85e50bdb3ecf529fba2b50cff20330085ff"}, {"sha": "23e91d4d73785f6dfac6b6ac198dc45574cabc88", "url": "https://api.github.com/repos/rust-lang/rust/commits/23e91d4d73785f6dfac6b6ac198dc45574cabc88", "html_url": "https://github.com/rust-lang/rust/commit/23e91d4d73785f6dfac6b6ac198dc45574cabc88"}], "stats": {"total": 305, "additions": 130, "deletions": 175}, "files": [{"sha": "e220a0293393e6b0de8c6efc20bd622d43ab8a8a", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 37, "deletions": 41, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/37076ebbe51cd5fe3c6013dc47870ded9efdf497/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37076ebbe51cd5fe3c6013dc47870ded9efdf497/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=37076ebbe51cd5fe3c6013dc47870ded9efdf497", "patch": "@@ -26,7 +26,7 @@ use rustc_target::spec::abi::Abi;\n use smallvec::SmallVec;\n use std::fmt;\n \n-#[derive(Debug, Copy, Clone, Encodable, HashStable_Generic)]\n+#[derive(Debug, Copy, Clone, HashStable_Generic)]\n pub struct Lifetime {\n     pub hir_id: HirId,\n \n@@ -41,8 +41,7 @@ pub struct Lifetime {\n     pub res: LifetimeName,\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq, Encodable, Hash, Copy)]\n-#[derive(HashStable_Generic)]\n+#[derive(Debug, Copy, Clone, HashStable_Generic)]\n pub enum ParamName {\n     /// Some user-given name like `T` or `'x`.\n     Plain(Ident),\n@@ -85,8 +84,7 @@ impl ParamName {\n     }\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq, Encodable, Hash, Copy)]\n-#[derive(HashStable_Generic)]\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, HashStable_Generic)]\n pub enum LifetimeName {\n     /// User-given names or fresh (synthetic) names.\n     Param(LocalDefId),\n@@ -243,13 +241,13 @@ impl<'hir> PathSegment<'hir> {\n     }\n }\n \n-#[derive(Encodable, Clone, Copy, Debug, HashStable_Generic)]\n+#[derive(Clone, Copy, Debug, HashStable_Generic)]\n pub struct ConstArg {\n     pub value: AnonConst,\n     pub span: Span,\n }\n \n-#[derive(Encodable, Clone, Copy, Debug, HashStable_Generic)]\n+#[derive(Clone, Copy, Debug, HashStable_Generic)]\n pub struct InferArg {\n     pub hir_id: HirId,\n     pub span: Span,\n@@ -422,8 +420,7 @@ impl<'hir> GenericArgs<'hir> {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Encodable, Hash, Debug)]\n-#[derive(HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug, HashStable_Generic)]\n pub enum GenericArgsParentheses {\n     No,\n     /// Bounds for `feature(return_type_notation)`, like `T: Trait<method(..): Send>`,\n@@ -435,8 +432,7 @@ pub enum GenericArgsParentheses {\n \n /// A modifier on a bound, currently this is only used for `?Sized`, where the\n /// modifier is `Maybe`. Negative bounds should also be handled here.\n-#[derive(Copy, Clone, PartialEq, Eq, Encodable, Hash, Debug)]\n-#[derive(HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable_Generic)]\n pub enum TraitBoundModifier {\n     None,\n     Maybe,\n@@ -474,7 +470,7 @@ impl GenericBound<'_> {\n \n pub type GenericBounds<'hir> = &'hir [GenericBound<'hir>];\n \n-#[derive(Copy, Clone, PartialEq, Eq, Encodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, Debug, HashStable_Generic)]\n pub enum LifetimeParamKind {\n     // Indicates that the lifetime definition was explicitly declared (e.g., in\n     // `fn foo<'a>(x: &'a u8) -> &'a u8 { x }`).\n@@ -539,7 +535,7 @@ impl<'hir> GenericParam<'hir> {\n /// early-bound (but can be a late-bound lifetime in functions, for example),\n /// or from a `for<...>` binder, in which case it's late-bound (and notably,\n /// does not show up in the parent item's generics).\n-#[derive(Debug, HashStable_Generic, PartialEq, Eq, Copy, Clone)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub enum GenericParamSource {\n     // Early or late-bound parameters defined on an item\n     Generics,\n@@ -1097,7 +1093,7 @@ pub struct PatField<'hir> {\n     pub span: Span,\n }\n \n-#[derive(Copy, Clone, PartialEq, Encodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Debug, HashStable_Generic)]\n pub enum RangeEnd {\n     Included,\n     Excluded,\n@@ -1197,7 +1193,7 @@ pub enum PatKind<'hir> {\n     Slice(&'hir [Pat<'hir>], Option<&'hir Pat<'hir>>, &'hir [Pat<'hir>]),\n }\n \n-#[derive(Copy, Clone, PartialEq, Encodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Debug, HashStable_Generic)]\n pub enum BinOpKind {\n     /// The `+` operator (addition).\n     Add,\n@@ -1325,7 +1321,7 @@ impl Into<ast::BinOpKind> for BinOpKind {\n \n pub type BinOp = Spanned<BinOpKind>;\n \n-#[derive(Copy, Clone, PartialEq, Encodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Debug, HashStable_Generic)]\n pub enum UnOp {\n     /// The `*` operator (dereferencing).\n     Deref,\n@@ -1450,19 +1446,19 @@ pub struct ExprField<'hir> {\n     pub is_shorthand: bool,\n }\n \n-#[derive(Copy, Clone, PartialEq, Encodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Debug, HashStable_Generic)]\n pub enum BlockCheckMode {\n     DefaultBlock,\n     UnsafeBlock(UnsafeSource),\n }\n \n-#[derive(Copy, Clone, PartialEq, Encodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Debug, HashStable_Generic)]\n pub enum UnsafeSource {\n     CompilerGenerated,\n     UserProvided,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Encodable, Decodable, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub struct BodyId {\n     pub hir_id: HirId,\n }\n@@ -1506,7 +1502,7 @@ impl<'hir> Body<'hir> {\n }\n \n /// The type of source expression that caused this generator to be created.\n-#[derive(Clone, PartialEq, PartialOrd, Eq, Hash, Debug, Copy)]\n+#[derive(Clone, PartialEq, Eq, Debug, Copy, Hash)]\n #[derive(HashStable_Generic, Encodable, Decodable)]\n pub enum GeneratorKind {\n     /// An explicit `async` block or the body of an async function.\n@@ -1539,7 +1535,7 @@ impl GeneratorKind {\n ///\n /// This helps error messages but is also used to drive coercions in\n /// type-checking (see #60424).\n-#[derive(Clone, PartialEq, PartialOrd, Eq, Hash, Debug, Copy)]\n+#[derive(Clone, PartialEq, Eq, Hash, Debug, Copy)]\n #[derive(HashStable_Generic, Encodable, Decodable)]\n pub enum AsyncGeneratorKind {\n     /// An explicit `async` block written by the user.\n@@ -1649,7 +1645,7 @@ impl fmt::Display for ConstContext {\n /// A literal.\n pub type Lit = Spanned<LitKind>;\n \n-#[derive(Copy, Clone, PartialEq, Eq, Encodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, Debug, HashStable_Generic)]\n pub enum ArrayLen {\n     Infer(HirId, Span),\n     Body(AnonConst),\n@@ -1671,7 +1667,7 @@ impl ArrayLen {\n ///\n /// You can check if this anon const is a default in a const param\n /// `const N: usize = { ... }` with `tcx.hir().opt_const_param_default_param_def_id(..)`\n-#[derive(Copy, Clone, PartialEq, Eq, Encodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, Debug, HashStable_Generic)]\n pub struct AnonConst {\n     pub hir_id: HirId,\n     pub def_id: LocalDefId,\n@@ -2105,7 +2101,7 @@ impl<'hir> QPath<'hir> {\n }\n \n /// Hints at the original code for a let statement.\n-#[derive(Copy, Clone, Encodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, Debug, HashStable_Generic)]\n pub enum LocalSource {\n     /// A `match _ { .. }`.\n     Normal,\n@@ -2158,7 +2154,7 @@ impl MatchSource {\n }\n \n /// The loop type that yielded an `ExprKind::Loop`.\n-#[derive(Copy, Clone, PartialEq, Encodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Debug, HashStable_Generic)]\n pub enum LoopSource {\n     /// A `loop { .. }` loop.\n     Loop,\n@@ -2178,7 +2174,7 @@ impl LoopSource {\n     }\n }\n \n-#[derive(Copy, Clone, Encodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, Debug, HashStable_Generic)]\n pub enum LoopIdError {\n     OutsideLoopScope,\n     UnlabeledCfInWhileCondition,\n@@ -2197,7 +2193,7 @@ impl fmt::Display for LoopIdError {\n     }\n }\n \n-#[derive(Copy, Clone, Encodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, Debug, HashStable_Generic)]\n pub struct Destination {\n     /// This is `Some(_)` iff there is an explicit user-specified 'label\n     pub label: Option<Label>,\n@@ -2208,7 +2204,7 @@ pub struct Destination {\n }\n \n /// The yield kind that caused an `ExprKind::Yield`.\n-#[derive(Copy, Clone, PartialEq, Eq, Debug, Encodable, Decodable, HashStable_Generic)]\n+#[derive(Copy, Clone, Debug, HashStable_Generic)]\n pub enum YieldSource {\n     /// An `<expr>.await`.\n     Await { expr: Option<HirId> },\n@@ -2327,7 +2323,7 @@ impl<'hir> TraitItem<'hir> {\n }\n \n /// Represents a trait method's body (or just argument names).\n-#[derive(Encodable, Debug, Clone, Copy, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub enum TraitFn<'hir> {\n     /// No default body in the trait, just a signature.\n     Required(&'hir [Ident]),\n@@ -2658,7 +2654,7 @@ pub struct OpaqueTy<'hir> {\n }\n \n /// From whence the opaque type came.\n-#[derive(Copy, Clone, PartialEq, Eq, Encodable, Decodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug, HashStable_Generic)]\n pub enum OpaqueTyOrigin {\n     /// `-> impl Trait`\n     FnReturn(LocalDefId),\n@@ -2818,7 +2814,7 @@ impl ImplicitSelfKind {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Encodable, Decodable, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Encodable, Decodable, Debug)]\n #[derive(HashStable_Generic)]\n pub enum IsAsync {\n     Async,\n@@ -2831,7 +2827,7 @@ impl IsAsync {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, Encodable, Decodable, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug, Encodable, Decodable, HashStable_Generic)]\n pub enum Defaultness {\n     Default { has_value: bool },\n     Final,\n@@ -2887,13 +2883,13 @@ pub enum ClosureBinder {\n     For { span: Span },\n }\n \n-#[derive(Encodable, Debug, Clone, Copy, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct Mod<'hir> {\n     pub spans: ModSpans,\n     pub item_ids: &'hir [ItemId],\n }\n \n-#[derive(Copy, Clone, Debug, HashStable_Generic, Encodable)]\n+#[derive(Copy, Clone, Debug, HashStable_Generic)]\n pub struct ModSpans {\n     /// A span from the first token past `{` to the last token until `}`.\n     /// For `mod foo;`, the inner span ranges from the first token\n@@ -2922,7 +2918,7 @@ pub struct Variant<'hir> {\n     pub span: Span,\n }\n \n-#[derive(Copy, Clone, PartialEq, Encodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Debug, HashStable_Generic)]\n pub enum UseKind {\n     /// One import, e.g., `use foo::bar` or `use foo::bar as baz`.\n     /// Also produced for each element of a list `use`, e.g.\n@@ -3233,7 +3229,7 @@ impl fmt::Display for Unsafety {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n #[derive(Encodable, Decodable, HashStable_Generic)]\n pub enum Constness {\n     Const,\n@@ -3249,7 +3245,7 @@ impl fmt::Display for Constness {\n     }\n }\n \n-#[derive(Copy, Clone, Encodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, Debug, HashStable_Generic)]\n pub struct FnHeader {\n     pub unsafety: Unsafety,\n     pub constness: Constness,\n@@ -3381,7 +3377,7 @@ impl ItemKind<'_> {\n /// type or method, and whether it is public). This allows other\n /// passes to find the impl they want without loading the ID (which\n /// means fewer edges in the incremental compilation graph).\n-#[derive(Encodable, Debug, Clone, Copy, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct TraitItemRef {\n     pub id: TraitItemId,\n     pub ident: Ident,\n@@ -3405,7 +3401,7 @@ pub struct ImplItemRef {\n     pub trait_item_def_id: Option<DefId>,\n }\n \n-#[derive(Copy, Clone, PartialEq, Encodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Debug, HashStable_Generic)]\n pub enum AssocItemKind {\n     Const,\n     Fn { has_self: bool },\n@@ -3474,7 +3470,7 @@ pub enum ForeignItemKind<'hir> {\n }\n \n /// A variable captured by a closure.\n-#[derive(Debug, Copy, Clone, Encodable, HashStable_Generic)]\n+#[derive(Debug, Copy, Clone, HashStable_Generic)]\n pub struct Upvar {\n     /// First span where it is accessed (there can be multiple).\n     pub span: Span,\n@@ -3483,7 +3479,7 @@ pub struct Upvar {\n // The TraitCandidate's import_ids is empty if the trait is defined in the same module, and\n // has length > 0 if the trait is found through an chain of imports, starting with the\n // import/use statement in the scope where the trait is used.\n-#[derive(Encodable, Decodable, Debug, Clone, HashStable_Generic)]\n+#[derive(Debug, Clone, HashStable_Generic)]\n pub struct TraitCandidate {\n     pub def_id: DefId,\n     pub import_ids: SmallVec<[LocalDefId; 1]>,"}, {"sha": "10712e1468679aa7f037849daf7ea2e4579c4033", "filename": "compiler/rustc_middle/src/middle/region.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37076ebbe51cd5fe3c6013dc47870ded9efdf497/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37076ebbe51cd5fe3c6013dc47870ded9efdf497/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fregion.rs?ref=37076ebbe51cd5fe3c6013dc47870ded9efdf497", "patch": "@@ -203,7 +203,7 @@ impl Scope {\n pub type ScopeDepth = u32;\n \n /// The region scope tree encodes information about region relationships.\n-#[derive(TyEncodable, TyDecodable, Default, Debug)]\n+#[derive(Default, Debug)]\n pub struct ScopeTree {\n     /// If not empty, this body is the root of this region hierarchy.\n     pub root_body: Option<hir::HirId>,\n@@ -317,13 +317,13 @@ pub struct ScopeTree {\n /// candidates in general). In constants, the `lifetime` field is None\n /// to indicate that certain expressions escape into 'static and\n /// should have no local cleanup scope.\n-#[derive(Debug, Copy, Clone, TyEncodable, TyDecodable, HashStable)]\n+#[derive(Debug, Copy, Clone, HashStable)]\n pub enum RvalueCandidateType {\n     Borrow { target: hir::ItemLocalId, lifetime: Option<Scope> },\n     Pattern { target: hir::ItemLocalId, lifetime: Option<Scope> },\n }\n \n-#[derive(Debug, Copy, Clone, TyEncodable, TyDecodable, HashStable)]\n+#[derive(Debug, Copy, Clone, HashStable)]\n pub struct YieldData {\n     /// The `Span` of the yield.\n     pub span: Span,"}, {"sha": "d69d42bb5d389ca8f66da66ca223a6a1c0eb37bf", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/37076ebbe51cd5fe3c6013dc47870ded9efdf497/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37076ebbe51cd5fe3c6013dc47870ded9efdf497/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=37076ebbe51cd5fe3c6013dc47870ded9efdf497", "patch": "@@ -199,15 +199,15 @@ impl<'tcx> ObligationCause<'tcx> {\n     }\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq, Hash, Lift, HashStable, TyEncodable, TyDecodable)]\n+#[derive(Clone, Debug, PartialEq, Eq, Lift, HashStable, TyEncodable, TyDecodable)]\n #[derive(TypeVisitable, TypeFoldable)]\n pub struct UnifyReceiverContext<'tcx> {\n     pub assoc_item: ty::AssocItem,\n     pub param_env: ty::ParamEnv<'tcx>,\n     pub substs: SubstsRef<'tcx>,\n }\n \n-#[derive(Clone, PartialEq, Eq, Hash, Lift, Default, HashStable)]\n+#[derive(Clone, PartialEq, Eq, Lift, Default, HashStable)]\n #[derive(TypeVisitable, TypeFoldable, TyEncodable, TyDecodable)]\n pub struct InternedObligationCauseCode<'tcx> {\n     /// `None` for `ObligationCauseCode::MiscObligation` (a common case, occurs ~60% of\n@@ -243,7 +243,7 @@ impl<'tcx> std::ops::Deref for InternedObligationCauseCode<'tcx> {\n     }\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq, Hash, Lift, HashStable, TyEncodable, TyDecodable)]\n+#[derive(Clone, Debug, PartialEq, Eq, Lift, HashStable, TyEncodable, TyDecodable)]\n #[derive(TypeVisitable, TypeFoldable)]\n pub enum ObligationCauseCode<'tcx> {\n     /// Not well classified or should be obvious from the span.\n@@ -468,7 +468,7 @@ pub enum WellFormedLoc {\n     },\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq, Hash, Lift, HashStable, TyEncodable, TyDecodable)]\n+#[derive(Clone, Debug, PartialEq, Eq, Lift, HashStable, TyEncodable, TyDecodable)]\n #[derive(TypeVisitable, TypeFoldable)]\n pub struct ImplDerivedObligationCause<'tcx> {\n     pub derived: DerivedObligationCause<'tcx>,\n@@ -529,7 +529,7 @@ impl<'tcx> ty::Lift<'tcx> for StatementAsExpression {\n     }\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq, Hash, Lift, HashStable, TyEncodable, TyDecodable)]\n+#[derive(Clone, Debug, PartialEq, Eq, Lift, HashStable, TyEncodable, TyDecodable)]\n #[derive(TypeVisitable, TypeFoldable)]\n pub struct MatchExpressionArmCause<'tcx> {\n     pub arm_block_id: Option<hir::HirId>,\n@@ -545,7 +545,7 @@ pub struct MatchExpressionArmCause<'tcx> {\n     pub opt_suggest_box_span: Option<Span>,\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n #[derive(Lift, TypeFoldable, TypeVisitable, HashStable, TyEncodable, TyDecodable)]\n pub struct IfExpressionCause<'tcx> {\n     pub then_id: hir::HirId,\n@@ -556,7 +556,7 @@ pub struct IfExpressionCause<'tcx> {\n     pub opt_suggest_box_span: Option<Span>,\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq, Hash, Lift, HashStable, TyEncodable, TyDecodable)]\n+#[derive(Clone, Debug, PartialEq, Eq, Lift, HashStable, TyEncodable, TyDecodable)]\n #[derive(TypeVisitable, TypeFoldable)]\n pub struct DerivedObligationCause<'tcx> {\n     /// The trait predicate of the parent obligation that led to the"}, {"sha": "6187fc43cf88b52befe1221c4cb9279e56318ba6", "filename": "compiler/rustc_middle/src/ty/adt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37076ebbe51cd5fe3c6013dc47870ded9efdf497/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37076ebbe51cd5fe3c6013dc47870ded9efdf497/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs?ref=37076ebbe51cd5fe3c6013dc47870ded9efdf497", "patch": "@@ -188,7 +188,7 @@ impl<'tcx> AdtDef<'tcx> {\n     }\n }\n \n-#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash, HashStable, TyEncodable, TyDecodable)]\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, HashStable, TyEncodable, TyDecodable)]\n pub enum AdtKind {\n     Struct,\n     Union,"}, {"sha": "0f6e4b329b87e5d4b7dc70e4b048d86a9eac65d0", "filename": "compiler/rustc_serialize/src/opaque.rs", "status": "modified", "additions": 21, "deletions": 115, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/37076ebbe51cd5fe3c6013dc47870ded9efdf497/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37076ebbe51cd5fe3c6013dc47870ded9efdf497/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs?ref=37076ebbe51cd5fe3c6013dc47870ded9efdf497", "patch": "@@ -51,13 +51,6 @@ macro_rules! write_leb128 {\n     }};\n }\n \n-/// A byte that [cannot occur in UTF8 sequences][utf8]. Used to mark the end of a string.\n-/// This way we can skip validation and still be relatively sure that deserialization\n-/// did not desynchronize.\n-///\n-/// [utf8]: https://en.wikipedia.org/w/index.php?title=UTF-8&oldid=1058865525#Codepage_layout\n-const STR_SENTINEL: u8 = 0xC1;\n-\n impl Encoder for MemEncoder {\n     #[inline]\n     fn emit_usize(&mut self, v: usize) {\n@@ -114,28 +107,6 @@ impl Encoder for MemEncoder {\n         self.data.extend_from_slice(&v.to_le_bytes());\n     }\n \n-    #[inline]\n-    fn emit_i8(&mut self, v: i8) {\n-        self.emit_u8(v as u8);\n-    }\n-\n-    #[inline]\n-    fn emit_bool(&mut self, v: bool) {\n-        self.emit_u8(if v { 1 } else { 0 });\n-    }\n-\n-    #[inline]\n-    fn emit_char(&mut self, v: char) {\n-        self.emit_u32(v as u32);\n-    }\n-\n-    #[inline]\n-    fn emit_str(&mut self, v: &str) {\n-        self.emit_usize(v.len());\n-        self.emit_raw_bytes(v.as_bytes());\n-        self.emit_u8(STR_SENTINEL);\n-    }\n-\n     #[inline]\n     fn emit_raw_bytes(&mut self, s: &[u8]) {\n         self.data.extend_from_slice(s);\n@@ -480,28 +451,6 @@ impl Encoder for FileEncoder {\n         self.write_all(&v.to_le_bytes());\n     }\n \n-    #[inline]\n-    fn emit_i8(&mut self, v: i8) {\n-        self.emit_u8(v as u8);\n-    }\n-\n-    #[inline]\n-    fn emit_bool(&mut self, v: bool) {\n-        self.emit_u8(if v { 1 } else { 0 });\n-    }\n-\n-    #[inline]\n-    fn emit_char(&mut self, v: char) {\n-        self.emit_u32(v as u32);\n-    }\n-\n-    #[inline]\n-    fn emit_str(&mut self, v: &str) {\n-        self.emit_usize(v.len());\n-        self.emit_raw_bytes(v.as_bytes());\n-        self.emit_u8(STR_SENTINEL);\n-    }\n-\n     #[inline]\n     fn emit_raw_bytes(&mut self, s: &[u8]) {\n         self.write_all(s);\n@@ -555,40 +504,11 @@ impl<'a> MemDecoder<'a> {\n         panic!(\"MemDecoder exhausted\")\n     }\n \n-    #[inline]\n-    fn read_byte(&mut self) -> u8 {\n-        if self.current == self.end {\n-            Self::decoder_exhausted();\n-        }\n-        // SAFETY: This type guarantees current <= end, and we just checked current == end.\n-        unsafe {\n-            let byte = *self.current;\n-            self.current = self.current.add(1);\n-            byte\n-        }\n-    }\n-\n     #[inline]\n     fn read_array<const N: usize>(&mut self) -> [u8; N] {\n         self.read_raw_bytes(N).try_into().unwrap()\n     }\n \n-    // The trait method doesn't have a lifetime parameter, and we need a version of this\n-    // that definitely returns a slice based on the underlying storage as opposed to\n-    // the Decoder itself in order to implement read_str efficiently.\n-    #[inline]\n-    fn read_raw_bytes_inherent(&mut self, bytes: usize) -> &'a [u8] {\n-        if bytes > self.remaining() {\n-            Self::decoder_exhausted();\n-        }\n-        // SAFETY: We just checked if this range is in-bounds above.\n-        unsafe {\n-            let slice = std::slice::from_raw_parts(self.current, bytes);\n-            self.current = self.current.add(bytes);\n-            slice\n-        }\n-    }\n-\n     /// While we could manually expose manipulation of the decoder position,\n     /// all current users of that method would need to reset the position later,\n     /// incurring the bounds check of set_position twice.\n@@ -653,7 +573,15 @@ impl<'a> Decoder for MemDecoder<'a> {\n \n     #[inline]\n     fn read_u8(&mut self) -> u8 {\n-        self.read_byte()\n+        if self.current == self.end {\n+            Self::decoder_exhausted();\n+        }\n+        // SAFETY: This type guarantees current <= end, and we just checked current == end.\n+        unsafe {\n+            let byte = *self.current;\n+            self.current = self.current.add(1);\n+            byte\n+        }\n     }\n \n     #[inline]\n@@ -681,39 +609,22 @@ impl<'a> Decoder for MemDecoder<'a> {\n         i16::from_le_bytes(self.read_array())\n     }\n \n-    #[inline]\n-    fn read_i8(&mut self) -> i8 {\n-        self.read_byte() as i8\n-    }\n-\n     #[inline]\n     fn read_isize(&mut self) -> isize {\n         read_leb128!(self, read_isize_leb128)\n     }\n \n     #[inline]\n-    fn read_bool(&mut self) -> bool {\n-        let value = self.read_u8();\n-        value != 0\n-    }\n-\n-    #[inline]\n-    fn read_char(&mut self) -> char {\n-        let bits = self.read_u32();\n-        std::char::from_u32(bits).unwrap()\n-    }\n-\n-    #[inline]\n-    fn read_str(&mut self) -> &str {\n-        let len = self.read_usize();\n-        let bytes = self.read_raw_bytes_inherent(len + 1);\n-        assert!(bytes[len] == STR_SENTINEL);\n-        unsafe { std::str::from_utf8_unchecked(&bytes[..len]) }\n-    }\n-\n-    #[inline]\n-    fn read_raw_bytes(&mut self, bytes: usize) -> &[u8] {\n-        self.read_raw_bytes_inherent(bytes)\n+    fn read_raw_bytes(&mut self, bytes: usize) -> &'a [u8] {\n+        if bytes > self.remaining() {\n+            Self::decoder_exhausted();\n+        }\n+        // SAFETY: We just checked if this range is in-bounds above.\n+        unsafe {\n+            let slice = std::slice::from_raw_parts(self.current, bytes);\n+            self.current = self.current.add(bytes);\n+            slice\n+        }\n     }\n \n     #[inline]\n@@ -787,12 +698,7 @@ impl Encodable<FileEncoder> for IntEncodedWithFixedSize {\n impl<'a> Decodable<MemDecoder<'a>> for IntEncodedWithFixedSize {\n     #[inline]\n     fn decode(decoder: &mut MemDecoder<'a>) -> IntEncodedWithFixedSize {\n-        let _start_pos = decoder.position();\n-        let bytes = decoder.read_raw_bytes(IntEncodedWithFixedSize::ENCODED_SIZE);\n-        let value = u64::from_le_bytes(bytes.try_into().unwrap());\n-        let _end_pos = decoder.position();\n-        debug_assert_eq!((_end_pos - _start_pos), IntEncodedWithFixedSize::ENCODED_SIZE);\n-\n-        IntEncodedWithFixedSize(value)\n+        let bytes = decoder.read_array::<{ IntEncodedWithFixedSize::ENCODED_SIZE }>();\n+        IntEncodedWithFixedSize(u64::from_le_bytes(bytes))\n     }\n }"}, {"sha": "e1bc598736fee7fc8aba85d26904cd5e20588f2f", "filename": "compiler/rustc_serialize/src/serialize.rs", "status": "modified", "additions": 61, "deletions": 8, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/37076ebbe51cd5fe3c6013dc47870ded9efdf497/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37076ebbe51cd5fe3c6013dc47870ded9efdf497/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs?ref=37076ebbe51cd5fe3c6013dc47870ded9efdf497", "patch": "@@ -12,6 +12,13 @@ use std::path;\n use std::rc::Rc;\n use std::sync::Arc;\n \n+/// A byte that [cannot occur in UTF8 sequences][utf8]. Used to mark the end of a string.\n+/// This way we can skip validation and still be relatively sure that deserialization\n+/// did not desynchronize.\n+///\n+/// [utf8]: https://en.wikipedia.org/w/index.php?title=UTF-8&oldid=1058865525#Codepage_layout\n+const STR_SENTINEL: u8 = 0xC1;\n+\n /// A note about error handling.\n ///\n /// Encoders may be fallible, but in practice failure is rare and there are so\n@@ -40,10 +47,29 @@ pub trait Encoder {\n     fn emit_i64(&mut self, v: i64);\n     fn emit_i32(&mut self, v: i32);\n     fn emit_i16(&mut self, v: i16);\n-    fn emit_i8(&mut self, v: i8);\n-    fn emit_bool(&mut self, v: bool);\n-    fn emit_char(&mut self, v: char);\n-    fn emit_str(&mut self, v: &str);\n+\n+    #[inline]\n+    fn emit_i8(&mut self, v: i8) {\n+        self.emit_u8(v as u8);\n+    }\n+\n+    #[inline]\n+    fn emit_bool(&mut self, v: bool) {\n+        self.emit_u8(if v { 1 } else { 0 });\n+    }\n+\n+    #[inline]\n+    fn emit_char(&mut self, v: char) {\n+        self.emit_u32(v as u32);\n+    }\n+\n+    #[inline]\n+    fn emit_str(&mut self, v: &str) {\n+        self.emit_usize(v.len());\n+        self.emit_raw_bytes(v.as_bytes());\n+        self.emit_u8(STR_SENTINEL);\n+    }\n+\n     fn emit_raw_bytes(&mut self, s: &[u8]);\n \n     fn emit_enum_variant<F>(&mut self, v_id: usize, f: F)\n@@ -79,11 +105,38 @@ pub trait Decoder {\n     fn read_i64(&mut self) -> i64;\n     fn read_i32(&mut self) -> i32;\n     fn read_i16(&mut self) -> i16;\n-    fn read_i8(&mut self) -> i8;\n-    fn read_bool(&mut self) -> bool;\n-    fn read_char(&mut self) -> char;\n-    fn read_str(&mut self) -> &str;\n+\n+    #[inline]\n+    fn read_i8(&mut self) -> i8 {\n+        self.read_u8() as i8\n+    }\n+\n+    #[inline]\n+    fn read_bool(&mut self) -> bool {\n+        let value = self.read_u8();\n+        value != 0\n+    }\n+\n+    #[inline]\n+    fn read_char(&mut self) -> char {\n+        let bits = self.read_u32();\n+        std::char::from_u32(bits).unwrap()\n+    }\n+\n+    #[inline]\n+    fn read_str(&mut self) -> &str {\n+        let len = self.read_usize();\n+        let bytes = self.read_raw_bytes(len + 1);\n+        assert!(bytes[len] == STR_SENTINEL);\n+        unsafe { std::str::from_utf8_unchecked(&bytes[..len]) }\n+    }\n+\n     fn read_raw_bytes(&mut self, len: usize) -> &[u8];\n+\n+    // Although there is an `emit_enum_variant` method in `Encoder`, the code\n+    // patterns in decoding are different enough to encoding that there is no\n+    // need for a corresponding `read_enum_variant` method here.\n+\n     fn peek_byte(&self) -> u8;\n     fn position(&self) -> usize;\n }"}]}