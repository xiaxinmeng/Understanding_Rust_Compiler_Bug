{"sha": "4d3ad04a9c84ac70c15465c1124c4d4dbef3b772", "node_id": "C_kwDOAAsO6NoAKDRkM2FkMDRhOWM4NGFjNzBjMTU0NjVjMTEyNGM0ZDRkYmVmM2I3NzI", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-12-28T13:52:52Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-12-28T13:52:52Z"}, "message": "Merge #11131\n\n11131: internal: avoid speculation when completing macros r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "24e1b585931570bc268d30ba8e54d45bfb5d5aa6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/24e1b585931570bc268d30ba8e54d45bfb5d5aa6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4d3ad04a9c84ac70c15465c1124c4d4dbef3b772", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhyxa0CRBK7hj4Ov3rIwAA6swIAHnlJw6c2t+z3sK/+jhngUmI\n1654YnQDk9Ue5zItXRbciZQcVnt61U6VqrIZqQdp4YGyB3RnljV3rTC9iXfwQyju\nu+FnuW+OlKNojTcgUtdv1bOWVUvgah8IJjqPwTcMJ0DIpvV1mez4PQzJDupWUUbT\n77AyhlDs0m5VnNfx+kRPrTKQwtNNBFXjDyWYeOtHUZwLcA6TBuP5PjRbvMmwHmqz\nG0qkykgNw2mJ3Pi99ySzYHWEOSCQUATC6Bdz1L9IOq7WO1DNlSkJiDNUlZug9IiZ\nti7eAVZhiDI72Ovtjh+lCnHcaCCP7a9Ftm2EOYf6VJ/7+vgj2Bt0RyRDFfEeOGY=\n=fWWr\n-----END PGP SIGNATURE-----\n", "payload": "tree 24e1b585931570bc268d30ba8e54d45bfb5d5aa6\nparent d6c307001785447b65aa3ab33217e9759e7b8b41\nparent 177a183e85467390bff24df6d72dbe0c9831d26a\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1640699572 +0000\ncommitter GitHub <noreply@github.com> 1640699572 +0000\n\nMerge #11131\n\n11131: internal: avoid speculation when completing macros r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4d3ad04a9c84ac70c15465c1124c4d4dbef3b772", "html_url": "https://github.com/rust-lang/rust/commit/4d3ad04a9c84ac70c15465c1124c4d4dbef3b772", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4d3ad04a9c84ac70c15465c1124c4d4dbef3b772/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d6c307001785447b65aa3ab33217e9759e7b8b41", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6c307001785447b65aa3ab33217e9759e7b8b41", "html_url": "https://github.com/rust-lang/rust/commit/d6c307001785447b65aa3ab33217e9759e7b8b41"}, {"sha": "177a183e85467390bff24df6d72dbe0c9831d26a", "url": "https://api.github.com/repos/rust-lang/rust/commits/177a183e85467390bff24df6d72dbe0c9831d26a", "html_url": "https://github.com/rust-lang/rust/commit/177a183e85467390bff24df6d72dbe0c9831d26a"}], "stats": {"total": 83, "additions": 50, "deletions": 33}, "files": [{"sha": "1070a26c26efa632f45ffd3e1510d37bc33036b1", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 33, "deletions": 17, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/4d3ad04a9c84ac70c15465c1124c4d4dbef3b772/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d3ad04a9c84ac70c15465c1124c4d4dbef3b772/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=4d3ad04a9c84ac70c15465c1124c4d4dbef3b772", "patch": "@@ -10,7 +10,7 @@ use hir_def::{\n     resolver::{self, HasResolver, Resolver, TypeNs},\n     AsMacroCall, FunctionId, TraitId, VariantId,\n };\n-use hir_expand::{name::AsName, ExpansionInfo};\n+use hir_expand::{name::AsName, ExpansionInfo, MacroCallId, MacroCallLoc};\n use hir_ty::{associated_type_shorthand_candidates, Interner};\n use itertools::Itertools;\n use rustc_hash::{FxHashMap, FxHashSet};\n@@ -160,6 +160,10 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.expand_attr_macro(item)\n     }\n \n+    pub fn resolve_derive_macro(&self, derive: &ast::Attr) -> Option<Vec<MacroDef>> {\n+        self.imp.resolve_derive_macro(derive)\n+    }\n+\n     pub fn expand_derive_macro(&self, derive: &ast::Attr) -> Option<Vec<SyntaxNode>> {\n         self.imp.expand_derive_macro(derive)\n     }\n@@ -443,28 +447,40 @@ impl<'db> SemanticsImpl<'db> {\n         Some(node)\n     }\n \n+    fn resolve_derive_macro(&self, attr: &ast::Attr) -> Option<Vec<MacroDef>> {\n+        let res = self\n+            .derive_macro_calls(attr)?\n+            .iter()\n+            .map(|&call| {\n+                let loc: MacroCallLoc = self.db.lookup_intern_macro_call(call);\n+                MacroDef { id: loc.def }\n+            })\n+            .collect();\n+        Some(res)\n+    }\n+\n     fn expand_derive_macro(&self, attr: &ast::Attr) -> Option<Vec<SyntaxNode>> {\n+        let res: Vec<_> = self\n+            .derive_macro_calls(attr)?\n+            .iter()\n+            .map(|call| call.as_file())\n+            .flat_map(|file_id| {\n+                let node = self.db.parse_or_expand(file_id)?;\n+                self.cache(node.clone(), file_id);\n+                Some(node)\n+            })\n+            .collect();\n+        Some(res)\n+    }\n+\n+    fn derive_macro_calls(&self, attr: &ast::Attr) -> Option<Vec<MacroCallId>> {\n         let item = attr.syntax().parent().and_then(ast::Item::cast)?;\n         let file_id = self.find_file(item.syntax()).file_id;\n         let item = InFile::new(file_id, &item);\n         let src = InFile::new(file_id, attr.clone());\n         self.with_ctx(|ctx| {\n-            let macro_call_ids = ctx.attr_to_derive_macro_call(item, src)?;\n-\n-            let expansions: Vec<_> = macro_call_ids\n-                .iter()\n-                .map(|call| call.as_file())\n-                .flat_map(|file_id| {\n-                    let node = self.db.parse_or_expand(file_id)?;\n-                    self.cache(node.clone(), file_id);\n-                    Some(node)\n-                })\n-                .collect();\n-            if expansions.is_empty() {\n-                None\n-            } else {\n-                Some(expansions)\n-            }\n+            let res = ctx.attr_to_derive_macro_call(item, src)?;\n+            Some(res.to_vec())\n         })\n     }\n "}, {"sha": "d763878834f61086df53895bac84ab20ea3dcc88", "filename": "crates/ide_completion/src/completions/attribute.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4d3ad04a9c84ac70c15465c1124c4d4dbef3b772/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d3ad04a9c84ac70c15465c1124c4d4dbef3b772/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute.rs?ref=4d3ad04a9c84ac70c15465c1124c4d4dbef3b772", "patch": "@@ -26,15 +26,15 @@ mod lint;\n mod repr;\n \n pub(crate) fn complete_attribute(acc: &mut Completions, ctx: &CompletionContext) -> Option<()> {\n-    let attribute = ctx.attribute_under_caret.as_ref()?;\n+    let attribute = ctx.fake_attribute_under_caret.as_ref()?;\n     let name_ref = match attribute.path() {\n         Some(p) => Some(p.as_single_name_ref()?),\n         None => None,\n     };\n     match (name_ref, attribute.token_tree()) {\n         (Some(path), Some(tt)) if tt.l_paren_token().is_some() => match path.text().as_str() {\n             \"repr\" => repr::complete_repr(acc, ctx, tt),\n-            \"derive\" => derive::complete_derive(acc, ctx, &parse_tt_as_comma_sep_paths(tt)?),\n+            \"derive\" => derive::complete_derive(acc, ctx, ctx.attr.as_ref()?),\n             \"feature\" => lint::complete_lint(acc, ctx, &parse_tt_as_comma_sep_paths(tt)?, FEATURES),\n             \"allow\" | \"warn\" | \"deny\" | \"forbid\" => {\n                 let existing_lints = parse_tt_as_comma_sep_paths(tt)?;"}, {"sha": "8aaade350f0b5ca5c131f818a04e124adf48ae07", "filename": "crates/ide_completion/src/completions/attribute/derive.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4d3ad04a9c84ac70c15465c1124c4d4dbef3b772/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d3ad04a9c84ac70c15465c1124c4d4dbef3b772/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs?ref=4d3ad04a9c84ac70c15465c1124c4d4dbef3b772", "patch": "@@ -13,17 +13,10 @@ use crate::{\n     item::CompletionItem, Completions, ImportEdit,\n };\n \n-pub(super) fn complete_derive(\n-    acc: &mut Completions,\n-    ctx: &CompletionContext,\n-    existing_derives: &[ast::Path],\n-) {\n+pub(super) fn complete_derive(acc: &mut Completions, ctx: &CompletionContext, attr: &ast::Attr) {\n     let core = ctx.famous_defs().core();\n-    let existing_derives: FxHashSet<_> = existing_derives\n-        .into_iter()\n-        .filter_map(|path| ctx.scope.speculative_resolve_as_mac(&path))\n-        .filter(|mac| mac.kind() == MacroKind::Derive)\n-        .collect();\n+    let existing_derives: FxHashSet<_> =\n+        ctx.sema.resolve_derive_macro(attr).into_iter().flatten().collect();\n \n     for (name, mac) in get_derives_in_scope(ctx) {\n         if existing_derives.contains(&mac) {"}, {"sha": "6b013c912257b9867d962e6c0db0800794bb74b0", "filename": "crates/ide_completion/src/completions/keyword.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4d3ad04a9c84ac70c15465c1124c4d4dbef3b772/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d3ad04a9c84ac70c15465c1124c4d4dbef3b772/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs?ref=4d3ad04a9c84ac70c15465c1124c4d4dbef3b772", "patch": "@@ -19,7 +19,7 @@ pub(crate) fn complete_expr_keyword(acc: &mut Completions, ctx: &CompletionConte\n         cov_mark::hit!(no_keyword_completion_in_record_lit);\n         return;\n     }\n-    if ctx.attribute_under_caret.is_some() {\n+    if ctx.fake_attribute_under_caret.is_some() {\n         cov_mark::hit!(no_keyword_completion_in_attr_of_expr);\n         return;\n     }"}, {"sha": "6e43aa608ac62a2e58588577746481e7e6db9c42", "filename": "crates/ide_completion/src/context.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4d3ad04a9c84ac70c15465c1124c4d4dbef3b772/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d3ad04a9c84ac70c15465c1124c4d4dbef3b772/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcontext.rs?ref=4d3ad04a9c84ac70c15465c1124c4d4dbef3b772", "patch": "@@ -103,6 +103,7 @@ pub(crate) struct CompletionContext<'a> {\n \n     /// The parent function of the cursor position if it exists.\n     pub(super) function_def: Option<ast::Fn>,\n+    pub(super) attr: Option<ast::Attr>,\n     /// The parent impl of the cursor position if it exists.\n     pub(super) impl_def: Option<ast::Impl>,\n     /// The NameLike under the cursor in the original file if it exists.\n@@ -111,7 +112,7 @@ pub(crate) struct CompletionContext<'a> {\n \n     pub(super) completion_location: Option<ImmediateLocation>,\n     pub(super) prev_sibling: Option<ImmediatePrevSibling>,\n-    pub(super) attribute_under_caret: Option<ast::Attr>,\n+    pub(super) fake_attribute_under_caret: Option<ast::Attr>,\n     pub(super) previous_token: Option<SyntaxToken>,\n \n     pub(super) lifetime_ctx: Option<LifetimeContext>,\n@@ -397,13 +398,14 @@ impl<'a> CompletionContext<'a> {\n             expected_name: None,\n             expected_type: None,\n             function_def: None,\n+            attr: None,\n             impl_def: None,\n             name_syntax: None,\n             lifetime_ctx: None,\n             pattern_ctx: None,\n             completion_location: None,\n             prev_sibling: None,\n-            attribute_under_caret: None,\n+            fake_attribute_under_caret: None,\n             previous_token: None,\n             path_context: None,\n             locals,\n@@ -641,14 +643,20 @@ impl<'a> CompletionContext<'a> {\n         let fake_ident_token = file_with_fake_ident.token_at_offset(offset).right_biased().unwrap();\n         let syntax_element = NodeOrToken::Token(fake_ident_token);\n         self.previous_token = previous_token(syntax_element.clone());\n-        self.attribute_under_caret = syntax_element.ancestors().find_map(ast::Attr::cast);\n         self.no_completion_required = {\n             let inside_impl_trait_block = inside_impl_trait_block(syntax_element.clone());\n             let fn_is_prev = self.previous_token_is(T![fn]);\n             let for_is_prev2 = for_is_prev2(syntax_element.clone());\n             (fn_is_prev && !inside_impl_trait_block) || for_is_prev2\n         };\n \n+        self.attr = self\n+            .sema\n+            .token_ancestors_with_macros(self.token.clone())\n+            .take_while(|it| it.kind() != SOURCE_FILE && it.kind() != MODULE)\n+            .find_map(ast::Attr::cast);\n+        self.fake_attribute_under_caret = syntax_element.ancestors().find_map(ast::Attr::cast);\n+\n         self.incomplete_let =\n             syntax_element.ancestors().take(6).find_map(ast::LetStmt::cast).map_or(false, |it| {\n                 it.syntax().text_range().end() == syntax_element.text_range().end()"}]}