{"sha": "4d8f995c3a482fecdb9a77455cd8d68d514d62ac", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkOGY5OTVjM2E0ODJmZWNkYjlhNzc0NTVjZDhkNjhkNTE0ZDYyYWM=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-12-30T20:36:03Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-02-16T14:29:21Z"}, "message": "rustc: merge check_static into check_const.", "tree": {"sha": "b0e8399e734c0be82e21481db5f3e5a28024caa2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b0e8399e734c0be82e21481db5f3e5a28024caa2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4d8f995c3a482fecdb9a77455cd8d68d514d62ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4d8f995c3a482fecdb9a77455cd8d68d514d62ac", "html_url": "https://github.com/rust-lang/rust/commit/4d8f995c3a482fecdb9a77455cd8d68d514d62ac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4d8f995c3a482fecdb9a77455cd8d68d514d62ac/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8dd1f6a0dc59236caffb483fdb0176df1945062f", "url": "https://api.github.com/repos/rust-lang/rust/commits/8dd1f6a0dc59236caffb483fdb0176df1945062f", "html_url": "https://github.com/rust-lang/rust/commit/8dd1f6a0dc59236caffb483fdb0176df1945062f"}], "stats": {"total": 726, "additions": 316, "deletions": 410}, "files": [{"sha": "abf70813d36e783d3d25193c2b9f2e27874f65f1", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4d8f995c3a482fecdb9a77455cd8d68d514d62ac/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d8f995c3a482fecdb9a77455cd8d68d514d62ac/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=4d8f995c3a482fecdb9a77455cd8d68d514d62ac", "patch": "@@ -90,7 +90,6 @@ pub mod middle {\n     pub mod check_loop;\n     pub mod check_match;\n     pub mod check_rvalues;\n-    pub mod check_static;\n     pub mod const_eval;\n     pub mod dataflow;\n     pub mod dead;"}, {"sha": "34d1654ec4b69e685787db277685c9c1c38401b4", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 299, "deletions": 50, "changes": 349, "blob_url": "https://github.com/rust-lang/rust/blob/4d8f995c3a482fecdb9a77455cd8d68d514d62ac/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d8f995c3a482fecdb9a77455cd8d68d514d62ac/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=4d8f995c3a482fecdb9a77455cd8d68d514d62ac", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,91 +8,178 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// Verifies that the types and values of const and static items\n+// are safe. The rules enforced by this module are:\n+//\n+// - For each *mutable* static item, it checks that its **type**:\n+//     - doesn't have a destructor\n+//     - doesn't own an owned pointer\n+//\n+// - For each *immutable* static item, it checks that its **value**:\n+//       - doesn't own owned, managed pointers\n+//       - doesn't contain a struct literal or a call to an enum variant / struct constructor where\n+//           - the type of the struct/enum has a dtor\n+//\n+// Rules Enforced Elsewhere:\n+// - It's not possible to take the address of a static item with unsafe interior. This is enforced\n+// by borrowck::gather_loans\n \n-use middle::def::*;\n+use self::Mode::*;\n+\n+use middle::def;\n+use middle::expr_use_visitor as euv;\n+use middle::infer;\n+use middle::mem_categorization as mc;\n+use middle::traits;\n use middle::ty;\n use util::ppaux;\n \n use syntax::ast;\n+use syntax::codemap::Span;\n+use syntax::print::pprust;\n use syntax::visit::{self, Visitor};\n \n+#[derive(Copy, Eq, PartialEq)]\n+enum Mode {\n+    InConstant,\n+    InStatic,\n+    InStaticMut,\n+    InNothing,\n+}\n+\n struct CheckCrateVisitor<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n-    in_const: bool\n+    mode: Mode,\n }\n \n impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n-    fn with_const<F>(&mut self, in_const: bool, f: F) where\n+    fn with_mode<F>(&mut self, mode: Mode, f: F) where\n         F: FnOnce(&mut CheckCrateVisitor<'a, 'tcx>),\n     {\n-        let was_const = self.in_const;\n-        self.in_const = in_const;\n+        let old = self.mode;\n+        self.mode = mode;\n         f(self);\n-        self.in_const = was_const;\n+        self.mode = old;\n     }\n-    fn inside_const<F>(&mut self, f: F) where\n-        F: FnOnce(&mut CheckCrateVisitor<'a, 'tcx>),\n-    {\n-        self.with_const(true, f);\n+\n+    fn msg(&self) -> &'static str {\n+        match self.mode {\n+            InConstant => \"constant\",\n+            InStaticMut | InStatic => \"static\",\n+            InNothing => unreachable!(),\n+        }\n+    }\n+\n+    fn check_static_mut_type(&self, e: &ast::Expr) {\n+        let node_ty = ty::node_id_to_type(self.tcx, e.id);\n+        let tcontents = ty::type_contents(self.tcx, node_ty);\n+\n+        let suffix = if tcontents.has_dtor() {\n+            \"destructors\"\n+        } else if tcontents.owns_owned() {\n+            \"owned pointers\"\n+        } else {\n+            return\n+        };\n+\n+        self.tcx.sess.span_err(e.span, &format!(\"mutable statics are not allowed \\\n+                                                 to have {}\", suffix)[]);\n+    }\n+\n+    fn check_static_type(&self, e: &ast::Expr) {\n+        let ty = ty::node_id_to_type(self.tcx, e.id);\n+        let infcx = infer::new_infer_ctxt(self.tcx);\n+        let mut fulfill_cx = traits::FulfillmentContext::new();\n+        let cause = traits::ObligationCause::new(e.span, e.id, traits::SharedStatic);\n+        fulfill_cx.register_builtin_bound(&infcx, ty, ty::BoundSync, cause);\n+        let env = ty::empty_parameter_environment(self.tcx);\n+        match fulfill_cx.select_all_or_error(&infcx, &env) {\n+            Ok(()) => { },\n+            Err(ref errors) => {\n+                traits::report_fulfillment_errors(&infcx, errors);\n+            }\n+        }\n     }\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, i: &ast::Item) {\n+        debug!(\"visit_item(item={})\", pprust::item_to_string(i));\n         match i.node {\n-            ast::ItemStatic(_, _, ref ex) |\n-            ast::ItemConst(_, ref ex) => {\n-                self.inside_const(|v| v.visit_expr(&**ex));\n+            ast::ItemStatic(_, ast::MutImmutable, ref expr) => {\n+                self.check_static_type(&**expr);\n+                self.with_mode(InStatic, |v| v.visit_expr(&**expr));\n+            }\n+            ast::ItemStatic(_, ast::MutMutable, ref expr) => {\n+                self.check_static_mut_type(&**expr);\n+                self.with_mode(InStaticMut, |v| v.visit_expr(&**expr));\n+            }\n+            ast::ItemConst(_, ref expr) => {\n+                self.with_mode(InConstant, |v| v.visit_expr(&**expr));\n             }\n             ast::ItemEnum(ref enum_definition, _) => {\n-                self.inside_const(|v| {\n+                self.with_mode(InConstant, |v| {\n                     for var in &enum_definition.variants {\n                         if let Some(ref ex) = var.node.disr_expr {\n                             v.visit_expr(&**ex);\n                         }\n                     }\n                 });\n             }\n-            _ => self.with_const(false, |v| visit::walk_item(v, i))\n+            _ => {\n+                self.with_mode(InNothing, |v| visit::walk_item(v, i));\n+            }\n         }\n     }\n+\n     fn visit_pat(&mut self, p: &ast::Pat) {\n-        let is_const = match p.node {\n-            ast::PatLit(_) | ast::PatRange(..) => true,\n-            _ => false\n+        let mode = match p.node {\n+            ast::PatLit(_) | ast::PatRange(..) => InConstant,\n+            _ => InNothing\n         };\n-        self.with_const(is_const, |v| visit::walk_pat(v, p))\n+        self.with_mode(mode, |v| visit::walk_pat(v, p))\n     }\n+\n     fn visit_expr(&mut self, ex: &ast::Expr) {\n-        if self.in_const {\n+        if self.mode != InNothing {\n             check_expr(self, ex);\n         }\n         visit::walk_expr(self, ex);\n     }\n }\n \n-pub fn check_crate(tcx: &ty::ctxt) {\n-    visit::walk_crate(&mut CheckCrateVisitor { tcx: tcx, in_const: false },\n-                      tcx.map.krate());\n-    tcx.sess.abort_if_errors();\n-}\n-\n+/// This function is used to enforce the constraints on\n+/// const/static items. It walks through the *value*\n+/// of the item walking down the expression and evaluating\n+/// every nested expression. If the expression is not part\n+/// of a const/static item, this function does nothing but\n+/// walking down through it.\n fn check_expr(v: &mut CheckCrateVisitor, e: &ast::Expr) {\n+    let node_ty = ty::node_id_to_type(v.tcx, e.id);\n+\n+    match node_ty.sty {\n+        ty::ty_struct(did, _) |\n+        ty::ty_enum(did, _) if ty::has_dtor(v.tcx, did) => {\n+            v.tcx.sess.span_err(e.span,\n+                                &format!(\"{}s are not allowed to have destructors\",\n+                                         v.msg())[])\n+        }\n+        _ => {}\n+    }\n+\n     match e.node {\n-        ast::ExprUnary(ast::UnDeref, _) => {}\n+        ast::ExprBox(..) |\n         ast::ExprUnary(ast::UnUniq, _) => {\n             span_err!(v.tcx.sess, e.span, E0010,\n-                      \"cannot do allocations in constant expressions\");\n+                      \"allocations are not allowed in {}s\", v.msg());\n         }\n         ast::ExprBinary(..) | ast::ExprUnary(..) => {\n             let method_call = ty::MethodCall::expr(e.id);\n             if v.tcx.method_map.borrow().contains_key(&method_call) {\n                 span_err!(v.tcx.sess, e.span, E0011,\n-                          \"user-defined operators are not allowed in constant \\\n-                           expressions\");\n+                          \"user-defined operators are not allowed in {}s\", v.msg());\n             }\n         }\n-        ast::ExprLit(_) => {}\n         ast::ExprCast(ref from, _) => {\n             let toty = ty::expr_ty(v.tcx, e);\n             let fromty = ty::expr_ty(v.tcx, &**from);\n@@ -102,20 +189,24 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &ast::Expr) {\n                 (ty::type_is_bare_fn(toty) && ty::type_is_bare_fn_item(fromty));\n             if !is_legal_cast {\n                 span_err!(v.tcx.sess, e.span, E0012,\n-                          \"can not cast to `{}` in a constant expression\",\n-                          ppaux::ty_to_string(v.tcx, toty));\n+                          \"can not cast to `{}` in {}s\",\n+                          ppaux::ty_to_string(v.tcx, toty), v.msg());\n             }\n             if ty::type_is_unsafe_ptr(fromty) && ty::type_is_numeric(toty) {\n                 span_err!(v.tcx.sess, e.span, E0018,\n-                          \"can not cast a pointer to an integer in a constant \\\n-                           expression\");\n+                          \"can not cast a pointer to an integer in {}s\", v.msg());\n             }\n         }\n         ast::ExprPath(_) | ast::ExprQPath(_) => {\n             match v.tcx.def_map.borrow()[e.id] {\n-                DefStatic(..) | DefConst(..) |\n-                DefFn(..) | DefStaticMethod(..) | DefMethod(..) |\n-                DefStruct(_) | DefVariant(_, _, _) => {}\n+                def::DefStatic(..) if v.mode == InConstant => {\n+                    span_err!(v.tcx.sess, e.span, E0013,\n+                              \"constants cannot refer to other statics, \\\n+                               insert an intermediate constant instead\");\n+                }\n+                def::DefStatic(..) | def::DefConst(..) |\n+                def::DefFn(..) | def::DefStaticMethod(..) | def::DefMethod(..) |\n+                def::DefStruct(_) | def::DefVariant(_, _, _) => {}\n \n                 def => {\n                     debug!(\"(checking const) found bad def: {:?}\", def);\n@@ -127,7 +218,7 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &ast::Expr) {\n         }\n         ast::ExprCall(ref callee, _) => {\n             match v.tcx.def_map.borrow()[callee.id] {\n-                DefStruct(..) | DefVariant(..) => {}    // OK.\n+                def::DefStruct(..) | def::DefVariant(..) => {}    // OK.\n                 _ => {\n                     span_err!(v.tcx.sess, e.span, E0015,\n                               \"function calls in constants are limited to \\\n@@ -160,6 +251,17 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &ast::Expr) {\n                 }\n             }\n         }\n+        ast::ExprAddrOf(ast::MutMutable, ref inner) => {\n+            match inner.node {\n+                // Mutable slices are allowed. Only in `static mut`.\n+                ast::ExprVec(_) if v.mode == InStaticMut => {}\n+                _ => span_err!(v.tcx.sess, e.span, E0017,\n+                               \"references in {}s may only refer \\\n+                                to immutable values\", v.msg())\n+            }\n+        }\n+\n+        ast::ExprLit(_) |\n         ast::ExprVec(_) |\n         ast::ExprAddrOf(ast::MutImmutable, _) |\n         ast::ExprParen(..) |\n@@ -170,18 +272,165 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &ast::Expr) {\n         ast::ExprRepeat(..) |\n         ast::ExprStruct(..) => {}\n \n-        ast::ExprAddrOf(_, ref inner) => {\n-            match inner.node {\n-                // Mutable slices are allowed.\n-                ast::ExprVec(_) => {}\n-                _ => span_err!(v.tcx.sess, e.span, E0017,\n-                               \"references in constants may only refer \\\n-                                to immutable values\")\n+        // Conditional control flow (possible to implement).\n+        ast::ExprMatch(..) |\n+        ast::ExprIf(..) |\n+        ast::ExprIfLet(..) |\n \n-            }\n+        // Loops (not very meaningful in constants).\n+        ast::ExprWhile(..) |\n+        ast::ExprWhileLet(..) |\n+        ast::ExprForLoop(..) |\n+        ast::ExprLoop(..) |\n+\n+        // More control flow (also not very meaningful).\n+        ast::ExprBreak(_) |\n+        ast::ExprAgain(_) |\n+        ast::ExprRet(_) |\n+\n+        // Miscellaneous expressions that could be implemented.\n+        ast::ExprClosure(..) |\n+        ast::ExprRange(..) |\n+\n+        // Various other expressions.\n+        ast::ExprMethodCall(..) |\n+        ast::ExprAssign(..) |\n+        ast::ExprAssignOp(..) |\n+        ast::ExprInlineAsm(_) |\n+        ast::ExprMac(_) => {\n+            span_err!(v.tcx.sess, e.span, E0019,\n+                      \"{} contains unimplemented expression type\", v.msg());\n         }\n+    }\n+}\n \n-        _ => span_err!(v.tcx.sess, e.span, E0019,\n-                       \"constant contains unimplemented expression type\")\n+struct GlobalVisitor<'a,'b,'tcx:'a+'b>(\n+    euv::ExprUseVisitor<'a,'b,'tcx,ty::ParameterEnvironment<'b,'tcx>>);\n+\n+struct GlobalChecker<'a,'tcx:'a> {\n+    tcx: &'a ty::ctxt<'tcx>\n+}\n+\n+pub fn check_crate(tcx: &ty::ctxt) {\n+    let param_env = ty::empty_parameter_environment(tcx);\n+    let mut checker = GlobalChecker {\n+        tcx: tcx\n+    };\n+    let visitor = euv::ExprUseVisitor::new(&mut checker, &param_env);\n+    visit::walk_crate(&mut GlobalVisitor(visitor), tcx.map.krate());\n+\n+    visit::walk_crate(&mut CheckCrateVisitor {\n+        tcx: tcx,\n+        mode: InNothing,\n+    }, tcx.map.krate());\n+\n+    tcx.sess.abort_if_errors();\n+}\n+\n+impl<'a,'b,'t,'v> Visitor<'v> for GlobalVisitor<'a,'b,'t> {\n+    fn visit_item(&mut self, item: &ast::Item) {\n+        match item.node {\n+            ast::ItemConst(_, ref e) |\n+            ast::ItemStatic(_, _, ref e) => {\n+                let GlobalVisitor(ref mut v) = *self;\n+                v.consume_expr(&**e);\n+            }\n+            _ => {}\n+        }\n+        visit::walk_item(self, item);\n     }\n }\n+\n+impl<'a, 'tcx> euv::Delegate<'tcx> for GlobalChecker<'a, 'tcx> {\n+    fn consume(&mut self,\n+               _consume_id: ast::NodeId,\n+               consume_span: Span,\n+               cmt: mc::cmt,\n+               _mode: euv::ConsumeMode) {\n+        let mut cur = &cmt;\n+        loop {\n+            match cur.cat {\n+                mc::cat_static_item => {\n+                    // statics cannot be consumed by value at any time, that would imply\n+                    // that they're an initializer (what a const is for) or kept in sync\n+                    // over time (not feasible), so deny it outright.\n+                    self.tcx.sess.span_err(consume_span,\n+                        \"cannot refer to other statics by value, use the \\\n+                         address-of operator or a constant instead\");\n+                    break;\n+                }\n+                mc::cat_deref(ref cmt, _, _) |\n+                mc::cat_downcast(ref cmt, _) |\n+                mc::cat_interior(ref cmt, _) => cur = cmt,\n+\n+                mc::cat_rvalue(..) |\n+                mc::cat_upvar(..) |\n+                mc::cat_local(..) => break\n+            }\n+        }\n+    }\n+    fn borrow(&mut self,\n+              _borrow_id: ast::NodeId,\n+              borrow_span: Span,\n+              cmt: mc::cmt<'tcx>,\n+              _loan_region: ty::Region,\n+              _bk: ty::BorrowKind,\n+              _loan_cause: euv::LoanCause) {\n+        let mut cur = &cmt;\n+        let mut is_interior = false;\n+        loop {\n+            match cur.cat {\n+                mc::cat_rvalue(..) => {\n+                    // constants cannot be borrowed if they contain interior mutability as\n+                    // it means that our \"silent insertion of statics\" could change\n+                    // initializer values (very bad).\n+                    if ty::type_contents(self.tcx, cur.ty).interior_unsafe() {\n+                        self.tcx.sess.span_err(borrow_span,\n+                            \"cannot borrow a constant which contains \\\n+                            interior mutability, create a static instead\");\n+                    }\n+                    break;\n+                }\n+                mc::cat_static_item => {\n+                    if is_interior {\n+                        // Borrowed statics can specifically *only* have their address taken,\n+                        // not any number of other borrows such as borrowing fields, reading\n+                        // elements of an array, etc.\n+                        self.tcx.sess.span_err(borrow_span,\n+                            \"cannot refer to the interior of another \\\n+                             static, use a constant instead\");\n+                    }\n+                    break;\n+                }\n+                mc::cat_deref(ref cmt, _, _) |\n+                mc::cat_downcast(ref cmt, _) |\n+                mc::cat_interior(ref cmt, _) => {\n+                    is_interior = true;\n+                    cur = cmt;\n+                }\n+\n+                mc::cat_upvar(..) |\n+                mc::cat_local(..) => break\n+            }\n+        }\n+    }\n+\n+    fn decl_without_init(&mut self,\n+                         _id: ast::NodeId,\n+                         _span: Span) {}\n+    fn mutate(&mut self,\n+              _assignment_id: ast::NodeId,\n+              _assignment_span: Span,\n+              _assignee_cmt: mc::cmt,\n+              _mode: euv::MutateMode) {}\n+\n+    fn matched_pat(&mut self,\n+                   _: &ast::Pat,\n+                   _: mc::cmt,\n+                   _: euv::MatchMode) {}\n+\n+    fn consume_pat(&mut self,\n+                   _consume_pat: &ast::Pat,\n+                   _cmt: mc::cmt,\n+                   _mode: euv::ConsumeMode) {}\n+}\n\\ No newline at end of file"}, {"sha": "ac0caebd6cf056405379e3b6e37b46836bdaf3bb", "filename": "src/librustc/middle/check_static.rs", "status": "removed", "additions": 0, "deletions": 342, "changes": 342, "blob_url": "https://github.com/rust-lang/rust/blob/8dd1f6a0dc59236caffb483fdb0176df1945062f/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dd1f6a0dc59236caffb483fdb0176df1945062f/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs?ref=8dd1f6a0dc59236caffb483fdb0176df1945062f", "patch": "@@ -1,342 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Verifies that the types and values of static items\n-// are safe. The rules enforced by this module are:\n-//\n-// - For each *mutable* static item, it checks that its **type**:\n-//     - doesn't have a destructor\n-//     - doesn't own an owned pointer\n-//\n-// - For each *immutable* static item, it checks that its **value**:\n-//       - doesn't own owned, managed pointers\n-//       - doesn't contain a struct literal or a call to an enum variant / struct constructor where\n-//           - the type of the struct/enum has a dtor\n-//\n-// Rules Enforced Elsewhere:\n-// - It's not possible to take the address of a static item with unsafe interior. This is enforced\n-// by borrowck::gather_loans\n-use self::Mode::*;\n-\n-use middle::ty;\n-use middle::def;\n-use middle::infer;\n-use middle::traits;\n-use middle::mem_categorization as mc;\n-use middle::expr_use_visitor as euv;\n-use util::nodemap::NodeSet;\n-\n-use syntax::ast;\n-use syntax::print::pprust;\n-use syntax::visit::Visitor;\n-use syntax::codemap::Span;\n-use syntax::visit;\n-\n-#[derive(Copy, Eq, PartialEq)]\n-enum Mode {\n-    InConstant,\n-    InStatic,\n-    InStaticMut,\n-    InNothing,\n-}\n-\n-struct CheckStaticVisitor<'a, 'tcx: 'a> {\n-    tcx: &'a ty::ctxt<'tcx>,\n-    mode: Mode,\n-    checker: &'a mut GlobalChecker,\n-}\n-\n-struct GlobalVisitor<'a,'b,'tcx:'a+'b>(\n-    euv::ExprUseVisitor<'a,'b,'tcx,ty::ParameterEnvironment<'b,'tcx>>);\n-struct GlobalChecker {\n-    static_consumptions: NodeSet,\n-    const_borrows: NodeSet,\n-    static_interior_borrows: NodeSet,\n-    static_local_borrows: NodeSet,\n-}\n-\n-pub fn check_crate(tcx: &ty::ctxt) {\n-    let mut checker = GlobalChecker {\n-        static_consumptions: NodeSet(),\n-        const_borrows: NodeSet(),\n-        static_interior_borrows: NodeSet(),\n-        static_local_borrows: NodeSet(),\n-    };\n-    {\n-        let param_env = ty::empty_parameter_environment(tcx);\n-        let visitor = euv::ExprUseVisitor::new(&mut checker, &param_env);\n-        visit::walk_crate(&mut GlobalVisitor(visitor), tcx.map.krate());\n-    }\n-    visit::walk_crate(&mut CheckStaticVisitor {\n-        tcx: tcx,\n-        mode: InNothing,\n-        checker: &mut checker,\n-    }, tcx.map.krate());\n-    tcx.sess.abort_if_errors();\n-}\n-\n-impl<'a, 'tcx> CheckStaticVisitor<'a, 'tcx> {\n-    fn with_mode<F>(&mut self, mode: Mode, f: F) where\n-        F: FnOnce(&mut CheckStaticVisitor<'a, 'tcx>),\n-    {\n-        let old = self.mode;\n-        self.mode = mode;\n-        f(self);\n-        self.mode = old;\n-    }\n-\n-    fn msg(&self) -> &'static str {\n-        match self.mode {\n-            InConstant => \"constants\",\n-            InStaticMut | InStatic => \"statics\",\n-            InNothing => unreachable!(),\n-        }\n-    }\n-\n-    fn check_static_mut_type(&self, e: &ast::Expr) {\n-        let node_ty = ty::node_id_to_type(self.tcx, e.id);\n-        let tcontents = ty::type_contents(self.tcx, node_ty);\n-\n-        let suffix = if tcontents.has_dtor() {\n-            \"destructors\"\n-        } else if tcontents.owns_owned() {\n-            \"owned pointers\"\n-        } else {\n-            return\n-        };\n-\n-        self.tcx.sess.span_err(e.span, &format!(\"mutable statics are not allowed \\\n-                                                to have {}\", suffix)[]);\n-    }\n-\n-    fn check_static_type(&self, e: &ast::Expr) {\n-        let ty = ty::node_id_to_type(self.tcx, e.id);\n-        let infcx = infer::new_infer_ctxt(self.tcx);\n-        let mut fulfill_cx = traits::FulfillmentContext::new();\n-        let cause = traits::ObligationCause::new(e.span, e.id, traits::SharedStatic);\n-        fulfill_cx.register_builtin_bound(&infcx, ty, ty::BoundSync, cause);\n-        let env = ty::empty_parameter_environment(self.tcx);\n-        match fulfill_cx.select_all_or_error(&infcx, &env) {\n-            Ok(()) => { },\n-            Err(ref errors) => {\n-                traits::report_fulfillment_errors(&infcx, errors);\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx, 'v> Visitor<'v> for CheckStaticVisitor<'a, 'tcx> {\n-    fn visit_item(&mut self, i: &ast::Item) {\n-        debug!(\"visit_item(item={})\", pprust::item_to_string(i));\n-        match i.node {\n-            ast::ItemStatic(_, ast::MutImmutable, ref expr) => {\n-                self.check_static_type(&**expr);\n-                self.with_mode(InStatic, |v| v.visit_expr(&**expr));\n-            }\n-            ast::ItemStatic(_, ast::MutMutable, ref expr) => {\n-                self.check_static_mut_type(&**expr);\n-                self.with_mode(InStaticMut, |v| v.visit_expr(&**expr));\n-            }\n-            ast::ItemConst(_, ref expr) => {\n-                self.with_mode(InConstant, |v| v.visit_expr(&**expr));\n-            }\n-            _ => {\n-                self.with_mode(InNothing, |v| visit::walk_item(v, i));\n-            }\n-        }\n-    }\n-\n-    /// This method is used to enforce the constraints on\n-    /// immutable static items. It walks through the *value*\n-    /// of the item walking down the expression and evaluating\n-    /// every nested expression. if the expression is not part\n-    /// of a static item, this method does nothing but walking\n-    /// down through it.\n-    fn visit_expr(&mut self, e: &ast::Expr) {\n-        if self.mode == InNothing {\n-            return visit::walk_expr(self, e);\n-        }\n-\n-        let node_ty = ty::node_id_to_type(self.tcx, e.id);\n-\n-        match node_ty.sty {\n-            ty::ty_struct(did, _) |\n-            ty::ty_enum(did, _) if ty::has_dtor(self.tcx, did) => {\n-                self.tcx.sess.span_err(e.span,\n-                                       &format!(\"{} are not allowed to have \\\n-                                                destructors\", self.msg())[])\n-            }\n-            _ => {}\n-        }\n-\n-        // statics cannot be consumed by value at any time, that would imply\n-        // that they're an initializer (what a const is for) or kept in sync\n-        // over time (not feasible), so deny it outright.\n-        if self.checker.static_consumptions.remove(&e.id) {\n-            self.tcx.sess.span_err(e.span, \"cannot refer to other statics by \\\n-                                            value, use the address-of operator \\\n-                                            or a constant instead\");\n-        }\n-\n-        // Borrowed statics can specifically *only* have their address taken,\n-        // not any number of other borrows such as borrowing fields, reading\n-        // elements of an array, etc.\n-        if self.checker.static_interior_borrows.remove(&e.id) {\n-            self.tcx.sess.span_err(e.span, \"cannot refer to the interior of \\\n-                                            another static, use a constant \\\n-                                            instead\");\n-        }\n-\n-        // constants cannot be borrowed if they contain interior mutability as\n-        // it means that our \"silent insertion of statics\" could change\n-        // initializer values (very bad).\n-        if self.checker.const_borrows.remove(&e.id) {\n-            let node_ty = ty::node_id_to_type(self.tcx, e.id);\n-            let tcontents = ty::type_contents(self.tcx, node_ty);\n-            if tcontents.interior_unsafe() {\n-                self.tcx.sess.span_err(e.span, \"cannot borrow a constant which \\\n-                                                contains interior mutability, \\\n-                                                create a static instead\");\n-            }\n-        }\n-\n-        // local variables in a block expression in a static context (i.e. being\n-        // assigned to a static variable) cannot be borrowed.\n-        if self.checker.static_local_borrows.remove(&e.id) {\n-            self.tcx.sess.span_err(e.span, \"cannot borrow a local variable inside \\\n-                                            a static block, define a separate static \\\n-                                            instead\");\n-        }\n-\n-        match e.node {\n-            ast::ExprAddrOf(ast::MutMutable, _) => {\n-                if self.mode != InStaticMut {\n-                    span_err!(self.tcx.sess, e.span, E0020,\n-                              \"{} are not allowed to have mutable references\",\n-                              self.msg());\n-                }\n-            },\n-            ast::ExprBox(..) |\n-            ast::ExprUnary(ast::UnUniq, _) => {\n-                span_err!(self.tcx.sess, e.span, E0022,\n-                          \"{} are not allowed to have custom pointers\",\n-                          self.msg());\n-            }\n-            ast::ExprPath(_) | ast::ExprQPath(_) => {\n-                match ty::resolve_expr(self.tcx, e) {\n-                    def::DefStatic(..) if self.mode == InConstant => {\n-                        let msg = \"constants cannot refer to other statics, \\\n-                                   insert an intermediate constant \\\n-                                   instead\";\n-                        self.tcx.sess.span_err(e.span, &msg[]);\n-                    }\n-                    _ => {}\n-                }\n-            }\n-            _ => {}\n-        }\n-        visit::walk_expr(self, e);\n-    }\n-}\n-\n-impl<'a,'b,'t,'v> Visitor<'v> for GlobalVisitor<'a,'b,'t> {\n-    fn visit_item(&mut self, item: &ast::Item) {\n-        match item.node {\n-            ast::ItemConst(_, ref e) |\n-            ast::ItemStatic(_, _, ref e) => {\n-                let GlobalVisitor(ref mut v) = *self;\n-                v.consume_expr(&**e);\n-            }\n-            _ => {}\n-        }\n-        visit::walk_item(self, item);\n-    }\n-}\n-\n-impl<'tcx> euv::Delegate<'tcx> for GlobalChecker {\n-    fn consume(&mut self,\n-               consume_id: ast::NodeId,\n-               _consume_span: Span,\n-               cmt: mc::cmt,\n-               _mode: euv::ConsumeMode) {\n-        let mut cur = &cmt;\n-        loop {\n-            match cur.cat {\n-                mc::cat_static_item => {\n-                    self.static_consumptions.insert(consume_id);\n-                    break\n-                }\n-                mc::cat_deref(ref cmt, _, _) |\n-                mc::cat_downcast(ref cmt, _) |\n-                mc::cat_interior(ref cmt, _) => cur = cmt,\n-\n-                mc::cat_rvalue(..) |\n-                mc::cat_upvar(..) |\n-                mc::cat_local(..) => break,\n-            }\n-        }\n-    }\n-    fn borrow(&mut self,\n-              borrow_id: ast::NodeId,\n-              _borrow_span: Span,\n-              cmt: mc::cmt,\n-              _loan_region: ty::Region,\n-              _bk: ty::BorrowKind,\n-              _loan_cause: euv::LoanCause) {\n-        let mut cur = &cmt;\n-        let mut is_interior = false;\n-        loop {\n-            match cur.cat {\n-                mc::cat_rvalue(..) => {\n-                    self.const_borrows.insert(borrow_id);\n-                    break\n-                }\n-                mc::cat_static_item => {\n-                    if is_interior {\n-                        self.static_interior_borrows.insert(borrow_id);\n-                    }\n-                    break\n-                }\n-                mc::cat_deref(ref cmt, _, _) |\n-                mc::cat_interior(ref cmt, _) => {\n-                    is_interior = true;\n-                    cur = cmt;\n-                }\n-\n-                mc::cat_downcast(..) |\n-                mc::cat_upvar(..) => unreachable!(),\n-\n-                mc::cat_local(..) => {\n-                    self.static_local_borrows.insert(borrow_id);\n-                    break\n-                }\n-            }\n-        }\n-    }\n-\n-    fn decl_without_init(&mut self,\n-                         _id: ast::NodeId,\n-                         _span: Span) {}\n-    fn mutate(&mut self,\n-              _assignment_id: ast::NodeId,\n-              _assignment_span: Span,\n-              _assignee_cmt: mc::cmt,\n-              _mode: euv::MutateMode) {}\n-\n-    fn matched_pat(&mut self,\n-                   _: &ast::Pat,\n-                   _: mc::cmt,\n-                   _: euv::MatchMode) {}\n-\n-    fn consume_pat(&mut self,\n-                   _consume_pat: &ast::Pat,\n-                   _cmt: mc::cmt,\n-                   _mode: euv::ConsumeMode) {}\n-}"}, {"sha": "c3e205e050fb7eb045d0f579a0485e93fa8e2797", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4d8f995c3a482fecdb9a77455cd8d68d514d62ac/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d8f995c3a482fecdb9a77455cd8d68d514d62ac/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=4d8f995c3a482fecdb9a77455cd8d68d514d62ac", "patch": "@@ -611,9 +611,6 @@ pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n     // passes are timed inside typeck\n     typeck::check_crate(&ty_cx, trait_map);\n \n-    time(time_passes, \"check static items\", (), |_|\n-         middle::check_static::check_crate(&ty_cx));\n-\n     time(time_passes, \"const checking\", (), |_|\n          middle::check_const::check_crate(&ty_cx));\n "}, {"sha": "1804b9e04c2c90eee2fa06afa026a2b5b005f6a5", "filename": "src/test/compile-fail/check-static-immutable-mut-slices.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4d8f995c3a482fecdb9a77455cd8d68d514d62ac/src%2Ftest%2Fcompile-fail%2Fcheck-static-immutable-mut-slices.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d8f995c3a482fecdb9a77455cd8d68d514d62ac/src%2Ftest%2Fcompile-fail%2Fcheck-static-immutable-mut-slices.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcheck-static-immutable-mut-slices.rs?ref=4d8f995c3a482fecdb9a77455cd8d68d514d62ac", "patch": "@@ -11,6 +11,6 @@\n // Checks that immutable static items can't have mutable slices\n \n static TEST: &'static mut [isize] = &mut [];\n-//~^ ERROR statics are not allowed to have mutable references\n+//~^ ERROR references in statics may only refer to immutable values\n \n pub fn main() { }"}, {"sha": "0180bccbca40bcfd752fc17c855814554a583196", "filename": "src/test/compile-fail/check-static-values-constraints.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4d8f995c3a482fecdb9a77455cd8d68d514d62ac/src%2Ftest%2Fcompile-fail%2Fcheck-static-values-constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d8f995c3a482fecdb9a77455cd8d68d514d62ac/src%2Ftest%2Fcompile-fail%2Fcheck-static-values-constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcheck-static-values-constraints.rs?ref=4d8f995c3a482fecdb9a77455cd8d68d514d62ac", "patch": "@@ -99,7 +99,7 @@ static STATIC10: UnsafeStruct = UnsafeStruct;\n struct MyOwned;\n \n static STATIC11: Box<MyOwned> = box MyOwned;\n-//~^ ERROR statics are not allowed to have custom pointers\n+//~^ ERROR allocations are not allowed in statics\n \n // The following examples test that mutable structs are just forbidden\n // to have types with destructors\n@@ -117,26 +117,27 @@ static mut STATIC14: SafeStruct = SafeStruct {\n //~^ ERROR mutable statics are not allowed to have destructors\n     field1: SafeEnum::Variant1,\n     field2: SafeEnum::Variant4(\"str\".to_string())\n+//~^ ERROR static contains unimplemented expression type\n };\n \n static STATIC15: &'static [Box<MyOwned>] = &[\n-    box MyOwned, //~ ERROR statics are not allowed to have custom pointers\n-    box MyOwned, //~ ERROR statics are not allowed to have custom pointers\n+    box MyOwned, //~ ERROR allocations are not allowed in statics\n+    box MyOwned, //~ ERROR allocations are not allowed in statics\n ];\n \n static STATIC16: (&'static Box<MyOwned>, &'static Box<MyOwned>) = (\n-    &box MyOwned, //~ ERROR statics are not allowed to have custom pointers\n-    &box MyOwned, //~ ERROR statics are not allowed to have custom pointers\n+    &box MyOwned, //~ ERROR allocations are not allowed in statics\n+    &box MyOwned, //~ ERROR allocations are not allowed in statics\n );\n \n static mut STATIC17: SafeEnum = SafeEnum::Variant1;\n //~^ ERROR mutable statics are not allowed to have destructors\n \n static STATIC19: Box<isize> =\n     box 3;\n-//~^ ERROR statics are not allowed to have custom pointers\n+//~^ ERROR allocations are not allowed in statics\n \n pub fn main() {\n     let y = { static x: Box<isize> = box 3; x };\n-    //~^ ERROR statics are not allowed to have custom pointers\n+    //~^ ERROR allocations are not allowed in statics\n }"}, {"sha": "d6f70ae1e57416498d181cd251d4f80fb423e79b", "filename": "src/test/compile-fail/issue-17458.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4d8f995c3a482fecdb9a77455cd8d68d514d62ac/src%2Ftest%2Fcompile-fail%2Fissue-17458.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d8f995c3a482fecdb9a77455cd8d68d514d62ac/src%2Ftest%2Fcompile-fail%2Fissue-17458.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17458.rs?ref=4d8f995c3a482fecdb9a77455cd8d68d514d62ac", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n static X: usize = 0 as *const usize as usize;\n-//~^ ERROR: can not cast a pointer to an integer in a constant expression\n+//~^ ERROR: can not cast a pointer to an integer in statics\n \n fn main() {\n     assert_eq!(X, 0);"}, {"sha": "2347d3f3d5c0a66f675d1fa00792aa392db9bff8", "filename": "src/test/compile-fail/issue-17718-const-bad-values.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4d8f995c3a482fecdb9a77455cd8d68d514d62ac/src%2Ftest%2Fcompile-fail%2Fissue-17718-const-bad-values.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d8f995c3a482fecdb9a77455cd8d68d514d62ac/src%2Ftest%2Fcompile-fail%2Fissue-17718-const-bad-values.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17718-const-bad-values.rs?ref=4d8f995c3a482fecdb9a77455cd8d68d514d62ac", "patch": "@@ -9,12 +9,12 @@\n // except according to those terms.\n \n const C1: &'static mut [usize] = &mut [];\n-//~^ ERROR: constants are not allowed to have mutable references\n+//~^ ERROR: references in constants may only refer to immutable values\n \n static mut S: usize = 3;\n const C2: &'static mut usize = &mut S;\n //~^ ERROR: constants cannot refer to other statics\n-//~^^ ERROR: are not allowed to have mutable references\n+//~^^ ERROR: references in constants may only refer to immutable values\n \n fn main() {}\n "}, {"sha": "53df24d5b00c2f66c0c2fb9d9609c2dfe43e340f", "filename": "src/test/compile-fail/issue-18118.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4d8f995c3a482fecdb9a77455cd8d68d514d62ac/src%2Ftest%2Fcompile-fail%2Fissue-18118.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d8f995c3a482fecdb9a77455cd8d68d514d62ac/src%2Ftest%2Fcompile-fail%2Fissue-18118.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18118.rs?ref=4d8f995c3a482fecdb9a77455cd8d68d514d62ac", "patch": "@@ -11,7 +11,8 @@\n pub fn main() {\n     static z: &'static isize = {\n         let p = 3;\n+        //~^ ERROR blocks in constants are limited to items and tail expressions\n         &p\n-//~^ ERROR cannot borrow a local variable inside a static block, define a separate static instead\n+        //~^ ERROR paths in constants may only refer to constants or functions\n     };\n }"}, {"sha": "8744afe23392422cdc25c79b43f86c52edd57d89", "filename": "src/test/compile-fail/issue-7364.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4d8f995c3a482fecdb9a77455cd8d68d514d62ac/src%2Ftest%2Fcompile-fail%2Fissue-7364.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d8f995c3a482fecdb9a77455cd8d68d514d62ac/src%2Ftest%2Fcompile-fail%2Fissue-7364.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7364.rs?ref=4d8f995c3a482fecdb9a77455cd8d68d514d62ac", "patch": "@@ -14,8 +14,9 @@ use std::cell::RefCell;\n \n // Regression test for issue 7364\n static boxed: Box<RefCell<isize>> = box RefCell::new(0);\n-//~^ ERROR statics are not allowed to have custom pointers\n+//~^ ERROR allocations are not allowed in statics\n //~| ERROR: the trait `core::marker::Sync` is not implemented for the type\n //~| ERROR: the trait `core::marker::Sync` is not implemented for the type\n+//~^^^^^ ERROR function calls in constants are limited to struct and enum constructors\n \n fn main() { }"}, {"sha": "08148328edcf30d7fe87ff7bccf5ee0a7b55afc6", "filename": "src/test/compile-fail/static-mut-not-constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4d8f995c3a482fecdb9a77455cd8d68d514d62ac/src%2Ftest%2Fcompile-fail%2Fstatic-mut-not-constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d8f995c3a482fecdb9a77455cd8d68d514d62ac/src%2Ftest%2Fcompile-fail%2Fstatic-mut-not-constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstatic-mut-not-constant.rs?ref=4d8f995c3a482fecdb9a77455cd8d68d514d62ac", "patch": "@@ -11,7 +11,7 @@\n #![feature(box_syntax)]\n \n static mut a: Box<isize> = box 3;\n-//~^ ERROR statics are not allowed to have custom pointers\n+//~^ ERROR allocations are not allowed in statics\n //~^^ ERROR mutable statics are not allowed to have owned pointers\n \n fn main() {}"}]}