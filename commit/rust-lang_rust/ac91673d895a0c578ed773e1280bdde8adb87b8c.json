{"sha": "ac91673d895a0c578ed773e1280bdde8adb87b8c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjOTE2NzNkODk1YTBjNTc4ZWQ3NzNlMTI4MGJkZGU4YWRiODdiOGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-31T06:35:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-31T06:35:19Z"}, "message": "Auto merge of #74959 - richkadel:llvm-coverage-map-gen-5.1, r=tmandry\n\nRust function-level coverage now works on external crates\n\nFollow-up to a known issue discussed (post-merge) in #74733:\n\nResolves a known issue in the coverage map where some regions had nonsensical source code locations.\n\nExternal crate functions are already included in their own coverage maps, per library, and don't need to also\nbe added to the importing crate's coverage map. (In fact, their source start and end byte positions are not relevant to the importing crate's SourceMap.)\n\nThe fix was to simply skip trying to add imported coverage info to the coverage map if the instrumented function is not \"local\".\n\nThe injected counters are still relevant, however, and the LLVM `instrprof.increment` intrinsic call parameters will map those counters to the external crates' coverage maps, when generating runtime coverage data.\n\nNow Rust Coverage can cleanly instrument and analyze coverage on an entire crate and its dependencies.\n\nExample (instrumenting https://github.com/google/json5format):\n\n```bash\n$ ./x.py build rust-demangler  # make sure the demangler is built\n$ cd ~/json5format\n$ RUSTC=$HOME/rust/build/x86_64-unknown-linux-gnu/stage1/bin/rustc \\\n   RUSTFLAGS=\"-Zinstrument-coverage\" \\\n   cargo build --example formatjson5\n$ LLVM_PROFILE_FILE=\"formatjson5.profraw\" \\\n   ./target/debug/examples/formatjson5 session_manager.cml\n$ ~/rust/build/x86_64-unknown-linux-gnu/llvm/bin/llvm-profdata merge \\\n   -sparse formatjson5.profraw -o formatjson5.profdata\n$ ~/rust/build/x86_64-unknown-linux-gnu/llvm/bin/llvm-cov show --use-color \\\n   --instr-profile=formatjson5.profdata target/debug/examples/formatjson5 \\\n   --show-line-counts-or-regions  \\\n   --Xdemangler=$HOME/rust/build/x86_64-unknown-linux-gnu/stage0-tools-bin/rust-demangler \\\n   --show-instantiations \\\n   2>&1 | less -R\n```\n\n(Scan forward for some of the non-zero coverage results, with `/^....[0-9]\\|  *[^ |0]`.)\n\n<img width=\"1071\" alt=\"Screen Shot 2020-07-30 at 1 21 01 PM\" src=\"https://user-images.githubusercontent.com/3827298/88970627-97e43000-d267-11ea-8e4d-fe40a091f756.png\">", "tree": {"sha": "24e5dc86c3a427f5a0e44c81379cef5de214e7c3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/24e5dc86c3a427f5a0e44c81379cef5de214e7c3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ac91673d895a0c578ed773e1280bdde8adb87b8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ac91673d895a0c578ed773e1280bdde8adb87b8c", "html_url": "https://github.com/rust-lang/rust/commit/ac91673d895a0c578ed773e1280bdde8adb87b8c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ac91673d895a0c578ed773e1280bdde8adb87b8c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "66b97dca3c8ab51f8af7b2db7ae4c8061fbf5e9b", "url": "https://api.github.com/repos/rust-lang/rust/commits/66b97dca3c8ab51f8af7b2db7ae4c8061fbf5e9b", "html_url": "https://github.com/rust-lang/rust/commit/66b97dca3c8ab51f8af7b2db7ae4c8061fbf5e9b"}, {"sha": "34b26d6a77c45776cbbef182b4c1b0b96ac326fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/34b26d6a77c45776cbbef182b4c1b0b96ac326fe", "html_url": "https://github.com/rust-lang/rust/commit/34b26d6a77c45776cbbef182b4c1b0b96ac326fe"}], "stats": {"total": 115, "additions": 62, "deletions": 53}, "files": [{"sha": "728af7b0a8cd177323e7def9bd8db33893379b75", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 57, "deletions": 52, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/ac91673d895a0c578ed773e1280bdde8adb87b8c/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac91673d895a0c578ed773e1280bdde8adb87b8c/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=ac91673d895a0c578ed773e1280bdde8adb87b8c", "patch": "@@ -90,64 +90,69 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         args: &Vec<Operand<'tcx>>,\n         caller_instance: ty::Instance<'tcx>,\n     ) -> bool {\n+        let mut is_codegen_intrinsic = true;\n+        // Set `is_codegen_intrinsic` to `false` to bypass `codegen_intrinsic_call()`.\n+\n         if self.tcx.sess.opts.debugging_opts.instrument_coverage {\n-            // Add the coverage information from the MIR to the Codegen context. Some coverage\n-            // intrinsics are used only to pass along the coverage information (returns `false`\n-            // for `is_codegen_intrinsic()`), but `count_code_region` is also converted into an\n-            // LLVM intrinsic to increment a coverage counter.\n-            match intrinsic {\n-                sym::count_code_region => {\n-                    use coverage::count_code_region_args::*;\n-                    self.add_counter_region(\n-                        caller_instance,\n-                        op_to_u64(&args[FUNCTION_SOURCE_HASH]),\n-                        op_to_u32(&args[COUNTER_ID]),\n-                        op_to_u32(&args[START_BYTE_POS]),\n-                        op_to_u32(&args[END_BYTE_POS]),\n-                    );\n-                    return true; // Also inject the counter increment in the backend\n-                }\n-                sym::coverage_counter_add | sym::coverage_counter_subtract => {\n-                    use coverage::coverage_counter_expression_args::*;\n-                    self.add_counter_expression_region(\n-                        caller_instance,\n-                        op_to_u32(&args[EXPRESSION_ID]),\n-                        op_to_u32(&args[LEFT_ID]),\n-                        if intrinsic == sym::coverage_counter_add {\n-                            ExprKind::Add\n-                        } else {\n-                            ExprKind::Subtract\n-                        },\n-                        op_to_u32(&args[RIGHT_ID]),\n-                        op_to_u32(&args[START_BYTE_POS]),\n-                        op_to_u32(&args[END_BYTE_POS]),\n-                    );\n-                    return false; // Does not inject backend code\n+            // If the intrinsic is from the local MIR, add the coverage information to the Codegen\n+            // context, to be encoded into the local crate's coverage map.\n+            if caller_instance.def_id().is_local() {\n+                // FIXME(richkadel): Make sure to add coverage analysis tests on a crate with\n+                // external crate dependencies, where:\n+                //   1. Both binary and dependent crates are compiled with `-Zinstrument-coverage`\n+                //   2. Only binary is compiled with `-Zinstrument-coverage`\n+                //   3. Only dependent crates are compiled with `-Zinstrument-coverage`\n+                match intrinsic {\n+                    sym::count_code_region => {\n+                        use coverage::count_code_region_args::*;\n+                        self.add_counter_region(\n+                            caller_instance,\n+                            op_to_u64(&args[FUNCTION_SOURCE_HASH]),\n+                            op_to_u32(&args[COUNTER_ID]),\n+                            op_to_u32(&args[START_BYTE_POS]),\n+                            op_to_u32(&args[END_BYTE_POS]),\n+                        );\n+                    }\n+                    sym::coverage_counter_add | sym::coverage_counter_subtract => {\n+                        use coverage::coverage_counter_expression_args::*;\n+                        self.add_counter_expression_region(\n+                            caller_instance,\n+                            op_to_u32(&args[EXPRESSION_ID]),\n+                            op_to_u32(&args[LEFT_ID]),\n+                            if intrinsic == sym::coverage_counter_add {\n+                                ExprKind::Add\n+                            } else {\n+                                ExprKind::Subtract\n+                            },\n+                            op_to_u32(&args[RIGHT_ID]),\n+                            op_to_u32(&args[START_BYTE_POS]),\n+                            op_to_u32(&args[END_BYTE_POS]),\n+                        );\n+                    }\n+                    sym::coverage_unreachable => {\n+                        use coverage::coverage_unreachable_args::*;\n+                        self.add_unreachable_region(\n+                            caller_instance,\n+                            op_to_u32(&args[START_BYTE_POS]),\n+                            op_to_u32(&args[END_BYTE_POS]),\n+                        );\n+                    }\n+                    _ => {}\n                 }\n-                sym::coverage_unreachable => {\n-                    use coverage::coverage_unreachable_args::*;\n-                    self.add_unreachable_region(\n-                        caller_instance,\n-                        op_to_u32(&args[START_BYTE_POS]),\n-                        op_to_u32(&args[END_BYTE_POS]),\n-                    );\n-                    return false; // Does not inject backend code\n+            }\n+\n+            // Only the `count_code_region` coverage intrinsic is translated into an actual LLVM\n+            // intrinsic call (local or not); otherwise, set `is_codegen_intrinsic` to `false`.\n+            match intrinsic {\n+                sym::coverage_counter_add\n+                | sym::coverage_counter_subtract\n+                | sym::coverage_unreachable => {\n+                    is_codegen_intrinsic = false;\n                 }\n                 _ => {}\n             }\n-        } else {\n-            // NOT self.tcx.sess.opts.debugging_opts.instrument_coverage\n-            if intrinsic == sym::count_code_region {\n-                // An external crate may have been pre-compiled with coverage instrumentation, and\n-                // some references from the current crate to the external crate might carry along\n-                // the call terminators to coverage intrinsics, like `count_code_region` (for\n-                // example, when instantiating a generic function). If the current crate has\n-                // `instrument_coverage` disabled, the `count_code_region` call terminators should\n-                // be ignored.\n-                return false; // Do not inject coverage counters inlined from external crates\n-            }\n         }\n-        true // Unhandled intrinsics should be passed to `codegen_intrinsic_call()`\n+        is_codegen_intrinsic\n     }\n \n     fn codegen_intrinsic_call("}, {"sha": "72138065a90ba965d1eb64419603216d02125fc0", "filename": "src/librustc_codegen_ssa/coverageinfo/map.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ac91673d895a0c578ed773e1280bdde8adb87b8c/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac91673d895a0c578ed773e1280bdde8adb87b8c/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmap.rs?ref=ac91673d895a0c578ed773e1280bdde8adb87b8c", "patch": "@@ -86,7 +86,11 @@ impl Region {\n     pub fn new(source_map: &SourceMap, start_byte_pos: u32, end_byte_pos: u32) -> Self {\n         let start = source_map.lookup_char_pos(BytePos::from_u32(start_byte_pos));\n         let end = source_map.lookup_char_pos(BytePos::from_u32(end_byte_pos));\n-        assert_eq!(start.file.name, end.file.name);\n+        assert_eq!(\n+            start.file.name, end.file.name,\n+            \"Region start ({} -> {:?}) and end ({} -> {:?}) don't come from the same source file!\",\n+            start_byte_pos, start, end_byte_pos, end\n+        );\n         Self { start, end }\n     }\n "}]}