{"sha": "cebed8ab921e7e5f539236ae7ef87ee1992eaaaf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlYmVkOGFiOTIxZTdlNWY1MzkyMzZhZTdlZjg3ZWUxOTkyZWFhYWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-18T01:46:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-18T01:46:24Z"}, "message": "auto merge of #15593 : steveklabnik/rust/string_guide, r=kballard\n\nI decided to change it up a little today and hack out the beginning of the String guide. Strings are different enough in Rust that I think they deserve a specific guide, especially for those who are used to managed languages.\r\n\r\nI decided to start with Strings because they get asked about a lot in IRC, and also based on discussions like this one on reddit: http://www.reddit.com/r/rust/comments/2ac390/generic_string_literals/\r\n\r\nI blatantly stole bits from our other documentation on Strings. It's a little sparse at current, but I wanted to start somewhere.\r\n\r\nI am not exactly sure what should go in \"Best Practices,\" and would like the feedback from the team on this. Specifically due to comments like this one: http://www.reddit.com/r/rust/comments/2ac390/generic_string_literals/citmxb5", "tree": {"sha": "c11ee3b55c11e726493a8d447629d15e8446bdab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c11ee3b55c11e726493a8d447629d15e8446bdab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cebed8ab921e7e5f539236ae7ef87ee1992eaaaf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cebed8ab921e7e5f539236ae7ef87ee1992eaaaf", "html_url": "https://github.com/rust-lang/rust/commit/cebed8ab921e7e5f539236ae7ef87ee1992eaaaf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cebed8ab921e7e5f539236ae7ef87ee1992eaaaf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f50e4ee559c0e6253e9d46a8e6763e25f7b90d90", "url": "https://api.github.com/repos/rust-lang/rust/commits/f50e4ee559c0e6253e9d46a8e6763e25f7b90d90", "html_url": "https://github.com/rust-lang/rust/commit/f50e4ee559c0e6253e9d46a8e6763e25f7b90d90"}, {"sha": "226b7d1b725300fe6fbcfc1a66dfc1298f0af893", "url": "https://api.github.com/repos/rust-lang/rust/commits/226b7d1b725300fe6fbcfc1a66dfc1298f0af893", "html_url": "https://github.com/rust-lang/rust/commit/226b7d1b725300fe6fbcfc1a66dfc1298f0af893"}], "stats": {"total": 137, "additions": 133, "deletions": 4}, "files": [{"sha": "6f301afc8498d45068ba7ee49836974c944eebe4", "filename": "src/doc/guide-strings.md", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/cebed8ab921e7e5f539236ae7ef87ee1992eaaaf/src%2Fdoc%2Fguide-strings.md", "raw_url": "https://github.com/rust-lang/rust/raw/cebed8ab921e7e5f539236ae7ef87ee1992eaaaf/src%2Fdoc%2Fguide-strings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-strings.md?ref=cebed8ab921e7e5f539236ae7ef87ee1992eaaaf", "patch": "@@ -0,0 +1,129 @@\n+% The Strings Guide\n+\n+# Strings\n+\n+Strings are an important concept to master in any programming language. If you\n+come from a managed language background, you may be surprised at the complexity\n+of string handling in a systems programming language. Efficient access and\n+allocation of memory for a dynamically sized structure involves a lot of\n+details. Luckily, Rust has lots of tools to help us here.\n+\n+A **string** is a sequence of unicode scalar values encoded as a stream of\n+UTF-8 bytes. All strings are guaranteed to be validly-encoded UTF-8 sequences.\n+Additionally, strings are not null-terminated and can contain null bytes.\n+\n+Rust has two main types of strings: `&str` and `String`.\n+\n+## &str\n+\n+The first kind is a `&str`. This is pronounced a 'string slice.' String literals\n+are of the type `&str`:\n+\n+```{rust}\n+let string = \"Hello there.\";\n+```\n+\n+Like any Rust type, string slices have an associated lifetime. A string literal\n+is a `&'static str`.  A string slice can be written without an explicit\n+lifetime in many cases, such as in function arguments. In these cases the\n+lifetime will be inferred:\n+\n+```{rust}\n+fn takes_slice(slice: &str) {\n+    println!(\"Got: {}\", slice);\n+}\n+```\n+\n+Like vector slices, string slices are simply a pointer plus a length. This\n+means that they're a 'view' into an already-allocated string, such as a\n+`&'static str` or a `String`.\n+\n+## String\n+\n+A `String` is a heap-allocated string. This string is growable, and is also\n+guaranteed to be UTF-8.\n+\n+```{rust}\n+let mut s = \"Hello\".to_string();\n+println!(\"{}\", s);\n+\n+s.push_str(\", world.\");\n+println!(\"{}\", s);\n+```\n+\n+You can coerce a `String` into a `&str` with the `as_slice()` method:\n+\n+```{rust}\n+fn takes_slice(slice: &str) {\n+    println!(\"Got: {}\", slice);\n+}\n+\n+fn main() {\n+    let s = \"Hello\".to_string();\n+    takes_slice(s.as_slice());\n+}\n+```\n+\n+You can also get a `&str` from a stack-allocated array of bytes:\n+\n+```{rust}\n+use std::str;\n+\n+let x: &[u8] = &[b'a', b'b'];\n+let stack_str: &str = str::from_utf8(x).unwrap();\n+```\n+\n+## Best Practices\n+\n+### `String` vs. `&str`\n+\n+In general, you should prefer `String` when you need ownership, and `&str` when\n+you just need to borrow a string. This is very similar to using `Vec<T>` vs. `&[T]`,\n+and `T` vs `&T` in general.\n+\n+This means starting off with this:\n+\n+```{rust,ignore}\n+fn foo(s: &str) {\n+```\n+\n+and only moving to this:\n+\n+```{rust,ignore}\n+fn foo(s: String) {\n+```\n+\n+If you have good reason. It's not polite to hold on to ownership you don't\n+need, and it can make your lifetimes more complex. Furthermore, you can pass\n+either kind of string into `foo` by using `.as_slice()` on any `String` you\n+need to pass in, so the `&str` version is more flexible.\n+\n+### Comparisons\n+\n+To compare a String to a constant string, prefer `as_slice()`...\n+\n+```{rust}\n+fn compare(string: String) {\n+    if string.as_slice() == \"Hello\" {\n+        println!(\"yes\");\n+    }\n+}\n+```\n+\n+... over `to_string()`:\n+\n+```{rust}\n+fn compare(string: String) {\n+    if string == \"Hello\".to_string() {\n+        println!(\"yes\");\n+    }\n+}\n+```\n+\n+Converting a `String` to a `&str` is cheap, but converting the `&str` to a\n+`String` involves an allocation.\n+\n+## Other Documentation\n+\n+* [the `&str` API documentation](/std/str/index.html)\n+* [the `String` API documentation](std/string/index.html)"}, {"sha": "bd6a13ae2e3ed7c28c273d7c16f6c6d4df1bc030", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cebed8ab921e7e5f539236ae7ef87ee1992eaaaf/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebed8ab921e7e5f539236ae7ef87ee1992eaaaf/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=cebed8ab921e7e5f539236ae7ef87ee1992eaaaf", "patch": "@@ -55,10 +55,10 @@ other languages.\n \n # Representation\n \n-Rust's string type, `str`, is a sequence of unicode codepoints encoded as a\n-stream of UTF-8 bytes. All safely-created strings are guaranteed to be validly\n-encoded UTF-8 sequences. Additionally, strings are not null-terminated\n-and can contain null codepoints.\n+Rust's string type, `str`, is a sequence of unicode scalar values encoded as a\n+stream of UTF-8 bytes. All strings are guaranteed to be validly encoded UTF-8\n+sequences. Additionally, strings are not null-terminated and can contain null\n+bytes.\n \n The actual representation of strings have direct mappings to vectors: `&str`\n is the same as `&[u8]`."}]}