{"sha": "e451d6e188b99ad53ddd6e21cf99f0e4f96cf74e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0NTFkNmUxODhiOTlhZDUzZGRkNmUyMWNmOTlmMGU0Zjk2Y2Y3NGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-07T22:58:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-07T22:58:11Z"}, "message": "Auto merge of #6853 - Jarcho:len_without_is_empty_fp, r=Manishearth\n\n`len_without_is_empty` will now consider multiple impl blocks\n\nfixes #1562\n\nThis also reverts #1559 as the `#[allow]` now works on the `len` method. A note has also been added to point out where the `empty` method is, if it exists.\n\nchangelog: `len_without_is_empty` will now consider multiple impl blocks\nchangelog: `len_without_is_empty` will now consider `#[allow]` on both the `len` method, and the type definition", "tree": {"sha": "ec2672205decda579327994cbe66bc2f56e72f5a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ec2672205decda579327994cbe66bc2f56e72f5a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e451d6e188b99ad53ddd6e21cf99f0e4f96cf74e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e451d6e188b99ad53ddd6e21cf99f0e4f96cf74e", "html_url": "https://github.com/rust-lang/rust/commit/e451d6e188b99ad53ddd6e21cf99f0e4f96cf74e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e451d6e188b99ad53ddd6e21cf99f0e4f96cf74e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5945e85f34067a584800d853f99de84f079f7150", "url": "https://api.github.com/repos/rust-lang/rust/commits/5945e85f34067a584800d853f99de84f079f7150", "html_url": "https://github.com/rust-lang/rust/commit/5945e85f34067a584800d853f99de84f079f7150"}, {"sha": "47145dec36fbe99960f45ee7065261e2dcfed152", "url": "https://api.github.com/repos/rust-lang/rust/commits/47145dec36fbe99960f45ee7065261e2dcfed152", "html_url": "https://github.com/rust-lang/rust/commit/47145dec36fbe99960f45ee7065261e2dcfed152"}], "stats": {"total": 308, "additions": 231, "deletions": 77}, "files": [{"sha": "1e1023b2743502e8d732eaf825e8c09f6414e9ec", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 125, "deletions": 41, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/e451d6e188b99ad53ddd6e21cf99f0e4f96cf74e/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e451d6e188b99ad53ddd6e21cf99f0e4f96cf74e/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=e451d6e188b99ad53ddd6e21cf99f0e4f96cf74e", "patch": "@@ -1,11 +1,17 @@\n-use crate::utils::{get_item_name, snippet_with_applicability, span_lint, span_lint_and_sugg};\n+use crate::utils::{\n+    get_item_name, get_parent_as_impl, is_allowed, snippet_with_applicability, span_lint, span_lint_and_sugg,\n+    span_lint_and_then,\n+};\n+use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::Applicability;\n-use rustc_hir::def_id::DefId;\n-use rustc_hir::{AssocItemKind, BinOpKind, Expr, ExprKind, Impl, ImplItemRef, Item, ItemKind, TraitItemRef};\n+use rustc_hir::{\n+    def_id::DefId, AssocItemKind, BinOpKind, Expr, ExprKind, FnRetTy, ImplItem, ImplItemKind, ImplicitSelfKind, Item,\n+    ItemKind, Mutability, Node, TraitItemRef, TyKind,\n+};\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty;\n+use rustc_middle::ty::{self, AssocKind, FnSig};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::{Span, Spanned, Symbol};\n \n@@ -113,14 +119,38 @@ impl<'tcx> LateLintPass<'tcx> for LenZero {\n             return;\n         }\n \n-        match item.kind {\n-            ItemKind::Trait(_, _, _, _, ref trait_items) => check_trait_items(cx, item, trait_items),\n-            ItemKind::Impl(Impl {\n-                of_trait: None,\n-                items: ref impl_items,\n-                ..\n-            }) => check_impl_items(cx, item, impl_items),\n-            _ => (),\n+        if let ItemKind::Trait(_, _, _, _, ref trait_items) = item.kind {\n+            check_trait_items(cx, item, trait_items);\n+        }\n+    }\n+\n+    fn check_impl_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx ImplItem<'_>) {\n+        if_chain! {\n+            if item.ident.as_str() == \"len\";\n+            if let ImplItemKind::Fn(sig, _) = &item.kind;\n+            if sig.decl.implicit_self.has_implicit_self();\n+            if cx.access_levels.is_exported(item.hir_id());\n+            if matches!(sig.decl.output, FnRetTy::Return(_));\n+            if let Some(imp) = get_parent_as_impl(cx.tcx, item.hir_id());\n+            if imp.of_trait.is_none();\n+            if let TyKind::Path(ty_path) = &imp.self_ty.kind;\n+            if let Some(ty_id) = cx.qpath_res(ty_path, imp.self_ty.hir_id).opt_def_id();\n+            if let Some(local_id) = ty_id.as_local();\n+            let ty_hir_id = cx.tcx.hir().local_def_id_to_hir_id(local_id);\n+            if !is_allowed(cx, LEN_WITHOUT_IS_EMPTY, ty_hir_id);\n+            then {\n+                let (name, kind) = match cx.tcx.hir().find(ty_hir_id) {\n+                    Some(Node::ForeignItem(x)) => (x.ident.name, \"extern type\"),\n+                    Some(Node::Item(x)) => match x.kind {\n+                        ItemKind::Struct(..) => (x.ident.name, \"struct\"),\n+                        ItemKind::Enum(..) => (x.ident.name, \"enum\"),\n+                        ItemKind::Union(..) => (x.ident.name, \"union\"),\n+                        _ => (x.ident.name, \"type\"),\n+                    }\n+                    _ => return,\n+                };\n+                check_for_is_empty(cx, sig.span, sig.decl.implicit_self, ty_id, name, kind)\n+            }\n         }\n     }\n \n@@ -202,40 +232,94 @@ fn check_trait_items(cx: &LateContext<'_>, visited_trait: &Item<'_>, trait_items\n     }\n }\n \n-fn check_impl_items(cx: &LateContext<'_>, item: &Item<'_>, impl_items: &[ImplItemRef<'_>]) {\n-    fn is_named_self(cx: &LateContext<'_>, item: &ImplItemRef<'_>, name: &str) -> bool {\n-        item.ident.name.as_str() == name\n-            && if let AssocItemKind::Fn { has_self } = item.kind {\n-                has_self && cx.tcx.fn_sig(item.id.def_id).inputs().skip_binder().len() == 1\n-            } else {\n-                false\n-            }\n+/// Checks if the given signature matches the expectations for `is_empty`\n+fn check_is_empty_sig(cx: &LateContext<'_>, sig: FnSig<'_>, self_kind: ImplicitSelfKind) -> bool {\n+    match &**sig.inputs_and_output {\n+        [arg, res] if *res == cx.tcx.types.bool => {\n+            matches!(\n+                (arg.kind(), self_kind),\n+                (ty::Ref(_, _, Mutability::Not), ImplicitSelfKind::ImmRef)\n+                    | (ty::Ref(_, _, Mutability::Mut), ImplicitSelfKind::MutRef)\n+            ) || (!arg.is_ref() && matches!(self_kind, ImplicitSelfKind::Imm | ImplicitSelfKind::Mut))\n+        },\n+        _ => false,\n     }\n+}\n \n-    let is_empty = if let Some(is_empty) = impl_items.iter().find(|i| is_named_self(cx, i, \"is_empty\")) {\n-        if cx.access_levels.is_exported(is_empty.id.hir_id()) {\n-            return;\n-        }\n-        \"a private\"\n-    } else {\n-        \"no corresponding\"\n-    };\n-\n-    if let Some(i) = impl_items.iter().find(|i| is_named_self(cx, i, \"len\")) {\n-        if cx.access_levels.is_exported(i.id.hir_id()) {\n-            let ty = cx.tcx.type_of(item.def_id);\n+/// Checks if the given type has an `is_empty` method with the appropriate signature.\n+fn check_for_is_empty(\n+    cx: &LateContext<'_>,\n+    span: Span,\n+    self_kind: ImplicitSelfKind,\n+    impl_ty: DefId,\n+    item_name: Symbol,\n+    item_kind: &str,\n+) {\n+    let is_empty = Symbol::intern(\"is_empty\");\n+    let is_empty = cx\n+        .tcx\n+        .inherent_impls(impl_ty)\n+        .iter()\n+        .flat_map(|&id| cx.tcx.associated_items(id).filter_by_name_unhygienic(is_empty))\n+        .find(|item| item.kind == AssocKind::Fn);\n \n-            span_lint(\n-                cx,\n-                LEN_WITHOUT_IS_EMPTY,\n-                item.span,\n-                &format!(\n-                    \"item `{}` has a public `len` method but {} `is_empty` method\",\n-                    ty, is_empty\n+    let (msg, is_empty_span, self_kind) = match is_empty {\n+        None => (\n+            format!(\n+                \"{} `{}` has a public `len` method, but no `is_empty` method\",\n+                item_kind,\n+                item_name.as_str(),\n+            ),\n+            None,\n+            None,\n+        ),\n+        Some(is_empty)\n+            if !cx\n+                .access_levels\n+                .is_exported(cx.tcx.hir().local_def_id_to_hir_id(is_empty.def_id.expect_local())) =>\n+        {\n+            (\n+                format!(\n+                    \"{} `{}` has a public `len` method, but a private `is_empty` method\",\n+                    item_kind,\n+                    item_name.as_str(),\n                 ),\n-            );\n+                Some(cx.tcx.def_span(is_empty.def_id)),\n+                None,\n+            )\n+        },\n+        Some(is_empty)\n+            if !(is_empty.fn_has_self_parameter\n+                && check_is_empty_sig(cx, cx.tcx.fn_sig(is_empty.def_id).skip_binder(), self_kind)) =>\n+        {\n+            (\n+                format!(\n+                    \"{} `{}` has a public `len` method, but the `is_empty` method has an unexpected signature\",\n+                    item_kind,\n+                    item_name.as_str(),\n+                ),\n+                Some(cx.tcx.def_span(is_empty.def_id)),\n+                Some(self_kind),\n+            )\n+        },\n+        Some(_) => return,\n+    };\n+\n+    span_lint_and_then(cx, LEN_WITHOUT_IS_EMPTY, span, &msg, |db| {\n+        if let Some(span) = is_empty_span {\n+            db.span_note(span, \"`is_empty` defined here\");\n         }\n-    }\n+        if let Some(self_kind) = self_kind {\n+            db.note(&format!(\n+                \"expected signature: `({}self) -> bool`\",\n+                match self_kind {\n+                    ImplicitSelfKind::ImmRef => \"&\",\n+                    ImplicitSelfKind::MutRef => \"&mut \",\n+                    _ => \"\",\n+                }\n+            ));\n+        }\n+    });\n }\n \n fn check_cmp(cx: &LateContext<'_>, span: Span, method: &Expr<'_>, lit: &Expr<'_>, op: &str, compare_to: u32) {"}, {"sha": "6582ad7170717b6c7a97cc864aaff89790895fef", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e451d6e188b99ad53ddd6e21cf99f0e4f96cf74e/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e451d6e188b99ad53ddd6e21cf99f0e4f96cf74e/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=e451d6e188b99ad53ddd6e21cf99f0e4f96cf74e", "patch": "@@ -63,9 +63,9 @@ use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::Node;\n use rustc_hir::{\n-    def, Arm, Block, Body, Constness, Crate, Expr, ExprKind, FnDecl, GenericArgs, HirId, ImplItem, ImplItemKind, Item,\n-    ItemKind, MatchSource, Param, Pat, PatKind, Path, PathSegment, QPath, TraitItem, TraitItemKind, TraitRef, TyKind,\n-    Unsafety,\n+    def, Arm, Block, Body, Constness, Crate, Expr, ExprKind, FnDecl, GenericArgs, HirId, Impl, ImplItem, ImplItemKind,\n+    Item, ItemKind, MatchSource, Param, Pat, PatKind, Path, PathSegment, QPath, TraitItem, TraitItemKind, TraitRef,\n+    TyKind, Unsafety,\n };\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::{LateContext, Level, Lint, LintContext};\n@@ -1004,6 +1004,21 @@ pub fn get_enclosing_block<'tcx>(cx: &LateContext<'tcx>, hir_id: HirId) -> Optio\n     })\n }\n \n+/// Gets the parent node if it's an impl block.\n+pub fn get_parent_as_impl(tcx: TyCtxt<'_>, id: HirId) -> Option<&Impl<'_>> {\n+    let map = tcx.hir();\n+    match map.parent_iter(id).next() {\n+        Some((\n+            _,\n+            Node::Item(Item {\n+                kind: ItemKind::Impl(imp),\n+                ..\n+            }),\n+        )) => Some(imp),\n+        _ => None,\n+    }\n+}\n+\n /// Returns the base type for HIR references and pointers.\n pub fn walk_ptrs_hir_ty<'tcx>(ty: &'tcx hir::Ty<'tcx>) -> &'tcx hir::Ty<'tcx> {\n     match ty.kind {"}, {"sha": "6b3636a482e957e25bfc3ce178268b931c67a397", "filename": "tests/ui/len_without_is_empty.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/e451d6e188b99ad53ddd6e21cf99f0e4f96cf74e/tests%2Fui%2Flen_without_is_empty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e451d6e188b99ad53ddd6e21cf99f0e4f96cf74e/tests%2Fui%2Flen_without_is_empty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flen_without_is_empty.rs?ref=e451d6e188b99ad53ddd6e21cf99f0e4f96cf74e", "patch": "@@ -34,6 +34,24 @@ impl PubAllowed {\n     }\n }\n \n+pub struct PubAllowedFn;\n+\n+impl PubAllowedFn {\n+    #[allow(clippy::len_without_is_empty)]\n+    pub fn len(&self) -> isize {\n+        1\n+    }\n+}\n+\n+#[allow(clippy::len_without_is_empty)]\n+pub struct PubAllowedStruct;\n+\n+impl PubAllowedStruct {\n+    pub fn len(&self) -> isize {\n+        1\n+    }\n+}\n+\n pub trait PubTraitsToo {\n     fn len(&self) -> isize;\n }\n@@ -68,6 +86,18 @@ impl HasWrongIsEmpty {\n     }\n }\n \n+pub struct MismatchedSelf;\n+\n+impl MismatchedSelf {\n+    pub fn len(self) -> isize {\n+        1\n+    }\n+\n+    pub fn is_empty(&self) -> bool {\n+        false\n+    }\n+}\n+\n struct NotPubOne;\n \n impl NotPubOne {\n@@ -142,4 +172,19 @@ pub trait DependsOnFoo: Foo {\n     fn len(&mut self) -> usize;\n }\n \n+pub struct MultipleImpls;\n+\n+// issue #1562\n+impl MultipleImpls {\n+    pub fn len(&self) -> usize {\n+        1\n+    }\n+}\n+\n+impl MultipleImpls {\n+    pub fn is_empty(&self) -> bool {\n+        false\n+    }\n+}\n+\n fn main() {}"}, {"sha": "f106506faf49edf27df75a9a63cde93233fe49bf", "filename": "tests/ui/len_without_is_empty.stderr", "status": "modified", "additions": 43, "deletions": 33, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/e451d6e188b99ad53ddd6e21cf99f0e4f96cf74e/tests%2Fui%2Flen_without_is_empty.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e451d6e188b99ad53ddd6e21cf99f0e4f96cf74e/tests%2Fui%2Flen_without_is_empty.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flen_without_is_empty.stderr?ref=e451d6e188b99ad53ddd6e21cf99f0e4f96cf74e", "patch": "@@ -1,54 +1,64 @@\n-error: item `PubOne` has a public `len` method but no corresponding `is_empty` method\n-  --> $DIR/len_without_is_empty.rs:6:1\n+error: struct `PubOne` has a public `len` method, but no `is_empty` method\n+  --> $DIR/len_without_is_empty.rs:7:5\n    |\n-LL | / impl PubOne {\n-LL | |     pub fn len(&self) -> isize {\n-LL | |         1\n-LL | |     }\n-LL | | }\n-   | |_^\n+LL |     pub fn len(&self) -> isize {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::len-without-is-empty` implied by `-D warnings`\n \n error: trait `PubTraitsToo` has a `len` method but no (possibly inherited) `is_empty` method\n-  --> $DIR/len_without_is_empty.rs:37:1\n+  --> $DIR/len_without_is_empty.rs:55:1\n    |\n LL | / pub trait PubTraitsToo {\n LL | |     fn len(&self) -> isize;\n LL | | }\n    | |_^\n \n-error: item `HasIsEmpty` has a public `len` method but a private `is_empty` method\n-  --> $DIR/len_without_is_empty.rs:49:1\n-   |\n-LL | / impl HasIsEmpty {\n-LL | |     pub fn len(&self) -> isize {\n-LL | |         1\n-LL | |     }\n-...  |\n-LL | |     }\n-LL | | }\n-   | |_^\n+error: struct `HasIsEmpty` has a public `len` method, but a private `is_empty` method\n+  --> $DIR/len_without_is_empty.rs:68:5\n+   |\n+LL |     pub fn len(&self) -> isize {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: `is_empty` defined here\n+  --> $DIR/len_without_is_empty.rs:72:5\n+   |\n+LL |     fn is_empty(&self) -> bool {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: item `HasWrongIsEmpty` has a public `len` method but no corresponding `is_empty` method\n-  --> $DIR/len_without_is_empty.rs:61:1\n-   |\n-LL | / impl HasWrongIsEmpty {\n-LL | |     pub fn len(&self) -> isize {\n-LL | |         1\n-LL | |     }\n-...  |\n-LL | |     }\n-LL | | }\n-   | |_^\n+error: struct `HasWrongIsEmpty` has a public `len` method, but the `is_empty` method has an unexpected signature\n+  --> $DIR/len_without_is_empty.rs:80:5\n+   |\n+LL |     pub fn len(&self) -> isize {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: `is_empty` defined here\n+  --> $DIR/len_without_is_empty.rs:84:5\n+   |\n+LL |     pub fn is_empty(&self, x: u32) -> bool {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: expected signature: `(&self) -> bool`\n+\n+error: struct `MismatchedSelf` has a public `len` method, but the `is_empty` method has an unexpected signature\n+  --> $DIR/len_without_is_empty.rs:92:5\n+   |\n+LL |     pub fn len(self) -> isize {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: `is_empty` defined here\n+  --> $DIR/len_without_is_empty.rs:96:5\n+   |\n+LL |     pub fn is_empty(&self) -> bool {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: expected signature: `(self) -> bool`\n \n error: trait `DependsOnFoo` has a `len` method but no (possibly inherited) `is_empty` method\n-  --> $DIR/len_without_is_empty.rs:141:1\n+  --> $DIR/len_without_is_empty.rs:171:1\n    |\n LL | / pub trait DependsOnFoo: Foo {\n LL | |     fn len(&mut self) -> usize;\n LL | | }\n    | |_^\n \n-error: aborting due to 5 previous errors\n+error: aborting due to 6 previous errors\n "}]}