{"sha": "c8e94975a6541e947a1bd4971e084c8ba637f2b6", "node_id": "C_kwDOAAsO6NoAKGM4ZTk0OTc1YTY1NDFlOTQ3YTFiZDQ5NzFlMDg0YzhiYTYzN2YyYjY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-14T15:18:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-14T15:18:26Z"}, "message": "Auto merge of #90596 - the8472:path-hash-opt, r=Mark-Simulacrum\n\nOptimize Eq and Hash for Path/PathBuf\n\n```\n# new\n\ntest path::tests::bench_hash_path_long                            ... bench:          86 ns/iter (+/- 1)\ntest path::tests::bench_hash_path_short                           ... bench:          13 ns/iter (+/- 1)\ntest path::tests::bench_path_hashset                              ... bench:         197 ns/iter (+/- 6)\ntest path::tests::bench_path_hashset_miss                         ... bench:          94 ns/iter (+/- 4)\n\n# old\n\ntest path::tests::bench_hash_path_long                            ... bench:         192 ns/iter (+/- 2)\ntest path::tests::bench_hash_path_short                           ... bench:          33 ns/iter (+/- 1)\ntest path::tests::bench_path_hashset                              ... bench:       1,121 ns/iter (+/- 24)\ntest path::tests::bench_path_hashset_miss                         ... bench:         273 ns/iter (+/- 6)\n```", "tree": {"sha": "66f5ba4c28a327483a36b5bfc1e775bb07fb72c7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/66f5ba4c28a327483a36b5bfc1e775bb07fb72c7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c8e94975a6541e947a1bd4971e084c8ba637f2b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c8e94975a6541e947a1bd4971e084c8ba637f2b6", "html_url": "https://github.com/rust-lang/rust/commit/c8e94975a6541e947a1bd4971e084c8ba637f2b6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c8e94975a6541e947a1bd4971e084c8ba637f2b6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b2c45441d7eefed63f6658ff8becd5a51eaeae1", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b2c45441d7eefed63f6658ff8becd5a51eaeae1", "html_url": "https://github.com/rust-lang/rust/commit/3b2c45441d7eefed63f6658ff8becd5a51eaeae1"}, {"sha": "c1ea7bdc87a07c733769fd6adaa16818d692df24", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1ea7bdc87a07c733769fd6adaa16818d692df24", "html_url": "https://github.com/rust-lang/rust/commit/c1ea7bdc87a07c733769fd6adaa16818d692df24"}], "stats": {"total": 151, "additions": 140, "deletions": 11}, "files": [{"sha": "cf2cd5adc4848102756a30c207f34e2e4595e169", "filename": "library/std/src/path.rs", "status": "modified", "additions": 61, "deletions": 9, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/c8e94975a6541e947a1bd4971e084c8ba637f2b6/library%2Fstd%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8e94975a6541e947a1bd4971e084c8ba637f2b6/library%2Fstd%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpath.rs?ref=c8e94975a6541e947a1bd4971e084c8ba637f2b6", "patch": "@@ -979,6 +979,25 @@ impl FusedIterator for Components<'_> {}\n impl<'a> cmp::PartialEq for Components<'a> {\n     #[inline]\n     fn eq(&self, other: &Components<'a>) -> bool {\n+        let Components { path: _, front: _, back: _, has_physical_root: _, prefix: _ } = self;\n+\n+        // Fast path for exact matches, e.g. for hashmap lookups.\n+        // Don't explicitly compare the prefix or has_physical_root fields since they'll\n+        // either be covered by the `path` buffer or are only relevant for `prefix_verbatim()`.\n+        if self.path.len() == other.path.len()\n+            && self.front == other.front\n+            && self.back == State::Body\n+            && other.back == State::Body\n+            && self.prefix_verbatim() == other.prefix_verbatim()\n+        {\n+            // possible future improvement: this could bail out earlier if there were a\n+            // reverse memcmp/bcmp comparing back to front\n+            if self.path == other.path {\n+                return true;\n+            }\n+        }\n+\n+        // compare back to front since absolute paths often share long prefixes\n         Iterator::eq(self.clone().rev(), other.clone().rev())\n     }\n }\n@@ -1013,13 +1032,12 @@ fn compare_components(mut left: Components<'_>, mut right: Components<'_>) -> cm\n     // The fast path isn't taken for paths with a PrefixComponent to avoid backtracking into\n     // the middle of one\n     if left.prefix.is_none() && right.prefix.is_none() && left.front == right.front {\n-        // this might benefit from a [u8]::first_mismatch simd implementation, if it existed\n-        let first_difference =\n-            match left.path.iter().zip(right.path.iter()).position(|(&a, &b)| a != b) {\n-                None if left.path.len() == right.path.len() => return cmp::Ordering::Equal,\n-                None => left.path.len().min(right.path.len()),\n-                Some(diff) => diff,\n-            };\n+        // possible future improvement: a [u8]::first_mismatch simd implementation\n+        let first_difference = match left.path.iter().zip(right.path).position(|(&a, &b)| a != b) {\n+            None if left.path.len() == right.path.len() => return cmp::Ordering::Equal,\n+            None => left.path.len().min(right.path.len()),\n+            Some(diff) => diff,\n+        };\n \n         if let Some(previous_sep) =\n             left.path[..first_difference].iter().rposition(|&b| left.is_sep_byte(b))\n@@ -2873,9 +2891,43 @@ impl cmp::PartialEq for Path {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Hash for Path {\n     fn hash<H: Hasher>(&self, h: &mut H) {\n-        for component in self.components() {\n-            component.hash(h);\n+        let bytes = self.as_u8_slice();\n+        let prefix_len = match parse_prefix(&self.inner) {\n+            Some(prefix) => {\n+                prefix.hash(h);\n+                prefix.len()\n+            }\n+            None => 0,\n+        };\n+        let bytes = &bytes[prefix_len..];\n+\n+        let mut component_start = 0;\n+        let mut bytes_hashed = 0;\n+\n+        for i in 0..bytes.len() {\n+            if is_sep_byte(bytes[i]) {\n+                if i > component_start {\n+                    let to_hash = &bytes[component_start..i];\n+                    h.write(to_hash);\n+                    bytes_hashed += to_hash.len();\n+                }\n+\n+                // skip over separator and optionally a following CurDir item\n+                // since components() would normalize these away\n+                component_start = i + match bytes[i..] {\n+                    [_, b'.', b'/', ..] | [_, b'.'] => 2,\n+                    _ => 1,\n+                };\n+            }\n+        }\n+\n+        if component_start < bytes.len() {\n+            let to_hash = &bytes[component_start..];\n+            h.write(to_hash);\n+            bytes_hashed += to_hash.len();\n         }\n+\n+        h.write_usize(bytes_hashed);\n     }\n }\n "}, {"sha": "2bf499e1ab823b656aefaab444a876fdcdd08b8a", "filename": "library/std/src/path/tests.rs", "status": "modified", "additions": 78, "deletions": 2, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/c8e94975a6541e947a1bd4971e084c8ba637f2b6/library%2Fstd%2Fsrc%2Fpath%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8e94975a6541e947a1bd4971e084c8ba637f2b6/library%2Fstd%2Fsrc%2Fpath%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpath%2Ftests.rs?ref=c8e94975a6541e947a1bd4971e084c8ba637f2b6", "patch": "@@ -1,6 +1,8 @@\n use super::*;\n \n-use crate::collections::BTreeSet;\n+use crate::collections::hash_map::DefaultHasher;\n+use crate::collections::{BTreeSet, HashSet};\n+use crate::hash::Hasher;\n use crate::rc::Rc;\n use crate::sync::Arc;\n use core::hint::black_box;\n@@ -1632,7 +1634,25 @@ fn into_rc() {\n fn test_ord() {\n     macro_rules! ord(\n         ($ord:ident, $left:expr, $right:expr) => ( {\n-            assert_eq!(Path::new($left).cmp(&Path::new($right)), core::cmp::Ordering::$ord);\n+            use core::cmp::Ordering;\n+\n+            let left = Path::new($left);\n+            let right = Path::new($right);\n+            assert_eq!(left.cmp(&right), Ordering::$ord);\n+            if (core::cmp::Ordering::$ord == Ordering::Equal) {\n+                assert_eq!(left, right);\n+\n+                let mut hasher = DefaultHasher::new();\n+                left.hash(&mut hasher);\n+                let left_hash = hasher.finish();\n+                hasher = DefaultHasher::new();\n+                right.hash(&mut hasher);\n+                let right_hash = hasher.finish();\n+\n+                assert_eq!(left_hash, right_hash, \"hashes for {:?} and {:?} must match\", left, right);\n+            } else {\n+                assert_ne!(left, right);\n+            }\n         });\n     );\n \n@@ -1693,3 +1713,59 @@ fn bench_path_cmp_fast_path_short(b: &mut test::Bencher) {\n         set.insert(paths[500].as_path());\n     });\n }\n+\n+#[bench]\n+fn bench_path_hashset(b: &mut test::Bencher) {\n+    let prefix = \"/my/home/is/my/castle/and/my/castle/has/a/rusty/workbench/\";\n+    let paths: Vec<_> =\n+        (0..1000).map(|num| PathBuf::from(prefix).join(format!(\"file {}.rs\", num))).collect();\n+\n+    let mut set = HashSet::new();\n+\n+    paths.iter().for_each(|p| {\n+        set.insert(p.as_path());\n+    });\n+\n+    b.iter(|| {\n+        set.remove(paths[500].as_path());\n+        set.insert(black_box(paths[500].as_path()))\n+    });\n+}\n+\n+#[bench]\n+fn bench_path_hashset_miss(b: &mut test::Bencher) {\n+    let prefix = \"/my/home/is/my/castle/and/my/castle/has/a/rusty/workbench/\";\n+    let paths: Vec<_> =\n+        (0..1000).map(|num| PathBuf::from(prefix).join(format!(\"file {}.rs\", num))).collect();\n+\n+    let mut set = HashSet::new();\n+\n+    paths.iter().for_each(|p| {\n+        set.insert(p.as_path());\n+    });\n+\n+    let probe = PathBuf::from(prefix).join(\"other\");\n+\n+    b.iter(|| set.remove(black_box(probe.as_path())));\n+}\n+\n+#[bench]\n+fn bench_hash_path_short(b: &mut test::Bencher) {\n+    let mut hasher = DefaultHasher::new();\n+    let path = Path::new(\"explorer.exe\");\n+\n+    b.iter(|| black_box(path).hash(&mut hasher));\n+\n+    black_box(hasher.finish());\n+}\n+\n+#[bench]\n+fn bench_hash_path_long(b: &mut test::Bencher) {\n+    let mut hasher = DefaultHasher::new();\n+    let path =\n+        Path::new(\"/aaaaa/aaaaaa/./../aaaaaaaa/bbbbbbbbbbbbb/ccccccccccc/ddddddddd/eeeeeee.fff\");\n+\n+    b.iter(|| black_box(path).hash(&mut hasher));\n+\n+    black_box(hasher.finish());\n+}"}, {"sha": "717add9ec48dbe40aa2823c8b3c13dabc590b203", "filename": "library/std/src/sys/unix/path.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c8e94975a6541e947a1bd4971e084c8ba637f2b6/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8e94975a6541e947a1bd4971e084c8ba637f2b6/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fpath.rs?ref=c8e94975a6541e947a1bd4971e084c8ba637f2b6", "patch": "@@ -11,6 +11,7 @@ pub fn is_verbatim_sep(b: u8) -> bool {\n     b == b'/'\n }\n \n+#[inline]\n pub fn parse_prefix(_: &OsStr) -> Option<Prefix<'_>> {\n     None\n }"}]}