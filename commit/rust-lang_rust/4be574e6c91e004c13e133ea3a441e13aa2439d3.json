{"sha": "4be574e6c91e004c13e133ea3a441e13aa2439d3", "node_id": "C_kwDOAAsO6NoAKDRiZTU3NGU2YzkxZTAwNGMxM2UxMzNlYTNhNDQxZTEzYWEyNDM5ZDM", "commit": {"author": {"name": "Caio", "email": "c410.f3r@gmail.com", "date": "2021-09-30T10:49:32Z"}, "committer": {"name": "Caio", "email": "c410.f3r@gmail.com", "date": "2021-09-30T10:49:32Z"}, "message": "Add 'core::array::from_fn' and 'core::array::try_from_fn'", "tree": {"sha": "10817dfb2fff754dd6645bae63e89805d64f9c07", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/10817dfb2fff754dd6645bae63e89805d64f9c07"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4be574e6c91e004c13e133ea3a441e13aa2439d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4be574e6c91e004c13e133ea3a441e13aa2439d3", "html_url": "https://github.com/rust-lang/rust/commit/4be574e6c91e004c13e133ea3a441e13aa2439d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4be574e6c91e004c13e133ea3a441e13aa2439d3/comments", "author": {"login": "c410-f3r", "id": 17877264, "node_id": "MDQ6VXNlcjE3ODc3MjY0", "avatar_url": "https://avatars.githubusercontent.com/u/17877264?v=4", "gravatar_id": "", "url": "https://api.github.com/users/c410-f3r", "html_url": "https://github.com/c410-f3r", "followers_url": "https://api.github.com/users/c410-f3r/followers", "following_url": "https://api.github.com/users/c410-f3r/following{/other_user}", "gists_url": "https://api.github.com/users/c410-f3r/gists{/gist_id}", "starred_url": "https://api.github.com/users/c410-f3r/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/c410-f3r/subscriptions", "organizations_url": "https://api.github.com/users/c410-f3r/orgs", "repos_url": "https://api.github.com/users/c410-f3r/repos", "events_url": "https://api.github.com/users/c410-f3r/events{/privacy}", "received_events_url": "https://api.github.com/users/c410-f3r/received_events", "type": "User", "site_admin": false}, "committer": {"login": "c410-f3r", "id": 17877264, "node_id": "MDQ6VXNlcjE3ODc3MjY0", "avatar_url": "https://avatars.githubusercontent.com/u/17877264?v=4", "gravatar_id": "", "url": "https://api.github.com/users/c410-f3r", "html_url": "https://github.com/c410-f3r", "followers_url": "https://api.github.com/users/c410-f3r/followers", "following_url": "https://api.github.com/users/c410-f3r/following{/other_user}", "gists_url": "https://api.github.com/users/c410-f3r/gists{/gist_id}", "starred_url": "https://api.github.com/users/c410-f3r/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/c410-f3r/subscriptions", "organizations_url": "https://api.github.com/users/c410-f3r/orgs", "repos_url": "https://api.github.com/users/c410-f3r/repos", "events_url": "https://api.github.com/users/c410-f3r/events{/privacy}", "received_events_url": "https://api.github.com/users/c410-f3r/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac8dd1b2f24dc62c962172b27433106b4e84dc62", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac8dd1b2f24dc62c962172b27433106b4e84dc62", "html_url": "https://github.com/rust-lang/rust/commit/ac8dd1b2f24dc62c962172b27433106b4e84dc62"}], "stats": {"total": 180, "additions": 171, "deletions": 9}, "files": [{"sha": "b823c33ee23c6b85d6dd831df0d1c86114b0b751", "filename": "library/core/src/array/mod.rs", "status": "modified", "additions": 91, "deletions": 7, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/4be574e6c91e004c13e133ea3a441e13aa2439d3/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4be574e6c91e004c13e133ea3a441e13aa2439d3/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fmod.rs?ref=4be574e6c91e004c13e133ea3a441e13aa2439d3", "patch": "@@ -20,6 +20,69 @@ mod iter;\n #[stable(feature = \"array_value_iter\", since = \"1.51.0\")]\n pub use iter::IntoIter;\n \n+/// Creates an array `[T; N]` where each array element `T` is returned by the `cb` call.\n+///\n+/// # Arguments\n+///\n+/// * `cb`: Callback where the passed argument is the current array index.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// #![feature(array_from_fn)]\n+///\n+/// let array = core::array::from_fn(|i| i);\n+/// assert_eq!(array, [0, 1, 2, 3, 4]);\n+/// ```\n+#[inline]\n+#[unstable(feature = \"array_from_fn\", issue = \"89379\")]\n+pub fn from_fn<F, T, const N: usize>(mut cb: F) -> [T; N]\n+where\n+    F: FnMut(usize) -> T,\n+{\n+    let mut idx = 0;\n+    [(); N].map(|_| {\n+        let res = cb(idx);\n+        idx += 1;\n+        res\n+    })\n+}\n+\n+/// Creates an array `[T; N]` where each fallible array element `T` is returned by the `cb` call.\n+/// Unlike `core::array::from_fn`, where the element creation can't fail, this version will return an error\n+/// if any element creation was unsuccessful.\n+///\n+/// # Arguments\n+///\n+/// * `cb`: Callback where the passed argument is the current array index.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// #![feature(array_from_fn)]\n+///\n+/// #[derive(Debug, PartialEq)]\n+/// enum SomeError {\n+///     Foo,\n+/// }\n+///\n+/// let array = core::array::try_from_fn(|i| Ok::<_, SomeError>(i));\n+/// assert_eq!(array, Ok([0, 1, 2, 3, 4]));\n+///\n+/// let another_array = core::array::try_from_fn::<SomeError, _, (), 2>(|_| Err(SomeError::Foo));\n+/// assert_eq!(another_array, Err(SomeError::Foo));\n+/// ```\n+#[inline]\n+#[unstable(feature = \"array_from_fn\", issue = \"89379\")]\n+pub fn try_from_fn<E, F, T, const N: usize>(cb: F) -> Result<[T; N], E>\n+where\n+    F: FnMut(usize) -> Result<T, E>,\n+{\n+    // SAFETY: we know for certain that this iterator will yield exactly `N`\n+    // items.\n+    unsafe { collect_into_array_rslt_unchecked(&mut (0..N).map(cb)) }\n+}\n+\n /// Converts a reference to `T` into a reference to an array of length 1 (without copying).\n #[stable(feature = \"array_from_ref\", since = \"1.53.0\")]\n pub fn from_ref<T>(s: &T) -> &[T; 1] {\n@@ -448,13 +511,15 @@ impl<T, const N: usize> [T; N] {\n ///\n /// It is up to the caller to guarantee that `iter` yields at least `N` items.\n /// Violating this condition causes undefined behavior.\n-unsafe fn collect_into_array_unchecked<I, const N: usize>(iter: &mut I) -> [I::Item; N]\n+unsafe fn collect_into_array_rslt_unchecked<E, I, T, const N: usize>(\n+    iter: &mut I,\n+) -> Result<[T; N], E>\n where\n     // Note: `TrustedLen` here is somewhat of an experiment. This is just an\n     // internal function, so feel free to remove if this bound turns out to be a\n     // bad idea. In that case, remember to also remove the lower bound\n     // `debug_assert!` below!\n-    I: Iterator + TrustedLen,\n+    I: Iterator<Item = Result<T, E>> + TrustedLen,\n {\n     debug_assert!(N <= iter.size_hint().1.unwrap_or(usize::MAX));\n     debug_assert!(N <= iter.size_hint().0);\n@@ -463,6 +528,18 @@ where\n     unsafe { collect_into_array(iter).unwrap_unchecked() }\n }\n \n+// Infallible version of `collect_into_array_rslt_unchecked`.\n+unsafe fn collect_into_array_unchecked<I, const N: usize>(iter: &mut I) -> [I::Item; N]\n+where\n+    I: Iterator + TrustedLen,\n+{\n+    let mut map = iter.map(|el| Ok::<_, Infallible>(el));\n+\n+    // SAFETY: Valid array elements are covered by the fact that all passed values\n+    // to `collect_into_array` are `Ok`.\n+    unsafe { collect_into_array_rslt_unchecked(&mut map).unwrap_unchecked() }\n+}\n+\n /// Pulls `N` items from `iter` and returns them as an array. If the iterator\n /// yields fewer than `N` items, `None` is returned and all already yielded\n /// items are dropped.\n@@ -473,13 +550,13 @@ where\n ///\n /// If `iter.next()` panicks, all items already yielded by the iterator are\n /// dropped.\n-fn collect_into_array<I, const N: usize>(iter: &mut I) -> Option<[I::Item; N]>\n+fn collect_into_array<E, I, T, const N: usize>(iter: &mut I) -> Option<Result<[T; N], E>>\n where\n-    I: Iterator,\n+    I: Iterator<Item = Result<T, E>>,\n {\n     if N == 0 {\n         // SAFETY: An empty array is always inhabited and has no validity invariants.\n-        return unsafe { Some(mem::zeroed()) };\n+        return unsafe { Some(Ok(mem::zeroed())) };\n     }\n \n     struct Guard<T, const N: usize> {\n@@ -504,7 +581,14 @@ where\n     let mut guard: Guard<_, N> =\n         Guard { ptr: MaybeUninit::slice_as_mut_ptr(&mut array), initialized: 0 };\n \n-    while let Some(item) = iter.next() {\n+    while let Some(item_rslt) = iter.next() {\n+        let item = match item_rslt {\n+            Err(err) => {\n+                return Some(Err(err));\n+            }\n+            Ok(elem) => elem,\n+        };\n+\n         // SAFETY: `guard.initialized` starts at 0, is increased by one in the\n         // loop and the loop is aborted once it reaches N (which is\n         // `array.len()`).\n@@ -520,7 +604,7 @@ where\n             // SAFETY: the condition above asserts that all elements are\n             // initialized.\n             let out = unsafe { MaybeUninit::array_assume_init(array) };\n-            return Some(out);\n+            return Some(Ok(out));\n         }\n     }\n "}, {"sha": "6889fe9a19e71e9fc2898a4f1b20fd11424d0448", "filename": "library/core/tests/array.rs", "status": "modified", "additions": 79, "deletions": 2, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/4be574e6c91e004c13e133ea3a441e13aa2439d3/library%2Fcore%2Ftests%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4be574e6c91e004c13e133ea3a441e13aa2439d3/library%2Fcore%2Ftests%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Farray.rs?ref=4be574e6c91e004c13e133ea3a441e13aa2439d3", "patch": "@@ -1,5 +1,6 @@\n use core::array;\n use core::convert::TryFrom;\n+use core::sync::atomic::{AtomicUsize, Ordering};\n \n #[test]\n fn array_from_ref() {\n@@ -303,8 +304,6 @@ fn array_map() {\n #[test]\n #[should_panic(expected = \"test succeeded\")]\n fn array_map_drop_safety() {\n-    use core::sync::atomic::AtomicUsize;\n-    use core::sync::atomic::Ordering;\n     static DROPPED: AtomicUsize = AtomicUsize::new(0);\n     struct DropCounter;\n     impl Drop for DropCounter {\n@@ -356,3 +355,81 @@ fn cell_allows_array_cycle() {\n     b3.a[0].set(Some(&b1));\n     b3.a[1].set(Some(&b2));\n }\n+\n+#[test]\n+fn array_from_fn() {\n+    let array = core::array::from_fn(|idx| idx);\n+    assert_eq!(array, [0, 1, 2, 3, 4]);\n+}\n+\n+#[test]\n+fn array_try_from_fn() {\n+    #[derive(Debug, PartialEq)]\n+    enum SomeError {\n+        Foo,\n+    }\n+\n+    let array = core::array::try_from_fn(|i| Ok::<_, SomeError>(i));\n+    assert_eq!(array, Ok([0, 1, 2, 3, 4]));\n+\n+    let another_array = core::array::try_from_fn::<SomeError, _, (), 2>(|_| Err(SomeError::Foo));\n+    assert_eq!(another_array, Err(SomeError::Foo));\n+}\n+\n+#[test]\n+fn array_try_from_fn_drops_inserted_elements_on_err() {\n+    static DROP_COUNTER: AtomicUsize = AtomicUsize::new(0);\n+\n+    struct CountDrop;\n+    impl Drop for CountDrop {\n+        fn drop(&mut self) {\n+            DROP_COUNTER.fetch_add(1, Ordering::SeqCst);\n+        }\n+    }\n+\n+    let _ = catch_unwind_silent(move || {\n+        let _: Result<[CountDrop; 4], ()> = core::array::try_from_fn(|idx| {\n+            if idx == 2 {\n+                return Err(());\n+            }\n+            Ok(CountDrop)\n+        });\n+    });\n+\n+    assert_eq!(DROP_COUNTER.load(Ordering::SeqCst), 2);\n+}\n+\n+#[test]\n+fn array_try_from_fn_drops_inserted_elements_on_panic() {\n+    static DROP_COUNTER: AtomicUsize = AtomicUsize::new(0);\n+\n+    struct CountDrop;\n+    impl Drop for CountDrop {\n+        fn drop(&mut self) {\n+            DROP_COUNTER.fetch_add(1, Ordering::SeqCst);\n+        }\n+    }\n+\n+    let _ = catch_unwind_silent(move || {\n+        let _: Result<[CountDrop; 4], ()> = core::array::try_from_fn(|idx| {\n+            if idx == 2 {\n+                panic!(\"peek a boo\");\n+            }\n+            Ok(CountDrop)\n+        });\n+    });\n+\n+    assert_eq!(DROP_COUNTER.load(Ordering::SeqCst), 2);\n+}\n+\n+// https://stackoverflow.com/a/59211505\n+fn catch_unwind_silent<F, R>(f: F) -> std::thread::Result<R>\n+where\n+    F: FnOnce() -> R + core::panic::UnwindSafe,\n+{\n+    let prev_hook = std::panic::take_hook();\n+    std::panic::set_hook(Box::new(|_| {}));\n+    let result = std::panic::catch_unwind(f);\n+    std::panic::set_hook(prev_hook);\n+    result\n+}"}, {"sha": "12088e91840d8bf217b9288b80b0dcfea65818a7", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4be574e6c91e004c13e133ea3a441e13aa2439d3/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4be574e6c91e004c13e133ea3a441e13aa2439d3/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=4be574e6c91e004c13e133ea3a441e13aa2439d3", "patch": "@@ -26,6 +26,7 @@\n #![feature(extern_types)]\n #![feature(flt2dec)]\n #![feature(fmt_internals)]\n+#![feature(array_from_fn)]\n #![feature(hashmap_internals)]\n #![feature(try_find)]\n #![feature(is_sorted)]"}]}