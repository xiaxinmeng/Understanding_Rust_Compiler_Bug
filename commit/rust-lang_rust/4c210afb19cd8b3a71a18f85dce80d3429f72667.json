{"sha": "4c210afb19cd8b3a71a18f85dce80d3429f72667", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjMjEwYWZiMTljZDhiM2E3MWExOGY4NWRjZTgwZDM0MjlmNzI2Njc=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-01-29T23:20:24Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-01-30T18:43:41Z"}, "message": "make `overlapping_impls` call closures instead of returning", "tree": {"sha": "288f5009c7c1a5d3b8482ceb7ad17767b35243f1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/288f5009c7c1a5d3b8482ceb7ad17767b35243f1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4c210afb19cd8b3a71a18f85dce80d3429f72667", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4c210afb19cd8b3a71a18f85dce80d3429f72667", "html_url": "https://github.com/rust-lang/rust/commit/4c210afb19cd8b3a71a18f85dce80d3429f72667", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4c210afb19cd8b3a71a18f85dce80d3429f72667/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c48f46ba368a5ae77acb0db46843a3e432ff87d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/c48f46ba368a5ae77acb0db46843a3e432ff87d3", "html_url": "https://github.com/rust-lang/rust/commit/c48f46ba368a5ae77acb0db46843a3e432ff87d3"}], "stats": {"total": 125, "additions": 75, "deletions": 50}, "files": [{"sha": "0e371e0130a39107e5ad62f28b56fdf1c3a9e0a5", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4c210afb19cd8b3a71a18f85dce80d3429f72667/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c210afb19cd8b3a71a18f85dce80d3429f72667/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=4c210afb19cd8b3a71a18f85dce80d3429f72667", "patch": "@@ -65,6 +65,7 @@\n #![feature(specialization)]\n #![feature(unboxed_closures)]\n #![feature(underscore_lifetimes)]\n+#![feature(universal_impl_trait)]\n #![feature(trace_macros)]\n #![feature(catch_expr)]\n #![feature(test)]"}, {"sha": "77bb78e4ee0783c59846cb44ac4ab92564950699", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4c210afb19cd8b3a71a18f85dce80d3429f72667/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c210afb19cd8b3a71a18f85dce80d3429f72667/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=4c210afb19cd8b3a71a18f85dce80d3429f72667", "patch": "@@ -40,13 +40,20 @@ pub struct OverlapResult<'tcx> {\n     pub intercrate_ambiguity_causes: Vec<IntercrateAmbiguityCause>,\n }\n \n-/// If there are types that satisfy both impls, returns a suitably-freshened\n-/// `ImplHeader` with those types substituted\n-pub fn overlapping_impls<'cx, 'gcx, 'tcx>(infcx: &InferCtxt<'cx, 'gcx, 'tcx>,\n-                                          impl1_def_id: DefId,\n-                                          impl2_def_id: DefId,\n-                                          intercrate_mode: IntercrateMode)\n-                                          -> Option<OverlapResult<'tcx>>\n+/// If there are types that satisfy both impls, invokes `on_overlap`\n+/// with a suitably-freshened `ImplHeader` with those types\n+/// substituted. Otherwise, invokes `no_overlap`.\n+pub fn overlapping_impls<F1, F2, R>(\n+    infcx: &InferCtxt<'_, '_, '_>,\n+    impl1_def_id: DefId,\n+    impl2_def_id: DefId,\n+    intercrate_mode: IntercrateMode,\n+    on_overlap: F1,\n+    no_overlap: F2,\n+) -> R\n+where\n+    F1: FnOnce(OverlapResult<'_>) -> R,\n+    F2: FnOnce() -> R,\n {\n     debug!(\"impl_can_satisfy(\\\n            impl1_def_id={:?}, \\\n@@ -57,7 +64,11 @@ pub fn overlapping_impls<'cx, 'gcx, 'tcx>(infcx: &InferCtxt<'cx, 'gcx, 'tcx>,\n            intercrate_mode);\n \n     let selcx = &mut SelectionContext::intercrate(infcx, intercrate_mode);\n-    overlap(selcx, impl1_def_id, impl2_def_id)\n+    if let Some(r) = overlap(selcx, impl1_def_id, impl2_def_id) {\n+        on_overlap(r)\n+    } else {\n+        no_overlap()\n+    }\n }\n \n fn with_fresh_ty_vars<'cx, 'gcx, 'tcx>(selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,"}, {"sha": "4ad2a4955e9ede1262a64371f3b1cb88eb30a4b4", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 26, "deletions": 25, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/4c210afb19cd8b3a71a18f85dce80d3429f72667/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c210afb19cd8b3a71a18f85dce80d3429f72667/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=4c210afb19cd8b3a71a18f85dce80d3429f72667", "patch": "@@ -134,26 +134,27 @@ impl<'a, 'gcx, 'tcx> Children {\n \n             let tcx = tcx.global_tcx();\n             let (le, ge) = tcx.infer_ctxt().enter(|infcx| {\n-                let overlap = traits::overlapping_impls(&infcx,\n-                                                        possible_sibling,\n-                                                        impl_def_id,\n-                                                        traits::IntercrateMode::Issue43355);\n-                if let Some(overlap) = overlap {\n-                    if tcx.impls_are_allowed_to_overlap(impl_def_id, possible_sibling) {\n-                        return Ok((false, false));\n-                    }\n-\n-                    let le = tcx.specializes((impl_def_id, possible_sibling));\n-                    let ge = tcx.specializes((possible_sibling, impl_def_id));\n-\n-                    if le == ge {\n-                        Err(overlap_error(overlap))\n-                    } else {\n-                        Ok((le, ge))\n-                    }\n-                } else {\n-                    Ok((false, false))\n-                }\n+                traits::overlapping_impls(\n+                    &infcx,\n+                    possible_sibling,\n+                    impl_def_id,\n+                    traits::IntercrateMode::Issue43355,\n+                    |overlap| {\n+                        if tcx.impls_are_allowed_to_overlap(impl_def_id, possible_sibling) {\n+                            return Ok((false, false));\n+                        }\n+\n+                        let le = tcx.specializes((impl_def_id, possible_sibling));\n+                        let ge = tcx.specializes((possible_sibling, impl_def_id));\n+\n+                        if le == ge {\n+                            Err(overlap_error(overlap))\n+                        } else {\n+                            Ok((le, ge))\n+                        }\n+                    },\n+                    || Ok((false, false)),\n+                )\n             })?;\n \n             if le && !ge {\n@@ -172,14 +173,14 @@ impl<'a, 'gcx, 'tcx> Children {\n             } else {\n                 if !tcx.impls_are_allowed_to_overlap(impl_def_id, possible_sibling) {\n                     tcx.infer_ctxt().enter(|infcx| {\n-                        if let Some(overlap) = traits::overlapping_impls(\n+                        traits::overlapping_impls(\n                             &infcx,\n                             possible_sibling,\n                             impl_def_id,\n-                            traits::IntercrateMode::Fixed)\n-                        {\n-                            last_lint = Some(overlap_error(overlap));\n-                        }\n+                            traits::IntercrateMode::Fixed,\n+                            |overlap| last_lint = Some(overlap_error(overlap)),\n+                            || (),\n+                        )\n                     });\n                 }\n "}, {"sha": "c8a37c01094ac8b4493cb705660e1769d382ef28", "filename": "src/librustc_typeck/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 29, "deletions": 17, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/4c210afb19cd8b3a71a18f85dce80d3429f72667/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c210afb19cd8b3a71a18f85dce80d3429f72667/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs?ref=4c210afb19cd8b3a71a18f85dce80d3429f72667", "patch": "@@ -83,27 +83,39 @@ impl<'a, 'tcx> InherentOverlapChecker<'a, 'tcx> {\n         for (i, &impl1_def_id) in impls.iter().enumerate() {\n             for &impl2_def_id in &impls[(i + 1)..] {\n                 let used_to_be_allowed = self.tcx.infer_ctxt().enter(|infcx| {\n-                    if let Some(overlap) =\n-                        traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id,\n-                                                  IntercrateMode::Issue43355)\n-                    {\n-                        self.check_for_common_items_in_impls(\n-                            impl1_def_id, impl2_def_id, overlap, false);\n-                        false\n-                    } else {\n-                        true\n-                    }\n+                    traits::overlapping_impls(\n+                        &infcx,\n+                        impl1_def_id,\n+                        impl2_def_id,\n+                        IntercrateMode::Issue43355,\n+                        |overlap| {\n+                            self.check_for_common_items_in_impls(\n+                                impl1_def_id,\n+                                impl2_def_id,\n+                                overlap,\n+                                false,\n+                            );\n+                            false\n+                        },\n+                        || true,\n+                    )\n                 });\n \n                 if used_to_be_allowed {\n                     self.tcx.infer_ctxt().enter(|infcx| {\n-                        if let Some(overlap) =\n-                            traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id,\n-                                                      IntercrateMode::Fixed)\n-                        {\n-                            self.check_for_common_items_in_impls(\n-                                impl1_def_id, impl2_def_id, overlap, true);\n-                        }\n+                        traits::overlapping_impls(\n+                            &infcx,\n+                            impl1_def_id,\n+                            impl2_def_id,\n+                            IntercrateMode::Fixed,\n+                            |overlap| self.check_for_common_items_in_impls(\n+                                impl1_def_id,\n+                                impl2_def_id,\n+                                overlap,\n+                                true,\n+                            ),\n+                            || (),\n+                        );\n                     });\n                 }\n             }"}]}