{"sha": "da2152c9ae2c3b0f8277dfb703c9e012dadfb17f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhMjE1MmM5YWUyYzNiMGY4Mjc3ZGZiNzAzYzllMDEyZGFkZmIxN2Y=", "commit": {"author": {"name": "Julian Orth", "email": "ju.orth@gmail.com", "date": "2014-10-18T21:34:20Z"}, "committer": {"name": "Julian Orth", "email": "ju.orth@gmail.com", "date": "2014-10-24T15:18:10Z"}, "message": "Improve shootout-reverse-complement", "tree": {"sha": "cae6d252cdcb01687e51b2890829b8acb1b7964a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cae6d252cdcb01687e51b2890829b8acb1b7964a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da2152c9ae2c3b0f8277dfb703c9e012dadfb17f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da2152c9ae2c3b0f8277dfb703c9e012dadfb17f", "html_url": "https://github.com/rust-lang/rust/commit/da2152c9ae2c3b0f8277dfb703c9e012dadfb17f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da2152c9ae2c3b0f8277dfb703c9e012dadfb17f/comments", "author": {"login": "mahkoh", "id": 1882250, "node_id": "MDQ6VXNlcjE4ODIyNTA=", "avatar_url": "https://avatars.githubusercontent.com/u/1882250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mahkoh", "html_url": "https://github.com/mahkoh", "followers_url": "https://api.github.com/users/mahkoh/followers", "following_url": "https://api.github.com/users/mahkoh/following{/other_user}", "gists_url": "https://api.github.com/users/mahkoh/gists{/gist_id}", "starred_url": "https://api.github.com/users/mahkoh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mahkoh/subscriptions", "organizations_url": "https://api.github.com/users/mahkoh/orgs", "repos_url": "https://api.github.com/users/mahkoh/repos", "events_url": "https://api.github.com/users/mahkoh/events{/privacy}", "received_events_url": "https://api.github.com/users/mahkoh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mahkoh", "id": 1882250, "node_id": "MDQ6VXNlcjE4ODIyNTA=", "avatar_url": "https://avatars.githubusercontent.com/u/1882250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mahkoh", "html_url": "https://github.com/mahkoh", "followers_url": "https://api.github.com/users/mahkoh/followers", "following_url": "https://api.github.com/users/mahkoh/following{/other_user}", "gists_url": "https://api.github.com/users/mahkoh/gists{/gist_id}", "starred_url": "https://api.github.com/users/mahkoh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mahkoh/subscriptions", "organizations_url": "https://api.github.com/users/mahkoh/orgs", "repos_url": "https://api.github.com/users/mahkoh/repos", "events_url": "https://api.github.com/users/mahkoh/events{/privacy}", "received_events_url": "https://api.github.com/users/mahkoh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "00cc6d24099eb93ecfeb9bf807ab9e5130a01749", "url": "https://api.github.com/repos/rust-lang/rust/commits/00cc6d24099eb93ecfeb9bf807ab9e5130a01749", "html_url": "https://github.com/rust-lang/rust/commit/00cc6d24099eb93ecfeb9bf807ab9e5130a01749"}], "stats": {"total": 347, "additions": 259, "deletions": 88}, "files": [{"sha": "85529cec0e962b6090ec13dbdb36e9c41e3f809c", "filename": "src/test/bench/shootout-reverse-complement.rs", "status": "modified", "additions": 259, "deletions": 88, "changes": 347, "blob_url": "https://github.com/rust-lang/rust/blob/da2152c9ae2c3b0f8277dfb703c9e012dadfb17f/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2152c9ae2c3b0f8277dfb703c9e012dadfb17f/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs?ref=da2152c9ae2c3b0f8277dfb703c9e012dadfb17f", "patch": "@@ -38,113 +38,284 @@\n // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n // OF THE POSSIBILITY OF SUCH DAMAGE.\n \n-// ignore-pretty very bad with line comments\n-// ignore-android doesn't terminate?\n-\n-#![feature(slicing_syntax)]\n-\n-use std::iter::range_step;\n-use std::io::{stdin, stdout, File};\n-\n-static LINE_LEN: uint = 60;\n-\n-fn make_complements() -> [u8, ..256] {\n-    let transforms = [\n-        ('A', 'T'), ('C', 'G'), ('G', 'C'), ('T', 'A'),\n-        ('U', 'A'), ('M', 'K'), ('R', 'Y'), ('W', 'W'),\n-        ('S', 'S'), ('Y', 'R'), ('K', 'M'), ('V', 'B'),\n-        ('H', 'D'), ('D', 'H'), ('B', 'V'), ('N', 'N'),\n-        ('\\n', '\\n')];\n-    let mut complements: [u8, ..256] = [0, ..256];\n-    for (i, c) in complements.iter_mut().enumerate() {\n-        *c = i as u8;\n+#![feature(slicing_syntax, asm, if_let, tuple_indexing)]\n+\n+extern crate libc;\n+\n+use std::io::stdio::{stdin_raw, stdout_raw};\n+use std::sync::{Future};\n+use std::num::{div_rem};\n+use std::ptr::{copy_memory};\n+use std::io::{IoResult, EndOfFile};\n+use std::slice::raw::{mut_buf_as_slice};\n+\n+use shared_memory::{SharedMemory};\n+\n+mod tables {\n+    use std::sync::{Once, ONCE_INIT};\n+\n+    /// Lookup tables.\n+    static mut CPL16: [u16, ..1 << 16] = [0, ..1 << 16];\n+    static mut CPL8:  [u8,  ..1 << 8]  = [0, ..1 << 8];\n+\n+    /// Generates the tables.\n+    pub fn get() -> Tables {\n+        /// To make sure we initialize the tables only once.\n+        static INIT: Once = ONCE_INIT;\n+        INIT.doit(|| {\n+            unsafe {\n+                for i in range(0, 1 << 8) {\n+                    CPL8[i] = match i as u8 {\n+                        b'A' | b'a' => b'T',\n+                        b'C' | b'c' => b'G',\n+                        b'G' | b'g' => b'C',\n+                        b'T' | b't' => b'A',\n+                        b'U' | b'u' => b'A',\n+                        b'M' | b'm' => b'K',\n+                        b'R' | b'r' => b'Y',\n+                        b'W' | b'w' => b'W',\n+                        b'S' | b's' => b'S',\n+                        b'Y' | b'y' => b'R',\n+                        b'K' | b'k' => b'M',\n+                        b'V' | b'v' => b'B',\n+                        b'H' | b'h' => b'D',\n+                        b'D' | b'd' => b'H',\n+                        b'B' | b'b' => b'V',\n+                        b'N' | b'n' => b'N',\n+                        i => i,\n+                    };\n+                }\n+\n+                for (i, v) in CPL16.iter_mut().enumerate() {\n+                    *v = *CPL8.unsafe_get(i & 255) as u16 << 8 |\n+                         *CPL8.unsafe_get(i >> 8)  as u16;\n+                }\n+            }\n+        });\n+        Tables { _dummy: () }\n+    }\n+\n+    /// Accessor for the static arrays.\n+    ///\n+    /// To make sure that the tables can't be accessed without having been initialized.\n+    pub struct Tables {\n+        _dummy: ()\n     }\n-    let lower = 'A' as u8 - 'a' as u8;\n-    for &(from, to) in transforms.iter() {\n-        complements[from as uint] = to as u8;\n-        complements[(from as u8 - lower) as uint] = to as u8;\n+\n+    impl Tables {\n+        /// Retreives the complement for `i`.\n+        pub fn cpl8(self, i: u8) -> u8 {\n+            // Not really unsafe.\n+            unsafe { CPL8[i as uint] }\n+        }\n+\n+        /// Retreives the complement for `i`.\n+        pub fn cpl16(self, i: u16) -> u16 {\n+            unsafe { CPL16[i as uint] }\n+        }\n     }\n-    complements\n }\n \n-fn main() {\n-    let complements = make_complements();\n-    let data = if std::os::getenv(\"RUST_BENCH\").is_some() {\n-        File::open(&Path::new(\"shootout-k-nucleotide.data\")).read_to_end()\n-    } else {\n-        stdin().read_to_end()\n-    };\n-    let mut data = data.unwrap();\n+mod shared_memory {\n+    use std::sync::{Arc};\n+    use std::mem::{transmute};\n+    use std::raw::{Slice};\n \n-    for seq in data.as_mut_slice().split_mut(|c| *c == '>' as u8) {\n-        // skip header and last \\n\n-        let begin = match seq.iter().position(|c| *c == '\\n' as u8) {\n-            None => continue,\n-            Some(c) => c\n-        };\n-        let len = seq.len();\n-        let seq = seq[mut begin+1..len-1];\n-\n-        // arrange line breaks\n-        let len = seq.len();\n-        let off = LINE_LEN - len % (LINE_LEN + 1);\n-        for i in range_step(LINE_LEN, len, LINE_LEN + 1) {\n-            for j in std::iter::count(i, -1).take(off) {\n-                seq[j] = seq[j - 1];\n+    /// Structure for sharing disjoint parts of a vector mutably across tasks.\n+    pub struct SharedMemory {\n+        ptr: Arc<Vec<u8>>,\n+        start: uint,\n+        len: uint,\n+    }\n+\n+    impl SharedMemory {\n+        pub fn new(ptr: Vec<u8>) -> SharedMemory {\n+            let len = ptr.len();\n+            SharedMemory {\n+                ptr: Arc::new(ptr),\n+                start: 0,\n+                len: len,\n+            }\n+        }\n+\n+        pub fn as_mut_slice(&mut self) -> &mut [u8] {\n+            unsafe {\n+                transmute(Slice {\n+                    data: self.ptr.as_ptr().offset(self.start as int) as *const u8,\n+                    len: self.len,\n+                })\n             }\n-            seq[i - off] = '\\n' as u8;\n         }\n \n-        // reverse complement, as\n-        //    seq.reverse(); for c in seq.iter_mut() { *c = complements[*c] }\n-        // but faster:\n-        for (front, back) in two_side_iter(seq) {\n-            let tmp = complements[*front as uint];\n-            *front = complements[*back as uint];\n-            *back = tmp;\n+        pub fn len(&self) -> uint {\n+            self.len\n         }\n-        if seq.len() % 2 == 1 {\n-            let middle = &mut seq[seq.len() / 2];\n-            *middle = complements[*middle as uint];\n+\n+        pub fn split_at(self, mid: uint) -> (SharedMemory, SharedMemory) {\n+            assert!(mid <= self.len);\n+            let left = SharedMemory {\n+                ptr: self.ptr.clone(),\n+                start: self.start,\n+                len: mid,\n+            };\n+            let right = SharedMemory {\n+                ptr: self.ptr,\n+                start: self.start + mid,\n+                len: self.len - mid,\n+            };\n+            (left, right)\n         }\n-    }\n \n-    stdout().write(data.as_slice()).unwrap();\n+        /// Resets the object so that it covers the whole range of the contained vector.\n+        ///\n+        /// You must not call this method if `self` is not the only reference to the\n+        /// shared memory.\n+        ///\n+        /// FIXME: If `Arc` had a method to check if the reference is unique, then we\n+        /// wouldn't need the `unsafe` here.\n+        ///\n+        /// FIXME: If `Arc` had a method to unwrap the contained value, then we could\n+        /// simply unwrap here.\n+        pub unsafe fn reset(self) -> SharedMemory {\n+            let len = self.ptr.len();\n+            SharedMemory {\n+                ptr: self.ptr,\n+                start: 0,\n+                len: len,\n+            }\n+        }\n+    }\n }\n \n-pub struct TwoSideIter<'a, T: 'a> {\n-    first: *mut T,\n-    last: *mut T,\n-    marker: std::kinds::marker::ContravariantLifetime<'a>,\n-    marker2: std::kinds::marker::NoCopy\n+\n+/// Reads all remaining bytes from the stream.\n+fn read_to_end<R: Reader>(r: &mut R) -> IoResult<Vec<u8>> {\n+    const CHUNK: uint = 64 * 1024;\n+\n+    let mut vec = Vec::with_capacity(1024 * 1024);\n+    loop {\n+        if vec.capacity() - vec.len() < CHUNK {\n+            let cap = vec.capacity();\n+            let mult = if cap < 256 * 1024 * 1024 {\n+                // FIXME (mahkoh): Temporary workaround for jemalloc on linux. Replace\n+                // this by 2x once the jemalloc preformance issue has been fixed.\n+                16\n+            } else {\n+                2\n+            };\n+            vec.reserve_exact(mult * cap);\n+        }\n+        unsafe {\n+            let ptr = vec.as_mut_ptr().offset(vec.len() as int);\n+            match mut_buf_as_slice(ptr, CHUNK, |s| r.read(s)) {\n+                Ok(n) => {\n+                    let len = vec.len();\n+                    vec.set_len(len + n);\n+                },\n+                Err(ref e) if e.kind == EndOfFile => break,\n+                Err(e) => return Err(e),\n+            }\n+        }\n+    }\n+    Ok(vec)\n }\n \n-pub fn two_side_iter<'a, T>(slice: &'a mut [T]) -> TwoSideIter<'a, T> {\n-    let len = slice.len();\n-    let first = slice.as_mut_ptr();\n-    let last = if len == 0 {\n-        first\n-    } else {\n-        unsafe { first.offset(len as int - 1) }\n+/// Finds the first position at which `b` occurs in `s`.\n+fn memchr(h: &[u8], n: u8) -> Option<uint> {\n+    use libc::{c_void, c_int, size_t};\n+    extern {\n+        fn memchr(h: *const c_void, n: c_int, s: size_t) -> *mut c_void;\n+    }\n+    let res = unsafe {\n+        memchr(h.as_ptr() as *const c_void, n as c_int, h.len() as size_t)\n     };\n-\n-    TwoSideIter {\n-        first: first,\n-        last: last,\n-        marker: std::kinds::marker::ContravariantLifetime,\n-        marker2: std::kinds::marker::NoCopy\n+    if res.is_null() {\n+        None\n+    } else {\n+        Some(res as uint - h.as_ptr() as uint)\n     }\n }\n \n-impl<'a, T> Iterator<(&'a mut T, &'a mut T)> for TwoSideIter<'a, T> {\n-    fn next(&mut self) -> Option<(&'a mut T, &'a mut T)> {\n-        if self.first < self.last {\n-            let result = unsafe { (&mut *self.first, &mut *self.last) };\n-            self.first = unsafe { self.first.offset(1) };\n-            self.last = unsafe { self.last.offset(-1) };\n-            Some(result)\n-        } else {\n-            None\n+/// Length of a normal line without the terminating \\n.\n+const LINE_LEN: uint = 60;\n+\n+/// Compute the reverse complement.\n+fn reverse_complement(mut view: SharedMemory, tables: tables::Tables) {\n+    // Drop the last newline\n+    let seq = view.as_mut_slice().init_mut();\n+    let len = seq.len();\n+    let off = LINE_LEN - len % (LINE_LEN + 1);\n+    let mut i = LINE_LEN;\n+    while i < len {\n+        unsafe {\n+            copy_memory(seq.as_mut_ptr().offset((i - off + 1) as int),\n+                        seq.as_ptr().offset((i - off) as int), off);\n+            *seq.unsafe_mut(i - off) = b'\\n';\n         }\n+        i += LINE_LEN + 1;\n     }\n+\n+    let (div, rem) = div_rem(len, 4);\n+    unsafe {\n+        let mut left = seq.as_mut_ptr() as *mut u16;\n+        // This is slow if len % 2 != 0 but still faster than bytewise operations.\n+        let mut right = seq.as_mut_ptr().offset(len as int - 2) as *mut u16;\n+        let end = left.offset(div as int);\n+        while left != end {\n+            let tmp = tables.cpl16(*left);\n+            *left = tables.cpl16(*right);\n+            *right = tmp;\n+            left = left.offset(1);\n+            right = right.offset(-1);\n+        }\n+\n+        let end = end as *mut u8;\n+        match rem {\n+            1 => *end = tables.cpl8(*end),\n+            2 => {\n+                let tmp = tables.cpl8(*end);\n+                *end = tables.cpl8(*end.offset(1));\n+                *end.offset(1) = tmp;\n+            },\n+            3 => {\n+                *end.offset(1) = tables.cpl8(*end.offset(1));\n+                let tmp = tables.cpl8(*end);\n+                *end = tables.cpl8(*end.offset(2));\n+                *end.offset(2) = tmp;\n+            },\n+            _ => { },\n+        }\n+    }\n+}\n+\n+fn main() {\n+    let mut data = SharedMemory::new(read_to_end(&mut stdin_raw()).unwrap());\n+    let tables = tables::get();\n+\n+    let mut futures = vec!();\n+    loop {\n+        let (_, mut tmp_data) = match memchr(data.as_mut_slice(), b'\\n') {\n+            Some(i) => data.split_at(i + 1),\n+            _ => break,\n+        };\n+        let (view, tmp_data) = match memchr(tmp_data.as_mut_slice(), b'>') {\n+            Some(i) => tmp_data.split_at(i),\n+            None => {\n+                let len = tmp_data.len();\n+                tmp_data.split_at(len)\n+            },\n+        };\n+        futures.push(Future::spawn(proc() reverse_complement(view, tables)));\n+        data = tmp_data;\n+    }\n+\n+    for f in futures.iter_mut() {\n+        f.get();\n+    }\n+\n+    // Not actually unsafe. If Arc had a way to check uniqueness then we could do that in\n+    // `reset` and it would tell us that, yes, it is unique at this point.\n+    data = unsafe { data.reset() };\n+\n+    stdout_raw().write(data.as_mut_slice()).unwrap();\n }"}]}