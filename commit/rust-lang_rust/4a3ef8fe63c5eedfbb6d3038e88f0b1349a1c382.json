{"sha": "4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhM2VmOGZlNjNjNWVlZGZiYjZkMzAzOGU4OGYwYjEzNDlhMWMzODI=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-04T19:55:23Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-04T19:55:23Z"}, "message": "Merge #370\n\n370: Self params & type r=matklad a=flodiebold\n\nThis implements type inference for `self`, so field completion for methods taking `self` works now.\r\n\r\n - rename `IMPL_ITEM` to `IMPL_BLOCK` -- rustc calls the methods etc. inside an impl `ImplItem`s, and the impl itself doesn't define an item, so I thought this name was clearer.\r\n - add HIR for impl blocks -- we collect all impls in a crate at once, so we can go from methods to containing impls, and since we will later also need to find all impls for a certain type (which may be anywhere in the crate, I think?). We could be more lazy here, but I don't know if it's worth the complexity.\r\n - resolve `self` and `Self` during type inference\r\n - refactor a bit in ty.rs as well\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "a2666ef628451437aea9b99a9e18d27bb54b53e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a2666ef628451437aea9b99a9e18d27bb54b53e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382", "html_url": "https://github.com/rust-lang/rust/commit/4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "04e6b26758003550633e41df14fe9bc0ac7f8e4a", "url": "https://api.github.com/repos/rust-lang/rust/commits/04e6b26758003550633e41df14fe9bc0ac7f8e4a", "html_url": "https://github.com/rust-lang/rust/commit/04e6b26758003550633e41df14fe9bc0ac7f8e4a"}, {"sha": "e6aeabf96f9cf339c81f3e79502d477269d141ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6aeabf96f9cf339c81f3e79502d477269d141ed", "html_url": "https://github.com/rust-lang/rust/commit/e6aeabf96f9cf339c81f3e79502d477269d141ed"}], "stats": {"total": 610, "additions": 548, "deletions": 62}, "files": [{"sha": "031d8b98f2aceabae0f07b2e2eb52e1d9d13091c", "filename": "crates/ra_analysis/src/completion/complete_dot.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_dot.rs?ref=4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382", "patch": "@@ -72,6 +72,21 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn test_struct_field_completion_self() {\n+        check_ref_completion(\n+            r\"\n+            struct A { the_field: u32 }\n+            impl A {\n+                fn foo(self) {\n+                    self.<|>\n+                }\n+            }\n+            \",\n+            r#\"the_field\"#,\n+        );\n+    }\n+\n     #[test]\n     fn test_no_struct_field_completion_for_method_call() {\n         check_ref_completion("}, {"sha": "5422a400b63db81ae780601ee71677f9ff732a95", "filename": "crates/ra_analysis/src/db.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382/crates%2Fra_analysis%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382/crates%2Fra_analysis%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdb.rs?ref=4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382", "patch": "@@ -105,6 +105,7 @@ salsa::database_storage! {\n             fn type_for_field() for hir::db::TypeForFieldQuery;\n             fn struct_data() for hir::db::StructDataQuery;\n             fn enum_data() for hir::db::EnumDataQuery;\n+            fn impls_in_module() for hir::db::ImplsInModuleQuery;\n         }\n     }\n }"}, {"sha": "846c76cfe7ae2abf668b5ac26c86a918a8461588", "filename": "crates/ra_analysis/src/mock_analysis.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382/crates%2Fra_analysis%2Fsrc%2Fmock_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382/crates%2Fra_analysis%2Fsrc%2Fmock_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fmock_analysis.rs?ref=4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382", "patch": "@@ -4,7 +4,7 @@ use relative_path::RelativePathBuf;\n use test_utils::{extract_offset, extract_range, parse_fixture, CURSOR_MARKER};\n use ra_db::mock::FileMap;\n \n-use crate::{Analysis, AnalysisChange, AnalysisHost, FileId, FilePosition, FileRange, SourceRootId};\n+use crate::{Analysis, AnalysisChange, AnalysisHost, CrateGraph, FileId, FilePosition, FileRange, SourceRootId};\n \n /// Mock analysis is used in test to bootstrap an AnalysisHost/Analysis\n /// from a set of in-memory files.\n@@ -87,12 +87,17 @@ impl MockAnalysis {\n         let source_root = SourceRootId(0);\n         let mut change = AnalysisChange::new();\n         change.add_root(source_root, true);\n+        let mut crate_graph = CrateGraph::default();\n         for (path, contents) in self.files.into_iter() {\n             assert!(path.starts_with('/'));\n             let path = RelativePathBuf::from_path(&path[1..]).unwrap();\n             let file_id = file_map.add(path.clone());\n+            if path == \"/lib.rs\" || path == \"/main.rs\" {\n+                crate_graph.add_crate_root(file_id);\n+            }\n             change.add_file(source_root, file_id, path, Arc::new(contents));\n         }\n+        change.set_crate_graph(crate_graph);\n         // change.set_file_resolver(Arc::new(file_map));\n         host.apply_change(change);\n         host"}, {"sha": "beeae1e1967b4ae563434ff66c5a928e4a7b5eb8", "filename": "crates/ra_analysis/tests/test/main.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382/crates%2Fra_analysis%2Ftests%2Ftest%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382/crates%2Fra_analysis%2Ftests%2Ftest%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Ftests%2Ftest%2Fmain.rs?ref=4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382", "patch": "@@ -138,14 +138,14 @@ fn test_resolve_parent_module_for_inline() {\n fn test_resolve_crate_root() {\n     let mock = MockAnalysis::with_files(\n         \"\n-        //- /lib.rs\n+        //- /bar.rs\n         mod foo;\n-        //- /foo.rs\n+        //- /bar/foo.rs\n         // emtpy <|>\n     \",\n     );\n-    let root_file = mock.id_of(\"/lib.rs\");\n-    let mod_file = mock.id_of(\"/foo.rs\");\n+    let root_file = mock.id_of(\"/bar.rs\");\n+    let mod_file = mock.id_of(\"/bar/foo.rs\");\n     let mut host = mock.analysis_host();\n     assert!(host.analysis().crate_for(mod_file).unwrap().is_empty());\n "}, {"sha": "58296fc6f3bc369a8eab8bedceb0551080f04fac", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382", "patch": "@@ -13,6 +13,7 @@ use crate::{\n     nameres::{ItemMap, InputModuleItems}},\n     ty::{InferenceResult, Ty},\n     adt::{StructData, EnumData},\n+    impl_block::ModuleImplBlocks,\n };\n \n salsa::query_group! {\n@@ -87,6 +88,11 @@ pub trait HirDatabase: SyntaxDatabase\n         type ModuleTreeQuery;\n         use fn crate::module::imp::module_tree;\n     }\n+\n+    fn impls_in_module(source_root_id: SourceRootId, module_id: ModuleId) -> Cancelable<Arc<ModuleImplBlocks>> {\n+        type ImplsInModuleQuery;\n+        use fn crate::impl_block::impls_in_module;\n+    }\n }\n \n }"}, {"sha": "75ef308ae4912c93d4a242c3fc66393b1f49d1a7", "filename": "crates/ra_hir/src/function.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382/crates%2Fra_hir%2Fsrc%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382/crates%2Fra_hir%2Fsrc%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffunction.rs?ref=4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382", "patch": "@@ -11,11 +11,11 @@ use ra_syntax::{\n     ast::{self, AstNode, DocCommentsOwner, NameOwner},\n };\n \n-use crate::{DefId, DefKind, HirDatabase, ty::InferenceResult, Module};\n+use crate::{DefId, DefKind, HirDatabase, ty::InferenceResult, Module, Crate, impl_block::ImplBlock};\n \n pub use self::scope::FnScopes;\n \n-#[derive(Debug)]\n+#[derive(Debug, Clone, PartialEq, Eq)]\n pub struct Function {\n     def_id: DefId,\n }\n@@ -25,6 +25,10 @@ impl Function {\n         Function { def_id }\n     }\n \n+    pub fn def_id(&self) -> DefId {\n+        self.def_id\n+    }\n+\n     pub fn syntax(&self, db: &impl HirDatabase) -> ast::FnDefNode {\n         let def_loc = self.def_id.loc(db);\n         assert!(def_loc.kind == DefKind::Function);\n@@ -48,6 +52,15 @@ impl Function {\n     pub fn module(&self, db: &impl HirDatabase) -> Cancelable<Module> {\n         self.def_id.module(db)\n     }\n+\n+    pub fn krate(&self, db: &impl HirDatabase) -> Cancelable<Option<Crate>> {\n+        self.def_id.krate(db)\n+    }\n+\n+    /// The containing impl block, if this is a method.\n+    pub fn impl_block(&self, db: &impl HirDatabase) -> Cancelable<Option<ImplBlock>> {\n+        self.def_id.impl_block(db)\n+    }\n }\n \n #[derive(Debug, Clone)]"}, {"sha": "4d6378e0286353d3c817b985edb27642ea44bd0f", "filename": "crates/ra_hir/src/ids.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382/crates%2Fra_hir%2Fsrc%2Fids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382/crates%2Fra_hir%2Fsrc%2Fids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fids.rs?ref=4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382", "patch": "@@ -2,7 +2,7 @@ use ra_db::{SourceRootId, LocationIntener, Cancelable, FileId};\n use ra_syntax::{SourceFileNode, SyntaxKind, SyntaxNode, SyntaxNodeRef, SourceFile, AstNode, ast};\n use ra_arena::{Arena, RawId, impl_arena_id};\n \n-use crate::{HirDatabase, PerNs, ModuleId, Module, Def, Function, Struct, Enum};\n+use crate::{HirDatabase, PerNs, ModuleId, Module, Def, Function, Struct, Enum, ImplBlock, Crate};\n \n /// hir makes a heavy use of ids: integer (u32) handlers to various things. You\n /// can think of id as a pointer (but without a lifetime) or a file descriptor\n@@ -177,6 +177,18 @@ impl DefId {\n         let loc = self.loc(db);\n         Module::new(db, loc.source_root_id, loc.module_id)\n     }\n+\n+    /// Returns the containing crate.\n+    pub fn krate(&self, db: &impl HirDatabase) -> Cancelable<Option<Crate>> {\n+        Ok(self.module(db)?.krate(db))\n+    }\n+\n+    /// Returns the containing impl block, if this is an impl item.\n+    pub fn impl_block(self, db: &impl HirDatabase) -> Cancelable<Option<ImplBlock>> {\n+        let loc = self.loc(db);\n+        let module_impls = db.impls_in_module(loc.source_root_id, loc.module_id)?;\n+        Ok(ImplBlock::containing(module_impls, self))\n+    }\n }\n \n impl DefLoc {"}, {"sha": "01afa84c4964f74be15e513414c3cda543fde873", "filename": "crates/ra_hir/src/impl_block.rs", "status": "added", "additions": 180, "deletions": 0, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs?ref=4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382", "patch": "@@ -0,0 +1,180 @@\n+use std::sync::Arc;\n+use rustc_hash::FxHashMap;\n+\n+use ra_arena::{Arena, RawId, impl_arena_id};\n+use ra_syntax::ast::{self, AstNode};\n+use ra_db::{LocationIntener, Cancelable, SourceRootId};\n+\n+use crate::{\n+    DefId, DefLoc, DefKind, SourceItemId, SourceFileItems,\n+    Module, Function,\n+    db::HirDatabase,\n+    type_ref::TypeRef,\n+    module::{ModuleSourceNode, ModuleId},\n+};\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct ImplBlock {\n+    module_impl_blocks: Arc<ModuleImplBlocks>,\n+    impl_id: ImplId,\n+}\n+\n+impl ImplBlock {\n+    pub(crate) fn containing(\n+        module_impl_blocks: Arc<ModuleImplBlocks>,\n+        def_id: DefId,\n+    ) -> Option<ImplBlock> {\n+        let impl_id = *module_impl_blocks.impls_by_def.get(&def_id)?;\n+        Some(ImplBlock {\n+            module_impl_blocks,\n+            impl_id,\n+        })\n+    }\n+\n+    fn impl_data(&self) -> &ImplData {\n+        &self.module_impl_blocks.impls[self.impl_id]\n+    }\n+\n+    pub fn target_trait(&self) -> Option<&TypeRef> {\n+        self.impl_data().target_trait.as_ref()\n+    }\n+\n+    pub fn target_type(&self) -> &TypeRef {\n+        &self.impl_data().target_type\n+    }\n+\n+    pub fn items(&self) -> &[ImplItem] {\n+        &self.impl_data().items\n+    }\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct ImplData {\n+    target_trait: Option<TypeRef>,\n+    target_type: TypeRef,\n+    items: Vec<ImplItem>,\n+}\n+\n+impl ImplData {\n+    pub(crate) fn from_ast(\n+        db: &impl AsRef<LocationIntener<DefLoc, DefId>>,\n+        file_items: &SourceFileItems,\n+        module: &Module,\n+        node: ast::ImplBlock,\n+    ) -> Self {\n+        let target_trait = node.target_type().map(TypeRef::from_ast);\n+        let target_type = TypeRef::from_ast_opt(node.target_type());\n+        let file_id = module.source().file_id();\n+        let items = if let Some(item_list) = node.item_list() {\n+            item_list\n+                .impl_items()\n+                .map(|item_node| {\n+                    let kind = match item_node {\n+                        ast::ImplItem::FnDef(..) => DefKind::Function,\n+                        ast::ImplItem::ConstDef(..) => DefKind::Item,\n+                        ast::ImplItem::TypeDef(..) => DefKind::Item,\n+                    };\n+                    let item_id = file_items.id_of_unchecked(item_node.syntax());\n+                    let def_loc = DefLoc {\n+                        kind,\n+                        source_root_id: module.source_root_id,\n+                        module_id: module.module_id,\n+                        source_item_id: SourceItemId {\n+                            file_id,\n+                            item_id: Some(item_id),\n+                        },\n+                    };\n+                    let def_id = def_loc.id(db);\n+                    match item_node {\n+                        ast::ImplItem::FnDef(..) => ImplItem::Method(Function::new(def_id)),\n+                        ast::ImplItem::ConstDef(..) => ImplItem::Const(def_id),\n+                        ast::ImplItem::TypeDef(..) => ImplItem::Type(def_id),\n+                    }\n+                })\n+                .collect()\n+        } else {\n+            Vec::new()\n+        };\n+        ImplData {\n+            target_trait,\n+            target_type,\n+            items,\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub enum ImplItem {\n+    Method(Function),\n+    // these don't have their own types yet\n+    Const(DefId),\n+    Type(DefId),\n+    // Existential\n+}\n+\n+impl ImplItem {\n+    pub fn def_id(&self) -> DefId {\n+        match self {\n+            ImplItem::Method(f) => f.def_id(),\n+            ImplItem::Const(def_id) => *def_id,\n+            ImplItem::Type(def_id) => *def_id,\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct ImplId(pub RawId);\n+impl_arena_id!(ImplId);\n+\n+/// Collection of impl blocks is a two-step process: First we collect the blocks\n+/// per-module; then we build an index of all impl blocks in the crate. This\n+/// way, we avoid having to do this process for the whole crate whenever someone\n+/// types in any file; as long as the impl blocks in the file don't change, we\n+/// don't need to do the second step again.\n+///\n+/// (The second step does not yet exist currently.)\n+#[derive(Debug, PartialEq, Eq)]\n+pub struct ModuleImplBlocks {\n+    impls: Arena<ImplId, ImplData>,\n+    impls_by_def: FxHashMap<DefId, ImplId>,\n+}\n+\n+impl ModuleImplBlocks {\n+    fn new() -> Self {\n+        ModuleImplBlocks {\n+            impls: Arena::default(),\n+            impls_by_def: FxHashMap::default(),\n+        }\n+    }\n+\n+    fn collect(&mut self, db: &impl HirDatabase, module: Module) -> Cancelable<()> {\n+        let module_source_node = module.source().resolve(db);\n+        let node = match &module_source_node {\n+            ModuleSourceNode::SourceFile(node) => node.borrowed().syntax(),\n+            ModuleSourceNode::Module(node) => node.borrowed().syntax(),\n+        };\n+\n+        let source_file_items = db.file_items(module.source().file_id());\n+\n+        for impl_block_ast in node.children().filter_map(ast::ImplBlock::cast) {\n+            let impl_block = ImplData::from_ast(db, &source_file_items, &module, impl_block_ast);\n+            let id = self.impls.alloc(impl_block);\n+            for impl_item in &self.impls[id].items {\n+                self.impls_by_def.insert(impl_item.def_id(), id);\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+}\n+\n+pub(crate) fn impls_in_module(\n+    db: &impl HirDatabase,\n+    source_root_id: SourceRootId,\n+    module_id: ModuleId,\n+) -> Cancelable<Arc<ModuleImplBlocks>> {\n+    let mut result = ModuleImplBlocks::new();\n+    let module = Module::new(db, source_root_id, module_id)?;\n+    result.collect(db, module)?;\n+    Ok(Arc::new(result))\n+}"}, {"sha": "5194e280b751b2d07c2cacaa32648e9c26356269", "filename": "crates/ra_hir/src/krate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382/crates%2Fra_hir%2Fsrc%2Fkrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382/crates%2Fra_hir%2Fsrc%2Fkrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fkrate.rs?ref=4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382", "patch": "@@ -5,7 +5,7 @@ use crate::{HirDatabase, Module, Name, AsName, HirFileId};\n /// hir::Crate describes a single crate. It's the main inteface with which\n /// crate's dependencies interact. Mostly, it should be just a proxy for the\n /// root module.\n-#[derive(Debug)]\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Crate {\n     crate_id: CrateId,\n }"}, {"sha": "2abcec441b846d1f65a7550edf79e9dbf7001a30", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382", "patch": "@@ -31,6 +31,7 @@ mod function;\n mod adt;\n mod type_ref;\n mod ty;\n+mod impl_block;\n \n use crate::{\n     db::HirDatabase,\n@@ -48,6 +49,7 @@ pub use self::{\n     function::{Function, FnScopes},\n     adt::{Struct, Enum},\n     ty::Ty,\n+    impl_block::{ImplBlock, ImplItem},\n };\n \n pub use self::function::FnSignatureInfo;"}, {"sha": "a9db932ff023e479078c1ce271da7590b1eae08f", "filename": "crates/ra_hir/src/mock.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382/crates%2Fra_hir%2Fsrc%2Fmock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382/crates%2Fra_hir%2Fsrc%2Fmock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmock.rs?ref=4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382", "patch": "@@ -30,6 +30,10 @@ impl MockDatabase {\n         let file_id = db.add_file(&mut source_root, \"/main.rs\", text);\n         db.query_mut(ra_db::SourceRootQuery)\n             .set(WORKSPACE, Arc::new(source_root.clone()));\n+\n+        let mut crate_graph = CrateGraph::default();\n+        crate_graph.add_crate_root(file_id);\n+        db.set_crate_graph(crate_graph);\n         (db, source_root, file_id)\n     }\n \n@@ -203,6 +207,7 @@ salsa::database_storage! {\n             fn type_for_field() for db::TypeForFieldQuery;\n             fn struct_data() for db::StructDataQuery;\n             fn enum_data() for db::EnumDataQuery;\n+            fn impls_in_module() for db::ImplsInModuleQuery;\n         }\n     }\n }"}, {"sha": "b9821115ce8ba39b232c5c3d245b2799b23ddf90", "filename": "crates/ra_hir/src/module.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382/crates%2Fra_hir%2Fsrc%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382/crates%2Fra_hir%2Fsrc%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule.rs?ref=4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382", "patch": "@@ -71,6 +71,21 @@ impl Module {\n         })\n     }\n \n+    /// Returns an iterator of all children of this module.\n+    pub fn children<'a>(&'a self) -> impl Iterator<Item = (Name, Module)> + 'a {\n+        self.module_id\n+            .children(&self.tree)\n+            .map(move |(name, module_id)| {\n+                (\n+                    name,\n+                    Module {\n+                        module_id,\n+                        ..self.clone()\n+                    },\n+                )\n+            })\n+    }\n+\n     /// Returns the crate this module is part of.\n     pub fn krate(&self, db: &impl HirDatabase) -> Option<Crate> {\n         let root_id = self.module_id.crate_root(&self.tree);"}, {"sha": "017caf442e29c56b082c6e6280741bd79689ec7d", "filename": "crates/ra_hir/src/name.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382/crates%2Fra_hir%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382/crates%2Fra_hir%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fname.rs?ref=4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382", "patch": "@@ -51,6 +51,7 @@ impl Name {\n             \"u128\" => KnownName::U128,\n             \"f32\" => KnownName::F32,\n             \"f64\" => KnownName::F64,\n+            \"Self\" => KnownName::Self_,\n             _ => return None,\n         };\n         Some(name)\n@@ -84,7 +85,7 @@ impl AsName for ra_db::Dependency {\n // const ISIZE: Name = Name::new(\"isize\")\n // ```\n // but const-fn is not that powerful yet.\n-#[derive(Debug)]\n+#[derive(Debug, PartialEq, Eq)]\n pub(crate) enum KnownName {\n     Isize,\n     I8,\n@@ -102,4 +103,6 @@ pub(crate) enum KnownName {\n \n     F32,\n     F64,\n+\n+    Self_,\n }"}, {"sha": "9fdfa0d131238b5f46661babe8c626176892229e", "filename": "crates/ra_hir/src/path.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382/crates%2Fra_hir%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382/crates%2Fra_hir%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fpath.rs?ref=4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382", "patch": "@@ -70,6 +70,11 @@ impl Path {\n         self.kind == PathKind::Plain && self.segments.len() == 1\n     }\n \n+    /// `true` if this path is just a standalone `self`\n+    pub fn is_self(&self) -> bool {\n+        self.kind == PathKind::Self_ && self.segments.len() == 0\n+    }\n+\n     /// If this path is a single identifier, like `foo`, return its name.\n     pub fn as_ident(&self) -> Option<&Name> {\n         if self.kind != PathKind::Plain || self.segments.len() > 1 {"}, {"sha": "e33762e0ddb2a11479dc0302d24b4a12ab636627", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 125, "deletions": 43, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382", "patch": "@@ -31,9 +31,10 @@ use ra_syntax::{\n };\n \n use crate::{\n-    Def, DefId, FnScopes, Module, Function, Struct, Enum, Path, Name, AsName,\n+    Def, DefId, FnScopes, Module, Function, Struct, Enum, Path, Name, AsName, ImplBlock,\n     db::HirDatabase,\n     type_ref::{TypeRef, Mutability},\n+    name::KnownName,\n };\n \n /// The ID of a type variable.\n@@ -235,36 +236,37 @@ impl Ty {\n     pub(crate) fn from_hir(\n         db: &impl HirDatabase,\n         module: &Module,\n+        impl_block: Option<&ImplBlock>,\n         type_ref: &TypeRef,\n     ) -> Cancelable<Self> {\n         Ok(match type_ref {\n             TypeRef::Never => Ty::Never,\n             TypeRef::Tuple(inner) => {\n                 let inner_tys = inner\n                     .iter()\n-                    .map(|tr| Ty::from_hir(db, module, tr))\n+                    .map(|tr| Ty::from_hir(db, module, impl_block, tr))\n                     .collect::<Cancelable<Vec<_>>>()?;\n                 Ty::Tuple(inner_tys.into())\n             }\n-            TypeRef::Path(path) => Ty::from_hir_path(db, module, path)?,\n+            TypeRef::Path(path) => Ty::from_hir_path(db, module, impl_block, path)?,\n             TypeRef::RawPtr(inner, mutability) => {\n-                let inner_ty = Ty::from_hir(db, module, inner)?;\n+                let inner_ty = Ty::from_hir(db, module, impl_block, inner)?;\n                 Ty::RawPtr(Arc::new(inner_ty), *mutability)\n             }\n             TypeRef::Array(_inner) => Ty::Unknown, // TODO\n             TypeRef::Slice(inner) => {\n-                let inner_ty = Ty::from_hir(db, module, inner)?;\n+                let inner_ty = Ty::from_hir(db, module, impl_block, inner)?;\n                 Ty::Slice(Arc::new(inner_ty))\n             }\n             TypeRef::Reference(inner, mutability) => {\n-                let inner_ty = Ty::from_hir(db, module, inner)?;\n+                let inner_ty = Ty::from_hir(db, module, impl_block, inner)?;\n                 Ty::Ref(Arc::new(inner_ty), *mutability)\n             }\n             TypeRef::Placeholder => Ty::Unknown,\n             TypeRef::Fn(params) => {\n                 let mut inner_tys = params\n                     .iter()\n-                    .map(|tr| Ty::from_hir(db, module, tr))\n+                    .map(|tr| Ty::from_hir(db, module, impl_block, tr))\n                     .collect::<Cancelable<Vec<_>>>()?;\n                 let return_ty = inner_tys\n                     .pop()\n@@ -279,9 +281,21 @@ impl Ty {\n         })\n     }\n \n+    pub(crate) fn from_hir_opt(\n+        db: &impl HirDatabase,\n+        module: &Module,\n+        impl_block: Option<&ImplBlock>,\n+        type_ref: Option<&TypeRef>,\n+    ) -> Cancelable<Self> {\n+        type_ref\n+            .map(|t| Ty::from_hir(db, module, impl_block, t))\n+            .unwrap_or(Ok(Ty::Unknown))\n+    }\n+\n     pub(crate) fn from_hir_path(\n         db: &impl HirDatabase,\n         module: &Module,\n+        impl_block: Option<&ImplBlock>,\n         path: &Path,\n     ) -> Cancelable<Self> {\n         if let Some(name) = path.as_ident() {\n@@ -291,6 +305,8 @@ impl Ty {\n                 return Ok(Ty::Uint(uint_ty));\n             } else if let Some(float_ty) = primitive::FloatTy::from_name(name) {\n                 return Ok(Ty::Float(float_ty));\n+            } else if name.as_known_name() == Some(KnownName::Self_) {\n+                return Ty::from_hir_opt(db, module, None, impl_block.map(|i| i.target_type()));\n             }\n         }\n \n@@ -308,18 +324,20 @@ impl Ty {\n     pub(crate) fn from_ast_opt(\n         db: &impl HirDatabase,\n         module: &Module,\n+        impl_block: Option<&ImplBlock>,\n         node: Option<ast::TypeRef>,\n     ) -> Cancelable<Self> {\n-        node.map(|n| Ty::from_ast(db, module, n))\n+        node.map(|n| Ty::from_ast(db, module, impl_block, n))\n             .unwrap_or(Ok(Ty::Unknown))\n     }\n \n     pub(crate) fn from_ast(\n         db: &impl HirDatabase,\n         module: &Module,\n+        impl_block: Option<&ImplBlock>,\n         node: ast::TypeRef,\n     ) -> Cancelable<Self> {\n-        Ty::from_hir(db, module, &TypeRef::from_ast(node))\n+        Ty::from_hir(db, module, impl_block, &TypeRef::from_ast(node))\n     }\n \n     pub fn unit() -> Self {\n@@ -402,18 +420,19 @@ impl fmt::Display for Ty {\n fn type_for_fn(db: &impl HirDatabase, f: Function) -> Cancelable<Ty> {\n     let syntax = f.syntax(db);\n     let module = f.module(db)?;\n+    let impl_block = f.impl_block(db)?;\n     let node = syntax.borrowed();\n     // TODO we ignore type parameters for now\n     let input = node\n         .param_list()\n         .map(|pl| {\n             pl.params()\n-                .map(|p| Ty::from_ast_opt(db, &module, p.type_ref()))\n+                .map(|p| Ty::from_ast_opt(db, &module, impl_block.as_ref(), p.type_ref()))\n                 .collect()\n         })\n         .unwrap_or_else(|| Ok(Vec::new()))?;\n     let output = if let Some(type_ref) = node.ret_type().and_then(|rt| rt.type_ref()) {\n-        Ty::from_ast(db, &module, type_ref)?\n+        Ty::from_ast(db, &module, impl_block.as_ref(), type_ref)?\n     } else {\n         Ty::unit()\n     };\n@@ -467,12 +486,13 @@ pub(super) fn type_for_field(db: &impl HirDatabase, def_id: DefId, field: Name)\n         ),\n     };\n     let module = def_id.module(db)?;\n+    let impl_block = def_id.impl_block(db)?;\n     let type_ref = if let Some(tr) = variant_data.get_field_type_ref(&field) {\n         tr\n     } else {\n         return Ok(Ty::Unknown);\n     };\n-    Ty::from_hir(db, &module, &type_ref)\n+    Ty::from_hir(db, &module, impl_block.as_ref(), &type_ref)\n }\n \n /// The result of type inference: A mapping from expressions and patterns to types.\n@@ -496,19 +516,32 @@ impl InferenceResult {\n struct InferenceContext<'a, D: HirDatabase> {\n     db: &'a D,\n     scopes: Arc<FnScopes>,\n+    /// The self param for the current method, if it exists.\n+    self_param: Option<LocalSyntaxPtr>,\n     module: Module,\n+    impl_block: Option<ImplBlock>,\n     var_unification_table: InPlaceUnificationTable<TypeVarId>,\n     type_of: FxHashMap<LocalSyntaxPtr, Ty>,\n+    /// The return type of the function being inferred.\n+    return_ty: Ty,\n }\n \n impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n-    fn new(db: &'a D, scopes: Arc<FnScopes>, module: Module) -> Self {\n+    fn new(\n+        db: &'a D,\n+        scopes: Arc<FnScopes>,\n+        module: Module,\n+        impl_block: Option<ImplBlock>,\n+    ) -> Self {\n         InferenceContext {\n             type_of: FxHashMap::default(),\n             var_unification_table: InPlaceUnificationTable::new(),\n+            self_param: None,       // set during parameter typing\n+            return_ty: Ty::Unknown, // set in collect_fn_signature\n             db,\n             scopes,\n             module,\n+            impl_block,\n         }\n     }\n \n@@ -525,6 +558,14 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         self.type_of.insert(LocalSyntaxPtr::new(node), ty);\n     }\n \n+    fn make_ty(&self, type_ref: &TypeRef) -> Cancelable<Ty> {\n+        Ty::from_hir(self.db, &self.module, self.impl_block.as_ref(), type_ref)\n+    }\n+\n+    fn make_ty_opt(&self, type_ref: Option<&TypeRef>) -> Cancelable<Ty> {\n+        Ty::from_hir_opt(self.db, &self.module, self.impl_block.as_ref(), type_ref)\n+    }\n+\n     fn unify(&mut self, ty1: &Ty, ty2: &Ty) -> bool {\n         match (ty1, ty2) {\n             (Ty::Unknown, ..) => true,\n@@ -628,6 +669,12 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 let ty = self.resolve_ty_as_possible(ty.clone());\n                 return Ok(Some(ty));\n             };\n+        } else if path.is_self() {\n+            // resolve `self` param\n+            let self_param = ctry!(self.self_param);\n+            let ty = ctry!(self.type_of.get(&self_param));\n+            let ty = self.resolve_ty_as_possible(ty.clone());\n+            return Ok(Some(ty));\n         };\n \n         // resolve in module\n@@ -826,7 +873,12 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             }\n             ast::Expr::CastExpr(e) => {\n                 let _inner_ty = self.infer_expr_opt(e.expr(), &Expectation::none())?;\n-                let cast_ty = Ty::from_ast_opt(self.db, &self.module, e.type_ref())?;\n+                let cast_ty = Ty::from_ast_opt(\n+                    self.db,\n+                    &self.module,\n+                    self.impl_block.as_ref(),\n+                    e.type_ref(),\n+                )?;\n                 let cast_ty = self.insert_type_vars(cast_ty);\n                 // TODO do the coercion...\n                 cast_ty\n@@ -880,7 +932,12 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         for stmt in node.statements() {\n             match stmt {\n                 ast::Stmt::LetStmt(stmt) => {\n-                    let decl_ty = Ty::from_ast_opt(self.db, &self.module, stmt.type_ref())?;\n+                    let decl_ty = Ty::from_ast_opt(\n+                        self.db,\n+                        &self.module,\n+                        self.impl_block.as_ref(),\n+                        stmt.type_ref(),\n+                    )?;\n                     let decl_ty = self.insert_type_vars(decl_ty);\n                     let ty = if let Some(expr) = stmt.initializer() {\n                         let expr_ty = self.infer_expr(expr, &Expectation::has_type(decl_ty))?;\n@@ -906,46 +963,71 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         self.write_ty(node.syntax(), ty.clone());\n         Ok(ty)\n     }\n+\n+    fn collect_fn_signature(&mut self, node: ast::FnDef) -> Cancelable<()> {\n+        if let Some(param_list) = node.param_list() {\n+            if let Some(self_param) = param_list.self_param() {\n+                let self_type = if let Some(type_ref) = self_param.type_ref() {\n+                    let ty = self.make_ty(&TypeRef::from_ast(type_ref))?;\n+                    self.insert_type_vars(ty)\n+                } else {\n+                    // TODO this should be handled by desugaring during HIR conversion\n+                    let ty = self.make_ty_opt(self.impl_block.as_ref().map(|i| i.target_type()))?;\n+                    let ty = match self_param.flavor() {\n+                        ast::SelfParamFlavor::Owned => ty,\n+                        ast::SelfParamFlavor::Ref => Ty::Ref(Arc::new(ty), Mutability::Shared),\n+                        ast::SelfParamFlavor::MutRef => Ty::Ref(Arc::new(ty), Mutability::Mut),\n+                    };\n+                    self.insert_type_vars(ty)\n+                };\n+                if let Some(self_kw) = self_param.self_kw() {\n+                    let self_param = LocalSyntaxPtr::new(self_kw.syntax());\n+                    self.self_param = Some(self_param);\n+                    self.type_of.insert(self_param, self_type);\n+                }\n+            }\n+            for param in param_list.params() {\n+                let pat = if let Some(pat) = param.pat() {\n+                    pat\n+                } else {\n+                    continue;\n+                };\n+                let ty = if let Some(type_ref) = param.type_ref() {\n+                    let ty = self.make_ty(&TypeRef::from_ast(type_ref))?;\n+                    self.insert_type_vars(ty)\n+                } else {\n+                    // missing type annotation\n+                    self.new_type_var()\n+                };\n+                self.type_of.insert(LocalSyntaxPtr::new(pat.syntax()), ty);\n+            }\n+        }\n+\n+        self.return_ty = if let Some(type_ref) = node.ret_type().and_then(|n| n.type_ref()) {\n+            let ty = self.make_ty(&TypeRef::from_ast(type_ref))?;\n+            self.insert_type_vars(ty)\n+        } else {\n+            Ty::unit()\n+        };\n+\n+        Ok(())\n+    }\n }\n \n pub fn infer(db: &impl HirDatabase, def_id: DefId) -> Cancelable<Arc<InferenceResult>> {\n     let function = Function::new(def_id); // TODO: consts also need inference\n     let scopes = function.scopes(db);\n     let module = function.module(db)?;\n-    let mut ctx = InferenceContext::new(db, scopes, module);\n+    let impl_block = function.impl_block(db)?;\n+    let mut ctx = InferenceContext::new(db, scopes, module, impl_block);\n \n     let syntax = function.syntax(db);\n     let node = syntax.borrowed();\n \n-    if let Some(param_list) = node.param_list() {\n-        for param in param_list.params() {\n-            let pat = if let Some(pat) = param.pat() {\n-                pat\n-            } else {\n-                continue;\n-            };\n-            if let Some(type_ref) = param.type_ref() {\n-                let ty = Ty::from_ast(db, &ctx.module, type_ref)?;\n-                let ty = ctx.insert_type_vars(ty);\n-                ctx.type_of.insert(LocalSyntaxPtr::new(pat.syntax()), ty);\n-            } else {\n-                // TODO self param\n-                let type_var = ctx.new_type_var();\n-                ctx.type_of\n-                    .insert(LocalSyntaxPtr::new(pat.syntax()), type_var);\n-            };\n-        }\n-    }\n-\n-    let ret_ty = if let Some(type_ref) = node.ret_type().and_then(|n| n.type_ref()) {\n-        let ty = Ty::from_ast(db, &ctx.module, type_ref)?;\n-        ctx.insert_type_vars(ty)\n-    } else {\n-        Ty::unit()\n-    };\n+    ctx.collect_fn_signature(node)?;\n \n     if let Some(block) = node.body() {\n-        ctx.infer_block(block, &Expectation::has_type(ret_ty))?;\n+        ctx.infer_block(block, &Expectation::has_type(ctx.return_ty.clone()))?;\n     }\n \n     Ok(Arc::new(ctx.resolve_all()))"}, {"sha": "fb53fcf0be965fee00458bf159c3499a50af4a92", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382", "patch": "@@ -134,6 +134,25 @@ fn test() -> &mut &f64 {\n     );\n }\n \n+#[test]\n+fn infer_self() {\n+    check_inference(\n+        r#\"\n+struct S;\n+\n+impl S {\n+    fn test(&self) {\n+        self;\n+    }\n+    fn test2(self: &Self) {\n+        self;\n+    }\n+}\n+\"#,\n+        \"0007_self.txt\",\n+    );\n+}\n+\n fn infer(content: &str) -> String {\n     let (db, _, file_id) = MockDatabase::with_single_file(content);\n     let source_file = db.source_file(file_id);"}, {"sha": "db4ba17d07915d25e96b8a521c4f4d89914eba13", "filename": "crates/ra_hir/src/ty/tests/data/0007_self.txt", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0007_self.txt", "raw_url": "https://github.com/rust-lang/rust/raw/4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0007_self.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0007_self.txt?ref=4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382", "patch": "@@ -0,0 +1,6 @@\n+[50; 54) 'self': &S\n+[34; 38) 'self': &S\n+[40; 61) '{     ...     }': ()\n+[88; 109) '{     ...     }': ()\n+[98; 102) 'self': &S\n+[75; 79) 'self': &S"}, {"sha": "2a3bd27e25fc09084e5b6ceab49e6c122ff75d0d", "filename": "crates/ra_syntax/src/ast.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382/crates%2Fra_syntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382/crates%2Fra_syntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast.rs?ref=4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382", "patch": "@@ -482,6 +482,37 @@ impl<'a> PrefixExpr<'a> {\n     }\n }\n \n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum SelfParamFlavor {\n+    /// self\n+    Owned,\n+    /// &self\n+    Ref,\n+    /// &mut self\n+    MutRef,\n+}\n+\n+impl<'a> SelfParam<'a> {\n+    pub fn flavor(&self) -> SelfParamFlavor {\n+        let borrowed = self.syntax().children().any(|n| n.kind() == AMP);\n+        if borrowed {\n+            // check for a `mut` coming after the & -- `mut &self` != `&mut self`\n+            if self\n+                .syntax()\n+                .children()\n+                .skip_while(|n| n.kind() != AMP)\n+                .any(|n| n.kind() == MUT_KW)\n+            {\n+                SelfParamFlavor::MutRef\n+            } else {\n+                SelfParamFlavor::Ref\n+            }\n+        } else {\n+            SelfParamFlavor::Owned\n+        }\n+    }\n+}\n+\n #[test]\n fn test_doc_comment_of_items() {\n     let file = SourceFileNode::parse("}, {"sha": "7df6a9c4661fd2c6a982bef127d63b86779eacee", "filename": "crates/ra_syntax/src/ast/generated.rs", "status": "modified", "additions": 84, "deletions": 3, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs?ref=4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382", "patch": "@@ -1442,7 +1442,39 @@ impl<R: TreeRoot<RaTypes>> ImplBlockNode<R> {\n }\n \n \n-impl<'a> ImplBlock<'a> {}\n+impl<'a> ImplBlock<'a> {\n+    pub fn item_list(self) -> Option<ItemList<'a>> {\n+        super::child_opt(self)\n+    }\n+}\n+\n+// ImplItem\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+pub enum ImplItem<'a> {\n+    FnDef(FnDef<'a>),\n+    TypeDef(TypeDef<'a>),\n+    ConstDef(ConstDef<'a>),\n+}\n+\n+impl<'a> AstNode<'a> for ImplItem<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+        match syntax.kind() {\n+            FN_DEF => Some(ImplItem::FnDef(FnDef { syntax })),\n+            TYPE_DEF => Some(ImplItem::TypeDef(TypeDef { syntax })),\n+            CONST_DEF => Some(ImplItem::ConstDef(ConstDef { syntax })),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(self) -> SyntaxNodeRef<'a> {\n+        match self {\n+            ImplItem::FnDef(inner) => inner.syntax(),\n+            ImplItem::TypeDef(inner) => inner.syntax(),\n+            ImplItem::ConstDef(inner) => inner.syntax(),\n+        }\n+    }\n+}\n+\n+impl<'a> ImplItem<'a> {}\n \n // ImplTraitType\n #[derive(Debug, Clone, Copy,)]\n@@ -1555,7 +1587,11 @@ impl<R: TreeRoot<RaTypes>> ItemListNode<R> {\n \n impl<'a> ast::FnDefOwner<'a> for ItemList<'a> {}\n impl<'a> ast::ModuleItemOwner<'a> for ItemList<'a> {}\n-impl<'a> ItemList<'a> {}\n+impl<'a> ItemList<'a> {\n+    pub fn impl_items(self) -> impl Iterator<Item = ImplItem<'a>> + 'a {\n+        super::children(self)\n+    }\n+}\n \n // Label\n #[derive(Debug, Clone, Copy,)]\n@@ -3452,6 +3488,43 @@ impl<'a> ReturnExpr<'a> {\n     }\n }\n \n+// SelfKw\n+#[derive(Debug, Clone, Copy,)]\n+pub struct SelfKwNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n+    pub(crate) syntax: SyntaxNode<R>,\n+}\n+pub type SelfKw<'a> = SelfKwNode<RefRoot<'a>>;\n+\n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<SelfKwNode<R1>> for SelfKwNode<R2> {\n+    fn eq(&self, other: &SelfKwNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for SelfKwNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for SelfKwNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n+impl<'a> AstNode<'a> for SelfKw<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+        match syntax.kind() {\n+            SELF_KW => Some(SelfKw { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n+}\n+\n+impl<R: TreeRoot<RaTypes>> SelfKwNode<R> {\n+    pub fn borrowed(&self) -> SelfKw {\n+        SelfKwNode { syntax: self.syntax.borrowed() }\n+    }\n+    pub fn owned(&self) -> SelfKwNode {\n+        SelfKwNode { syntax: self.syntax.owned() }\n+    }\n+}\n+\n+\n+impl<'a> SelfKw<'a> {}\n+\n // SelfParam\n #[derive(Debug, Clone, Copy,)]\n pub struct SelfParamNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n@@ -3487,7 +3560,15 @@ impl<R: TreeRoot<RaTypes>> SelfParamNode<R> {\n }\n \n \n-impl<'a> SelfParam<'a> {}\n+impl<'a> SelfParam<'a> {\n+    pub fn type_ref(self) -> Option<TypeRef<'a>> {\n+        super::child_opt(self)\n+    }\n+\n+    pub fn self_kw(self) -> Option<SelfKw<'a>> {\n+        super::child_opt(self)\n+    }\n+}\n \n // SlicePat\n #[derive(Debug, Clone, Copy,)]"}, {"sha": "c55e9e07a83b7ee88013a83201b106c3857cfa3c", "filename": "crates/ra_syntax/src/grammar.ron", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "raw_url": "https://github.com/rust-lang/rust/raw/4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron?ref=4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382", "patch": "@@ -284,6 +284,7 @@ Grammar(\n             options: [ \"ItemList\" ]\n         ),\n         \"ItemList\": (\n+            collections: [[\"impl_items\", \"ImplItem\"]],\n             traits: [ \"FnDefOwner\", \"ModuleItemOwner\" ],\n         ),\n         \"ConstDef\": ( traits: [\n@@ -307,7 +308,7 @@ Grammar(\n             \"AttrsOwner\",\n             \"DocCommentsOwner\"\n         ] ),\n-        \"ImplBlock\": (collections: []),\n+        \"ImplBlock\": (options: [\"ItemList\"]),\n \n         \"ParenType\": (options: [\"TypeRef\"]),\n         \"TupleType\": ( collections: [[\"fields\", \"TypeRef\"]] ),\n@@ -351,6 +352,9 @@ Grammar(\n             enum: [\"StructDef\", \"EnumDef\", \"FnDef\", \"TraitDef\", \"TypeDef\", \"ImplBlock\",\n                    \"UseItem\", \"ExternCrateItem\", \"ConstDef\", \"StaticDef\", \"Module\" ]\n         ),\n+        \"ImplItem\": (\n+            enum: [\"FnDef\", \"TypeDef\", \"ConstDef\"]\n+        ),\n \n         \"TupleExpr\": (),\n         \"ArrayExpr\": (),\n@@ -530,7 +534,8 @@ Grammar(\n                 [\"params\", \"Param\"]\n             ]\n         ),\n-        \"SelfParam\": (),\n+        \"SelfParam\": (options: [\"TypeRef\", \"SelfKw\"]),\n+        \"SelfKw\": (),\n         \"Param\": (\n             options: [ \"Pat\", \"TypeRef\" ],\n         ),"}, {"sha": "265e84570d519469a20a10315a0ac1db414fd02a", "filename": "crates/ra_syntax/src/grammar/items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382/crates%2Fra_syntax%2Fsrc%2Fgrammar%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382/crates%2Fra_syntax%2Fsrc%2Fgrammar%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fgrammar%2Fitems.rs?ref=4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382", "patch": "@@ -151,7 +151,7 @@ pub(super) fn maybe_item(p: &mut Parser, flavor: ItemFlavor) -> MaybeItem {\n         // test unsafe_default_impl\n         // unsafe default impl Foo {}\n         IMPL_KW => {\n-            traits::impl_item(p);\n+            traits::impl_block(p);\n             IMPL_BLOCK\n         }\n         _ => {"}, {"sha": "0a0621753fc189e9907f9a28f14a14c5cb4ef828", "filename": "crates/ra_syntax/src/grammar/items/traits.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382/crates%2Fra_syntax%2Fsrc%2Fgrammar%2Fitems%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382/crates%2Fra_syntax%2Fsrc%2Fgrammar%2Fitems%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fgrammar%2Fitems%2Ftraits.rs?ref=4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382", "patch": "@@ -40,9 +40,9 @@ pub(crate) fn trait_item_list(p: &mut Parser) {\n     m.complete(p, ITEM_LIST);\n }\n \n-// test impl_item\n+// test impl_block\n // impl Foo {}\n-pub(super) fn impl_item(p: &mut Parser) {\n+pub(super) fn impl_block(p: &mut Parser) {\n     assert!(p.at(IMPL_KW));\n     p.bump();\n     if choose_type_params_over_qpath(p) {\n@@ -52,7 +52,7 @@ pub(super) fn impl_item(p: &mut Parser) {\n     // TODO: never type\n     // impl ! {}\n \n-    // test impl_item_neg\n+    // test impl_block_neg\n     // impl !Send for X {}\n     p.eat(EXCL);\n     impl_type(p);"}, {"sha": "b7527c8705acb07589470ae7a882cf2b9c7cabb9", "filename": "crates/ra_syntax/tests/data/parser/inline/ok/0063_impl_block_neg.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382/crates%2Fra_syntax%2Ftests%2Fdata%2Fparser%2Finline%2Fok%2F0063_impl_block_neg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382/crates%2Fra_syntax%2Ftests%2Fdata%2Fparser%2Finline%2Fok%2F0063_impl_block_neg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftests%2Fdata%2Fparser%2Finline%2Fok%2F0063_impl_block_neg.rs?ref=4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382", "previous_filename": "crates/ra_syntax/tests/data/parser/inline/ok/0063_impl_item_neg.rs"}, {"sha": "563e43508052150cc751fd4b0cf046d76180e063", "filename": "crates/ra_syntax/tests/data/parser/inline/ok/0063_impl_block_neg.txt", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382/crates%2Fra_syntax%2Ftests%2Fdata%2Fparser%2Finline%2Fok%2F0063_impl_block_neg.txt", "raw_url": "https://github.com/rust-lang/rust/raw/4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382/crates%2Fra_syntax%2Ftests%2Fdata%2Fparser%2Finline%2Fok%2F0063_impl_block_neg.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftests%2Fdata%2Fparser%2Finline%2Fok%2F0063_impl_block_neg.txt?ref=4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382", "previous_filename": "crates/ra_syntax/tests/data/parser/inline/ok/0063_impl_item_neg.txt"}, {"sha": "d6337f6b3a77b519e9937c7d0ae645e8c4b14912", "filename": "crates/ra_syntax/tests/data/parser/inline/ok/0079_impl_block.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382/crates%2Fra_syntax%2Ftests%2Fdata%2Fparser%2Finline%2Fok%2F0079_impl_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382/crates%2Fra_syntax%2Ftests%2Fdata%2Fparser%2Finline%2Fok%2F0079_impl_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftests%2Fdata%2Fparser%2Finline%2Fok%2F0079_impl_block.rs?ref=4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382", "previous_filename": "crates/ra_syntax/tests/data/parser/inline/ok/0079_impl_item.rs"}, {"sha": "a2c218aa9fb1dd5587aeff6c5702852cc76a20a1", "filename": "crates/ra_syntax/tests/data/parser/inline/ok/0079_impl_block.txt", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382/crates%2Fra_syntax%2Ftests%2Fdata%2Fparser%2Finline%2Fok%2F0079_impl_block.txt", "raw_url": "https://github.com/rust-lang/rust/raw/4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382/crates%2Fra_syntax%2Ftests%2Fdata%2Fparser%2Finline%2Fok%2F0079_impl_block.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftests%2Fdata%2Fparser%2Finline%2Fok%2F0079_impl_block.txt?ref=4a3ef8fe63c5eedfbb6d3038e88f0b1349a1c382", "previous_filename": "crates/ra_syntax/tests/data/parser/inline/ok/0079_impl_item.txt"}]}