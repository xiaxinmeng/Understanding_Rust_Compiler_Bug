{"sha": "3b4d6e080404560f63599deeb328dfa27fe081a6", "node_id": "C_kwDOAAsO6NoAKDNiNGQ2ZTA4MDQwNDU2MGY2MzU5OWRlZWIzMjhkZmEyN2ZlMDgxYTY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-22T12:04:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-22T12:04:45Z"}, "message": "Auto merge of #108339 - GuillaumeGomez:rollup-4z02kas, r=GuillaumeGomez\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #108110 (Move some `InferCtxt` methods to `EvalCtxt` in new solver)\n - #108168 (Fix ICE on type alias in recursion)\n - #108230 (Convert a hard-warning about named static lifetimes into lint \"unused_lifetimes\")\n - #108239 (Fix overlapping spans in removing extra arguments)\n - #108246 (Add an InstCombine for redundant casts)\n - #108264 (no-fail-fast support for tool testsuites)\n - #108310 (rustdoc: Fix duplicated attributes for first reexport)\n - #108318 (Remove unused FileDesc::get_cloexec)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "0404fed1412000d50e1807cda997649437aa7220", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0404fed1412000d50e1807cda997649437aa7220"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3b4d6e080404560f63599deeb328dfa27fe081a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3b4d6e080404560f63599deeb328dfa27fe081a6", "html_url": "https://github.com/rust-lang/rust/commit/3b4d6e080404560f63599deeb328dfa27fe081a6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3b4d6e080404560f63599deeb328dfa27fe081a6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd4a96a12d0bf6dc12edf20a45df3a33052c9d7d", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd4a96a12d0bf6dc12edf20a45df3a33052c9d7d", "html_url": "https://github.com/rust-lang/rust/commit/bd4a96a12d0bf6dc12edf20a45df3a33052c9d7d"}, {"sha": "0d0de4971e2b134549f5e8019cbc06dadc5596ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d0de4971e2b134549f5e8019cbc06dadc5596ca", "html_url": "https://github.com/rust-lang/rust/commit/0d0de4971e2b134549f5e8019cbc06dadc5596ca"}], "stats": {"total": 962, "additions": 562, "deletions": 400}, "files": [{"sha": "e977767e0240972bb7c43ff5430ca53b9339f281", "filename": "compiler/rustc_hir_analysis/src/collect/resolve_bound_vars.rs", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/3b4d6e080404560f63599deeb328dfa27fe081a6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4d6e080404560f63599deeb328dfa27fe081a6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs?ref=3b4d6e080404560f63599deeb328dfa27fe081a6", "patch": "@@ -18,6 +18,7 @@ use rustc_middle::bug;\n use rustc_middle::hir::nested_filter;\n use rustc_middle::middle::resolve_bound_vars::*;\n use rustc_middle::ty::{self, ir::TypeVisitor, DefIdTree, TyCtxt, TypeSuperVisitable};\n+use rustc_session::lint;\n use rustc_span::def_id::DefId;\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n@@ -923,17 +924,16 @@ impl<'a, 'tcx> Visitor<'tcx> for BoundVarContext<'a, 'tcx> {\n                         origin,\n                         ..\n                     }) => {\n-\n                         let (bound_vars, binders): (FxIndexMap<LocalDefId, ResolvedArg>, Vec<_>) =\n                             bound_generic_params\n-                            .iter()\n-                            .enumerate()\n-                            .map(|(late_bound_idx, param)| {\n-                                let pair = ResolvedArg::late(late_bound_idx as u32, param);\n-                                let r = late_arg_as_bound_arg(this.tcx, &pair.1, param);\n-                                (pair, r)\n-                            })\n-                            .unzip();\n+                                .iter()\n+                                .enumerate()\n+                                .map(|(late_bound_idx, param)| {\n+                                    let pair = ResolvedArg::late(late_bound_idx as u32, param);\n+                                    let r = late_arg_as_bound_arg(this.tcx, &pair.1, param);\n+                                    (pair, r)\n+                                })\n+                                .unzip();\n                         this.record_late_bound_vars(hir_id, binders.clone());\n                         // Even if there are no lifetimes defined here, we still wrap it in a binder\n                         // scope. If there happens to be a nested poly trait ref (an error), that\n@@ -968,20 +968,22 @@ impl<'a, 'tcx> Visitor<'tcx> for BoundVarContext<'a, 'tcx> {\n                                     continue;\n                                 }\n                                 this.insert_lifetime(lt, ResolvedArg::StaticLifetime);\n-                                this.tcx\n-                                    .sess\n-                                    .struct_span_warn(\n-                                        lifetime.ident.span,\n-                                        &format!(\n-                                            \"unnecessary lifetime parameter `{}`\",\n+                                this.tcx.struct_span_lint_hir(\n+                                    lint::builtin::UNUSED_LIFETIMES,\n+                                    lifetime.hir_id,\n+                                    lifetime.ident.span,\n+                                    format!(\n+                                        \"unnecessary lifetime parameter `{}`\",\n+                                        lifetime.ident\n+                                    ),\n+                                    |lint| {\n+                                        let help = &format!(\n+                                            \"you can use the `'static` lifetime directly, in place of `{}`\",\n                                             lifetime.ident,\n-                                        ),\n-                                    )\n-                                    .help(&format!(\n-                                        \"you can use the `'static` lifetime directly, in place of `{}`\",\n-                                        lifetime.ident,\n-                                    ))\n-                                    .emit();\n+                                        );\n+                                        lint.help(help)\n+                                    },\n+                                );\n                             }\n                         }\n                     }"}, {"sha": "6a33826ea281c1728b560da9aa4923d8a94e4196", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3b4d6e080404560f63599deeb328dfa27fe081a6/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4d6e080404560f63599deeb328dfa27fe081a6/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=3b4d6e080404560f63599deeb328dfa27fe081a6", "patch": "@@ -932,25 +932,22 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     labels\n                         .push((provided_span, format!(\"unexpected argument{}\", provided_ty_name)));\n                     let mut span = provided_span;\n-                    if arg_idx.index() > 0\n+                    if span.can_be_used_for_suggestions() {\n+                        if arg_idx.index() > 0\n                         && let Some((_, prev)) = provided_arg_tys\n                             .get(ProvidedIdx::from_usize(arg_idx.index() - 1)\n                     ) {\n                         // Include previous comma\n-                        span = span.with_lo(prev.hi());\n-                    } else if let Some((_, next)) = provided_arg_tys.get(\n-                        ProvidedIdx::from_usize(arg_idx.index() + 1),\n-                    ) {\n-                        // Include next comma\n-                        span = span.until(*next);\n+                        span = prev.shrink_to_hi().to(span);\n                     }\n-                    suggestions.push((span, String::new()));\n+                        suggestions.push((span, String::new()));\n \n-                    suggestion_text = match suggestion_text {\n-                        SuggestionText::None => SuggestionText::Remove(false),\n-                        SuggestionText::Remove(_) => SuggestionText::Remove(true),\n-                        _ => SuggestionText::DidYouMean,\n-                    };\n+                        suggestion_text = match suggestion_text {\n+                            SuggestionText::None => SuggestionText::Remove(false),\n+                            SuggestionText::Remove(_) => SuggestionText::Remove(true),\n+                            _ => SuggestionText::DidYouMean,\n+                        };\n+                    }\n                 }\n                 Error::Missing(expected_idx) => {\n                     // If there are multiple missing arguments adjacent to each other,"}, {"sha": "21f3ef9267ff35227b5976fbcd7ad02ef52decec", "filename": "compiler/rustc_middle/src/values.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3b4d6e080404560f63599deeb328dfa27fe081a6/compiler%2Frustc_middle%2Fsrc%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4d6e080404560f63599deeb328dfa27fe081a6/compiler%2Frustc_middle%2Fsrc%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fvalues.rs?ref=3b4d6e080404560f63599deeb328dfa27fe081a6", "patch": "@@ -2,7 +2,7 @@ use crate::dep_graph::DepKind;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{pluralize, struct_span_err, Applicability, MultiSpan};\n use rustc_hir as hir;\n-use rustc_hir::def::DefKind;\n+use rustc_hir::def::{DefKind, Res};\n use rustc_middle::ty::Representability;\n use rustc_middle::ty::{self, DefIdTree, Ty, TyCtxt};\n use rustc_query_system::query::QueryInfo;\n@@ -199,7 +199,8 @@ fn find_item_ty_spans(\n ) {\n     match ty.kind {\n         hir::TyKind::Path(hir::QPath::Resolved(_, path)) => {\n-            if let Some(def_id) = path.res.opt_def_id() {\n+            if let Res::Def(kind, def_id) = path.res\n+                && kind != DefKind::TyAlias {\n                 let check_params = def_id.as_local().map_or(true, |def_id| {\n                     if def_id == needle {\n                         spans.push(ty.span);"}, {"sha": "3896f0e57ead92e141c64ee46b3b9fbe7584fb0f", "filename": "compiler/rustc_mir_transform/src/instcombine.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3b4d6e080404560f63599deeb328dfa27fe081a6/compiler%2Frustc_mir_transform%2Fsrc%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4d6e080404560f63599deeb328dfa27fe081a6/compiler%2Frustc_mir_transform%2Fsrc%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finstcombine.rs?ref=3b4d6e080404560f63599deeb328dfa27fe081a6", "patch": "@@ -30,6 +30,7 @@ impl<'tcx> MirPass<'tcx> for InstCombine {\n                         ctx.combine_bool_cmp(&statement.source_info, rvalue);\n                         ctx.combine_ref_deref(&statement.source_info, rvalue);\n                         ctx.combine_len(&statement.source_info, rvalue);\n+                        ctx.combine_cast(&statement.source_info, rvalue);\n                     }\n                     _ => {}\n                 }\n@@ -142,6 +143,14 @@ impl<'tcx> InstCombineContext<'tcx, '_> {\n         }\n     }\n \n+    fn combine_cast(&self, _source_info: &SourceInfo, rvalue: &mut Rvalue<'tcx>) {\n+        if let Rvalue::Cast(_kind, operand, ty) = rvalue {\n+            if operand.ty(self.local_decls, self.tcx) == *ty {\n+                *rvalue = Rvalue::Use(operand.clone());\n+            }\n+        }\n+    }\n+\n     fn combine_primitive_clone(\n         &self,\n         terminator: &mut Terminator<'tcx>,"}, {"sha": "d55aebf1a269612d2f212425ec0ad961fa77cdfd", "filename": "compiler/rustc_trait_selection/src/solve/assembly.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3b4d6e080404560f63599deeb328dfa27fe081a6/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4d6e080404560f63599deeb328dfa27fe081a6/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs?ref=3b4d6e080404560f63599deeb328dfa27fe081a6", "patch": "@@ -1,6 +1,5 @@\n //! Code shared by trait and projection goals for candidate assembly.\n \n-use super::infcx_ext::InferCtxtExt;\n #[cfg(doc)]\n use super::trait_goals::structural_traits::*;\n use super::{CanonicalResponse, Certainty, EvalCtxt, Goal, MaybeCause, QueryResult};\n@@ -206,7 +205,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         &mut self,\n         goal: Goal<'tcx, G>,\n     ) -> Vec<Candidate<'tcx>> {\n-        debug_assert_eq!(goal, self.infcx.resolve_vars_if_possible(goal));\n+        debug_assert_eq!(goal, self.resolve_vars_if_possible(goal));\n \n         // HACK: `_: Trait` is ambiguous, because it may be satisfied via a builtin rule,\n         // object bound, alias bound, etc. We are unable to determine this until we can at\n@@ -250,25 +249,25 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         let &ty::Alias(ty::Projection, projection_ty) = goal.predicate.self_ty().kind() else {\n             return\n         };\n-        self.infcx.probe(|_| {\n-            let normalized_ty = self.infcx.next_ty_infer();\n+        self.probe(|this| {\n+            let normalized_ty = this.next_ty_infer();\n             let normalizes_to_goal = goal.with(\n                 tcx,\n                 ty::Binder::dummy(ty::ProjectionPredicate {\n                     projection_ty,\n                     term: normalized_ty.into(),\n                 }),\n             );\n-            let normalization_certainty = match self.evaluate_goal(normalizes_to_goal) {\n+            let normalization_certainty = match this.evaluate_goal(normalizes_to_goal) {\n                 Ok((_, certainty)) => certainty,\n                 Err(NoSolution) => return,\n             };\n-            let normalized_ty = self.infcx.resolve_vars_if_possible(normalized_ty);\n+            let normalized_ty = this.resolve_vars_if_possible(normalized_ty);\n \n             // NOTE: Alternatively we could call `evaluate_goal` here and only have a `Normalized` candidate.\n             // This doesn't work as long as we use `CandidateSource` in winnowing.\n             let goal = goal.with(tcx, goal.predicate.with_self_ty(tcx, normalized_ty));\n-            let normalized_candidates = self.assemble_and_evaluate_candidates(goal);\n+            let normalized_candidates = this.assemble_and_evaluate_candidates(goal);\n             for mut normalized_candidate in normalized_candidates {\n                 normalized_candidate.result =\n                     normalized_candidate.result.unchecked_map(|mut response| {"}, {"sha": "67addd732d0adfa4dcfc3cba641efe34003119d0", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt.rs", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/3b4d6e080404560f63599deeb328dfa27fe081a6/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4d6e080404560f63599deeb328dfa27fe081a6/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs?ref=3b4d6e080404560f63599deeb328dfa27fe081a6", "patch": "@@ -0,0 +1,172 @@\n+use rustc_hir::def_id::DefId;\n+use rustc_infer::infer::at::ToTrace;\n+use rustc_infer::infer::canonical::CanonicalVarValues;\n+use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use rustc_infer::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime};\n+use rustc_infer::traits::query::NoSolution;\n+use rustc_infer::traits::ObligationCause;\n+use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n+use rustc_middle::ty::{self, ir::TypeVisitor, Ty, TyCtxt, TypeFoldable, TypeSuperVisitable};\n+use rustc_span::DUMMY_SP;\n+use std::ops::ControlFlow;\n+\n+use super::search_graph::SearchGraph;\n+use super::Goal;\n+\n+pub struct EvalCtxt<'a, 'tcx> {\n+    // FIXME: should be private.\n+    pub(super) infcx: &'a InferCtxt<'tcx>,\n+\n+    pub(super) var_values: CanonicalVarValues<'tcx>,\n+\n+    pub(super) search_graph: &'a mut SearchGraph<'tcx>,\n+\n+    /// This field is used by a debug assertion in [`EvalCtxt::evaluate_goal`],\n+    /// see the comment in that method for more details.\n+    pub in_projection_eq_hack: bool,\n+}\n+\n+impl<'tcx> EvalCtxt<'_, 'tcx> {\n+    pub(super) fn probe<T>(&mut self, f: impl FnOnce(&mut EvalCtxt<'_, 'tcx>) -> T) -> T {\n+        self.infcx.probe(|_| f(self))\n+    }\n+\n+    pub(super) fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.infcx.tcx\n+    }\n+\n+    pub(super) fn next_ty_infer(&self) -> Ty<'tcx> {\n+        self.infcx.next_ty_var(TypeVariableOrigin {\n+            kind: TypeVariableOriginKind::MiscVariable,\n+            span: DUMMY_SP,\n+        })\n+    }\n+\n+    pub(super) fn next_const_infer(&self, ty: Ty<'tcx>) -> ty::Const<'tcx> {\n+        self.infcx.next_const_var(\n+            ty,\n+            ConstVariableOrigin { kind: ConstVariableOriginKind::MiscVariable, span: DUMMY_SP },\n+        )\n+    }\n+\n+    /// Is the projection predicate is of the form `exists<T> <Ty as Trait>::Assoc = T`.\n+    ///\n+    /// This is the case if the `term` is an inference variable in the innermost universe\n+    /// and does not occur in any other part of the predicate.\n+    pub(super) fn term_is_fully_unconstrained(\n+        &self,\n+        goal: Goal<'tcx, ty::ProjectionPredicate<'tcx>>,\n+    ) -> bool {\n+        let term_is_infer = match goal.predicate.term.unpack() {\n+            ty::TermKind::Ty(ty) => {\n+                if let &ty::Infer(ty::TyVar(vid)) = ty.kind() {\n+                    match self.infcx.probe_ty_var(vid) {\n+                        Ok(value) => bug!(\"resolved var in query: {goal:?} {value:?}\"),\n+                        Err(universe) => universe == self.universe(),\n+                    }\n+                } else {\n+                    false\n+                }\n+            }\n+            ty::TermKind::Const(ct) => {\n+                if let ty::ConstKind::Infer(ty::InferConst::Var(vid)) = ct.kind() {\n+                    match self.infcx.probe_const_var(vid) {\n+                        Ok(value) => bug!(\"resolved var in query: {goal:?} {value:?}\"),\n+                        Err(universe) => universe == self.universe(),\n+                    }\n+                } else {\n+                    false\n+                }\n+            }\n+        };\n+\n+        // Guard against `<T as Trait<?0>>::Assoc = ?0>`.\n+        struct ContainsTerm<'tcx> {\n+            term: ty::Term<'tcx>,\n+        }\n+        impl<'tcx> TypeVisitor<TyCtxt<'tcx>> for ContainsTerm<'tcx> {\n+            type BreakTy = ();\n+            fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n+                if t.needs_infer() {\n+                    if ty::Term::from(t) == self.term {\n+                        ControlFlow::Break(())\n+                    } else {\n+                        t.super_visit_with(self)\n+                    }\n+                } else {\n+                    ControlFlow::Continue(())\n+                }\n+            }\n+\n+            fn visit_const(&mut self, c: ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n+                if c.needs_infer() {\n+                    if ty::Term::from(c) == self.term {\n+                        ControlFlow::Break(())\n+                    } else {\n+                        c.super_visit_with(self)\n+                    }\n+                } else {\n+                    ControlFlow::Continue(())\n+                }\n+            }\n+        }\n+\n+        let mut visitor = ContainsTerm { term: goal.predicate.term };\n+\n+        term_is_infer\n+            && goal.predicate.projection_ty.visit_with(&mut visitor).is_continue()\n+            && goal.param_env.visit_with(&mut visitor).is_continue()\n+    }\n+\n+    #[instrument(level = \"debug\", skip(self, param_env), ret)]\n+    pub(super) fn eq<T: ToTrace<'tcx>>(\n+        &self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        lhs: T,\n+        rhs: T,\n+    ) -> Result<Vec<Goal<'tcx, ty::Predicate<'tcx>>>, NoSolution> {\n+        self.infcx\n+            .at(&ObligationCause::dummy(), param_env)\n+            .eq(lhs, rhs)\n+            .map(|InferOk { value: (), obligations }| {\n+                obligations.into_iter().map(|o| o.into()).collect()\n+            })\n+            .map_err(|e| {\n+                debug!(?e, \"failed to equate\");\n+                NoSolution\n+            })\n+    }\n+\n+    pub(super) fn instantiate_binder_with_infer<T: TypeFoldable<'tcx> + Copy>(\n+        &self,\n+        value: ty::Binder<'tcx, T>,\n+    ) -> T {\n+        self.infcx.instantiate_binder_with_fresh_vars(\n+            DUMMY_SP,\n+            LateBoundRegionConversionTime::HigherRankedType,\n+            value,\n+        )\n+    }\n+\n+    pub(super) fn instantiate_binder_with_placeholders<T: TypeFoldable<'tcx> + Copy>(\n+        &self,\n+        value: ty::Binder<'tcx, T>,\n+    ) -> T {\n+        self.infcx.instantiate_binder_with_placeholders(value)\n+    }\n+\n+    pub(super) fn resolve_vars_if_possible<T>(&self, value: T) -> T\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        self.infcx.resolve_vars_if_possible(value)\n+    }\n+\n+    pub(super) fn fresh_substs_for_item(&self, def_id: DefId) -> ty::SubstsRef<'tcx> {\n+        self.infcx.fresh_substs_for_item(DUMMY_SP, def_id)\n+    }\n+\n+    pub(super) fn universe(&self) -> ty::UniverseIndex {\n+        self.infcx.universe()\n+    }\n+}"}, {"sha": "06570e1f4b41cd600615f1507e023378c7cb3125", "filename": "compiler/rustc_trait_selection/src/solve/infcx_ext.rs", "status": "removed", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/bd4a96a12d0bf6dc12edf20a45df3a33052c9d7d/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Finfcx_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd4a96a12d0bf6dc12edf20a45df3a33052c9d7d/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Finfcx_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Finfcx_ext.rs?ref=bd4a96a12d0bf6dc12edf20a45df3a33052c9d7d", "patch": "@@ -1,77 +0,0 @@\n-use rustc_infer::infer::at::ToTrace;\n-use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc_infer::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime};\n-use rustc_infer::traits::query::NoSolution;\n-use rustc_infer::traits::ObligationCause;\n-use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n-use rustc_middle::ty::{self, Ty, TypeFoldable};\n-use rustc_span::DUMMY_SP;\n-\n-use super::Goal;\n-\n-/// Methods used inside of the canonical queries of the solver.\n-///\n-/// Most notably these do not care about diagnostics information.\n-/// If you find this while looking for methods to use outside of the\n-/// solver, you may look at the implementation of these method for\n-/// help.\n-pub(super) trait InferCtxtExt<'tcx> {\n-    fn next_ty_infer(&self) -> Ty<'tcx>;\n-    fn next_const_infer(&self, ty: Ty<'tcx>) -> ty::Const<'tcx>;\n-\n-    fn eq<T: ToTrace<'tcx>>(\n-        &self,\n-        param_env: ty::ParamEnv<'tcx>,\n-        lhs: T,\n-        rhs: T,\n-    ) -> Result<Vec<Goal<'tcx, ty::Predicate<'tcx>>>, NoSolution>;\n-\n-    fn instantiate_binder_with_infer<T: TypeFoldable<'tcx> + Copy>(\n-        &self,\n-        value: ty::Binder<'tcx, T>,\n-    ) -> T;\n-}\n-\n-impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n-    fn next_ty_infer(&self) -> Ty<'tcx> {\n-        self.next_ty_var(TypeVariableOrigin {\n-            kind: TypeVariableOriginKind::MiscVariable,\n-            span: DUMMY_SP,\n-        })\n-    }\n-    fn next_const_infer(&self, ty: Ty<'tcx>) -> ty::Const<'tcx> {\n-        self.next_const_var(\n-            ty,\n-            ConstVariableOrigin { kind: ConstVariableOriginKind::MiscVariable, span: DUMMY_SP },\n-        )\n-    }\n-\n-    #[instrument(level = \"debug\", skip(self, param_env), ret)]\n-    fn eq<T: ToTrace<'tcx>>(\n-        &self,\n-        param_env: ty::ParamEnv<'tcx>,\n-        lhs: T,\n-        rhs: T,\n-    ) -> Result<Vec<Goal<'tcx, ty::Predicate<'tcx>>>, NoSolution> {\n-        self.at(&ObligationCause::dummy(), param_env)\n-            .eq(lhs, rhs)\n-            .map(|InferOk { value: (), obligations }| {\n-                obligations.into_iter().map(|o| o.into()).collect()\n-            })\n-            .map_err(|e| {\n-                debug!(?e, \"failed to equate\");\n-                NoSolution\n-            })\n-    }\n-\n-    fn instantiate_binder_with_infer<T: TypeFoldable<'tcx> + Copy>(\n-        &self,\n-        value: ty::Binder<'tcx, T>,\n-    ) -> T {\n-        self.instantiate_binder_with_fresh_vars(\n-            DUMMY_SP,\n-            LateBoundRegionConversionTime::HigherRankedType,\n-            value,\n-        )\n-    }\n-}"}, {"sha": "c080f7e59fa225a1ad65b3ac84654866b7371ce0", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 7, "deletions": 23, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3b4d6e080404560f63599deeb328dfa27fe081a6/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4d6e080404560f63599deeb328dfa27fe081a6/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=3b4d6e080404560f63599deeb328dfa27fe081a6", "patch": "@@ -35,16 +35,15 @@ use crate::solve::search_graph::OverflowHandler;\n use crate::traits::ObligationCause;\n \n mod assembly;\n+mod eval_ctxt;\n mod fulfill;\n-mod infcx_ext;\n mod project_goals;\n mod search_graph;\n mod trait_goals;\n \n+pub use eval_ctxt::EvalCtxt;\n pub use fulfill::FulfillmentCtxt;\n \n-use self::infcx_ext::InferCtxtExt;\n-\n /// A goal is a statement, i.e. `predicate`, we want to prove\n /// given some assumptions, i.e. `param_env`.\n ///\n@@ -180,22 +179,7 @@ impl<'tcx> InferCtxtEvalExt<'tcx> for InferCtxt<'tcx> {\n     }\n }\n \n-struct EvalCtxt<'a, 'tcx> {\n-    infcx: &'a InferCtxt<'tcx>,\n-    var_values: CanonicalVarValues<'tcx>,\n-\n-    search_graph: &'a mut search_graph::SearchGraph<'tcx>,\n-\n-    /// This field is used by a debug assertion in [`EvalCtxt::evaluate_goal`],\n-    /// see the comment in that method for more details.\n-    in_projection_eq_hack: bool,\n-}\n-\n impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n-    fn tcx(&self) -> TyCtxt<'tcx> {\n-        self.infcx.tcx\n-    }\n-\n     /// The entry point of the solver.\n     ///\n     /// This function deals with (coinductive) cycles, overflow, and caching\n@@ -427,7 +411,7 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n \n         let evaluate_normalizes_to = |ecx: &mut EvalCtxt<'_, 'tcx>, alias, other| {\n             debug!(\"evaluate_normalizes_to(alias={:?}, other={:?})\", alias, other);\n-            let r = ecx.infcx.probe(|_| {\n+            let r = ecx.probe(|ecx| {\n                 let (_, certainty) = ecx.evaluate_goal(goal.with(\n                     tcx,\n                     ty::Binder::dummy(ty::ProjectionPredicate {\n@@ -462,10 +446,10 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n                 // Evaluate all 3 potential candidates for the alias' being equal\n                 candidates.push(evaluate_normalizes_to(self, alias_lhs, goal.predicate.1));\n                 candidates.push(evaluate_normalizes_to(self, alias_rhs, goal.predicate.0));\n-                candidates.push(self.infcx.probe(|_| {\n+                candidates.push(self.probe(|this| {\n                     debug!(\"compute_alias_eq_goal: alias defids are equal, equating substs\");\n-                    let nested_goals = self.infcx.eq(goal.param_env, alias_lhs, alias_rhs)?;\n-                    self.evaluate_all_and_make_canonical_response(nested_goals)\n+                    let nested_goals = this.eq(goal.param_env, alias_lhs, alias_rhs)?;\n+                    this.evaluate_all_and_make_canonical_response(nested_goals)\n                 }));\n \n                 debug!(?candidates);\n@@ -481,7 +465,7 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n         goal: Goal<'tcx, (ty::Const<'tcx>, Ty<'tcx>)>,\n     ) -> QueryResult<'tcx> {\n         let (ct, ty) = goal.predicate;\n-        let nested_goals = self.infcx.eq(goal.param_env, ct.ty(), ty)?;\n+        let nested_goals = self.eq(goal.param_env, ct.ty(), ty)?;\n         self.evaluate_all_and_make_canonical_response(nested_goals)\n     }\n }"}, {"sha": "9f83bfa1ccb9bf6a97535471aa986c58f8860555", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 12, "deletions": 84, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/3b4d6e080404560f63599deeb328dfa27fe081a6/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4d6e080404560f63599deeb328dfa27fe081a6/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=3b4d6e080404560f63599deeb328dfa27fe081a6", "patch": "@@ -1,7 +1,6 @@\n use crate::traits::{specialization_graph, translate_substs};\n \n use super::assembly;\n-use super::infcx_ext::InferCtxtExt;\n use super::trait_goals::structural_traits;\n use super::{Certainty, EvalCtxt, Goal, QueryResult};\n use rustc_errors::ErrorGuaranteed;\n@@ -13,12 +12,11 @@ use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::specialization_graph::LeafDef;\n use rustc_infer::traits::Reveal;\n use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n+use rustc_middle::ty::ProjectionPredicate;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n-use rustc_middle::ty::{ir::TypeVisitor, ProjectionPredicate, TypeSuperVisitable};\n use rustc_middle::ty::{ToPredicate, TypeVisitable};\n use rustc_span::{sym, DUMMY_SP};\n use std::iter;\n-use std::ops::ControlFlow;\n \n impl<'tcx> EvalCtxt<'_, 'tcx> {\n     pub(super) fn compute_projection_goal(\n@@ -38,8 +36,8 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         } else {\n             let predicate = goal.predicate;\n             let unconstrained_rhs = match predicate.term.unpack() {\n-                ty::TermKind::Ty(_) => self.infcx.next_ty_infer().into(),\n-                ty::TermKind::Const(ct) => self.infcx.next_const_infer(ct.ty()).into(),\n+                ty::TermKind::Ty(_) => self.next_ty_infer().into(),\n+                ty::TermKind::Const(ct) => self.next_const_infer(ct.ty()).into(),\n             };\n             let unconstrained_predicate = ty::Clause::Projection(ProjectionPredicate {\n                 projection_ty: goal.predicate.projection_ty,\n@@ -49,8 +47,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n                 this.evaluate_goal(goal.with(this.tcx(), unconstrained_predicate))\n             })?;\n \n-            let nested_eq_goals =\n-                self.infcx.eq(goal.param_env, unconstrained_rhs, predicate.term)?;\n+            let nested_eq_goals = self.eq(goal.param_env, unconstrained_rhs, predicate.term)?;\n             let eval_certainty = self.evaluate_all(nested_eq_goals)?;\n             self.make_canonical_response(normalize_certainty.unify_and(eval_certainty))\n         }\n@@ -65,73 +62,6 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         result\n     }\n \n-    /// Is the projection predicate is of the form `exists<T> <Ty as Trait>::Assoc = T`.\n-    ///\n-    /// This is the case if the `term` is an inference variable in the innermost universe\n-    /// and does not occur in any other part of the predicate.\n-    fn term_is_fully_unconstrained(&self, goal: Goal<'tcx, ProjectionPredicate<'tcx>>) -> bool {\n-        let infcx = self.infcx;\n-        let term_is_infer = match goal.predicate.term.unpack() {\n-            ty::TermKind::Ty(ty) => {\n-                if let &ty::Infer(ty::TyVar(vid)) = ty.kind() {\n-                    match infcx.probe_ty_var(vid) {\n-                        Ok(value) => bug!(\"resolved var in query: {goal:?} {value:?}\"),\n-                        Err(universe) => universe == infcx.universe(),\n-                    }\n-                } else {\n-                    false\n-                }\n-            }\n-            ty::TermKind::Const(ct) => {\n-                if let ty::ConstKind::Infer(ty::InferConst::Var(vid)) = ct.kind() {\n-                    match self.infcx.probe_const_var(vid) {\n-                        Ok(value) => bug!(\"resolved var in query: {goal:?} {value:?}\"),\n-                        Err(universe) => universe == infcx.universe(),\n-                    }\n-                } else {\n-                    false\n-                }\n-            }\n-        };\n-\n-        // Guard against `<T as Trait<?0>>::Assoc = ?0>`.\n-        struct ContainsTerm<'tcx> {\n-            term: ty::Term<'tcx>,\n-        }\n-        impl<'tcx> TypeVisitor<TyCtxt<'tcx>> for ContainsTerm<'tcx> {\n-            type BreakTy = ();\n-            fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n-                if t.needs_infer() {\n-                    if ty::Term::from(t) == self.term {\n-                        ControlFlow::Break(())\n-                    } else {\n-                        t.super_visit_with(self)\n-                    }\n-                } else {\n-                    ControlFlow::Continue(())\n-                }\n-            }\n-\n-            fn visit_const(&mut self, c: ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n-                if c.needs_infer() {\n-                    if ty::Term::from(c) == self.term {\n-                        ControlFlow::Break(())\n-                    } else {\n-                        c.super_visit_with(self)\n-                    }\n-                } else {\n-                    ControlFlow::Continue(())\n-                }\n-            }\n-        }\n-\n-        let mut visitor = ContainsTerm { term: goal.predicate.term };\n-\n-        term_is_infer\n-            && goal.predicate.projection_ty.visit_with(&mut visitor).is_continue()\n-            && goal.param_env.visit_with(&mut visitor).is_continue()\n-    }\n-\n     /// After normalizing the projection to `normalized_alias` with the given\n     /// `normalization_certainty`, constrain the inference variable `term` to it\n     /// and return a query response.\n@@ -145,7 +75,6 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         //\n         // It can however be ambiguous when the `normalized_alias` contains a projection.\n         let nested_goals = self\n-            .infcx\n             .eq(goal.param_env, goal.predicate.term, normalized_alias.into())\n             .expect(\"failed to unify with unconstrained term\");\n         let rhs_certainty =\n@@ -177,10 +106,10 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n         if let Some(poly_projection_pred) = assumption.to_opt_poly_projection_pred()\n             && poly_projection_pred.projection_def_id() == goal.predicate.def_id()\n         {\n-            ecx.infcx.probe(|_| {\n+            ecx.probe(|ecx| {\n                 let assumption_projection_pred =\n-                    ecx.infcx.instantiate_binder_with_infer(poly_projection_pred);\n-                let mut nested_goals = ecx.infcx.eq(\n+                    ecx.instantiate_binder_with_infer(poly_projection_pred);\n+                let mut nested_goals = ecx.eq(\n                     goal.param_env,\n                     goal.predicate.projection_ty,\n                     assumption_projection_pred.projection_ty,\n@@ -215,11 +144,11 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n             return Err(NoSolution);\n         }\n \n-        ecx.infcx.probe(|_| {\n-            let impl_substs = ecx.infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id);\n+        ecx.probe(|ecx| {\n+            let impl_substs = ecx.fresh_substs_for_item(impl_def_id);\n             let impl_trait_ref = impl_trait_ref.subst(tcx, impl_substs);\n \n-            let mut nested_goals = ecx.infcx.eq(goal.param_env, goal_trait_ref, impl_trait_ref)?;\n+            let mut nested_goals = ecx.eq(goal.param_env, goal_trait_ref, impl_trait_ref)?;\n             let where_clause_bounds = tcx\n                 .predicates_of(impl_def_id)\n                 .instantiate(tcx, impl_substs)\n@@ -367,7 +296,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx> {\n         let tcx = ecx.tcx();\n-        ecx.infcx.probe(|_| {\n+        ecx.probe(|ecx| {\n             let metadata_ty = match goal.predicate.self_ty().kind() {\n                 ty::Bool\n                 | ty::Char\n@@ -546,8 +475,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx> {\n         let discriminant = goal.predicate.self_ty().discriminant_ty(ecx.tcx());\n-        ecx.infcx\n-            .probe(|_| ecx.eq_term_and_make_canonical_response(goal, Certainty::Yes, discriminant))\n+        ecx.probe(|ecx| ecx.eq_term_and_make_canonical_response(goal, Certainty::Yes, discriminant))\n     }\n }\n "}, {"sha": "6d1381bbf0c9f35c02c8a915f1df682c2f68ad32", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 19, "deletions": 21, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/3b4d6e080404560f63599deeb328dfa27fe081a6/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4d6e080404560f63599deeb328dfa27fe081a6/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=3b4d6e080404560f63599deeb328dfa27fe081a6", "patch": "@@ -3,11 +3,9 @@\n use std::iter;\n \n use super::assembly;\n-use super::infcx_ext::InferCtxtExt;\n use super::{CanonicalResponse, Certainty, EvalCtxt, Goal, QueryResult};\n use rustc_hir::def_id::DefId;\n use rustc_hir::LangItem;\n-use rustc_infer::infer::InferCtxt;\n use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::util::supertraits;\n use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n@@ -45,12 +43,12 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n             return Err(NoSolution);\n         }\n \n-        ecx.infcx.probe(|_| {\n-            let impl_substs = ecx.infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id);\n+        ecx.probe(|ecx| {\n+            let impl_substs = ecx.fresh_substs_for_item(impl_def_id);\n             let impl_trait_ref = impl_trait_ref.subst(tcx, impl_substs);\n \n             let mut nested_goals =\n-                ecx.infcx.eq(goal.param_env, goal.predicate.trait_ref, impl_trait_ref)?;\n+                ecx.eq(goal.param_env, goal.predicate.trait_ref, impl_trait_ref)?;\n             let where_clause_bounds = tcx\n                 .predicates_of(impl_def_id)\n                 .instantiate(tcx, impl_substs)\n@@ -72,10 +70,10 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n             && poly_trait_pred.def_id() == goal.predicate.def_id()\n         {\n             // FIXME: Constness and polarity\n-            ecx.infcx.probe(|_| {\n+            ecx.probe(|ecx| {\n                 let assumption_trait_pred =\n-                    ecx.infcx.instantiate_binder_with_infer(poly_trait_pred);\n-                let mut nested_goals = ecx.infcx.eq(\n+                    ecx.instantiate_binder_with_infer(poly_trait_pred);\n+                let mut nested_goals = ecx.eq(\n                     goal.param_env,\n                     goal.predicate.trait_ref,\n                     assumption_trait_pred.trait_ref,\n@@ -118,7 +116,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n     ) -> QueryResult<'tcx> {\n         let tcx = ecx.tcx();\n \n-        ecx.infcx.probe(|_| {\n+        ecx.probe(|ecx| {\n             let nested_obligations = tcx\n                 .predicates_of(goal.predicate.def_id())\n                 .instantiate(tcx, goal.predicate.trait_ref.substs);\n@@ -275,7 +273,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         if b_ty.is_ty_var() {\n             return ecx.make_canonical_response(Certainty::AMBIGUOUS);\n         }\n-        ecx.infcx.probe(|_| {\n+        ecx.probe(|ecx| {\n             match (a_ty.kind(), b_ty.kind()) {\n                 // Trait upcasting, or `dyn Trait + Auto + 'a` -> `dyn Trait + 'b`\n                 (&ty::Dynamic(_, _, ty::Dyn), &ty::Dynamic(_, _, ty::Dyn)) => {\n@@ -318,7 +316,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n                 // `[T; n]` -> `[T]` unsizing\n                 (&ty::Array(a_elem_ty, ..), &ty::Slice(b_elem_ty)) => {\n                     // We just require that the element type stays the same\n-                    let nested_goals = ecx.infcx.eq(goal.param_env, a_elem_ty, b_elem_ty)?;\n+                    let nested_goals = ecx.eq(goal.param_env, a_elem_ty, b_elem_ty)?;\n                     ecx.evaluate_all_and_make_canonical_response(nested_goals)\n                 }\n                 // Struct unsizing `Struct<T>` -> `Struct<U>` where `T: Unsize<U>`\n@@ -352,7 +350,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n \n                     // Finally, we require that `TailA: Unsize<TailB>` for the tail field\n                     // types.\n-                    let mut nested_goals = ecx.infcx.eq(goal.param_env, unsized_a_ty, b_ty)?;\n+                    let mut nested_goals = ecx.eq(goal.param_env, unsized_a_ty, b_ty)?;\n                     nested_goals.push(goal.with(\n                         tcx,\n                         ty::Binder::dummy(\n@@ -371,7 +369,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n \n                     // Substitute just the tail field of B., and require that they're equal.\n                     let unsized_a_ty = tcx.mk_tup(a_rest_tys.iter().chain([b_last_ty]).copied());\n-                    let mut nested_goals = ecx.infcx.eq(goal.param_env, unsized_a_ty, b_ty)?;\n+                    let mut nested_goals = ecx.eq(goal.param_env, unsized_a_ty, b_ty)?;\n \n                     // Similar to ADTs, require that the rest of the fields are equal.\n                     nested_goals.push(goal.with(\n@@ -411,7 +409,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         }\n \n         let mut unsize_dyn_to_principal = |principal: Option<ty::PolyExistentialTraitRef<'tcx>>| {\n-            ecx.infcx.probe(|_| -> Result<_, NoSolution> {\n+            ecx.probe(|ecx| -> Result<_, NoSolution> {\n                 // Require that all of the trait predicates from A match B, except for\n                 // the auto traits. We do this by constructing a new A type with B's\n                 // auto traits, and equating these types.\n@@ -431,7 +429,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n                 let new_a_ty = tcx.mk_dynamic(new_a_data, b_region, ty::Dyn);\n \n                 // We also require that A's lifetime outlives B's lifetime.\n-                let mut nested_obligations = ecx.infcx.eq(goal.param_env, new_a_ty, b_ty)?;\n+                let mut nested_obligations = ecx.eq(goal.param_env, new_a_ty, b_ty)?;\n                 nested_obligations.push(\n                     goal.with(tcx, ty::Binder::dummy(ty::OutlivesPredicate(a_region, b_region))),\n                 );\n@@ -482,16 +480,16 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n     fn probe_and_evaluate_goal_for_constituent_tys(\n         &mut self,\n         goal: Goal<'tcx, TraitPredicate<'tcx>>,\n-        constituent_tys: impl Fn(&InferCtxt<'tcx>, Ty<'tcx>) -> Result<Vec<Ty<'tcx>>, NoSolution>,\n+        constituent_tys: impl Fn(&EvalCtxt<'_, 'tcx>, Ty<'tcx>) -> Result<Vec<Ty<'tcx>>, NoSolution>,\n     ) -> QueryResult<'tcx> {\n-        self.infcx.probe(|_| {\n-            self.evaluate_all_and_make_canonical_response(\n-                constituent_tys(self.infcx, goal.predicate.self_ty())?\n+        self.probe(|this| {\n+            this.evaluate_all_and_make_canonical_response(\n+                constituent_tys(this, goal.predicate.self_ty())?\n                     .into_iter()\n                     .map(|ty| {\n                         goal.with(\n-                            self.tcx(),\n-                            ty::Binder::dummy(goal.predicate.with_self_ty(self.tcx(), ty)),\n+                            this.tcx(),\n+                            ty::Binder::dummy(goal.predicate.with_self_ty(this.tcx(), ty)),\n                         )\n                     })\n                     .collect(),"}, {"sha": "2c13465d347c40b26d38e5e0dc8e4bbee1343980", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals/structural_traits.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3b4d6e080404560f63599deeb328dfa27fe081a6/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4d6e080404560f63599deeb328dfa27fe081a6/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs?ref=3b4d6e080404560f63599deeb328dfa27fe081a6", "patch": "@@ -1,16 +1,18 @@\n use rustc_hir::{Movability, Mutability};\n-use rustc_infer::{infer::InferCtxt, traits::query::NoSolution};\n+use rustc_infer::traits::query::NoSolution;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n \n+use crate::solve::EvalCtxt;\n+\n // Calculates the constituent types of a type for `auto trait` purposes.\n //\n // For types with an \"existential\" binder, i.e. generator witnesses, we also\n // instantiate the binder with placeholders eagerly.\n pub(super) fn instantiate_constituent_tys_for_auto_trait<'tcx>(\n-    infcx: &InferCtxt<'tcx>,\n+    ecx: &EvalCtxt<'_, 'tcx>,\n     ty: Ty<'tcx>,\n ) -> Result<Vec<Ty<'tcx>>, NoSolution> {\n-    let tcx = infcx.tcx;\n+    let tcx = ecx.tcx();\n     match *ty.kind() {\n         ty::Uint(_)\n         | ty::Int(_)\n@@ -53,9 +55,7 @@ pub(super) fn instantiate_constituent_tys_for_auto_trait<'tcx>(\n             Ok(vec![generator_substs.tupled_upvars_ty(), generator_substs.witness()])\n         }\n \n-        ty::GeneratorWitness(types) => {\n-            Ok(infcx.instantiate_binder_with_placeholders(types).to_vec())\n-        }\n+        ty::GeneratorWitness(types) => Ok(ecx.instantiate_binder_with_placeholders(types).to_vec()),\n \n         ty::GeneratorWitnessMIR(..) => todo!(),\n \n@@ -74,7 +74,7 @@ pub(super) fn instantiate_constituent_tys_for_auto_trait<'tcx>(\n }\n \n pub(super) fn instantiate_constituent_tys_for_sized_trait<'tcx>(\n-    infcx: &InferCtxt<'tcx>,\n+    ecx: &EvalCtxt<'_, 'tcx>,\n     ty: Ty<'tcx>,\n ) -> Result<Vec<Ty<'tcx>>, NoSolution> {\n     match *ty.kind() {\n@@ -113,18 +113,18 @@ pub(super) fn instantiate_constituent_tys_for_sized_trait<'tcx>(\n         ty::Tuple(tys) => Ok(tys.to_vec()),\n \n         ty::Adt(def, substs) => {\n-            let sized_crit = def.sized_constraint(infcx.tcx);\n+            let sized_crit = def.sized_constraint(ecx.tcx());\n             Ok(sized_crit\n                 .0\n                 .iter()\n-                .map(|ty| sized_crit.rebind(*ty).subst(infcx.tcx, substs))\n+                .map(|ty| sized_crit.rebind(*ty).subst(ecx.tcx(), substs))\n                 .collect())\n         }\n     }\n }\n \n pub(super) fn instantiate_constituent_tys_for_copy_clone_trait<'tcx>(\n-    infcx: &InferCtxt<'tcx>,\n+    ecx: &EvalCtxt<'_, 'tcx>,\n     ty: Ty<'tcx>,\n ) -> Result<Vec<Ty<'tcx>>, NoSolution> {\n     match *ty.kind() {\n@@ -165,17 +165,15 @@ pub(super) fn instantiate_constituent_tys_for_copy_clone_trait<'tcx>(\n         ty::Closure(_, substs) => Ok(vec![substs.as_closure().tupled_upvars_ty()]),\n \n         ty::Generator(_, substs, Movability::Movable) => {\n-            if infcx.tcx.features().generator_clone {\n+            if ecx.tcx().features().generator_clone {\n                 let generator = substs.as_generator();\n                 Ok(vec![generator.tupled_upvars_ty(), generator.witness()])\n             } else {\n                 Err(NoSolution)\n             }\n         }\n \n-        ty::GeneratorWitness(types) => {\n-            Ok(infcx.instantiate_binder_with_placeholders(types).to_vec())\n-        }\n+        ty::GeneratorWitness(types) => Ok(ecx.instantiate_binder_with_placeholders(types).to_vec()),\n \n         ty::GeneratorWitnessMIR(..) => todo!(),\n     }"}, {"sha": "66c33d58d6ca3ae2fbeffc53b9c80ff669924d5b", "filename": "library/std/src/sys/unix/fd.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3b4d6e080404560f63599deeb328dfa27fe081a6/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4d6e080404560f63599deeb328dfa27fe081a6/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs?ref=3b4d6e080404560f63599deeb328dfa27fe081a6", "patch": "@@ -197,11 +197,6 @@ impl FileDesc {\n         }\n     }\n \n-    #[cfg(target_os = \"linux\")]\n-    pub fn get_cloexec(&self) -> io::Result<bool> {\n-        unsafe { Ok((cvt(libc::fcntl(self.as_raw_fd(), libc::F_GETFD))? & libc::FD_CLOEXEC) != 0) }\n-    }\n-\n     #[cfg(not(any(\n         target_env = \"newlib\",\n         target_os = \"solaris\","}, {"sha": "b4f1506dc8f30c019aaaf0ec021eac9ceb6d6c15", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3b4d6e080404560f63599deeb328dfa27fe081a6/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4d6e080404560f63599deeb328dfa27fe081a6/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=3b4d6e080404560f63599deeb328dfa27fe081a6", "patch": "@@ -435,6 +435,10 @@ impl Step for Rustfmt {\n             &[],\n         );\n \n+        if !builder.fail_fast {\n+            cargo.arg(\"--no-fail-fast\");\n+        }\n+\n         let dir = testdir(builder, compiler.host);\n         t!(fs::create_dir_all(&dir));\n         cargo.env(\"RUSTFMT_TEST_DIR\", dir);\n@@ -615,6 +619,10 @@ impl Step for Miri {\n         );\n         cargo.add_rustc_lib_path(builder, compiler);\n \n+        if !builder.fail_fast {\n+            cargo.arg(\"--no-fail-fast\");\n+        }\n+\n         // miri tests need to know about the stage sysroot\n         cargo.env(\"MIRI_SYSROOT\", &miri_sysroot);\n         cargo.env(\"MIRI_HOST_SYSROOT\", sysroot);\n@@ -746,6 +754,10 @@ impl Step for Clippy {\n             &[],\n         );\n \n+        if !builder.fail_fast {\n+            cargo.arg(\"--no-fail-fast\");\n+        }\n+\n         cargo.env(\"RUSTC_TEST_SUITE\", builder.rustc(compiler));\n         cargo.env(\"RUSTC_LIB_PATH\", builder.rustc_libdir(compiler));\n         let host_libs = builder.stage_out(compiler, Mode::ToolRustc).join(builder.cargo_dir());"}, {"sha": "5541136ef490d8f9192c414e25f9a8dbf559f5d4", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3b4d6e080404560f63599deeb328dfa27fe081a6/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4d6e080404560f63599deeb328dfa27fe081a6/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=3b4d6e080404560f63599deeb328dfa27fe081a6", "patch": "@@ -2114,17 +2114,29 @@ fn get_all_import_attributes<'hir>(\n     attributes: &mut Vec<ast::Attribute>,\n     is_inline: bool,\n ) {\n+    let mut first = true;\n     let hir_map = tcx.hir();\n     let mut visitor = OneLevelVisitor::new(hir_map, target_def_id);\n     let mut visited = FxHashSet::default();\n+\n     // If the item is an import and has at least a path with two parts, we go into it.\n     while let hir::ItemKind::Use(path, _) = item.kind && visited.insert(item.hir_id()) {\n-        // We add the attributes from this import into the list.\n-        add_without_unwanted_attributes(attributes, hir_map.attrs(item.hir_id()), is_inline);\n+        if first {\n+            // This is the \"original\" reexport so we get all its attributes without filtering them.\n+            attributes.extend_from_slice(hir_map.attrs(item.hir_id()));\n+            first = false;\n+        } else {\n+            add_without_unwanted_attributes(attributes, hir_map.attrs(item.hir_id()), is_inline);\n+        }\n \n-        let def_id = if path.segments.len() > 1 {\n-            match path.segments[path.segments.len() - 2].res {\n+        let def_id = if let [.., parent_segment, _] = &path.segments {\n+            match parent_segment.res {\n                 hir::def::Res::Def(_, def_id) => def_id,\n+                _ if parent_segment.ident.name == kw::Crate => {\n+                    // In case the \"parent\" is the crate, it'll give `Res::Err` so we need to\n+                    // circumvent it this way.\n+                    tcx.parent(item.owner_id.def_id.to_def_id())\n+                }\n                 _ => break,\n             }\n         } else {\n@@ -2341,9 +2353,7 @@ fn clean_maybe_renamed_item<'tcx>(\n         if let Some(import_id) = import_id &&\n             let Some(hir::Node::Item(use_node)) = cx.tcx.hir().find_by_def_id(import_id)\n         {\n-            // First, we add the attributes from the current import.\n-            extra_attrs.extend_from_slice(inline::load_attrs(cx, import_id.to_def_id()));\n-            let is_inline = extra_attrs.lists(sym::doc).get_word_attr(sym::inline).is_some();\n+            let is_inline = inline::load_attrs(cx, import_id.to_def_id()).lists(sym::doc).get_word_attr(sym::inline).is_some();\n             // Then we get all the various imports' attributes.\n             get_all_import_attributes(use_node, cx.tcx, item.owner_id.def_id, &mut extra_attrs, is_inline);\n             add_without_unwanted_attributes(&mut extra_attrs, inline::load_attrs(cx, def_id), is_inline);"}, {"sha": "528a8e5a90f268a828fae097e5767896b50ed7f8", "filename": "tests/mir-opt/casts.redundant.InstCombine.diff", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3b4d6e080404560f63599deeb328dfa27fe081a6/tests%2Fmir-opt%2Fcasts.redundant.InstCombine.diff", "raw_url": "https://github.com/rust-lang/rust/raw/3b4d6e080404560f63599deeb328dfa27fe081a6/tests%2Fmir-opt%2Fcasts.redundant.InstCombine.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fcasts.redundant.InstCombine.diff?ref=3b4d6e080404560f63599deeb328dfa27fe081a6", "patch": "@@ -0,0 +1,25 @@\n+- // MIR for `redundant` before InstCombine\n++ // MIR for `redundant` after InstCombine\n+  \n+  fn redundant(_1: *const &u8) -> *const &u8 {\n+      debug x => _1;                       // in scope 0 at $DIR/casts.rs:+0:30: +0:31\n+      let mut _0: *const &u8;              // return place in scope 0 at $DIR/casts.rs:+0:51: +0:64\n+      let mut _2: *const &u8;              // in scope 0 at $DIR/casts.rs:+1:5: +1:55\n+      let mut _3: *const &u8;              // in scope 0 at $DIR/casts.rs:+1:36: +1:37\n+      scope 1 (inlined generic_cast::<&u8, &u8>) { // at $DIR/casts.rs:6:5: 6:38\n+          debug x => _3;                   // in scope 1 at $DIR/casts.rs:10:23: 10:24\n+      }\n+  \n+      bb0: {\n+          StorageLive(_2);                 // scope 0 at $DIR/casts.rs:+1:5: +1:55\n+          StorageLive(_3);                 // scope 0 at $DIR/casts.rs:+1:36: +1:37\n+          _3 = _1;                         // scope 0 at $DIR/casts.rs:+1:36: +1:37\n+-         _2 = _3 as *const &u8 (PtrToPtr); // scope 1 at $DIR/casts.rs:11:5: 11:18\n++         _2 = _3;                         // scope 1 at $DIR/casts.rs:11:5: 11:18\n+          StorageDead(_3);                 // scope 0 at $DIR/casts.rs:+1:37: +1:38\n+          _0 = _2;                         // scope 0 at $DIR/casts.rs:+1:5: +1:55\n+          StorageDead(_2);                 // scope 0 at $DIR/casts.rs:+2:1: +2:2\n+          return;                          // scope 0 at $DIR/casts.rs:+2:2: +2:2\n+      }\n+  }\n+  "}, {"sha": "21a470ea30075fb4a95b710f34cb2d9a777a47b2", "filename": "tests/mir-opt/casts.redundant.PreCodegen.after.mir", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3b4d6e080404560f63599deeb328dfa27fe081a6/tests%2Fmir-opt%2Fcasts.redundant.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/3b4d6e080404560f63599deeb328dfa27fe081a6/tests%2Fmir-opt%2Fcasts.redundant.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fcasts.redundant.PreCodegen.after.mir?ref=3b4d6e080404560f63599deeb328dfa27fe081a6", "patch": "@@ -0,0 +1,14 @@\n+// MIR for `redundant` after PreCodegen\n+\n+fn redundant(_1: *const &u8) -> *const &u8 {\n+    debug x => _1;                       // in scope 0 at $DIR/casts.rs:+0:30: +0:31\n+    let mut _0: *const &u8;              // return place in scope 0 at $DIR/casts.rs:+0:51: +0:64\n+    scope 1 (inlined generic_cast::<&u8, &u8>) { // at $DIR/casts.rs:6:5: 6:38\n+        debug x => _1;                   // in scope 1 at $DIR/casts.rs:10:23: 10:24\n+    }\n+\n+    bb0: {\n+        _0 = _1;                         // scope 0 at $DIR/casts.rs:+1:5: +1:55\n+        return;                          // scope 0 at $DIR/casts.rs:+2:2: +2:2\n+    }\n+}"}, {"sha": "0c793984ceb6ce347cee838b90de1108c7db1d45", "filename": "tests/mir-opt/casts.roundtrip.PreCodegen.after.mir", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3b4d6e080404560f63599deeb328dfa27fe081a6/tests%2Fmir-opt%2Fcasts.roundtrip.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/3b4d6e080404560f63599deeb328dfa27fe081a6/tests%2Fmir-opt%2Fcasts.roundtrip.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fcasts.roundtrip.PreCodegen.after.mir?ref=3b4d6e080404560f63599deeb328dfa27fe081a6", "patch": "@@ -0,0 +1,15 @@\n+// MIR for `roundtrip` after PreCodegen\n+\n+fn roundtrip(_1: *const u8) -> *const u8 {\n+    debug x => _1;                       // in scope 0 at $DIR/casts.rs:+0:18: +0:19\n+    let mut _0: *const u8;               // return place in scope 0 at $DIR/casts.rs:+0:35: +0:44\n+    let mut _2: *mut u8;                 // in scope 0 at $DIR/casts.rs:+1:5: +1:17\n+\n+    bb0: {\n+        StorageLive(_2);                 // scope 0 at $DIR/casts.rs:+1:5: +1:17\n+        _2 = _1 as *mut u8 (PtrToPtr);   // scope 0 at $DIR/casts.rs:+1:5: +1:17\n+        _0 = move _2 as *const u8 (Pointer(MutToConstPointer)); // scope 0 at $DIR/casts.rs:+1:5: +1:17\n+        StorageDead(_2);                 // scope 0 at $DIR/casts.rs:+1:16: +1:17\n+        return;                          // scope 0 at $DIR/casts.rs:+2:2: +2:2\n+    }\n+}"}, {"sha": "259c462da3d42810db41de52e535d00b9f3ba112", "filename": "tests/mir-opt/casts.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3b4d6e080404560f63599deeb328dfa27fe081a6/tests%2Fmir-opt%2Fcasts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4d6e080404560f63599deeb328dfa27fe081a6/tests%2Fmir-opt%2Fcasts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fcasts.rs?ref=3b4d6e080404560f63599deeb328dfa27fe081a6", "patch": "@@ -0,0 +1,17 @@\n+#![crate_type = \"lib\"]\n+\n+// EMIT_MIR casts.redundant.InstCombine.diff\n+// EMIT_MIR casts.redundant.PreCodegen.after.mir\n+pub fn redundant<'a, 'b: 'a>(x: *const &'a u8) -> *const &'a u8 {\n+    generic_cast::<&'a u8, &'b u8>(x) as *const &'a u8\n+}\n+\n+#[inline]\n+fn generic_cast<T, U>(x: *const T) -> *const U {\n+    x as *const U\n+}\n+\n+// EMIT_MIR casts.roundtrip.PreCodegen.after.mir\n+pub fn roundtrip(x: *const u8) -> *const u8 {\n+    x as *mut u8 as *const u8\n+}"}, {"sha": "8e1b6ba88a692a912c3ce474642d32c9cf31bcef", "filename": "tests/rustdoc/issue-108281.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3b4d6e080404560f63599deeb328dfa27fe081a6/tests%2Frustdoc%2Fissue-108281.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4d6e080404560f63599deeb328dfa27fe081a6/tests%2Frustdoc%2Fissue-108281.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fissue-108281.rs?ref=3b4d6e080404560f63599deeb328dfa27fe081a6", "patch": "@@ -0,0 +1,25 @@\n+// Regression test for <https://github.com/rust-lang/rust/issues/108281>.\n+// It ensures that the attributes on the first reexport are not duplicated.\n+\n+#![crate_name = \"foo\"]\n+\n+// @has 'foo/index.html'\n+\n+#[doc(hidden)]\n+pub fn bar() {}\n+mod sub {\n+    pub fn public() {}\n+}\n+\n+// @matches - '//*[@class=\"desc docblock-short\"]' '^Displayed$'\n+/// Displayed\n+#[doc(inline)]\n+pub use crate::bar as Bar;\n+// @matches - '//*[@class=\"desc docblock-short\"]' '^Hello\\sDisplayed$'\n+#[doc(inline)]\n+/// Hello\n+pub use crate::Bar as Bar2;\n+\n+// @matches - '//*[@class=\"desc docblock-short\"]' '^Public$'\n+/// Public\n+pub use crate::sub::public as Public;"}, {"sha": "eb739b149a1030083d4727c837f0126cf473fa09", "filename": "tests/ui/alloc-error/alloc-error-handler-bad-signature-3.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3b4d6e080404560f63599deeb328dfa27fe081a6/tests%2Fui%2Falloc-error%2Falloc-error-handler-bad-signature-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3b4d6e080404560f63599deeb328dfa27fe081a6/tests%2Fui%2Falloc-error%2Falloc-error-handler-bad-signature-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Falloc-error%2Falloc-error-handler-bad-signature-3.stderr?ref=3b4d6e080404560f63599deeb328dfa27fe081a6", "patch": "@@ -7,10 +7,7 @@ LL |   fn oom() -> ! {\n    |  _-^^^^^^^^^^^^\n LL | |     loop {}\n LL | | }\n-   | | -\n-   | | |\n-   | |_unexpected argument of type `core::alloc::Layout`\n-   |   help: remove the extra argument\n+   | |_- unexpected argument of type `core::alloc::Layout`\n    |\n note: function defined here\n   --> $DIR/alloc-error-handler-bad-signature-3.rs:10:4"}, {"sha": "1442062326d198d1bf5b55b1946d7cc6fc403a9a", "filename": "tests/ui/argument-suggestions/extra_arguments.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3b4d6e080404560f63599deeb328dfa27fe081a6/tests%2Fui%2Fargument-suggestions%2Fextra_arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4d6e080404560f63599deeb328dfa27fe081a6/tests%2Fui%2Fargument-suggestions%2Fextra_arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fargument-suggestions%2Fextra_arguments.rs?ref=3b4d6e080404560f63599deeb328dfa27fe081a6", "patch": "@@ -3,8 +3,15 @@ fn one_arg(_a: i32) {}\n fn two_arg_same(_a: i32, _b: i32) {}\n fn two_arg_diff(_a: i32, _b: &str) {}\n \n+macro_rules! foo {\n+    ($x:expr) => {\n+        empty($x, 1); //~ ERROR function takes\n+    }\n+}\n+\n fn main() {\n   empty(\"\"); //~ ERROR function takes\n+  empty(1, 1); //~ ERROR function takes\n \n   one_arg(1, 1); //~ ERROR function takes\n   one_arg(1, \"\"); //~ ERROR function takes\n@@ -32,4 +39,5 @@ fn main() {\n     1,\n     \"\"\n   );\n+  foo!(1);\n }"}, {"sha": "11c710997435585e0f727d3165797a04a5580965", "filename": "tests/ui/argument-suggestions/extra_arguments.stderr", "status": "modified", "additions": 54, "deletions": 15, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/3b4d6e080404560f63599deeb328dfa27fe081a6/tests%2Fui%2Fargument-suggestions%2Fextra_arguments.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3b4d6e080404560f63599deeb328dfa27fe081a6/tests%2Fui%2Fargument-suggestions%2Fextra_arguments.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fargument-suggestions%2Fextra_arguments.stderr?ref=3b4d6e080404560f63599deeb328dfa27fe081a6", "patch": "@@ -1,5 +1,5 @@\n error[E0061]: this function takes 0 arguments but 1 argument was supplied\n-  --> $DIR/extra_arguments.rs:7:3\n+  --> $DIR/extra_arguments.rs:13:3\n    |\n LL |   empty(\"\");\n    |   ^^^^^ --\n@@ -13,8 +13,27 @@ note: function defined here\n LL | fn empty() {}\n    |    ^^^^^\n \n+error[E0061]: this function takes 0 arguments but 2 arguments were supplied\n+  --> $DIR/extra_arguments.rs:14:3\n+   |\n+LL |   empty(1, 1);\n+   |   ^^^^^ -  - unexpected argument of type `{integer}`\n+   |         |\n+   |         unexpected argument of type `{integer}`\n+   |\n+note: function defined here\n+  --> $DIR/extra_arguments.rs:1:4\n+   |\n+LL | fn empty() {}\n+   |    ^^^^^\n+help: remove the extra arguments\n+   |\n+LL -   empty(1, 1);\n+LL +   empty();\n+   |\n+\n error[E0061]: this function takes 1 argument but 2 arguments were supplied\n-  --> $DIR/extra_arguments.rs:9:3\n+  --> $DIR/extra_arguments.rs:16:3\n    |\n LL |   one_arg(1, 1);\n    |   ^^^^^^^  ---\n@@ -29,7 +48,7 @@ LL | fn one_arg(_a: i32) {}\n    |    ^^^^^^^ -------\n \n error[E0061]: this function takes 1 argument but 2 arguments were supplied\n-  --> $DIR/extra_arguments.rs:10:3\n+  --> $DIR/extra_arguments.rs:17:3\n    |\n LL |   one_arg(1, \"\");\n    |   ^^^^^^^  ----\n@@ -44,7 +63,7 @@ LL | fn one_arg(_a: i32) {}\n    |    ^^^^^^^ -------\n \n error[E0061]: this function takes 1 argument but 3 arguments were supplied\n-  --> $DIR/extra_arguments.rs:11:3\n+  --> $DIR/extra_arguments.rs:18:3\n    |\n LL |   one_arg(1, \"\", 1.0);\n    |   ^^^^^^^    --  --- unexpected argument of type `{float}`\n@@ -63,7 +82,7 @@ LL +   one_arg(1);\n    |\n \n error[E0061]: this function takes 2 arguments but 3 arguments were supplied\n-  --> $DIR/extra_arguments.rs:13:3\n+  --> $DIR/extra_arguments.rs:20:3\n    |\n LL |   two_arg_same(1, 1, 1);\n    |   ^^^^^^^^^^^^     ---\n@@ -78,7 +97,7 @@ LL | fn two_arg_same(_a: i32, _b: i32) {}\n    |    ^^^^^^^^^^^^ -------  -------\n \n error[E0061]: this function takes 2 arguments but 3 arguments were supplied\n-  --> $DIR/extra_arguments.rs:14:3\n+  --> $DIR/extra_arguments.rs:21:3\n    |\n LL |   two_arg_same(1, 1, 1.0);\n    |   ^^^^^^^^^^^^     -----\n@@ -93,7 +112,7 @@ LL | fn two_arg_same(_a: i32, _b: i32) {}\n    |    ^^^^^^^^^^^^ -------  -------\n \n error[E0061]: this function takes 2 arguments but 3 arguments were supplied\n-  --> $DIR/extra_arguments.rs:16:3\n+  --> $DIR/extra_arguments.rs:23:3\n    |\n LL |   two_arg_diff(1, 1, \"\");\n    |   ^^^^^^^^^^^^  ---\n@@ -108,7 +127,7 @@ LL | fn two_arg_diff(_a: i32, _b: &str) {}\n    |    ^^^^^^^^^^^^ -------  --------\n \n error[E0061]: this function takes 2 arguments but 3 arguments were supplied\n-  --> $DIR/extra_arguments.rs:17:3\n+  --> $DIR/extra_arguments.rs:24:3\n    |\n LL |   two_arg_diff(1, \"\", \"\");\n    |   ^^^^^^^^^^^^      ----\n@@ -123,7 +142,7 @@ LL | fn two_arg_diff(_a: i32, _b: &str) {}\n    |    ^^^^^^^^^^^^ -------  --------\n \n error[E0061]: this function takes 2 arguments but 4 arguments were supplied\n-  --> $DIR/extra_arguments.rs:18:3\n+  --> $DIR/extra_arguments.rs:25:3\n    |\n LL |   two_arg_diff(1, 1, \"\", \"\");\n    |   ^^^^^^^^^^^^    -      -- unexpected argument of type `&'static str`\n@@ -142,7 +161,7 @@ LL +   two_arg_diff(1, \"\");\n    |\n \n error[E0061]: this function takes 2 arguments but 4 arguments were supplied\n-  --> $DIR/extra_arguments.rs:19:3\n+  --> $DIR/extra_arguments.rs:26:3\n    |\n LL |   two_arg_diff(1, \"\", 1, \"\");\n    |   ^^^^^^^^^^^^        -  -- unexpected argument of type `&'static str`\n@@ -161,7 +180,7 @@ LL +   two_arg_diff(1, \"\");\n    |\n \n error[E0061]: this function takes 2 arguments but 3 arguments were supplied\n-  --> $DIR/extra_arguments.rs:22:3\n+  --> $DIR/extra_arguments.rs:29:3\n    |\n LL |   two_arg_same(1, 1,     \"\");\n    |   ^^^^^^^^^^^^     --------\n@@ -176,7 +195,7 @@ LL | fn two_arg_same(_a: i32, _b: i32) {}\n    |    ^^^^^^^^^^^^ -------  -------\n \n error[E0061]: this function takes 2 arguments but 3 arguments were supplied\n-  --> $DIR/extra_arguments.rs:23:3\n+  --> $DIR/extra_arguments.rs:30:3\n    |\n LL |   two_arg_diff(1, 1,     \"\");\n    |   ^^^^^^^^^^^^  ---\n@@ -191,7 +210,7 @@ LL | fn two_arg_diff(_a: i32, _b: &str) {}\n    |    ^^^^^^^^^^^^ -------  --------\n \n error[E0061]: this function takes 2 arguments but 3 arguments were supplied\n-  --> $DIR/extra_arguments.rs:24:3\n+  --> $DIR/extra_arguments.rs:31:3\n    |\n LL |     two_arg_same(\n    |     ^^^^^^^^^^^^\n@@ -211,7 +230,7 @@ LL | fn two_arg_same(_a: i32, _b: i32) {}\n    |    ^^^^^^^^^^^^ -------  -------\n \n error[E0061]: this function takes 2 arguments but 3 arguments were supplied\n-  --> $DIR/extra_arguments.rs:30:3\n+  --> $DIR/extra_arguments.rs:37:3\n    |\n LL |     two_arg_diff(\n    |     ^^^^^^^^^^^^\n@@ -229,6 +248,26 @@ note: function defined here\n LL | fn two_arg_diff(_a: i32, _b: &str) {}\n    |    ^^^^^^^^^^^^ -------  --------\n \n-error: aborting due to 14 previous errors\n+error[E0061]: this function takes 0 arguments but 2 arguments were supplied\n+  --> $DIR/extra_arguments.rs:8:9\n+   |\n+LL |         empty($x, 1);\n+   |         ^^^^^     - unexpected argument of type `{integer}`\n+...\n+LL |   foo!(1);\n+   |   -------\n+   |   |    |\n+   |   |    unexpected argument of type `{integer}`\n+   |   |    help: remove the extra argument\n+   |   in this macro invocation\n+   |\n+note: function defined here\n+  --> $DIR/extra_arguments.rs:1:4\n+   |\n+LL | fn empty() {}\n+   |    ^^^^^\n+   = note: this error originates in the macro `foo` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 16 previous errors\n \n For more information about this error, try `rustc --explain E0061`."}, {"sha": "83655341d6a243756412fcf1a2369eaf324f5e94", "filename": "tests/ui/generic-associated-types/method-unsatisfied-assoc-type-predicate.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/3b4d6e080404560f63599deeb328dfa27fe081a6/tests%2Fui%2Fgeneric-associated-types%2Fmethod-unsatisfied-assoc-type-predicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4d6e080404560f63599deeb328dfa27fe081a6/tests%2Fui%2Fgeneric-associated-types%2Fmethod-unsatisfied-assoc-type-predicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fgeneric-associated-types%2Fmethod-unsatisfied-assoc-type-predicate.rs?ref=3b4d6e080404560f63599deeb328dfa27fe081a6", "previous_filename": "tests/ui/generic-associated-types/method-unsatified-assoc-type-predicate.rs"}, {"sha": "4246f8c069d4b6dee432a94d5bfab3bf67bb5657", "filename": "tests/ui/generic-associated-types/method-unsatisfied-assoc-type-predicate.stderr", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b4d6e080404560f63599deeb328dfa27fe081a6/tests%2Fui%2Fgeneric-associated-types%2Fmethod-unsatisfied-assoc-type-predicate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3b4d6e080404560f63599deeb328dfa27fe081a6/tests%2Fui%2Fgeneric-associated-types%2Fmethod-unsatisfied-assoc-type-predicate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fgeneric-associated-types%2Fmethod-unsatisfied-assoc-type-predicate.stderr?ref=3b4d6e080404560f63599deeb328dfa27fe081a6", "patch": "@@ -1,5 +1,5 @@\n error[E0599]: the method `f` exists for struct `S`, but its trait bounds were not satisfied\n-  --> $DIR/method-unsatified-assoc-type-predicate.rs:28:7\n+  --> $DIR/method-unsatisfied-assoc-type-predicate.rs:28:7\n    |\n LL | struct S;\n    | --------\n@@ -12,7 +12,7 @@ LL |     a.f();\n    |       ^ method cannot be called on `S` due to unsatisfied trait bounds\n    |\n note: trait bound `<S as X>::Y<i32> = i32` was not satisfied\n-  --> $DIR/method-unsatified-assoc-type-predicate.rs:12:11\n+  --> $DIR/method-unsatisfied-assoc-type-predicate.rs:12:11\n    |\n LL | impl<T: X<Y<i32> = i32>> M for T {}\n    |           ^^^^^^^^^^^^   -     -", "previous_filename": "tests/ui/generic-associated-types/method-unsatified-assoc-type-predicate.stderr"}, {"sha": "060ee8821d8da946560087a760625e1d98484f5d", "filename": "tests/ui/generic-associated-types/unsatisfied-item-lifetime-bound.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b4d6e080404560f63599deeb328dfa27fe081a6/tests%2Fui%2Fgeneric-associated-types%2Funsatisfied-item-lifetime-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4d6e080404560f63599deeb328dfa27fe081a6/tests%2Fui%2Fgeneric-associated-types%2Funsatisfied-item-lifetime-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fgeneric-associated-types%2Funsatisfied-item-lifetime-bound.rs?ref=3b4d6e080404560f63599deeb328dfa27fe081a6", "patch": "@@ -1,3 +1,5 @@\n+#![warn(unused_lifetimes)]\n+\n pub trait X {\n     type Y<'a: 'static>;\n     //~^ WARNING unnecessary lifetime parameter", "previous_filename": "tests/ui/generic-associated-types/unsatified-item-lifetime-bound.rs"}, {"sha": "a69cd0028c1f1cf0721160079d53909c8514d7c9", "filename": "tests/ui/generic-associated-types/unsatisfied-item-lifetime-bound.stderr", "status": "renamed", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3b4d6e080404560f63599deeb328dfa27fe081a6/tests%2Fui%2Fgeneric-associated-types%2Funsatisfied-item-lifetime-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3b4d6e080404560f63599deeb328dfa27fe081a6/tests%2Fui%2Fgeneric-associated-types%2Funsatisfied-item-lifetime-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fgeneric-associated-types%2Funsatisfied-item-lifetime-bound.stderr?ref=3b4d6e080404560f63599deeb328dfa27fe081a6", "patch": "@@ -1,45 +1,50 @@\n warning: unnecessary lifetime parameter `'a`\n-  --> $DIR/unsatified-item-lifetime-bound.rs:2:12\n+  --> $DIR/unsatisfied-item-lifetime-bound.rs:4:12\n    |\n LL |     type Y<'a: 'static>;\n    |            ^^\n    |\n    = help: you can use the `'static` lifetime directly, in place of `'a`\n+note: the lint level is defined here\n+  --> $DIR/unsatisfied-item-lifetime-bound.rs:1:9\n+   |\n+LL | #![warn(unused_lifetimes)]\n+   |         ^^^^^^^^^^^^^^^^\n \n error[E0478]: lifetime bound not satisfied\n-  --> $DIR/unsatified-item-lifetime-bound.rs:11:8\n+  --> $DIR/unsatisfied-item-lifetime-bound.rs:13:8\n    |\n LL |     f: <T as X>::Y<'a>,\n    |        ^^^^^^^^^^^^^^^\n    |\n note: lifetime parameter instantiated with the lifetime `'a` as defined here\n-  --> $DIR/unsatified-item-lifetime-bound.rs:10:10\n+  --> $DIR/unsatisfied-item-lifetime-bound.rs:12:10\n    |\n LL | struct B<'a, T: for<'r> X<Y<'r> = &'r ()>> {\n    |          ^^\n    = note: but lifetime parameter must outlive the static lifetime\n \n error[E0478]: lifetime bound not satisfied\n-  --> $DIR/unsatified-item-lifetime-bound.rs:16:8\n+  --> $DIR/unsatisfied-item-lifetime-bound.rs:18:8\n    |\n LL |     f: <T as X>::Y<'a>,\n    |        ^^^^^^^^^^^^^^^\n    |\n note: lifetime parameter instantiated with the lifetime `'a` as defined here\n-  --> $DIR/unsatified-item-lifetime-bound.rs:15:10\n+  --> $DIR/unsatisfied-item-lifetime-bound.rs:17:10\n    |\n LL | struct C<'a, T: X> {\n    |          ^^\n    = note: but lifetime parameter must outlive the static lifetime\n \n error[E0478]: lifetime bound not satisfied\n-  --> $DIR/unsatified-item-lifetime-bound.rs:21:8\n+  --> $DIR/unsatisfied-item-lifetime-bound.rs:23:8\n    |\n LL |     f: <() as X>::Y<'a>,\n    |        ^^^^^^^^^^^^^^^^\n    |\n note: lifetime parameter instantiated with the lifetime `'a` as defined here\n-  --> $DIR/unsatified-item-lifetime-bound.rs:20:10\n+  --> $DIR/unsatisfied-item-lifetime-bound.rs:22:10\n    |\n LL | struct D<'a> {\n    |          ^^", "previous_filename": "tests/ui/generic-associated-types/unsatified-item-lifetime-bound.stderr"}, {"sha": "a6dbf3f08f2a88b80ef743712b91572d23699841", "filename": "tests/ui/impl-trait/equal-hidden-lifetimes.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3b4d6e080404560f63599deeb328dfa27fe081a6/tests%2Fui%2Fimpl-trait%2Fequal-hidden-lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4d6e080404560f63599deeb328dfa27fe081a6/tests%2Fui%2Fimpl-trait%2Fequal-hidden-lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fequal-hidden-lifetimes.rs?ref=3b4d6e080404560f63599deeb328dfa27fe081a6", "patch": "@@ -5,7 +5,6 @@\n \n // `'a == 'static` so `&'a i32` is fine as the return type\n fn equal_regions_static<'a: 'static>(x: &'a i32) -> impl Sized {\n-    //~^ WARNING unnecessary lifetime parameter `'a`\n     x\n }\n "}, {"sha": "3e48aef553b16c8f9b987ebcd00fd23f95a56611", "filename": "tests/ui/impl-trait/equal-hidden-lifetimes.stderr", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bd4a96a12d0bf6dc12edf20a45df3a33052c9d7d/tests%2Fui%2Fimpl-trait%2Fequal-hidden-lifetimes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bd4a96a12d0bf6dc12edf20a45df3a33052c9d7d/tests%2Fui%2Fimpl-trait%2Fequal-hidden-lifetimes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fequal-hidden-lifetimes.stderr?ref=bd4a96a12d0bf6dc12edf20a45df3a33052c9d7d", "patch": "@@ -1,10 +0,0 @@\n-warning: unnecessary lifetime parameter `'a`\n-  --> $DIR/equal-hidden-lifetimes.rs:7:25\n-   |\n-LL | fn equal_regions_static<'a: 'static>(x: &'a i32) -> impl Sized {\n-   |                         ^^\n-   |\n-   = help: you can use the `'static` lifetime directly, in place of `'a`\n-\n-warning: 1 warning emitted\n-"}, {"sha": "59add7eb18bdb92355f27278a6d76ec6cf0e4ce2", "filename": "tests/ui/infinite/auxiliary/alias.rs", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b4d6e080404560f63599deeb328dfa27fe081a6/tests%2Fui%2Finfinite%2Fauxiliary%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4d6e080404560f63599deeb328dfa27fe081a6/tests%2Fui%2Finfinite%2Fauxiliary%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finfinite%2Fauxiliary%2Falias.rs?ref=3b4d6e080404560f63599deeb328dfa27fe081a6", "patch": "@@ -0,0 +1,2 @@\n+pub struct W<T>(T);\n+pub type Wrapper<T> = W<T>;"}, {"sha": "45356f359ceded3a0916be4376dbdbb930bfe7e3", "filename": "tests/ui/infinite/infinite-alias.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3b4d6e080404560f63599deeb328dfa27fe081a6/tests%2Fui%2Finfinite%2Finfinite-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4d6e080404560f63599deeb328dfa27fe081a6/tests%2Fui%2Finfinite%2Finfinite-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finfinite%2Finfinite-alias.rs?ref=3b4d6e080404560f63599deeb328dfa27fe081a6", "patch": "@@ -0,0 +1,9 @@\n+// aux-build: alias.rs\n+// regression test for 108160\n+\n+extern crate alias;\n+\n+use alias::Wrapper;\n+struct Rec(Wrapper<Rec>); //~ ERROR recursive type `Rec` has infinite\n+\n+fn main() {}"}, {"sha": "9d9265f8c367c44ae82d239fac544fac6fdc3e28", "filename": "tests/ui/infinite/infinite-alias.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3b4d6e080404560f63599deeb328dfa27fe081a6/tests%2Fui%2Finfinite%2Finfinite-alias.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3b4d6e080404560f63599deeb328dfa27fe081a6/tests%2Fui%2Finfinite%2Finfinite-alias.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finfinite%2Finfinite-alias.stderr?ref=3b4d6e080404560f63599deeb328dfa27fe081a6", "patch": "@@ -0,0 +1,14 @@\n+error[E0072]: recursive type `Rec` has infinite size\n+  --> $DIR/infinite-alias.rs:7:1\n+   |\n+LL | struct Rec(Wrapper<Rec>);\n+   | ^^^^^^^^^^ ------------ recursive without indirection\n+   |\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle\n+   |\n+LL | struct Rec(Box<Wrapper<Rec>>);\n+   |            ++++            +\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0072`."}, {"sha": "2742529edd3b317b9fd8a11ac44c64ba9f8f100d", "filename": "tests/ui/issues/issue-26094.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3b4d6e080404560f63599deeb328dfa27fe081a6/tests%2Fui%2Fissues%2Fissue-26094.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4d6e080404560f63599deeb328dfa27fe081a6/tests%2Fui%2Fissues%2Fissue-26094.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-26094.rs?ref=3b4d6e080404560f63599deeb328dfa27fe081a6", "patch": "@@ -1,13 +1,12 @@\n macro_rules! some_macro {\n-    ($other: expr) => ({\n+    ($other: expr) => {{\n         $other(None) //~ NOTE unexpected argument of type `Option<_>`\n-    })\n+    }};\n }\n \n fn some_function() {} //~ NOTE defined here\n \n fn main() {\n     some_macro!(some_function);\n     //~^ ERROR function takes 0 arguments but 1 argument was supplied\n-    //~| NOTE in this expansion of some_macro!\n }"}, {"sha": "ecdf48470f730294ca540081896c5433781e0f29", "filename": "tests/ui/issues/issue-26094.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3b4d6e080404560f63599deeb328dfa27fe081a6/tests%2Fui%2Fissues%2Fissue-26094.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3b4d6e080404560f63599deeb328dfa27fe081a6/tests%2Fui%2Fissues%2Fissue-26094.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-26094.stderr?ref=3b4d6e080404560f63599deeb328dfa27fe081a6", "patch": "@@ -2,10 +2,7 @@ error[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> $DIR/issue-26094.rs:10:17\n    |\n LL |         $other(None)\n-   |                ----\n-   |                |\n-   |                unexpected argument of type `Option<_>`\n-   |                help: remove the extra argument\n+   |                ---- unexpected argument of type `Option<_>`\n ...\n LL |     some_macro!(some_function);\n    |                 ^^^^^^^^^^^^^"}, {"sha": "813c1d3e2cccd9410c86a683bb6ec0b53533adbc", "filename": "tests/ui/issues/issue-30438-c.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3b4d6e080404560f63599deeb328dfa27fe081a6/tests%2Fui%2Fissues%2Fissue-30438-c.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4d6e080404560f63599deeb328dfa27fe081a6/tests%2Fui%2Fissues%2Fissue-30438-c.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-30438-c.rs?ref=3b4d6e080404560f63599deeb328dfa27fe081a6", "patch": "@@ -5,7 +5,6 @@ trait Trait { type Out; }\n struct Test<'a> { s: &'a str }\n \n fn silly<'y, 'z>(_s: &'y Test<'z>) -> &'y <Test<'z> as Trait>::Out where 'z: 'static {\n-    //~^ WARN unnecessary lifetime parameter `'z`\n     let x = Test { s: \"this cannot last\" };\n     &x\n     //~^ ERROR: cannot return reference to local variable `x`"}, {"sha": "7c001088097ab54618608442b4772da575b36b7e", "filename": "tests/ui/issues/issue-30438-c.stderr", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3b4d6e080404560f63599deeb328dfa27fe081a6/tests%2Fui%2Fissues%2Fissue-30438-c.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3b4d6e080404560f63599deeb328dfa27fe081a6/tests%2Fui%2Fissues%2Fissue-30438-c.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-30438-c.stderr?ref=3b4d6e080404560f63599deeb328dfa27fe081a6", "patch": "@@ -1,17 +1,9 @@\n-warning: unnecessary lifetime parameter `'z`\n-  --> $DIR/issue-30438-c.rs:7:74\n-   |\n-LL | fn silly<'y, 'z>(_s: &'y Test<'z>) -> &'y <Test<'z> as Trait>::Out where 'z: 'static {\n-   |                                                                          ^^\n-   |\n-   = help: you can use the `'static` lifetime directly, in place of `'z`\n-\n error[E0515]: cannot return reference to local variable `x`\n-  --> $DIR/issue-30438-c.rs:10:5\n+  --> $DIR/issue-30438-c.rs:9:5\n    |\n LL |     &x\n    |     ^^ returns a reference to data owned by the current function\n \n-error: aborting due to previous error; 1 warning emitted\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0515`."}, {"sha": "46462c432a8c76f437e68c49e5a4fa311d090f5b", "filename": "tests/ui/regions/regions-free-region-outlives-static-outlives-free-region.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b4d6e080404560f63599deeb328dfa27fe081a6/tests%2Fui%2Fregions%2Fregions-free-region-outlives-static-outlives-free-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4d6e080404560f63599deeb328dfa27fe081a6/tests%2Fui%2Fregions%2Fregions-free-region-outlives-static-outlives-free-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fregions%2Fregions-free-region-outlives-static-outlives-free-region.rs?ref=3b4d6e080404560f63599deeb328dfa27fe081a6", "patch": "@@ -8,6 +8,8 @@\n //\n //     'a : 'b\n \n+#![warn(unused_lifetimes)]\n+\n fn test<'a,'b>(x: &'a i32) -> &'b i32\n     where 'a: 'static //~ WARN unnecessary lifetime parameter `'a`\n {"}, {"sha": "9f03a6553ba83e05c7ca67630bfb61b8d7f0fa52", "filename": "tests/ui/regions/regions-free-region-outlives-static-outlives-free-region.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3b4d6e080404560f63599deeb328dfa27fe081a6/tests%2Fui%2Fregions%2Fregions-free-region-outlives-static-outlives-free-region.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3b4d6e080404560f63599deeb328dfa27fe081a6/tests%2Fui%2Fregions%2Fregions-free-region-outlives-static-outlives-free-region.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fregions%2Fregions-free-region-outlives-static-outlives-free-region.stderr?ref=3b4d6e080404560f63599deeb328dfa27fe081a6", "patch": "@@ -1,10 +1,15 @@\n warning: unnecessary lifetime parameter `'a`\n-  --> $DIR/regions-free-region-outlives-static-outlives-free-region.rs:12:11\n+  --> $DIR/regions-free-region-outlives-static-outlives-free-region.rs:14:11\n    |\n LL |     where 'a: 'static\n    |           ^^\n    |\n    = help: you can use the `'static` lifetime directly, in place of `'a`\n+note: the lint level is defined here\n+  --> $DIR/regions-free-region-outlives-static-outlives-free-region.rs:11:9\n+   |\n+LL | #![warn(unused_lifetimes)]\n+   |         ^^^^^^^^^^^^^^^^\n \n warning: 1 warning emitted\n "}, {"sha": "e2ebb394d0ad2098ee72e70f31805b17436250d6", "filename": "tests/ui/regions/regions-static-bound-rpass.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b4d6e080404560f63599deeb328dfa27fe081a6/tests%2Fui%2Fregions%2Fregions-static-bound-rpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4d6e080404560f63599deeb328dfa27fe081a6/tests%2Fui%2Fregions%2Fregions-static-bound-rpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fregions%2Fregions-static-bound-rpass.rs?ref=3b4d6e080404560f63599deeb328dfa27fe081a6", "patch": "@@ -1,5 +1,7 @@\n // run-pass\n \n+#![warn(unused_lifetimes)]\n+\n fn invariant_id<'a,'b>(t: &'b mut &'static ()) -> &'b mut &'a ()\n     where 'a: 'static { t }\n //~^ WARN unnecessary lifetime parameter `'a`"}, {"sha": "f0f3a4c5261aac2b8e0817029ff9bbfc2177d151", "filename": "tests/ui/regions/regions-static-bound-rpass.stderr", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3b4d6e080404560f63599deeb328dfa27fe081a6/tests%2Fui%2Fregions%2Fregions-static-bound-rpass.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3b4d6e080404560f63599deeb328dfa27fe081a6/tests%2Fui%2Fregions%2Fregions-static-bound-rpass.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fregions%2Fregions-static-bound-rpass.stderr?ref=3b4d6e080404560f63599deeb328dfa27fe081a6", "patch": "@@ -1,21 +1,26 @@\n warning: unnecessary lifetime parameter `'a`\n-  --> $DIR/regions-static-bound-rpass.rs:4:11\n+  --> $DIR/regions-static-bound-rpass.rs:6:11\n    |\n LL |     where 'a: 'static { t }\n    |           ^^\n    |\n    = help: you can use the `'static` lifetime directly, in place of `'a`\n+note: the lint level is defined here\n+  --> $DIR/regions-static-bound-rpass.rs:3:9\n+   |\n+LL | #![warn(unused_lifetimes)]\n+   |         ^^^^^^^^^^^^^^^^\n \n warning: unnecessary lifetime parameter `'a`\n-  --> $DIR/regions-static-bound-rpass.rs:8:11\n+  --> $DIR/regions-static-bound-rpass.rs:10:11\n    |\n LL |     where 'a: 'static { t }\n    |           ^^\n    |\n    = help: you can use the `'static` lifetime directly, in place of `'a`\n \n warning: unnecessary lifetime parameter `'b`\n-  --> $DIR/regions-static-bound-rpass.rs:12:19\n+  --> $DIR/regions-static-bound-rpass.rs:14:19\n    |\n LL |     where 'a: 'b, 'b: 'static { t }\n    |                   ^^"}, {"sha": "e7aa8795f01a6aeed8894c91771c630dbc642f70", "filename": "tests/ui/regions/regions-static-bound.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3b4d6e080404560f63599deeb328dfa27fe081a6/tests%2Fui%2Fregions%2Fregions-static-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4d6e080404560f63599deeb328dfa27fe081a6/tests%2Fui%2Fregions%2Fregions-static-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fregions%2Fregions-static-bound.rs?ref=3b4d6e080404560f63599deeb328dfa27fe081a6", "patch": "@@ -1,6 +1,8 @@\n-fn static_id<'a,'b>(t: &'a ()) -> &'static ()\n-    where 'a: 'static { t }\n-//~^ WARN unnecessary lifetime parameter `'a`\n+#![warn(unused_lifetimes)]\n+\n+fn static_id<'a,'b>(t: &'a ()) -> &'static () where 'a: 'static { t }\n+//~^ WARN lifetime parameter `'b` never used\n+//~| WARN unnecessary lifetime parameter `'a`\n \n fn static_id_indirect<'a,'b>(t: &'a ()) -> &'static ()\n     where 'a: 'b, 'b: 'static { t }"}, {"sha": "b314e9fe85d4e547c55923a1385a56020bbe8f91", "filename": "tests/ui/regions/regions-static-bound.stderr", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3b4d6e080404560f63599deeb328dfa27fe081a6/tests%2Fui%2Fregions%2Fregions-static-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3b4d6e080404560f63599deeb328dfa27fe081a6/tests%2Fui%2Fregions%2Fregions-static-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fregions%2Fregions-static-bound.stderr?ref=3b4d6e080404560f63599deeb328dfa27fe081a6", "patch": "@@ -1,29 +1,43 @@\n+warning: lifetime parameter `'b` never used\n+  --> $DIR/regions-static-bound.rs:3:17\n+   |\n+LL | fn static_id<'a,'b>(t: &'a ()) -> &'static () where 'a: 'static { t }\n+   |                -^^\n+   |                |\n+   |                help: elide the unused lifetime\n+   |\n+note: the lint level is defined here\n+  --> $DIR/regions-static-bound.rs:1:9\n+   |\n+LL | #![warn(unused_lifetimes)]\n+   |         ^^^^^^^^^^^^^^^^\n+\n warning: unnecessary lifetime parameter `'a`\n-  --> $DIR/regions-static-bound.rs:2:11\n+  --> $DIR/regions-static-bound.rs:3:53\n    |\n-LL |     where 'a: 'static { t }\n-   |           ^^\n+LL | fn static_id<'a,'b>(t: &'a ()) -> &'static () where 'a: 'static { t }\n+   |                                                     ^^\n    |\n    = help: you can use the `'static` lifetime directly, in place of `'a`\n \n warning: unnecessary lifetime parameter `'b`\n-  --> $DIR/regions-static-bound.rs:6:19\n+  --> $DIR/regions-static-bound.rs:8:19\n    |\n LL |     where 'a: 'b, 'b: 'static { t }\n    |                   ^^\n    |\n    = help: you can use the `'static` lifetime directly, in place of `'b`\n \n error: lifetime may not live long enough\n-  --> $DIR/regions-static-bound.rs:10:5\n+  --> $DIR/regions-static-bound.rs:12:5\n    |\n LL | fn static_id_wrong_way<'a>(t: &'a ()) -> &'static () where 'static: 'a {\n    |                        -- lifetime `'a` defined here\n LL |     t\n    |     ^ returning this value requires that `'a` must outlive `'static`\n \n error[E0521]: borrowed data escapes outside of function\n-  --> $DIR/regions-static-bound.rs:15:5\n+  --> $DIR/regions-static-bound.rs:17:5\n    |\n LL | fn error(u: &(), v: &()) {\n    |          -  - let's call the lifetime of this reference `'1`\n@@ -36,7 +50,7 @@ LL |     static_id(&u);\n    |     argument requires that `'1` must outlive `'static`\n \n error[E0521]: borrowed data escapes outside of function\n-  --> $DIR/regions-static-bound.rs:17:5\n+  --> $DIR/regions-static-bound.rs:19:5\n    |\n LL | fn error(u: &(), v: &()) {\n    |                  -  - let's call the lifetime of this reference `'2`\n@@ -49,6 +63,6 @@ LL |     static_id_indirect(&v);\n    |     `v` escapes the function body here\n    |     argument requires that `'2` must outlive `'static`\n \n-error: aborting due to 3 previous errors; 2 warnings emitted\n+error: aborting due to 3 previous errors; 3 warnings emitted\n \n For more information about this error, try `rustc --explain E0521`."}, {"sha": "847fe87b2ea378af454453f9bc421e04afc215dd", "filename": "tests/ui/static/static-lifetime-bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b4d6e080404560f63599deeb328dfa27fe081a6/tests%2Fui%2Fstatic%2Fstatic-lifetime-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4d6e080404560f63599deeb328dfa27fe081a6/tests%2Fui%2Fstatic%2Fstatic-lifetime-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstatic%2Fstatic-lifetime-bound.rs?ref=3b4d6e080404560f63599deeb328dfa27fe081a6", "patch": "@@ -1,4 +1,4 @@\n-fn f<'a: 'static>(_: &'a i32) {} //~WARN unnecessary lifetime parameter `'a`\n+fn f<'a: 'static>(_: &'a i32) {}\n \n fn main() {\n     let x = 0;"}, {"sha": "19e55a6582e86f10ea78af1149d31ba7cd5fdb3e", "filename": "tests/ui/static/static-lifetime-bound.stderr", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3b4d6e080404560f63599deeb328dfa27fe081a6/tests%2Fui%2Fstatic%2Fstatic-lifetime-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3b4d6e080404560f63599deeb328dfa27fe081a6/tests%2Fui%2Fstatic%2Fstatic-lifetime-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstatic%2Fstatic-lifetime-bound.stderr?ref=3b4d6e080404560f63599deeb328dfa27fe081a6", "patch": "@@ -1,11 +1,3 @@\n-warning: unnecessary lifetime parameter `'a`\n-  --> $DIR/static-lifetime-bound.rs:1:6\n-   |\n-LL | fn f<'a: 'static>(_: &'a i32) {}\n-   |      ^^\n-   |\n-   = help: you can use the `'static` lifetime directly, in place of `'a`\n-\n error[E0597]: `x` does not live long enough\n   --> $DIR/static-lifetime-bound.rs:5:7\n    |\n@@ -19,6 +11,6 @@ LL |     f(&x);\n LL | }\n    | - `x` dropped here while still borrowed\n \n-error: aborting due to previous error; 1 warning emitted\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0597`."}, {"sha": "7c3a3a844060634ab4391168bb5e1d5b632cb331", "filename": "tests/ui/type-alias-impl-trait/bounds-are-checked.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3b4d6e080404560f63599deeb328dfa27fe081a6/tests%2Fui%2Ftype-alias-impl-trait%2Fbounds-are-checked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4d6e080404560f63599deeb328dfa27fe081a6/tests%2Fui%2Ftype-alias-impl-trait%2Fbounds-are-checked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype-alias-impl-trait%2Fbounds-are-checked.rs?ref=3b4d6e080404560f63599deeb328dfa27fe081a6", "patch": "@@ -6,7 +6,6 @@\n type X<'a> = impl Into<&'static str> + From<&'a str>;\n \n fn f<'a: 'static>(t: &'a str) -> X<'a> {\n-    //~^ WARNING unnecessary lifetime parameter\n     t\n     //~^ ERROR expected generic lifetime parameter, found `'static`\n }"}, {"sha": "962dedde09a52d033409bc22875d0c8d017c4c00", "filename": "tests/ui/type-alias-impl-trait/bounds-are-checked.stderr", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3b4d6e080404560f63599deeb328dfa27fe081a6/tests%2Fui%2Ftype-alias-impl-trait%2Fbounds-are-checked.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3b4d6e080404560f63599deeb328dfa27fe081a6/tests%2Fui%2Ftype-alias-impl-trait%2Fbounds-are-checked.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype-alias-impl-trait%2Fbounds-are-checked.stderr?ref=3b4d6e080404560f63599deeb328dfa27fe081a6", "patch": "@@ -1,20 +1,12 @@\n-warning: unnecessary lifetime parameter `'a`\n-  --> $DIR/bounds-are-checked.rs:8:6\n-   |\n-LL | fn f<'a: 'static>(t: &'a str) -> X<'a> {\n-   |      ^^\n-   |\n-   = help: you can use the `'static` lifetime directly, in place of `'a`\n-\n error[E0792]: expected generic lifetime parameter, found `'static`\n-  --> $DIR/bounds-are-checked.rs:10:5\n+  --> $DIR/bounds-are-checked.rs:9:5\n    |\n LL | type X<'a> = impl Into<&'static str> + From<&'a str>;\n    |        -- cannot use static lifetime; use a bound lifetime instead or remove the lifetime parameter from the opaque type\n ...\n LL |     t\n    |     ^\n \n-error: aborting due to previous error; 1 warning emitted\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0792`."}, {"sha": "6f9434255a802fa576c5ad806d8ce34399ebcba1", "filename": "tests/ui/type-alias-impl-trait/implied_lifetime_wf_check3.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3b4d6e080404560f63599deeb328dfa27fe081a6/tests%2Fui%2Ftype-alias-impl-trait%2Fimplied_lifetime_wf_check3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4d6e080404560f63599deeb328dfa27fe081a6/tests%2Fui%2Ftype-alias-impl-trait%2Fimplied_lifetime_wf_check3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype-alias-impl-trait%2Fimplied_lifetime_wf_check3.rs?ref=3b4d6e080404560f63599deeb328dfa27fe081a6", "patch": "@@ -4,7 +4,6 @@ mod test_lifetime_param {\n     type Ty<'a> = impl Sized + 'a;\n     fn defining(a: &str) -> Ty<'_> { a }\n     fn assert_static<'a: 'static>() {}\n-    //~^ WARN: unnecessary lifetime parameter `'a`\n     fn test<'a>() where Ty<'a>: 'static { assert_static::<'a>() }\n     //~^ ERROR: lifetime may not live long enough\n }\n@@ -13,14 +12,12 @@ mod test_higher_kinded_lifetime_param {\n     type Ty<'a> = impl Sized + 'a;\n     fn defining(a: &str) -> Ty<'_> { a }\n     fn assert_static<'a: 'static>() {}\n-    //~^ WARN: unnecessary lifetime parameter `'a`\n     fn test<'a>() where for<'b> Ty<'b>: 'a { assert_static::<'a>() }\n     //~^ ERROR: lifetime may not live long enough\n }\n \n mod test_higher_kinded_lifetime_param2 {\n     fn assert_static<'a: 'static>() {}\n-    //~^ WARN: unnecessary lifetime parameter `'a`\n     fn test<'a>() { assert_static::<'a>() }\n     //~^ ERROR: lifetime may not live long enough\n }"}, {"sha": "399775641f8a3a73c0efec54ca1679c3f65eee5d", "filename": "tests/ui/type-alias-impl-trait/implied_lifetime_wf_check3.stderr", "status": "modified", "additions": 5, "deletions": 29, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3b4d6e080404560f63599deeb328dfa27fe081a6/tests%2Fui%2Ftype-alias-impl-trait%2Fimplied_lifetime_wf_check3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3b4d6e080404560f63599deeb328dfa27fe081a6/tests%2Fui%2Ftype-alias-impl-trait%2Fimplied_lifetime_wf_check3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype-alias-impl-trait%2Fimplied_lifetime_wf_check3.stderr?ref=3b4d6e080404560f63599deeb328dfa27fe081a6", "patch": "@@ -1,49 +1,25 @@\n-warning: unnecessary lifetime parameter `'a`\n-  --> $DIR/implied_lifetime_wf_check3.rs:6:22\n-   |\n-LL |     fn assert_static<'a: 'static>() {}\n-   |                      ^^\n-   |\n-   = help: you can use the `'static` lifetime directly, in place of `'a`\n-\n-warning: unnecessary lifetime parameter `'a`\n-  --> $DIR/implied_lifetime_wf_check3.rs:15:22\n-   |\n-LL |     fn assert_static<'a: 'static>() {}\n-   |                      ^^\n-   |\n-   = help: you can use the `'static` lifetime directly, in place of `'a`\n-\n-warning: unnecessary lifetime parameter `'a`\n-  --> $DIR/implied_lifetime_wf_check3.rs:22:22\n-   |\n-LL |     fn assert_static<'a: 'static>() {}\n-   |                      ^^\n-   |\n-   = help: you can use the `'static` lifetime directly, in place of `'a`\n-\n error: lifetime may not live long enough\n-  --> $DIR/implied_lifetime_wf_check3.rs:8:43\n+  --> $DIR/implied_lifetime_wf_check3.rs:7:43\n    |\n LL |     fn test<'a>() where Ty<'a>: 'static { assert_static::<'a>() }\n    |             -- lifetime `'a` defined here ^^^^^^^^^^^^^^^^^^^ requires that `'a` must outlive `'static`\n \n error: lifetime may not live long enough\n-  --> $DIR/implied_lifetime_wf_check3.rs:17:46\n+  --> $DIR/implied_lifetime_wf_check3.rs:15:46\n    |\n LL |     fn test<'a>() where for<'b> Ty<'b>: 'a { assert_static::<'a>() }\n    |             -- lifetime `'a` defined here    ^^^^^^^^^^^^^^^^^^^ requires that `'a` must outlive `'static`\n \n error: lifetime may not live long enough\n-  --> $DIR/implied_lifetime_wf_check3.rs:24:21\n+  --> $DIR/implied_lifetime_wf_check3.rs:21:21\n    |\n LL |     fn test<'a>() { assert_static::<'a>() }\n    |             --      ^^^^^^^^^^^^^^^^^^^ requires that `'a` must outlive `'static`\n    |             |\n    |             lifetime `'a` defined here\n \n error[E0310]: the parameter type `A` may not live long enough\n-  --> $DIR/implied_lifetime_wf_check3.rs:32:41\n+  --> $DIR/implied_lifetime_wf_check3.rs:29:41\n    |\n LL |     fn test<A>() where Ty<A>: 'static { assert_static::<A>() }\n    |                                         ^^^^^^^^^^^^^^^^^^ ...so that the type `A` will meet its required lifetime bounds\n@@ -53,6 +29,6 @@ help: consider adding an explicit lifetime bound...\n LL |     fn test<A: 'static>() where Ty<A>: 'static { assert_static::<A>() }\n    |              +++++++++\n \n-error: aborting due to 4 previous errors; 3 warnings emitted\n+error: aborting due to 4 previous errors\n \n For more information about this error, try `rustc --explain E0310`."}]}