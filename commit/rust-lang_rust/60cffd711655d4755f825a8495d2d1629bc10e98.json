{"sha": "60cffd711655d4755f825a8495d2d1629bc10e98", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwY2ZmZDcxMTY1NWQ0NzU1ZjgyNWE4NDk1ZDJkMTYyOWJjMTBlOTg=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-12T23:13:30Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-12T23:13:30Z"}, "message": "rustc: Complete the transition of pprust to interior vectors", "tree": {"sha": "a3ab4a1205a84995de30475a7d099f660a323db3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a3ab4a1205a84995de30475a7d099f660a323db3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/60cffd711655d4755f825a8495d2d1629bc10e98", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/60cffd711655d4755f825a8495d2d1629bc10e98", "html_url": "https://github.com/rust-lang/rust/commit/60cffd711655d4755f825a8495d2d1629bc10e98", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/60cffd711655d4755f825a8495d2d1629bc10e98/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a190a2c68eb0606b4617bea999796ea9a9ae06a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/a190a2c68eb0606b4617bea999796ea9a9ae06a6", "html_url": "https://github.com/rust-lang/rust/commit/a190a2c68eb0606b4617bea999796ea9a9ae06a6"}], "stats": {"total": 128, "additions": 48, "deletions": 80}, "files": [{"sha": "a3fd6670db3c9fcb4234bc54d2aa58729f33d320", "filename": "src/comp/syntax/parse/lexer.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/60cffd711655d4755f825a8495d2d1629bc10e98/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60cffd711655d4755f825a8495d2d1629bc10e98/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs?ref=60cffd711655d4755f825a8495d2d1629bc10e98", "patch": "@@ -606,13 +606,13 @@ fn consume_non_eol_whitespace(&reader rdr) {\n }\n \n fn consume_whitespace_counting_blank_lines(&reader rdr,\n-                                           &mutable vec[cmnt] comments) {\n+                                           &mutable cmnt[] comments) {\n     while (is_whitespace(rdr.curr()) && !rdr.is_eof()) {\n         if (rdr.curr() == '\\n' && rdr.next() == '\\n') {\n             log \">>> blank-line comment\";\n             let vec[str] v = [];\n-            comments += [rec(style=blank_line, lines=v,\n-                             pos=rdr.get_chpos())];\n+            comments += ~[rec(style=blank_line, lines=v,\n+                              pos=rdr.get_chpos())];\n         }\n         rdr.bump();\n     }\n@@ -706,12 +706,12 @@ fn peeking_at_comment(&reader rdr) -> bool {\n }\n \n fn consume_comment(&reader rdr, bool code_to_the_left,\n-                   &mutable vec[cmnt] comments) {\n+                   &mutable cmnt[] comments) {\n     log \">>> consume comment\";\n     if (rdr.curr() == '/' && rdr.next() == '/') {\n-        vec::push[cmnt](comments, read_line_comments(rdr, code_to_the_left));\n+        comments += ~[read_line_comments(rdr, code_to_the_left)];\n     } else if (rdr.curr() == '/' && rdr.next() == '*') {\n-        vec::push[cmnt](comments, read_block_comment(rdr, code_to_the_left));\n+        comments += ~[read_block_comment(rdr, code_to_the_left)];\n     } else { fail; }\n     log \"<<< consume comment\";\n }\n@@ -732,14 +732,14 @@ fn is_lit(&token::token t) -> bool {\n \n type lit = rec(str lit, uint pos);\n \n-fn gather_comments_and_literals(&codemap::codemap cm, str path) ->\n-   rec(vec[cmnt] cmnts, vec[lit] lits) {\n+fn gather_comments_and_literals(&codemap::codemap cm, str path)\n+        -> rec(cmnt[] cmnts, lit[] lits) {\n     auto srdr = io::file_reader(path);\n     auto src = str::unsafe_from_bytes(srdr.read_whole_stream());\n     auto itr = @interner::mk[str](str::hash, str::eq);\n     auto rdr = new_reader(cm, src, codemap::new_filemap(path, 0u), itr);\n-    let vec[cmnt] comments = [];\n-    let vec[lit] literals = [];\n+    let cmnt[] comments = ~[];\n+    let lit[] literals = ~[];\n     let bool first_read = true;\n     while (!rdr.is_eof()) {\n         while (true) {\n@@ -757,9 +757,8 @@ fn gather_comments_and_literals(&codemap::codemap cm, str path) ->\n         }\n         auto tok = next_token(rdr);\n         if (is_lit(tok)) {\n-            vec::push[lit](literals,\n-                           rec(lit=rdr.get_mark_str(),\n-                               pos=rdr.get_mark_chpos()));\n+            literals += ~[rec(lit=rdr.get_mark_str(),\n+                              pos=rdr.get_mark_chpos())];\n         }\n         log \"tok: \" + token::to_str(rdr, tok);\n         first_read = false;"}, {"sha": "d4510a9c2933b2b92a2609f0609bca385c731c8d", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 36, "deletions": 67, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/60cffd711655d4755f825a8495d2d1629bc10e98/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60cffd711655d4755f825a8495d2d1629bc10e98/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=60cffd711655d4755f825a8495d2d1629bc10e98", "patch": "@@ -43,26 +43,26 @@ fn no_ann() -> pp_ann {\n type ps =\n     @rec(pp::printer s,\n          option::t[codemap] cm,\n-         option::t[vec[lexer::cmnt]] comments,\n-         option::t[vec[lexer::lit]] literals,\n+         option::t[lexer::cmnt[]] comments,\n+         option::t[lexer::lit[]] literals,\n          mutable uint cur_cmnt,\n          mutable uint cur_lit,\n-         mutable vec[pp::breaks] boxes,\n+         mutable pp::breaks[] boxes,\n          pp_ann ann);\n \n fn ibox(&ps s, uint u) {\n-    vec::push(s.boxes, pp::inconsistent);\n+    s.boxes += ~[pp::inconsistent];\n     pp::ibox(s.s, u);\n }\n \n-fn end(&ps s) { vec::pop(s.boxes); pp::end(s.s); }\n+fn end(&ps s) { ivec::pop(s.boxes); pp::end(s.s); }\n \n fn rust_printer(io::writer writer) -> ps {\n-    let vec[pp::breaks] boxes = [];\n+    let pp::breaks[] boxes = ~[];\n     ret @rec(s=pp::mk_printer(writer, default_columns),\n              cm=none[codemap],\n-             comments=none[vec[lexer::cmnt]],\n-             literals=none[vec[lexer::lit]],\n+             comments=none[lexer::cmnt[]],\n+             literals=none[lexer::lit[]],\n              mutable cur_cmnt=0u,\n              mutable cur_lit=0u,\n              mutable boxes=boxes,\n@@ -75,7 +75,7 @@ const uint default_columns = 78u;\n \n fn print_crate(&codemap cm, @ast::crate crate, str filename,\n                io::writer out, &pp_ann ann) {\n-    let vec[pp::breaks] boxes = [];\n+    let pp::breaks[] boxes = ~[];\n     auto r = lexer::gather_comments_and_literals(cm, filename);\n     auto s =\n         @rec(s=pp::mk_printer(out, default_columns),\n@@ -134,12 +134,12 @@ fn attribute_to_str(&ast::attribute attr) -> str {\n }\n \n fn cbox(&ps s, uint u) {\n-    vec::push(s.boxes, pp::consistent);\n+    s.boxes += ~[pp::consistent];\n     pp::cbox(s.s, u);\n }\n \n fn box(&ps s, uint u, pp::breaks b) {\n-    vec::push(s.boxes, b);\n+    s.boxes += ~[b];\n     pp::box(s.s, u, b);\n }\n \n@@ -197,17 +197,7 @@ fn synth_comment(&ps s, str text) {\n     word(s.s, \"*/\");\n }\n \n-fn commasep[IN](&ps s, breaks b, vec[IN] elts, fn(&ps, &IN)  op) {\n-    box(s, 0u, b);\n-    auto first = true;\n-    for (IN elt in elts) {\n-        if (first) { first = false; } else { word_space(s, \",\"); }\n-        op(s, elt);\n-    }\n-    end(s);\n-}\n-\n-fn commasep_ivec[IN](&ps s, breaks b, &IN[] elts, fn(&ps, &IN)  op) {\n+fn commasep[IN](&ps s, breaks b, &IN[] elts, fn(&ps, &IN)  op) {\n     box(s, 0u, b);\n     auto first = true;\n     for (IN elt in elts) {\n@@ -218,29 +208,9 @@ fn commasep_ivec[IN](&ps s, breaks b, &IN[] elts, fn(&ps, &IN)  op) {\n }\n \n \n-fn commasep_cmnt[IN](&ps s, breaks b, vec[IN] elts, fn(&ps, &IN)  op,\n+fn commasep_cmnt[IN](&ps s, breaks b, &IN[] elts, fn(&ps, &IN)  op,\n                      fn(&IN) -> codemap::span  get_span) {\n     box(s, 0u, b);\n-    auto len = vec::len[IN](elts);\n-    auto i = 0u;\n-    for (IN elt in elts) {\n-        maybe_print_comment(s, get_span(elt).hi);\n-        op(s, elt);\n-        i += 1u;\n-        if (i < len) {\n-            word(s.s, \",\");\n-            maybe_print_trailing_comment(s, get_span(elt),\n-                                         some(get_span(elts.(i)).hi));\n-            space_if_not_hardbreak(s);\n-        }\n-    }\n-    end(s);\n-}\n-\n-// TODO: Remove me.\n-fn commasep_cmnt_ivec[IN](&ps s, breaks b, &IN[] elts, fn(&ps, &IN)  op,\n-                          fn(&IN) -> codemap::span  get_span) {\n-    box(s, 0u, b);\n     auto len = ivec::len[IN](elts);\n     auto i = 0u;\n     for (IN elt in elts) {\n@@ -259,7 +229,7 @@ fn commasep_cmnt_ivec[IN](&ps s, breaks b, &IN[] elts, fn(&ps, &IN)  op,\n \n fn commasep_exprs(&ps s, breaks b, &(@ast::expr)[] exprs) {\n     fn expr_span(&@ast::expr expr) -> codemap::span { ret expr.span; }\n-    commasep_cmnt_ivec(s, b, exprs, print_expr, expr_span);\n+    commasep_cmnt(s, b, exprs, print_expr, expr_span);\n }\n \n fn print_mod(&ps s, ast::_mod _mod, &ast::attribute[] attrs) {\n@@ -321,7 +291,7 @@ fn print_type(&ps s, &ast::ty ty) {\n         case (ast::ty_tup(?elts)) {\n             word(s.s, \"tup\");\n             popen(s);\n-            commasep_ivec(s, inconsistent, elts, print_mt);\n+            commasep(s, inconsistent, elts, print_mt);\n             pclose(s);\n         }\n         case (ast::ty_rec(?fields)) {\n@@ -335,7 +305,7 @@ fn print_type(&ps s, &ast::ty ty) {\n                 end(s);\n             }\n             fn get_span(&ast::ty_field f) -> codemap::span { ret f.span; }\n-            commasep_cmnt_ivec(s, consistent, fields, print_field, get_span);\n+            commasep_cmnt(s, consistent, fields, print_field, get_span);\n             pclose(s);\n         }\n         case (ast::ty_fn(?proto, ?inputs, ?output, ?cf, ?constrs)) {\n@@ -492,7 +462,7 @@ fn print_item(&ps s, &@ast::item item) {\n                         fn print_variant_arg(&ps s, &ast::variant_arg arg) {\n                             print_type(s, *arg.ty);\n                         }\n-                        commasep_ivec(s, consistent, v.node.args,\n+                        commasep(s, consistent, v.node.args,\n                                       print_variant_arg);\n                         pclose(s);\n                     }\n@@ -516,7 +486,7 @@ fn print_item(&ps s, &@ast::item item) {\n                 end(s);\n             }\n             fn get_span(&ast::obj_field f) -> codemap::span { ret f.ty.span; }\n-            commasep_cmnt_ivec(s, consistent, _obj.fields, print_field,\n+            commasep_cmnt(s, consistent, _obj.fields, print_field,\n                                get_span);\n             pclose(s);\n             space(s.s);\n@@ -724,7 +694,7 @@ fn print_expr(&ps s, &@ast::expr expr) {\n             fn get_span(&ast::elt elt) -> codemap::span { ret elt.expr.span; }\n             word(s.s, \"tup\");\n             popen(s);\n-            commasep_cmnt_ivec(s, inconsistent, exprs, printElt, get_span);\n+            commasep_cmnt(s, inconsistent, exprs, printElt, get_span);\n             pclose(s);\n         }\n         case (ast::expr_rec(?fields, ?wth)) {\n@@ -741,7 +711,7 @@ fn print_expr(&ps s, &@ast::expr expr) {\n             }\n             word(s.s, \"rec\");\n             popen(s);\n-            commasep_cmnt_ivec(s, consistent, fields, print_field, get_span);\n+            commasep_cmnt(s, consistent, fields, print_field, get_span);\n             alt (wth) {\n                 case (some(?expr)) {\n                     if (ivec::len(fields) > 0u) { space(s.s); }\n@@ -774,7 +744,7 @@ fn print_expr(&ps s, &@ast::expr expr) {\n             word_nbsp(s, \"bind\");\n             print_expr(s, func);\n             popen(s);\n-            commasep_ivec(s, inconsistent, args, print_opt);\n+            commasep(s, inconsistent, args, print_opt);\n             pclose(s);\n         }\n         case (ast::expr_spawn(_, _, ?e, ?es)) {\n@@ -1039,7 +1009,7 @@ fn print_expr(&ps s, &@ast::expr expr) {\n             alt (anon_obj.fields) {\n                 case (none) { }\n                 case (some(?fields)) {\n-                    commasep_cmnt_ivec(s, consistent, fields, print_field, \n+                    commasep_cmnt(s, consistent, fields, print_field, \n                                        get_span);\n                 }\n             }\n@@ -1126,7 +1096,7 @@ fn print_path(&ps s, &ast::path path) {\n     }\n     if (ivec::len(path.node.types) > 0u) {\n         word(s.s, \"[\");\n-        commasep_ivec(s, inconsistent, path.node.types, print_boxed_type);\n+        commasep(s, inconsistent, path.node.types, print_boxed_type);\n         word(s.s, \"]\");\n     }\n }\n@@ -1143,7 +1113,7 @@ fn print_pat(&ps s, &@ast::pat pat) {\n             print_path(s, path);\n             if (ivec::len(args) > 0u) {\n                 popen(s);\n-                commasep_ivec(s, inconsistent, args, print_pat);\n+                commasep(s, inconsistent, args, print_pat);\n                 pclose(s);\n             }\n         }\n@@ -1159,7 +1129,7 @@ fn print_pat(&ps s, &@ast::pat pat) {\n             fn get_span(&ast::field_pat f) -> codemap::span {\n                 ret f.pat.span;\n             }\n-            commasep_cmnt_ivec(s, consistent, fields, print_field, get_span);\n+            commasep_cmnt(s, consistent, fields, print_field, get_span);\n             if (etc) {\n                 if (ivec::len(fields) != 0u) { word_space(s, \",\"); }\n                 word(s.s, \"_\");\n@@ -1195,7 +1165,7 @@ fn print_fn_args_and_ret(&ps s, &ast::fn_decl decl) {\n         word(s.s, x.ident);\n         end(s);\n     }\n-    commasep_ivec(s, inconsistent, decl.inputs, print_arg);\n+    commasep(s, inconsistent, decl.inputs, print_arg);\n     pclose(s);\n     maybe_print_comment(s, decl.output.span.lo);\n     if (decl.output.node != ast::ty_nil) {\n@@ -1217,7 +1187,7 @@ fn print_type_params(&ps s, &ast::ty_param[] params) {\n     if (ivec::len(params) > 0u) {\n         word(s.s, \"[\");\n         fn printParam(&ps s, &ast::ty_param param) { word(s.s, param); }\n-        commasep_ivec(s, inconsistent, params, printParam);\n+        commasep(s, inconsistent, params, printParam);\n         word(s.s, \"]\");\n     }\n }\n@@ -1236,7 +1206,7 @@ fn print_meta_item(&ps s, &@ast::meta_item item) {\n         case (ast::meta_list(?name, ?items)) {\n             word(s.s, name);\n             popen(s);\n-            commasep_ivec(s, consistent, items, print_meta_item);\n+            commasep(s, consistent, items, print_meta_item);\n             pclose(s);\n         }\n     }\n@@ -1252,7 +1222,7 @@ fn print_view_item(&ps s, &@ast::view_item item) {\n             word(s.s, id);\n             if (ivec::len(mta) > 0u) {\n                 popen(s);\n-                commasep_ivec(s, consistent, mta, print_meta_item);\n+                commasep(s, consistent, mta, print_meta_item);\n                 pclose(s);\n             }\n         }\n@@ -1348,7 +1318,7 @@ fn print_ty_fn(&ps s, &ast::proto proto, &option::t[str] id,\n         print_alias(s, input.node.mode);\n         print_type(s, *input.node.ty);\n     }\n-    commasep_ivec(s, inconsistent, inputs, print_arg);\n+    commasep(s, inconsistent, inputs, print_arg);\n     pclose(s);\n     maybe_print_comment(s, output.span.lo);\n     if (output.node != ast::ty_nil) {\n@@ -1396,7 +1366,7 @@ fn print_remaining_comments(&ps s) {\n }\n \n fn in_cbox(&ps s) -> bool {\n-    auto len = vec::len(s.boxes);\n+    auto len = ivec::len(s.boxes);\n     if (len == 0u) { ret false; }\n     ret s.boxes.(len - 1u) == pp::consistent;\n }\n@@ -1446,7 +1416,7 @@ fn lit_to_str(&@ast::lit l) -> str { be to_str(l, print_literal); }\n fn next_lit(&ps s) -> option::t[lexer::lit] {\n     alt (s.literals) {\n         case (some(?lits)) {\n-            if (s.cur_lit < vec::len(lits)) {\n+            if (s.cur_lit < ivec::len(lits)) {\n                 ret some(lits.(s.cur_lit));\n             } else { ret none[lexer::lit]; }\n         }\n@@ -1541,7 +1511,7 @@ fn to_str[T](&T t, fn(&ps, &T)  f) -> str {\n fn next_comment(&ps s) -> option::t[lexer::cmnt] {\n     alt (s.comments) {\n         case (some(?cmnts)) {\n-            if (s.cur_cmnt < vec::len(cmnts)) {\n+            if (s.cur_cmnt < ivec::len(cmnts)) {\n                 ret some(cmnts.(s.cur_cmnt));\n             } else { ret none[lexer::cmnt]; }\n         }\n@@ -1579,12 +1549,11 @@ fn uint_to_str(&uint i) -> str { ret uint::str(i); }\n \n fn ast_constr_to_str(&@ast::constr c) -> str {\n     // TODO: Remove this vec->ivec conversion.\n-    auto cag_ivec = ~[];\n+    auto cags = ~[];\n     for (@ast::constr_arg_general[uint] cag in c.node.args) {\n-        cag_ivec += ~[cag];\n+        cags += ~[cag];\n     }\n-    ret ast::path_to_str(c.node.path) +\n-            constr_args_to_str(uint_to_str, cag_ivec);\n+    ret ast::path_to_str(c.node.path) + constr_args_to_str(uint_to_str, cags);\n }\n \n fn ast_constrs_str(&(@ast::constr)[] constrs) -> str {"}]}