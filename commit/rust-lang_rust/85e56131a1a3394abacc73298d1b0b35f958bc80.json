{"sha": "85e56131a1a3394abacc73298d1b0b35f958bc80", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1ZTU2MTMxYTFhMzM5NGFiYWNjNzMyOThkMWIwYjM1Zjk1OGJjODA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-13T19:50:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-13T19:50:57Z"}, "message": "Auto merge of #1644 - JCTyblaidd:detect_race_with_alloc, r=RalfJung\n\nMore tests, fix issue 1643 and detect races with allocation.\n\nFixes #1643 by disabling race detection for V-Table memory, adds race detection between r/w & memory allocation, and adds more tests.\n\n~~There is one unusual result in dealloc_read_race_stack_drop.rs, where the stack variable is read by thread 0 & thread 2 and so reports a race with thread 0, any ideas for the cause of the read on thread 0?~~ Fixed, bug with reporting the index a read race occured in correctly.", "tree": {"sha": "0fad1dd2588833cdb71d53de4636f595e10bc8f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0fad1dd2588833cdb71d53de4636f595e10bc8f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/85e56131a1a3394abacc73298d1b0b35f958bc80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/85e56131a1a3394abacc73298d1b0b35f958bc80", "html_url": "https://github.com/rust-lang/rust/commit/85e56131a1a3394abacc73298d1b0b35f958bc80", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/85e56131a1a3394abacc73298d1b0b35f958bc80/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2065b52dfef3cd5a5216e65c21a056a69574bddc", "url": "https://api.github.com/repos/rust-lang/rust/commits/2065b52dfef3cd5a5216e65c21a056a69574bddc", "html_url": "https://github.com/rust-lang/rust/commit/2065b52dfef3cd5a5216e65c21a056a69574bddc"}, {"sha": "c13aabcb456c54f3f5ecfb48b874293ba1a46b46", "url": "https://api.github.com/repos/rust-lang/rust/commits/c13aabcb456c54f3f5ecfb48b874293ba1a46b46", "html_url": "https://github.com/rust-lang/rust/commit/c13aabcb456c54f3f5ecfb48b874293ba1a46b46"}], "stats": {"total": 779, "additions": 731, "deletions": 48}, "files": [{"sha": "3b6723b94437317258bc20e9062a802285878488", "filename": "rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85e56131a1a3394abacc73298d1b0b35f958bc80/rust-version", "raw_url": "https://github.com/rust-lang/rust/raw/85e56131a1a3394abacc73298d1b0b35f958bc80/rust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-version?ref=85e56131a1a3394abacc73298d1b0b35f958bc80", "patch": "@@ -1 +1 @@\n-a2e29d67c26bdf8f278c98ee02d6cc77a279ed2e\n+12813159a985d87a98578e05cc39200e4e8c2102"}, {"sha": "44cce53957773c0ab874f8b929f1479e650c5148", "filename": "src/data_race.rs", "status": "modified", "additions": 106, "deletions": 25, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/85e56131a1a3394abacc73298d1b0b35f958bc80/src%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85e56131a1a3394abacc73298d1b0b35f958bc80/src%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdata_race.rs?ref=85e56131a1a3394abacc73298d1b0b35f958bc80", "patch": "@@ -9,6 +9,9 @@\n //! Relaxed stores now unconditionally block all currently active release sequences and so per-thread tracking of release\n //! sequences is not needed.\n //!\n+//! The implementation also models races with memory allocation and deallocation via treating allocation and\n+//! deallocation as a type of write internally for detecting data-races.\n+//!\n //! This does not explore weak memory orders and so can still miss data-races\n //! but should not report false-positives\n //!\n@@ -73,7 +76,7 @@ use rustc_target::abi::Size;\n use crate::{\n     ImmTy, Immediate, InterpResult, MPlaceTy, MemPlaceMeta, MiriEvalContext, MiriEvalContextExt,\n     OpTy, Pointer, RangeMap, ScalarMaybeUninit, Tag, ThreadId, VClock, VTimestamp,\n-    VectorIdx,\n+    VectorIdx, MemoryKind, MiriMemoryKind\n };\n \n pub type AllocExtra = VClockAlloc;\n@@ -192,6 +195,34 @@ struct AtomicMemoryCellClocks {\n     sync_vector: VClock,\n }\n \n+/// Type of write operation: allocating memory\n+/// non-atomic writes and deallocating memory\n+/// are all treated as writes for the purpose\n+/// of the data-race detector.\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+enum WriteType {\n+    /// Allocate memory.\n+    Allocate,\n+\n+    /// Standard unsynchronized write.\n+    Write,\n+\n+    /// Deallocate memory.\n+    /// Note that when memory is deallocated first, later non-atomic accesses\n+    /// will be reported as use-after-free, not as data races.\n+    /// (Same for `Allocate` above.)\n+    Deallocate,\n+}\n+impl WriteType {\n+    fn get_descriptor(self) -> &'static str {\n+        match self {\n+            WriteType::Allocate => \"Allocate\",\n+            WriteType::Write => \"Write\",\n+            WriteType::Deallocate => \"Deallocate\",\n+        }\n+    }\n+}\n+\n /// Memory Cell vector clock metadata\n /// for data-race detection.\n #[derive(Clone, PartialEq, Eq, Debug)]\n@@ -204,6 +235,11 @@ struct MemoryCellClocks {\n     /// that performed the last write operation.\n     write_index: VectorIdx,\n \n+    /// The type of operation that the write index represents,\n+    /// either newly allocated memory, a non-atomic write or\n+    /// a deallocation of memory.\n+    write_type: WriteType,\n+\n     /// The vector-clock of the timestamp of the last read operation\n     /// performed by a thread since the last write operation occurred.\n     /// It is reset to zero on each write operation.\n@@ -215,20 +251,18 @@ struct MemoryCellClocks {\n     atomic_ops: Option<Box<AtomicMemoryCellClocks>>,\n }\n \n-/// Create a default memory cell clocks instance\n-/// for uninitialized memory.\n-impl Default for MemoryCellClocks {\n-    fn default() -> Self {\n+impl MemoryCellClocks {\n+    /// Create a new set of clocks representing memory allocated\n+    ///  at a given vector timestamp and index.\n+    fn new(alloc: VTimestamp, alloc_index: VectorIdx) -> Self {\n         MemoryCellClocks {\n             read: VClock::default(),\n-            write: 0,\n-            write_index: VectorIdx::MAX_INDEX,\n+            write: alloc,\n+            write_index: alloc_index,\n+            write_type: WriteType::Allocate,\n             atomic_ops: None,\n         }\n     }\n-}\n-\n-impl MemoryCellClocks {\n     \n     /// Load the internal atomic memory cells if they exist.\n     #[inline]\n@@ -382,6 +416,7 @@ impl MemoryCellClocks {\n         &mut self,\n         clocks: &ThreadClockSet,\n         index: VectorIdx,\n+        write_type: WriteType,\n     ) -> Result<(), DataRace> {\n         log::trace!(\"Unsynchronized write with vectors: {:#?} :: {:#?}\", self, clocks);\n         if self.write <= clocks.clock[self.write_index] && self.read <= clocks.clock {\n@@ -393,6 +428,7 @@ impl MemoryCellClocks {\n             if race_free {\n                 self.write = clocks.clock[index];\n                 self.write_index = index;\n+                self.write_type = write_type;\n                 self.read.set_zero_vector();\n                 Ok(())\n             } else {\n@@ -638,6 +674,21 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n             Ok(())\n         }\n     }\n+\n+    fn reset_vector_clocks(\n+        &mut self,\n+        ptr: Pointer<Tag>,\n+        size: Size\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        if let Some(data_race) = &mut this.memory.extra.data_race {\n+            if data_race.multi_threaded.get() {\n+                let alloc_meta = this.memory.get_raw_mut(ptr.alloc_id)?.extra.data_race.as_mut().unwrap();\n+                alloc_meta.reset_clocks(ptr.offset, size);\n+            }\n+        }\n+        Ok(())\n+    }\n }\n \n /// Vector clock metadata for a logical memory allocation.\n@@ -646,22 +697,50 @@ pub struct VClockAlloc {\n     /// Assigning each byte a MemoryCellClocks.\n     alloc_ranges: RefCell<RangeMap<MemoryCellClocks>>,\n \n-    // Pointer to global state.\n+    /// Pointer to global state.\n     global: MemoryExtra,\n }\n \n impl VClockAlloc {\n-    /// Create a new data-race allocation detector.\n-    pub fn new_allocation(global: &MemoryExtra, len: Size) -> VClockAlloc {\n+    /// Create a new data-race detector for newly allocated memory.\n+    pub fn new_allocation(global: &MemoryExtra, len: Size, kind: MemoryKind<MiriMemoryKind>) -> VClockAlloc {\n+        let (alloc_timestamp, alloc_index) = match kind {\n+            // User allocated and stack memory should track allocation.\n+            MemoryKind::Machine(\n+                MiriMemoryKind::Rust | MiriMemoryKind::C | MiriMemoryKind::WinHeap\n+            ) | MemoryKind::Stack => {\n+                let (alloc_index, clocks) = global.current_thread_state();\n+                let alloc_timestamp = clocks.clock[alloc_index];\n+                (alloc_timestamp, alloc_index)\n+            }\n+            // Other global memory should trace races but be allocated at the 0 timestamp.\n+            MemoryKind::Machine(\n+                MiriMemoryKind::Global | MiriMemoryKind::Machine | MiriMemoryKind::Env |\n+                MiriMemoryKind::ExternStatic | MiriMemoryKind::Tls\n+            ) | MemoryKind::CallerLocation | MemoryKind::Vtable => {\n+                (0, VectorIdx::MAX_INDEX)\n+            }\n+        };\n         VClockAlloc {\n             global: Rc::clone(global),\n-            alloc_ranges: RefCell::new(RangeMap::new(len, MemoryCellClocks::default())),\n+            alloc_ranges: RefCell::new(RangeMap::new(\n+                len, MemoryCellClocks::new(alloc_timestamp, alloc_index)\n+            )),\n+        }\n+    }\n+\n+    fn reset_clocks(&mut self, offset: Size, len: Size) {\n+        let mut alloc_ranges = self.alloc_ranges.borrow_mut();\n+        for (_, range) in alloc_ranges.iter_mut(offset, len) {\n+            // Reset the portion of the range\n+            *range = MemoryCellClocks::new(0, VectorIdx::MAX_INDEX);\n         }\n     }\n \n     // Find an index, if one exists where the value\n     // in `l` is greater than the value in `r`.\n     fn find_gt_index(l: &VClock, r: &VClock) -> Option<VectorIdx> {\n+        log::trace!(\"Find index where not {:?} <= {:?}\", l, r);\n         let l_slice = l.as_slice();\n         let r_slice = r.as_slice();\n         l_slice\n@@ -681,7 +760,7 @@ impl VClockAlloc {\n                         .enumerate()\n                         .find_map(|(idx, &r)| if r == 0 { None } else { Some(idx) })\n                         .expect(\"Invalid VClock Invariant\");\n-                    Some(idx)\n+                    Some(idx + r_slice.len())\n                 } else {\n                     None\n                 }\n@@ -712,18 +791,18 @@ impl VClockAlloc {\n             // Convert the write action into the vector clock it\n             // represents for diagnostic purposes.\n             write_clock = VClock::new_with_index(range.write_index, range.write);\n-            (\"WRITE\", range.write_index, &write_clock)\n+            (range.write_type.get_descriptor(), range.write_index, &write_clock)\n         } else if let Some(idx) = Self::find_gt_index(&range.read, &current_clocks.clock) {\n-            (\"READ\", idx, &range.read)\n+            (\"Read\", idx, &range.read)\n         } else if !is_atomic {\n             if let Some(atomic) = range.atomic() {\n                 if let Some(idx) = Self::find_gt_index(&atomic.write_vector, &current_clocks.clock)\n                 {\n-                    (\"ATOMIC_STORE\", idx, &atomic.write_vector)\n+                    (\"Atomic Store\", idx, &atomic.write_vector)\n                 } else if let Some(idx) =\n                     Self::find_gt_index(&atomic.read_vector, &current_clocks.clock)\n                 {\n-                    (\"ATOMIC_LOAD\", idx, &atomic.read_vector)\n+                    (\"Atomic Load\", idx, &atomic.read_vector)\n                 } else {\n                     unreachable!(\n                         \"Failed to report data-race for non-atomic operation: no race found\"\n@@ -774,7 +853,7 @@ impl VClockAlloc {\n                     return Self::report_data_race(\n                         &self.global,\n                         range,\n-                        \"READ\",\n+                        \"Read\",\n                         false,\n                         pointer,\n                         len,\n@@ -792,17 +871,17 @@ impl VClockAlloc {\n         &mut self,\n         pointer: Pointer<Tag>,\n         len: Size,\n-        action: &str,\n+        write_type: WriteType,\n     ) -> InterpResult<'tcx> {\n         if self.global.multi_threaded.get() {\n             let (index, clocks) = self.global.current_thread_state();\n             for (_, range) in self.alloc_ranges.get_mut().iter_mut(pointer.offset, len) {\n-                if let Err(DataRace) = range.write_race_detect(&*clocks, index) {\n+                if let Err(DataRace) = range.write_race_detect(&*clocks, index, write_type) {\n                     // Report data-race\n                     return Self::report_data_race(\n                         &self.global,\n                         range,\n-                        action,\n+                        write_type.get_descriptor(),\n                         false,\n                         pointer,\n                         len,\n@@ -820,15 +899,15 @@ impl VClockAlloc {\n     /// being created or if it is temporarily disabled during a racy read or write\n     /// operation\n     pub fn write<'tcx>(&mut self, pointer: Pointer<Tag>, len: Size) -> InterpResult<'tcx> {\n-        self.unique_access(pointer, len, \"Write\")\n+        self.unique_access(pointer, len, WriteType::Write)\n     }\n \n     /// Detect data-races for an unsynchronized deallocate operation, will not perform\n     /// data-race threads if `multi-threaded` is false, either due to no threads\n     /// being created or if it is temporarily disabled during a racy read or write\n     /// operation\n     pub fn deallocate<'tcx>(&mut self, pointer: Pointer<Tag>, len: Size) -> InterpResult<'tcx> {\n-        self.unique_access(pointer, len, \"Deallocate\")\n+        self.unique_access(pointer, len, WriteType::Deallocate)\n     }\n }\n \n@@ -1134,6 +1213,8 @@ impl GlobalState {\n             vector_info.push(thread)\n         };\n \n+        log::trace!(\"Creating thread = {:?} with vector index = {:?}\", thread, created_index);\n+\n         // Mark the chosen vector index as in use by the thread.\n         thread_info[thread].vector_index = Some(created_index);\n "}, {"sha": "e639bf450ada9ae1261e7f7e6ecac2441edb0647", "filename": "src/machine.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/85e56131a1a3394abacc73298d1b0b35f958bc80/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85e56131a1a3394abacc73298d1b0b35f958bc80/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=85e56131a1a3394abacc73298d1b0b35f958bc80", "patch": "@@ -478,7 +478,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n                 (None, Tag::Untagged)\n             };\n         let race_alloc = if let Some(data_race) = &memory_extra.data_race {\n-            Some(data_race::AllocExtra::new_allocation(&data_race, alloc.size))\n+            Some(data_race::AllocExtra::new_allocation(&data_race, alloc.size, kind))\n         } else {\n             None\n         };\n@@ -510,6 +510,18 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         Ok(())\n     }\n \n+    \n+    fn after_static_mem_initialized(\n+        ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        ptr: Pointer<Self::PointerTag>,\n+        size: Size,\n+    ) -> InterpResult<'tcx> {\n+        if ecx.memory.extra.data_race.is_some() {\n+            ecx.reset_vector_clocks(ptr, size)?;\n+        }\n+        Ok(())\n+    }\n+\n     #[inline(always)]\n     fn tag_global_base_pointer(memory_extra: &MemoryExtra, id: AllocId) -> Self::PointerTag {\n         if let Some(stacked_borrows) = &memory_extra.stacked_borrows {"}, {"sha": "fc1e9d30e637ab8a9ec5b4d3c4ca75bcdc15e09f", "filename": "tests/compile-fail/data_race/alloc_read_race.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/85e56131a1a3394abacc73298d1b0b35f958bc80/tests%2Fcompile-fail%2Fdata_race%2Falloc_read_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85e56131a1a3394abacc73298d1b0b35f958bc80/tests%2Fcompile-fail%2Fdata_race%2Falloc_read_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdata_race%2Falloc_read_race.rs?ref=85e56131a1a3394abacc73298d1b0b35f958bc80", "patch": "@@ -0,0 +1,48 @@\n+// ignore-windows: Concurrency on Windows is not supported yet.\n+\n+use std::thread::spawn;\n+use std::ptr::null_mut;\n+use std::sync::atomic::{Ordering, AtomicPtr};\n+use std::mem::MaybeUninit;\n+\n+#[derive(Copy, Clone)]\n+struct EvilSend<T>(pub T);\n+\n+unsafe impl<T> Send for EvilSend<T> {}\n+unsafe impl<T> Sync for EvilSend<T> {}\n+\n+pub fn main() {\n+    // Shared atomic pointer\n+    let pointer = AtomicPtr::new(null_mut::<MaybeUninit<usize>>());\n+    let ptr = EvilSend(&pointer as *const AtomicPtr<MaybeUninit<usize>>);\n+\n+    // Note: this is scheduler-dependent\n+    // the operations need to occur in\n+    // order, otherwise the allocation is\n+    // not visible to the other-thread to\n+    // detect the race:\n+    //  1. alloc\n+    //  2. write\n+    unsafe {\n+        let j1 = spawn(move || {\n+            // Concurrent allocate the memory.\n+            // Uses relaxed semantics to not generate\n+            // a release sequence.\n+            let pointer = &*ptr.0;\n+            pointer.store(Box::into_raw(Box::new(MaybeUninit::uninit())), Ordering::Relaxed);\n+        });\n+\n+        let j2 = spawn(move || {\n+            let pointer = &*ptr.0;\n+\n+            // Note: could also error due to reading uninitialized memory, but the data-race detector triggers first.\n+            *pointer.load(Ordering::Relaxed) //~ ERROR Data race detected between Read on Thread(id = 2) and Allocate on Thread(id = 1)\n+        });\n+\n+        j1.join().unwrap();\n+        j2.join().unwrap();\n+\n+        // Clean up memory, will never be executed\n+        drop(Box::from_raw(pointer.load(Ordering::Relaxed)));\n+    }\n+}"}, {"sha": "d9f5af396a2d8c15424ec0c6503f3d80cd639b82", "filename": "tests/compile-fail/data_race/alloc_write_race.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/85e56131a1a3394abacc73298d1b0b35f958bc80/tests%2Fcompile-fail%2Fdata_race%2Falloc_write_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85e56131a1a3394abacc73298d1b0b35f958bc80/tests%2Fcompile-fail%2Fdata_race%2Falloc_write_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdata_race%2Falloc_write_race.rs?ref=85e56131a1a3394abacc73298d1b0b35f958bc80", "patch": "@@ -0,0 +1,50 @@\n+// ignore-windows: Concurrency on Windows is not supported yet.\n+\n+use std::thread::spawn;\n+use std::ptr::null_mut;\n+use std::sync::atomic::{Ordering, AtomicPtr};\n+\n+#[derive(Copy, Clone)]\n+struct EvilSend<T>(pub T);\n+\n+unsafe impl<T> Send for EvilSend<T> {}\n+unsafe impl<T> Sync for EvilSend<T> {}\n+\n+extern \"C\" {\n+    fn malloc(size: usize) -> *mut u8;\n+    fn free(ptr: *mut u8);\n+}\n+\n+pub fn main() {\n+    // Shared atomic pointer\n+    let pointer = AtomicPtr::new(null_mut::<usize>());\n+    let ptr = EvilSend(&pointer as *const AtomicPtr<usize>);\n+\n+    // Note: this is scheduler-dependent\n+    // the operations need to occur in\n+    // order, otherwise the allocation is\n+    // not visible to the other-thread to\n+    // detect the race:\n+    //  1. alloc\n+    //  2. write\n+    unsafe {\n+        let j1 = spawn(move || {\n+            // Concurrent allocate the memory.\n+            // Uses relaxed semantics to not generate\n+            // a release sequence.\n+            let pointer = &*ptr.0;\n+            pointer.store(malloc(std::mem::size_of::<usize>()) as *mut usize, Ordering::Relaxed);\n+        });\n+\n+        let j2 = spawn(move || {\n+            let pointer = &*ptr.0;\n+            *pointer.load(Ordering::Relaxed) = 2; //~ ERROR Data race detected between Write on Thread(id = 2) and Allocate on Thread(id = 1)\n+        });\n+\n+        j1.join().unwrap();\n+        j2.join().unwrap();\n+\n+        // Clean up memory, will never be executed\n+        free(pointer.load(Ordering::Relaxed) as *mut _);\n+    }\n+}"}, {"sha": "44860ee6280037de31050c8378dec1ebd931a952", "filename": "tests/compile-fail/data_race/atomic_read_na_write_race1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85e56131a1a3394abacc73298d1b0b35f958bc80/tests%2Fcompile-fail%2Fdata_race%2Fatomic_read_na_write_race1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85e56131a1a3394abacc73298d1b0b35f958bc80/tests%2Fcompile-fail%2Fdata_race%2Fatomic_read_na_write_race1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdata_race%2Fatomic_read_na_write_race1.rs?ref=85e56131a1a3394abacc73298d1b0b35f958bc80", "patch": "@@ -22,7 +22,7 @@ pub fn main() {\n \n         let j2 = spawn(move || {\n             //Equivalent to: (&*c.0).load(Ordering::SeqCst)\n-            atomic_load(c.0 as *mut usize) //~ ERROR Data race\n+            atomic_load(c.0 as *mut usize) //~ ERROR Data race detected between Atomic Load on Thread(id = 2) and Write on Thread(id = 1)\n         });\n \n         j1.join().unwrap();"}, {"sha": "6d28e18886cd843afe937eabbbbc26033df7fb54", "filename": "tests/compile-fail/data_race/atomic_read_na_write_race2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85e56131a1a3394abacc73298d1b0b35f958bc80/tests%2Fcompile-fail%2Fdata_race%2Fatomic_read_na_write_race2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85e56131a1a3394abacc73298d1b0b35f958bc80/tests%2Fcompile-fail%2Fdata_race%2Fatomic_read_na_write_race2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdata_race%2Fatomic_read_na_write_race2.rs?ref=85e56131a1a3394abacc73298d1b0b35f958bc80", "patch": "@@ -22,7 +22,7 @@ pub fn main() {\n \n         let j2 = spawn(move || {\n             let atomic_ref = &mut *c.0;\n-            *atomic_ref.get_mut() = 32; //~ ERROR Data race\n+            *atomic_ref.get_mut() = 32; //~ ERROR Data race detected between Write on Thread(id = 2) and Atomic Load on Thread(id = 1)\n         });\n \n         j1.join().unwrap();"}, {"sha": "0b753f6710a5ff86382877ab6e166b54f0009034", "filename": "tests/compile-fail/data_race/atomic_write_na_read_race1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85e56131a1a3394abacc73298d1b0b35f958bc80/tests%2Fcompile-fail%2Fdata_race%2Fatomic_write_na_read_race1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85e56131a1a3394abacc73298d1b0b35f958bc80/tests%2Fcompile-fail%2Fdata_race%2Fatomic_write_na_read_race1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdata_race%2Fatomic_write_na_read_race1.rs?ref=85e56131a1a3394abacc73298d1b0b35f958bc80", "patch": "@@ -22,7 +22,7 @@ pub fn main() {\n \n         let j2 = spawn(move || {\n             let atomic_ref = &mut *c.0;\n-            *atomic_ref.get_mut() //~ ERROR Data race\n+            *atomic_ref.get_mut() //~ ERROR Data race detected between Read on Thread(id = 2) and Atomic Store on Thread(id = 1)\n         });\n \n         j1.join().unwrap();"}, {"sha": "a9f5fb2fe5bc51e74af87734f251476ae649c7f0", "filename": "tests/compile-fail/data_race/atomic_write_na_read_race2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85e56131a1a3394abacc73298d1b0b35f958bc80/tests%2Fcompile-fail%2Fdata_race%2Fatomic_write_na_read_race2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85e56131a1a3394abacc73298d1b0b35f958bc80/tests%2Fcompile-fail%2Fdata_race%2Fatomic_write_na_read_race2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdata_race%2Fatomic_write_na_read_race2.rs?ref=85e56131a1a3394abacc73298d1b0b35f958bc80", "patch": "@@ -22,7 +22,7 @@ pub fn main() {\n \n         let j2 = spawn(move || {\n             //Equivalent to: (&*c.0).store(32, Ordering::SeqCst)\n-            atomic_store(c.0 as *mut usize, 32); //~ ERROR Data race\n+            atomic_store(c.0 as *mut usize, 32); //~ ERROR Data race detected between Atomic Store on Thread(id = 2) and Read on Thread(id = 1)\n         });\n \n         j1.join().unwrap();"}, {"sha": "d5a828fa6e41c2b4c58cdc2264d7c7c189fa9993", "filename": "tests/compile-fail/data_race/atomic_write_na_write_race1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85e56131a1a3394abacc73298d1b0b35f958bc80/tests%2Fcompile-fail%2Fdata_race%2Fatomic_write_na_write_race1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85e56131a1a3394abacc73298d1b0b35f958bc80/tests%2Fcompile-fail%2Fdata_race%2Fatomic_write_na_write_race1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdata_race%2Fatomic_write_na_write_race1.rs?ref=85e56131a1a3394abacc73298d1b0b35f958bc80", "patch": "@@ -22,7 +22,7 @@ pub fn main() {\n \n         let j2 = spawn(move || {\n             //Equivalent to: (&*c.0).store(64, Ordering::SeqCst)\n-            atomic_store(c.0 as *mut usize, 64); //~ ERROR Data race\n+            atomic_store(c.0 as *mut usize, 64); //~ ERROR Data race detected between Atomic Store on Thread(id = 2) and Write on Thread(id = 1)\n         });\n \n         j1.join().unwrap();"}, {"sha": "9812dcd79920a1a30297f06f64860517b6f3259a", "filename": "tests/compile-fail/data_race/atomic_write_na_write_race2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85e56131a1a3394abacc73298d1b0b35f958bc80/tests%2Fcompile-fail%2Fdata_race%2Fatomic_write_na_write_race2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85e56131a1a3394abacc73298d1b0b35f958bc80/tests%2Fcompile-fail%2Fdata_race%2Fatomic_write_na_write_race2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdata_race%2Fatomic_write_na_write_race2.rs?ref=85e56131a1a3394abacc73298d1b0b35f958bc80", "patch": "@@ -22,7 +22,7 @@ pub fn main() {\n \n         let j2 = spawn(move || {\n             let atomic_ref = &mut *c.0;\n-            *atomic_ref.get_mut() = 32; //~ ERROR Data race\n+            *atomic_ref.get_mut() = 32; //~ ERROR Data race detected between Write on Thread(id = 2) and Atomic Store on Thread(id = 1)\n         });\n \n         j1.join().unwrap();"}, {"sha": "ad539ec5b08398c5de432323cc4a956abab5f2b1", "filename": "tests/compile-fail/data_race/dangling_thread_async_race.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/85e56131a1a3394abacc73298d1b0b35f958bc80/tests%2Fcompile-fail%2Fdata_race%2Fdangling_thread_async_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85e56131a1a3394abacc73298d1b0b35f958bc80/tests%2Fcompile-fail%2Fdata_race%2Fdangling_thread_async_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdata_race%2Fdangling_thread_async_race.rs?ref=85e56131a1a3394abacc73298d1b0b35f958bc80", "patch": "@@ -24,9 +24,9 @@ fn main() {\n         })\n     };\n \n-    // Detatch the thread and sleep until it terminates\n+    // Detach the thread and sleep until it terminates\n     mem::drop(join);\n-    sleep(Duration::from_millis(100));\n+    sleep(Duration::from_millis(200));\n \n     // Spawn and immediately join a thread\n     // to execute the join code-path\n@@ -36,7 +36,7 @@ fn main() {\n \n     let join2 = unsafe {\n         spawn(move || {\n-            *c.0 = 64; //~ ERROR Data race      \n+            *c.0 = 64; //~ ERROR Data race detected between Write on Thread(id = 3) and Write on Thread(id = 1) \n         })\n     };\n "}, {"sha": "755ba8efdae957412b45c42d3942c0d761a57c5f", "filename": "tests/compile-fail/data_race/dangling_thread_race.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/85e56131a1a3394abacc73298d1b0b35f958bc80/tests%2Fcompile-fail%2Fdata_race%2Fdangling_thread_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85e56131a1a3394abacc73298d1b0b35f958bc80/tests%2Fcompile-fail%2Fdata_race%2Fdangling_thread_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdata_race%2Fdangling_thread_race.rs?ref=85e56131a1a3394abacc73298d1b0b35f958bc80", "patch": "@@ -24,9 +24,9 @@ fn main() {\n         })\n     };\n \n-    // Detatch the thread and sleep until it terminates\n+    // Detach the thread and sleep until it terminates\n     mem::drop(join);\n-    sleep(Duration::from_millis(100));\n+    sleep(Duration::from_millis(200));\n \n     // Spawn and immediately join a thread\n     // to execute the join code-path\n@@ -36,6 +36,6 @@ fn main() {\n \n \n     unsafe {\n-        *c.0 = 64; //~ ERROR Data race\n+        *c.0 = 64; //~ ERROR Data race detected between Write on Thread(id = 0, name = \"main\") and Write on Thread(id = 1)\n     }\n }"}, {"sha": "14b02e95cc2330b5ce769af108f6e80035c51737", "filename": "tests/compile-fail/data_race/dealloc_read_race1.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/85e56131a1a3394abacc73298d1b0b35f958bc80/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_read_race1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85e56131a1a3394abacc73298d1b0b35f958bc80/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_read_race1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_read_race1.rs?ref=85e56131a1a3394abacc73298d1b0b35f958bc80", "patch": "@@ -0,0 +1,32 @@\n+// ignore-windows: Concurrency on Windows is not supported yet.\n+\n+use std::thread::spawn;\n+\n+#[derive(Copy, Clone)]\n+struct EvilSend<T>(pub T);\n+\n+unsafe impl<T> Send for EvilSend<T> {}\n+unsafe impl<T> Sync for EvilSend<T> {}\n+\n+extern \"Rust\" {\n+    fn __rust_dealloc(ptr: *mut u8, size: usize, align: usize);\n+}\n+\n+pub fn main() {\n+    // Shared atomic pointer\n+    let pointer: *mut usize = Box::into_raw(Box::new(0usize));\n+    let ptr = EvilSend(pointer);\n+\n+    unsafe {\n+        let j1 = spawn(move || {\n+            *ptr.0\n+        });\n+\n+        let j2 = spawn(move || {\n+            __rust_dealloc(ptr.0 as *mut _, std::mem::size_of::<usize>(), std::mem::align_of::<usize>());  //~ ERROR Data race detected between Deallocate on Thread(id = 2) and Read on Thread(id = 1)\n+        });\n+\n+        j1.join().unwrap();\n+        j2.join().unwrap();\n+    }\n+}"}, {"sha": "a4bf210ef439f24acb96fc71ffc2ff658961a626", "filename": "tests/compile-fail/data_race/dealloc_read_race2.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/85e56131a1a3394abacc73298d1b0b35f958bc80/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_read_race2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85e56131a1a3394abacc73298d1b0b35f958bc80/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_read_race2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_read_race2.rs?ref=85e56131a1a3394abacc73298d1b0b35f958bc80", "patch": "@@ -0,0 +1,34 @@\n+// ignore-windows: Concurrency on Windows is not supported yet.\n+\n+use std::thread::spawn;\n+\n+#[derive(Copy, Clone)]\n+struct EvilSend<T>(pub T);\n+\n+unsafe impl<T> Send for EvilSend<T> {}\n+unsafe impl<T> Sync for EvilSend<T> {}\n+\n+extern \"Rust\" {\n+    fn __rust_dealloc(ptr: *mut u8, size: usize, align: usize);\n+}\n+\n+pub fn main() {\n+    // Shared atomic pointer\n+    let pointer: *mut usize = Box::into_raw(Box::new(0usize));\n+    let ptr = EvilSend(pointer);\n+\n+    unsafe {\n+        let j1 = spawn(move || {\n+            __rust_dealloc(ptr.0 as *mut _, std::mem::size_of::<usize>(), std::mem::align_of::<usize>())\n+        });\n+\n+        let j2 = spawn(move || {\n+            // Also an error of the form: Data race detected between Read on Thread(id = 2) and Deallocate on Thread(id = 1) \n+            // but the invalid allocation is detected first.\n+            *ptr.0 //~ ERROR dereferenced after this allocation got freed\n+        });\n+\n+        j1.join().unwrap();\n+        j2.join().unwrap();\n+    }\n+}"}, {"sha": "31960fb2162bf781a208ff857a8b45657de94a7f", "filename": "tests/compile-fail/data_race/dealloc_read_race_stack.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/85e56131a1a3394abacc73298d1b0b35f958bc80/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_read_race_stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85e56131a1a3394abacc73298d1b0b35f958bc80/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_read_race_stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_read_race_stack.rs?ref=85e56131a1a3394abacc73298d1b0b35f958bc80", "patch": "@@ -0,0 +1,52 @@\n+// ignore-windows: Concurrency on Windows is not supported yet.\n+// compile-flags: -Zmiri-disable-isolation\n+\n+use std::thread::{spawn, sleep};\n+use std::ptr::null_mut;\n+use std::sync::atomic::{Ordering, AtomicPtr};\n+use std::time::Duration;\n+\n+#[derive(Copy, Clone)]\n+struct EvilSend<T>(pub T);\n+\n+unsafe impl<T> Send for EvilSend<T> {}\n+unsafe impl<T> Sync for EvilSend<T> {}\n+\n+pub fn main() {\n+    // Shared atomic pointer\n+    let pointer = AtomicPtr::new(null_mut::<usize>());\n+    let ptr = EvilSend(&pointer as *const AtomicPtr<usize>);\n+\n+    // Note: this is scheduler-dependent\n+    // the operations need to occur in\n+    // order, otherwise the allocation is\n+    // not visible to the other-thread to\n+    // detect the race:\n+    //  1. stack-allocate\n+    //  2. read\n+    //  3. stack-deallocate\n+    unsafe {\n+        let j1 = spawn(move || {\n+            // Concurrent allocate the memory.\n+            // Uses relaxed semantics to not generate\n+            // a release sequence.\n+            let pointer = &*ptr.0;\n+            {\n+                let mut stack_var = 0usize;\n+\n+                pointer.store(&mut stack_var as *mut _, Ordering::Release);\n+\n+                sleep(Duration::from_millis(200));\n+\n+            } //~ ERROR Data race detected between Deallocate on Thread(id = 1) and Read on Thread(id = 2)\n+        });\n+\n+        let j2 = spawn(move || {\n+            let pointer = &*ptr.0;\n+            *pointer.load(Ordering::Acquire)\n+        });\n+\n+        j1.join().unwrap();\n+        j2.join().unwrap();\n+    }\n+}"}, {"sha": "44950a34db2f855ba29e39f0b8dc1cb31c3a7165", "filename": "tests/compile-fail/data_race/dealloc_read_race_stack_drop.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/85e56131a1a3394abacc73298d1b0b35f958bc80/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_read_race_stack_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85e56131a1a3394abacc73298d1b0b35f958bc80/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_read_race_stack_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_read_race_stack_drop.rs?ref=85e56131a1a3394abacc73298d1b0b35f958bc80", "patch": "@@ -0,0 +1,52 @@\n+// ignore-windows: Concurrency on Windows is not supported yet.\n+// compile-flags: -Zmiri-disable-isolation\n+\n+use std::thread::{spawn, sleep};\n+use std::ptr::null_mut;\n+use std::sync::atomic::{Ordering, AtomicPtr};\n+use std::time::Duration;\n+\n+#[derive(Copy, Clone)]\n+struct EvilSend<T>(pub T);\n+\n+unsafe impl<T> Send for EvilSend<T> {}\n+unsafe impl<T> Sync for EvilSend<T> {}\n+\n+pub fn main() {\n+    // Shared atomic pointer\n+    let pointer = AtomicPtr::new(null_mut::<usize>());\n+    let ptr = EvilSend(&pointer as *const AtomicPtr<usize>);\n+\n+    // Note: this is scheduler-dependent\n+    // the operations need to occur in\n+    // order, otherwise the allocation is\n+    // not visible to the other-thread to\n+    // detect the race:\n+    //  1. stack-allocate\n+    //  2. read\n+    //  3. stack-deallocate\n+    unsafe {\n+        let j1 = spawn(move || {\n+            // Concurrent allocate the memory.\n+            // Uses relaxed semantics to not generate\n+            // a release sequence.\n+            let pointer = &*ptr.0;\n+\n+            let mut stack_var = 0usize;\n+\n+            pointer.store(&mut stack_var as *mut _, Ordering::Release);\n+\n+            sleep(Duration::from_millis(200));\n+\n+            drop(stack_var);\n+        });  //~ ERROR Data race detected between Deallocate on Thread(id = 1) and Read on Thread(id = 2)\n+\n+        let j2 = spawn(move || {\n+            let pointer = &*ptr.0;\n+            *pointer.load(Ordering::Acquire)\n+        });\n+\n+        j1.join().unwrap();\n+        j2.join().unwrap();\n+    }\n+}"}, {"sha": "edcdfffdb5f53b5443545cc1707c1f3dcbce094c", "filename": "tests/compile-fail/data_race/dealloc_write_race1.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/85e56131a1a3394abacc73298d1b0b35f958bc80/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_write_race1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85e56131a1a3394abacc73298d1b0b35f958bc80/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_write_race1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_write_race1.rs?ref=85e56131a1a3394abacc73298d1b0b35f958bc80", "patch": "@@ -0,0 +1,31 @@\n+// ignore-windows: Concurrency on Windows is not supported yet.\n+\n+use std::thread::spawn;\n+\n+#[derive(Copy, Clone)]\n+struct EvilSend<T>(pub T);\n+\n+unsafe impl<T> Send for EvilSend<T> {}\n+unsafe impl<T> Sync for EvilSend<T> {}\n+\n+extern \"Rust\" {\n+    fn __rust_dealloc(ptr: *mut u8, size: usize, align: usize);\n+}\n+pub fn main() {\n+    // Shared atomic pointer\n+    let pointer: *mut usize = Box::into_raw(Box::new(0usize));\n+    let ptr = EvilSend(pointer);\n+\n+    unsafe {\n+        let j1 = spawn(move || {\n+            *ptr.0 = 2;\n+        });\n+\n+        let j2 = spawn(move || {\n+            __rust_dealloc(ptr.0 as *mut _, std::mem::size_of::<usize>(), std::mem::align_of::<usize>());  //~ ERROR Data race detected between Deallocate on Thread(id = 2) and Write on Thread(id = 1)\n+        });\n+\n+        j1.join().unwrap();\n+        j2.join().unwrap();\n+    }\n+}"}, {"sha": "20c05fa8f17bcfe91612cf7979cb2308d414b7b1", "filename": "tests/compile-fail/data_race/dealloc_write_race2.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/85e56131a1a3394abacc73298d1b0b35f958bc80/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_write_race2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85e56131a1a3394abacc73298d1b0b35f958bc80/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_write_race2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_write_race2.rs?ref=85e56131a1a3394abacc73298d1b0b35f958bc80", "patch": "@@ -0,0 +1,33 @@\n+// ignore-windows: Concurrency on Windows is not supported yet.\n+\n+use std::thread::spawn;\n+\n+#[derive(Copy, Clone)]\n+struct EvilSend<T>(pub T);\n+\n+unsafe impl<T> Send for EvilSend<T> {}\n+unsafe impl<T> Sync for EvilSend<T> {}\n+\n+extern \"Rust\" {\n+    fn __rust_dealloc(ptr: *mut u8, size: usize, align: usize);\n+}\n+pub fn main() {\n+    // Shared atomic pointer\n+    let pointer: *mut usize = Box::into_raw(Box::new(0usize));\n+    let ptr = EvilSend(pointer);\n+\n+    unsafe {\n+        let j1 = spawn(move || {\n+            __rust_dealloc(ptr.0 as *mut _, std::mem::size_of::<usize>(), std::mem::align_of::<usize>());\n+        });\n+\n+        let j2 = spawn(move || {\n+            // Also an error of the form: Data race detected between Write on Thread(id = 2) and Deallocate on Thread(id = 1)\n+            // but the invalid allocation is detected first.\n+            *ptr.0 = 2; //~ ERROR dereferenced after this allocation got freed\n+        });\n+\n+        j1.join().unwrap();\n+        j2.join().unwrap();\n+    }\n+}"}, {"sha": "25dea65fe7e09019e6cfcd577e5d6f9ea10a2de0", "filename": "tests/compile-fail/data_race/dealloc_write_race_stack.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/85e56131a1a3394abacc73298d1b0b35f958bc80/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_write_race_stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85e56131a1a3394abacc73298d1b0b35f958bc80/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_write_race_stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_write_race_stack.rs?ref=85e56131a1a3394abacc73298d1b0b35f958bc80", "patch": "@@ -0,0 +1,52 @@\n+// ignore-windows: Concurrency on Windows is not supported yet.\n+// compile-flags: -Zmiri-disable-isolation\n+\n+use std::thread::{spawn, sleep};\n+use std::ptr::null_mut;\n+use std::sync::atomic::{Ordering, AtomicPtr};\n+use std::time::Duration;\n+\n+#[derive(Copy, Clone)]\n+struct EvilSend<T>(pub T);\n+\n+unsafe impl<T> Send for EvilSend<T> {}\n+unsafe impl<T> Sync for EvilSend<T> {}\n+\n+pub fn main() {\n+    // Shared atomic pointer\n+    let pointer = AtomicPtr::new(null_mut::<usize>());\n+    let ptr = EvilSend(&pointer as *const AtomicPtr<usize>);\n+\n+    // Note: this is scheduler-dependent\n+    // the operations need to occur in\n+    // order, otherwise the allocation is\n+    // not visible to the other-thread to\n+    // detect the race:\n+    //  1. stack-allocate\n+    //  2. read\n+    //  3. stack-deallocate\n+    unsafe {\n+        let j1 = spawn(move || {\n+            // Concurrent allocate the memory.\n+            // Uses relaxed semantics to not generate\n+            // a release sequence.\n+            let pointer = &*ptr.0;\n+            {\n+                let mut stack_var = 0usize;\n+\n+                pointer.store(&mut stack_var as *mut _, Ordering::Release);\n+\n+                sleep(Duration::from_millis(200));\n+\n+            } //~ ERROR Data race detected between Deallocate on Thread(id = 1) and Write on Thread(id = 2)\n+        });\n+\n+        let j2 = spawn(move || {\n+            let pointer = &*ptr.0;\n+            *pointer.load(Ordering::Acquire) = 3;\n+        });\n+\n+        j1.join().unwrap();\n+        j2.join().unwrap();\n+    }\n+}"}, {"sha": "1d239e9eb74d02f69d06bb1af8fdaa965c8bda9f", "filename": "tests/compile-fail/data_race/dealloc_write_race_stack_drop.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/85e56131a1a3394abacc73298d1b0b35f958bc80/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_write_race_stack_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85e56131a1a3394abacc73298d1b0b35f958bc80/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_write_race_stack_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_write_race_stack_drop.rs?ref=85e56131a1a3394abacc73298d1b0b35f958bc80", "patch": "@@ -0,0 +1,53 @@\n+// ignore-windows: Concurrency on Windows is not supported yet.\n+// compile-flags: -Zmiri-disable-isolation\n+\n+use std::thread::{spawn, sleep};\n+use std::ptr::null_mut;\n+use std::sync::atomic::{Ordering, AtomicPtr};\n+use std::time::Duration;\n+\n+#[derive(Copy, Clone)]\n+struct EvilSend<T>(pub T);\n+\n+unsafe impl<T> Send for EvilSend<T> {}\n+unsafe impl<T> Sync for EvilSend<T> {}\n+\n+pub fn main() {\n+    // Shared atomic pointer\n+    let pointer = AtomicPtr::new(null_mut::<usize>());\n+    let ptr = EvilSend(&pointer as *const AtomicPtr<usize>);\n+\n+    // Note: this is scheduler-dependent\n+    // the operations need to occur in\n+    // order, otherwise the allocation is\n+    // not visible to the other-thread to\n+    // detect the race:\n+    //  1. stack-allocate\n+    //  2. read\n+    //  3. stack-deallocate\n+    unsafe {\n+        let j1 = spawn(move || {\n+            // Concurrent allocate the memory.\n+            // Uses relaxed semantics to not generate\n+            // a release sequence.\n+            let pointer = &*ptr.0;\n+\n+            let mut stack_var = 0usize;\n+\n+            pointer.store(&mut stack_var as *mut _, Ordering::Release);\n+            \n+            sleep(Duration::from_millis(200));\n+\n+            // Note: Implicit read for drop(_) races with write, would detect race with deallocate after.\n+            drop(stack_var); //~ ERROR Data race detected between Read on Thread(id = 1) and Write on Thread(id = 2)\n+        });\n+\n+        let j2 = spawn(move || {\n+            let pointer = &*ptr.0;\n+            *pointer.load(Ordering::Acquire) = 3;\n+        });\n+\n+        j1.join().unwrap();\n+        j2.join().unwrap();\n+    }\n+}"}, {"sha": "832158a34a6a67cd362c3ee6030e7e1c1bf7acef", "filename": "tests/compile-fail/data_race/enable_after_join_to_main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85e56131a1a3394abacc73298d1b0b35f958bc80/tests%2Fcompile-fail%2Fdata_race%2Fenable_after_join_to_main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85e56131a1a3394abacc73298d1b0b35f958bc80/tests%2Fcompile-fail%2Fdata_race%2Fenable_after_join_to_main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdata_race%2Fenable_after_join_to_main.rs?ref=85e56131a1a3394abacc73298d1b0b35f958bc80", "patch": "@@ -29,7 +29,7 @@ pub fn main() {\n         });\n \n         let j2 = spawn(move || {\n-            *c.0 = 64; //~ ERROR Data race\n+            *c.0 = 64; //~ ERROR Data race detected between Write on Thread(id = 6) and Write on Thread(id = 5)\n         });\n \n         j1.join().unwrap();"}, {"sha": "0df66d66ad0773944aa0a0a205750db96a58376b", "filename": "tests/compile-fail/data_race/read_write_race.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85e56131a1a3394abacc73298d1b0b35f958bc80/tests%2Fcompile-fail%2Fdata_race%2Fread_write_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85e56131a1a3394abacc73298d1b0b35f958bc80/tests%2Fcompile-fail%2Fdata_race%2Fread_write_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdata_race%2Fread_write_race.rs?ref=85e56131a1a3394abacc73298d1b0b35f958bc80", "patch": "@@ -18,7 +18,7 @@ pub fn main() {\n         });\n \n         let j2 = spawn(move || {\n-            *c.0 = 64; //~ ERROR Data race\n+            *c.0 = 64; //~ ERROR Data race detected between Write on Thread(id = 2) and Read on Thread(id = 1)\n         });\n \n         j1.join().unwrap();"}, {"sha": "0cf915cdef2b1fd868ccc9a0d30ec0c053b1adc7", "filename": "tests/compile-fail/data_race/read_write_race_stack.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/85e56131a1a3394abacc73298d1b0b35f958bc80/tests%2Fcompile-fail%2Fdata_race%2Fread_write_race_stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85e56131a1a3394abacc73298d1b0b35f958bc80/tests%2Fcompile-fail%2Fdata_race%2Fread_write_race_stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdata_race%2Fread_write_race_stack.rs?ref=85e56131a1a3394abacc73298d1b0b35f958bc80", "patch": "@@ -0,0 +1,57 @@\n+// ignore-windows: Concurrency on Windows is not supported yet.\n+// compile-flags: -Zmiri-disable-isolation -Zmir-opt-level=0\n+\n+// Note: mir-opt-level set to 0 to prevent the read of stack_var in thread 1\n+// from being optimized away and preventing the detection of the data-race.\n+\n+use std::thread::{spawn, sleep};\n+use std::ptr::null_mut;\n+use std::sync::atomic::{Ordering, AtomicPtr};\n+use std::time::Duration;\n+\n+#[derive(Copy, Clone)]\n+struct EvilSend<T>(pub T);\n+\n+unsafe impl<T> Send for EvilSend<T> {}\n+unsafe impl<T> Sync for EvilSend<T> {}\n+\n+pub fn main() {\n+    // Shared atomic pointer\n+    let pointer = AtomicPtr::new(null_mut::<usize>());\n+    let ptr = EvilSend(&pointer as *const AtomicPtr<usize>);\n+\n+    // Note: this is scheduler-dependent\n+    // the operations need to occur in\n+    // order, otherwise the allocation is\n+    // not visible to the other-thread to\n+    // detect the race:\n+    //  1. stack-allocate\n+    //  2. atomic_store\n+    //  3. atomic_load\n+    //  4. write-value\n+    //  5. read-value\n+    unsafe {\n+        let j1 = spawn(move || {\n+            // Concurrent allocate the memory.\n+            // Uses relaxed semantics to not generate\n+            // a release sequence.\n+            let pointer = &*ptr.0;\n+\n+            let mut stack_var = 0usize;\n+\n+            pointer.store(&mut stack_var as *mut _, Ordering::Release);\n+            \n+            sleep(Duration::from_millis(200));\n+\n+            stack_var //~ ERROR Data race detected between Read on Thread(id = 1) and Write on Thread(id = 2)\n+        });\n+\n+        let j2 = spawn(move || {\n+            let pointer = &*ptr.0;\n+            *pointer.load(Ordering::Acquire) = 3;\n+        });\n+\n+        j1.join().unwrap();\n+        j2.join().unwrap();\n+    }\n+}"}, {"sha": "8b8616431f37a797289bd5277f8f9c88a2453027", "filename": "tests/compile-fail/data_race/relax_acquire_race.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85e56131a1a3394abacc73298d1b0b35f958bc80/tests%2Fcompile-fail%2Fdata_race%2Frelax_acquire_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85e56131a1a3394abacc73298d1b0b35f958bc80/tests%2Fcompile-fail%2Fdata_race%2Frelax_acquire_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdata_race%2Frelax_acquire_race.rs?ref=85e56131a1a3394abacc73298d1b0b35f958bc80", "patch": "@@ -37,7 +37,7 @@ pub fn main() {\n \n         let j3 = spawn(move || {\n             if SYNC.load(Ordering::Acquire) == 2 {\n-                *c.0 //~ ERROR Data race\n+                *c.0 //~ ERROR Data race detected between Read on Thread(id = 3) and Write on Thread(id = 1)\n             } else {\n                 0\n             }"}, {"sha": "29c428b388d430ecb4025e896cd822b1d03f8fd9", "filename": "tests/compile-fail/data_race/release_seq_race.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/85e56131a1a3394abacc73298d1b0b35f958bc80/tests%2Fcompile-fail%2Fdata_race%2Frelease_seq_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85e56131a1a3394abacc73298d1b0b35f958bc80/tests%2Fcompile-fail%2Fdata_race%2Frelease_seq_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdata_race%2Frelease_seq_race.rs?ref=85e56131a1a3394abacc73298d1b0b35f958bc80", "patch": "@@ -30,7 +30,7 @@ pub fn main() {\n         let j1 = spawn(move || {\n             *c.0 = 1;\n             SYNC.store(1, Ordering::Release);\n-            sleep(Duration::from_millis(100));\n+            sleep(Duration::from_millis(200));\n             SYNC.store(3, Ordering::Relaxed);\n         });\n \n@@ -40,9 +40,9 @@ pub fn main() {\n         });\n \n         let j3 = spawn(move || {\n-            sleep(Duration::from_millis(1000));\n+            sleep(Duration::from_millis(500));\n             if SYNC.load(Ordering::Acquire) == 3 {\n-                *c.0 //~ ERROR Data race\n+                *c.0 //~ ERROR Data race detected between Read on Thread(id = 3) and Write on Thread(id = 1)\n             } else {\n                 0\n             }"}, {"sha": "54b9f49937c888dd8b523d8bb2d5e53b787acb67", "filename": "tests/compile-fail/data_race/release_seq_race_same_thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85e56131a1a3394abacc73298d1b0b35f958bc80/tests%2Fcompile-fail%2Fdata_race%2Frelease_seq_race_same_thread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85e56131a1a3394abacc73298d1b0b35f958bc80/tests%2Fcompile-fail%2Fdata_race%2Frelease_seq_race_same_thread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdata_race%2Frelease_seq_race_same_thread.rs?ref=85e56131a1a3394abacc73298d1b0b35f958bc80", "patch": "@@ -38,7 +38,7 @@ pub fn main() {\n \n         let j2 = spawn(move || {\n             if SYNC.load(Ordering::Acquire) == 2 {\n-                *c.0 //~ ERROR Data race\n+                *c.0 //~ ERROR Data race detected between Read on Thread(id = 2) and Write on Thread(id = 1)\n             } else {\n                 0\n             }"}, {"sha": "fcf683a65d8ed6c7e128281d83254bc13caf2b4c", "filename": "tests/compile-fail/data_race/rmw_race.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85e56131a1a3394abacc73298d1b0b35f958bc80/tests%2Fcompile-fail%2Fdata_race%2Frmw_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85e56131a1a3394abacc73298d1b0b35f958bc80/tests%2Fcompile-fail%2Fdata_race%2Frmw_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdata_race%2Frmw_race.rs?ref=85e56131a1a3394abacc73298d1b0b35f958bc80", "patch": "@@ -38,7 +38,7 @@ pub fn main() {\n \n         let j3 = spawn(move || {\n             if SYNC.load(Ordering::Acquire) == 3 {\n-                *c.0 //~ ERROR Data race\n+                *c.0 //~ ERROR Data race detected between Read on Thread(id = 3) and Write on Thread(id = 1)\n             } else {\n                 0\n             }"}, {"sha": "61909eda86337debbdbdb9b0dce7a0d0b868220b", "filename": "tests/compile-fail/data_race/write_write_race.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85e56131a1a3394abacc73298d1b0b35f958bc80/tests%2Fcompile-fail%2Fdata_race%2Fwrite_write_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85e56131a1a3394abacc73298d1b0b35f958bc80/tests%2Fcompile-fail%2Fdata_race%2Fwrite_write_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdata_race%2Fwrite_write_race.rs?ref=85e56131a1a3394abacc73298d1b0b35f958bc80", "patch": "@@ -18,7 +18,7 @@ pub fn main() {\n         });\n \n         let j2 = spawn(move || {\n-            *c.0 = 64; //~ ERROR Data race\n+            *c.0 = 64; //~ ERROR Data race detected between Write on Thread(id = 2) and Write on Thread(id = 1)\n         });\n \n         j1.join().unwrap();"}, {"sha": "aa1428f8a74b7522e86f177b6cd9ec2c6f3ceda0", "filename": "tests/compile-fail/data_race/write_write_race_stack.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/85e56131a1a3394abacc73298d1b0b35f958bc80/tests%2Fcompile-fail%2Fdata_race%2Fwrite_write_race_stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85e56131a1a3394abacc73298d1b0b35f958bc80/tests%2Fcompile-fail%2Fdata_race%2Fwrite_write_race_stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdata_race%2Fwrite_write_race_stack.rs?ref=85e56131a1a3394abacc73298d1b0b35f958bc80", "patch": "@@ -0,0 +1,57 @@\n+// ignore-windows: Concurrency on Windows is not supported yet.\n+// compile-flags: -Zmiri-disable-isolation\n+\n+use std::thread::{spawn, sleep};\n+use std::ptr::null_mut;\n+use std::sync::atomic::{Ordering, AtomicPtr};\n+use std::time::Duration;\n+\n+#[derive(Copy, Clone)]\n+struct EvilSend<T>(pub T);\n+\n+unsafe impl<T> Send for EvilSend<T> {}\n+unsafe impl<T> Sync for EvilSend<T> {}\n+\n+pub fn main() {\n+    // Shared atomic pointer\n+    let pointer = AtomicPtr::new(null_mut::<usize>());\n+    let ptr = EvilSend(&pointer as *const AtomicPtr<usize>);\n+\n+    // Note: this is scheduler-dependent\n+    // the operations need to occur in\n+    // order, otherwise the allocation is\n+    // not visible to the other-thread to\n+    // detect the race:\n+    //  1. stack-allocate\n+    //  2. atomic_store\n+    //  3. atomic_load\n+    //  4. write-value\n+    //  5. write-value\n+    unsafe {\n+        let j1 = spawn(move || {\n+            // Concurrent allocate the memory.\n+            // Uses relaxed semantics to not generate\n+            // a release sequence.\n+            let pointer = &*ptr.0;\n+\n+            let mut stack_var = 0usize;\n+\n+            pointer.store(&mut stack_var as *mut _, Ordering::Release);\n+            \n+            sleep(Duration::from_millis(200));\n+\n+            stack_var = 1usize; //~ ERROR Data race detected between Write on Thread(id = 1) and Write on Thread(id = 2)\n+            \n+            // read to silence errors\n+            stack_var\n+        });\n+\n+        let j2 = spawn(move || {\n+            let pointer = &*ptr.0;\n+            *pointer.load(Ordering::Acquire) = 3;\n+        });\n+\n+        j1.join().unwrap();\n+        j2.join().unwrap();\n+    }\n+}"}, {"sha": "d509d1b3f797d3ccdb3abce7eaa60e65511753bd", "filename": "tests/run-pass/concurrency/concurrent_caller_location.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/85e56131a1a3394abacc73298d1b0b35f958bc80/tests%2Frun-pass%2Fconcurrency%2Fconcurrent_caller_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85e56131a1a3394abacc73298d1b0b35f958bc80/tests%2Frun-pass%2Fconcurrency%2Fconcurrent_caller_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Fconcurrent_caller_location.rs?ref=85e56131a1a3394abacc73298d1b0b35f958bc80", "patch": "@@ -0,0 +1,19 @@\n+// ignore-windows: Concurrency on Windows is not supported yet.\n+\n+use std::thread::spawn;\n+use std::panic::Location;\n+\n+fn initialize() {\n+    let _ignore = initialize_inner();\n+}\n+\n+fn initialize_inner() -> &'static Location<'static> {\n+    Location::caller()\n+}\n+\n+fn main() {\n+    let j1 = spawn(initialize);\n+    let j2 = spawn(initialize);\n+    j1.join().unwrap();\n+    j2.join().unwrap();\n+}"}, {"sha": "03676519d4f1c052581dee9227a650c2a4b8d782", "filename": "tests/run-pass/concurrency/concurrent_caller_location.stderr", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85e56131a1a3394abacc73298d1b0b35f958bc80/tests%2Frun-pass%2Fconcurrency%2Fconcurrent_caller_location.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/85e56131a1a3394abacc73298d1b0b35f958bc80/tests%2Frun-pass%2Fconcurrency%2Fconcurrent_caller_location.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Fconcurrent_caller_location.stderr?ref=85e56131a1a3394abacc73298d1b0b35f958bc80", "patch": "@@ -0,0 +1,2 @@\n+warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+"}, {"sha": "1238a1bd6f5e168430d981d6bcdc28fde78df40d", "filename": "tests/run-pass/concurrency/issue1643.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/85e56131a1a3394abacc73298d1b0b35f958bc80/tests%2Frun-pass%2Fconcurrency%2Fissue1643.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85e56131a1a3394abacc73298d1b0b35f958bc80/tests%2Frun-pass%2Fconcurrency%2Fissue1643.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Fissue1643.rs?ref=85e56131a1a3394abacc73298d1b0b35f958bc80", "patch": "@@ -0,0 +1,16 @@\n+// ignore-windows: Concurrency on Windows is not supported yet.\n+\n+use std::thread::spawn;\n+\n+fn initialize() {\n+    initialize_inner(&mut || false)\n+}\n+\n+fn initialize_inner(_init: &mut dyn FnMut() -> bool) {}\n+\n+fn main() {\n+    let j1 = spawn(initialize);\n+    let j2 = spawn(initialize);\n+    j1.join().unwrap();\n+    j2.join().unwrap();\n+}"}, {"sha": "03676519d4f1c052581dee9227a650c2a4b8d782", "filename": "tests/run-pass/concurrency/issue1643.stderr", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85e56131a1a3394abacc73298d1b0b35f958bc80/tests%2Frun-pass%2Fconcurrency%2Fissue1643.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/85e56131a1a3394abacc73298d1b0b35f958bc80/tests%2Frun-pass%2Fconcurrency%2Fissue1643.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Fissue1643.stderr?ref=85e56131a1a3394abacc73298d1b0b35f958bc80", "patch": "@@ -0,0 +1,2 @@\n+warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+"}]}