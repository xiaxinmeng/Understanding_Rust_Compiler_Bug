{"sha": "996ff2e0a0f911f52bb1de6bdd0cfd5704de1fc9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5NmZmMmUwYTBmOTExZjUyYmIxZGU2YmRkMGNmZDU3MDRkZTFmYzk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-07T01:26:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-07T01:26:15Z"}, "message": "Auto merge of #87408 - kornelski:try_reserve_error, r=yaahc\n\nHide allocator details from TryReserveError\n\nI think there's [no need for TryReserveError to carry detailed information](https://github.com/rust-lang/rust/issues/48043#issuecomment-825139280), but I wouldn't want that issue to delay stabilization of the `try_reserve` feature.\n\nSo I'm proposing to stabilize `try_reserve` with a `TryReserveError` as an opaque structure, and if needed, expose error details later.\n\nThis PR moves the `enum` to an unstable inner `TryReserveErrorKind` that lives under a separate feature flag. `TryReserveErrorKind` could possibly be left as an implementation detail forever, and the `TryReserveError` get methods such as `allocation_size() -> Option<usize>` or `layout() -> Option<Layout>` instead, or the details could be dropped completely to make try-reserve errors just a unit struct, and thus smaller and cheaper.", "tree": {"sha": "f10bdc2b1742f123ce140d43cb11d8f07dabfe92", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f10bdc2b1742f123ce140d43cb11d8f07dabfe92"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/996ff2e0a0f911f52bb1de6bdd0cfd5704de1fc9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/996ff2e0a0f911f52bb1de6bdd0cfd5704de1fc9", "html_url": "https://github.com/rust-lang/rust/commit/996ff2e0a0f911f52bb1de6bdd0cfd5704de1fc9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/996ff2e0a0f911f52bb1de6bdd0cfd5704de1fc9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db3cb435c1197ef3e3919c03b7f81ca8bffbd007", "url": "https://api.github.com/repos/rust-lang/rust/commits/db3cb435c1197ef3e3919c03b7f81ca8bffbd007", "html_url": "https://github.com/rust-lang/rust/commit/db3cb435c1197ef3e3919c03b7f81ca8bffbd007"}, {"sha": "a294aa8d3d7b73b7de60c629ae202194cffeb2f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/a294aa8d3d7b73b7de60c629ae202194cffeb2f4", "html_url": "https://github.com/rust-lang/rust/commit/a294aa8d3d7b73b7de60c629ae202194cffeb2f4"}], "stats": {"total": 378, "additions": 269, "deletions": 109}, "files": [{"sha": "f91067526b13f28293cfdf94ad9566e9d8bd58d6", "filename": "compiler/rustc_middle/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/996ff2e0a0f911f52bb1de6bdd0cfd5704de1fc9/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/996ff2e0a0f911f52bb1de6bdd0cfd5704de1fc9/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flib.rs?ref=996ff2e0a0f911f52bb1de6bdd0cfd5704de1fc9", "patch": "@@ -51,6 +51,7 @@\n #![feature(iter_zip)]\n #![feature(thread_local_const_init)]\n #![feature(try_reserve)]\n+#![feature(try_reserve_kind)]\n #![feature(nonzero_ops)]\n #![recursion_limit = \"512\"]\n "}, {"sha": "00fb4902c61f759085f65b26eaa0348a062ae76c", "filename": "compiler/rustc_mir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/996ff2e0a0f911f52bb1de6bdd0cfd5704de1fc9/compiler%2Frustc_mir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/996ff2e0a0f911f52bb1de6bdd0cfd5704de1fc9/compiler%2Frustc_mir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Flib.rs?ref=996ff2e0a0f911f52bb1de6bdd0cfd5704de1fc9", "patch": "@@ -30,6 +30,7 @@ Rust MIR: a lowered representation of Rust.\n #![feature(once_cell)]\n #![feature(control_flow_enum)]\n #![feature(try_reserve)]\n+#![feature(try_reserve_kind)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "3ee857f3399e09f931e342a03528244ae48d6941", "filename": "library/alloc/src/collections/mod.rs", "status": "modified", "additions": 43, "deletions": 6, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/996ff2e0a0f911f52bb1de6bdd0cfd5704de1fc9/library%2Falloc%2Fsrc%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/996ff2e0a0f911f52bb1de6bdd0cfd5704de1fc9/library%2Falloc%2Fsrc%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fmod.rs?ref=996ff2e0a0f911f52bb1de6bdd0cfd5704de1fc9", "patch": "@@ -58,7 +58,31 @@ use core::fmt::Display;\n /// The error type for `try_reserve` methods.\n #[derive(Clone, PartialEq, Eq, Debug)]\n #[unstable(feature = \"try_reserve\", reason = \"new API\", issue = \"48043\")]\n-pub enum TryReserveError {\n+pub struct TryReserveError {\n+    kind: TryReserveErrorKind,\n+}\n+\n+impl TryReserveError {\n+    /// Details about the allocation that caused the error\n+    #[inline]\n+    #[unstable(\n+        feature = \"try_reserve_kind\",\n+        reason = \"Uncertain how much info should be exposed\",\n+        issue = \"48043\"\n+    )]\n+    pub fn kind(&self) -> TryReserveErrorKind {\n+        self.kind.clone()\n+    }\n+}\n+\n+/// Details of the allocation that caused a `TryReserveError`\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+#[unstable(\n+    feature = \"try_reserve_kind\",\n+    reason = \"Uncertain how much info should be exposed\",\n+    issue = \"48043\"\n+)]\n+pub enum TryReserveErrorKind {\n     /// Error due to the computed capacity exceeding the collection's maximum\n     /// (usually `isize::MAX` bytes).\n     CapacityOverflow,\n@@ -81,12 +105,23 @@ pub enum TryReserveError {\n     },\n }\n \n+#[unstable(\n+    feature = \"try_reserve_kind\",\n+    reason = \"Uncertain how much info should be exposed\",\n+    issue = \"48043\"\n+)]\n+impl From<TryReserveErrorKind> for TryReserveError {\n+    fn from(kind: TryReserveErrorKind) -> Self {\n+        Self { kind }\n+    }\n+}\n+\n #[unstable(feature = \"try_reserve\", reason = \"new API\", issue = \"48043\")]\n impl From<LayoutError> for TryReserveError {\n-    /// Always evaluates to [`TryReserveError::CapacityOverflow`].\n+    /// Always evaluates to [`TryReserveErrorKind::CapacityOverflow`].\n     #[inline]\n     fn from(_: LayoutError) -> Self {\n-        TryReserveError::CapacityOverflow\n+        TryReserveErrorKind::CapacityOverflow.into()\n     }\n }\n \n@@ -97,11 +132,13 @@ impl Display for TryReserveError {\n         fmt: &mut core::fmt::Formatter<'_>,\n     ) -> core::result::Result<(), core::fmt::Error> {\n         fmt.write_str(\"memory allocation failed\")?;\n-        let reason = match &self {\n-            TryReserveError::CapacityOverflow => {\n+        let reason = match self.kind {\n+            TryReserveErrorKind::CapacityOverflow => {\n                 \" because the computed capacity exceeded the collection's maximum\"\n             }\n-            TryReserveError::AllocError { .. } => \" because the memory allocator returned a error\",\n+            TryReserveErrorKind::AllocError { .. } => {\n+                \" because the memory allocator returned a error\"\n+            }\n         };\n         fmt.write_str(reason)\n     }"}, {"sha": "bea5cf11be5e8da7ae83dfb45a92ed109d63f865", "filename": "library/alloc/src/collections/vec_deque/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/996ff2e0a0f911f52bb1de6bdd0cfd5704de1fc9/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/996ff2e0a0f911f52bb1de6bdd0cfd5704de1fc9/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs?ref=996ff2e0a0f911f52bb1de6bdd0cfd5704de1fc9", "patch": "@@ -19,6 +19,7 @@ use core::slice;\n \n use crate::alloc::{Allocator, Global};\n use crate::collections::TryReserveError;\n+use crate::collections::TryReserveErrorKind;\n use crate::raw_vec::RawVec;\n use crate::vec::Vec;\n \n@@ -773,7 +774,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         let new_cap = used_cap\n             .checked_add(additional)\n             .and_then(|needed_cap| needed_cap.checked_next_power_of_two())\n-            .ok_or(TryReserveError::CapacityOverflow)?;\n+            .ok_or(TryReserveErrorKind::CapacityOverflow)?;\n \n         if new_cap > old_cap {\n             self.buf.try_reserve_exact(used_cap, new_cap - used_cap)?;"}, {"sha": "3caada06f6b58d33128685ea8fb0ca32184c3b4f", "filename": "library/alloc/src/raw_vec.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/996ff2e0a0f911f52bb1de6bdd0cfd5704de1fc9/library%2Falloc%2Fsrc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/996ff2e0a0f911f52bb1de6bdd0cfd5704de1fc9/library%2Falloc%2Fsrc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fraw_vec.rs?ref=996ff2e0a0f911f52bb1de6bdd0cfd5704de1fc9", "patch": "@@ -13,7 +13,8 @@ use core::slice;\n use crate::alloc::handle_alloc_error;\n use crate::alloc::{Allocator, Global, Layout};\n use crate::boxed::Box;\n-use crate::collections::TryReserveError::{self, *};\n+use crate::collections::TryReserveError;\n+use crate::collections::TryReserveErrorKind::*;\n \n #[cfg(test)]\n mod tests;\n@@ -425,7 +426,7 @@ impl<T, A: Allocator> RawVec<T, A> {\n         if mem::size_of::<T>() == 0 {\n             // Since we return a capacity of `usize::MAX` when `elem_size` is\n             // 0, getting to here necessarily means the `RawVec` is overfull.\n-            return Err(CapacityOverflow);\n+            return Err(CapacityOverflow.into());\n         }\n \n         // Nothing we can really do about these checks, sadly.\n@@ -451,7 +452,7 @@ impl<T, A: Allocator> RawVec<T, A> {\n         if mem::size_of::<T>() == 0 {\n             // Since we return a capacity of `usize::MAX` when the type size is\n             // 0, getting to here necessarily means the `RawVec` is overfull.\n-            return Err(CapacityOverflow);\n+            return Err(CapacityOverflow.into());\n         }\n \n         let cap = len.checked_add(additional).ok_or(CapacityOverflow)?;\n@@ -471,10 +472,9 @@ impl<T, A: Allocator> RawVec<T, A> {\n \n         let ptr = unsafe {\n             let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n-            self.alloc.shrink(ptr, layout, new_layout).map_err(|_| TryReserveError::AllocError {\n-                layout: new_layout,\n-                non_exhaustive: (),\n-            })?\n+            self.alloc\n+                .shrink(ptr, layout, new_layout)\n+                .map_err(|_| AllocError { layout: new_layout, non_exhaustive: () })?\n         };\n         self.set_ptr(ptr);\n         Ok(())\n@@ -510,7 +510,7 @@ where\n         alloc.allocate(new_layout)\n     };\n \n-    memory.map_err(|_| AllocError { layout: new_layout, non_exhaustive: () })\n+    memory.map_err(|_| AllocError { layout: new_layout, non_exhaustive: () }.into())\n }\n \n unsafe impl<#[may_dangle] T, A: Allocator> Drop for RawVec<T, A> {\n@@ -526,7 +526,7 @@ unsafe impl<#[may_dangle] T, A: Allocator> Drop for RawVec<T, A> {\n #[cfg(not(no_global_oom_handling))]\n #[inline]\n fn handle_reserve(result: Result<(), TryReserveError>) {\n-    match result {\n+    match result.map_err(|e| e.kind()) {\n         Err(CapacityOverflow) => capacity_overflow(),\n         Err(AllocError { layout, .. }) => handle_alloc_error(layout),\n         Ok(()) => { /* yay */ }\n@@ -545,7 +545,7 @@ fn handle_reserve(result: Result<(), TryReserveError>) {\n #[inline]\n fn alloc_guard(alloc_size: usize) -> Result<(), TryReserveError> {\n     if usize::BITS < 64 && alloc_size > isize::MAX as usize {\n-        Err(CapacityOverflow)\n+        Err(CapacityOverflow.into())\n     } else {\n         Ok(())\n     }"}, {"sha": "b3e048a6587b9aa020ccf3e04ec354bcfa0940ce", "filename": "library/alloc/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/996ff2e0a0f911f52bb1de6bdd0cfd5704de1fc9/library%2Falloc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/996ff2e0a0f911f52bb1de6bdd0cfd5704de1fc9/library%2Falloc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Flib.rs?ref=996ff2e0a0f911f52bb1de6bdd0cfd5704de1fc9", "patch": "@@ -8,6 +8,7 @@\n #![feature(pattern)]\n #![feature(trusted_len)]\n #![feature(try_reserve)]\n+#![feature(try_reserve_kind)]\n #![feature(unboxed_closures)]\n #![feature(associated_type_bounds)]\n #![feature(binary_heap_into_iter_sorted)]"}, {"sha": "cf9d734a9d54ddee3f1d7d1ec0e0ef1f1cae7da0", "filename": "library/alloc/tests/string.rs", "status": "modified", "additions": 51, "deletions": 23, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/996ff2e0a0f911f52bb1de6bdd0cfd5704de1fc9/library%2Falloc%2Ftests%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/996ff2e0a0f911f52bb1de6bdd0cfd5704de1fc9/library%2Falloc%2Ftests%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fstring.rs?ref=996ff2e0a0f911f52bb1de6bdd0cfd5704de1fc9", "patch": "@@ -1,6 +1,6 @@\n use std::borrow::Cow;\n use std::cell::Cell;\n-use std::collections::TryReserveError::*;\n+use std::collections::TryReserveErrorKind::*;\n use std::ops::Bound;\n use std::ops::Bound::*;\n use std::ops::RangeBounds;\n@@ -703,35 +703,42 @@ fn test_try_reserve() {\n         let mut empty_string: String = String::new();\n \n         // Check isize::MAX doesn't count as an overflow\n-        if let Err(CapacityOverflow) = empty_string.try_reserve(MAX_CAP) {\n+        if let Err(CapacityOverflow) = empty_string.try_reserve(MAX_CAP).map_err(|e| e.kind()) {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n         // Play it again, frank! (just to be sure)\n-        if let Err(CapacityOverflow) = empty_string.try_reserve(MAX_CAP) {\n+        if let Err(CapacityOverflow) = empty_string.try_reserve(MAX_CAP).map_err(|e| e.kind()) {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n \n         if guards_against_isize {\n             // Check isize::MAX + 1 does count as overflow\n-            if let Err(CapacityOverflow) = empty_string.try_reserve(MAX_CAP + 1) {\n+            if let Err(CapacityOverflow) =\n+                empty_string.try_reserve(MAX_CAP + 1).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"isize::MAX + 1 should trigger an overflow!\")\n             }\n \n             // Check usize::MAX does count as overflow\n-            if let Err(CapacityOverflow) = empty_string.try_reserve(MAX_USIZE) {\n+            if let Err(CapacityOverflow) = empty_string.try_reserve(MAX_USIZE).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"usize::MAX should trigger an overflow!\")\n             }\n         } else {\n             // Check isize::MAX + 1 is an OOM\n-            if let Err(AllocError { .. }) = empty_string.try_reserve(MAX_CAP + 1) {\n+            if let Err(AllocError { .. }) =\n+                empty_string.try_reserve(MAX_CAP + 1).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"isize::MAX + 1 should trigger an OOM!\")\n             }\n \n             // Check usize::MAX is an OOM\n-            if let Err(AllocError { .. }) = empty_string.try_reserve(MAX_USIZE) {\n+            if let Err(AllocError { .. }) =\n+                empty_string.try_reserve(MAX_USIZE).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"usize::MAX should trigger an OOM!\")\n             }\n@@ -742,25 +749,27 @@ fn test_try_reserve() {\n         // Same basic idea, but with non-zero len\n         let mut ten_bytes: String = String::from(\"0123456789\");\n \n-        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 10) {\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 10).map_err(|e| e.kind()) {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n-        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 10) {\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 10).map_err(|e| e.kind()) {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n         if guards_against_isize {\n-            if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 9) {\n+            if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 9).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"isize::MAX + 1 should trigger an overflow!\");\n             }\n         } else {\n-            if let Err(AllocError { .. }) = ten_bytes.try_reserve(MAX_CAP - 9) {\n+            if let Err(AllocError { .. }) = ten_bytes.try_reserve(MAX_CAP - 9).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"isize::MAX + 1 should trigger an OOM!\")\n             }\n         }\n         // Should always overflow in the add-to-len\n-        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_USIZE) {\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_USIZE).map_err(|e| e.kind()) {\n         } else {\n             panic!(\"usize::MAX should trigger an overflow!\")\n         }\n@@ -782,30 +791,40 @@ fn test_try_reserve_exact() {\n     {\n         let mut empty_string: String = String::new();\n \n-        if let Err(CapacityOverflow) = empty_string.try_reserve_exact(MAX_CAP) {\n+        if let Err(CapacityOverflow) = empty_string.try_reserve_exact(MAX_CAP).map_err(|e| e.kind())\n+        {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n-        if let Err(CapacityOverflow) = empty_string.try_reserve_exact(MAX_CAP) {\n+        if let Err(CapacityOverflow) = empty_string.try_reserve_exact(MAX_CAP).map_err(|e| e.kind())\n+        {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n \n         if guards_against_isize {\n-            if let Err(CapacityOverflow) = empty_string.try_reserve_exact(MAX_CAP + 1) {\n+            if let Err(CapacityOverflow) =\n+                empty_string.try_reserve_exact(MAX_CAP + 1).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"isize::MAX + 1 should trigger an overflow!\")\n             }\n \n-            if let Err(CapacityOverflow) = empty_string.try_reserve_exact(MAX_USIZE) {\n+            if let Err(CapacityOverflow) =\n+                empty_string.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"usize::MAX should trigger an overflow!\")\n             }\n         } else {\n-            if let Err(AllocError { .. }) = empty_string.try_reserve_exact(MAX_CAP + 1) {\n+            if let Err(AllocError { .. }) =\n+                empty_string.try_reserve_exact(MAX_CAP + 1).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"isize::MAX + 1 should trigger an OOM!\")\n             }\n \n-            if let Err(AllocError { .. }) = empty_string.try_reserve_exact(MAX_USIZE) {\n+            if let Err(AllocError { .. }) =\n+                empty_string.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"usize::MAX should trigger an OOM!\")\n             }\n@@ -815,24 +834,33 @@ fn test_try_reserve_exact() {\n     {\n         let mut ten_bytes: String = String::from(\"0123456789\");\n \n-        if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 10) {\n+        if let Err(CapacityOverflow) =\n+            ten_bytes.try_reserve_exact(MAX_CAP - 10).map_err(|e| e.kind())\n+        {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n-        if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 10) {\n+        if let Err(CapacityOverflow) =\n+            ten_bytes.try_reserve_exact(MAX_CAP - 10).map_err(|e| e.kind())\n+        {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n         if guards_against_isize {\n-            if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n+            if let Err(CapacityOverflow) =\n+                ten_bytes.try_reserve_exact(MAX_CAP - 9).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"isize::MAX + 1 should trigger an overflow!\");\n             }\n         } else {\n-            if let Err(AllocError { .. }) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n+            if let Err(AllocError { .. }) =\n+                ten_bytes.try_reserve_exact(MAX_CAP - 9).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"isize::MAX + 1 should trigger an OOM!\")\n             }\n         }\n-        if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_USIZE) {\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind())\n+        {\n         } else {\n             panic!(\"usize::MAX should trigger an overflow!\")\n         }"}, {"sha": "d3a6dcfddc5270f8bdea31709c7dd6d1e6b5a233", "filename": "library/alloc/tests/vec.rs", "status": "modified", "additions": 76, "deletions": 33, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/996ff2e0a0f911f52bb1de6bdd0cfd5704de1fc9/library%2Falloc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/996ff2e0a0f911f52bb1de6bdd0cfd5704de1fc9/library%2Falloc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fvec.rs?ref=996ff2e0a0f911f52bb1de6bdd0cfd5704de1fc9", "patch": "@@ -1,6 +1,6 @@\n use std::borrow::Cow;\n use std::cell::Cell;\n-use std::collections::TryReserveError::*;\n+use std::collections::TryReserveErrorKind::*;\n use std::fmt::Debug;\n use std::iter::InPlaceIterable;\n use std::mem::{size_of, swap};\n@@ -1478,35 +1478,41 @@ fn test_try_reserve() {\n         let mut empty_bytes: Vec<u8> = Vec::new();\n \n         // Check isize::MAX doesn't count as an overflow\n-        if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_CAP) {\n+        if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_CAP).map_err(|e| e.kind()) {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n         // Play it again, frank! (just to be sure)\n-        if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_CAP) {\n+        if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_CAP).map_err(|e| e.kind()) {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n \n         if guards_against_isize {\n             // Check isize::MAX + 1 does count as overflow\n-            if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_CAP + 1) {\n+            if let Err(CapacityOverflow) =\n+                empty_bytes.try_reserve(MAX_CAP + 1).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"isize::MAX + 1 should trigger an overflow!\")\n             }\n \n             // Check usize::MAX does count as overflow\n-            if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_USIZE) {\n+            if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_USIZE).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"usize::MAX should trigger an overflow!\")\n             }\n         } else {\n             // Check isize::MAX + 1 is an OOM\n-            if let Err(AllocError { .. }) = empty_bytes.try_reserve(MAX_CAP + 1) {\n+            if let Err(AllocError { .. }) =\n+                empty_bytes.try_reserve(MAX_CAP + 1).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"isize::MAX + 1 should trigger an OOM!\")\n             }\n \n             // Check usize::MAX is an OOM\n-            if let Err(AllocError { .. }) = empty_bytes.try_reserve(MAX_USIZE) {\n+            if let Err(AllocError { .. }) = empty_bytes.try_reserve(MAX_USIZE).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"usize::MAX should trigger an OOM!\")\n             }\n@@ -1517,25 +1523,27 @@ fn test_try_reserve() {\n         // Same basic idea, but with non-zero len\n         let mut ten_bytes: Vec<u8> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n \n-        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 10) {\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 10).map_err(|e| e.kind()) {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n-        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 10) {\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 10).map_err(|e| e.kind()) {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n         if guards_against_isize {\n-            if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 9) {\n+            if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 9).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"isize::MAX + 1 should trigger an overflow!\");\n             }\n         } else {\n-            if let Err(AllocError { .. }) = ten_bytes.try_reserve(MAX_CAP - 9) {\n+            if let Err(AllocError { .. }) = ten_bytes.try_reserve(MAX_CAP - 9).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"isize::MAX + 1 should trigger an OOM!\")\n             }\n         }\n         // Should always overflow in the add-to-len\n-        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_USIZE) {\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_USIZE).map_err(|e| e.kind()) {\n         } else {\n             panic!(\"usize::MAX should trigger an overflow!\")\n         }\n@@ -1545,25 +1553,31 @@ fn test_try_reserve() {\n         // Same basic idea, but with interesting type size\n         let mut ten_u32s: Vec<u32> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n \n-        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP / 4 - 10) {\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP / 4 - 10).map_err(|e| e.kind())\n+        {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n-        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP / 4 - 10) {\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP / 4 - 10).map_err(|e| e.kind())\n+        {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n         if guards_against_isize {\n-            if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP / 4 - 9) {\n+            if let Err(CapacityOverflow) =\n+                ten_u32s.try_reserve(MAX_CAP / 4 - 9).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"isize::MAX + 1 should trigger an overflow!\");\n             }\n         } else {\n-            if let Err(AllocError { .. }) = ten_u32s.try_reserve(MAX_CAP / 4 - 9) {\n+            if let Err(AllocError { .. }) =\n+                ten_u32s.try_reserve(MAX_CAP / 4 - 9).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"isize::MAX + 1 should trigger an OOM!\")\n             }\n         }\n         // Should fail in the mul-by-size\n-        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_USIZE - 20) {\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_USIZE - 20).map_err(|e| e.kind()) {\n         } else {\n             panic!(\"usize::MAX should trigger an overflow!\");\n         }\n@@ -1585,30 +1599,40 @@ fn test_try_reserve_exact() {\n     {\n         let mut empty_bytes: Vec<u8> = Vec::new();\n \n-        if let Err(CapacityOverflow) = empty_bytes.try_reserve_exact(MAX_CAP) {\n+        if let Err(CapacityOverflow) = empty_bytes.try_reserve_exact(MAX_CAP).map_err(|e| e.kind())\n+        {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n-        if let Err(CapacityOverflow) = empty_bytes.try_reserve_exact(MAX_CAP) {\n+        if let Err(CapacityOverflow) = empty_bytes.try_reserve_exact(MAX_CAP).map_err(|e| e.kind())\n+        {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n \n         if guards_against_isize {\n-            if let Err(CapacityOverflow) = empty_bytes.try_reserve_exact(MAX_CAP + 1) {\n+            if let Err(CapacityOverflow) =\n+                empty_bytes.try_reserve_exact(MAX_CAP + 1).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"isize::MAX + 1 should trigger an overflow!\")\n             }\n \n-            if let Err(CapacityOverflow) = empty_bytes.try_reserve_exact(MAX_USIZE) {\n+            if let Err(CapacityOverflow) =\n+                empty_bytes.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"usize::MAX should trigger an overflow!\")\n             }\n         } else {\n-            if let Err(AllocError { .. }) = empty_bytes.try_reserve_exact(MAX_CAP + 1) {\n+            if let Err(AllocError { .. }) =\n+                empty_bytes.try_reserve_exact(MAX_CAP + 1).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"isize::MAX + 1 should trigger an OOM!\")\n             }\n \n-            if let Err(AllocError { .. }) = empty_bytes.try_reserve_exact(MAX_USIZE) {\n+            if let Err(AllocError { .. }) =\n+                empty_bytes.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"usize::MAX should trigger an OOM!\")\n             }\n@@ -1618,24 +1642,33 @@ fn test_try_reserve_exact() {\n     {\n         let mut ten_bytes: Vec<u8> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n \n-        if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 10) {\n+        if let Err(CapacityOverflow) =\n+            ten_bytes.try_reserve_exact(MAX_CAP - 10).map_err(|e| e.kind())\n+        {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n-        if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 10) {\n+        if let Err(CapacityOverflow) =\n+            ten_bytes.try_reserve_exact(MAX_CAP - 10).map_err(|e| e.kind())\n+        {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n         if guards_against_isize {\n-            if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n+            if let Err(CapacityOverflow) =\n+                ten_bytes.try_reserve_exact(MAX_CAP - 9).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"isize::MAX + 1 should trigger an overflow!\");\n             }\n         } else {\n-            if let Err(AllocError { .. }) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n+            if let Err(AllocError { .. }) =\n+                ten_bytes.try_reserve_exact(MAX_CAP - 9).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"isize::MAX + 1 should trigger an OOM!\")\n             }\n         }\n-        if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_USIZE) {\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind())\n+        {\n         } else {\n             panic!(\"usize::MAX should trigger an overflow!\")\n         }\n@@ -1644,24 +1677,34 @@ fn test_try_reserve_exact() {\n     {\n         let mut ten_u32s: Vec<u32> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n \n-        if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP / 4 - 10) {\n+        if let Err(CapacityOverflow) =\n+            ten_u32s.try_reserve_exact(MAX_CAP / 4 - 10).map_err(|e| e.kind())\n+        {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n-        if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP / 4 - 10) {\n+        if let Err(CapacityOverflow) =\n+            ten_u32s.try_reserve_exact(MAX_CAP / 4 - 10).map_err(|e| e.kind())\n+        {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n         if guards_against_isize {\n-            if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP / 4 - 9) {\n+            if let Err(CapacityOverflow) =\n+                ten_u32s.try_reserve_exact(MAX_CAP / 4 - 9).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"isize::MAX + 1 should trigger an overflow!\");\n             }\n         } else {\n-            if let Err(AllocError { .. }) = ten_u32s.try_reserve_exact(MAX_CAP / 4 - 9) {\n+            if let Err(AllocError { .. }) =\n+                ten_u32s.try_reserve_exact(MAX_CAP / 4 - 9).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"isize::MAX + 1 should trigger an OOM!\")\n             }\n         }\n-        if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_USIZE - 20) {\n+        if let Err(CapacityOverflow) =\n+            ten_u32s.try_reserve_exact(MAX_USIZE - 20).map_err(|e| e.kind())\n+        {\n         } else {\n             panic!(\"usize::MAX should trigger an overflow!\")\n         }"}, {"sha": "e9fd19d76ea43f293df52f574b58fb54bde41472", "filename": "library/alloc/tests/vec_deque.rs", "status": "modified", "additions": 69, "deletions": 31, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/996ff2e0a0f911f52bb1de6bdd0cfd5704de1fc9/library%2Falloc%2Ftests%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/996ff2e0a0f911f52bb1de6bdd0cfd5704de1fc9/library%2Falloc%2Ftests%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fvec_deque.rs?ref=996ff2e0a0f911f52bb1de6bdd0cfd5704de1fc9", "patch": "@@ -1,4 +1,4 @@\n-use std::collections::TryReserveError::*;\n+use std::collections::TryReserveErrorKind::*;\n use std::collections::{vec_deque::Drain, VecDeque};\n use std::fmt::Debug;\n use std::mem::size_of;\n@@ -1171,23 +1171,26 @@ fn test_try_reserve() {\n         let mut empty_bytes: VecDeque<u8> = VecDeque::new();\n \n         // Check isize::MAX doesn't count as an overflow\n-        if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_CAP) {\n+        if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_CAP).map_err(|e| e.kind()) {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n         // Play it again, frank! (just to be sure)\n-        if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_CAP) {\n+        if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_CAP).map_err(|e| e.kind()) {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n \n         if guards_against_isize {\n             // Check isize::MAX + 1 does count as overflow\n-            if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_CAP + 1) {\n+            if let Err(CapacityOverflow) =\n+                empty_bytes.try_reserve(MAX_CAP + 1).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"isize::MAX + 1 should trigger an overflow!\")\n             }\n \n             // Check usize::MAX does count as overflow\n-            if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_USIZE) {\n+            if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_USIZE).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"usize::MAX should trigger an overflow!\")\n             }\n@@ -1196,7 +1199,7 @@ fn test_try_reserve() {\n             // VecDeque starts with capacity 7, always adds 1 to the capacity\n             // and also rounds the number to next power of 2 so this is the\n             // furthest we can go without triggering CapacityOverflow\n-            if let Err(AllocError { .. }) = empty_bytes.try_reserve(MAX_CAP) {\n+            if let Err(AllocError { .. }) = empty_bytes.try_reserve(MAX_CAP).map_err(|e| e.kind()) {\n             } else {\n                 panic!(\"isize::MAX + 1 should trigger an OOM!\")\n             }\n@@ -1207,25 +1210,27 @@ fn test_try_reserve() {\n         // Same basic idea, but with non-zero len\n         let mut ten_bytes: VecDeque<u8> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10].into_iter().collect();\n \n-        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 10) {\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 10).map_err(|e| e.kind()) {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n-        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 10) {\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 10).map_err(|e| e.kind()) {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n         if guards_against_isize {\n-            if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 9) {\n+            if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 9).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"isize::MAX + 1 should trigger an overflow!\");\n             }\n         } else {\n-            if let Err(AllocError { .. }) = ten_bytes.try_reserve(MAX_CAP - 9) {\n+            if let Err(AllocError { .. }) = ten_bytes.try_reserve(MAX_CAP - 9).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"isize::MAX + 1 should trigger an OOM!\")\n             }\n         }\n         // Should always overflow in the add-to-len\n-        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_USIZE) {\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_USIZE).map_err(|e| e.kind()) {\n         } else {\n             panic!(\"usize::MAX should trigger an overflow!\")\n         }\n@@ -1235,25 +1240,31 @@ fn test_try_reserve() {\n         // Same basic idea, but with interesting type size\n         let mut ten_u32s: VecDeque<u32> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10].into_iter().collect();\n \n-        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP / 4 - 10) {\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP / 4 - 10).map_err(|e| e.kind())\n+        {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n-        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP / 4 - 10) {\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP / 4 - 10).map_err(|e| e.kind())\n+        {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n         if guards_against_isize {\n-            if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP / 4 - 9) {\n+            if let Err(CapacityOverflow) =\n+                ten_u32s.try_reserve(MAX_CAP / 4 - 9).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"isize::MAX + 1 should trigger an overflow!\");\n             }\n         } else {\n-            if let Err(AllocError { .. }) = ten_u32s.try_reserve(MAX_CAP / 4 - 9) {\n+            if let Err(AllocError { .. }) =\n+                ten_u32s.try_reserve(MAX_CAP / 4 - 9).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"isize::MAX + 1 should trigger an OOM!\")\n             }\n         }\n         // Should fail in the mul-by-size\n-        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_USIZE - 20) {\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_USIZE - 20).map_err(|e| e.kind()) {\n         } else {\n             panic!(\"usize::MAX should trigger an overflow!\");\n         }\n@@ -1275,20 +1286,26 @@ fn test_try_reserve_exact() {\n     {\n         let mut empty_bytes: VecDeque<u8> = VecDeque::new();\n \n-        if let Err(CapacityOverflow) = empty_bytes.try_reserve_exact(MAX_CAP) {\n+        if let Err(CapacityOverflow) = empty_bytes.try_reserve_exact(MAX_CAP).map_err(|e| e.kind())\n+        {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n-        if let Err(CapacityOverflow) = empty_bytes.try_reserve_exact(MAX_CAP) {\n+        if let Err(CapacityOverflow) = empty_bytes.try_reserve_exact(MAX_CAP).map_err(|e| e.kind())\n+        {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n \n         if guards_against_isize {\n-            if let Err(CapacityOverflow) = empty_bytes.try_reserve_exact(MAX_CAP + 1) {\n+            if let Err(CapacityOverflow) =\n+                empty_bytes.try_reserve_exact(MAX_CAP + 1).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"isize::MAX + 1 should trigger an overflow!\")\n             }\n \n-            if let Err(CapacityOverflow) = empty_bytes.try_reserve_exact(MAX_USIZE) {\n+            if let Err(CapacityOverflow) =\n+                empty_bytes.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"usize::MAX should trigger an overflow!\")\n             }\n@@ -1297,7 +1314,9 @@ fn test_try_reserve_exact() {\n             // VecDeque starts with capacity 7, always adds 1 to the capacity\n             // and also rounds the number to next power of 2 so this is the\n             // furthest we can go without triggering CapacityOverflow\n-            if let Err(AllocError { .. }) = empty_bytes.try_reserve_exact(MAX_CAP) {\n+            if let Err(AllocError { .. }) =\n+                empty_bytes.try_reserve_exact(MAX_CAP).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"isize::MAX + 1 should trigger an OOM!\")\n             }\n@@ -1307,24 +1326,33 @@ fn test_try_reserve_exact() {\n     {\n         let mut ten_bytes: VecDeque<u8> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10].into_iter().collect();\n \n-        if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 10) {\n+        if let Err(CapacityOverflow) =\n+            ten_bytes.try_reserve_exact(MAX_CAP - 10).map_err(|e| e.kind())\n+        {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n-        if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 10) {\n+        if let Err(CapacityOverflow) =\n+            ten_bytes.try_reserve_exact(MAX_CAP - 10).map_err(|e| e.kind())\n+        {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n         if guards_against_isize {\n-            if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n+            if let Err(CapacityOverflow) =\n+                ten_bytes.try_reserve_exact(MAX_CAP - 9).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"isize::MAX + 1 should trigger an overflow!\");\n             }\n         } else {\n-            if let Err(AllocError { .. }) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n+            if let Err(AllocError { .. }) =\n+                ten_bytes.try_reserve_exact(MAX_CAP - 9).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"isize::MAX + 1 should trigger an OOM!\")\n             }\n         }\n-        if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_USIZE) {\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind())\n+        {\n         } else {\n             panic!(\"usize::MAX should trigger an overflow!\")\n         }\n@@ -1333,24 +1361,34 @@ fn test_try_reserve_exact() {\n     {\n         let mut ten_u32s: VecDeque<u32> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10].into_iter().collect();\n \n-        if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP / 4 - 10) {\n+        if let Err(CapacityOverflow) =\n+            ten_u32s.try_reserve_exact(MAX_CAP / 4 - 10).map_err(|e| e.kind())\n+        {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n-        if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP / 4 - 10) {\n+        if let Err(CapacityOverflow) =\n+            ten_u32s.try_reserve_exact(MAX_CAP / 4 - 10).map_err(|e| e.kind())\n+        {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n         if guards_against_isize {\n-            if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP / 4 - 9) {\n+            if let Err(CapacityOverflow) =\n+                ten_u32s.try_reserve_exact(MAX_CAP / 4 - 9).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"isize::MAX + 1 should trigger an overflow!\");\n             }\n         } else {\n-            if let Err(AllocError { .. }) = ten_u32s.try_reserve_exact(MAX_CAP / 4 - 9) {\n+            if let Err(AllocError { .. }) =\n+                ten_u32s.try_reserve_exact(MAX_CAP / 4 - 9).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"isize::MAX + 1 should trigger an OOM!\")\n             }\n         }\n-        if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_USIZE - 20) {\n+        if let Err(CapacityOverflow) =\n+            ten_u32s.try_reserve_exact(MAX_USIZE - 20).map_err(|e| e.kind())\n+        {\n         } else {\n             panic!(\"usize::MAX should trigger an overflow!\")\n         }"}, {"sha": "941708429b98587210ebcddc0b89c69eff4c9a11", "filename": "library/std/src/collections/hash/map.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/996ff2e0a0f911f52bb1de6bdd0cfd5704de1fc9/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/996ff2e0a0f911f52bb1de6bdd0cfd5704de1fc9/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs?ref=996ff2e0a0f911f52bb1de6bdd0cfd5704de1fc9", "patch": "@@ -8,6 +8,7 @@ use hashbrown::hash_map as base;\n use crate::borrow::Borrow;\n use crate::cell::Cell;\n use crate::collections::TryReserveError;\n+use crate::collections::TryReserveErrorKind;\n use crate::fmt::{self, Debug};\n #[allow(deprecated)]\n use crate::hash::{BuildHasher, Hash, Hasher, SipHasher13};\n@@ -2990,9 +2991,11 @@ fn map_entry<'a, K: 'a, V: 'a>(raw: base::RustcEntry<'a, K, V>) -> Entry<'a, K,\n #[inline]\n pub(super) fn map_try_reserve_error(err: hashbrown::TryReserveError) -> TryReserveError {\n     match err {\n-        hashbrown::TryReserveError::CapacityOverflow => TryReserveError::CapacityOverflow,\n+        hashbrown::TryReserveError::CapacityOverflow => {\n+            TryReserveErrorKind::CapacityOverflow.into()\n+        }\n         hashbrown::TryReserveError::AllocError { layout } => {\n-            TryReserveError::AllocError { layout, non_exhaustive: () }\n+            TryReserveErrorKind::AllocError { layout, non_exhaustive: () }.into()\n         }\n     }\n }"}, {"sha": "18d868d49a634e3e1204e05c33fbe6d256851cc2", "filename": "library/std/src/collections/hash/map/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/996ff2e0a0f911f52bb1de6bdd0cfd5704de1fc9/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/996ff2e0a0f911f52bb1de6bdd0cfd5704de1fc9/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap%2Ftests.rs?ref=996ff2e0a0f911f52bb1de6bdd0cfd5704de1fc9", "patch": "@@ -3,7 +3,7 @@ use super::HashMap;\n use super::RandomState;\n use crate::cell::RefCell;\n use rand::{thread_rng, Rng};\n-use realstd::collections::TryReserveError::*;\n+use realstd::collections::TryReserveErrorKind::*;\n \n // https://github.com/rust-lang/rust/issues/62301\n fn _assert_hashmap_is_unwind_safe() {\n@@ -821,12 +821,12 @@ fn test_try_reserve() {\n \n     const MAX_USIZE: usize = usize::MAX;\n \n-    if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_USIZE) {\n+    if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_USIZE).map_err(|e| e.kind()) {\n     } else {\n         panic!(\"usize::MAX should trigger an overflow!\");\n     }\n \n-    if let Err(AllocError { .. }) = empty_bytes.try_reserve(MAX_USIZE / 8) {\n+    if let Err(AllocError { .. }) = empty_bytes.try_reserve(MAX_USIZE / 8).map_err(|e| e.kind()) {\n     } else {\n         panic!(\"usize::MAX / 8 should trigger an OOM!\")\n     }"}, {"sha": "130bb5cb2b3c2b77f6b7402330dd2ded199be0f7", "filename": "library/std/src/collections/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/996ff2e0a0f911f52bb1de6bdd0cfd5704de1fc9/library%2Fstd%2Fsrc%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/996ff2e0a0f911f52bb1de6bdd0cfd5704de1fc9/library%2Fstd%2Fsrc%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fmod.rs?ref=996ff2e0a0f911f52bb1de6bdd0cfd5704de1fc9", "patch": "@@ -422,6 +422,12 @@ pub use self::hash_set::HashSet;\n \n #[unstable(feature = \"try_reserve\", reason = \"new API\", issue = \"48043\")]\n pub use alloc_crate::collections::TryReserveError;\n+#[unstable(\n+    feature = \"try_reserve_kind\",\n+    reason = \"Uncertain how much info should be exposed\",\n+    issue = \"48043\"\n+)]\n+pub use alloc_crate::collections::TryReserveErrorKind;\n \n mod hash;\n "}, {"sha": "1af6157ca68bfb98ec5426f61223f3eb6e815032", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/996ff2e0a0f911f52bb1de6bdd0cfd5704de1fc9/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/996ff2e0a0f911f52bb1de6bdd0cfd5704de1fc9/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=996ff2e0a0f911f52bb1de6bdd0cfd5704de1fc9", "patch": "@@ -326,6 +326,7 @@\n #![feature(trace_macros)]\n #![feature(try_blocks)]\n #![feature(try_reserve)]\n+#![feature(try_reserve_kind)]\n #![feature(unboxed_closures)]\n #![feature(unsafe_cell_raw_get)]\n #![feature(unwrap_infallible)]"}]}