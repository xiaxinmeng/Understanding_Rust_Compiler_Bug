{"sha": "c5f7c19cf274f510b48d6835f5677ae22e978d6d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1ZjdjMTljZjI3NGY1MTBiNDhkNjgzNWY1Njc3YWUyMmU5NzhkNmQ=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2015-07-14T13:37:52Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2015-07-14T13:37:52Z"}, "message": "End of error code spanning centralization", "tree": {"sha": "aa4e03fb9432f6a24c96bb20e645ad0f5a112d03", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa4e03fb9432f6a24c96bb20e645ad0f5a112d03"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c5f7c19cf274f510b48d6835f5677ae22e978d6d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c5f7c19cf274f510b48d6835f5677ae22e978d6d", "html_url": "https://github.com/rust-lang/rust/commit/c5f7c19cf274f510b48d6835f5677ae22e978d6d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c5f7c19cf274f510b48d6835f5677ae22e978d6d/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f52a87c44e84a0089819e77ad85ea24b88d547e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/f52a87c44e84a0089819e77ad85ea24b88d547e7", "html_url": "https://github.com/rust-lang/rust/commit/f52a87c44e84a0089819e77ad85ea24b88d547e7"}], "stats": {"total": 619, "additions": 430, "deletions": 189}, "files": [{"sha": "782e0a3660b330b677d1b0471ed7deca9316be8f", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c5f7c19cf274f510b48d6835f5677ae22e978d6d/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5f7c19cf274f510b48d6835f5677ae22e978d6d/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=c5f7c19cf274f510b48d6835f5677ae22e978d6d", "patch": "@@ -208,10 +208,13 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                     // Return an error here by looking up the namespace that\n                     // had the duplicate.\n                     let ns = ns.unwrap();\n-                    resolve_err!(self, sp, E0428,\n-                                 \"duplicate definition of {} `{}`\",\n-                                 namespace_error_to_string(duplicate_type),\n-                                 token::get_name(name));\n+                    ::resolve_error(\n+                        &::ResolutionError::DuplicateDefinition(\n+                            self,\n+                            sp,\n+                            namespace_error_to_string(duplicate_type),\n+                            &*token::get_name(name))\n+                    );\n                     {\n                         let r = child.span_for_namespace(ns);\n                         if let Some(sp) = r {\n@@ -304,9 +307,10 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                             full_path.segments.last().unwrap().identifier.name;\n                         if &token::get_name(source_name)[..] == \"mod\" ||\n                            &token::get_name(source_name)[..] == \"self\" {\n-                            resolve_err!(self, view_path.span, E0429,\n-                                         \"{}\",\n-                                         \"`self` imports are only allowed within a { } list\");\n+                            ::resolve_error(&::ResolutionError::SelfImportsOnlyAllowedWithin(\n+                                                                                self,\n+                                                                                view_path.span)\n+                            );\n                         }\n \n                         let subclass = SingleImport(binding.name,\n@@ -326,9 +330,11 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                             _ => None\n                         }).collect::<Vec<Span>>();\n                         if mod_spans.len() > 1 {\n-                            resolve_err!(self, mod_spans[0], E0430,\n-                                         \"{}\",\n-                                         \"`self` import can only appear once in the list\");\n+                            ::resolve_error(\n+                                &::ResolutionError::SelfImportCanOnlyAppearOnceInTheList(\n+                                    self,\n+                                    mod_spans[0])\n+                            );\n                             for other_span in mod_spans.iter().skip(1) {\n                                 self.session.span_note(*other_span,\n                                     \"another `self` import appears here\");\n@@ -343,10 +349,12 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                                     let name = match module_path.last() {\n                                         Some(name) => *name,\n                                         None => {\n-                                            resolve_err!(self, source_item.span, E0431,\n-                                                \"{}\",\n-                                                \"`self` import can only appear in an import list \\\n-                                                 with a non-empty prefix\");\n+                                            ::resolve_error(\n+                                                &::ResolutionError::\n+                                                SelfImportOnlyInImportListWithNonEmptyPrefix(\n+                                                    self,\n+                                                    source_item.span)\n+                                            );\n                                             continue;\n                                         }\n                                     };"}, {"sha": "850a5d1db268213ffff62b759cff24b453d757dc", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 403, "deletions": 169, "changes": 572, "blob_url": "https://github.com/rust-lang/rust/blob/c5f7c19cf274f510b48d6835f5677ae22e978d6d/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5f7c19cf274f510b48d6835f5677ae22e978d6d/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=c5f7c19cf274f510b48d6835f5677ae22e978d6d", "patch": "@@ -117,34 +117,266 @@ mod build_reduced_graph;\n mod resolve_imports;\n \n pub enum ResolutionError<'b, 'a:'b, 'tcx:'a> {\n-    /// error: static variables cannot be referenced in a pattern\n+    /// error E0401: can't use type parameters from outer function\n+    TypeParametersFromOuterFunction(&'b Resolver<'a, 'tcx>, syntax::codemap::Span),\n+    /// error E0402: cannot use an outer type parameter in this context\n+    OuterTypeParameterContext(&'b Resolver<'a, 'tcx>, syntax::codemap::Span),\n+    /// error E0403: the name is already used for a type parameter in this type parameter list\n+    NameAlreadyUsedInTypeParameterList(&'b Resolver<'a, 'tcx>, syntax::codemap::Span,\n+                                       syntax::ast::Name),\n+    /// error E0404: is not a trait\n+    IsNotATrait(&'b Resolver<'a, 'tcx>, syntax::codemap::Span, &'b str),\n+    /// error E0405: use of undeclared trait name\n+    UndeclaredTraitName(&'b Resolver<'a, 'tcx>, syntax::codemap::Span, &'b str),\n+    /// error E0406: undeclared associated type\n+    UndeclaredAssociatedType(&'b Resolver<'a, 'tcx>, syntax::codemap::Span),\n+    /// error E0407: method is not a member of trait\n+    MethodNotMemberOfTrait(&'b Resolver<'a, 'tcx>, syntax::codemap::Span, syntax::ast::Name,\n+                           &'b str),\n+    /// error E0408: variable `{}` from pattern #1 is not bound in pattern\n+    VariableNotBoundInPattern(&'b Resolver<'a, 'tcx>, syntax::codemap::Span, syntax::ast::Name,\n+                              usize),\n+    /// error E0409: variable is bound with different mode in pattern #{} than in pattern #1\n+    VariableBoundWithDifferentMode(&'b Resolver<'a, 'tcx>, syntax::codemap::Span,\n+                                   syntax::ast::Name, usize),\n+    /// error E0410: variable from pattern is not bound in pattern #1\n+    VariableNotBoundInParentPattern(&'b Resolver<'a, 'tcx>, syntax::codemap::Span,\n+                                    syntax::ast::Name, usize),\n+    /// error E0411: use of `Self` outside of an impl or trait\n+    SelfUsedOutsideImplOrTrait(&'b Resolver<'a, 'tcx>, syntax::codemap::Span),\n+    /// error E0412: use of undeclared\n+    UseOfUndeclared(&'b Resolver<'a, 'tcx>, syntax::codemap::Span, &'b str, &'b str),\n+    /// error E0413: declaration shadows an enum variant or unit-like struct in scope\n+    DeclarationShadowsEnumVariantOrUnitLikeStruct(&'b Resolver<'a, 'tcx>, syntax::codemap::Span,\n+                                                  syntax::ast::Name),\n+    /// error E0414: only irrefutable patterns allowed here\n+    OnlyIrrefutablePatternsAllowedHere(&'b Resolver<'a, 'tcx>, syntax::codemap::Span),\n+    /// error E0415: identifier is bound more than once in this parameter list\n+    IdentifierBoundMoreThanOnceInParameterList(&'b Resolver<'a, 'tcx>, syntax::codemap::Span,\n+                                               &'b str),\n+    /// error E0416: identifier is bound more than once in the same pattern\n+    IdentifierBoundMoreThanOnceInSamePattern(&'b Resolver<'a, 'tcx>, syntax::codemap::Span,\n+                                             &'b str),\n+    /// error E0417: static variables cannot be referenced in a pattern\n     StaticVariableReference(&'b Resolver<'a, 'tcx>, syntax::codemap::Span),\n-    /// error: does not name a struct\n-    DoesNotNameAStruct(&'b Resolver<'a, 'tcx>, syntax::codemap::Span),\n-    /// error: is a struct variant name, but this expression uses it like a function name\n-    StructVariantUsedAsFunction(&'a Resolver<'a, 'tcx>, syntax::codemap::Span),\n-    /// error: unresolved import\n-    UnresolvedImport(&'b Resolver<'a, 'tcx>, syntax::codemap::Span),\n-    /// error: failed to resolve\n-    FailedToResolve(&'b Resolver<'a, 'tcx>, syntax::codemap::Span),\n+    /// error E0418: is not an enum variant, struct or const\n+    NotAnEnumVariantStructOrConst(&'b Resolver<'a, 'tcx>, syntax::codemap::Span, &'b str),\n+    /// error E0419: unresolved enum variant, struct or const\n+    UnresolvedEnumVariantStructOrConst(&'b Resolver<'a, 'tcx>, syntax::codemap::Span, &'b str),\n+    /// error E0420: is not an associated const\n+    NotAnAssociatedConst(&'b Resolver<'a, 'tcx>, syntax::codemap::Span, &'b str),\n+    /// error E0421: unresolved associated const\n+    UnresolvedAssociatedConst(&'b Resolver<'a, 'tcx>, syntax::codemap::Span, &'b str),\n+    /// error E0422: does not name a struct\n+    DoesNotNameAStruct(&'b Resolver<'a, 'tcx>, syntax::codemap::Span, &'b str),\n+    /// error E0423: is a struct variant name, but this expression uses it like a function name\n+    StructVariantUsedAsFunction(&'a Resolver<'a, 'tcx>, syntax::codemap::Span, &'b str),\n+    /// error E0424: `self` is not available in a static method\n+    SelfNotAvailableInStaticMethod(&'a Resolver<'a, 'tcx>, syntax::codemap::Span),\n+    /// error E0425: unresolved name\n+    UnresolvedName(&'a Resolver<'a, 'tcx>, syntax::codemap::Span, &'b str, &'b str),\n+    /// error E0426: use of undeclared label\n+    UndeclaredLabel(&'a Resolver<'a, 'tcx>, syntax::codemap::Span, &'b str),\n+    /// error E0427: cannot use `ref` binding mode with ...\n+    CannotUseRefBindingModeWith(&'a Resolver<'a, 'tcx>, syntax::codemap::Span, &'b str),\n+    /// error E0428: duplicate definition\n+    DuplicateDefinition(&'a Resolver<'a, 'tcx>, syntax::codemap::Span, &'b str, &'b str),\n+    /// error E0429: `self` imports are only allowed within a { } list\n+    SelfImportsOnlyAllowedWithin(&'a Resolver<'a, 'tcx>, syntax::codemap::Span),\n+    /// error E0430: `self` import can only appear once in the list\n+    SelfImportCanOnlyAppearOnceInTheList(&'a Resolver<'a, 'tcx>, syntax::codemap::Span),\n+    /// error E0431: `self` import can only appear in an import list with a non-empty prefix\n+    SelfImportOnlyInImportListWithNonEmptyPrefix(&'a Resolver<'a, 'tcx>, syntax::codemap::Span),\n+    /// error E0432: unresolved import\n+    UnresolvedImport(&'b Resolver<'a, 'tcx>, syntax::codemap::Span,\n+                     Option<(&'b str, Option<&'b str>)>),\n+    /// error E0433: failed to resolve\n+    FailedToResolve(&'b Resolver<'a, 'tcx>, syntax::codemap::Span, &'b str),\n+    /// error E0434: can't capture dynamic environment in a fn item\n+    CannotCaptureDynamicEnvironmentInFnItem(&'b Resolver<'a, 'tcx>, syntax::codemap::Span),\n+    /// error E0435: attempt to use a non-constant value in a constant\n+    AttemptToUseNonConstantValueInConstant(&'b Resolver<'a, 'tcx>, syntax::codemap::Span),\n }\n \n-fn resolve_error<'b, 'a:'b, 'tcx:'a>(resolution_error: &ResolutionError<'b, 'a, 'tcx>, formatted: &str) {\n+fn resolve_error<'b, 'a:'b, 'tcx:'a>(resolution_error: &ResolutionError<'b, 'a, 'tcx>) {\n     match resolution_error {\n+        &ResolutionError::TypeParametersFromOuterFunction(resolver, span) => {\n+            resolve_err!(resolver, span, E0401, \"can't use type parameters from \\\n+                                                 outer function; try using a local \\\n+                                                 type parameter instead\");\n+        },\n+        &ResolutionError::OuterTypeParameterContext(resolver, span) => {\n+            resolve_err!(resolver, span, E0402,\n+                         \"cannot use an outer type parameter in this context\");\n+        },\n+        &ResolutionError::NameAlreadyUsedInTypeParameterList(resolver, span, name) => {\n+            resolve_err!(resolver, span, E0403,\n+                         \"the name `{}` is already used for a type \\\n+                          parameter in this type parameter list\", name);\n+        },\n+        &ResolutionError::IsNotATrait(resolver, span, name) => {\n+            resolve_err!(resolver, span, E0404,\n+                         \"`{}` is not a trait\",\n+                         name);\n+        },\n+        &ResolutionError::UndeclaredTraitName(resolver, span, name) => {\n+            resolve_err!(resolver, span, E0405,\n+                         \"use of undeclared trait name `{}`\",\n+                         name);\n+        },\n+        &ResolutionError::UndeclaredAssociatedType(resolver, span) => {\n+            resolve_err!(resolver, span, E0406, \"undeclared associated type\");\n+        },\n+        &ResolutionError::MethodNotMemberOfTrait(resolver, span, method, trait_) => {\n+            resolve_err!(resolver, span, E0407,\n+                         \"method `{}` is not a member of trait `{}`\",\n+                         method,\n+                         trait_);\n+        },\n+        &ResolutionError::VariableNotBoundInPattern(resolver, span, variable_name,\n+                                                    pattern_number) => {\n+            resolve_err!(resolver, span, E0408,\n+                         \"variable `{}` from pattern #1 is not bound in pattern #{}\",\n+                         variable_name,\n+                         pattern_number);\n+        },\n+        &ResolutionError::VariableBoundWithDifferentMode(resolver, span, variable_name,\n+                                                         pattern_number) => {\n+            resolve_err!(resolver, span, E0409,\n+                         \"variable `{}` is bound with different \\\n+                         mode in pattern #{} than in pattern #1\",\n+                         variable_name,\n+                         pattern_number);\n+        },\n+        &ResolutionError::VariableNotBoundInParentPattern(resolver, span, variable_name,\n+                                                          pattern_number) => {\n+            resolve_err!(resolver, span, E0410,\n+                         \"variable `{}` from pattern #{} is not bound in pattern #1\",\n+                         variable_name,\n+                         pattern_number);\n+        },\n+        &ResolutionError::SelfUsedOutsideImplOrTrait(resolver, span) => {\n+            resolve_err!(resolver, span, E0411, \"use of `Self` outside of an impl or trait\");\n+        },\n+        &ResolutionError::UseOfUndeclared(resolver, span, kind, name) => {\n+            resolve_err!(resolver, span, E0412,\n+                         \"use of undeclared {} `{}`\",\n+                         kind,\n+                         name);\n+        },\n+        &ResolutionError::DeclarationShadowsEnumVariantOrUnitLikeStruct(resolver, span, name) => {\n+            resolve_err!(resolver, span, E0413,\n+                         \"declaration of `{}` shadows an enum variant or unit-like struct in \\\n+                          scope\",\n+                         name);\n+        },\n+        &ResolutionError::OnlyIrrefutablePatternsAllowedHere(resolver, span) => {\n+            resolve_err!(resolver, span, E0414, \"only irrefutable patterns allowed here\");\n+        },\n+        &ResolutionError::IdentifierBoundMoreThanOnceInParameterList(resolver, span,\n+                                                                     identifier) => {\n+            resolve_err!(resolver, span, E0415,\n+                         \"identifier `{}` is bound more than once in this parameter list\",\n+                         identifier);\n+        },\n+        &ResolutionError::IdentifierBoundMoreThanOnceInSamePattern(resolver, span, identifier) => {\n+            resolve_err!(resolver, span, E0416,\n+                         \"identifier `{}` is bound more than once in the same pattern\",\n+                         identifier);\n+        },\n         &ResolutionError::StaticVariableReference(resolver, span) => {\n-            resolve_err!(resolver, span, E0417, \"{}\", formatted);\n+            resolve_err!(resolver, span, E0417, \"static variables cannot be \\\n+                                                 referenced in a pattern, \\\n+                                                 use a `const` instead\");\n+        },\n+        &ResolutionError::NotAnEnumVariantStructOrConst(resolver, span, name) => {\n+            resolve_err!(resolver, span, E0418,\n+                         \"`{}` is not an enum variant, struct or const\",\n+                         name);\n+        },\n+        &ResolutionError::UnresolvedEnumVariantStructOrConst(resolver, span, name) => {\n+            resolve_err!(resolver, span, E0419,\n+                         \"unresolved enum variant, struct or const `{}`\",\n+                         name);\n+        },\n+        &ResolutionError::NotAnAssociatedConst(resolver, span, name) => {\n+            resolve_err!(resolver, span, E0420,\n+                         \"`{}` is not an associated const\",\n+                         name);\n         },\n-        &ResolutionError::DoesNotNameAStruct(resolver, span) => {\n-            resolve_err!(resolver, span, E0422, \"{}\", formatted);\n+        &ResolutionError::UnresolvedAssociatedConst(resolver, span, name) => {\n+            resolve_err!(resolver, span, E0421,\n+                         \"unresolved associated const `{}`\",\n+                         name);\n         },\n-        &ResolutionError::StructVariantUsedAsFunction(resolver, span) => {\n-            resolve_err!(resolver, span, E0423, \"{}\", formatted);\n+        &ResolutionError::DoesNotNameAStruct(resolver, span, name) => {\n+            resolve_err!(resolver, span, E0422, \"`{}` does not name a structure\", name);\n         },\n-        &ResolutionError::UnresolvedImport(resolver, span) => {\n-            resolve_err!(resolver, span, E0432, \"{}\", formatted);\n+        &ResolutionError::StructVariantUsedAsFunction(resolver, span, path_name) => {\n+            resolve_err!(resolver, span, E0423,\n+                         \"`{}` is a struct variant name, but \\\n+                          this expression \\\n+                          uses it like a function name\",\n+                          path_name);\n         },\n-        &ResolutionError::FailedToResolve(resolver, span) => {\n-            resolve_err!(resolver, span, E0433, \"{}\", formatted);\n+        &ResolutionError::SelfNotAvailableInStaticMethod(resolver, span) => {\n+            resolve_err!(resolver, span, E0424, \"`self` is not available in a static method. \\\n+                                                 Maybe a `self` argument is missing?\");\n+        },\n+        &ResolutionError::UnresolvedName(resolver, span, path, name) => {\n+            resolve_err!(resolver, span, E0425,\n+                         \"unresolved name `{}`{}\",\n+                         path,\n+                         name);\n+        },\n+        &ResolutionError::UndeclaredLabel(resolver, span, name) => {\n+            resolve_err!(resolver, span, E0426,\n+                         \"use of undeclared label `{}`\",\n+                         name);\n+        },\n+        &ResolutionError::CannotUseRefBindingModeWith(resolver, span, descr) => {\n+            resolve_err!(resolver, span, E0427,\n+                         \"cannot use `ref` binding mode with {}\",\n+                         descr);\n+        },\n+        &ResolutionError::DuplicateDefinition(resolver, span, namespace, name) => {\n+            resolve_err!(resolver, span, E0428,\n+                         \"duplicate definition of {} `{}`\",\n+                         namespace,\n+                         name);\n+        },\n+        &ResolutionError::SelfImportsOnlyAllowedWithin(resolver, span) => {\n+            resolve_err!(resolver, span, E0429, \"{}\",\n+                         \"`self` imports are only allowed within a { } list\");\n+        },\n+        &ResolutionError::SelfImportCanOnlyAppearOnceInTheList(resolver, span) => {\n+            resolve_err!(resolver, span, E0430,\n+                         \"`self` import can only appear once in the list\");\n+        },\n+        &ResolutionError::SelfImportOnlyInImportListWithNonEmptyPrefix(resolver, span) => {\n+            resolve_err!(resolver, span, E0431,\n+                         \"`self` import can only appear in an import list with a \\\n+                          non-empty prefix\");\n+        }\n+        &ResolutionError::UnresolvedImport(resolver, span, name) => {\n+            let msg = match name {\n+                Some((n, Some(p))) => format!(\"unresolved import `{}`{}\", n, p),\n+                Some((n, None)) => format!(\"unresolved import (maybe you meant `{}::*`?)\", n),\n+                None => \"unresolved import\".to_owned()\n+            };\n+            resolve_err!(resolver, span, E0432, \"{}\", msg);\n+        },\n+        &ResolutionError::FailedToResolve(resolver, span, msg) => {\n+            resolve_err!(resolver, span, E0433, \"failed to resolve. {}\", msg);\n+        },\n+        &ResolutionError::CannotCaptureDynamicEnvironmentInFnItem(resolver, span) => {\n+            resolve_err!(resolver, span, E0434, \"{}\",\n+                         \"can't capture dynamic environment in a fn item; \\\n+                          use the || { ... } closure form instead\");\n+        },\n+        &ResolutionError::AttemptToUseNonConstantValueInConstant(resolver, span) =>{\n+            resolve_err!(resolver, span, E0435,\n+                         \"attempt to use a non-constant value in a constant\");\n         },\n     }\n }\n@@ -1343,10 +1575,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                               PathSearch,\n                                               true) {\n                 Failed(Some((span, msg))) => {\n-                    resolve_error(&ResolutionError::FailedToResolve(self, span),\n-                                  &*format!(\"failed to resolve. {}\",\n-                                        msg)\n-                                 );\n+                    resolve_error(&ResolutionError::FailedToResolve(self, span, &*msg));\n                 },\n                 Failed(None) => (), // Continue up the search chain.\n                 Indeterminate => {\n@@ -1604,13 +1833,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                          .span_to_snippet((*imports)[index].span)\n                          .unwrap();\n             if sn.contains(\"::\") {\n-                resolve_error(&ResolutionError::UnresolvedImport(self, (*imports)[index].span),\n-                              \"unresolved import\");\n+                resolve_error(&ResolutionError::UnresolvedImport(self,\n+                                                                 (*imports)[index].span,\n+                                                                 None));\n             } else {\n-                resolve_error(&ResolutionError::UnresolvedImport(self, (*imports)[index].span),\n-                              &*format!(\"unresolved import (maybe you meant `{}::*`?)\",\n-                                    sn)\n-                             );\n+                resolve_error(&ResolutionError::UnresolvedImport(self,\n+                                                                 (*imports)[index].span,\n+                                                                 Some((&*sn, None))));\n             }\n         }\n \n@@ -1736,16 +1965,20 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             // This was an attempt to access an upvar inside a\n                             // named function item. This is not allowed, so we\n                             // report an error.\n-                            resolve_err!(self, span, E0434, \"{}\",\n-                                         \"can't capture dynamic environment in a fn item; \\\n-                                          use the || { ... } closure form instead\");\n+                            resolve_error(\n+                                &ResolutionError::CannotCaptureDynamicEnvironmentInFnItem(\n+                                    self,\n+                                    span)\n+                            );\n                             return None;\n                         }\n                         ConstantItemRibKind => {\n                             // Still doesn't deal with upvars\n-                            resolve_err!(self, span, E0435, \"{}\",\n-                                         \"attempt to use a non-constant \\\n-                                          value in a constant\");\n+                            resolve_error(\n+                                &ResolutionError::AttemptToUseNonConstantValueInConstant(\n+                                    self,\n+                                    span)\n+                            );\n                             return None;\n                         }\n                     }\n@@ -1761,17 +1994,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             // This was an attempt to use a type parameter outside\n                             // its scope.\n \n-                            resolve_err!(self, span, E0401, \"{}\",\n-                                         \"can't use type parameters from \\\n-                                          outer function; try using a local \\\n-                                          type parameter instead\");\n+                            resolve_error(&ResolutionError::TypeParametersFromOuterFunction(self,\n+                                                                                            span));\n                             return None;\n                         }\n                         ConstantItemRibKind => {\n                             // see #9186\n-                            resolve_err!(self, span, E0402, \"{}\",\n-                                         \"cannot use an outer type \\\n-                                          parameter in this context\");\n+                            resolve_error(&ResolutionError::OuterTypeParameterContext(self, span));\n                             return None;\n                         }\n                     }\n@@ -1969,12 +2198,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     debug!(\"with_type_parameter_rib: {}\", type_parameter.id);\n \n                     if seen_bindings.contains(&name) {\n-                        resolve_err!(self, type_parameter.span, E0403,\n-                                     \"the name `{}` is already \\\n-                                      used for a type \\\n-                                      parameter in this type \\\n-                                      parameter list\",\n-                                     name)\n+                        resolve_error(&ResolutionError::NameAlreadyUsedInTypeParameterList(\n+                                                            self,\n+                                                            type_parameter.span,\n+                                                            name));\n                     }\n                     seen_bindings.insert(name);\n \n@@ -2061,9 +2288,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 debug!(\"(resolving trait) found trait def: {:?}\", path_res);\n                 Ok(path_res)\n             } else {\n-                resolve_err!(self, trait_path.span, E0404,\n-                             \"`{}` is not a trait\",\n-                             path_names_to_string(trait_path, path_depth));\n+                resolve_error(&ResolutionError::IsNotATrait(self, trait_path.span,\n+                                                            &*path_names_to_string(trait_path,\n+                                                                                 path_depth))\n+                             );\n \n                 // If it's a typedef, give a note\n                 if let DefTy(..) = path_res.base_def {\n@@ -2073,9 +2301,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 Err(())\n             }\n         } else {\n-            resolve_err!(self, trait_path.span, E0405,\n-                         \"use of undeclared trait name `{}`\",\n-                         path_names_to_string(trait_path, path_depth));\n+            resolve_error(&ResolutionError::UndeclaredTraitName(self,\n+                                                                trait_path.span,\n+                                                                &*path_names_to_string(trait_path,\n+                                                                                     path_depth)));\n             Err(())\n         }\n     }\n@@ -2093,8 +2322,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     if let Some(PathResolution { base_def: DefTyParam(..), .. }) = path_res {\n                         self.record_def(eq_pred.id, path_res.unwrap());\n                     } else {\n-                        resolve_err!(self, eq_pred.span, E0406, \"{}\",\n-                                     \"undeclared associated type\");\n+                        resolve_error(&ResolutionError::UndeclaredAssociatedType(self,\n+                                                                                 eq_pred.span));\n                     }\n                 }\n             }\n@@ -2219,8 +2448,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         if let Some((did, ref trait_ref)) = self.current_trait_ref {\n             if !self.trait_item_map.contains_key(&(name, did)) {\n                 let path_str = path_names_to_string(&trait_ref.path, 0);\n-                resolve_err!(self, span, E0407, \"method `{}` is not a member of trait `{}`\",\n-                             name, path_str);\n+                resolve_error(&ResolutionError::MethodNotMemberOfTrait(self,\n+                                                                       span,\n+                                                                       name,\n+                                                                       &*path_str));\n             }\n         }\n     }\n@@ -2267,31 +2498,30 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             for (&key, &binding_0) in &map_0 {\n                 match map_i.get(&key) {\n                   None => {\n-                    resolve_err!(self, p.span, E0408,\n-                                 \"variable `{}` from pattern #1 is \\\n-                                  not bound in pattern #{}\",\n-                                 key,\n-                                 i + 1);\n+                    resolve_error(&ResolutionError::VariableNotBoundInPattern(self,\n+                                                                              p.span,\n+                                                                              key,\n+                                                                              i + 1));\n                   }\n                   Some(binding_i) => {\n                     if binding_0.binding_mode != binding_i.binding_mode {\n-                        resolve_err!(self, binding_i.span, E0409,\n-                                     \"variable `{}` is bound with different \\\n-                                      mode in pattern #{} than in pattern #1\",\n-                                     key,\n-                                     i + 1);\n+                        resolve_error(&ResolutionError::VariableBoundWithDifferentMode(\n+                                                                        self,\n+                                                                        binding_i.span,\n+                                                                        key,\n+                                                                        i + 1)\n+                                     );\n                     }\n                   }\n                 }\n             }\n \n             for (&key, &binding) in &map_i {\n                 if !map_0.contains_key(&key) {\n-                    resolve_err!(self, binding.span, E0410,\n-                                 \"variable `{}` from pattern #{} is \\\n-                                  not bound in pattern #1\",\n-                                 key,\n-                                 i + 1);\n+                    resolve_error(&ResolutionError::VariableNotBoundInParentPattern(self,\n+                                                                                    binding.span,\n+                                                                                    key,\n+                                                                                    i + 1));\n                 }\n             }\n         }\n@@ -2405,13 +2635,16 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             maybe_qself.is_none() &&\n                             path.segments[0].identifier.name == self_type_name;\n                         if is_invalid_self_type_name {\n-                            resolve_err!(self, ty.span, E0411,\n-                                         \"use of `Self` outside of an impl or trait\");\n+                            resolve_error(&ResolutionError::SelfUsedOutsideImplOrTrait(self,\n+                                                                                       ty.span));\n                         } else {\n-                            resolve_err!(self, ty.span, E0412,\n-                                         \"use of undeclared {} `{}`\",\n-                                         kind,\n-                                         path_names_to_string(path, 0));\n+                            resolve_error(&ResolutionError::UseOfUndeclared(\n+                                                                    self,\n+                                                                    ty.span,\n+                                                                    kind,\n+                                                                    &*path_names_to_string(path,\n+                                                                                           0))\n+                                         );\n                         }\n                     }\n                 }\n@@ -2463,11 +2696,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             });\n                         }\n                         FoundStructOrEnumVariant(..) => {\n-                            resolve_err!(self, pattern.span, E0413,\n-                                         \"declaration of `{}` shadows an enum \\\n-                                         variant or unit-like struct in \\\n-                                         scope\",\n-                                         renamed);\n+                            resolve_error(\n+                                &ResolutionError::DeclarationShadowsEnumVariantOrUnitLikeStruct(\n+                                    self,\n+                                    pattern.span,\n+                                    renamed)\n+                            );\n                         }\n                         FoundConst(def, lp) if mode == RefutableMode => {\n                             debug!(\"(resolving pattern) resolving `{}` to \\\n@@ -2485,10 +2719,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             });\n                         }\n                         FoundConst(..) => {\n-                            resolve_err!(self, pattern.span, E0414,\n-                                         \"{}\",\n-                                         \"only irrefutable patterns \\\n-                                          allowed here\");\n+                            resolve_error(\n+                                &ResolutionError::OnlyIrrefutablePatternsAllowedHere(\n+                                    self,\n+                                    pattern.span)\n+                            );\n                         }\n                         BareIdentifierPatternUnresolved => {\n                             debug!(\"(resolving pattern) binding `{}`\",\n@@ -2520,22 +2755,22 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     bindings_list.contains_key(&renamed) {\n                                 // Forbid duplicate bindings in the same\n                                 // parameter list.\n-                                resolve_err!(self, pattern.span, E0415,\n-                                             \"identifier `{}` \\\n-                                              is bound more \\\n-                                              than once in \\\n-                                              this parameter \\\n-                                              list\",\n-                                             token::get_ident(ident));\n+                                resolve_error(\n+                                    &ResolutionError::IdentifierBoundMoreThanOnceInParameterList(\n+                                        self,\n+                                        pattern.span,\n+                                        &*token::get_ident(ident))\n+                                );\n                             } else if bindings_list.get(&renamed) ==\n                                     Some(&pat_id) {\n                                 // Then this is a duplicate variable in the\n                                 // same disjunction, which is an error.\n-                                resolve_err!(self, pattern.span, E0416,\n-                                             \"identifier `{}` is bound \\\n-                                              more than once in the same \\\n-                                              pattern\",\n-                                             token::get_ident(ident));\n+                                resolve_error(\n+                                    &ResolutionError::IdentifierBoundMoreThanOnceInSamePattern(\n+                                        self,\n+                                        pattern.span,\n+                                        &*token::get_ident(ident))\n+                                );\n                             }\n                             // Else, not bound in the same pattern: do\n                             // nothing.\n@@ -2566,21 +2801,23 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 self.record_def(pattern.id, path_res);\n                             }\n                             DefStatic(..) => {\n-                                resolve_error(&ResolutionError::StaticVariableReference(&self, path.span),\n-                                              \"static variables cannot be \\\n-                                               referenced in a pattern, \\\n-                                               use a `const` instead\");\n+                                resolve_error(&ResolutionError::StaticVariableReference(&self,\n+                                              path.span));\n                             }\n                             _ => {\n                                 // If anything ends up here entirely resolved,\n                                 // it's an error. If anything ends up here\n                                 // partially resolved, that's OK, because it may\n                                 // be a `T::CONST` that typeck will resolve.\n                                 if path_res.depth == 0 {\n-                                    resolve_err!(self, path.span, E0418,\n-                                                 \"`{}` is not an enum variant, struct or const\",\n-                                                 token::get_ident(\n-                                                     path.segments.last().unwrap().identifier));\n+                                    resolve_error(\n+                                        &ResolutionError::NotAnEnumVariantStructOrConst(\n+                                            self,\n+                                            path.span,\n+                                            &*token::get_ident(\n+                                                path.segments.last().unwrap().identifier)\n+                                            )\n+                                    );\n                                 } else {\n                                     let const_name = path.segments.last().unwrap()\n                                                          .identifier.name;\n@@ -2591,9 +2828,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             }\n                         }\n                     } else {\n-                        resolve_err!(self, path.span, E0419,\n-                                     \"unresolved enum variant, struct or const `{}`\",\n-                                     token::get_ident(path.segments.last().unwrap().identifier));\n+                        resolve_error(\n+                            &ResolutionError::UnresolvedEnumVariantStructOrConst(\n+                                self,\n+                                path.span,\n+                                &*token::get_ident(path.segments.last().unwrap().identifier))\n+                        );\n                     }\n                     visit::walk_path(self, path);\n                 }\n@@ -2625,16 +2865,24 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 self.record_def(pattern.id, path_res);\n                             }\n                             _ => {\n-                                resolve_err!(self, path.span, E0420,\n-                                             \"`{}` is not an associated const\",\n-                                             token::get_ident(\n-                                                 path.segments.last().unwrap().identifier));\n+                                resolve_error(\n+                                    &ResolutionError::NotAnAssociatedConst(\n+                                        self,\n+                                        path.span,\n+                                        &*token::get_ident(\n+                                            path.segments.last().unwrap().identifier)\n+                                    )\n+                                );\n                             }\n                         }\n                     } else {\n-                        resolve_err!(self, path.span, E0421,\n-                                     \"unresolved associated const `{}`\",\n-                                     token::get_ident(path.segments.last().unwrap().identifier));\n+                        resolve_error(\n+                            &ResolutionError::UnresolvedAssociatedConst(\n+                                self,\n+                                path.span,\n+                                &*token::get_ident(path.segments.last().unwrap().identifier)\n+                            )\n+                        );\n                     }\n                     visit::walk_pat(self, pattern);\n                 }\n@@ -2647,9 +2895,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         result => {\n                             debug!(\"(resolving pattern) didn't find struct \\\n                                     def: {:?}\", result);\n-                            resolve_error(&ResolutionError::DoesNotNameAStruct(self, path.span),\n-                                         &*format!(\"`{}` does not name a structure\",\n-                                             path_names_to_string(path, 0)));\n+                            resolve_error(&ResolutionError::DoesNotNameAStruct(\n+                                                                self,\n+                                                                path.span,\n+                                                                &*path_names_to_string(path, 0))\n+                                         );\n                         }\n                     }\n                     visit::walk_path(self, path);\n@@ -2695,10 +2945,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 return FoundConst(def, LastMod(AllPublic));\n                             }\n                             DefStatic(..) => {\n-                                resolve_error(&ResolutionError::StaticVariableReference(self, span),\n-                                              \"static variables cannot be \\\n-                                               referenced in a pattern, \\\n-                                               use a `const` instead\");\n+                                resolve_error(&ResolutionError::StaticVariableReference(self,\n+                                                                                        span));\n                                 return BareIdentifierPatternUnresolved;\n                             }\n                             _ => {\n@@ -2715,10 +2963,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             Failed(err) => {\n                 match err {\n                     Some((span, msg)) => {\n-                        resolve_error(&ResolutionError::FailedToResolve(self, span),\n-                                      &*format!(\"failed to resolve. {}\",\n-                                            msg)\n-                                     );\n+                        resolve_error(&ResolutionError::FailedToResolve(self, span, &*msg));\n                     }\n                     None => ()\n                 }\n@@ -2947,10 +3192,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     }\n                 };\n \n-                resolve_error(&ResolutionError::FailedToResolve(self, span),\n-                              &*format!(\"failed to resolve. {}\",\n-                                    msg)\n-                             );\n+                resolve_error(&ResolutionError::FailedToResolve(self, span, &*msg));\n                 return None;\n             }\n             Indeterminate => panic!(\"indeterminate unexpected\"),\n@@ -3009,10 +3251,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     }\n                 };\n \n-                resolve_error(&ResolutionError::FailedToResolve(self, span),\n-                              &*format!(\"failed to resolve. {}\",\n-                                    msg)\n-                             );\n+                resolve_error(&ResolutionError::FailedToResolve(self, span, &*msg));\n                 return None;\n             }\n \n@@ -3108,10 +3347,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                          failed to resolve {}\", name);\n \n                 if let Some((span, msg)) = err {\n-                    resolve_error(&ResolutionError::FailedToResolve(self, span),\n-                                  &*format!(\"failed to resolve. {}\",\n-                                        msg)\n-                                 )\n+                    resolve_error(&ResolutionError::FailedToResolve(self, span, &*msg))\n                 }\n \n                 return None;\n@@ -3314,11 +3550,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     if let DefVariant(_, _, true) = path_res.base_def {\n                         let path_name = path_names_to_string(path, 0);\n \n-                        resolve_error(&ResolutionError::StructVariantUsedAsFunction(self, expr.span),\n-                                      &*format!(\"`{}` is a struct variant name, but \\\n-                                           this expression \\\n-                                           uses it like a function name\",\n-                                          path_name));\n+                        resolve_error(&ResolutionError::StructVariantUsedAsFunction(self,\n+                                                                                    expr.span,\n+                                                                                    &*path_name));\n \n                         let msg = format!(\"did you mean to write: \\\n                                            `{} {{ /* fields */ }}`?\",\n@@ -3355,11 +3589,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     match type_res.map(|r| r.base_def) {\n                         Some(DefTy(struct_id, _))\n                             if self.structs.contains_key(&struct_id) => {\n-                                resolve_error(&ResolutionError::StructVariantUsedAsFunction(self, expr.span),\n-                                              &*format!(\"`{}` is a struct variant name, but \\\n-                                                  this expression \\\n-                                                  uses it like a function name\",\n-                                                 path_name));\n+                                resolve_error(&ResolutionError::StructVariantUsedAsFunction(self,\n+                                                                                    expr.span,\n+                                                                                    &*path_name));\n \n                                 let msg = format!(\"did you mean to write: \\\n                                                      `{} {{ /* fields */ }}`?\",\n@@ -3386,11 +3618,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n                             if method_scope &&\n                                &token::get_name(special_names::self_)[..] == path_name {\n-                                    resolve_err!(self, expr.span, E0424,\n-                                                 \"{}\",\n-                                                 \"`self` is not available \\\n-                                                  in a static method. Maybe a \\\n-                                                  `self` argument is missing?\");\n+                                resolve_error(\n+                                    &ResolutionError::SelfNotAvailableInStaticMethod(\n+                                        self,\n+                                        expr.span)\n+                                );\n                             } else {\n                                 let last_name = path.segments.last().unwrap().identifier.name;\n                                 let mut msg = match self.find_fallback_in_self_type(last_name) {\n@@ -3414,10 +3646,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     msg = format!(\". Did you mean {}?\", msg)\n                                 }\n \n-                                resolve_err!(self, expr.span, E0425,\n-                                             \"unresolved name `{}`{}\",\n-                                             path_name,\n-                                             msg);\n+                                resolve_error(&ResolutionError::UnresolvedName(self,\n+                                                                               expr.span,\n+                                                                               &*path_name,\n+                                                                               &*msg));\n                             }\n                         }\n                     }\n@@ -3435,9 +3667,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     None => {\n                         debug!(\"(resolving expression) didn't find struct def\",);\n \n-                        resolve_error(&ResolutionError::DoesNotNameAStruct(self, path.span),\n-                                     &*format!(\"`{}` does not name a structure\",\n-                                         path_names_to_string(path, 0)));\n+                        resolve_error(&ResolutionError::DoesNotNameAStruct(\n+                                                                self,\n+                                                                path.span,\n+                                                                &*path_names_to_string(path, 0))\n+                                     );\n                     }\n                 }\n \n@@ -3462,9 +3696,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 let renamed = mtwt::resolve(label);\n                 match self.search_label(renamed) {\n                     None => {\n-                        resolve_err!(self, expr.span, E0426,\n-                                     \"use of undeclared label `{}`\",\n-                                     token::get_ident(label))\n+                        resolve_error(&ResolutionError::UndeclaredLabel(self,\n+                                                                        expr.span,\n+                                                                        &*token::get_ident(label)))\n                     }\n                     Some(DlDef(def @ DefLabel(_))) => {\n                         // Since this def is a label, it is never read.\n@@ -3610,9 +3844,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         match pat_binding_mode {\n             BindByValue(_) => {}\n             BindByRef(..) => {\n-                resolve_err!(self, pat.span, E0427,\n-                             \"cannot use `ref` binding mode with {}\",\n-                             descr);\n+                resolve_error(&ResolutionError::CannotUseRefBindingModeWith(self,\n+                                                                            pat.span,\n+                                                                            descr));\n             }\n         }\n     }"}, {"sha": "3b06eab8cf2eca394025f1d549d0e69eb7abf8e1", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c5f7c19cf274f510b48d6835f5677ae22e978d6d/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5f7c19cf274f510b48d6835f5677ae22e978d6d/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=c5f7c19cf274f510b48d6835f5677ae22e978d6d", "patch": "@@ -272,12 +272,11 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                         Some((span, msg)) => (span, format!(\". {}\", msg)),\n                         None => (import_directive.span, String::new())\n                     };\n-                    ::resolve_error(&::ResolutionError::UnresolvedImport(self.resolver, span),\n-                                    &*format!(\"unresolved import `{}`{}\",\n-                                            import_path_to_string(\n-                                                &import_directive.module_path,\n-                                                import_directive.subclass),\n-                                            help)\n+                    ::resolve_error(&::ResolutionError::UnresolvedImport(self.resolver, span,\n+                                                Some((&*import_path_to_string(\n+                                                        &import_directive.module_path,\n+                                                        import_directive.subclass),\n+                                                      Some(&*help))))\n                                    );\n                 }\n                 ResolveResult::Indeterminate => break, // Bail out. We'll come around next time."}]}