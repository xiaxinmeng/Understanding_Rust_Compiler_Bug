{"sha": "de3e581e29b1fd02fe4ef5cc415e5173f30e2ca7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlM2U1ODFlMjliMWZkMDJmZTRlZjVjYzQxNWU1MTczZjMwZTJjYTc=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-09-23T12:04:37Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-11-19T00:14:32Z"}, "message": "rustc: support u128 discriminant ranges.", "tree": {"sha": "458b910ec8b00af62abe9cf210f1f81436c6cbac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/458b910ec8b00af62abe9cf210f1f81436c6cbac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de3e581e29b1fd02fe4ef5cc415e5173f30e2ca7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de3e581e29b1fd02fe4ef5cc415e5173f30e2ca7", "html_url": "https://github.com/rust-lang/rust/commit/de3e581e29b1fd02fe4ef5cc415e5173f30e2ca7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de3e581e29b1fd02fe4ef5cc415e5173f30e2ca7/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "018323ffc2c38669f594b8f7025a3440ae529d2a", "url": "https://api.github.com/repos/rust-lang/rust/commits/018323ffc2c38669f594b8f7025a3440ae529d2a", "html_url": "https://github.com/rust-lang/rust/commit/018323ffc2c38669f594b8f7025a3440ae529d2a"}], "stats": {"total": 171, "additions": 70, "deletions": 101}, "files": [{"sha": "b59f7480476b8ff1b193f8507502b49da5a1d2ea", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/de3e581e29b1fd02fe4ef5cc415e5173f30e2ca7/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de3e581e29b1fd02fe4ef5cc415e5173f30e2ca7/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=de3e581e29b1fd02fe4ef5cc415e5173f30e2ca7", "patch": "@@ -46,6 +46,7 @@\n #![feature(const_fn)]\n #![feature(core_intrinsics)]\n #![feature(drain_filter)]\n+#![feature(i128)]\n #![feature(i128_type)]\n #![feature(inclusive_range)]\n #![feature(inclusive_range_syntax)]"}, {"sha": "a97574681a231a413d26f8166d92693bb52d6cc2", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/de3e581e29b1fd02fe4ef5cc415e5173f30e2ca7/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de3e581e29b1fd02fe4ef5cc415e5173f30e2ca7/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=de3e581e29b1fd02fe4ef5cc415e5173f30e2ca7", "patch": "@@ -20,7 +20,7 @@ use syntax_pos::DUMMY_SP;\n \n use std::cmp;\n use std::fmt;\n-use std::i64;\n+use std::i128;\n use std::iter;\n use std::mem;\n use std::ops::{Add, Sub, Mul, AddAssign, Deref, RangeInclusive};\n@@ -467,7 +467,7 @@ impl<'a, 'tcx> Integer {\n     }\n \n     /// Find the smallest Integer type which can represent the signed value.\n-    pub fn fit_signed(x: i64) -> Integer {\n+    pub fn fit_signed(x: i128) -> Integer {\n         match x {\n             -0x0000_0000_0000_0001...0x0000_0000_0000_0000 => I1,\n             -0x0000_0000_0000_0080...0x0000_0000_0000_007f => I8,\n@@ -479,7 +479,7 @@ impl<'a, 'tcx> Integer {\n     }\n \n     /// Find the smallest Integer type which can represent the unsigned value.\n-    pub fn fit_unsigned(x: u64) -> Integer {\n+    pub fn fit_unsigned(x: u128) -> Integer {\n         match x {\n             0...0x0000_0000_0000_0001 => I1,\n             0...0x0000_0000_0000_00ff => I8,\n@@ -495,7 +495,7 @@ impl<'a, 'tcx> Integer {\n         let dl = cx.data_layout();\n \n         let wanted = align.abi();\n-        for &candidate in &[I8, I16, I32, I64] {\n+        for &candidate in &[I8, I16, I32, I64, I128] {\n             let ty = Int(candidate, false);\n             if wanted == ty.align(dl).abi() && wanted == ty.size(dl).bytes() {\n                 return Some(candidate);\n@@ -522,19 +522,19 @@ impl<'a, 'tcx> Integer {\n \n     /// Find the appropriate Integer type and signedness for the given\n     /// signed discriminant range and #[repr] attribute.\n-    /// N.B.: u64 values above i64::MAX will be treated as signed, but\n+    /// N.B.: u128 values above i128::MAX will be treated as signed, but\n     /// that shouldn't affect anything, other than maybe debuginfo.\n     fn repr_discr(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                   ty: Ty<'tcx>,\n                   repr: &ReprOptions,\n-                  min: i64,\n-                  max: i64)\n+                  min: i128,\n+                  max: i128)\n                   -> (Integer, bool) {\n         // Theoretically, negative values could be larger in unsigned representation\n         // than the unsigned representation of the signed minimum. However, if there\n-        // are any negative values, the only valid unsigned representation is u64\n-        // which can fit all i64 values, so the result remains unaffected.\n-        let unsigned_fit = Integer::fit_unsigned(cmp::max(min as u64, max as u64));\n+        // are any negative values, the only valid unsigned representation is u128\n+        // which can fit all i128 values, so the result remains unaffected.\n+        let unsigned_fit = Integer::fit_unsigned(cmp::max(min as u128, max as u128));\n         let signed_fit = cmp::max(Integer::fit_signed(min), Integer::fit_signed(max));\n \n         let mut min_from_extern = None;\n@@ -782,11 +782,11 @@ pub enum Variants {\n     Tagged {\n         discr: Primitive,\n         /// Inclusive wrap-around range of discriminant values, that is,\n-        /// if min > max, it represents min..=u64::MAX followed by 0..=max.\n+        /// if min > max, it represents min..=u128::MAX followed by 0..=max.\n         // FIXME(eddyb) always use the shortest range, e.g. by finding\n         // the largest space between two consecutive discriminants and\n         // taking everything else as the (shortest) discriminant range.\n-        discr_range: RangeInclusive<u64>,\n+        discr_range: RangeInclusive<u128>,\n         variants: Vec<CachedLayout>,\n     },\n \n@@ -1375,14 +1375,12 @@ impl<'a, 'tcx> CachedLayout {\n                     }\n                 }\n \n-                let (mut min, mut max) = (i64::max_value(), i64::min_value());\n+                let (mut min, mut max) = (i128::max_value(), i128::min_value());\n                 for discr in def.discriminants(tcx) {\n-                    let x = discr.to_u128_unchecked() as i64;\n+                    let x = discr.to_u128_unchecked() as i128;\n                     if x < min { min = x; }\n                     if x > max { max = x; }\n                 }\n-                // FIXME: should handle i128? signed-value based impl is weird and hard to\n-                // grok.\n                 let (min_ity, signed) = Integer::repr_discr(tcx, ty, &def.repr, min, max);\n \n                 let mut align = dl.aggregate_align;\n@@ -1479,9 +1477,7 @@ impl<'a, 'tcx> CachedLayout {\n                 tcx.intern_layout(CachedLayout {\n                     variants: Variants::Tagged {\n                         discr,\n-\n-                        // FIXME: should be u128?\n-                        discr_range: (min as u64)..=(max as u64),\n+                        discr_range: (min as u128)..=(max as u128),\n                         variants\n                     },\n                     // FIXME(eddyb): using `FieldPlacement::Arbitrary` here results"}, {"sha": "9da3a479f0c28b8d78d3c56a96ff4930c58a87b5", "filename": "src/librustc_trans/builder.rs", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/de3e581e29b1fd02fe4ef5cc415e5173f30e2ca7/src%2Flibrustc_trans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de3e581e29b1fd02fe4ef5cc415e5173f30e2ca7/src%2Flibrustc_trans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuilder.rs?ref=de3e581e29b1fd02fe4ef5cc415e5173f30e2ca7", "patch": "@@ -24,6 +24,7 @@ use rustc::session::{config, Session};\n \n use std::borrow::Cow;\n use std::ffi::CString;\n+use std::ops::Range;\n use std::ptr;\n use syntax_pos::Span;\n \n@@ -549,35 +550,26 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     }\n \n \n-    pub fn load_range_assert(&self, ptr: ValueRef, lo: u64,\n-                             hi: u64, signed: llvm::Bool,\n-                             align: Option<Align>) -> ValueRef {\n-        let value = self.load(ptr, align);\n-\n+    pub fn range_metadata(&self, load: ValueRef, range: Range<u128>) {\n         unsafe {\n-            let t = llvm::LLVMGetElementType(llvm::LLVMTypeOf(ptr));\n-            let min = llvm::LLVMConstInt(t, lo, signed);\n-            let max = llvm::LLVMConstInt(t, hi, signed);\n-\n-            let v = [min, max];\n+            let llty = val_ty(load);\n+            let v = [\n+                C_uint_big(llty, range.start),\n+                C_uint_big(llty, range.end)\n+            ];\n \n-            llvm::LLVMSetMetadata(value, llvm::MD_range as c_uint,\n+            llvm::LLVMSetMetadata(load, llvm::MD_range as c_uint,\n                                   llvm::LLVMMDNodeInContext(self.ccx.llcx(),\n                                                             v.as_ptr(),\n                                                             v.len() as c_uint));\n         }\n-\n-        value\n     }\n \n-    pub fn load_nonnull(&self, ptr: ValueRef, align: Option<Align>) -> ValueRef {\n-        let value = self.load(ptr, align);\n+    pub fn nonnull_metadata(&self, load: ValueRef) {\n         unsafe {\n-            llvm::LLVMSetMetadata(value, llvm::MD_nonnull as c_uint,\n+            llvm::LLVMSetMetadata(load, llvm::MD_nonnull as c_uint,\n                                   llvm::LLVMMDNodeInContext(self.ccx.llcx(), ptr::null(), 0));\n         }\n-\n-        value\n     }\n \n     pub fn store(&self, val: ValueRef, ptr: ValueRef, align: Option<Align>) -> ValueRef {"}, {"sha": "f476416619e699810cf5779b74fd2cd331854aff", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de3e581e29b1fd02fe4ef5cc415e5173f30e2ca7/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de3e581e29b1fd02fe4ef5cc415e5173f30e2ca7/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=de3e581e29b1fd02fe4ef5cc415e5173f30e2ca7", "patch": "@@ -178,9 +178,9 @@ pub fn C_uint(t: Type, i: u64) -> ValueRef {\n     }\n }\n \n-pub fn C_big_integral(t: Type, u: u128) -> ValueRef {\n+pub fn C_uint_big(t: Type, u: u128) -> ValueRef {\n     unsafe {\n-        let words = [u as u64, u.wrapping_shr(64) as u64];\n+        let words = [u as u64, (u >> 64) as u64];\n         llvm::LLVMConstIntOfArbitraryPrecision(t.to_ref(), 2, words.as_ptr())\n     }\n }"}, {"sha": "a7d467f1cc5f3f572cb4d2dc0fb2f29b3952bba5", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/de3e581e29b1fd02fe4ef5cc415e5173f30e2ca7/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de3e581e29b1fd02fe4ef5cc415e5173f30e2ca7/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=de3e581e29b1fd02fe4ef5cc415e5173f30e2ca7", "patch": "@@ -40,7 +40,8 @@ impl<'a, 'tcx> VirtualIndex {\n         debug!(\"get_fn({:?}, {:?})\", Value(llvtable), self);\n \n         let llvtable = bcx.pointercast(llvtable, fn_ty.llvm_type(bcx.ccx).ptr_to().ptr_to());\n-        let ptr = bcx.load_nonnull(bcx.inbounds_gep(llvtable, &[C_usize(bcx.ccx, self.0)]), None);\n+        let ptr = bcx.load(bcx.inbounds_gep(llvtable, &[C_usize(bcx.ccx, self.0)]), None);\n+        bcx.nonnull_metadata(ptr);\n         // Vtable loads are invariant\n         bcx.set_invariant_load(ptr);\n         ptr"}, {"sha": "cc0bbb8145dbdcbeb9c07111a7bb306519ceae29", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/de3e581e29b1fd02fe4ef5cc415e5173f30e2ca7/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de3e581e29b1fd02fe4ef5cc415e5173f30e2ca7/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=de3e581e29b1fd02fe4ef5cc415e5173f30e2ca7", "patch": "@@ -666,17 +666,18 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n         if by_ref && !arg.is_indirect() {\n             // Have to load the argument, maybe while casting it.\n-            if arg.layout.ty == bcx.tcx().types.bool {\n-                llval = bcx.load_range_assert(llval, 0, 2, llvm::False, None);\n-                // We store bools as i8 so we need to truncate to i1.\n-                llval = base::to_immediate(bcx, llval, arg.layout);\n-            } else if let Some(ty) = arg.cast {\n+            if let Some(ty) = arg.cast {\n                 llval = bcx.load(bcx.pointercast(llval, ty.llvm_type(bcx.ccx).ptr_to()),\n                                  (align | Alignment::Packed(arg.layout.align))\n                                     .non_abi());\n             } else {\n                 llval = bcx.load(llval, align.non_abi());\n             }\n+            if arg.layout.ty == bcx.tcx().types.bool {\n+                bcx.range_metadata(llval, 0..2);\n+                // We store bools as i8 so we need to truncate to i1.\n+                llval = base::to_immediate(bcx, llval, arg.layout);\n+            }\n         }\n \n         llargs.push(llval);"}, {"sha": "e8ff9ae32483ca132fce518829cfe026a4758d38", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/de3e581e29b1fd02fe4ef5cc415e5173f30e2ca7/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de3e581e29b1fd02fe4ef5cc415e5173f30e2ca7/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=de3e581e29b1fd02fe4ef5cc415e5173f30e2ca7", "patch": "@@ -28,7 +28,7 @@ use abi::{self, Abi};\n use callee;\n use builder::Builder;\n use common::{self, CrateContext, const_get_elt, val_ty};\n-use common::{C_array, C_bool, C_bytes, C_int, C_uint, C_big_integral, C_u32, C_u64};\n+use common::{C_array, C_bool, C_bytes, C_int, C_uint, C_uint_big, C_u32, C_u64};\n use common::{C_null, C_struct, C_str_slice, C_undef, C_usize, C_vector, C_fat_ptr};\n use common::const_to_opt_u128;\n use consts;\n@@ -70,13 +70,13 @@ impl<'a, 'tcx> Const<'tcx> {\n             I16(v) => (C_int(Type::i16(ccx), v as i64), tcx.types.i16),\n             I32(v) => (C_int(Type::i32(ccx), v as i64), tcx.types.i32),\n             I64(v) => (C_int(Type::i64(ccx), v as i64), tcx.types.i64),\n-            I128(v) => (C_big_integral(Type::i128(ccx), v as u128), tcx.types.i128),\n+            I128(v) => (C_uint_big(Type::i128(ccx), v as u128), tcx.types.i128),\n             Isize(v) => (C_int(Type::isize(ccx), v.as_i64()), tcx.types.isize),\n             U8(v) => (C_uint(Type::i8(ccx), v as u64), tcx.types.u8),\n             U16(v) => (C_uint(Type::i16(ccx), v as u64), tcx.types.u16),\n             U32(v) => (C_uint(Type::i32(ccx), v as u64), tcx.types.u32),\n             U64(v) => (C_uint(Type::i64(ccx), v), tcx.types.u64),\n-            U128(v) => (C_big_integral(Type::i128(ccx), v), tcx.types.u128),\n+            U128(v) => (C_uint_big(Type::i128(ccx), v), tcx.types.u128),\n             Usize(v) => (C_uint(Type::isize(ccx), v.as_u64()), tcx.types.usize),\n         };\n         Const { llval: llval, ty: ty }\n@@ -994,7 +994,7 @@ unsafe fn cast_const_float_to_int(ccx: &CrateContext,\n         let err = ConstEvalErr { span: span, kind: ErrKind::CannotCast };\n         err.report(ccx.tcx(), span, \"expression\");\n     }\n-    C_big_integral(int_ty, cast_result.value)\n+    C_uint_big(int_ty, cast_result.value)\n }\n \n unsafe fn cast_const_int_to_float(ccx: &CrateContext,"}, {"sha": "6da9c7a46576620a7b922abfaf4d474e81538b60", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 25, "deletions": 47, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/de3e581e29b1fd02fe4ef5cc415e5173f30e2ca7/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de3e581e29b1fd02fe4ef5cc415e5173f30e2ca7/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=de3e581e29b1fd02fe4ef5cc415e5173f30e2ca7", "patch": "@@ -14,10 +14,9 @@ use rustc::ty::layout::{self, Align, TyLayout, LayoutOf};\n use rustc::mir;\n use rustc::mir::tcx::LvalueTy;\n use rustc_data_structures::indexed_vec::Idx;\n-use abi;\n use base;\n use builder::Builder;\n-use common::{self, CrateContext, C_usize, C_u8, C_u32, C_uint, C_int, C_null, val_ty};\n+use common::{self, CrateContext, C_usize, C_u8, C_u32, C_uint, C_int, C_null};\n use consts;\n use type_of::LayoutLlvmExt;\n use type_::Type;\n@@ -140,30 +139,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n             return OperandRef::new_zst(bcx.ccx, self.layout);\n         }\n \n-        let val = if common::type_is_fat_ptr(bcx.ccx, self.layout.ty) {\n-            let data = self.project_field(bcx, abi::FAT_PTR_ADDR);\n-            let lldata = if self.layout.ty.is_region_ptr() || self.layout.ty.is_box() {\n-                bcx.load_nonnull(data.llval, data.alignment.non_abi())\n-            } else {\n-                bcx.load(data.llval, data.alignment.non_abi())\n-            };\n-\n-            let extra = self.project_field(bcx, abi::FAT_PTR_EXTRA);\n-            let meta_ty = val_ty(extra.llval);\n-            // If the 'extra' field is a pointer, it's a vtable, so use load_nonnull\n-            // instead\n-            let llextra = if meta_ty.element_type().kind() == llvm::TypeKind::Pointer {\n-                bcx.load_nonnull(extra.llval, extra.alignment.non_abi())\n-            } else {\n-                bcx.load(extra.llval, extra.alignment.non_abi())\n-            };\n-\n-            OperandValue::Pair(lldata, llextra)\n-        } else if common::type_is_imm_pair(bcx.ccx, self.layout.ty) {\n-            OperandValue::Pair(\n-                self.project_field(bcx, 0).load(bcx).pack_if_pair(bcx).immediate(),\n-                self.project_field(bcx, 1).load(bcx).pack_if_pair(bcx).immediate())\n-        } else if self.layout.is_llvm_immediate() {\n+        let val = if self.layout.is_llvm_immediate() {\n             let mut const_llval = ptr::null_mut();\n             unsafe {\n                 let global = llvm::LLVMIsAGlobalVariable(self.llval);\n@@ -174,22 +150,26 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n \n             let llval = if !const_llval.is_null() {\n                 const_llval\n-            } else if self.layout.ty.is_bool() {\n-                bcx.load_range_assert(self.llval, 0, 2, llvm::False,\n-                    self.alignment.non_abi())\n-            } else if self.layout.ty.is_char() {\n-                // a char is a Unicode codepoint, and so takes values from 0\n-                // to 0x10FFFF inclusive only.\n-                bcx.load_range_assert(self.llval, 0, 0x10FFFF + 1, llvm::False,\n-                    self.alignment.non_abi())\n-            } else if self.layout.ty.is_region_ptr() ||\n-                      self.layout.ty.is_box() ||\n-                      self.layout.ty.is_fn() {\n-                bcx.load_nonnull(self.llval, self.alignment.non_abi())\n             } else {\n-                bcx.load(self.llval, self.alignment.non_abi())\n+                let load = bcx.load(self.llval, self.alignment.non_abi());\n+                if self.layout.ty.is_bool() {\n+                    bcx.range_metadata(load, 0..2);\n+                } else if self.layout.ty.is_char() {\n+                    // a char is a Unicode codepoint, and so takes values from 0\n+                    // to 0x10FFFF inclusive only.\n+                    bcx.range_metadata(load, 0..0x10FFFF+1);\n+                } else if self.layout.ty.is_region_ptr() ||\n+                        self.layout.ty.is_box() ||\n+                        self.layout.ty.is_fn() {\n+                    bcx.nonnull_metadata(load);\n+                }\n+                load\n             };\n             OperandValue::Immediate(base::to_immediate(bcx, llval, self.layout))\n+        } else if common::type_is_imm_pair(bcx.ccx, self.layout.ty) {\n+            OperandValue::Pair(\n+                self.project_field(bcx, 0).load(bcx).pack_if_pair(bcx).immediate(),\n+                self.project_field(bcx, 1).load(bcx).pack_if_pair(bcx).immediate())\n         } else {\n             OperandValue::Ref(self.llval, self.alignment)\n         };\n@@ -314,28 +294,26 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n             layout::Variants::Tagged { ref discr_range, .. } => {\n                 (discr_range.start, discr_range.end)\n             }\n-            _ => (0, u64::max_value()),\n+            _ => (0, !0),\n         };\n         let max_next = max.wrapping_add(1);\n         let bits = discr_scalar.size(bcx.ccx).bits();\n-        assert!(bits <= 64);\n-        let mask = !0u64 >> (64 - bits);\n-        let lldiscr = match discr_scalar {\n+        assert!(bits <= 128);\n+        let mask = !0u128 >> (128 - bits);\n+        let lldiscr = bcx.load(discr.llval, discr.alignment.non_abi());\n+        match discr_scalar {\n             // For a (max) discr of -1, max will be `-1 as usize`, which overflows.\n             // However, that is fine here (it would still represent the full range),\n             layout::Int(..) if max_next & mask != min & mask => {\n                 // llvm::ConstantRange can deal with ranges that wrap around,\n                 // so an overflow on (max + 1) is fine.\n-                bcx.load_range_assert(discr.llval, min, max_next,\n-                                      /* signed: */ llvm::True,\n-                                      discr.alignment.non_abi())\n+                bcx.range_metadata(lldiscr, min..max_next);\n             }\n             _ => {\n                 // i.e., if the range is everything.  The lo==hi case would be\n                 // rejected by the LLVM verifier (it would mean either an\n                 // empty set, which is impossible, or the entire range of the\n                 // type, which is pointless).\n-                bcx.load(discr.llval, discr.alignment.non_abi())\n             }\n         };\n         match self.layout.variants {"}, {"sha": "f584c6a653e5fa291587ef453b34cebdcc4794cd", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/de3e581e29b1fd02fe4ef5cc415e5173f30e2ca7/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de3e581e29b1fd02fe4ef5cc415e5173f30e2ca7/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=de3e581e29b1fd02fe4ef5cc415e5173f30e2ca7", "patch": "@@ -23,7 +23,7 @@ use base;\n use builder::Builder;\n use callee;\n use common::{self, val_ty};\n-use common::{C_bool, C_u8, C_i32, C_u32, C_u64, C_null, C_usize, C_uint, C_big_integral};\n+use common::{C_bool, C_u8, C_i32, C_u32, C_u64, C_null, C_usize, C_uint, C_uint_big};\n use consts;\n use monomorphize;\n use type_::Type;\n@@ -289,7 +289,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                                 base::call_assume(&bcx, bcx.icmp(\n                                     llvm::IntULE,\n                                     llval,\n-                                    C_uint(ll_t_in, discr_range.end)\n+                                    C_uint_big(ll_t_in, discr_range.end)\n                                 ));\n                             }\n                             _ => {}\n@@ -807,7 +807,7 @@ fn cast_int_to_float(bcx: &Builder,\n     if is_u128_to_f32 {\n         // All inputs greater or equal to (f32::MAX + 0.5 ULP) are rounded to infinity,\n         // and for everything else LLVM's uitofp works just fine.\n-        let max = C_big_integral(int_ty, MAX_F32_PLUS_HALF_ULP);\n+        let max = C_uint_big(int_ty, MAX_F32_PLUS_HALF_ULP);\n         let overflow = bcx.icmp(llvm::IntUGE, x, max);\n         let infinity_bits = C_u32(bcx.ccx, ieee::Single::INFINITY.to_bits() as u32);\n         let infinity = consts::bitcast(infinity_bits, float_ty);\n@@ -934,8 +934,8 @@ fn cast_float_to_int(bcx: &Builder,\n     // performed is ultimately up to the backend, but at least x86 does perform them.\n     let less_or_nan = bcx.fcmp(llvm::RealULT, x, f_min);\n     let greater = bcx.fcmp(llvm::RealOGT, x, f_max);\n-    let int_max = C_big_integral(int_ty, int_max(signed, int_ty));\n-    let int_min = C_big_integral(int_ty, int_min(signed, int_ty) as u128);\n+    let int_max = C_uint_big(int_ty, int_max(signed, int_ty));\n+    let int_min = C_uint_big(int_ty, int_min(signed, int_ty) as u128);\n     let s0 = bcx.select(less_or_nan, int_min, fptosui_result);\n     let s1 = bcx.select(greater, int_max, s0);\n "}]}