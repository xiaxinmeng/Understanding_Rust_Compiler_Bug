{"sha": "c28ada0368de78034e0930e01406f5e03a70d610", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyOGFkYTAzNjhkZTc4MDM0ZTA5MzBlMDE0MDZmNWUwM2E3MGQ2MTA=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2011-12-09T16:16:04Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2011-12-14T22:32:18Z"}, "message": "first attempt, not happy with it", "tree": {"sha": "cd2707ac10933a2637f2da5c0e1c758daaa8c3ba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cd2707ac10933a2637f2da5c0e1c758daaa8c3ba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c28ada0368de78034e0930e01406f5e03a70d610", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c28ada0368de78034e0930e01406f5e03a70d610", "html_url": "https://github.com/rust-lang/rust/commit/c28ada0368de78034e0930e01406f5e03a70d610", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c28ada0368de78034e0930e01406f5e03a70d610/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "941101a9cdcd45e674e8ef57201a99a9d454e89f", "url": "https://api.github.com/repos/rust-lang/rust/commits/941101a9cdcd45e674e8ef57201a99a9d454e89f", "html_url": "https://github.com/rust-lang/rust/commit/941101a9cdcd45e674e8ef57201a99a9d454e89f"}], "stats": {"total": 133, "additions": 66, "deletions": 67}, "files": [{"sha": "66e6f3b174109d7fd965ff128041c19315ef6f7e", "filename": "Makefile.in", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c28ada0368de78034e0930e01406f5e03a70d610/Makefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/c28ada0368de78034e0930e01406f5e03a70d610/Makefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Makefile.in?ref=c28ada0368de78034e0930e01406f5e03a70d610", "patch": "@@ -372,6 +372,10 @@ $(foreach host,$(CFG_TARGET_TRIPLES),\t\t\t\t\t\t\t\\\n  $(eval $(foreach stage,1 2 3,\t\t\t\t\t\t\t\t\t\\\n   $(eval $(call DEF_RUSTC_STAGE_TARGET,$(host),$(stage))))))\n \n+rustc-stage1: rustc-stage1-H-$(CFG_HOST_TRIPLE)\n+rustc-stage2: rustc-stage2-H-$(CFG_HOST_TRIPLE)\n+rustc-stage3: rustc-stage3-H-$(CFG_HOST_TRIPLE)\n+\n define DEF_RUSTC_TARGET\n # $(1) == architecture\n "}, {"sha": "2dc585a61068830f69b355aa357025d7a90931e7", "filename": "src/comp/middle/fn_usage.rs", "status": "modified", "additions": 7, "deletions": 25, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c28ada0368de78034e0930e01406f5e03a70d610/src%2Fcomp%2Fmiddle%2Ffn_usage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c28ada0368de78034e0930e01406f5e03a70d610/src%2Fcomp%2Fmiddle%2Ffn_usage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffn_usage.rs?ref=c28ada0368de78034e0930e01406f5e03a70d610", "patch": "@@ -7,8 +7,7 @@ export check_crate_fn_usage;\n \n type fn_usage_ctx = {\n     tcx: ty::ctxt,\n-    unsafe_fn_legal: bool,\n-    generic_bare_fn_legal: bool\n+    unsafe_fn_legal: bool\n };\n \n fn fn_usage_expr(expr: @ast::expr,\n@@ -29,44 +28,28 @@ fn fn_usage_expr(expr: @ast::expr,\n               _ {}\n             }\n         }\n-        if !ctx.generic_bare_fn_legal\n-            && ty::expr_has_ty_params(ctx.tcx, expr) {\n-            alt ty::struct(ctx.tcx, ty::expr_ty(ctx.tcx, expr)) {\n-              ty::ty_fn(ast::proto_bare., _, _, _, _) {\n-                ctx.tcx.sess.span_fatal(\n-                    expr.span,\n-                    \"generic bare functions can only be called or bound\");\n-              }\n-              _ { }\n-            }\n-        }\n       }\n \n       ast::expr_call(f, args, _) {\n-        let f_ctx = {unsafe_fn_legal: true,\n-                     generic_bare_fn_legal: true with ctx};\n+        let f_ctx = {unsafe_fn_legal: true with ctx};\n         v.visit_expr(f, f_ctx, v);\n \n-        let args_ctx = {unsafe_fn_legal: false,\n-                        generic_bare_fn_legal: false with ctx};\n+        let args_ctx = {unsafe_fn_legal: false with ctx};\n         visit::visit_exprs(args, args_ctx, v);\n       }\n \n       ast::expr_bind(f, args) {\n-        let f_ctx = {unsafe_fn_legal: false,\n-                     generic_bare_fn_legal: true with ctx};\n+        let f_ctx = {unsafe_fn_legal: false with ctx};\n         v.visit_expr(f, f_ctx, v);\n \n-        let args_ctx = {unsafe_fn_legal: false,\n-                        generic_bare_fn_legal: false with ctx};\n+        let args_ctx = {unsafe_fn_legal: false with ctx};\n         for arg in args {\n             visit::visit_expr_opt(arg, args_ctx, v);\n         }\n       }\n \n       _ {\n-        let subctx = {unsafe_fn_legal: false,\n-                      generic_bare_fn_legal: false with ctx};\n+        let subctx = {unsafe_fn_legal: false with ctx};\n         visit::visit_expr(expr, subctx, v);\n       }\n     }\n@@ -79,8 +62,7 @@ fn check_crate_fn_usage(tcx: ty::ctxt, crate: @ast::crate) {\n                   with *visit::default_visitor()});\n     let ctx = {\n         tcx: tcx,\n-        unsafe_fn_legal: false,\n-        generic_bare_fn_legal: false\n+        unsafe_fn_legal: false\n     };\n     visit::visit_crate(*crate, ctx, visit);\n }"}, {"sha": "bf1530e523fdef6306971ce836b18698504c26ac", "filename": "src/comp/middle/freevars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c28ada0368de78034e0930e01406f5e03a70d610/src%2Fcomp%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c28ada0368de78034e0930e01406f5e03a70d610/src%2Fcomp%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffreevars.rs?ref=c28ada0368de78034e0930e01406f5e03a70d610", "patch": "@@ -33,7 +33,7 @@ fn collect_freevars(def_map: resolve::def_map, walker: fn@(visit::vt<int>)) ->\n     let walk_expr =\n         lambda (expr: @ast::expr, &&depth: int, v: visit::vt<int>) {\n             alt expr.node {\n-              ast::expr_fn(f) {\n+              ast::expr_fn(f, captures) {\n                 if f.proto == ast::proto_block ||\n                     f.proto == ast::proto_shared(ast::sugar_normal) ||\n                     f.proto == ast::proto_shared(ast::sugar_sexy) {"}, {"sha": "974c6ca5f7f35f8a0fc47844ea0f4dc0b70aa2c3", "filename": "src/comp/middle/kind.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c28ada0368de78034e0930e01406f5e03a70d610/src%2Fcomp%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c28ada0368de78034e0930e01406f5e03a70d610/src%2Fcomp%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fkind.rs?ref=c28ada0368de78034e0930e01406f5e03a70d610", "patch": "@@ -107,7 +107,14 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n           none. {}\n         }\n       }\n-      expr_fn({proto: proto_shared(_), _}) {\n+      expr_fn({proto: proto_send, _}, captures) {\n+        for free in *freevars::get_freevars(cx.tcx, e.id) {\n+            let id = ast_util::def_id_of_def(free).node;\n+            let ty = ty::node_id_to_type(cx.tcx, id);\n+            check_copy(cx, ty, e.span);\n+        }\n+      }\n+      expr_fn({proto: proto_shared(_), _}, captures) {\n         for free in *freevars::get_freevars(cx.tcx, e.id) {\n             let id = ast_util::def_id_of_def(free).node;\n             let ty = ty::node_id_to_type(cx.tcx, id);"}, {"sha": "9c868fcf8119add4a363ae2c795b266e9031b004", "filename": "src/comp/middle/last_use.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c28ada0368de78034e0930e01406f5e03a70d610/src%2Fcomp%2Fmiddle%2Flast_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c28ada0368de78034e0930e01406f5e03a70d610/src%2Fcomp%2Fmiddle%2Flast_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Flast_use.rs?ref=c28ada0368de78034e0930e01406f5e03a70d610", "patch": "@@ -134,7 +134,8 @@ fn visit_expr(ex: @expr, cx: ctx, v: visit::vt<ctx>) {\n         let arg_ts = ty::ty_fn_args(cx.tcx, ty::expr_ty(cx.tcx, f));\n         for arg in args {\n             alt arg.node {\n-              expr_fn(_) { fns += [arg]; }\n+              //NDM--register captured as uses\n+              expr_fn(_, captured) { fns += [arg]; }\n               _ {\n                 alt arg_ts[i].mode {\n                   by_mut_ref. { clear_if_path(cx, arg, v, false); }"}, {"sha": "0654b6da6994ebdfca5309d39e3b9bfb7e54443d", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c28ada0368de78034e0930e01406f5e03a70d610/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c28ada0368de78034e0930e01406f5e03a70d610/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=c28ada0368de78034e0930e01406f5e03a70d610", "patch": "@@ -4047,7 +4047,8 @@ fn trans_expr(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n         assert op != ast::deref; // lvals are handled above\n         ret trans_unary(bcx, op, x, e.id, dest);\n       }\n-      ast::expr_fn(f) { ret trans_expr_fn(bcx, f, e.span, e.id, dest); }\n+      // NDM captures\n+      ast::expr_fn(f, cap) { ret trans_expr_fn(bcx, f, e.span, e.id, dest); }\n       ast::expr_bind(f, args) { ret trans_bind(bcx, f, args, e.id, dest); }\n       ast::expr_copy(a) {\n         if !ty::expr_is_lval(tcx, a) { ret trans_expr(bcx, a, dest); }"}, {"sha": "929dbce308a10efa4f33dcb9bf83e346b7065f25", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c28ada0368de78034e0930e01406f5e03a70d610/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c28ada0368de78034e0930e01406f5e03a70d610/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=c28ada0368de78034e0930e01406f5e03a70d610", "patch": "@@ -341,7 +341,7 @@ fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n         find_pre_post_expr(fcx, arg);\n         copy_pre_post(fcx.ccx, e.id, arg);\n       }\n-      expr_fn(f) {\n+      expr_fn(f, _) { // NDM captures\n         let rslt = expr_pp(fcx.ccx, e);\n         clear_pp(rslt);\n         for def in *freevars::get_freevars(fcx.ccx.tcx, e.id) {"}, {"sha": "414668f3c4048de25ec166d0127cf4fa0c99f1de", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c28ada0368de78034e0930e01406f5e03a70d610/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c28ada0368de78034e0930e01406f5e03a70d610/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=c28ada0368de78034e0930e01406f5e03a70d610", "patch": "@@ -358,7 +358,7 @@ fn find_pre_post_state_expr(fcx: fn_ctxt, pres: prestate, e: @expr) -> bool {\n       }\n       expr_mac(_) { fcx.ccx.tcx.sess.bug(\"unexpanded macro\"); }\n       expr_lit(l) { ret pure_exp(fcx.ccx, e.id, pres); }\n-      expr_fn(f) { ret pure_exp(fcx.ccx, e.id, pres); }\n+      expr_fn(f, _) { ret pure_exp(fcx.ccx, e.id, pres); } // NDM Captures\n       expr_block(b) {\n         ret find_pre_post_state_block(fcx, pres, b) |\n                 set_prestate_ann(fcx.ccx, e.id, pres) |"}, {"sha": "efa73ea8f44277d6e5826313ee118dc70ee4557d", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c28ada0368de78034e0930e01406f5e03a70d610/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c28ada0368de78034e0930e01406f5e03a70d610/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=c28ada0368de78034e0930e01406f5e03a70d610", "patch": "@@ -1001,7 +1001,7 @@ mod writeback {\n         if !wbcx.success { ret; }\n         resolve_type_vars_for_node(wbcx, e.span, e.id);\n         alt e.node {\n-          ast::expr_fn(f) {\n+          ast::expr_fn(f, _) { // NDM captures?\n             for input in f.decl.inputs {\n                 resolve_type_vars_for_node(wbcx, e.span, input.id);\n             }\n@@ -1526,7 +1526,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n                       some(a) {\n                         let is_block =\n                             alt a.node {\n-                              ast::expr_fn(_) { true }\n+                              ast::expr_fn(_, _) { true }\n                               _ { false }\n                             };\n                         if is_block == check_blocks {\n@@ -1902,7 +1902,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         if !arm_non_bot { result_ty = ty::mk_bot(tcx); }\n         write::ty_only_fixup(fcx, id, result_ty);\n       }\n-      ast::expr_fn(f) {\n+      ast::expr_fn(f, captures) { // NDM captures\n         let cx = @{tcx: tcx};\n         let fty = ty_of_fn_decl(cx.tcx, m_check_tyvar(fcx), f.decl,\n                                  f.proto, [], none).ty;"}, {"sha": "62b24e220d869cc340abd77d9232e1d4135f4491", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c28ada0368de78034e0930e01406f5e03a70d610/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c28ada0368de78034e0930e01406f5e03a70d610/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=c28ada0368de78034e0930e01406f5e03a70d610", "patch": "@@ -237,8 +237,8 @@ tag expr_ {\n // At the moment, one can only capture local variables.\n type capture_ = {\n     is_send: bool,\n-    copies: [ident],\n-    moves: [ident]\n+    copies: [spanned<ident>],\n+    moves: [spanned<ident>]\n };\n \n type capture = spanned<capture_>;"}, {"sha": "564087792eefb0faa25625522a4f2585eb1662ca", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c28ada0368de78034e0930e01406f5e03a70d610/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c28ada0368de78034e0930e01406f5e03a70d610/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=c28ada0368de78034e0930e01406f5e03a70d610", "patch": "@@ -381,7 +381,8 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n           expr_alt(expr, arms) {\n             expr_alt(fld.fold_expr(expr), vec::map(fld.fold_arm, arms))\n           }\n-          expr_fn(f) { expr_fn(fld.fold_fn(f)) }\n+          // NDM fold_captures\n+          expr_fn(f, captures) { expr_fn(fld.fold_fn(f), captures) }\n           expr_block(blk) { expr_block(fld.fold_block(blk)) }\n           expr_move(el, er) {\n             expr_move(fld.fold_expr(el), fld.fold_expr(er))"}, {"sha": "063042e3bad8169a9d4644e4c08a1392674e01b6", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 30, "deletions": 28, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/c28ada0368de78034e0930e01406f5e03a70d610/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c28ada0368de78034e0930e01406f5e03a70d610/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=c28ada0368de78034e0930e01406f5e03a70d610", "patch": "@@ -18,7 +18,7 @@ tag fn_kw {\n     fn_kw_fn;\n     fn_kw_lambda;\n     fn_kw_block;\n-};\n+}\n \n type parse_sess = @{cm: codemap::codemap, mutable next_id: node_id};\n \n@@ -1292,7 +1292,7 @@ fn parse_if_expr(p: parser) -> @ast::expr {\n //   CC := [send; copy ID*; move ID*]\n //\n // where any part is optional and trailing ; is permitted.\n-fn parse_capture_clause(p: parser) -> (bool, @ast::capture) {\n+fn parse_capture_clause(p: parser) -> @ast::capture {\n     fn expect_opt_trailing_semi(p: parser) {\n         if !eat(p, token::SEMI) {\n             if p.peek() != token::RBRACE {\n@@ -1301,12 +1301,13 @@ fn parse_capture_clause(p: parser) -> (bool, @ast::capture) {\n         }\n     }\n \n-    fn eat_ident_list(p: parser) -> [ast::ident] {\n+    fn eat_ident_list(p: parser) -> [ast::spanned<ast::ident>] {\n         let res = [];\n         while true {\n             alt p.peek() {\n               token::IDENT(_, _) {\n-                res += parse_ident(p);\n+                let i = spanned(p.get_lo_pos(), p.get_hi_pos(), parse_ident(p));\n+                res += [i];\n                 if !eat(p, token::COMMA) {\n                     ret res;\n                 }\n@@ -1321,52 +1322,53 @@ fn parse_capture_clause(p: parser) -> (bool, @ast::capture) {\n     let copies = [];\n     let moves = [];\n \n-    if p.peek() != token::LBRACE {\n-        ret (is_send, captures);\n-    }\n-\n-    expect(p, token::LBRACE);\n-    while p.peek() != token::RBRACE {\n-        if eat_word(p, \"send\") {\n-            is_send = true;\n-            expect_opt_trailing_semi(p);\n-        } else if eat_word(p, \"copy\") {\n-            copies += eat_ident_list();\n-            expect_opt_trailing_semi(p);\n-        } else if eat_word(p, \"move\") {\n-            moves += eat_ident_list();\n-            expect_opt_trailing_semi(p);\n-        } else {\n-            let s: str = \"expecting send, copy, or move clause\";\n-            p.fatal(s);\n+    let lo = p.get_lo_pos();\n+    if eat(p, token::LBRACE) {\n+        while !eat(p, token::RBRACE) {\n+            if eat_word(p, \"send\") {\n+                is_send = true;\n+                expect_opt_trailing_semi(p);\n+            } else if eat_word(p, \"copy\") {\n+                copies += eat_ident_list(p);\n+                expect_opt_trailing_semi(p);\n+            } else if eat_word(p, \"move\") {\n+                moves += eat_ident_list(p);\n+                expect_opt_trailing_semi(p);\n+            } else {\n+                let s: str = \"expecting send, copy, or move clause\";\n+                p.fatal(s);\n+            }\n         }\n     }\n+    let hi = p.get_last_hi_pos();\n \n-    ret @{is_send: is_send, copies: copies, moves: moves};\n+    ret @spanned(lo, hi, {is_send: is_send, copies: copies, moves: moves});\n }\n \n fn parse_fn_expr(p: parser, kw: fn_kw) -> @ast::expr {\n     let lo = p.get_last_lo_pos();\n-    let cap = parse_capture_clause(p);\n+    let captures = parse_capture_clause(p);\n     let decl = parse_fn_decl(p, ast::impure_fn, ast::il_normal);\n     let body = parse_block(p);\n-    let proto = alt (kw, cap.is_send) {\n+    let proto = alt (kw, captures.node.is_send) {\n       (fn_kw_fn., true) { ast::proto_bare }\n       (fn_kw_lambda., true) { ast::proto_send }\n       (fn_kw_lambda., false) { ast::proto_shared(ast::sugar_sexy) }\n       (fn_kw_block., false) { ast::proto_block }\n       (_, true) { p.fatal(\"only lambda can be declared sendable\"); }\n-    }\n+    };\n     let _fn = {decl: decl, proto: proto, body: body};\n-    ret mk_expr(p, lo, body.span.hi, ast::expr_fn(_fn, cap));\n+    ret mk_expr(p, lo, body.span.hi, ast::expr_fn(_fn, captures));\n }\n \n fn parse_fn_block_expr(p: parser) -> @ast::expr {\n     let lo = p.get_last_lo_pos();\n     let decl = parse_fn_block_decl(p);\n+    let mid = p.get_last_hi_pos();\n     let body = parse_block_tail(p, lo, ast::default_blk);\n     let _fn = {decl: decl, proto: ast::proto_block, body: body};\n-    ret mk_expr(p, lo, body.span.hi, ast::expr_fn(_fn));\n+    let captures = @spanned(lo, mid, {is_send: false, copies: [], moves: []});\n+    ret mk_expr(p, lo, body.span.hi, ast::expr_fn(_fn, captures));\n }\n \n fn parse_else_expr(p: parser) -> @ast::expr {"}, {"sha": "16b9f89bf637da5e1ec42f4ed80895839b8117f6", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c28ada0368de78034e0930e01406f5e03a70d610/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c28ada0368de78034e0930e01406f5e03a70d610/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=c28ada0368de78034e0930e01406f5e03a70d610", "patch": "@@ -818,7 +818,7 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n         }\n         bclose_(s, expr.span, alt_indent_unit);\n       }\n-      ast::expr_fn(f) {\n+      ast::expr_fn(f, captures) { // NDM captures\n \n         // If the return type is the magic ty_infer, then we need to\n         // pretty print as a lambda-block"}, {"sha": "4f52f15b05d82f58e5b910d207e78a772573e997", "filename": "src/comp/syntax/visit.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c28ada0368de78034e0930e01406f5e03a70d610/src%2Fcomp%2Fsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c28ada0368de78034e0930e01406f5e03a70d610/src%2Fcomp%2Fsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fvisit.rs?ref=c28ada0368de78034e0930e01406f5e03a70d610", "patch": "@@ -273,7 +273,8 @@ fn visit_expr<E>(ex: @expr, e: E, v: vt<E>) {\n         v.visit_expr(x, e, v);\n         for a: arm in arms { v.visit_arm(a, e, v); }\n       }\n-      expr_fn(f) { v.visit_fn(f, [], ex.span, none, ex.id, e, v); }\n+      // NDM add visit routine?\n+      expr_fn(f, captures) { v.visit_fn(f, [], ex.span, none, ex.id, e, v); }\n       expr_block(b) { v.visit_block(b, e, v); }\n       expr_assign(a, b) { v.visit_expr(b, e, v); v.visit_expr(a, e, v); }\n       expr_copy(a) { v.visit_expr(a, e, v); }"}]}