{"sha": "adb2bb6e6175e5eeb51b7ef337b3300afd19301d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkYjJiYjZlNjE3NWU1ZWViNTFiN2VmMzM3YjMzMDBhZmQxOTMwMWQ=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-02-13T17:12:28Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-02-13T17:12:28Z"}, "message": "Rollup merge of #58167 - ljedrz:HirIdify_body_id, r=Zoxc\n\nHirId-ify hir::BodyId\n\nAnother step towards https://github.com/rust-lang/rust/pull/57578.", "tree": {"sha": "398060c60a3d014161e9ee8fdb2207cc27376a33", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/398060c60a3d014161e9ee8fdb2207cc27376a33"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/adb2bb6e6175e5eeb51b7ef337b3300afd19301d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcZE/8CRBK7hj4Ov3rIwAAdHIIAKUiNIB1yLz0osxyyTsayUIV\nwkmKqHscTocNoD+xN+ZTfNlAez7H2Xm+nCbOenK0/dHwTPcgYDTwNlFpC1ORpU6w\nTUUMN9W5HhxzJZOEMFMQihpbmlve8Pd3p/LBHSGnpahr41BW90xsb0+SQyfWjilS\nGtivJ18xpaObpZMdCwfqMScAH6UrB5Mc0GddX9SS7poLWGjAQ8NYjDSBANDVshI+\n94Z+qMq3I9dmZPBDUOXj3leUWAZy/3R7rxjNU5IZs2uB47ngY5vw737b10odW2tU\nYgqjf77/GUFOuJTAjt8GzutCXxsXpbm4w0ubBTT1iG8spCZ8u7mTeQs1DjmxbH0=\n=LpPT\n-----END PGP SIGNATURE-----\n", "payload": "tree 398060c60a3d014161e9ee8fdb2207cc27376a33\nparent 78c60bb865115c5f54e6d3347bc04ca5157e45ca\nparent eac43ccda4858e5415822a3a31bffb029cb0ed2b\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1550077948 +0100\ncommitter GitHub <noreply@github.com> 1550077948 +0100\n\nRollup merge of #58167 - ljedrz:HirIdify_body_id, r=Zoxc\n\nHirId-ify hir::BodyId\n\nAnother step towards https://github.com/rust-lang/rust/pull/57578.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/adb2bb6e6175e5eeb51b7ef337b3300afd19301d", "html_url": "https://github.com/rust-lang/rust/commit/adb2bb6e6175e5eeb51b7ef337b3300afd19301d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "78c60bb865115c5f54e6d3347bc04ca5157e45ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/78c60bb865115c5f54e6d3347bc04ca5157e45ca", "html_url": "https://github.com/rust-lang/rust/commit/78c60bb865115c5f54e6d3347bc04ca5157e45ca"}, {"sha": "eac43ccda4858e5415822a3a31bffb029cb0ed2b", "url": "https://api.github.com/repos/rust-lang/rust/commits/eac43ccda4858e5415822a3a31bffb029cb0ed2b", "html_url": "https://github.com/rust-lang/rust/commit/eac43ccda4858e5415822a3a31bffb029cb0ed2b"}], "stats": {"total": 322, "additions": 175, "deletions": 147}, "files": [{"sha": "b6cf4c1b84d0c6454b91bfb8374518c31eef8756", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 24, "deletions": 5, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=adb2bb6e6175e5eeb51b7ef337b3300afd19301d", "patch": "@@ -127,9 +127,9 @@ impl<'hir> Entry<'hir> {\n         }\n     }\n \n-    fn is_body_owner(self, node_id: NodeId) -> bool {\n+    fn is_body_owner(self, hir_id: HirId) -> bool {\n         match self.associated_body() {\n-            Some(b) => b.node_id == node_id,\n+            Some(b) => b.hir_id == hir_id,\n             None => false,\n         }\n     }\n@@ -438,7 +438,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn body(&self, id: BodyId) -> &'hir Body {\n-        self.read(id.node_id);\n+        self.read_by_hir_id(id.hir_id);\n \n         // N.B., intentionally bypass `self.forest.krate()` so that we\n         // do not trigger a read of the whole krate here\n@@ -462,9 +462,10 @@ impl<'hir> Map<'hir> {\n     /// Returns the `NodeId` that corresponds to the definition of\n     /// which this is the body of, i.e., a `fn`, `const` or `static`\n     /// item (possibly associated), a closure, or a `hir::AnonConst`.\n-    pub fn body_owner(&self, BodyId { node_id }: BodyId) -> NodeId {\n+    pub fn body_owner(&self, BodyId { hir_id }: BodyId) -> NodeId {\n+        let node_id = self.hir_to_node_id(hir_id);\n         let parent = self.get_parent_node(node_id);\n-        assert!(self.map[parent.as_usize()].map_or(false, |e| e.is_body_owner(node_id)));\n+        assert!(self.map[parent.as_usize()].map_or(false, |e| e.is_body_owner(hir_id)));\n         parent\n     }\n \n@@ -488,6 +489,12 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn maybe_body_owned_by_by_hir_id(&self, id: HirId) -> Option<BodyId> {\n+        let node_id = self.hir_to_node_id(id);\n+        self.maybe_body_owned_by(node_id)\n+    }\n+\n     /// Given a body owner's id, returns the `BodyId` associated with it.\n     pub fn body_owned_by(&self, id: NodeId) -> BodyId {\n         self.maybe_body_owned_by(id).unwrap_or_else(|| {\n@@ -521,6 +528,12 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn body_owner_kind_by_hir_id(&self, id: HirId) -> BodyOwnerKind {\n+        let node_id = self.hir_to_node_id(id);\n+        self.body_owner_kind(node_id)\n+    }\n+\n     pub fn ty_param_owner(&self, id: NodeId) -> NodeId {\n         match self.get(id) {\n             Node::Item(&Item { node: ItemKind::Trait(..), .. }) => id,\n@@ -837,6 +850,12 @@ impl<'hir> Map<'hir> {\n         self.local_def_id(self.get_module_parent_node(id))\n     }\n \n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn get_module_parent_by_hir_id(&self, id: HirId) -> DefId {\n+        let node_id = self.hir_to_node_id(id);\n+        self.get_module_parent(node_id)\n+    }\n+\n     /// Returns the `NodeId` of `id`'s nearest module parent, or `id` itself if no\n     /// module parent is in this map.\n     pub fn get_module_parent_node(&self, id: NodeId) -> NodeId {"}, {"sha": "139a4222f89de648ece83e0f145bc15d14cb76b7", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=adb2bb6e6175e5eeb51b7ef337b3300afd19301d", "patch": "@@ -72,7 +72,7 @@ pub mod print;\n /// the `local_id` part of the `HirId` changing, which is a very useful property in\n /// incremental compilation where we have to persist things through changes to\n /// the code base.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, PartialOrd, Ord)]\n pub struct HirId {\n     pub owner: DefIndex,\n     pub local_id: ItemLocalId,\n@@ -1234,7 +1234,7 @@ pub enum UnsafeSource {\n \n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct BodyId {\n-    pub node_id: NodeId,\n+    pub hir_id: HirId,\n }\n \n /// The body of a function, closure, or constant value. In the case of\n@@ -1268,7 +1268,7 @@ pub struct Body {\n impl Body {\n     pub fn id(&self) -> BodyId {\n         BodyId {\n-            node_id: self.value.id\n+            hir_id: self.value.hir_id,\n         }\n     }\n }"}, {"sha": "b10e89373259798624d97801c4f5939b5967094b", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=adb2bb6e6175e5eeb51b7ef337b3300afd19301d", "patch": "@@ -989,8 +989,8 @@ impl<'a> ToStableHashKey<StableHashingContext<'a>> for hir::BodyId {\n     fn to_stable_hash_key(&self,\n                           hcx: &StableHashingContext<'a>)\n                           -> (DefPathHash, hir::ItemLocalId) {\n-        let hir::BodyId { node_id } = *self;\n-        node_id.to_stable_hash_key(hcx)\n+        let hir::BodyId { hir_id } = *self;\n+        hir_id.to_stable_hash_key(hcx)\n     }\n }\n "}, {"sha": "9e0e48e474118fd14730ee363d1f804427b4b026", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=adb2bb6e6175e5eeb51b7ef337b3300afd19301d", "patch": "@@ -105,7 +105,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         };\n \n         if let Some(body_id) = body_id {\n-            let expr = self.tcx.hir().expect_expr(body_id.node_id);\n+            let expr = self.tcx.hir().expect_expr_by_hir_id(body_id.hir_id);\n             local_visitor.visit_expr(expr);\n         }\n "}, {"sha": "a61771b2a4eeab2884b672a2c33391e0ec67b96d", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=adb2bb6e6175e5eeb51b7ef337b3300afd19301d", "patch": "@@ -7,6 +7,7 @@ pub use self::SubregionOrigin::*;\n pub use self::ValuePairs::*;\n pub use crate::ty::IntVarValue;\n \n+use crate::hir;\n use crate::hir::def_id::DefId;\n use crate::infer::canonical::{Canonical, CanonicalVarValues};\n use crate::middle::free_region::RegionRelations;\n@@ -203,7 +204,7 @@ pub struct InferCtxt<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     // for each body-id in this map, which will process the\n     // obligations within. This is expected to be done 'late enough'\n     // that all type inference variables have been bound and so forth.\n-    pub region_obligations: RefCell<Vec<(ast::NodeId, RegionObligation<'tcx>)>>,\n+    pub region_obligations: RefCell<Vec<(hir::HirId, RegionObligation<'tcx>)>>,\n \n     /// What is the innermost universe we have created? Starts out as\n     /// `UniverseIndex::root()` but grows from there as we enter\n@@ -1433,7 +1434,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     pub fn partially_normalize_associated_types_in<T>(\n         &self,\n         span: Span,\n-        body_id: ast::NodeId,\n+        body_id: hir::HirId,\n         param_env: ty::ParamEnv<'tcx>,\n         value: &T,\n     ) -> InferOk<'tcx, T>"}, {"sha": "1f81321d22d6ed1099dd7082ef905130050c1b3c", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=adb2bb6e6175e5eeb51b7ef337b3300afd19301d", "patch": "@@ -98,7 +98,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     pub fn instantiate_opaque_types<T: TypeFoldable<'tcx>>(\n         &self,\n         parent_def_id: DefId,\n-        body_id: ast::NodeId,\n+        body_id: hir::HirId,\n         param_env: ty::ParamEnv<'tcx>,\n         value: &T,\n     ) -> InferOk<'tcx, (T, OpaqueTypeMap<'tcx>)> {\n@@ -632,7 +632,7 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for ReverseMapper<'cx, 'gcx, 'tcx>\n struct Instantiator<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     parent_def_id: DefId,\n-    body_id: ast::NodeId,\n+    body_id: hir::HirId,\n     param_env: ty::ParamEnv<'tcx>,\n     opaque_types: OpaqueTypeMap<'tcx>,\n     obligations: Vec<PredicateObligation<'tcx>>,"}, {"sha": "39aa51a95f793cb9bebe71b05f16bafc9f493df5", "filename": "src/librustc/infer/outlives/env.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs?ref=adb2bb6e6175e5eeb51b7ef337b3300afd19301d", "patch": "@@ -1,7 +1,7 @@\n use crate::infer::outlives::free_region_map::FreeRegionMap;\n use crate::infer::{GenericKind, InferCtxt};\n+use crate::hir;\n use rustc_data_structures::fx::FxHashMap;\n-use syntax::ast;\n use syntax_pos::Span;\n use crate::traits::query::outlives_bounds::{self, OutlivesBound};\n use crate::ty::{self, Ty};\n@@ -55,7 +55,7 @@ pub struct OutlivesEnvironment<'tcx> {\n     // results when proving outlives obligations like `T: 'x` later\n     // (e.g., if `T: 'x` must be proven within the body B1, then we\n     // know it is true if either `'a: 'x` or `'b: 'x`).\n-    region_bound_pairs_map: FxHashMap<ast::NodeId, RegionBoundPairs<'tcx>>,\n+    region_bound_pairs_map: FxHashMap<hir::HirId, RegionBoundPairs<'tcx>>,\n \n     // Used to compute `region_bound_pairs_map`: contains the set of\n     // in-scope region-bound pairs thus far.\n@@ -87,7 +87,7 @@ impl<'a, 'gcx: 'tcx, 'tcx: 'a> OutlivesEnvironment<'tcx> {\n     }\n \n     /// Borrows current value of the `region_bound_pairs`.\n-    pub fn region_bound_pairs_map(&self) -> &FxHashMap<ast::NodeId, RegionBoundPairs<'tcx>> {\n+    pub fn region_bound_pairs_map(&self) -> &FxHashMap<hir::HirId, RegionBoundPairs<'tcx>> {\n         &self.region_bound_pairs_map\n     }\n \n@@ -162,7 +162,7 @@ impl<'a, 'gcx: 'tcx, 'tcx: 'a> OutlivesEnvironment<'tcx> {\n         &mut self,\n         infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n         fn_sig_tys: &[Ty<'tcx>],\n-        body_id: ast::NodeId,\n+        body_id: hir::HirId,\n         span: Span,\n     ) {\n         debug!(\"add_implied_bounds()\");\n@@ -176,7 +176,7 @@ impl<'a, 'gcx: 'tcx, 'tcx: 'a> OutlivesEnvironment<'tcx> {\n     }\n \n     /// Save the current set of region-bound pairs under the given `body_id`.\n-    pub fn save_implied_bounds(&mut self, body_id: ast::NodeId) {\n+    pub fn save_implied_bounds(&mut self, body_id: hir::HirId) {\n         let old = self.region_bound_pairs_map.insert(\n             body_id,\n             self.region_bound_pairs_accum.clone(),"}, {"sha": "bbda3d2fdbf84d9ac15ebb7d186ac0e7cd65fd52", "filename": "src/librustc/infer/outlives/obligations.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs?ref=adb2bb6e6175e5eeb51b7ef337b3300afd19301d", "patch": "@@ -63,7 +63,7 @@ use crate::infer::outlives::env::RegionBoundPairs;\n use crate::infer::outlives::verify::VerifyBoundCx;\n use crate::infer::{self, GenericKind, InferCtxt, RegionObligation, SubregionOrigin, VerifyBound};\n use rustc_data_structures::fx::FxHashMap;\n-use syntax::ast;\n+use crate::hir;\n use crate::traits::ObligationCause;\n use crate::ty::outlives::Component;\n use crate::ty::{self, Region, Ty, TyCtxt, TypeFoldable};\n@@ -76,7 +76,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     /// information).\n     pub fn register_region_obligation(\n         &self,\n-        body_id: ast::NodeId,\n+        body_id: hir::HirId,\n         obligation: RegionObligation<'tcx>,\n     ) {\n         debug!(\n@@ -110,7 +110,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     }\n \n     /// Trait queries just want to pass back type obligations \"as is\"\n-    pub fn take_registered_region_obligations(&self) -> Vec<(ast::NodeId, RegionObligation<'tcx>)> {\n+    pub fn take_registered_region_obligations(&self) -> Vec<(hir::HirId, RegionObligation<'tcx>)> {\n         ::std::mem::replace(&mut *self.region_obligations.borrow_mut(), vec![])\n     }\n \n@@ -149,7 +149,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     /// processed.\n     pub fn process_registered_region_obligations(\n         &self,\n-        region_bound_pairs_map: &FxHashMap<ast::NodeId, RegionBoundPairs<'tcx>>,\n+        region_bound_pairs_map: &FxHashMap<hir::HirId, RegionBoundPairs<'tcx>>,\n         implicit_region_bound: Option<ty::Region<'tcx>>,\n         param_env: ty::ParamEnv<'tcx>,\n     ) {"}, {"sha": "8957bbaa4ad7d9eb3df9793e8398b28e2e6e56fd", "filename": "src/librustc/traits/auto_trait.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fauto_trait.rs?ref=adb2bb6e6175e5eeb51b7ef337b3300afd19301d", "patch": "@@ -202,7 +202,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                 full_env,\n                 ty,\n                 trait_did,\n-                ObligationCause::misc(DUMMY_SP, ast::DUMMY_NODE_ID),\n+                ObligationCause::misc(DUMMY_SP, hir::DUMMY_HIR_ID),\n             );\n             fulfill.select_all_or_error(&infcx).unwrap_or_else(|e| {\n                 panic!(\n@@ -315,7 +315,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n             user_env.caller_bounds.iter().cloned().collect();\n \n         let mut new_env = param_env.clone();\n-        let dummy_cause = ObligationCause::misc(DUMMY_SP, ast::DUMMY_NODE_ID);\n+        let dummy_cause = ObligationCause::misc(DUMMY_SP, hir::DUMMY_HIR_ID);\n \n         while let Some(pred) = predicates.pop_front() {\n             infcx.clear_caches();\n@@ -669,7 +669,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n         select: &mut SelectionContext<'c, 'd, 'cx>,\n         only_projections: bool,\n     ) -> bool {\n-        let dummy_cause = ObligationCause::misc(DUMMY_SP, ast::DUMMY_NODE_ID);\n+        let dummy_cause = ObligationCause::misc(DUMMY_SP, hir::DUMMY_HIR_ID);\n \n         for (obligation, mut predicate) in nested\n             .map(|o| (o.clone(), o.predicate.clone()))"}, {"sha": "459ff4db9e957d6157cc034bb1cd5556eafeb82b", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=adb2bb6e6175e5eeb51b7ef337b3300afd19301d", "patch": "@@ -132,7 +132,7 @@ pub struct ObligationCause<'tcx> {\n     /// (in particular, closures can add new assumptions). See the\n     /// field `region_obligations` of the `FulfillmentContext` for more\n     /// information.\n-    pub body_id: ast::NodeId,\n+    pub body_id: hir::HirId,\n \n     pub code: ObligationCauseCode<'tcx>\n }\n@@ -654,7 +654,7 @@ pub fn type_known_to_meet_bound_modulo_regions<'a, 'gcx, 'tcx>(\n     };\n     let obligation = Obligation {\n         param_env,\n-        cause: ObligationCause::misc(span, ast::DUMMY_NODE_ID),\n+        cause: ObligationCause::misc(span, hir::DUMMY_HIR_ID),\n         recursion_depth: 0,\n         predicate: trait_ref.to_predicate(),\n     };\n@@ -677,7 +677,7 @@ pub fn type_known_to_meet_bound_modulo_regions<'a, 'gcx, 'tcx>(\n         // We can use a dummy node-id here because we won't pay any mind\n         // to region obligations that arise (there shouldn't really be any\n         // anyhow).\n-        let cause = ObligationCause::misc(span, ast::DUMMY_NODE_ID);\n+        let cause = ObligationCause::misc(span, hir::DUMMY_HIR_ID);\n \n         fulfill_cx.register_bound(infcx, param_env, ty, def_id, cause);\n \n@@ -1057,7 +1057,7 @@ impl<'tcx,O> Obligation<'tcx,O> {\n     }\n \n     pub fn misc(span: Span,\n-                body_id: ast::NodeId,\n+                body_id: hir::HirId,\n                 param_env: ty::ParamEnv<'tcx>,\n                 trait_ref: O)\n                 -> Obligation<'tcx, O> {\n@@ -1075,18 +1075,18 @@ impl<'tcx,O> Obligation<'tcx,O> {\n impl<'tcx> ObligationCause<'tcx> {\n     #[inline]\n     pub fn new(span: Span,\n-               body_id: ast::NodeId,\n+               body_id: hir::HirId,\n                code: ObligationCauseCode<'tcx>)\n                -> ObligationCause<'tcx> {\n-        ObligationCause { span: span, body_id: body_id, code: code }\n+        ObligationCause { span, body_id, code }\n     }\n \n-    pub fn misc(span: Span, body_id: ast::NodeId) -> ObligationCause<'tcx> {\n-        ObligationCause { span: span, body_id: body_id, code: MiscObligation }\n+    pub fn misc(span: Span, body_id: hir::HirId) -> ObligationCause<'tcx> {\n+        ObligationCause { span, body_id, code: MiscObligation }\n     }\n \n     pub fn dummy() -> ObligationCause<'tcx> {\n-        ObligationCause { span: DUMMY_SP, body_id: ast::CRATE_NODE_ID, code: MiscObligation }\n+        ObligationCause { span: DUMMY_SP, body_id: hir::CRATE_HIR_ID, code: MiscObligation }\n     }\n }\n "}, {"sha": "954de15905fb7092875e64a2178671e232f5e8bc", "filename": "src/librustc/traits/query/outlives_bounds.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs?ref=adb2bb6e6175e5eeb51b7ef337b3300afd19301d", "patch": "@@ -1,6 +1,6 @@\n use crate::infer::InferCtxt;\n use crate::infer::canonical::OriginalQueryValues;\n-use syntax::ast;\n+use crate::hir;\n use syntax::source_map::Span;\n use crate::traits::{FulfillmentContext, ObligationCause, TraitEngine, TraitEngineExt};\n use crate::traits::query::NoSolution;\n@@ -89,7 +89,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     pub fn implied_outlives_bounds(\n         &self,\n         param_env: ty::ParamEnv<'tcx>,\n-        body_id: ast::NodeId,\n+        body_id: hir::HirId,\n         ty: Ty<'tcx>,\n         span: Span,\n     ) -> Vec<OutlivesBound<'tcx>> {"}, {"sha": "1bb67b3ffaae84cc6e09431d62c19971f5637757", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=adb2bb6e6175e5eeb51b7ef337b3300afd19301d", "patch": "@@ -39,7 +39,7 @@ use std::ops::Deref;\n use rustc_data_structures::sync::{self, Lrc, ParallelIterator, par_iter};\n use std::slice;\n use std::{mem, ptr};\n-use syntax::ast::{self, DUMMY_NODE_ID, Name, Ident, NodeId};\n+use syntax::ast::{self, Name, Ident, NodeId};\n use syntax::attr;\n use syntax::ext::hygiene::Mark;\n use syntax::symbol::{keywords, Symbol, LocalInternedString, InternedString};\n@@ -2795,7 +2795,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn find_field_index(self, ident: Ident, variant: &VariantDef) -> Option<usize> {\n         variant.fields.iter().position(|field| {\n-            self.adjust_ident(ident, variant.did, DUMMY_NODE_ID).0 == field.ident.modern()\n+            self.adjust_ident(ident, variant.did, hir::DUMMY_HIR_ID).0 == field.ident.modern()\n         })\n     }\n \n@@ -3003,10 +3003,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// its supposed definition name (`def_name`). The method also needs `DefId` of the supposed\n     /// definition's parent/scope to perform comparison.\n     pub fn hygienic_eq(self, use_name: Ident, def_name: Ident, def_parent_def_id: DefId) -> bool {\n-        self.adjust_ident(use_name, def_parent_def_id, DUMMY_NODE_ID).0 == def_name.modern()\n+        self.adjust_ident(use_name, def_parent_def_id, hir::DUMMY_HIR_ID).0 == def_name.modern()\n     }\n \n-    pub fn adjust_ident(self, mut ident: Ident, scope: DefId, block: NodeId) -> (Ident, DefId) {\n+    pub fn adjust_ident(self, mut ident: Ident, scope: DefId, block: hir::HirId) -> (Ident, DefId) {\n         ident = ident.modern();\n         let target_expansion = match scope.krate {\n             LOCAL_CRATE => self.hir().definitions().expansion_that_defined(scope.index),\n@@ -3015,8 +3015,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let scope = match ident.span.adjust(target_expansion) {\n             Some(actual_expansion) =>\n                 self.hir().definitions().parent_module_of_macro_def(actual_expansion),\n-            None if block == DUMMY_NODE_ID => DefId::local(CRATE_DEF_INDEX), // Dummy DefId\n-            None => self.hir().get_module_parent(block),\n+            None if block == hir::DUMMY_HIR_ID => DefId::local(CRATE_DEF_INDEX), // Dummy DefId\n+            None => self.hir().get_module_parent_by_hir_id(block),\n         };\n         (ident, scope)\n     }\n@@ -3193,8 +3193,8 @@ fn param_env<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         if tcx.sess.opts.debugging_opts.chalk { Some(def_id) } else { None }\n     );\n \n-    let body_id = tcx.hir().as_local_node_id(def_id).map_or(DUMMY_NODE_ID, |id| {\n-        tcx.hir().maybe_body_owned_by(id).map_or(id, |body| body.node_id)\n+    let body_id = tcx.hir().as_local_hir_id(def_id).map_or(hir::DUMMY_HIR_ID, |id| {\n+        tcx.hir().maybe_body_owned_by_by_hir_id(id).map_or(id, |body| body.hir_id)\n     });\n     let cause = traits::ObligationCause::misc(tcx.def_span(def_id), body_id);\n     traits::normalize_param_env_or_error(tcx, def_id, unnormalized_env, cause)"}, {"sha": "282bf1219fa5c174deca13a16c972947c71129e5", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=adb2bb6e6175e5eeb51b7ef337b3300afd19301d", "patch": "@@ -1,10 +1,10 @@\n+use crate::hir;\n use crate::hir::def_id::DefId;\n use crate::infer::InferCtxt;\n use crate::ty::subst::Substs;\n use crate::traits;\n use crate::ty::{self, ToPredicate, Ty, TyCtxt, TypeFoldable};\n use std::iter::once;\n-use syntax::ast;\n use syntax_pos::Span;\n use crate::middle::lang_items;\n \n@@ -16,7 +16,7 @@ use crate::middle::lang_items;\n /// say \"$0 is WF if $0 is WF\".\n pub fn obligations<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                    param_env: ty::ParamEnv<'tcx>,\n-                                   body_id: ast::NodeId,\n+                                   body_id: hir::HirId,\n                                    ty: Ty<'tcx>,\n                                    span: Span)\n                                    -> Option<Vec<traits::PredicateObligation<'tcx>>>\n@@ -42,7 +42,7 @@ pub fn obligations<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n /// if `Bar: Eq`.\n pub fn trait_obligations<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                          param_env: ty::ParamEnv<'tcx>,\n-                                         body_id: ast::NodeId,\n+                                         body_id: hir::HirId,\n                                          trait_ref: &ty::TraitRef<'tcx>,\n                                          span: Span)\n                                          -> Vec<traits::PredicateObligation<'tcx>>\n@@ -54,7 +54,7 @@ pub fn trait_obligations<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n \n pub fn predicate_obligations<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                              param_env: ty::ParamEnv<'tcx>,\n-                                             body_id: ast::NodeId,\n+                                             body_id: hir::HirId,\n                                              predicate: &ty::Predicate<'tcx>,\n                                              span: Span)\n                                              -> Vec<traits::PredicateObligation<'tcx>>\n@@ -103,7 +103,7 @@ pub fn predicate_obligations<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n struct WfPredicates<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-    body_id: ast::NodeId,\n+    body_id: hir::HirId,\n     span: Span,\n     out: Vec<traits::PredicateObligation<'tcx>>,\n }"}, {"sha": "307df163866392dcdabd7314bc633cb99e31b421", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=adb2bb6e6175e5eeb51b7ef337b3300afd19301d", "patch": "@@ -404,7 +404,7 @@ fn closure_to_block(closure_id: LocalDefId,\n     match tcx.hir().get(closure_id) {\n         Node::Expr(expr) => match expr.node {\n             hir::ExprKind::Closure(.., body_id, _, _) => {\n-                body_id.node_id\n+                tcx.hir().hir_to_node_id(body_id.hir_id)\n             }\n             _ => {\n                 bug!(\"encountered non-closure id: {}\", closure_id)"}, {"sha": "c593be4e67f4577d0ce57c6ec09a8d624d3f61f4", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=adb2bb6e6175e5eeb51b7ef337b3300afd19301d", "patch": "@@ -1174,9 +1174,9 @@ impl MirPass for QualifyAndPromoteConstants {\n         }\n \n         let def_id = src.def_id();\n-        let id = tcx.hir().as_local_node_id(def_id).unwrap();\n+        let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n         let mut const_promoted_temps = None;\n-        let mode = match tcx.hir().body_owner_kind(id) {\n+        let mode = match tcx.hir().body_owner_kind_by_hir_id(id) {\n             hir::BodyOwnerKind::Closure => Mode::Fn,\n             hir::BodyOwnerKind::Fn => {\n                 if tcx.is_const_fn(def_id) {"}, {"sha": "20f31b3ebc1736e4c4a4244639dac1fbf62713da", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=adb2bb6e6175e5eeb51b7ef337b3300afd19301d", "patch": "@@ -56,8 +56,7 @@ fn const_is_rvalue_promotable_to_static<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let node_id = tcx.hir().as_local_node_id(def_id)\n         .expect(\"rvalue_promotable_map invoked with non-local def-id\");\n     let body_id = tcx.hir().body_owned_by(node_id);\n-    let body_hir_id = tcx.hir().node_to_hir_id(body_id.node_id);\n-    tcx.rvalue_promotable_map(def_id).contains(&body_hir_id.local_id)\n+    tcx.rvalue_promotable_map(def_id).contains(&body_id.hir_id.local_id)\n }\n \n fn rvalue_promotable_map<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,"}, {"sha": "91651ad29dfa48e023beb1f65eb7cf2e9555c018", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=adb2bb6e6175e5eeb51b7ef337b3300afd19301d", "patch": "@@ -805,7 +805,8 @@ impl<'a, 'tcx> NamePrivacyVisitor<'a, 'tcx> {\n                    def: &'tcx ty::AdtDef, // definition of the struct or enum\n                    field: &'tcx ty::FieldDef) { // definition of the field\n         let ident = Ident::new(keywords::Invalid.name(), use_ctxt);\n-        let def_id = self.tcx.adjust_ident(ident, def.did, self.current_item).1;\n+        let current_hir = self.tcx.hir().node_to_hir_id(self.current_item);\n+        let def_id = self.tcx.adjust_ident(ident, def.did, current_hir).1;\n         if !def.is_enum() && !field.vis.is_accessible_from(def_id, self.tcx) {\n             struct_span_err!(self.tcx.sess, span, E0451, \"field `{}` of {} `{}` is private\",\n                              field.ident, def.variant_descr(), self.tcx.item_path_str(def.did))"}, {"sha": "dad45130062a45a1c3d8726f55eb0b37992947cc", "filename": "src/librustc_traits/implied_outlives_bounds.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs?ref=adb2bb6e6175e5eeb51b7ef337b3300afd19301d", "patch": "@@ -1,6 +1,7 @@\n //! Provider for the `implied_outlives_bounds` query.\n //! Do not call this query directory. See [`rustc::traits::query::implied_outlives_bounds`].\n \n+use rustc::hir;\n use rustc::infer::InferCtxt;\n use rustc::infer::canonical::{self, Canonical};\n use rustc::traits::{TraitEngine, TraitEngineExt};\n@@ -11,7 +12,6 @@ use rustc::ty::outlives::Component;\n use rustc::ty::query::Providers;\n use rustc::ty::wf;\n use smallvec::{SmallVec, smallvec};\n-use syntax::ast::DUMMY_NODE_ID;\n use syntax::source_map::DUMMY_SP;\n use rustc::traits::FulfillmentContext;\n \n@@ -65,7 +65,7 @@ fn compute_implied_outlives_bounds<'tcx>(\n         // unresolved inference variables here anyway, but there might be\n         // during typeck under some circumstances.)\n         let obligations =\n-            wf::obligations(infcx, param_env, DUMMY_NODE_ID, ty, DUMMY_SP).unwrap_or(vec![]);\n+            wf::obligations(infcx, param_env, hir::DUMMY_HIR_ID, ty, DUMMY_SP).unwrap_or(vec![]);\n \n         // N.B., all of these predicates *ought* to be easily proven\n         // true. In fact, their correctness is (mostly) implied by"}, {"sha": "38f7a21e66c55fc8a5de858c3fd53968486d0f17", "filename": "src/librustc_traits/normalize_projection_ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc_traits%2Fnormalize_projection_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc_traits%2Fnormalize_projection_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fnormalize_projection_ty.rs?ref=adb2bb6e6175e5eeb51b7ef337b3300afd19301d", "patch": "@@ -1,11 +1,11 @@\n+use rustc::hir;\n use rustc::infer::canonical::{Canonical, QueryResponse};\n use rustc::traits::query::{normalize::NormalizationResult, CanonicalProjectionGoal, NoSolution};\n use rustc::traits::{self, ObligationCause, SelectionContext, TraitEngineExt};\n use rustc::ty::query::Providers;\n use rustc::ty::{ParamEnvAnd, TyCtxt};\n use rustc_data_structures::sync::Lrc;\n use std::sync::atomic::Ordering;\n-use syntax::ast::DUMMY_NODE_ID;\n use syntax_pos::DUMMY_SP;\n \n crate fn provide(p: &mut Providers<'_>) {\n@@ -34,7 +34,7 @@ fn normalize_projection_ty<'tcx>(\n              value: goal,\n          }| {\n             let selcx = &mut SelectionContext::new(infcx);\n-            let cause = ObligationCause::misc(DUMMY_SP, DUMMY_NODE_ID);\n+            let cause = ObligationCause::misc(DUMMY_SP, hir::DUMMY_HIR_ID);\n             let mut obligations = vec![];\n             let answer = traits::normalize_projection_type(\n                 selcx,"}, {"sha": "30fbdbdeb443363c1fcb1654e98f9ef344aaae16", "filename": "src/librustc_traits/type_op.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc_traits%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc_traits%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Ftype_op.rs?ref=adb2bb6e6175e5eeb51b7ef337b3300afd19301d", "patch": "@@ -1,6 +1,7 @@\n use rustc::infer::at::ToTrace;\n use rustc::infer::canonical::{Canonical, QueryResponse};\n use rustc::infer::InferCtxt;\n+use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::traits::query::type_op::ascribe_user_type::AscribeUserType;\n use rustc::traits::query::type_op::eq::Eq;\n@@ -18,7 +19,6 @@ use rustc::ty::{\n };\n use rustc_data_structures::sync::Lrc;\n use std::fmt;\n-use syntax::ast;\n use syntax_pos::DUMMY_SP;\n \n crate fn provide(p: &mut Providers<'_>) {\n@@ -71,7 +71,7 @@ impl AscribeUserTypeCx<'me, 'gcx, 'tcx> {\n         self.infcx\n             .partially_normalize_associated_types_in(\n                 DUMMY_SP,\n-                ast::CRATE_NODE_ID,\n+                hir::CRATE_HIR_ID,\n                 self.param_env,\n                 &value,\n             )"}, {"sha": "23e9cd55cdce7f552fff4cfbb1cb05c07c18e61e", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=adb2bb6e6175e5eeb51b7ef337b3300afd19301d", "patch": "@@ -878,8 +878,9 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                                           binding.item_name, binding.span)\n         }?;\n \n+        let hir_ref_id = self.tcx().hir().node_to_hir_id(ref_id);\n         let (assoc_ident, def_scope) =\n-            tcx.adjust_ident(binding.item_name, candidate.def_id(), ref_id);\n+            tcx.adjust_ident(binding.item_name, candidate.def_id(), hir_ref_id);\n         let assoc_ty = tcx.associated_items(candidate.def_id()).find(|i| {\n             i.kind == ty::AssociatedKind::Type && i.ident.modern() == assoc_ident\n         }).expect(\"missing associated type\");\n@@ -1373,7 +1374,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n         };\n \n         let trait_did = bound.def_id();\n-        let (assoc_ident, def_scope) = tcx.adjust_ident(assoc_ident, trait_did, ref_id);\n+        let hir_ref_id = self.tcx().hir().node_to_hir_id(ref_id);\n+        let (assoc_ident, def_scope) = tcx.adjust_ident(assoc_ident, trait_did, hir_ref_id);\n         let item = tcx.associated_items(trait_did).find(|i| {\n             Namespace::from(i.kind) == Namespace::Type &&\n                 i.ident.modern() == assoc_ident"}, {"sha": "f863cfe1887db6f9c726b2652a1668a4ddae7b9e", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=adb2bb6e6175e5eeb51b7ef337b3300afd19301d", "patch": "@@ -1,6 +1,7 @@\n use super::{FnCtxt, PlaceOp, Needs};\n use super::method::MethodCallee;\n \n+use rustc::hir;\n use rustc::infer::{InferCtxt, InferOk};\n use rustc::session::DiagnosticMessageId;\n use rustc::traits::{self, TraitEngine};\n@@ -9,7 +10,7 @@ use rustc::ty::{ToPredicate, TypeFoldable};\n use rustc::ty::adjustment::{Adjustment, Adjust, OverloadedDeref};\n \n use syntax_pos::Span;\n-use syntax::ast::{self, Ident};\n+use syntax::ast::Ident;\n \n use std::iter;\n \n@@ -21,7 +22,7 @@ enum AutoderefKind {\n \n pub struct Autoderef<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-    body_id: ast::NodeId,\n+    body_id: hir::HirId,\n     param_env: ty::ParamEnv<'tcx>,\n     steps: Vec<(Ty<'tcx>, AutoderefKind)>,\n     cur_ty: Ty<'tcx>,\n@@ -87,7 +88,7 @@ impl<'a, 'gcx, 'tcx> Iterator for Autoderef<'a, 'gcx, 'tcx> {\n impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n     pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n                param_env: ty::ParamEnv<'tcx>,\n-               body_id: ast::NodeId,\n+               body_id: hir::HirId,\n                span: Span,\n                base_ty: Ty<'tcx>)\n                -> Autoderef<'a, 'gcx, 'tcx>"}, {"sha": "722af8f0e778d16bbd85a3491977f8eabec5f42a", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=adb2bb6e6175e5eeb51b7ef337b3300afd19301d", "patch": "@@ -641,7 +641,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             .liberate_late_bound_regions(expr_def_id, &bound_sig);\n         let liberated_sig = self.inh.normalize_associated_types_in(\n             body.value.span,\n-            body.value.id,\n+            body.value.hir_id,\n             self.param_env,\n             &liberated_sig,\n         );"}, {"sha": "05ca54df2984b8eab95210201ecceb274fa33d59", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=adb2bb6e6175e5eeb51b7ef337b3300afd19301d", "patch": "@@ -84,10 +84,11 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // `ObligationCause` (and the `FnCtxt`). This is what\n     // `regionck_item` expects.\n     let impl_m_node_id = tcx.hir().as_local_node_id(impl_m.def_id).unwrap();\n+    let impl_m_hir_id = tcx.hir().node_to_hir_id(impl_m_node_id);\n \n     let cause = ObligationCause {\n         span: impl_m_span,\n-        body_id: impl_m_node_id,\n+        body_id: impl_m_hir_id,\n         code: ObligationCauseCode::CompareImplMethodObligation {\n             item_name: impl_m.ident.name,\n             impl_item_def_id: impl_m.def_id,\n@@ -205,7 +206,7 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // Construct trait parameter environment and then shift it into the placeholder viewpoint.\n     // The key step here is to update the caller_bounds's predicates to be\n     // the new hybrid bounds we computed.\n-    let normalize_cause = traits::ObligationCause::misc(impl_m_span, impl_m_node_id);\n+    let normalize_cause = traits::ObligationCause::misc(impl_m_span, impl_m_hir_id);\n     let param_env = ty::ParamEnv::new(\n         tcx.intern_predicates(&hybrid_preds.predicates),\n         Reveal::UserFacing,\n@@ -262,7 +263,7 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         );\n         let impl_sig =\n             inh.normalize_associated_types_in(impl_m_span,\n-                                              impl_m_node_id,\n+                                              impl_m_hir_id,\n                                               param_env,\n                                               &impl_sig);\n         let impl_fty = tcx.mk_fn_ptr(ty::Binder::bind(impl_sig));\n@@ -275,7 +276,7 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             trait_sig.subst(tcx, trait_to_skol_substs);\n         let trait_sig =\n             inh.normalize_associated_types_in(impl_m_span,\n-                                              impl_m_node_id,\n+                                              impl_m_hir_id,\n                                               param_env,\n                                               &trait_sig);\n         let trait_fty = tcx.mk_fn_ptr(ty::Binder::bind(trait_sig));\n@@ -347,8 +348,8 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         // Finally, resolve all regions. This catches wily misuses of\n         // lifetime parameters.\n-        let fcx = FnCtxt::new(&inh, param_env, impl_m_node_id);\n-        fcx.regionck_item(impl_m_node_id, impl_m_span, &[]);\n+        let fcx = FnCtxt::new(&inh, param_env, impl_m_hir_id);\n+        fcx.regionck_item(impl_m_hir_id, impl_m_span, &[]);\n \n         Ok(())\n     })\n@@ -903,22 +904,23 @@ pub fn compare_const_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // Create a parameter environment that represents the implementation's\n         // method.\n         let impl_c_node_id = tcx.hir().as_local_node_id(impl_c.def_id).unwrap();\n+        let impl_c_hir_id = tcx.hir().node_to_hir_id(impl_c_node_id);\n \n         // Compute placeholder form of impl and trait const tys.\n         let impl_ty = tcx.type_of(impl_c.def_id);\n         let trait_ty = tcx.type_of(trait_c.def_id).subst(tcx, trait_to_impl_substs);\n-        let mut cause = ObligationCause::misc(impl_c_span, impl_c_node_id);\n+        let mut cause = ObligationCause::misc(impl_c_span, impl_c_hir_id);\n \n         // There is no \"body\" here, so just pass dummy id.\n         let impl_ty = inh.normalize_associated_types_in(impl_c_span,\n-                                                        impl_c_node_id,\n+                                                        impl_c_hir_id,\n                                                         param_env,\n                                                         &impl_ty);\n \n         debug!(\"compare_const_impl: impl_ty={:?}\", impl_ty);\n \n         let trait_ty = inh.normalize_associated_types_in(impl_c_span,\n-                                                         impl_c_node_id,\n+                                                         impl_c_hir_id,\n                                                          param_env,\n                                                          &trait_ty);\n \n@@ -973,7 +975,7 @@ pub fn compare_const_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             return;\n         }\n \n-        let fcx = FnCtxt::new(&inh, param_env, impl_c_node_id);\n-        fcx.regionck_item(impl_c_node_id, impl_c_span, &[]);\n+        let fcx = FnCtxt::new(&inh, param_env, impl_c_hir_id);\n+        fcx.regionck_item(impl_c_hir_id, impl_c_span, &[]);\n     });\n }"}, {"sha": "ad74e78fecdcdb1270e7b743975cc57b6be0bd79", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=adb2bb6e6175e5eeb51b7ef337b3300afd19301d", "patch": "@@ -1,5 +1,6 @@\n use crate::check::regionck::RegionCtxt;\n \n+use crate::hir;\n use crate::hir::def_id::DefId;\n use rustc::infer::outlives::env::OutlivesEnvironment;\n use rustc::infer::{self, InferOk, SuppressRegionErrors};\n@@ -9,7 +10,6 @@ use rustc::ty::subst::{Subst, Substs, UnpackedKind};\n use rustc::ty::{self, Ty, TyCtxt};\n use crate::util::common::ErrorReported;\n \n-use syntax::ast;\n use syntax_pos::Span;\n \n /// This function confirms that the `Drop` implementation identified by\n@@ -70,7 +70,7 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n     drop_impl_ty: Ty<'tcx>,\n     self_type_did: DefId,\n ) -> Result<(), ErrorReported> {\n-    let drop_impl_node_id = tcx.hir().as_local_node_id(drop_impl_did).unwrap();\n+    let drop_impl_hir_id = tcx.hir().as_local_hir_id(drop_impl_did).unwrap();\n \n     // check that the impl type can be made to match the trait type.\n \n@@ -85,7 +85,7 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n         let fresh_impl_substs = infcx.fresh_substs_for_item(drop_impl_span, drop_impl_did);\n         let fresh_impl_self_ty = drop_impl_ty.subst(tcx, fresh_impl_substs);\n \n-        let cause = &ObligationCause::misc(drop_impl_span, drop_impl_node_id);\n+        let cause = &ObligationCause::misc(drop_impl_span, drop_impl_hir_id);\n         match infcx\n             .at(cause, impl_param_env)\n             .eq(named_type, fresh_impl_self_ty)\n@@ -291,7 +291,7 @@ pub fn check_safety_of_destructor_if_necessary<'a, 'gcx, 'tcx>(\n     rcx: &mut RegionCtxt<'a, 'gcx, 'tcx>,\n     ty: Ty<'tcx>,\n     span: Span,\n-    body_id: ast::NodeId,\n+    body_id: hir::HirId,\n     scope: region::Scope,\n ) -> Result<(), ErrorReported> {\n     debug!(\"check_safety_of_destructor_if_necessary typ: {:?} scope: {:?}\","}, {"sha": "fca9fa0829f7263e6e9f255ff00761b10c4e753a", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=adb2bb6e6175e5eeb51b7ef337b3300afd19301d", "patch": "@@ -58,7 +58,7 @@ fn equate_intrinsic_type<'a, 'tcx>(\n         safety,\n         abi\n     )));\n-    let cause = ObligationCause::new(it.span, it.id, ObligationCauseCode::IntrinsicType);\n+    let cause = ObligationCause::new(it.span, it.hir_id, ObligationCauseCode::IntrinsicType);\n     require_same_types(tcx, &cause, tcx.mk_fn_ptr(tcx.fn_sig(def_id)), fty);\n }\n "}, {"sha": "709177212ada7409e2824b367f9684cf9790d400", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=adb2bb6e6175e5eeb51b7ef337b3300afd19301d", "patch": "@@ -401,7 +401,7 @@ fn method_autoderef_steps<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n     tcx.infer_ctxt().enter_with_canonical(DUMMY_SP, &goal, |ref infcx, goal, inference_vars| {\n         let ParamEnvAnd { param_env, value: self_ty } = goal;\n \n-        let mut autoderef = Autoderef::new(infcx, param_env, ast::DUMMY_NODE_ID, DUMMY_SP, self_ty)\n+        let mut autoderef = Autoderef::new(infcx, param_env, hir::DUMMY_HIR_ID, DUMMY_SP, self_ty)\n             .include_raw_pointers()\n             .silence_errors();\n         let mut reached_raw_pointer = false;\n@@ -1183,7 +1183,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         stable_pick: &Pick,\n         unstable_candidates: &[(&Candidate<'tcx>, Symbol)],\n     ) {\n-        let mut diag = self.tcx.struct_span_lint_node(\n+        let mut diag = self.tcx.struct_span_lint_hir(\n             lint::builtin::UNSTABLE_NAME_COLLISIONS,\n             self.fcx.body_id,\n             self.span,"}, {"sha": "768842ef39214f0e5dc817212e925e8ac356c000", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=adb2bb6e6175e5eeb51b7ef337b3300afd19301d", "patch": "@@ -346,7 +346,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                     };\n \n                                     let field_ty = field.ty(tcx, substs);\n-                                    let scope = self.tcx.hir().get_module_parent(self.body_id);\n+                                    let scope = self.tcx.hir().get_module_parent_by_hir_id(\n+                                        self.body_id);\n                                     if field.vis.is_accessible_from(scope, self.tcx) {\n                                         if self.is_fn_ty(&field_ty, span) {\n                                             err.help(&format!(\"use `({0}.{1})(...)` if you \\\n@@ -499,7 +500,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                               err: &mut DiagnosticBuilder,\n                               mut msg: String,\n                               candidates: Vec<DefId>) {\n-        let module_did = self.tcx.hir().get_module_parent(self.body_id);\n+        let module_did = self.tcx.hir().get_module_parent_by_hir_id(self.body_id);\n         let module_id = self.tcx.hir().as_local_node_id(module_did).unwrap();\n         let krate = self.tcx.hir().krate();\n         let (span, found_use) = UsePlacementFinder::check(self.tcx, krate, module_id);"}, {"sha": "91e44a15882684f3e463b5e1feef378f8110ee60", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=adb2bb6e6175e5eeb51b7ef337b3300afd19301d", "patch": "@@ -510,7 +510,7 @@ impl<'gcx, 'tcx> EnclosingBreakables<'gcx, 'tcx> {\n }\n \n pub struct FnCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    body_id: ast::NodeId,\n+    body_id: hir::HirId,\n \n     /// The parameter environment used for proving trait obligations\n     /// in this function. This can change when we descend into\n@@ -672,7 +672,7 @@ impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n \n     fn normalize_associated_types_in<T>(&self,\n                                         span: Span,\n-                                        body_id: ast::NodeId,\n+                                        body_id: hir::HirId,\n                                         param_env: ty::ParamEnv<'tcx>,\n                                         value: &T) -> T\n         where T : TypeFoldable<'tcx>\n@@ -861,14 +861,14 @@ fn typeck_tables_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 tcx.liberate_late_bound_regions(def_id, &fn_sig);\n             let fn_sig =\n                 inh.normalize_associated_types_in(body.value.span,\n-                                                  body_id.node_id,\n+                                                  body_id.hir_id,\n                                                   param_env,\n                                                   &fn_sig);\n \n             let fcx = check_fn(&inh, param_env, fn_sig, decl, id, body, None).0;\n             fcx\n         } else {\n-            let fcx = FnCtxt::new(&inh, param_env, body.value.id);\n+            let fcx = FnCtxt::new(&inh, param_env, body.value.hir_id);\n             let expected_type = tcx.type_of(def_id);\n             let expected_type = fcx.normalize_associated_types_in(body.value.span, &expected_type);\n             fcx.require_type_is_sized(expected_type, body.value.span, traits::ConstSized);\n@@ -1062,7 +1062,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n \n     // Create the function context.  This is either derived from scratch or,\n     // in the case of closures, based on the outer context.\n-    let mut fcx = FnCtxt::new(inherited, param_env, body.value.id);\n+    let mut fcx = FnCtxt::new(inherited, param_env, body.value.hir_id);\n     *fcx.ps.borrow_mut() = UnsafetyState::function(fn_sig.unsafety, fn_id);\n \n     let declared_ret_ty = fn_sig.output();\n@@ -1169,8 +1169,9 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n                 let substs = fcx.tcx.mk_substs_trait(declared_ret_ty, &[]);\n                 let trait_ref = ty::TraitRef::new(term_id, substs);\n                 let return_ty_span = decl.output.span();\n+                let fn_hir_id = fcx.tcx.hir().node_to_hir_id(fn_id);\n                 let cause = traits::ObligationCause::new(\n-                    return_ty_span, fn_id, ObligationCauseCode::MainFunctionType);\n+                    return_ty_span, fn_hir_id, ObligationCauseCode::MainFunctionType);\n \n                 inherited.register_predicate(\n                     traits::Obligation::new(\n@@ -2022,7 +2023,7 @@ enum TupleArgumentsFlag {\n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn new(inh: &'a Inherited<'a, 'gcx, 'tcx>,\n                param_env: ty::ParamEnv<'tcx>,\n-               body_id: ast::NodeId)\n+               body_id: hir::HirId)\n                -> FnCtxt<'a, 'gcx, 'tcx> {\n         FnCtxt {\n             body_id,"}, {"sha": "792f8eaacd29031d9d1a1eb8cf8d94529a697727", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=adb2bb6e6175e5eeb51b7ef337b3300afd19301d", "patch": "@@ -112,7 +112,7 @@ macro_rules! ignore_err {\n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn regionck_expr(&self, body: &'gcx hir::Body) {\n         let subject = self.tcx.hir().body_owner_def_id(body.id());\n-        let id = body.value.id;\n+        let id = body.value.hir_id;\n         let mut rcx = RegionCtxt::new(\n             self,\n             RepeatingScope(id),\n@@ -138,9 +138,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     /// Region checking during the WF phase for items. `wf_tys` are the\n     /// types from which we should derive implied bounds, if any.\n-    pub fn regionck_item(&self, item_id: ast::NodeId, span: Span, wf_tys: &[Ty<'tcx>]) {\n+    pub fn regionck_item(&self, item_id: hir::HirId, span: Span, wf_tys: &[Ty<'tcx>]) {\n         debug!(\"regionck_item(item.id={:?}, wf_tys={:?})\", item_id, wf_tys);\n-        let subject = self.tcx.hir().local_def_id(item_id);\n+        let subject = self.tcx.hir().local_def_id_from_hir_id(item_id);\n         let mut rcx = RegionCtxt::new(\n             self,\n             RepeatingScope(item_id),\n@@ -166,18 +166,19 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn regionck_fn(&self, fn_id: ast::NodeId, body: &'gcx hir::Body) {\n         debug!(\"regionck_fn(id={})\", fn_id);\n         let subject = self.tcx.hir().body_owner_def_id(body.id());\n-        let node_id = body.value.id;\n+        let hir_id = body.value.hir_id;\n         let mut rcx = RegionCtxt::new(\n             self,\n-            RepeatingScope(node_id),\n-            node_id,\n+            RepeatingScope(hir_id),\n+            hir_id,\n             Subject(subject),\n             self.param_env,\n         );\n \n         if self.err_count_since_creation() == 0 {\n+            let fn_hir_id = self.tcx.hir().node_to_hir_id(fn_id);\n             // regionck assumes typeck succeeded\n-            rcx.visit_fn_body(fn_id, body, self.tcx.hir().span(fn_id));\n+            rcx.visit_fn_body(fn_hir_id, body, self.tcx.hir().span_by_hir_id(fn_hir_id));\n         }\n \n         rcx.resolve_regions_and_report_errors(SuppressRegionErrors::when_nll_is_enabled(self.tcx));\n@@ -201,13 +202,13 @@ pub struct RegionCtxt<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     outlives_environment: OutlivesEnvironment<'tcx>,\n \n     // id of innermost fn body id\n-    body_id: ast::NodeId,\n+    body_id: hir::HirId,\n \n     // call_site scope of innermost fn\n     call_site_scope: Option<region::Scope>,\n \n     // id of innermost fn or loop\n-    repeating_scope: ast::NodeId,\n+    repeating_scope: hir::HirId,\n \n     // id of AST node being analyzed (the subject of the analysis).\n     subject_def_id: DefId,\n@@ -220,14 +221,14 @@ impl<'a, 'gcx, 'tcx> Deref for RegionCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-pub struct RepeatingScope(ast::NodeId);\n+pub struct RepeatingScope(hir::HirId);\n pub struct Subject(DefId);\n \n impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     pub fn new(\n         fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n         RepeatingScope(initial_repeating_scope): RepeatingScope,\n-        initial_body_id: ast::NodeId,\n+        initial_body_id: hir::HirId,\n         Subject(subject): Subject,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> RegionCtxt<'a, 'gcx, 'tcx> {\n@@ -244,7 +245,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn set_repeating_scope(&mut self, scope: ast::NodeId) -> ast::NodeId {\n+    fn set_repeating_scope(&mut self, scope: hir::HirId) -> hir::HirId {\n         mem::replace(&mut self.repeating_scope, scope)\n     }\n \n@@ -301,15 +302,15 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     /// `intravisit::Visitor` impl below.)\n     fn visit_fn_body(\n         &mut self,\n-        id: ast::NodeId, // the id of the fn itself\n+        id: hir::HirId, // the id of the fn itself\n         body: &'gcx hir::Body,\n         span: Span,\n     ) {\n         // When we enter a function, we can derive\n-        debug!(\"visit_fn_body(id={})\", id);\n+        debug!(\"visit_fn_body(id={:?})\", id);\n \n         let body_id = body.id();\n-        self.body_id = body_id.node_id;\n+        self.body_id = body_id.hir_id;\n \n         let call_site = region::Scope {\n             id: body.value.hir_id.local_id,\n@@ -318,11 +319,10 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         self.call_site_scope = Some(call_site);\n \n         let fn_sig = {\n-            let fn_hir_id = self.tcx.hir().node_to_hir_id(id);\n-            match self.tables.borrow().liberated_fn_sigs().get(fn_hir_id) {\n+            match self.tables.borrow().liberated_fn_sigs().get(id) {\n                 Some(f) => f.clone(),\n                 None => {\n-                    bug!(\"No fn-sig entry for id={}\", id);\n+                    bug!(\"No fn-sig entry for id={:?}\", id);\n                 }\n             }\n         };\n@@ -342,11 +342,11 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         self.outlives_environment.add_implied_bounds(\n             self.fcx,\n             &fn_sig_tys[..],\n-            body_id.node_id,\n+            body_id.hir_id,\n             span,\n         );\n         self.outlives_environment\n-            .save_implied_bounds(body_id.node_id);\n+            .save_implied_bounds(body_id.hir_id);\n         self.link_fn_args(\n             region::Scope {\n                 id: body.value.hir_id.local_id,\n@@ -355,7 +355,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             &body.arguments,\n         );\n         self.visit_body(body);\n-        self.visit_region_obligations(body_id.node_id);\n+        self.visit_region_obligations(body_id.hir_id);\n \n         let call_site_scope = self.call_site_scope.unwrap();\n         debug!(\n@@ -365,17 +365,16 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         );\n         let call_site_region = self.tcx.mk_region(ty::ReScope(call_site_scope));\n \n-        let body_hir_id = self.tcx.hir().node_to_hir_id(body_id.node_id);\n-        self.type_of_node_must_outlive(infer::CallReturn(span), body_hir_id, call_site_region);\n+        self.type_of_node_must_outlive(infer::CallReturn(span), body_id.hir_id, call_site_region);\n \n         self.constrain_opaque_types(\n             &self.fcx.opaque_types.borrow(),\n             self.outlives_environment.free_region_map(),\n         );\n     }\n \n-    fn visit_region_obligations(&mut self, node_id: ast::NodeId) {\n-        debug!(\"visit_region_obligations: node_id={}\", node_id);\n+    fn visit_region_obligations(&mut self, hir_id: hir::HirId) {\n+        debug!(\"visit_region_obligations: hir_id={:?}\", hir_id);\n \n         // region checking can introduce new pending obligations\n         // which, when processed, might generate new region\n@@ -474,7 +473,8 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n         let env_snapshot = self.outlives_environment.push_snapshot_pre_closure();\n \n         let body = self.tcx.hir().body(body_id);\n-        self.visit_fn_body(id, body, span);\n+        let hir_id = self.tcx.hir().node_to_hir_id(id);\n+        self.visit_fn_body(hir_id, body, span);\n \n         // Restore state from previous function.\n         self.outlives_environment\n@@ -502,7 +502,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n \n     fn visit_expr(&mut self, expr: &'gcx hir::Expr) {\n         debug!(\n-            \"regionck::visit_expr(e={:?}, repeating_scope={})\",\n+            \"regionck::visit_expr(e={:?}, repeating_scope={:?})\",\n             expr, self.repeating_scope\n         );\n \n@@ -555,7 +555,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         debug!(\n-            \"regionck::visit_expr(e={:?}, repeating_scope={}) - visiting subexprs\",\n+            \"regionck::visit_expr(e={:?}, repeating_scope={:?}) - visiting subexprs\",\n             expr, self.repeating_scope\n         );\n         match expr.node {\n@@ -679,16 +679,16 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n             }\n \n             hir::ExprKind::Loop(ref body, _, _) => {\n-                let repeating_scope = self.set_repeating_scope(body.id);\n+                let repeating_scope = self.set_repeating_scope(body.hir_id);\n                 intravisit::walk_expr(self, expr);\n                 self.set_repeating_scope(repeating_scope);\n             }\n \n             hir::ExprKind::While(ref cond, ref body, _) => {\n-                let repeating_scope = self.set_repeating_scope(cond.id);\n+                let repeating_scope = self.set_repeating_scope(cond.hir_id);\n                 self.visit_expr(&cond);\n \n-                self.set_repeating_scope(body.id);\n+                self.set_repeating_scope(body.hir_id);\n                 self.visit_block(&body);\n \n                 self.set_repeating_scope(repeating_scope);\n@@ -758,7 +758,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn check_expr_fn_block(&mut self, expr: &'gcx hir::Expr, body_id: hir::BodyId) {\n-        let repeating_scope = self.set_repeating_scope(body_id.node_id);\n+        let repeating_scope = self.set_repeating_scope(body_id.hir_id);\n         intravisit::walk_expr(self, expr);\n         self.set_repeating_scope(repeating_scope);\n     }"}, {"sha": "86b2e0bfe8aef6d9a96b51f61aec50baa5239b05", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=adb2bb6e6175e5eeb51b7ef337b3300afd19301d", "patch": "@@ -22,7 +22,7 @@ use rustc::hir;\n /// `F: for<'b, 'tcx> where 'gcx: 'tcx FnOnce(FnCtxt<'b, 'gcx, 'tcx>)`.\n struct CheckWfFcxBuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     inherited: super::InheritedBuilder<'a, 'gcx, 'tcx>,\n-    id: ast::NodeId,\n+    id: hir::HirId,\n     span: Span,\n     param_env: ty::ParamEnv<'tcx>,\n }\n@@ -226,9 +226,10 @@ fn for_item<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>, item: &hir::Item)\n fn for_id<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>, id: ast::NodeId, span: Span)\n                           -> CheckWfFcxBuilder<'a, 'gcx, 'tcx> {\n     let def_id = tcx.hir().local_def_id(id);\n+    let hir_id = tcx.hir().node_to_hir_id(id);\n     CheckWfFcxBuilder {\n         inherited: Inherited::build(tcx, def_id),\n-        id,\n+        id: hir_id,\n         span,\n         param_env: tcx.param_env(def_id),\n     }\n@@ -968,13 +969,13 @@ fn reject_shadowing_parameters(tcx: TyCtxt, def_id: DefId) {\n fn check_false_global_bounds<'a, 'gcx, 'tcx>(\n     fcx: &FnCtxt<'a, 'gcx, 'tcx>,\n     span: Span,\n-    id: ast::NodeId)\n+    id: hir::HirId)\n {\n     use rustc::ty::TypeFoldable;\n \n     let empty_env = ty::ParamEnv::empty();\n \n-    let def_id = fcx.tcx.hir().local_def_id(id);\n+    let def_id = fcx.tcx.hir().local_def_id_from_hir_id(id);\n     let predicates = fcx.tcx.predicates_of(def_id).predicates\n         .iter()\n         .map(|(p, _)| *p)"}, {"sha": "e68c50d752bd5d78c07f71605f6f1191d050587f", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=adb2bb6e6175e5eeb51b7ef337b3300afd19301d", "patch": "@@ -100,7 +100,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         body: &'gcx hir::Body,\n         rustc_dump_user_substs: bool,\n     ) -> WritebackCx<'cx, 'gcx, 'tcx> {\n-        let owner = fcx.tcx.hir().definitions().node_to_hir_id(body.id().node_id);\n+        let owner = body.id().hir_id;\n \n         WritebackCx {\n             fcx,"}, {"sha": "0996d1ff3b9989f2377b2f5396415ea208061682", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=adb2bb6e6175e5eeb51b7ef337b3300afd19301d", "patch": "@@ -162,8 +162,8 @@ fn visit_implementation_of_dispatch_from_dyn<'a, 'tcx>(\n     if impl_did.is_local() {\n         let dispatch_from_dyn_trait = tcx.lang_items().dispatch_from_dyn_trait().unwrap();\n \n-        let impl_node_id = tcx.hir().as_local_node_id(impl_did).unwrap();\n-        let span = tcx.hir().span(impl_node_id);\n+        let impl_hir_id = tcx.hir().as_local_hir_id(impl_did).unwrap();\n+        let span = tcx.hir().span_by_hir_id(impl_hir_id);\n \n         let source = tcx.type_of(impl_did);\n         assert!(!source.has_escaping_bound_vars());\n@@ -185,7 +185,7 @@ fn visit_implementation_of_dispatch_from_dyn<'a, 'tcx>(\n         };\n \n         tcx.infer_ctxt().enter(|infcx| {\n-            let cause = ObligationCause::misc(span, impl_node_id);\n+            let cause = ObligationCause::misc(span, impl_hir_id);\n \n             use ty::TyKind::*;\n             match (&source.sty, &target.sty) {\n@@ -332,7 +332,7 @@ pub fn coerce_unsized_info<'a, 'gcx>(gcx: TyCtxt<'a, 'gcx, 'gcx>,\n     });\n \n     // this provider should only get invoked for local def-ids\n-    let impl_node_id = gcx.hir().as_local_node_id(impl_did).unwrap_or_else(|| {\n+    let impl_hir_id = gcx.hir().as_local_hir_id(impl_did).unwrap_or_else(|| {\n         bug!(\"coerce_unsized_info: invoked for non-local def-id {:?}\", impl_did)\n     });\n \n@@ -344,7 +344,7 @@ pub fn coerce_unsized_info<'a, 'gcx>(gcx: TyCtxt<'a, 'gcx, 'gcx>,\n            source,\n            target);\n \n-    let span = gcx.hir().span(impl_node_id);\n+    let span = gcx.hir().span_by_hir_id(impl_hir_id);\n     let param_env = gcx.param_env(impl_did);\n     assert!(!source.has_escaping_bound_vars());\n \n@@ -355,7 +355,7 @@ pub fn coerce_unsized_info<'a, 'gcx>(gcx: TyCtxt<'a, 'gcx, 'gcx>,\n            target);\n \n     gcx.infer_ctxt().enter(|infcx| {\n-        let cause = ObligationCause::misc(span, impl_node_id);\n+        let cause = ObligationCause::misc(span, impl_hir_id);\n         let check_mutbl = |mt_a: ty::TypeAndMut<'gcx>,\n                            mt_b: ty::TypeAndMut<'gcx>,\n                            mk_ptr: &dyn Fn(Ty<'gcx>) -> Ty<'gcx>| {\n@@ -481,11 +481,11 @@ pub fn coerce_unsized_info<'a, 'gcx>(gcx: TyCtxt<'a, 'gcx, 'gcx>,\n                                being coerced, none found\");\n                     return err_info;\n                 } else if diff_fields.len() > 1 {\n-                    let item = gcx.hir().expect_item(impl_node_id);\n+                    let item = gcx.hir().expect_item_by_hir_id(impl_hir_id);\n                     let span = if let ItemKind::Impl(.., Some(ref t), _, _) = item.node {\n                         t.path.span\n                     } else {\n-                        gcx.hir().span(impl_node_id)\n+                        gcx.hir().span_by_hir_id(impl_hir_id)\n                     };\n \n                     let mut err = struct_span_err!(gcx.sess,\n@@ -527,7 +527,7 @@ pub fn coerce_unsized_info<'a, 'gcx>(gcx: TyCtxt<'a, 'gcx, 'gcx>,\n         let mut fulfill_cx = TraitEngine::new(infcx.tcx);\n \n         // Register an obligation for `A: Trait<B>`.\n-        let cause = traits::ObligationCause::misc(span, impl_node_id);\n+        let cause = traits::ObligationCause::misc(span, impl_hir_id);\n         let predicate = gcx.predicate_for_trait_def(param_env,\n                                                     cause,\n                                                     trait_def_id,"}, {"sha": "7055218577c5c8accb30895dbbff87adb7d455c0", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=adb2bb6e6175e5eeb51b7ef337b3300afd19301d", "patch": "@@ -179,12 +179,12 @@ fn require_same_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n fn check_main_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, main_def_id: DefId) {\n-    let main_id = tcx.hir().as_local_node_id(main_def_id).unwrap();\n+    let main_id = tcx.hir().as_local_hir_id(main_def_id).unwrap();\n     let main_span = tcx.def_span(main_def_id);\n     let main_t = tcx.type_of(main_def_id);\n     match main_t.sty {\n         ty::FnDef(..) => {\n-            if let Some(Node::Item(it)) = tcx.hir().find(main_id) {\n+            if let Some(Node::Item(it)) = tcx.hir().find_by_hir_id(main_id) {\n                 if let hir::ItemKind::Fn(.., ref generics, _) = it.node {\n                     let mut error = false;\n                     if !generics.params.is_empty() {\n@@ -244,12 +244,12 @@ fn check_main_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, main_def_id: DefId) {\n }\n \n fn check_start_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, start_def_id: DefId) {\n-    let start_id = tcx.hir().as_local_node_id(start_def_id).unwrap();\n+    let start_id = tcx.hir().as_local_hir_id(start_def_id).unwrap();\n     let start_span = tcx.def_span(start_def_id);\n     let start_t = tcx.type_of(start_def_id);\n     match start_t.sty {\n         ty::FnDef(..) => {\n-            if let Some(Node::Item(it)) = tcx.hir().find(start_id) {\n+            if let Some(Node::Item(it)) = tcx.hir().find_by_hir_id(start_id) {\n                 if let hir::ItemKind::Fn(.., ref generics, _) = it.node {\n                     let mut error = false;\n                     if !generics.params.is_empty() {"}, {"sha": "d12b5021ca9fae5902c5fe3fbdfd0d7bc8939c6e", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb2bb6e6175e5eeb51b7ef337b3300afd19301d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=adb2bb6e6175e5eeb51b7ef337b3300afd19301d", "patch": "@@ -3830,7 +3830,7 @@ fn print_const(cx: &DocContext, n: ty::LazyConst) -> String {\n }\n \n fn print_const_expr(cx: &DocContext, body: hir::BodyId) -> String {\n-    cx.tcx.hir().node_to_pretty_string(body.node_id)\n+    cx.tcx.hir().hir_to_pretty_string(body.hir_id)\n }\n \n /// Given a type Path, resolve it to a Type using the TyCtxt"}]}