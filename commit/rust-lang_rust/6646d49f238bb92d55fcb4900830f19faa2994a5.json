{"sha": "6646d49f238bb92d55fcb4900830f19faa2994a5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2NDZkNDlmMjM4YmI5MmQ1NWZjYjQ5MDA4MzBmMTlmYWEyOTk0YTU=", "commit": {"author": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2019-04-13T10:38:31Z"}, "committer": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2019-04-14T03:42:20Z"}, "message": "Fix bug and add expr , pat , ty matcher", "tree": {"sha": "1a7091b6e104abedcc086e99f560f36010aefe5f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1a7091b6e104abedcc086e99f560f36010aefe5f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6646d49f238bb92d55fcb4900830f19faa2994a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6646d49f238bb92d55fcb4900830f19faa2994a5", "html_url": "https://github.com/rust-lang/rust/commit/6646d49f238bb92d55fcb4900830f19faa2994a5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6646d49f238bb92d55fcb4900830f19faa2994a5/comments", "author": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "committer": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f66300ccd1e6ef05b633cda06c87f913d1c91a1e", "url": "https://api.github.com/repos/rust-lang/rust/commits/f66300ccd1e6ef05b633cda06c87f913d1c91a1e", "html_url": "https://github.com/rust-lang/rust/commit/f66300ccd1e6ef05b633cda06c87f913d1c91a1e"}], "stats": {"total": 340, "additions": 307, "deletions": 33}, "files": [{"sha": "a530f3b03c2ef145300bf4fdee1af0eb9291d7e3", "filename": "crates/ra_mbe/src/lib.rs", "status": "modified", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/6646d49f238bb92d55fcb4900830f19faa2994a5/crates%2Fra_mbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6646d49f238bb92d55fcb4900830f19faa2994a5/crates%2Fra_mbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Flib.rs?ref=6646d49f238bb92d55fcb4900830f19faa2994a5", "patch": "@@ -189,6 +189,14 @@ impl_froms!(TokenTree: Leaf, Subtree);\n         rules.expand(&invocation_tt).unwrap()\n     }\n \n+    pub(crate) fn expand_to_syntax(\n+        rules: &MacroRules,\n+        invocation: &str,\n+    ) -> ra_syntax::TreeArc<ast::SourceFile> {\n+        let expanded = expand(rules, invocation);\n+        token_tree_to_ast_item_list(&expanded)\n+    }\n+\n     pub(crate) fn assert_expansion(rules: &MacroRules, invocation: &str, expansion: &str) {\n         let expanded = expand(rules, invocation);\n         assert_eq!(expanded.to_string(), expansion);\n@@ -485,4 +493,93 @@ SOURCE_FILE@[0; 40)\n         );\n         assert_expansion(&rules, \"foo! { foo }\", \"fn foo () {let a = foo :: bar ;}\");\n     }\n+\n+    #[test]\n+    fn test_expr() {\n+        let rules = create_rules(\n+            r#\"\n+        macro_rules! foo {\n+            ($ i:expr) => {\n+                 fn bar() { $ i; } \n+            }\n+        }\n+\"#,\n+        );\n+\n+        assert_expansion(\n+            &rules,\n+            \"foo! { 2 + 2 * baz(3).quux() }\",\n+            \"fn bar () {2 + 2 * baz (3) . quux () ;}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_expr_order() {\n+        let rules = create_rules(\n+            r#\"\n+        macro_rules! foo {\n+            ($ i:expr) => {\n+                 fn bar() { $ i * 2; } \n+            }\n+        }\n+\"#,\n+        );\n+\n+        assert_eq!(\n+            expand_to_syntax(&rules, \"foo! { 1 + 1  }\").syntax().debug_dump().trim(),\n+            r#\"SOURCE_FILE@[0; 15)\n+  FN_DEF@[0; 15)\n+    FN_KW@[0; 2) \"fn\"\n+    NAME@[2; 5)\n+      IDENT@[2; 5) \"bar\"\n+    PARAM_LIST@[5; 7)\n+      L_PAREN@[5; 6) \"(\"\n+      R_PAREN@[6; 7) \")\"\n+    BLOCK@[7; 15)\n+      L_CURLY@[7; 8) \"{\"\n+      EXPR_STMT@[8; 14)\n+        BIN_EXPR@[8; 13)\n+          BIN_EXPR@[8; 11)\n+            LITERAL@[8; 9)\n+              INT_NUMBER@[8; 9) \"1\"\n+            PLUS@[9; 10) \"+\"\n+            LITERAL@[10; 11)\n+              INT_NUMBER@[10; 11) \"1\"\n+          STAR@[11; 12) \"*\"\n+          LITERAL@[12; 13)\n+            INT_NUMBER@[12; 13) \"2\"\n+        SEMI@[13; 14) \";\"\n+      R_CURLY@[14; 15) \"}\"\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_ty() {\n+        let rules = create_rules(\n+            r#\"\n+        macro_rules! foo {\n+            ($ i:ty) => (\n+                fn bar() -> $ i { unimplemented!() }\n+            )\n+        }\n+\"#,\n+        );\n+        assert_expansion(\n+            &rules,\n+            \"foo! { Baz<u8> }\",\n+            \"fn bar () -> Baz < u8 > {unimplemented ! ()}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_pat_() {\n+        let rules = create_rules(\n+            r#\"\n+        macro_rules! foo {\n+            ($ i:pat) => { fn foo() { let $ i; } }\n+        }\n+\"#,\n+        );\n+        assert_expansion(&rules, \"foo! { (a, b) }\", \"fn foo () {let (a , b) ;}\");\n+    }\n }"}, {"sha": "7a259f33861698e8c898014de5334563481d4eaa", "filename": "crates/ra_mbe/src/mbe_expander.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6646d49f238bb92d55fcb4900830f19faa2994a5/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6646d49f238bb92d55fcb4900830f19faa2994a5/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs?ref=6646d49f238bb92d55fcb4900830f19faa2994a5", "patch": "@@ -144,6 +144,19 @@ fn match_lhs(pattern: &crate::Subtree, input: &mut TtCursor) -> Result<Bindings,\n                                 input.eat_path().ok_or(ExpandError::UnexpectedToken)?.clone();\n                             res.inner.insert(text.clone(), Binding::Simple(path.into()));\n                         }\n+                        \"expr\" => {\n+                            let expr =\n+                                input.eat_expr().ok_or(ExpandError::UnexpectedToken)?.clone();\n+                            res.inner.insert(text.clone(), Binding::Simple(expr.into()));\n+                        }\n+                        \"ty\" => {\n+                            let ty = input.eat_ty().ok_or(ExpandError::UnexpectedToken)?.clone();\n+                            res.inner.insert(text.clone(), Binding::Simple(ty.into()));\n+                        }\n+                        \"pat\" => {\n+                            let pat = input.eat_pat().ok_or(ExpandError::UnexpectedToken)?.clone();\n+                            res.inner.insert(text.clone(), Binding::Simple(pat.into()));\n+                        }\n                         _ => return Err(ExpandError::UnexpectedToken),\n                     }\n                 }"}, {"sha": "13d5d2169e0ac98379367f2bbeebed2323a8c05e", "filename": "crates/ra_mbe/src/subtree_parser.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6646d49f238bb92d55fcb4900830f19faa2994a5/crates%2Fra_mbe%2Fsrc%2Fsubtree_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6646d49f238bb92d55fcb4900830f19faa2994a5/crates%2Fra_mbe%2Fsrc%2Fsubtree_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsubtree_parser.rs?ref=6646d49f238bb92d55fcb4900830f19faa2994a5", "patch": "@@ -30,6 +30,18 @@ impl<'a> Parser<'a> {\n         self.parse(ra_parser::parse_path)\n     }\n \n+    pub fn parse_expr(self) -> Option<tt::TokenTree> {\n+        self.parse(ra_parser::parse_expr)\n+    }\n+\n+    pub fn parse_ty(self) -> Option<tt::TokenTree> {\n+        self.parse(ra_parser::parse_ty)\n+    }\n+\n+    pub fn parse_pat(self) -> Option<tt::TokenTree> {\n+        self.parse(ra_parser::parse_pat)\n+    }\n+\n     fn parse<F>(self, f: F) -> Option<tt::TokenTree>\n     where\n         F: FnOnce(&dyn TokenSource, &mut dyn TreeSink),"}, {"sha": "0a070b46a04a23ed38b3dc07301d40c4e9b0f239", "filename": "crates/ra_mbe/src/subtree_source.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6646d49f238bb92d55fcb4900830f19faa2994a5/crates%2Fra_mbe%2Fsrc%2Fsubtree_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6646d49f238bb92d55fcb4900830f19faa2994a5/crates%2Fra_mbe%2Fsrc%2Fsubtree_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsubtree_source.rs?ref=6646d49f238bb92d55fcb4900830f19faa2994a5", "patch": "@@ -109,6 +109,8 @@ impl<'a> SubTreeWalker<'a> {\n         self.cursor = match self.ts.get(0) {\n             DelimToken::Token(token) => match token {\n                 tt::TokenTree::Subtree(subtree) => {\n+                    let ts = TokenSeq::from(subtree);\n+                    self.stack.push((ts, 0));\n                     WalkCursor::Token(0, convert_delim(subtree.delimiter, false))\n                 }\n                 tt::TokenTree::Leaf(leaf) => {\n@@ -254,7 +256,7 @@ impl<'a> WalkerOwner<'a> {\n                         }\n                     }\n                 } else if walker.stack.len() == 1 {\n-                    if let DelimToken::Delim(_, is_end) = walker.ts.get(*u) {\n+                    if let DelimToken::Delim(_, is_end) = walker.top().get(*u) {\n                         if !is_end {\n                             let (_, last_idx) = &walker.stack[0];\n                             if let DelimToken::Token(token) = walker.ts.get(*last_idx) {\n@@ -310,10 +312,16 @@ impl<'a> TokenSource for SubtreeTokenSource<'a> {\n         }\n     }\n     fn is_token_joint_to_next(&self, pos: usize) -> bool {\n-        self.walker.get(pos).unwrap().is_joint_to_next\n+        match self.walker.get(pos) {\n+            Some(t) => t.is_joint_to_next,\n+            _ => false,\n+        }\n     }\n     fn is_keyword(&self, pos: usize, kw: &str) -> bool {\n-        self.walker.get(pos).unwrap().text == *kw\n+        match self.walker.get(pos) {\n+            Some(t) => t.text == *kw,\n+            _ => false,\n+        }\n     }\n }\n "}, {"sha": "f6cefe087e5def73a7f80b4eb567cb107607b438", "filename": "crates/ra_mbe/src/tt_cursor.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6646d49f238bb92d55fcb4900830f19faa2994a5/crates%2Fra_mbe%2Fsrc%2Ftt_cursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6646d49f238bb92d55fcb4900830f19faa2994a5/crates%2Fra_mbe%2Fsrc%2Ftt_cursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Ftt_cursor.rs?ref=6646d49f238bb92d55fcb4900830f19faa2994a5", "patch": "@@ -84,6 +84,21 @@ impl<'a> TtCursor<'a> {\n         parser.parse_path()\n     }\n \n+    pub(crate) fn eat_expr(&mut self) -> Option<tt::TokenTree> {\n+        let parser = Parser::new(&mut self.pos, self.subtree);\n+        parser.parse_expr()\n+    }\n+\n+    pub(crate) fn eat_ty(&mut self) -> Option<tt::TokenTree> {\n+        let parser = Parser::new(&mut self.pos, self.subtree);\n+        parser.parse_ty()\n+    }\n+\n+    pub(crate) fn eat_pat(&mut self) -> Option<tt::TokenTree> {\n+        let parser = Parser::new(&mut self.pos, self.subtree);\n+        parser.parse_pat()\n+    }\n+\n     pub(crate) fn expect_char(&mut self, char: char) -> Result<(), ParseError> {\n         if self.at_char(char) {\n             self.bump();"}, {"sha": "5a7a5514190a6189a62375ad143fdb1438393eae", "filename": "crates/ra_parser/src/grammar.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6646d49f238bb92d55fcb4900830f19faa2994a5/crates%2Fra_parser%2Fsrc%2Fgrammar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6646d49f238bb92d55fcb4900830f19faa2994a5/crates%2Fra_parser%2Fsrc%2Fgrammar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar.rs?ref=6646d49f238bb92d55fcb4900830f19faa2994a5", "patch": "@@ -53,6 +53,18 @@ pub(crate) fn path(p: &mut Parser) {\n     paths::type_path(p);\n }\n \n+pub(crate) fn expr(p: &mut Parser) {\n+    expressions::expr(p);\n+}\n+\n+pub(crate) fn type_(p: &mut Parser) {\n+    types::type_(p)\n+}\n+\n+pub(crate) fn pattern(p: &mut Parser) {\n+    patterns::pattern(p)\n+}\n+\n pub(crate) fn reparser(\n     node: SyntaxKind,\n     first_child: Option<SyntaxKind>,"}, {"sha": "2955773256f3189a95bb0ac4b3ee9fa55173ab6b", "filename": "crates/ra_parser/src/grammar/expressions.rs", "status": "modified", "additions": 41, "deletions": 9, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/6646d49f238bb92d55fcb4900830f19faa2994a5/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6646d49f238bb92d55fcb4900830f19faa2994a5/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions.rs?ref=6646d49f238bb92d55fcb4900830f19faa2994a5", "patch": "@@ -8,17 +8,20 @@ const EXPR_FIRST: TokenSet = LHS_FIRST;\n \n pub(super) fn expr(p: &mut Parser) -> BlockLike {\n     let r = Restrictions { forbid_structs: false, prefer_stmt: false };\n-    expr_bp(p, r, 1).1\n+    let mut dollar_lvl = 0;\n+    expr_bp(p, r, 1, &mut dollar_lvl).1\n }\n \n pub(super) fn expr_stmt(p: &mut Parser) -> (Option<CompletedMarker>, BlockLike) {\n     let r = Restrictions { forbid_structs: false, prefer_stmt: true };\n-    expr_bp(p, r, 1)\n+    let mut dollar_lvl = 0;\n+    expr_bp(p, r, 1, &mut dollar_lvl)\n }\n \n fn expr_no_struct(p: &mut Parser) {\n     let r = Restrictions { forbid_structs: true, prefer_stmt: false };\n-    expr_bp(p, r, 1);\n+    let mut dollar_lvl = 0;\n+    expr_bp(p, r, 1, &mut dollar_lvl);\n }\n \n // test block\n@@ -206,8 +209,23 @@ fn current_op(p: &Parser) -> (u8, Op) {\n }\n \n // Parses expression with binding power of at least bp.\n-fn expr_bp(p: &mut Parser, r: Restrictions, bp: u8) -> (Option<CompletedMarker>, BlockLike) {\n-    let mut lhs = match lhs(p, r) {\n+fn expr_bp(\n+    p: &mut Parser,\n+    r: Restrictions,\n+    mut bp: u8,\n+    dollar_lvl: &mut usize,\n+) -> (Option<CompletedMarker>, BlockLike) {\n+    // `newly_dollar_open` is a flag indicated that dollar is just closed after lhs, e.g.\n+    // `$1$ + a`\n+    // We use this flag to skip handling it.\n+    let mut newly_dollar_open = false;\n+\n+    if p.at_l_dollar() {\n+        *dollar_lvl += p.eat_l_dollars();\n+        newly_dollar_open = true;\n+    }\n+\n+    let mut lhs = match lhs(p, r, dollar_lvl) {\n         Some((lhs, blocklike)) => {\n             // test stmt_bin_expr_ambiguity\n             // fn foo() {\n@@ -223,6 +241,15 @@ fn expr_bp(p: &mut Parser, r: Restrictions, bp: u8) -> (Option<CompletedMarker>,\n     };\n \n     loop {\n+        if *dollar_lvl > 0 && p.at_r_dollar() {\n+            *dollar_lvl -= p.eat_r_dollars(*dollar_lvl);\n+            if !newly_dollar_open {\n+                // We \"pump\" bp for make it highest priority\n+                bp = 255;\n+            }\n+            newly_dollar_open = false;\n+        }\n+\n         let is_range = p.current() == DOTDOT || p.current() == DOTDOTEQ;\n         let (op_bp, op) = current_op(p);\n         if op_bp < bp {\n@@ -235,7 +262,8 @@ fn expr_bp(p: &mut Parser, r: Restrictions, bp: u8) -> (Option<CompletedMarker>,\n                 p.bump_compound(kind, n);\n             }\n         }\n-        expr_bp(p, r, op_bp + 1);\n+\n+        expr_bp(p, r, op_bp + 1, dollar_lvl);\n         lhs = m.complete(p, if is_range { RANGE_EXPR } else { BIN_EXPR });\n     }\n     (Some(lhs), BlockLike::NotBlock)\n@@ -244,7 +272,11 @@ fn expr_bp(p: &mut Parser, r: Restrictions, bp: u8) -> (Option<CompletedMarker>,\n const LHS_FIRST: TokenSet =\n     atom::ATOM_EXPR_FIRST.union(token_set![AMP, STAR, EXCL, DOTDOT, DOTDOTEQ, MINUS]);\n \n-fn lhs(p: &mut Parser, r: Restrictions) -> Option<(CompletedMarker, BlockLike)> {\n+fn lhs(\n+    p: &mut Parser,\n+    r: Restrictions,\n+    dollar_lvl: &mut usize,\n+) -> Option<(CompletedMarker, BlockLike)> {\n     let m;\n     let kind = match p.current() {\n         // test ref_expr\n@@ -275,7 +307,7 @@ fn lhs(p: &mut Parser, r: Restrictions) -> Option<(CompletedMarker, BlockLike)>\n             m = p.start();\n             p.bump();\n             if p.at_ts(EXPR_FIRST) {\n-                expr_bp(p, r, 2);\n+                expr_bp(p, r, 2, dollar_lvl);\n             }\n             return Some((m.complete(p, RANGE_EXPR), BlockLike::NotBlock));\n         }\n@@ -287,7 +319,7 @@ fn lhs(p: &mut Parser, r: Restrictions) -> Option<(CompletedMarker, BlockLike)>\n             ));\n         }\n     };\n-    expr_bp(p, r, 255);\n+    expr_bp(p, r, 255, dollar_lvl);\n     Some((m.complete(p, kind), BlockLike::NotBlock))\n }\n "}, {"sha": "03fa9b71e3011cf5f86aee7c0b93e0c0d39901e3", "filename": "crates/ra_parser/src/grammar/patterns.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6646d49f238bb92d55fcb4900830f19faa2994a5/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6646d49f238bb92d55fcb4900830f19faa2994a5/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fpatterns.rs?ref=6646d49f238bb92d55fcb4900830f19faa2994a5", "patch": "@@ -5,7 +5,7 @@ pub(super) const PATTERN_FIRST: TokenSet = expressions::LITERAL_FIRST\n     .union(token_set![REF_KW, MUT_KW, L_PAREN, L_BRACK, AMP, UNDERSCORE, MINUS]);\n \n pub(super) fn pattern(p: &mut Parser) {\n-    pattern_r(p, PAT_RECOVERY_SET)\n+    pattern_r(p, PAT_RECOVERY_SET);\n }\n \n /// Parses a pattern list separated by pipes `|`"}, {"sha": "56755c394b59cc2e276d999f8cd7ae77cba764da", "filename": "crates/ra_parser/src/lib.rs", "status": "modified", "additions": 26, "deletions": 7, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/6646d49f238bb92d55fcb4900830f19faa2994a5/crates%2Fra_parser%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6646d49f238bb92d55fcb4900830f19faa2994a5/crates%2Fra_parser%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Flib.rs?ref=6646d49f238bb92d55fcb4900830f19faa2994a5", "patch": "@@ -53,20 +53,39 @@ pub trait TreeSink {\n     fn error(&mut self, error: ParseError);\n }\n \n-/// Parse given tokens into the given sink as a rust file.\n-pub fn parse(token_source: &dyn TokenSource, tree_sink: &mut dyn TreeSink) {\n+fn parse_from_tokens<F>(token_source: &dyn TokenSource, tree_sink: &mut dyn TreeSink, f: F)\n+where\n+    F: FnOnce(&mut parser::Parser),\n+{\n     let mut p = parser::Parser::new(token_source);\n-    grammar::root(&mut p);\n+    f(&mut p);\n     let events = p.finish();\n     event::process(tree_sink, events);\n }\n \n+/// Parse given tokens into the given sink as a rust file.\n+pub fn parse(token_source: &dyn TokenSource, tree_sink: &mut dyn TreeSink) {\n+    parse_from_tokens(token_source, tree_sink, grammar::root);\n+}\n+\n /// Parse given tokens into the given sink as a path\n pub fn parse_path(token_source: &dyn TokenSource, tree_sink: &mut dyn TreeSink) {\n-    let mut p = parser::Parser::new(token_source);\n-    grammar::path(&mut p);\n-    let events = p.finish();\n-    event::process(tree_sink, events);\n+    parse_from_tokens(token_source, tree_sink, grammar::path);\n+}\n+\n+/// Parse given tokens into the given sink as a expression\n+pub fn parse_expr(token_source: &dyn TokenSource, tree_sink: &mut dyn TreeSink) {\n+    parse_from_tokens(token_source, tree_sink, grammar::expr);\n+}\n+\n+/// Parse given tokens into the given sink as a ty\n+pub fn parse_ty(token_source: &dyn TokenSource, tree_sink: &mut dyn TreeSink) {\n+    parse_from_tokens(token_source, tree_sink, grammar::type_);\n+}\n+\n+/// Parse given tokens into the given sink as a pattern\n+pub fn parse_pat(token_source: &dyn TokenSource, tree_sink: &mut dyn TreeSink) {\n+    parse_from_tokens(token_source, tree_sink, grammar::pattern);\n }\n \n /// A parsing function for a specific braced-block."}, {"sha": "71f1f8b302a40f185eda0418c854910006e16a87", "filename": "crates/ra_parser/src/parser.rs", "status": "modified", "additions": 79, "deletions": 13, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/6646d49f238bb92d55fcb4900830f19faa2994a5/crates%2Fra_parser%2Fsrc%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6646d49f238bb92d55fcb4900830f19faa2994a5/crates%2Fra_parser%2Fsrc%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fparser.rs?ref=6646d49f238bb92d55fcb4900830f19faa2994a5", "patch": "@@ -45,8 +45,9 @@ impl<'t> Parser<'t> {\n     ///\n     /// Useful for parsing things like `>>`.\n     pub(crate) fn current2(&self) -> Option<(SyntaxKind, SyntaxKind)> {\n-        let c1 = self.token_source.token_kind(self.token_pos);\n-        let c2 = self.token_source.token_kind(self.token_pos + 1);\n+        let c1 = self.nth(0);\n+        let c2 = self.nth(1);\n+\n         if self.token_source.is_token_joint_to_next(self.token_pos) {\n             Some((c1, c2))\n         } else {\n@@ -59,9 +60,9 @@ impl<'t> Parser<'t> {\n     ///\n     /// Useful for parsing things like `=>>`.\n     pub(crate) fn current3(&self) -> Option<(SyntaxKind, SyntaxKind, SyntaxKind)> {\n-        let c1 = self.token_source.token_kind(self.token_pos);\n-        let c2 = self.token_source.token_kind(self.token_pos + 1);\n-        let c3 = self.token_source.token_kind(self.token_pos + 2);\n+        let c1 = self.nth(0);\n+        let c2 = self.nth(1);\n+        let c3 = self.nth(2);\n         if self.token_source.is_token_joint_to_next(self.token_pos)\n             && self.token_source.is_token_joint_to_next(self.token_pos + 1)\n         {\n@@ -77,7 +78,23 @@ impl<'t> Parser<'t> {\n         let steps = self.steps.get();\n         assert!(steps <= 10_000_000, \"the parser seems stuck\");\n         self.steps.set(steps + 1);\n-        self.token_source.token_kind(self.token_pos + n)\n+\n+        // It is beecause the Dollar will appear between nth\n+        // Following code skips through it\n+        let mut non_dollars_count = 0;\n+        let mut i = 0;\n+\n+        loop {\n+            let kind = self.token_source.token_kind(self.token_pos + i);\n+            i += 1;\n+\n+            match kind {\n+                EOF => return EOF,\n+                SyntaxKind::L_DOLLAR | SyntaxKind::R_DOLLAR => {}\n+                _ if non_dollars_count == n => return kind,\n+                _ => non_dollars_count += 1,\n+            }\n+        }\n     }\n \n     /// Checks if the current token is `kind`.\n@@ -99,8 +116,6 @@ impl<'t> Parser<'t> {\n     /// consumed between the `start` and the corresponding `Marker::complete`\n     /// belong to the same node.\n     pub(crate) fn start(&mut self) -> Marker {\n-        self.eat_dollars();\n-\n         let pos = self.events.len() as u32;\n         self.push_event(Event::tombstone());\n         Marker::new(pos)\n@@ -185,20 +200,71 @@ impl<'t> Parser<'t> {\n         self.eat_dollars();\n         self.token_pos += usize::from(n_raw_tokens);\n         self.push_event(Event::Token { kind, n_raw_tokens });\n-        self.eat_dollars();\n     }\n \n     fn push_event(&mut self, event: Event) {\n         self.events.push(event)\n     }\n \n     fn eat_dollars(&mut self) {\n-        while self.nth(0) == SyntaxKind::L_DOLLAR || self.nth(0) == SyntaxKind::R_DOLLAR {\n-            let kind = self.nth(0);\n-            self.token_pos += 1;\n-            self.push_event(Event::Token { kind, n_raw_tokens: 1 });\n+        loop {\n+            match self.token_source.token_kind(self.token_pos) {\n+                k @ SyntaxKind::L_DOLLAR | k @ SyntaxKind::R_DOLLAR => {\n+                    self.token_pos += 1;\n+                    self.push_event(Event::Token { kind: k, n_raw_tokens: 1 });\n+                }\n+                _ => {\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+\n+    pub(crate) fn eat_l_dollars(&mut self) -> usize {\n+        let mut ate_count = 0;\n+        loop {\n+            match self.token_source.token_kind(self.token_pos) {\n+                k @ SyntaxKind::L_DOLLAR => {\n+                    self.token_pos += 1;\n+                    self.push_event(Event::Token { kind: k, n_raw_tokens: 1 });\n+                    ate_count += 1;\n+                }\n+                _ => {\n+                    return ate_count;\n+                }\n+            }\n         }\n     }\n+\n+    pub(crate) fn eat_r_dollars(&mut self, max_count: usize) -> usize {\n+        let mut ate_count = 0;\n+        loop {\n+            match self.token_source.token_kind(self.token_pos) {\n+                k @ SyntaxKind::R_DOLLAR => {\n+                    self.token_pos += 1;\n+                    self.push_event(Event::Token { kind: k, n_raw_tokens: 1 });\n+                    ate_count += 1;\n+\n+                    if max_count >= ate_count {\n+                        return ate_count;\n+                    }\n+                }\n+                _ => {\n+                    return ate_count;\n+                }\n+            }\n+        }\n+    }\n+\n+    pub(crate) fn at_l_dollar(&self) -> bool {\n+        let kind = self.token_source.token_kind(self.token_pos);\n+        (kind == SyntaxKind::L_DOLLAR)\n+    }\n+\n+    pub(crate) fn at_r_dollar(&self) -> bool {\n+        let kind = self.token_source.token_kind(self.token_pos);\n+        (kind == SyntaxKind::R_DOLLAR)\n+    }\n }\n \n /// See `Parser::start`."}]}