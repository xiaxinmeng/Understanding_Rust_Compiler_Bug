{"sha": "4b25f08512eab11aec151d8f718fca0d8840d0c0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiMjVmMDg1MTJlYWIxMWFlYzE1MWQ4ZjcxOGZjYTBkODg0MGQwYzA=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-08-04T12:52:57Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-08-17T02:50:57Z"}, "message": "rustc: move trait objects from TraitRef to ExistentialTraitRef.", "tree": {"sha": "ad7537a1817424d79f65f8c67d71a647b5f0489b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ad7537a1817424d79f65f8c67d71a647b5f0489b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b25f08512eab11aec151d8f718fca0d8840d0c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b25f08512eab11aec151d8f718fca0d8840d0c0", "html_url": "https://github.com/rust-lang/rust/commit/4b25f08512eab11aec151d8f718fca0d8840d0c0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b25f08512eab11aec151d8f718fca0d8840d0c0/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ef6af09e3b9df3dd01f0e4d53176b0a72ce5722", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ef6af09e3b9df3dd01f0e4d53176b0a72ce5722", "html_url": "https://github.com/rust-lang/rust/commit/5ef6af09e3b9df3dd01f0e4d53176b0a72ce5722"}], "stats": {"total": 1474, "additions": 682, "deletions": 792}, "files": [{"sha": "951570679e08ea8ced2fd5aba1f513c4920eca87", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=4b25f08512eab11aec151d8f718fca0d8840d0c0", "patch": "@@ -1248,9 +1248,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                      generics: &ty::Generics<'tcx>)\n                                      -> &'tcx subst::Substs<'tcx>\n     {\n-        let type_defs = generics.types.as_full_slice();\n-        let region_defs = generics.regions.as_full_slice();\n-        let substs = Substs::from_param_defs(region_defs, type_defs, |def| {\n+        let substs = Substs::from_generics(generics, |def, _| {\n             self.region_var_for_def(span, def)\n         }, |def, substs| {\n             self.type_var_for_def(span, def, substs)\n@@ -1271,9 +1269,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         assert!(generics.types.len(subst::SelfSpace) == 1);\n         assert!(generics.types.len(subst::FnSpace) == 0);\n \n-        let type_defs = generics.types.as_full_slice();\n-        let region_defs = generics.regions.as_full_slice();\n-        let substs = Substs::from_param_defs(region_defs, type_defs, |def| {\n+        let substs = Substs::from_generics(generics, |def, _| {\n             self.region_var_for_def(span, def)\n         }, |def, substs| {\n             if def.space == subst::SelfSpace {"}, {"sha": "f1701d60fd0c051b259f3f1e85f3617e2d94b0ce", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=4b25f08512eab11aec151d8f718fca0d8840d0c0", "patch": "@@ -231,7 +231,7 @@ fn fundamental_ty(tcx: TyCtxt, ty: Ty) -> bool {\n         ty::TyEnum(def, _) | ty::TyStruct(def, _) =>\n             def.is_fundamental(),\n         ty::TyTrait(ref data) =>\n-            tcx.has_attr(data.principal_def_id(), \"fundamental\"),\n+            tcx.has_attr(data.principal.def_id(), \"fundamental\"),\n         _ =>\n             false\n     }\n@@ -275,7 +275,7 @@ fn ty_is_local_constructor(tcx: TyCtxt, ty: Ty, infer_is_local: InferIsLocal)->\n         }\n \n         ty::TyTrait(ref tt) => {\n-            tt.principal_def_id().is_local()\n+            tt.principal.def_id().is_local()\n         }\n \n         ty::TyError => {"}, {"sha": "ea4fc1c25ab42483a4ff73c6844bf8d1479609b5", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=4b25f08512eab11aec151d8f718fca0d8840d0c0", "patch": "@@ -1133,10 +1133,9 @@ fn confirm_object_candidate<'cx, 'gcx, 'tcx>(\n                 object_ty)\n         }\n     };\n-    let projection_bounds = data.projection_bounds_with_self_ty(selcx.tcx(), object_ty);\n-    let env_predicates = projection_bounds.iter()\n-                                          .map(|p| p.to_predicate())\n-                                          .collect();\n+    let env_predicates = data.projection_bounds.iter().map(|p| {\n+        p.with_self_ty(selcx.tcx(), object_ty).to_predicate()\n+    }).collect();\n     let env_predicate = {\n         let env_predicates = elaborate_predicates(selcx.tcx(), env_predicates);\n "}, {"sha": "73108e7d37f88fa2e64dba6cc08f931edfee7249", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 23, "deletions": 26, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=4b25f08512eab11aec151d8f718fca0d8840d0c0", "patch": "@@ -1528,7 +1528,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 ty::TyTrait(ref data) => {\n                     match this.tcx().lang_items.to_builtin_kind(obligation.predicate.def_id()) {\n                         Some(bound @ ty::BoundSend) | Some(bound @ ty::BoundSync) => {\n-                            if data.bounds.builtin_bounds.contains(&bound) {\n+                            if data.builtin_bounds.contains(&bound) {\n                                 debug!(\"assemble_candidates_from_object_ty: matched builtin bound, \\\n                                         pushing candidate\");\n                                 candidates.vec.push(BuiltinObjectCandidate);\n@@ -1538,7 +1538,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                         _ => {}\n                     }\n \n-                    data.principal_trait_ref_with_self_ty(this.tcx(), self_ty)\n+                    data.principal.with_self_ty(this.tcx(), self_ty)\n                 }\n                 ty::TyInfer(ty::TyVar(_)) => {\n                     debug!(\"assemble_candidates_from_object_ty: ambiguous\");\n@@ -1622,7 +1622,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 // We always upcast when we can because of reason\n                 // #2 (region bounds).\n                 data_a.principal.def_id() == data_a.principal.def_id() &&\n-                data_a.bounds.builtin_bounds.is_superset(&data_b.bounds.builtin_bounds)\n+                data_a.builtin_bounds.is_superset(&data_b.builtin_bounds)\n             }\n \n             // T -> Trait.\n@@ -2179,10 +2179,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         match self_ty.sty {\n             ty::TyTrait(ref data) => {\n                 // OK to skip the binder, it is reintroduced below\n-                let input_types = data.principal.skip_binder().substs.types.get_slice(TypeSpace);\n-                let assoc_types = data.bounds.projection_bounds\n-                                             .iter()\n-                                             .map(|pb| pb.skip_binder().ty);\n+                let input_types = data.principal.skip_binder().input_types();\n+                let assoc_types = data.projection_bounds.iter()\n+                                      .map(|pb| pb.skip_binder().ty);\n                 let all_types: Vec<_> = input_types.iter().cloned()\n                                                           .chain(assoc_types)\n                                                           .collect();\n@@ -2315,7 +2314,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n         let poly_trait_ref = match self_ty.sty {\n             ty::TyTrait(ref data) => {\n-                data.principal_trait_ref_with_self_ty(self.tcx(), self_ty)\n+                data.principal.with_self_ty(self.tcx(), self_ty)\n             }\n             _ => {\n                 span_bug!(obligation.cause.span,\n@@ -2487,13 +2486,12 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             // Trait+Kx+'a -> Trait+Ky+'b (upcasts).\n             (&ty::TyTrait(ref data_a), &ty::TyTrait(ref data_b)) => {\n                 // See assemble_candidates_for_unsizing for more info.\n-                let bounds = ty::ExistentialBounds {\n-                    region_bound: data_b.bounds.region_bound,\n-                    builtin_bounds: data_b.bounds.builtin_bounds,\n-                    projection_bounds: data_a.bounds.projection_bounds.clone(),\n-                };\n-\n-                let new_trait = tcx.mk_trait(data_a.principal.clone(), bounds);\n+                let new_trait = tcx.mk_trait(ty::TraitObject {\n+                    principal: data_a.principal,\n+                    region_bound: data_b.region_bound,\n+                    builtin_bounds: data_b.builtin_bounds,\n+                    projection_bounds: data_a.projection_bounds.clone(),\n+                });\n                 let origin = TypeOrigin::Misc(obligation.cause.span);\n                 let InferOk { obligations, .. } =\n                     self.infcx.sub_types(false, origin, new_trait, target)\n@@ -2504,21 +2502,21 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 let cause = ObligationCause::new(obligation.cause.span,\n                                                  obligation.cause.body_id,\n                                                  ObjectCastObligation(target));\n-                let outlives = ty::OutlivesPredicate(data_a.bounds.region_bound,\n-                                                     data_b.bounds.region_bound);\n+                let outlives = ty::OutlivesPredicate(data_a.region_bound,\n+                                                     data_b.region_bound);\n                 nested.push(Obligation::with_depth(cause,\n                                                    obligation.recursion_depth + 1,\n                                                    ty::Binder(outlives).to_predicate()));\n             }\n \n             // T -> Trait.\n             (_, &ty::TyTrait(ref data)) => {\n-                let mut object_dids = Some(data.principal_def_id()).into_iter();\n+                let mut object_dids = Some(data.principal.def_id()).into_iter();\n                 // FIXME(#33243)\n-//                    data.bounds.builtin_bounds.iter().flat_map(|bound| {\n+//                    data.builtin_bounds.iter().flat_map(|bound| {\n //                        tcx.lang_items.from_builtin_kind(bound).ok()\n //                    })\n-//                    .chain(Some(data.principal_def_id()));\n+//                    .chain(Some(data.principal.def_id()));\n                 if let Some(did) = object_dids.find(|did| {\n                     !tcx.is_object_safe(*did)\n                 }) {\n@@ -2535,10 +2533,10 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 };\n \n                 // Create the obligation for casting from T to Trait.\n-                push(data.principal_trait_ref_with_self_ty(tcx, source).to_predicate());\n+                push(data.principal.with_self_ty(tcx, source).to_predicate());\n \n                 // We can only make objects from sized types.\n-                let mut builtin_bounds = data.bounds.builtin_bounds;\n+                let mut builtin_bounds = data.builtin_bounds;\n                 builtin_bounds.insert(ty::BoundSized);\n \n                 // Create additional obligations for all the various builtin\n@@ -2554,14 +2552,13 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 }\n \n                 // Create obligations for the projection predicates.\n-                for bound in data.projection_bounds_with_self_ty(tcx, source) {\n-                    push(bound.to_predicate());\n+                for bound in &data.projection_bounds {\n+                    push(bound.with_self_ty(tcx, source).to_predicate());\n                 }\n \n                 // If the type is `Foo+'a`, ensures that the type\n                 // being cast to `Foo+'a` outlives `'a`:\n-                let outlives = ty::OutlivesPredicate(source,\n-                                                     data.bounds.region_bound);\n+                let outlives = ty::OutlivesPredicate(source, data.region_bound);\n                 push(ty::Binder(outlives).to_predicate());\n             }\n "}, {"sha": "dfb5482ad873b45a1db11ae340323a62cf7a24a9", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 5, "deletions": 20, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=4b25f08512eab11aec151d8f718fca0d8840d0c0", "patch": "@@ -27,9 +27,9 @@ use ty::subst::{self, Substs};\n use traits;\n use ty::{self, TraitRef, Ty, TypeAndMut};\n use ty::{TyS, TypeVariants};\n-use ty::{AdtDef, ClosureSubsts, ExistentialBounds, Region};\n+use ty::{AdtDef, ClosureSubsts, Region};\n use hir::FreevarMap;\n-use ty::{BareFnTy, InferTy, ParamTy, ProjectionTy, TraitTy};\n+use ty::{BareFnTy, InferTy, ParamTy, ProjectionTy, TraitObject};\n use ty::{TyVar, TyVid, IntVar, IntVid, FloatVar, FloatVid};\n use ty::TypeVariants::*;\n use ty::layout::{Layout, TargetDataLayout};\n@@ -1150,12 +1150,6 @@ impl_interners!('tcx,\n     region: mk_region(Region, keep_local) -> Region\n );\n \n-fn bound_list_is_sorted(bounds: &[ty::PolyProjectionPredicate]) -> bool {\n-    bounds.is_empty() ||\n-        bounds[1..].iter().enumerate().all(\n-            |(index, bound)| bounds[index].sort_key() <= bound.sort_key())\n-}\n-\n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Create an unsafe fn ty based on a safe fn ty.\n     pub fn safe_to_unsafe_fn_ty(self, bare_fn: &BareFnTy<'tcx>) -> Ty<'tcx> {\n@@ -1288,18 +1282,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.mk_ty(TyFnPtr(fty))\n     }\n \n-    pub fn mk_trait(self,\n-                    principal: ty::PolyTraitRef<'tcx>,\n-                    bounds: ExistentialBounds<'tcx>)\n-                    -> Ty<'tcx>\n-    {\n-        assert!(bound_list_is_sorted(&bounds.projection_bounds));\n-\n-        let inner = box TraitTy {\n-            principal: principal,\n-            bounds: bounds\n-        };\n-        self.mk_ty(TyTrait(inner))\n+    pub fn mk_trait(self, mut obj: TraitObject<'tcx>) -> Ty<'tcx> {\n+        obj.projection_bounds.sort_by(|a, b| a.sort_key().cmp(&b.sort_key()));\n+        self.mk_ty(TyTrait(box obj))\n     }\n \n     pub fn mk_projection(self,"}, {"sha": "933746ebc2ad13365a1add69cf3bb61c3e5683e5", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=4b25f08512eab11aec151d8f718fca0d8840d0c0", "patch": "@@ -243,7 +243,7 @@ impl<'a, 'gcx, 'lcx, 'tcx> ty::TyS<'tcx> {\n             ty::TyFnDef(..) => format!(\"fn item\"),\n             ty::TyFnPtr(_) => \"fn pointer\".to_string(),\n             ty::TyTrait(ref inner) => {\n-                format!(\"trait {}\", tcx.item_path_str(inner.principal_def_id()))\n+                format!(\"trait {}\", tcx.item_path_str(inner.principal.def_id()))\n             }\n             ty::TyStruct(def, _) => {\n                 format!(\"struct `{}`\", tcx.item_path_str(def.did))"}, {"sha": "f7472d611befe30732f07bbca9ea9986732ee436", "filename": "src/librustc/ty/fast_reject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffast_reject.rs?ref=4b25f08512eab11aec151d8f718fca0d8840d0c0", "patch": "@@ -61,7 +61,7 @@ pub fn simplify_type<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         ty::TyArray(..) | ty::TySlice(_) => Some(VecSimplifiedType),\n         ty::TyRawPtr(_) => Some(PtrSimplifiedType),\n         ty::TyTrait(ref trait_info) => {\n-            Some(TraitSimplifiedType(trait_info.principal_def_id()))\n+            Some(TraitSimplifiedType(trait_info.principal.def_id()))\n         }\n         ty::TyStruct(def, _) => {\n             Some(StructSimplifiedType(def.did))"}, {"sha": "6cc759c420d29e87459981e1bfa4e88bd98f3b70", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=4b25f08512eab11aec151d8f718fca0d8840d0c0", "patch": "@@ -116,17 +116,16 @@ impl FlagComputation {\n                 self.add_substs(substs);\n             }\n \n-            &ty::TyTrait(box ty::TraitTy { ref principal, ref bounds }) => {\n+            &ty::TyTrait(ref obj) => {\n                 let mut computation = FlagComputation::new();\n-                computation.add_substs(principal.0.substs);\n-                for projection_bound in &bounds.projection_bounds {\n+                computation.add_substs(obj.principal.skip_binder().substs);\n+                for projection_bound in &obj.projection_bounds {\n                     let mut proj_computation = FlagComputation::new();\n-                    proj_computation.add_projection_predicate(&projection_bound.0);\n+                    proj_computation.add_existential_projection(&projection_bound.0);\n                     self.add_bound_computation(&proj_computation);\n                 }\n                 self.add_bound_computation(&computation);\n-\n-                self.add_bounds(bounds);\n+                self.add_region(obj.region_bound);\n             }\n \n             &ty::TyBox(tt) | &ty::TyArray(tt, _) | &ty::TySlice(tt) => {\n@@ -199,9 +198,9 @@ impl FlagComputation {\n         }\n     }\n \n-    fn add_projection_predicate(&mut self, projection_predicate: &ty::ProjectionPredicate) {\n-        self.add_projection_ty(&projection_predicate.projection_ty);\n-        self.add_ty(projection_predicate.ty);\n+    fn add_existential_projection(&mut self, projection: &ty::ExistentialProjection) {\n+        self.add_substs(projection.trait_ref.substs);\n+        self.add_ty(projection.ty);\n     }\n \n     fn add_projection_ty(&mut self, projection_ty: &ty::ProjectionTy) {\n@@ -214,8 +213,4 @@ impl FlagComputation {\n             self.add_region(r);\n         }\n     }\n-\n-    fn add_bounds(&mut self, bounds: &ty::ExistentialBounds) {\n-        self.add_region(bounds.region_bound);\n-    }\n }"}, {"sha": "597261cca72bf0973d4ce3c547d926008cadb933", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=4b25f08512eab11aec151d8f718fca0d8840d0c0", "patch": "@@ -140,10 +140,6 @@ pub trait TypeFolder<'gcx: 'tcx, 'tcx> : Sized {\n         t.super_fold_with(self)\n     }\n \n-    fn fold_trait_ref(&mut self, t: &ty::TraitRef<'tcx>) -> ty::TraitRef<'tcx> {\n-        t.super_fold_with(self)\n-    }\n-\n     fn fold_impl_header(&mut self, imp: &ty::ImplHeader<'tcx>) -> ty::ImplHeader<'tcx> {\n         imp.super_fold_with(self)\n     }\n@@ -177,11 +173,6 @@ pub trait TypeFolder<'gcx: 'tcx, 'tcx> : Sized {\n         r.super_fold_with(self)\n     }\n \n-    fn fold_existential_bounds(&mut self, s: &ty::ExistentialBounds<'tcx>)\n-                               -> ty::ExistentialBounds<'tcx> {\n-        s.super_fold_with(self)\n-    }\n-\n     fn fold_autoref(&mut self, ar: &adjustment::AutoRef<'tcx>)\n                     -> adjustment::AutoRef<'tcx> {\n         ar.super_fold_with(self)"}, {"sha": "1dcc623d3655868cf931b3538b6bfb6ca2faa524", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=4b25f08512eab11aec151d8f718fca0d8840d0c0", "patch": "@@ -322,7 +322,7 @@ pub fn characteristic_def_id_of_type(ty: Ty) -> Option<DefId> {\n         ty::TyStruct(adt_def, _) |\n         ty::TyEnum(adt_def, _) => Some(adt_def.did),\n \n-        ty::TyTrait(ref data) => Some(data.principal_def_id()),\n+        ty::TyTrait(ref data) => Some(data.principal.def_id()),\n \n         ty::TyArray(subty, _) |\n         ty::TySlice(subty) |"}, {"sha": "6ac57a877a75952ad5475f47343cd9fb379b9361", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=4b25f08512eab11aec151d8f718fca0d8840d0c0", "patch": "@@ -54,11 +54,13 @@ use hir::{ItemImpl, ItemTrait, PatKind};\n use hir::intravisit::Visitor;\n \n pub use self::sty::{Binder, DebruijnIndex};\n-pub use self::sty::{BuiltinBound, BuiltinBounds, ExistentialBounds};\n+pub use self::sty::{BuiltinBound, BuiltinBounds};\n pub use self::sty::{BareFnTy, FnSig, PolyFnSig};\n-pub use self::sty::{ClosureTy, InferTy, ParamTy, ProjectionTy, TraitTy};\n+pub use self::sty::{ClosureTy, InferTy, ParamTy, ProjectionTy, TraitObject};\n pub use self::sty::{ClosureSubsts, TypeAndMut};\n pub use self::sty::{TraitRef, TypeVariants, PolyTraitRef};\n+pub use self::sty::{ExistentialTraitRef, PolyExistentialTraitRef};\n+pub use self::sty::{ExistentialProjection, PolyExistentialProjection};\n pub use self::sty::{BoundRegion, EarlyBoundRegion, FreeRegion, Region};\n pub use self::sty::Issue32330;\n pub use self::sty::{TyVid, IntVid, FloatVid, RegionVid, SkolemizedRegionVid};"}, {"sha": "aa48474e50cf1bbe66dc5786d0f14935517945cd", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 53, "deletions": 36, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=4b25f08512eab11aec151d8f718fca0d8840d0c0", "patch": "@@ -326,24 +326,33 @@ impl<'tcx> Relate<'tcx> for ty::ProjectionTy<'tcx> {\n     }\n }\n \n-impl<'tcx> Relate<'tcx> for ty::ProjectionPredicate<'tcx> {\n+impl<'tcx> Relate<'tcx> for ty::ExistentialProjection<'tcx> {\n     fn relate<'a, 'gcx, R>(relation: &mut R,\n-                           a: &ty::ProjectionPredicate<'tcx>,\n-                           b: &ty::ProjectionPredicate<'tcx>)\n-                           -> RelateResult<'tcx, ty::ProjectionPredicate<'tcx>>\n+                           a: &ty::ExistentialProjection<'tcx>,\n+                           b: &ty::ExistentialProjection<'tcx>)\n+                           -> RelateResult<'tcx, ty::ExistentialProjection<'tcx>>\n         where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n-        let projection_ty = relation.relate(&a.projection_ty, &b.projection_ty)?;\n-        let ty = relation.relate(&a.ty, &b.ty)?;\n-        Ok(ty::ProjectionPredicate { projection_ty: projection_ty, ty: ty })\n+        if a.item_name != b.item_name {\n+            Err(TypeError::ProjectionNameMismatched(\n+                expected_found(relation, &a.item_name, &b.item_name)))\n+        } else {\n+            let trait_ref = relation.relate(&a.trait_ref, &b.trait_ref)?;\n+            let ty = relation.relate(&a.ty, &b.ty)?;\n+            Ok(ty::ExistentialProjection {\n+                trait_ref: trait_ref,\n+                item_name: a.item_name,\n+                ty: ty\n+            })\n+        }\n     }\n }\n \n-impl<'tcx> Relate<'tcx> for Vec<ty::PolyProjectionPredicate<'tcx>> {\n+impl<'tcx> Relate<'tcx> for Vec<ty::PolyExistentialProjection<'tcx>> {\n     fn relate<'a, 'gcx, R>(relation: &mut R,\n-                           a: &Vec<ty::PolyProjectionPredicate<'tcx>>,\n-                           b: &Vec<ty::PolyProjectionPredicate<'tcx>>)\n-                           -> RelateResult<'tcx, Vec<ty::PolyProjectionPredicate<'tcx>>>\n+                           a: &Vec<ty::PolyExistentialProjection<'tcx>>,\n+                           b: &Vec<ty::PolyExistentialProjection<'tcx>>)\n+                           -> RelateResult<'tcx, Vec<ty::PolyExistentialProjection<'tcx>>>\n         where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         // To be compatible, `a` and `b` must be for precisely the\n@@ -361,27 +370,6 @@ impl<'tcx> Relate<'tcx> for Vec<ty::PolyProjectionPredicate<'tcx>> {\n     }\n }\n \n-impl<'tcx> Relate<'tcx> for ty::ExistentialBounds<'tcx> {\n-    fn relate<'a, 'gcx, R>(relation: &mut R,\n-                           a: &ty::ExistentialBounds<'tcx>,\n-                           b: &ty::ExistentialBounds<'tcx>)\n-                           -> RelateResult<'tcx, ty::ExistentialBounds<'tcx>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n-    {\n-        let r =\n-            relation.with_cause(\n-                Cause::ExistentialRegionBound,\n-                |relation| relation.relate_with_variance(ty::Contravariant,\n-                                                         &a.region_bound,\n-                                                         &b.region_bound))?;\n-        let nb = relation.relate(&a.builtin_bounds, &b.builtin_bounds)?;\n-        let pb = relation.relate(&a.projection_bounds, &b.projection_bounds)?;\n-        Ok(ty::ExistentialBounds { region_bound: r,\n-                                   builtin_bounds: nb,\n-                                   projection_bounds: pb })\n-    }\n-}\n-\n impl<'tcx> Relate<'tcx> for ty::BuiltinBounds {\n     fn relate<'a, 'gcx, R>(relation: &mut R,\n                            a: &ty::BuiltinBounds,\n@@ -416,6 +404,23 @@ impl<'tcx> Relate<'tcx> for ty::TraitRef<'tcx> {\n     }\n }\n \n+impl<'tcx> Relate<'tcx> for ty::ExistentialTraitRef<'tcx> {\n+    fn relate<'a, 'gcx, R>(relation: &mut R,\n+                           a: &ty::ExistentialTraitRef<'tcx>,\n+                           b: &ty::ExistentialTraitRef<'tcx>)\n+                           -> RelateResult<'tcx, ty::ExistentialTraitRef<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+    {\n+        // Different traits cannot be related\n+        if a.def_id != b.def_id {\n+            Err(TypeError::Traits(expected_found(relation, &a.def_id, &b.def_id)))\n+        } else {\n+            let substs = relate_item_substs(relation, a.def_id, a.substs, b.substs)?;\n+            Ok(ty::ExistentialTraitRef { def_id: a.def_id, substs: substs })\n+        }\n+    }\n+}\n+\n impl<'tcx> Relate<'tcx> for Ty<'tcx> {\n     fn relate<'a, 'gcx, R>(relation: &mut R,\n                            a: &Ty<'tcx>,\n@@ -478,11 +483,23 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n             Ok(tcx.mk_enum(a_def, substs))\n         }\n \n-        (&ty::TyTrait(ref a_), &ty::TyTrait(ref b_)) =>\n+        (&ty::TyTrait(ref a_obj), &ty::TyTrait(ref b_obj)) =>\n         {\n-            let principal = relation.relate(&a_.principal, &b_.principal)?;\n-            let bounds = relation.relate(&a_.bounds, &b_.bounds)?;\n-            Ok(tcx.mk_trait(principal, bounds))\n+            let principal = relation.relate(&a_obj.principal, &b_obj.principal)?;\n+            let r =\n+                relation.with_cause(\n+                    Cause::ExistentialRegionBound,\n+                    |relation| relation.relate_with_variance(ty::Contravariant,\n+                                                             &a_obj.region_bound,\n+                                                             &b_obj.region_bound))?;\n+            let nb = relation.relate(&a_obj.builtin_bounds, &b_obj.builtin_bounds)?;\n+            let pb = relation.relate(&a_obj.projection_bounds, &b_obj.projection_bounds)?;\n+            Ok(tcx.mk_trait(ty::TraitObject {\n+                principal: principal,\n+                region_bound: r,\n+                builtin_bounds: nb,\n+                projection_bounds: pb\n+            }))\n         }\n \n         (&ty::TyStruct(a_def, a_substs), &ty::TyStruct(b_def, b_substs))"}, {"sha": "14005c1bd8b767cedc0940bc2b140ac26f54dbc1", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 61, "deletions": 29, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=4b25f08512eab11aec151d8f718fca0d8840d0c0", "patch": "@@ -10,7 +10,7 @@\n \n use infer::type_variable;\n use ty::subst::{self, VecPerParamSpace};\n-use ty::{self, Lift, TraitRef, Ty, TyCtxt};\n+use ty::{self, Lift, Ty, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n \n use std::rc::Rc;\n@@ -80,10 +80,20 @@ impl<'tcx> Lift<'tcx> for ty::Region {\n     }\n }\n \n-impl<'a, 'tcx> Lift<'tcx> for TraitRef<'a> {\n-    type Lifted = TraitRef<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<TraitRef<'tcx>> {\n-        tcx.lift(&self.substs).map(|substs| TraitRef {\n+impl<'a, 'tcx> Lift<'tcx> for ty::TraitRef<'a> {\n+    type Lifted = ty::TraitRef<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&self.substs).map(|substs| ty::TraitRef {\n+            def_id: self.def_id,\n+            substs: substs\n+        })\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for ty::ExistentialTraitRef<'a> {\n+    type Lifted = ty::ExistentialTraitRef<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&self.substs).map(|substs| ty::ExistentialTraitRef {\n             def_id: self.def_id,\n             substs: substs\n         })\n@@ -141,6 +151,19 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ProjectionPredicate<'a> {\n     }\n }\n \n+impl<'a, 'tcx> Lift<'tcx> for ty::ExistentialProjection<'a> {\n+    type Lifted = ty::ExistentialProjection<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&(self.trait_ref, self.ty)).map(|(trait_ref, ty)| {\n+            ty::ExistentialProjection {\n+                trait_ref: trait_ref,\n+                item_name: self.item_name,\n+                ty: ty\n+            }\n+        })\n+    }\n+}\n+\n impl<'a, 'tcx> Lift<'tcx> for ty::Predicate<'a> {\n     type Lifted = ty::Predicate<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n@@ -437,16 +460,20 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for VecPerParamSpace<T> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::TraitTy<'tcx> {\n+impl<'tcx> TypeFoldable<'tcx> for ty::TraitObject<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        ty::TraitTy {\n+        ty::TraitObject {\n             principal: self.principal.fold_with(folder),\n-            bounds: self.bounds.fold_with(folder),\n+            region_bound: self.region_bound.fold_with(folder),\n+            builtin_bounds: self.builtin_bounds,\n+            projection_bounds: self.projection_bounds.fold_with(folder),\n         }\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.principal.visit_with(visitor) || self.bounds.visit_with(visitor)\n+        self.principal.visit_with(visitor) ||\n+        self.region_bound.visit_with(visitor) ||\n+        self.projection_bounds.visit_with(visitor)\n     }\n }\n \n@@ -599,8 +626,17 @@ impl<'tcx> TypeFoldable<'tcx> for ty::TraitRef<'tcx> {\n         }\n     }\n \n-    fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        folder.fold_trait_ref(self)\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.substs.visit_with(visitor)\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::ExistentialTraitRef<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        ty::ExistentialTraitRef {\n+            def_id: self.def_id,\n+            substs: self.substs.fold_with(folder),\n+        }\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n@@ -741,24 +777,6 @@ impl<'tcx> TypeFoldable<'tcx> for ty::BuiltinBounds {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::ExistentialBounds<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        ty::ExistentialBounds {\n-            region_bound: self.region_bound.fold_with(folder),\n-            builtin_bounds: self.builtin_bounds,\n-            projection_bounds: self.projection_bounds.fold_with(folder),\n-        }\n-    }\n-\n-    fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        folder.fold_existential_bounds(self)\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.region_bound.visit_with(visitor) || self.projection_bounds.visit_with(visitor)\n-    }\n-}\n-\n impl<'tcx> TypeFoldable<'tcx> for ty::TypeParameterDef<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::TypeParameterDef {\n@@ -893,6 +911,20 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ProjectionPredicate<'tcx> {\n     }\n }\n \n+impl<'tcx> TypeFoldable<'tcx> for ty::ExistentialProjection<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        ty::ExistentialProjection {\n+            trait_ref: self.trait_ref.fold_with(folder),\n+            item_name: self.item_name,\n+            ty: self.ty.fold_with(folder),\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.trait_ref.visit_with(visitor) || self.ty.visit_with(visitor)\n+    }\n+}\n+\n impl<'tcx> TypeFoldable<'tcx> for ty::ProjectionTy<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::ProjectionTy {"}, {"sha": "91214873f193d57568f3e3fd43594470befe25df", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 105, "deletions": 75, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=4b25f08512eab11aec151d8f718fca0d8840d0c0", "patch": "@@ -152,7 +152,7 @@ pub enum TypeVariants<'tcx> {\n     TyFnPtr(&'tcx BareFnTy<'tcx>),\n \n     /// A trait, defined with `trait`.\n-    TyTrait(Box<TraitTy<'tcx>>),\n+    TyTrait(Box<TraitObject<'tcx>>),\n \n     /// The anonymous type of a closure. Used to represent the type of\n     /// `|a| a`.\n@@ -291,57 +291,11 @@ impl<'tcx> Decodable for ClosureSubsts<'tcx> {\n }\n \n #[derive(Clone, PartialEq, Eq, Hash)]\n-pub struct TraitTy<'tcx> {\n-    pub principal: ty::PolyTraitRef<'tcx>,\n-    pub bounds: ExistentialBounds<'tcx>,\n-}\n-\n-impl<'a, 'gcx, 'tcx> TraitTy<'tcx> {\n-    pub fn principal_def_id(&self) -> DefId {\n-        self.principal.0.def_id\n-    }\n-\n-    /// Object types don't have a self-type specified. Therefore, when\n-    /// we convert the principal trait-ref into a normal trait-ref,\n-    /// you must give *some* self-type. A common choice is `mk_err()`\n-    /// or some skolemized type.\n-    pub fn principal_trait_ref_with_self_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                            self_ty: Ty<'tcx>)\n-                                            -> ty::PolyTraitRef<'tcx>\n-    {\n-        // otherwise the escaping regions would be captured by the binder\n-        assert!(!self_ty.has_escaping_regions());\n-\n-        ty::Binder(TraitRef {\n-            def_id: self.principal.0.def_id,\n-            substs: tcx.mk_substs(self.principal.0.substs.with_self_ty(self_ty)),\n-        })\n-    }\n-\n-    pub fn projection_bounds_with_self_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                          self_ty: Ty<'tcx>)\n-                                          -> Vec<ty::PolyProjectionPredicate<'tcx>>\n-    {\n-        // otherwise the escaping regions would be captured by the binders\n-        assert!(!self_ty.has_escaping_regions());\n-\n-        self.bounds.projection_bounds.iter()\n-            .map(|in_poly_projection_predicate| {\n-                let in_projection_ty = &in_poly_projection_predicate.0.projection_ty;\n-                let substs = tcx.mk_substs(in_projection_ty.trait_ref.substs.with_self_ty(self_ty));\n-                let trait_ref = ty::TraitRef::new(in_projection_ty.trait_ref.def_id,\n-                                              substs);\n-                let projection_ty = ty::ProjectionTy {\n-                    trait_ref: trait_ref,\n-                    item_name: in_projection_ty.item_name\n-                };\n-                ty::Binder(ty::ProjectionPredicate {\n-                    projection_ty: projection_ty,\n-                    ty: in_poly_projection_predicate.0.ty\n-                })\n-            })\n-            .collect()\n-    }\n+pub struct TraitObject<'tcx> {\n+    pub principal: PolyExistentialTraitRef<'tcx>,\n+    pub region_bound: ty::Region,\n+    pub builtin_bounds: BuiltinBounds,\n+    pub projection_bounds: Vec<PolyExistentialProjection<'tcx>>,\n }\n \n /// A complete reference to a trait. These take numerous guises in syntax,\n@@ -392,6 +346,70 @@ impl<'tcx> PolyTraitRef<'tcx> {\n     }\n }\n \n+/// An existential reference to a trait, where `Self` is erased.\n+/// For example, the trait object `Trait<'a, 'b, X, Y>` is:\n+///\n+///     exists T. T: Trait<'a, 'b, X, Y>\n+///\n+/// The substitutions don't include the erased `Self`, only trait\n+/// type and lifetime parameters (`[X, Y]` and `['a, 'b]` above).\n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct ExistentialTraitRef<'tcx> {\n+    pub def_id: DefId,\n+    pub substs: &'tcx Substs<'tcx>,\n+}\n+\n+impl<'a, 'gcx, 'tcx> ExistentialTraitRef<'tcx> {\n+    pub fn erase_self_ty(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                         trait_ref: ty::TraitRef<'tcx>)\n+                         -> ty::ExistentialTraitRef<'tcx> {\n+        let mut substs = trait_ref.substs.clone();\n+        substs.types.pop(subst::SelfSpace);\n+        ty::ExistentialTraitRef {\n+            def_id: trait_ref.def_id,\n+            substs: tcx.mk_substs(substs)\n+        }\n+    }\n+\n+    pub fn input_types(&self) -> &[Ty<'tcx>] {\n+        // Select only the \"input types\" from a trait-reference. For\n+        // now this is all the types that appear in the\n+        // trait-reference, but it should eventually exclude\n+        // associated types.\n+        self.substs.types.as_full_slice()\n+    }\n+}\n+\n+pub type PolyExistentialTraitRef<'tcx> = Binder<ExistentialTraitRef<'tcx>>;\n+\n+impl<'a, 'gcx, 'tcx> PolyExistentialTraitRef<'tcx> {\n+    pub fn def_id(&self) -> DefId {\n+        self.0.def_id\n+    }\n+\n+    pub fn input_types(&self) -> &[Ty<'tcx>] {\n+        // FIXME(#20664) every use of this fn is probably a bug, it should yield Binder<>\n+        self.0.input_types()\n+    }\n+\n+    /// Object types don't have a self-type specified. Therefore, when\n+    /// we convert the principal trait-ref into a normal trait-ref,\n+    /// you must give *some* self-type. A common choice is `mk_err()`\n+    /// or some skolemized type.\n+    pub fn with_self_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                        self_ty: Ty<'tcx>)\n+                        -> ty::PolyTraitRef<'tcx>\n+    {\n+        // otherwise the escaping regions would be captured by the binder\n+        assert!(!self_ty.has_escaping_regions());\n+\n+        self.map_bound(|trait_ref| TraitRef {\n+            def_id: trait_ref.def_id,\n+            substs: tcx.mk_substs(trait_ref.substs.with_self_ty(self_ty)),\n+        })\n+    }\n+}\n+\n /// Binder is a binder for higher-ranked lifetimes. It is part of the\n /// compiler's representation for things like `for<'a> Fn(&'a isize)`\n /// (which would be represented by the type `PolyTraitRef ==\n@@ -730,27 +748,40 @@ pub enum InferTy {\n     FreshFloatTy(u32)\n }\n \n-/// Bounds suitable for an existentially quantified type parameter\n-/// such as those that appear in object types or closure types.\n-#[derive(PartialEq, Eq, Hash, Clone)]\n-pub struct ExistentialBounds<'tcx> {\n-    pub region_bound: ty::Region,\n-    pub builtin_bounds: BuiltinBounds,\n-    pub projection_bounds: Vec<ty::PolyProjectionPredicate<'tcx>>,\n+/// A `ProjectionPredicate` for an `ExistentialTraitRef`.\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+pub struct ExistentialProjection<'tcx> {\n+    pub trait_ref: ExistentialTraitRef<'tcx>,\n+    pub item_name: Name,\n+    pub ty: Ty<'tcx>\n }\n \n-impl<'tcx> ExistentialBounds<'tcx> {\n-    pub fn new(region_bound: ty::Region,\n-               builtin_bounds: BuiltinBounds,\n-               projection_bounds: Vec<ty::PolyProjectionPredicate<'tcx>>)\n-               -> Self {\n-        let mut projection_bounds = projection_bounds;\n-        projection_bounds.sort_by(|a, b| a.sort_key().cmp(&b.sort_key()));\n-        ExistentialBounds {\n-            region_bound: region_bound,\n-            builtin_bounds: builtin_bounds,\n-            projection_bounds: projection_bounds\n-        }\n+pub type PolyExistentialProjection<'tcx> = Binder<ExistentialProjection<'tcx>>;\n+\n+impl<'a, 'tcx, 'gcx> PolyExistentialProjection<'tcx> {\n+    pub fn item_name(&self) -> Name {\n+        self.0.item_name // safe to skip the binder to access a name\n+    }\n+\n+    pub fn sort_key(&self) -> (DefId, Name) {\n+        (self.0.trait_ref.def_id, self.0.item_name)\n+    }\n+\n+    pub fn with_self_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                        self_ty: Ty<'tcx>)\n+                        -> ty::PolyProjectionPredicate<'tcx>\n+    {\n+        // otherwise the escaping regions would be captured by the binders\n+        assert!(!self_ty.has_escaping_regions());\n+\n+        let trait_ref = self.map_bound(|proj| proj.trait_ref);\n+        self.map_bound(|proj| ty::ProjectionPredicate {\n+            projection_ty: ty::ProjectionTy {\n+                trait_ref: trait_ref.with_self_ty(tcx, self_ty).0,\n+                item_name: proj.item_name\n+            },\n+            ty: proj.ty\n+        })\n     }\n }\n \n@@ -1185,7 +1216,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n \n     pub fn ty_to_def_id(&self) -> Option<DefId> {\n         match self.sty {\n-            TyTrait(ref tt) => Some(tt.principal_def_id()),\n+            TyTrait(ref tt) => Some(tt.principal.def_id()),\n             TyStruct(def, _) |\n             TyEnum(def, _) => Some(def.did),\n             TyClosure(id, _) => Some(id),\n@@ -1209,9 +1240,8 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n                 vec![*region]\n             }\n             TyTrait(ref obj) => {\n-                let mut v = vec![obj.bounds.region_bound];\n-                v.extend_from_slice(obj.principal.skip_binder()\n-                                       .substs.regions.as_full_slice());\n+                let mut v = vec![obj.region_bound];\n+                v.extend_from_slice(obj.principal.skip_binder().substs.regions.as_full_slice());\n                 v\n             }\n             TyEnum(_, substs) |"}, {"sha": "3c1f6e91992207c489a8922ab63dffbf3e6158e5", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=4b25f08512eab11aec151d8f718fca0d8840d0c0", "patch": "@@ -451,21 +451,21 @@ impl<'a, 'gcx, 'tcx> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tcx> {\n                 // to sort them again by the name, in string form.\n \n                 // Hash the whole principal trait ref.\n-                self.def_id(data.principal_def_id());\n+                self.def_id(data.principal.def_id());\n                 data.principal.visit_with(self);\n \n                 // Hash region and builtin bounds.\n-                data.bounds.region_bound.visit_with(self);\n-                self.hash(data.bounds.builtin_bounds);\n+                data.region_bound.visit_with(self);\n+                self.hash(data.builtin_bounds);\n \n                 // Only projection bounds are left, sort and hash them.\n-                let mut projection_bounds: Vec<_> = data.bounds.projection_bounds\n+                let mut projection_bounds: Vec<_> = data.projection_bounds\n                                                         .iter()\n                                                         .map(|b| (b.item_name().as_str(), b))\n                                                         .collect();\n                 projection_bounds.sort_by_key(|&(ref name, _)| name.clone());\n                 for (name, bound) in projection_bounds {\n-                    self.def_id(bound.0.projection_ty.trait_ref.def_id);\n+                    self.def_id(bound.0.trait_ref.def_id);\n                     self.hash(name);\n                     bound.visit_with(self);\n                 }"}, {"sha": "3bf539245571e5170ab9aab28be106664fe927b3", "filename": "src/librustc/ty/walk.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwalk.rs?ref=4b25f08512eab11aec151d8f718fca0d8840d0c0", "patch": "@@ -81,9 +81,9 @@ fn push_subtypes<'tcx>(stack: &mut Vec<Ty<'tcx>>, parent_ty: Ty<'tcx>) {\n         ty::TyProjection(ref data) => {\n             push_reversed(stack, data.trait_ref.substs.types.as_full_slice());\n         }\n-        ty::TyTrait(box ty::TraitTy { ref principal, ref bounds }) => {\n-            push_reversed(stack, principal.substs().types.as_full_slice());\n-            push_reversed(stack, &bounds.projection_bounds.iter().map(|pred| {\n+        ty::TyTrait(ref obj) => {\n+            push_reversed(stack, obj.principal.input_types());\n+            push_reversed(stack, &obj.projection_bounds.iter().map(|pred| {\n                 pred.0.ty\n             }).collect::<Vec<_>>());\n         }"}, {"sha": "77d0835bf6bc1ba278ae98e3e169c346bc615b62", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=4b25f08512eab11aec151d8f718fca0d8840d0c0", "patch": "@@ -406,13 +406,13 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                     // FIXME(#33243): remove RFC1592\n                     self.out.push(traits::Obligation::new(\n                         cause.clone(),\n-                        ty::Predicate::ObjectSafe(data.principal_def_id())\n+                        ty::Predicate::ObjectSafe(data.principal.def_id())\n                     ));\n                     let component_traits =\n-                        data.bounds.builtin_bounds.iter().flat_map(|bound| {\n+                        data.builtin_bounds.iter().flat_map(|bound| {\n                             tcx.lang_items.from_builtin_kind(bound).ok()\n                         });\n-//                        .chain(Some(data.principal_def_id()));\n+//                        .chain(Some(data.principal.def_id()));\n                     self.out.extend(\n                         component_traits.map(|did| { traits::Obligation::new(\n                             cause.clone(),\n@@ -476,7 +476,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                   .collect()\n     }\n \n-    fn from_object_ty(&mut self, ty: Ty<'tcx>, data: &ty::TraitTy<'tcx>) {\n+    fn from_object_ty(&mut self, ty: Ty<'tcx>, data: &ty::TraitObject<'tcx>) {\n         // Imagine a type like this:\n         //\n         //     trait Foo { }\n@@ -512,10 +512,10 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n         if !data.has_escaping_regions() {\n             let implicit_bounds =\n                 object_region_bounds(self.infcx.tcx,\n-                                     &data.principal,\n-                                     data.bounds.builtin_bounds);\n+                                     data.principal,\n+                                     data.builtin_bounds);\n \n-            let explicit_bound = data.bounds.region_bound;\n+            let explicit_bound = data.region_bound;\n \n             for implicit_bound in implicit_bounds {\n                 let cause = self.cause(traits::ReferenceOutlivesReferent(ty));\n@@ -534,7 +534,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n /// `ty::required_region_bounds`, see that for more information.\n pub fn object_region_bounds<'a, 'gcx, 'tcx>(\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    principal: &ty::PolyTraitRef<'tcx>,\n+    principal: ty::PolyExistentialTraitRef<'tcx>,\n     others: ty::BuiltinBounds)\n     -> Vec<ty::Region>\n {\n@@ -543,13 +543,8 @@ pub fn object_region_bounds<'a, 'gcx, 'tcx>(\n     // a skolemized type.\n     let open_ty = tcx.mk_infer(ty::FreshTy(0));\n \n-    // Note that we preserve the overall binding levels here.\n-    assert!(!open_ty.has_escaping_regions());\n-    let substs = tcx.mk_substs(principal.0.substs.with_self_ty(open_ty));\n-    let trait_refs = vec!(ty::Binder(ty::TraitRef::new(principal.0.def_id, substs)));\n-\n     let mut predicates = others.to_predicates(tcx, open_ty);\n-    predicates.extend(trait_refs.iter().map(|t| t.to_predicate()));\n+    predicates.push(principal.with_self_ty(tcx, open_ty).to_predicate());\n \n     tcx.required_region_bounds(open_ty, predicates)\n }"}, {"sha": "fb0b6413fab40e6334574699db1536f76d3aea61", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 55, "deletions": 49, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=4b25f08512eab11aec151d8f718fca0d8840d0c0", "patch": "@@ -288,7 +288,8 @@ fn in_binder<'a, 'gcx, 'tcx, T, U>(f: &mut fmt::Formatter,\n /// projection bounds, so we just stuff them altogether. But in\n /// reality we should eventually sort things out better.\n #[derive(Clone, Debug)]\n-struct TraitAndProjections<'tcx>(ty::TraitRef<'tcx>, Vec<ty::ProjectionPredicate<'tcx>>);\n+struct TraitAndProjections<'tcx>(ty::ExistentialTraitRef<'tcx>,\n+                                 Vec<ty::ProjectionPredicate<'tcx>>);\n \n impl<'tcx> TypeFoldable<'tcx> for TraitAndProjections<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n@@ -311,24 +312,24 @@ impl<'tcx> fmt::Display for TraitAndProjections<'tcx> {\n     }\n }\n \n-impl<'tcx> fmt::Display for ty::TraitTy<'tcx> {\n+impl<'tcx> fmt::Display for ty::TraitObject<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        let bounds = &self.bounds;\n-\n         // Generate the main trait ref, including associated types.\n         ty::tls::with(|tcx| {\n             let principal = tcx.lift(&self.principal.0)\n                                .expect(\"could not lift TraitRef for printing\");\n-            let projections = tcx.lift(&bounds.projection_bounds[..])\n-                                 .expect(\"could not lift projections for printing\");\n-            let projections = projections.into_iter().map(|p| p.0).collect();\n+            let projections = self.projection_bounds.iter().map(|p| {\n+                let projection = tcx.lift(p)\n+                                    .expect(\"could not lift projection for printing\");\n+                projection.with_self_ty(tcx, tcx.types.err).0\n+            }).collect();\n \n             let tap = ty::Binder(TraitAndProjections(principal, projections));\n             in_binder(f, tcx, &ty::Binder(\"\"), Some(tap))\n         })?;\n \n         // Builtin bounds.\n-        for bound in &bounds.builtin_bounds {\n+        for bound in &self.builtin_bounds {\n             write!(f, \" + {:?}\", bound)?;\n         }\n \n@@ -337,7 +338,7 @@ impl<'tcx> fmt::Display for ty::TraitTy<'tcx> {\n         // use thread-local data of some kind? There are also\n         // advantages to just showing the region, since it makes\n         // people aware that it's there.\n-        let bound = bounds.region_bound.to_string();\n+        let bound = self.region_bound.to_string();\n         if !bound.is_empty() {\n             write!(f, \" + {}\", bound)?;\n         }\n@@ -397,10 +398,13 @@ impl<'tcx> fmt::Debug for ty::TraitRef<'tcx> {\n         // when printing out the debug representation, we don't need\n         // to enumerate the `for<...>` etc because the debruijn index\n         // tells you everything you need to know.\n-        match self.substs.self_ty() {\n-            None => write!(f, \"{}\", *self),\n-            Some(self_ty) => write!(f, \"<{:?} as {}>\", self_ty, *self)\n-        }\n+        write!(f, \"<{:?} as {}>\", self.self_ty(), *self)\n+    }\n+}\n+\n+impl<'tcx> fmt::Debug for ty::ExistentialTraitRef<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}\", *self)\n     }\n }\n \n@@ -448,11 +452,38 @@ impl<'tcx> fmt::Debug for ty::adjustment::AutoDerefRef<'tcx> {\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::TraitTy<'tcx> {\n+impl<'tcx> fmt::Debug for ty::TraitObject<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"TraitTy({:?},{:?})\",\n-               self.principal,\n-               self.bounds)\n+        let mut empty = true;\n+        let mut maybe_continue = |f: &mut fmt::Formatter| {\n+            if empty {\n+                empty = false;\n+                Ok(())\n+            } else {\n+                write!(f, \" + \")\n+            }\n+        };\n+\n+        maybe_continue(f)?;\n+        write!(f, \"{:?}\", self.principal)?;\n+\n+        let region_str = format!(\"{:?}\", self.region_bound);\n+        if !region_str.is_empty() {\n+            maybe_continue(f)?;\n+            write!(f, \"{}\", region_str)?;\n+        }\n+\n+        for bound in &self.builtin_bounds {\n+            maybe_continue(f)?;\n+            write!(f, \"{:?}\", bound)?;\n+        }\n+\n+        for projection_bound in &self.projection_bounds {\n+            maybe_continue(f)?;\n+            write!(f, \"{:?}\", projection_bound)?;\n+        }\n+\n+        Ok(())\n     }\n }\n \n@@ -668,38 +699,6 @@ impl<'tcx> fmt::Display for ty::FnSig<'tcx> {\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::ExistentialBounds<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        let mut empty = true;\n-        let mut maybe_continue = |f: &mut fmt::Formatter| {\n-            if empty {\n-                empty = false;\n-                Ok(())\n-            } else {\n-                write!(f, \" + \")\n-            }\n-        };\n-\n-        let region_str = format!(\"{:?}\", self.region_bound);\n-        if !region_str.is_empty() {\n-            maybe_continue(f)?;\n-            write!(f, \"{}\", region_str)?;\n-        }\n-\n-        for bound in &self.builtin_bounds {\n-            maybe_continue(f)?;\n-            write!(f, \"{:?}\", bound)?;\n-        }\n-\n-        for projection_bound in &self.projection_bounds {\n-            maybe_continue(f)?;\n-            write!(f, \"{:?}\", projection_bound)?;\n-        }\n-\n-        Ok(())\n-    }\n-}\n-\n impl fmt::Display for ty::BuiltinBounds {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let mut bounds = self.iter();\n@@ -819,6 +818,13 @@ impl<'tcx> fmt::Display for ty::TraitRef<'tcx> {\n     }\n }\n \n+impl<'tcx> fmt::Display for ty::ExistentialTraitRef<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        parameterized(f, self.substs, self.def_id, Ns::Type, &[],\n+                      |tcx| Some(tcx.lookup_trait_def(self.def_id).generics.clone()))\n+    }\n+}\n+\n impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {"}, {"sha": "c552e612504e9eb00c20c67960425662a94cd905", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=4b25f08512eab11aec151d8f718fca0d8840d0c0", "patch": "@@ -524,16 +524,8 @@ pub fn encode_cast_kind(ebml_w: &mut Encoder, kind: cast::CastKind) {\n trait rbml_writer_helpers<'tcx> {\n     fn emit_region(&mut self, ecx: &e::EncodeContext, r: ty::Region);\n     fn emit_ty<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>, ty: Ty<'tcx>);\n-    fn emit_tys<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>, tys: &[Ty<'tcx>]);\n-    fn emit_predicate<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n-                          predicate: &ty::Predicate<'tcx>);\n-    fn emit_trait_ref<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n-                          ty: &ty::TraitRef<'tcx>);\n     fn emit_substs<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n                        substs: &subst::Substs<'tcx>);\n-    fn emit_existential_bounds<'b>(&mut self, ecx: &e::EncodeContext<'b,'tcx>,\n-                                   bounds: &ty::ExistentialBounds<'tcx>);\n-    fn emit_builtin_bounds(&mut self, ecx: &e::EncodeContext, bounds: &ty::BuiltinBounds);\n     fn emit_upvar_capture(&mut self, ecx: &e::EncodeContext, capture: &ty::UpvarCapture);\n     fn emit_auto_adjustment<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n                                 adj: &adjustment::AutoAdjustment<'tcx>);\n@@ -556,39 +548,6 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n                                                     ty)));\n     }\n \n-    fn emit_tys<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>, tys: &[Ty<'tcx>]) {\n-        self.emit_from_vec(tys, |this, ty| Ok(this.emit_ty(ecx, *ty)));\n-    }\n-\n-    fn emit_trait_ref<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>,\n-                          trait_ref: &ty::TraitRef<'tcx>) {\n-        self.emit_opaque(|this| Ok(tyencode::enc_trait_ref(&mut this.cursor,\n-                                                           &ecx.ty_str_ctxt(),\n-                                                           *trait_ref)));\n-    }\n-\n-    fn emit_predicate<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>,\n-                          predicate: &ty::Predicate<'tcx>) {\n-        self.emit_opaque(|this| {\n-            Ok(tyencode::enc_predicate(&mut this.cursor,\n-                                       &ecx.ty_str_ctxt(),\n-                                       predicate))\n-        });\n-    }\n-\n-    fn emit_existential_bounds<'b>(&mut self, ecx: &e::EncodeContext<'b,'tcx>,\n-                                   bounds: &ty::ExistentialBounds<'tcx>) {\n-        self.emit_opaque(|this| Ok(tyencode::enc_existential_bounds(&mut this.cursor,\n-                                                                    &ecx.ty_str_ctxt(),\n-                                                                    bounds)));\n-    }\n-\n-    fn emit_builtin_bounds(&mut self, ecx: &e::EncodeContext, bounds: &ty::BuiltinBounds) {\n-        self.emit_opaque(|this| Ok(tyencode::enc_builtin_bounds(&mut this.cursor,\n-                                                                &ecx.ty_str_ctxt(),\n-                                                                bounds)));\n-    }\n-\n     fn emit_upvar_capture(&mut self, ecx: &e::EncodeContext, capture: &ty::UpvarCapture) {\n         use rustc_serialize::Encoder;\n \n@@ -879,8 +838,6 @@ trait rbml_decoder_decoder_helpers<'tcx> {\n                                    -> ty::PolyTraitRef<'tcx>;\n     fn read_predicate<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                               -> ty::Predicate<'tcx>;\n-    fn read_existential_bounds<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n-                                       -> ty::ExistentialBounds<'tcx>;\n     fn read_substs<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                            -> subst::Substs<'tcx>;\n     fn read_upvar_capture(&mut self, dcx: &DecodeContext)\n@@ -988,12 +945,6 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n         self.read_ty_encoded(dcx, |decoder| decoder.parse_predicate())\n     }\n \n-    fn read_existential_bounds<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n-                                       -> ty::ExistentialBounds<'tcx>\n-    {\n-        self.read_ty_encoded(dcx, |decoder| decoder.parse_existential_bounds())\n-    }\n-\n     fn read_substs<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n                            -> subst::Substs<'tcx> {\n         self.read_opaque(|_, doc| {"}, {"sha": "11c155cbd5b9f0e448f5cc7c814a103f8209b6a4", "filename": "src/librustc_metadata/tydecode.rs", "status": "modified", "additions": 37, "deletions": 24, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc_metadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc_metadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftydecode.rs?ref=4b25f08512eab11aec151d8f718fca0d8840d0c0", "patch": "@@ -307,6 +307,12 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n         ty::TraitRef {def_id: def, substs: substs}\n     }\n \n+    pub fn parse_existential_trait_ref(&mut self) -> ty::ExistentialTraitRef<'tcx> {\n+        let def = self.parse_def();\n+        let substs = self.tcx.mk_substs(self.parse_substs());\n+        ty::ExistentialTraitRef {def_id: def, substs: substs}\n+    }\n+\n     pub fn parse_ty(&mut self) -> Ty<'tcx> {\n         let tcx = self.tcx;\n         match self.next() {\n@@ -340,10 +346,30 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n             }\n             'x' => {\n                 assert_eq!(self.next(), '[');\n-                let trait_ref = ty::Binder(self.parse_trait_ref());\n-                let bounds = self.parse_existential_bounds();\n+                let trait_ref = ty::Binder(self.parse_existential_trait_ref());\n+                let builtin_bounds = self.parse_builtin_bounds();\n+                let region_bound = self.parse_region();\n+                let mut projection_bounds = Vec::new();\n+\n+                loop {\n+                    match self.next() {\n+                        'P' => {\n+                            let bound = self.parse_existential_projection();\n+                            projection_bounds.push(ty::Binder(bound));\n+                        }\n+                        '.' => { break; }\n+                        c => {\n+                            bug!(\"parse_bounds: bad bounds ('{}')\", c)\n+                        }\n+                    }\n+                }\n                 assert_eq!(self.next(), ']');\n-                return tcx.mk_trait(trait_ref, bounds);\n+                return tcx.mk_trait(ty::TraitObject {\n+                    principal: trait_ref,\n+                    region_bound: region_bound,\n+                    builtin_bounds: builtin_bounds,\n+                    projection_bounds: projection_bounds\n+                });\n             }\n             'p' => {\n                 assert_eq!(self.next(), '[');\n@@ -588,6 +614,14 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n         }\n     }\n \n+    fn parse_existential_projection(&mut self) -> ty::ExistentialProjection<'tcx> {\n+        ty::ExistentialProjection {\n+            trait_ref: self.parse_existential_trait_ref(),\n+            item_name: token::intern(&self.parse_str('|')),\n+            ty: self.parse_ty(),\n+        }\n+    }\n+\n     pub fn parse_type_param_def(&mut self) -> ty::TypeParameterDef<'tcx> {\n         let name = self.parse_name(':');\n         let def_id = self.parse_def();\n@@ -649,27 +683,6 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n         }\n     }\n \n-    pub fn parse_existential_bounds(&mut self) -> ty::ExistentialBounds<'tcx> {\n-        let builtin_bounds = self.parse_builtin_bounds();\n-        let region_bound = self.parse_region();\n-        let mut projection_bounds = Vec::new();\n-\n-        loop {\n-            match self.next() {\n-                'P' => {\n-                    projection_bounds.push(ty::Binder(self.parse_projection_predicate()));\n-                }\n-                '.' => { break; }\n-                c => {\n-                    bug!(\"parse_bounds: bad bounds ('{}')\", c)\n-                }\n-            }\n-        }\n-\n-        ty::ExistentialBounds::new(\n-            region_bound, builtin_bounds, projection_bounds)\n-    }\n-\n     fn parse_builtin_bounds(&mut self) -> ty::BuiltinBounds {\n         let mut builtin_bounds = ty::BuiltinBounds::empty();\n         loop {"}, {"sha": "8deb1eb6ac31dc0f08f001a0096d2eced262058f", "filename": "src/librustc_metadata/tyencode.rs", "status": "modified", "additions": 34, "deletions": 33, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc_metadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc_metadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftyencode.rs?ref=4b25f08512eab11aec151d8f718fca0d8840d0c0", "patch": "@@ -104,11 +104,26 @@ pub fn enc_ty<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx\n             enc_substs(w, cx, substs);\n             write!(w, \"]\");\n         }\n-        ty::TyTrait(box ty::TraitTy { ref principal,\n-                                       ref bounds }) => {\n+        ty::TyTrait(ref obj) => {\n             write!(w, \"x[\");\n-            enc_trait_ref(w, cx, principal.0);\n-            enc_existential_bounds(w, cx, bounds);\n+            enc_existential_trait_ref(w, cx, obj.principal.0);\n+            enc_builtin_bounds(w, cx, &obj.builtin_bounds);\n+\n+            enc_region(w, cx, obj.region_bound);\n+\n+            // Encode projection_bounds in a stable order\n+            let mut projection_bounds: Vec<_> = obj.projection_bounds\n+                                                .iter()\n+                                                .map(|b| (b.item_name().as_str(), b))\n+                                                .collect();\n+            projection_bounds.sort_by_key(|&(ref name, _)| name.clone());\n+\n+            for tp in projection_bounds.iter().map(|&(_, tp)| tp) {\n+                write!(w, \"P\");\n+                enc_existential_projection(w, cx, &tp.0);\n+            }\n+\n+            write!(w, \".\");\n             write!(w, \"]\");\n         }\n         ty::TyTuple(ts) => {\n@@ -344,6 +359,12 @@ pub fn enc_trait_ref<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n     enc_substs(w, cx, s.substs);\n }\n \n+fn enc_existential_trait_ref<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n+                                       s: ty::ExistentialTraitRef<'tcx>) {\n+    write!(w, \"{}|\", (cx.ds)(cx.tcx, s.def_id));\n+    enc_substs(w, cx, s.substs);\n+}\n+\n fn enc_unsafety(w: &mut Cursor<Vec<u8>>, p: hir::Unsafety) {\n     match p {\n         hir::Unsafety::Normal => write!(w, \"n\"),\n@@ -386,7 +407,7 @@ fn enc_fn_sig<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n     enc_ty(w, cx, fsig.0.output);\n }\n \n-pub fn enc_builtin_bounds(w: &mut Cursor<Vec<u8>>, _cx: &ctxt, bs: &ty::BuiltinBounds) {\n+fn enc_builtin_bounds(w: &mut Cursor<Vec<u8>>, _cx: &ctxt, bs: &ty::BuiltinBounds) {\n     for bound in bs {\n         match bound {\n             ty::BoundSend => write!(w, \"S\"),\n@@ -399,28 +420,6 @@ pub fn enc_builtin_bounds(w: &mut Cursor<Vec<u8>>, _cx: &ctxt, bs: &ty::BuiltinB\n     write!(w, \".\");\n }\n \n-pub fn enc_existential_bounds<'a,'tcx>(w: &mut Cursor<Vec<u8>>,\n-                                       cx: &ctxt<'a,'tcx>,\n-                                       bs: &ty::ExistentialBounds<'tcx>) {\n-    enc_builtin_bounds(w, cx, &bs.builtin_bounds);\n-\n-    enc_region(w, cx, bs.region_bound);\n-\n-    // Encode projection_bounds in a stable order\n-    let mut projection_bounds: Vec<_> = bs.projection_bounds\n-                                          .iter()\n-                                          .map(|b| (b.item_name().as_str(), b))\n-                                          .collect();\n-    projection_bounds.sort_by_key(|&(ref name, _)| name.clone());\n-\n-    for tp in projection_bounds.iter().map(|&(_, tp)| tp) {\n-        write!(w, \"P\");\n-        enc_projection_predicate(w, cx, &tp.0);\n-    }\n-\n-    write!(w, \".\");\n-}\n-\n pub fn enc_type_param_def<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n                                     v: &ty::TypeParameterDef<'tcx>) {\n     write!(w, \"{}:{}|{}|{}|{}|\",\n@@ -489,7 +488,9 @@ pub fn enc_predicate<'a, 'tcx>(w: &mut Cursor<Vec<u8>>,\n         }\n         ty::Predicate::Projection(ty::Binder(ref data)) => {\n             write!(w, \"p\");\n-            enc_projection_predicate(w, cx, data);\n+            enc_trait_ref(w, cx, data.projection_ty.trait_ref);\n+            write!(w, \"{}|\", data.projection_ty.item_name);\n+            enc_ty(w, cx, data.ty);\n         }\n         ty::Predicate::WellFormed(data) => {\n             write!(w, \"w\");\n@@ -509,10 +510,10 @@ pub fn enc_predicate<'a, 'tcx>(w: &mut Cursor<Vec<u8>>,\n     }\n }\n \n-fn enc_projection_predicate<'a, 'tcx>(w: &mut Cursor<Vec<u8>>,\n-                                      cx: &ctxt<'a, 'tcx>,\n-                                      data: &ty::ProjectionPredicate<'tcx>) {\n-    enc_trait_ref(w, cx, data.projection_ty.trait_ref);\n-    write!(w, \"{}|\", data.projection_ty.item_name);\n+fn enc_existential_projection<'a, 'tcx>(w: &mut Cursor<Vec<u8>>,\n+                                        cx: &ctxt<'a, 'tcx>,\n+                                        data: &ty::ExistentialProjection<'tcx>) {\n+    enc_existential_trait_ref(w, cx, data.trait_ref);\n+    write!(w, \"{}|\", data.item_name);\n     enc_ty(w, cx, data.ty);\n }"}, {"sha": "749a7495421ed469e35ba282e70ff36ef2c8332d", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=4b25f08512eab11aec151d8f718fca0d8840d0c0", "patch": "@@ -562,14 +562,9 @@ pub fn unsized_info<'ccx, 'tcx>(ccx: &CrateContext<'ccx, 'tcx>,\n             // change to the vtable.\n             old_info.expect(\"unsized_info: missing old info for trait upcast\")\n         }\n-        (_, &ty::TyTrait(box ty::TraitTy { ref principal, .. })) => {\n-            // Note that we preserve binding levels here:\n-            let substs = principal.0.substs.with_self_ty(source).erase_regions();\n-            let substs = ccx.tcx().mk_substs(substs);\n-            let trait_ref = ty::Binder(ty::TraitRef {\n-                def_id: principal.def_id(),\n-                substs: substs,\n-            });\n+        (_, &ty::TyTrait(ref data)) => {\n+            let trait_ref = data.principal.with_self_ty(ccx.tcx(), source);\n+            let trait_ref = ccx.tcx().erase_regions(&trait_ref);\n             consts::ptrcast(meth::get_vtable(ccx, trait_ref),\n                             Type::vtable_ptr(ccx))\n         }"}, {"sha": "277110347d01d112e5dcd9224c2c6a5ebcbb54a3", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=4b25f08512eab11aec151d8f718fca0d8840d0c0", "patch": "@@ -1055,8 +1055,7 @@ fn create_trans_items_for_vtable_methods<'a, 'tcx>(scx: &SharedCrateContext<'a,\n     assert!(!trait_ty.needs_subst() && !impl_ty.needs_subst());\n \n     if let ty::TyTrait(ref trait_ty) = trait_ty.sty {\n-        let poly_trait_ref = trait_ty.principal_trait_ref_with_self_ty(scx.tcx(),\n-                                                                       impl_ty);\n+        let poly_trait_ref = trait_ty.principal.with_self_ty(scx.tcx(), impl_ty);\n \n         // Walk all methods of the trait, including those of its supertraits\n         for trait_ref in traits::supertraits(scx.tcx(), poly_trait_ref) {"}, {"sha": "6a99f12b2788c7cab7dd15ff0e5542931a6d9901", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=4b25f08512eab11aec151d8f718fca0d8840d0c0", "patch": "@@ -627,7 +627,7 @@ fn trait_pointer_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     // But it does not describe the trait's methods.\n \n     let def_id = match trait_type.sty {\n-        ty::TyTrait(ref data) => data.principal_def_id(),\n+        ty::TyTrait(ref data) => data.principal.def_id(),\n         _ => {\n             bug!(\"debuginfo: Unexpected trait-object type in \\\n                   trait_pointer_metadata(): {:?}\","}, {"sha": "2dd07cf44055330f489dca82d4bbfcb33bcb78be", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=4b25f08512eab11aec151d8f718fca0d8840d0c0", "patch": "@@ -476,10 +476,10 @@ pub fn push_unique_type_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             output.push(']');\n         },\n         ty::TyTrait(ref trait_data) => {\n-            push_item_name(tcx, trait_data.principal.skip_binder().def_id, output);\n+            push_item_name(tcx, trait_data.principal.def_id(), output);\n             push_type_params(tcx,\n                              &trait_data.principal.skip_binder().substs.types,\n-                             &trait_data.bounds.projection_bounds,\n+                             &trait_data.projection_bounds,\n                              output);\n         },\n         ty::TyFnDef(_, _, &ty::BareFnTy{ unsafety, abi, ref sig } ) |\n@@ -562,7 +562,7 @@ fn push_item_name(tcx: TyCtxt,\n \n fn push_type_params<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                               types: &'tcx subst::VecPerParamSpace<Ty<'tcx>>,\n-                              projections: &[ty::PolyProjectionPredicate<'tcx>],\n+                              projections: &[ty::PolyExistentialProjection<'tcx>],\n                               output: &mut String) {\n     if types.is_empty() && projections.is_empty() {\n         return;\n@@ -577,7 +577,7 @@ fn push_type_params<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     for projection in projections {\n         let projection = projection.skip_binder();\n-        let name = &projection.projection_ty.item_name.as_str();\n+        let name = &projection.item_name.as_str();\n         output.push_str(name);\n         output.push_str(\"=\");\n         push_unique_type_name(tcx, projection.ty, output);"}, {"sha": "ed4ea3c937b90b191d9b40b1812c9f74e6ff0f86", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 187, "deletions": 276, "changes": 463, "blob_url": "https://github.com/rust-lang/rust/blob/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=4b25f08512eab11aec151d8f718fca0d8840d0c0", "patch": "@@ -169,6 +169,11 @@ struct ConvertedBinding<'tcx> {\n \n type TraitAndProjections<'tcx> = (ty::PolyTraitRef<'tcx>, Vec<ty::PolyProjectionPredicate<'tcx>>);\n \n+/// Dummy type used for the `Self` of a `TraitRef` created for converting\n+/// a trait object, and which gets removed in `ExistentialTraitRef`.\n+/// This type must not appear anywhere in other converted types.\n+const TRAIT_OBJECT_DUMMY_SELF: ty::TypeVariants<'static> = ty::TyInfer(ty::FreshTy(0));\n+\n pub fn ast_region_to_region(tcx: TyCtxt, lifetime: &hir::Lifetime)\n                             -> ty::Region {\n     let r = match tcx.named_region_map.defs.get(&lifetime.id) {\n@@ -478,48 +483,37 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 type_substs.len() <= formal_ty_param_count);\n \n         let mut substs = region_substs;\n-        substs.types.extend(TypeSpace, type_substs.into_iter());\n \n-        match self_ty {\n-            None => {\n-                // If no self-type is provided, it's still possible that\n-                // one was declared, because this could be an object type.\n-            }\n-            Some(ty) => {\n-                // If a self-type is provided, one should have been\n-                // \"declared\" (in other words, this should be a\n-                // trait-ref).\n-                assert!(decl_generics.types.get_self().is_some());\n-                substs.types.push(SelfSpace, ty);\n-            }\n-        }\n+        // If a self-type was declared, one should be provided.\n+        assert_eq!(decl_generics.types.get_self().is_some(), self_ty.is_some());\n+        substs.types.extend(SelfSpace, self_ty.into_iter());\n+        substs.types.extend(TypeSpace, type_substs.into_iter());\n \n+        let is_object = self_ty.map_or(false, |ty| ty.sty == TRAIT_OBJECT_DUMMY_SELF);\n         let actual_supplied_ty_param_count = substs.types.len(TypeSpace);\n         for param in &ty_param_defs[actual_supplied_ty_param_count..] {\n-            if let Some(default) = param.default {\n+            let default = if let Some(default) = param.default {\n                 // If we are converting an object type, then the\n                 // `Self` parameter is unknown. However, some of the\n                 // other type parameters may reference `Self` in their\n                 // defaults. This will lead to an ICE if we are not\n                 // careful!\n-                if self_ty.is_none() && default.has_self_ty() {\n+                if is_object && default.has_self_ty() {\n                     span_err!(tcx.sess, span, E0393,\n                               \"the type parameter `{}` must be explicitly specified \\\n                                in an object type because its default value `{}` references \\\n                                the type `Self`\",\n                               param.name,\n                               default);\n-                    substs.types.push(TypeSpace, tcx.types.err);\n+                    tcx.types.err\n                 } else {\n                     // This is a default type parameter.\n-                    let default = default.subst_spanned(tcx,\n-                                                        &substs,\n-                                                        Some(span));\n-                    substs.types.push(TypeSpace, default);\n+                    default.subst_spanned(tcx, &substs, Some(span))\n                 }\n             } else {\n                 span_bug!(span, \"extra parameter without default\");\n-            }\n+            };\n+            substs.types.push(TypeSpace, default);\n         }\n \n         debug!(\"create_substs_for_ast_path(decl_generics={:?}, self_ty={:?}) -> {:?}\",\n@@ -539,11 +533,12 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                 self_ty: Option<Ty<'tcx>>)\n                                 -> Vec<Ty<'tcx>>\n     {\n+        let is_object = self_ty.map_or(false, |ty| ty.sty == TRAIT_OBJECT_DUMMY_SELF);\n         let use_default = |p: &ty::TypeParameterDef<'tcx>| {\n             if let Some(ref default) = p.default {\n-                if self_ty.is_none() && default.has_self_ty() {\n+                if is_object && default.has_self_ty() {\n                     // There is no suitable inference default for a type parameter\n-                    // that references self with no self-type provided.\n+                    // that references self, in an object type.\n                     return false;\n                 }\n             }\n@@ -709,7 +704,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     pub fn instantiate_poly_trait_ref(&self,\n         rscope: &RegionScope,\n         ast_trait_ref: &hir::PolyTraitRef,\n-        self_ty: Option<Ty<'tcx>>,\n+        self_ty: Ty<'tcx>,\n         poly_projections: &mut Vec<ty::PolyProjectionPredicate<'tcx>>)\n         -> ty::PolyTraitRef<'tcx>\n     {\n@@ -734,7 +729,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     pub fn instantiate_mono_trait_ref(&self,\n         rscope: &RegionScope,\n         trait_ref: &hir::TraitRef,\n-        self_ty: Option<Ty<'tcx>>)\n+        self_ty: Ty<'tcx>)\n         -> ty::TraitRef<'tcx>\n     {\n         let trait_def_id = self.trait_def_id(trait_ref);\n@@ -760,32 +755,12 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         }\n     }\n \n-    fn object_path_to_poly_trait_ref(&self,\n-        rscope: &RegionScope,\n-        span: Span,\n-        param_mode: PathParamMode,\n-        trait_def_id: DefId,\n-        trait_path_ref_id: ast::NodeId,\n-        trait_segment: &hir::PathSegment,\n-        mut projections: &mut Vec<ty::PolyProjectionPredicate<'tcx>>)\n-        -> ty::PolyTraitRef<'tcx>\n-    {\n-        self.ast_path_to_poly_trait_ref(rscope,\n-                                        span,\n-                                        param_mode,\n-                                        trait_def_id,\n-                                        None,\n-                                        trait_path_ref_id,\n-                                        trait_segment,\n-                                        projections)\n-    }\n-\n     fn ast_path_to_poly_trait_ref(&self,\n         rscope: &RegionScope,\n         span: Span,\n         param_mode: PathParamMode,\n         trait_def_id: DefId,\n-        self_ty: Option<Ty<'tcx>>,\n+        self_ty: Ty<'tcx>,\n         path_id: ast::NodeId,\n         trait_segment: &hir::PathSegment,\n         poly_projections: &mut Vec<ty::PolyProjectionPredicate<'tcx>>)\n@@ -808,21 +783,14 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                                  trait_segment);\n         let poly_trait_ref = ty::Binder(ty::TraitRef::new(trait_def_id, substs));\n \n-        {\n-            let converted_bindings =\n-                assoc_bindings\n-                .iter()\n-                .filter_map(|binding| {\n-                    // specify type to assert that error was already reported in Err case:\n-                    let predicate: Result<_, ErrorReported> =\n-                        self.ast_type_binding_to_poly_projection_predicate(path_id,\n-                                                                           poly_trait_ref.clone(),\n-                                                                           self_ty,\n-                                                                           binding);\n-                    predicate.ok() // ok to ignore Err() because ErrorReported (see above)\n-                });\n-            poly_projections.extend(converted_bindings);\n-        }\n+        poly_projections.extend(assoc_bindings.iter().filter_map(|binding| {\n+            // specify type to assert that error was already reported in Err case:\n+            let predicate: Result<_, ErrorReported> =\n+                self.ast_type_binding_to_poly_projection_predicate(path_id,\n+                                                                   poly_trait_ref,\n+                                                                   binding);\n+            predicate.ok() // ok to ignore Err() because ErrorReported (see above)\n+        }));\n \n         debug!(\"ast_path_to_poly_trait_ref(trait_segment={:?}, projections={:?}) -> {:?}\",\n                trait_segment, poly_projections, poly_trait_ref);\n@@ -834,7 +802,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                   span: Span,\n                                   param_mode: PathParamMode,\n                                   trait_def_id: DefId,\n-                                  self_ty: Option<Ty<'tcx>>,\n+                                  self_ty: Ty<'tcx>,\n                                   trait_segment: &hir::PathSegment)\n                                   -> ty::TraitRef<'tcx>\n     {\n@@ -854,7 +822,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                        span: Span,\n                                        param_mode: PathParamMode,\n                                        trait_def_id: DefId,\n-                                       self_ty: Option<Ty<'tcx>>,\n+                                       self_ty: Ty<'tcx>,\n                                        trait_segment: &hir::PathSegment)\n                                        -> (&'tcx Substs<'tcx>, Vec<ConvertedBinding<'tcx>>)\n     {\n@@ -902,7 +870,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let substs = self.create_substs_for_ast_path(span,\n                                                      param_mode,\n                                                      &trait_def.generics,\n-                                                     self_ty,\n+                                                     Some(self_ty),\n                                                      types,\n                                                      regions);\n \n@@ -912,8 +880,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     fn ast_type_binding_to_poly_projection_predicate(\n         &self,\n         path_id: ast::NodeId,\n-        mut trait_ref: ty::PolyTraitRef<'tcx>,\n-        self_ty: Option<Ty<'tcx>>,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n         binding: &ConvertedBinding<'tcx>)\n         -> Result<ty::PolyProjectionPredicate<'tcx>, ErrorReported>\n     {\n@@ -967,62 +934,39 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         // Simple case: X is defined in the current trait.\n         if self.trait_defines_associated_type_named(trait_ref.def_id(), binding.item_name) {\n-            return Ok(ty::Binder(ty::ProjectionPredicate {      // <-------------------+\n-                projection_ty: ty::ProjectionTy {               //                     |\n-                    trait_ref: trait_ref.skip_binder().clone(), // Binder moved here --+\n-                    item_name: binding.item_name,\n-                },\n-                ty: binding.ty,\n+            return Ok(trait_ref.map_bound(|trait_ref| {\n+                ty::ProjectionPredicate {\n+                    projection_ty: ty::ProjectionTy {\n+                        trait_ref: trait_ref,\n+                        item_name: binding.item_name,\n+                    },\n+                    ty: binding.ty,\n+                }\n             }));\n         }\n \n         // Otherwise, we have to walk through the supertraits to find\n-        // those that do.  This is complicated by the fact that, for an\n-        // object type, the `Self` type is not present in the\n-        // substitutions (after all, it's being constructed right now),\n-        // but the `supertraits` iterator really wants one. To handle\n-        // this, we currently insert a dummy type and then remove it\n-        // later. Yuck.\n-\n-        let dummy_self_ty = tcx.mk_infer(ty::FreshTy(0));\n-        if self_ty.is_none() { // if converting for an object type\n-            let mut dummy_substs = trait_ref.skip_binder().substs.clone(); // binder moved here -+\n-            assert!(dummy_substs.self_ty().is_none());                     //                    |\n-            dummy_substs.types.push(SelfSpace, dummy_self_ty);             //                    |\n-            trait_ref = ty::Binder(ty::TraitRef::new(trait_ref.def_id(),   // <------------+\n-                                                     tcx.mk_substs(dummy_substs)));\n-        }\n-\n+        // those that do.\n         self.ensure_super_predicates(binding.span, trait_ref.def_id())?;\n \n-        let mut candidates: Vec<ty::PolyTraitRef> =\n+        let candidates: Vec<ty::PolyTraitRef> =\n             traits::supertraits(tcx, trait_ref.clone())\n             .filter(|r| self.trait_defines_associated_type_named(r.def_id(), binding.item_name))\n             .collect();\n \n-        // If converting for an object type, then remove the dummy-ty from `Self` now.\n-        // Yuckety yuck.\n-        if self_ty.is_none() {\n-            for candidate in &mut candidates {\n-                let mut dummy_substs = candidate.0.substs.clone();\n-                assert!(dummy_substs.self_ty() == Some(dummy_self_ty));\n-                dummy_substs.types.pop(SelfSpace);\n-                *candidate = ty::Binder(ty::TraitRef::new(candidate.def_id(),\n-                                                          tcx.mk_substs(dummy_substs)));\n-            }\n-        }\n-\n         let candidate = self.one_bound_for_assoc_type(candidates,\n                                                       &trait_ref.to_string(),\n                                                       &binding.item_name.as_str(),\n                                                       binding.span)?;\n \n-        Ok(ty::Binder(ty::ProjectionPredicate {             // <-------------------------+\n-            projection_ty: ty::ProjectionTy {               //                           |\n-                trait_ref: candidate.skip_binder().clone(), // binder is moved up here --+\n-                item_name: binding.item_name,\n-            },\n-            ty: binding.ty,\n+        Ok(candidate.map_bound(|trait_ref| {\n+            ty::ProjectionPredicate {\n+                projection_ty: ty::ProjectionTy {\n+                    trait_ref: trait_ref,\n+                    item_name: binding.item_name,\n+                },\n+                ty: binding.ty,\n+            }\n         }))\n     }\n \n@@ -1059,11 +1003,12 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         decl_ty.subst(self.tcx(), &substs)\n     }\n \n-    fn ast_ty_to_trait_ref(&self,\n-                           rscope: &RegionScope,\n-                           ty: &hir::Ty,\n-                           bounds: &[hir::TyParamBound])\n-                           -> Result<TraitAndProjections<'tcx>, ErrorReported>\n+    fn ast_ty_to_object_trait_ref(&self,\n+                                  rscope: &RegionScope,\n+                                  span: Span,\n+                                  ty: &hir::Ty,\n+                                  bounds: &[hir::TyParamBound])\n+                                  -> Ty<'tcx>\n     {\n         /*!\n          * In a type like `Foo + Send`, we want to wait to collect the\n@@ -1076,33 +1021,32 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n          * name, and reports an error otherwise.\n          */\n \n+        let tcx = self.tcx();\n         match ty.node {\n             hir::TyPath(None, ref path) => {\n-                let resolution = self.tcx().expect_resolution(ty.id);\n+                let resolution = tcx.expect_resolution(ty.id);\n                 match resolution.base_def {\n                     Def::Trait(trait_def_id) if resolution.depth == 0 => {\n-                        let mut projection_bounds = Vec::new();\n-                        let trait_ref =\n-                            self.object_path_to_poly_trait_ref(rscope,\n-                                                               path.span,\n-                                                               PathParamMode::Explicit,\n-                                                               trait_def_id,\n-                                                               ty.id,\n-                                                               path.segments.last().unwrap(),\n-                                                               &mut projection_bounds);\n-                        Ok((trait_ref, projection_bounds))\n+                        self.trait_path_to_object_type(rscope,\n+                                                       path.span,\n+                                                       PathParamMode::Explicit,\n+                                                       trait_def_id,\n+                                                       ty.id,\n+                                                       path.segments.last().unwrap(),\n+                                                       span,\n+                                                       partition_bounds(tcx, span, bounds))\n                     }\n                     _ => {\n-                        struct_span_err!(self.tcx().sess, ty.span, E0172,\n+                        struct_span_err!(tcx.sess, ty.span, E0172,\n                                   \"expected a reference to a trait\")\n                             .span_label(ty.span, &format!(\"expected a trait\"))\n                             .emit();\n-                        Err(ErrorReported)\n+                        tcx.types.err\n                     }\n                 }\n             }\n             _ => {\n-                let mut err = struct_span_err!(self.tcx().sess, ty.span, E0178,\n+                let mut err = struct_span_err!(tcx.sess, ty.span, E0178,\n                                                \"expected a path on the left-hand side \\\n                                                 of `+`, not `{}`\",\n                                                pprust::ty_to_string(ty));\n@@ -1141,44 +1085,93 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                     }\n                 }\n                 err.emit();\n-                Err(ErrorReported)\n+                tcx.types.err\n             }\n         }\n     }\n \n-    fn trait_ref_to_object_type(&self,\n-                                rscope: &RegionScope,\n-                                span: Span,\n-                                trait_ref: ty::PolyTraitRef<'tcx>,\n-                                projection_bounds: Vec<ty::PolyProjectionPredicate<'tcx>>,\n-                                bounds: &[hir::TyParamBound])\n-                                -> Ty<'tcx>\n-    {\n-        let existential_bounds = self.conv_existential_bounds(rscope,\n-                                                              span,\n-                                                              trait_ref.clone(),\n-                                                              projection_bounds,\n-                                                              bounds);\n-\n-        let result = self.make_object_type(span, trait_ref, existential_bounds);\n-        debug!(\"trait_ref_to_object_type: result={:?}\",\n-               result);\n-\n-        result\n+    /// Transform a PolyTraitRef into a PolyExistentialTraitRef by\n+    /// removing the dummy Self type (TRAIT_OBJECT_DUMMY_SELF).\n+    fn trait_ref_to_existential(&self, trait_ref: ty::TraitRef<'tcx>)\n+                                -> ty::ExistentialTraitRef<'tcx> {\n+        assert_eq!(trait_ref.self_ty().sty, TRAIT_OBJECT_DUMMY_SELF);\n+        ty::ExistentialTraitRef::erase_self_ty(self.tcx(), trait_ref)\n     }\n \n-    fn make_object_type(&self,\n-                        span: Span,\n-                        principal: ty::PolyTraitRef<'tcx>,\n-                        bounds: ty::ExistentialBounds<'tcx>)\n-                        -> Ty<'tcx> {\n+    fn trait_path_to_object_type(&self,\n+                                 rscope: &RegionScope,\n+                                 path_span: Span,\n+                                 param_mode: PathParamMode,\n+                                 trait_def_id: DefId,\n+                                 trait_path_ref_id: ast::NodeId,\n+                                 trait_segment: &hir::PathSegment,\n+                                 span: Span,\n+                                 partitioned_bounds: PartitionedBounds)\n+                                 -> Ty<'tcx> {\n         let tcx = self.tcx();\n-        let object = ty::TraitTy {\n-            principal: principal,\n-            bounds: bounds\n+\n+        let mut projection_bounds = vec![];\n+        let dummy_self = tcx.mk_ty(TRAIT_OBJECT_DUMMY_SELF);\n+        let principal = self.ast_path_to_poly_trait_ref(rscope,\n+                                                        path_span,\n+                                                        param_mode,\n+                                                        trait_def_id,\n+                                                        dummy_self,\n+                                                        trait_path_ref_id,\n+                                                        trait_segment,\n+                                                        &mut projection_bounds);\n+\n+        let PartitionedBounds { builtin_bounds,\n+                                trait_bounds,\n+                                region_bounds } =\n+            partitioned_bounds;\n+\n+        if !trait_bounds.is_empty() {\n+            let b = &trait_bounds[0];\n+            let span = b.trait_ref.path.span;\n+            struct_span_err!(self.tcx().sess, span, E0225,\n+                             \"only the builtin traits can be used as closure or object bounds\")\n+                .span_label(span, &format!(\"non-builtin trait used as bounds\"))\n+                .emit();\n+        }\n+\n+        // Erase the dummy_self (TRAIT_OBJECT_DUMMY_SELF) used above.\n+        let existential_principal = principal.map_bound(|trait_ref| {\n+            self.trait_ref_to_existential(trait_ref)\n+        });\n+        let existential_projections = projection_bounds.iter().map(|bound| {\n+            bound.map_bound(|b| {\n+                let p = b.projection_ty;\n+                ty::ExistentialProjection {\n+                    trait_ref: self.trait_ref_to_existential(p.trait_ref),\n+                    item_name: p.item_name,\n+                    ty: b.ty\n+                }\n+            })\n+        }).collect();\n+\n+        let region_bound =\n+            self.compute_object_lifetime_bound(span,\n+                                               &region_bounds,\n+                                               existential_principal,\n+                                               builtin_bounds);\n+\n+        let region_bound = match region_bound {\n+            Some(r) => r,\n+            None => {\n+                match rscope.object_lifetime_default(span) {\n+                    Some(r) => r,\n+                    None => {\n+                        span_err!(self.tcx().sess, span, E0228,\n+                                  \"the lifetime bound for this object type cannot be deduced \\\n+                                   from context; please supply an explicit bound\");\n+                        ty::ReStatic\n+                    }\n+                }\n+            }\n         };\n-        let object_trait_ref =\n-            object.principal_trait_ref_with_self_ty(tcx, tcx.types.err);\n+\n+        debug!(\"region_bound: {:?}\", region_bound);\n \n         // ensure the super predicates and stop if we encountered an error\n         if self.ensure_super_predicates(span, principal.def_id()).is_err() {\n@@ -1198,7 +1191,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         }\n \n         let mut associated_types: FnvHashSet<(DefId, ast::Name)> =\n-            traits::supertraits(tcx, object_trait_ref)\n+            traits::supertraits(tcx, principal)\n             .flat_map(|tr| {\n                 let trait_def = tcx.lookup_trait_def(tr.def_id());\n                 trait_def.associated_type_names\n@@ -1208,7 +1201,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             })\n             .collect();\n \n-        for projection_bound in &object.bounds.projection_bounds {\n+        for projection_bound in &projection_bounds {\n             let pair = (projection_bound.0.projection_ty.trait_ref.def_id,\n                         projection_bound.0.projection_ty.item_name);\n             associated_types.remove(&pair);\n@@ -1224,7 +1217,14 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                         .emit();\n         }\n \n-        tcx.mk_trait(object.principal, object.bounds)\n+        let ty = tcx.mk_trait(ty::TraitObject {\n+            principal: existential_principal,\n+            region_bound: region_bound,\n+            builtin_bounds: builtin_bounds,\n+            projection_bounds: existential_projections\n+        });\n+        debug!(\"trait_object_type: {:?}\", ty);\n+        ty\n     }\n \n     fn report_ambiguous_associated_type(&self,\n@@ -1458,7 +1458,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                                         span,\n                                                         param_mode,\n                                                         trait_def_id,\n-                                                        Some(self_ty),\n+                                                        self_ty,\n                                                         trait_segment);\n \n         debug!(\"qpath_to_ty: trait_ref={:?}\", trait_ref);\n@@ -1520,23 +1520,17 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             Def::Trait(trait_def_id) => {\n                 // N.B. this case overlaps somewhat with\n                 // TyObjectSum, see that fn for details\n-                let mut projection_bounds = Vec::new();\n-\n-                let trait_ref =\n-                    self.object_path_to_poly_trait_ref(rscope,\n-                                                       span,\n-                                                       param_mode,\n-                                                       trait_def_id,\n-                                                       base_path_ref_id,\n-                                                       base_segments.last().unwrap(),\n-                                                       &mut projection_bounds);\n \n                 tcx.prohibit_type_params(base_segments.split_last().unwrap().1);\n-                self.trait_ref_to_object_type(rscope,\n-                                              span,\n-                                              trait_ref,\n-                                              projection_bounds,\n-                                              &[])\n+\n+                self.trait_path_to_object_type(rscope,\n+                                               span,\n+                                               param_mode,\n+                                               trait_def_id,\n+                                               base_path_ref_id,\n+                                               base_segments.last().unwrap(),\n+                                               span,\n+                                               partition_bounds(tcx, span, &[]))\n             }\n             Def::Enum(did) | Def::TyAlias(did) | Def::Struct(did) => {\n                 tcx.prohibit_type_params(base_segments.split_last().unwrap().1);\n@@ -1676,18 +1670,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 tcx.mk_slice(self.ast_ty_to_ty(rscope, &ty))\n             }\n             hir::TyObjectSum(ref ty, ref bounds) => {\n-                match self.ast_ty_to_trait_ref(rscope, &ty, bounds) {\n-                    Ok((trait_ref, projection_bounds)) => {\n-                        self.trait_ref_to_object_type(rscope,\n-                                                      ast_ty.span,\n-                                                      trait_ref,\n-                                                      projection_bounds,\n-                                                      bounds)\n-                    }\n-                    Err(ErrorReported) => {\n-                        self.tcx().types.err\n-                    }\n-                }\n+                self.ast_ty_to_object_trait_ref(rscope, ast_ty.span, ty, bounds)\n             }\n             hir::TyPtr(ref mt) => {\n                 tcx.mk_ptr(ty::TypeAndMut {\n@@ -1764,7 +1747,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 tcx.mk_fn_ptr(bare_fn_ty)\n             }\n             hir::TyPolyTraitRef(ref bounds) => {\n-                self.conv_ty_poly_trait_ref(rscope, ast_ty.span, bounds)\n+                self.conv_object_ty_poly_trait_ref(rscope, ast_ty.span, bounds)\n             }\n             hir::TyImplTrait(ref bounds) => {\n                 use collect::{compute_bounds, SizedByDefault};\n@@ -2091,104 +2074,32 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         }\n     }\n \n-    /// Given an existential type like `Foo+'a+Bar`, this routine converts\n-    /// the `'a` and `Bar` intos an `ExistentialBounds` struct.\n-    /// The `main_trait_refs` argument specifies the `Foo` -- it is absent\n-    /// for closures. Eventually this should all be normalized, I think,\n-    /// so that there is no \"main trait ref\" and instead we just have a flat\n-    /// list of bounds as the existential type.\n-    fn conv_existential_bounds(&self,\n-        rscope: &RegionScope,\n-        span: Span,\n-        principal_trait_ref: ty::PolyTraitRef<'tcx>,\n-        projection_bounds: Vec<ty::PolyProjectionPredicate<'tcx>>,\n-        ast_bounds: &[hir::TyParamBound])\n-        -> ty::ExistentialBounds<'tcx>\n-    {\n-        let partitioned_bounds =\n-            partition_bounds(self.tcx(), span, ast_bounds);\n-\n-        self.conv_existential_bounds_from_partitioned_bounds(\n-            rscope, span, principal_trait_ref, projection_bounds, partitioned_bounds)\n-    }\n-\n-    fn conv_ty_poly_trait_ref(&self,\n+    fn conv_object_ty_poly_trait_ref(&self,\n         rscope: &RegionScope,\n         span: Span,\n         ast_bounds: &[hir::TyParamBound])\n         -> Ty<'tcx>\n     {\n         let mut partitioned_bounds = partition_bounds(self.tcx(), span, &ast_bounds[..]);\n \n-        let mut projection_bounds = Vec::new();\n-        let main_trait_bound = if !partitioned_bounds.trait_bounds.is_empty() {\n-            let trait_bound = partitioned_bounds.trait_bounds.remove(0);\n-            self.instantiate_poly_trait_ref(rscope,\n-                                            trait_bound,\n-                                            None,\n-                                            &mut projection_bounds)\n+        let trait_bound = if !partitioned_bounds.trait_bounds.is_empty() {\n+            partitioned_bounds.trait_bounds.remove(0)\n         } else {\n             span_err!(self.tcx().sess, span, E0224,\n                       \"at least one non-builtin trait is required for an object type\");\n             return self.tcx().types.err;\n         };\n \n-        let bounds =\n-            self.conv_existential_bounds_from_partitioned_bounds(rscope,\n-                                                                 span,\n-                                                                 main_trait_bound.clone(),\n-                                                                 projection_bounds,\n-                                                                 partitioned_bounds);\n-\n-        self.make_object_type(span, main_trait_bound, bounds)\n-    }\n-\n-    pub fn conv_existential_bounds_from_partitioned_bounds(&self,\n-        rscope: &RegionScope,\n-        span: Span,\n-        principal_trait_ref: ty::PolyTraitRef<'tcx>,\n-        projection_bounds: Vec<ty::PolyProjectionPredicate<'tcx>>, // Empty for boxed closures\n-        partitioned_bounds: PartitionedBounds)\n-        -> ty::ExistentialBounds<'tcx>\n-    {\n-        let PartitionedBounds { builtin_bounds,\n-                                trait_bounds,\n-                                region_bounds } =\n-            partitioned_bounds;\n-\n-        if !trait_bounds.is_empty() {\n-            let b = &trait_bounds[0];\n-            let span = b.trait_ref.path.span;\n-            struct_span_err!(self.tcx().sess, span, E0225,\n-                             \"only the builtin traits can be used as closure or object bounds\")\n-                .span_label(span, &format!(\"non-builtin trait used as bounds\"))\n-                .emit();\n-        }\n-\n-        let region_bound =\n-            self.compute_object_lifetime_bound(span,\n-                                               &region_bounds,\n-                                               principal_trait_ref,\n-                                               builtin_bounds);\n-\n-        let region_bound = match region_bound {\n-            Some(r) => r,\n-            None => {\n-                match rscope.object_lifetime_default(span) {\n-                    Some(r) => r,\n-                    None => {\n-                        span_err!(self.tcx().sess, span, E0228,\n-                                  \"the lifetime bound for this object type cannot be deduced \\\n-                                   from context; please supply an explicit bound\");\n-                        ty::ReStatic\n-                    }\n-                }\n-            }\n-        };\n-\n-        debug!(\"region_bound: {:?}\", region_bound);\n-\n-        ty::ExistentialBounds::new(region_bound, builtin_bounds, projection_bounds)\n+        let trait_ref = &trait_bound.trait_ref;\n+        let trait_def_id = self.trait_def_id(trait_ref);\n+        self.trait_path_to_object_type(rscope,\n+                                       trait_ref.path.span,\n+                                       PathParamMode::Explicit,\n+                                       trait_def_id,\n+                                       trait_ref.ref_id,\n+                                       trait_ref.path.segments.last().unwrap(),\n+                                       span,\n+                                       partitioned_bounds)\n     }\n \n     /// Given the bounds on an object, determines what single region bound (if any) we can\n@@ -2199,7 +2110,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     fn compute_object_lifetime_bound(&self,\n         span: Span,\n         explicit_region_bounds: &[&hir::Lifetime],\n-        principal_trait_ref: ty::PolyTraitRef<'tcx>,\n+        principal_trait_ref: ty::PolyExistentialTraitRef<'tcx>,\n         builtin_bounds: ty::BuiltinBounds)\n         -> Option<ty::Region> // if None, use the default\n     {\n@@ -2230,7 +2141,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         // No explicit region bound specified. Therefore, examine trait\n         // bounds and see if we can derive region bounds from those.\n         let derived_region_bounds =\n-            object_region_bounds(tcx, &principal_trait_ref, builtin_bounds);\n+            object_region_bounds(tcx, principal_trait_ref, builtin_bounds);\n \n         // If there are no derived region bounds, then report back that we\n         // can find no region bound. The caller will use the default."}, {"sha": "fb78d3a37ca236404c5706916566637f1d3be83c", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=4b25f08512eab11aec151d8f718fca0d8840d0c0", "patch": "@@ -78,7 +78,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn unsize_kind(&self, t: Ty<'tcx>) -> Option<UnsizeKind<'tcx>> {\n         match t.sty {\n             ty::TySlice(_) | ty::TyStr => Some(UnsizeKind::Length),\n-            ty::TyTrait(ref tty) => Some(UnsizeKind::Vtable(tty.principal_def_id())),\n+            ty::TyTrait(ref tty) => Some(UnsizeKind::Vtable(tty.principal.def_id())),\n             ty::TyStruct(def, substs) => {\n                 // FIXME(arielb1): do some kind of normalization\n                 match def.struct_variant().fields.last() {"}, {"sha": "8a007293e64ff3aed6596953b700c7b7fa591fee", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=4b25f08512eab11aec151d8f718fca0d8840d0c0", "patch": "@@ -102,12 +102,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         match expected_ty.sty {\n             ty::TyTrait(ref object_type) => {\n-                let proj_bounds = object_type.projection_bounds_with_self_ty(self.tcx,\n-                                                                             self.tcx.types.err);\n-                let sig = proj_bounds.iter()\n-                                     .filter_map(|pb| self.deduce_sig_from_projection(pb))\n-                                     .next();\n-                let kind = self.tcx.lang_items.fn_trait_kind(object_type.principal_def_id());\n+                let sig = object_type.projection_bounds.iter().filter_map(|pb| {\n+                    let pb = pb.with_self_ty(self.tcx, self.tcx.types.err);\n+                    self.deduce_sig_from_projection(&pb)\n+                }).next();\n+                let kind = self.tcx.lang_items.fn_trait_kind(object_type.principal.def_id());\n                 (sig, kind)\n             }\n             ty::TyInfer(ty::TyVar(vid)) => {"}, {"sha": "250bf9265d1a4c35db26425a75a2309ac0c94088", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=4b25f08512eab11aec151d8f718fca0d8840d0c0", "patch": "@@ -210,7 +210,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n \n             probe::ObjectPick => {\n                 let trait_def_id = pick.item.container().id();\n-                self.extract_trait_ref(self_ty, |this, object_ty, data| {\n+                self.extract_existential_trait_ref(self_ty, |this, object_ty, principal| {\n                     // The object data has no entry for the Self\n                     // Type. For the purposes of this method call, we\n                     // substitute the object type itself. This\n@@ -222,9 +222,9 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                     // been ruled out when we deemed the trait to be\n                     // \"object safe\".\n                     let original_poly_trait_ref =\n-                        data.principal_trait_ref_with_self_ty(this.tcx, object_ty);\n+                        principal.with_self_ty(this.tcx, object_ty);\n                     let upcast_poly_trait_ref =\n-                        this.upcast(original_poly_trait_ref.clone(), trait_def_id);\n+                        this.upcast(original_poly_trait_ref, trait_def_id);\n                     let upcast_trait_ref =\n                         this.replace_late_bound_regions_with_fresh_var(&upcast_poly_trait_ref);\n                     debug!(\"original_poly_trait_ref={:?} upcast_trait_ref={:?} target_trait={:?}\",\n@@ -276,8 +276,12 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn extract_trait_ref<R, F>(&mut self, self_ty: Ty<'tcx>, mut closure: F) -> R where\n-        F: FnMut(&mut ConfirmContext<'a, 'gcx, 'tcx>, Ty<'tcx>, &ty::TraitTy<'tcx>) -> R,\n+    fn extract_existential_trait_ref<R, F>(&mut self,\n+                                           self_ty: Ty<'tcx>,\n+                                           mut closure: F) -> R\n+        where F: FnMut(&mut ConfirmContext<'a, 'gcx, 'tcx>,\n+                       Ty<'tcx>,\n+                       ty::PolyExistentialTraitRef<'tcx>) -> R,\n     {\n         // If we specified that this is an object method, then the\n         // self-type ought to be something that can be dereferenced to\n@@ -288,7 +292,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         self.fcx.autoderef(self.span, self_ty)\n             .filter_map(|(ty, _)| {\n                 match ty.sty {\n-                    ty::TyTrait(ref data) => Some(closure(self, ty, &data)),\n+                    ty::TyTrait(ref data) => Some(closure(self, ty, data.principal)),\n                     _ => None,\n                 }\n             })\n@@ -331,9 +335,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         // parameters from the type and those from the method.\n         //\n         // FIXME -- permit users to manually specify lifetimes\n-        let type_defs = method.generics.types.as_full_slice();\n-        let region_defs = method.generics.regions.as_full_slice();\n-        subst::Substs::from_param_defs(region_defs, type_defs, |def| {\n+        subst::Substs::from_generics(&method.generics, |def, _| {\n             if def.space != subst::FnSpace {\n                 substs.region_for_def(def)\n             } else {"}, {"sha": "ff34f37bde0dd44e04aa714783d69b26f11162ed", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=4b25f08512eab11aec151d8f718fca0d8840d0c0", "patch": "@@ -189,9 +189,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         assert!(trait_def.generics.regions.is_empty());\n \n         // Construct a trait-reference `self_ty : Trait<input_tys>`\n-        let type_defs = trait_def.generics.types.as_full_slice();\n-        let region_defs = trait_def.generics.regions.as_full_slice();\n-        let substs = subst::Substs::from_param_defs(region_defs, type_defs, |def| {\n+        let substs = subst::Substs::from_generics(&trait_def.generics, |def, _| {\n             self.region_var_for_def(span, def)\n         }, |def, substs| {\n             if def.space == subst::SelfSpace {"}, {"sha": "f6ac3235cf33ef476f94f92b2640cf35d27e661c", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 15, "deletions": 22, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=4b25f08512eab11aec151d8f718fca0d8840d0c0", "patch": "@@ -290,8 +290,8 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n         match self_ty.sty {\n             ty::TyTrait(box ref data) => {\n-                self.assemble_inherent_candidates_from_object(self_ty, data);\n-                self.assemble_inherent_impl_candidates_for_type(data.principal_def_id());\n+                self.assemble_inherent_candidates_from_object(self_ty, data.principal);\n+                self.assemble_inherent_impl_candidates_for_type(data.principal.def_id());\n             }\n             ty::TyEnum(def, _) |\n             ty::TyStruct(def, _) => {\n@@ -445,7 +445,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n     fn assemble_inherent_candidates_from_object(&mut self,\n                                                 self_ty: Ty<'tcx>,\n-                                                data: &ty::TraitTy<'tcx>) {\n+                                                principal: ty::PolyExistentialTraitRef<'tcx>) {\n         debug!(\"assemble_inherent_candidates_from_object(self_ty={:?})\",\n                self_ty);\n \n@@ -456,7 +456,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         // a substitution that replaces `Self` with the object type\n         // itself. Hence, a `&self` method will wind up with an\n         // argument type like `&Trait`.\n-        let trait_ref = data.principal_trait_ref_with_self_ty(self.tcx, self_ty);\n+        let trait_ref = principal.with_self_ty(self.tcx, self_ty);\n         self.elaborate_bounds(&[trait_ref], |this, new_trait_ref, item| {\n             let new_trait_ref = this.erase_late_bound_regions(&new_trait_ref);\n \n@@ -1227,15 +1227,16 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             return impl_ty;\n         }\n \n-        let placeholder;\n-        let mut substs = substs;\n-        if\n-            !method.generics.types.is_empty_in(subst::FnSpace) ||\n-            !method.generics.regions.is_empty_in(subst::FnSpace)\n-        {\n-            let type_defs = method.generics.types.as_full_slice();\n-            let region_defs = method.generics.regions.as_full_slice();\n-            placeholder = subst::Substs::from_param_defs(region_defs, type_defs, |def| {\n+        // Erase any late-bound regions from the method and substitute\n+        // in the values from the substitution.\n+        let xform_self_ty = method.fty.sig.input(0);\n+        let xform_self_ty = self.erase_late_bound_regions(&xform_self_ty);\n+\n+        if method.generics.types.is_empty_in(subst::FnSpace) &&\n+           method.generics.regions.is_empty_in(subst::FnSpace) {\n+            xform_self_ty.subst(self.tcx, substs)\n+        } else {\n+            let substs = subst::Substs::from_generics(&method.generics, |def, _| {\n                 if def.space != subst::FnSpace {\n                     substs.region_for_def(def)\n                 } else {\n@@ -1250,16 +1251,8 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                     self.type_var_for_def(self.span, def, cur_substs)\n                 }\n             });\n-            substs = &placeholder;\n+            xform_self_ty.subst(self.tcx, &substs)\n         }\n-\n-        // Erase any late-bound regions from the method and substitute\n-        // in the values from the substitution.\n-        let xform_self_ty = method.fty.sig.input(0);\n-        let xform_self_ty = self.erase_late_bound_regions(&xform_self_ty);\n-        let xform_self_ty = xform_self_ty.subst(self.tcx, substs);\n-\n-        xform_self_ty\n     }\n \n     /// Get the type of an impl and generate substitutions with placeholders."}, {"sha": "dc6fa334b74fc66ad5f86e11bf358a6c2c3ee665", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=4b25f08512eab11aec151d8f718fca0d8840d0c0", "patch": "@@ -358,7 +358,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             match ty.sty {\n                 ty::TyEnum(def, _) | ty::TyStruct(def, _) => def.did.is_local(),\n \n-                ty::TyTrait(ref tr) => tr.principal_def_id().is_local(),\n+                ty::TyTrait(ref tr) => tr.principal.def_id().is_local(),\n \n                 ty::TyParam(_) => true,\n "}, {"sha": "8e34b0b8c55595ed8be6e1e7e38f5329d22bfb55", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=4b25f08512eab11aec151d8f718fca0d8840d0c0", "patch": "@@ -824,11 +824,11 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             }\n \n             /*From:*/ (_,\n-            /*To:  */  &ty::TyTrait(box ty::TraitTy { ref bounds, .. })) => {\n+            /*To:  */  &ty::TyTrait(ref obj)) => {\n                 // When T is existentially quantified as a trait\n                 // `Foo+'to`, it must outlive the region bound `'to`.\n                 self.type_must_outlive(infer::RelateObjectBound(cast_expr.span),\n-                                       from_ty, bounds.region_bound);\n+                                       from_ty, obj.region_bound);\n             }\n \n             /*From:*/ (&ty::TyBox(from_referent_ty),"}, {"sha": "485e744bf916eb573c861de4f96dd5fe6a76da7e", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=4b25f08512eab11aec151d8f718fca0d8840d0c0", "patch": "@@ -75,7 +75,7 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n             }\n \n             TyTrait(ref t) => {\n-                Some(t.principal_def_id())\n+                Some(t.principal.def_id())\n             }\n \n             TyBox(_) => {"}, {"sha": "97aed4d5e82f9f1fb583046d97ab01bf5ed38ceb", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=4b25f08512eab11aec151d8f718fca0d8840d0c0", "patch": "@@ -80,7 +80,7 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                         self.check_def_id(item, def.did);\n                     }\n                     ty::TyTrait(ref data) => {\n-                        self.check_def_id(item, data.principal_def_id());\n+                        self.check_def_id(item, data.principal.def_id());\n                     }\n                     ty::TyBox(..) => {\n                         match self.tcx.lang_items.require_owned_box() {"}, {"sha": "f60fb9583a66113a6ca8970350d358e18f30b965", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=4b25f08512eab11aec151d8f718fca0d8840d0c0", "patch": "@@ -168,14 +168,14 @@ impl<'cx, 'tcx,'v> intravisit::Visitor<'v> for OverlapChecker<'cx, 'tcx> {\n                     // This is something like impl Trait1 for Trait2. Illegal\n                     // if Trait1 is a supertrait of Trait2 or Trait2 is not object safe.\n \n-                    if !self.tcx.is_object_safe(data.principal_def_id()) {\n+                    if !self.tcx.is_object_safe(data.principal.def_id()) {\n                         // This is an error, but it will be\n                         // reported by wfcheck.  Ignore it\n                         // here. This is tested by\n                         // `coherence-impl-trait-for-trait-object-safe.rs`.\n                     } else {\n                         let mut supertrait_def_ids =\n-                            traits::supertrait_def_ids(self.tcx, data.principal_def_id());\n+                            traits::supertrait_def_ids(self.tcx, data.principal.def_id());\n                         if supertrait_def_ids.any(|d| d == trait_def_id) {\n                             span_err!(self.tcx.sess, item.span, E0371,\n                                       \"the object type `{}` automatically \\"}, {"sha": "a2a162a7f5f742906a0b1b49502c123fa45fe540", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 13, "deletions": 21, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=4b25f08512eab11aec151d8f718fca0d8840d0c0", "patch": "@@ -722,7 +722,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                 AstConv::instantiate_mono_trait_ref(&ccx.icx(&()),\n                                                     &ExplicitRscope,\n                                                     ast_trait_ref,\n-                                                    None);\n+                                                    tcx.mk_self_type());\n \n             tcx.record_trait_has_default_impl(trait_ref.def_id);\n \n@@ -752,7 +752,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                 AstConv::instantiate_mono_trait_ref(&ccx.icx(&ty_predicates),\n                                                     &ExplicitRscope,\n                                                     ast_trait_ref,\n-                                                    Some(selfty))\n+                                                    selfty)\n             });\n             tcx.impl_trait_refs.borrow_mut().insert(def_id, trait_ref);\n \n@@ -1815,10 +1815,12 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                             let mut projections = Vec::new();\n \n                             let trait_ref =\n-                                conv_poly_trait_ref(&ccx.icx(&(base_predicates, ast_generics)),\n-                                                    ty,\n-                                                    poly_trait_ref,\n-                                                    &mut projections);\n+                                AstConv::instantiate_poly_trait_ref(&ccx.icx(&(base_predicates,\n+                                                                               ast_generics)),\n+                                                                    &ExplicitRscope,\n+                                                                    poly_trait_ref,\n+                                                                    ty,\n+                                                                    &mut projections);\n \n                             result.predicates.push(trait_ref.to_predicate());\n \n@@ -2069,7 +2071,7 @@ pub fn compute_bounds<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n     let mut trait_bounds: Vec<_> = trait_bounds.iter().map(|&bound| {\n         astconv.instantiate_poly_trait_ref(&rscope,\n                                            bound,\n-                                           Some(param_ty),\n+                                           param_ty,\n                                            &mut projection_bounds)\n     }).collect();\n \n@@ -2100,7 +2102,10 @@ fn predicates_from_bound<'tcx>(astconv: &AstConv<'tcx, 'tcx>,\n     match *bound {\n         hir::TraitTyParamBound(ref tr, hir::TraitBoundModifier::None) => {\n             let mut projections = Vec::new();\n-            let pred = conv_poly_trait_ref(astconv, param_ty, tr, &mut projections);\n+            let pred = astconv.instantiate_poly_trait_ref(&ExplicitRscope,\n+                                                          tr,\n+                                                          param_ty,\n+                                                          &mut projections);\n             projections.into_iter()\n                        .map(|p| p.to_predicate())\n                        .chain(Some(pred.to_predicate()))\n@@ -2117,19 +2122,6 @@ fn predicates_from_bound<'tcx>(astconv: &AstConv<'tcx, 'tcx>,\n     }\n }\n \n-fn conv_poly_trait_ref<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n-                                         param_ty: Ty<'tcx>,\n-                                         trait_ref: &hir::PolyTraitRef,\n-                                         projections: &mut Vec<ty::PolyProjectionPredicate<'tcx>>)\n-                                         -> ty::PolyTraitRef<'tcx>\n-{\n-    AstConv::instantiate_poly_trait_ref(astconv,\n-                                        &ExplicitRscope,\n-                                        trait_ref,\n-                                        Some(param_ty),\n-                                        projections)\n-}\n-\n fn compute_type_scheme_of_foreign_fn_decl<'a, 'tcx>(\n     ccx: &CrateCtxt<'a, 'tcx>,\n     id: DefId,"}, {"sha": "6e6f9ce65c50faecbe0bd5eede99f9c1c295b04e", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=4b25f08512eab11aec151d8f718fca0d8840d0c0", "patch": "@@ -396,19 +396,16 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n             ty::TyTrait(ref data) => {\n                 let poly_trait_ref =\n-                    data.principal_trait_ref_with_self_ty(self.tcx(),\n-                                                          self.tcx().types.err);\n+                    data.principal.with_self_ty(self.tcx(), self.tcx().types.err);\n \n                 // The type `Foo<T+'a>` is contravariant w/r/t `'a`:\n                 let contra = self.contravariant(variance);\n-                self.add_constraints_from_region(generics, data.bounds.region_bound, contra);\n+                self.add_constraints_from_region(generics, data.region_bound, contra);\n \n                 // Ignore the SelfSpace, it is erased.\n                 self.add_constraints_from_trait_ref(generics, poly_trait_ref.0, variance);\n \n-                let projections = data.projection_bounds_with_self_ty(self.tcx(),\n-                                                                      self.tcx().types.err);\n-                for projection in &projections {\n+                for projection in &data.projection_bounds {\n                     self.add_constraints_from_ty(generics, projection.0.ty, self.invariant);\n                 }\n             }"}, {"sha": "ffe5b9aad2fb36361674b37d34b87cc8b5b27676", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 18, "deletions": 24, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b25f08512eab11aec151d8f718fca0d8840d0c0/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=4b25f08512eab11aec151d8f718fca0d8840d0c0", "patch": "@@ -630,26 +630,6 @@ impl Clean<TyParamBound> for hir::TyParamBound {\n     }\n }\n \n-impl<'tcx> Clean<(Vec<TyParamBound>, Vec<TypeBinding>)> for ty::ExistentialBounds<'tcx> {\n-    fn clean(&self, cx: &DocContext) -> (Vec<TyParamBound>, Vec<TypeBinding>) {\n-        let mut tp_bounds = vec![];\n-        self.region_bound.clean(cx).map(|b| tp_bounds.push(RegionBound(b)));\n-        for bb in &self.builtin_bounds {\n-            tp_bounds.push(bb.clean(cx));\n-        }\n-\n-        let mut bindings = vec![];\n-        for &ty::Binder(ref pb) in &self.projection_bounds {\n-            bindings.push(TypeBinding {\n-                name: pb.projection_ty.item_name.clean(cx),\n-                ty: pb.ty.clean(cx)\n-            });\n-        }\n-\n-        (tp_bounds, bindings)\n-    }\n-}\n-\n fn external_path_params(cx: &DocContext, trait_did: Option<DefId>,\n                         bindings: Vec<TypeBinding>, substs: &subst::Substs) -> PathParameters {\n     let lifetimes = substs.regions.get_slice(subst::TypeSpace)\n@@ -1848,12 +1828,26 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n                     is_generic: false,\n                 }\n             }\n-            ty::TyTrait(box ty::TraitTy { ref principal, ref bounds }) => {\n-                let did = principal.def_id();\n+            ty::TyTrait(ref obj) => {\n+                let did = obj.principal.def_id();\n                 inline::record_extern_fqn(cx, did, TypeTrait);\n-                let (typarams, bindings) = bounds.clean(cx);\n+\n+                let mut typarams = vec![];\n+                obj.region_bound.clean(cx).map(|b| typarams.push(RegionBound(b)));\n+                for bb in &obj.builtin_bounds {\n+                    typarams.push(bb.clean(cx));\n+                }\n+\n+                let mut bindings = vec![];\n+                for &ty::Binder(ref pb) in &obj.projection_bounds {\n+                    bindings.push(TypeBinding {\n+                        name: pb.item_name.clean(cx),\n+                        ty: pb.ty.clean(cx)\n+                    });\n+                }\n+\n                 let path = external_path(cx, &cx.tcx().item_name(did).as_str(),\n-                                         Some(did), bindings, principal.substs());\n+                                         Some(did), bindings, obj.principal.0.substs);\n                 ResolvedPath {\n                     path: path,\n                     typarams: Some(typarams),"}]}