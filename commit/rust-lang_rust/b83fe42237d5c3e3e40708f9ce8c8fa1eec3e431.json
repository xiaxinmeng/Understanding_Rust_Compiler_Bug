{"sha": "b83fe42237d5c3e3e40708f9ce8c8fa1eec3e431", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4M2ZlNDIyMzdkNWMzZTNlNDA3MDhmOWNlOGM4ZmExZWVjM2U0MzE=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2018-08-21T19:40:03Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2018-08-22T20:36:10Z"}, "message": "Hard error for unsized values more often\n* Sized checking in MIR should be a hard error in all borrowck modes\n* box operands should be an error even with unsized locals", "tree": {"sha": "83b78dc3cf506849f088a6a06b99325bfd92b40d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/83b78dc3cf506849f088a6a06b99325bfd92b40d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b83fe42237d5c3e3e40708f9ce8c8fa1eec3e431", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b83fe42237d5c3e3e40708f9ce8c8fa1eec3e431", "html_url": "https://github.com/rust-lang/rust/commit/b83fe42237d5c3e3e40708f9ce8c8fa1eec3e431", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b83fe42237d5c3e3e40708f9ce8c8fa1eec3e431/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b75b0471a8b87c44e0bd953d2a5c36d896128723", "url": "https://api.github.com/repos/rust-lang/rust/commits/b75b0471a8b87c44e0bd953d2a5c36d896128723", "html_url": "https://github.com/rust-lang/rust/commit/b75b0471a8b87c44e0bd953d2a5c36d896128723"}], "stats": {"total": 55, "additions": 23, "deletions": 32}, "files": [{"sha": "502b67b513692227ac65e01009748287d1784bd5", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b83fe42237d5c3e3e40708f9ce8c8fa1eec3e431/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b83fe42237d5c3e3e40708f9ce8c8fa1eec3e431/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=b83fe42237d5c3e3e40708f9ce8c8fa1eec3e431", "patch": "@@ -125,7 +125,6 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n         flow_inits,\n         move_data,\n         elements,\n-        errors_buffer,\n     );\n \n     if let Some(all_facts) = &mut all_facts {"}, {"sha": "0f17f4e7721fe7929ebf745c2a2b30ce0b98c55f", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 23, "deletions": 31, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/b83fe42237d5c3e3e40708f9ce8c8fa1eec3e431/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b83fe42237d5c3e3e40708f9ce8c8fa1eec3e431/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=b83fe42237d5c3e3e40708f9ce8c8fa1eec3e431", "patch": "@@ -38,7 +38,6 @@ use rustc::traits::query::type_op;\n use rustc::traits::query::{Fallible, NoSolution};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::{self, CanonicalTy, RegionVid, ToPolyTraitRef, Ty, TyCtxt, TyKind};\n-use rustc_errors::Diagnostic;\n use std::fmt;\n use std::rc::Rc;\n use syntax_pos::{Span, DUMMY_SP};\n@@ -106,8 +105,7 @@ mod relate_tys;\n /// - `liveness` -- results of a liveness computation on the MIR; used to create liveness\n ///   constraints for the regions in the types of variables\n /// - `flow_inits` -- results of a maybe-init dataflow analysis\n-/// - `move_data` -- move-data constructed when performing the maybe-init dataflow analysis\n-/// - `errors_buffer` -- errors are sent here for future reporting\n+/// - `move_data` -- move-data constructed when performing the maybe-init dataflow analysiss\n pub(crate) fn type_check<'gcx, 'tcx>(\n     infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n     param_env: ty::ParamEnv<'gcx>,\n@@ -120,7 +118,6 @@ pub(crate) fn type_check<'gcx, 'tcx>(\n     flow_inits: &mut FlowAtLocation<MaybeInitializedPlaces<'_, 'gcx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n     elements: &Rc<RegionValueElements>,\n-    errors_buffer: &mut Vec<Diagnostic>,\n ) -> MirTypeckResults<'tcx> {\n     let implicit_region_bound = infcx.tcx.mk_region(ty::ReVar(universal_regions.fr_fn_body));\n     let mut constraints = MirTypeckRegionConstraints {\n@@ -161,7 +158,6 @@ pub(crate) fn type_check<'gcx, 'tcx>(\n             &region_bound_pairs,\n             Some(implicit_region_bound),\n             Some(&mut borrowck_context),\n-            Some(errors_buffer),\n             |cx| {\n                 cx.equate_inputs_and_outputs(\n                     mir,\n@@ -191,7 +187,6 @@ fn type_check_internal<'a, 'gcx, 'tcx, R>(\n     region_bound_pairs: &'a [(ty::Region<'tcx>, GenericKind<'tcx>)],\n     implicit_region_bound: Option<ty::Region<'tcx>>,\n     borrowck_context: Option<&'a mut BorrowCheckContext<'a, 'tcx>>,\n-    errors_buffer: Option<&mut Vec<Diagnostic>>,\n     mut extra: impl FnMut(&mut TypeChecker<'a, 'gcx, 'tcx>) -> R,\n ) -> R where {\n     let mut checker = TypeChecker::new(\n@@ -211,7 +206,7 @@ fn type_check_internal<'a, 'gcx, 'tcx, R>(\n \n     if !errors_reported {\n         // if verifier failed, don't do further checks to avoid ICEs\n-        checker.typeck_mir(mir, errors_buffer);\n+        checker.typeck_mir(mir);\n     }\n \n     extra(&mut checker)\n@@ -964,7 +959,6 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         mir: &Mir<'tcx>,\n         term: &Terminator<'tcx>,\n         term_location: Location,\n-        errors_buffer: &mut Option<&mut Vec<Diagnostic>>,\n     ) {\n         debug!(\"check_terminator: {:?}\", term);\n         let tcx = self.tcx();\n@@ -1044,7 +1038,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     &sig,\n                 );\n                 let sig = self.normalize(sig, term_location);\n-                self.check_call_dest(mir, term, &sig, destination, term_location, errors_buffer);\n+                self.check_call_dest(mir, term, &sig, destination, term_location);\n \n                 self.prove_predicates(\n                     sig.inputs().iter().map(|ty| ty::Predicate::WellFormed(ty)),\n@@ -1118,7 +1112,6 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         sig: &ty::FnSig<'tcx>,\n         destination: &Option<(Place<'tcx>, BasicBlock)>,\n         term_location: Location,\n-        errors_buffer: &mut Option<&mut Vec<Diagnostic>>,\n     ) {\n         let tcx = self.tcx();\n         match *destination {\n@@ -1152,7 +1145,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 // this check is done at `check_local`.\n                 if self.tcx().features().unsized_locals {\n                     let span = term.source_info.span;\n-                    self.ensure_place_sized(dest_ty, span, errors_buffer);\n+                    self.ensure_place_sized(dest_ty, span);\n                 }\n             }\n             None => {\n@@ -1305,7 +1298,6 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         mir: &Mir<'tcx>,\n         local: Local,\n         local_decl: &LocalDecl<'tcx>,\n-        errors_buffer: &mut Option<&mut Vec<Diagnostic>>,\n     ) {\n         match mir.local_kind(local) {\n             LocalKind::ReturnPointer | LocalKind::Arg => {\n@@ -1321,18 +1313,15 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n \n         // When `#![feature(unsized_locals)]` is enabled, only function calls\n-        // are checked in `check_call_dest`.\n+        // and nullary ops are checked in `check_call_dest`.\n         if !self.tcx().features().unsized_locals {\n             let span = local_decl.source_info.span;\n             let ty = local_decl.ty;\n-            self.ensure_place_sized(ty, span, errors_buffer);\n+            self.ensure_place_sized(ty, span);\n         }\n     }\n \n-    fn ensure_place_sized(&mut self,\n-                          ty: Ty<'tcx>,\n-                          span: Span,\n-                          errors_buffer: &mut Option<&mut Vec<Diagnostic>>) {\n+    fn ensure_place_sized(&mut self, ty: Ty<'tcx>, span: Span) {\n         let tcx = self.tcx();\n \n         // Erase the regions from `ty` to get a global type.  The\n@@ -1354,15 +1343,13 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                      cannot be statically determined\",\n                     ty\n                 );\n-                if let Some(ref mut errors_buffer) = *errors_buffer {\n-                    diag.buffer(errors_buffer);\n-                } else {\n-                    // we're allowed to use emit() here because the\n-                    // NLL migration will be turned on (and thus\n-                    // errors will need to be buffered) *only if*\n-                    // errors_buffer is Some.\n-                    diag.emit();\n-                }\n+\n+                // While this is located in `nll::typeck` this error is not\n+                // an NLL error, it's a required check to prevent creation\n+                // of unsized rvalues in certain cases:\n+                // * operand of a box expression\n+                // * callee in a call expression\n+                diag.emit();\n             }\n         }\n     }\n@@ -1437,6 +1424,12 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             },\n \n             Rvalue::NullaryOp(_, ty) => {\n+                // Even with unsized locals cannot box an unsized value.\n+                if self.tcx().features().unsized_locals {\n+                    let span = mir.source_info(location).span;\n+                    self.ensure_place_sized(ty, span);\n+                }\n+\n                 let trait_ref = ty::TraitRef {\n                     def_id: tcx.lang_items().sized_trait().unwrap(),\n                     substs: tcx.mk_substs_trait(ty, &[]),\n@@ -1840,12 +1833,12 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         })\n     }\n \n-    fn typeck_mir(&mut self, mir: &Mir<'tcx>, mut errors_buffer: Option<&mut Vec<Diagnostic>>) {\n+    fn typeck_mir(&mut self, mir: &Mir<'tcx>) {\n         self.last_span = mir.span;\n         debug!(\"run_on_mir: {:?}\", mir.span);\n \n         for (local, local_decl) in mir.local_decls.iter_enumerated() {\n-            self.check_local(mir, local, local_decl, &mut errors_buffer);\n+            self.check_local(mir, local, local_decl);\n         }\n \n         for (block, block_data) in mir.basic_blocks().iter_enumerated() {\n@@ -1861,7 +1854,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 location.statement_index += 1;\n             }\n \n-            self.check_terminator(mir, block_data.terminator(), location, &mut errors_buffer);\n+            self.check_terminator(mir, block_data.terminator(), location);\n             self.check_iscleanup(mir, block_data);\n         }\n     }\n@@ -1918,7 +1911,6 @@ impl MirPass for TypeckMir {\n                 &[],\n                 None,\n                 None,\n-                None,\n                 |_| (),\n             );\n "}]}