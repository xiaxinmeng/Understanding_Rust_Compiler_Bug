{"sha": "7166e8549bad95b05f66acd508d07a6cd97d3dc0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxNjZlODU0OWJhZDk1YjA1ZjY2YWNkNTA4ZDA3YTZjZDk3ZDNkYzA=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-06-13T16:45:16Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-06-13T16:45:16Z"}, "message": "internal: refactor NoSuchField diagnostic", "tree": {"sha": "cf85d27f8eda6afdf4f9a92bcf646a7e1ce77397", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf85d27f8eda6afdf4f9a92bcf646a7e1ce77397"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7166e8549bad95b05f66acd508d07a6cd97d3dc0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7166e8549bad95b05f66acd508d07a6cd97d3dc0", "html_url": "https://github.com/rust-lang/rust/commit/7166e8549bad95b05f66acd508d07a6cd97d3dc0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7166e8549bad95b05f66acd508d07a6cd97d3dc0/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3621eeb02652038a8185f60d78fb4791a732dc6", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3621eeb02652038a8185f60d78fb4791a732dc6", "html_url": "https://github.com/rust-lang/rust/commit/d3621eeb02652038a8185f60d78fb4791a732dc6"}], "stats": {"total": 614, "additions": 300, "deletions": 314}, "files": [{"sha": "c7702e09fcfa5c349ab1b5c477991e7f25232d3b", "filename": "crates/hir/src/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 23, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7166e8549bad95b05f66acd508d07a6cd97d3dc0/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7166e8549bad95b05f66acd508d07a6cd97d3dc0/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdiagnostics.rs?ref=7166e8549bad95b05f66acd508d07a6cd97d3dc0", "patch": "@@ -35,6 +35,7 @@ diagnostics![\n     InactiveCode,\n     MacroError,\n     MissingFields,\n+    NoSuchField,\n     UnimplementedBuiltinMacro,\n     UnresolvedExternCrate,\n     UnresolvedImport,\n@@ -92,31 +93,9 @@ pub struct UnimplementedBuiltinMacro {\n     pub node: InFile<SyntaxNodePtr>,\n }\n \n-// Diagnostic: no-such-field\n-//\n-// This diagnostic is triggered if created structure does not have field provided in record.\n #[derive(Debug)]\n pub struct NoSuchField {\n-    pub file: HirFileId,\n-    pub field: AstPtr<ast::RecordExprField>,\n-}\n-\n-impl Diagnostic for NoSuchField {\n-    fn code(&self) -> DiagnosticCode {\n-        DiagnosticCode(\"no-such-field\")\n-    }\n-\n-    fn message(&self) -> String {\n-        \"no such field\".to_string()\n-    }\n-\n-    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n-        InFile::new(self.file, self.field.clone().into())\n-    }\n-\n-    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n-        self\n-    }\n+    pub field: InFile<AstPtr<ast::RecordExprField>>,\n }\n \n // Diagnostic: break-outside-of-loop"}, {"sha": "7faf6ec1f152d9cf19f8c8f3458f0cadeb3208a3", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7166e8549bad95b05f66acd508d07a6cd97d3dc0/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7166e8549bad95b05f66acd508d07a6cd97d3dc0/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=7166e8549bad95b05f66acd508d07a6cd97d3dc0", "patch": "@@ -1077,7 +1077,7 @@ impl Function {\n             match d {\n                 hir_ty::InferenceDiagnostic::NoSuchField { expr } => {\n                     let field = source_map.field_syntax(*expr);\n-                    sink.push(NoSuchField { file: field.file_id, field: field.value })\n+                    acc.push(NoSuchField { field }.into())\n                 }\n                 hir_ty::InferenceDiagnostic::BreakOutsideOfLoop { expr } => {\n                     let ptr = source_map"}, {"sha": "caaa89e0a5a97ef8c2ad526d17000ef51c67b968", "filename": "crates/ide/src/diagnostics.rs", "status": "modified", "additions": 11, "deletions": 135, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/7166e8549bad95b05f66acd508d07a6cd97d3dc0/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7166e8549bad95b05f66acd508d07a6cd97d3dc0/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics.rs?ref=7166e8549bad95b05f66acd508d07a6cd97d3dc0", "patch": "@@ -4,15 +4,16 @@\n //! macro-expanded files, but we need to present them to the users in terms of\n //! original files. So we need to map the ranges.\n \n-mod unresolved_module;\n+mod inactive_code;\n+mod macro_error;\n+mod missing_fields;\n+mod no_such_field;\n+mod unimplemented_builtin_macro;\n mod unresolved_extern_crate;\n mod unresolved_import;\n mod unresolved_macro_call;\n+mod unresolved_module;\n mod unresolved_proc_macro;\n-mod unimplemented_builtin_macro;\n-mod macro_error;\n-mod inactive_code;\n-mod missing_fields;\n \n mod fixes;\n mod field_shorthand;\n@@ -161,9 +162,6 @@ pub(crate) fn diagnostics(\n         .on::<hir::diagnostics::MissingOkOrSomeInTailExpr, _>(|d| {\n             res.borrow_mut().push(diagnostic_with_fix(d, &sema, resolve));\n         })\n-        .on::<hir::diagnostics::NoSuchField, _>(|d| {\n-            res.borrow_mut().push(diagnostic_with_fix(d, &sema, resolve));\n-        })\n         .on::<hir::diagnostics::RemoveThisSemicolon, _>(|d| {\n             res.borrow_mut().push(diagnostic_with_fix(d, &sema, resolve));\n         })\n@@ -220,14 +218,15 @@ pub(crate) fn diagnostics(\n     for diag in diags {\n         #[rustfmt::skip]\n         let d = match diag {\n-            AnyDiagnostic::UnresolvedModule(d) => unresolved_module::unresolved_module(&ctx, &d),\n+            AnyDiagnostic::MacroError(d) => macro_error::macro_error(&ctx, &d),\n+            AnyDiagnostic::MissingFields(d) => missing_fields::missing_fields(&ctx, &d),\n+            AnyDiagnostic::NoSuchField(d) => no_such_field::no_such_field(&ctx, &d),\n+            AnyDiagnostic::UnimplementedBuiltinMacro(d) => unimplemented_builtin_macro::unimplemented_builtin_macro(&ctx, &d),\n             AnyDiagnostic::UnresolvedExternCrate(d) => unresolved_extern_crate::unresolved_extern_crate(&ctx, &d),\n             AnyDiagnostic::UnresolvedImport(d) => unresolved_import::unresolved_import(&ctx, &d),\n             AnyDiagnostic::UnresolvedMacroCall(d) => unresolved_macro_call::unresolved_macro_call(&ctx, &d),\n+            AnyDiagnostic::UnresolvedModule(d) => unresolved_module::unresolved_module(&ctx, &d),\n             AnyDiagnostic::UnresolvedProcMacro(d) => unresolved_proc_macro::unresolved_proc_macro(&ctx, &d),\n-            AnyDiagnostic::UnimplementedBuiltinMacro(d) => unimplemented_builtin_macro::unimplemented_builtin_macro(&ctx, &d),\n-            AnyDiagnostic::MissingFields(d) => missing_fields::missing_fields(&ctx, &d),\n-            AnyDiagnostic::MacroError(d) => macro_error::macro_error(&ctx, &d),\n \n             AnyDiagnostic::InactiveCode(d) => match inactive_code::inactive_code(&ctx, &d) {\n                 Some(it) => it,\n@@ -722,129 +721,6 @@ fn foo() { break; }\n         );\n     }\n \n-    #[test]\n-    fn no_such_field_diagnostics() {\n-        check_diagnostics(\n-            r#\"\n-struct S { foo: i32, bar: () }\n-impl S {\n-    fn new() -> S {\n-        S {\n-      //^ Missing structure fields:\n-      //|    - bar\n-            foo: 92,\n-            baz: 62,\n-          //^^^^^^^ no such field\n-        }\n-    }\n-}\n-\"#,\n-        );\n-    }\n-    #[test]\n-    fn no_such_field_with_feature_flag_diagnostics() {\n-        check_diagnostics(\n-            r#\"\n-//- /lib.rs crate:foo cfg:feature=foo\n-struct MyStruct {\n-    my_val: usize,\n-    #[cfg(feature = \"foo\")]\n-    bar: bool,\n-}\n-\n-impl MyStruct {\n-    #[cfg(feature = \"foo\")]\n-    pub(crate) fn new(my_val: usize, bar: bool) -> Self {\n-        Self { my_val, bar }\n-    }\n-    #[cfg(not(feature = \"foo\"))]\n-    pub(crate) fn new(my_val: usize, _bar: bool) -> Self {\n-        Self { my_val }\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn no_such_field_enum_with_feature_flag_diagnostics() {\n-        check_diagnostics(\n-            r#\"\n-//- /lib.rs crate:foo cfg:feature=foo\n-enum Foo {\n-    #[cfg(not(feature = \"foo\"))]\n-    Buz,\n-    #[cfg(feature = \"foo\")]\n-    Bar,\n-    Baz\n-}\n-\n-fn test_fn(f: Foo) {\n-    match f {\n-        Foo::Bar => {},\n-        Foo::Baz => {},\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn no_such_field_with_feature_flag_diagnostics_on_struct_lit() {\n-        check_diagnostics(\n-            r#\"\n-//- /lib.rs crate:foo cfg:feature=foo\n-struct S {\n-    #[cfg(feature = \"foo\")]\n-    foo: u32,\n-    #[cfg(not(feature = \"foo\"))]\n-    bar: u32,\n-}\n-\n-impl S {\n-    #[cfg(feature = \"foo\")]\n-    fn new(foo: u32) -> Self {\n-        Self { foo }\n-    }\n-    #[cfg(not(feature = \"foo\"))]\n-    fn new(bar: u32) -> Self {\n-        Self { bar }\n-    }\n-    fn new2(bar: u32) -> Self {\n-        #[cfg(feature = \"foo\")]\n-        { Self { foo: bar } }\n-        #[cfg(not(feature = \"foo\"))]\n-        { Self { bar } }\n-    }\n-    fn new2(val: u32) -> Self {\n-        Self {\n-            #[cfg(feature = \"foo\")]\n-            foo: val,\n-            #[cfg(not(feature = \"foo\"))]\n-            bar: val,\n-        }\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn no_such_field_with_type_macro() {\n-        check_diagnostics(\n-            r#\"\n-macro_rules! Type { () => { u32 }; }\n-struct Foo { bar: Type![] }\n-\n-impl Foo {\n-    fn new() -> Self {\n-        Foo { bar: 0 }\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n     #[test]\n     fn missing_unsafe_diagnostic_with_raw_ptr() {\n         check_diagnostics("}, {"sha": "8b137891791fe96927ad78e64b0aad7bded08bdc", "filename": "crates/ide/src/diagnostics/fixes/create_field.rs", "status": "modified", "additions": 0, "deletions": 155, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/7166e8549bad95b05f66acd508d07a6cd97d3dc0/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes%2Fcreate_field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7166e8549bad95b05f66acd508d07a6cd97d3dc0/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes%2Fcreate_field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes%2Fcreate_field.rs?ref=7166e8549bad95b05f66acd508d07a6cd97d3dc0", "patch": "@@ -1,156 +1 @@\n-use hir::{db::AstDatabase, diagnostics::NoSuchField, HasSource, HirDisplay, Semantics};\n-use ide_db::{base_db::FileId, source_change::SourceChange, RootDatabase};\n-use syntax::{\n-    ast::{self, edit::IndentLevel, make},\n-    AstNode,\n-};\n-use text_edit::TextEdit;\n \n-use crate::{\n-    diagnostics::{fix, DiagnosticWithFixes},\n-    Assist, AssistResolveStrategy,\n-};\n-impl DiagnosticWithFixes for NoSuchField {\n-    fn fixes(\n-        &self,\n-        sema: &Semantics<RootDatabase>,\n-        _resolve: &AssistResolveStrategy,\n-    ) -> Option<Vec<Assist>> {\n-        let root = sema.db.parse_or_expand(self.file)?;\n-        missing_record_expr_field_fixes(\n-            sema,\n-            self.file.original_file(sema.db),\n-            &self.field.to_node(&root),\n-        )\n-    }\n-}\n-\n-fn missing_record_expr_field_fixes(\n-    sema: &Semantics<RootDatabase>,\n-    usage_file_id: FileId,\n-    record_expr_field: &ast::RecordExprField,\n-) -> Option<Vec<Assist>> {\n-    let record_lit = ast::RecordExpr::cast(record_expr_field.syntax().parent()?.parent()?)?;\n-    let def_id = sema.resolve_variant(record_lit)?;\n-    let module;\n-    let def_file_id;\n-    let record_fields = match def_id {\n-        hir::VariantDef::Struct(s) => {\n-            module = s.module(sema.db);\n-            let source = s.source(sema.db)?;\n-            def_file_id = source.file_id;\n-            let fields = source.value.field_list()?;\n-            record_field_list(fields)?\n-        }\n-        hir::VariantDef::Union(u) => {\n-            module = u.module(sema.db);\n-            let source = u.source(sema.db)?;\n-            def_file_id = source.file_id;\n-            source.value.record_field_list()?\n-        }\n-        hir::VariantDef::Variant(e) => {\n-            module = e.module(sema.db);\n-            let source = e.source(sema.db)?;\n-            def_file_id = source.file_id;\n-            let fields = source.value.field_list()?;\n-            record_field_list(fields)?\n-        }\n-    };\n-    let def_file_id = def_file_id.original_file(sema.db);\n-\n-    let new_field_type = sema.type_of_expr(&record_expr_field.expr()?)?;\n-    if new_field_type.is_unknown() {\n-        return None;\n-    }\n-    let new_field = make::record_field(\n-        None,\n-        make::name(&record_expr_field.field_name()?.text()),\n-        make::ty(&new_field_type.display_source_code(sema.db, module.into()).ok()?),\n-    );\n-\n-    let last_field = record_fields.fields().last()?;\n-    let last_field_syntax = last_field.syntax();\n-    let indent = IndentLevel::from_node(last_field_syntax);\n-\n-    let mut new_field = new_field.to_string();\n-    if usage_file_id != def_file_id {\n-        new_field = format!(\"pub(crate) {}\", new_field);\n-    }\n-    new_field = format!(\"\\n{}{}\", indent, new_field);\n-\n-    let needs_comma = !last_field_syntax.to_string().ends_with(',');\n-    if needs_comma {\n-        new_field = format!(\",{}\", new_field);\n-    }\n-\n-    let source_change = SourceChange::from_text_edit(\n-        def_file_id,\n-        TextEdit::insert(last_field_syntax.text_range().end(), new_field),\n-    );\n-\n-    return Some(vec![fix(\n-        \"create_field\",\n-        \"Create field\",\n-        source_change,\n-        record_expr_field.syntax().text_range(),\n-    )]);\n-\n-    fn record_field_list(field_def_list: ast::FieldList) -> Option<ast::RecordFieldList> {\n-        match field_def_list {\n-            ast::FieldList::RecordFieldList(it) => Some(it),\n-            ast::FieldList::TupleFieldList(_) => None,\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use crate::diagnostics::tests::check_fix;\n-\n-    #[test]\n-    fn test_add_field_from_usage() {\n-        check_fix(\n-            r\"\n-fn main() {\n-    Foo { bar: 3, baz$0: false};\n-}\n-struct Foo {\n-    bar: i32\n-}\n-\",\n-            r\"\n-fn main() {\n-    Foo { bar: 3, baz: false};\n-}\n-struct Foo {\n-    bar: i32,\n-    baz: bool\n-}\n-\",\n-        )\n-    }\n-\n-    #[test]\n-    fn test_add_field_in_other_file_from_usage() {\n-        check_fix(\n-            r#\"\n-//- /main.rs\n-mod foo;\n-\n-fn main() {\n-    foo::Foo { bar: 3, $0baz: false};\n-}\n-//- /foo.rs\n-struct Foo {\n-    bar: i32\n-}\n-\"#,\n-            r#\"\n-struct Foo {\n-    bar: i32,\n-    pub(crate) baz: bool\n-}\n-\"#,\n-        )\n-    }\n-}"}, {"sha": "61962de28e8f072a0212e41b8d4f8d20a616f938", "filename": "crates/ide/src/diagnostics/no_such_field.rs", "status": "added", "additions": 286, "deletions": 0, "changes": 286, "blob_url": "https://github.com/rust-lang/rust/blob/7166e8549bad95b05f66acd508d07a6cd97d3dc0/crates%2Fide%2Fsrc%2Fdiagnostics%2Fno_such_field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7166e8549bad95b05f66acd508d07a6cd97d3dc0/crates%2Fide%2Fsrc%2Fdiagnostics%2Fno_such_field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Fno_such_field.rs?ref=7166e8549bad95b05f66acd508d07a6cd97d3dc0", "patch": "@@ -0,0 +1,286 @@\n+use hir::{db::AstDatabase, HasSource, HirDisplay, Semantics};\n+use ide_db::{base_db::FileId, source_change::SourceChange, RootDatabase};\n+use syntax::{\n+    ast::{self, edit::IndentLevel, make},\n+    AstNode,\n+};\n+use text_edit::TextEdit;\n+\n+use crate::{\n+    diagnostics::{fix, Diagnostic, DiagnosticsContext},\n+    Assist,\n+};\n+\n+// Diagnostic: no-such-field\n+//\n+// This diagnostic is triggered if created structure does not have field provided in record.\n+pub(super) fn no_such_field(ctx: &DiagnosticsContext<'_>, d: &hir::NoSuchField) -> Diagnostic {\n+    Diagnostic::new(\n+        \"no-such-field\",\n+        \"no such field\".to_string(),\n+        ctx.sema.diagnostics_display_range(d.field.clone().map(|it| it.into())).range,\n+    )\n+    .with_fixes(fixes(ctx, d))\n+}\n+\n+fn fixes(ctx: &DiagnosticsContext<'_>, d: &hir::NoSuchField) -> Option<Vec<Assist>> {\n+    let root = ctx.sema.db.parse_or_expand(d.field.file_id)?;\n+    missing_record_expr_field_fixes(\n+        &ctx.sema,\n+        d.field.file_id.original_file(ctx.sema.db),\n+        &d.field.value.to_node(&root),\n+    )\n+}\n+\n+fn missing_record_expr_field_fixes(\n+    sema: &Semantics<RootDatabase>,\n+    usage_file_id: FileId,\n+    record_expr_field: &ast::RecordExprField,\n+) -> Option<Vec<Assist>> {\n+    let record_lit = ast::RecordExpr::cast(record_expr_field.syntax().parent()?.parent()?)?;\n+    let def_id = sema.resolve_variant(record_lit)?;\n+    let module;\n+    let def_file_id;\n+    let record_fields = match def_id {\n+        hir::VariantDef::Struct(s) => {\n+            module = s.module(sema.db);\n+            let source = s.source(sema.db)?;\n+            def_file_id = source.file_id;\n+            let fields = source.value.field_list()?;\n+            record_field_list(fields)?\n+        }\n+        hir::VariantDef::Union(u) => {\n+            module = u.module(sema.db);\n+            let source = u.source(sema.db)?;\n+            def_file_id = source.file_id;\n+            source.value.record_field_list()?\n+        }\n+        hir::VariantDef::Variant(e) => {\n+            module = e.module(sema.db);\n+            let source = e.source(sema.db)?;\n+            def_file_id = source.file_id;\n+            let fields = source.value.field_list()?;\n+            record_field_list(fields)?\n+        }\n+    };\n+    let def_file_id = def_file_id.original_file(sema.db);\n+\n+    let new_field_type = sema.type_of_expr(&record_expr_field.expr()?)?;\n+    if new_field_type.is_unknown() {\n+        return None;\n+    }\n+    let new_field = make::record_field(\n+        None,\n+        make::name(&record_expr_field.field_name()?.text()),\n+        make::ty(&new_field_type.display_source_code(sema.db, module.into()).ok()?),\n+    );\n+\n+    let last_field = record_fields.fields().last()?;\n+    let last_field_syntax = last_field.syntax();\n+    let indent = IndentLevel::from_node(last_field_syntax);\n+\n+    let mut new_field = new_field.to_string();\n+    if usage_file_id != def_file_id {\n+        new_field = format!(\"pub(crate) {}\", new_field);\n+    }\n+    new_field = format!(\"\\n{}{}\", indent, new_field);\n+\n+    let needs_comma = !last_field_syntax.to_string().ends_with(',');\n+    if needs_comma {\n+        new_field = format!(\",{}\", new_field);\n+    }\n+\n+    let source_change = SourceChange::from_text_edit(\n+        def_file_id,\n+        TextEdit::insert(last_field_syntax.text_range().end(), new_field),\n+    );\n+\n+    return Some(vec![fix(\n+        \"create_field\",\n+        \"Create field\",\n+        source_change,\n+        record_expr_field.syntax().text_range(),\n+    )]);\n+\n+    fn record_field_list(field_def_list: ast::FieldList) -> Option<ast::RecordFieldList> {\n+        match field_def_list {\n+            ast::FieldList::RecordFieldList(it) => Some(it),\n+            ast::FieldList::TupleFieldList(_) => None,\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::diagnostics::tests::{check_diagnostics, check_fix};\n+\n+    #[test]\n+    fn no_such_field_diagnostics() {\n+        check_diagnostics(\n+            r#\"\n+struct S { foo: i32, bar: () }\n+impl S {\n+    fn new() -> S {\n+        S {\n+      //^ Missing structure fields:\n+      //|    - bar\n+            foo: 92,\n+            baz: 62,\n+          //^^^^^^^ no such field\n+        }\n+    }\n+}\n+\"#,\n+        );\n+    }\n+    #[test]\n+    fn no_such_field_with_feature_flag_diagnostics() {\n+        check_diagnostics(\n+            r#\"\n+//- /lib.rs crate:foo cfg:feature=foo\n+struct MyStruct {\n+    my_val: usize,\n+    #[cfg(feature = \"foo\")]\n+    bar: bool,\n+}\n+\n+impl MyStruct {\n+    #[cfg(feature = \"foo\")]\n+    pub(crate) fn new(my_val: usize, bar: bool) -> Self {\n+        Self { my_val, bar }\n+    }\n+    #[cfg(not(feature = \"foo\"))]\n+    pub(crate) fn new(my_val: usize, _bar: bool) -> Self {\n+        Self { my_val }\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_such_field_enum_with_feature_flag_diagnostics() {\n+        check_diagnostics(\n+            r#\"\n+//- /lib.rs crate:foo cfg:feature=foo\n+enum Foo {\n+    #[cfg(not(feature = \"foo\"))]\n+    Buz,\n+    #[cfg(feature = \"foo\")]\n+    Bar,\n+    Baz\n+}\n+\n+fn test_fn(f: Foo) {\n+    match f {\n+        Foo::Bar => {},\n+        Foo::Baz => {},\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_such_field_with_feature_flag_diagnostics_on_struct_lit() {\n+        check_diagnostics(\n+            r#\"\n+//- /lib.rs crate:foo cfg:feature=foo\n+struct S {\n+    #[cfg(feature = \"foo\")]\n+    foo: u32,\n+    #[cfg(not(feature = \"foo\"))]\n+    bar: u32,\n+}\n+\n+impl S {\n+    #[cfg(feature = \"foo\")]\n+    fn new(foo: u32) -> Self {\n+        Self { foo }\n+    }\n+    #[cfg(not(feature = \"foo\"))]\n+    fn new(bar: u32) -> Self {\n+        Self { bar }\n+    }\n+    fn new2(bar: u32) -> Self {\n+        #[cfg(feature = \"foo\")]\n+        { Self { foo: bar } }\n+        #[cfg(not(feature = \"foo\"))]\n+        { Self { bar } }\n+    }\n+    fn new2(val: u32) -> Self {\n+        Self {\n+            #[cfg(feature = \"foo\")]\n+            foo: val,\n+            #[cfg(not(feature = \"foo\"))]\n+            bar: val,\n+        }\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_such_field_with_type_macro() {\n+        check_diagnostics(\n+            r#\"\n+macro_rules! Type { () => { u32 }; }\n+struct Foo { bar: Type![] }\n+\n+impl Foo {\n+    fn new() -> Self {\n+        Foo { bar: 0 }\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_add_field_from_usage() {\n+        check_fix(\n+            r\"\n+fn main() {\n+    Foo { bar: 3, baz$0: false};\n+}\n+struct Foo {\n+    bar: i32\n+}\n+\",\n+            r\"\n+fn main() {\n+    Foo { bar: 3, baz: false};\n+}\n+struct Foo {\n+    bar: i32,\n+    baz: bool\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn test_add_field_in_other_file_from_usage() {\n+        check_fix(\n+            r#\"\n+//- /main.rs\n+mod foo;\n+\n+fn main() {\n+    foo::Foo { bar: 3, $0baz: false};\n+}\n+//- /foo.rs\n+struct Foo {\n+    bar: i32\n+}\n+\"#,\n+            r#\"\n+struct Foo {\n+    bar: i32,\n+    pub(crate) baz: bool\n+}\n+\"#,\n+        )\n+    }\n+}"}]}