{"sha": "0ed8ca45f4180ad26cc42e6181ec47f86553f91b", "node_id": "C_kwDOAAsO6NoAKDBlZDhjYTQ1ZjQxODBhZDI2Y2M0MmU2MTgxZWM0N2Y4NjU1M2Y5MWI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-30T22:00:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-30T22:00:36Z"}, "message": "Auto merge of #8322 - jubnzv:8282-single-match, r=llogiq\n\nsingle_match: Don't lint non-exhaustive matches; support tuples\n\n`single_match` lint:\n* Don't lint exhaustive enum patterns without a wild.\n  Rationale: The definition of the enum could be changed, so the user can get non-exhaustive match after applying the suggested lint (see https://github.com/rust-lang/rust-clippy/issues/8282#issuecomment-1013566068 for context).\n* Lint `match` constructions with tuples (as suggested at https://github.com/rust-lang/rust-clippy/issues/8282#issuecomment-1015621148)\n\nCloses #8282\n\n---\n\nchangelog: [`single_match`]: Don't lint exhaustive enum patterns without a wild.\nchangelog: [`single_match`]: Lint `match` constructions with tuples", "tree": {"sha": "c72033466aa40542751e94ff29db5a9e088b39c2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c72033466aa40542751e94ff29db5a9e088b39c2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0ed8ca45f4180ad26cc42e6181ec47f86553f91b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0ed8ca45f4180ad26cc42e6181ec47f86553f91b", "html_url": "https://github.com/rust-lang/rust/commit/0ed8ca45f4180ad26cc42e6181ec47f86553f91b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0ed8ca45f4180ad26cc42e6181ec47f86553f91b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ceffdee9bc8dc7b645cb1b91bec5df8a6716087", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ceffdee9bc8dc7b645cb1b91bec5df8a6716087", "html_url": "https://github.com/rust-lang/rust/commit/7ceffdee9bc8dc7b645cb1b91bec5df8a6716087"}, {"sha": "a8fdf5ca8aab08ba56678a4bce36f9da5ae8e52d", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8fdf5ca8aab08ba56678a4bce36f9da5ae8e52d", "html_url": "https://github.com/rust-lang/rust/commit/a8fdf5ca8aab08ba56678a4bce36f9da5ae8e52d"}], "stats": {"total": 289, "additions": 220, "deletions": 69}, "files": [{"sha": "e0cbadeb64550dc3ce5192a10f2f6cab17bee4bb", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 113, "deletions": 18, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/0ed8ca45f4180ad26cc42e6181ec47f86553f91b/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ed8ca45f4180ad26cc42e6181ec47f86553f91b/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=0ed8ca45f4180ad26cc42e6181ec47f86553f91b", "patch": "@@ -31,7 +31,7 @@ use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::{Span, Spanned};\n use rustc_span::{sym, symbol::kw};\n-use std::cmp::Ordering;\n+use std::cmp::{max, Ordering};\n use std::collections::hash_map::Entry;\n \n declare_clippy_lint! {\n@@ -830,12 +830,12 @@ fn report_single_match_single_pattern(\n     );\n }\n \n-fn check_single_match_opt_like(\n-    cx: &LateContext<'_>,\n+fn check_single_match_opt_like<'a>(\n+    cx: &LateContext<'a>,\n     ex: &Expr<'_>,\n     arms: &[Arm<'_>],\n     expr: &Expr<'_>,\n-    ty: Ty<'_>,\n+    ty: Ty<'a>,\n     els: Option<&Expr<'_>>,\n ) {\n     // list of candidate `Enum`s we know will never get any more members\n@@ -849,25 +849,120 @@ fn check_single_match_opt_like(\n         (&paths::RESULT, \"Ok\"),\n     ];\n \n-    let path = match arms[1].pat.kind {\n-        PatKind::TupleStruct(ref path, inner, _) => {\n-            // Contains any non wildcard patterns (e.g., `Err(err)`)?\n-            if !inner.iter().all(is_wild) {\n-                return;\n+    // We want to suggest to exclude an arm that contains only wildcards or forms the exhaustive\n+    // match with the second branch, without enum variants in matches.\n+    if !contains_only_wilds(arms[1].pat) && !form_exhaustive_matches(arms[0].pat, arms[1].pat) {\n+        return;\n+    }\n+\n+    let mut paths_and_types = Vec::new();\n+    if !collect_pat_paths(&mut paths_and_types, cx, arms[1].pat, ty) {\n+        return;\n+    }\n+\n+    let in_candidate_enum = |path_info: &(String, &TyS<'_>)| -> bool {\n+        let (path, ty) = path_info;\n+        for &(ty_path, pat_path) in candidates {\n+            if path == pat_path && match_type(cx, ty, ty_path) {\n+                return true;\n             }\n-            rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| s.print_qpath(path, false))\n+        }\n+        false\n+    };\n+    if paths_and_types.iter().all(in_candidate_enum) {\n+        report_single_match_single_pattern(cx, ex, arms, expr, els);\n+    }\n+}\n+\n+/// Collects paths and their types from the given patterns. Returns true if the given pattern could\n+/// be simplified, false otherwise.\n+fn collect_pat_paths<'a>(acc: &mut Vec<(String, Ty<'a>)>, cx: &LateContext<'a>, pat: &Pat<'_>, ty: Ty<'a>) -> bool {\n+    match pat.kind {\n+        PatKind::Wild => true,\n+        PatKind::Tuple(inner, _) => inner.iter().all(|p| {\n+            let p_ty = cx.typeck_results().pat_ty(p);\n+            collect_pat_paths(acc, cx, p, p_ty)\n+        }),\n+        PatKind::TupleStruct(ref path, ..) => {\n+            let path = rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| {\n+                s.print_qpath(path, false);\n+            });\n+            acc.push((path, ty));\n+            true\n+        },\n+        PatKind::Binding(BindingAnnotation::Unannotated, .., ident, None) => {\n+            acc.push((ident.to_string(), ty));\n+            true\n         },\n-        PatKind::Binding(BindingAnnotation::Unannotated, .., ident, None) => ident.to_string(),\n         PatKind::Path(ref path) => {\n-            rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| s.print_qpath(path, false))\n+            let path = rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| {\n+                s.print_qpath(path, false);\n+            });\n+            acc.push((path, ty));\n+            true\n         },\n-        _ => return,\n-    };\n+        _ => false,\n+    }\n+}\n \n-    for &(ty_path, pat_path) in candidates {\n-        if path == *pat_path && match_type(cx, ty, ty_path) {\n-            report_single_match_single_pattern(cx, ex, arms, expr, els);\n-        }\n+/// Returns true if the given arm of pattern matching contains wildcard patterns.\n+fn contains_only_wilds(pat: &Pat<'_>) -> bool {\n+    match pat.kind {\n+        PatKind::Wild => true,\n+        PatKind::Tuple(inner, _) | PatKind::TupleStruct(_, inner, ..) => inner.iter().all(contains_only_wilds),\n+        _ => false,\n+    }\n+}\n+\n+/// Returns true if the given patterns forms only exhaustive matches that don't contain enum\n+/// patterns without a wildcard.\n+fn form_exhaustive_matches(left: &Pat<'_>, right: &Pat<'_>) -> bool {\n+    match (&left.kind, &right.kind) {\n+        (PatKind::Wild, _) | (_, PatKind::Wild) => true,\n+        (PatKind::Tuple(left_in, left_pos), PatKind::Tuple(right_in, right_pos)) => {\n+            // We don't actually know the position and the presence of the `..` (dotdot) operator\n+            // in the arms, so we need to evaluate the correct offsets here in order to iterate in\n+            // both arms at the same time.\n+            let len = max(\n+                left_in.len() + {\n+                    if left_pos.is_some() { 1 } else { 0 }\n+                },\n+                right_in.len() + {\n+                    if right_pos.is_some() { 1 } else { 0 }\n+                },\n+            );\n+            let mut left_pos = left_pos.unwrap_or(usize::MAX);\n+            let mut right_pos = right_pos.unwrap_or(usize::MAX);\n+            let mut left_dot_space = 0;\n+            let mut right_dot_space = 0;\n+            for i in 0..len {\n+                let mut found_dotdot = false;\n+                if i == left_pos {\n+                    left_dot_space += 1;\n+                    if left_dot_space < len - left_in.len() {\n+                        left_pos += 1;\n+                    }\n+                    found_dotdot = true;\n+                }\n+                if i == right_pos {\n+                    right_dot_space += 1;\n+                    if right_dot_space < len - right_in.len() {\n+                        right_pos += 1;\n+                    }\n+                    found_dotdot = true;\n+                }\n+                if found_dotdot {\n+                    continue;\n+                }\n+                if !contains_only_wilds(&left_in[i - left_dot_space])\n+                    && !contains_only_wilds(&right_in[i - right_dot_space])\n+                {\n+                    return false;\n+                }\n+            }\n+            true\n+        },\n+        _ => false,\n     }\n }\n "}, {"sha": "bd371888046361ceea6c5ce3b9c866301df7e5a4", "filename": "tests/ui/single_match.rs", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/0ed8ca45f4180ad26cc42e6181ec47f86553f91b/tests%2Fui%2Fsingle_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ed8ca45f4180ad26cc42e6181ec47f86553f91b/tests%2Fui%2Fsingle_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle_match.rs?ref=0ed8ca45f4180ad26cc42e6181ec47f86553f91b", "patch": "@@ -145,6 +145,84 @@ fn if_suggestion() {\n     };\n }\n \n+// See: issue #8282\n+fn ranges() {\n+    enum E {\n+        V,\n+    }\n+    let x = (Some(E::V), Some(42));\n+\n+    // Don't lint, because the `E` enum can be extended with additional fields later. Thus, the\n+    // proposed replacement to `if let Some(E::V)` may hide non-exhaustive warnings that appeared\n+    // because of `match` construction.\n+    match x {\n+        (Some(E::V), _) => {},\n+        (None, _) => {},\n+    }\n+\n+    // lint\n+    match x {\n+        (Some(_), _) => {},\n+        (None, _) => {},\n+    }\n+\n+    // lint\n+    match x {\n+        (Some(E::V), _) => todo!(),\n+        (_, _) => {},\n+    }\n+\n+    // lint\n+    match (Some(42), Some(E::V), Some(42)) {\n+        (.., Some(E::V), _) => {},\n+        (..) => {},\n+    }\n+\n+    // Don't lint, see above.\n+    match (Some(E::V), Some(E::V), Some(E::V)) {\n+        (.., Some(E::V), _) => {},\n+        (.., None, _) => {},\n+    }\n+\n+    // Don't lint, see above.\n+    match (Some(E::V), Some(E::V), Some(E::V)) {\n+        (Some(E::V), ..) => {},\n+        (None, ..) => {},\n+    }\n+\n+    // Don't lint, see above.\n+    match (Some(E::V), Some(E::V), Some(E::V)) {\n+        (_, Some(E::V), ..) => {},\n+        (_, None, ..) => {},\n+    }\n+}\n+\n+fn skip_type_aliases() {\n+    enum OptionEx {\n+        Some(i32),\n+        None,\n+    }\n+    enum ResultEx {\n+        Err(i32),\n+        Ok(i32),\n+    }\n+\n+    use OptionEx::{None, Some};\n+    use ResultEx::{Err, Ok};\n+\n+    // don't lint\n+    match Err(42) {\n+        Ok(_) => dummy(),\n+        Err(_) => (),\n+    };\n+\n+    // don't lint\n+    match Some(1i32) {\n+        Some(_) => dummy(),\n+        None => (),\n+    };\n+}\n+\n macro_rules! single_match {\n     ($num:literal) => {\n         match $num {"}, {"sha": "318faf2571758a1c5c7b7069207c014f645c8f90", "filename": "tests/ui/single_match.stderr", "status": "modified", "additions": 28, "deletions": 10, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/0ed8ca45f4180ad26cc42e6181ec47f86553f91b/tests%2Fui%2Fsingle_match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0ed8ca45f4180ad26cc42e6181ec47f86553f91b/tests%2Fui%2Fsingle_match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle_match.stderr?ref=0ed8ca45f4180ad26cc42e6181ec47f86553f91b", "patch": "@@ -38,15 +38,6 @@ LL | |         _ => {},\n LL | |     };\n    | |_____^ help: try this: `if let (2..=3, 7..=9) = z { dummy() }`\n \n-error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n-  --> $DIR/single_match.rs:54:5\n-   |\n-LL | /     match x {\n-LL | |         Some(y) => dummy(),\n-LL | |         None => (),\n-LL | |     };\n-   | |_____^ help: try this: `if let Some(y) = x { dummy() }`\n-\n error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n   --> $DIR/single_match.rs:59:5\n    |\n@@ -128,5 +119,32 @@ LL | |         _ => (),\n LL | |     };\n    | |_____^ help: try this: `if let None = x { println!() }`\n \n-error: aborting due to 13 previous errors\n+error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n+  --> $DIR/single_match.rs:164:5\n+   |\n+LL | /     match x {\n+LL | |         (Some(_), _) => {},\n+LL | |         (None, _) => {},\n+LL | |     }\n+   | |_____^ help: try this: `if let (Some(_), _) = x {}`\n+\n+error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n+  --> $DIR/single_match.rs:170:5\n+   |\n+LL | /     match x {\n+LL | |         (Some(E::V), _) => todo!(),\n+LL | |         (_, _) => {},\n+LL | |     }\n+   | |_____^ help: try this: `if let (Some(E::V), _) = x { todo!() }`\n+\n+error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n+  --> $DIR/single_match.rs:176:5\n+   |\n+LL | /     match (Some(42), Some(E::V), Some(42)) {\n+LL | |         (.., Some(E::V), _) => {},\n+LL | |         (..) => {},\n+LL | |     }\n+   | |_____^ help: try this: `if let (.., Some(E::V), _) = (Some(42), Some(E::V), Some(42)) {}`\n+\n+error: aborting due to 15 previous errors\n "}, {"sha": "21ea704b62ab5c9134fcccdcda1d853a27af1c42", "filename": "tests/ui/single_match_else.stderr", "status": "modified", "additions": 1, "deletions": 41, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/0ed8ca45f4180ad26cc42e6181ec47f86553f91b/tests%2Fui%2Fsingle_match_else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0ed8ca45f4180ad26cc42e6181ec47f86553f91b/tests%2Fui%2Fsingle_match_else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle_match_else.stderr?ref=0ed8ca45f4180ad26cc42e6181ec47f86553f91b", "patch": "@@ -19,45 +19,5 @@ LL +         None\n LL +     }\n    |\n \n-error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n-  --> $DIR/single_match_else.rs:70:5\n-   |\n-LL | /     match Some(1) {\n-LL | |         Some(a) => println!(\"${:?}\", a),\n-LL | |         None => {\n-LL | |             println!(\"else block\");\n-LL | |             return\n-LL | |         },\n-LL | |     }\n-   | |_____^\n-   |\n-help: try this\n-   |\n-LL ~     if let Some(a) = Some(1) { println!(\"${:?}\", a) } else {\n-LL +         println!(\"else block\");\n-LL +         return\n-LL +     }\n-   |\n-\n-error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n-  --> $DIR/single_match_else.rs:79:5\n-   |\n-LL | /     match Some(1) {\n-LL | |         Some(a) => println!(\"${:?}\", a),\n-LL | |         None => {\n-LL | |             println!(\"else block\");\n-LL | |             return;\n-LL | |         },\n-LL | |     }\n-   | |_____^\n-   |\n-help: try this\n-   |\n-LL ~     if let Some(a) = Some(1) { println!(\"${:?}\", a) } else {\n-LL +         println!(\"else block\");\n-LL +         return;\n-LL +     }\n-   |\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to previous error\n "}]}