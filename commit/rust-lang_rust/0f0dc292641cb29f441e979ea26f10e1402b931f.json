{"sha": "0f0dc292641cb29f441e979ea26f10e1402b931f", "node_id": "C_kwDOAAsO6NoAKDBmMGRjMjkyNjQxY2IyOWY0NDFlOTc5ZWEyNmYxMGUxNDAyYjkzMWY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-08T01:08:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-08T01:08:26Z"}, "message": "Auto merge of #109971 - WaffleLapkin:yeet_ownership, r=Nilstrieb\n\nYeet `owning_ref`\n\nBased on the discussions from https://github.com/rust-lang/rust/pull/109948\n\nThis replaces `owning_ref` with a far simpler & safer abstraction.\n\nFixes #109974", "tree": {"sha": "b8a5a4288da1476c4fa7264b52f116bc5848a63f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b8a5a4288da1476c4fa7264b52f116bc5848a63f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f0dc292641cb29f441e979ea26f10e1402b931f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f0dc292641cb29f441e979ea26f10e1402b931f", "html_url": "https://github.com/rust-lang/rust/commit/0f0dc292641cb29f441e979ea26f10e1402b931f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f0dc292641cb29f441e979ea26f10e1402b931f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ba86600c9452508a0ab05cd4bdc9af4c96f7d4ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba86600c9452508a0ab05cd4bdc9af4c96f7d4ba", "html_url": "https://github.com/rust-lang/rust/commit/ba86600c9452508a0ab05cd4bdc9af4c96f7d4ba"}, {"sha": "fbe0591c6897216042a201795185bc0c0dac42c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/fbe0591c6897216042a201795185bc0c0dac42c1", "html_url": "https://github.com/rust-lang/rust/commit/fbe0591c6897216042a201795185bc0c0dac42c1"}], "stats": {"total": 2239, "additions": 227, "deletions": 2012}, "files": [{"sha": "3e3fcc08bd64470448001fbc19df6409ba19a3a8", "filename": "compiler/rustc_codegen_ssa/src/back/metadata.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0f0dc292641cb29f441e979ea26f10e1402b931f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f0dc292641cb29f441e979ea26f10e1402b931f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs?ref=0f0dc292641cb29f441e979ea26f10e1402b931f", "patch": "@@ -13,8 +13,7 @@ use object::{\n use snap::write::FrameEncoder;\n \n use rustc_data_structures::memmap::Mmap;\n-use rustc_data_structures::owning_ref::OwningRef;\n-use rustc_data_structures::rustc_erase_owner;\n+use rustc_data_structures::owned_slice::try_slice_owned;\n use rustc_data_structures::sync::MetadataRef;\n use rustc_metadata::fs::METADATA_FILENAME;\n use rustc_metadata::EncodedMetadata;\n@@ -42,10 +41,10 @@ fn load_metadata_with(\n ) -> Result<MetadataRef, String> {\n     let file =\n         File::open(path).map_err(|e| format!(\"failed to open file '{}': {}\", path.display(), e))?;\n-    let data = unsafe { Mmap::map(file) }\n-        .map_err(|e| format!(\"failed to mmap file '{}': {}\", path.display(), e))?;\n-    let metadata = OwningRef::new(data).try_map(f)?;\n-    return Ok(rustc_erase_owner!(metadata.map_owner_box()));\n+\n+    unsafe { Mmap::map(file) }\n+        .map_err(|e| format!(\"failed to mmap file '{}': {}\", path.display(), e))\n+        .and_then(|mmap| try_slice_owned(mmap, |mmap| f(mmap)))\n }\n \n impl MetadataLoader for DefaultMetadataLoader {"}, {"sha": "e373bd18402a8b7d960076ef17b598c8749a6fb8", "filename": "compiler/rustc_data_structures/src/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f0dc292641cb29f441e979ea26f10e1402b931f/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f0dc292641cb29f441e979ea26f10e1402b931f/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs?ref=0f0dc292641cb29f441e979ea26f10e1402b931f", "patch": "@@ -1,5 +1,5 @@\n //! Various data structures used by the Rust compiler. The intention\n-//! is that code in here should be not be *specific* to rustc, so that\n+//! is that code in here should not be *specific* to rustc, so that\n //! it can be easily unit tested and so forth.\n //!\n //! # Note\n@@ -27,6 +27,8 @@\n #![feature(thread_id_value)]\n #![feature(vec_into_raw_parts)]\n #![feature(get_mut_unchecked)]\n+#![feature(lint_reasons)]\n+#![feature(unwrap_infallible)]\n #![allow(rustc::default_hash_types)]\n #![allow(rustc::potential_query_instability)]\n #![deny(rustc::untranslatable_diagnostic)]\n@@ -59,7 +61,6 @@ pub mod intern;\n pub mod jobserver;\n pub mod macros;\n pub mod obligation_forest;\n-pub mod owning_ref;\n pub mod sip128;\n pub mod small_c_str;\n pub mod small_str;\n@@ -82,6 +83,7 @@ pub mod vec_linked_list;\n pub mod work_queue;\n pub use atomic_ref::AtomicRef;\n pub mod frozen;\n+pub mod owned_slice;\n pub mod sso;\n pub mod steal;\n pub mod tagged_ptr;"}, {"sha": "1556873f59765c0cac66770a826877e03cfd03d7", "filename": "compiler/rustc_data_structures/src/memmap.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0f0dc292641cb29f441e979ea26f10e1402b931f/compiler%2Frustc_data_structures%2Fsrc%2Fmemmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f0dc292641cb29f441e979ea26f10e1402b931f/compiler%2Frustc_data_structures%2Fsrc%2Fmemmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fmemmap.rs?ref=0f0dc292641cb29f441e979ea26f10e1402b931f", "patch": "@@ -2,9 +2,7 @@ use std::fs::File;\n use std::io;\n use std::ops::{Deref, DerefMut};\n \n-use crate::owning_ref::StableAddress;\n-\n-/// A trivial wrapper for [`memmap2::Mmap`] that implements [`StableAddress`].\n+/// A trivial wrapper for [`memmap2::Mmap`] (or `Vec<u8>` on WASM).\n #[cfg(not(target_arch = \"wasm32\"))]\n pub struct Mmap(memmap2::Mmap);\n \n@@ -46,12 +44,6 @@ impl AsRef<[u8]> for Mmap {\n     }\n }\n \n-// SAFETY: On architectures other than WASM, mmap is used as backing storage. The address of this\n-// memory map is stable. On WASM, `Vec<u8>` is used as backing storage. The `Mmap` type doesn't\n-// export any function that can cause the `Vec` to be re-allocated. As such the address of the\n-// bytes inside this `Vec` is stable.\n-unsafe impl StableAddress for Mmap {}\n-\n #[cfg(not(target_arch = \"wasm32\"))]\n pub struct MmapMut(memmap2::MmapMut);\n "}, {"sha": "048401f66c27e327c62f464cdf8cf7cd18ff027f", "filename": "compiler/rustc_data_structures/src/owned_slice.rs", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/0f0dc292641cb29f441e979ea26f10e1402b931f/compiler%2Frustc_data_structures%2Fsrc%2Fowned_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f0dc292641cb29f441e979ea26f10e1402b931f/compiler%2Frustc_data_structures%2Fsrc%2Fowned_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fowned_slice.rs?ref=0f0dc292641cb29f441e979ea26f10e1402b931f", "patch": "@@ -0,0 +1,118 @@\n+use std::{borrow::Borrow, ops::Deref};\n+\n+// Use our fake Send/Sync traits when on not parallel compiler,\n+// so that `OwnedSlice` only implements/requires Send/Sync\n+// for parallel compiler builds.\n+use crate::sync::{Send, Sync};\n+\n+/// An owned slice.\n+///\n+/// This is similar to `Box<[u8]>` but allows slicing and using anything as the\n+/// backing buffer.\n+///\n+/// See [`slice_owned`] for `OwnedSlice` construction and examples.\n+///\n+/// ---------------------------------------------------------------------------\n+///\n+/// This is essentially a replacement for `owning_ref` which is a lot simpler\n+/// and even sound! \ud83c\udf38\n+pub struct OwnedSlice {\n+    /// This is conceptually a `&'self.owner [u8]`.\n+    bytes: *const [u8],\n+\n+    // +---------------------------------------+\n+    // | We expect `dead_code` lint here,      |\n+    // | because we don't want to accidentally |\n+    // | touch the owner \u2014 otherwise the owner |\n+    // | could invalidate out `bytes` pointer  |\n+    // |                                       |\n+    // | so be quiet                           |\n+    // +----+  +-------------------------------+\n+    //       \\/\n+    //      \u2282(\u00b4\uff65\u25e1\uff65\u2282 )\u2218\u02da\u02f3\u00b0 (I am the phantom remnant of #97770)\n+    #[expect(dead_code)]\n+    owner: Box<dyn Send + Sync>,\n+}\n+\n+/// Makes an [`OwnedSlice`] out of an `owner` and a `slicer` function.\n+///\n+/// ## Examples\n+///\n+/// ```rust\n+/// # use rustc_data_structures::owned_slice::{OwnedSlice, slice_owned};\n+/// let vec = vec![1, 2, 3, 4];\n+///\n+/// // Identical to slicing via `&v[1..3]` but produces an owned slice\n+/// let slice: OwnedSlice = slice_owned(vec, |v| &v[1..3]);\n+/// assert_eq!(&*slice, [2, 3]);\n+/// ```\n+///\n+/// ```rust\n+/// # use rustc_data_structures::owned_slice::{OwnedSlice, slice_owned};\n+/// # use std::ops::Deref;\n+/// let vec = vec![1, 2, 3, 4];\n+///\n+/// // Identical to slicing via `&v[..]` but produces an owned slice\n+/// let slice: OwnedSlice = slice_owned(vec, Deref::deref);\n+/// assert_eq!(&*slice, [1, 2, 3, 4]);\n+/// ```\n+pub fn slice_owned<O, F>(owner: O, slicer: F) -> OwnedSlice\n+where\n+    O: Send + Sync + 'static,\n+    F: FnOnce(&O) -> &[u8],\n+{\n+    try_slice_owned(owner, |x| Ok::<_, !>(slicer(x))).into_ok()\n+}\n+\n+/// Makes an [`OwnedSlice`] out of an `owner` and a `slicer` function that can fail.\n+///\n+/// See [`slice_owned`] for the infallible version.\n+pub fn try_slice_owned<O, F, E>(owner: O, slicer: F) -> Result<OwnedSlice, E>\n+where\n+    O: Send + Sync + 'static,\n+    F: FnOnce(&O) -> Result<&[u8], E>,\n+{\n+    // We box the owner of the bytes, so it doesn't move.\n+    //\n+    // Since the owner does not move and we don't access it in any way\n+    // before drop, there is nothing that can invalidate the bytes pointer.\n+    //\n+    // Thus, \"extending\" the lifetime of the reference returned from `F` is fine.\n+    // We pretend that we pass it a reference that lives as long as the returned slice.\n+    //\n+    // N.B. the HRTB on the `slicer` is important \u2014 without it the caller could provide\n+    // a short lived slice, unrelated to the owner.\n+\n+    let owner = Box::new(owner);\n+    let bytes = slicer(&*owner)?;\n+\n+    Ok(OwnedSlice { bytes, owner })\n+}\n+\n+impl Deref for OwnedSlice {\n+    type Target = [u8];\n+\n+    #[inline]\n+    fn deref(&self) -> &[u8] {\n+        // Safety:\n+        // `self.bytes` is valid per the construction in `slice_owned`\n+        // (which is the only constructor)\n+        unsafe { &*self.bytes }\n+    }\n+}\n+\n+impl Borrow<[u8]> for OwnedSlice {\n+    #[inline]\n+    fn borrow(&self) -> &[u8] {\n+        self\n+    }\n+}\n+\n+// Safety: `OwnedSlice` is conceptually `(&'self.1 [u8], Box<dyn Send + Sync>)`, which is `Send`\n+unsafe impl Send for OwnedSlice {}\n+\n+// Safety: `OwnedSlice` is conceptually `(&'self.1 [u8], Box<dyn Send + Sync>)`, which is `Sync`\n+unsafe impl Sync for OwnedSlice {}\n+\n+#[cfg(test)]\n+mod tests;"}, {"sha": "e715fb55362dd7b66789296e831d275668952bfa", "filename": "compiler/rustc_data_structures/src/owned_slice/tests.rs", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/0f0dc292641cb29f441e979ea26f10e1402b931f/compiler%2Frustc_data_structures%2Fsrc%2Fowned_slice%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f0dc292641cb29f441e979ea26f10e1402b931f/compiler%2Frustc_data_structures%2Fsrc%2Fowned_slice%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fowned_slice%2Ftests.rs?ref=0f0dc292641cb29f441e979ea26f10e1402b931f", "patch": "@@ -0,0 +1,74 @@\n+use std::{\n+    ops::Deref,\n+    sync::{\n+        atomic::{self, AtomicBool},\n+        Arc,\n+    },\n+};\n+\n+use crate::{\n+    owned_slice::{slice_owned, try_slice_owned, OwnedSlice},\n+    OnDrop,\n+};\n+\n+#[test]\n+fn smoke() {\n+    let slice = slice_owned(vec![1, 2, 3, 4, 5, 6], Vec::as_slice);\n+\n+    assert_eq!(&*slice, [1, 2, 3, 4, 5, 6]);\n+}\n+\n+#[test]\n+fn static_storage() {\n+    let slice = slice_owned(Box::new(String::from(\"what\")), |_| b\"bytes boo\");\n+\n+    assert_eq!(&*slice, b\"bytes boo\");\n+}\n+\n+#[test]\n+fn slice_the_slice() {\n+    let slice = slice_owned(vec![1, 2, 3, 4, 5, 6], Vec::as_slice);\n+    let slice = slice_owned(slice, |s| &s[1..][..4]);\n+    let slice = slice_owned(slice, |s| s);\n+    let slice = slice_owned(slice, |s| &s[1..]);\n+\n+    assert_eq!(&*slice, &[1, 2, 3, 4, 5, 6][1..][..4][1..]);\n+}\n+\n+#[test]\n+fn try_and_fail() {\n+    let res = try_slice_owned(vec![0], |v| v.get(12..).ok_or(()));\n+\n+    assert!(res.is_err());\n+}\n+\n+#[test]\n+fn boxed() {\n+    // It's important that we don't cause UB because of `Box`'es uniqueness\n+\n+    let boxed: Box<[u8]> = vec![1, 1, 2, 3, 5, 8, 13, 21].into_boxed_slice();\n+    let slice = slice_owned(boxed, Deref::deref);\n+\n+    assert_eq!(&*slice, [1, 1, 2, 3, 5, 8, 13, 21]);\n+}\n+\n+#[test]\n+fn drop_drops() {\n+    let flag = Arc::new(AtomicBool::new(false));\n+    let flag_prime = Arc::clone(&flag);\n+    let d = OnDrop(move || flag_prime.store(true, atomic::Ordering::Relaxed));\n+\n+    let slice = slice_owned(d, |_| &[]);\n+\n+    assert_eq!(flag.load(atomic::Ordering::Relaxed), false);\n+\n+    drop(slice);\n+\n+    assert_eq!(flag.load(atomic::Ordering::Relaxed), true);\n+}\n+\n+#[test]\n+fn send_sync() {\n+    crate::sync::assert_send::<OwnedSlice>();\n+    crate::sync::assert_sync::<OwnedSlice>();\n+}"}, {"sha": "dff72d1e43251989d52b6bec53c8588f7f4df47b", "filename": "compiler/rustc_data_structures/src/owning_ref/LICENSE", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ba86600c9452508a0ab05cd4bdc9af4c96f7d4ba/compiler%2Frustc_data_structures%2Fsrc%2Fowning_ref%2FLICENSE", "raw_url": "https://github.com/rust-lang/rust/raw/ba86600c9452508a0ab05cd4bdc9af4c96f7d4ba/compiler%2Frustc_data_structures%2Fsrc%2Fowning_ref%2FLICENSE", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fowning_ref%2FLICENSE?ref=ba86600c9452508a0ab05cd4bdc9af4c96f7d4ba", "patch": "@@ -1,21 +0,0 @@\n-The MIT License (MIT)\n-\n-Copyright (c) 2015 Marvin L\u00f6bel\n-\n-Permission is hereby granted, free of charge, to any person obtaining a copy\n-of this software and associated documentation files (the \"Software\"), to deal\n-in the Software without restriction, including without limitation the rights\n-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n-copies of the Software, and to permit persons to whom the Software is\n-furnished to do so, subject to the following conditions:\n-\n-The above copyright notice and this permission notice shall be included in all\n-copies or substantial portions of the Software.\n-\n-THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n-SOFTWARE."}, {"sha": "d1d92b905b82e0b9da4db953f10c263d8bce4838", "filename": "compiler/rustc_data_structures/src/owning_ref/mod.rs", "status": "removed", "additions": 0, "deletions": 1211, "changes": 1211, "blob_url": "https://github.com/rust-lang/rust/blob/ba86600c9452508a0ab05cd4bdc9af4c96f7d4ba/compiler%2Frustc_data_structures%2Fsrc%2Fowning_ref%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba86600c9452508a0ab05cd4bdc9af4c96f7d4ba/compiler%2Frustc_data_structures%2Fsrc%2Fowning_ref%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fowning_ref%2Fmod.rs?ref=ba86600c9452508a0ab05cd4bdc9af4c96f7d4ba", "patch": "@@ -1,1211 +0,0 @@\n-#![warn(missing_docs)]\n-\n-/*!\n-# An owning reference.\n-\n-This crate provides the _owning reference_ types `OwningRef` and `OwningRefMut`\n-that enables it to bundle a reference together with the owner of the data it points to.\n-This allows moving and dropping of an `OwningRef` without needing to recreate the reference.\n-\n-This can sometimes be useful because Rust borrowing rules normally prevent\n-moving a type that has been moved from. For example, this kind of code gets rejected:\n-\n-```compile_fail,E0515\n-fn return_owned_and_referenced<'a>() -> (Vec<u8>, &'a [u8]) {\n-    let v = vec![1, 2, 3, 4];\n-    let s = &v[1..3];\n-    (v, s)\n-}\n-```\n-\n-Even though, from a memory-layout point of view, this can be entirely safe\n-if the new location of the vector still lives longer than the lifetime `'a`\n-of the reference because the backing allocation of the vector does not change.\n-\n-This library enables this safe usage by keeping the owner and the reference\n-bundled together in a wrapper type that ensure that lifetime constraint:\n-\n-```\n-# use rustc_data_structures::owning_ref::OwningRef;\n-# fn main() {\n-fn return_owned_and_referenced() -> OwningRef<Vec<u8>, [u8]> {\n-    let v = vec![1, 2, 3, 4];\n-    let or = OwningRef::new(v);\n-    let or = or.map(|v| &v[1..3]);\n-    or\n-}\n-# }\n-```\n-\n-It works by requiring owner types to dereference to stable memory locations\n-and preventing mutable access to root containers, which in practice requires heap allocation\n-as provided by `Box<T>`, `Rc<T>`, etc.\n-\n-Also provided are typedefs for common owner type combinations,\n-which allow for less verbose type signatures.\n-For example, `BoxRef<T>` instead of `OwningRef<Box<T>, T>`.\n-\n-The crate also provides the more advanced `OwningHandle` type,\n-which allows more freedom in bundling a dependent handle object\n-along with the data it depends on, at the cost of some unsafe needed in the API.\n-See the documentation around `OwningHandle` for more details.\n-\n-# Examples\n-\n-## Basics\n-\n-```\n-use rustc_data_structures::owning_ref::BoxRef;\n-\n-fn main() {\n-    // Create an array owned by a Box.\n-    let arr = Box::new([1, 2, 3, 4]) as Box<[i32]>;\n-\n-    // Transfer into a BoxRef.\n-    let arr: BoxRef<[i32]> = BoxRef::new(arr);\n-    assert_eq!(&*arr, &[1, 2, 3, 4]);\n-\n-    // We can slice the array without losing ownership or changing type.\n-    let arr: BoxRef<[i32]> = arr.map(|arr| &arr[1..3]);\n-    assert_eq!(&*arr, &[2, 3]);\n-\n-    // Also works for Arc, Rc, String and Vec!\n-}\n-```\n-\n-## Caching a reference to a struct field\n-\n-```\n-use rustc_data_structures::owning_ref::BoxRef;\n-\n-fn main() {\n-    struct Foo {\n-        tag: u32,\n-        x: u16,\n-        y: u16,\n-        z: u16,\n-    }\n-    let foo = Foo { tag: 1, x: 100, y: 200, z: 300 };\n-\n-    let or = BoxRef::new(Box::new(foo)).map(|foo| {\n-        match foo.tag {\n-            0 => &foo.x,\n-            1 => &foo.y,\n-            2 => &foo.z,\n-            _ => panic!(),\n-        }\n-    });\n-\n-    assert_eq!(*or, 200);\n-}\n-```\n-\n-## Caching a reference to an entry in a vector\n-\n-```\n-use rustc_data_structures::owning_ref::VecRef;\n-\n-fn main() {\n-    let v = VecRef::new(vec![1, 2, 3, 4, 5]).map(|v| &v[3]);\n-    assert_eq!(*v, 4);\n-}\n-```\n-\n-## Caching a subslice of a String\n-\n-```\n-use rustc_data_structures::owning_ref::StringRef;\n-\n-fn main() {\n-    let s = StringRef::new(\"hello world\".to_owned())\n-        .map(|s| s.split(' ').nth(1).unwrap());\n-\n-    assert_eq!(&*s, \"world\");\n-}\n-```\n-\n-## Reference counted slices that share ownership of the backing storage\n-\n-```\n-use rustc_data_structures::owning_ref::RcRef;\n-use std::rc::Rc;\n-\n-fn main() {\n-    let rc: RcRef<[i32]> = RcRef::new(Rc::new([1, 2, 3, 4]) as Rc<[i32]>);\n-    assert_eq!(&*rc, &[1, 2, 3, 4]);\n-\n-    let rc_a: RcRef<[i32]> = rc.clone().map(|s| &s[0..2]);\n-    let rc_b = rc.clone().map(|s| &s[1..3]);\n-    let rc_c = rc.clone().map(|s| &s[2..4]);\n-    assert_eq!(&*rc_a, &[1, 2]);\n-    assert_eq!(&*rc_b, &[2, 3]);\n-    assert_eq!(&*rc_c, &[3, 4]);\n-\n-    let rc_c_a = rc_c.clone().map(|s| &s[1]);\n-    assert_eq!(&*rc_c_a, &4);\n-}\n-```\n-\n-## Atomic reference counted slices that share ownership of the backing storage\n-\n-```\n-use rustc_data_structures::owning_ref::ArcRef;\n-use std::sync::Arc;\n-\n-fn main() {\n-    use std::thread;\n-\n-    fn par_sum(rc: ArcRef<[i32]>) -> i32 {\n-        if rc.len() == 0 {\n-            return 0;\n-        } else if rc.len() == 1 {\n-            return rc[0];\n-        }\n-        let mid = rc.len() / 2;\n-        let left = rc.clone().map(|s| &s[..mid]);\n-        let right = rc.map(|s| &s[mid..]);\n-\n-        let left = thread::spawn(move || par_sum(left));\n-        let right = thread::spawn(move || par_sum(right));\n-\n-        left.join().unwrap() + right.join().unwrap()\n-    }\n-\n-    let rc: Arc<[i32]> = Arc::new([1, 2, 3, 4]);\n-    let rc: ArcRef<[i32]> = rc.into();\n-\n-    assert_eq!(par_sum(rc), 10);\n-}\n-```\n-\n-## References into RAII locks\n-\n-```\n-use rustc_data_structures::owning_ref::RefRef;\n-use std::cell::{RefCell, Ref};\n-\n-fn main() {\n-    let refcell = RefCell::new((1, 2, 3, 4));\n-    // Also works with Mutex and RwLock\n-\n-    let refref = {\n-        let refref = RefRef::new(refcell.borrow()).map(|x| &x.3);\n-        assert_eq!(*refref, 4);\n-\n-        // We move the RAII lock and the reference to one of\n-        // the subfields in the data it guards here:\n-        refref\n-    };\n-\n-    assert_eq!(*refref, 4);\n-\n-    drop(refref);\n-\n-    assert_eq!(*refcell.borrow(), (1, 2, 3, 4));\n-}\n-```\n-\n-## Mutable reference\n-\n-When the owned container implements `DerefMut`, it is also possible to make\n-a _mutable owning reference_. (e.g., with `Box`, `RefMut`, `MutexGuard`)\n-\n-```\n-use rustc_data_structures::owning_ref::RefMutRefMut;\n-use std::cell::{RefCell, RefMut};\n-\n-fn main() {\n-    let refcell = RefCell::new((1, 2, 3, 4));\n-\n-    let mut refmut_refmut = {\n-        let mut refmut_refmut = RefMutRefMut::new(refcell.borrow_mut()).map_mut(|x| &mut x.3);\n-        assert_eq!(*refmut_refmut, 4);\n-        *refmut_refmut *= 2;\n-\n-        refmut_refmut\n-    };\n-\n-    assert_eq!(*refmut_refmut, 8);\n-    *refmut_refmut *= 2;\n-\n-    drop(refmut_refmut);\n-\n-    assert_eq!(*refcell.borrow(), (1, 2, 3, 16));\n-}\n-```\n-*/\n-\n-pub use stable_deref_trait::{\n-    CloneStableDeref as CloneStableAddress, StableDeref as StableAddress,\n-};\n-use std::mem;\n-\n-/// An owning reference.\n-///\n-/// This wraps an owner `O` and a reference `&T` pointing\n-/// at something reachable from `O::Target` while keeping\n-/// the ability to move `self` around.\n-///\n-/// The owner is usually a pointer that points at some base type.\n-///\n-/// For more details and examples, see the module and method docs.\n-pub struct OwningRef<O, T: ?Sized> {\n-    owner: O,\n-    reference: *const T,\n-}\n-\n-/// An mutable owning reference.\n-///\n-/// This wraps an owner `O` and a reference `&mut T` pointing\n-/// at something reachable from `O::Target` while keeping\n-/// the ability to move `self` around.\n-///\n-/// The owner is usually a pointer that points at some base type.\n-///\n-/// For more details and examples, see the module and method docs.\n-pub struct OwningRefMut<O, T: ?Sized> {\n-    owner: O,\n-    reference: *mut T,\n-}\n-\n-/// Helper trait for an erased concrete type an owner dereferences to.\n-/// This is used in form of a trait object for keeping\n-/// something around to (virtually) call the destructor.\n-pub trait Erased {}\n-impl<T> Erased for T {}\n-\n-/// Helper trait for erasing the concrete type of what an owner dereferences to,\n-/// for example `Box<T> -> Box<Erased>`. This would be unneeded with\n-/// higher kinded types support in the language.\n-#[allow(unused_lifetimes)]\n-pub unsafe trait IntoErased<'a> {\n-    /// Owner with the dereference type substituted to `Erased`.\n-    type Erased;\n-    /// Performs the type erasure.\n-    fn into_erased(self) -> Self::Erased;\n-}\n-\n-/// Helper trait for erasing the concrete type of what an owner dereferences to,\n-/// for example `Box<T> -> Box<Erased + Send>`. This would be unneeded with\n-/// higher kinded types support in the language.\n-#[allow(unused_lifetimes)]\n-pub unsafe trait IntoErasedSend<'a> {\n-    /// Owner with the dereference type substituted to `Erased + Send`.\n-    type Erased: Send;\n-    /// Performs the type erasure.\n-    fn into_erased_send(self) -> Self::Erased;\n-}\n-\n-/// Helper trait for erasing the concrete type of what an owner dereferences to,\n-/// for example `Box<T> -> Box<Erased + Send + Sync>`. This would be unneeded with\n-/// higher kinded types support in the language.\n-#[allow(unused_lifetimes)]\n-pub unsafe trait IntoErasedSendSync<'a> {\n-    /// Owner with the dereference type substituted to `Erased + Send + Sync`.\n-    type Erased: Send + Sync;\n-    /// Performs the type erasure.\n-    fn into_erased_send_sync(self) -> Self::Erased;\n-}\n-\n-/////////////////////////////////////////////////////////////////////////////\n-// OwningRef\n-/////////////////////////////////////////////////////////////////////////////\n-\n-impl<O, T: ?Sized> OwningRef<O, T> {\n-    /// Creates a new owning reference from an owner\n-    /// initialized to the direct dereference of it.\n-    ///\n-    /// # Example\n-    /// ```\n-    /// use rustc_data_structures::owning_ref::OwningRef;\n-    ///\n-    /// fn main() {\n-    ///     let owning_ref = OwningRef::new(Box::new(42));\n-    ///     assert_eq!(*owning_ref, 42);\n-    /// }\n-    /// ```\n-    pub fn new(o: O) -> Self\n-    where\n-        O: StableAddress,\n-        O: Deref<Target = T>,\n-    {\n-        OwningRef { reference: &*o, owner: o }\n-    }\n-\n-    /// Like `new`, but doesn\u2019t require `O` to implement the `StableAddress` trait.\n-    /// Instead, the caller is responsible to make the same promises as implementing the trait.\n-    ///\n-    /// This is useful for cases where coherence rules prevents implementing the trait\n-    /// without adding a dependency to this crate in a third-party library.\n-    pub unsafe fn new_assert_stable_address(o: O) -> Self\n-    where\n-        O: Deref<Target = T>,\n-    {\n-        OwningRef { reference: &*o, owner: o }\n-    }\n-\n-    /// Converts `self` into a new owning reference that points at something reachable\n-    /// from the previous one.\n-    ///\n-    /// This can be a reference to a field of `U`, something reachable from a field of\n-    /// `U`, or even something unrelated with a `'static` lifetime.\n-    ///\n-    /// # Example\n-    /// ```\n-    /// use rustc_data_structures::owning_ref::OwningRef;\n-    ///\n-    /// fn main() {\n-    ///     let owning_ref = OwningRef::new(Box::new([1, 2, 3, 4]));\n-    ///\n-    ///     // create an owning reference that points at the\n-    ///     // third element of the array.\n-    ///     let owning_ref = owning_ref.map(|array| &array[2]);\n-    ///     assert_eq!(*owning_ref, 3);\n-    /// }\n-    /// ```\n-    pub fn map<F, U: ?Sized>(self, f: F) -> OwningRef<O, U>\n-    where\n-        O: StableAddress,\n-        F: FnOnce(&T) -> &U,\n-    {\n-        OwningRef { reference: f(&self), owner: self.owner }\n-    }\n-\n-    /// Tries to convert `self` into a new owning reference that points\n-    /// at something reachable from the previous one.\n-    ///\n-    /// This can be a reference to a field of `U`, something reachable from a field of\n-    /// `U`, or even something unrelated with a `'static` lifetime.\n-    ///\n-    /// # Example\n-    /// ```\n-    /// use rustc_data_structures::owning_ref::OwningRef;\n-    ///\n-    /// fn main() {\n-    ///     let owning_ref = OwningRef::new(Box::new([1, 2, 3, 4]));\n-    ///\n-    ///     // create an owning reference that points at the\n-    ///     // third element of the array.\n-    ///     let owning_ref = owning_ref.try_map(|array| {\n-    ///         if array[2] == 3 { Ok(&array[2]) } else { Err(()) }\n-    ///     });\n-    ///     assert_eq!(*owning_ref.unwrap(), 3);\n-    /// }\n-    /// ```\n-    pub fn try_map<F, U: ?Sized, E>(self, f: F) -> Result<OwningRef<O, U>, E>\n-    where\n-        O: StableAddress,\n-        F: FnOnce(&T) -> Result<&U, E>,\n-    {\n-        Ok(OwningRef { reference: f(&self)?, owner: self.owner })\n-    }\n-\n-    /// Converts `self` into a new owning reference with a different owner type.\n-    ///\n-    /// The new owner type needs to still contain the original owner in some way\n-    /// so that the reference into it remains valid. This function is marked unsafe\n-    /// because the user needs to manually uphold this guarantee.\n-    pub unsafe fn map_owner<F, P>(self, f: F) -> OwningRef<P, T>\n-    where\n-        O: StableAddress,\n-        P: StableAddress,\n-        F: FnOnce(O) -> P,\n-    {\n-        OwningRef { reference: self.reference, owner: f(self.owner) }\n-    }\n-\n-    /// Converts `self` into a new owning reference where the owner is wrapped\n-    /// in an additional `Box<O>`.\n-    ///\n-    /// This can be used to safely erase the owner of any `OwningRef<O, T>`\n-    /// to an `OwningRef<Box<Erased>, T>`.\n-    pub fn map_owner_box(self) -> OwningRef<Box<O>, T> {\n-        OwningRef { reference: self.reference, owner: Box::new(self.owner) }\n-    }\n-\n-    /// Erases the concrete base type of the owner with a trait object.\n-    ///\n-    /// This allows mixing of owned references with different owner base types.\n-    ///\n-    /// # Example\n-    /// ```\n-    /// use rustc_data_structures::owning_ref::{OwningRef, Erased};\n-    ///\n-    /// fn main() {\n-    ///     // N.B., using the concrete types here for explicitness.\n-    ///     // For less verbose code type aliases like `BoxRef` are provided.\n-    ///\n-    ///     let owning_ref_a: OwningRef<Box<[i32; 4]>, [i32; 4]>\n-    ///         = OwningRef::new(Box::new([1, 2, 3, 4]));\n-    ///\n-    ///     let owning_ref_b: OwningRef<Box<Vec<(i32, bool)>>, Vec<(i32, bool)>>\n-    ///         = OwningRef::new(Box::new(vec![(0, false), (1, true)]));\n-    ///\n-    ///     let owning_ref_a: OwningRef<Box<[i32; 4]>, i32>\n-    ///         = owning_ref_a.map(|a| &a[0]);\n-    ///\n-    ///     let owning_ref_b: OwningRef<Box<Vec<(i32, bool)>>, i32>\n-    ///         = owning_ref_b.map(|a| &a[1].0);\n-    ///\n-    ///     let owning_refs: [OwningRef<Box<dyn Erased>, i32>; 2]\n-    ///         = [owning_ref_a.erase_owner(), owning_ref_b.erase_owner()];\n-    ///\n-    ///     assert_eq!(*owning_refs[0], 1);\n-    ///     assert_eq!(*owning_refs[1], 1);\n-    /// }\n-    /// ```\n-    pub fn erase_owner<'a>(self) -> OwningRef<O::Erased, T>\n-    where\n-        O: IntoErased<'a>,\n-    {\n-        OwningRef { reference: self.reference, owner: self.owner.into_erased() }\n-    }\n-\n-    /// Erases the concrete base type of the owner with a trait object which implements `Send`.\n-    ///\n-    /// This allows mixing of owned references with different owner base types.\n-    pub fn erase_send_owner<'a>(self) -> OwningRef<O::Erased, T>\n-    where\n-        O: IntoErasedSend<'a>,\n-    {\n-        OwningRef { reference: self.reference, owner: self.owner.into_erased_send() }\n-    }\n-\n-    /// Erases the concrete base type of the owner with a trait object\n-    /// which implements `Send` and `Sync`.\n-    ///\n-    /// This allows mixing of owned references with different owner base types.\n-    pub fn erase_send_sync_owner<'a>(self) -> OwningRef<O::Erased, T>\n-    where\n-        O: IntoErasedSendSync<'a>,\n-    {\n-        OwningRef { reference: self.reference, owner: self.owner.into_erased_send_sync() }\n-    }\n-\n-    // UNIMPLEMENTED: wrap_owner\n-\n-    // FIXME: Naming convention?\n-    /// A getter for the underlying owner.\n-    pub fn owner(&self) -> &O {\n-        &self.owner\n-    }\n-\n-    // FIXME: Naming convention?\n-    /// Discards the reference and retrieves the owner.\n-    pub fn into_inner(self) -> O {\n-        self.owner\n-    }\n-}\n-\n-impl<O, T: ?Sized> OwningRefMut<O, T> {\n-    /// Creates a new owning reference from an owner\n-    /// initialized to the direct dereference of it.\n-    ///\n-    /// # Example\n-    /// ```\n-    /// use rustc_data_structures::owning_ref::OwningRefMut;\n-    ///\n-    /// fn main() {\n-    ///     let owning_ref_mut = OwningRefMut::new(Box::new(42));\n-    ///     assert_eq!(*owning_ref_mut, 42);\n-    /// }\n-    /// ```\n-    pub fn new(mut o: O) -> Self\n-    where\n-        O: StableAddress,\n-        O: DerefMut<Target = T>,\n-    {\n-        OwningRefMut { reference: &mut *o, owner: o }\n-    }\n-\n-    /// Like `new`, but doesn\u2019t require `O` to implement the `StableAddress` trait.\n-    /// Instead, the caller is responsible to make the same promises as implementing the trait.\n-    ///\n-    /// This is useful for cases where coherence rules prevents implementing the trait\n-    /// without adding a dependency to this crate in a third-party library.\n-    pub unsafe fn new_assert_stable_address(mut o: O) -> Self\n-    where\n-        O: DerefMut<Target = T>,\n-    {\n-        OwningRefMut { reference: &mut *o, owner: o }\n-    }\n-\n-    /// Converts `self` into a new _shared_ owning reference that points at\n-    /// something reachable from the previous one.\n-    ///\n-    /// This can be a reference to a field of `U`, something reachable from a field of\n-    /// `U`, or even something unrelated with a `'static` lifetime.\n-    ///\n-    /// # Example\n-    /// ```\n-    /// use rustc_data_structures::owning_ref::OwningRefMut;\n-    ///\n-    /// fn main() {\n-    ///     let owning_ref_mut = OwningRefMut::new(Box::new([1, 2, 3, 4]));\n-    ///\n-    ///     // create an owning reference that points at the\n-    ///     // third element of the array.\n-    ///     let owning_ref = owning_ref_mut.map(|array| &array[2]);\n-    ///     assert_eq!(*owning_ref, 3);\n-    /// }\n-    /// ```\n-    pub fn map<F, U: ?Sized>(mut self, f: F) -> OwningRef<O, U>\n-    where\n-        O: StableAddress,\n-        F: FnOnce(&mut T) -> &U,\n-    {\n-        OwningRef { reference: f(&mut self), owner: self.owner }\n-    }\n-\n-    /// Converts `self` into a new _mutable_ owning reference that points at\n-    /// something reachable from the previous one.\n-    ///\n-    /// This can be a reference to a field of `U`, something reachable from a field of\n-    /// `U`, or even something unrelated with a `'static` lifetime.\n-    ///\n-    /// # Example\n-    /// ```\n-    /// use rustc_data_structures::owning_ref::OwningRefMut;\n-    ///\n-    /// fn main() {\n-    ///     let owning_ref_mut = OwningRefMut::new(Box::new([1, 2, 3, 4]));\n-    ///\n-    ///     // create an owning reference that points at the\n-    ///     // third element of the array.\n-    ///     let owning_ref_mut = owning_ref_mut.map_mut(|array| &mut array[2]);\n-    ///     assert_eq!(*owning_ref_mut, 3);\n-    /// }\n-    /// ```\n-    pub fn map_mut<F, U: ?Sized>(mut self, f: F) -> OwningRefMut<O, U>\n-    where\n-        O: StableAddress,\n-        F: FnOnce(&mut T) -> &mut U,\n-    {\n-        OwningRefMut { reference: f(&mut self), owner: self.owner }\n-    }\n-\n-    /// Tries to convert `self` into a new _shared_ owning reference that points\n-    /// at something reachable from the previous one.\n-    ///\n-    /// This can be a reference to a field of `U`, something reachable from a field of\n-    /// `U`, or even something unrelated with a `'static` lifetime.\n-    ///\n-    /// # Example\n-    /// ```\n-    /// use rustc_data_structures::owning_ref::OwningRefMut;\n-    ///\n-    /// fn main() {\n-    ///     let owning_ref_mut = OwningRefMut::new(Box::new([1, 2, 3, 4]));\n-    ///\n-    ///     // create an owning reference that points at the\n-    ///     // third element of the array.\n-    ///     let owning_ref = owning_ref_mut.try_map(|array| {\n-    ///         if array[2] == 3 { Ok(&array[2]) } else { Err(()) }\n-    ///     });\n-    ///     assert_eq!(*owning_ref.unwrap(), 3);\n-    /// }\n-    /// ```\n-    pub fn try_map<F, U: ?Sized, E>(mut self, f: F) -> Result<OwningRef<O, U>, E>\n-    where\n-        O: StableAddress,\n-        F: FnOnce(&mut T) -> Result<&U, E>,\n-    {\n-        Ok(OwningRef { reference: f(&mut self)?, owner: self.owner })\n-    }\n-\n-    /// Tries to convert `self` into a new _mutable_ owning reference that points\n-    /// at something reachable from the previous one.\n-    ///\n-    /// This can be a reference to a field of `U`, something reachable from a field of\n-    /// `U`, or even something unrelated with a `'static` lifetime.\n-    ///\n-    /// # Example\n-    /// ```\n-    /// use rustc_data_structures::owning_ref::OwningRefMut;\n-    ///\n-    /// fn main() {\n-    ///     let owning_ref_mut = OwningRefMut::new(Box::new([1, 2, 3, 4]));\n-    ///\n-    ///     // create an owning reference that points at the\n-    ///     // third element of the array.\n-    ///     let owning_ref_mut = owning_ref_mut.try_map_mut(|array| {\n-    ///         if array[2] == 3 { Ok(&mut array[2]) } else { Err(()) }\n-    ///     });\n-    ///     assert_eq!(*owning_ref_mut.unwrap(), 3);\n-    /// }\n-    /// ```\n-    pub fn try_map_mut<F, U: ?Sized, E>(mut self, f: F) -> Result<OwningRefMut<O, U>, E>\n-    where\n-        O: StableAddress,\n-        F: FnOnce(&mut T) -> Result<&mut U, E>,\n-    {\n-        Ok(OwningRefMut { reference: f(&mut self)?, owner: self.owner })\n-    }\n-\n-    /// Converts `self` into a new owning reference with a different owner type.\n-    ///\n-    /// The new owner type needs to still contain the original owner in some way\n-    /// so that the reference into it remains valid. This function is marked unsafe\n-    /// because the user needs to manually uphold this guarantee.\n-    pub unsafe fn map_owner<F, P>(self, f: F) -> OwningRefMut<P, T>\n-    where\n-        O: StableAddress,\n-        P: StableAddress,\n-        F: FnOnce(O) -> P,\n-    {\n-        OwningRefMut { reference: self.reference, owner: f(self.owner) }\n-    }\n-\n-    /// Converts `self` into a new owning reference where the owner is wrapped\n-    /// in an additional `Box<O>`.\n-    ///\n-    /// This can be used to safely erase the owner of any `OwningRefMut<O, T>`\n-    /// to an `OwningRefMut<Box<Erased>, T>`.\n-    pub fn map_owner_box(self) -> OwningRefMut<Box<O>, T> {\n-        OwningRefMut { reference: self.reference, owner: Box::new(self.owner) }\n-    }\n-\n-    /// Erases the concrete base type of the owner with a trait object.\n-    ///\n-    /// This allows mixing of owned references with different owner base types.\n-    ///\n-    /// # Example\n-    /// ```\n-    /// use rustc_data_structures::owning_ref::{OwningRefMut, Erased};\n-    ///\n-    /// fn main() {\n-    ///     // N.B., using the concrete types here for explicitness.\n-    ///     // For less verbose code type aliases like `BoxRef` are provided.\n-    ///\n-    ///     let owning_ref_mut_a: OwningRefMut<Box<[i32; 4]>, [i32; 4]>\n-    ///         = OwningRefMut::new(Box::new([1, 2, 3, 4]));\n-    ///\n-    ///     let owning_ref_mut_b: OwningRefMut<Box<Vec<(i32, bool)>>, Vec<(i32, bool)>>\n-    ///         = OwningRefMut::new(Box::new(vec![(0, false), (1, true)]));\n-    ///\n-    ///     let owning_ref_mut_a: OwningRefMut<Box<[i32; 4]>, i32>\n-    ///         = owning_ref_mut_a.map_mut(|a| &mut a[0]);\n-    ///\n-    ///     let owning_ref_mut_b: OwningRefMut<Box<Vec<(i32, bool)>>, i32>\n-    ///         = owning_ref_mut_b.map_mut(|a| &mut a[1].0);\n-    ///\n-    ///     let owning_refs_mut: [OwningRefMut<Box<dyn Erased>, i32>; 2]\n-    ///         = [owning_ref_mut_a.erase_owner(), owning_ref_mut_b.erase_owner()];\n-    ///\n-    ///     assert_eq!(*owning_refs_mut[0], 1);\n-    ///     assert_eq!(*owning_refs_mut[1], 1);\n-    /// }\n-    /// ```\n-    pub fn erase_owner<'a>(self) -> OwningRefMut<O::Erased, T>\n-    where\n-        O: IntoErased<'a>,\n-    {\n-        OwningRefMut { reference: self.reference, owner: self.owner.into_erased() }\n-    }\n-\n-    // UNIMPLEMENTED: wrap_owner\n-\n-    // FIXME: Naming convention?\n-    /// A getter for the underlying owner.\n-    pub fn owner(&self) -> &O {\n-        &self.owner\n-    }\n-\n-    // FIXME: Naming convention?\n-    /// Discards the reference and retrieves the owner.\n-    pub fn into_inner(self) -> O {\n-        self.owner\n-    }\n-}\n-\n-/////////////////////////////////////////////////////////////////////////////\n-// OwningHandle\n-/////////////////////////////////////////////////////////////////////////////\n-\n-use std::ops::{Deref, DerefMut};\n-\n-/// `OwningHandle` is a complement to `OwningRef`. Where `OwningRef` allows\n-/// consumers to pass around an owned object and a dependent reference,\n-/// `OwningHandle` contains an owned object and a dependent _object_.\n-///\n-/// `OwningHandle` can encapsulate a `RefMut` along with its associated\n-/// `RefCell`, or an `RwLockReadGuard` along with its associated `RwLock`.\n-/// However, the API is completely generic and there are no restrictions on\n-/// what types of owning and dependent objects may be used.\n-///\n-/// `OwningHandle` is created by passing an owner object (which dereferences\n-/// to a stable address) along with a callback which receives a pointer to\n-/// that stable location. The callback may then dereference the pointer and\n-/// mint a dependent object, with the guarantee that the returned object will\n-/// not outlive the referent of the pointer.\n-///\n-/// Since the callback needs to dereference a raw pointer, it requires `unsafe`\n-/// code. To avoid forcing this unsafety on most callers, the `ToHandle` trait is\n-/// implemented for common data structures. Types that implement `ToHandle` can\n-/// be wrapped into an `OwningHandle` without passing a callback.\n-pub struct OwningHandle<O, H>\n-where\n-    O: StableAddress,\n-    H: Deref,\n-{\n-    handle: H,\n-    _owner: O,\n-}\n-\n-impl<O, H> Deref for OwningHandle<O, H>\n-where\n-    O: StableAddress,\n-    H: Deref,\n-{\n-    type Target = H::Target;\n-    fn deref(&self) -> &H::Target {\n-        self.handle.deref()\n-    }\n-}\n-\n-unsafe impl<O, H> StableAddress for OwningHandle<O, H>\n-where\n-    O: StableAddress,\n-    H: StableAddress,\n-{\n-}\n-\n-impl<O, H> DerefMut for OwningHandle<O, H>\n-where\n-    O: StableAddress,\n-    H: DerefMut,\n-{\n-    fn deref_mut(&mut self) -> &mut H::Target {\n-        self.handle.deref_mut()\n-    }\n-}\n-\n-/// Trait to implement the conversion of owner to handle for common types.\n-pub trait ToHandle {\n-    /// The type of handle to be encapsulated by the OwningHandle.\n-    type Handle: Deref;\n-\n-    /// Given an appropriately-long-lived pointer to ourselves, create a\n-    /// handle to be encapsulated by the `OwningHandle`.\n-    unsafe fn to_handle(x: *const Self) -> Self::Handle;\n-}\n-\n-/// Trait to implement the conversion of owner to mutable handle for common types.\n-pub trait ToHandleMut {\n-    /// The type of handle to be encapsulated by the OwningHandle.\n-    type HandleMut: DerefMut;\n-\n-    /// Given an appropriately-long-lived pointer to ourselves, create a\n-    /// mutable handle to be encapsulated by the `OwningHandle`.\n-    unsafe fn to_handle_mut(x: *const Self) -> Self::HandleMut;\n-}\n-\n-impl<O, H> OwningHandle<O, H>\n-where\n-    O: StableAddress<Target: ToHandle<Handle = H>>,\n-    H: Deref,\n-{\n-    /// Creates a new `OwningHandle` for a type that implements `ToHandle`. For types\n-    /// that don't implement `ToHandle`, callers may invoke `new_with_fn`, which accepts\n-    /// a callback to perform the conversion.\n-    pub fn new(o: O) -> Self {\n-        OwningHandle::new_with_fn(o, |x| unsafe { O::Target::to_handle(x) })\n-    }\n-}\n-\n-impl<O, H> OwningHandle<O, H>\n-where\n-    O: StableAddress<Target: ToHandleMut<HandleMut = H>>,\n-    H: DerefMut,\n-{\n-    /// Creates a new mutable `OwningHandle` for a type that implements `ToHandleMut`.\n-    pub fn new_mut(o: O) -> Self {\n-        OwningHandle::new_with_fn(o, |x| unsafe { O::Target::to_handle_mut(x) })\n-    }\n-}\n-\n-impl<O, H> OwningHandle<O, H>\n-where\n-    O: StableAddress,\n-    H: Deref,\n-{\n-    /// Creates a new OwningHandle. The provided callback will be invoked with\n-    /// a pointer to the object owned by `o`, and the returned value is stored\n-    /// as the object to which this `OwningHandle` will forward `Deref` and\n-    /// `DerefMut`.\n-    pub fn new_with_fn<F>(o: O, f: F) -> Self\n-    where\n-        F: FnOnce(*const O::Target) -> H,\n-    {\n-        let h: H;\n-        {\n-            h = f(o.deref() as *const O::Target);\n-        }\n-\n-        OwningHandle { handle: h, _owner: o }\n-    }\n-\n-    /// Creates a new OwningHandle. The provided callback will be invoked with\n-    /// a pointer to the object owned by `o`, and the returned value is stored\n-    /// as the object to which this `OwningHandle` will forward `Deref` and\n-    /// `DerefMut`.\n-    pub fn try_new<F, E>(o: O, f: F) -> Result<Self, E>\n-    where\n-        F: FnOnce(*const O::Target) -> Result<H, E>,\n-    {\n-        let h: H;\n-        {\n-            h = f(o.deref() as *const O::Target)?;\n-        }\n-\n-        Ok(OwningHandle { handle: h, _owner: o })\n-    }\n-}\n-\n-/////////////////////////////////////////////////////////////////////////////\n-// std traits\n-/////////////////////////////////////////////////////////////////////////////\n-\n-use std::borrow::Borrow;\n-use std::cmp::Ordering;\n-use std::fmt::{self, Debug};\n-use std::hash::{Hash, Hasher};\n-\n-impl<O, T: ?Sized> Deref for OwningRef<O, T> {\n-    type Target = T;\n-\n-    fn deref(&self) -> &T {\n-        unsafe { &*self.reference }\n-    }\n-}\n-\n-impl<O, T: ?Sized> Deref for OwningRefMut<O, T> {\n-    type Target = T;\n-\n-    fn deref(&self) -> &T {\n-        unsafe { &*self.reference }\n-    }\n-}\n-\n-impl<O, T: ?Sized> DerefMut for OwningRefMut<O, T> {\n-    fn deref_mut(&mut self) -> &mut T {\n-        unsafe { &mut *self.reference }\n-    }\n-}\n-\n-unsafe impl<O, T: ?Sized> StableAddress for OwningRef<O, T> {}\n-\n-impl<O, T: ?Sized> AsRef<T> for OwningRef<O, T> {\n-    fn as_ref(&self) -> &T {\n-        self\n-    }\n-}\n-\n-impl<O, T: ?Sized> AsRef<T> for OwningRefMut<O, T> {\n-    fn as_ref(&self) -> &T {\n-        self\n-    }\n-}\n-\n-impl<O, T: ?Sized> AsMut<T> for OwningRefMut<O, T> {\n-    fn as_mut(&mut self) -> &mut T {\n-        self\n-    }\n-}\n-\n-impl<O, T: ?Sized> Borrow<T> for OwningRef<O, T> {\n-    fn borrow(&self) -> &T {\n-        self\n-    }\n-}\n-\n-impl<O, T: ?Sized> From<O> for OwningRef<O, T>\n-where\n-    O: StableAddress,\n-    O: Deref<Target = T>,\n-{\n-    fn from(owner: O) -> Self {\n-        OwningRef::new(owner)\n-    }\n-}\n-\n-impl<O, T: ?Sized> From<O> for OwningRefMut<O, T>\n-where\n-    O: StableAddress,\n-    O: DerefMut<Target = T>,\n-{\n-    fn from(owner: O) -> Self {\n-        OwningRefMut::new(owner)\n-    }\n-}\n-\n-impl<O, T: ?Sized> From<OwningRefMut<O, T>> for OwningRef<O, T>\n-where\n-    O: StableAddress,\n-    O: DerefMut<Target = T>,\n-{\n-    fn from(other: OwningRefMut<O, T>) -> Self {\n-        OwningRef { owner: other.owner, reference: other.reference }\n-    }\n-}\n-\n-// ^ FIXME: Is an Into impl for calling into_inner() possible as well?\n-\n-impl<O, T: ?Sized> Debug for OwningRef<O, T>\n-where\n-    O: Debug,\n-    T: Debug,\n-{\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"OwningRef {{ owner: {:?}, reference: {:?} }}\", self.owner(), &**self)\n-    }\n-}\n-\n-impl<O, T: ?Sized> Debug for OwningRefMut<O, T>\n-where\n-    O: Debug,\n-    T: Debug,\n-{\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"OwningRefMut {{ owner: {:?}, reference: {:?} }}\", self.owner(), &**self)\n-    }\n-}\n-\n-impl<O, T: ?Sized> Clone for OwningRef<O, T>\n-where\n-    O: CloneStableAddress,\n-{\n-    fn clone(&self) -> Self {\n-        OwningRef { owner: self.owner.clone(), reference: self.reference }\n-    }\n-}\n-\n-unsafe impl<O, T: ?Sized> CloneStableAddress for OwningRef<O, T> where O: CloneStableAddress {}\n-\n-unsafe impl<O, T: ?Sized> Send for OwningRef<O, T>\n-where\n-    O: Send,\n-    for<'a> &'a T: Send,\n-{\n-}\n-unsafe impl<O, T: ?Sized> Sync for OwningRef<O, T>\n-where\n-    O: Sync,\n-    for<'a> &'a T: Sync,\n-{\n-}\n-\n-unsafe impl<O, T: ?Sized> Send for OwningRefMut<O, T>\n-where\n-    O: Send,\n-    for<'a> &'a mut T: Send,\n-{\n-}\n-unsafe impl<O, T: ?Sized> Sync for OwningRefMut<O, T>\n-where\n-    O: Sync,\n-    for<'a> &'a mut T: Sync,\n-{\n-}\n-\n-impl Debug for dyn Erased {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"<Erased>\",)\n-    }\n-}\n-\n-impl<O, T: ?Sized> PartialEq for OwningRef<O, T>\n-where\n-    T: PartialEq,\n-{\n-    fn eq(&self, other: &Self) -> bool {\n-        self.deref().eq(other.deref())\n-    }\n-}\n-\n-impl<O, T: ?Sized> Eq for OwningRef<O, T> where T: Eq {}\n-\n-impl<O, T: ?Sized> PartialOrd for OwningRef<O, T>\n-where\n-    T: PartialOrd,\n-{\n-    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n-        self.deref().partial_cmp(other.deref())\n-    }\n-}\n-\n-impl<O, T: ?Sized> Ord for OwningRef<O, T>\n-where\n-    T: Ord,\n-{\n-    fn cmp(&self, other: &Self) -> Ordering {\n-        self.deref().cmp(other.deref())\n-    }\n-}\n-\n-impl<O, T: ?Sized> Hash for OwningRef<O, T>\n-where\n-    T: Hash,\n-{\n-    fn hash<H: Hasher>(&self, state: &mut H) {\n-        self.deref().hash(state);\n-    }\n-}\n-\n-impl<O, T: ?Sized> PartialEq for OwningRefMut<O, T>\n-where\n-    T: PartialEq,\n-{\n-    fn eq(&self, other: &Self) -> bool {\n-        self.deref().eq(other.deref())\n-    }\n-}\n-\n-impl<O, T: ?Sized> Eq for OwningRefMut<O, T> where T: Eq {}\n-\n-impl<O, T: ?Sized> PartialOrd for OwningRefMut<O, T>\n-where\n-    T: PartialOrd,\n-{\n-    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n-        self.deref().partial_cmp(other.deref())\n-    }\n-}\n-\n-impl<O, T: ?Sized> Ord for OwningRefMut<O, T>\n-where\n-    T: Ord,\n-{\n-    fn cmp(&self, other: &Self) -> Ordering {\n-        self.deref().cmp(other.deref())\n-    }\n-}\n-\n-impl<O, T: ?Sized> Hash for OwningRefMut<O, T>\n-where\n-    T: Hash,\n-{\n-    fn hash<H: Hasher>(&self, state: &mut H) {\n-        self.deref().hash(state);\n-    }\n-}\n-\n-/////////////////////////////////////////////////////////////////////////////\n-// std types integration and convenience type defs\n-/////////////////////////////////////////////////////////////////////////////\n-\n-use std::cell::{Ref, RefCell, RefMut};\n-use std::rc::Rc;\n-use std::sync::Arc;\n-use std::sync::{MutexGuard, RwLockReadGuard, RwLockWriteGuard};\n-\n-impl<T: 'static> ToHandle for RefCell<T> {\n-    type Handle = Ref<'static, T>;\n-    unsafe fn to_handle(x: *const Self) -> Self::Handle {\n-        (*x).borrow()\n-    }\n-}\n-\n-impl<T: 'static> ToHandleMut for RefCell<T> {\n-    type HandleMut = RefMut<'static, T>;\n-    unsafe fn to_handle_mut(x: *const Self) -> Self::HandleMut {\n-        (*x).borrow_mut()\n-    }\n-}\n-\n-// N.B., implementing ToHandle{,Mut} for Mutex and RwLock requires a decision\n-// about which handle creation to use (i.e., read() vs try_read()) as well as\n-// what to do with error results.\n-\n-/// Typedef of an owning reference that uses a `Box` as the owner.\n-pub type BoxRef<T, U = T> = OwningRef<Box<T>, U>;\n-/// Typedef of an owning reference that uses a `Vec` as the owner.\n-pub type VecRef<T, U = T> = OwningRef<Vec<T>, U>;\n-/// Typedef of an owning reference that uses a `String` as the owner.\n-pub type StringRef = OwningRef<String, str>;\n-\n-/// Typedef of an owning reference that uses an `Rc` as the owner.\n-pub type RcRef<T, U = T> = OwningRef<Rc<T>, U>;\n-/// Typedef of an owning reference that uses an `Arc` as the owner.\n-pub type ArcRef<T, U = T> = OwningRef<Arc<T>, U>;\n-\n-/// Typedef of an owning reference that uses a `Ref` as the owner.\n-pub type RefRef<'a, T, U = T> = OwningRef<Ref<'a, T>, U>;\n-/// Typedef of an owning reference that uses a `RefMut` as the owner.\n-pub type RefMutRef<'a, T, U = T> = OwningRef<RefMut<'a, T>, U>;\n-/// Typedef of an owning reference that uses a `MutexGuard` as the owner.\n-pub type MutexGuardRef<'a, T, U = T> = OwningRef<MutexGuard<'a, T>, U>;\n-/// Typedef of an owning reference that uses an `RwLockReadGuard` as the owner.\n-pub type RwLockReadGuardRef<'a, T, U = T> = OwningRef<RwLockReadGuard<'a, T>, U>;\n-/// Typedef of an owning reference that uses an `RwLockWriteGuard` as the owner.\n-pub type RwLockWriteGuardRef<'a, T, U = T> = OwningRef<RwLockWriteGuard<'a, T>, U>;\n-\n-/// Typedef of a mutable owning reference that uses a `Box` as the owner.\n-pub type BoxRefMut<T, U = T> = OwningRefMut<Box<T>, U>;\n-/// Typedef of a mutable owning reference that uses a `Vec` as the owner.\n-pub type VecRefMut<T, U = T> = OwningRefMut<Vec<T>, U>;\n-/// Typedef of a mutable owning reference that uses a `String` as the owner.\n-pub type StringRefMut = OwningRefMut<String, str>;\n-\n-/// Typedef of a mutable owning reference that uses a `RefMut` as the owner.\n-pub type RefMutRefMut<'a, T, U = T> = OwningRefMut<RefMut<'a, T>, U>;\n-/// Typedef of a mutable owning reference that uses a `MutexGuard` as the owner.\n-pub type MutexGuardRefMut<'a, T, U = T> = OwningRefMut<MutexGuard<'a, T>, U>;\n-/// Typedef of a mutable owning reference that uses an `RwLockWriteGuard` as the owner.\n-pub type RwLockWriteGuardRefMut<'a, T, U = T> = OwningRef<RwLockWriteGuard<'a, T>, U>;\n-\n-unsafe impl<'a, T: 'a> IntoErased<'a> for Box<T> {\n-    type Erased = Box<dyn Erased + 'a>;\n-    fn into_erased(self) -> Self::Erased {\n-        self\n-    }\n-}\n-unsafe impl<'a, T: 'a> IntoErased<'a> for Rc<T> {\n-    type Erased = Rc<dyn Erased + 'a>;\n-    fn into_erased(self) -> Self::Erased {\n-        self\n-    }\n-}\n-unsafe impl<'a, T: 'a> IntoErased<'a> for Arc<T> {\n-    type Erased = Arc<dyn Erased + 'a>;\n-    fn into_erased(self) -> Self::Erased {\n-        self\n-    }\n-}\n-\n-unsafe impl<'a, T: Send + 'a> IntoErasedSend<'a> for Box<T> {\n-    type Erased = Box<dyn Erased + Send + 'a>;\n-    fn into_erased_send(self) -> Self::Erased {\n-        self\n-    }\n-}\n-\n-unsafe impl<'a, T: Send + 'a> IntoErasedSendSync<'a> for Box<T> {\n-    type Erased = Box<dyn Erased + Sync + Send + 'a>;\n-    fn into_erased_send_sync(self) -> Self::Erased {\n-        let result: Box<dyn Erased + Send + 'a> = self;\n-        // This is safe since Erased can always implement Sync\n-        // Only the destructor is available and it takes &mut self\n-        unsafe { mem::transmute(result) }\n-    }\n-}\n-\n-unsafe impl<'a, T: Send + Sync + 'a> IntoErasedSendSync<'a> for Arc<T> {\n-    type Erased = Arc<dyn Erased + Send + Sync + 'a>;\n-    fn into_erased_send_sync(self) -> Self::Erased {\n-        self\n-    }\n-}\n-\n-/// Typedef of an owning reference that uses an erased `Box` as the owner.\n-pub type ErasedBoxRef<U> = OwningRef<Box<dyn Erased>, U>;\n-/// Typedef of an owning reference that uses an erased `Rc` as the owner.\n-pub type ErasedRcRef<U> = OwningRef<Rc<dyn Erased>, U>;\n-/// Typedef of an owning reference that uses an erased `Arc` as the owner.\n-pub type ErasedArcRef<U> = OwningRef<Arc<dyn Erased>, U>;\n-\n-/// Typedef of a mutable owning reference that uses an erased `Box` as the owner.\n-pub type ErasedBoxRefMut<U> = OwningRefMut<Box<dyn Erased>, U>;\n-\n-#[cfg(test)]\n-mod tests;"}, {"sha": "a9b187c4ce0a79f979ae4c562ebe56ab598c40bb", "filename": "compiler/rustc_data_structures/src/owning_ref/tests.rs", "status": "removed", "additions": 0, "deletions": 711, "changes": 711, "blob_url": "https://github.com/rust-lang/rust/blob/ba86600c9452508a0ab05cd4bdc9af4c96f7d4ba/compiler%2Frustc_data_structures%2Fsrc%2Fowning_ref%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba86600c9452508a0ab05cd4bdc9af4c96f7d4ba/compiler%2Frustc_data_structures%2Fsrc%2Fowning_ref%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fowning_ref%2Ftests.rs?ref=ba86600c9452508a0ab05cd4bdc9af4c96f7d4ba", "patch": "@@ -1,711 +0,0 @@\n-// FIXME: owning_ref is not sound under stacked borrows. Preferably, get rid of it.\n-#[cfg(not(miri))]\n-mod owning_ref {\n-    use super::super::OwningRef;\n-    use super::super::{BoxRef, Erased, ErasedBoxRef, RcRef};\n-    use std::cmp::Ordering;\n-    use std::collections::hash_map::DefaultHasher;\n-    use std::collections::HashMap;\n-    use std::hash::{Hash, Hasher};\n-    use std::rc::Rc;\n-\n-    #[derive(Debug, PartialEq)]\n-    struct Example(u32, String, [u8; 3]);\n-    fn example() -> Example {\n-        Example(42, \"hello world\".to_string(), [1, 2, 3])\n-    }\n-\n-    #[test]\n-    fn new_deref() {\n-        let or: OwningRef<Box<()>, ()> = OwningRef::new(Box::new(()));\n-        assert_eq!(&*or, &());\n-    }\n-\n-    #[test]\n-    fn into() {\n-        let or: OwningRef<Box<()>, ()> = Box::new(()).into();\n-        assert_eq!(&*or, &());\n-    }\n-\n-    #[test]\n-    fn map_offset_ref() {\n-        let or: BoxRef<Example> = Box::new(example()).into();\n-        let or: BoxRef<_, u32> = or.map(|x| &x.0);\n-        assert_eq!(&*or, &42);\n-\n-        let or: BoxRef<Example> = Box::new(example()).into();\n-        let or: BoxRef<_, u8> = or.map(|x| &x.2[1]);\n-        assert_eq!(&*or, &2);\n-    }\n-\n-    #[test]\n-    fn map_heap_ref() {\n-        let or: BoxRef<Example> = Box::new(example()).into();\n-        let or: BoxRef<_, str> = or.map(|x| &x.1[..5]);\n-        assert_eq!(&*or, \"hello\");\n-    }\n-\n-    #[test]\n-    fn map_static_ref() {\n-        let or: BoxRef<()> = Box::new(()).into();\n-        let or: BoxRef<_, str> = or.map(|_| \"hello\");\n-        assert_eq!(&*or, \"hello\");\n-    }\n-\n-    #[test]\n-    fn map_chained() {\n-        let or: BoxRef<String> = Box::new(example().1).into();\n-        let or: BoxRef<_, str> = or.map(|x| &x[1..5]);\n-        let or: BoxRef<_, str> = or.map(|x| &x[..2]);\n-        assert_eq!(&*or, \"el\");\n-    }\n-\n-    #[test]\n-    fn map_chained_inference() {\n-        let or = BoxRef::new(Box::new(example().1)).map(|x| &x[..5]).map(|x| &x[1..3]);\n-        assert_eq!(&*or, \"el\");\n-    }\n-\n-    #[test]\n-    fn owner() {\n-        let or: BoxRef<String> = Box::new(example().1).into();\n-        let or = or.map(|x| &x[..5]);\n-        assert_eq!(&*or, \"hello\");\n-        assert_eq!(&**or.owner(), \"hello world\");\n-    }\n-\n-    #[test]\n-    fn into_inner() {\n-        let or: BoxRef<String> = Box::new(example().1).into();\n-        let or = or.map(|x| &x[..5]);\n-        assert_eq!(&*or, \"hello\");\n-        let s = *or.into_inner();\n-        assert_eq!(&s, \"hello world\");\n-    }\n-\n-    #[test]\n-    fn fmt_debug() {\n-        let or: BoxRef<String> = Box::new(example().1).into();\n-        let or = or.map(|x| &x[..5]);\n-        let s = format!(\"{:?}\", or);\n-        assert_eq!(&s, \"OwningRef { owner: \\\"hello world\\\", reference: \\\"hello\\\" }\");\n-    }\n-\n-    #[test]\n-    fn erased_owner() {\n-        let o1: BoxRef<Example, str> = BoxRef::new(Box::new(example())).map(|x| &x.1[..]);\n-\n-        let o2: BoxRef<String, str> = BoxRef::new(Box::new(example().1)).map(|x| &x[..]);\n-\n-        let os: Vec<ErasedBoxRef<str>> = vec![o1.erase_owner(), o2.erase_owner()];\n-        assert!(os.iter().all(|e| &e[..] == \"hello world\"));\n-    }\n-\n-    #[test]\n-    fn raii_locks() {\n-        use super::super::{MutexGuardRef, RwLockReadGuardRef, RwLockWriteGuardRef};\n-        use super::super::{RefMutRef, RefRef};\n-        use std::cell::RefCell;\n-        use std::sync::{Mutex, RwLock};\n-\n-        {\n-            let a = RefCell::new(1);\n-            let a = {\n-                let a = RefRef::new(a.borrow());\n-                assert_eq!(*a, 1);\n-                a\n-            };\n-            assert_eq!(*a, 1);\n-            drop(a);\n-        }\n-        {\n-            let a = RefCell::new(1);\n-            let a = {\n-                let a = RefMutRef::new(a.borrow_mut());\n-                assert_eq!(*a, 1);\n-                a\n-            };\n-            assert_eq!(*a, 1);\n-            drop(a);\n-        }\n-        {\n-            let a = Mutex::new(1);\n-            let a = {\n-                let a = MutexGuardRef::new(a.lock().unwrap());\n-                assert_eq!(*a, 1);\n-                a\n-            };\n-            assert_eq!(*a, 1);\n-            drop(a);\n-        }\n-        {\n-            let a = RwLock::new(1);\n-            let a = {\n-                let a = RwLockReadGuardRef::new(a.read().unwrap());\n-                assert_eq!(*a, 1);\n-                a\n-            };\n-            assert_eq!(*a, 1);\n-            drop(a);\n-        }\n-        {\n-            let a = RwLock::new(1);\n-            let a = {\n-                let a = RwLockWriteGuardRef::new(a.write().unwrap());\n-                assert_eq!(*a, 1);\n-                a\n-            };\n-            assert_eq!(*a, 1);\n-            drop(a);\n-        }\n-    }\n-\n-    #[test]\n-    fn eq() {\n-        let or1: BoxRef<[u8]> = BoxRef::new(vec![1, 2, 3].into_boxed_slice());\n-        let or2: BoxRef<[u8]> = BoxRef::new(vec![1, 2, 3].into_boxed_slice());\n-        assert_eq!(or1.eq(&or2), true);\n-    }\n-\n-    #[test]\n-    fn cmp() {\n-        let or1: BoxRef<[u8]> = BoxRef::new(vec![1, 2, 3].into_boxed_slice());\n-        let or2: BoxRef<[u8]> = BoxRef::new(vec![4, 5, 6].into_boxed_slice());\n-        assert_eq!(or1.cmp(&or2), Ordering::Less);\n-    }\n-\n-    #[test]\n-    fn partial_cmp() {\n-        let or1: BoxRef<[u8]> = BoxRef::new(vec![4, 5, 6].into_boxed_slice());\n-        let or2: BoxRef<[u8]> = BoxRef::new(vec![1, 2, 3].into_boxed_slice());\n-        assert_eq!(or1.partial_cmp(&or2), Some(Ordering::Greater));\n-    }\n-\n-    #[test]\n-    fn hash() {\n-        let mut h1 = DefaultHasher::new();\n-        let mut h2 = DefaultHasher::new();\n-\n-        let or1: BoxRef<[u8]> = BoxRef::new(vec![1, 2, 3].into_boxed_slice());\n-        let or2: BoxRef<[u8]> = BoxRef::new(vec![1, 2, 3].into_boxed_slice());\n-\n-        or1.hash(&mut h1);\n-        or2.hash(&mut h2);\n-\n-        assert_eq!(h1.finish(), h2.finish());\n-    }\n-\n-    #[test]\n-    fn borrow() {\n-        let mut hash = HashMap::new();\n-        let key = RcRef::<String>::new(Rc::new(\"foo-bar\".to_string())).map(|s| &s[..]);\n-\n-        hash.insert(key.clone().map(|s| &s[..3]), 42);\n-        hash.insert(key.clone().map(|s| &s[4..]), 23);\n-\n-        assert_eq!(hash.get(\"foo\"), Some(&42));\n-        assert_eq!(hash.get(\"bar\"), Some(&23));\n-    }\n-\n-    #[test]\n-    fn total_erase() {\n-        let a: OwningRef<Vec<u8>, [u8]> = OwningRef::new(vec![]).map(|x| &x[..]);\n-        let b: OwningRef<Box<[u8]>, [u8]> =\n-            OwningRef::new(vec![].into_boxed_slice()).map(|x| &x[..]);\n-\n-        let c: OwningRef<Rc<Vec<u8>>, [u8]> = unsafe { a.map_owner(Rc::new) };\n-        let d: OwningRef<Rc<Box<[u8]>>, [u8]> = unsafe { b.map_owner(Rc::new) };\n-\n-        let e: OwningRef<Rc<dyn Erased>, [u8]> = c.erase_owner();\n-        let f: OwningRef<Rc<dyn Erased>, [u8]> = d.erase_owner();\n-\n-        let _g = e.clone();\n-        let _h = f.clone();\n-    }\n-\n-    #[test]\n-    fn total_erase_box() {\n-        let a: OwningRef<Vec<u8>, [u8]> = OwningRef::new(vec![]).map(|x| &x[..]);\n-        let b: OwningRef<Box<[u8]>, [u8]> =\n-            OwningRef::new(vec![].into_boxed_slice()).map(|x| &x[..]);\n-\n-        let c: OwningRef<Box<Vec<u8>>, [u8]> = a.map_owner_box();\n-        let d: OwningRef<Box<Box<[u8]>>, [u8]> = b.map_owner_box();\n-\n-        let _e: OwningRef<Box<dyn Erased>, [u8]> = c.erase_owner();\n-        let _f: OwningRef<Box<dyn Erased>, [u8]> = d.erase_owner();\n-    }\n-\n-    #[test]\n-    fn try_map1() {\n-        use std::any::Any;\n-\n-        let x = Box::new(123_i32);\n-        let y: Box<dyn Any> = x;\n-\n-        assert!(OwningRef::new(y).try_map(|x| x.downcast_ref::<i32>().ok_or(())).is_ok());\n-    }\n-\n-    #[test]\n-    fn try_map2() {\n-        use std::any::Any;\n-\n-        let x = Box::new(123_i32);\n-        let y: Box<dyn Any> = x;\n-\n-        assert!(!OwningRef::new(y).try_map(|x| x.downcast_ref::<i32>().ok_or(())).is_err());\n-    }\n-}\n-\n-mod owning_handle {\n-    use super::super::OwningHandle;\n-    use super::super::RcRef;\n-    use std::cell::RefCell;\n-    use std::rc::Rc;\n-    use std::sync::Arc;\n-    use std::sync::RwLock;\n-\n-    #[test]\n-    fn owning_handle() {\n-        use std::cell::RefCell;\n-        let cell = Rc::new(RefCell::new(2));\n-        let cell_ref = RcRef::new(cell);\n-        let mut handle =\n-            OwningHandle::new_with_fn(cell_ref, |x| unsafe { x.as_ref() }.unwrap().borrow_mut());\n-        assert_eq!(*handle, 2);\n-        *handle = 3;\n-        assert_eq!(*handle, 3);\n-    }\n-\n-    #[test]\n-    fn try_owning_handle_ok() {\n-        use std::cell::RefCell;\n-        let cell = Rc::new(RefCell::new(2));\n-        let cell_ref = RcRef::new(cell);\n-        let mut handle = OwningHandle::try_new::<_, ()>(cell_ref, |x| {\n-            Ok(unsafe { x.as_ref() }.unwrap().borrow_mut())\n-        })\n-        .unwrap();\n-        assert_eq!(*handle, 2);\n-        *handle = 3;\n-        assert_eq!(*handle, 3);\n-    }\n-\n-    #[test]\n-    fn try_owning_handle_err() {\n-        use std::cell::RefCell;\n-        let cell = Rc::new(RefCell::new(2));\n-        let cell_ref = RcRef::new(cell);\n-        let handle = OwningHandle::try_new::<_, ()>(cell_ref, |x| {\n-            if false {\n-                return Ok(unsafe { x.as_ref() }.unwrap().borrow_mut());\n-            }\n-            Err(())\n-        });\n-        assert!(handle.is_err());\n-    }\n-\n-    #[test]\n-    fn nested() {\n-        use std::cell::RefCell;\n-        use std::sync::{Arc, RwLock};\n-\n-        let result = {\n-            let complex = Rc::new(RefCell::new(Arc::new(RwLock::new(\"someString\"))));\n-            let curr = RcRef::new(complex);\n-            let curr =\n-                OwningHandle::new_with_fn(curr, |x| unsafe { x.as_ref() }.unwrap().borrow_mut());\n-            let mut curr = OwningHandle::new_with_fn(curr, |x| {\n-                unsafe { x.as_ref() }.unwrap().try_write().unwrap()\n-            });\n-            assert_eq!(*curr, \"someString\");\n-            *curr = \"someOtherString\";\n-            curr\n-        };\n-        assert_eq!(*result, \"someOtherString\");\n-    }\n-\n-    #[test]\n-    fn owning_handle_safe() {\n-        use std::cell::RefCell;\n-        let cell = Rc::new(RefCell::new(2));\n-        let cell_ref = RcRef::new(cell);\n-        let handle = OwningHandle::new(cell_ref);\n-        assert_eq!(*handle, 2);\n-    }\n-\n-    #[test]\n-    fn owning_handle_mut_safe() {\n-        use std::cell::RefCell;\n-        let cell = Rc::new(RefCell::new(2));\n-        let cell_ref = RcRef::new(cell);\n-        let mut handle = OwningHandle::new_mut(cell_ref);\n-        assert_eq!(*handle, 2);\n-        *handle = 3;\n-        assert_eq!(*handle, 3);\n-    }\n-\n-    #[test]\n-    fn owning_handle_safe_2() {\n-        let result = {\n-            let complex = Rc::new(RefCell::new(Arc::new(RwLock::new(\"someString\"))));\n-            let curr = RcRef::new(complex);\n-            let curr =\n-                OwningHandle::new_with_fn(curr, |x| unsafe { x.as_ref() }.unwrap().borrow_mut());\n-            let mut curr = OwningHandle::new_with_fn(curr, |x| {\n-                unsafe { x.as_ref() }.unwrap().try_write().unwrap()\n-            });\n-            assert_eq!(*curr, \"someString\");\n-            *curr = \"someOtherString\";\n-            curr\n-        };\n-        assert_eq!(*result, \"someOtherString\");\n-    }\n-}\n-\n-// FIXME: owning_ref is not sound under stacked borrows. Preferably, get rid of it.\n-#[cfg(not(miri))]\n-mod owning_ref_mut {\n-    use super::super::BoxRef;\n-    use super::super::{BoxRefMut, Erased, ErasedBoxRefMut, OwningRefMut};\n-    use std::cmp::Ordering;\n-    use std::collections::hash_map::DefaultHasher;\n-    use std::collections::HashMap;\n-    use std::hash::{Hash, Hasher};\n-\n-    #[derive(Debug, PartialEq)]\n-    struct Example(u32, String, [u8; 3]);\n-    fn example() -> Example {\n-        Example(42, \"hello world\".to_string(), [1, 2, 3])\n-    }\n-\n-    #[test]\n-    fn new_deref() {\n-        let or: OwningRefMut<Box<()>, ()> = OwningRefMut::new(Box::new(()));\n-        assert_eq!(&*or, &());\n-    }\n-\n-    #[test]\n-    fn new_deref_mut() {\n-        let mut or: OwningRefMut<Box<()>, ()> = OwningRefMut::new(Box::new(()));\n-        assert_eq!(&mut *or, &mut ());\n-    }\n-\n-    #[test]\n-    fn mutate() {\n-        let mut or: OwningRefMut<Box<usize>, usize> = OwningRefMut::new(Box::new(0));\n-        assert_eq!(&*or, &0);\n-        *or = 1;\n-        assert_eq!(&*or, &1);\n-    }\n-\n-    #[test]\n-    fn into() {\n-        let or: OwningRefMut<Box<()>, ()> = Box::new(()).into();\n-        assert_eq!(&*or, &());\n-    }\n-\n-    #[test]\n-    fn map_offset_ref() {\n-        let or: BoxRefMut<Example> = Box::new(example()).into();\n-        let or: BoxRef<_, u32> = or.map(|x| &mut x.0);\n-        assert_eq!(&*or, &42);\n-\n-        let or: BoxRefMut<Example> = Box::new(example()).into();\n-        let or: BoxRef<_, u8> = or.map(|x| &mut x.2[1]);\n-        assert_eq!(&*or, &2);\n-    }\n-\n-    #[test]\n-    fn map_heap_ref() {\n-        let or: BoxRefMut<Example> = Box::new(example()).into();\n-        let or: BoxRef<_, str> = or.map(|x| &mut x.1[..5]);\n-        assert_eq!(&*or, \"hello\");\n-    }\n-\n-    #[test]\n-    fn map_static_ref() {\n-        let or: BoxRefMut<()> = Box::new(()).into();\n-        let or: BoxRef<_, str> = or.map(|_| \"hello\");\n-        assert_eq!(&*or, \"hello\");\n-    }\n-\n-    #[test]\n-    fn map_mut_offset_ref() {\n-        let or: BoxRefMut<Example> = Box::new(example()).into();\n-        let or: BoxRefMut<_, u32> = or.map_mut(|x| &mut x.0);\n-        assert_eq!(&*or, &42);\n-\n-        let or: BoxRefMut<Example> = Box::new(example()).into();\n-        let or: BoxRefMut<_, u8> = or.map_mut(|x| &mut x.2[1]);\n-        assert_eq!(&*or, &2);\n-    }\n-\n-    #[test]\n-    fn map_mut_heap_ref() {\n-        let or: BoxRefMut<Example> = Box::new(example()).into();\n-        let or: BoxRefMut<_, str> = or.map_mut(|x| &mut x.1[..5]);\n-        assert_eq!(&*or, \"hello\");\n-    }\n-\n-    #[test]\n-    fn map_mut_static_ref() {\n-        static mut MUT_S: [u8; 5] = *b\"hello\";\n-\n-        let mut_s: &'static mut [u8] = unsafe { &mut MUT_S };\n-\n-        let or: BoxRefMut<()> = Box::new(()).into();\n-        let or: BoxRefMut<_, [u8]> = or.map_mut(move |_| mut_s);\n-        assert_eq!(&*or, b\"hello\");\n-    }\n-\n-    #[test]\n-    fn map_mut_chained() {\n-        let or: BoxRefMut<String> = Box::new(example().1).into();\n-        let or: BoxRefMut<_, str> = or.map_mut(|x| &mut x[1..5]);\n-        let or: BoxRefMut<_, str> = or.map_mut(|x| &mut x[..2]);\n-        assert_eq!(&*or, \"el\");\n-    }\n-\n-    #[test]\n-    fn map_chained_inference() {\n-        let or = BoxRefMut::new(Box::new(example().1))\n-            .map_mut(|x| &mut x[..5])\n-            .map_mut(|x| &mut x[1..3]);\n-        assert_eq!(&*or, \"el\");\n-    }\n-\n-    #[test]\n-    fn try_map_mut() {\n-        let or: BoxRefMut<String> = Box::new(example().1).into();\n-        let or: Result<BoxRefMut<_, str>, ()> = or.try_map_mut(|x| Ok(&mut x[1..5]));\n-        assert_eq!(&*or.unwrap(), \"ello\");\n-\n-        let or: BoxRefMut<String> = Box::new(example().1).into();\n-        let or: Result<BoxRefMut<_, str>, ()> = or.try_map_mut(|_| Err(()));\n-        assert!(or.is_err());\n-    }\n-\n-    #[test]\n-    fn owner() {\n-        let or: BoxRefMut<String> = Box::new(example().1).into();\n-        let or = or.map_mut(|x| &mut x[..5]);\n-        assert_eq!(&*or, \"hello\");\n-        assert_eq!(&**or.owner(), \"hello world\");\n-    }\n-\n-    #[test]\n-    fn into_inner() {\n-        let or: BoxRefMut<String> = Box::new(example().1).into();\n-        let or = or.map_mut(|x| &mut x[..5]);\n-        assert_eq!(&*or, \"hello\");\n-        let s = *or.into_inner();\n-        assert_eq!(&s, \"hello world\");\n-    }\n-\n-    #[test]\n-    fn fmt_debug() {\n-        let or: BoxRefMut<String> = Box::new(example().1).into();\n-        let or = or.map_mut(|x| &mut x[..5]);\n-        let s = format!(\"{:?}\", or);\n-        assert_eq!(&s, \"OwningRefMut { owner: \\\"hello world\\\", reference: \\\"hello\\\" }\");\n-    }\n-\n-    #[test]\n-    fn erased_owner() {\n-        let o1: BoxRefMut<Example, str> =\n-            BoxRefMut::new(Box::new(example())).map_mut(|x| &mut x.1[..]);\n-\n-        let o2: BoxRefMut<String, str> =\n-            BoxRefMut::new(Box::new(example().1)).map_mut(|x| &mut x[..]);\n-\n-        let os: Vec<ErasedBoxRefMut<str>> = vec![o1.erase_owner(), o2.erase_owner()];\n-        assert!(os.iter().all(|e| &e[..] == \"hello world\"));\n-    }\n-\n-    #[test]\n-    fn raii_locks() {\n-        use super::super::RefMutRefMut;\n-        use super::super::{MutexGuardRefMut, RwLockWriteGuardRefMut};\n-        use std::cell::RefCell;\n-        use std::sync::{Mutex, RwLock};\n-\n-        {\n-            let a = RefCell::new(1);\n-            let a = {\n-                let a = RefMutRefMut::new(a.borrow_mut());\n-                assert_eq!(*a, 1);\n-                a\n-            };\n-            assert_eq!(*a, 1);\n-            drop(a);\n-        }\n-        {\n-            let a = Mutex::new(1);\n-            let a = {\n-                let a = MutexGuardRefMut::new(a.lock().unwrap());\n-                assert_eq!(*a, 1);\n-                a\n-            };\n-            assert_eq!(*a, 1);\n-            drop(a);\n-        }\n-        {\n-            let a = RwLock::new(1);\n-            let a = {\n-                let a = RwLockWriteGuardRefMut::new(a.write().unwrap());\n-                assert_eq!(*a, 1);\n-                a\n-            };\n-            assert_eq!(*a, 1);\n-            drop(a);\n-        }\n-    }\n-\n-    #[test]\n-    fn eq() {\n-        let or1: BoxRefMut<[u8]> = BoxRefMut::new(vec![1, 2, 3].into_boxed_slice());\n-        let or2: BoxRefMut<[u8]> = BoxRefMut::new(vec![1, 2, 3].into_boxed_slice());\n-        assert_eq!(or1.eq(&or2), true);\n-    }\n-\n-    #[test]\n-    fn cmp() {\n-        let or1: BoxRefMut<[u8]> = BoxRefMut::new(vec![1, 2, 3].into_boxed_slice());\n-        let or2: BoxRefMut<[u8]> = BoxRefMut::new(vec![4, 5, 6].into_boxed_slice());\n-        assert_eq!(or1.cmp(&or2), Ordering::Less);\n-    }\n-\n-    #[test]\n-    fn partial_cmp() {\n-        let or1: BoxRefMut<[u8]> = BoxRefMut::new(vec![4, 5, 6].into_boxed_slice());\n-        let or2: BoxRefMut<[u8]> = BoxRefMut::new(vec![1, 2, 3].into_boxed_slice());\n-        assert_eq!(or1.partial_cmp(&or2), Some(Ordering::Greater));\n-    }\n-\n-    #[test]\n-    fn hash() {\n-        let mut h1 = DefaultHasher::new();\n-        let mut h2 = DefaultHasher::new();\n-\n-        let or1: BoxRefMut<[u8]> = BoxRefMut::new(vec![1, 2, 3].into_boxed_slice());\n-        let or2: BoxRefMut<[u8]> = BoxRefMut::new(vec![1, 2, 3].into_boxed_slice());\n-\n-        or1.hash(&mut h1);\n-        or2.hash(&mut h2);\n-\n-        assert_eq!(h1.finish(), h2.finish());\n-    }\n-\n-    #[test]\n-    fn borrow() {\n-        let mut hash = HashMap::new();\n-        let key1 = BoxRefMut::<String>::new(Box::new(\"foo\".to_string())).map(|s| &s[..]);\n-        let key2 = BoxRefMut::<String>::new(Box::new(\"bar\".to_string())).map(|s| &s[..]);\n-\n-        hash.insert(key1, 42);\n-        hash.insert(key2, 23);\n-\n-        assert_eq!(hash.get(\"foo\"), Some(&42));\n-        assert_eq!(hash.get(\"bar\"), Some(&23));\n-    }\n-\n-    #[test]\n-    fn total_erase() {\n-        let a: OwningRefMut<Vec<u8>, [u8]> = OwningRefMut::new(vec![]).map_mut(|x| &mut x[..]);\n-        let b: OwningRefMut<Box<[u8]>, [u8]> =\n-            OwningRefMut::new(vec![].into_boxed_slice()).map_mut(|x| &mut x[..]);\n-\n-        let c: OwningRefMut<Box<Vec<u8>>, [u8]> = unsafe { a.map_owner(Box::new) };\n-        let d: OwningRefMut<Box<Box<[u8]>>, [u8]> = unsafe { b.map_owner(Box::new) };\n-\n-        let _e: OwningRefMut<Box<dyn Erased>, [u8]> = c.erase_owner();\n-        let _f: OwningRefMut<Box<dyn Erased>, [u8]> = d.erase_owner();\n-    }\n-\n-    #[test]\n-    fn total_erase_box() {\n-        let a: OwningRefMut<Vec<u8>, [u8]> = OwningRefMut::new(vec![]).map_mut(|x| &mut x[..]);\n-        let b: OwningRefMut<Box<[u8]>, [u8]> =\n-            OwningRefMut::new(vec![].into_boxed_slice()).map_mut(|x| &mut x[..]);\n-\n-        let c: OwningRefMut<Box<Vec<u8>>, [u8]> = a.map_owner_box();\n-        let d: OwningRefMut<Box<Box<[u8]>>, [u8]> = b.map_owner_box();\n-\n-        let _e: OwningRefMut<Box<dyn Erased>, [u8]> = c.erase_owner();\n-        let _f: OwningRefMut<Box<dyn Erased>, [u8]> = d.erase_owner();\n-    }\n-\n-    #[test]\n-    fn try_map1() {\n-        use std::any::Any;\n-\n-        let x = Box::new(123_i32);\n-        let y: Box<dyn Any> = x;\n-\n-        assert!(OwningRefMut::new(y).try_map_mut(|x| x.downcast_mut::<i32>().ok_or(())).is_ok());\n-    }\n-\n-    #[test]\n-    fn try_map2() {\n-        use std::any::Any;\n-\n-        let x = Box::new(123_i32);\n-        let y: Box<dyn Any> = x;\n-\n-        assert!(!OwningRefMut::new(y).try_map_mut(|x| x.downcast_mut::<i32>().ok_or(())).is_err());\n-    }\n-\n-    #[test]\n-    fn try_map3() {\n-        use std::any::Any;\n-\n-        let x = Box::new(123_i32);\n-        let y: Box<dyn Any> = x;\n-\n-        assert!(OwningRefMut::new(y).try_map(|x| x.downcast_ref::<i32>().ok_or(())).is_ok());\n-    }\n-\n-    #[test]\n-    fn try_map4() {\n-        use std::any::Any;\n-\n-        let x = Box::new(123_i32);\n-        let y: Box<dyn Any> = x;\n-\n-        assert!(!OwningRefMut::new(y).try_map(|x| x.downcast_ref::<i32>().ok_or(())).is_err());\n-    }\n-\n-    #[test]\n-    fn into_owning_ref() {\n-        use super::super::BoxRef;\n-\n-        let or: BoxRefMut<()> = Box::new(()).into();\n-        let or: BoxRef<()> = or.into();\n-        assert_eq!(&*or, &());\n-    }\n-\n-    struct Foo {\n-        u: u32,\n-    }\n-    struct Bar {\n-        f: Foo,\n-    }\n-\n-    #[test]\n-    fn ref_mut() {\n-        use std::cell::RefCell;\n-\n-        let a = RefCell::new(Bar { f: Foo { u: 42 } });\n-        let mut b = OwningRefMut::new(a.borrow_mut());\n-        assert_eq!(b.f.u, 42);\n-        b.f.u = 43;\n-        let mut c = b.map_mut(|x| &mut x.f);\n-        assert_eq!(c.u, 43);\n-        c.u = 44;\n-        let mut d = c.map_mut(|x| &mut x.u);\n-        assert_eq!(*d, 44);\n-        *d = 45;\n-        assert_eq!(*d, 45);\n-    }\n-}"}, {"sha": "ef1da85198fd4049c41eb3cf83e184a391a6e56f", "filename": "compiler/rustc_data_structures/src/sync.rs", "status": "modified", "additions": 7, "deletions": 26, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/0f0dc292641cb29f441e979ea26f10e1402b931f/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f0dc292641cb29f441e979ea26f10e1402b931f/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs?ref=0f0dc292641cb29f441e979ea26f10e1402b931f", "patch": "@@ -7,9 +7,6 @@\n //! while the serial versions degenerate straightforwardly to serial execution.\n //! The operations include `join`, `parallel`, `par_iter`, and `par_for_each`.\n //!\n-//! `rustc_erase_owner!` erases an `OwningRef` owner into `Erased` for the\n-//! serial version and `Erased + Send + Sync` for the parallel version.\n-//!\n //! Types\n //! -----\n //! The parallel versions of types provide various kinds of synchronization,\n@@ -42,7 +39,7 @@\n //!\n //! [^2] `MTLockRef` is a typedef.\n \n-use crate::owning_ref::{Erased, OwningRef};\n+use crate::owned_slice::OwnedSlice;\n use std::collections::HashMap;\n use std::hash::{BuildHasher, Hash};\n use std::ops::{Deref, DerefMut};\n@@ -57,18 +54,11 @@ mod vec;\n \n cfg_if! {\n     if #[cfg(not(parallel_compiler))] {\n-        pub auto trait Send {}\n-        pub auto trait Sync {}\n-\n-        impl<T> Send for T {}\n-        impl<T> Sync for T {}\n+        pub unsafe auto trait Send {}\n+        pub unsafe auto trait Sync {}\n \n-        #[macro_export]\n-        macro_rules! rustc_erase_owner {\n-            ($v:expr) => {\n-                $v.erase_owner()\n-            }\n-        }\n+        unsafe impl<T> Send for T {}\n+        unsafe impl<T> Sync for T {}\n \n         use std::ops::Add;\n \n@@ -197,7 +187,7 @@ cfg_if! {\n             }\n         }\n \n-        pub type MetadataRef = OwningRef<Box<dyn Erased>, [u8]>;\n+        pub type MetadataRef = OwnedSlice;\n \n         pub use std::rc::Rc as Lrc;\n         pub use std::rc::Weak as Weak;\n@@ -380,20 +370,11 @@ cfg_if! {\n             });\n         }\n \n-        pub type MetadataRef = OwningRef<Box<dyn Erased + Send + Sync>, [u8]>;\n+        pub type MetadataRef = OwnedSlice;\n \n         /// This makes locks panic if they are already held.\n         /// It is only useful when you are running in a single thread\n         const ERROR_CHECKING: bool = false;\n-\n-        #[macro_export]\n-        macro_rules! rustc_erase_owner {\n-            ($v:expr) => {{\n-                let v = $v;\n-                ::rustc_data_structures::sync::assert_send_val(&v);\n-                v.erase_send_sync_owner()\n-            }}\n-        }\n     }\n }\n "}, {"sha": "81e62eccb8a59feb37d6a0197a402352992ba579", "filename": "compiler/rustc_metadata/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f0dc292641cb29f441e979ea26f10e1402b931f/compiler%2Frustc_metadata%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f0dc292641cb29f441e979ea26f10e1402b931f/compiler%2Frustc_metadata%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flib.rs?ref=0f0dc292641cb29f441e979ea26f10e1402b931f", "patch": "@@ -22,8 +22,6 @@ extern crate proc_macro;\n extern crate rustc_macros;\n #[macro_use]\n extern crate rustc_middle;\n-#[macro_use]\n-extern crate rustc_data_structures;\n \n #[macro_use]\n extern crate tracing;"}, {"sha": "2515269ea2ff2ec29d17e307714efacd315817a5", "filename": "compiler/rustc_metadata/src/locator.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0f0dc292641cb29f441e979ea26f10e1402b931f/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f0dc292641cb29f441e979ea26f10e1402b931f/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs?ref=0f0dc292641cb29f441e979ea26f10e1402b931f", "patch": "@@ -218,7 +218,7 @@ use crate::rmeta::{rustc_version, MetadataBlob, METADATA_HEADER};\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::memmap::Mmap;\n-use rustc_data_structures::owning_ref::OwningRef;\n+use rustc_data_structures::owned_slice::slice_owned;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::MetadataRef;\n use rustc_errors::{DiagnosticArgValue, FatalError, IntoDiagnosticArg};\n@@ -236,6 +236,7 @@ use rustc_target::spec::{Target, TargetTriple};\n use snap::read::FrameDecoder;\n use std::borrow::Cow;\n use std::io::{Read, Result as IoResult, Write};\n+use std::ops::Deref;\n use std::path::{Path, PathBuf};\n use std::{cmp, fmt};\n \n@@ -814,15 +815,14 @@ fn get_metadata_section<'p>(\n             // Assume the decompressed data will be at least the size of the compressed data, so we\n             // don't have to grow the buffer as much.\n             let mut inflated = Vec::with_capacity(compressed_bytes.len());\n-            match FrameDecoder::new(compressed_bytes).read_to_end(&mut inflated) {\n-                Ok(_) => rustc_erase_owner!(OwningRef::new(inflated).map_owner_box()),\n-                Err(_) => {\n-                    return Err(MetadataError::LoadFailure(format!(\n-                        \"failed to decompress metadata: {}\",\n-                        filename.display()\n-                    )));\n-                }\n-            }\n+            FrameDecoder::new(compressed_bytes).read_to_end(&mut inflated).map_err(|_| {\n+                MetadataError::LoadFailure(format!(\n+                    \"failed to decompress metadata: {}\",\n+                    filename.display()\n+                ))\n+            })?;\n+\n+            slice_owned(inflated, Deref::deref)\n         }\n         CrateFlavor::Rmeta => {\n             // mmap the file, because only a small fraction of it is read.\n@@ -840,7 +840,7 @@ fn get_metadata_section<'p>(\n                 ))\n             })?;\n \n-            rustc_erase_owner!(OwningRef::new(mmap).map_owner_box())\n+            slice_owned(mmap, Deref::deref)\n         }\n     };\n     let blob = MetadataBlob::new(raw_bytes);"}, {"sha": "852c6d964694de22f55a31b0222a6c2e5a222265", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f0dc292641cb29f441e979ea26f10e1402b931f/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f0dc292641cb29f441e979ea26f10e1402b931f/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=0f0dc292641cb29f441e979ea26f10e1402b931f", "patch": "@@ -51,12 +51,6 @@ mod cstore_impl;\n #[derive(Clone)]\n pub(crate) struct MetadataBlob(Lrc<MetadataRef>);\n \n-// This is needed so we can create an OwningRef into the blob.\n-// The data behind a `MetadataBlob` has a stable address because it is\n-// contained within an Rc/Arc.\n-unsafe impl rustc_data_structures::owning_ref::StableAddress for MetadataBlob {}\n-\n-// This is needed so we can create an OwningRef into the blob.\n impl std::ops::Deref for MetadataBlob {\n     type Target = [u8];\n "}, {"sha": "02cab561b8f612dac707b678f9db2f97a2254a7b", "filename": "compiler/rustc_metadata/src/rmeta/def_path_hash_map.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0f0dc292641cb29f441e979ea26f10e1402b931f/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdef_path_hash_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f0dc292641cb29f441e979ea26f10e1402b931f/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdef_path_hash_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdef_path_hash_map.rs?ref=0f0dc292641cb29f441e979ea26f10e1402b931f", "patch": "@@ -1,14 +1,14 @@\n use crate::rmeta::DecodeContext;\n use crate::rmeta::EncodeContext;\n-use crate::rmeta::MetadataBlob;\n-use rustc_data_structures::owning_ref::OwningRef;\n+use rustc_data_structures::owned_slice::slice_owned;\n+use rustc_data_structures::owned_slice::OwnedSlice;\n use rustc_hir::def_path_hash_map::{Config as HashMapConfig, DefPathHashMap};\n use rustc_middle::parameterized_over_tcx;\n use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n use rustc_span::def_id::{DefIndex, DefPathHash};\n \n pub(crate) enum DefPathHashMapRef<'tcx> {\n-    OwnedFromMetadata(odht::HashTable<HashMapConfig, OwningRef<MetadataBlob, [u8]>>),\n+    OwnedFromMetadata(odht::HashTable<HashMapConfig, OwnedSlice>),\n     BorrowedFromTcx(&'tcx DefPathHashMap),\n }\n \n@@ -50,11 +50,11 @@ impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for DefPathHashMapRef<'static>\n \n         let len = d.read_usize();\n         let pos = d.position();\n-        let o = OwningRef::new(d.blob().clone()).map(|x| &x[pos..pos + len]);\n+        let o = slice_owned(d.blob().clone(), |blob| &blob[pos..pos + len]);\n \n-        // Although we already have the data we need via the OwningRef, we still need\n-        // to advance the DecodeContext's position so it's in a valid state after\n-        // the method. We use read_raw_bytes() for that.\n+        // Although we already have the data we need via the `OwnedSlice`, we still need\n+        // to advance the `DecodeContext`'s position so it's in a valid state after\n+        // the method. We use `read_raw_bytes()` for that.\n         let _ = d.read_raw_bytes(len);\n \n         let inner = odht::HashTable::from_raw_bytes(o).unwrap_or_else(|e| {"}]}