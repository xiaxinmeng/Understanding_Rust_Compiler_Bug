{"sha": "c3b78f440e1978a84f7224fe443086c1c91254a1", "node_id": "C_kwDOAAsO6NoAKGMzYjc4ZjQ0MGUxOTc4YTg0ZjcyMjRmZTQ0MzA4NmMxYzkxMjU0YTE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-10T17:35:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-10T17:35:37Z"}, "message": "Auto merge of #13917 - Veykril:raw-attrs, r=Veykril\n\nSplit out hir-def attribute handling parts into hir-expand\n\nThis should help with `cfg_attr` handling for macro inputs", "tree": {"sha": "77e248274f8394be55591b0c0ab0f60aa062dc17", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/77e248274f8394be55591b0c0ab0f60aa062dc17"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c3b78f440e1978a84f7224fe443086c1c91254a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c3b78f440e1978a84f7224fe443086c1c91254a1", "html_url": "https://github.com/rust-lang/rust/commit/c3b78f440e1978a84f7224fe443086c1c91254a1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c3b78f440e1978a84f7224fe443086c1c91254a1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "674b52aaaa3a4a49678d16c28fa2b2290cc07d41", "url": "https://api.github.com/repos/rust-lang/rust/commits/674b52aaaa3a4a49678d16c28fa2b2290cc07d41", "html_url": "https://github.com/rust-lang/rust/commit/674b52aaaa3a4a49678d16c28fa2b2290cc07d41"}, {"sha": "621e96bd6ad0cf35c4dc4d1cfd8f6bc83096946f", "url": "https://api.github.com/repos/rust-lang/rust/commits/621e96bd6ad0cf35c4dc4d1cfd8f6bc83096946f", "html_url": "https://github.com/rust-lang/rust/commit/621e96bd6ad0cf35c4dc4d1cfd8f6bc83096946f"}], "stats": {"total": 920, "additions": 510, "deletions": 410}, "files": [{"sha": "5f426d8856263aa38a71c457c27d4a280cc274d5", "filename": "Cargo.lock", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c3b78f440e1978a84f7224fe443086c1c91254a1/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/c3b78f440e1978a84f7224fe443086c1c91254a1/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=c3b78f440e1978a84f7224fe443086c1c91254a1", "patch": "@@ -519,6 +519,7 @@ dependencies = [\n  \"hkalbasi-rustc-ap-rustc_abi\",\n  \"hkalbasi-rustc-ap-rustc_index\",\n  \"indexmap\",\n+ \"intern\",\n  \"itertools\",\n  \"la-arena\",\n  \"limit\",\n@@ -544,6 +545,7 @@ dependencies = [\n  \"either\",\n  \"expect-test\",\n  \"hashbrown\",\n+ \"intern\",\n  \"itertools\",\n  \"la-arena\",\n  \"limit\",\n@@ -574,6 +576,7 @@ dependencies = [\n  \"hir-def\",\n  \"hir-expand\",\n  \"hkalbasi-rustc-ap-rustc_index\",\n+ \"intern\",\n  \"itertools\",\n  \"la-arena\",\n  \"limit\",\n@@ -803,6 +806,16 @@ dependencies = [\n  \"cfg-if\",\n ]\n \n+[[package]]\n+name = \"intern\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"dashmap\",\n+ \"hashbrown\",\n+ \"once_cell\",\n+ \"rustc-hash\",\n+]\n+\n [[package]]\n name = \"itertools\"\n version = \"0.10.5\""}, {"sha": "a1078427707b9c2f8b0a896da68e794e93cfd065", "filename": "crates/hir-def/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-def%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-def%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2FCargo.toml?ref=c3b78f440e1978a84f7224fe443086c1c91254a1", "patch": "@@ -29,6 +29,7 @@ smallvec = \"1.10.0\"\n tracing = \"0.1.35\"\n \n stdx = { path = \"../stdx\", version = \"0.0.0\" }\n+intern = { path = \"../intern\", version = \"0.0.0\" }\n base-db = { path = \"../base-db\", version = \"0.0.0\" }\n syntax = { path = \"../syntax\", version = \"0.0.0\" }\n profile = { path = \"../profile\", version = \"0.0.0\" }"}, {"sha": "cd35ba00f6f52398a40c55aae41a89ebdfd87777", "filename": "crates/hir-def/src/adt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-def%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-def%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fadt.rs?ref=c3b78f440e1978a84f7224fe443086c1c91254a1", "patch": "@@ -8,6 +8,7 @@ use hir_expand::{\n     name::{AsName, Name},\n     HirFileId, InFile,\n };\n+use intern::Interned;\n use la_arena::{Arena, ArenaMap};\n use rustc_abi::{Integer, IntegerType};\n use syntax::ast::{self, HasName, HasVisibility};\n@@ -17,7 +18,6 @@ use crate::{\n     body::{CfgExpander, LowerCtx},\n     builtin_type::{BuiltinInt, BuiltinUint},\n     db::DefDatabase,\n-    intern::Interned,\n     item_tree::{AttrOwner, Field, FieldAstId, Fields, ItemTree, ModItem, RawVisibilityId},\n     layout::{Align, ReprFlags, ReprOptions},\n     nameres::diagnostics::DefDiagnostic,"}, {"sha": "a0113fd048ce5f008e81ce251d5a54819117e9fa", "filename": "crates/hir-def/src/attr.rs", "status": "modified", "additions": 20, "deletions": 314, "changes": 334, "blob_url": "https://github.com/rust-lang/rust/blob/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fattr.rs?ref=c3b78f440e1978a84f7224fe443086c1c91254a1", "patch": "@@ -1,27 +1,27 @@\n //! A higher level attributes based on TokenTree, with also some shortcuts.\n \n-use std::{fmt, hash::Hash, ops, sync::Arc};\n+use std::{hash::Hash, ops, sync::Arc};\n \n use base_db::CrateId;\n use cfg::{CfgExpr, CfgOptions};\n use either::Either;\n-use hir_expand::{hygiene::Hygiene, name::AsName, HirFileId, InFile};\n+use hir_expand::{\n+    attrs::{collect_attrs, Attr, AttrId, RawAttrs},\n+    HirFileId, InFile,\n+};\n use itertools::Itertools;\n use la_arena::{ArenaMap, Idx, RawIdx};\n-use mbe::{syntax_node_to_token_tree, DelimiterKind, Punct};\n-use smallvec::{smallvec, SmallVec};\n+use mbe::DelimiterKind;\n use syntax::{\n-    ast::{self, AstNode, HasAttrs, IsString},\n-    match_ast, AstPtr, AstToken, SmolStr, SyntaxNode, TextRange, TextSize,\n+    ast::{self, HasAttrs, IsString},\n+    AstPtr, AstToken, SmolStr, TextRange, TextSize,\n };\n use tt::Subtree;\n \n use crate::{\n     db::DefDatabase,\n-    intern::Interned,\n     item_tree::{AttrOwner, Fields, ItemTreeId, ItemTreeNode},\n     nameres::{ModuleOrigin, ModuleSource},\n-    path::{ModPath, PathKind},\n     src::{HasChildSource, HasSource},\n     AdtId, AttrDefId, EnumId, GenericParamId, LocalEnumVariantId, LocalFieldId, Lookup, MacroId,\n     VariantId,\n@@ -47,12 +47,6 @@ impl From<Documentation> for String {\n     }\n }\n \n-/// Syntactical attributes, without filtering of `cfg_attr`s.\n-#[derive(Default, Debug, Clone, PartialEq, Eq)]\n-pub(crate) struct RawAttrs {\n-    entries: Option<Arc<[Attr]>>,\n-}\n-\n #[derive(Default, Debug, Clone, PartialEq, Eq)]\n pub struct Attrs(RawAttrs);\n \n@@ -62,30 +56,21 @@ pub struct AttrsWithOwner {\n     owner: AttrDefId,\n }\n \n-impl ops::Deref for RawAttrs {\n-    type Target = [Attr];\n-\n-    fn deref(&self) -> &[Attr] {\n-        match &self.entries {\n-            Some(it) => &*it,\n-            None => &[],\n-        }\n-    }\n-}\n impl Attrs {\n     pub fn get(&self, id: AttrId) -> Option<&Attr> {\n         (**self).iter().find(|attr| attr.id == id)\n     }\n+\n+    pub(crate) fn filter(db: &dyn DefDatabase, krate: CrateId, raw_attrs: RawAttrs) -> Attrs {\n+        Attrs(raw_attrs.filter(db.upcast(), krate))\n+    }\n }\n \n impl ops::Deref for Attrs {\n     type Target = [Attr];\n \n     fn deref(&self) -> &[Attr] {\n-        match &self.0.entries {\n-            Some(it) => &*it,\n-            None => &[],\n-        }\n+        &self.0\n     }\n }\n \n@@ -97,114 +82,6 @@ impl ops::Deref for AttrsWithOwner {\n     }\n }\n \n-impl RawAttrs {\n-    pub(crate) const EMPTY: Self = Self { entries: None };\n-\n-    pub(crate) fn new(db: &dyn DefDatabase, owner: &dyn ast::HasAttrs, hygiene: &Hygiene) -> Self {\n-        let entries = collect_attrs(owner)\n-            .filter_map(|(id, attr)| match attr {\n-                Either::Left(attr) => {\n-                    attr.meta().and_then(|meta| Attr::from_src(db, meta, hygiene, id))\n-                }\n-                Either::Right(comment) => comment.doc_comment().map(|doc| Attr {\n-                    id,\n-                    input: Some(Interned::new(AttrInput::Literal(SmolStr::new(doc)))),\n-                    path: Interned::new(ModPath::from(hir_expand::name!(doc))),\n-                }),\n-            })\n-            .collect::<Arc<_>>();\n-\n-        Self { entries: if entries.is_empty() { None } else { Some(entries) } }\n-    }\n-\n-    fn from_attrs_owner(db: &dyn DefDatabase, owner: InFile<&dyn ast::HasAttrs>) -> Self {\n-        let hygiene = Hygiene::new(db.upcast(), owner.file_id);\n-        Self::new(db, owner.value, &hygiene)\n-    }\n-\n-    pub(crate) fn merge(&self, other: Self) -> Self {\n-        // FIXME: This needs to fixup `AttrId`s\n-        match (&self.entries, other.entries) {\n-            (None, None) => Self::EMPTY,\n-            (None, entries @ Some(_)) => Self { entries },\n-            (Some(entries), None) => Self { entries: Some(entries.clone()) },\n-            (Some(a), Some(b)) => {\n-                let last_ast_index = a.last().map_or(0, |it| it.id.ast_index + 1);\n-                Self {\n-                    entries: Some(\n-                        a.iter()\n-                            .cloned()\n-                            .chain(b.iter().map(|it| {\n-                                let mut it = it.clone();\n-                                it.id.ast_index += last_ast_index;\n-                                it\n-                            }))\n-                            .collect(),\n-                    ),\n-                }\n-            }\n-        }\n-    }\n-\n-    /// Processes `cfg_attr`s, returning the resulting semantic `Attrs`.\n-    pub(crate) fn filter(self, db: &dyn DefDatabase, krate: CrateId) -> Attrs {\n-        let has_cfg_attrs = self.iter().any(|attr| {\n-            attr.path.as_ident().map_or(false, |name| *name == hir_expand::name![cfg_attr])\n-        });\n-        if !has_cfg_attrs {\n-            return Attrs(self);\n-        }\n-\n-        let crate_graph = db.crate_graph();\n-        let new_attrs = self\n-            .iter()\n-            .flat_map(|attr| -> SmallVec<[_; 1]> {\n-                let is_cfg_attr =\n-                    attr.path.as_ident().map_or(false, |name| *name == hir_expand::name![cfg_attr]);\n-                if !is_cfg_attr {\n-                    return smallvec![attr.clone()];\n-                }\n-\n-                let subtree = match attr.token_tree_value() {\n-                    Some(it) => it,\n-                    _ => return smallvec![attr.clone()],\n-                };\n-\n-                // Input subtree is: `(cfg, $(attr),+)`\n-                // Split it up into a `cfg` subtree and the `attr` subtrees.\n-                // FIXME: There should be a common API for this.\n-                let mut parts = subtree.token_trees.split(|tt| {\n-                    matches!(tt, tt::TokenTree::Leaf(tt::Leaf::Punct(Punct { char: ',', .. })))\n-                });\n-                let cfg = match parts.next() {\n-                    Some(it) => it,\n-                    None => return smallvec![],\n-                };\n-                let cfg = Subtree { delimiter: subtree.delimiter, token_trees: cfg.to_vec() };\n-                let cfg = CfgExpr::parse(&cfg);\n-                let index = attr.id;\n-                let attrs = parts.filter(|a| !a.is_empty()).filter_map(|attr| {\n-                    let tree = Subtree { delimiter: None, token_trees: attr.to_vec() };\n-                    // FIXME hygiene\n-                    let hygiene = Hygiene::new_unhygienic();\n-                    Attr::from_tt(db, &tree, &hygiene, index)\n-                });\n-\n-                let cfg_options = &crate_graph[krate].cfg_options;\n-                if cfg_options.check(&cfg) == Some(false) {\n-                    smallvec![]\n-                } else {\n-                    cov_mark::hit!(cfg_attr_active);\n-\n-                    attrs.collect()\n-                }\n-            })\n-            .collect();\n-\n-        Attrs(RawAttrs { entries: Some(new_attrs) })\n-    }\n-}\n-\n impl Attrs {\n     pub const EMPTY: Self = Self(RawAttrs::EMPTY);\n \n@@ -403,7 +280,7 @@ impl AttrsWithOwner {\n                         .raw_attrs(AttrOwner::ModItem(definition_tree_id.value.into()))\n                         .clone(),\n                     ModuleOrigin::BlockExpr { block } => RawAttrs::from_attrs_owner(\n-                        db,\n+                        db.upcast(),\n                         InFile::new(block.file_id, block.to_node(db.upcast()))\n                             .as_ref()\n                             .map(|it| it as &dyn ast::HasAttrs),\n@@ -439,7 +316,7 @@ impl AttrsWithOwner {\n                 GenericParamId::ConstParamId(it) => {\n                     let src = it.parent().child_source(db);\n                     RawAttrs::from_attrs_owner(\n-                        db,\n+                        db.upcast(),\n                         src.with_value(src.value[it.local_id()].as_ref().either(\n                             |it| match it {\n                                 ast::TypeOrConstParam::Type(it) => it as _,\n@@ -452,7 +329,7 @@ impl AttrsWithOwner {\n                 GenericParamId::TypeParamId(it) => {\n                     let src = it.parent().child_source(db);\n                     RawAttrs::from_attrs_owner(\n-                        db,\n+                        db.upcast(),\n                         src.with_value(src.value[it.local_id()].as_ref().either(\n                             |it| match it {\n                                 ast::TypeOrConstParam::Type(it) => it as _,\n@@ -464,14 +341,14 @@ impl AttrsWithOwner {\n                 }\n                 GenericParamId::LifetimeParamId(it) => {\n                     let src = it.parent.child_source(db);\n-                    RawAttrs::from_attrs_owner(db, src.with_value(&src.value[it.local_id]))\n+                    RawAttrs::from_attrs_owner(db.upcast(), src.with_value(&src.value[it.local_id]))\n                 }\n             },\n             AttrDefId::ExternBlockId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n         };\n \n-        let attrs = raw_attrs.filter(db, def.krate(db));\n-        Self { attrs, owner: def }\n+        let attrs = raw_attrs.filter(db.upcast(), def.krate(db));\n+        Self { attrs: Attrs(attrs), owner: def }\n     }\n \n     pub fn source_map(&self, db: &dyn DefDatabase) -> AttrSourceMap {\n@@ -627,40 +504,6 @@ fn doc_indent(attrs: &Attrs) -> usize {\n         .unwrap_or(0)\n }\n \n-fn inner_attributes(\n-    syntax: &SyntaxNode,\n-) -> Option<impl Iterator<Item = Either<ast::Attr, ast::Comment>>> {\n-    let node = match_ast! {\n-        match syntax {\n-            ast::SourceFile(_) => syntax.clone(),\n-            ast::ExternBlock(it) => it.extern_item_list()?.syntax().clone(),\n-            ast::Fn(it) => it.body()?.stmt_list()?.syntax().clone(),\n-            ast::Impl(it) => it.assoc_item_list()?.syntax().clone(),\n-            ast::Module(it) => it.item_list()?.syntax().clone(),\n-            ast::BlockExpr(it) => {\n-                use syntax::SyntaxKind::{BLOCK_EXPR , EXPR_STMT};\n-                // Block expressions accept outer and inner attributes, but only when they are the outer\n-                // expression of an expression statement or the final expression of another block expression.\n-                let may_carry_attributes = matches!(\n-                    it.syntax().parent().map(|it| it.kind()),\n-                     Some(BLOCK_EXPR | EXPR_STMT)\n-                );\n-                if !may_carry_attributes {\n-                    return None\n-                }\n-                syntax.clone()\n-            },\n-            _ => return None,\n-        }\n-    };\n-\n-    let attrs = ast::AttrDocCommentIter::from_syntax_node(&node).filter(|el| match el {\n-        Either::Left(attr) => attr.kind().is_inner(),\n-        Either::Right(comment) => comment.is_inner(),\n-    });\n-    Some(attrs)\n-}\n-\n #[derive(Debug)]\n pub struct AttrSourceMap {\n     source: Vec<Either<ast::Attr, ast::Comment>>,\n@@ -703,7 +546,7 @@ impl AttrSourceMap {\n     }\n \n     fn source_of_id(&self, id: AttrId) -> InFile<&Either<ast::Attr, ast::Comment>> {\n-        let ast_idx = id.ast_index as usize;\n+        let ast_idx = id.ast_index();\n         let file_id = match self.mod_def_site_file_id {\n             Some((file_id, def_site_cut)) if def_site_cut <= ast_idx => file_id,\n             _ => self.file_id,\n@@ -779,128 +622,6 @@ fn get_doc_string_in_attr(it: &ast::Attr) -> Option<ast::String> {\n     }\n }\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct AttrId {\n-    pub(crate) ast_index: u32,\n-}\n-\n-#[derive(Debug, Clone, PartialEq, Eq)]\n-pub struct Attr {\n-    pub(crate) id: AttrId,\n-    pub(crate) path: Interned<ModPath>,\n-    pub(crate) input: Option<Interned<AttrInput>>,\n-}\n-\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub enum AttrInput {\n-    /// `#[attr = \"string\"]`\n-    Literal(SmolStr),\n-    /// `#[attr(subtree)]`\n-    TokenTree(tt::Subtree, mbe::TokenMap),\n-}\n-\n-impl fmt::Display for AttrInput {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self {\n-            AttrInput::Literal(lit) => write!(f, \" = \\\"{}\\\"\", lit.escape_debug()),\n-            AttrInput::TokenTree(subtree, _) => subtree.fmt(f),\n-        }\n-    }\n-}\n-\n-impl Attr {\n-    fn from_src(\n-        db: &dyn DefDatabase,\n-        ast: ast::Meta,\n-        hygiene: &Hygiene,\n-        id: AttrId,\n-    ) -> Option<Attr> {\n-        let path = Interned::new(ModPath::from_src(db.upcast(), ast.path()?, hygiene)?);\n-        let input = if let Some(ast::Expr::Literal(lit)) = ast.expr() {\n-            let value = match lit.kind() {\n-                ast::LiteralKind::String(string) => string.value()?.into(),\n-                _ => lit.syntax().first_token()?.text().trim_matches('\"').into(),\n-            };\n-            Some(Interned::new(AttrInput::Literal(value)))\n-        } else if let Some(tt) = ast.token_tree() {\n-            let (tree, map) = syntax_node_to_token_tree(tt.syntax());\n-            Some(Interned::new(AttrInput::TokenTree(tree, map)))\n-        } else {\n-            None\n-        };\n-        Some(Attr { id, path, input })\n-    }\n-\n-    fn from_tt(\n-        db: &dyn DefDatabase,\n-        tt: &tt::Subtree,\n-        hygiene: &Hygiene,\n-        id: AttrId,\n-    ) -> Option<Attr> {\n-        let (parse, _) = mbe::token_tree_to_syntax_node(tt, mbe::TopEntryPoint::MetaItem);\n-        let ast = ast::Meta::cast(parse.syntax_node())?;\n-\n-        Self::from_src(db, ast, hygiene, id)\n-    }\n-\n-    pub fn path(&self) -> &ModPath {\n-        &self.path\n-    }\n-}\n-\n-impl Attr {\n-    /// #[path = \"string\"]\n-    pub fn string_value(&self) -> Option<&SmolStr> {\n-        match self.input.as_deref()? {\n-            AttrInput::Literal(it) => Some(it),\n-            _ => None,\n-        }\n-    }\n-\n-    /// #[path(ident)]\n-    pub fn single_ident_value(&self) -> Option<&tt::Ident> {\n-        match self.input.as_deref()? {\n-            AttrInput::TokenTree(subtree, _) => match &*subtree.token_trees {\n-                [tt::TokenTree::Leaf(tt::Leaf::Ident(ident))] => Some(ident),\n-                _ => None,\n-            },\n-            _ => None,\n-        }\n-    }\n-\n-    /// #[path TokenTree]\n-    pub fn token_tree_value(&self) -> Option<&Subtree> {\n-        match self.input.as_deref()? {\n-            AttrInput::TokenTree(subtree, _) => Some(subtree),\n-            _ => None,\n-        }\n-    }\n-\n-    /// Parses this attribute as a token tree consisting of comma separated paths.\n-    pub fn parse_path_comma_token_tree(&self) -> Option<impl Iterator<Item = ModPath> + '_> {\n-        let args = self.token_tree_value()?;\n-\n-        if args.delimiter_kind() != Some(DelimiterKind::Parenthesis) {\n-            return None;\n-        }\n-        let paths = args\n-            .token_trees\n-            .split(|tt| matches!(tt, tt::TokenTree::Leaf(tt::Leaf::Punct(Punct { char: ',', .. }))))\n-            .filter_map(|tts| {\n-                if tts.is_empty() {\n-                    return None;\n-                }\n-                let segments = tts.iter().filter_map(|tt| match tt {\n-                    tt::TokenTree::Leaf(tt::Leaf::Ident(id)) => Some(id.as_name()),\n-                    _ => None,\n-                });\n-                Some(ModPath::from_segments(PathKind::Plain, segments))\n-            });\n-\n-        Some(paths)\n-    }\n-}\n-\n #[derive(Debug, Clone, Copy)]\n pub struct AttrQuery<'attr> {\n     attrs: &'attr Attrs,\n@@ -953,21 +674,6 @@ fn attrs_from_item_tree<N: ItemTreeNode>(id: ItemTreeId<N>, db: &dyn DefDatabase\n     tree.raw_attrs(mod_item.into()).clone()\n }\n \n-fn collect_attrs(\n-    owner: &dyn ast::HasAttrs,\n-) -> impl Iterator<Item = (AttrId, Either<ast::Attr, ast::Comment>)> {\n-    let inner_attrs = inner_attributes(owner.syntax()).into_iter().flatten();\n-    let outer_attrs =\n-        ast::AttrDocCommentIter::from_syntax_node(owner.syntax()).filter(|el| match el {\n-            Either::Left(attr) => attr.kind().is_outer(),\n-            Either::Right(comment) => comment.is_outer(),\n-        });\n-    outer_attrs\n-        .chain(inner_attrs)\n-        .enumerate()\n-        .map(|(id, attr)| (AttrId { ast_index: id as u32 }, attr))\n-}\n-\n pub(crate) fn variants_attrs_source_map(\n     db: &dyn DefDatabase,\n     def: EnumId,"}, {"sha": "9713256813eb6ce4c0d1eca93a277165c20e7150", "filename": "crates/hir-def/src/body.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody.rs?ref=c3b78f440e1978a84f7224fe443086c1c91254a1", "patch": "@@ -12,15 +12,17 @@ use base_db::CrateId;\n use cfg::{CfgExpr, CfgOptions};\n use drop_bomb::DropBomb;\n use either::Either;\n-use hir_expand::{hygiene::Hygiene, ExpandError, ExpandResult, HirFileId, InFile, MacroCallId};\n+use hir_expand::{\n+    attrs::RawAttrs, hygiene::Hygiene, ExpandError, ExpandResult, HirFileId, InFile, MacroCallId,\n+};\n use la_arena::{Arena, ArenaMap};\n use limit::Limit;\n use profile::Count;\n use rustc_hash::FxHashMap;\n use syntax::{ast, AstPtr, SyntaxNodePtr};\n \n use crate::{\n-    attr::{Attrs, RawAttrs},\n+    attr::Attrs,\n     db::DefDatabase,\n     expr::{dummy_expr_id, Expr, ExprId, Label, LabelId, Pat, PatId},\n     item_scope::BuiltinShadowMode,\n@@ -64,7 +66,7 @@ impl CfgExpander {\n     }\n \n     pub(crate) fn parse_attrs(&self, db: &dyn DefDatabase, owner: &dyn ast::HasAttrs) -> Attrs {\n-        RawAttrs::new(db, owner, &self.hygiene).filter(db, self.krate)\n+        Attrs::filter(db, self.krate, RawAttrs::new(db.upcast(), owner, &self.hygiene))\n     }\n \n     pub(crate) fn is_cfg_enabled(&self, db: &dyn DefDatabase, owner: &dyn ast::HasAttrs) -> bool {"}, {"sha": "4c29e16b2b813ba0ca6e1349cf48a9693265883d", "filename": "crates/hir-def/src/body/lower.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs?ref=c3b78f440e1978a84f7224fe443086c1c91254a1", "patch": "@@ -10,6 +10,7 @@ use hir_expand::{\n     name::{name, AsName, Name},\n     AstId, ExpandError, HirFileId, InFile,\n };\n+use intern::Interned;\n use la_arena::Arena;\n use once_cell::unsync::OnceCell;\n use profile::Count;\n@@ -33,7 +34,6 @@ use crate::{\n         Label, LabelId, Literal, MatchArm, Movability, Pat, PatId, RecordFieldPat, RecordLitField,\n         Statement,\n     },\n-    intern::Interned,\n     item_scope::BuiltinShadowMode,\n     path::{GenericArgs, Path},\n     type_ref::{Mutability, Rawness, TypeRef},"}, {"sha": "19d2fe956f098b964a6e773f57acbbcf1304b044", "filename": "crates/hir-def/src/child_by_source.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-def%2Fsrc%2Fchild_by_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-def%2Fsrc%2Fchild_by_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fchild_by_source.rs?ref=c3b78f440e1978a84f7224fe443086c1c91254a1", "patch": "@@ -117,7 +117,7 @@ impl ChildBySource for ItemScope {\n                 let adt = ast_id.to_node(db.upcast());\n                 calls.for_each(|(attr_id, call_id, calls)| {\n                     if let Some(Either::Left(attr)) =\n-                        adt.doc_comments_and_attrs().nth(attr_id.ast_index as usize)\n+                        adt.doc_comments_and_attrs().nth(attr_id.ast_index())\n                     {\n                         res[keys::DERIVE_MACRO_CALL].insert(attr, (attr_id, call_id, calls.into()));\n                     }"}, {"sha": "f461e85b0182c77f726740121ce6439ea21aefeb", "filename": "crates/hir-def/src/data.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fdata.rs?ref=c3b78f440e1978a84f7224fe443086c1c91254a1", "patch": "@@ -3,14 +3,14 @@\n use std::sync::Arc;\n \n use hir_expand::{name::Name, AstId, ExpandResult, HirFileId, InFile, MacroCallId, MacroDefKind};\n+use intern::Interned;\n use smallvec::SmallVec;\n use syntax::ast;\n \n use crate::{\n     attr::Attrs,\n     body::{Expander, Mark},\n     db::DefDatabase,\n-    intern::Interned,\n     item_tree::{self, AssocItem, FnFlags, ItemTree, ItemTreeId, ModItem, Param, TreeId},\n     nameres::{\n         attr_resolution::ResolvedAttr,"}, {"sha": "65cdd1b69b17d5ee05a408653bc8b760b85f33a9", "filename": "crates/hir-def/src/db.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-def%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-def%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fdb.rs?ref=c3b78f440e1978a84f7224fe443086c1c91254a1", "patch": "@@ -4,6 +4,7 @@ use std::sync::Arc;\n use base_db::{salsa, CrateId, SourceDatabase, Upcast};\n use either::Either;\n use hir_expand::{db::AstDatabase, HirFileId};\n+use intern::Interned;\n use la_arena::ArenaMap;\n use syntax::{ast, AstPtr, SmolStr};\n \n@@ -17,7 +18,6 @@ use crate::{\n     },\n     generics::GenericParams,\n     import_map::ImportMap,\n-    intern::Interned,\n     item_tree::{AttrOwner, ItemTree},\n     lang_item::{LangItemTarget, LangItems},\n     nameres::{diagnostics::DefDiagnostic, DefMap},"}, {"sha": "48028b7c6a82a5c8dc961c7f6f2ede60489a9aa7", "filename": "crates/hir-def/src/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-def%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-def%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fexpr.rs?ref=c3b78f440e1978a84f7224fe443086c1c91254a1", "patch": "@@ -15,11 +15,11 @@\n use std::fmt;\n \n use hir_expand::name::Name;\n+use intern::Interned;\n use la_arena::{Idx, RawIdx};\n \n use crate::{\n     builtin_type::{BuiltinFloat, BuiltinInt, BuiltinUint},\n-    intern::Interned,\n     path::{GenericArgs, Path},\n     type_ref::{Mutability, Rawness, TypeRef},\n     BlockId,"}, {"sha": "b2ab0c30e0370c02ddadba6d425c005115e8c6b4", "filename": "crates/hir-def/src/generics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-def%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-def%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fgenerics.rs?ref=c3b78f440e1978a84f7224fe443086c1c91254a1", "patch": "@@ -9,6 +9,7 @@ use hir_expand::{\n     name::{AsName, Name},\n     ExpandResult, HirFileId, InFile,\n };\n+use intern::Interned;\n use la_arena::{Arena, ArenaMap, Idx};\n use once_cell::unsync::Lazy;\n use std::ops::DerefMut;\n@@ -20,7 +21,6 @@ use crate::{\n     child_by_source::ChildBySource,\n     db::DefDatabase,\n     dyn_map::DynMap,\n-    intern::Interned,\n     keys,\n     src::{HasChildSource, HasSource},\n     type_ref::{LifetimeRef, TypeBound, TypeRef},"}, {"sha": "53a4173ff4230f8c3c896200590f0875e52cb350", "filename": "crates/hir-def/src/item_scope.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-def%2Fsrc%2Fitem_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-def%2Fsrc%2Fitem_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fitem_scope.rs?ref=c3b78f440e1978a84f7224fe443086c1c91254a1", "patch": "@@ -4,7 +4,7 @@\n use std::collections::hash_map::Entry;\n \n use base_db::CrateId;\n-use hir_expand::{name::Name, AstId, MacroCallId};\n+use hir_expand::{attrs::AttrId, name::Name, AstId, MacroCallId};\n use itertools::Itertools;\n use once_cell::sync::Lazy;\n use profile::Count;\n@@ -14,8 +14,8 @@ use stdx::format_to;\n use syntax::ast;\n \n use crate::{\n-    attr::AttrId, db::DefDatabase, per_ns::PerNs, visibility::Visibility, AdtId, BuiltinType,\n-    ConstId, HasModule, ImplId, LocalModuleId, MacroId, ModuleDefId, ModuleId, TraitId,\n+    db::DefDatabase, per_ns::PerNs, visibility::Visibility, AdtId, BuiltinType, ConstId, HasModule,\n+    ImplId, LocalModuleId, MacroId, ModuleDefId, ModuleId, TraitId,\n };\n \n #[derive(Copy, Clone, Debug)]"}, {"sha": "3e1f7d44460f192ea4b02f8e85240cfd97533403", "filename": "crates/hir-def/src/item_tree.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fitem_tree.rs?ref=c3b78f440e1978a84f7224fe443086c1c91254a1", "patch": "@@ -48,10 +48,12 @@ use base_db::CrateId;\n use either::Either;\n use hir_expand::{\n     ast_id_map::FileAstId,\n+    attrs::RawAttrs,\n     hygiene::Hygiene,\n     name::{name, AsName, Name},\n     ExpandTo, HirFileId, InFile,\n };\n+use intern::Interned;\n use la_arena::{Arena, Idx, IdxRange, RawIdx};\n use profile::Count;\n use rustc_hash::FxHashMap;\n@@ -60,10 +62,9 @@ use stdx::never;\n use syntax::{ast, match_ast, SyntaxKind};\n \n use crate::{\n-    attr::{Attrs, RawAttrs},\n+    attr::Attrs,\n     db::DefDatabase,\n     generics::GenericParams,\n-    intern::Interned,\n     path::{path, AssociatedTypeBinding, GenericArgs, ImportAlias, ModPath, Path, PathKind},\n     type_ref::{Mutability, TraitRef, TypeBound, TypeRef},\n     visibility::RawVisibility,\n@@ -120,7 +121,7 @@ impl ItemTree {\n         let mut item_tree = match_ast! {\n             match syntax {\n                 ast::SourceFile(file) => {\n-                    top_attrs = Some(RawAttrs::new(db, &file, ctx.hygiene()));\n+                    top_attrs = Some(RawAttrs::new(db.upcast(), &file, ctx.hygiene()));\n                     ctx.lower_module_items(&file)\n                 },\n                 ast::MacroItems(items) => {\n@@ -152,15 +153,19 @@ impl ItemTree {\n \n     /// Returns the inner attributes of the source file.\n     pub fn top_level_attrs(&self, db: &dyn DefDatabase, krate: CrateId) -> Attrs {\n-        self.attrs.get(&AttrOwner::TopLevel).unwrap_or(&RawAttrs::EMPTY).clone().filter(db, krate)\n+        Attrs::filter(\n+            db,\n+            krate,\n+            self.attrs.get(&AttrOwner::TopLevel).unwrap_or(&RawAttrs::EMPTY).clone(),\n+        )\n     }\n \n     pub(crate) fn raw_attrs(&self, of: AttrOwner) -> &RawAttrs {\n         self.attrs.get(&of).unwrap_or(&RawAttrs::EMPTY)\n     }\n \n     pub(crate) fn attrs(&self, db: &dyn DefDatabase, krate: CrateId, of: AttrOwner) -> Attrs {\n-        self.raw_attrs(of).clone().filter(db, krate)\n+        Attrs::filter(db, krate, self.raw_attrs(of).clone())\n     }\n \n     pub fn pretty_print(&self) -> String {"}, {"sha": "27705cbbbdc587b1fffd3eaa8958893fedba3ece", "filename": "crates/hir-def/src/item_tree/lower.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs?ref=c3b78f440e1978a84f7224fe443086c1c91254a1", "patch": "@@ -99,7 +99,7 @@ impl<'a> Ctx<'a> {\n     }\n \n     fn lower_mod_item(&mut self, item: &ast::Item) -> Option<ModItem> {\n-        let attrs = RawAttrs::new(self.db, item, self.hygiene());\n+        let attrs = RawAttrs::new(self.db.upcast(), item, self.hygiene());\n         let item: ModItem = match item {\n             ast::Item::Struct(ast) => self.lower_struct(ast)?.into(),\n             ast::Item::Union(ast) => self.lower_union(ast)?.into(),\n@@ -173,7 +173,7 @@ impl<'a> Ctx<'a> {\n         for field in fields.fields() {\n             if let Some(data) = self.lower_record_field(&field) {\n                 let idx = self.data().fields.alloc(data);\n-                self.add_attrs(idx.into(), RawAttrs::new(self.db, &field, self.hygiene()));\n+                self.add_attrs(idx.into(), RawAttrs::new(self.db.upcast(), &field, self.hygiene()));\n             }\n         }\n         let end = self.next_field_idx();\n@@ -194,7 +194,7 @@ impl<'a> Ctx<'a> {\n         for (i, field) in fields.fields().enumerate() {\n             let data = self.lower_tuple_field(i, &field);\n             let idx = self.data().fields.alloc(data);\n-            self.add_attrs(idx.into(), RawAttrs::new(self.db, &field, self.hygiene()));\n+            self.add_attrs(idx.into(), RawAttrs::new(self.db.upcast(), &field, self.hygiene()));\n         }\n         let end = self.next_field_idx();\n         IdxRange::new(start..end)\n@@ -239,7 +239,10 @@ impl<'a> Ctx<'a> {\n         for variant in variants.variants() {\n             if let Some(data) = self.lower_variant(&variant) {\n                 let idx = self.data().variants.alloc(data);\n-                self.add_attrs(idx.into(), RawAttrs::new(self.db, &variant, self.hygiene()));\n+                self.add_attrs(\n+                    idx.into(),\n+                    RawAttrs::new(self.db.upcast(), &variant, self.hygiene()),\n+                );\n             }\n         }\n         let end = self.next_variant_idx();\n@@ -283,7 +286,10 @@ impl<'a> Ctx<'a> {\n                 };\n                 let ty = Interned::new(self_type);\n                 let idx = self.data().params.alloc(Param::Normal(None, ty));\n-                self.add_attrs(idx.into(), RawAttrs::new(self.db, &self_param, self.hygiene()));\n+                self.add_attrs(\n+                    idx.into(),\n+                    RawAttrs::new(self.db.upcast(), &self_param, self.hygiene()),\n+                );\n                 has_self_param = true;\n             }\n             for param in param_list.params() {\n@@ -307,7 +313,7 @@ impl<'a> Ctx<'a> {\n                         self.data().params.alloc(Param::Normal(name, ty))\n                     }\n                 };\n-                self.add_attrs(idx.into(), RawAttrs::new(self.db, &param, self.hygiene()));\n+                self.add_attrs(idx.into(), RawAttrs::new(self.db.upcast(), &param, self.hygiene()));\n             }\n         }\n         let end_param = self.next_param_idx();\n@@ -442,7 +448,7 @@ impl<'a> Ctx<'a> {\n         let items = trait_def.assoc_item_list().map(|list| {\n             list.assoc_items()\n                 .filter_map(|item| {\n-                    let attrs = RawAttrs::new(self.db, &item, self.hygiene());\n+                    let attrs = RawAttrs::new(self.db.upcast(), &item, self.hygiene());\n                     self.lower_assoc_item(&item).map(|item| {\n                         self.add_attrs(ModItem::from(item).into(), attrs);\n                         item\n@@ -471,7 +477,7 @@ impl<'a> Ctx<'a> {\n             .flat_map(|it| it.assoc_items())\n             .filter_map(|item| {\n                 let assoc = self.lower_assoc_item(&item)?;\n-                let attrs = RawAttrs::new(self.db, &item, self.hygiene());\n+                let attrs = RawAttrs::new(self.db.upcast(), &item, self.hygiene());\n                 self.add_attrs(ModItem::from(assoc).into(), attrs);\n                 Some(assoc)\n             })\n@@ -541,7 +547,7 @@ impl<'a> Ctx<'a> {\n                     // (in other words, the knowledge that they're in an extern block must not be used).\n                     // This is because an extern block can contain macros whose ItemTree's top-level items\n                     // should be considered to be in an extern block too.\n-                    let attrs = RawAttrs::new(self.db, &item, self.hygiene());\n+                    let attrs = RawAttrs::new(self.db.upcast(), &item, self.hygiene());\n                     let id: ModItem = match item {\n                         ast::ExternItem::Fn(ast) => self.lower_function(&ast)?.into(),\n                         ast::ExternItem::Static(ast) => self.lower_static(&ast)?.into(),"}, {"sha": "8f230b87d0101da7fd15ffdc22b9285b61643d4c", "filename": "crates/hir-def/src/item_tree/pretty.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Fpretty.rs?ref=c3b78f440e1978a84f7224fe443086c1c91254a1", "patch": "@@ -3,7 +3,6 @@\n use std::fmt::{self, Write};\n \n use crate::{\n-    attr::RawAttrs,\n     generics::{TypeOrConstParamData, WherePredicate, WherePredicateTypeTarget},\n     pretty::{print_path, print_type_bounds, print_type_ref},\n     visibility::RawVisibility,"}, {"sha": "72beec8186c1fa09f14038f5a625ae77aa94bce2", "filename": "crates/hir-def/src/keys.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-def%2Fsrc%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-def%2Fsrc%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fkeys.rs?ref=c3b78f440e1978a84f7224fe443086c1c91254a1", "patch": "@@ -2,12 +2,11 @@\n \n use std::marker::PhantomData;\n \n-use hir_expand::MacroCallId;\n+use hir_expand::{attrs::AttrId, MacroCallId};\n use rustc_hash::FxHashMap;\n use syntax::{ast, AstNode, AstPtr};\n \n use crate::{\n-    attr::AttrId,\n     dyn_map::{DynMap, Policy},\n     ConstId, EnumId, EnumVariantId, FieldId, FunctionId, ImplId, LifetimeParamId, Macro2Id,\n     MacroRulesId, ProcMacroId, StaticId, StructId, TraitId, TypeAliasId, TypeOrConstParamId,"}, {"sha": "8eae2e92f4262676727de7fad6daad606ac14d89", "filename": "crates/hir-def/src/lib.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Flib.rs?ref=c3b78f440e1978a84f7224fe443086c1c91254a1", "patch": "@@ -28,7 +28,6 @@ pub mod dyn_map;\n pub mod keys;\n \n pub mod item_tree;\n-pub mod intern;\n \n pub mod adt;\n pub mod data;\n@@ -61,10 +60,10 @@ use std::{\n     sync::Arc,\n };\n \n-use attr::Attr;\n use base_db::{impl_intern_key, salsa, CrateId, ProcMacroKind};\n use hir_expand::{\n     ast_id_map::FileAstId,\n+    attrs::{Attr, AttrId, AttrInput},\n     builtin_attr_macro::BuiltinAttrExpander,\n     builtin_derive_macro::BuiltinDeriveExpander,\n     builtin_fn_macro::{BuiltinFnLikeExpander, EagerExpander},\n@@ -82,7 +81,6 @@ use syntax::ast;\n \n use crate::{\n     adt::VariantData,\n-    attr::AttrId,\n     builtin_type::BuiltinType,\n     item_tree::{\n         Const, Enum, Function, Impl, ItemTreeId, ItemTreeNode, MacroDef, MacroRules, ModItem,\n@@ -943,7 +941,7 @@ pub fn macro_id_to_def_id(db: &dyn db::DefDatabase, id: MacroId) -> MacroDefId {\n fn derive_macro_as_call_id(\n     db: &dyn db::DefDatabase,\n     item_attr: &AstIdWithPath<ast::Adt>,\n-    derive_attr: AttrId,\n+    derive_attr_index: AttrId,\n     derive_pos: u32,\n     krate: CrateId,\n     resolver: impl Fn(path::ModPath) -> Option<(MacroId, MacroDefId)>,\n@@ -956,7 +954,7 @@ fn derive_macro_as_call_id(\n         MacroCallKind::Derive {\n             ast_id: item_attr.ast_id,\n             derive_index: derive_pos,\n-            derive_attr_index: derive_attr.ast_index,\n+            derive_attr_index,\n         },\n     );\n     Ok((macro_id, def_id, call_id))\n@@ -971,7 +969,7 @@ fn attr_macro_as_call_id(\n     is_derive: bool,\n ) -> MacroCallId {\n     let mut arg = match macro_attr.input.as_deref() {\n-        Some(attr::AttrInput::TokenTree(tt, map)) => (tt.clone(), map.clone()),\n+        Some(AttrInput::TokenTree(tt, map)) => (tt.clone(), map.clone()),\n         _ => Default::default(),\n     };\n \n@@ -984,9 +982,16 @@ fn attr_macro_as_call_id(\n         MacroCallKind::Attr {\n             ast_id: item_attr.ast_id,\n             attr_args: Arc::new(arg),\n-            invoc_attr_index: macro_attr.id.ast_index,\n+            invoc_attr_index: macro_attr.id,\n             is_derive,\n         },\n     );\n     res\n }\n+intern::impl_internable!(\n+    crate::type_ref::TypeRef,\n+    crate::type_ref::TraitRef,\n+    crate::type_ref::TypeBound,\n+    crate::path::GenericArgs,\n+    generics::GenericParams,\n+);"}, {"sha": "79cabeb0fb7a4ca123df00c1b9f3d610b4b21633", "filename": "crates/hir-def/src/nameres/attr_resolution.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-def%2Fsrc%2Fnameres%2Fattr_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-def%2Fsrc%2Fnameres%2Fattr_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fattr_resolution.rs?ref=c3b78f440e1978a84f7224fe443086c1c91254a1", "patch": "@@ -1,10 +1,9 @@\n //! Post-nameres attribute resolution.\n \n-use hir_expand::MacroCallId;\n+use hir_expand::{attrs::Attr, MacroCallId};\n use syntax::{ast, SmolStr};\n \n use crate::{\n-    attr::Attr,\n     attr_macro_as_call_id, builtin_attr,\n     db::DefDatabase,\n     item_scope::BuiltinShadowMode,"}, {"sha": "33a787fd9f95d6ec8ea4a9f32ea96cc7e6ffc239", "filename": "crates/hir-def/src/nameres/collector.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs?ref=c3b78f440e1978a84f7224fe443086c1c91254a1", "patch": "@@ -10,6 +10,7 @@ use cfg::{CfgExpr, CfgOptions};\n use either::Either;\n use hir_expand::{\n     ast_id_map::FileAstId,\n+    attrs::{Attr, AttrId},\n     builtin_attr_macro::find_builtin_attr,\n     builtin_derive_macro::find_builtin_derive,\n     builtin_fn_macro::find_builtin_macro,\n@@ -26,7 +27,7 @@ use stdx::always;\n use syntax::{ast, SmolStr};\n \n use crate::{\n-    attr::{Attr, AttrId, Attrs},\n+    attr::Attrs,\n     attr_macro_as_call_id,\n     db::DefDatabase,\n     derive_macro_as_call_id,\n@@ -451,7 +452,7 @@ impl DefCollector<'_> {\n                         MacroCallKind::Attr {\n                             ast_id: ast_id.ast_id,\n                             attr_args: Default::default(),\n-                            invoc_attr_index: attr.id.ast_index,\n+                            invoc_attr_index: attr.id,\n                             is_derive: false,\n                         },\n                         attr.path().clone(),\n@@ -1406,7 +1407,7 @@ impl DefCollector<'_> {\n                         directive.module_id,\n                         MacroCallKind::Derive {\n                             ast_id: ast_id.ast_id,\n-                            derive_attr_index: derive_attr.ast_index,\n+                            derive_attr_index: *derive_attr,\n                             derive_index: *derive_pos as u32,\n                         },\n                         ast_id.path.clone(),"}, {"sha": "b024d7c6777c03ee4a4ba0b0eea4affbeea58ab7", "filename": "crates/hir-def/src/nameres/diagnostics.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-def%2Fsrc%2Fnameres%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-def%2Fsrc%2Fnameres%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fdiagnostics.rs?ref=c3b78f440e1978a84f7224fe443086c1c91254a1", "patch": "@@ -2,12 +2,11 @@\n \n use base_db::CrateId;\n use cfg::{CfgExpr, CfgOptions};\n-use hir_expand::MacroCallKind;\n+use hir_expand::{attrs::AttrId, MacroCallKind};\n use la_arena::Idx;\n use syntax::ast::{self, AnyHasAttrs};\n \n use crate::{\n-    attr::AttrId,\n     item_tree::{self, ItemTreeId},\n     nameres::LocalModuleId,\n     path::ModPath,\n@@ -32,9 +31,9 @@ pub enum DefDiagnosticKind {\n \n     UnimplementedBuiltinMacro { ast: AstId<ast::Macro> },\n \n-    InvalidDeriveTarget { ast: AstId<ast::Item>, id: u32 },\n+    InvalidDeriveTarget { ast: AstId<ast::Item>, id: usize },\n \n-    MalformedDerive { ast: AstId<ast::Adt>, id: u32 },\n+    MalformedDerive { ast: AstId<ast::Adt>, id: usize },\n }\n \n #[derive(Debug, PartialEq, Eq)]\n@@ -120,7 +119,7 @@ impl DefDiagnostic {\n     ) -> Self {\n         Self {\n             in_module: container,\n-            kind: DefDiagnosticKind::InvalidDeriveTarget { ast, id: id.ast_index },\n+            kind: DefDiagnosticKind::InvalidDeriveTarget { ast, id: id.ast_index() },\n         }\n     }\n \n@@ -131,7 +130,7 @@ impl DefDiagnostic {\n     ) -> Self {\n         Self {\n             in_module: container,\n-            kind: DefDiagnosticKind::MalformedDerive { ast, id: id.ast_index },\n+            kind: DefDiagnosticKind::MalformedDerive { ast, id: id.ast_index() },\n         }\n     }\n }"}, {"sha": "25a23fcd61a51ddc5d0d5c7c34a53bcfbdc45cf2", "filename": "crates/hir-def/src/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fpath.rs?ref=c3b78f440e1978a84f7224fe443086c1c91254a1", "patch": "@@ -8,10 +8,10 @@ use std::{\n \n use crate::{\n     body::LowerCtx,\n-    intern::Interned,\n     type_ref::{ConstScalarOrPath, LifetimeRef},\n };\n use hir_expand::name::Name;\n+use intern::Interned;\n use syntax::ast;\n \n use crate::type_ref::{TypeBound, TypeRef};"}, {"sha": "d570191595b6800118ba1f934d1f30a7a566963c", "filename": "crates/hir-def/src/path/lower.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-def%2Fsrc%2Fpath%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-def%2Fsrc%2Fpath%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fpath%2Flower.rs?ref=c3b78f440e1978a84f7224fe443086c1c91254a1", "patch": "@@ -1,9 +1,10 @@\n //! Transforms syntax into `Path` objects, ideally with accounting for hygiene\n \n-use crate::{intern::Interned, type_ref::ConstScalarOrPath};\n+use crate::type_ref::ConstScalarOrPath;\n \n use either::Either;\n use hir_expand::name::{name, AsName};\n+use intern::Interned;\n use syntax::ast::{self, AstNode, HasTypeBounds};\n \n use super::AssociatedTypeBinding;"}, {"sha": "1c0bd204d309bd9f01947d37965d7e587c949884", "filename": "crates/hir-def/src/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-def%2Fsrc%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-def%2Fsrc%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fpretty.rs?ref=c3b78f440e1978a84f7224fe443086c1c91254a1", "patch": "@@ -3,10 +3,10 @@\n use std::fmt::{self, Write};\n \n use hir_expand::mod_path::PathKind;\n+use intern::Interned;\n use itertools::Itertools;\n \n use crate::{\n-    intern::Interned,\n     path::{GenericArg, GenericArgs, Path},\n     type_ref::{Mutability, TraitBoundModifier, TypeBound, TypeRef},\n };"}, {"sha": "86958e3daea4d06e62319826e1c2ee0963ec6c74", "filename": "crates/hir-def/src/resolver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fresolver.rs?ref=c3b78f440e1978a84f7224fe443086c1c91254a1", "patch": "@@ -4,6 +4,7 @@ use std::{hash::BuildHasherDefault, sync::Arc};\n use base_db::CrateId;\n use hir_expand::name::{name, Name};\n use indexmap::IndexMap;\n+use intern::Interned;\n use rustc_hash::FxHashSet;\n use smallvec::{smallvec, SmallVec};\n \n@@ -13,7 +14,6 @@ use crate::{\n     db::DefDatabase,\n     expr::{ExprId, LabelId, PatId},\n     generics::{GenericParams, TypeOrConstParamData},\n-    intern::Interned,\n     item_scope::{BuiltinShadowMode, BUILTIN_SCOPE},\n     nameres::DefMap,\n     path::{ModPath, PathKind},"}, {"sha": "0149fdaa43cf332c167fc1b67515db97b6fdc71f", "filename": "crates/hir-def/src/type_ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-def%2Fsrc%2Ftype_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-def%2Fsrc%2Ftype_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Ftype_ref.rs?ref=c3b78f440e1978a84f7224fe443086c1c91254a1", "patch": "@@ -7,13 +7,13 @@ use hir_expand::{\n     name::{AsName, Name},\n     AstId,\n };\n+use intern::Interned;\n use syntax::ast::{self, HasName};\n \n use crate::{\n     body::LowerCtx,\n     builtin_type::{BuiltinInt, BuiltinType, BuiltinUint},\n     expr::Literal,\n-    intern::Interned,\n     path::Path,\n };\n "}, {"sha": "a73e690a7e055647c511fefb740048a60e03d870", "filename": "crates/hir-expand/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-expand%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-expand%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2FCargo.toml?ref=c3b78f440e1978a84f7224fe443086c1c91254a1", "patch": "@@ -22,6 +22,7 @@ hashbrown = { version = \"0.12.1\", features = [\n smallvec = { version = \"1.10.0\", features = [\"const_new\"] }\n \n stdx = { path = \"../stdx\", version = \"0.0.0\" }\n+intern = { path = \"../intern\", version = \"0.0.0\" }\n base-db = { path = \"../base-db\", version = \"0.0.0\" }\n cfg = { path = \"../cfg\", version = \"0.0.0\" }\n syntax = { path = \"../syntax\", version = \"0.0.0\" }"}, {"sha": "c7135732b8a2a8d7ac2663692a9d9b3dd0c9572f", "filename": "crates/hir-expand/src/attrs.rs", "status": "added", "additions": 346, "deletions": 0, "changes": 346, "blob_url": "https://github.com/rust-lang/rust/blob/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-expand%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-expand%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Fattrs.rs?ref=c3b78f440e1978a84f7224fe443086c1c91254a1", "patch": "@@ -0,0 +1,346 @@\n+//! A higher level attributes based on TokenTree, with also some shortcuts.\n+use std::{fmt, ops, sync::Arc};\n+\n+use base_db::CrateId;\n+use cfg::CfgExpr;\n+use either::Either;\n+use intern::Interned;\n+use mbe::{syntax_node_to_token_tree, DelimiterKind, Punct};\n+use smallvec::{smallvec, SmallVec};\n+use syntax::{ast, match_ast, AstNode, SmolStr, SyntaxNode};\n+use tt::Subtree;\n+\n+use crate::{\n+    db::AstDatabase,\n+    hygiene::Hygiene,\n+    mod_path::{ModPath, PathKind},\n+    name::AsName,\n+    InFile,\n+};\n+\n+/// Syntactical attributes, without filtering of `cfg_attr`s.\n+#[derive(Default, Debug, Clone, PartialEq, Eq)]\n+pub struct RawAttrs {\n+    entries: Option<Arc<[Attr]>>,\n+}\n+\n+impl ops::Deref for RawAttrs {\n+    type Target = [Attr];\n+\n+    fn deref(&self) -> &[Attr] {\n+        match &self.entries {\n+            Some(it) => &*it,\n+            None => &[],\n+        }\n+    }\n+}\n+\n+impl RawAttrs {\n+    pub const EMPTY: Self = Self { entries: None };\n+\n+    pub fn new(db: &dyn AstDatabase, owner: &dyn ast::HasAttrs, hygiene: &Hygiene) -> Self {\n+        let entries = collect_attrs(owner)\n+            .filter_map(|(id, attr)| match attr {\n+                Either::Left(attr) => {\n+                    attr.meta().and_then(|meta| Attr::from_src(db, meta, hygiene, id))\n+                }\n+                Either::Right(comment) => comment.doc_comment().map(|doc| Attr {\n+                    id,\n+                    input: Some(Interned::new(AttrInput::Literal(SmolStr::new(doc)))),\n+                    path: Interned::new(ModPath::from(crate::name!(doc))),\n+                }),\n+            })\n+            .collect::<Arc<_>>();\n+\n+        Self { entries: if entries.is_empty() { None } else { Some(entries) } }\n+    }\n+\n+    pub fn from_attrs_owner(db: &dyn AstDatabase, owner: InFile<&dyn ast::HasAttrs>) -> Self {\n+        let hygiene = Hygiene::new(db, owner.file_id);\n+        Self::new(db, owner.value, &hygiene)\n+    }\n+\n+    pub fn merge(&self, other: Self) -> Self {\n+        match (&self.entries, other.entries) {\n+            (None, None) => Self::EMPTY,\n+            (None, entries @ Some(_)) => Self { entries },\n+            (Some(entries), None) => Self { entries: Some(entries.clone()) },\n+            (Some(a), Some(b)) => {\n+                let last_ast_index = a.last().map_or(0, |it| it.id.ast_index() + 1) as u32;\n+                Self {\n+                    entries: Some(\n+                        a.iter()\n+                            .cloned()\n+                            .chain(b.iter().map(|it| {\n+                                let mut it = it.clone();\n+                                it.id.id = it.id.ast_index() as u32 + last_ast_index\n+                                    | (it.id.cfg_attr_index().unwrap_or(0) as u32)\n+                                        << AttrId::AST_INDEX_BITS;\n+                                it\n+                            }))\n+                            .collect(),\n+                    ),\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Processes `cfg_attr`s, returning the resulting semantic `Attrs`.\n+    // FIXME: This should return a different type\n+    pub fn filter(self, db: &dyn AstDatabase, krate: CrateId) -> RawAttrs {\n+        let has_cfg_attrs = self\n+            .iter()\n+            .any(|attr| attr.path.as_ident().map_or(false, |name| *name == crate::name![cfg_attr]));\n+        if !has_cfg_attrs {\n+            return self;\n+        }\n+\n+        let crate_graph = db.crate_graph();\n+        let new_attrs = self\n+            .iter()\n+            .flat_map(|attr| -> SmallVec<[_; 1]> {\n+                let is_cfg_attr =\n+                    attr.path.as_ident().map_or(false, |name| *name == crate::name![cfg_attr]);\n+                if !is_cfg_attr {\n+                    return smallvec![attr.clone()];\n+                }\n+\n+                let subtree = match attr.token_tree_value() {\n+                    Some(it) => it,\n+                    _ => return smallvec![attr.clone()],\n+                };\n+\n+                let (cfg, parts) = match parse_cfg_attr_input(subtree) {\n+                    Some(it) => it,\n+                    None => return smallvec![attr.clone()],\n+                };\n+                let index = attr.id;\n+                let attrs =\n+                    parts.enumerate().take(1 << AttrId::CFG_ATTR_BITS).filter_map(|(idx, attr)| {\n+                        let tree = Subtree { delimiter: None, token_trees: attr.to_vec() };\n+                        // FIXME hygiene\n+                        let hygiene = Hygiene::new_unhygienic();\n+                        Attr::from_tt(db, &tree, &hygiene, index.with_cfg_attr(idx))\n+                    });\n+\n+                let cfg_options = &crate_graph[krate].cfg_options;\n+                let cfg = Subtree { delimiter: subtree.delimiter, token_trees: cfg.to_vec() };\n+                let cfg = CfgExpr::parse(&cfg);\n+                if cfg_options.check(&cfg) == Some(false) {\n+                    smallvec![]\n+                } else {\n+                    cov_mark::hit!(cfg_attr_active);\n+\n+                    attrs.collect()\n+                }\n+            })\n+            .collect();\n+\n+        RawAttrs { entries: Some(new_attrs) }\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct AttrId {\n+    id: u32,\n+}\n+\n+// FIXME: This only handles a single level of cfg_attr nesting\n+// that is `#[cfg_attr(all(), cfg_attr(all(), cfg(any())))]` breaks again\n+impl AttrId {\n+    const CFG_ATTR_BITS: usize = 7;\n+    const AST_INDEX_MASK: usize = 0x00FF_FFFF;\n+    const AST_INDEX_BITS: usize = Self::AST_INDEX_MASK.count_ones() as usize;\n+    const CFG_ATTR_SET_BITS: u32 = 1 << 31;\n+\n+    pub fn ast_index(&self) -> usize {\n+        self.id as usize & Self::AST_INDEX_MASK\n+    }\n+\n+    pub fn cfg_attr_index(&self) -> Option<usize> {\n+        if self.id & Self::CFG_ATTR_SET_BITS == 0 {\n+            None\n+        } else {\n+            Some(self.id as usize >> Self::AST_INDEX_BITS)\n+        }\n+    }\n+\n+    pub fn with_cfg_attr(self, idx: usize) -> AttrId {\n+        AttrId { id: self.id | (idx as u32) << Self::AST_INDEX_BITS | Self::CFG_ATTR_SET_BITS }\n+    }\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct Attr {\n+    pub id: AttrId,\n+    pub path: Interned<ModPath>,\n+    pub input: Option<Interned<AttrInput>>,\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub enum AttrInput {\n+    /// `#[attr = \"string\"]`\n+    Literal(SmolStr),\n+    /// `#[attr(subtree)]`\n+    TokenTree(tt::Subtree, mbe::TokenMap),\n+}\n+\n+impl fmt::Display for AttrInput {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            AttrInput::Literal(lit) => write!(f, \" = \\\"{}\\\"\", lit.escape_debug()),\n+            AttrInput::TokenTree(subtree, _) => subtree.fmt(f),\n+        }\n+    }\n+}\n+\n+impl Attr {\n+    fn from_src(\n+        db: &dyn AstDatabase,\n+        ast: ast::Meta,\n+        hygiene: &Hygiene,\n+        id: AttrId,\n+    ) -> Option<Attr> {\n+        let path = Interned::new(ModPath::from_src(db, ast.path()?, hygiene)?);\n+        let input = if let Some(ast::Expr::Literal(lit)) = ast.expr() {\n+            let value = match lit.kind() {\n+                ast::LiteralKind::String(string) => string.value()?.into(),\n+                _ => lit.syntax().first_token()?.text().trim_matches('\"').into(),\n+            };\n+            Some(Interned::new(AttrInput::Literal(value)))\n+        } else if let Some(tt) = ast.token_tree() {\n+            let (tree, map) = syntax_node_to_token_tree(tt.syntax());\n+            Some(Interned::new(AttrInput::TokenTree(tree, map)))\n+        } else {\n+            None\n+        };\n+        Some(Attr { id, path, input })\n+    }\n+\n+    fn from_tt(\n+        db: &dyn AstDatabase,\n+        tt: &tt::Subtree,\n+        hygiene: &Hygiene,\n+        id: AttrId,\n+    ) -> Option<Attr> {\n+        let (parse, _) = mbe::token_tree_to_syntax_node(tt, mbe::TopEntryPoint::MetaItem);\n+        let ast = ast::Meta::cast(parse.syntax_node())?;\n+\n+        Self::from_src(db, ast, hygiene, id)\n+    }\n+\n+    pub fn path(&self) -> &ModPath {\n+        &self.path\n+    }\n+}\n+\n+impl Attr {\n+    /// #[path = \"string\"]\n+    pub fn string_value(&self) -> Option<&SmolStr> {\n+        match self.input.as_deref()? {\n+            AttrInput::Literal(it) => Some(it),\n+            _ => None,\n+        }\n+    }\n+\n+    /// #[path(ident)]\n+    pub fn single_ident_value(&self) -> Option<&tt::Ident> {\n+        match self.input.as_deref()? {\n+            AttrInput::TokenTree(subtree, _) => match &*subtree.token_trees {\n+                [tt::TokenTree::Leaf(tt::Leaf::Ident(ident))] => Some(ident),\n+                _ => None,\n+            },\n+            _ => None,\n+        }\n+    }\n+\n+    /// #[path TokenTree]\n+    pub fn token_tree_value(&self) -> Option<&Subtree> {\n+        match self.input.as_deref()? {\n+            AttrInput::TokenTree(subtree, _) => Some(subtree),\n+            _ => None,\n+        }\n+    }\n+\n+    /// Parses this attribute as a token tree consisting of comma separated paths.\n+    pub fn parse_path_comma_token_tree(&self) -> Option<impl Iterator<Item = ModPath> + '_> {\n+        let args = self.token_tree_value()?;\n+\n+        if args.delimiter_kind() != Some(DelimiterKind::Parenthesis) {\n+            return None;\n+        }\n+        let paths = args\n+            .token_trees\n+            .split(|tt| matches!(tt, tt::TokenTree::Leaf(tt::Leaf::Punct(Punct { char: ',', .. }))))\n+            .filter_map(|tts| {\n+                if tts.is_empty() {\n+                    return None;\n+                }\n+                let segments = tts.iter().filter_map(|tt| match tt {\n+                    tt::TokenTree::Leaf(tt::Leaf::Ident(id)) => Some(id.as_name()),\n+                    _ => None,\n+                });\n+                Some(ModPath::from_segments(PathKind::Plain, segments))\n+            });\n+\n+        Some(paths)\n+    }\n+}\n+\n+pub fn collect_attrs(\n+    owner: &dyn ast::HasAttrs,\n+) -> impl Iterator<Item = (AttrId, Either<ast::Attr, ast::Comment>)> {\n+    let inner_attrs = inner_attributes(owner.syntax()).into_iter().flatten();\n+    let outer_attrs =\n+        ast::AttrDocCommentIter::from_syntax_node(owner.syntax()).filter(|el| match el {\n+            Either::Left(attr) => attr.kind().is_outer(),\n+            Either::Right(comment) => comment.is_outer(),\n+        });\n+    outer_attrs.chain(inner_attrs).enumerate().map(|(id, attr)| (AttrId { id: id as u32 }, attr))\n+}\n+\n+fn inner_attributes(\n+    syntax: &SyntaxNode,\n+) -> Option<impl Iterator<Item = Either<ast::Attr, ast::Comment>>> {\n+    let node = match_ast! {\n+        match syntax {\n+            ast::SourceFile(_) => syntax.clone(),\n+            ast::ExternBlock(it) => it.extern_item_list()?.syntax().clone(),\n+            ast::Fn(it) => it.body()?.stmt_list()?.syntax().clone(),\n+            ast::Impl(it) => it.assoc_item_list()?.syntax().clone(),\n+            ast::Module(it) => it.item_list()?.syntax().clone(),\n+            ast::BlockExpr(it) => {\n+                use syntax::SyntaxKind::{BLOCK_EXPR , EXPR_STMT};\n+                // Block expressions accept outer and inner attributes, but only when they are the outer\n+                // expression of an expression statement or the final expression of another block expression.\n+                let may_carry_attributes = matches!(\n+                    it.syntax().parent().map(|it| it.kind()),\n+                     Some(BLOCK_EXPR | EXPR_STMT)\n+                );\n+                if !may_carry_attributes {\n+                    return None\n+                }\n+                syntax.clone()\n+            },\n+            _ => return None,\n+        }\n+    };\n+\n+    let attrs = ast::AttrDocCommentIter::from_syntax_node(&node).filter(|el| match el {\n+        Either::Left(attr) => attr.kind().is_inner(),\n+        Either::Right(comment) => comment.is_inner(),\n+    });\n+    Some(attrs)\n+}\n+\n+// Input subtree is: `(cfg, $(attr),+)`\n+// Split it up into a `cfg` subtree and the `attr` subtrees.\n+pub fn parse_cfg_attr_input(\n+    subtree: &Subtree,\n+) -> Option<(&[tt::TokenTree], impl Iterator<Item = &[tt::TokenTree]>)> {\n+    let mut parts = subtree\n+        .token_trees\n+        .split(|tt| matches!(tt, tt::TokenTree::Leaf(tt::Leaf::Punct(Punct { char: ',', .. }))));\n+    let cfg = parts.next()?;\n+    Some((cfg, parts.filter(|it| !it.is_empty())))\n+}"}, {"sha": "ec5886824f8610b03416bbb90f93a651f76862d4", "filename": "crates/hir-expand/src/db.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Fdb.rs?ref=c3b78f440e1978a84f7224fe443086c1c91254a1", "patch": "@@ -168,7 +168,9 @@ pub fn expand_speculative(\n                 // Attributes may have an input token tree, build the subtree and map for this as well\n                 // then try finding a token id for our token if it is inside this input subtree.\n                 let item = ast::Item::cast(speculative_args.clone())?;\n-                item.doc_comments_and_attrs().nth(invoc_attr_index as usize).and_then(Either::left)\n+                item.doc_comments_and_attrs()\n+                    .nth(invoc_attr_index.ast_index())\n+                    .and_then(Either::left)\n             }?;\n             match attr.token_tree() {\n                 Some(token_tree) => {\n@@ -321,14 +323,15 @@ fn macro_arg(\n }\n \n fn censor_for_macro_input(loc: &MacroCallLoc, node: &SyntaxNode) -> FxHashSet<SyntaxNode> {\n+    // FIXME: handle `cfg_attr`\n     (|| {\n         let censor = match loc.kind {\n             MacroCallKind::FnLike { .. } => return None,\n             MacroCallKind::Derive { derive_attr_index, .. } => {\n                 cov_mark::hit!(derive_censoring);\n                 ast::Item::cast(node.clone())?\n                     .attrs()\n-                    .take(derive_attr_index as usize + 1)\n+                    .take(derive_attr_index.ast_index() + 1)\n                     // FIXME, this resolution should not be done syntactically\n                     // derive is a proper macro now, no longer builtin\n                     // But we do not have resolution at this stage, this means\n@@ -343,7 +346,7 @@ fn censor_for_macro_input(loc: &MacroCallLoc, node: &SyntaxNode) -> FxHashSet<Sy\n                 cov_mark::hit!(attribute_macro_attr_censoring);\n                 ast::Item::cast(node.clone())?\n                     .doc_comments_and_attrs()\n-                    .nth(invoc_attr_index as usize)\n+                    .nth(invoc_attr_index.ast_index())\n                     .and_then(Either::left)\n                     .map(|attr| attr.syntax().clone())\n                     .into_iter()"}, {"sha": "5a55dc5c9e25cd113d5905a10af6088cfef65b39", "filename": "crates/hir-expand/src/hygiene.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-expand%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-expand%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Fhygiene.rs?ref=c3b78f440e1978a84f7224fe443086c1c91254a1", "patch": "@@ -191,7 +191,7 @@ fn make_hygiene_info(\n             let tt = ast_id\n                 .to_node(db)\n                 .doc_comments_and_attrs()\n-                .nth(invoc_attr_index as usize)\n+                .nth(invoc_attr_index.ast_index())\n                 .and_then(Either::left)?\n                 .token_tree()?;\n             Some(InFile::new(ast_id.file_id, tt))"}, {"sha": "5554c7517f5accd4e1cce69412e70c6f72b7fad9", "filename": "crates/hir-expand/src/lib.rs", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Flib.rs?ref=c3b78f440e1978a84f7224fe443086c1c91254a1", "patch": "@@ -17,6 +17,7 @@ pub mod proc_macro;\n pub mod quote;\n pub mod eager;\n pub mod mod_path;\n+pub mod attrs;\n mod fixup;\n \n pub use mbe::{Origin, ValueResult};\n@@ -37,6 +38,7 @@ use syntax::{\n \n use crate::{\n     ast_id_map::FileAstId,\n+    attrs::AttrId,\n     builtin_attr_macro::BuiltinAttrExpander,\n     builtin_derive_macro::BuiltinDeriveExpander,\n     builtin_fn_macro::{BuiltinFnLikeExpander, EagerExpander},\n@@ -145,7 +147,7 @@ pub enum MacroCallKind {\n         ///\n         /// Outer attributes are counted first, then inner attributes. This does not support\n         /// out-of-line modules, which may have attributes spread across 2 files!\n-        derive_attr_index: u32,\n+        derive_attr_index: AttrId,\n         /// Index of the derive macro in the derive attribute\n         derive_index: u32,\n     },\n@@ -156,7 +158,7 @@ pub enum MacroCallKind {\n         ///\n         /// Outer attributes are counted first, then inner attributes. This does not support\n         /// out-of-line modules, which may have attributes spread across 2 files!\n-        invoc_attr_index: u32,\n+        invoc_attr_index: AttrId,\n         /// Whether this attribute is the `#[derive]` attribute.\n         is_derive: bool,\n     },\n@@ -261,10 +263,11 @@ impl HirFileId {\n         });\n         let attr_input_or_mac_def = def.or_else(|| match loc.kind {\n             MacroCallKind::Attr { ast_id, invoc_attr_index, .. } => {\n+                // FIXME: handle `cfg_attr`\n                 let tt = ast_id\n                     .to_node(db)\n                     .doc_comments_and_attrs()\n-                    .nth(invoc_attr_index as usize)\n+                    .nth(invoc_attr_index.ast_index())\n                     .and_then(Either::left)?\n                     .token_tree()?;\n                 Some(InFile::new(ast_id.file_id, tt))\n@@ -397,8 +400,7 @@ impl MacroDefId {\n     }\n }\n \n-// FIXME: attribute indices do not account for `cfg_attr`, which means that we'll strip the whole\n-// `cfg_attr` instead of just one of the attributes it expands to\n+// FIXME: attribute indices do not account for nested `cfg_attr`\n \n impl MacroCallKind {\n     /// Returns the file containing the macro invocation.\n@@ -419,7 +421,7 @@ impl MacroCallKind {\n                 // FIXME: handle `cfg_attr`\n                 ast_id.with_value(ast_id.to_node(db)).map(|it| {\n                     it.doc_comments_and_attrs()\n-                        .nth(*derive_attr_index as usize)\n+                        .nth(derive_attr_index.ast_index())\n                         .and_then(|it| match it {\n                             Either::Left(attr) => Some(attr.syntax().clone()),\n                             Either::Right(_) => None,\n@@ -431,7 +433,7 @@ impl MacroCallKind {\n                 // FIXME: handle `cfg_attr`\n                 ast_id.with_value(ast_id.to_node(db)).map(|it| {\n                     it.doc_comments_and_attrs()\n-                        .nth(*invoc_attr_index as usize)\n+                        .nth(invoc_attr_index.ast_index())\n                         .and_then(|it| match it {\n                             Either::Left(attr) => Some(attr.syntax().clone()),\n                             Either::Right(_) => None,\n@@ -488,19 +490,21 @@ impl MacroCallKind {\n             MacroCallKind::FnLike { ast_id, .. } => ast_id.to_node(db).syntax().text_range(),\n             MacroCallKind::Derive { ast_id, derive_attr_index, .. } => {\n                 // FIXME: should be the range of the macro name, not the whole derive\n+                // FIXME: handle `cfg_attr`\n                 ast_id\n                     .to_node(db)\n                     .doc_comments_and_attrs()\n-                    .nth(derive_attr_index as usize)\n+                    .nth(derive_attr_index.ast_index())\n                     .expect(\"missing derive\")\n                     .expect_left(\"derive is a doc comment?\")\n                     .syntax()\n                     .text_range()\n             }\n+            // FIXME: handle `cfg_attr`\n             MacroCallKind::Attr { ast_id, invoc_attr_index, .. } => ast_id\n                 .to_node(db)\n                 .doc_comments_and_attrs()\n-                .nth(invoc_attr_index as usize)\n+                .nth(invoc_attr_index.ast_index())\n                 .expect(\"missing attribute\")\n                 .expect_left(\"attribute macro is a doc comment?\")\n                 .syntax()\n@@ -592,9 +596,10 @@ impl ExpansionInfo {\n             let token_range = token.value.text_range();\n             match &loc.kind {\n                 MacroCallKind::Attr { attr_args, invoc_attr_index, is_derive, .. } => {\n+                    // FIXME: handle `cfg_attr`\n                     let attr = item\n                         .doc_comments_and_attrs()\n-                        .nth(*invoc_attr_index as usize)\n+                        .nth(invoc_attr_index.ast_index())\n                         .and_then(Either::left)?;\n                     match attr.token_tree() {\n                         Some(token_tree)\n@@ -1031,3 +1036,5 @@ impl ExpandTo {\n pub struct UnresolvedMacro {\n     pub path: ModPath,\n }\n+\n+intern::impl_internable!(ModPath, attrs::AttrInput);"}, {"sha": "75b33da1f230bfbe8050a103c26d6960260488e8", "filename": "crates/hir-ty/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-ty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-ty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2FCargo.toml?ref=c3b78f440e1978a84f7224fe443086c1c91254a1", "patch": "@@ -29,6 +29,7 @@ typed-arena = \"2.0.1\"\n rustc_index = { version = \"0.0.20221221\", package = \"hkalbasi-rustc-ap-rustc_index\", default-features = false }\n \n stdx = { path = \"../stdx\", version = \"0.0.0\" }\n+intern = { path = \"../intern\", version = \"0.0.0\" }\n hir-def = { path = \"../hir-def\", version = \"0.0.0\" }\n hir-expand = { path = \"../hir-expand\", version = \"0.0.0\" }\n base-db = { path = \"../base-db\", version = \"0.0.0\" }"}, {"sha": "f9642aa7475ac3e927992626c0745e17ba24aa9c", "filename": "crates/hir-ty/src/display.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs?ref=c3b78f440e1978a84f7224fe443086c1c91254a1", "patch": "@@ -11,14 +11,14 @@ use hir_def::{\n     db::DefDatabase,\n     find_path,\n     generics::{TypeOrConstParamData, TypeParamProvenance},\n-    intern::{Internable, Interned},\n     item_scope::ItemInNs,\n     path::{Path, PathKind},\n     type_ref::{ConstScalar, TraitBoundModifier, TypeBound, TypeRef},\n     visibility::Visibility,\n     HasModule, ItemContainerId, Lookup, ModuleDefId, ModuleId, TraitId,\n };\n use hir_expand::{hygiene::Hygiene, name::Name};\n+use intern::{Internable, Interned};\n use itertools::Itertools;\n use smallvec::SmallVec;\n use syntax::SmolStr;"}, {"sha": "7bf73560cbe6fb19a7312942d52ef3f9adb8ee95", "filename": "crates/hir-ty/src/interner.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-ty%2Fsrc%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-ty%2Fsrc%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finterner.rs?ref=c3b78f440e1978a84f7224fe443086c1c91254a1", "patch": "@@ -4,11 +4,8 @@\n use crate::{chalk_db, tls, GenericArg};\n use base_db::salsa::InternId;\n use chalk_ir::{Goal, GoalData};\n-use hir_def::{\n-    intern::{impl_internable, InternStorage, Internable, Interned},\n-    type_ref::ConstScalar,\n-    TypeAliasId,\n-};\n+use hir_def::{type_ref::ConstScalar, TypeAliasId};\n+use intern::{impl_internable, Interned};\n use smallvec::SmallVec;\n use std::{fmt, sync::Arc};\n "}, {"sha": "4b1f40f91d6e08ee46059d64f5a41e10434da533", "filename": "crates/hir-ty/src/lower.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flower.rs?ref=c3b78f440e1978a84f7224fe443086c1c91254a1", "patch": "@@ -23,7 +23,6 @@ use hir_def::{\n     generics::{\n         TypeOrConstParamData, TypeParamProvenance, WherePredicate, WherePredicateTypeTarget,\n     },\n-    intern::Interned,\n     lang_item::lang_attr,\n     path::{GenericArg, ModPath, Path, PathKind, PathSegment, PathSegments},\n     resolver::{HasResolver, Resolver, TypeNs},\n@@ -35,6 +34,7 @@ use hir_def::{\n     TypeAliasId, TypeOrConstParamId, TypeParamId, UnionId, VariantId,\n };\n use hir_expand::{name::Name, ExpandResult};\n+use intern::Interned;\n use itertools::Either;\n use la_arena::ArenaMap;\n use rustc_hash::FxHashSet;"}, {"sha": "4f516e18be6e0e664e1a02059d1db87e1ae8fd41", "filename": "crates/hir-ty/src/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-ty%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir-ty%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Futils.rs?ref=c3b78f440e1978a84f7224fe443086c1c91254a1", "patch": "@@ -11,13 +11,13 @@ use hir_def::{\n         GenericParams, TypeOrConstParamData, TypeParamProvenance, WherePredicate,\n         WherePredicateTypeTarget,\n     },\n-    intern::Interned,\n     resolver::{HasResolver, TypeNs},\n     type_ref::{TraitBoundModifier, TypeRef},\n     ConstParamId, FunctionId, GenericDefId, ItemContainerId, Lookup, TraitId, TypeAliasId,\n     TypeOrConstParamId, TypeParamId,\n };\n use hir_expand::name::Name;\n+use intern::Interned;\n use itertools::Either;\n use rustc_hash::FxHashSet;\n use smallvec::{smallvec, SmallVec};"}, {"sha": "ec66660f34a539dfdc12c9489002a60ce42a794c", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=c3b78f440e1978a84f7224fe443086c1c91254a1", "patch": "@@ -107,7 +107,7 @@ pub use {\n     cfg::{CfgAtom, CfgExpr, CfgOptions},\n     hir_def::{\n         adt::StructKind,\n-        attr::{Attr, Attrs, AttrsWithOwner, Documentation},\n+        attr::{Attrs, AttrsWithOwner, Documentation},\n         builtin_attr::AttributeTemplate,\n         find_path::PrefixKind,\n         import_map,\n@@ -122,6 +122,7 @@ pub use {\n         ModuleDefId,\n     },\n     hir_expand::{\n+        attrs::Attr,\n         name::{known, Name},\n         ExpandResult, HirFileId, InFile, MacroFile, Origin,\n     },\n@@ -784,7 +785,7 @@ fn precise_macro_call_location(\n             let token = (|| {\n                 let derive_attr = node\n                     .doc_comments_and_attrs()\n-                    .nth(*derive_attr_index as usize)\n+                    .nth(derive_attr_index.ast_index())\n                     .and_then(Either::left)?;\n                 let token_tree = derive_attr.meta()?.token_tree()?;\n                 let group_by = token_tree\n@@ -812,9 +813,11 @@ fn precise_macro_call_location(\n             let node = ast_id.to_node(db.upcast());\n             let attr = node\n                 .doc_comments_and_attrs()\n-                .nth((*invoc_attr_index) as usize)\n+                .nth(invoc_attr_index.ast_index())\n                 .and_then(Either::left)\n-                .unwrap_or_else(|| panic!(\"cannot find attribute #{invoc_attr_index}\"));\n+                .unwrap_or_else(|| {\n+                    panic!(\"cannot find attribute #{}\", invoc_attr_index.ast_index())\n+                });\n \n             (\n                 ast_id.with_value(SyntaxNodePtr::from(AstPtr::new(&attr))),"}, {"sha": "2b5bfda1d4347ef959f143663534c9e9bfb5256d", "filename": "crates/hir/src/semantics/source_to_def.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs?ref=c3b78f440e1978a84f7224fe443086c1c91254a1", "patch": "@@ -87,7 +87,6 @@\n \n use base_db::FileId;\n use hir_def::{\n-    attr::AttrId,\n     child_by_source::ChildBySource,\n     dyn_map::DynMap,\n     expr::{LabelId, PatId},\n@@ -96,7 +95,7 @@ use hir_def::{\n     GenericDefId, GenericParamId, ImplId, LifetimeParamId, MacroId, ModuleId, StaticId, StructId,\n     TraitId, TypeAliasId, TypeParamId, UnionId, VariantId,\n };\n-use hir_expand::{name::AsName, HirFileId, MacroCallId};\n+use hir_expand::{attrs::AttrId, name::AsName, HirFileId, MacroCallId};\n use rustc_hash::FxHashMap;\n use smallvec::SmallVec;\n use stdx::impl_from;"}, {"sha": "78007fc860ff446c15671c8d00f0e982760d76da", "filename": "crates/intern/Cargo.toml", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fintern%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fintern%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fintern%2FCargo.toml?ref=c3b78f440e1978a84f7224fe443086c1c91254a1", "patch": "@@ -0,0 +1,18 @@\n+[package]\n+name = \"intern\"\n+version = \"0.0.0\"\n+description = \"TBD\"\n+license = \"MIT OR Apache-2.0\"\n+edition = \"2021\"\n+rust-version = \"1.65\"\n+\n+[lib]\n+doctest = false\n+\n+\n+[dependencies]\n+# We need to freeze the version of the crate, as the raw-api feature is considered unstable\n+dashmap = { version = \"=5.4.0\", features = [\"raw-api\"] }\n+hashbrown = { version = \"0.12.1\", default-features = false }\n+once_cell = \"1.15.0\"\n+rustc-hash = \"1.1.0\""}, {"sha": "fb2903696b37352939db88c79b869266724a88ea", "filename": "crates/intern/src/lib.rs", "status": "renamed", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fintern%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3b78f440e1978a84f7224fe443086c1c91254a1/crates%2Fintern%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fintern%2Fsrc%2Flib.rs?ref=c3b78f440e1978a84f7224fe443086c1c91254a1", "patch": "@@ -14,8 +14,6 @@ use hashbrown::HashMap;\n use once_cell::sync::OnceCell;\n use rustc_hash::FxHasher;\n \n-use crate::generics::GenericParams;\n-\n type InternMap<T> = DashMap<Arc<T>, (), BuildHasherDefault<FxHasher>>;\n type Guard<T> = dashmap::RwLockWriteGuard<\n     'static,\n@@ -204,9 +202,9 @@ pub trait Internable: Hash + Eq + 'static {\n #[doc(hidden)]\n macro_rules! _impl_internable {\n     ( $($t:path),+ $(,)? ) => { $(\n-        impl Internable for $t {\n-            fn storage() -> &'static InternStorage<Self> {\n-                static STORAGE: InternStorage<$t> = InternStorage::new();\n+        impl $crate::Internable for $t {\n+            fn storage() -> &'static $crate::InternStorage<Self> {\n+                static STORAGE: $crate::InternStorage<$t> = $crate::InternStorage::new();\n                 &STORAGE\n             }\n         }\n@@ -215,13 +213,4 @@ macro_rules! _impl_internable {\n \n pub use crate::_impl_internable as impl_internable;\n \n-impl_internable!(\n-    crate::type_ref::TypeRef,\n-    crate::type_ref::TraitRef,\n-    crate::type_ref::TypeBound,\n-    crate::path::ModPath,\n-    crate::path::GenericArgs,\n-    crate::attr::AttrInput,\n-    GenericParams,\n-    str,\n-);\n+impl_internable!(str,);", "previous_filename": "crates/hir-def/src/intern.rs"}]}