{"sha": "851a880f52e3d026f4329303df26095f4e42f8f7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1MWE4ODBmNTJlM2QwMjZmNDMyOTMwM2RmMjYwOTVmNGU0MmY4Zjc=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-05-01T21:17:44Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-05-02T20:21:56Z"}, "message": "remove irrelevant comments", "tree": {"sha": "661db4a3c131b204a8d5425d1f6df4c6e7121c54", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/661db4a3c131b204a8d5425d1f6df4c6e7121c54"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/851a880f52e3d026f4329303df26095f4e42f8f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/851a880f52e3d026f4329303df26095f4e42f8f7", "html_url": "https://github.com/rust-lang/rust/commit/851a880f52e3d026f4329303df26095f4e42f8f7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/851a880f52e3d026f4329303df26095f4e42f8f7/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1dd9c3e52a78399ca071728c76fafcd9524f793e", "url": "https://api.github.com/repos/rust-lang/rust/commits/1dd9c3e52a78399ca071728c76fafcd9524f793e", "html_url": "https://github.com/rust-lang/rust/commit/1dd9c3e52a78399ca071728c76fafcd9524f793e"}], "stats": {"total": 132, "additions": 40, "deletions": 92}, "files": [{"sha": "e8ed8bf104cc8892fd60416a4fe752abff12ea48", "filename": "src/librustc/mir/README.md", "status": "modified", "additions": 40, "deletions": 92, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/851a880f52e3d026f4329303df26095f4e42f8f7/src%2Flibrustc%2Fmir%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/851a880f52e3d026f4329303df26095f4e42f8f7/src%2Flibrustc%2Fmir%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2FREADME.md?ref=851a880f52e3d026f4329303df26095f4e42f8f7", "patch": "@@ -32,111 +32,59 @@ MIR and then iteratively optimize it by putting it through various\n pipeline stages. This section describes those pipeline stages and how\n you can extend them.\n \n-Here is a diagram showing the various MIR queries involved in producing\n-the final `optimized_mir()` for a single def-id `D`. The arrows here\n-indicate how data flows from query to query.\n+To produce the `optimized_mir(D)` for a given def-id `D`, the MIR\n+passes through several suites of optimizations, each represented by a\n+query. Each suite consists of multiple optimizations and\n+transformations. These suites represent useful intermediate points\n+where we want to access the MIR for type checking or other purposes:\n \n-```\n-mir_build(D)\n-  -> mir_pass((0,0,D))              ---+ each suite consists of many passes\n-    -> ...                             |\n-      -> mir_pass((0,N,D))             |\n-        -> mir_suite((0,D))         ---+ ---+ there are several suites\n-          -> ...                            |\n-            -> mir_suite((M,D))          ---+\n-              -> mir_optimized(D)\n-```\n-\n-The MIR transformation pipeline is organized into **suites**.  When\n-you ask for `mir_optimized(D)`, it will turn around and request the\n-result from the final **suite** of MIR passes\n-(`mir_suite((M,D))`). This will in turn (eventually) trigger the MIR\n-to be build and then passes through each of the optimization suites.\n-Each suite internally triggers one query for each of its passes\n-(`mir_pass(...)`).\n-\n-The reason for the suites is that they represent points in the MIR\n-transformation pipeline where other bits of code are interested in\n-observing. For example, the `MIR_CONST` suite defines the point where\n-analysis for constant rvalues and expressions can take\n-place. `MIR_OPTIMIZED` naturally represents the point where we\n-actually generate machine code. Nobody should ever request the result\n-of an individual *pass*, at least outside of the transformation\n-pipeline: this allows us to add passes into the appropriate suite\n-without having to modify anything else in the compiler.\n+- `mir_build(D)` -- not a query, but this constructs the initial MIR\n+- `mir_const(D)` -- applies some simple transformations to make MIR ready for constant evaluation;\n+- `mir_validated(D)` -- applies some more transformations, making MIR ready for borrow checking;\n+- `optimized_mir(D)` -- the final state, after all optimizations have been performed.\n \n ### Stealing\n \n-Each of these intermediate queries yields up a `&'tcx\n-Steal<Mir<'tcx>>`, allocated using `tcx.alloc_steal_mir()`. This\n-indicates that the result may be **stolen** by the next pass -- this\n-is an optimization to avoid cloning the MIR. Attempting to use a\n-stolen result will cause a panic in the compiler. Therefore, it is\n-important that you not read directly from these intermediate queries\n-except as part of the MIR processing pipeline.\n+The intermediate queries `mir_const()` and `mir_validated()` yield up\n+a `&'tcx Steal<Mir<'tcx>>`, allocated using\n+`tcx.alloc_steal_mir()`. This indicates that the result may be\n+**stolen** by the next suite of optimizations -- this is an\n+optimization to avoid cloning the MIR. Attempting to use a stolen\n+result will cause a panic in the compiler. Therefore, it is important\n+that you not read directly from these intermediate queries except as\n+part of the MIR processing pipeline.\n \n Because of this stealing mechanism, some care must also be taken to\n ensure that, before the MIR at a particular phase in the processing\n pipeline is stolen, anyone who may want to read from it has already\n-done so. Sometimes this requires **forcing** queries\n-(`ty::queries::foo::force(...)`) during an optimization pass -- this\n-will force a query to execute even though you don't directly require\n-its result. The query can then read the MIR it needs, and -- once it\n-is complete -- you can steal it.\n+done so. Concretely, this means that if you have some query `foo(D)`\n+that wants to access the result of `mir_const(D)` or\n+`mir_validated(D)`, you need to have the successor pass either \"force\"\n+`foo(D)` using `ty::queries::foo::force(...)`. This will force a query\n+to execute even though you don't directly require its result.\n \n As an example, consider MIR const qualification. It wants to read the\n-result produced by the `MIR_CONST` suite. However, that result will be\n-**stolen** by the first pass in the next suite (that pass performs\n-const promotion):\n+result produced by the `mir_const()` suite. However, that result will\n+be **stolen** by the `mir_validated()` suite. If nothing was done,\n+then `mir_const_qualif(D)` would succeed if it came before\n+`mir_validated(D)`, but fail otherwise. Therefore, `mir_validated(D)`\n+will **force** `mir_const_qualif` before it actually steals, thus\n+ensuring that the reads have already happened:\n \n ```\n-mir_suite((MIR_CONST,D)) --read-by--> mir_const_qualif(D)\n-            |\n-        stolen-by\n-            |\n-            v\n-mir_pass((MIR_VALIDATED,0,D))\n+mir_const(D) --read-by--> mir_const_qualif(D)\n+     |                       ^\n+  stolen-by                  |\n+     |                    (forces)\n+     v                       |\n+mir_validated(D) ------------+\n ```\n \n-Therefore, the const promotion pass (the `mir_pass()` in the diagram)\n-will **force** `mir_const_qualif` before it actually steals, thus\n-ensuring that the reads have already happened (and the final result is\n-cached).\n-\n ### Implementing and registering a pass\n \n-To create a new MIR pass, you have to implement one of the MIR pass\n-traits. There are several traits, and you want to pick the most\n-specific one that applies to your pass. They are described here in\n-order of preference. Once you have implemented a trait for your type\n-`Foo`, you then have to insert `Foo` into one of the suites; this is\n-done in `librustc_driver/driver.rs` by invoking `push_pass()` with the\n-appropriate suite.\n-\n-**The `MirPass` trait.** For the most part, a MIR pass works by taking\n-as input the MIR for a single function and mutating it imperatively to\n-perform an optimization. To write such a pass, you can implement the\n-`MirPass` trait, which has a single callback that takes an `&mut Mir`.\n-\n-**The `DefIdPass` trait.** When a `MirPass` trait is executed, the\n-system will automatically steal the result of the previous pass and\n-supply it to you. (See the section on queries and stealing below.)\n-Sometimes you don't want to steal the result of the previous pass\n-right away. In such cases, you can define a `DefIdPass`, which simply\n-gets a callback and lets you decide when to steal the previous result.\n-\n-**The `Pass` trait.** The most primitive but flexible trait is `Pass`.\n-Unlike the other pass types, it returns a `Multi` result, which means\n-it scan be used for interprocedural passes which mutate more than one\n-MIR at a time (e.g., `inline`).\n-\n-### The MIR Context\n-\n-All of the passes when invoked take a `MirCtxt` object. This contains\n-various methods to find out (e.g.) the current pass suite and pass\n-index, the def-id you are operating on, and so forth. You can also\n-access the MIR for the current def-id using `read_previous_mir()`; the\n-\"previous\" refers to the fact that this will be the MIR that was\n-output by the previous pass. Finally, you can `steal_previous_mir()`\n-to steal the output of the current pass (in which case you get\n-ownership of the MIR).\n+To create a new MIR pass, you simply implement the `MirPass` trait for\n+some fresh singleton type `Foo`. Once you have implemented a trait for\n+your type `Foo`, you then have to insert `Foo` into one of the suites;\n+this is done in `librustc_driver/driver.rs` by invoking `push_pass(S,\n+Foo)` with the appropriate suite substituted for `S`.\n+"}]}