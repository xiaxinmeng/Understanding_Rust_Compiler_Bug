{"sha": "83487b8f27a11c95a4d7a1a7e086f1c2ed86b6b0", "node_id": "C_kwDOAAsO6NoAKDgzNDg3YjhmMjdhMTFjOTVhNGQ3YTFhN2UwODZmMWMyZWQ4NmI2YjA", "commit": {"author": {"name": "Mahdi Dibaiee", "email": "mdibaiee@pm.me", "date": "2021-12-30T17:07:05Z"}, "committer": {"name": "Mahdi Dibaiee", "email": "mdibaiee@pm.me", "date": "2022-01-05T08:03:55Z"}, "message": "Rustdoc: resolve associated traits for primitive types\n\nFixes #90703", "tree": {"sha": "7b91864b5863767ef5b1eb14dc693ea5f02c2539", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7b91864b5863767ef5b1eb14dc693ea5f02c2539"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/83487b8f27a11c95a4d7a1a7e086f1c2ed86b6b0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYxDoXUzfgu5d8FXXuroRW98MWYoFAmHVUPAACgkQuroRW98M\nWYoahQ/+N8ayDxa7h0nW4loEIlcINXaUh/F4uoKu2Czzw1qWacEJgxZ797fNUlGh\nh668PaEI76GxMmDDQ0bdEhONN77hPA8Yrodj4/LKqpGBqutjSfjFWAIek9HBO4KK\ncUD7g5m5/m0gTsts0mLx4r0yV2P6/k8ZVS2nyNOiLX7NoQxTc53h/Vwlq2WjFuIm\nC3zTZmjmdNOS/dibXxQ4gfFVWlhgbe0wVMxrsFvHE6EQZefvabzpdRnw3t10qfiV\nQpJH3zUwL+uN6+MlMSjGXk2NjeRMbMAg5WGp3PgwUaZ5VfvvMZ2QBJFFc4dsAl77\n+sq6UfqDmO6kJ1LnVPYtCw5qnbwCFbr327nLCaQ5ki9UVYqZTGJNMiPObCLOeO8J\nXrRZ+QH1z6Ikiek9QkLn9pF8AxwjKzelWrp1V8WCpw+cfVgfI1BxDJDGowZzsI6B\nG8XG8jCQCoaHk3Gmv8iZ2P4gDb/985CJBT/LknVz1IOitw2nJAjPxmdXPh+IEnbx\nA+wcKffzs5MW0V0sPrKGaf6mjAQXMWJqFOB/SxvW7CWWDCdD39bcU7X4j1ECJCuF\nSyyob+tGYp+SLjBcw8O4rRYuZ/kmZ8omF+nZoePqCKSZ2pxZYEqUaj+IjNo4ODwo\nQRH+1Tv4rfseAeVvpjP4QfskZGwVzyoynSB48tKVLU8YGv1udLs=\n=/J0x\n-----END PGP SIGNATURE-----", "payload": "tree 7b91864b5863767ef5b1eb14dc693ea5f02c2539\nparent 26c9b0046f96403cdf959e4e1f874ec25f9dbf6f\nauthor Mahdi Dibaiee <mdibaiee@pm.me> 1640884025 +0000\ncommitter Mahdi Dibaiee <mdibaiee@pm.me> 1641369835 +0000\n\nRustdoc: resolve associated traits for primitive types\n\nFixes #90703\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/83487b8f27a11c95a4d7a1a7e086f1c2ed86b6b0", "html_url": "https://github.com/rust-lang/rust/commit/83487b8f27a11c95a4d7a1a7e086f1c2ed86b6b0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/83487b8f27a11c95a4d7a1a7e086f1c2ed86b6b0/comments", "author": {"login": "mdibaiee", "id": 2807772, "node_id": "MDQ6VXNlcjI4MDc3NzI=", "avatar_url": "https://avatars.githubusercontent.com/u/2807772?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mdibaiee", "html_url": "https://github.com/mdibaiee", "followers_url": "https://api.github.com/users/mdibaiee/followers", "following_url": "https://api.github.com/users/mdibaiee/following{/other_user}", "gists_url": "https://api.github.com/users/mdibaiee/gists{/gist_id}", "starred_url": "https://api.github.com/users/mdibaiee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mdibaiee/subscriptions", "organizations_url": "https://api.github.com/users/mdibaiee/orgs", "repos_url": "https://api.github.com/users/mdibaiee/repos", "events_url": "https://api.github.com/users/mdibaiee/events{/privacy}", "received_events_url": "https://api.github.com/users/mdibaiee/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mdibaiee", "id": 2807772, "node_id": "MDQ6VXNlcjI4MDc3NzI=", "avatar_url": "https://avatars.githubusercontent.com/u/2807772?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mdibaiee", "html_url": "https://github.com/mdibaiee", "followers_url": "https://api.github.com/users/mdibaiee/followers", "following_url": "https://api.github.com/users/mdibaiee/following{/other_user}", "gists_url": "https://api.github.com/users/mdibaiee/gists{/gist_id}", "starred_url": "https://api.github.com/users/mdibaiee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mdibaiee/subscriptions", "organizations_url": "https://api.github.com/users/mdibaiee/orgs", "repos_url": "https://api.github.com/users/mdibaiee/repos", "events_url": "https://api.github.com/users/mdibaiee/events{/privacy}", "received_events_url": "https://api.github.com/users/mdibaiee/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "26c9b0046f96403cdf959e4e1f874ec25f9dbf6f", "url": "https://api.github.com/repos/rust-lang/rust/commits/26c9b0046f96403cdf959e4e1f874ec25f9dbf6f", "html_url": "https://github.com/rust-lang/rust/commit/26c9b0046f96403cdf959e4e1f874ec25f9dbf6f"}], "stats": {"total": 115, "additions": 85, "deletions": 30}, "files": [{"sha": "680a74e5aa63c166b8367a2f307bb166a813ee46", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 76, "deletions": 21, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/83487b8f27a11c95a4d7a1a7e086f1c2ed86b6b0/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83487b8f27a11c95a4d7a1a7e086f1c2ed86b6b0/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=83487b8f27a11c95a4d7a1a7e086f1c2ed86b6b0", "patch": "@@ -13,7 +13,7 @@ use rustc_hir::def::{\n     PerNS,\n };\n use rustc_hir::def_id::{CrateNum, DefId};\n-use rustc_middle::ty::TyCtxt;\n+use rustc_middle::ty::{Ty, TyCtxt};\n use rustc_middle::{bug, span_bug, ty};\n use rustc_resolve::ParentScope;\n use rustc_session::lint::Lint;\n@@ -618,6 +618,44 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         })\n     }\n \n+    /// Convert a PrimitiveType to a Ty, where possible.\n+    ///\n+    /// This is used for resolving trait impls for primitives\n+    fn primitive_type_to_ty(&mut self, prim: PrimitiveType) -> Option<Ty<'tcx>> {\n+        use PrimitiveType::*;\n+        let tcx = self.cx.tcx;\n+\n+        Some(tcx.mk_ty(match prim {\n+            Bool => ty::Bool,\n+            Str => ty::Str,\n+            Char => ty::Char,\n+            Never => ty::Never,\n+            I8 => ty::Int(ty::IntTy::I8),\n+            I16 => ty::Int(ty::IntTy::I16),\n+            I32 => ty::Int(ty::IntTy::I32),\n+            I64 => ty::Int(ty::IntTy::I64),\n+            I128 => ty::Int(ty::IntTy::I128),\n+            Isize => ty::Int(ty::IntTy::Isize),\n+            F32 => ty::Float(ty::FloatTy::F32),\n+            F64 => ty::Float(ty::FloatTy::F64),\n+            U8 => ty::Uint(ty::UintTy::U8),\n+            U16 => ty::Uint(ty::UintTy::U16),\n+            U32 => ty::Uint(ty::UintTy::U32),\n+            U64 => ty::Uint(ty::UintTy::U64),\n+            U128 => ty::Uint(ty::UintTy::U128),\n+            Usize => ty::Uint(ty::UintTy::Usize),\n+            //ty::Tuple(tys) if tys.is_empty() => Res::Primitive(Unit),\n+            //ty::Tuple(_) => Res::Primitive(Tuple),\n+            //ty::Array(..) => Res::Primitive(Array),\n+            //ty::Slice(_) => Res::Primitive(Slice),\n+            //ty::RawPtr(_) => Res::Primitive(RawPointer),\n+            //ty::Ref(..) => Res::Primitive(Reference),\n+            //ty::FnDef(..) => panic!(\"type alias to a function definition\"),\n+            //ty::FnPtr(_) => Res::Primitive(Fn),\n+            _ => return None,\n+        }))\n+    }\n+\n     /// Returns:\n     /// - None if no associated item was found\n     /// - Some((_, _, Some(_))) if an item was found and should go through a side channel\n@@ -632,7 +670,25 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         let tcx = self.cx.tcx;\n \n         match root_res {\n-            Res::Primitive(prim) => self.resolve_primitive_associated_item(prim, ns, item_name),\n+            Res::Primitive(prim) => {\n+                self.resolve_primitive_associated_item(prim, ns, item_name).or_else(|| {\n+                    let assoc_item = self\n+                        .primitive_type_to_ty(prim)\n+                        .map(|ty| {\n+                            resolve_associated_trait_item(ty, module_id, item_name, ns, self.cx)\n+                        })\n+                        .flatten();\n+\n+                    assoc_item.map(|item| {\n+                        let kind = item.kind;\n+                        let fragment = UrlFragment::from_assoc_item(item_name, kind, false);\n+                        // HACK(jynelson): `clean` expects the type, not the associated item\n+                        // but the disambiguator logic expects the associated item.\n+                        // Store the kind in a side channel so that only the disambiguator logic looks at it.\n+                        (root_res, fragment, Some((kind.as_def_kind(), item.def_id)))\n+                    })\n+                })\n+            }\n             Res::Def(DefKind::TyAlias, did) => {\n                 // Resolve the link on the type the alias points to.\n                 // FIXME: if the associated item is defined directly on the type alias,\n@@ -666,8 +722,13 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     // To handle that properly resolve() would have to support\n                     // something like [`ambi_fn`](<SomeStruct as SomeTrait>::ambi_fn)\n                     .or_else(|| {\n-                        let item =\n-                            resolve_associated_trait_item(did, module_id, item_name, ns, self.cx);\n+                        let item = resolve_associated_trait_item(\n+                            tcx.type_of(did),\n+                            module_id,\n+                            item_name,\n+                            ns,\n+                            self.cx,\n+                        );\n                         debug!(\"got associated item {:?}\", item);\n                         item\n                     });\n@@ -767,20 +828,20 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n /// Given `[std::io::Error::source]`, where `source` is unresolved, this would\n /// find `std::error::Error::source` and return\n /// `<io::Error as error::Error>::source`.\n-fn resolve_associated_trait_item(\n-    did: DefId,\n+fn resolve_associated_trait_item<'a>(\n+    ty: Ty<'a>,\n     module: DefId,\n     item_name: Symbol,\n     ns: Namespace,\n-    cx: &mut DocContext<'_>,\n+    cx: &mut DocContext<'a>,\n ) -> Option<ty::AssocItem> {\n     // FIXME: this should also consider blanket impls (`impl<T> X for T`). Unfortunately\n     // `get_auto_trait_and_blanket_impls` is broken because the caching behavior is wrong. In the\n     // meantime, just don't look for these blanket impls.\n \n     // Next consider explicit impls: `impl MyTrait for MyType`\n     // Give precedence to inherent impls.\n-    let traits = traits_implemented_by(cx, did, module);\n+    let traits = traits_implemented_by(cx, ty, module);\n     debug!(\"considering traits {:?}\", traits);\n     let mut candidates = traits.iter().filter_map(|&trait_| {\n         cx.tcx.associated_items(trait_).find_by_name_and_namespace(\n@@ -799,7 +860,11 @@ fn resolve_associated_trait_item(\n ///\n /// NOTE: this cannot be a query because more traits could be available when more crates are compiled!\n /// So it is not stable to serialize cross-crate.\n-fn traits_implemented_by(cx: &mut DocContext<'_>, type_: DefId, module: DefId) -> FxHashSet<DefId> {\n+fn traits_implemented_by<'a>(\n+    cx: &mut DocContext<'a>,\n+    ty: Ty<'a>,\n+    module: DefId,\n+) -> FxHashSet<DefId> {\n     let mut resolver = cx.resolver.borrow_mut();\n     let in_scope_traits = cx.module_trait_cache.entry(module).or_insert_with(|| {\n         resolver.access(|resolver| {\n@@ -813,7 +878,6 @@ fn traits_implemented_by(cx: &mut DocContext<'_>, type_: DefId, module: DefId) -\n     });\n \n     let tcx = cx.tcx;\n-    let ty = tcx.type_of(type_);\n     let iter = in_scope_traits.iter().flat_map(|&trait_| {\n         trace!(\"considering explicit impl for trait {:?}\", trait_);\n \n@@ -826,19 +890,10 @@ fn traits_implemented_by(cx: &mut DocContext<'_>, type_: DefId, module: DefId) -\n                 \"comparing type {} with kind {:?} against type {:?}\",\n                 impl_type,\n                 impl_type.kind(),\n-                type_\n+                ty\n             );\n             // Fast path: if this is a primitive simple `==` will work\n-            let saw_impl = impl_type == ty\n-                || match impl_type.kind() {\n-                    // Check if these are the same def_id\n-                    ty::Adt(def, _) => {\n-                        debug!(\"adt def_id: {:?}\", def.did);\n-                        def.did == type_\n-                    }\n-                    ty::Foreign(def_id) => *def_id == type_,\n-                    _ => false,\n-                };\n+            let saw_impl = impl_type == ty;\n \n             if saw_impl { Some(trait_) } else { None }\n         })"}, {"sha": "587cbad68486422f1cb4d0ed487b1e011cac02d4", "filename": "src/test/rustdoc-ui/intra-doc/non-path-primitives.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/83487b8f27a11c95a4d7a1a7e086f1c2ed86b6b0/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fnon-path-primitives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83487b8f27a11c95a4d7a1a7e086f1c2ed86b6b0/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fnon-path-primitives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fnon-path-primitives.rs?ref=83487b8f27a11c95a4d7a1a7e086f1c2ed86b6b0", "patch": "@@ -28,7 +28,6 @@\n //! [unit::eq] //~ ERROR unresolved\n //! [tuple::eq] //~ ERROR unresolved\n //! [fn::eq] //~ ERROR unresolved\n-//! [never::eq] //~ ERROR unresolved\n \n // FIXME(#78800): This breaks because it's a blanket impl\n // (I think? Might break for other reasons too.)"}, {"sha": "4828a30446355d70b91c605165be598399076039", "filename": "src/test/rustdoc-ui/intra-doc/non-path-primitives.stderr", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/83487b8f27a11c95a4d7a1a7e086f1c2ed86b6b0/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fnon-path-primitives.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/83487b8f27a11c95a4d7a1a7e086f1c2ed86b6b0/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fnon-path-primitives.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fnon-path-primitives.stderr?ref=83487b8f27a11c95a4d7a1a7e086f1c2ed86b6b0", "patch": "@@ -53,17 +53,11 @@ error: unresolved link to `fn::eq`\n LL | //! [fn::eq]\n    |      ^^^^^^ the builtin type `fn` has no associated item named `eq`\n \n-error: unresolved link to `never::eq`\n-  --> $DIR/non-path-primitives.rs:31:6\n-   |\n-LL | //! [never::eq]\n-   |      ^^^^^^^^^ the builtin type `never` has no associated item named `eq`\n-\n error: unresolved link to `reference::deref`\n-  --> $DIR/non-path-primitives.rs:35:6\n+  --> $DIR/non-path-primitives.rs:34:6\n    |\n LL | //! [reference::deref]\n    |      ^^^^^^^^^^^^^^^^ the builtin type `reference` has no associated item named `deref`\n \n-error: aborting due to 9 previous errors\n+error: aborting due to 8 previous errors\n "}, {"sha": "2f9bb86cd0e04366c25220f127c0643a70d522af", "filename": "src/test/rustdoc/intra-doc/prim-associated-traits.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/83487b8f27a11c95a4d7a1a7e086f1c2ed86b6b0/src%2Ftest%2Frustdoc%2Fintra-doc%2Fprim-associated-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83487b8f27a11c95a4d7a1a7e086f1c2ed86b6b0/src%2Ftest%2Frustdoc%2Fintra-doc%2Fprim-associated-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fprim-associated-traits.rs?ref=83487b8f27a11c95a4d7a1a7e086f1c2ed86b6b0", "patch": "@@ -0,0 +1,7 @@\n+use std::{num::ParseFloatError, str::FromStr};\n+\n+// @has 'prim_associated_traits/struct.Number.html' '//a[@href=\"{{channel}}/std/primitive.f64.html#method.from_str\"]' 'f64::from_str()'\n+/// Uses the rules from [`f64::from_str()`].\n+pub struct Number {\n+    pub value: f64,\n+}"}]}