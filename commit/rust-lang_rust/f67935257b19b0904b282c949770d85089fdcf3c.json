{"sha": "f67935257b19b0904b282c949770d85089fdcf3c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2NzkzNTI1N2IxOWIwOTA0YjI4MmM5NDk3NzBkODUwODlmZGNmM2M=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-12T10:46:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-12T10:46:41Z"}, "message": "auto merge of #7696 : glinscott/rust/utf8_perf, r=cmr\n\nMoves multibyte code to it's own function to make char_range_at\r\neasier to inline, and faster for single and multibyte chars.\r\n\r\nBenchmarked reading example.json 100 times, 1.18s before, 1.08s\r\nafter.\r\n\r\nAlso, optimize str::is_utf8 for the single and multibyte case\r\nBefore:\r\nis_utf8_ascii:          272.355162 ms\r\nis_utf8_multibyte:      167.337334 ms\r\n\r\nAfter:\r\nis_utf8_ascii:          218.088049 ms\r\nis_utf8_multibyte:      134.836722 ms", "tree": {"sha": "a3390ee1fa12d5ee8ccd384437feeb96155d82ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a3390ee1fa12d5ee8ccd384437feeb96155d82ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f67935257b19b0904b282c949770d85089fdcf3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f67935257b19b0904b282c949770d85089fdcf3c", "html_url": "https://github.com/rust-lang/rust/commit/f67935257b19b0904b282c949770d85089fdcf3c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f67935257b19b0904b282c949770d85089fdcf3c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d56c9762a363abb5e98f31e43381005863414795", "url": "https://api.github.com/repos/rust-lang/rust/commits/d56c9762a363abb5e98f31e43381005863414795", "html_url": "https://github.com/rust-lang/rust/commit/d56c9762a363abb5e98f31e43381005863414795"}, {"sha": "8926b31088bdb04d1fa772afa0a7dcbc13b38c1f", "url": "https://api.github.com/repos/rust-lang/rust/commits/8926b31088bdb04d1fa772afa0a7dcbc13b38c1f", "html_url": "https://github.com/rust-lang/rust/commit/8926b31088bdb04d1fa772afa0a7dcbc13b38c1f"}], "stats": {"total": 147, "additions": 111, "deletions": 36}, "files": [{"sha": "1d8a2d404a7a361b2e39abfb93b56a015f56b993", "filename": "src/libstd/str.rs", "status": "modified", "additions": 76, "deletions": 36, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/f67935257b19b0904b282c949770d85089fdcf3c/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f67935257b19b0904b282c949770d85089fdcf3c/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=f67935257b19b0904b282c949770d85089fdcf3c", "patch": "@@ -596,17 +596,25 @@ pub fn is_utf8(v: &[u8]) -> bool {\n     let mut i = 0u;\n     let total = v.len();\n     while i < total {\n-        let mut chsize = utf8_char_width(v[i]);\n-        if chsize == 0u { return false; }\n-        if i + chsize > total { return false; }\n-        i += 1u;\n-        while chsize > 1u {\n-            if v[i] & 192u8 != TAG_CONT_U8 { return false; }\n+        if v[i] < 128u8 {\n             i += 1u;\n-            chsize -= 1u;\n+        } else {\n+            let w = utf8_char_width(v[i]);\n+            if w == 0u { return false; }\n+\n+            let nexti = i + w;\n+            if nexti > total { return false; }\n+\n+            if v[i + 1] & 192u8 != TAG_CONT_U8 { return false; }\n+            if w > 2 {\n+                if v[i + 2] & 192u8 != TAG_CONT_U8 { return false; }\n+                if w > 3 && (v[i + 3] & 192u8 != TAG_CONT_U8) { return false; }\n+            }\n+\n+            i = nexti;\n         }\n     }\n-    return true;\n+    true\n }\n \n /// Determines if a vector of `u16` contains valid UTF-16\n@@ -722,17 +730,29 @@ pub fn count_bytes<'b>(s: &'b str, start: uint, n: uint) -> uint {\n     end - start\n }\n \n+// https://tools.ietf.org/html/rfc3629\n+static UTF8_CHAR_WIDTH: [u8, ..256] = [\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 0x1F\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 0x3F\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 0x5F\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 0x7F\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 0x9F\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 0xBF\n+2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,\n+2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, // 0xDF\n+3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3, // 0xEF\n+4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0, // 0xFF\n+];\n+\n /// Given a first byte, determine how many bytes are in this UTF-8 character\n pub fn utf8_char_width(b: u8) -> uint {\n-    let byte: uint = b as uint;\n-    if byte < 128u { return 1u; }\n-    // Not a valid start byte\n-    if byte < 192u { return 0u; }\n-    if byte < 224u { return 2u; }\n-    if byte < 240u { return 3u; }\n-    if byte < 248u { return 4u; }\n-    if byte < 252u { return 5u; }\n-    return 6u;\n+    return UTF8_CHAR_WIDTH[b] as uint;\n }\n \n #[allow(missing_doc)]\n@@ -1714,26 +1734,29 @@ impl<'self> StrSlice<'self> for &'self str {\n      * If `i` is greater than or equal to the length of the string.\n      * If `i` is not the index of the beginning of a valid UTF-8 character.\n      */\n+    #[inline]\n     fn char_range_at(&self, i: uint) -> CharRange {\n-        let b0 = self[i];\n-        let w = utf8_char_width(b0);\n-        assert!((w != 0u));\n-        if w == 1u { return CharRange {ch: b0 as char, next: i + 1u}; }\n-        let mut val = 0u;\n-        let end = i + w;\n-        let mut i = i + 1u;\n-        while i < end {\n-            let byte = self[i];\n-            assert_eq!(byte & 192u8, TAG_CONT_U8);\n-            val <<= 6u;\n-            val += (byte & 63u8) as uint;\n-            i += 1u;\n+        if (self[i] < 128u8) {\n+            return CharRange {ch: self[i] as char, next: i + 1 };\n         }\n-        // Clunky way to get the right bits from the first byte. Uses two shifts,\n-        // the first to clip off the marker bits at the left of the byte, and then\n-        // a second (as uint) to get it to the right position.\n-        val += ((b0 << ((w + 1u) as u8)) as uint) << ((w - 1u) * 6u - w - 1u);\n-        return CharRange {ch: val as char, next: i};\n+\n+        // Multibyte case is a fn to allow char_range_at to inline cleanly\n+        fn multibyte_char_range_at(s: &str, i: uint) -> CharRange {\n+            let mut val = s[i] as uint;\n+            let w = UTF8_CHAR_WIDTH[val] as uint;\n+            assert!((w != 0));\n+\n+            // First byte is special, only want bottom 5 bits for width 2, 4 bits\n+            // for width 3, and 3 bits for width 4\n+            val &= 0x7Fu >> w;\n+            val = (val << 6) | (s[i + 1] & 63u8) as uint;\n+            if w > 2 { val = (val << 6) | (s[i + 2] & 63u8) as uint; }\n+            if w > 3 { val = (val << 6) | (s[i + 3] & 63u8) as uint; }\n+\n+            return CharRange {ch: val as char, next: i + w};\n+        }\n+\n+        return multibyte_char_range_at(*self, i);\n     }\n \n     /// Plucks the character starting at the `i`th byte of a string\n@@ -2430,7 +2453,11 @@ mod tests {\n     fn test_push_char() {\n         let mut data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\";\n         data.push_char('\u534e');\n-        assert_eq!(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\", data);\n+        data.push_char('b'); // 1 byte\n+        data.push_char('\u00a2'); // 2 byte\n+        data.push_char('\u20ac'); // 3 byte\n+        data.push_char('\ud852\udf62'); // 4 byte\n+        assert_eq!(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eb\u00a2\u20ac\ud852\udf62\", data);\n     }\n \n     #[test]\n@@ -3240,6 +3267,19 @@ mod tests {\n         \"22\".cmp(& &\"1234\") == Greater;\n     }\n \n+    #[test]\n+    fn test_char_range_at() {\n+        let data = ~\"b\u00a2\u20ac\ud852\udf62\ud852\udf62\u20ac\u00a2b\";\n+        assert_eq!('b', data.char_range_at(0).ch);\n+        assert_eq!('\u00a2', data.char_range_at(1).ch);\n+        assert_eq!('\u20ac', data.char_range_at(3).ch);\n+        assert_eq!('\ud852\udf62', data.char_range_at(6).ch);\n+        assert_eq!('\ud852\udf62', data.char_range_at(10).ch);\n+        assert_eq!('\u20ac', data.char_range_at(14).ch);\n+        assert_eq!('\u00a2', data.char_range_at(17).ch);\n+        assert_eq!('b', data.char_range_at(19).ch);\n+    }\n+\n     #[test]\n     fn test_char_range_at_reverse_underflow() {\n         assert_eq!(\"abc\".char_range_at_reverse(0).next, 0);"}, {"sha": "82139ca3c16a4116baa61bfb95181bb6d08f308e", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f67935257b19b0904b282c949770d85089fdcf3c/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f67935257b19b0904b282c949770d85089fdcf3c/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=f67935257b19b0904b282c949770d85089fdcf3c", "patch": "@@ -19,6 +19,7 @@ use std::os;\n use std::rand::RngUtil;\n use std::rand;\n use std::result;\n+use std::str;\n use std::uint;\n use std::util;\n use std::vec;\n@@ -36,6 +37,8 @@ fn main() {\n     bench!(vec_plus);\n     bench!(vec_append);\n     bench!(vec_push_all);\n+    bench!(is_utf8_ascii);\n+    bench!(is_utf8_multibyte);\n }\n \n fn maybe_run_test(argv: &[~str], name: ~str, test: &fn()) {\n@@ -127,3 +130,24 @@ fn vec_push_all() {\n         }\n     }\n }\n+\n+fn is_utf8_ascii() {\n+    let mut v : ~[u8] = ~[];\n+    for uint::range(0, 20000) |_| {\n+        v.push('b' as u8);\n+        if !str::is_utf8(v) {\n+            fail!(\"is_utf8 failed\");\n+        }\n+    }\n+}\n+\n+fn is_utf8_multibyte() {\n+    let s = \"b\u00a2\u20ac\ud852\udf62\";\n+    let mut v : ~[u8]= ~[];\n+    for uint::range(0, 5000) |_| {\n+        v.push_all(s.as_bytes());\n+        if !str::is_utf8(v) {\n+            fail!(\"is_utf8 failed\");\n+        }\n+    }\n+}"}, {"sha": "556d7dd521c96481f049eb824514297c9329571d", "filename": "src/test/run-pass/utf8_chars.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f67935257b19b0904b282c949770d85089fdcf3c/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f67935257b19b0904b282c949770d85089fdcf3c/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Futf8_chars.rs?ref=f67935257b19b0904b282c949770d85089fdcf3c", "patch": "@@ -27,9 +27,20 @@ pub fn main() {\n     assert!(s.char_at(1u) == '\u00e9');\n \n     assert!((str::is_utf8(s.as_bytes())));\n+    // invalid prefix\n     assert!((!str::is_utf8(~[0x80_u8])));\n+    // invalid 2 byte prefix\n     assert!((!str::is_utf8(~[0xc0_u8])));\n     assert!((!str::is_utf8(~[0xc0_u8, 0x10_u8])));\n+    // invalid 3 byte prefix\n+    assert!((!str::is_utf8(~[0xe0_u8])));\n+    assert!((!str::is_utf8(~[0xe0_u8, 0x10_u8])));\n+    assert!((!str::is_utf8(~[0xe0_u8, 0xff_u8, 0x10_u8])));\n+    // invalid 4 byte prefix\n+    assert!((!str::is_utf8(~[0xf0_u8])));\n+    assert!((!str::is_utf8(~[0xf0_u8, 0x10_u8])));\n+    assert!((!str::is_utf8(~[0xf0_u8, 0xff_u8, 0x10_u8])));\n+    assert!((!str::is_utf8(~[0xf0_u8, 0xff_u8, 0xff_u8, 0x10_u8])));\n \n     let mut stack = ~\"a\u00d7c\u20ac\";\n     assert_eq!(stack.pop_char(), '\u20ac');"}]}