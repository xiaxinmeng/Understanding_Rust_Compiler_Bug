{"sha": "3c3ae1d0e26c9ae0906dc57daa14bb9e4627e3c8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjM2FlMWQwZTI2YzlhZTA5MDZkYzU3ZGFhMTRiYjllNDYyN2UzYzg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-05T06:55:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-05T06:55:46Z"}, "message": "auto merge of #8875 : alexcrichton/rust/fix-inner-static-library-bug, r=huonw\n\nThese commits fix bugs related to identically named statics in functions of implementations in various situations. The commit messages have most of the information about what bugs are being fixed and why.\r\n\r\nAs a bonus, while I was messing around with name mangling, I improved the backtraces we'll get in gdb by removing `__extensions__` for the trait/type being implemented and by adding the method name as well. Yay!", "tree": {"sha": "47ce723467db1b41debcb0777bf3c1ddfd5147ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/47ce723467db1b41debcb0777bf3c1ddfd5147ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3c3ae1d0e26c9ae0906dc57daa14bb9e4627e3c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3c3ae1d0e26c9ae0906dc57daa14bb9e4627e3c8", "html_url": "https://github.com/rust-lang/rust/commit/3c3ae1d0e26c9ae0906dc57daa14bb9e4627e3c8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3c3ae1d0e26c9ae0906dc57daa14bb9e4627e3c8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2bd628eafab1225cdc59c468c32868302b5e92ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/2bd628eafab1225cdc59c468c32868302b5e92ed", "html_url": "https://github.com/rust-lang/rust/commit/2bd628eafab1225cdc59c468c32868302b5e92ed"}, {"sha": "7baff57f268eff79cd8ed6a8d7fd48d4b3f81878", "url": "https://api.github.com/repos/rust-lang/rust/commits/7baff57f268eff79cd8ed6a8d7fd48d4b3f81878", "html_url": "https://github.com/rust-lang/rust/commit/7baff57f268eff79cd8ed6a8d7fd48d4b3f81878"}], "stats": {"total": 315, "additions": 262, "deletions": 53}, "files": [{"sha": "91e2331ec8c6102b65b3b0b9ccafd715e6c72465", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 76, "deletions": 24, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/3c3ae1d0e26c9ae0906dc57daa14bb9e4627e3c8/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c3ae1d0e26c9ae0906dc57daa14bb9e4627e3c8/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=3c3ae1d0e26c9ae0906dc57daa14bb9e4627e3c8", "patch": "@@ -35,7 +35,7 @@ use std::run;\n use std::str;\n use std::vec;\n use syntax::ast;\n-use syntax::ast_map::{path, path_mod, path_name};\n+use syntax::ast_map::{path, path_mod, path_name, path_pretty_name};\n use syntax::attr;\n use syntax::attr::{AttrMetaMethods};\n use syntax::print::pprust;\n@@ -667,8 +667,7 @@ pub fn truncated_hash_result(symbol_hasher: &mut hash::State) -> ~str {\n pub fn symbol_hash(tcx: ty::ctxt,\n                    symbol_hasher: &mut hash::State,\n                    t: ty::t,\n-                   link_meta: LinkMeta)\n-                   -> @str {\n+                   link_meta: LinkMeta) -> @str {\n     // NB: do *not* use abbrevs here as we want the symbol names\n     // to be independent of one another in the crate.\n \n@@ -723,7 +722,7 @@ pub fn sanitize(s: &str) -> ~str {\n             'a' .. 'z'\n             | 'A' .. 'Z'\n             | '0' .. '9'\n-            | '_' => result.push_char(c),\n+            | '_' | '.' => result.push_char(c),\n \n             _ => {\n                 let mut tstr = ~\"\";\n@@ -744,19 +743,65 @@ pub fn sanitize(s: &str) -> ~str {\n     return result;\n }\n \n-pub fn mangle(sess: Session, ss: path) -> ~str {\n-    // Follow C++ namespace-mangling style\n+pub fn mangle(sess: Session, ss: path,\n+              hash: Option<&str>, vers: Option<&str>) -> ~str {\n+    // Follow C++ namespace-mangling style, see\n+    // http://en.wikipedia.org/wiki/Name_mangling for more info.\n+    //\n+    // It turns out that on OSX you can actually have arbitrary symbols in\n+    // function names (at least when given to LLVM), but this is not possible\n+    // when using unix's linker. Perhaps one day when we just a linker from LLVM\n+    // we won't need to do this name mangling. The problem with name mangling is\n+    // that it seriously limits the available characters. For example we can't\n+    // have things like @T or ~[T] in symbol names when one would theoretically\n+    // want them for things like impls of traits on that type.\n+    //\n+    // To be able to work on all platforms and get *some* reasonable output, we\n+    // use C++ name-mangling.\n+\n+    let mut n = ~\"_ZN\"; // _Z == Begin name-sequence, N == nested\n+\n+    let push = |s: &str| {\n+        let sani = sanitize(s);\n+        n.push_str(fmt!(\"%u%s\", sani.len(), sani));\n+    };\n \n-    let mut n = ~\"_ZN\"; // Begin name-sequence.\n+    // First, connect each component with <len, name> pairs.\n+    for s in ss.iter() {\n+        match *s {\n+            path_name(s) | path_mod(s) | path_pretty_name(s, _) => {\n+                push(sess.str_of(s))\n+            }\n+        }\n+    }\n \n+    // next, if any identifiers are \"pretty\" and need extra information tacked\n+    // on, then use the hash to generate two unique characters. For now\n+    // hopefully 2 characters is enough to avoid collisions.\n+    static EXTRA_CHARS: &'static str =\n+        \"abcdefghijklmnopqrstuvwxyz\\\n+         ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\n+         0123456789\";\n+    let mut hash = match hash { Some(s) => s.to_owned(), None => ~\"\" };\n     for s in ss.iter() {\n         match *s {\n-            path_name(s) | path_mod(s) => {\n-                let sani = sanitize(sess.str_of(s));\n-                n.push_str(fmt!(\"%u%s\", sani.len(), sani));\n+            path_pretty_name(_, extra) => {\n+                let hi = (extra >> 32) as u32 as uint;\n+                let lo = extra as u32 as uint;\n+                hash.push_char(EXTRA_CHARS[hi % EXTRA_CHARS.len()] as char);\n+                hash.push_char(EXTRA_CHARS[lo % EXTRA_CHARS.len()] as char);\n             }\n+            _ => {}\n         }\n     }\n+    if hash.len() > 0 {\n+        push(hash);\n+    }\n+    match vers {\n+        Some(s) => push(s),\n+        None => {}\n+    }\n+\n     n.push_char('E'); // End name-sequence.\n     n\n }\n@@ -765,10 +810,15 @@ pub fn exported_name(sess: Session,\n                      path: path,\n                      hash: &str,\n                      vers: &str) -> ~str {\n-    mangle(sess,\n-           vec::append_one(\n-               vec::append_one(path, path_name(sess.ident_of(hash))),\n-               path_name(sess.ident_of(vers))))\n+    // The version will get mangled to have a leading '_', but it makes more\n+    // sense to lead with a 'v' b/c this is a version...\n+    let vers = if vers.len() > 0 && !char::is_XID_start(vers.char_at(0)) {\n+        \"v\" + vers\n+    } else {\n+        vers.to_owned()\n+    };\n+\n+    mangle(sess, path, Some(hash), Some(vers.as_slice()))\n }\n \n pub fn mangle_exported_name(ccx: &mut CrateContext,\n@@ -786,31 +836,33 @@ pub fn mangle_internal_name_by_type_only(ccx: &mut CrateContext,\n     let s = ppaux::ty_to_short_str(ccx.tcx, t);\n     let hash = get_symbol_hash(ccx, t);\n     return mangle(ccx.sess,\n-        ~[path_name(ccx.sess.ident_of(name)),\n-          path_name(ccx.sess.ident_of(s)),\n-          path_name(ccx.sess.ident_of(hash))]);\n+                  ~[path_name(ccx.sess.ident_of(name)),\n+                    path_name(ccx.sess.ident_of(s))],\n+                  Some(hash.as_slice()),\n+                  None);\n }\n \n pub fn mangle_internal_name_by_type_and_seq(ccx: &mut CrateContext,\n-                                         t: ty::t,\n-                                         name: &str) -> ~str {\n+                                            t: ty::t,\n+                                            name: &str) -> ~str {\n     let s = ppaux::ty_to_str(ccx.tcx, t);\n     let hash = get_symbol_hash(ccx, t);\n     return mangle(ccx.sess,\n-        ~[path_name(ccx.sess.ident_of(s)),\n-          path_name(ccx.sess.ident_of(hash)),\n-          path_name(gensym_name(name))]);\n+                  ~[path_name(ccx.sess.ident_of(s)),\n+                    path_name(gensym_name(name))],\n+                  Some(hash.as_slice()),\n+                  None);\n }\n \n pub fn mangle_internal_name_by_path_and_seq(ccx: &mut CrateContext,\n                                             mut path: path,\n                                             flav: &str) -> ~str {\n     path.push(path_name(gensym_name(flav)));\n-    mangle(ccx.sess, path)\n+    mangle(ccx.sess, path, None, None)\n }\n \n pub fn mangle_internal_name_by_path(ccx: &mut CrateContext, path: path) -> ~str {\n-    mangle(ccx.sess, path)\n+    mangle(ccx.sess, path, None, None)\n }\n \n pub fn mangle_internal_name_by_seq(_ccx: &mut CrateContext, flav: &str) -> ~str {"}, {"sha": "c3bc3e0fe25c1e7ffba2f6fcdd61877f2cf7bda9", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3c3ae1d0e26c9ae0906dc57daa14bb9e4627e3c8/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c3ae1d0e26c9ae0906dc57daa14bb9e4627e3c8/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=3c3ae1d0e26c9ae0906dc57daa14bb9e4627e3c8", "patch": "@@ -188,6 +188,10 @@ pub static tag_impls_impl: uint = 0x84;\n pub static tag_items_data_item_inherent_impl: uint = 0x85;\n pub static tag_items_data_item_extension_impl: uint = 0x86;\n \n+pub static tag_path_elt_pretty_name: uint = 0x87;\n+pub static tag_path_elt_pretty_name_ident: uint = 0x88;\n+pub static tag_path_elt_pretty_name_extra: uint = 0x89;\n+\n pub struct LinkMeta {\n     name: @str,\n     vers: @str,"}, {"sha": "7d173e333fcd5353a265d65a2ef4800163942ef4", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3c3ae1d0e26c9ae0906dc57daa14bb9e4627e3c8/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c3ae1d0e26c9ae0906dc57daa14bb9e4627e3c8/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=3c3ae1d0e26c9ae0906dc57daa14bb9e4627e3c8", "patch": "@@ -303,6 +303,15 @@ fn item_path(item_doc: ebml::Doc) -> ast_map::path {\n         } else if tag == tag_path_elt_name {\n             let str = elt_doc.as_str_slice();\n             result.push(ast_map::path_name(token::str_to_ident(str)));\n+        } else if tag == tag_path_elt_pretty_name {\n+            let name_doc = reader::get_doc(elt_doc,\n+                                           tag_path_elt_pretty_name_ident);\n+            let extra_doc = reader::get_doc(elt_doc,\n+                                            tag_path_elt_pretty_name_extra);\n+            let str = name_doc.as_str_slice();\n+            let extra = reader::doc_as_u64(extra_doc);\n+            result.push(ast_map::path_pretty_name(token::str_to_ident(str),\n+                                                  extra));\n         } else {\n             // ignore tag_path_len element\n         }"}, {"sha": "fb52963f4fc9aa3cec1d6f5a3f8ef9872261751c", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3c3ae1d0e26c9ae0906dc57daa14bb9e4627e3c8/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c3ae1d0e26c9ae0906dc57daa14bb9e4627e3c8/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=3c3ae1d0e26c9ae0906dc57daa14bb9e4627e3c8", "patch": "@@ -359,12 +359,21 @@ fn encode_path(ecx: &EncodeContext,\n     fn encode_path_elt(ecx: &EncodeContext,\n                        ebml_w: &mut writer::Encoder,\n                        elt: ast_map::path_elt) {\n-        let (tag, name) = match elt {\n-          ast_map::path_mod(name) => (tag_path_elt_mod, name),\n-          ast_map::path_name(name) => (tag_path_elt_name, name)\n-        };\n-\n-        ebml_w.wr_tagged_str(tag, ecx.tcx.sess.str_of(name));\n+        match elt {\n+            ast_map::path_mod(n) => {\n+                ebml_w.wr_tagged_str(tag_path_elt_mod, ecx.tcx.sess.str_of(n));\n+            }\n+            ast_map::path_name(n) => {\n+                ebml_w.wr_tagged_str(tag_path_elt_name, ecx.tcx.sess.str_of(n));\n+            }\n+            ast_map::path_pretty_name(n, extra) => {\n+                ebml_w.start_tag(tag_path_elt_pretty_name);\n+                ebml_w.wr_tagged_str(tag_path_elt_pretty_name_ident,\n+                                     ecx.tcx.sess.str_of(n));\n+                ebml_w.wr_tagged_u64(tag_path_elt_pretty_name_extra, extra);\n+                ebml_w.end_tag();\n+            }\n+        }\n     }\n \n     ebml_w.start_tag(tag_path);"}, {"sha": "5f5db9b4487f5defa9cbc83ab7223c1bced6b3d0", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3c3ae1d0e26c9ae0906dc57daa14bb9e4627e3c8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c3ae1d0e26c9ae0906dc57daa14bb9e4627e3c8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=3c3ae1d0e26c9ae0906dc57daa14bb9e4627e3c8", "patch": "@@ -77,7 +77,7 @@ use std::local_data;\n use extra::time;\n use extra::sort;\n use syntax::ast::Ident;\n-use syntax::ast_map::{path, path_elt_to_str, path_name};\n+use syntax::ast_map::{path, path_elt_to_str, path_name, path_pretty_name};\n use syntax::ast_util::{local_def};\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n@@ -2627,8 +2627,7 @@ pub fn register_method(ccx: @mut CrateContext,\n     let mty = ty::node_id_to_type(ccx.tcx, id);\n \n     let mut path = (*path).clone();\n-    path.push(path_name(gensym_name(\"meth\")));\n-    path.push(path_name(m.ident));\n+    path.push(path_pretty_name(m.ident, token::gensym(\"meth\") as u64));\n \n     let sym = exported_name(ccx, path, mty, m.attrs);\n "}, {"sha": "6e4928857f8d1e1269ee531ddf4bf26fa109c13b", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3c3ae1d0e26c9ae0906dc57daa14bb9e4627e3c8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c3ae1d0e26c9ae0906dc57daa14bb9e4627e3c8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=3c3ae1d0e26c9ae0906dc57daa14bb9e4627e3c8", "patch": "@@ -948,7 +948,8 @@ pub fn path_str(sess: session::Session, p: &[path_elt]) -> ~str {\n     let mut first = true;\n     for e in p.iter() {\n         match *e {\n-            ast_map::path_name(s) | ast_map::path_mod(s) => {\n+            ast_map::path_name(s) | ast_map::path_mod(s) |\n+            ast_map::path_pretty_name(s, _) => {\n                 if first {\n                     first = false\n                 } else {"}, {"sha": "76b23d9d536aa56b32fba354e138cb30078fa97e", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3c3ae1d0e26c9ae0906dc57daa14bb9e4627e3c8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c3ae1d0e26c9ae0906dc57daa14bb9e4627e3c8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=3c3ae1d0e26c9ae0906dc57daa14bb9e4627e3c8", "patch": "@@ -34,7 +34,7 @@ use middle::trans::type_::Type;\n \n use std::c_str::ToCStr;\n use std::vec;\n-use syntax::ast_map::{path, path_mod, path_name};\n+use syntax::ast_map::{path, path_mod, path_name, path_pretty_name};\n use syntax::ast_util;\n use syntax::{ast, ast_map};\n use syntax::visit;\n@@ -254,7 +254,7 @@ pub fn trans_static_method_callee(bcx: @mut Block,\n     } else {\n         let path = csearch::get_item_path(bcx.tcx(), method_id);\n         match path[path.len()-1] {\n-            path_name(s) => { s }\n+            path_pretty_name(s, _) | path_name(s) => { s }\n             path_mod(_) => { fail!(\"path doesn't have a name?\") }\n         }\n     };"}, {"sha": "8c1394618e3054976285dc08cb7b3d7c4a044640", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3c3ae1d0e26c9ae0906dc57daa14bb9e4627e3c8/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c3ae1d0e26c9ae0906dc57daa14bb9e4627e3c8/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=3c3ae1d0e26c9ae0906dc57daa14bb9e4627e3c8", "patch": "@@ -799,7 +799,8 @@ impl Repr for ast_map::path_elt {\n     fn repr(&self, tcx: ctxt) -> ~str {\n         match *self {\n             ast_map::path_mod(id) => id.repr(tcx),\n-            ast_map::path_name(id) => id.repr(tcx)\n+            ast_map::path_name(id) => id.repr(tcx),\n+            ast_map::path_pretty_name(id, _) => id.repr(tcx),\n         }\n     }\n }"}, {"sha": "dd991b065e9fd02278c420f1f19a66c00376be9f", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 63, "deletions": 13, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/3c3ae1d0e26c9ae0906dc57daa14bb9e4627e3c8/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c3ae1d0e26c9ae0906dc57daa14bb9e4627e3c8/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=3c3ae1d0e26c9ae0906dc57daa14bb9e4627e3c8", "patch": "@@ -16,6 +16,7 @@ use ast_util;\n use codemap::Span;\n use codemap;\n use diagnostic::span_handler;\n+use parse::token::get_ident_interner;\n use parse::token::ident_interner;\n use parse::token::special_idents;\n use print::pprust;\n@@ -28,7 +29,13 @@ use std::vec;\n #[deriving(Clone, Eq)]\n pub enum path_elt {\n     path_mod(Ident),\n-    path_name(Ident)\n+    path_name(Ident),\n+\n+    // A pretty name can come from an `impl` block. We attempt to select a\n+    // reasonable name for debuggers to see, but to guarantee uniqueness with\n+    // other paths the hash should also be taken into account during symbol\n+    // generation.\n+    path_pretty_name(Ident, u64),\n }\n \n pub type path = ~[path_elt];\n@@ -37,8 +44,9 @@ pub fn path_to_str_with_sep(p: &[path_elt], sep: &str, itr: @ident_interner)\n                          -> ~str {\n     let strs = do p.map |e| {\n         match *e {\n-          path_mod(s) => itr.get(s.name),\n-          path_name(s) => itr.get(s.name)\n+            path_mod(s) | path_name(s) | path_pretty_name(s, _) => {\n+                itr.get(s.name)\n+            }\n         }\n     };\n     strs.connect(sep)\n@@ -58,8 +66,9 @@ pub fn path_to_str(p: &[path_elt], itr: @ident_interner) -> ~str {\n \n pub fn path_elt_to_str(pe: path_elt, itr: @ident_interner) -> ~str {\n     match pe {\n-        path_mod(s) => itr.get(s.name).to_owned(),\n-        path_name(s) => itr.get(s.name).to_owned()\n+        path_mod(s) | path_name(s) | path_pretty_name(s, _) => {\n+            itr.get(s.name).to_owned()\n+        }\n     }\n }\n \n@@ -109,8 +118,8 @@ pub struct Ctx {\n }\n \n impl Ctx {\n-    fn extend(&self, elt: Ident) -> @path {\n-        @vec::append(self.path.clone(), [path_name(elt)])\n+    fn extend(&self, elt: path_elt) -> @path {\n+        @vec::append(self.path.clone(), [elt])\n     }\n \n     fn map_method(&mut self,\n@@ -131,7 +140,7 @@ impl Ctx {\n                       struct_def: @ast::struct_def,\n                       parent_node: ast_node,\n                       ident: ast::Ident) {\n-        let p = self.extend(ident);\n+        let p = self.extend(path_name(ident));\n \n         // If this is a tuple-like struct, register the constructor.\n         match struct_def.ctor_id {\n@@ -173,7 +182,15 @@ impl Ctx {\n         for a in decl.inputs.iter() {\n             self.map.insert(a.id, node_arg(a.pat));\n         }\n+        match *fk {\n+            visit::fk_method(name, _, _) => { self.path.push(path_name(name)) }\n+            _ => {}\n+        }\n         visit::walk_fn(self, fk, decl, body, sp, id, ());\n+        match *fk {\n+            visit::fk_method(*) => { self.path.pop(); }\n+            _ => {}\n+        }\n     }\n \n     fn map_stmt(&mut self, stmt: @Stmt) {\n@@ -199,6 +216,28 @@ impl Ctx {\n \n         visit::walk_pat(self, pat, ());\n     }\n+\n+    fn impl_pretty_name(&self, trait_ref: &Option<trait_ref>,\n+                        ty: &Ty, default: Ident) -> path_elt {\n+        let itr = get_ident_interner();\n+        let ty_ident = match ty.node {\n+            ty_path(ref path, _, _) => path.segments.last().identifier,\n+            _ => default\n+        };\n+        let hash = (trait_ref, ty).hash();\n+        match *trait_ref {\n+            None => path_pretty_name(ty_ident, hash),\n+            Some(ref trait_ref) => {\n+                // XXX: this dollar sign is actually a relic of being one of the\n+                //      very few valid symbol names on unix. These kinds of\n+                //      details shouldn't be exposed way up here in the ast.\n+                let s = fmt!(\"%s$%s\",\n+                             itr.get(trait_ref.path.segments.last().identifier.name),\n+                             itr.get(ty_ident.name));\n+                path_pretty_name(Ident::new(itr.gensym(s)), hash)\n+            }\n+        }\n+    }\n }\n \n impl Visitor<()> for Ctx {\n@@ -207,20 +246,28 @@ impl Visitor<()> for Ctx {\n         let item_path = @self.path.clone();\n         self.map.insert(i.id, node_item(i, item_path));\n         match i.node {\n-            item_impl(_, _, _, ref ms) => {\n+            item_impl(_, ref maybe_trait, ref ty, ref ms) => {\n+                // Right now the ident on impls is __extensions__ which isn't\n+                // very pretty when debugging, so attempt to select a better\n+                // name to use.\n+                let elt = self.impl_pretty_name(maybe_trait, ty, i.ident);\n+\n                 let impl_did = ast_util::local_def(i.id);\n                 for m in ms.iter() {\n-                    let extended = { self.extend(i.ident) };\n+                    let extended = { self.extend(elt) };\n                     self.map_method(impl_did, extended, *m, false)\n                 }\n+\n+                self.path.push(elt);\n             }\n             item_enum(ref enum_definition, _) => {\n                 for v in (*enum_definition).variants.iter() {\n+                    let elt = path_name(i.ident);\n                     // FIXME #2543: bad clone\n                     self.map.insert(v.node.id,\n                                     node_variant((*v).clone(),\n                                                  i,\n-                                                 self.extend(i.ident)));\n+                                                 self.extend(elt)));\n                 }\n             }\n             item_foreign_mod(ref nm) => {\n@@ -239,7 +286,9 @@ impl Visitor<()> for Ctx {\n                                                       // FIXME (#2543)\n                                                       if nm.sort ==\n                                                             ast::named {\n-                                                        self.extend(i.ident)\n+                                                          let e = path_name(\n+                                                              i.ident);\n+                                                          self.extend(e)\n                                                       } else {\n                                                         // Anonymous extern\n                                                         // mods go in the\n@@ -258,7 +307,7 @@ impl Visitor<()> for Ctx {\n                     self.map.insert(p.ref_id, node_item(i, item_path));\n                 }\n                 for tm in methods.iter() {\n-                    let ext = { self.extend(i.ident) };\n+                    let ext = { self.extend(path_name(i.ident)) };\n                     let d_id = ast_util::local_def(i.id);\n                     match *tm {\n                         required(ref m) => {\n@@ -279,6 +328,7 @@ impl Visitor<()> for Ctx {\n             item_mod(_) | item_foreign_mod(_) => {\n                 self.path.push(path_mod(i.ident));\n             }\n+            item_impl(*) => {} // this was guessed above.\n             _ => self.path.push(path_name(i.ident))\n         }\n         visit::walk_item(self, i, ());"}, {"sha": "841da21c5e8459c546cae4a3367036d78d5decc3", "filename": "src/test/auxiliary/inner_static.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/3c3ae1d0e26c9ae0906dc57daa14bb9e4627e3c8/src%2Ftest%2Fauxiliary%2Finner_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c3ae1d0e26c9ae0906dc57daa14bb9e4627e3c8/src%2Ftest%2Fauxiliary%2Finner_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Finner_static.rs?ref=3c3ae1d0e26c9ae0906dc57daa14bb9e4627e3c8", "patch": "@@ -0,0 +1,61 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub struct A<T>;\n+pub struct B<T>;\n+\n+pub mod test {\n+    pub struct A<T>;\n+}\n+\n+impl<T> A<T> {\n+    pub fn foo(&self) -> int {\n+        static a: int = 1;\n+        return a\n+    }\n+\n+    pub fn bar(&self) -> int {\n+        static a: int = 2;\n+        return a;\n+    }\n+}\n+\n+impl<T> B<T> {\n+    pub fn foo(&self) -> int {\n+        static a: int = 3;\n+        return a\n+    }\n+\n+    pub fn bar(&self) -> int {\n+        static a: int = 4;\n+        return a;\n+    }\n+}\n+\n+impl<T> test::A<T> {\n+    pub fn foo(&self) -> int {\n+        static a: int = 5;\n+        return a\n+    }\n+\n+    pub fn bar(&self) -> int {\n+        static a: int = 6;\n+        return a;\n+    }\n+}\n+\n+pub fn foo() -> int {\n+    let a = A::<()>;\n+    let b = B::<()>;\n+    let c = test::A::<()>;\n+    return a.foo() + a.bar() +\n+           b.foo() + b.bar() +\n+           c.foo() + c.bar();\n+}"}, {"sha": "0f5bac795e768771efb7eb6f8180e138323dbbfb", "filename": "src/test/compile-fail/ambig_impl_2_exe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c3ae1d0e26c9ae0906dc57daa14bb9e4627e3c8/src%2Ftest%2Fcompile-fail%2Fambig_impl_2_exe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c3ae1d0e26c9ae0906dc57daa14bb9e4627e3c8/src%2Ftest%2Fcompile-fail%2Fambig_impl_2_exe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fambig_impl_2_exe.rs?ref=3c3ae1d0e26c9ae0906dc57daa14bb9e4627e3c8", "patch": "@@ -15,6 +15,6 @@ use ambig_impl_2_lib::me;\n trait me {\n     fn me(&self) -> uint;\n }\n-impl me for uint { fn me(&self) -> uint { *self } } //~ NOTE is `__extensions__::me`\n+impl me for uint { fn me(&self) -> uint { *self } } //~ NOTE is `me$uint::me`\n fn main() { 1u.me(); } //~ ERROR multiple applicable methods in scope\n //~^ NOTE is `ambig_impl_2_lib::__extensions__::me`"}, {"sha": "df88ff1f0d02eb55eee607f31fc0a5cacf7c8177", "filename": "src/test/compile-fail/ambig_impl_unify.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3c3ae1d0e26c9ae0906dc57daa14bb9e4627e3c8/src%2Ftest%2Fcompile-fail%2Fambig_impl_unify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c3ae1d0e26c9ae0906dc57daa14bb9e4627e3c8/src%2Ftest%2Fcompile-fail%2Fambig_impl_unify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fambig_impl_unify.rs?ref=3c3ae1d0e26c9ae0906dc57daa14bb9e4627e3c8", "patch": "@@ -13,11 +13,11 @@ trait foo {\n }\n \n impl foo for ~[uint] {\n-    fn foo(&self) -> int {1} //~ NOTE candidate #1 is `__extensions__::foo`\n+    fn foo(&self) -> int {1} //~ NOTE candidate #1 is `foo$__extensions__::foo`\n }\n \n impl foo for ~[int] {\n-    fn foo(&self) -> int {2} //~ NOTE candidate #2 is `__extensions__::foo`\n+    fn foo(&self) -> int {2} //~ NOTE candidate #2 is `foo$__extensions__::foo`\n }\n \n fn main() {"}, {"sha": "3bd806aeef3e5df06666458f84f74faee54e3ee7", "filename": "src/test/run-pass/inner-static.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3c3ae1d0e26c9ae0906dc57daa14bb9e4627e3c8/src%2Ftest%2Frun-pass%2Finner-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c3ae1d0e26c9ae0906dc57daa14bb9e4627e3c8/src%2Ftest%2Frun-pass%2Finner-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Finner-static.rs?ref=3c3ae1d0e26c9ae0906dc57daa14bb9e4627e3c8", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:inner_static.rs\n+// xfail-fast\n+\n+extern mod inner_static;\n+\n+pub fn main() {\n+    let a = inner_static::A::<()>;\n+    let b = inner_static::B::<()>;\n+    let c = inner_static::test::A::<()>;\n+    assert_eq!(a.bar(), 2);\n+    assert_eq!(b.bar(), 4);\n+    assert_eq!(c.bar(), 6);\n+}"}]}