{"sha": "925e9a2188dcd6e1988ceaa3ab8d64fcdb3d6d1e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyNWU5YTIxODhkY2Q2ZTE5ODhjZWFhM2FiOGQ2NGZjZGIzZDZkMWU=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2020-03-04T20:37:52Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2020-03-09T09:42:41Z"}, "message": "rustc_parse: Use `Token::ident` where possible", "tree": {"sha": "245d7c2b396a68d2580f9defc4ec04232aef94ba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/245d7c2b396a68d2580f9defc4ec04232aef94ba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/925e9a2188dcd6e1988ceaa3ab8d64fcdb3d6d1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/925e9a2188dcd6e1988ceaa3ab8d64fcdb3d6d1e", "html_url": "https://github.com/rust-lang/rust/commit/925e9a2188dcd6e1988ceaa3ab8d64fcdb3d6d1e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/925e9a2188dcd6e1988ceaa3ab8d64fcdb3d6d1e/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2cb0b8582ebbf9784db9cec06fff517badbf4553", "url": "https://api.github.com/repos/rust-lang/rust/commits/2cb0b8582ebbf9784db9cec06fff517badbf4553", "html_url": "https://github.com/rust-lang/rust/commit/2cb0b8582ebbf9784db9cec06fff517badbf4553"}], "stats": {"total": 178, "additions": 86, "deletions": 92}, "files": [{"sha": "2883159a9f34ca1af05fb9dd435cfd0aa14368dd", "filename": "src/librustc_builtin_macros/format.rs", "status": "modified", "additions": 32, "deletions": 33, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/925e9a2188dcd6e1988ceaa3ab8d64fcdb3d6d1e/src%2Flibrustc_builtin_macros%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/925e9a2188dcd6e1988ceaa3ab8d64fcdb3d6d1e/src%2Flibrustc_builtin_macros%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fformat.rs?ref=925e9a2188dcd6e1988ceaa3ab8d64fcdb3d6d1e", "patch": "@@ -156,44 +156,43 @@ fn parse_args<'a>(\n         if p.token == token::Eof {\n             break;\n         } // accept trailing commas\n-        if p.token.is_ident() && p.look_ahead(1, |t| *t == token::Eq) {\n-            named = true;\n-            let name = if let token::Ident(name, _) = p.normalized_token.kind {\n+        match p.token.ident() {\n+            Some((ident, _)) if p.look_ahead(1, |t| *t == token::Eq) => {\n+                named = true;\n                 p.bump();\n-                name\n-            } else {\n-                unreachable!();\n-            };\n+                p.expect(&token::Eq)?;\n+                let e = p.parse_expr()?;\n+                if let Some(prev) = names.get(&ident.name) {\n+                    ecx.struct_span_err(e.span, &format!(\"duplicate argument named `{}`\", ident))\n+                        .span_label(args[*prev].span, \"previously here\")\n+                        .span_label(e.span, \"duplicate argument\")\n+                        .emit();\n+                    continue;\n+                }\n \n-            p.expect(&token::Eq)?;\n-            let e = p.parse_expr()?;\n-            if let Some(prev) = names.get(&name) {\n-                ecx.struct_span_err(e.span, &format!(\"duplicate argument named `{}`\", name))\n-                    .span_label(args[*prev].span, \"previously here\")\n-                    .span_label(e.span, \"duplicate argument\")\n-                    .emit();\n-                continue;\n+                // Resolve names into slots early.\n+                // Since all the positional args are already seen at this point\n+                // if the input is valid, we can simply append to the positional\n+                // args. And remember the names.\n+                let slot = args.len();\n+                names.insert(ident.name, slot);\n+                args.push(e);\n             }\n-\n-            // Resolve names into slots early.\n-            // Since all the positional args are already seen at this point\n-            // if the input is valid, we can simply append to the positional\n-            // args. And remember the names.\n-            let slot = args.len();\n-            names.insert(name, slot);\n-            args.push(e);\n-        } else {\n-            let e = p.parse_expr()?;\n-            if named {\n-                let mut err = ecx\n-                    .struct_span_err(e.span, \"positional arguments cannot follow named arguments\");\n-                err.span_label(e.span, \"positional arguments must be before named arguments\");\n-                for pos in names.values() {\n-                    err.span_label(args[*pos].span, \"named argument\");\n+            _ => {\n+                let e = p.parse_expr()?;\n+                if named {\n+                    let mut err = ecx.struct_span_err(\n+                        e.span,\n+                        \"positional arguments cannot follow named arguments\",\n+                    );\n+                    err.span_label(e.span, \"positional arguments must be before named arguments\");\n+                    for pos in names.values() {\n+                        err.span_label(args[*pos].span, \"named argument\");\n+                    }\n+                    err.emit();\n                 }\n-                err.emit();\n+                args.push(e);\n             }\n-            args.push(e);\n         }\n     }\n     Ok((fmtstr, args, names))"}, {"sha": "efba3a8ccb1e63923908ac1928716957c242cece", "filename": "src/librustc_expand/mbe/macro_parser.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/925e9a2188dcd6e1988ceaa3ab8d64fcdb3d6d1e/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/925e9a2188dcd6e1988ceaa3ab8d64fcdb3d6d1e/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs?ref=925e9a2188dcd6e1988ceaa3ab8d64fcdb3d6d1e", "patch": "@@ -750,15 +750,9 @@ pub(super) fn parse_tt(parser: &mut Cow<'_, Parser<'_>>, ms: &[TokenTree]) -> Na\n \n /// The token is an identifier, but not `_`.\n /// We prohibit passing `_` to macros expecting `ident` for now.\n-fn get_macro_name(token: &Token) -> Option<(Name, bool)> {\n-    match token.kind {\n-        token::Ident(name, is_raw) if name != kw::Underscore => Some((name, is_raw)),\n-        token::Interpolated(ref nt) => match **nt {\n-            token::NtIdent(ident, is_raw) if ident.name != kw::Underscore => {\n-                Some((ident.name, is_raw))\n-            }\n-            _ => None,\n-        },\n+fn get_macro_ident(token: &Token) -> Option<(Ident, bool)> {\n+    match token.ident() {\n+        Some((ident, is_raw)) if ident.name != kw::Underscore => Some((ident, is_raw)),\n         _ => None,\n     }\n }\n@@ -783,7 +777,7 @@ fn may_begin_with(token: &Token, name: Name) -> bool {\n             && !token.is_keyword(kw::Let)\n         }\n         sym::ty => token.can_begin_type(),\n-        sym::ident => get_macro_name(token).is_some(),\n+        sym::ident => get_macro_ident(token).is_some(),\n         sym::literal => token.can_begin_literal_or_bool(),\n         sym::vis => match token.kind {\n             // The follow-set of :vis + \"priv\" keyword + interpolated\n@@ -888,9 +882,9 @@ fn parse_nt_inner<'a>(p: &mut Parser<'a>, sp: Span, name: Symbol) -> PResult<'a,\n         sym::ty => token::NtTy(p.parse_ty()?),\n         // this could be handled like a token, since it is one\n         sym::ident => {\n-            if let Some((name, is_raw)) = get_macro_name(&p.token) {\n+            if let Some((ident, is_raw)) = get_macro_ident(&p.token) {\n                 p.bump();\n-                token::NtIdent(Ident::new(name, p.normalized_prev_token.span), is_raw)\n+                token::NtIdent(ident, is_raw)\n             } else {\n                 let token_str = pprust::token_to_string(&p.token);\n                 let msg = &format!(\"expected ident, found {}\", &token_str);"}, {"sha": "7c1df531ad16e341167f193314175c0402f07bd0", "filename": "src/librustc_parse/parser/diagnostics.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/925e9a2188dcd6e1988ceaa3ab8d64fcdb3d6d1e/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/925e9a2188dcd6e1988ceaa3ab8d64fcdb3d6d1e/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs?ref=925e9a2188dcd6e1988ceaa3ab8d64fcdb3d6d1e", "patch": "@@ -192,17 +192,19 @@ impl<'a> Parser<'a> {\n             TokenKind::CloseDelim(token::DelimToken::Brace),\n             TokenKind::CloseDelim(token::DelimToken::Paren),\n         ];\n-        if let token::Ident(name, false) = self.normalized_token.kind {\n-            if Ident::new(name, self.normalized_token.span).is_raw_guess()\n-                && self.look_ahead(1, |t| valid_follow.contains(&t.kind))\n+        match self.token.ident() {\n+            Some((ident, false))\n+                if ident.is_raw_guess()\n+                    && self.look_ahead(1, |t| valid_follow.contains(&t.kind)) =>\n             {\n                 err.span_suggestion(\n-                    self.normalized_token.span,\n+                    ident.span,\n                     \"you can escape reserved keywords to use them as identifiers\",\n-                    format!(\"r#{}\", name),\n+                    format!(\"r#{}\", ident.name),\n                     Applicability::MaybeIncorrect,\n                 );\n             }\n+            _ => {}\n         }\n         if let Some(token_descr) = super::token_descr_opt(&self.token) {\n             err.span_label(self.token.span, format!(\"expected identifier, found {}\", token_descr));"}, {"sha": "66266aa5dc4168c63eb06d9d2d266bc0bda5e210", "filename": "src/librustc_parse/parser/expr.rs", "status": "modified", "additions": 26, "deletions": 24, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/925e9a2188dcd6e1988ceaa3ab8d64fcdb3d6d1e/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/925e9a2188dcd6e1988ceaa3ab8d64fcdb3d6d1e/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fexpr.rs?ref=925e9a2188dcd6e1988ceaa3ab8d64fcdb3d6d1e", "patch": "@@ -97,9 +97,10 @@ impl<'a> Parser<'a> {\n     fn parse_expr_catch_underscore(&mut self) -> PResult<'a, P<Expr>> {\n         match self.parse_expr() {\n             Ok(expr) => Ok(expr),\n-            Err(mut err) => match self.normalized_token.kind {\n-                token::Ident(name, false)\n-                    if name == kw::Underscore && self.look_ahead(1, |t| t == &token::Comma) =>\n+            Err(mut err) => match self.token.ident() {\n+                Some((ident, false))\n+                    if ident.name == kw::Underscore\n+                        && self.look_ahead(1, |t| t == &token::Comma) =>\n                 {\n                     // Special-case handling of `foo(_, _, _)`\n                     err.emit();\n@@ -331,21 +332,19 @@ impl<'a> Parser<'a> {\n     ///\n     /// Also performs recovery for `and` / `or` which are mistaken for `&&` and `||` respectively.\n     fn check_assoc_op(&self) -> Option<Spanned<AssocOp>> {\n-        Some(Spanned {\n-            node: match (AssocOp::from_token(&self.token), &self.normalized_token.kind) {\n-                (Some(op), _) => op,\n-                (None, token::Ident(sym::and, false)) => {\n-                    self.error_bad_logical_op(\"and\", \"&&\", \"conjunction\");\n-                    AssocOp::LAnd\n-                }\n-                (None, token::Ident(sym::or, false)) => {\n-                    self.error_bad_logical_op(\"or\", \"||\", \"disjunction\");\n-                    AssocOp::LOr\n-                }\n-                _ => return None,\n-            },\n-            span: self.normalized_token.span,\n-        })\n+        let (op, span) = match (AssocOp::from_token(&self.token), self.token.ident()) {\n+            (Some(op), _) => (op, self.token.span),\n+            (None, Some((ident, false))) if ident.name == sym::and => {\n+                self.error_bad_logical_op(\"and\", \"&&\", \"conjunction\");\n+                (AssocOp::LAnd, ident.span)\n+            }\n+            (None, Some((ident, false))) if ident.name == sym::or => {\n+                self.error_bad_logical_op(\"or\", \"||\", \"disjunction\");\n+                (AssocOp::LOr, ident.span)\n+            }\n+            _ => return None,\n+        };\n+        Some(source_map::respan(span, op))\n     }\n \n     /// Error on `and` and `or` suggesting `&&` and `||` respectively.\n@@ -1907,20 +1906,23 @@ impl<'a> Parser<'a> {\n \n     /// Use in case of error after field-looking code: `S { foo: () with a }`.\n     fn find_struct_error_after_field_looking_code(&self) -> Option<Field> {\n-        if let token::Ident(name, _) = self.normalized_token.kind {\n-            if !self.token.is_reserved_ident() && self.look_ahead(1, |t| *t == token::Colon) {\n-                return Some(ast::Field {\n-                    ident: Ident::new(name, self.normalized_token.span),\n+        match self.token.ident() {\n+            Some((ident, is_raw))\n+                if (is_raw || !ident.is_reserved())\n+                    && self.look_ahead(1, |t| *t == token::Colon) =>\n+            {\n+                Some(ast::Field {\n+                    ident,\n                     span: self.token.span,\n                     expr: self.mk_expr_err(self.token.span),\n                     is_shorthand: false,\n                     attrs: AttrVec::new(),\n                     id: DUMMY_NODE_ID,\n                     is_placeholder: false,\n-                });\n+                })\n             }\n+            _ => None,\n         }\n-        None\n     }\n \n     fn recover_struct_comma_after_dotdot(&mut self, span: Span) {"}, {"sha": "c1b38591f56c3b47d1c8b8014b31b0497c04d828", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/925e9a2188dcd6e1988ceaa3ab8d64fcdb3d6d1e/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/925e9a2188dcd6e1988ceaa3ab8d64fcdb3d6d1e/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=925e9a2188dcd6e1988ceaa3ab8d64fcdb3d6d1e", "patch": "@@ -750,10 +750,10 @@ impl<'a> Parser<'a> {\n     }\n \n     fn parse_ident_or_underscore(&mut self) -> PResult<'a, ast::Ident> {\n-        match self.normalized_token.kind {\n-            token::Ident(name @ kw::Underscore, false) => {\n+        match self.token.ident() {\n+            Some((ident, false)) if ident.name == kw::Underscore => {\n                 self.bump();\n-                Ok(Ident::new(name, self.normalized_prev_token.span))\n+                Ok(ident)\n             }\n             _ => self.parse_ident(),\n         }\n@@ -1609,15 +1609,12 @@ impl<'a> Parser<'a> {\n     /// Returns the parsed optional self parameter and whether a self shortcut was used.\n     fn parse_self_param(&mut self) -> PResult<'a, Option<Param>> {\n         // Extract an identifier *after* having confirmed that the token is one.\n-        let expect_self_ident = |this: &mut Self| {\n-            match this.normalized_token.kind {\n-                // Preserve hygienic context.\n-                token::Ident(name, _) => {\n-                    this.bump();\n-                    Ident::new(name, this.normalized_prev_token.span)\n-                }\n-                _ => unreachable!(),\n+        let expect_self_ident = |this: &mut Self| match this.token.ident() {\n+            Some((ident, false)) => {\n+                this.bump();\n+                ident\n             }\n+            _ => unreachable!(),\n         };\n         // Is `self` `n` tokens ahead?\n         let is_isolated_self = |this: &Self, n| {"}, {"sha": "0e3cee45dcdb0a802a1ae997faa573fd766174ae", "filename": "src/librustc_parse/parser/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/925e9a2188dcd6e1988ceaa3ab8d64fcdb3d6d1e/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/925e9a2188dcd6e1988ceaa3ab8d64fcdb3d6d1e/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmod.rs?ref=925e9a2188dcd6e1988ceaa3ab8d64fcdb3d6d1e", "patch": "@@ -480,9 +480,9 @@ impl<'a> Parser<'a> {\n     }\n \n     fn parse_ident_common(&mut self, recover: bool) -> PResult<'a, ast::Ident> {\n-        match self.normalized_token.kind {\n-            token::Ident(name, _) => {\n-                if self.token.is_reserved_ident() {\n+        match self.token.ident() {\n+            Some((ident, is_raw)) => {\n+                if !is_raw && ident.is_reserved() {\n                     let mut err = self.expected_ident_found();\n                     if recover {\n                         err.emit();\n@@ -491,7 +491,7 @@ impl<'a> Parser<'a> {\n                     }\n                 }\n                 self.bump();\n-                Ok(Ident::new(name, self.normalized_prev_token.span))\n+                Ok(ident)\n             }\n             _ => Err(match self.prev_token.kind {\n                 TokenKind::DocComment(..) => {"}, {"sha": "f88b4fe6ff0a8dfedec357ab9a8802e6797599ce", "filename": "src/librustc_parse/parser/path.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/925e9a2188dcd6e1988ceaa3ab8d64fcdb3d6d1e/src%2Flibrustc_parse%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/925e9a2188dcd6e1988ceaa3ab8d64fcdb3d6d1e/src%2Flibrustc_parse%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fpath.rs?ref=925e9a2188dcd6e1988ceaa3ab8d64fcdb3d6d1e", "patch": "@@ -240,10 +240,10 @@ impl<'a> Parser<'a> {\n     }\n \n     pub(super) fn parse_path_segment_ident(&mut self) -> PResult<'a, Ident> {\n-        match self.normalized_token.kind {\n-            token::Ident(name, _) if name.is_path_segment_keyword() => {\n+        match self.token.ident() {\n+            Some((ident, false)) if ident.is_path_segment_keyword() => {\n                 self.bump();\n-                Ok(Ident::new(name, self.normalized_prev_token.span))\n+                Ok(ident)\n             }\n             _ => self.parse_ident(),\n         }"}]}