{"sha": "e79b2a18a21e6b178d73473bb8fdbf3d18c66051", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3OWIyYTE4YTIxZTZiMTc4ZDczNDczYmI4ZmRiZjNkMThjNjYwNTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-19T12:41:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-19T12:41:38Z"}, "message": "Auto merge of #61172 - matthewjasper:cleanup-implied-bounds-lint, r=varkor\n\nImprove the explicit_outlives_requirements lint\n\n* Don't use Strings to compare parameters\n* Extend the lint to lifetime bounds\n* Extend the lint to enums and unions\n* Use the correct span for where clauses in tuple structs\n* Try to early-out where possible\n* Remove unnecessary bounds in rustc crates", "tree": {"sha": "093258b3615472cfd3dbad9238abc18c1cdc0361", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/093258b3615472cfd3dbad9238abc18c1cdc0361"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e79b2a18a21e6b178d73473bb8fdbf3d18c66051", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e79b2a18a21e6b178d73473bb8fdbf3d18c66051", "html_url": "https://github.com/rust-lang/rust/commit/e79b2a18a21e6b178d73473bb8fdbf3d18c66051", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e79b2a18a21e6b178d73473bb8fdbf3d18c66051/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8", "html_url": "https://github.com/rust-lang/rust/commit/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8"}, {"sha": "fdeb58151370c1a65fa1ff23e7d4b304fca01d2a", "url": "https://api.github.com/repos/rust-lang/rust/commits/fdeb58151370c1a65fa1ff23e7d4b304fca01d2a", "html_url": "https://github.com/rust-lang/rust/commit/fdeb58151370c1a65fa1ff23e7d4b304fca01d2a"}], "stats": {"total": 3977, "additions": 3429, "deletions": 548}, "files": [{"sha": "1777d765cc8a66013c0cdc4f8a0475f7fe820f0a", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e79b2a18a21e6b178d73473bb8fdbf3d18c66051/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e79b2a18a21e6b178d73473bb8fdbf3d18c66051/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=e79b2a18a21e6b178d73473bb8fdbf3d18c66051", "patch": "@@ -773,7 +773,6 @@ pub fn walk_generic_param<'v, V: Visitor<'v>>(visitor: &mut V, param: &'v Generi\n \n pub fn walk_generics<'v, V: Visitor<'v>>(visitor: &mut V, generics: &'v Generics) {\n     walk_list!(visitor, visit_generic_param, &generics.params);\n-    visitor.visit_id(generics.where_clause.hir_id);\n     walk_list!(visitor, visit_where_predicate, &generics.where_clause.predicates);\n }\n "}, {"sha": "996af3672e8bd1fdd5ea9c7713e4604d7d2d0f58", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e79b2a18a21e6b178d73473bb8fdbf3d18c66051/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e79b2a18a21e6b178d73473bb8fdbf3d18c66051/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=e79b2a18a21e6b178d73473bb8fdbf3d18c66051", "patch": "@@ -1755,8 +1755,8 @@ impl<'a> LoweringContext<'a> {\n                 generics: hir::Generics {\n                     params: lifetime_defs,\n                     where_clause: hir::WhereClause {\n-                        hir_id: lctx.next_id(),\n                         predicates: hir_vec![],\n+                        span,\n                     },\n                     span,\n                 },\n@@ -2647,8 +2647,8 @@ impl<'a> LoweringContext<'a> {\n                 generics: hir::Generics {\n                     params: generic_params,\n                     where_clause: hir::WhereClause {\n-                        hir_id: this.next_id(),\n                         predicates: hir_vec![],\n+                        span,\n                     },\n                     span,\n                 },\n@@ -3001,11 +3001,11 @@ impl<'a> LoweringContext<'a> {\n             AnonymousLifetimeMode::ReportError,\n             |this| {\n                 hir::WhereClause {\n-                    hir_id: this.lower_node_id(wc.id),\n                     predicates: wc.predicates\n                         .iter()\n                         .map(|predicate| this.lower_where_predicate(predicate))\n                         .collect(),\n+                    span: wc.span,\n                 }\n             },\n         )"}, {"sha": "527f18f57dc2e9a921d3fce0ec0ae6dbfd0dec48", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e79b2a18a21e6b178d73473bb8fdbf3d18c66051/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e79b2a18a21e6b178d73473bb8fdbf3d18c66051/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=e79b2a18a21e6b178d73473bb8fdbf3d18c66051", "patch": "@@ -592,8 +592,8 @@ impl Generics {\n         Generics {\n             params: HirVec::new(),\n             where_clause: WhereClause {\n-                hir_id: DUMMY_HIR_ID,\n                 predicates: HirVec::new(),\n+                span: DUMMY_SP,\n             },\n             span: DUMMY_SP,\n         }\n@@ -644,19 +644,18 @@ pub enum SyntheticTyParamKind {\n /// A where-clause in a definition.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct WhereClause {\n-    pub hir_id: HirId,\n     pub predicates: HirVec<WherePredicate>,\n+    // Only valid if predicates isn't empty.\n+    span: Span,\n }\n \n impl WhereClause {\n     pub fn span(&self) -> Option<Span> {\n-        self.predicates.iter().map(|predicate| predicate.span())\n-            .fold(None, |acc, i| match (acc, i) {\n-                (None, i) => Some(i),\n-                (Some(acc), i) => {\n-                    Some(acc.to(i))\n-                }\n-            })\n+        if self.predicates.is_empty() {\n+            None\n+        } else {\n+            Some(self.span)\n+        }\n     }\n }\n "}, {"sha": "e1c713b537c2a13435da7b6efa23a5e9be1e1330", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e79b2a18a21e6b178d73473bb8fdbf3d18c66051/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e79b2a18a21e6b178d73473bb8fdbf3d18c66051/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=e79b2a18a21e6b178d73473bb8fdbf3d18c66051", "patch": "@@ -2202,8 +2202,8 @@ impl<'a> State<'a> {\n         let generics = hir::Generics {\n             params: hir::HirVec::new(),\n             where_clause: hir::WhereClause {\n-                hir_id: hir::DUMMY_HIR_ID,\n                 predicates: hir::HirVec::new(),\n+                span: syntax_pos::DUMMY_SP,\n             },\n             span: syntax_pos::DUMMY_SP,\n         };"}, {"sha": "1a4b12b03d8317716ed2e453e27545a4f68e7e82", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 211, "deletions": 101, "changes": 312, "blob_url": "https://github.com/rust-lang/rust/blob/e79b2a18a21e6b178d73473bb8fdbf3d18c66051/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e79b2a18a21e6b178d73473bb8fdbf3d18c66051/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=e79b2a18a21e6b178d73473bb8fdbf3d18c66051", "patch": "@@ -23,7 +23,7 @@\n \n use rustc::hir::def::{Res, DefKind};\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n-use rustc::ty::{self, Ty};\n+use rustc::ty::{self, Ty, TyCtxt};\n use rustc::{lint, util};\n use hir::Node;\n use util::nodemap::HirIdSet;\n@@ -1494,58 +1494,107 @@ impl EarlyLintPass for KeywordIdents {\n declare_lint_pass!(ExplicitOutlivesRequirements => [EXPLICIT_OUTLIVES_REQUIREMENTS]);\n \n impl ExplicitOutlivesRequirements {\n-    fn collect_outlives_bound_spans(\n-        &self,\n-        cx: &LateContext<'_, '_>,\n-        item_def_id: DefId,\n-        param_name: &str,\n-        bounds: &hir::GenericBounds,\n-        infer_static: bool\n-    ) -> Vec<(usize, Span)> {\n-        // For lack of a more elegant strategy for comparing the `ty::Predicate`s\n-        // returned by this query with the params/bounds grabbed from the HIR\u2014and\n-        // with some regrets\u2014we're going to covert the param/lifetime names to\n-        // strings\n-        let inferred_outlives = cx.tcx.inferred_outlives_of(item_def_id);\n-\n-        let ty_lt_names = inferred_outlives.iter().filter_map(|pred| {\n-            let binder = match pred {\n-                ty::Predicate::TypeOutlives(binder) => binder,\n-                _ => { return None; }\n-            };\n-            let ty_outlives_pred = binder.skip_binder();\n-            let ty_name = match ty_outlives_pred.0.sty {\n-                ty::Param(param) => param.name.to_string(),\n-                _ => { return None; }\n-            };\n-            let lt_name = match ty_outlives_pred.1 {\n-                ty::RegionKind::ReEarlyBound(region) => {\n-                    region.name.to_string()\n-                },\n-                _ => { return None; }\n-            };\n-            Some((ty_name, lt_name))\n-        }).collect::<Vec<_>>();\n-\n-        let mut bound_spans = Vec::new();\n-        for (i, bound) in bounds.iter().enumerate() {\n-            if let hir::GenericBound::Outlives(lifetime) = bound {\n-                let is_static = match lifetime.name {\n-                    hir::LifetimeName::Static => true,\n-                    _ => false\n-                };\n-                if is_static && !infer_static {\n-                    // infer-outlives for 'static is still feature-gated (tracking issue #44493)\n-                    continue;\n+    fn lifetimes_outliving_lifetime<'tcx>(\n+        inferred_outlives: &'tcx [ty::Predicate<'tcx>],\n+        index: u32,\n+    ) -> Vec<ty::Region<'tcx>> {\n+        inferred_outlives.iter().filter_map(|pred| {\n+            match pred {\n+                ty::Predicate::RegionOutlives(outlives) => {\n+                    let outlives = outlives.skip_binder();\n+                    match outlives.0 {\n+                        ty::ReEarlyBound(ebr) if ebr.index == index => {\n+                            Some(outlives.1)\n+                        }\n+                        _ => None,\n+                    }\n                 }\n+                _ => None\n+            }\n+        }).collect()\n+    }\n \n-                let lt_name = &lifetime.name.ident().to_string();\n-                if ty_lt_names.contains(&(param_name.to_owned(), lt_name.to_owned())) {\n-                    bound_spans.push((i, bound.span()));\n+    fn lifetimes_outliving_type<'tcx>(\n+        inferred_outlives: &'tcx [ty::Predicate<'tcx>],\n+        index: u32,\n+    ) -> Vec<ty::Region<'tcx>> {\n+        inferred_outlives.iter().filter_map(|pred| {\n+            match pred {\n+                ty::Predicate::TypeOutlives(outlives) => {\n+                    let outlives = outlives.skip_binder();\n+                    if outlives.0.is_param(index) {\n+                        Some(outlives.1)\n+                    } else {\n+                        None\n+                    }\n                 }\n+                _ => None\n+            }\n+        }).collect()\n+    }\n+\n+    fn collect_outlived_lifetimes<'tcx>(\n+        &self,\n+        param: &'tcx hir::GenericParam,\n+        tcx: TyCtxt<'tcx>,\n+        inferred_outlives: &'tcx [ty::Predicate<'tcx>],\n+        ty_generics: &'tcx ty::Generics,\n+    ) -> Vec<ty::Region<'tcx>> {\n+        let index = ty_generics.param_def_id_to_index[\n+            &tcx.hir().local_def_id_from_hir_id(param.hir_id)];\n+\n+        match param.kind {\n+            hir::GenericParamKind::Lifetime { .. } => {\n+                Self::lifetimes_outliving_lifetime(inferred_outlives, index)\n+            }\n+            hir::GenericParamKind::Type { .. } => {\n+                Self::lifetimes_outliving_type(inferred_outlives, index)\n             }\n+            hir::GenericParamKind::Const { .. } => Vec::new(),\n         }\n-        bound_spans\n+    }\n+\n+\n+    fn collect_outlives_bound_spans<'tcx>(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        bounds: &hir::GenericBounds,\n+        inferred_outlives: &[ty::Region<'tcx>],\n+        infer_static: bool,\n+    ) -> Vec<(usize, Span)> {\n+        use rustc::middle::resolve_lifetime::Region;\n+\n+        bounds\n+            .iter()\n+            .enumerate()\n+            .filter_map(|(i, bound)| {\n+                if let hir::GenericBound::Outlives(lifetime) = bound {\n+                    let is_inferred = match tcx.named_region(lifetime.hir_id) {\n+                        Some(Region::Static) if infer_static => {\n+                            inferred_outlives.iter()\n+                                .any(|r| if let ty::ReStatic = r { true } else { false })\n+                        }\n+                        Some(Region::EarlyBound(index, ..)) => inferred_outlives\n+                            .iter()\n+                            .any(|r| {\n+                                if let ty::ReEarlyBound(ebr) = r {\n+                                    ebr.index == index\n+                                } else {\n+                                    false\n+                                }\n+                            }),\n+                        _ => false,\n+                    };\n+                    if is_inferred {\n+                        Some((i, bound.span()))\n+                    } else {\n+                        None\n+                    }\n+                } else {\n+                    None\n+                }\n+            })\n+            .collect()\n     }\n \n     fn consolidate_outlives_bound_spans(\n@@ -1569,7 +1618,7 @@ impl ExplicitOutlivesRequirements {\n             let mut from_start = true;\n             for (i, bound_span) in bound_spans {\n                 match last_merged_i {\n-                    // If the first bound is inferable, our span should also eat the trailing `+`\n+                    // If the first bound is inferable, our span should also eat the leading `+`.\n                     None if i == 0 => {\n                         merged.push(bound_span.to(bounds[1].span().shrink_to_lo()));\n                         last_merged_i = Some(0);\n@@ -1607,26 +1656,48 @@ impl ExplicitOutlivesRequirements {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ExplicitOutlivesRequirements {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::Item) {\n+        use rustc::middle::resolve_lifetime::Region;\n+\n         let infer_static = cx.tcx.features().infer_static_outlives_requirements;\n         let def_id = cx.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n-        if let hir::ItemKind::Struct(_, ref generics) = item.node {\n+        if let hir::ItemKind::Struct(_, ref hir_generics)\n+            | hir::ItemKind::Enum(_, ref hir_generics)\n+            | hir::ItemKind::Union(_, ref hir_generics) = item.node\n+        {\n+            let inferred_outlives = cx.tcx.inferred_outlives_of(def_id);\n+            if inferred_outlives.is_empty() {\n+                return;\n+            }\n+\n+            let ty_generics = cx.tcx.generics_of(def_id);\n+\n             let mut bound_count = 0;\n             let mut lint_spans = Vec::new();\n \n-            for param in &generics.params {\n-                let param_name = match param.kind {\n-                    hir::GenericParamKind::Lifetime { .. } => continue,\n-                    hir::GenericParamKind::Type { .. } => {\n-                        match param.name {\n-                            hir::ParamName::Fresh(_) => continue,\n-                            hir::ParamName::Error => continue,\n-                            hir::ParamName::Plain(name) => name.to_string(),\n-                        }\n+            for param in &hir_generics.params {\n+                let has_lifetime_bounds = param.bounds.iter().any(|bound| {\n+                    if let hir::GenericBound::Outlives(_) = bound {\n+                        true\n+                    } else {\n+                        false\n                     }\n-                    hir::GenericParamKind::Const { .. } => continue,\n-                };\n+                });\n+                if !has_lifetime_bounds {\n+                    continue;\n+                }\n+\n+                let relevant_lifetimes = self.collect_outlived_lifetimes(\n+                    param,\n+                    cx.tcx,\n+                    inferred_outlives,\n+                    ty_generics,\n+                );\n+                if relevant_lifetimes.is_empty() {\n+                    continue;\n+                }\n+\n                 let bound_spans = self.collect_outlives_bound_spans(\n-                    cx, def_id, &param_name, &param.bounds, infer_static\n+                    cx.tcx, &param.bounds, &relevant_lifetimes, infer_static,\n                 );\n                 bound_count += bound_spans.len();\n                 lint_spans.extend(\n@@ -1638,54 +1709,93 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ExplicitOutlivesRequirements {\n \n             let mut where_lint_spans = Vec::new();\n             let mut dropped_predicate_count = 0;\n-            let num_predicates = generics.where_clause.predicates.len();\n-            for (i, where_predicate) in generics.where_clause.predicates.iter().enumerate() {\n-                if let hir::WherePredicate::BoundPredicate(predicate) = where_predicate {\n-                    let param_name = match predicate.bounded_ty.node {\n-                        hir::TyKind::Path(ref qpath) => {\n-                            if let hir::QPath::Resolved(None, ty_param_path) = qpath {\n-                                ty_param_path.segments[0].ident.to_string()\n-                            } else {\n-                                continue;\n-                            }\n-                        },\n-                        _ => { continue; }\n-                    };\n-                    let bound_spans = self.collect_outlives_bound_spans(\n-                        cx, def_id, &param_name, &predicate.bounds, infer_static\n-                    );\n-                    bound_count += bound_spans.len();\n-\n-                    let drop_predicate = bound_spans.len() == predicate.bounds.len();\n-                    if drop_predicate {\n-                        dropped_predicate_count += 1;\n-                    }\n-\n-                    // If all the bounds on a predicate were inferable and there are\n-                    // further predicates, we want to eat the trailing comma\n-                    if drop_predicate && i + 1 < num_predicates {\n-                        let next_predicate_span = generics.where_clause.predicates[i+1].span();\n-                        where_lint_spans.push(\n-                            predicate.span.to(next_predicate_span.shrink_to_lo())\n-                        );\n-                    } else {\n-                        where_lint_spans.extend(\n-                            self.consolidate_outlives_bound_spans(\n-                                predicate.span.shrink_to_lo(),\n+            let num_predicates = hir_generics.where_clause.predicates.len();\n+            for (i, where_predicate) in hir_generics.where_clause.predicates.iter().enumerate() {\n+                let (relevant_lifetimes, bounds, span) = match where_predicate {\n+                    hir::WherePredicate::RegionPredicate(predicate) => {\n+                        if let Some(Region::EarlyBound(index, ..))\n+                            = cx.tcx.named_region(predicate.lifetime.hir_id)\n+                        {\n+                            (\n+                                Self::lifetimes_outliving_lifetime(inferred_outlives, index),\n                                 &predicate.bounds,\n-                                bound_spans\n+                                predicate.span,\n                             )\n-                        );\n+                        } else {\n+                            continue;\n+                        }\n+                    }\n+                    hir::WherePredicate::BoundPredicate(predicate) => {\n+                        // FIXME we can also infer bounds on associated types,\n+                        // and should check for them here.\n+                        match predicate.bounded_ty.node {\n+                            hir::TyKind::Path(hir::QPath::Resolved(\n+                                None,\n+                                ref path,\n+                            )) => {\n+                                if let Res::Def(DefKind::TyParam, def_id) = path.res {\n+                                    let index = ty_generics.param_def_id_to_index[&def_id];\n+                                    (\n+                                        Self::lifetimes_outliving_type(inferred_outlives, index),\n+                                        &predicate.bounds,\n+                                        predicate.span,\n+                                    )\n+                                } else {\n+                                    continue;\n+                                }\n+                            },\n+                            _ => { continue; }\n+                        }\n                     }\n+                    _ => continue,\n+                };\n+                if relevant_lifetimes.is_empty() {\n+                    continue;\n+                }\n+\n+                let bound_spans = self.collect_outlives_bound_spans(\n+                    cx.tcx, bounds, &relevant_lifetimes, infer_static,\n+                );\n+                bound_count += bound_spans.len();\n+\n+                let drop_predicate = bound_spans.len() == bounds.len();\n+                if drop_predicate {\n+                    dropped_predicate_count += 1;\n+                }\n+\n+                // If all the bounds on a predicate were inferable and there are\n+                // further predicates, we want to eat the trailing comma.\n+                if drop_predicate && i + 1 < num_predicates {\n+                    let next_predicate_span = hir_generics.where_clause.predicates[i + 1].span();\n+                    where_lint_spans.push(\n+                        span.to(next_predicate_span.shrink_to_lo())\n+                    );\n+                } else {\n+                    where_lint_spans.extend(\n+                        self.consolidate_outlives_bound_spans(\n+                            span.shrink_to_lo(),\n+                            bounds,\n+                            bound_spans\n+                        )\n+                    );\n                 }\n             }\n \n             // If all predicates are inferable, drop the entire clause\n             // (including the `where`)\n             if num_predicates > 0 && dropped_predicate_count == num_predicates {\n-                let full_where_span = generics.span.shrink_to_hi()\n-                    .to(generics.where_clause.span()\n-                    .expect(\"span of (nonempty) where clause should exist\"));\n+                let where_span = hir_generics.where_clause.span()\n+                    .expect(\"span of (nonempty) where clause should exist\");\n+                // Extend the where clause back to the closing `>` of the\n+                // generics, except for tuple struct, which have the `where`\n+                // after the fields of the struct.\n+                let full_where_span = if let hir::ItemKind::Struct(hir::VariantData::Tuple(..), _)\n+                        = item.node\n+                {\n+                    where_span\n+                } else {\n+                    hir_generics.span.shrink_to_hi().to(where_span)\n+                };\n                 lint_spans.push(\n                     full_where_span\n                 );"}, {"sha": "8236cd1f73857c350386a6a78350a82b332f97be", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e79b2a18a21e6b178d73473bb8fdbf3d18c66051/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e79b2a18a21e6b178d73473bb8fdbf3d18c66051/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=e79b2a18a21e6b178d73473bb8fdbf3d18c66051", "patch": "@@ -2001,16 +2001,15 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 let PathSeg(def_id, index) = path_segs.last().unwrap();\n                 self.ast_path_to_ty(span, *def_id, &path.segments[*index])\n             }\n-            Res::Def(DefKind::TyParam, did) => {\n+            Res::Def(DefKind::TyParam, def_id) => {\n                 assert_eq!(opt_self_ty, None);\n                 self.prohibit_generics(&path.segments);\n \n-                let hir_id = tcx.hir().as_local_hir_id(did).unwrap();\n+                let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n                 let item_id = tcx.hir().get_parent_node_by_hir_id(hir_id);\n                 let item_def_id = tcx.hir().local_def_id_from_hir_id(item_id);\n                 let generics = tcx.generics_of(item_def_id);\n-                let index = generics.param_def_id_to_index[\n-                    &tcx.hir().local_def_id_from_hir_id(hir_id)];\n+                let index = generics.param_def_id_to_index[&def_id];\n                 tcx.mk_ty_param(index, tcx.hir().name_by_hir_id(hir_id).as_interned_str())\n             }\n             Res::SelfTy(Some(_), None) => {"}, {"sha": "b1a62ac81d03314c3d8e35418e3fac9ffc8e7d16", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e79b2a18a21e6b178d73473bb8fdbf3d18c66051/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e79b2a18a21e6b178d73473bb8fdbf3d18c66051/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=e79b2a18a21e6b178d73473bb8fdbf3d18c66051", "patch": "@@ -362,7 +362,6 @@ impl Default for Generics {\n         Generics {\n             params: Vec::new(),\n             where_clause: WhereClause {\n-                id: DUMMY_NODE_ID,\n                 predicates: Vec::new(),\n                 span: DUMMY_SP,\n             },\n@@ -374,7 +373,6 @@ impl Default for Generics {\n /// A where-clause in a definition.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct WhereClause {\n-    pub id: NodeId,\n     pub predicates: Vec<WherePredicate>,\n     pub span: Span,\n }"}, {"sha": "5a5b633e3151ffa55d0f2e539b6cead4376107d2", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e79b2a18a21e6b178d73473bb8fdbf3d18c66051/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e79b2a18a21e6b178d73473bb8fdbf3d18c66051/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=e79b2a18a21e6b178d73473bb8fdbf3d18c66051", "patch": "@@ -750,8 +750,7 @@ pub fn noop_visit_generics<T: MutVisitor>(generics: &mut Generics, vis: &mut T)\n }\n \n pub fn noop_visit_where_clause<T: MutVisitor>(wc: &mut WhereClause, vis: &mut T) {\n-    let WhereClause { id, predicates, span } = wc;\n-    vis.visit_id(id);\n+    let WhereClause { predicates, span } = wc;\n     visit_vec(predicates, |predicate| vis.visit_where_predicate(predicate));\n     vis.visit_span(span);\n }"}, {"sha": "fa697e06d269dcc47bf192a60374a9d5bb5525ae", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e79b2a18a21e6b178d73473bb8fdbf3d18c66051/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e79b2a18a21e6b178d73473bb8fdbf3d18c66051/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=e79b2a18a21e6b178d73473bb8fdbf3d18c66051", "patch": "@@ -5075,7 +5075,6 @@ impl<'a> Parser<'a> {\n         Ok(ast::Generics {\n             params,\n             where_clause: WhereClause {\n-                id: ast::DUMMY_NODE_ID,\n                 predicates: Vec::new(),\n                 span: DUMMY_SP,\n             },\n@@ -5334,7 +5333,6 @@ impl<'a> Parser<'a> {\n     /// ```\n     fn parse_where_clause(&mut self) -> PResult<'a, WhereClause> {\n         let mut where_clause = WhereClause {\n-            id: ast::DUMMY_NODE_ID,\n             predicates: Vec::new(),\n             span: self.prev_span.to(self.prev_span),\n         };"}, {"sha": "0aac4f83658b9d9735dc46200286d0e76ca48fe8", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e79b2a18a21e6b178d73473bb8fdbf3d18c66051/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e79b2a18a21e6b178d73473bb8fdbf3d18c66051/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=e79b2a18a21e6b178d73473bb8fdbf3d18c66051", "patch": "@@ -3042,7 +3042,6 @@ impl<'a> State<'a> {\n         let generics = ast::Generics {\n             params: Vec::new(),\n             where_clause: ast::WhereClause {\n-                id: ast::DUMMY_NODE_ID,\n                 predicates: Vec::new(),\n                 span: syntax_pos::DUMMY_SP,\n             },"}, {"sha": "90d826429da4db27ea777b0ce4e50ed2a55e3ac6", "filename": "src/libsyntax_ext/deriving/generic/ty.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e79b2a18a21e6b178d73473bb8fdbf3d18c66051/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e79b2a18a21e6b178d73473bb8fdbf3d18c66051/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs?ref=e79b2a18a21e6b178d73473bb8fdbf3d18c66051", "patch": "@@ -223,7 +223,6 @@ fn mk_generics(params: Vec<ast::GenericParam>, span: Span) -> Generics {\n     Generics {\n         params,\n         where_clause: ast::WhereClause {\n-            id: ast::DUMMY_NODE_ID,\n             predicates: Vec::new(),\n             span,\n         },"}, {"sha": "069401b3f1829796d9dc1592b69c041b75174b7d", "filename": "src/test/ui/error-codes/E0646.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e79b2a18a21e6b178d73473bb8fdbf3d18c66051/src%2Ftest%2Fui%2Ferror-codes%2FE0646.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e79b2a18a21e6b178d73473bb8fdbf3d18c66051/src%2Ftest%2Fui%2Ferror-codes%2FE0646.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0646.stderr?ref=e79b2a18a21e6b178d73473bb8fdbf3d18c66051", "patch": "@@ -1,8 +1,8 @@\n error[E0646]: `main` function is not allowed to have a `where` clause\n-  --> $DIR/E0646.rs:1:17\n+  --> $DIR/E0646.rs:1:11\n    |\n LL | fn main() where (): Copy {}\n-   |                 ^^^^^^^^ `main` cannot have a `where` clause\n+   |           ^^^^^^^^^^^^^^ `main` cannot have a `where` clause\n \n error: aborting due to previous error\n "}, {"sha": "08cedfaef04ce340ad32317f86562beae575b89b", "filename": "src/test/ui/error-codes/E0647.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e79b2a18a21e6b178d73473bb8fdbf3d18c66051/src%2Ftest%2Fui%2Ferror-codes%2FE0647.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e79b2a18a21e6b178d73473bb8fdbf3d18c66051/src%2Ftest%2Fui%2Ferror-codes%2FE0647.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0647.stderr?ref=e79b2a18a21e6b178d73473bb8fdbf3d18c66051", "patch": "@@ -1,8 +1,8 @@\n error[E0647]: start function is not allowed to have a `where` clause\n-  --> $DIR/E0647.rs:7:56\n+  --> $DIR/E0647.rs:7:50\n    |\n LL | fn start(_: isize, _: *const *const u8) -> isize where (): Copy {\n-   |                                                        ^^^^^^^^ start function cannot have a `where` clause\n+   |                                                  ^^^^^^^^^^^^^^ start function cannot have a `where` clause\n \n error: aborting due to previous error\n "}, {"sha": "28469bee01714b0ffd48a850bc5d76bcde94aa67", "filename": "src/test/ui/issues/issue-50714-1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e79b2a18a21e6b178d73473bb8fdbf3d18c66051/src%2Ftest%2Fui%2Fissues%2Fissue-50714-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e79b2a18a21e6b178d73473bb8fdbf3d18c66051/src%2Ftest%2Fui%2Fissues%2Fissue-50714-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50714-1.stderr?ref=e79b2a18a21e6b178d73473bb8fdbf3d18c66051", "patch": "@@ -1,8 +1,8 @@\n error[E0647]: start function is not allowed to have a `where` clause\n-  --> $DIR/issue-50714-1.rs:9:56\n+  --> $DIR/issue-50714-1.rs:9:50\n    |\n LL | fn start(_: isize, _: *const *const u8) -> isize where fn(&()): Eq {\n-   |                                                        ^^^^^^^^^^^ start function cannot have a `where` clause\n+   |                                                  ^^^^^^^^^^^^^^^^^ start function cannot have a `where` clause\n \n error: aborting due to previous error\n "}, {"sha": "a11aceb6211c57d0862483172d8e520900867c81", "filename": "src/test/ui/issues/issue-50714.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e79b2a18a21e6b178d73473bb8fdbf3d18c66051/src%2Ftest%2Fui%2Fissues%2Fissue-50714.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e79b2a18a21e6b178d73473bb8fdbf3d18c66051/src%2Ftest%2Fui%2Fissues%2Fissue-50714.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50714.stderr?ref=e79b2a18a21e6b178d73473bb8fdbf3d18c66051", "patch": "@@ -1,8 +1,8 @@\n error[E0646]: `main` function is not allowed to have a `where` clause\n-  --> $DIR/issue-50714.rs:3:17\n+  --> $DIR/issue-50714.rs:3:11\n    |\n LL | fn main() where fn(&()): Eq {}\n-   |                 ^^^^^^^^^^^ `main` cannot have a `where` clause\n+   |           ^^^^^^^^^^^^^^^^^ `main` cannot have a `where` clause\n \n error: aborting due to previous error\n "}, {"sha": "0b3de0df2b884827195dca2cb8c2623cf5ddb763", "filename": "src/test/ui/rust-2018/edition-lint-infer-outlives-multispan.rs", "status": "modified", "additions": 335, "deletions": 42, "changes": 377, "blob_url": "https://github.com/rust-lang/rust/blob/e79b2a18a21e6b178d73473bb8fdbf3d18c66051/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives-multispan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e79b2a18a21e6b178d73473bb8fdbf3d18c66051/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives-multispan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives-multispan.rs?ref=e79b2a18a21e6b178d73473bb8fdbf3d18c66051", "patch": "@@ -1,75 +1,368 @@\n #![allow(unused)]\n #![deny(explicit_outlives_requirements)]\n \n-use std::fmt::{Debug, Display};\n \n // These examples should live in edition-lint-infer-outlives.rs, but are split\n // into this separate file because they can't be `rustfix`'d (and thus, can't\n // be part of a `run-rustfix` test file) until rust-lang-nursery/rustfix#141\n // is solved\n \n-struct TeeOutlivesAyIsDebugBee<'a, 'b, T: 'a + Debug + 'b> {\n-    //~^ ERROR outlives requirements can be inferred\n-    tee: &'a &'b T\n+mod structs {\n+    use std::fmt::Debug;\n+\n+    struct TeeOutlivesAyIsDebugBee<'a, 'b, T: 'a + Debug + 'b> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T\n+    }\n+\n+    struct TeeWhereOutlivesAyIsDebugBee<'a, 'b, T> where T: 'a + Debug + 'b {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T\n+    }\n+\n+    struct TeeYooOutlivesAyIsDebugBee<'a, 'b, T, U: 'a + Debug + 'b> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: T,\n+        yoo: &'a &'b U\n+    }\n+\n+    struct TeeOutlivesAyYooBeeIsDebug<'a, 'b, T: 'a, U: 'b + Debug> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a T,\n+        yoo: &'b U\n+    }\n+\n+    struct TeeOutlivesAyYooIsDebugBee<'a, 'b, T: 'a, U: Debug + 'b> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a T,\n+        yoo: &'b U\n+    }\n+\n+    struct TeeOutlivesAyYooWhereBee<'a, 'b, T: 'a, U> where U: 'b {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a T,\n+        yoo: &'b U\n+    }\n+\n+    struct TeeYooWhereOutlivesAyIsDebugBee<'a, 'b, T, U> where U: 'a + Debug + 'b {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: T,\n+        yoo: &'a &'b U\n+    }\n+\n+    struct TeeOutlivesAyYooWhereBeeIsDebug<'a, 'b, T: 'a, U> where U: 'b + Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a T,\n+        yoo: &'b U\n+    }\n+\n+    struct TeeOutlivesAyYooWhereIsDebugBee<'a, 'b, T: 'a, U> where U: Debug + 'b {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a T,\n+        yoo: &'b U\n+    }\n+\n+    struct TeeWhereOutlivesAyYooWhereBeeIsDebug<'a, 'b, T, U> where T: 'a, U: 'b + Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a T,\n+        yoo: &'b U\n+    }\n+\n+    struct TeeWhereOutlivesAyYooWhereIsDebugBee<'a, 'b, T, U> where T: 'a, U: Debug + 'b {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a T,\n+        yoo: &'b U\n+    }\n+\n+    struct BeeOutlivesAyTeeBee<'a, 'b: 'a, T: 'b> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T,\n+    }\n+\n+    struct BeeOutlivesAyTeeAyBee<'a, 'b: 'a, T: 'a + 'b> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T,\n+    }\n+\n+    struct BeeOutlivesAyTeeOutlivesAyIsDebugBee<'a, 'b: 'a, T: 'a + Debug + 'b> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T\n+    }\n+\n+    struct BeeWhereAyTeeWhereOutlivesAyIsDebugBee<'a, 'b, T> where 'b: 'a, T: 'a + Debug + 'b {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T\n+    }\n+\n+    struct BeeOutlivesAyTeeYooOutlivesAyIsDebugBee<'a, 'b: 'a, T, U: 'a + Debug + 'b> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: T,\n+        yoo: &'a &'b U\n+    }\n+\n+    struct BeeWhereAyTeeYooWhereOutlivesAyIsDebugBee<'a, 'b, T, U>\n+        where U: 'a + Debug + 'b, 'b: 'a\n+        //~^ ERROR outlives requirements can be inferred\n+    {\n+        tee: T,\n+        yoo: &'a &'b U\n+    }\n }\n \n-struct TeeWhereOutlivesAyIsDebugBee<'a, 'b, T> where T: 'a + Debug + 'b {\n+mod tuple_structs {\n+    use std::fmt::Debug;\n+\n+    struct TeeOutlivesAyIsDebugBee<'a, 'b, T: 'a + Debug + 'b>(&'a &'b T);\n     //~^ ERROR outlives requirements can be inferred\n-    tee: &'a &'b T\n-}\n \n-struct TeeYooOutlivesAyIsDebugBee<'a, 'b, T, U: 'a + Debug + 'b> {\n+    struct TeeWhereOutlivesAyIsDebugBee<'a, 'b, T>(&'a &'b T) where T: 'a + Debug + 'b;\n     //~^ ERROR outlives requirements can be inferred\n-    tee: T,\n-    yoo: &'a &'b U\n-}\n \n-struct TeeOutlivesAyYooBeeIsDebug<'a, 'b, T: 'a, U: 'b + Debug> {\n+    struct TeeYooOutlivesAyIsDebugBee<'a, 'b, T, U: 'a + Debug + 'b>(T, &'a &'b U);\n     //~^ ERROR outlives requirements can be inferred\n-    tee: &'a T,\n-    yoo: &'b U\n-}\n \n-struct TeeOutlivesAyYooIsDebugBee<'a, 'b, T: 'a, U: Debug + 'b> {\n+    struct TeeOutlivesAyYooBeeIsDebug<'a, 'b, T: 'a, U: 'b + Debug>(&'a T, &'b U);\n     //~^ ERROR outlives requirements can be inferred\n-    tee: &'a T,\n-    yoo: &'b U\n-}\n \n-struct TeeOutlivesAyYooWhereBee<'a, 'b, T: 'a, U> where U: 'b {\n+    struct TeeOutlivesAyYooIsDebugBee<'a, 'b, T: 'a, U: Debug + 'b>(&'a T, &'b U);\n     //~^ ERROR outlives requirements can be inferred\n-    tee: &'a T,\n-    yoo: &'b U\n-}\n \n-struct TeeYooWhereOutlivesAyIsDebugBee<'a, 'b, T, U> where U: 'a + Debug + 'b {\n+    struct TeeOutlivesAyYooWhereBee<'a, 'b, T: 'a, U>(&'a T, &'b U) where U: 'b;\n     //~^ ERROR outlives requirements can be inferred\n-    tee: T,\n-    yoo: &'a &'b U\n-}\n \n-struct TeeOutlivesAyYooWhereBeeIsDebug<'a, 'b, T: 'a, U> where U: 'b + Debug {\n+    struct TeeYooWhereOutlivesAyIsDebugBee<'a, 'b, T, U>(T, &'a &'b U) where U: 'a + Debug + 'b;\n     //~^ ERROR outlives requirements can be inferred\n-    tee: &'a T,\n-    yoo: &'b U\n-}\n \n-struct TeeOutlivesAyYooWhereIsDebugBee<'a, 'b, T: 'a, U> where U: Debug + 'b {\n+    struct TeeOutlivesAyYooWhereBeeIsDebug<'a, 'b, T: 'a, U>(&'a T, &'b U) where U: 'b + Debug;\n     //~^ ERROR outlives requirements can be inferred\n-    tee: &'a T,\n-    yoo: &'b U\n-}\n \n-struct TeeWhereOutlivesAyYooWhereBeeIsDebug<'a, 'b, T, U> where T: 'a, U: 'b + Debug {\n+    struct TeeOutlivesAyYooWhereIsDebugBee<'a, 'b, T: 'a, U>(&'a T, &'b U) where U: Debug + 'b;\n+    //~^ ERROR outlives requirements can be inferred\n+\n+    struct TeeWhereAyYooWhereBeeIsDebug<'a, 'b, T, U>(&'a T, &'b U) where T: 'a, U: 'b + Debug;\n+    //~^ ERROR outlives requirements can be inferred\n+\n+    struct TeeWhereAyYooWhereIsDebugBee<'a, 'b, T, U>(&'a T, &'b U) where T: 'a, U: Debug + 'b;\n+    //~^ ERROR outlives requirements can be inferred\n+\n+    struct BeeOutlivesAyTeeBee<'a, 'b: 'a, T: 'b>(&'a &'b T);\n+    //~^ ERROR outlives requirements can be inferred\n+\n+    struct BeeOutlivesAyTeeAyBee<'a, 'b: 'a, T: 'a + 'b>(&'a &'b T);\n+    //~^ ERROR outlives requirements can be inferred\n+\n+    struct BeeOutlivesAyTeeOutlivesAyIsDebugBee<'a, 'b: 'a, T: 'a + Debug + 'b>(&'a &'b T);\n+    //~^ ERROR outlives requirements can be inferred\n+\n+    struct BeeWhereAyTeeWhereAyIsDebugBee<'a, 'b, T>(&'a &'b T) where 'b: 'a, T: 'a + Debug + 'b;\n     //~^ ERROR outlives requirements can be inferred\n-    tee: &'a T,\n-    yoo: &'b U\n-}\n \n-struct TeeWhereOutlivesAyYooWhereIsDebugBee<'a, 'b, T, U> where T: 'a, U: Debug + 'b {\n+    struct BeeOutlivesAyTeeYooOutlivesAyIsDebugBee<'a, 'b: 'a, T, U: 'a + Debug + 'b>(T, &'a &'b U);\n     //~^ ERROR outlives requirements can be inferred\n-    tee: &'a T,\n-    yoo: &'b U\n+\n+    struct BeeWhereAyTeeYooWhereAyIsDebugBee<'a, 'b, T, U>(T, &'a &'b U)\n+        where U: 'a + Debug + 'b, 'b: 'a;\n+    //~^ ERROR outlives requirements can be inferred\n+}\n+\n+mod enums {\n+    use std::fmt::Debug;\n+\n+    enum TeeOutlivesAyIsDebugBee<'a, 'b, T: 'a + Debug + 'b> {\n+        //~^ ERROR outlives requirements can be inferred\n+        V { tee: &'a &'b T },\n+    }\n+\n+    enum TeeWhereOutlivesAyIsDebugBee<'a, 'b, T> where T: 'a + Debug + 'b {\n+        //~^ ERROR outlives requirements can be inferred\n+        V(&'a &'b T),\n+    }\n+\n+    enum TeeYooOutlivesAyIsDebugBee<'a, 'b, T, U: 'a + Debug + 'b> {\n+        //~^ ERROR outlives requirements can be inferred\n+        V { tee: T, },\n+        W(&'a &'b U),\n+    }\n+\n+    enum TeeOutlivesAyYooBeeIsDebug<'a, 'b, T: 'a, U: 'b + Debug> {\n+        //~^ ERROR outlives requirements can be inferred\n+        V { tee: &'a T, yoo: &'b U },\n+        W,\n+    }\n+\n+    enum TeeOutlivesAyYooIsDebugBee<'a, 'b, T: 'a, U: Debug + 'b> {\n+        //~^ ERROR outlives requirements can be inferred\n+        V(&'a T, &'b U),\n+        W,\n+    }\n+\n+    enum TeeOutlivesAyYooWhereBee<'a, 'b, T: 'a, U> where U: 'b {\n+        //~^ ERROR outlives requirements can be inferred\n+        V { tee: &'a T },\n+        W(&'b U),\n+    }\n+\n+    enum TeeYooWhereOutlivesAyIsDebugBee<'a, 'b, T, U> where U: 'a + Debug + 'b {\n+        //~^ ERROR outlives requirements can be inferred\n+        V { tee: T, yoo: &'a &'b U },\n+        W,\n+    }\n+\n+    enum TeeOutlivesAyYooWhereBeeIsDebug<'a, 'b, T: 'a, U> where U: 'b + Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        V(&'a T, &'b U),\n+        W,\n+    }\n+\n+    enum TeeOutlivesAyYooWhereIsDebugBee<'a, 'b, T: 'a, U> where U: Debug + 'b {\n+        //~^ ERROR outlives requirements can be inferred\n+        V { tee: &'a T },\n+        W(&'b U)\n+    }\n+\n+    enum TeeWhereOutlivesAyYooWhereBeeIsDebug<'a, 'b, T, U> where T: 'a, U: 'b + Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        V { tee: &'a T, yoo: &'b U },\n+        W,\n+    }\n+\n+    enum TeeWhereOutlivesAyYooWhereIsDebugBee<'a, 'b, T, U> where T: 'a, U: Debug + 'b {\n+        //~^ ERROR outlives requirements can be inferred\n+        V(&'a T, &'b U),\n+        W,\n+    }\n+\n+    enum BeeOutlivesAyTeeBee<'a, 'b: 'a, T: 'b> {\n+        //~^ ERROR outlives requirements can be inferred\n+        V { tee: &'a &'b T },\n+    }\n+\n+    enum BeeOutlivesAyTeeAyBee<'a, 'b: 'a, T: 'a + 'b> {\n+        //~^ ERROR outlives requirements can be inferred\n+        V { tee: &'a &'b T },\n+        W,\n+    }\n+\n+    enum BeeOutlivesAyTeeOutlivesAyIsDebugBee<'a, 'b: 'a, T: 'a + Debug + 'b> {\n+        //~^ ERROR outlives requirements can be inferred\n+        V { tee: &'a &'b T },\n+    }\n+\n+    enum BeeWhereAyTeeWhereOutlivesAyIsDebugBee<'a, 'b, T> where 'b: 'a, T: 'a + Debug + 'b {\n+        //~^ ERROR outlives requirements can be inferred\n+        V(&'a &'b T),\n+    }\n+\n+    enum BeeOutlivesAyTeeYooOutlivesAyIsDebugBee<'a, 'b: 'a, T, U: 'a + Debug + 'b> {\n+        //~^ ERROR outlives requirements can be inferred\n+        V { tee: T },\n+        W(&'a &'b U),\n+    }\n+\n+    enum BeeWhereAyTeeYooWhereOutlivesAyIsDebugBee<'a, 'b, T, U> where U: 'a + Debug + 'b, 'b: 'a {\n+        //~^ ERROR outlives requirements can be inferred\n+        V { tee: T, yoo: &'a &'b U },\n+    }\n+}\n+\n+mod unions {\n+    use std::fmt::Debug;\n+\n+    union TeeOutlivesAyIsDebugBee<'a, 'b, T: 'a + Debug + 'b> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T\n+    }\n+\n+    union TeeWhereOutlivesAyIsDebugBee<'a, 'b, T> where T: 'a + Debug + 'b {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T\n+    }\n+\n+    union TeeYooOutlivesAyIsDebugBee<'a, 'b, T, U: 'a + Debug + 'b> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: *const T,\n+        yoo: &'a &'b U\n+    }\n+\n+    union TeeOutlivesAyYooBeeIsDebug<'a, 'b, T: 'a, U: 'b + Debug> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a T,\n+        yoo: &'b U\n+    }\n+\n+    union TeeOutlivesAyYooIsDebugBee<'a, 'b, T: 'a, U: Debug + 'b> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a T,\n+        yoo: &'b U\n+    }\n+\n+    union TeeOutlivesAyYooWhereBee<'a, 'b, T: 'a, U> where U: 'b {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a T,\n+        yoo: &'b U\n+    }\n+\n+    union TeeYooWhereOutlivesAyIsDebugBee<'a, 'b, T, U> where U: 'a + Debug + 'b {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: *const T,\n+        yoo: &'a &'b U\n+    }\n+\n+    union TeeOutlivesAyYooWhereBeeIsDebug<'a, 'b, T: 'a, U> where U: 'b + Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a T,\n+        yoo: &'b U\n+    }\n+\n+    union TeeOutlivesAyYooWhereIsDebugBee<'a, 'b, T: 'a, U> where U: Debug + 'b {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a T,\n+        yoo: &'b U\n+    }\n+\n+    union TeeWhereOutlivesAyYooWhereBeeIsDebug<'a, 'b, T, U> where T: 'a, U: 'b + Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a T,\n+        yoo: &'b U\n+    }\n+\n+    union TeeWhereOutlivesAyYooWhereIsDebugBee<'a, 'b, T, U> where T: 'a, U: Debug + 'b {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a T,\n+        yoo: &'b U\n+    }\n+\n+    union BeeOutlivesAyTeeBee<'a, 'b: 'a, T: 'b> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T,\n+    }\n+\n+    union BeeOutlivesAyTeeAyBee<'a, 'b: 'a, T: 'a + 'b> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T,\n+    }\n+\n+    union BeeOutlivesAyTeeOutlivesAyIsDebugBee<'a, 'b: 'a, T: 'a + Debug + 'b> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T\n+    }\n+\n+    union BeeWhereAyTeeWhereOutlivesAyIsDebugBee<'a, 'b, T> where 'b: 'a, T: 'a + Debug + 'b {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T\n+    }\n+\n+    union BeeOutlivesAyTeeYooOutlivesAyIsDebugBee<'a, 'b: 'a, T, U: 'a + Debug + 'b> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: *const T,\n+        yoo: &'a &'b U\n+    }\n+\n+    union BeeWhereAyTeeYooWhereOutlivesAyIsDebugBee<'a, 'b, T, U> where U: 'a + Debug + 'b, 'b: 'a {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: *const T,\n+        yoo: &'a &'b U\n+    }\n }\n \n fn main() {}"}, {"sha": "e0e846422d3ce33361f321ed4b9d3468827a84ce", "filename": "src/test/ui/rust-2018/edition-lint-infer-outlives-multispan.stderr", "status": "modified", "additions": 626, "deletions": 56, "changes": 682, "blob_url": "https://github.com/rust-lang/rust/blob/e79b2a18a21e6b178d73473bb8fdbf3d18c66051/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives-multispan.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e79b2a18a21e6b178d73473bb8fdbf3d18c66051/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives-multispan.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives-multispan.stderr?ref=e79b2a18a21e6b178d73473bb8fdbf3d18c66051", "patch": "@@ -1,8 +1,8 @@\n error: outlives requirements can be inferred\n-  --> $DIR/edition-lint-infer-outlives-multispan.rs:11:43\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:13:47\n    |\n-LL | struct TeeOutlivesAyIsDebugBee<'a, 'b, T: 'a + Debug + 'b> {\n-   |                                           ^^^^^     ^^^^^\n+LL |     struct TeeOutlivesAyIsDebugBee<'a, 'b, T: 'a + Debug + 'b> {\n+   |                                               ^^^^^     ^^^^^\n    |\n note: lint level defined here\n   --> $DIR/edition-lint-infer-outlives-multispan.rs:2:9\n@@ -11,108 +11,678 @@ LL | #![deny(explicit_outlives_requirements)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n help: remove these bounds\n    |\n-LL | struct TeeOutlivesAyIsDebugBee<'a, 'b, T: Debug> {\n-   |                                          --   --\n+LL |     struct TeeOutlivesAyIsDebugBee<'a, 'b, T: Debug> {\n+   |                                              --   --\n \n error: outlives requirements can be inferred\n-  --> $DIR/edition-lint-infer-outlives-multispan.rs:16:57\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:18:61\n    |\n-LL | struct TeeWhereOutlivesAyIsDebugBee<'a, 'b, T> where T: 'a + Debug + 'b {\n-   |                                                         ^^^^^     ^^^^^\n+LL |     struct TeeWhereOutlivesAyIsDebugBee<'a, 'b, T> where T: 'a + Debug + 'b {\n+   |                                                             ^^^^^     ^^^^^\n help: remove these bounds\n    |\n-LL | struct TeeWhereOutlivesAyIsDebugBee<'a, 'b, T> where T: Debug {\n-   |                                                        --   --\n+LL |     struct TeeWhereOutlivesAyIsDebugBee<'a, 'b, T> where T: Debug {\n+   |                                                            --   --\n \n error: outlives requirements can be inferred\n-  --> $DIR/edition-lint-infer-outlives-multispan.rs:21:49\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:23:53\n    |\n-LL | struct TeeYooOutlivesAyIsDebugBee<'a, 'b, T, U: 'a + Debug + 'b> {\n-   |                                                 ^^^^^     ^^^^^\n+LL |     struct TeeYooOutlivesAyIsDebugBee<'a, 'b, T, U: 'a + Debug + 'b> {\n+   |                                                     ^^^^^     ^^^^^\n help: remove these bounds\n    |\n-LL | struct TeeYooOutlivesAyIsDebugBee<'a, 'b, T, U: Debug> {\n-   |                                                --   --\n+LL |     struct TeeYooOutlivesAyIsDebugBee<'a, 'b, T, U: Debug> {\n+   |                                                    --   --\n \n error: outlives requirements can be inferred\n-  --> $DIR/edition-lint-infer-outlives-multispan.rs:27:44\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:29:48\n    |\n-LL | struct TeeOutlivesAyYooBeeIsDebug<'a, 'b, T: 'a, U: 'b + Debug> {\n-   |                                            ^^^^     ^^^^^\n+LL |     struct TeeOutlivesAyYooBeeIsDebug<'a, 'b, T: 'a, U: 'b + Debug> {\n+   |                                                ^^^^     ^^^^^\n help: remove these bounds\n    |\n-LL | struct TeeOutlivesAyYooBeeIsDebug<'a, 'b, T, U: Debug> {\n-   |                                           --   --\n+LL |     struct TeeOutlivesAyYooBeeIsDebug<'a, 'b, T, U: Debug> {\n+   |                                               --   --\n \n error: outlives requirements can be inferred\n-  --> $DIR/edition-lint-infer-outlives-multispan.rs:33:44\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:35:48\n    |\n-LL | struct TeeOutlivesAyYooIsDebugBee<'a, 'b, T: 'a, U: Debug + 'b> {\n-   |                                            ^^^^          ^^^^^\n+LL |     struct TeeOutlivesAyYooIsDebugBee<'a, 'b, T: 'a, U: Debug + 'b> {\n+   |                                                ^^^^          ^^^^^\n help: remove these bounds\n    |\n-LL | struct TeeOutlivesAyYooIsDebugBee<'a, 'b, T, U: Debug> {\n-   |                                           --        --\n+LL |     struct TeeOutlivesAyYooIsDebugBee<'a, 'b, T, U: Debug> {\n+   |                                               --        --\n \n error: outlives requirements can be inferred\n-  --> $DIR/edition-lint-infer-outlives-multispan.rs:39:42\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:41:46\n    |\n-LL | struct TeeOutlivesAyYooWhereBee<'a, 'b, T: 'a, U> where U: 'b {\n-   |                                          ^^^^    ^^^^^^^^^^^^\n+LL |     struct TeeOutlivesAyYooWhereBee<'a, 'b, T: 'a, U> where U: 'b {\n+   |                                              ^^^^    ^^^^^^^^^^^^\n help: remove these bounds\n    |\n-LL | struct TeeOutlivesAyYooWhereBee<'a, 'b, T, U> {\n-   |                                         --  --\n+LL |     struct TeeOutlivesAyYooWhereBee<'a, 'b, T, U> {\n+   |                                             --  --\n \n error: outlives requirements can be inferred\n-  --> $DIR/edition-lint-infer-outlives-multispan.rs:45:63\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:47:67\n    |\n-LL | struct TeeYooWhereOutlivesAyIsDebugBee<'a, 'b, T, U> where U: 'a + Debug + 'b {\n-   |                                                               ^^^^^     ^^^^^\n+LL |     struct TeeYooWhereOutlivesAyIsDebugBee<'a, 'b, T, U> where U: 'a + Debug + 'b {\n+   |                                                                   ^^^^^     ^^^^^\n help: remove these bounds\n    |\n-LL | struct TeeYooWhereOutlivesAyIsDebugBee<'a, 'b, T, U> where U: Debug {\n-   |                                                              --   --\n+LL |     struct TeeYooWhereOutlivesAyIsDebugBee<'a, 'b, T, U> where U: Debug {\n+   |                                                                  --   --\n \n error: outlives requirements can be inferred\n-  --> $DIR/edition-lint-infer-outlives-multispan.rs:51:49\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:53:53\n    |\n-LL | struct TeeOutlivesAyYooWhereBeeIsDebug<'a, 'b, T: 'a, U> where U: 'b + Debug {\n-   |                                                 ^^^^              ^^^^^\n+LL |     struct TeeOutlivesAyYooWhereBeeIsDebug<'a, 'b, T: 'a, U> where U: 'b + Debug {\n+   |                                                     ^^^^              ^^^^^\n help: remove these bounds\n    |\n-LL | struct TeeOutlivesAyYooWhereBeeIsDebug<'a, 'b, T, U> where U: Debug {\n-   |                                                --            --\n+LL |     struct TeeOutlivesAyYooWhereBeeIsDebug<'a, 'b, T, U> where U: Debug {\n+   |                                                    --            --\n \n error: outlives requirements can be inferred\n-  --> $DIR/edition-lint-infer-outlives-multispan.rs:57:49\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:59:53\n    |\n-LL | struct TeeOutlivesAyYooWhereIsDebugBee<'a, 'b, T: 'a, U> where U: Debug + 'b {\n-   |                                                 ^^^^                   ^^^^^\n+LL |     struct TeeOutlivesAyYooWhereIsDebugBee<'a, 'b, T: 'a, U> where U: Debug + 'b {\n+   |                                                     ^^^^                   ^^^^^\n help: remove these bounds\n    |\n-LL | struct TeeOutlivesAyYooWhereIsDebugBee<'a, 'b, T, U> where U: Debug {\n-   |                                                --                 --\n+LL |     struct TeeOutlivesAyYooWhereIsDebugBee<'a, 'b, T, U> where U: Debug {\n+   |                                                    --                 --\n \n error: outlives requirements can be inferred\n-  --> $DIR/edition-lint-infer-outlives-multispan.rs:63:65\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:65:69\n    |\n-LL | struct TeeWhereOutlivesAyYooWhereBeeIsDebug<'a, 'b, T, U> where T: 'a, U: 'b + Debug {\n-   |                                                                 ^^^^^^^   ^^^^^\n+LL |     struct TeeWhereOutlivesAyYooWhereBeeIsDebug<'a, 'b, T, U> where T: 'a, U: 'b + Debug {\n+   |                                                                     ^^^^^^^   ^^^^^\n help: remove these bounds\n    |\n-LL | struct TeeWhereOutlivesAyYooWhereBeeIsDebug<'a, 'b, T, U> where U: Debug {\n-   |                                                                -- --\n+LL |     struct TeeWhereOutlivesAyYooWhereBeeIsDebug<'a, 'b, T, U> where U: Debug {\n+   |                                                                    -- --\n \n error: outlives requirements can be inferred\n-  --> $DIR/edition-lint-infer-outlives-multispan.rs:69:65\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:71:69\n    |\n-LL | struct TeeWhereOutlivesAyYooWhereIsDebugBee<'a, 'b, T, U> where T: 'a, U: Debug + 'b {\n-   |                                                                 ^^^^^^^        ^^^^^\n+LL |     struct TeeWhereOutlivesAyYooWhereIsDebugBee<'a, 'b, T, U> where T: 'a, U: Debug + 'b {\n+   |                                                                     ^^^^^^^        ^^^^^\n help: remove these bounds\n    |\n-LL | struct TeeWhereOutlivesAyYooWhereIsDebugBee<'a, 'b, T, U> where U: Debug {\n-   |                                                                --      --\n+LL |     struct TeeWhereOutlivesAyYooWhereIsDebugBee<'a, 'b, T, U> where U: Debug {\n+   |                                                                    --      --\n \n-error: aborting due to 11 previous errors\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:77:38\n+   |\n+LL |     struct BeeOutlivesAyTeeBee<'a, 'b: 'a, T: 'b> {\n+   |                                      ^^^^   ^^^^\n+help: remove these bounds\n+   |\n+LL |     struct BeeOutlivesAyTeeBee<'a, 'b, T> {\n+   |                                     -- --\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:82:40\n+   |\n+LL |     struct BeeOutlivesAyTeeAyBee<'a, 'b: 'a, T: 'a + 'b> {\n+   |                                        ^^^^   ^^^^^^^^^\n+help: remove these bounds\n+   |\n+LL |     struct BeeOutlivesAyTeeAyBee<'a, 'b, T> {\n+   |                                       -- --\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:87:55\n+   |\n+LL |     struct BeeOutlivesAyTeeOutlivesAyIsDebugBee<'a, 'b: 'a, T: 'a + Debug + 'b> {\n+   |                                                       ^^^^     ^^^^^     ^^^^^\n+help: remove these bounds\n+   |\n+LL |     struct BeeOutlivesAyTeeOutlivesAyIsDebugBee<'a, 'b, T: Debug> {\n+   |                                                      --   --   --\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:92:68\n+   |\n+LL |     struct BeeWhereAyTeeWhereOutlivesAyIsDebugBee<'a, 'b, T> where 'b: 'a, T: 'a + Debug + 'b {\n+   |                                                                    ^^^^^^^^   ^^^^^     ^^^^^\n+help: remove these bounds\n+   |\n+LL |     struct BeeWhereAyTeeWhereOutlivesAyIsDebugBee<'a, 'b, T> where T: Debug {\n+   |                                                                   -- --   --\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:97:58\n+   |\n+LL |     struct BeeOutlivesAyTeeYooOutlivesAyIsDebugBee<'a, 'b: 'a, T, U: 'a + Debug + 'b> {\n+   |                                                          ^^^^        ^^^^^     ^^^^^\n+help: remove these bounds\n+   |\n+LL |     struct BeeOutlivesAyTeeYooOutlivesAyIsDebugBee<'a, 'b, T, U: Debug> {\n+   |                                                         --      --   --\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:104:18\n+   |\n+LL |         where U: 'a + Debug + 'b, 'b: 'a\n+   |                  ^^^^^     ^^^^^  ^^^^^^\n+help: remove these bounds\n+   |\n+LL |         where U: Debug, \n+   |                 --   ----\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:115:47\n+   |\n+LL |     struct TeeOutlivesAyIsDebugBee<'a, 'b, T: 'a + Debug + 'b>(&'a &'b T);\n+   |                                               ^^^^^     ^^^^^\n+help: remove these bounds\n+   |\n+LL |     struct TeeOutlivesAyIsDebugBee<'a, 'b, T: Debug>(&'a &'b T);\n+   |                                              --   --\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:118:72\n+   |\n+LL |     struct TeeWhereOutlivesAyIsDebugBee<'a, 'b, T>(&'a &'b T) where T: 'a + Debug + 'b;\n+   |                                                                        ^^^^^     ^^^^^\n+help: remove these bounds\n+   |\n+LL |     struct TeeWhereOutlivesAyIsDebugBee<'a, 'b, T>(&'a &'b T) where T: Debug;\n+   |                                                                       --   --\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:121:53\n+   |\n+LL |     struct TeeYooOutlivesAyIsDebugBee<'a, 'b, T, U: 'a + Debug + 'b>(T, &'a &'b U);\n+   |                                                     ^^^^^     ^^^^^\n+help: remove these bounds\n+   |\n+LL |     struct TeeYooOutlivesAyIsDebugBee<'a, 'b, T, U: Debug>(T, &'a &'b U);\n+   |                                                    --   --\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:124:48\n+   |\n+LL |     struct TeeOutlivesAyYooBeeIsDebug<'a, 'b, T: 'a, U: 'b + Debug>(&'a T, &'b U);\n+   |                                                ^^^^     ^^^^^\n+help: remove these bounds\n+   |\n+LL |     struct TeeOutlivesAyYooBeeIsDebug<'a, 'b, T, U: Debug>(&'a T, &'b U);\n+   |                                               --   --\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:127:48\n+   |\n+LL |     struct TeeOutlivesAyYooIsDebugBee<'a, 'b, T: 'a, U: Debug + 'b>(&'a T, &'b U);\n+   |                                                ^^^^          ^^^^^\n+help: remove these bounds\n+   |\n+LL |     struct TeeOutlivesAyYooIsDebugBee<'a, 'b, T, U: Debug>(&'a T, &'b U);\n+   |                                               --        --\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:130:46\n+   |\n+LL |     struct TeeOutlivesAyYooWhereBee<'a, 'b, T: 'a, U>(&'a T, &'b U) where U: 'b;\n+   |                                              ^^^^                   ^^^^^^^^^^^\n+help: remove these bounds\n+   |\n+LL |     struct TeeOutlivesAyYooWhereBee<'a, 'b, T, U>(&'a T, &'b U) ;\n+   |                                             --                 --\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:133:81\n+   |\n+LL |     struct TeeYooWhereOutlivesAyIsDebugBee<'a, 'b, T, U>(T, &'a &'b U) where U: 'a + Debug + 'b;\n+   |                                                                                 ^^^^^     ^^^^^\n+help: remove these bounds\n+   |\n+LL |     struct TeeYooWhereOutlivesAyIsDebugBee<'a, 'b, T, U>(T, &'a &'b U) where U: Debug;\n+   |                                                                                --   --\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:136:53\n+   |\n+LL |     struct TeeOutlivesAyYooWhereBeeIsDebug<'a, 'b, T: 'a, U>(&'a T, &'b U) where U: 'b + Debug;\n+   |                                                     ^^^^                            ^^^^^\n+help: remove these bounds\n+   |\n+LL |     struct TeeOutlivesAyYooWhereBeeIsDebug<'a, 'b, T, U>(&'a T, &'b U) where U: Debug;\n+   |                                                    --                          --\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:139:53\n+   |\n+LL |     struct TeeOutlivesAyYooWhereIsDebugBee<'a, 'b, T: 'a, U>(&'a T, &'b U) where U: Debug + 'b;\n+   |                                                     ^^^^                                 ^^^^^\n+help: remove these bounds\n+   |\n+LL |     struct TeeOutlivesAyYooWhereIsDebugBee<'a, 'b, T, U>(&'a T, &'b U) where U: Debug;\n+   |                                                    --                               --\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:142:75\n+   |\n+LL |     struct TeeWhereAyYooWhereBeeIsDebug<'a, 'b, T, U>(&'a T, &'b U) where T: 'a, U: 'b + Debug;\n+   |                                                                           ^^^^^^^   ^^^^^\n+help: remove these bounds\n+   |\n+LL |     struct TeeWhereAyYooWhereBeeIsDebug<'a, 'b, T, U>(&'a T, &'b U) where U: Debug;\n+   |                                                                          -- --\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:145:75\n+   |\n+LL |     struct TeeWhereAyYooWhereIsDebugBee<'a, 'b, T, U>(&'a T, &'b U) where T: 'a, U: Debug + 'b;\n+   |                                                                           ^^^^^^^        ^^^^^\n+help: remove these bounds\n+   |\n+LL |     struct TeeWhereAyYooWhereIsDebugBee<'a, 'b, T, U>(&'a T, &'b U) where U: Debug;\n+   |                                                                          --      --\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:148:38\n+   |\n+LL |     struct BeeOutlivesAyTeeBee<'a, 'b: 'a, T: 'b>(&'a &'b T);\n+   |                                      ^^^^   ^^^^\n+help: remove these bounds\n+   |\n+LL |     struct BeeOutlivesAyTeeBee<'a, 'b, T>(&'a &'b T);\n+   |                                     -- --\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:151:40\n+   |\n+LL |     struct BeeOutlivesAyTeeAyBee<'a, 'b: 'a, T: 'a + 'b>(&'a &'b T);\n+   |                                        ^^^^   ^^^^^^^^^\n+help: remove these bounds\n+   |\n+LL |     struct BeeOutlivesAyTeeAyBee<'a, 'b, T>(&'a &'b T);\n+   |                                       -- --\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:154:55\n+   |\n+LL |     struct BeeOutlivesAyTeeOutlivesAyIsDebugBee<'a, 'b: 'a, T: 'a + Debug + 'b>(&'a &'b T);\n+   |                                                       ^^^^     ^^^^^     ^^^^^\n+help: remove these bounds\n+   |\n+LL |     struct BeeOutlivesAyTeeOutlivesAyIsDebugBee<'a, 'b, T: Debug>(&'a &'b T);\n+   |                                                      --   --   --\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:157:71\n+   |\n+LL |     struct BeeWhereAyTeeWhereAyIsDebugBee<'a, 'b, T>(&'a &'b T) where 'b: 'a, T: 'a + Debug + 'b;\n+   |                                                                       ^^^^^^^^   ^^^^^     ^^^^^\n+help: remove these bounds\n+   |\n+LL |     struct BeeWhereAyTeeWhereAyIsDebugBee<'a, 'b, T>(&'a &'b T) where T: Debug;\n+   |                                                                      -- --   --\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:160:58\n+   |\n+LL |     struct BeeOutlivesAyTeeYooOutlivesAyIsDebugBee<'a, 'b: 'a, T, U: 'a + Debug + 'b>(T, &'a &'b U);\n+   |                                                          ^^^^        ^^^^^     ^^^^^\n+help: remove these bounds\n+   |\n+LL |     struct BeeOutlivesAyTeeYooOutlivesAyIsDebugBee<'a, 'b, T, U: Debug>(T, &'a &'b U);\n+   |                                                         --      --   --\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:164:18\n+   |\n+LL |         where U: 'a + Debug + 'b, 'b: 'a;\n+   |                  ^^^^^     ^^^^^  ^^^^^^\n+help: remove these bounds\n+   |\n+LL |         where U: Debug, ;\n+   |                 --   ----\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:171:45\n+   |\n+LL |     enum TeeOutlivesAyIsDebugBee<'a, 'b, T: 'a + Debug + 'b> {\n+   |                                             ^^^^^     ^^^^^\n+help: remove these bounds\n+   |\n+LL |     enum TeeOutlivesAyIsDebugBee<'a, 'b, T: Debug> {\n+   |                                            --   --\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:176:59\n+   |\n+LL |     enum TeeWhereOutlivesAyIsDebugBee<'a, 'b, T> where T: 'a + Debug + 'b {\n+   |                                                           ^^^^^     ^^^^^\n+help: remove these bounds\n+   |\n+LL |     enum TeeWhereOutlivesAyIsDebugBee<'a, 'b, T> where T: Debug {\n+   |                                                          --   --\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:181:51\n+   |\n+LL |     enum TeeYooOutlivesAyIsDebugBee<'a, 'b, T, U: 'a + Debug + 'b> {\n+   |                                                   ^^^^^     ^^^^^\n+help: remove these bounds\n+   |\n+LL |     enum TeeYooOutlivesAyIsDebugBee<'a, 'b, T, U: Debug> {\n+   |                                                  --   --\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:187:46\n+   |\n+LL |     enum TeeOutlivesAyYooBeeIsDebug<'a, 'b, T: 'a, U: 'b + Debug> {\n+   |                                              ^^^^     ^^^^^\n+help: remove these bounds\n+   |\n+LL |     enum TeeOutlivesAyYooBeeIsDebug<'a, 'b, T, U: Debug> {\n+   |                                             --   --\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:193:46\n+   |\n+LL |     enum TeeOutlivesAyYooIsDebugBee<'a, 'b, T: 'a, U: Debug + 'b> {\n+   |                                              ^^^^          ^^^^^\n+help: remove these bounds\n+   |\n+LL |     enum TeeOutlivesAyYooIsDebugBee<'a, 'b, T, U: Debug> {\n+   |                                             --        --\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:199:44\n+   |\n+LL |     enum TeeOutlivesAyYooWhereBee<'a, 'b, T: 'a, U> where U: 'b {\n+   |                                            ^^^^    ^^^^^^^^^^^^\n+help: remove these bounds\n+   |\n+LL |     enum TeeOutlivesAyYooWhereBee<'a, 'b, T, U> {\n+   |                                           --  --\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:205:65\n+   |\n+LL |     enum TeeYooWhereOutlivesAyIsDebugBee<'a, 'b, T, U> where U: 'a + Debug + 'b {\n+   |                                                                 ^^^^^     ^^^^^\n+help: remove these bounds\n+   |\n+LL |     enum TeeYooWhereOutlivesAyIsDebugBee<'a, 'b, T, U> where U: Debug {\n+   |                                                                --   --\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:211:51\n+   |\n+LL |     enum TeeOutlivesAyYooWhereBeeIsDebug<'a, 'b, T: 'a, U> where U: 'b + Debug {\n+   |                                                   ^^^^              ^^^^^\n+help: remove these bounds\n+   |\n+LL |     enum TeeOutlivesAyYooWhereBeeIsDebug<'a, 'b, T, U> where U: Debug {\n+   |                                                  --            --\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:217:51\n+   |\n+LL |     enum TeeOutlivesAyYooWhereIsDebugBee<'a, 'b, T: 'a, U> where U: Debug + 'b {\n+   |                                                   ^^^^                   ^^^^^\n+help: remove these bounds\n+   |\n+LL |     enum TeeOutlivesAyYooWhereIsDebugBee<'a, 'b, T, U> where U: Debug {\n+   |                                                  --                 --\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:223:67\n+   |\n+LL |     enum TeeWhereOutlivesAyYooWhereBeeIsDebug<'a, 'b, T, U> where T: 'a, U: 'b + Debug {\n+   |                                                                   ^^^^^^^   ^^^^^\n+help: remove these bounds\n+   |\n+LL |     enum TeeWhereOutlivesAyYooWhereBeeIsDebug<'a, 'b, T, U> where U: Debug {\n+   |                                                                  -- --\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:229:67\n+   |\n+LL |     enum TeeWhereOutlivesAyYooWhereIsDebugBee<'a, 'b, T, U> where T: 'a, U: Debug + 'b {\n+   |                                                                   ^^^^^^^        ^^^^^\n+help: remove these bounds\n+   |\n+LL |     enum TeeWhereOutlivesAyYooWhereIsDebugBee<'a, 'b, T, U> where U: Debug {\n+   |                                                                  --      --\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:235:36\n+   |\n+LL |     enum BeeOutlivesAyTeeBee<'a, 'b: 'a, T: 'b> {\n+   |                                    ^^^^   ^^^^\n+help: remove these bounds\n+   |\n+LL |     enum BeeOutlivesAyTeeBee<'a, 'b, T> {\n+   |                                   -- --\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:240:38\n+   |\n+LL |     enum BeeOutlivesAyTeeAyBee<'a, 'b: 'a, T: 'a + 'b> {\n+   |                                      ^^^^   ^^^^^^^^^\n+help: remove these bounds\n+   |\n+LL |     enum BeeOutlivesAyTeeAyBee<'a, 'b, T> {\n+   |                                     -- --\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:246:53\n+   |\n+LL |     enum BeeOutlivesAyTeeOutlivesAyIsDebugBee<'a, 'b: 'a, T: 'a + Debug + 'b> {\n+   |                                                     ^^^^     ^^^^^     ^^^^^\n+help: remove these bounds\n+   |\n+LL |     enum BeeOutlivesAyTeeOutlivesAyIsDebugBee<'a, 'b, T: Debug> {\n+   |                                                    --   --   --\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:251:66\n+   |\n+LL |     enum BeeWhereAyTeeWhereOutlivesAyIsDebugBee<'a, 'b, T> where 'b: 'a, T: 'a + Debug + 'b {\n+   |                                                                  ^^^^^^^^   ^^^^^     ^^^^^\n+help: remove these bounds\n+   |\n+LL |     enum BeeWhereAyTeeWhereOutlivesAyIsDebugBee<'a, 'b, T> where T: Debug {\n+   |                                                                 -- --   --\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:256:56\n+   |\n+LL |     enum BeeOutlivesAyTeeYooOutlivesAyIsDebugBee<'a, 'b: 'a, T, U: 'a + Debug + 'b> {\n+   |                                                        ^^^^        ^^^^^     ^^^^^\n+help: remove these bounds\n+   |\n+LL |     enum BeeOutlivesAyTeeYooOutlivesAyIsDebugBee<'a, 'b, T, U: Debug> {\n+   |                                                       --      --   --\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:262:75\n+   |\n+LL |     enum BeeWhereAyTeeYooWhereOutlivesAyIsDebugBee<'a, 'b, T, U> where U: 'a + Debug + 'b, 'b: 'a {\n+   |                                                                           ^^^^^     ^^^^^  ^^^^^^\n+help: remove these bounds\n+   |\n+LL |     enum BeeWhereAyTeeYooWhereOutlivesAyIsDebugBee<'a, 'b, T, U> where U: Debug,  {\n+   |                                                                          --   ----\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:271:46\n+   |\n+LL |     union TeeOutlivesAyIsDebugBee<'a, 'b, T: 'a + Debug + 'b> {\n+   |                                              ^^^^^     ^^^^^\n+help: remove these bounds\n+   |\n+LL |     union TeeOutlivesAyIsDebugBee<'a, 'b, T: Debug> {\n+   |                                             --   --\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:276:60\n+   |\n+LL |     union TeeWhereOutlivesAyIsDebugBee<'a, 'b, T> where T: 'a + Debug + 'b {\n+   |                                                            ^^^^^     ^^^^^\n+help: remove these bounds\n+   |\n+LL |     union TeeWhereOutlivesAyIsDebugBee<'a, 'b, T> where T: Debug {\n+   |                                                           --   --\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:281:52\n+   |\n+LL |     union TeeYooOutlivesAyIsDebugBee<'a, 'b, T, U: 'a + Debug + 'b> {\n+   |                                                    ^^^^^     ^^^^^\n+help: remove these bounds\n+   |\n+LL |     union TeeYooOutlivesAyIsDebugBee<'a, 'b, T, U: Debug> {\n+   |                                                   --   --\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:287:47\n+   |\n+LL |     union TeeOutlivesAyYooBeeIsDebug<'a, 'b, T: 'a, U: 'b + Debug> {\n+   |                                               ^^^^     ^^^^^\n+help: remove these bounds\n+   |\n+LL |     union TeeOutlivesAyYooBeeIsDebug<'a, 'b, T, U: Debug> {\n+   |                                              --   --\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:293:47\n+   |\n+LL |     union TeeOutlivesAyYooIsDebugBee<'a, 'b, T: 'a, U: Debug + 'b> {\n+   |                                               ^^^^          ^^^^^\n+help: remove these bounds\n+   |\n+LL |     union TeeOutlivesAyYooIsDebugBee<'a, 'b, T, U: Debug> {\n+   |                                              --        --\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:299:45\n+   |\n+LL |     union TeeOutlivesAyYooWhereBee<'a, 'b, T: 'a, U> where U: 'b {\n+   |                                             ^^^^    ^^^^^^^^^^^^\n+help: remove these bounds\n+   |\n+LL |     union TeeOutlivesAyYooWhereBee<'a, 'b, T, U> {\n+   |                                            --  --\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:305:66\n+   |\n+LL |     union TeeYooWhereOutlivesAyIsDebugBee<'a, 'b, T, U> where U: 'a + Debug + 'b {\n+   |                                                                  ^^^^^     ^^^^^\n+help: remove these bounds\n+   |\n+LL |     union TeeYooWhereOutlivesAyIsDebugBee<'a, 'b, T, U> where U: Debug {\n+   |                                                                 --   --\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:311:52\n+   |\n+LL |     union TeeOutlivesAyYooWhereBeeIsDebug<'a, 'b, T: 'a, U> where U: 'b + Debug {\n+   |                                                    ^^^^              ^^^^^\n+help: remove these bounds\n+   |\n+LL |     union TeeOutlivesAyYooWhereBeeIsDebug<'a, 'b, T, U> where U: Debug {\n+   |                                                   --            --\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:317:52\n+   |\n+LL |     union TeeOutlivesAyYooWhereIsDebugBee<'a, 'b, T: 'a, U> where U: Debug + 'b {\n+   |                                                    ^^^^                   ^^^^^\n+help: remove these bounds\n+   |\n+LL |     union TeeOutlivesAyYooWhereIsDebugBee<'a, 'b, T, U> where U: Debug {\n+   |                                                   --                 --\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:323:68\n+   |\n+LL |     union TeeWhereOutlivesAyYooWhereBeeIsDebug<'a, 'b, T, U> where T: 'a, U: 'b + Debug {\n+   |                                                                    ^^^^^^^   ^^^^^\n+help: remove these bounds\n+   |\n+LL |     union TeeWhereOutlivesAyYooWhereBeeIsDebug<'a, 'b, T, U> where U: Debug {\n+   |                                                                   -- --\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:329:68\n+   |\n+LL |     union TeeWhereOutlivesAyYooWhereIsDebugBee<'a, 'b, T, U> where T: 'a, U: Debug + 'b {\n+   |                                                                    ^^^^^^^        ^^^^^\n+help: remove these bounds\n+   |\n+LL |     union TeeWhereOutlivesAyYooWhereIsDebugBee<'a, 'b, T, U> where U: Debug {\n+   |                                                                   --      --\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:335:37\n+   |\n+LL |     union BeeOutlivesAyTeeBee<'a, 'b: 'a, T: 'b> {\n+   |                                     ^^^^   ^^^^\n+help: remove these bounds\n+   |\n+LL |     union BeeOutlivesAyTeeBee<'a, 'b, T> {\n+   |                                    -- --\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:340:39\n+   |\n+LL |     union BeeOutlivesAyTeeAyBee<'a, 'b: 'a, T: 'a + 'b> {\n+   |                                       ^^^^   ^^^^^^^^^\n+help: remove these bounds\n+   |\n+LL |     union BeeOutlivesAyTeeAyBee<'a, 'b, T> {\n+   |                                      -- --\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:345:54\n+   |\n+LL |     union BeeOutlivesAyTeeOutlivesAyIsDebugBee<'a, 'b: 'a, T: 'a + Debug + 'b> {\n+   |                                                      ^^^^     ^^^^^     ^^^^^\n+help: remove these bounds\n+   |\n+LL |     union BeeOutlivesAyTeeOutlivesAyIsDebugBee<'a, 'b, T: Debug> {\n+   |                                                     --   --   --\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:350:67\n+   |\n+LL |     union BeeWhereAyTeeWhereOutlivesAyIsDebugBee<'a, 'b, T> where 'b: 'a, T: 'a + Debug + 'b {\n+   |                                                                   ^^^^^^^^   ^^^^^     ^^^^^\n+help: remove these bounds\n+   |\n+LL |     union BeeWhereAyTeeWhereOutlivesAyIsDebugBee<'a, 'b, T> where T: Debug {\n+   |                                                                  -- --   --\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:355:57\n+   |\n+LL |     union BeeOutlivesAyTeeYooOutlivesAyIsDebugBee<'a, 'b: 'a, T, U: 'a + Debug + 'b> {\n+   |                                                         ^^^^        ^^^^^     ^^^^^\n+help: remove these bounds\n+   |\n+LL |     union BeeOutlivesAyTeeYooOutlivesAyIsDebugBee<'a, 'b, T, U: Debug> {\n+   |                                                        --      --   --\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:361:76\n+   |\n+LL |     union BeeWhereAyTeeYooWhereOutlivesAyIsDebugBee<'a, 'b, T, U> where U: 'a + Debug + 'b, 'b: 'a {\n+   |                                                                            ^^^^^     ^^^^^  ^^^^^^\n+help: remove these bounds\n+   |\n+LL |     union BeeWhereAyTeeYooWhereOutlivesAyIsDebugBee<'a, 'b, T, U> where U: Debug,  {\n+   |                                                                           --   ----\n+\n+error: aborting due to 68 previous errors\n "}, {"sha": "13645244da069b3e20369fe5877993f2e4e51931", "filename": "src/test/ui/rust-2018/edition-lint-infer-outlives.fixed", "status": "modified", "additions": 706, "deletions": 113, "changes": 819, "blob_url": "https://github.com/rust-lang/rust/blob/e79b2a18a21e6b178d73473bb8fdbf3d18c66051/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/e79b2a18a21e6b178d73473bb8fdbf3d18c66051/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives.fixed?ref=e79b2a18a21e6b178d73473bb8fdbf3d18c66051", "patch": "@@ -3,9 +3,6 @@\n #![allow(unused)]\n #![deny(explicit_outlives_requirements)]\n \n-use std::fmt::{Debug, Display};\n-\n-\n // Programmatically generated examples!\n //\n // Exercise outlives bounds for each of the following parameter/position\n@@ -17,177 +14,773 @@ use std::fmt::{Debug, Display};\n // \u2022 two parameters (T and U), one bound inline, one with a where clause\n // \u2022 two parameters (T and U), both with where clauses\n //\n-// \u2014and for every permutation of 0, 1, or 2 lifetimes to outlive and 0 or 1\n-// trait bounds distributed among said parameters (subject to no where clause\n-// being empty and the struct having at least one lifetime).\n+// \u2014and for every permutation of 1 or 2 lifetimes to outlive and 0 or 1 trait\n+// bounds distributed among said parameters (subject to no where clause being\n+// empty and the struct having at least one lifetime).\n+//\n+// \u2014and for each of tuple structs, enums and unions.\n+\n+mod structs {\n+    use std::fmt::Debug;\n+\n+    struct TeeOutlivesAy<'a, T> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a T\n+    }\n+\n+    struct TeeOutlivesAyIsDebug<'a, T: Debug> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a T\n+    }\n+\n+    struct TeeIsDebugOutlivesAy<'a, T: Debug> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a T\n+    }\n+\n+    struct TeeOutlivesAyBee<'a, 'b, T> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T\n+    }\n+\n+    struct TeeOutlivesAyBeeIsDebug<'a, 'b, T: Debug> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T\n+    }\n+\n+    struct TeeIsDebugOutlivesAyBee<'a, 'b, T: Debug> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T\n+    }\n+\n+    struct TeeWhereOutlivesAy<'a, T> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a T\n+    }\n+\n+    struct TeeWhereOutlivesAyIsDebug<'a, T> where T: Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a T\n+    }\n+\n+    struct TeeWhereIsDebugOutlivesAy<'a, T> where T: Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a T\n+    }\n+\n+    struct TeeWhereOutlivesAyBee<'a, 'b, T> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T\n+    }\n+\n+    struct TeeWhereOutlivesAyBeeIsDebug<'a, 'b, T> where T: Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T\n+    }\n+\n+    struct TeeWhereIsDebugOutlivesAyBee<'a, 'b, T> where T: Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T\n+    }\n+\n+    struct TeeYooOutlivesAy<'a, T, U> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: T,\n+        yoo: &'a U\n+    }\n+\n+    struct TeeYooOutlivesAyIsDebug<'a, T, U: Debug> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: T,\n+        yoo: &'a U\n+    }\n+\n+    struct TeeYooIsDebugOutlivesAy<'a, T, U: Debug> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: T,\n+        yoo: &'a U\n+    }\n+\n+    struct TeeOutlivesAyYooIsDebug<'a, T, U: Debug> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a T,\n+        yoo: U\n+    }\n+\n+    struct TeeYooOutlivesAyBee<'a, 'b, T, U> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: T,\n+        yoo: &'a &'b U\n+    }\n+\n+    struct TeeYooOutlivesAyBeeIsDebug<'a, 'b, T, U: Debug> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: T,\n+        yoo: &'a &'b U\n+    }\n+\n+    struct TeeYooIsDebugOutlivesAyBee<'a, 'b, T, U: Debug> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: T,\n+        yoo: &'a &'b U\n+    }\n+\n+    struct TeeOutlivesAyBeeYooIsDebug<'a, 'b, T, U: Debug> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T,\n+        yoo: U\n+    }\n+\n+    struct TeeYooWhereOutlivesAy<'a, T, U> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: T,\n+        yoo: &'a U\n+    }\n+\n+    struct TeeYooWhereOutlivesAyIsDebug<'a, T, U> where U: Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: T,\n+        yoo: &'a U\n+    }\n+\n+    struct TeeYooWhereIsDebugOutlivesAy<'a, T, U> where U: Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: T,\n+        yoo: &'a U\n+    }\n+\n+    struct TeeOutlivesAyYooWhereIsDebug<'a, T, U> where U: Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a T,\n+        yoo: U\n+    }\n+\n+    struct TeeYooWhereOutlivesAyBee<'a, 'b, T, U> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: T,\n+        yoo: &'a &'b U\n+    }\n+\n+    struct TeeYooWhereOutlivesAyBeeIsDebug<'a, 'b, T, U> where U: Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: T,\n+        yoo: &'a &'b U\n+    }\n+\n+    struct TeeYooWhereIsDebugOutlivesAyBee<'a, 'b, T, U> where U: Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: T,\n+        yoo: &'a &'b U\n+    }\n+\n+    struct TeeOutlivesAyBeeYooWhereIsDebug<'a, 'b, T, U> where U: Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T,\n+        yoo: U\n+    }\n+\n+    struct TeeWhereOutlivesAyYooWhereIsDebug<'a, T, U> where U: Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a T,\n+        yoo: U\n+    }\n+\n+    struct TeeWhereOutlivesAyBeeYooWhereIsDebug<'a, 'b, T, U> where U: Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T,\n+        yoo: U\n+    }\n+\n+    struct BeeOutlivesAy<'a, 'b> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b (),\n+    }\n+\n+    struct BeeWhereOutlivesAy<'a, 'b> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b (),\n+    }\n+\n+    struct BeeOutlivesAyTee<'a, 'b, T> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T,\n+    }\n+\n+    struct BeeWhereOutlivesAyTee<'a, 'b, T> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T,\n+    }\n+\n+    struct BeeWhereOutlivesAyTeeWhereBee<'a, 'b, T> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T,\n+    }\n+\n+    struct BeeWhereOutlivesAyTeeWhereAyBee<'a, 'b, T> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T,\n+    }\n+\n+    struct BeeOutlivesAyTeeDebug<'a, 'b, T: Debug> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T,\n+    }\n+\n+    struct BeeWhereOutlivesAyTeeWhereDebug<'a, 'b, T> where T: Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T,\n+    }\n+}\n \n+mod tuple_structs {\n+    use std::fmt::Debug;\n \n-struct TeeOutlivesAy<'a, T> {\n+    struct TeeOutlivesAy<'a, T>(&'a T);\n     //~^ ERROR outlives requirements can be inferred\n-    tee: &'a T\n-}\n \n-struct TeeOutlivesAyIsDebug<'a, T: Debug> {\n+    struct TeeOutlivesAyIsDebug<'a, T: Debug>(&'a T);\n     //~^ ERROR outlives requirements can be inferred\n-    tee: &'a T\n-}\n \n-struct TeeIsDebugOutlivesAy<'a, T: Debug> {\n+    struct TeeIsDebugOutlivesAy<'a, T: Debug>(&'a T);\n     //~^ ERROR outlives requirements can be inferred\n-    tee: &'a T\n-}\n \n-struct TeeOutlivesAyBee<'a, 'b, T> {\n+    struct TeeOutlivesAyBee<'a, 'b, T>(&'a &'b T);\n     //~^ ERROR outlives requirements can be inferred\n-    tee: &'a &'b T\n-}\n \n-struct TeeOutlivesAyBeeIsDebug<'a, 'b, T: Debug> {\n+    struct TeeOutlivesAyBeeIsDebug<'a, 'b, T: Debug>(&'a &'b T);\n     //~^ ERROR outlives requirements can be inferred\n-    tee: &'a &'b T\n-}\n \n-struct TeeIsDebugOutlivesAyBee<'a, 'b, T: Debug> {\n+    struct TeeIsDebugOutlivesAyBee<'a, 'b, T: Debug>(&'a &'b T);\n     //~^ ERROR outlives requirements can be inferred\n-    tee: &'a &'b T\n-}\n \n-struct TeeWhereOutlivesAy<'a, T> {\n+    struct TeeWhereOutlivesAy<'a, T>(&'a T) ;\n     //~^ ERROR outlives requirements can be inferred\n-    tee: &'a T\n-}\n \n-struct TeeWhereOutlivesAyIsDebug<'a, T> where T: Debug {\n+    struct TeeWhereOutlivesAyIsDebug<'a, T>(&'a T) where T: Debug;\n     //~^ ERROR outlives requirements can be inferred\n-    tee: &'a T\n-}\n \n-struct TeeWhereIsDebugOutlivesAy<'a, T> where T: Debug {\n+    struct TeeWhereIsDebugOutlivesAy<'a, T>(&'a T) where T: Debug;\n     //~^ ERROR outlives requirements can be inferred\n-    tee: &'a T\n-}\n \n-struct TeeWhereOutlivesAyBee<'a, 'b, T> {\n+    struct TeeWhereOutlivesAyBee<'a, 'b, T>(&'a &'b T) ;\n     //~^ ERROR outlives requirements can be inferred\n-    tee: &'a &'b T\n-}\n \n-struct TeeWhereOutlivesAyBeeIsDebug<'a, 'b, T> where T: Debug {\n+    struct TeeWhereOutlivesAyBeeIsDebug<'a, 'b, T>(&'a &'b T) where T: Debug;\n     //~^ ERROR outlives requirements can be inferred\n-    tee: &'a &'b T\n-}\n \n-struct TeeWhereIsDebugOutlivesAyBee<'a, 'b, T> where T: Debug {\n+    struct TeeWhereIsDebugOutlivesAyBee<'a, 'b, T>(&'a &'b T) where T: Debug;\n     //~^ ERROR outlives requirements can be inferred\n-    tee: &'a &'b T\n-}\n \n-struct TeeYooOutlivesAy<'a, T, U> {\n+    struct TeeYooOutlivesAy<'a, T, U>(T, &'a U);\n     //~^ ERROR outlives requirements can be inferred\n-    tee: T,\n-    yoo: &'a U\n-}\n \n-struct TeeYooOutlivesAyIsDebug<'a, T, U: Debug> {\n+    struct TeeYooOutlivesAyIsDebug<'a, T, U: Debug>(T, &'a U);\n     //~^ ERROR outlives requirements can be inferred\n-    tee: T,\n-    yoo: &'a U\n-}\n \n-struct TeeYooIsDebugOutlivesAy<'a, T, U: Debug> {\n+    struct TeeYooIsDebugOutlivesAy<'a, T, U: Debug>(T, &'a U);\n     //~^ ERROR outlives requirements can be inferred\n-    tee: T,\n-    yoo: &'a U\n-}\n \n-struct TeeOutlivesAyYooIsDebug<'a, T, U: Debug> {\n+    struct TeeOutlivesAyYooIsDebug<'a, T, U: Debug>(&'a T, U);\n     //~^ ERROR outlives requirements can be inferred\n-    tee: &'a T,\n-    yoo: U\n-}\n \n-struct TeeYooOutlivesAyBee<'a, 'b, T, U> {\n+    struct TeeYooOutlivesAyBee<'a, 'b, T, U>(T, &'a &'b U);\n     //~^ ERROR outlives requirements can be inferred\n-    tee: T,\n-    yoo: &'a &'b U\n-}\n \n-struct TeeYooOutlivesAyBeeIsDebug<'a, 'b, T, U: Debug> {\n+    struct TeeYooOutlivesAyBeeIsDebug<'a, 'b, T, U: Debug>(T, &'a &'b U);\n     //~^ ERROR outlives requirements can be inferred\n-    tee: T,\n-    yoo: &'a &'b U\n-}\n \n-struct TeeYooIsDebugOutlivesAyBee<'a, 'b, T, U: Debug> {\n+    struct TeeYooIsDebugOutlivesAyBee<'a, 'b, T, U: Debug>(T, &'a &'b U);\n     //~^ ERROR outlives requirements can be inferred\n-    tee: T,\n-    yoo: &'a &'b U\n-}\n \n-struct TeeOutlivesAyBeeYooIsDebug<'a, 'b, T, U: Debug> {\n+    struct TeeOutlivesAyBeeYooIsDebug<'a, 'b, T, U: Debug>(&'a &'b T, U);\n     //~^ ERROR outlives requirements can be inferred\n-    tee: &'a &'b T,\n-    yoo: U\n-}\n \n-struct TeeYooWhereOutlivesAy<'a, T, U> {\n+    struct TeeYooWhereOutlivesAy<'a, T, U>(T, &'a U) ;\n     //~^ ERROR outlives requirements can be inferred\n-    tee: T,\n-    yoo: &'a U\n-}\n \n-struct TeeYooWhereOutlivesAyIsDebug<'a, T, U> where U: Debug {\n+    struct TeeYooWhereOutlivesAyIsDebug<'a, T, U>(T, &'a U) where U: Debug;\n     //~^ ERROR outlives requirements can be inferred\n-    tee: T,\n-    yoo: &'a U\n-}\n \n-struct TeeYooWhereIsDebugOutlivesAy<'a, T, U> where U: Debug {\n+    struct TeeYooWhereIsDebugOutlivesAy<'a, T, U>(T, &'a U) where U: Debug;\n     //~^ ERROR outlives requirements can be inferred\n-    tee: T,\n-    yoo: &'a U\n-}\n \n-struct TeeOutlivesAyYooWhereIsDebug<'a, T, U> where U: Debug {\n+    struct TeeOutlivesAyYooWhereIsDebug<'a, T, U>(&'a T, U) where U: Debug;\n     //~^ ERROR outlives requirements can be inferred\n-    tee: &'a T,\n-    yoo: U\n-}\n \n-struct TeeYooWhereOutlivesAyBee<'a, 'b, T, U> {\n+    struct TeeYooWhereOutlivesAyBee<'a, 'b, T, U>(T, &'a &'b U) ;\n     //~^ ERROR outlives requirements can be inferred\n-    tee: T,\n-    yoo: &'a &'b U\n-}\n \n-struct TeeYooWhereOutlivesAyBeeIsDebug<'a, 'b, T, U> where U: Debug {\n+    struct TeeYooWhereOutlivesAyBeeIsDebug<'a, 'b, T, U>(T, &'a &'b U) where U: Debug;\n     //~^ ERROR outlives requirements can be inferred\n-    tee: T,\n-    yoo: &'a &'b U\n-}\n \n-struct TeeYooWhereIsDebugOutlivesAyBee<'a, 'b, T, U> where U: Debug {\n+    struct TeeYooWhereIsDebugOutlivesAyBee<'a, 'b, T, U>(T, &'a &'b U) where U: Debug;\n     //~^ ERROR outlives requirements can be inferred\n-    tee: T,\n-    yoo: &'a &'b U\n-}\n \n-struct TeeOutlivesAyBeeYooWhereIsDebug<'a, 'b, T, U> where U: Debug {\n+    struct TeeOutlivesAyBeeYooWhereIsDebug<'a, 'b, T, U>(&'a &'b T, U) where U: Debug;\n     //~^ ERROR outlives requirements can be inferred\n-    tee: &'a &'b T,\n-    yoo: U\n-}\n \n-struct TeeWhereOutlivesAyYooWhereIsDebug<'a, T, U> where U: Debug {\n+    struct TeeWhereOutlivesAyYooWhereIsDebug<'a, T, U>(&'a T, U) where U: Debug;\n+    //~^ ERROR outlives requirements can be inferred\n+\n+    struct TeeWhereAyBeeYooWhereIsDebug<'a, 'b, T, U>(&'a &'b T, U) where U: Debug;\n+    //~^ ERROR outlives requirements can be inferred\n+\n+    struct BeeOutlivesAy<'a, 'b>(&'a &'b ());\n+    //~^ ERROR outlives requirements can be inferred\n+\n+    struct BeeWhereOutlivesAy<'a, 'b>(&'a &'b ()) ;\n+    //~^ ERROR outlives requirements can be inferred\n+\n+    struct BeeOutlivesAyTee<'a, 'b, T>(&'a &'b T);\n+    //~^ ERROR outlives requirements can be inferred\n+\n+    struct BeeWhereOutlivesAyTee<'a, 'b, T>(&'a &'b T) ;\n+    //~^ ERROR outlives requirements can be inferred\n+\n+    struct BeeWhereOutlivesAyTeeWhereBee<'a, 'b, T>(&'a &'b T) ;\n+    //~^ ERROR outlives requirements can be inferred\n+\n+    struct BeeWhereOutlivesAyTeeWhereAyBee<'a, 'b, T>(&'a &'b T) ;\n     //~^ ERROR outlives requirements can be inferred\n-    tee: &'a T,\n-    yoo: U\n-}\n \n-struct TeeWhereOutlivesAyBeeYooWhereIsDebug<'a, 'b, T, U> where U: Debug {\n+    struct BeeOutlivesAyTeeDebug<'a, 'b, T: Debug>(&'a &'b T);\n     //~^ ERROR outlives requirements can be inferred\n-    tee: &'a &'b T,\n-    yoo: U\n+\n+    struct BeeWhereOutlivesAyTeeWhereDebug<'a, 'b, T>(&'a &'b T) where T: Debug;\n+    //~^ ERROR outlives requirements can be inferred\n+}\n+\n+mod enums {\n+    use std::fmt::Debug;\n+\n+    enum TeeOutlivesAy<'a, T> {\n+        //~^ ERROR outlives requirements can be inferred\n+        V { tee: &'a T },\n+    }\n+\n+    enum TeeOutlivesAyIsDebug<'a, T: Debug> {\n+        //~^ ERROR outlives requirements can be inferred\n+        V(&'a T),\n+    }\n+\n+    enum TeeIsDebugOutlivesAy<'a, T: Debug> {\n+        //~^ ERROR outlives requirements can be inferred\n+        V { tee: &'a T },\n+        W,\n+    }\n+\n+    enum TeeOutlivesAyBee<'a, 'b, T> {\n+        //~^ ERROR outlives requirements can be inferred\n+        V(&'a &'b T),\n+        W,\n+    }\n+\n+    enum TeeOutlivesAyBeeIsDebug<'a, 'b, T: Debug> {\n+        //~^ ERROR outlives requirements can be inferred\n+        V { tee: &'a &'b T },\n+    }\n+\n+    enum TeeIsDebugOutlivesAyBee<'a, 'b, T: Debug> {\n+        //~^ ERROR outlives requirements can be inferred\n+        V(&'a &'b T),\n+    }\n+\n+    enum TeeWhereOutlivesAy<'a, T> {\n+        //~^ ERROR outlives requirements can be inferred\n+        V { tee: &'a T },\n+        W,\n+    }\n+\n+    enum TeeWhereOutlivesAyIsDebug<'a, T> where T: Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        V(&'a T),\n+        W,\n+    }\n+\n+    enum TeeWhereIsDebugOutlivesAy<'a, T> where T: Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        V { tee: &'a T },\n+    }\n+\n+    enum TeeWhereOutlivesAyBee<'a, 'b, T> {\n+        //~^ ERROR outlives requirements can be inferred\n+        V(&'a &'b T),\n+    }\n+\n+    enum TeeWhereOutlivesAyBeeIsDebug<'a, 'b, T> where T: Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        V { tee: &'a &'b T },\n+        W,\n+    }\n+\n+    enum TeeWhereIsDebugOutlivesAyBee<'a, 'b, T> where T: Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        V(&'a &'b T),\n+        W,\n+    }\n+\n+    enum TeeYooOutlivesAy<'a, T, U> {\n+        //~^ ERROR outlives requirements can be inferred\n+        V { tee: T },\n+        W(&'a U),\n+    }\n+\n+    enum TeeYooOutlivesAyIsDebug<'a, T, U: Debug> {\n+        //~^ ERROR outlives requirements can be inferred\n+        V { tee: T, yoo: &'a U },\n+        W,\n+    }\n+\n+    enum TeeYooIsDebugOutlivesAy<'a, T, U: Debug> {\n+        //~^ ERROR outlives requirements can be inferred\n+        V(T, &'a U),\n+        W,\n+    }\n+\n+    enum TeeOutlivesAyYooIsDebug<'a, T, U: Debug> {\n+        //~^ ERROR outlives requirements can be inferred\n+        V { tee: &'a T },\n+        W(U),\n+    }\n+\n+    enum TeeYooOutlivesAyBee<'a, 'b, T, U> {\n+        //~^ ERROR outlives requirements can be inferred\n+        V { tee: T, yoo: &'a &'b U },\n+        W,\n+    }\n+\n+    enum TeeYooOutlivesAyBeeIsDebug<'a, 'b, T, U: Debug> {\n+        //~^ ERROR outlives requirements can be inferred\n+        V(T, &'a &'b U),\n+        W,\n+    }\n+\n+    enum TeeYooIsDebugOutlivesAyBee<'a, 'b, T, U: Debug> {\n+        //~^ ERROR outlives requirements can be inferred\n+        V { tee: T, yoo: &'a &'b U },\n+        W,\n+    }\n+\n+    enum TeeOutlivesAyBeeYooIsDebug<'a, 'b, T, U: Debug> {\n+        //~^ ERROR outlives requirements can be inferred\n+        V(&'a &'b T, U),\n+        W,\n+    }\n+\n+    enum TeeYooWhereOutlivesAy<'a, T, U> {\n+        //~^ ERROR outlives requirements can be inferred\n+        V { tee: T },\n+        W(&'a U),\n+    }\n+\n+    enum TeeYooWhereOutlivesAyIsDebug<'a, T, U> where U: Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        V { tee: T, yoo: &'a U },\n+        W,\n+    }\n+\n+    enum TeeYooWhereIsDebugOutlivesAy<'a, T, U> where U: Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        V(T, &'a U),\n+        W,\n+    }\n+\n+    enum TeeOutlivesAyYooWhereIsDebug<'a, T, U> where U: Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        V { tee: &'a T },\n+        W(U),\n+    }\n+\n+    enum TeeYooWhereOutlivesAyBee<'a, 'b, T, U> {\n+        //~^ ERROR outlives requirements can be inferred\n+        V { tee: T, yoo: &'a &'b U },\n+        W,\n+    }\n+\n+    enum TeeYooWhereOutlivesAyBeeIsDebug<'a, 'b, T, U> where U: Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        V(T, &'a &'b U),\n+        W,\n+    }\n+\n+    enum TeeYooWhereIsDebugOutlivesAyBee<'a, 'b, T, U> where U: Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        V { tee: T },\n+        W(&'a &'b U),\n+    }\n+\n+    enum TeeOutlivesAyBeeYooWhereIsDebug<'a, 'b, T, U> where U: Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        V { tee: &'a &'b T, yoo: U },\n+        W,\n+    }\n+\n+    enum TeeWhereOutlivesAyYooWhereIsDebug<'a, T, U> where U: Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        V(&'a T, U),\n+        W,\n+    }\n+\n+    enum TeeWhereOutlivesAyBeeYooWhereIsDebug<'a, 'b, T, U> where U: Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        V { tee: &'a &'b T },\n+        W(U),\n+    }\n+\n+    enum BeeOutlivesAy<'a, 'b> {\n+        //~^ ERROR outlives requirements can be inferred\n+        V { tee: &'a &'b () },\n+    }\n+\n+    enum BeeWhereOutlivesAy<'a, 'b> {\n+        //~^ ERROR outlives requirements can be inferred\n+        V(&'a &'b ()),\n+    }\n+\n+    enum BeeOutlivesAyTee<'a, 'b, T> {\n+        //~^ ERROR outlives requirements can be inferred\n+        V { tee: &'a &'b T },\n+        W,\n+    }\n+\n+    enum BeeWhereOutlivesAyTee<'a, 'b, T> {\n+        //~^ ERROR outlives requirements can be inferred\n+        V(&'a &'b T),\n+        W,\n+    }\n+\n+    enum BeeWhereOutlivesAyTeeWhereBee<'a, 'b, T> {\n+        //~^ ERROR outlives requirements can be inferred\n+        V(&'a &'b T),\n+    }\n+\n+    enum BeeWhereOutlivesAyTeeWhereAyBee<'a, 'b, T> {\n+        //~^ ERROR outlives requirements can be inferred\n+        V(&'a &'b T),\n+        W,\n+    }\n+\n+    enum BeeOutlivesAyTeeDebug<'a, 'b, T: Debug> {\n+        //~^ ERROR outlives requirements can be inferred\n+        V { tee: &'a &'b T },\n+    }\n+\n+    enum BeeWhereOutlivesAyTeeWhereDebug<'a, 'b, T> where T: Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        V(&'a &'b T),\n+    }\n+}\n+\n+mod unions {\n+    use std::fmt::Debug;\n+\n+    union TeeOutlivesAy<'a, T> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a T\n+    }\n+\n+    union TeeOutlivesAyIsDebug<'a, T: Debug> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a T\n+    }\n+\n+    union TeeIsDebugOutlivesAy<'a, T: Debug> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a T\n+    }\n+\n+    union TeeOutlivesAyBee<'a, 'b, T> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T\n+    }\n+\n+    union TeeOutlivesAyBeeIsDebug<'a, 'b, T: Debug> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T\n+    }\n+\n+    union TeeIsDebugOutlivesAyBee<'a, 'b, T: Debug> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T\n+    }\n+\n+    union TeeWhereOutlivesAy<'a, T> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a T\n+    }\n+\n+    union TeeWhereOutlivesAyIsDebug<'a, T> where T: Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a T\n+    }\n+\n+    union TeeWhereIsDebugOutlivesAy<'a, T> where T: Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a T\n+    }\n+\n+    union TeeWhereOutlivesAyBee<'a, 'b, T> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T\n+    }\n+\n+    union TeeWhereOutlivesAyBeeIsDebug<'a, 'b, T> where T: Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T\n+    }\n+\n+    union TeeWhereIsDebugOutlivesAyBee<'a, 'b, T> where T: Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T\n+    }\n+\n+    union TeeYooOutlivesAy<'a, T, U> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: *const T,\n+        yoo: &'a U\n+    }\n+\n+    union TeeYooOutlivesAyIsDebug<'a, T, U: Debug> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: *const T,\n+        yoo: &'a U\n+    }\n+\n+    union TeeYooIsDebugOutlivesAy<'a, T, U: Debug> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: *const T,\n+        yoo: &'a U\n+    }\n+\n+    union TeeOutlivesAyYooIsDebug<'a, T, U: Debug> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a T,\n+        yoo: *const U\n+    }\n+\n+    union TeeYooOutlivesAyBee<'a, 'b, T, U> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: *const T,\n+        yoo: &'a &'b U\n+    }\n+\n+    union TeeYooOutlivesAyBeeIsDebug<'a, 'b, T, U: Debug> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: *const T,\n+        yoo: &'a &'b U\n+    }\n+\n+    union TeeYooIsDebugOutlivesAyBee<'a, 'b, T, U: Debug> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: *const T,\n+        yoo: &'a &'b U\n+    }\n+\n+    union TeeOutlivesAyBeeYooIsDebug<'a, 'b, T, U: Debug> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T,\n+        yoo: *const U\n+    }\n+\n+    union TeeYooWhereOutlivesAy<'a, T, U> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: *const T,\n+        yoo: &'a U\n+    }\n+\n+    union TeeYooWhereOutlivesAyIsDebug<'a, T, U> where U: Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: *const T,\n+        yoo: &'a U\n+    }\n+\n+    union TeeYooWhereIsDebugOutlivesAy<'a, T, U> where U: Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: *const T,\n+        yoo: &'a U\n+    }\n+\n+    union TeeOutlivesAyYooWhereIsDebug<'a, T, U> where U: Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a T,\n+        yoo: *const U\n+    }\n+\n+    union TeeYooWhereOutlivesAyBee<'a, 'b, T, U> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: *const T,\n+        yoo: &'a &'b U\n+    }\n+\n+    union TeeYooWhereOutlivesAyBeeIsDebug<'a, 'b, T, U> where U: Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: *const T,\n+        yoo: &'a &'b U\n+    }\n+\n+    union TeeYooWhereIsDebugOutlivesAyBee<'a, 'b, T, U> where U: Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: *const T,\n+        yoo: &'a &'b U\n+    }\n+\n+    union TeeOutlivesAyBeeYooWhereIsDebug<'a, 'b, T, U> where U: Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T,\n+        yoo: *const U\n+    }\n+\n+    union TeeWhereOutlivesAyYooWhereIsDebug<'a, T, U> where U: Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a T,\n+        yoo: *const U\n+    }\n+\n+    union TeeWhereOutlivesAyBeeYooWhereIsDebug<'a, 'b, T, U> where U: Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T,\n+        yoo: *const U\n+    }\n+\n+    union BeeOutlivesAy<'a, 'b> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b (),\n+    }\n+\n+    union BeeWhereOutlivesAy<'a, 'b> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b (),\n+    }\n+\n+    union BeeOutlivesAyTee<'a, 'b, T> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T,\n+    }\n+\n+    union BeeWhereOutlivesAyTee<'a, 'b, T> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T,\n+    }\n+\n+    union BeeWhereOutlivesAyTeeWhereBee<'a, 'b, T> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T,\n+    }\n+\n+    union BeeWhereOutlivesAyTeeWhereAyBee<'a, 'b, T> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T,\n+    }\n+\n+    union BeeOutlivesAyTeeDebug<'a, 'b, T: Debug> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T,\n+    }\n+\n+    union BeeWhereOutlivesAyTeeWhereDebug<'a, 'b, T> where T: Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T,\n+    }\n }\n \n "}, {"sha": "d9486ba66f8aa236ff01d364281591550d7aff5d", "filename": "src/test/ui/rust-2018/edition-lint-infer-outlives.rs", "status": "modified", "additions": 706, "deletions": 113, "changes": 819, "blob_url": "https://github.com/rust-lang/rust/blob/e79b2a18a21e6b178d73473bb8fdbf3d18c66051/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e79b2a18a21e6b178d73473bb8fdbf3d18c66051/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives.rs?ref=e79b2a18a21e6b178d73473bb8fdbf3d18c66051", "patch": "@@ -3,9 +3,6 @@\n #![allow(unused)]\n #![deny(explicit_outlives_requirements)]\n \n-use std::fmt::{Debug, Display};\n-\n-\n // Programmatically generated examples!\n //\n // Exercise outlives bounds for each of the following parameter/position\n@@ -17,177 +14,773 @@ use std::fmt::{Debug, Display};\n // \u2022 two parameters (T and U), one bound inline, one with a where clause\n // \u2022 two parameters (T and U), both with where clauses\n //\n-// \u2014and for every permutation of 0, 1, or 2 lifetimes to outlive and 0 or 1\n-// trait bounds distributed among said parameters (subject to no where clause\n-// being empty and the struct having at least one lifetime).\n+// \u2014and for every permutation of 1 or 2 lifetimes to outlive and 0 or 1 trait\n+// bounds distributed among said parameters (subject to no where clause being\n+// empty and the struct having at least one lifetime).\n+//\n+// \u2014and for each of tuple structs, enums and unions.\n+\n+mod structs {\n+    use std::fmt::Debug;\n+\n+    struct TeeOutlivesAy<'a, T: 'a> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a T\n+    }\n+\n+    struct TeeOutlivesAyIsDebug<'a, T: 'a + Debug> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a T\n+    }\n+\n+    struct TeeIsDebugOutlivesAy<'a, T: Debug + 'a> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a T\n+    }\n+\n+    struct TeeOutlivesAyBee<'a, 'b, T: 'a + 'b> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T\n+    }\n+\n+    struct TeeOutlivesAyBeeIsDebug<'a, 'b, T: 'a + 'b + Debug> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T\n+    }\n+\n+    struct TeeIsDebugOutlivesAyBee<'a, 'b, T: Debug + 'a + 'b> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T\n+    }\n+\n+    struct TeeWhereOutlivesAy<'a, T> where T: 'a {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a T\n+    }\n+\n+    struct TeeWhereOutlivesAyIsDebug<'a, T> where T: 'a + Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a T\n+    }\n+\n+    struct TeeWhereIsDebugOutlivesAy<'a, T> where T: Debug + 'a {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a T\n+    }\n+\n+    struct TeeWhereOutlivesAyBee<'a, 'b, T> where T: 'a + 'b {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T\n+    }\n+\n+    struct TeeWhereOutlivesAyBeeIsDebug<'a, 'b, T> where T: 'a + 'b + Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T\n+    }\n+\n+    struct TeeWhereIsDebugOutlivesAyBee<'a, 'b, T> where T: Debug + 'a + 'b {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T\n+    }\n+\n+    struct TeeYooOutlivesAy<'a, T, U: 'a> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: T,\n+        yoo: &'a U\n+    }\n+\n+    struct TeeYooOutlivesAyIsDebug<'a, T, U: 'a + Debug> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: T,\n+        yoo: &'a U\n+    }\n+\n+    struct TeeYooIsDebugOutlivesAy<'a, T, U: Debug + 'a> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: T,\n+        yoo: &'a U\n+    }\n+\n+    struct TeeOutlivesAyYooIsDebug<'a, T: 'a, U: Debug> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a T,\n+        yoo: U\n+    }\n+\n+    struct TeeYooOutlivesAyBee<'a, 'b, T, U: 'a + 'b> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: T,\n+        yoo: &'a &'b U\n+    }\n+\n+    struct TeeYooOutlivesAyBeeIsDebug<'a, 'b, T, U: 'a + 'b + Debug> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: T,\n+        yoo: &'a &'b U\n+    }\n+\n+    struct TeeYooIsDebugOutlivesAyBee<'a, 'b, T, U: Debug + 'a + 'b> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: T,\n+        yoo: &'a &'b U\n+    }\n+\n+    struct TeeOutlivesAyBeeYooIsDebug<'a, 'b, T: 'a + 'b, U: Debug> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T,\n+        yoo: U\n+    }\n+\n+    struct TeeYooWhereOutlivesAy<'a, T, U> where U: 'a {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: T,\n+        yoo: &'a U\n+    }\n+\n+    struct TeeYooWhereOutlivesAyIsDebug<'a, T, U> where U: 'a + Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: T,\n+        yoo: &'a U\n+    }\n+\n+    struct TeeYooWhereIsDebugOutlivesAy<'a, T, U> where U: Debug + 'a {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: T,\n+        yoo: &'a U\n+    }\n+\n+    struct TeeOutlivesAyYooWhereIsDebug<'a, T: 'a, U> where U: Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a T,\n+        yoo: U\n+    }\n+\n+    struct TeeYooWhereOutlivesAyBee<'a, 'b, T, U> where U: 'a + 'b {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: T,\n+        yoo: &'a &'b U\n+    }\n+\n+    struct TeeYooWhereOutlivesAyBeeIsDebug<'a, 'b, T, U> where U: 'a + 'b + Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: T,\n+        yoo: &'a &'b U\n+    }\n+\n+    struct TeeYooWhereIsDebugOutlivesAyBee<'a, 'b, T, U> where U: Debug + 'a + 'b {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: T,\n+        yoo: &'a &'b U\n+    }\n+\n+    struct TeeOutlivesAyBeeYooWhereIsDebug<'a, 'b, T: 'a + 'b, U> where U: Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T,\n+        yoo: U\n+    }\n+\n+    struct TeeWhereOutlivesAyYooWhereIsDebug<'a, T, U> where T: 'a, U: Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a T,\n+        yoo: U\n+    }\n+\n+    struct TeeWhereOutlivesAyBeeYooWhereIsDebug<'a, 'b, T, U> where T: 'a + 'b, U: Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T,\n+        yoo: U\n+    }\n+\n+    struct BeeOutlivesAy<'a, 'b: 'a> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b (),\n+    }\n+\n+    struct BeeWhereOutlivesAy<'a, 'b> where 'b: 'a {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b (),\n+    }\n+\n+    struct BeeOutlivesAyTee<'a, 'b: 'a, T> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T,\n+    }\n+\n+    struct BeeWhereOutlivesAyTee<'a, 'b, T> where 'b: 'a {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T,\n+    }\n+\n+    struct BeeWhereOutlivesAyTeeWhereBee<'a, 'b, T> where 'b: 'a, T: 'b {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T,\n+    }\n+\n+    struct BeeWhereOutlivesAyTeeWhereAyBee<'a, 'b, T> where 'b: 'a, T: 'a + 'b {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T,\n+    }\n+\n+    struct BeeOutlivesAyTeeDebug<'a, 'b: 'a, T: Debug> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T,\n+    }\n+\n+    struct BeeWhereOutlivesAyTeeWhereDebug<'a, 'b, T> where 'b: 'a, T: Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T,\n+    }\n+}\n \n+mod tuple_structs {\n+    use std::fmt::Debug;\n \n-struct TeeOutlivesAy<'a, T: 'a> {\n+    struct TeeOutlivesAy<'a, T: 'a>(&'a T);\n     //~^ ERROR outlives requirements can be inferred\n-    tee: &'a T\n-}\n \n-struct TeeOutlivesAyIsDebug<'a, T: 'a + Debug> {\n+    struct TeeOutlivesAyIsDebug<'a, T: 'a + Debug>(&'a T);\n     //~^ ERROR outlives requirements can be inferred\n-    tee: &'a T\n-}\n \n-struct TeeIsDebugOutlivesAy<'a, T: Debug + 'a> {\n+    struct TeeIsDebugOutlivesAy<'a, T: Debug + 'a>(&'a T);\n     //~^ ERROR outlives requirements can be inferred\n-    tee: &'a T\n-}\n \n-struct TeeOutlivesAyBee<'a, 'b, T: 'a + 'b> {\n+    struct TeeOutlivesAyBee<'a, 'b, T: 'a + 'b>(&'a &'b T);\n     //~^ ERROR outlives requirements can be inferred\n-    tee: &'a &'b T\n-}\n \n-struct TeeOutlivesAyBeeIsDebug<'a, 'b, T: 'a + 'b + Debug> {\n+    struct TeeOutlivesAyBeeIsDebug<'a, 'b, T: 'a + 'b + Debug>(&'a &'b T);\n     //~^ ERROR outlives requirements can be inferred\n-    tee: &'a &'b T\n-}\n \n-struct TeeIsDebugOutlivesAyBee<'a, 'b, T: Debug + 'a + 'b> {\n+    struct TeeIsDebugOutlivesAyBee<'a, 'b, T: Debug + 'a + 'b>(&'a &'b T);\n     //~^ ERROR outlives requirements can be inferred\n-    tee: &'a &'b T\n-}\n \n-struct TeeWhereOutlivesAy<'a, T> where T: 'a {\n+    struct TeeWhereOutlivesAy<'a, T>(&'a T) where T: 'a;\n     //~^ ERROR outlives requirements can be inferred\n-    tee: &'a T\n-}\n \n-struct TeeWhereOutlivesAyIsDebug<'a, T> where T: 'a + Debug {\n+    struct TeeWhereOutlivesAyIsDebug<'a, T>(&'a T) where T: 'a + Debug;\n     //~^ ERROR outlives requirements can be inferred\n-    tee: &'a T\n-}\n \n-struct TeeWhereIsDebugOutlivesAy<'a, T> where T: Debug + 'a {\n+    struct TeeWhereIsDebugOutlivesAy<'a, T>(&'a T) where T: Debug + 'a;\n     //~^ ERROR outlives requirements can be inferred\n-    tee: &'a T\n-}\n \n-struct TeeWhereOutlivesAyBee<'a, 'b, T> where T: 'a + 'b {\n+    struct TeeWhereOutlivesAyBee<'a, 'b, T>(&'a &'b T) where T: 'a + 'b;\n     //~^ ERROR outlives requirements can be inferred\n-    tee: &'a &'b T\n-}\n \n-struct TeeWhereOutlivesAyBeeIsDebug<'a, 'b, T> where T: 'a + 'b + Debug {\n+    struct TeeWhereOutlivesAyBeeIsDebug<'a, 'b, T>(&'a &'b T) where T: 'a + 'b + Debug;\n     //~^ ERROR outlives requirements can be inferred\n-    tee: &'a &'b T\n-}\n \n-struct TeeWhereIsDebugOutlivesAyBee<'a, 'b, T> where T: Debug + 'a + 'b {\n+    struct TeeWhereIsDebugOutlivesAyBee<'a, 'b, T>(&'a &'b T) where T: Debug + 'a + 'b;\n     //~^ ERROR outlives requirements can be inferred\n-    tee: &'a &'b T\n-}\n \n-struct TeeYooOutlivesAy<'a, T, U: 'a> {\n+    struct TeeYooOutlivesAy<'a, T, U: 'a>(T, &'a U);\n     //~^ ERROR outlives requirements can be inferred\n-    tee: T,\n-    yoo: &'a U\n-}\n \n-struct TeeYooOutlivesAyIsDebug<'a, T, U: 'a + Debug> {\n+    struct TeeYooOutlivesAyIsDebug<'a, T, U: 'a + Debug>(T, &'a U);\n     //~^ ERROR outlives requirements can be inferred\n-    tee: T,\n-    yoo: &'a U\n-}\n \n-struct TeeYooIsDebugOutlivesAy<'a, T, U: Debug + 'a> {\n+    struct TeeYooIsDebugOutlivesAy<'a, T, U: Debug + 'a>(T, &'a U);\n     //~^ ERROR outlives requirements can be inferred\n-    tee: T,\n-    yoo: &'a U\n-}\n \n-struct TeeOutlivesAyYooIsDebug<'a, T: 'a, U: Debug> {\n+    struct TeeOutlivesAyYooIsDebug<'a, T: 'a, U: Debug>(&'a T, U);\n     //~^ ERROR outlives requirements can be inferred\n-    tee: &'a T,\n-    yoo: U\n-}\n \n-struct TeeYooOutlivesAyBee<'a, 'b, T, U: 'a + 'b> {\n+    struct TeeYooOutlivesAyBee<'a, 'b, T, U: 'a + 'b>(T, &'a &'b U);\n     //~^ ERROR outlives requirements can be inferred\n-    tee: T,\n-    yoo: &'a &'b U\n-}\n \n-struct TeeYooOutlivesAyBeeIsDebug<'a, 'b, T, U: 'a + 'b + Debug> {\n+    struct TeeYooOutlivesAyBeeIsDebug<'a, 'b, T, U: 'a + 'b + Debug>(T, &'a &'b U);\n     //~^ ERROR outlives requirements can be inferred\n-    tee: T,\n-    yoo: &'a &'b U\n-}\n \n-struct TeeYooIsDebugOutlivesAyBee<'a, 'b, T, U: Debug + 'a + 'b> {\n+    struct TeeYooIsDebugOutlivesAyBee<'a, 'b, T, U: Debug + 'a + 'b>(T, &'a &'b U);\n     //~^ ERROR outlives requirements can be inferred\n-    tee: T,\n-    yoo: &'a &'b U\n-}\n \n-struct TeeOutlivesAyBeeYooIsDebug<'a, 'b, T: 'a + 'b, U: Debug> {\n+    struct TeeOutlivesAyBeeYooIsDebug<'a, 'b, T: 'a + 'b, U: Debug>(&'a &'b T, U);\n     //~^ ERROR outlives requirements can be inferred\n-    tee: &'a &'b T,\n-    yoo: U\n-}\n \n-struct TeeYooWhereOutlivesAy<'a, T, U> where U: 'a {\n+    struct TeeYooWhereOutlivesAy<'a, T, U>(T, &'a U) where U: 'a;\n     //~^ ERROR outlives requirements can be inferred\n-    tee: T,\n-    yoo: &'a U\n-}\n \n-struct TeeYooWhereOutlivesAyIsDebug<'a, T, U> where U: 'a + Debug {\n+    struct TeeYooWhereOutlivesAyIsDebug<'a, T, U>(T, &'a U) where U: 'a + Debug;\n     //~^ ERROR outlives requirements can be inferred\n-    tee: T,\n-    yoo: &'a U\n-}\n \n-struct TeeYooWhereIsDebugOutlivesAy<'a, T, U> where U: Debug + 'a {\n+    struct TeeYooWhereIsDebugOutlivesAy<'a, T, U>(T, &'a U) where U: Debug + 'a;\n     //~^ ERROR outlives requirements can be inferred\n-    tee: T,\n-    yoo: &'a U\n-}\n \n-struct TeeOutlivesAyYooWhereIsDebug<'a, T: 'a, U> where U: Debug {\n+    struct TeeOutlivesAyYooWhereIsDebug<'a, T: 'a, U>(&'a T, U) where U: Debug;\n     //~^ ERROR outlives requirements can be inferred\n-    tee: &'a T,\n-    yoo: U\n-}\n \n-struct TeeYooWhereOutlivesAyBee<'a, 'b, T, U> where U: 'a + 'b {\n+    struct TeeYooWhereOutlivesAyBee<'a, 'b, T, U>(T, &'a &'b U) where U: 'a + 'b;\n     //~^ ERROR outlives requirements can be inferred\n-    tee: T,\n-    yoo: &'a &'b U\n-}\n \n-struct TeeYooWhereOutlivesAyBeeIsDebug<'a, 'b, T, U> where U: 'a + 'b + Debug {\n+    struct TeeYooWhereOutlivesAyBeeIsDebug<'a, 'b, T, U>(T, &'a &'b U) where U: 'a + 'b + Debug;\n     //~^ ERROR outlives requirements can be inferred\n-    tee: T,\n-    yoo: &'a &'b U\n-}\n \n-struct TeeYooWhereIsDebugOutlivesAyBee<'a, 'b, T, U> where U: Debug + 'a + 'b {\n+    struct TeeYooWhereIsDebugOutlivesAyBee<'a, 'b, T, U>(T, &'a &'b U) where U: Debug + 'a + 'b;\n     //~^ ERROR outlives requirements can be inferred\n-    tee: T,\n-    yoo: &'a &'b U\n-}\n \n-struct TeeOutlivesAyBeeYooWhereIsDebug<'a, 'b, T: 'a + 'b, U> where U: Debug {\n+    struct TeeOutlivesAyBeeYooWhereIsDebug<'a, 'b, T: 'a + 'b, U>(&'a &'b T, U) where U: Debug;\n     //~^ ERROR outlives requirements can be inferred\n-    tee: &'a &'b T,\n-    yoo: U\n-}\n \n-struct TeeWhereOutlivesAyYooWhereIsDebug<'a, T, U> where T: 'a, U: Debug {\n+    struct TeeWhereOutlivesAyYooWhereIsDebug<'a, T, U>(&'a T, U) where T: 'a, U: Debug;\n+    //~^ ERROR outlives requirements can be inferred\n+\n+    struct TeeWhereAyBeeYooWhereIsDebug<'a, 'b, T, U>(&'a &'b T, U) where T: 'a + 'b, U: Debug;\n+    //~^ ERROR outlives requirements can be inferred\n+\n+    struct BeeOutlivesAy<'a, 'b: 'a>(&'a &'b ());\n+    //~^ ERROR outlives requirements can be inferred\n+\n+    struct BeeWhereOutlivesAy<'a, 'b>(&'a &'b ()) where 'b: 'a;\n+    //~^ ERROR outlives requirements can be inferred\n+\n+    struct BeeOutlivesAyTee<'a, 'b: 'a, T>(&'a &'b T);\n+    //~^ ERROR outlives requirements can be inferred\n+\n+    struct BeeWhereOutlivesAyTee<'a, 'b, T>(&'a &'b T) where 'b: 'a;\n+    //~^ ERROR outlives requirements can be inferred\n+\n+    struct BeeWhereOutlivesAyTeeWhereBee<'a, 'b, T>(&'a &'b T) where 'b: 'a, T: 'b;\n+    //~^ ERROR outlives requirements can be inferred\n+\n+    struct BeeWhereOutlivesAyTeeWhereAyBee<'a, 'b, T>(&'a &'b T) where 'b: 'a, T: 'a + 'b;\n     //~^ ERROR outlives requirements can be inferred\n-    tee: &'a T,\n-    yoo: U\n-}\n \n-struct TeeWhereOutlivesAyBeeYooWhereIsDebug<'a, 'b, T, U> where T: 'a + 'b, U: Debug {\n+    struct BeeOutlivesAyTeeDebug<'a, 'b: 'a, T: Debug>(&'a &'b T);\n     //~^ ERROR outlives requirements can be inferred\n-    tee: &'a &'b T,\n-    yoo: U\n+\n+    struct BeeWhereOutlivesAyTeeWhereDebug<'a, 'b, T>(&'a &'b T) where 'b: 'a, T: Debug;\n+    //~^ ERROR outlives requirements can be inferred\n+}\n+\n+mod enums {\n+    use std::fmt::Debug;\n+\n+    enum TeeOutlivesAy<'a, T: 'a> {\n+        //~^ ERROR outlives requirements can be inferred\n+        V { tee: &'a T },\n+    }\n+\n+    enum TeeOutlivesAyIsDebug<'a, T: 'a + Debug> {\n+        //~^ ERROR outlives requirements can be inferred\n+        V(&'a T),\n+    }\n+\n+    enum TeeIsDebugOutlivesAy<'a, T: Debug + 'a> {\n+        //~^ ERROR outlives requirements can be inferred\n+        V { tee: &'a T },\n+        W,\n+    }\n+\n+    enum TeeOutlivesAyBee<'a, 'b, T: 'a + 'b> {\n+        //~^ ERROR outlives requirements can be inferred\n+        V(&'a &'b T),\n+        W,\n+    }\n+\n+    enum TeeOutlivesAyBeeIsDebug<'a, 'b, T: 'a + 'b + Debug> {\n+        //~^ ERROR outlives requirements can be inferred\n+        V { tee: &'a &'b T },\n+    }\n+\n+    enum TeeIsDebugOutlivesAyBee<'a, 'b, T: Debug + 'a + 'b> {\n+        //~^ ERROR outlives requirements can be inferred\n+        V(&'a &'b T),\n+    }\n+\n+    enum TeeWhereOutlivesAy<'a, T> where T: 'a {\n+        //~^ ERROR outlives requirements can be inferred\n+        V { tee: &'a T },\n+        W,\n+    }\n+\n+    enum TeeWhereOutlivesAyIsDebug<'a, T> where T: 'a + Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        V(&'a T),\n+        W,\n+    }\n+\n+    enum TeeWhereIsDebugOutlivesAy<'a, T> where T: Debug + 'a {\n+        //~^ ERROR outlives requirements can be inferred\n+        V { tee: &'a T },\n+    }\n+\n+    enum TeeWhereOutlivesAyBee<'a, 'b, T> where T: 'a + 'b {\n+        //~^ ERROR outlives requirements can be inferred\n+        V(&'a &'b T),\n+    }\n+\n+    enum TeeWhereOutlivesAyBeeIsDebug<'a, 'b, T> where T: 'a + 'b + Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        V { tee: &'a &'b T },\n+        W,\n+    }\n+\n+    enum TeeWhereIsDebugOutlivesAyBee<'a, 'b, T> where T: Debug + 'a + 'b {\n+        //~^ ERROR outlives requirements can be inferred\n+        V(&'a &'b T),\n+        W,\n+    }\n+\n+    enum TeeYooOutlivesAy<'a, T, U: 'a> {\n+        //~^ ERROR outlives requirements can be inferred\n+        V { tee: T },\n+        W(&'a U),\n+    }\n+\n+    enum TeeYooOutlivesAyIsDebug<'a, T, U: 'a + Debug> {\n+        //~^ ERROR outlives requirements can be inferred\n+        V { tee: T, yoo: &'a U },\n+        W,\n+    }\n+\n+    enum TeeYooIsDebugOutlivesAy<'a, T, U: Debug + 'a> {\n+        //~^ ERROR outlives requirements can be inferred\n+        V(T, &'a U),\n+        W,\n+    }\n+\n+    enum TeeOutlivesAyYooIsDebug<'a, T: 'a, U: Debug> {\n+        //~^ ERROR outlives requirements can be inferred\n+        V { tee: &'a T },\n+        W(U),\n+    }\n+\n+    enum TeeYooOutlivesAyBee<'a, 'b, T, U: 'a + 'b> {\n+        //~^ ERROR outlives requirements can be inferred\n+        V { tee: T, yoo: &'a &'b U },\n+        W,\n+    }\n+\n+    enum TeeYooOutlivesAyBeeIsDebug<'a, 'b, T, U: 'a + 'b + Debug> {\n+        //~^ ERROR outlives requirements can be inferred\n+        V(T, &'a &'b U),\n+        W,\n+    }\n+\n+    enum TeeYooIsDebugOutlivesAyBee<'a, 'b, T, U: Debug + 'a + 'b> {\n+        //~^ ERROR outlives requirements can be inferred\n+        V { tee: T, yoo: &'a &'b U },\n+        W,\n+    }\n+\n+    enum TeeOutlivesAyBeeYooIsDebug<'a, 'b, T: 'a + 'b, U: Debug> {\n+        //~^ ERROR outlives requirements can be inferred\n+        V(&'a &'b T, U),\n+        W,\n+    }\n+\n+    enum TeeYooWhereOutlivesAy<'a, T, U> where U: 'a {\n+        //~^ ERROR outlives requirements can be inferred\n+        V { tee: T },\n+        W(&'a U),\n+    }\n+\n+    enum TeeYooWhereOutlivesAyIsDebug<'a, T, U> where U: 'a + Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        V { tee: T, yoo: &'a U },\n+        W,\n+    }\n+\n+    enum TeeYooWhereIsDebugOutlivesAy<'a, T, U> where U: Debug + 'a {\n+        //~^ ERROR outlives requirements can be inferred\n+        V(T, &'a U),\n+        W,\n+    }\n+\n+    enum TeeOutlivesAyYooWhereIsDebug<'a, T: 'a, U> where U: Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        V { tee: &'a T },\n+        W(U),\n+    }\n+\n+    enum TeeYooWhereOutlivesAyBee<'a, 'b, T, U> where U: 'a + 'b {\n+        //~^ ERROR outlives requirements can be inferred\n+        V { tee: T, yoo: &'a &'b U },\n+        W,\n+    }\n+\n+    enum TeeYooWhereOutlivesAyBeeIsDebug<'a, 'b, T, U> where U: 'a + 'b + Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        V(T, &'a &'b U),\n+        W,\n+    }\n+\n+    enum TeeYooWhereIsDebugOutlivesAyBee<'a, 'b, T, U> where U: Debug + 'a + 'b {\n+        //~^ ERROR outlives requirements can be inferred\n+        V { tee: T },\n+        W(&'a &'b U),\n+    }\n+\n+    enum TeeOutlivesAyBeeYooWhereIsDebug<'a, 'b, T: 'a + 'b, U> where U: Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        V { tee: &'a &'b T, yoo: U },\n+        W,\n+    }\n+\n+    enum TeeWhereOutlivesAyYooWhereIsDebug<'a, T, U> where T: 'a, U: Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        V(&'a T, U),\n+        W,\n+    }\n+\n+    enum TeeWhereOutlivesAyBeeYooWhereIsDebug<'a, 'b, T, U> where T: 'a + 'b, U: Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        V { tee: &'a &'b T },\n+        W(U),\n+    }\n+\n+    enum BeeOutlivesAy<'a, 'b: 'a> {\n+        //~^ ERROR outlives requirements can be inferred\n+        V { tee: &'a &'b () },\n+    }\n+\n+    enum BeeWhereOutlivesAy<'a, 'b> where 'b: 'a {\n+        //~^ ERROR outlives requirements can be inferred\n+        V(&'a &'b ()),\n+    }\n+\n+    enum BeeOutlivesAyTee<'a, 'b: 'a, T> {\n+        //~^ ERROR outlives requirements can be inferred\n+        V { tee: &'a &'b T },\n+        W,\n+    }\n+\n+    enum BeeWhereOutlivesAyTee<'a, 'b, T> where 'b: 'a {\n+        //~^ ERROR outlives requirements can be inferred\n+        V(&'a &'b T),\n+        W,\n+    }\n+\n+    enum BeeWhereOutlivesAyTeeWhereBee<'a, 'b, T> where 'b: 'a, T: 'b {\n+        //~^ ERROR outlives requirements can be inferred\n+        V(&'a &'b T),\n+    }\n+\n+    enum BeeWhereOutlivesAyTeeWhereAyBee<'a, 'b, T> where 'b: 'a, T: 'a + 'b {\n+        //~^ ERROR outlives requirements can be inferred\n+        V(&'a &'b T),\n+        W,\n+    }\n+\n+    enum BeeOutlivesAyTeeDebug<'a, 'b: 'a, T: Debug> {\n+        //~^ ERROR outlives requirements can be inferred\n+        V { tee: &'a &'b T },\n+    }\n+\n+    enum BeeWhereOutlivesAyTeeWhereDebug<'a, 'b, T> where 'b: 'a, T: Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        V(&'a &'b T),\n+    }\n+}\n+\n+mod unions {\n+    use std::fmt::Debug;\n+\n+    union TeeOutlivesAy<'a, T: 'a> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a T\n+    }\n+\n+    union TeeOutlivesAyIsDebug<'a, T: 'a + Debug> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a T\n+    }\n+\n+    union TeeIsDebugOutlivesAy<'a, T: Debug + 'a> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a T\n+    }\n+\n+    union TeeOutlivesAyBee<'a, 'b, T: 'a + 'b> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T\n+    }\n+\n+    union TeeOutlivesAyBeeIsDebug<'a, 'b, T: 'a + 'b + Debug> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T\n+    }\n+\n+    union TeeIsDebugOutlivesAyBee<'a, 'b, T: Debug + 'a + 'b> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T\n+    }\n+\n+    union TeeWhereOutlivesAy<'a, T> where T: 'a {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a T\n+    }\n+\n+    union TeeWhereOutlivesAyIsDebug<'a, T> where T: 'a + Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a T\n+    }\n+\n+    union TeeWhereIsDebugOutlivesAy<'a, T> where T: Debug + 'a {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a T\n+    }\n+\n+    union TeeWhereOutlivesAyBee<'a, 'b, T> where T: 'a + 'b {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T\n+    }\n+\n+    union TeeWhereOutlivesAyBeeIsDebug<'a, 'b, T> where T: 'a + 'b + Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T\n+    }\n+\n+    union TeeWhereIsDebugOutlivesAyBee<'a, 'b, T> where T: Debug + 'a + 'b {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T\n+    }\n+\n+    union TeeYooOutlivesAy<'a, T, U: 'a> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: *const T,\n+        yoo: &'a U\n+    }\n+\n+    union TeeYooOutlivesAyIsDebug<'a, T, U: 'a + Debug> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: *const T,\n+        yoo: &'a U\n+    }\n+\n+    union TeeYooIsDebugOutlivesAy<'a, T, U: Debug + 'a> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: *const T,\n+        yoo: &'a U\n+    }\n+\n+    union TeeOutlivesAyYooIsDebug<'a, T: 'a, U: Debug> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a T,\n+        yoo: *const U\n+    }\n+\n+    union TeeYooOutlivesAyBee<'a, 'b, T, U: 'a + 'b> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: *const T,\n+        yoo: &'a &'b U\n+    }\n+\n+    union TeeYooOutlivesAyBeeIsDebug<'a, 'b, T, U: 'a + 'b + Debug> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: *const T,\n+        yoo: &'a &'b U\n+    }\n+\n+    union TeeYooIsDebugOutlivesAyBee<'a, 'b, T, U: Debug + 'a + 'b> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: *const T,\n+        yoo: &'a &'b U\n+    }\n+\n+    union TeeOutlivesAyBeeYooIsDebug<'a, 'b, T: 'a + 'b, U: Debug> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T,\n+        yoo: *const U\n+    }\n+\n+    union TeeYooWhereOutlivesAy<'a, T, U> where U: 'a {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: *const T,\n+        yoo: &'a U\n+    }\n+\n+    union TeeYooWhereOutlivesAyIsDebug<'a, T, U> where U: 'a + Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: *const T,\n+        yoo: &'a U\n+    }\n+\n+    union TeeYooWhereIsDebugOutlivesAy<'a, T, U> where U: Debug + 'a {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: *const T,\n+        yoo: &'a U\n+    }\n+\n+    union TeeOutlivesAyYooWhereIsDebug<'a, T: 'a, U> where U: Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a T,\n+        yoo: *const U\n+    }\n+\n+    union TeeYooWhereOutlivesAyBee<'a, 'b, T, U> where U: 'a + 'b {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: *const T,\n+        yoo: &'a &'b U\n+    }\n+\n+    union TeeYooWhereOutlivesAyBeeIsDebug<'a, 'b, T, U> where U: 'a + 'b + Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: *const T,\n+        yoo: &'a &'b U\n+    }\n+\n+    union TeeYooWhereIsDebugOutlivesAyBee<'a, 'b, T, U> where U: Debug + 'a + 'b {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: *const T,\n+        yoo: &'a &'b U\n+    }\n+\n+    union TeeOutlivesAyBeeYooWhereIsDebug<'a, 'b, T: 'a + 'b, U> where U: Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T,\n+        yoo: *const U\n+    }\n+\n+    union TeeWhereOutlivesAyYooWhereIsDebug<'a, T, U> where T: 'a, U: Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a T,\n+        yoo: *const U\n+    }\n+\n+    union TeeWhereOutlivesAyBeeYooWhereIsDebug<'a, 'b, T, U> where T: 'a + 'b, U: Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T,\n+        yoo: *const U\n+    }\n+\n+    union BeeOutlivesAy<'a, 'b: 'a> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b (),\n+    }\n+\n+    union BeeWhereOutlivesAy<'a, 'b> where 'b: 'a {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b (),\n+    }\n+\n+    union BeeOutlivesAyTee<'a, 'b: 'a, T> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T,\n+    }\n+\n+    union BeeWhereOutlivesAyTee<'a, 'b, T> where 'b: 'a {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T,\n+    }\n+\n+    union BeeWhereOutlivesAyTeeWhereBee<'a, 'b, T> where 'b: 'a, T: 'b {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T,\n+    }\n+\n+    union BeeWhereOutlivesAyTeeWhereAyBee<'a, 'b, T> where 'b: 'a, T: 'a + 'b {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T,\n+    }\n+\n+    union BeeOutlivesAyTeeDebug<'a, 'b: 'a, T: Debug> {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T,\n+    }\n+\n+    union BeeWhereOutlivesAyTeeWhereDebug<'a, 'b, T> where 'b: 'a, T: Debug {\n+        //~^ ERROR outlives requirements can be inferred\n+        tee: &'a &'b T,\n+    }\n }\n \n "}, {"sha": "cddce94254b40661318eb52aee1d792486b0463f", "filename": "src/test/ui/rust-2018/edition-lint-infer-outlives.stderr", "status": "modified", "additions": 821, "deletions": 89, "changes": 910, "blob_url": "https://github.com/rust-lang/rust/blob/e79b2a18a21e6b178d73473bb8fdbf3d18c66051/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e79b2a18a21e6b178d73473bb8fdbf3d18c66051/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives.stderr?ref=e79b2a18a21e6b178d73473bb8fdbf3d18c66051", "patch": "@@ -1,8 +1,8 @@\n error: outlives requirements can be inferred\n-  --> $DIR/edition-lint-infer-outlives.rs:25:27\n+  --> $DIR/edition-lint-infer-outlives.rs:26:31\n    |\n-LL | struct TeeOutlivesAy<'a, T: 'a> {\n-   |                           ^^^^ help: remove this bound\n+LL |     struct TeeOutlivesAy<'a, T: 'a> {\n+   |                               ^^^^ help: remove this bound\n    |\n note: lint level defined here\n   --> $DIR/edition-lint-infer-outlives.rs:4:9\n@@ -11,178 +11,910 @@ LL | #![deny(explicit_outlives_requirements)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: outlives requirements can be inferred\n-  --> $DIR/edition-lint-infer-outlives.rs:30:36\n+  --> $DIR/edition-lint-infer-outlives.rs:31:40\n    |\n-LL | struct TeeOutlivesAyIsDebug<'a, T: 'a + Debug> {\n-   |                                    ^^^^^ help: remove this bound\n+LL |     struct TeeOutlivesAyIsDebug<'a, T: 'a + Debug> {\n+   |                                        ^^^^^ help: remove this bound\n \n error: outlives requirements can be inferred\n-  --> $DIR/edition-lint-infer-outlives.rs:35:41\n+  --> $DIR/edition-lint-infer-outlives.rs:36:45\n    |\n-LL | struct TeeIsDebugOutlivesAy<'a, T: Debug + 'a> {\n-   |                                         ^^^^^ help: remove this bound\n+LL |     struct TeeIsDebugOutlivesAy<'a, T: Debug + 'a> {\n+   |                                             ^^^^^ help: remove this bound\n \n error: outlives requirements can be inferred\n-  --> $DIR/edition-lint-infer-outlives.rs:40:34\n+  --> $DIR/edition-lint-infer-outlives.rs:41:38\n    |\n-LL | struct TeeOutlivesAyBee<'a, 'b, T: 'a + 'b> {\n-   |                                  ^^^^^^^^^ help: remove these bounds\n+LL |     struct TeeOutlivesAyBee<'a, 'b, T: 'a + 'b> {\n+   |                                      ^^^^^^^^^ help: remove these bounds\n \n error: outlives requirements can be inferred\n-  --> $DIR/edition-lint-infer-outlives.rs:45:43\n+  --> $DIR/edition-lint-infer-outlives.rs:46:47\n    |\n-LL | struct TeeOutlivesAyBeeIsDebug<'a, 'b, T: 'a + 'b + Debug> {\n-   |                                           ^^^^^^^^^^ help: remove these bounds\n+LL |     struct TeeOutlivesAyBeeIsDebug<'a, 'b, T: 'a + 'b + Debug> {\n+   |                                               ^^^^^^^^^^ help: remove these bounds\n \n error: outlives requirements can be inferred\n-  --> $DIR/edition-lint-infer-outlives.rs:50:48\n+  --> $DIR/edition-lint-infer-outlives.rs:51:52\n    |\n-LL | struct TeeIsDebugOutlivesAyBee<'a, 'b, T: Debug + 'a + 'b> {\n-   |                                                ^^^^^^^^^^ help: remove these bounds\n+LL |     struct TeeIsDebugOutlivesAyBee<'a, 'b, T: Debug + 'a + 'b> {\n+   |                                                    ^^^^^^^^^^ help: remove these bounds\n \n error: outlives requirements can be inferred\n-  --> $DIR/edition-lint-infer-outlives.rs:55:33\n+  --> $DIR/edition-lint-infer-outlives.rs:56:37\n    |\n-LL | struct TeeWhereOutlivesAy<'a, T> where T: 'a {\n-   |                                 ^^^^^^^^^^^^ help: remove this bound\n+LL |     struct TeeWhereOutlivesAy<'a, T> where T: 'a {\n+   |                                     ^^^^^^^^^^^^ help: remove this bound\n \n error: outlives requirements can be inferred\n-  --> $DIR/edition-lint-infer-outlives.rs:60:50\n+  --> $DIR/edition-lint-infer-outlives.rs:61:54\n    |\n-LL | struct TeeWhereOutlivesAyIsDebug<'a, T> where T: 'a + Debug {\n-   |                                                  ^^^^^ help: remove this bound\n+LL |     struct TeeWhereOutlivesAyIsDebug<'a, T> where T: 'a + Debug {\n+   |                                                      ^^^^^ help: remove this bound\n \n error: outlives requirements can be inferred\n-  --> $DIR/edition-lint-infer-outlives.rs:65:55\n+  --> $DIR/edition-lint-infer-outlives.rs:66:59\n    |\n-LL | struct TeeWhereIsDebugOutlivesAy<'a, T> where T: Debug + 'a {\n-   |                                                       ^^^^^ help: remove this bound\n+LL |     struct TeeWhereIsDebugOutlivesAy<'a, T> where T: Debug + 'a {\n+   |                                                           ^^^^^ help: remove this bound\n \n error: outlives requirements can be inferred\n-  --> $DIR/edition-lint-infer-outlives.rs:70:40\n+  --> $DIR/edition-lint-infer-outlives.rs:71:44\n    |\n-LL | struct TeeWhereOutlivesAyBee<'a, 'b, T> where T: 'a + 'b {\n-   |                                        ^^^^^^^^^^^^^^^^^ help: remove these bounds\n+LL |     struct TeeWhereOutlivesAyBee<'a, 'b, T> where T: 'a + 'b {\n+   |                                            ^^^^^^^^^^^^^^^^^ help: remove these bounds\n \n error: outlives requirements can be inferred\n-  --> $DIR/edition-lint-infer-outlives.rs:75:57\n+  --> $DIR/edition-lint-infer-outlives.rs:76:61\n    |\n-LL | struct TeeWhereOutlivesAyBeeIsDebug<'a, 'b, T> where T: 'a + 'b + Debug {\n-   |                                                         ^^^^^^^^^^ help: remove these bounds\n+LL |     struct TeeWhereOutlivesAyBeeIsDebug<'a, 'b, T> where T: 'a + 'b + Debug {\n+   |                                                             ^^^^^^^^^^ help: remove these bounds\n \n error: outlives requirements can be inferred\n-  --> $DIR/edition-lint-infer-outlives.rs:80:62\n+  --> $DIR/edition-lint-infer-outlives.rs:81:66\n    |\n-LL | struct TeeWhereIsDebugOutlivesAyBee<'a, 'b, T> where T: Debug + 'a + 'b {\n-   |                                                              ^^^^^^^^^^ help: remove these bounds\n+LL |     struct TeeWhereIsDebugOutlivesAyBee<'a, 'b, T> where T: Debug + 'a + 'b {\n+   |                                                                  ^^^^^^^^^^ help: remove these bounds\n \n error: outlives requirements can be inferred\n-  --> $DIR/edition-lint-infer-outlives.rs:85:33\n+  --> $DIR/edition-lint-infer-outlives.rs:86:37\n    |\n-LL | struct TeeYooOutlivesAy<'a, T, U: 'a> {\n-   |                                 ^^^^ help: remove this bound\n+LL |     struct TeeYooOutlivesAy<'a, T, U: 'a> {\n+   |                                     ^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:92:46\n+   |\n+LL |     struct TeeYooOutlivesAyIsDebug<'a, T, U: 'a + Debug> {\n+   |                                              ^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:98:51\n+   |\n+LL |     struct TeeYooIsDebugOutlivesAy<'a, T, U: Debug + 'a> {\n+   |                                                   ^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:104:41\n+   |\n+LL |     struct TeeOutlivesAyYooIsDebug<'a, T: 'a, U: Debug> {\n+   |                                         ^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:110:44\n+   |\n+LL |     struct TeeYooOutlivesAyBee<'a, 'b, T, U: 'a + 'b> {\n+   |                                            ^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:116:53\n+   |\n+LL |     struct TeeYooOutlivesAyBeeIsDebug<'a, 'b, T, U: 'a + 'b + Debug> {\n+   |                                                     ^^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:122:58\n+   |\n+LL |     struct TeeYooIsDebugOutlivesAyBee<'a, 'b, T, U: Debug + 'a + 'b> {\n+   |                                                          ^^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:128:48\n+   |\n+LL |     struct TeeOutlivesAyBeeYooIsDebug<'a, 'b, T: 'a + 'b, U: Debug> {\n+   |                                                ^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:134:43\n+   |\n+LL |     struct TeeYooWhereOutlivesAy<'a, T, U> where U: 'a {\n+   |                                           ^^^^^^^^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:140:60\n+   |\n+LL |     struct TeeYooWhereOutlivesAyIsDebug<'a, T, U> where U: 'a + Debug {\n+   |                                                            ^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:146:65\n+   |\n+LL |     struct TeeYooWhereIsDebugOutlivesAy<'a, T, U> where U: Debug + 'a {\n+   |                                                                 ^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:152:46\n+   |\n+LL |     struct TeeOutlivesAyYooWhereIsDebug<'a, T: 'a, U> where U: Debug {\n+   |                                              ^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:158:50\n+   |\n+LL |     struct TeeYooWhereOutlivesAyBee<'a, 'b, T, U> where U: 'a + 'b {\n+   |                                                  ^^^^^^^^^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:164:67\n+   |\n+LL |     struct TeeYooWhereOutlivesAyBeeIsDebug<'a, 'b, T, U> where U: 'a + 'b + Debug {\n+   |                                                                   ^^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:170:72\n+   |\n+LL |     struct TeeYooWhereIsDebugOutlivesAyBee<'a, 'b, T, U> where U: Debug + 'a + 'b {\n+   |                                                                        ^^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:176:53\n+   |\n+LL |     struct TeeOutlivesAyBeeYooWhereIsDebug<'a, 'b, T: 'a + 'b, U> where U: Debug {\n+   |                                                     ^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:182:62\n+   |\n+LL |     struct TeeWhereOutlivesAyYooWhereIsDebug<'a, T, U> where T: 'a, U: Debug {\n+   |                                                              ^^^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:188:69\n+   |\n+LL |     struct TeeWhereOutlivesAyBeeYooWhereIsDebug<'a, 'b, T, U> where T: 'a + 'b, U: Debug {\n+   |                                                                     ^^^^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:194:32\n+   |\n+LL |     struct BeeOutlivesAy<'a, 'b: 'a> {\n+   |                                ^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:199:38\n+   |\n+LL |     struct BeeWhereOutlivesAy<'a, 'b> where 'b: 'a {\n+   |                                      ^^^^^^^^^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:204:35\n+   |\n+LL |     struct BeeOutlivesAyTee<'a, 'b: 'a, T> {\n+   |                                   ^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:209:44\n+   |\n+LL |     struct BeeWhereOutlivesAyTee<'a, 'b, T> where 'b: 'a {\n+   |                                            ^^^^^^^^^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:214:52\n+   |\n+LL |     struct BeeWhereOutlivesAyTeeWhereBee<'a, 'b, T> where 'b: 'a, T: 'b {\n+   |                                                    ^^^^^^^^^^^^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:219:54\n+   |\n+LL |     struct BeeWhereOutlivesAyTeeWhereAyBee<'a, 'b, T> where 'b: 'a, T: 'a + 'b {\n+   |                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:224:40\n+   |\n+LL |     struct BeeOutlivesAyTeeDebug<'a, 'b: 'a, T: Debug> {\n+   |                                        ^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:229:61\n+   |\n+LL |     struct BeeWhereOutlivesAyTeeWhereDebug<'a, 'b, T> where 'b: 'a, T: Debug {\n+   |                                                             ^^^^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:238:31\n+   |\n+LL |     struct TeeOutlivesAy<'a, T: 'a>(&'a T);\n+   |                               ^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:241:40\n+   |\n+LL |     struct TeeOutlivesAyIsDebug<'a, T: 'a + Debug>(&'a T);\n+   |                                        ^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:244:45\n+   |\n+LL |     struct TeeIsDebugOutlivesAy<'a, T: Debug + 'a>(&'a T);\n+   |                                             ^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:247:38\n+   |\n+LL |     struct TeeOutlivesAyBee<'a, 'b, T: 'a + 'b>(&'a &'b T);\n+   |                                      ^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:250:47\n+   |\n+LL |     struct TeeOutlivesAyBeeIsDebug<'a, 'b, T: 'a + 'b + Debug>(&'a &'b T);\n+   |                                               ^^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:253:52\n+   |\n+LL |     struct TeeIsDebugOutlivesAyBee<'a, 'b, T: Debug + 'a + 'b>(&'a &'b T);\n+   |                                                    ^^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:256:45\n+   |\n+LL |     struct TeeWhereOutlivesAy<'a, T>(&'a T) where T: 'a;\n+   |                                             ^^^^^^^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:259:61\n+   |\n+LL |     struct TeeWhereOutlivesAyIsDebug<'a, T>(&'a T) where T: 'a + Debug;\n+   |                                                             ^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:262:66\n+   |\n+LL |     struct TeeWhereIsDebugOutlivesAy<'a, T>(&'a T) where T: Debug + 'a;\n+   |                                                                  ^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:265:56\n+   |\n+LL |     struct TeeWhereOutlivesAyBee<'a, 'b, T>(&'a &'b T) where T: 'a + 'b;\n+   |                                                        ^^^^^^^^^^^^^^^^ help: remove these bounds\n \n error: outlives requirements can be inferred\n-  --> $DIR/edition-lint-infer-outlives.rs:91:42\n+  --> $DIR/edition-lint-infer-outlives.rs:268:72\n    |\n-LL | struct TeeYooOutlivesAyIsDebug<'a, T, U: 'a + Debug> {\n-   |                                          ^^^^^ help: remove this bound\n+LL |     struct TeeWhereOutlivesAyBeeIsDebug<'a, 'b, T>(&'a &'b T) where T: 'a + 'b + Debug;\n+   |                                                                        ^^^^^^^^^^ help: remove these bounds\n \n error: outlives requirements can be inferred\n-  --> $DIR/edition-lint-infer-outlives.rs:97:47\n+  --> $DIR/edition-lint-infer-outlives.rs:271:77\n    |\n-LL | struct TeeYooIsDebugOutlivesAy<'a, T, U: Debug + 'a> {\n-   |                                               ^^^^^ help: remove this bound\n+LL |     struct TeeWhereIsDebugOutlivesAyBee<'a, 'b, T>(&'a &'b T) where T: Debug + 'a + 'b;\n+   |                                                                             ^^^^^^^^^^ help: remove these bounds\n \n error: outlives requirements can be inferred\n-  --> $DIR/edition-lint-infer-outlives.rs:103:37\n+  --> $DIR/edition-lint-infer-outlives.rs:274:37\n    |\n-LL | struct TeeOutlivesAyYooIsDebug<'a, T: 'a, U: Debug> {\n+LL |     struct TeeYooOutlivesAy<'a, T, U: 'a>(T, &'a U);\n    |                                     ^^^^ help: remove this bound\n \n error: outlives requirements can be inferred\n-  --> $DIR/edition-lint-infer-outlives.rs:109:40\n+  --> $DIR/edition-lint-infer-outlives.rs:277:46\n    |\n-LL | struct TeeYooOutlivesAyBee<'a, 'b, T, U: 'a + 'b> {\n-   |                                        ^^^^^^^^^ help: remove these bounds\n+LL |     struct TeeYooOutlivesAyIsDebug<'a, T, U: 'a + Debug>(T, &'a U);\n+   |                                              ^^^^^ help: remove this bound\n \n error: outlives requirements can be inferred\n-  --> $DIR/edition-lint-infer-outlives.rs:115:49\n+  --> $DIR/edition-lint-infer-outlives.rs:280:51\n    |\n-LL | struct TeeYooOutlivesAyBeeIsDebug<'a, 'b, T, U: 'a + 'b + Debug> {\n-   |                                                 ^^^^^^^^^^ help: remove these bounds\n+LL |     struct TeeYooIsDebugOutlivesAy<'a, T, U: Debug + 'a>(T, &'a U);\n+   |                                                   ^^^^^ help: remove this bound\n \n error: outlives requirements can be inferred\n-  --> $DIR/edition-lint-infer-outlives.rs:121:54\n+  --> $DIR/edition-lint-infer-outlives.rs:283:41\n    |\n-LL | struct TeeYooIsDebugOutlivesAyBee<'a, 'b, T, U: Debug + 'a + 'b> {\n-   |                                                      ^^^^^^^^^^ help: remove these bounds\n+LL |     struct TeeOutlivesAyYooIsDebug<'a, T: 'a, U: Debug>(&'a T, U);\n+   |                                         ^^^^ help: remove this bound\n \n error: outlives requirements can be inferred\n-  --> $DIR/edition-lint-infer-outlives.rs:127:44\n+  --> $DIR/edition-lint-infer-outlives.rs:286:44\n    |\n-LL | struct TeeOutlivesAyBeeYooIsDebug<'a, 'b, T: 'a + 'b, U: Debug> {\n+LL |     struct TeeYooOutlivesAyBee<'a, 'b, T, U: 'a + 'b>(T, &'a &'b U);\n    |                                            ^^^^^^^^^ help: remove these bounds\n \n error: outlives requirements can be inferred\n-  --> $DIR/edition-lint-infer-outlives.rs:133:39\n+  --> $DIR/edition-lint-infer-outlives.rs:289:53\n    |\n-LL | struct TeeYooWhereOutlivesAy<'a, T, U> where U: 'a {\n-   |                                       ^^^^^^^^^^^^ help: remove this bound\n+LL |     struct TeeYooOutlivesAyBeeIsDebug<'a, 'b, T, U: 'a + 'b + Debug>(T, &'a &'b U);\n+   |                                                     ^^^^^^^^^^ help: remove these bounds\n \n error: outlives requirements can be inferred\n-  --> $DIR/edition-lint-infer-outlives.rs:139:56\n+  --> $DIR/edition-lint-infer-outlives.rs:292:58\n    |\n-LL | struct TeeYooWhereOutlivesAyIsDebug<'a, T, U> where U: 'a + Debug {\n-   |                                                        ^^^^^ help: remove this bound\n+LL |     struct TeeYooIsDebugOutlivesAyBee<'a, 'b, T, U: Debug + 'a + 'b>(T, &'a &'b U);\n+   |                                                          ^^^^^^^^^^ help: remove these bounds\n \n error: outlives requirements can be inferred\n-  --> $DIR/edition-lint-infer-outlives.rs:145:61\n+  --> $DIR/edition-lint-infer-outlives.rs:295:48\n    |\n-LL | struct TeeYooWhereIsDebugOutlivesAy<'a, T, U> where U: Debug + 'a {\n-   |                                                             ^^^^^ help: remove this bound\n+LL |     struct TeeOutlivesAyBeeYooIsDebug<'a, 'b, T: 'a + 'b, U: Debug>(&'a &'b T, U);\n+   |                                                ^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:298:54\n+   |\n+LL |     struct TeeYooWhereOutlivesAy<'a, T, U>(T, &'a U) where U: 'a;\n+   |                                                      ^^^^^^^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:301:70\n+   |\n+LL |     struct TeeYooWhereOutlivesAyIsDebug<'a, T, U>(T, &'a U) where U: 'a + Debug;\n+   |                                                                      ^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:304:75\n+   |\n+LL |     struct TeeYooWhereIsDebugOutlivesAy<'a, T, U>(T, &'a U) where U: Debug + 'a;\n+   |                                                                           ^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:307:46\n+   |\n+LL |     struct TeeOutlivesAyYooWhereIsDebug<'a, T: 'a, U>(&'a T, U) where U: Debug;\n+   |                                              ^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:310:65\n+   |\n+LL |     struct TeeYooWhereOutlivesAyBee<'a, 'b, T, U>(T, &'a &'b U) where U: 'a + 'b;\n+   |                                                                 ^^^^^^^^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:313:81\n+   |\n+LL |     struct TeeYooWhereOutlivesAyBeeIsDebug<'a, 'b, T, U>(T, &'a &'b U) where U: 'a + 'b + Debug;\n+   |                                                                                 ^^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:316:86\n+   |\n+LL |     struct TeeYooWhereIsDebugOutlivesAyBee<'a, 'b, T, U>(T, &'a &'b U) where U: Debug + 'a + 'b;\n+   |                                                                                      ^^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:319:53\n+   |\n+LL |     struct TeeOutlivesAyBeeYooWhereIsDebug<'a, 'b, T: 'a + 'b, U>(&'a &'b T, U) where U: Debug;\n+   |                                                     ^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:322:72\n+   |\n+LL |     struct TeeWhereOutlivesAyYooWhereIsDebug<'a, T, U>(&'a T, U) where T: 'a, U: Debug;\n+   |                                                                        ^^^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:325:75\n+   |\n+LL |     struct TeeWhereAyBeeYooWhereIsDebug<'a, 'b, T, U>(&'a &'b T, U) where T: 'a + 'b, U: Debug;\n+   |                                                                           ^^^^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:328:32\n+   |\n+LL |     struct BeeOutlivesAy<'a, 'b: 'a>(&'a &'b ());\n+   |                                ^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:331:51\n+   |\n+LL |     struct BeeWhereOutlivesAy<'a, 'b>(&'a &'b ()) where 'b: 'a;\n+   |                                                   ^^^^^^^^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:334:35\n+   |\n+LL |     struct BeeOutlivesAyTee<'a, 'b: 'a, T>(&'a &'b T);\n+   |                                   ^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:337:56\n+   |\n+LL |     struct BeeWhereOutlivesAyTee<'a, 'b, T>(&'a &'b T) where 'b: 'a;\n+   |                                                        ^^^^^^^^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:340:64\n+   |\n+LL |     struct BeeWhereOutlivesAyTeeWhereBee<'a, 'b, T>(&'a &'b T) where 'b: 'a, T: 'b;\n+   |                                                                ^^^^^^^^^^^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:343:66\n+   |\n+LL |     struct BeeWhereOutlivesAyTeeWhereAyBee<'a, 'b, T>(&'a &'b T) where 'b: 'a, T: 'a + 'b;\n+   |                                                                  ^^^^^^^^^^^^^^^^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:346:40\n+   |\n+LL |     struct BeeOutlivesAyTeeDebug<'a, 'b: 'a, T: Debug>(&'a &'b T);\n+   |                                        ^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:349:72\n+   |\n+LL |     struct BeeWhereOutlivesAyTeeWhereDebug<'a, 'b, T>(&'a &'b T) where 'b: 'a, T: Debug;\n+   |                                                                        ^^^^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:356:29\n+   |\n+LL |     enum TeeOutlivesAy<'a, T: 'a> {\n+   |                             ^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:361:38\n+   |\n+LL |     enum TeeOutlivesAyIsDebug<'a, T: 'a + Debug> {\n+   |                                      ^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:366:43\n+   |\n+LL |     enum TeeIsDebugOutlivesAy<'a, T: Debug + 'a> {\n+   |                                           ^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:372:36\n+   |\n+LL |     enum TeeOutlivesAyBee<'a, 'b, T: 'a + 'b> {\n+   |                                    ^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:378:45\n+   |\n+LL |     enum TeeOutlivesAyBeeIsDebug<'a, 'b, T: 'a + 'b + Debug> {\n+   |                                             ^^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:383:50\n+   |\n+LL |     enum TeeIsDebugOutlivesAyBee<'a, 'b, T: Debug + 'a + 'b> {\n+   |                                                  ^^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:388:35\n+   |\n+LL |     enum TeeWhereOutlivesAy<'a, T> where T: 'a {\n+   |                                   ^^^^^^^^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:394:52\n+   |\n+LL |     enum TeeWhereOutlivesAyIsDebug<'a, T> where T: 'a + Debug {\n+   |                                                    ^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:400:57\n+   |\n+LL |     enum TeeWhereIsDebugOutlivesAy<'a, T> where T: Debug + 'a {\n+   |                                                         ^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:405:42\n+   |\n+LL |     enum TeeWhereOutlivesAyBee<'a, 'b, T> where T: 'a + 'b {\n+   |                                          ^^^^^^^^^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:410:59\n+   |\n+LL |     enum TeeWhereOutlivesAyBeeIsDebug<'a, 'b, T> where T: 'a + 'b + Debug {\n+   |                                                           ^^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:416:64\n+   |\n+LL |     enum TeeWhereIsDebugOutlivesAyBee<'a, 'b, T> where T: Debug + 'a + 'b {\n+   |                                                                ^^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:422:35\n+   |\n+LL |     enum TeeYooOutlivesAy<'a, T, U: 'a> {\n+   |                                   ^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:428:44\n+   |\n+LL |     enum TeeYooOutlivesAyIsDebug<'a, T, U: 'a + Debug> {\n+   |                                            ^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:434:49\n+   |\n+LL |     enum TeeYooIsDebugOutlivesAy<'a, T, U: Debug + 'a> {\n+   |                                                 ^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:440:39\n+   |\n+LL |     enum TeeOutlivesAyYooIsDebug<'a, T: 'a, U: Debug> {\n+   |                                       ^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:446:42\n+   |\n+LL |     enum TeeYooOutlivesAyBee<'a, 'b, T, U: 'a + 'b> {\n+   |                                          ^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:452:51\n+   |\n+LL |     enum TeeYooOutlivesAyBeeIsDebug<'a, 'b, T, U: 'a + 'b + Debug> {\n+   |                                                   ^^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:458:56\n+   |\n+LL |     enum TeeYooIsDebugOutlivesAyBee<'a, 'b, T, U: Debug + 'a + 'b> {\n+   |                                                        ^^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:464:46\n+   |\n+LL |     enum TeeOutlivesAyBeeYooIsDebug<'a, 'b, T: 'a + 'b, U: Debug> {\n+   |                                              ^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:470:41\n+   |\n+LL |     enum TeeYooWhereOutlivesAy<'a, T, U> where U: 'a {\n+   |                                         ^^^^^^^^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:476:58\n+   |\n+LL |     enum TeeYooWhereOutlivesAyIsDebug<'a, T, U> where U: 'a + Debug {\n+   |                                                          ^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:482:63\n+   |\n+LL |     enum TeeYooWhereIsDebugOutlivesAy<'a, T, U> where U: Debug + 'a {\n+   |                                                               ^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:488:44\n+   |\n+LL |     enum TeeOutlivesAyYooWhereIsDebug<'a, T: 'a, U> where U: Debug {\n+   |                                            ^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:494:48\n+   |\n+LL |     enum TeeYooWhereOutlivesAyBee<'a, 'b, T, U> where U: 'a + 'b {\n+   |                                                ^^^^^^^^^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:500:65\n+   |\n+LL |     enum TeeYooWhereOutlivesAyBeeIsDebug<'a, 'b, T, U> where U: 'a + 'b + Debug {\n+   |                                                                 ^^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:506:70\n+   |\n+LL |     enum TeeYooWhereIsDebugOutlivesAyBee<'a, 'b, T, U> where U: Debug + 'a + 'b {\n+   |                                                                      ^^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:512:51\n+   |\n+LL |     enum TeeOutlivesAyBeeYooWhereIsDebug<'a, 'b, T: 'a + 'b, U> where U: Debug {\n+   |                                                   ^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:518:60\n+   |\n+LL |     enum TeeWhereOutlivesAyYooWhereIsDebug<'a, T, U> where T: 'a, U: Debug {\n+   |                                                            ^^^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:524:67\n+   |\n+LL |     enum TeeWhereOutlivesAyBeeYooWhereIsDebug<'a, 'b, T, U> where T: 'a + 'b, U: Debug {\n+   |                                                                   ^^^^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:530:30\n+   |\n+LL |     enum BeeOutlivesAy<'a, 'b: 'a> {\n+   |                              ^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:535:36\n+   |\n+LL |     enum BeeWhereOutlivesAy<'a, 'b> where 'b: 'a {\n+   |                                    ^^^^^^^^^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:540:33\n+   |\n+LL |     enum BeeOutlivesAyTee<'a, 'b: 'a, T> {\n+   |                                 ^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:546:42\n+   |\n+LL |     enum BeeWhereOutlivesAyTee<'a, 'b, T> where 'b: 'a {\n+   |                                          ^^^^^^^^^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:552:50\n+   |\n+LL |     enum BeeWhereOutlivesAyTeeWhereBee<'a, 'b, T> where 'b: 'a, T: 'b {\n+   |                                                  ^^^^^^^^^^^^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:557:52\n+   |\n+LL |     enum BeeWhereOutlivesAyTeeWhereAyBee<'a, 'b, T> where 'b: 'a, T: 'a + 'b {\n+   |                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:563:38\n+   |\n+LL |     enum BeeOutlivesAyTeeDebug<'a, 'b: 'a, T: Debug> {\n+   |                                      ^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:568:59\n+   |\n+LL |     enum BeeWhereOutlivesAyTeeWhereDebug<'a, 'b, T> where 'b: 'a, T: Debug {\n+   |                                                           ^^^^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:577:30\n+   |\n+LL |     union TeeOutlivesAy<'a, T: 'a> {\n+   |                              ^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:582:39\n+   |\n+LL |     union TeeOutlivesAyIsDebug<'a, T: 'a + Debug> {\n+   |                                       ^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:587:44\n+   |\n+LL |     union TeeIsDebugOutlivesAy<'a, T: Debug + 'a> {\n+   |                                            ^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:592:37\n+   |\n+LL |     union TeeOutlivesAyBee<'a, 'b, T: 'a + 'b> {\n+   |                                     ^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:597:46\n+   |\n+LL |     union TeeOutlivesAyBeeIsDebug<'a, 'b, T: 'a + 'b + Debug> {\n+   |                                              ^^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:602:51\n+   |\n+LL |     union TeeIsDebugOutlivesAyBee<'a, 'b, T: Debug + 'a + 'b> {\n+   |                                                   ^^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:607:36\n+   |\n+LL |     union TeeWhereOutlivesAy<'a, T> where T: 'a {\n+   |                                    ^^^^^^^^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:612:53\n+   |\n+LL |     union TeeWhereOutlivesAyIsDebug<'a, T> where T: 'a + Debug {\n+   |                                                     ^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:617:58\n+   |\n+LL |     union TeeWhereIsDebugOutlivesAy<'a, T> where T: Debug + 'a {\n+   |                                                          ^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:622:43\n+   |\n+LL |     union TeeWhereOutlivesAyBee<'a, 'b, T> where T: 'a + 'b {\n+   |                                           ^^^^^^^^^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:627:60\n+   |\n+LL |     union TeeWhereOutlivesAyBeeIsDebug<'a, 'b, T> where T: 'a + 'b + Debug {\n+   |                                                            ^^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:632:65\n+   |\n+LL |     union TeeWhereIsDebugOutlivesAyBee<'a, 'b, T> where T: Debug + 'a + 'b {\n+   |                                                                 ^^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:637:36\n+   |\n+LL |     union TeeYooOutlivesAy<'a, T, U: 'a> {\n+   |                                    ^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:643:45\n+   |\n+LL |     union TeeYooOutlivesAyIsDebug<'a, T, U: 'a + Debug> {\n+   |                                             ^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:649:50\n+   |\n+LL |     union TeeYooIsDebugOutlivesAy<'a, T, U: Debug + 'a> {\n+   |                                                  ^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:655:40\n+   |\n+LL |     union TeeOutlivesAyYooIsDebug<'a, T: 'a, U: Debug> {\n+   |                                        ^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:661:43\n+   |\n+LL |     union TeeYooOutlivesAyBee<'a, 'b, T, U: 'a + 'b> {\n+   |                                           ^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:667:52\n+   |\n+LL |     union TeeYooOutlivesAyBeeIsDebug<'a, 'b, T, U: 'a + 'b + Debug> {\n+   |                                                    ^^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:673:57\n+   |\n+LL |     union TeeYooIsDebugOutlivesAyBee<'a, 'b, T, U: Debug + 'a + 'b> {\n+   |                                                         ^^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:679:47\n+   |\n+LL |     union TeeOutlivesAyBeeYooIsDebug<'a, 'b, T: 'a + 'b, U: Debug> {\n+   |                                               ^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:685:42\n+   |\n+LL |     union TeeYooWhereOutlivesAy<'a, T, U> where U: 'a {\n+   |                                          ^^^^^^^^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:691:59\n+   |\n+LL |     union TeeYooWhereOutlivesAyIsDebug<'a, T, U> where U: 'a + Debug {\n+   |                                                           ^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:697:64\n+   |\n+LL |     union TeeYooWhereIsDebugOutlivesAy<'a, T, U> where U: Debug + 'a {\n+   |                                                                ^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:703:45\n+   |\n+LL |     union TeeOutlivesAyYooWhereIsDebug<'a, T: 'a, U> where U: Debug {\n+   |                                             ^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:709:49\n+   |\n+LL |     union TeeYooWhereOutlivesAyBee<'a, 'b, T, U> where U: 'a + 'b {\n+   |                                                 ^^^^^^^^^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:715:66\n+   |\n+LL |     union TeeYooWhereOutlivesAyBeeIsDebug<'a, 'b, T, U> where U: 'a + 'b + Debug {\n+   |                                                                  ^^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:721:71\n+   |\n+LL |     union TeeYooWhereIsDebugOutlivesAyBee<'a, 'b, T, U> where U: Debug + 'a + 'b {\n+   |                                                                       ^^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:727:52\n+   |\n+LL |     union TeeOutlivesAyBeeYooWhereIsDebug<'a, 'b, T: 'a + 'b, U> where U: Debug {\n+   |                                                    ^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:733:61\n+   |\n+LL |     union TeeWhereOutlivesAyYooWhereIsDebug<'a, T, U> where T: 'a, U: Debug {\n+   |                                                             ^^^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:739:68\n+   |\n+LL |     union TeeWhereOutlivesAyBeeYooWhereIsDebug<'a, 'b, T, U> where T: 'a + 'b, U: Debug {\n+   |                                                                    ^^^^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:745:31\n+   |\n+LL |     union BeeOutlivesAy<'a, 'b: 'a> {\n+   |                               ^^^^ help: remove this bound\n \n error: outlives requirements can be inferred\n-  --> $DIR/edition-lint-infer-outlives.rs:151:42\n+  --> $DIR/edition-lint-infer-outlives.rs:750:37\n    |\n-LL | struct TeeOutlivesAyYooWhereIsDebug<'a, T: 'a, U> where U: Debug {\n-   |                                          ^^^^ help: remove this bound\n+LL |     union BeeWhereOutlivesAy<'a, 'b> where 'b: 'a {\n+   |                                     ^^^^^^^^^^^^^ help: remove this bound\n \n error: outlives requirements can be inferred\n-  --> $DIR/edition-lint-infer-outlives.rs:157:46\n+  --> $DIR/edition-lint-infer-outlives.rs:755:34\n    |\n-LL | struct TeeYooWhereOutlivesAyBee<'a, 'b, T, U> where U: 'a + 'b {\n-   |                                              ^^^^^^^^^^^^^^^^^ help: remove these bounds\n+LL |     union BeeOutlivesAyTee<'a, 'b: 'a, T> {\n+   |                                  ^^^^ help: remove this bound\n \n error: outlives requirements can be inferred\n-  --> $DIR/edition-lint-infer-outlives.rs:163:63\n+  --> $DIR/edition-lint-infer-outlives.rs:760:43\n    |\n-LL | struct TeeYooWhereOutlivesAyBeeIsDebug<'a, 'b, T, U> where U: 'a + 'b + Debug {\n-   |                                                               ^^^^^^^^^^ help: remove these bounds\n+LL |     union BeeWhereOutlivesAyTee<'a, 'b, T> where 'b: 'a {\n+   |                                           ^^^^^^^^^^^^^ help: remove this bound\n \n error: outlives requirements can be inferred\n-  --> $DIR/edition-lint-infer-outlives.rs:169:68\n+  --> $DIR/edition-lint-infer-outlives.rs:765:51\n    |\n-LL | struct TeeYooWhereIsDebugOutlivesAyBee<'a, 'b, T, U> where U: Debug + 'a + 'b {\n-   |                                                                    ^^^^^^^^^^ help: remove these bounds\n+LL |     union BeeWhereOutlivesAyTeeWhereBee<'a, 'b, T> where 'b: 'a, T: 'b {\n+   |                                                   ^^^^^^^^^^^^^^^^^^^^ help: remove these bounds\n \n error: outlives requirements can be inferred\n-  --> $DIR/edition-lint-infer-outlives.rs:175:49\n+  --> $DIR/edition-lint-infer-outlives.rs:770:53\n    |\n-LL | struct TeeOutlivesAyBeeYooWhereIsDebug<'a, 'b, T: 'a + 'b, U> where U: Debug {\n-   |                                                 ^^^^^^^^^ help: remove these bounds\n+LL |     union BeeWhereOutlivesAyTeeWhereAyBee<'a, 'b, T> where 'b: 'a, T: 'a + 'b {\n+   |                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^ help: remove these bounds\n \n error: outlives requirements can be inferred\n-  --> $DIR/edition-lint-infer-outlives.rs:181:58\n+  --> $DIR/edition-lint-infer-outlives.rs:775:39\n    |\n-LL | struct TeeWhereOutlivesAyYooWhereIsDebug<'a, T, U> where T: 'a, U: Debug {\n-   |                                                          ^^^^^^^ help: remove this bound\n+LL |     union BeeOutlivesAyTeeDebug<'a, 'b: 'a, T: Debug> {\n+   |                                       ^^^^ help: remove this bound\n \n error: outlives requirements can be inferred\n-  --> $DIR/edition-lint-infer-outlives.rs:187:65\n+  --> $DIR/edition-lint-infer-outlives.rs:780:60\n    |\n-LL | struct TeeWhereOutlivesAyBeeYooWhereIsDebug<'a, 'b, T, U> where T: 'a + 'b, U: Debug {\n-   |                                                                 ^^^^^^^^^^^^ help: remove these bounds\n+LL |     union BeeWhereOutlivesAyTeeWhereDebug<'a, 'b, T> where 'b: 'a, T: Debug {\n+   |                                                            ^^^^^^^^ help: remove this bound\n \n-error: aborting due to 30 previous errors\n+error: aborting due to 152 previous errors\n "}]}