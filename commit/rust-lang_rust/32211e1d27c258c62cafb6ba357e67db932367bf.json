{"sha": "32211e1d27c258c62cafb6ba357e67db932367bf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyMjExZTFkMjdjMjU4YzYyY2FmYjZiYTM1N2U2N2RiOTMyMzY3YmY=", "commit": {"author": {"name": "Ulrik Sverdrup", "email": "root@localhost", "date": "2015-05-30T20:03:57Z"}, "committer": {"name": "Ulrik Sverdrup", "email": "root@localhost", "date": "2015-05-30T20:15:40Z"}, "message": "Mark Arc function get_mut and method make_unique unsafe\n\nThis is a temporary mitigation for issue #24880 which points out that\nthese functions are racy in a particular situation where weak pointers\nexist.\n\nTo mitigate this, mark the functions unsafe until this can be fixed or\nanother decision is made.\n\nThis is a breaking change to unstable API, because the new version\nrequires an `unsafe` block. Review carefully if weak pointers may race\nfor any uses of this API and consider abandoning it.\n\n[breaking-change]", "tree": {"sha": "56e895dafa8fce96d2c65a5dd55bb03f82e8dca9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/56e895dafa8fce96d2c65a5dd55bb03f82e8dca9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/32211e1d27c258c62cafb6ba357e67db932367bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/32211e1d27c258c62cafb6ba357e67db932367bf", "html_url": "https://github.com/rust-lang/rust/commit/32211e1d27c258c62cafb6ba357e67db932367bf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/32211e1d27c258c62cafb6ba357e67db932367bf/comments", "author": {"login": "invalid-email-address", "id": 148100, "node_id": "MDQ6VXNlcjE0ODEwMA==", "avatar_url": "https://avatars.githubusercontent.com/u/148100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/invalid-email-address", "html_url": "https://github.com/invalid-email-address", "followers_url": "https://api.github.com/users/invalid-email-address/followers", "following_url": "https://api.github.com/users/invalid-email-address/following{/other_user}", "gists_url": "https://api.github.com/users/invalid-email-address/gists{/gist_id}", "starred_url": "https://api.github.com/users/invalid-email-address/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/invalid-email-address/subscriptions", "organizations_url": "https://api.github.com/users/invalid-email-address/orgs", "repos_url": "https://api.github.com/users/invalid-email-address/repos", "events_url": "https://api.github.com/users/invalid-email-address/events{/privacy}", "received_events_url": "https://api.github.com/users/invalid-email-address/received_events", "type": "User", "site_admin": false}, "committer": {"login": "invalid-email-address", "id": 148100, "node_id": "MDQ6VXNlcjE0ODEwMA==", "avatar_url": "https://avatars.githubusercontent.com/u/148100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/invalid-email-address", "html_url": "https://github.com/invalid-email-address", "followers_url": "https://api.github.com/users/invalid-email-address/followers", "following_url": "https://api.github.com/users/invalid-email-address/following{/other_user}", "gists_url": "https://api.github.com/users/invalid-email-address/gists{/gist_id}", "starred_url": "https://api.github.com/users/invalid-email-address/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/invalid-email-address/subscriptions", "organizations_url": "https://api.github.com/users/invalid-email-address/orgs", "repos_url": "https://api.github.com/users/invalid-email-address/repos", "events_url": "https://api.github.com/users/invalid-email-address/events{/privacy}", "received_events_url": "https://api.github.com/users/invalid-email-address/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee1ba33c4c679e679b0fd95aaf7145e7ebc275d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee1ba33c4c679e679b0fd95aaf7145e7ebc275d4", "html_url": "https://github.com/rust-lang/rust/commit/ee1ba33c4c679e679b0fd95aaf7145e7ebc275d4"}], "stats": {"total": 91, "additions": 56, "deletions": 35}, "files": [{"sha": "593ecc72d50cd00379065dba912c00333742ef39", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 56, "deletions": 35, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/32211e1d27c258c62cafb6ba357e67db932367bf/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32211e1d27c258c62cafb6ba357e67db932367bf/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=32211e1d27c258c62cafb6ba357e67db932367bf", "patch": "@@ -250,6 +250,9 @@ pub fn strong_count<T: ?Sized>(this: &Arc<T>) -> usize { this.inner().strong.loa\n ///\n /// Returns `None` if the `Arc<T>` is not unique.\n ///\n+/// This function is marked **unsafe** because it is racy if weak pointers\n+/// are active.\n+///\n /// # Examples\n ///\n /// ```\n@@ -258,24 +261,27 @@ pub fn strong_count<T: ?Sized>(this: &Arc<T>) -> usize { this.inner().strong.loa\n /// # fn main() {\n /// use alloc::arc::{Arc, get_mut};\n ///\n+/// # unsafe {\n /// let mut x = Arc::new(3);\n /// *get_mut(&mut x).unwrap() = 4;\n /// assert_eq!(*x, 4);\n ///\n /// let _y = x.clone();\n /// assert!(get_mut(&mut x).is_none());\n /// # }\n+/// # }\n /// ```\n #[inline]\n #[unstable(feature = \"alloc\")]\n-pub fn get_mut<T: ?Sized>(this: &mut Arc<T>) -> Option<&mut T> {\n+pub unsafe fn get_mut<T: ?Sized>(this: &mut Arc<T>) -> Option<&mut T> {\n+    // FIXME(#24880) potential race with upgraded weak pointers here\n     if strong_count(this) == 1 && weak_count(this) == 0 {\n         // This unsafety is ok because we're guaranteed that the pointer\n         // returned is the *only* pointer that will ever be returned to T. Our\n         // reference count is guaranteed to be 1 at this point, and we required\n         // the Arc itself to be `mut`, so we're returning the only possible\n         // reference to the inner data.\n-        let inner = unsafe { &mut **this._ptr };\n+        let inner = &mut **this._ptr;\n         Some(&mut inner.data)\n     } else {\n         None\n@@ -332,19 +338,26 @@ impl<T: Clone> Arc<T> {\n     /// This is also referred to as a copy-on-write operation because the inner\n     /// data is cloned if the reference count is greater than one.\n     ///\n+    /// This method is marked **unsafe** because it is racy if weak pointers\n+    /// are active.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n     /// # #![feature(alloc)]\n     /// use std::sync::Arc;\n     ///\n+    /// # unsafe {\n     /// let mut five = Arc::new(5);\n     ///\n     /// let mut_five = five.make_unique();\n+    /// # }\n     /// ```\n     #[inline]\n     #[unstable(feature = \"alloc\")]\n-    pub fn make_unique(&mut self) -> &mut T {\n+    pub unsafe fn make_unique(&mut self) -> &mut T {\n+        // FIXME(#24880) potential race with upgraded weak pointers here\n+        //\n         // Note that we hold a strong reference, which also counts as a weak\n         // reference, so we only clone if there is an additional reference of\n         // either kind.\n@@ -354,7 +367,7 @@ impl<T: Clone> Arc<T> {\n         }\n         // As with `get_mut()`, the unsafety is ok because our reference was\n         // either unique to begin with, or became one upon cloning the contents.\n-        let inner = unsafe { &mut **self._ptr };\n+        let inner = &mut **self._ptr;\n         &mut inner.data\n     }\n }\n@@ -744,39 +757,43 @@ mod tests {\n \n     #[test]\n     fn test_arc_get_mut() {\n-        let mut x = Arc::new(3);\n-        *get_mut(&mut x).unwrap() = 4;\n-        assert_eq!(*x, 4);\n-        let y = x.clone();\n-        assert!(get_mut(&mut x).is_none());\n-        drop(y);\n-        assert!(get_mut(&mut x).is_some());\n-        let _w = x.downgrade();\n-        assert!(get_mut(&mut x).is_none());\n+        unsafe {\n+            let mut x = Arc::new(3);\n+            *get_mut(&mut x).unwrap() = 4;\n+            assert_eq!(*x, 4);\n+            let y = x.clone();\n+            assert!(get_mut(&mut x).is_none());\n+            drop(y);\n+            assert!(get_mut(&mut x).is_some());\n+            let _w = x.downgrade();\n+            assert!(get_mut(&mut x).is_none());\n+        }\n     }\n \n     #[test]\n     fn test_cowarc_clone_make_unique() {\n-        let mut cow0 = Arc::new(75);\n-        let mut cow1 = cow0.clone();\n-        let mut cow2 = cow1.clone();\n-\n-        assert!(75 == *cow0.make_unique());\n-        assert!(75 == *cow1.make_unique());\n-        assert!(75 == *cow2.make_unique());\n-\n-        *cow0.make_unique() += 1;\n-        *cow1.make_unique() += 2;\n-        *cow2.make_unique() += 3;\n-\n-        assert!(76 == *cow0);\n-        assert!(77 == *cow1);\n-        assert!(78 == *cow2);\n-\n-        // none should point to the same backing memory\n-        assert!(*cow0 != *cow1);\n-        assert!(*cow0 != *cow2);\n-        assert!(*cow1 != *cow2);\n+        unsafe {\n+            let mut cow0 = Arc::new(75);\n+            let mut cow1 = cow0.clone();\n+            let mut cow2 = cow1.clone();\n+\n+            assert!(75 == *cow0.make_unique());\n+            assert!(75 == *cow1.make_unique());\n+            assert!(75 == *cow2.make_unique());\n+\n+            *cow0.make_unique() += 1;\n+            *cow1.make_unique() += 2;\n+            *cow2.make_unique() += 3;\n+\n+            assert!(76 == *cow0);\n+            assert!(77 == *cow1);\n+            assert!(78 == *cow2);\n+\n+            // none should point to the same backing memory\n+            assert!(*cow0 != *cow1);\n+            assert!(*cow0 != *cow2);\n+            assert!(*cow1 != *cow2);\n+        }\n     }\n \n     #[test]\n@@ -789,7 +806,9 @@ mod tests {\n         assert!(75 == *cow1);\n         assert!(75 == *cow2);\n \n-        *cow0.make_unique() += 1;\n+        unsafe {\n+            *cow0.make_unique() += 1;\n+        }\n \n         assert!(76 == *cow0);\n         assert!(75 == *cow1);\n@@ -810,7 +829,9 @@ mod tests {\n         assert!(75 == *cow0);\n         assert!(75 == *cow1_weak.upgrade().unwrap());\n \n-        *cow0.make_unique() += 1;\n+        unsafe {\n+            *cow0.make_unique() += 1;\n+        }\n \n         assert!(76 == *cow0);\n         assert!(cow1_weak.upgrade().is_none());"}]}