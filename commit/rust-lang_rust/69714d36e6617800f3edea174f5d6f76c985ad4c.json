{"sha": "69714d36e6617800f3edea174f5d6f76c985ad4c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5NzE0ZDM2ZTY2MTc4MDBmM2VkZWExNzRmNWQ2Zjc2Yzk4NWFkNGM=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2021-04-05T15:13:50Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2021-04-05T17:19:18Z"}, "message": "Hide Binders internals more", "tree": {"sha": "e74b3e3ab442e4e2e36c3985de978ebbbccf7634", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e74b3e3ab442e4e2e36c3985de978ebbbccf7634"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/69714d36e6617800f3edea174f5d6f76c985ad4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/69714d36e6617800f3edea174f5d6f76c985ad4c", "html_url": "https://github.com/rust-lang/rust/commit/69714d36e6617800f3edea174f5d6f76c985ad4c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/69714d36e6617800f3edea174f5d6f76c985ad4c/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e9798a992b30b735f14018379e0861d2ec30647", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e9798a992b30b735f14018379e0861d2ec30647", "html_url": "https://github.com/rust-lang/rust/commit/6e9798a992b30b735f14018379e0861d2ec30647"}], "stats": {"total": 196, "additions": 108, "deletions": 88}, "files": [{"sha": "ccfe348a4222942fdcf213a1da59ce2a776756ba", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69714d36e6617800f3edea174f5d6f76c985ad4c/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69714d36e6617800f3edea174f5d6f76c985ad4c/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=69714d36e6617800f3edea174f5d6f76c985ad4c", "patch": "@@ -702,7 +702,7 @@ impl_from!(Struct, Union, Enum for Adt);\n impl Adt {\n     pub fn has_non_default_type_params(self, db: &dyn HirDatabase) -> bool {\n         let subst = db.generic_defaults(self.into());\n-        subst.iter().any(|ty| ty.value.is_unknown())\n+        subst.iter().any(|ty| ty.skip_binders().is_unknown())\n     }\n \n     /// Turns this ADT into a type. Any type parameters of the ADT will be\n@@ -1089,7 +1089,7 @@ pub struct TypeAlias {\n impl TypeAlias {\n     pub fn has_non_default_type_params(self, db: &dyn HirDatabase) -> bool {\n         let subst = db.generic_defaults(self.id.into());\n-        subst.iter().any(|ty| ty.value.is_unknown())\n+        subst.iter().any(|ty| ty.skip_binders().is_unknown())\n     }\n \n     pub fn module(self, db: &dyn HirDatabase) -> Module {"}, {"sha": "7955bf0b52feb89a82a3a71c0801cf5b2797dae3", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69714d36e6617800f3edea174f5d6f76c985ad4c/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69714d36e6617800f3edea174f5d6f76c985ad4c/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=69714d36e6617800f3edea174f5d6f76c985ad4c", "patch": "@@ -494,9 +494,9 @@ impl<'db> SemanticsImpl<'db> {\n     fn resolve_method_call_as_callable(&self, call: &ast::MethodCallExpr) -> Option<Callable> {\n         // FIXME: this erases Substs\n         let func = self.resolve_method_call(call)?;\n-        let ty = self.db.value_ty(func.into());\n+        let (ty, _) = self.db.value_ty(func.into()).into_value_and_skipped_binders();\n         let resolver = self.analyze(call.syntax()).resolver;\n-        let ty = Type::new_with_resolver(self.db, &resolver, ty.value)?;\n+        let ty = Type::new_with_resolver(self.db, &resolver, ty)?;\n         let mut res = ty.as_callable(self.db)?;\n         res.is_bound_method = true;\n         Some(res)"}, {"sha": "db278d0db23df7511fec57f9d1e6f1680f9beb5a", "filename": "crates/hir_ty/src/diagnostics/expr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/69714d36e6617800f3edea174f5d6f76c985ad4c/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69714d36e6617800f3edea174f5d6f76c985ad4c/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs?ref=69714d36e6617800f3edea174f5d6f76c985ad4c", "patch": "@@ -245,7 +245,8 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n                     Some(callee) => callee,\n                     None => return,\n                 };\n-                let sig = db.callable_item_signature(callee.into()).value;\n+                let sig =\n+                    db.callable_item_signature(callee.into()).into_value_and_skipped_binders().0;\n \n                 (sig, args)\n             }"}, {"sha": "2e178e5a81600fde3c01410c103eea7f0d05c425", "filename": "crates/hir_ty/src/display.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/69714d36e6617800f3edea174f5d6f76c985ad4c/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69714d36e6617800f3edea174f5d6f76c985ad4c/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs?ref=69714d36e6617800f3edea174f5d6f76c985ad4c", "patch": "@@ -353,7 +353,7 @@ impl HirDisplay for Ty {\n                                 .as_ref()\n                                 .map(|rpit| rpit.impl_traits[idx as usize].bounds.clone());\n                             let bounds = data.subst(parameters);\n-                            bounds.value\n+                            bounds.into_value_and_skipped_binders().0\n                         } else {\n                             Vec::new()\n                         }\n@@ -543,7 +543,7 @@ impl HirDisplay for Ty {\n                             .as_ref()\n                             .map(|rpit| rpit.impl_traits[idx as usize].bounds.clone());\n                         let bounds = data.subst(&parameters);\n-                        write_bounds_like_dyn_trait_with_prefix(\"impl\", &bounds.value, f)?;\n+                        write_bounds_like_dyn_trait_with_prefix(\"impl\", bounds.skip_binders(), f)?;\n                         // FIXME: it would maybe be good to distinguish this from the alias type (when debug printing), and to show the substitution\n                     }\n                     ImplTraitId::AsyncBlockTypeImplTrait(..) => {\n@@ -630,7 +630,7 @@ impl HirDisplay for Ty {\n                             .as_ref()\n                             .map(|rpit| rpit.impl_traits[idx as usize].bounds.clone());\n                         let bounds = data.subst(&opaque_ty.substitution);\n-                        write_bounds_like_dyn_trait_with_prefix(\"impl\", &bounds.value, f)?;\n+                        write_bounds_like_dyn_trait_with_prefix(\"impl\", bounds.skip_binders(), f)?;\n                     }\n                     ImplTraitId::AsyncBlockTypeImplTrait(..) => {\n                         write!(f, \"{{async block}}\")?;"}, {"sha": "61b5cf269af6236ddd2e7062fd51c1ecc301d000", "filename": "crates/hir_ty/src/lib.rs", "status": "modified", "additions": 11, "deletions": 33, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/69714d36e6617800f3edea174f5d6f76c985ad4c/crates%2Fhir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69714d36e6617800f3edea174f5d6f76c985ad4c/crates%2Fhir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flib.rs?ref=69714d36e6617800f3edea174f5d6f76c985ad4c", "patch": "@@ -118,49 +118,27 @@ pub fn param_idx(db: &dyn HirDatabase, id: TypeParamId) -> Option<usize> {\n }\n \n impl<T> Binders<T> {\n-    pub fn new(num_binders: usize, value: T) -> Self {\n-        Self { num_binders, value }\n-    }\n-\n     pub fn wrap_empty(value: T) -> Self\n     where\n         T: TypeWalk,\n     {\n-        Self { num_binders: 0, value: value.shift_bound_vars(DebruijnIndex::ONE) }\n-    }\n-\n-    pub fn as_ref(&self) -> Binders<&T> {\n-        Binders { num_binders: self.num_binders, value: &self.value }\n-    }\n-\n-    pub fn map<U>(self, f: impl FnOnce(T) -> U) -> Binders<U> {\n-        Binders { num_binders: self.num_binders, value: f(self.value) }\n-    }\n-\n-    pub fn filter_map<U>(self, f: impl FnOnce(T) -> Option<U>) -> Option<Binders<U>> {\n-        Some(Binders { num_binders: self.num_binders, value: f(self.value)? })\n-    }\n-\n-    pub fn skip_binders(&self) -> &T {\n-        &self.value\n-    }\n-\n-    pub fn into_value_and_skipped_binders(self) -> (T, usize) {\n-        (self.value, self.num_binders)\n+        Binders::empty(&Interner, value.shift_bound_vars(DebruijnIndex::ONE))\n     }\n }\n \n impl<T: Clone> Binders<&T> {\n     pub fn cloned(&self) -> Binders<T> {\n-        Binders { num_binders: self.num_binders, value: self.value.clone() }\n+        let (value, binders) = self.into_value_and_skipped_binders();\n+        Binders::new(binders, value.clone())\n     }\n }\n \n impl<T: TypeWalk> Binders<T> {\n     /// Substitutes all variables.\n     pub fn subst(self, subst: &Substitution) -> T {\n-        assert_eq!(subst.len(&Interner), self.num_binders);\n-        self.value.subst_bound_vars(subst)\n+        let (value, binders) = self.into_value_and_skipped_binders();\n+        assert_eq!(subst.len(&Interner), binders);\n+        value.subst_bound_vars(subst)\n     }\n }\n \n@@ -334,12 +312,12 @@ impl Ty {\n     /// If this is a `dyn Trait` type, this returns the `Trait` part.\n     fn dyn_trait_ref(&self) -> Option<&TraitRef> {\n         match self.kind(&Interner) {\n-            TyKind::Dyn(dyn_ty) => {\n-                dyn_ty.bounds.value.interned().get(0).and_then(|b| match b.skip_binders() {\n+            TyKind::Dyn(dyn_ty) => dyn_ty.bounds.skip_binders().interned().get(0).and_then(|b| {\n+                match b.skip_binders() {\n                     WhereClause::Implemented(trait_ref) => Some(trait_ref),\n                     _ => None,\n-                })\n-            }\n+                }\n+            }),\n             _ => None,\n         }\n     }\n@@ -459,7 +437,7 @@ impl Ty {\n                     ImplTraitId::AsyncBlockTypeImplTrait(..) => unreachable!(),\n                 };\n \n-                predicates.map(|it| it.value)\n+                predicates.map(|it| it.into_value_and_skipped_binders().0)\n             }\n             TyKind::Placeholder(idx) => {\n                 let id = from_placeholder_idx(db, *idx);"}, {"sha": "19465b2ed08ef16dadbee1e8f031bb4b00fe6ef0", "filename": "crates/hir_ty/src/lower.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/69714d36e6617800f3edea174f5d6f76c985ad4c/crates%2Fhir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69714d36e6617800f3edea174f5d6f76c985ad4c/crates%2Fhir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flower.rs?ref=69714d36e6617800f3edea174f5d6f76c985ad4c", "patch": "@@ -832,12 +832,15 @@ pub fn associated_type_shorthand_candidates<R>(\n \n     match res {\n         // FIXME: how to correctly handle higher-ranked bounds here?\n-        TypeNs::SelfType(impl_id) => {\n-            search(db.impl_trait(impl_id)?.value.shift_bound_vars_out(DebruijnIndex::ONE))\n-        }\n+        TypeNs::SelfType(impl_id) => search(\n+            db.impl_trait(impl_id)?\n+                .into_value_and_skipped_binders()\n+                .0\n+                .shift_bound_vars_out(DebruijnIndex::ONE),\n+        ),\n         TypeNs::GenericParam(param_id) => {\n             let predicates = db.generic_predicates_for_param(param_id);\n-            let res = predicates.iter().find_map(|pred| match &pred.value.value {\n+            let res = predicates.iter().find_map(|pred| match pred.skip_binders().skip_binders() {\n                 // FIXME: how to correctly handle higher-ranked bounds here?\n                 WhereClause::Implemented(tr) => {\n                     search(tr.clone().shift_bound_vars_out(DebruijnIndex::ONE))\n@@ -1088,8 +1091,8 @@ fn fn_sig_for_struct_constructor(db: &dyn HirDatabase, def: StructId) -> PolyFnS\n     let ctx =\n         TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n     let params = fields.iter().map(|(_, field)| ctx.lower_ty(&field.type_ref)).collect::<Vec<_>>();\n-    let ret = type_for_adt(db, def.into());\n-    Binders::new(ret.num_binders, CallableSig::from_params_and_return(params, ret.value, false))\n+    let (ret, binders) = type_for_adt(db, def.into()).into_value_and_skipped_binders();\n+    Binders::new(binders, CallableSig::from_params_and_return(params, ret, false))\n }\n \n /// Build the type of a tuple struct constructor.\n@@ -1114,8 +1117,8 @@ fn fn_sig_for_enum_variant_constructor(db: &dyn HirDatabase, def: EnumVariantId)\n     let ctx =\n         TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n     let params = fields.iter().map(|(_, field)| ctx.lower_ty(&field.type_ref)).collect::<Vec<_>>();\n-    let ret = type_for_adt(db, def.parent.into());\n-    Binders::new(ret.num_binders, CallableSig::from_params_and_return(params, ret.value, false))\n+    let (ret, binders) = type_for_adt(db, def.parent.into()).into_value_and_skipped_binders();\n+    Binders::new(binders, CallableSig::from_params_and_return(params, ret, false))\n }\n \n /// Build the type of a tuple enum variant constructor.\n@@ -1267,9 +1270,9 @@ pub(crate) fn impl_trait_query(db: &dyn HirDatabase, impl_id: ImplId) -> Option<\n     let resolver = impl_id.resolver(db.upcast());\n     let ctx =\n         TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n-    let self_ty = db.impl_self_ty(impl_id);\n+    let (self_ty, binders) = db.impl_self_ty(impl_id).into_value_and_skipped_binders();\n     let target_trait = impl_data.target_trait.as_ref()?;\n-    Some(Binders::new(self_ty.num_binders, ctx.lower_trait_ref(target_trait, Some(self_ty.value))?))\n+    Some(Binders::new(binders, ctx.lower_trait_ref(target_trait, Some(self_ty))?))\n }\n \n pub(crate) fn return_type_impl_traits("}, {"sha": "ad502280812abaea1f6428e41b8b46e9b59f57cb", "filename": "crates/hir_ty/src/method_resolution.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/69714d36e6617800f3edea174f5d6f76c985ad4c/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69714d36e6617800f3edea174f5d6f76c985ad4c/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs?ref=69714d36e6617800f3edea174f5d6f76c985ad4c", "patch": "@@ -102,11 +102,11 @@ impl TraitImpls {\n         for (_module_id, module_data) in crate_def_map.modules() {\n             for impl_id in module_data.scope.impls() {\n                 let target_trait = match db.impl_trait(impl_id) {\n-                    Some(tr) => tr.value.hir_trait_id(),\n+                    Some(tr) => tr.skip_binders().hir_trait_id(),\n                     None => continue,\n                 };\n                 let self_ty = db.impl_self_ty(impl_id);\n-                let self_ty_fp = TyFingerprint::for_impl(&self_ty.value);\n+                let self_ty_fp = TyFingerprint::for_impl(self_ty.skip_binders());\n                 impls\n                     .map\n                     .entry(target_trait)\n@@ -201,7 +201,7 @@ impl InherentImpls {\n                 }\n \n                 let self_ty = db.impl_self_ty(impl_id);\n-                if let Some(fp) = TyFingerprint::for_impl(&self_ty.value) {\n+                if let Some(fp) = TyFingerprint::for_impl(self_ty.skip_binders()) {\n                     map.entry(fp).or_default().push(impl_id);\n                 }\n             }\n@@ -774,7 +774,7 @@ fn transform_receiver_ty(\n         AssocContainerId::ModuleId(_) => unreachable!(),\n     };\n     let sig = db.callable_item_signature(function_id.into());\n-    Some(sig.value.params()[0].clone().subst_bound_vars(&substs))\n+    Some(sig.map(|s| s.params()[0].clone()).subst(&substs))\n }\n \n pub fn implements_trait("}, {"sha": "47867f77e9a955f05817d1d430c448e6c8cecf39", "filename": "crates/hir_ty/src/traits/chalk.rs", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/69714d36e6617800f3edea174f5d6f76c985ad4c/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69714d36e6617800f3edea174f5d6f76c985ad4c/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs?ref=69714d36e6617800f3edea174f5d6f76c985ad4c", "patch": "@@ -184,10 +184,15 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n                     .db\n                     .return_type_impl_traits(func)\n                     .expect(\"impl trait id without impl traits\");\n-                let data = &datas.value.impl_traits[idx as usize];\n+                let data = &datas.skip_binders().impl_traits[idx as usize];\n                 let bound = OpaqueTyDatumBound {\n                     bounds: make_binders(\n-                        data.bounds.value.iter().cloned().map(|b| b.to_chalk(self.db)).collect(),\n+                        data.bounds\n+                            .skip_binders()\n+                            .iter()\n+                            .cloned()\n+                            .map(|b| b.to_chalk(self.db))\n+                            .collect(),\n                         1,\n                     ),\n                     where_clauses: make_binders(vec![], 0),\n@@ -535,7 +540,8 @@ fn impl_def_datum(\n         .impl_trait(impl_id)\n         // ImplIds for impls where the trait ref can't be resolved should never reach Chalk\n         .expect(\"invalid impl passed to Chalk\")\n-        .value;\n+        .into_value_and_skipped_binders()\n+        .0;\n     let impl_data = db.impl_data(impl_id);\n \n     let generic_params = generics(db.upcast(), impl_id.into());\n@@ -605,18 +611,22 @@ fn type_alias_associated_ty_value(\n         _ => panic!(\"assoc ty value should be in impl\"),\n     };\n \n-    let trait_ref = db.impl_trait(impl_id).expect(\"assoc ty value should not exist\").value; // we don't return any assoc ty values if the impl'd trait can't be resolved\n+    let trait_ref = db\n+        .impl_trait(impl_id)\n+        .expect(\"assoc ty value should not exist\")\n+        .into_value_and_skipped_binders()\n+        .0; // we don't return any assoc ty values if the impl'd trait can't be resolved\n \n     let assoc_ty = db\n         .trait_data(trait_ref.hir_trait_id())\n         .associated_type_by_name(&type_alias_data.name)\n         .expect(\"assoc ty value should not exist\"); // validated when building the impl data as well\n-    let ty = db.ty(type_alias.into());\n-    let value_bound = rust_ir::AssociatedTyValueBound { ty: ty.value.to_chalk(db) };\n+    let (ty, binders) = db.ty(type_alias.into()).into_value_and_skipped_binders();\n+    let value_bound = rust_ir::AssociatedTyValueBound { ty: ty.to_chalk(db) };\n     let value = rust_ir::AssociatedTyValue {\n         impl_id: impl_id.to_chalk(db),\n         associated_ty_id: to_assoc_type_id(assoc_ty),\n-        value: make_binders(value_bound, ty.num_binders),\n+        value: make_binders(value_bound, binders),\n     };\n     Arc::new(value)\n }\n@@ -628,20 +638,15 @@ pub(crate) fn fn_def_datum_query(\n ) -> Arc<FnDefDatum> {\n     let callable_def: CallableDefId = from_chalk(db, fn_def_id);\n     let generic_params = generics(db.upcast(), callable_def.into());\n-    let sig = db.callable_item_signature(callable_def);\n+    let (sig, binders) = db.callable_item_signature(callable_def).into_value_and_skipped_binders();\n     let bound_vars = generic_params.bound_vars_subst(DebruijnIndex::INNERMOST);\n     let where_clauses = convert_where_clauses(db, callable_def.into(), &bound_vars);\n     let bound = rust_ir::FnDefDatumBound {\n         // Note: Chalk doesn't actually use this information yet as far as I am aware, but we provide it anyway\n         inputs_and_output: make_binders(\n             rust_ir::FnDefInputsAndOutputDatum {\n-                argument_types: sig\n-                    .value\n-                    .params()\n-                    .iter()\n-                    .map(|ty| ty.clone().to_chalk(db))\n-                    .collect(),\n-                return_type: sig.value.ret().clone().to_chalk(db),\n+                argument_types: sig.params().iter().map(|ty| ty.clone().to_chalk(db)).collect(),\n+                return_type: sig.ret().clone().to_chalk(db),\n             }\n             .shifted_in(&Interner),\n             0,\n@@ -650,12 +655,8 @@ pub(crate) fn fn_def_datum_query(\n     };\n     let datum = FnDefDatum {\n         id: fn_def_id,\n-        sig: chalk_ir::FnSig {\n-            abi: (),\n-            safety: chalk_ir::Safety::Safe,\n-            variadic: sig.value.is_varargs,\n-        },\n-        binders: make_binders(bound, sig.num_binders),\n+        sig: chalk_ir::FnSig { abi: (), safety: chalk_ir::Safety::Safe, variadic: sig.is_varargs },\n+        binders: make_binders(bound, binders),\n     };\n     Arc::new(datum)\n }"}, {"sha": "72458f367fa92f42b35d0755ab4dc698fd5ec099", "filename": "crates/hir_ty/src/traits/chalk/mapping.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/69714d36e6617800f3edea174f5d6f76c985ad4c/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69714d36e6617800f3edea174f5d6f76c985ad4c/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs?ref=69714d36e6617800f3edea174f5d6f76c985ad4c", "patch": "@@ -93,12 +93,13 @@ impl ToChalk for Ty {\n             TyKind::BoundVar(idx) => chalk_ir::TyKind::BoundVar(idx).intern(&Interner),\n             TyKind::InferenceVar(..) => panic!(\"uncanonicalized infer ty\"),\n             TyKind::Dyn(dyn_ty) => {\n+                let (bounds, binders) = dyn_ty.bounds.into_value_and_skipped_binders();\n                 let where_clauses = chalk_ir::QuantifiedWhereClauses::from_iter(\n                     &Interner,\n-                    dyn_ty.bounds.value.interned().iter().cloned().map(|p| p.to_chalk(db)),\n+                    bounds.interned().iter().cloned().map(|p| p.to_chalk(db)),\n                 );\n                 let bounded_ty = chalk_ir::DynTy {\n-                    bounds: make_binders(where_clauses, 1),\n+                    bounds: make_binders(where_clauses, binders),\n                     lifetime: LifetimeData::Static.intern(&Interner),\n                 };\n                 chalk_ir::TyKind::Dyn(bounded_ty).intern(&Interner)\n@@ -486,13 +487,14 @@ where\n     type Chalk = chalk_ir::Binders<T::Chalk>;\n \n     fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::Binders<T::Chalk> {\n+        let (value, binders) = self.into_value_and_skipped_binders();\n         chalk_ir::Binders::new(\n             chalk_ir::VariableKinds::from_iter(\n                 &Interner,\n                 std::iter::repeat(chalk_ir::VariableKind::Ty(chalk_ir::TyVariableKind::General))\n-                    .take(self.num_binders),\n+                    .take(binders),\n             ),\n-            self.value.to_chalk(db),\n+            value.to_chalk(db),\n         )\n     }\n \n@@ -537,7 +539,8 @@ pub(super) fn generic_predicate_to_inline_bound(\n     // An InlineBound is like a GenericPredicate, except the self type is left out.\n     // We don't have a special type for this, but Chalk does.\n     let self_ty_shifted_in = self_ty.clone().shift_bound_vars(DebruijnIndex::ONE);\n-    match &pred.value {\n+    let (pred, binders) = pred.as_ref().into_value_and_skipped_binders();\n+    match pred {\n         WhereClause::Implemented(trait_ref) => {\n             if trait_ref.self_type_parameter(&Interner) != &self_ty_shifted_in {\n                 // we can only convert predicates back to type bounds if they\n@@ -549,7 +552,7 @@ pub(super) fn generic_predicate_to_inline_bound(\n                 .map(|ty| ty.clone().to_chalk(db).cast(&Interner))\n                 .collect();\n             let trait_bound = rust_ir::TraitBound { trait_id: trait_ref.trait_id, args_no_self };\n-            Some(make_binders(rust_ir::InlineBound::TraitBound(trait_bound), pred.num_binders))\n+            Some(make_binders(rust_ir::InlineBound::TraitBound(trait_bound), binders))\n         }\n         WhereClause::AliasEq(AliasEq { alias: AliasTy::Projection(projection_ty), ty }) => {\n             if projection_ty.self_type_parameter(&Interner) != &self_ty_shifted_in {\n@@ -566,7 +569,7 @@ pub(super) fn generic_predicate_to_inline_bound(\n                 associated_ty_id: projection_ty.associated_ty_id,\n                 parameters: Vec::new(), // FIXME we don't support generic associated types yet\n             };\n-            Some(make_binders(rust_ir::InlineBound::AliasEqBound(alias_eq_bound), pred.num_binders))\n+            Some(make_binders(rust_ir::InlineBound::AliasEqBound(alias_eq_bound), binders))\n         }\n         _ => None,\n     }"}, {"sha": "0e3dd511f9d91fa872cff4cd29409e6b83f9a639", "filename": "crates/hir_ty/src/types.rs", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/69714d36e6617800f3edea174f5d6f76c985ad4c/crates%2Fhir_ty%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69714d36e6617800f3edea174f5d6f76c985ad4c/crates%2Fhir_ty%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftypes.rs?ref=69714d36e6617800f3edea174f5d6f76c985ad4c", "patch": "@@ -299,7 +299,41 @@ impl Substitution {\n #[derive(Copy, Clone, PartialEq, Eq, Debug, Hash)]\n pub struct Binders<T> {\n     pub num_binders: usize,\n-    pub value: T,\n+    value: T,\n+}\n+\n+impl<T> Binders<T> {\n+    pub fn new(num_binders: usize, value: T) -> Self {\n+        Self { num_binders, value }\n+    }\n+\n+    pub fn empty(_interner: &Interner, value: T) -> Self {\n+        Self { num_binders: 0, value }\n+    }\n+\n+    pub fn as_ref(&self) -> Binders<&T> {\n+        Binders { num_binders: self.num_binders, value: &self.value }\n+    }\n+\n+    pub fn map<U>(self, f: impl FnOnce(T) -> U) -> Binders<U> {\n+        Binders { num_binders: self.num_binders, value: f(self.value) }\n+    }\n+\n+    pub fn filter_map<U>(self, f: impl FnOnce(T) -> Option<U>) -> Option<Binders<U>> {\n+        Some(Binders { num_binders: self.num_binders, value: f(self.value)? })\n+    }\n+\n+    pub fn skip_binders(&self) -> &T {\n+        &self.value\n+    }\n+\n+    pub fn into_value_and_skipped_binders(self) -> (T, usize) {\n+        (self.value, self.num_binders)\n+    }\n+\n+    pub fn skip_binders_mut(&mut self) -> &mut T {\n+        &mut self.value\n+    }\n }\n \n /// A trait with type parameters. This includes the `Self`, so this represents a concrete type implementing the trait."}, {"sha": "b1e22da0af6e9b1428195c591a66b3df8219410a", "filename": "crates/hir_ty/src/walk.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/69714d36e6617800f3edea174f5d6f76c985ad4c/crates%2Fhir_ty%2Fsrc%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69714d36e6617800f3edea174f5d6f76c985ad4c/crates%2Fhir_ty%2Fsrc%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fwalk.rs?ref=69714d36e6617800f3edea174f5d6f76c985ad4c", "patch": "@@ -139,7 +139,7 @@ impl TypeWalk for Ty {\n                 }\n             }\n             TyKind::Dyn(dyn_ty) => {\n-                for p in dyn_ty.bounds.value.interned().iter() {\n+                for p in dyn_ty.bounds.skip_binders().interned().iter() {\n                     p.walk(f);\n                 }\n             }\n@@ -167,7 +167,7 @@ impl TypeWalk for Ty {\n                 p_ty.substitution.walk_mut_binders(f, binders);\n             }\n             TyKind::Dyn(dyn_ty) => {\n-                for p in make_mut_slice(dyn_ty.bounds.value.interned_mut()) {\n+                for p in make_mut_slice(dyn_ty.bounds.skip_binders_mut().interned_mut()) {\n                     p.walk_mut_binders(f, binders.shifted_in());\n                 }\n             }\n@@ -294,15 +294,15 @@ impl TypeWalk for Substitution {\n \n impl<T: TypeWalk> TypeWalk for Binders<T> {\n     fn walk(&self, f: &mut impl FnMut(&Ty)) {\n-        self.value.walk(f);\n+        self.skip_binders().walk(f);\n     }\n \n     fn walk_mut_binders(\n         &mut self,\n         f: &mut impl FnMut(&mut Ty, DebruijnIndex),\n         binders: DebruijnIndex,\n     ) {\n-        self.value.walk_mut_binders(f, binders.shifted_in())\n+        self.skip_binders_mut().walk_mut_binders(f, binders.shifted_in())\n     }\n }\n "}]}