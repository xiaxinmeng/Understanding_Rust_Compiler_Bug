{"sha": "3322d65addd9ec61b8c5bc055803f6549946da8b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzMjJkNjVhZGRkOWVjNjFiOGM1YmMwNTU4MDNmNjU0OTk0NmRhOGI=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-11-12T15:53:55Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-11-12T15:53:55Z"}, "message": "Merge #2223\n\n2223: Move expression lowering to hir_def r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "19436c04e20caba6646ed1828066d57378726e90", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/19436c04e20caba6646ed1828066d57378726e90"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3322d65addd9ec61b8c5bc055803f6549946da8b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdytWTCRBK7hj4Ov3rIwAAdHIIAFSXLfBCmdDMERESR5rIGXxb\nFrIfz7xI6EOrtgL3aepO1G35CB0RyAiGgOJSK1S72VaMorCDEf/upytdXVVHuLhj\nqUCRmy7FQGsKJVdfLIrOU5WEe7K4s/nMwqX+n66EeyMCjJIqR4LA49h4kEiWDihB\nRhXSP4okDfVxgsYzsY1L9unhyRQ8lO4raEv/WMwDBNjdNkEJyii5WrQ0St811EU3\nWXMrETx5xvXWunXhDYl4L6Uhmrsum2AG7Uxd/UhwbND0VzQ8paBdfbNW75ckZ6t2\nH7lzrYXLhTIMvhReUZDLNrjG4zeNhyDrJme92/5+d9GlpCSpCjkKVy1pDlJrjGY=\n=Z6h2\n-----END PGP SIGNATURE-----\n", "payload": "tree 19436c04e20caba6646ed1828066d57378726e90\nparent 2549be750e4c611a582bc0845b1da71e131f1118\nparent fe5e74e083e6d091c387ba7faa3a571eba9626ec\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1573574035 +0000\ncommitter GitHub <noreply@github.com> 1573574035 +0000\n\nMerge #2223\n\n2223: Move expression lowering to hir_def r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3322d65addd9ec61b8c5bc055803f6549946da8b", "html_url": "https://github.com/rust-lang/rust/commit/3322d65addd9ec61b8c5bc055803f6549946da8b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3322d65addd9ec61b8c5bc055803f6549946da8b/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2549be750e4c611a582bc0845b1da71e131f1118", "url": "https://api.github.com/repos/rust-lang/rust/commits/2549be750e4c611a582bc0845b1da71e131f1118", "html_url": "https://github.com/rust-lang/rust/commit/2549be750e4c611a582bc0845b1da71e131f1118"}, {"sha": "fe5e74e083e6d091c387ba7faa3a571eba9626ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/fe5e74e083e6d091c387ba7faa3a571eba9626ec", "html_url": "https://github.com/rust-lang/rust/commit/fe5e74e083e6d091c387ba7faa3a571eba9626ec"}], "stats": {"total": 1497, "additions": 765, "deletions": 732}, "files": [{"sha": "9ac811232fca4cca148d7006847c51bd0c84d29e", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3322d65addd9ec61b8c5bc055803f6549946da8b/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3322d65addd9ec61b8c5bc055803f6549946da8b/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=3322d65addd9ec61b8c5bc055803f6549946da8b", "patch": "@@ -113,10 +113,10 @@ pub trait HirDatabase: DefDatabase + AstDatabase {\n     #[salsa::invoke(crate::ty::generic_defaults_query)]\n     fn generic_defaults(&self, def: GenericDef) -> Substs;\n \n-    #[salsa::invoke(Body::body_with_source_map_query)]\n+    #[salsa::invoke(crate::expr::body_with_source_map_query)]\n     fn body_with_source_map(&self, def: DefWithBody) -> (Arc<Body>, Arc<BodySourceMap>);\n \n-    #[salsa::invoke(Body::body_query)]\n+    #[salsa::invoke(crate::expr::body_query)]\n     fn body(&self, def: DefWithBody) -> Arc<Body>;\n \n     #[salsa::invoke(crate::ty::method_resolution::CrateImplBlocks::impls_in_crate_query)]"}, {"sha": "82955fa55867fd897c36d5bc165c9262dffb7e71", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 34, "deletions": 132, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/3322d65addd9ec61b8c5bc055803f6549946da8b/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3322d65addd9ec61b8c5bc055803f6549946da8b/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=3322d65addd9ec61b8c5bc055803f6549946da8b", "patch": "@@ -1,112 +1,52 @@\n //! FIXME: write short doc here\n \n-pub(crate) mod lower;\n pub(crate) mod scope;\n pub(crate) mod validation;\n \n-use std::{ops::Index, sync::Arc};\n+use std::sync::Arc;\n \n-use ra_arena::{map::ArenaMap, Arena};\n use ra_syntax::{ast, AstPtr};\n-use rustc_hash::FxHashMap;\n \n-use crate::{db::HirDatabase, DefWithBody, Either, HasSource, Resolver, Source};\n+use crate::{db::HirDatabase, DefWithBody, HasSource, Resolver};\n \n pub use self::scope::ExprScopes;\n \n-pub use hir_def::expr::{\n-    ArithOp, Array, BinaryOp, BindingAnnotation, CmpOp, Expr, ExprId, Literal, LogicOp, MatchArm,\n-    Ordering, Pat, PatId, RecordFieldPat, RecordLitField, Statement, UnaryOp,\n+pub use hir_def::{\n+    body::{Body, BodySourceMap, ExprPtr, ExprSource, PatPtr, PatSource},\n+    expr::{\n+        ArithOp, Array, BinaryOp, BindingAnnotation, CmpOp, Expr, ExprId, Literal, LogicOp,\n+        MatchArm, Ordering, Pat, PatId, RecordFieldPat, RecordLitField, Statement, UnaryOp,\n+    },\n };\n \n-/// The body of an item (function, const etc.).\n-#[derive(Debug, Eq, PartialEq)]\n-pub struct Body {\n-    exprs: Arena<ExprId, Expr>,\n-    pats: Arena<PatId, Pat>,\n-    /// The patterns for the function's parameters. While the parameter types are\n-    /// part of the function signature, the patterns are not (they don't change\n-    /// the external type of the function).\n-    ///\n-    /// If this `Body` is for the body of a constant, this will just be\n-    /// empty.\n-    params: Vec<PatId>,\n-    /// The `ExprId` of the actual body expression.\n-    body_expr: ExprId,\n+pub(crate) fn body_with_source_map_query(\n+    db: &impl HirDatabase,\n+    def: DefWithBody,\n+) -> (Arc<Body>, Arc<BodySourceMap>) {\n+    let mut params = None;\n+\n+    let (file_id, body) = match def {\n+        DefWithBody::Function(f) => {\n+            let src = f.source(db);\n+            params = src.ast.param_list();\n+            (src.file_id, src.ast.body().map(ast::Expr::from))\n+        }\n+        DefWithBody::Const(c) => {\n+            let src = c.source(db);\n+            (src.file_id, src.ast.body())\n+        }\n+        DefWithBody::Static(s) => {\n+            let src = s.source(db);\n+            (src.file_id, src.ast.body())\n+        }\n+    };\n+    let resolver = hir_def::body::MacroResolver::new(db, def.module(db).id);\n+    let (body, source_map) = Body::new(db, resolver, file_id, params, body);\n+    (Arc::new(body), Arc::new(source_map))\n }\n \n-type ExprPtr = Either<AstPtr<ast::Expr>, AstPtr<ast::RecordField>>;\n-type ExprSource = Source<ExprPtr>;\n-\n-type PatPtr = Either<AstPtr<ast::Pat>, AstPtr<ast::SelfParam>>;\n-type PatSource = Source<PatPtr>;\n-\n-/// An item body together with the mapping from syntax nodes to HIR expression\n-/// IDs. This is needed to go from e.g. a position in a file to the HIR\n-/// expression containing it; but for type inference etc., we want to operate on\n-/// a structure that is agnostic to the actual positions of expressions in the\n-/// file, so that we don't recompute types whenever some whitespace is typed.\n-///\n-/// One complication here is that, due to macro expansion, a single `Body` might\n-/// be spread across several files. So, for each ExprId and PatId, we record\n-/// both the HirFileId and the position inside the file. However, we only store\n-/// AST -> ExprId mapping for non-macro files, as it is not clear how to handle\n-/// this properly for macros.\n-#[derive(Default, Debug, Eq, PartialEq)]\n-pub struct BodySourceMap {\n-    expr_map: FxHashMap<ExprPtr, ExprId>,\n-    expr_map_back: ArenaMap<ExprId, ExprSource>,\n-    pat_map: FxHashMap<PatPtr, PatId>,\n-    pat_map_back: ArenaMap<PatId, PatSource>,\n-    field_map: FxHashMap<(ExprId, usize), AstPtr<ast::RecordField>>,\n-}\n-\n-impl Body {\n-    pub(crate) fn body_with_source_map_query(\n-        db: &impl HirDatabase,\n-        def: DefWithBody,\n-    ) -> (Arc<Body>, Arc<BodySourceMap>) {\n-        let mut params = None;\n-\n-        let (file_id, body) = match def {\n-            DefWithBody::Function(f) => {\n-                let src = f.source(db);\n-                params = src.ast.param_list();\n-                (src.file_id, src.ast.body().map(ast::Expr::from))\n-            }\n-            DefWithBody::Const(c) => {\n-                let src = c.source(db);\n-                (src.file_id, src.ast.body())\n-            }\n-            DefWithBody::Static(s) => {\n-                let src = s.source(db);\n-                (src.file_id, src.ast.body())\n-            }\n-        };\n-\n-        let (body, source_map) = lower::lower(db, def.resolver(db), file_id, params, body);\n-        (Arc::new(body), Arc::new(source_map))\n-    }\n-\n-    pub(crate) fn body_query(db: &impl HirDatabase, def: DefWithBody) -> Arc<Body> {\n-        db.body_with_source_map(def).0\n-    }\n-\n-    pub fn params(&self) -> &[PatId] {\n-        &self.params\n-    }\n-\n-    pub fn body_expr(&self) -> ExprId {\n-        self.body_expr\n-    }\n-\n-    pub fn exprs(&self) -> impl Iterator<Item = (ExprId, &Expr)> {\n-        self.exprs.iter()\n-    }\n-\n-    pub fn pats(&self) -> impl Iterator<Item = (PatId, &Pat)> {\n-        self.pats.iter()\n-    }\n+pub(crate) fn body_query(db: &impl HirDatabase, def: DefWithBody) -> Arc<Body> {\n+    db.body_with_source_map(def).0\n }\n \n // needs arbitrary_self_types to be a method... or maybe move to the def?\n@@ -132,41 +72,3 @@ pub(crate) fn resolver_for_scope(\n     }\n     r\n }\n-\n-impl Index<ExprId> for Body {\n-    type Output = Expr;\n-\n-    fn index(&self, expr: ExprId) -> &Expr {\n-        &self.exprs[expr]\n-    }\n-}\n-\n-impl Index<PatId> for Body {\n-    type Output = Pat;\n-\n-    fn index(&self, pat: PatId) -> &Pat {\n-        &self.pats[pat]\n-    }\n-}\n-\n-impl BodySourceMap {\n-    pub(crate) fn expr_syntax(&self, expr: ExprId) -> Option<ExprSource> {\n-        self.expr_map_back.get(expr).copied()\n-    }\n-\n-    pub(crate) fn node_expr(&self, node: &ast::Expr) -> Option<ExprId> {\n-        self.expr_map.get(&Either::A(AstPtr::new(node))).cloned()\n-    }\n-\n-    pub(crate) fn pat_syntax(&self, pat: PatId) -> Option<PatSource> {\n-        self.pat_map_back.get(pat).copied()\n-    }\n-\n-    pub(crate) fn node_pat(&self, node: &ast::Pat) -> Option<PatId> {\n-        self.pat_map.get(&Either::A(AstPtr::new(node))).cloned()\n-    }\n-\n-    pub(crate) fn field_syntax(&self, expr: ExprId, field: usize) -> AstPtr<ast::RecordField> {\n-        self.field_map[&(expr, field)]\n-    }\n-}"}, {"sha": "adc68b23c5730c7cd3206bdf8b4c9297caa82235", "filename": "crates/ra_hir/src/expr/lower.rs", "status": "removed", "additions": 0, "deletions": 593, "changes": 593, "blob_url": "https://github.com/rust-lang/rust/blob/2549be750e4c611a582bc0845b1da71e131f1118/crates%2Fra_hir%2Fsrc%2Fexpr%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2549be750e4c611a582bc0845b1da71e131f1118/crates%2Fra_hir%2Fsrc%2Fexpr%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr%2Flower.rs?ref=2549be750e4c611a582bc0845b1da71e131f1118", "patch": "@@ -1,593 +0,0 @@\n-//! FIXME: write short doc here\n-\n-use hir_def::{\n-    builtin_type::{BuiltinFloat, BuiltinInt},\n-    path::GenericArgs,\n-    type_ref::TypeRef,\n-};\n-use hir_expand::{\n-    hygiene::Hygiene,\n-    name::{self, AsName, Name},\n-};\n-use ra_arena::Arena;\n-use ra_syntax::{\n-    ast::{\n-        self, ArgListOwner, ArrayExprKind, LiteralKind, LoopBodyOwner, NameOwner,\n-        TypeAscriptionOwner,\n-    },\n-    AstNode, AstPtr,\n-};\n-use test_utils::tested_by;\n-\n-use crate::{\n-    db::HirDatabase, AstId, Either, HirFileId, MacroCallLoc, MacroFileKind, Mutability, Path,\n-    Resolver, Source,\n-};\n-\n-use super::{\n-    Array, BinaryOp, BindingAnnotation, Body, BodySourceMap, Expr, ExprId, Literal, MatchArm, Pat,\n-    PatId, PatPtr, RecordFieldPat, RecordLitField, Statement,\n-};\n-\n-pub(super) fn lower(\n-    db: &impl HirDatabase,\n-    resolver: Resolver,\n-    file_id: HirFileId,\n-    params: Option<ast::ParamList>,\n-    body: Option<ast::Expr>,\n-) -> (Body, BodySourceMap) {\n-    ExprCollector {\n-        resolver,\n-        db,\n-        original_file_id: file_id,\n-        current_file_id: file_id,\n-        source_map: BodySourceMap::default(),\n-        body: Body {\n-            exprs: Arena::default(),\n-            pats: Arena::default(),\n-            params: Vec::new(),\n-            body_expr: ExprId::dummy(),\n-        },\n-    }\n-    .collect(params, body)\n-}\n-\n-struct ExprCollector<DB> {\n-    db: DB,\n-    resolver: Resolver,\n-    // Expr collector expands macros along the way. original points to the file\n-    // we started with, current points to the current macro expansion. source\n-    // maps don't support macros yet, so we only record info into source map if\n-    // current == original (see #1196)\n-    original_file_id: HirFileId,\n-    current_file_id: HirFileId,\n-\n-    body: Body,\n-    source_map: BodySourceMap,\n-}\n-\n-impl<'a, DB> ExprCollector<&'a DB>\n-where\n-    DB: HirDatabase,\n-{\n-    fn collect(\n-        mut self,\n-        param_list: Option<ast::ParamList>,\n-        body: Option<ast::Expr>,\n-    ) -> (Body, BodySourceMap) {\n-        if let Some(param_list) = param_list {\n-            if let Some(self_param) = param_list.self_param() {\n-                let ptr = AstPtr::new(&self_param);\n-                let param_pat = self.alloc_pat(\n-                    Pat::Bind {\n-                        name: name::SELF_PARAM,\n-                        mode: BindingAnnotation::Unannotated,\n-                        subpat: None,\n-                    },\n-                    Either::B(ptr),\n-                );\n-                self.body.params.push(param_pat);\n-            }\n-\n-            for param in param_list.params() {\n-                let pat = match param.pat() {\n-                    None => continue,\n-                    Some(pat) => pat,\n-                };\n-                let param_pat = self.collect_pat(pat);\n-                self.body.params.push(param_pat);\n-            }\n-        };\n-\n-        self.body.body_expr = self.collect_expr_opt(body);\n-        (self.body, self.source_map)\n-    }\n-\n-    fn alloc_expr(&mut self, expr: Expr, ptr: AstPtr<ast::Expr>) -> ExprId {\n-        let ptr = Either::A(ptr);\n-        let id = self.body.exprs.alloc(expr);\n-        if self.current_file_id == self.original_file_id {\n-            self.source_map.expr_map.insert(ptr, id);\n-        }\n-        self.source_map\n-            .expr_map_back\n-            .insert(id, Source { file_id: self.current_file_id, ast: ptr });\n-        id\n-    }\n-    // desugared exprs don't have ptr, that's wrong and should be fixed\n-    // somehow.\n-    fn alloc_expr_desugared(&mut self, expr: Expr) -> ExprId {\n-        self.body.exprs.alloc(expr)\n-    }\n-    fn alloc_expr_field_shorthand(&mut self, expr: Expr, ptr: AstPtr<ast::RecordField>) -> ExprId {\n-        let ptr = Either::B(ptr);\n-        let id = self.body.exprs.alloc(expr);\n-        if self.current_file_id == self.original_file_id {\n-            self.source_map.expr_map.insert(ptr, id);\n-        }\n-        self.source_map\n-            .expr_map_back\n-            .insert(id, Source { file_id: self.current_file_id, ast: ptr });\n-        id\n-    }\n-    fn alloc_pat(&mut self, pat: Pat, ptr: PatPtr) -> PatId {\n-        let id = self.body.pats.alloc(pat);\n-        if self.current_file_id == self.original_file_id {\n-            self.source_map.pat_map.insert(ptr, id);\n-        }\n-        self.source_map.pat_map_back.insert(id, Source { file_id: self.current_file_id, ast: ptr });\n-        id\n-    }\n-\n-    fn empty_block(&mut self) -> ExprId {\n-        let block = Expr::Block { statements: Vec::new(), tail: None };\n-        self.body.exprs.alloc(block)\n-    }\n-\n-    fn missing_expr(&mut self) -> ExprId {\n-        self.body.exprs.alloc(Expr::Missing)\n-    }\n-\n-    fn missing_pat(&mut self) -> PatId {\n-        self.body.pats.alloc(Pat::Missing)\n-    }\n-\n-    fn collect_expr(&mut self, expr: ast::Expr) -> ExprId {\n-        let syntax_ptr = AstPtr::new(&expr);\n-        match expr {\n-            ast::Expr::IfExpr(e) => {\n-                let then_branch = self.collect_block_opt(e.then_branch());\n-\n-                let else_branch = e.else_branch().map(|b| match b {\n-                    ast::ElseBranch::Block(it) => self.collect_block(it),\n-                    ast::ElseBranch::IfExpr(elif) => {\n-                        let expr: ast::Expr = ast::Expr::cast(elif.syntax().clone()).unwrap();\n-                        self.collect_expr(expr)\n-                    }\n-                });\n-\n-                let condition = match e.condition() {\n-                    None => self.missing_expr(),\n-                    Some(condition) => match condition.pat() {\n-                        None => self.collect_expr_opt(condition.expr()),\n-                        // if let -- desugar to match\n-                        Some(pat) => {\n-                            let pat = self.collect_pat(pat);\n-                            let match_expr = self.collect_expr_opt(condition.expr());\n-                            let placeholder_pat = self.missing_pat();\n-                            let arms = vec![\n-                                MatchArm { pats: vec![pat], expr: then_branch, guard: None },\n-                                MatchArm {\n-                                    pats: vec![placeholder_pat],\n-                                    expr: else_branch.unwrap_or_else(|| self.empty_block()),\n-                                    guard: None,\n-                                },\n-                            ];\n-                            return self\n-                                .alloc_expr(Expr::Match { expr: match_expr, arms }, syntax_ptr);\n-                        }\n-                    },\n-                };\n-\n-                self.alloc_expr(Expr::If { condition, then_branch, else_branch }, syntax_ptr)\n-            }\n-            ast::Expr::TryBlockExpr(e) => {\n-                let body = self.collect_block_opt(e.body());\n-                self.alloc_expr(Expr::TryBlock { body }, syntax_ptr)\n-            }\n-            ast::Expr::BlockExpr(e) => self.collect_block(e),\n-            ast::Expr::LoopExpr(e) => {\n-                let body = self.collect_block_opt(e.loop_body());\n-                self.alloc_expr(Expr::Loop { body }, syntax_ptr)\n-            }\n-            ast::Expr::WhileExpr(e) => {\n-                let body = self.collect_block_opt(e.loop_body());\n-\n-                let condition = match e.condition() {\n-                    None => self.missing_expr(),\n-                    Some(condition) => match condition.pat() {\n-                        None => self.collect_expr_opt(condition.expr()),\n-                        // if let -- desugar to match\n-                        Some(pat) => {\n-                            tested_by!(infer_while_let);\n-                            let pat = self.collect_pat(pat);\n-                            let match_expr = self.collect_expr_opt(condition.expr());\n-                            let placeholder_pat = self.missing_pat();\n-                            let break_ = self.alloc_expr_desugared(Expr::Break { expr: None });\n-                            let arms = vec![\n-                                MatchArm { pats: vec![pat], expr: body, guard: None },\n-                                MatchArm { pats: vec![placeholder_pat], expr: break_, guard: None },\n-                            ];\n-                            let match_expr =\n-                                self.alloc_expr_desugared(Expr::Match { expr: match_expr, arms });\n-                            return self.alloc_expr(Expr::Loop { body: match_expr }, syntax_ptr);\n-                        }\n-                    },\n-                };\n-\n-                self.alloc_expr(Expr::While { condition, body }, syntax_ptr)\n-            }\n-            ast::Expr::ForExpr(e) => {\n-                let iterable = self.collect_expr_opt(e.iterable());\n-                let pat = self.collect_pat_opt(e.pat());\n-                let body = self.collect_block_opt(e.loop_body());\n-                self.alloc_expr(Expr::For { iterable, pat, body }, syntax_ptr)\n-            }\n-            ast::Expr::CallExpr(e) => {\n-                let callee = self.collect_expr_opt(e.expr());\n-                let args = if let Some(arg_list) = e.arg_list() {\n-                    arg_list.args().map(|e| self.collect_expr(e)).collect()\n-                } else {\n-                    Vec::new()\n-                };\n-                self.alloc_expr(Expr::Call { callee, args }, syntax_ptr)\n-            }\n-            ast::Expr::MethodCallExpr(e) => {\n-                let receiver = self.collect_expr_opt(e.expr());\n-                let args = if let Some(arg_list) = e.arg_list() {\n-                    arg_list.args().map(|e| self.collect_expr(e)).collect()\n-                } else {\n-                    Vec::new()\n-                };\n-                let method_name = e.name_ref().map(|nr| nr.as_name()).unwrap_or_else(Name::missing);\n-                let generic_args = e.type_arg_list().and_then(GenericArgs::from_ast);\n-                self.alloc_expr(\n-                    Expr::MethodCall { receiver, method_name, args, generic_args },\n-                    syntax_ptr,\n-                )\n-            }\n-            ast::Expr::MatchExpr(e) => {\n-                let expr = self.collect_expr_opt(e.expr());\n-                let arms = if let Some(match_arm_list) = e.match_arm_list() {\n-                    match_arm_list\n-                        .arms()\n-                        .map(|arm| MatchArm {\n-                            pats: arm.pats().map(|p| self.collect_pat(p)).collect(),\n-                            expr: self.collect_expr_opt(arm.expr()),\n-                            guard: arm\n-                                .guard()\n-                                .and_then(|guard| guard.expr())\n-                                .map(|e| self.collect_expr(e)),\n-                        })\n-                        .collect()\n-                } else {\n-                    Vec::new()\n-                };\n-                self.alloc_expr(Expr::Match { expr, arms }, syntax_ptr)\n-            }\n-            ast::Expr::PathExpr(e) => {\n-                let path = e\n-                    .path()\n-                    .and_then(|path| self.parse_path(path))\n-                    .map(Expr::Path)\n-                    .unwrap_or(Expr::Missing);\n-                self.alloc_expr(path, syntax_ptr)\n-            }\n-            ast::Expr::ContinueExpr(_e) => {\n-                // FIXME: labels\n-                self.alloc_expr(Expr::Continue, syntax_ptr)\n-            }\n-            ast::Expr::BreakExpr(e) => {\n-                let expr = e.expr().map(|e| self.collect_expr(e));\n-                self.alloc_expr(Expr::Break { expr }, syntax_ptr)\n-            }\n-            ast::Expr::ParenExpr(e) => {\n-                let inner = self.collect_expr_opt(e.expr());\n-                // make the paren expr point to the inner expression as well\n-                self.source_map.expr_map.insert(Either::A(syntax_ptr), inner);\n-                inner\n-            }\n-            ast::Expr::ReturnExpr(e) => {\n-                let expr = e.expr().map(|e| self.collect_expr(e));\n-                self.alloc_expr(Expr::Return { expr }, syntax_ptr)\n-            }\n-            ast::Expr::RecordLit(e) => {\n-                let path = e.path().and_then(|path| self.parse_path(path));\n-                let mut field_ptrs = Vec::new();\n-                let record_lit = if let Some(nfl) = e.record_field_list() {\n-                    let fields = nfl\n-                        .fields()\n-                        .inspect(|field| field_ptrs.push(AstPtr::new(field)))\n-                        .map(|field| RecordLitField {\n-                            name: field\n-                                .name_ref()\n-                                .map(|nr| nr.as_name())\n-                                .unwrap_or_else(Name::missing),\n-                            expr: if let Some(e) = field.expr() {\n-                                self.collect_expr(e)\n-                            } else if let Some(nr) = field.name_ref() {\n-                                // field shorthand\n-                                self.alloc_expr_field_shorthand(\n-                                    Expr::Path(Path::from_name_ref(&nr)),\n-                                    AstPtr::new(&field),\n-                                )\n-                            } else {\n-                                self.missing_expr()\n-                            },\n-                        })\n-                        .collect();\n-                    let spread = nfl.spread().map(|s| self.collect_expr(s));\n-                    Expr::RecordLit { path, fields, spread }\n-                } else {\n-                    Expr::RecordLit { path, fields: Vec::new(), spread: None }\n-                };\n-\n-                let res = self.alloc_expr(record_lit, syntax_ptr);\n-                for (i, ptr) in field_ptrs.into_iter().enumerate() {\n-                    self.source_map.field_map.insert((res, i), ptr);\n-                }\n-                res\n-            }\n-            ast::Expr::FieldExpr(e) => {\n-                let expr = self.collect_expr_opt(e.expr());\n-                let name = match e.field_access() {\n-                    Some(kind) => kind.as_name(),\n-                    _ => Name::missing(),\n-                };\n-                self.alloc_expr(Expr::Field { expr, name }, syntax_ptr)\n-            }\n-            ast::Expr::AwaitExpr(e) => {\n-                let expr = self.collect_expr_opt(e.expr());\n-                self.alloc_expr(Expr::Await { expr }, syntax_ptr)\n-            }\n-            ast::Expr::TryExpr(e) => {\n-                let expr = self.collect_expr_opt(e.expr());\n-                self.alloc_expr(Expr::Try { expr }, syntax_ptr)\n-            }\n-            ast::Expr::CastExpr(e) => {\n-                let expr = self.collect_expr_opt(e.expr());\n-                let type_ref = TypeRef::from_ast_opt(e.type_ref());\n-                self.alloc_expr(Expr::Cast { expr, type_ref }, syntax_ptr)\n-            }\n-            ast::Expr::RefExpr(e) => {\n-                let expr = self.collect_expr_opt(e.expr());\n-                let mutability = Mutability::from_mutable(e.is_mut());\n-                self.alloc_expr(Expr::Ref { expr, mutability }, syntax_ptr)\n-            }\n-            ast::Expr::PrefixExpr(e) => {\n-                let expr = self.collect_expr_opt(e.expr());\n-                if let Some(op) = e.op_kind() {\n-                    self.alloc_expr(Expr::UnaryOp { expr, op }, syntax_ptr)\n-                } else {\n-                    self.alloc_expr(Expr::Missing, syntax_ptr)\n-                }\n-            }\n-            ast::Expr::LambdaExpr(e) => {\n-                let mut args = Vec::new();\n-                let mut arg_types = Vec::new();\n-                if let Some(pl) = e.param_list() {\n-                    for param in pl.params() {\n-                        let pat = self.collect_pat_opt(param.pat());\n-                        let type_ref = param.ascribed_type().map(TypeRef::from_ast);\n-                        args.push(pat);\n-                        arg_types.push(type_ref);\n-                    }\n-                }\n-                let body = self.collect_expr_opt(e.body());\n-                self.alloc_expr(Expr::Lambda { args, arg_types, body }, syntax_ptr)\n-            }\n-            ast::Expr::BinExpr(e) => {\n-                let lhs = self.collect_expr_opt(e.lhs());\n-                let rhs = self.collect_expr_opt(e.rhs());\n-                let op = e.op_kind().map(BinaryOp::from);\n-                self.alloc_expr(Expr::BinaryOp { lhs, rhs, op }, syntax_ptr)\n-            }\n-            ast::Expr::TupleExpr(e) => {\n-                let exprs = e.exprs().map(|expr| self.collect_expr(expr)).collect();\n-                self.alloc_expr(Expr::Tuple { exprs }, syntax_ptr)\n-            }\n-            ast::Expr::BoxExpr(e) => {\n-                let expr = self.collect_expr_opt(e.expr());\n-                self.alloc_expr(Expr::Box { expr }, syntax_ptr)\n-            }\n-\n-            ast::Expr::ArrayExpr(e) => {\n-                let kind = e.kind();\n-\n-                match kind {\n-                    ArrayExprKind::ElementList(e) => {\n-                        let exprs = e.map(|expr| self.collect_expr(expr)).collect();\n-                        self.alloc_expr(Expr::Array(Array::ElementList(exprs)), syntax_ptr)\n-                    }\n-                    ArrayExprKind::Repeat { initializer, repeat } => {\n-                        let initializer = self.collect_expr_opt(initializer);\n-                        let repeat = self.collect_expr_opt(repeat);\n-                        self.alloc_expr(\n-                            Expr::Array(Array::Repeat { initializer, repeat }),\n-                            syntax_ptr,\n-                        )\n-                    }\n-                }\n-            }\n-\n-            ast::Expr::Literal(e) => {\n-                let lit = match e.kind() {\n-                    LiteralKind::IntNumber { suffix } => {\n-                        let known_name = suffix.and_then(|it| BuiltinInt::from_suffix(&it));\n-\n-                        Literal::Int(Default::default(), known_name)\n-                    }\n-                    LiteralKind::FloatNumber { suffix } => {\n-                        let known_name = suffix.and_then(|it| BuiltinFloat::from_suffix(&it));\n-\n-                        Literal::Float(Default::default(), known_name)\n-                    }\n-                    LiteralKind::ByteString => Literal::ByteString(Default::default()),\n-                    LiteralKind::String => Literal::String(Default::default()),\n-                    LiteralKind::Byte => Literal::Int(Default::default(), Some(BuiltinInt::U8)),\n-                    LiteralKind::Bool => Literal::Bool(Default::default()),\n-                    LiteralKind::Char => Literal::Char(Default::default()),\n-                };\n-                self.alloc_expr(Expr::Literal(lit), syntax_ptr)\n-            }\n-            ast::Expr::IndexExpr(e) => {\n-                let base = self.collect_expr_opt(e.base());\n-                let index = self.collect_expr_opt(e.index());\n-                self.alloc_expr(Expr::Index { base, index }, syntax_ptr)\n-            }\n-\n-            // FIXME implement HIR for these:\n-            ast::Expr::Label(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n-            ast::Expr::RangeExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n-            ast::Expr::MacroCall(e) => {\n-                let ast_id = AstId::new(\n-                    self.current_file_id,\n-                    self.db.ast_id_map(self.current_file_id).ast_id(&e),\n-                );\n-\n-                if let Some(path) = e.path().and_then(|path| self.parse_path(path)) {\n-                    if let Some(def) = self.resolver.resolve_path_as_macro(self.db, &path) {\n-                        let call_id = self.db.intern_macro(MacroCallLoc { def: def.id, ast_id });\n-                        let file_id = call_id.as_file(MacroFileKind::Expr);\n-                        if let Some(node) = self.db.parse_or_expand(file_id) {\n-                            if let Some(expr) = ast::Expr::cast(node) {\n-                                log::debug!(\"macro expansion {:#?}\", expr.syntax());\n-                                let old_file_id =\n-                                    std::mem::replace(&mut self.current_file_id, file_id);\n-                                let id = self.collect_expr(expr);\n-                                self.current_file_id = old_file_id;\n-                                return id;\n-                            }\n-                        }\n-                    }\n-                }\n-                // FIXME: Instead of just dropping the error from expansion\n-                // report it\n-                self.alloc_expr(Expr::Missing, syntax_ptr)\n-            }\n-        }\n-    }\n-\n-    fn collect_expr_opt(&mut self, expr: Option<ast::Expr>) -> ExprId {\n-        if let Some(expr) = expr {\n-            self.collect_expr(expr)\n-        } else {\n-            self.missing_expr()\n-        }\n-    }\n-\n-    fn collect_block(&mut self, expr: ast::BlockExpr) -> ExprId {\n-        let syntax_node_ptr = AstPtr::new(&expr.clone().into());\n-        let block = match expr.block() {\n-            Some(block) => block,\n-            None => return self.alloc_expr(Expr::Missing, syntax_node_ptr),\n-        };\n-        let statements = block\n-            .statements()\n-            .map(|s| match s {\n-                ast::Stmt::LetStmt(stmt) => {\n-                    let pat = self.collect_pat_opt(stmt.pat());\n-                    let type_ref = stmt.ascribed_type().map(TypeRef::from_ast);\n-                    let initializer = stmt.initializer().map(|e| self.collect_expr(e));\n-                    Statement::Let { pat, type_ref, initializer }\n-                }\n-                ast::Stmt::ExprStmt(stmt) => Statement::Expr(self.collect_expr_opt(stmt.expr())),\n-            })\n-            .collect();\n-        let tail = block.expr().map(|e| self.collect_expr(e));\n-        self.alloc_expr(Expr::Block { statements, tail }, syntax_node_ptr)\n-    }\n-\n-    fn collect_block_opt(&mut self, expr: Option<ast::BlockExpr>) -> ExprId {\n-        if let Some(block) = expr {\n-            self.collect_block(block)\n-        } else {\n-            self.missing_expr()\n-        }\n-    }\n-\n-    fn collect_pat(&mut self, pat: ast::Pat) -> PatId {\n-        let pattern = match &pat {\n-            ast::Pat::BindPat(bp) => {\n-                let name = bp.name().map(|nr| nr.as_name()).unwrap_or_else(Name::missing);\n-                let annotation = BindingAnnotation::new(bp.is_mutable(), bp.is_ref());\n-                let subpat = bp.pat().map(|subpat| self.collect_pat(subpat));\n-                Pat::Bind { name, mode: annotation, subpat }\n-            }\n-            ast::Pat::TupleStructPat(p) => {\n-                let path = p.path().and_then(|path| self.parse_path(path));\n-                let args = p.args().map(|p| self.collect_pat(p)).collect();\n-                Pat::TupleStruct { path, args }\n-            }\n-            ast::Pat::RefPat(p) => {\n-                let pat = self.collect_pat_opt(p.pat());\n-                let mutability = Mutability::from_mutable(p.is_mut());\n-                Pat::Ref { pat, mutability }\n-            }\n-            ast::Pat::PathPat(p) => {\n-                let path = p.path().and_then(|path| self.parse_path(path));\n-                path.map(Pat::Path).unwrap_or(Pat::Missing)\n-            }\n-            ast::Pat::TuplePat(p) => {\n-                let args = p.args().map(|p| self.collect_pat(p)).collect();\n-                Pat::Tuple(args)\n-            }\n-            ast::Pat::PlaceholderPat(_) => Pat::Wild,\n-            ast::Pat::RecordPat(p) => {\n-                let path = p.path().and_then(|path| self.parse_path(path));\n-                let record_field_pat_list =\n-                    p.record_field_pat_list().expect(\"every struct should have a field list\");\n-                let mut fields: Vec<_> = record_field_pat_list\n-                    .bind_pats()\n-                    .filter_map(|bind_pat| {\n-                        let ast_pat =\n-                            ast::Pat::cast(bind_pat.syntax().clone()).expect(\"bind pat is a pat\");\n-                        let pat = self.collect_pat(ast_pat);\n-                        let name = bind_pat.name()?.as_name();\n-                        Some(RecordFieldPat { name, pat })\n-                    })\n-                    .collect();\n-                let iter = record_field_pat_list.record_field_pats().filter_map(|f| {\n-                    let ast_pat = f.pat()?;\n-                    let pat = self.collect_pat(ast_pat);\n-                    let name = f.name()?.as_name();\n-                    Some(RecordFieldPat { name, pat })\n-                });\n-                fields.extend(iter);\n-\n-                Pat::Record { path, args: fields }\n-            }\n-\n-            // FIXME: implement\n-            ast::Pat::DotDotPat(_) => Pat::Missing,\n-            ast::Pat::BoxPat(_) => Pat::Missing,\n-            ast::Pat::LiteralPat(_) => Pat::Missing,\n-            ast::Pat::SlicePat(_) | ast::Pat::RangePat(_) => Pat::Missing,\n-        };\n-        let ptr = AstPtr::new(&pat);\n-        self.alloc_pat(pattern, Either::A(ptr))\n-    }\n-\n-    fn collect_pat_opt(&mut self, pat: Option<ast::Pat>) -> PatId {\n-        if let Some(pat) = pat {\n-            self.collect_pat(pat)\n-        } else {\n-            self.missing_pat()\n-        }\n-    }\n-\n-    fn parse_path(&mut self, path: ast::Path) -> Option<Path> {\n-        let hygiene = Hygiene::new(self.db, self.current_file_id);\n-        Path::from_src(path, &hygiene)\n-    }\n-}"}, {"sha": "0f754eb9c75515c3ed8767723127102802a6da16", "filename": "crates/ra_hir/src/marks.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3322d65addd9ec61b8c5bc055803f6549946da8b/crates%2Fra_hir%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3322d65addd9ec61b8c5bc055803f6549946da8b/crates%2Fra_hir%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmarks.rs?ref=3322d65addd9ec61b8c5bc055803f6549946da8b", "patch": "@@ -5,6 +5,5 @@ test_utils::marks!(\n     type_var_cycles_resolve_as_possible\n     type_var_resolves_to_int_var\n     match_ergonomics_ref\n-    infer_while_let\n     coerce_merge_fail_fallback\n );"}, {"sha": "8863c3608739935571a5c9bb3e52cfe792112a0d", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3322d65addd9ec61b8c5bc055803f6549946da8b/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3322d65addd9ec61b8c5bc055803f6549946da8b/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=3322d65addd9ec61b8c5bc055803f6549946da8b", "patch": "@@ -222,7 +222,6 @@ mod collections {\n \n #[test]\n fn infer_while_let() {\n-    covers!(infer_while_let);\n     let (db, pos) = TestDB::with_position(\n         r#\"\n //- /main.rs\n@@ -4825,7 +4824,7 @@ fn main() {\n         @r###\"\n         ![0; 1) '6': i32\n         [64; 88) '{     ...!(); }': ()\n-        [74; 75) 'x': i32        \n+        [74; 75) 'x': i32\n     \"###\n     );\n }"}, {"sha": "ac8f8261b8ff23c4c466542a474608abd1c6ce82", "filename": "crates/ra_hir_def/src/body.rs", "status": "modified", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/3322d65addd9ec61b8c5bc055803f6549946da8b/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3322d65addd9ec61b8c5bc055803f6549946da8b/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody.rs?ref=3322d65addd9ec61b8c5bc055803f6549946da8b", "patch": "@@ -1,2 +1,144 @@\n //! FIXME: write short doc here\n mod lower;\n+\n+use std::{ops::Index, sync::Arc};\n+\n+use hir_expand::{either::Either, HirFileId, MacroDefId, Source};\n+use ra_arena::{map::ArenaMap, Arena};\n+use ra_syntax::{ast, AstPtr};\n+use rustc_hash::FxHashMap;\n+\n+use crate::{\n+    db::DefDatabase2,\n+    expr::{Expr, ExprId, Pat, PatId},\n+    nameres::CrateDefMap,\n+    path::Path,\n+    ModuleId,\n+};\n+\n+pub struct MacroResolver {\n+    crate_def_map: Arc<CrateDefMap>,\n+    module: ModuleId,\n+}\n+\n+impl MacroResolver {\n+    pub fn new(db: &impl DefDatabase2, module: ModuleId) -> MacroResolver {\n+        MacroResolver { crate_def_map: db.crate_def_map(module.krate), module }\n+    }\n+\n+    pub(crate) fn resolve_path_as_macro(\n+        &self,\n+        db: &impl DefDatabase2,\n+        path: &Path,\n+    ) -> Option<MacroDefId> {\n+        self.crate_def_map.resolve_path(db, self.module.module_id, path).0.get_macros()\n+    }\n+}\n+\n+/// The body of an item (function, const etc.).\n+#[derive(Debug, Eq, PartialEq)]\n+pub struct Body {\n+    exprs: Arena<ExprId, Expr>,\n+    pats: Arena<PatId, Pat>,\n+    /// The patterns for the function's parameters. While the parameter types are\n+    /// part of the function signature, the patterns are not (they don't change\n+    /// the external type of the function).\n+    ///\n+    /// If this `Body` is for the body of a constant, this will just be\n+    /// empty.\n+    params: Vec<PatId>,\n+    /// The `ExprId` of the actual body expression.\n+    body_expr: ExprId,\n+}\n+\n+pub type ExprPtr = Either<AstPtr<ast::Expr>, AstPtr<ast::RecordField>>;\n+pub type ExprSource = Source<ExprPtr>;\n+\n+pub type PatPtr = Either<AstPtr<ast::Pat>, AstPtr<ast::SelfParam>>;\n+pub type PatSource = Source<PatPtr>;\n+\n+/// An item body together with the mapping from syntax nodes to HIR expression\n+/// IDs. This is needed to go from e.g. a position in a file to the HIR\n+/// expression containing it; but for type inference etc., we want to operate on\n+/// a structure that is agnostic to the actual positions of expressions in the\n+/// file, so that we don't recompute types whenever some whitespace is typed.\n+///\n+/// One complication here is that, due to macro expansion, a single `Body` might\n+/// be spread across several files. So, for each ExprId and PatId, we record\n+/// both the HirFileId and the position inside the file. However, we only store\n+/// AST -> ExprId mapping for non-macro files, as it is not clear how to handle\n+/// this properly for macros.\n+#[derive(Default, Debug, Eq, PartialEq)]\n+pub struct BodySourceMap {\n+    expr_map: FxHashMap<ExprPtr, ExprId>,\n+    expr_map_back: ArenaMap<ExprId, ExprSource>,\n+    pat_map: FxHashMap<PatPtr, PatId>,\n+    pat_map_back: ArenaMap<PatId, PatSource>,\n+    field_map: FxHashMap<(ExprId, usize), AstPtr<ast::RecordField>>,\n+}\n+\n+impl Body {\n+    pub fn new(\n+        db: &impl DefDatabase2,\n+        resolver: MacroResolver,\n+        file_id: HirFileId,\n+        params: Option<ast::ParamList>,\n+        body: Option<ast::Expr>,\n+    ) -> (Body, BodySourceMap) {\n+        lower::lower(db, resolver, file_id, params, body)\n+    }\n+\n+    pub fn params(&self) -> &[PatId] {\n+        &self.params\n+    }\n+\n+    pub fn body_expr(&self) -> ExprId {\n+        self.body_expr\n+    }\n+\n+    pub fn exprs(&self) -> impl Iterator<Item = (ExprId, &Expr)> {\n+        self.exprs.iter()\n+    }\n+\n+    pub fn pats(&self) -> impl Iterator<Item = (PatId, &Pat)> {\n+        self.pats.iter()\n+    }\n+}\n+\n+impl Index<ExprId> for Body {\n+    type Output = Expr;\n+\n+    fn index(&self, expr: ExprId) -> &Expr {\n+        &self.exprs[expr]\n+    }\n+}\n+\n+impl Index<PatId> for Body {\n+    type Output = Pat;\n+\n+    fn index(&self, pat: PatId) -> &Pat {\n+        &self.pats[pat]\n+    }\n+}\n+\n+impl BodySourceMap {\n+    pub fn expr_syntax(&self, expr: ExprId) -> Option<ExprSource> {\n+        self.expr_map_back.get(expr).copied()\n+    }\n+\n+    pub fn node_expr(&self, node: &ast::Expr) -> Option<ExprId> {\n+        self.expr_map.get(&Either::A(AstPtr::new(node))).cloned()\n+    }\n+\n+    pub fn pat_syntax(&self, pat: PatId) -> Option<PatSource> {\n+        self.pat_map_back.get(pat).copied()\n+    }\n+\n+    pub fn node_pat(&self, node: &ast::Pat) -> Option<PatId> {\n+        self.pat_map.get(&Either::A(AstPtr::new(node))).cloned()\n+    }\n+\n+    pub fn field_syntax(&self, expr: ExprId, field: usize) -> AstPtr<ast::RecordField> {\n+        self.field_map[&(expr, field)]\n+    }\n+}"}, {"sha": "2aa863c9ecd228ddae8e09511622ad52085233b6", "filename": "crates/ra_hir_def/src/body/lower.rs", "status": "modified", "additions": 584, "deletions": 2, "changes": 586, "blob_url": "https://github.com/rust-lang/rust/blob/3322d65addd9ec61b8c5bc055803f6549946da8b/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3322d65addd9ec61b8c5bc055803f6549946da8b/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs?ref=3322d65addd9ec61b8c5bc055803f6549946da8b", "patch": "@@ -1,8 +1,590 @@\n //! FIXME: write short doc here\n \n-use ra_syntax::ast;\n+use hir_expand::{\n+    either::Either,\n+    hygiene::Hygiene,\n+    name::{self, AsName, Name},\n+    AstId, HirFileId, MacroCallLoc, MacroFileKind, Source,\n+};\n+use ra_arena::Arena;\n+use ra_syntax::{\n+    ast::{\n+        self, ArgListOwner, ArrayExprKind, LiteralKind, LoopBodyOwner, NameOwner,\n+        TypeAscriptionOwner,\n+    },\n+    AstNode, AstPtr,\n+};\n \n-use crate::expr::{ArithOp, BinaryOp, CmpOp, LogicOp, Ordering};\n+use crate::{\n+    body::{Body, BodySourceMap, MacroResolver, PatPtr},\n+    builtin_type::{BuiltinFloat, BuiltinInt},\n+    db::DefDatabase2,\n+    expr::{\n+        ArithOp, Array, BinaryOp, BindingAnnotation, CmpOp, Expr, ExprId, Literal, LogicOp,\n+        MatchArm, Ordering, Pat, PatId, RecordFieldPat, RecordLitField, Statement,\n+    },\n+    path::GenericArgs,\n+    path::Path,\n+    type_ref::{Mutability, TypeRef},\n+};\n+\n+pub(super) fn lower(\n+    db: &impl DefDatabase2,\n+    resolver: MacroResolver,\n+    file_id: HirFileId,\n+    params: Option<ast::ParamList>,\n+    body: Option<ast::Expr>,\n+) -> (Body, BodySourceMap) {\n+    ExprCollector {\n+        resolver,\n+        db,\n+        original_file_id: file_id,\n+        current_file_id: file_id,\n+        source_map: BodySourceMap::default(),\n+        body: Body {\n+            exprs: Arena::default(),\n+            pats: Arena::default(),\n+            params: Vec::new(),\n+            body_expr: ExprId::dummy(),\n+        },\n+    }\n+    .collect(params, body)\n+}\n+\n+struct ExprCollector<DB> {\n+    db: DB,\n+    resolver: MacroResolver,\n+    original_file_id: HirFileId,\n+    current_file_id: HirFileId,\n+\n+    body: Body,\n+    source_map: BodySourceMap,\n+}\n+\n+impl<'a, DB> ExprCollector<&'a DB>\n+where\n+    DB: DefDatabase2,\n+{\n+    fn collect(\n+        mut self,\n+        param_list: Option<ast::ParamList>,\n+        body: Option<ast::Expr>,\n+    ) -> (Body, BodySourceMap) {\n+        if let Some(param_list) = param_list {\n+            if let Some(self_param) = param_list.self_param() {\n+                let ptr = AstPtr::new(&self_param);\n+                let param_pat = self.alloc_pat(\n+                    Pat::Bind {\n+                        name: name::SELF_PARAM,\n+                        mode: BindingAnnotation::Unannotated,\n+                        subpat: None,\n+                    },\n+                    Either::B(ptr),\n+                );\n+                self.body.params.push(param_pat);\n+            }\n+\n+            for param in param_list.params() {\n+                let pat = match param.pat() {\n+                    None => continue,\n+                    Some(pat) => pat,\n+                };\n+                let param_pat = self.collect_pat(pat);\n+                self.body.params.push(param_pat);\n+            }\n+        };\n+\n+        self.body.body_expr = self.collect_expr_opt(body);\n+        (self.body, self.source_map)\n+    }\n+\n+    fn alloc_expr(&mut self, expr: Expr, ptr: AstPtr<ast::Expr>) -> ExprId {\n+        let ptr = Either::A(ptr);\n+        let id = self.body.exprs.alloc(expr);\n+        if self.current_file_id == self.original_file_id {\n+            self.source_map.expr_map.insert(ptr, id);\n+        }\n+        self.source_map\n+            .expr_map_back\n+            .insert(id, Source { file_id: self.current_file_id, ast: ptr });\n+        id\n+    }\n+    // desugared exprs don't have ptr, that's wrong and should be fixed\n+    // somehow.\n+    fn alloc_expr_desugared(&mut self, expr: Expr) -> ExprId {\n+        self.body.exprs.alloc(expr)\n+    }\n+    fn alloc_expr_field_shorthand(&mut self, expr: Expr, ptr: AstPtr<ast::RecordField>) -> ExprId {\n+        let ptr = Either::B(ptr);\n+        let id = self.body.exprs.alloc(expr);\n+        if self.current_file_id == self.original_file_id {\n+            self.source_map.expr_map.insert(ptr, id);\n+        }\n+        self.source_map\n+            .expr_map_back\n+            .insert(id, Source { file_id: self.current_file_id, ast: ptr });\n+        id\n+    }\n+    fn alloc_pat(&mut self, pat: Pat, ptr: PatPtr) -> PatId {\n+        let id = self.body.pats.alloc(pat);\n+        if self.current_file_id == self.original_file_id {\n+            self.source_map.pat_map.insert(ptr, id);\n+        }\n+        self.source_map.pat_map_back.insert(id, Source { file_id: self.current_file_id, ast: ptr });\n+        id\n+    }\n+\n+    fn empty_block(&mut self) -> ExprId {\n+        let block = Expr::Block { statements: Vec::new(), tail: None };\n+        self.body.exprs.alloc(block)\n+    }\n+\n+    fn missing_expr(&mut self) -> ExprId {\n+        self.body.exprs.alloc(Expr::Missing)\n+    }\n+\n+    fn missing_pat(&mut self) -> PatId {\n+        self.body.pats.alloc(Pat::Missing)\n+    }\n+\n+    fn collect_expr(&mut self, expr: ast::Expr) -> ExprId {\n+        let syntax_ptr = AstPtr::new(&expr);\n+        match expr {\n+            ast::Expr::IfExpr(e) => {\n+                let then_branch = self.collect_block_opt(e.then_branch());\n+\n+                let else_branch = e.else_branch().map(|b| match b {\n+                    ast::ElseBranch::Block(it) => self.collect_block(it),\n+                    ast::ElseBranch::IfExpr(elif) => {\n+                        let expr: ast::Expr = ast::Expr::cast(elif.syntax().clone()).unwrap();\n+                        self.collect_expr(expr)\n+                    }\n+                });\n+\n+                let condition = match e.condition() {\n+                    None => self.missing_expr(),\n+                    Some(condition) => match condition.pat() {\n+                        None => self.collect_expr_opt(condition.expr()),\n+                        // if let -- desugar to match\n+                        Some(pat) => {\n+                            let pat = self.collect_pat(pat);\n+                            let match_expr = self.collect_expr_opt(condition.expr());\n+                            let placeholder_pat = self.missing_pat();\n+                            let arms = vec![\n+                                MatchArm { pats: vec![pat], expr: then_branch, guard: None },\n+                                MatchArm {\n+                                    pats: vec![placeholder_pat],\n+                                    expr: else_branch.unwrap_or_else(|| self.empty_block()),\n+                                    guard: None,\n+                                },\n+                            ];\n+                            return self\n+                                .alloc_expr(Expr::Match { expr: match_expr, arms }, syntax_ptr);\n+                        }\n+                    },\n+                };\n+\n+                self.alloc_expr(Expr::If { condition, then_branch, else_branch }, syntax_ptr)\n+            }\n+            ast::Expr::TryBlockExpr(e) => {\n+                let body = self.collect_block_opt(e.body());\n+                self.alloc_expr(Expr::TryBlock { body }, syntax_ptr)\n+            }\n+            ast::Expr::BlockExpr(e) => self.collect_block(e),\n+            ast::Expr::LoopExpr(e) => {\n+                let body = self.collect_block_opt(e.loop_body());\n+                self.alloc_expr(Expr::Loop { body }, syntax_ptr)\n+            }\n+            ast::Expr::WhileExpr(e) => {\n+                let body = self.collect_block_opt(e.loop_body());\n+\n+                let condition = match e.condition() {\n+                    None => self.missing_expr(),\n+                    Some(condition) => match condition.pat() {\n+                        None => self.collect_expr_opt(condition.expr()),\n+                        // if let -- desugar to match\n+                        Some(pat) => {\n+                            let pat = self.collect_pat(pat);\n+                            let match_expr = self.collect_expr_opt(condition.expr());\n+                            let placeholder_pat = self.missing_pat();\n+                            let break_ = self.alloc_expr_desugared(Expr::Break { expr: None });\n+                            let arms = vec![\n+                                MatchArm { pats: vec![pat], expr: body, guard: None },\n+                                MatchArm { pats: vec![placeholder_pat], expr: break_, guard: None },\n+                            ];\n+                            let match_expr =\n+                                self.alloc_expr_desugared(Expr::Match { expr: match_expr, arms });\n+                            return self.alloc_expr(Expr::Loop { body: match_expr }, syntax_ptr);\n+                        }\n+                    },\n+                };\n+\n+                self.alloc_expr(Expr::While { condition, body }, syntax_ptr)\n+            }\n+            ast::Expr::ForExpr(e) => {\n+                let iterable = self.collect_expr_opt(e.iterable());\n+                let pat = self.collect_pat_opt(e.pat());\n+                let body = self.collect_block_opt(e.loop_body());\n+                self.alloc_expr(Expr::For { iterable, pat, body }, syntax_ptr)\n+            }\n+            ast::Expr::CallExpr(e) => {\n+                let callee = self.collect_expr_opt(e.expr());\n+                let args = if let Some(arg_list) = e.arg_list() {\n+                    arg_list.args().map(|e| self.collect_expr(e)).collect()\n+                } else {\n+                    Vec::new()\n+                };\n+                self.alloc_expr(Expr::Call { callee, args }, syntax_ptr)\n+            }\n+            ast::Expr::MethodCallExpr(e) => {\n+                let receiver = self.collect_expr_opt(e.expr());\n+                let args = if let Some(arg_list) = e.arg_list() {\n+                    arg_list.args().map(|e| self.collect_expr(e)).collect()\n+                } else {\n+                    Vec::new()\n+                };\n+                let method_name = e.name_ref().map(|nr| nr.as_name()).unwrap_or_else(Name::missing);\n+                let generic_args = e.type_arg_list().and_then(GenericArgs::from_ast);\n+                self.alloc_expr(\n+                    Expr::MethodCall { receiver, method_name, args, generic_args },\n+                    syntax_ptr,\n+                )\n+            }\n+            ast::Expr::MatchExpr(e) => {\n+                let expr = self.collect_expr_opt(e.expr());\n+                let arms = if let Some(match_arm_list) = e.match_arm_list() {\n+                    match_arm_list\n+                        .arms()\n+                        .map(|arm| MatchArm {\n+                            pats: arm.pats().map(|p| self.collect_pat(p)).collect(),\n+                            expr: self.collect_expr_opt(arm.expr()),\n+                            guard: arm\n+                                .guard()\n+                                .and_then(|guard| guard.expr())\n+                                .map(|e| self.collect_expr(e)),\n+                        })\n+                        .collect()\n+                } else {\n+                    Vec::new()\n+                };\n+                self.alloc_expr(Expr::Match { expr, arms }, syntax_ptr)\n+            }\n+            ast::Expr::PathExpr(e) => {\n+                let path = e\n+                    .path()\n+                    .and_then(|path| self.parse_path(path))\n+                    .map(Expr::Path)\n+                    .unwrap_or(Expr::Missing);\n+                self.alloc_expr(path, syntax_ptr)\n+            }\n+            ast::Expr::ContinueExpr(_e) => {\n+                // FIXME: labels\n+                self.alloc_expr(Expr::Continue, syntax_ptr)\n+            }\n+            ast::Expr::BreakExpr(e) => {\n+                let expr = e.expr().map(|e| self.collect_expr(e));\n+                self.alloc_expr(Expr::Break { expr }, syntax_ptr)\n+            }\n+            ast::Expr::ParenExpr(e) => {\n+                let inner = self.collect_expr_opt(e.expr());\n+                // make the paren expr point to the inner expression as well\n+                self.source_map.expr_map.insert(Either::A(syntax_ptr), inner);\n+                inner\n+            }\n+            ast::Expr::ReturnExpr(e) => {\n+                let expr = e.expr().map(|e| self.collect_expr(e));\n+                self.alloc_expr(Expr::Return { expr }, syntax_ptr)\n+            }\n+            ast::Expr::RecordLit(e) => {\n+                let path = e.path().and_then(|path| self.parse_path(path));\n+                let mut field_ptrs = Vec::new();\n+                let record_lit = if let Some(nfl) = e.record_field_list() {\n+                    let fields = nfl\n+                        .fields()\n+                        .inspect(|field| field_ptrs.push(AstPtr::new(field)))\n+                        .map(|field| RecordLitField {\n+                            name: field\n+                                .name_ref()\n+                                .map(|nr| nr.as_name())\n+                                .unwrap_or_else(Name::missing),\n+                            expr: if let Some(e) = field.expr() {\n+                                self.collect_expr(e)\n+                            } else if let Some(nr) = field.name_ref() {\n+                                // field shorthand\n+                                self.alloc_expr_field_shorthand(\n+                                    Expr::Path(Path::from_name_ref(&nr)),\n+                                    AstPtr::new(&field),\n+                                )\n+                            } else {\n+                                self.missing_expr()\n+                            },\n+                        })\n+                        .collect();\n+                    let spread = nfl.spread().map(|s| self.collect_expr(s));\n+                    Expr::RecordLit { path, fields, spread }\n+                } else {\n+                    Expr::RecordLit { path, fields: Vec::new(), spread: None }\n+                };\n+\n+                let res = self.alloc_expr(record_lit, syntax_ptr);\n+                for (i, ptr) in field_ptrs.into_iter().enumerate() {\n+                    self.source_map.field_map.insert((res, i), ptr);\n+                }\n+                res\n+            }\n+            ast::Expr::FieldExpr(e) => {\n+                let expr = self.collect_expr_opt(e.expr());\n+                let name = match e.field_access() {\n+                    Some(kind) => kind.as_name(),\n+                    _ => Name::missing(),\n+                };\n+                self.alloc_expr(Expr::Field { expr, name }, syntax_ptr)\n+            }\n+            ast::Expr::AwaitExpr(e) => {\n+                let expr = self.collect_expr_opt(e.expr());\n+                self.alloc_expr(Expr::Await { expr }, syntax_ptr)\n+            }\n+            ast::Expr::TryExpr(e) => {\n+                let expr = self.collect_expr_opt(e.expr());\n+                self.alloc_expr(Expr::Try { expr }, syntax_ptr)\n+            }\n+            ast::Expr::CastExpr(e) => {\n+                let expr = self.collect_expr_opt(e.expr());\n+                let type_ref = TypeRef::from_ast_opt(e.type_ref());\n+                self.alloc_expr(Expr::Cast { expr, type_ref }, syntax_ptr)\n+            }\n+            ast::Expr::RefExpr(e) => {\n+                let expr = self.collect_expr_opt(e.expr());\n+                let mutability = Mutability::from_mutable(e.is_mut());\n+                self.alloc_expr(Expr::Ref { expr, mutability }, syntax_ptr)\n+            }\n+            ast::Expr::PrefixExpr(e) => {\n+                let expr = self.collect_expr_opt(e.expr());\n+                if let Some(op) = e.op_kind() {\n+                    self.alloc_expr(Expr::UnaryOp { expr, op }, syntax_ptr)\n+                } else {\n+                    self.alloc_expr(Expr::Missing, syntax_ptr)\n+                }\n+            }\n+            ast::Expr::LambdaExpr(e) => {\n+                let mut args = Vec::new();\n+                let mut arg_types = Vec::new();\n+                if let Some(pl) = e.param_list() {\n+                    for param in pl.params() {\n+                        let pat = self.collect_pat_opt(param.pat());\n+                        let type_ref = param.ascribed_type().map(TypeRef::from_ast);\n+                        args.push(pat);\n+                        arg_types.push(type_ref);\n+                    }\n+                }\n+                let body = self.collect_expr_opt(e.body());\n+                self.alloc_expr(Expr::Lambda { args, arg_types, body }, syntax_ptr)\n+            }\n+            ast::Expr::BinExpr(e) => {\n+                let lhs = self.collect_expr_opt(e.lhs());\n+                let rhs = self.collect_expr_opt(e.rhs());\n+                let op = e.op_kind().map(BinaryOp::from);\n+                self.alloc_expr(Expr::BinaryOp { lhs, rhs, op }, syntax_ptr)\n+            }\n+            ast::Expr::TupleExpr(e) => {\n+                let exprs = e.exprs().map(|expr| self.collect_expr(expr)).collect();\n+                self.alloc_expr(Expr::Tuple { exprs }, syntax_ptr)\n+            }\n+            ast::Expr::BoxExpr(e) => {\n+                let expr = self.collect_expr_opt(e.expr());\n+                self.alloc_expr(Expr::Box { expr }, syntax_ptr)\n+            }\n+\n+            ast::Expr::ArrayExpr(e) => {\n+                let kind = e.kind();\n+\n+                match kind {\n+                    ArrayExprKind::ElementList(e) => {\n+                        let exprs = e.map(|expr| self.collect_expr(expr)).collect();\n+                        self.alloc_expr(Expr::Array(Array::ElementList(exprs)), syntax_ptr)\n+                    }\n+                    ArrayExprKind::Repeat { initializer, repeat } => {\n+                        let initializer = self.collect_expr_opt(initializer);\n+                        let repeat = self.collect_expr_opt(repeat);\n+                        self.alloc_expr(\n+                            Expr::Array(Array::Repeat { initializer, repeat }),\n+                            syntax_ptr,\n+                        )\n+                    }\n+                }\n+            }\n+\n+            ast::Expr::Literal(e) => {\n+                let lit = match e.kind() {\n+                    LiteralKind::IntNumber { suffix } => {\n+                        let known_name = suffix.and_then(|it| BuiltinInt::from_suffix(&it));\n+\n+                        Literal::Int(Default::default(), known_name)\n+                    }\n+                    LiteralKind::FloatNumber { suffix } => {\n+                        let known_name = suffix.and_then(|it| BuiltinFloat::from_suffix(&it));\n+\n+                        Literal::Float(Default::default(), known_name)\n+                    }\n+                    LiteralKind::ByteString => Literal::ByteString(Default::default()),\n+                    LiteralKind::String => Literal::String(Default::default()),\n+                    LiteralKind::Byte => Literal::Int(Default::default(), Some(BuiltinInt::U8)),\n+                    LiteralKind::Bool => Literal::Bool(Default::default()),\n+                    LiteralKind::Char => Literal::Char(Default::default()),\n+                };\n+                self.alloc_expr(Expr::Literal(lit), syntax_ptr)\n+            }\n+            ast::Expr::IndexExpr(e) => {\n+                let base = self.collect_expr_opt(e.base());\n+                let index = self.collect_expr_opt(e.index());\n+                self.alloc_expr(Expr::Index { base, index }, syntax_ptr)\n+            }\n+\n+            // FIXME implement HIR for these:\n+            ast::Expr::Label(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n+            ast::Expr::RangeExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n+            ast::Expr::MacroCall(e) => {\n+                let ast_id = AstId::new(\n+                    self.current_file_id,\n+                    self.db.ast_id_map(self.current_file_id).ast_id(&e),\n+                );\n+\n+                if let Some(path) = e.path().and_then(|path| self.parse_path(path)) {\n+                    if let Some(def) = self.resolver.resolve_path_as_macro(self.db, &path) {\n+                        let call_id = self.db.intern_macro(MacroCallLoc { def, ast_id });\n+                        let file_id = call_id.as_file(MacroFileKind::Expr);\n+                        if let Some(node) = self.db.parse_or_expand(file_id) {\n+                            if let Some(expr) = ast::Expr::cast(node) {\n+                                log::debug!(\"macro expansion {:#?}\", expr.syntax());\n+                                let old_file_id =\n+                                    std::mem::replace(&mut self.current_file_id, file_id);\n+                                let id = self.collect_expr(expr);\n+                                self.current_file_id = old_file_id;\n+                                return id;\n+                            }\n+                        }\n+                    }\n+                }\n+                // FIXME: Instead of just dropping the error from expansion\n+                // report it\n+                self.alloc_expr(Expr::Missing, syntax_ptr)\n+            }\n+        }\n+    }\n+\n+    fn collect_expr_opt(&mut self, expr: Option<ast::Expr>) -> ExprId {\n+        if let Some(expr) = expr {\n+            self.collect_expr(expr)\n+        } else {\n+            self.missing_expr()\n+        }\n+    }\n+\n+    fn collect_block(&mut self, expr: ast::BlockExpr) -> ExprId {\n+        let syntax_node_ptr = AstPtr::new(&expr.clone().into());\n+        let block = match expr.block() {\n+            Some(block) => block,\n+            None => return self.alloc_expr(Expr::Missing, syntax_node_ptr),\n+        };\n+        let statements = block\n+            .statements()\n+            .map(|s| match s {\n+                ast::Stmt::LetStmt(stmt) => {\n+                    let pat = self.collect_pat_opt(stmt.pat());\n+                    let type_ref = stmt.ascribed_type().map(TypeRef::from_ast);\n+                    let initializer = stmt.initializer().map(|e| self.collect_expr(e));\n+                    Statement::Let { pat, type_ref, initializer }\n+                }\n+                ast::Stmt::ExprStmt(stmt) => Statement::Expr(self.collect_expr_opt(stmt.expr())),\n+            })\n+            .collect();\n+        let tail = block.expr().map(|e| self.collect_expr(e));\n+        self.alloc_expr(Expr::Block { statements, tail }, syntax_node_ptr)\n+    }\n+\n+    fn collect_block_opt(&mut self, expr: Option<ast::BlockExpr>) -> ExprId {\n+        if let Some(block) = expr {\n+            self.collect_block(block)\n+        } else {\n+            self.missing_expr()\n+        }\n+    }\n+\n+    fn collect_pat(&mut self, pat: ast::Pat) -> PatId {\n+        let pattern = match &pat {\n+            ast::Pat::BindPat(bp) => {\n+                let name = bp.name().map(|nr| nr.as_name()).unwrap_or_else(Name::missing);\n+                let annotation = BindingAnnotation::new(bp.is_mutable(), bp.is_ref());\n+                let subpat = bp.pat().map(|subpat| self.collect_pat(subpat));\n+                Pat::Bind { name, mode: annotation, subpat }\n+            }\n+            ast::Pat::TupleStructPat(p) => {\n+                let path = p.path().and_then(|path| self.parse_path(path));\n+                let args = p.args().map(|p| self.collect_pat(p)).collect();\n+                Pat::TupleStruct { path, args }\n+            }\n+            ast::Pat::RefPat(p) => {\n+                let pat = self.collect_pat_opt(p.pat());\n+                let mutability = Mutability::from_mutable(p.is_mut());\n+                Pat::Ref { pat, mutability }\n+            }\n+            ast::Pat::PathPat(p) => {\n+                let path = p.path().and_then(|path| self.parse_path(path));\n+                path.map(Pat::Path).unwrap_or(Pat::Missing)\n+            }\n+            ast::Pat::TuplePat(p) => {\n+                let args = p.args().map(|p| self.collect_pat(p)).collect();\n+                Pat::Tuple(args)\n+            }\n+            ast::Pat::PlaceholderPat(_) => Pat::Wild,\n+            ast::Pat::RecordPat(p) => {\n+                let path = p.path().and_then(|path| self.parse_path(path));\n+                let record_field_pat_list =\n+                    p.record_field_pat_list().expect(\"every struct should have a field list\");\n+                let mut fields: Vec<_> = record_field_pat_list\n+                    .bind_pats()\n+                    .filter_map(|bind_pat| {\n+                        let ast_pat =\n+                            ast::Pat::cast(bind_pat.syntax().clone()).expect(\"bind pat is a pat\");\n+                        let pat = self.collect_pat(ast_pat);\n+                        let name = bind_pat.name()?.as_name();\n+                        Some(RecordFieldPat { name, pat })\n+                    })\n+                    .collect();\n+                let iter = record_field_pat_list.record_field_pats().filter_map(|f| {\n+                    let ast_pat = f.pat()?;\n+                    let pat = self.collect_pat(ast_pat);\n+                    let name = f.name()?.as_name();\n+                    Some(RecordFieldPat { name, pat })\n+                });\n+                fields.extend(iter);\n+\n+                Pat::Record { path, args: fields }\n+            }\n+\n+            // FIXME: implement\n+            ast::Pat::DotDotPat(_) => Pat::Missing,\n+            ast::Pat::BoxPat(_) => Pat::Missing,\n+            ast::Pat::LiteralPat(_) => Pat::Missing,\n+            ast::Pat::SlicePat(_) | ast::Pat::RangePat(_) => Pat::Missing,\n+        };\n+        let ptr = AstPtr::new(&pat);\n+        self.alloc_pat(pattern, Either::A(ptr))\n+    }\n+\n+    fn collect_pat_opt(&mut self, pat: Option<ast::Pat>) -> PatId {\n+        if let Some(pat) = pat {\n+            self.collect_pat(pat)\n+        } else {\n+            self.missing_pat()\n+        }\n+    }\n+\n+    fn parse_path(&mut self, path: ast::Path) -> Option<Path> {\n+        let hygiene = Hygiene::new(self.db, self.current_file_id);\n+        Path::from_src(path, &hygiene)\n+    }\n+}\n \n impl From<ast::BinOp> for BinaryOp {\n     fn from(ast_op: ast::BinOp) -> Self {"}, {"sha": "04c1d8f69b8651d41f511c241fcfd2fcd909d12d", "filename": "crates/ra_hir_def/src/expr.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3322d65addd9ec61b8c5bc055803f6549946da8b/crates%2Fra_hir_def%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3322d65addd9ec61b8c5bc055803f6549946da8b/crates%2Fra_hir_def%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fexpr.rs?ref=3322d65addd9ec61b8c5bc055803f6549946da8b", "patch": "@@ -9,6 +9,8 @@\n //! 3. Unresolved. Paths are stored as sequences of names, and not as defs the\n //!    names refer to.\n //! 4. Desugared. There's no `if let`.\n+//!\n+//! See also a neighboring `body` module.\n \n use hir_expand::name::Name;\n use ra_arena::{impl_arena_id, RawId};"}]}