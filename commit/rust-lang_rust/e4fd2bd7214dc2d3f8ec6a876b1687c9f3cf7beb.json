{"sha": "e4fd2bd7214dc2d3f8ec6a876b1687c9f3cf7beb", "node_id": "C_kwDOAAsO6NoAKGU0ZmQyYmQ3MjE0ZGMyZDNmOGVjNmE4NzZiMTY4N2M5ZjNjZjdiZWI", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-08-15T09:36:21Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-08-21T10:54:26Z"}, "message": "Refactor cost computation as a visitor.", "tree": {"sha": "5b18825a99014ada0a3d9b9605a288d7bf03fcb3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b18825a99014ada0a3d9b9605a288d7bf03fcb3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e4fd2bd7214dc2d3f8ec6a876b1687c9f3cf7beb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e4fd2bd7214dc2d3f8ec6a876b1687c9f3cf7beb", "html_url": "https://github.com/rust-lang/rust/commit/e4fd2bd7214dc2d3f8ec6a876b1687c9f3cf7beb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e4fd2bd7214dc2d3f8ec6a876b1687c9f3cf7beb/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bb99e6fdd99b0a9a9f75bc60b0995b4ef8e752ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb99e6fdd99b0a9a9f75bc60b0995b4ef8e752ab", "html_url": "https://github.com/rust-lang/rust/commit/bb99e6fdd99b0a9a9f75bc60b0995b4ef8e752ab"}], "stats": {"total": 214, "additions": 122, "deletions": 92}, "files": [{"sha": "481c4c56304a02684dfde91471c65f7f5b1d9790", "filename": "compiler/rustc_mir_transform/src/inline.rs", "status": "modified", "additions": 122, "deletions": 92, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/e4fd2bd7214dc2d3f8ec6a876b1687c9f3cf7beb/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4fd2bd7214dc2d3f8ec6a876b1687c9f3cf7beb/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs?ref=e4fd2bd7214dc2d3f8ec6a876b1687c9f3cf7beb", "patch": "@@ -409,118 +409,56 @@ impl<'tcx> Inliner<'tcx> {\n         debug!(\"    final inline threshold = {}\", threshold);\n \n         // FIXME: Give a bonus to functions with only a single caller\n-        let mut first_block = true;\n-        let mut cost = 0;\n+        let diverges = matches!(\n+            callee_body.basic_blocks()[START_BLOCK].terminator().kind,\n+            TerminatorKind::Unreachable | TerminatorKind::Call { target: None, .. }\n+        );\n+        if diverges && !matches!(callee_attrs.inline, InlineAttr::Always) {\n+            return Err(\"callee diverges unconditionally\");\n+        }\n+\n+        let mut checker = CostChecker {\n+            tcx: self.tcx,\n+            param_env: self.param_env,\n+            instance: callsite.callee,\n+            callee_body,\n+            cost: 0,\n+        };\n \n-        // Traverse the MIR manually so we can account for the effects of\n-        // inlining on the CFG.\n+        // Traverse the MIR manually so we can account for the effects of inlining on the CFG.\n         let mut work_list = vec![START_BLOCK];\n         let mut visited = BitSet::new_empty(callee_body.basic_blocks().len());\n         while let Some(bb) = work_list.pop() {\n             if !visited.insert(bb.index()) {\n                 continue;\n             }\n+\n             let blk = &callee_body.basic_blocks()[bb];\n+            checker.visit_basic_block_data(bb, blk);\n \n-            for stmt in &blk.statements {\n-                // Don't count StorageLive/StorageDead in the inlining cost.\n-                match stmt.kind {\n-                    StatementKind::StorageLive(_)\n-                    | StatementKind::StorageDead(_)\n-                    | StatementKind::Deinit(_)\n-                    | StatementKind::Nop => {}\n-                    _ => cost += INSTR_COST,\n-                }\n-            }\n             let term = blk.terminator();\n-            let mut is_drop = false;\n-            match term.kind {\n-                TerminatorKind::Drop { ref place, target, unwind }\n-                | TerminatorKind::DropAndReplace { ref place, target, unwind, .. } => {\n-                    is_drop = true;\n-                    work_list.push(target);\n-                    // If the place doesn't actually need dropping, treat it like\n-                    // a regular goto.\n-                    let ty = callsite.callee.subst_mir(self.tcx, &place.ty(callee_body, tcx).ty);\n-                    if ty.needs_drop(tcx, self.param_env) {\n-                        cost += CALL_PENALTY;\n-                        if let Some(unwind) = unwind {\n-                            cost += LANDINGPAD_PENALTY;\n-                            work_list.push(unwind);\n-                        }\n-                    } else {\n-                        cost += INSTR_COST;\n-                    }\n-                }\n-\n-                TerminatorKind::Unreachable | TerminatorKind::Call { target: None, .. }\n-                    if first_block =>\n-                {\n-                    // If the function always diverges, don't inline\n-                    // unless the cost is zero\n-                    threshold = 0;\n-                }\n-\n-                TerminatorKind::Call { func: Operand::Constant(ref f), cleanup, .. } => {\n-                    if let ty::FnDef(def_id, _) =\n-                        *callsite.callee.subst_mir(self.tcx, &f.literal.ty()).kind()\n-                    {\n-                        // Don't give intrinsics the extra penalty for calls\n-                        if tcx.is_intrinsic(def_id) {\n-                            cost += INSTR_COST;\n-                        } else {\n-                            cost += CALL_PENALTY;\n-                        }\n-                    } else {\n-                        cost += CALL_PENALTY;\n-                    }\n-                    if cleanup.is_some() {\n-                        cost += LANDINGPAD_PENALTY;\n-                    }\n-                }\n-                TerminatorKind::Assert { cleanup, .. } => {\n-                    cost += CALL_PENALTY;\n-\n-                    if cleanup.is_some() {\n-                        cost += LANDINGPAD_PENALTY;\n-                    }\n-                }\n-                TerminatorKind::Resume => cost += RESUME_PENALTY,\n-                TerminatorKind::InlineAsm { cleanup, .. } => {\n-                    cost += INSTR_COST;\n+            if let TerminatorKind::Drop { ref place, target, unwind }\n+            | TerminatorKind::DropAndReplace { ref place, target, unwind, .. } = term.kind\n+            {\n+                work_list.push(target);\n \n-                    if cleanup.is_some() {\n-                        cost += LANDINGPAD_PENALTY;\n+                // If the place doesn't actually need dropping, treat it like a regular goto.\n+                let ty = callsite.callee.subst_mir(self.tcx, &place.ty(callee_body, tcx).ty);\n+                if ty.needs_drop(tcx, self.param_env) && let Some(unwind) = unwind {\n+                        work_list.push(unwind);\n                     }\n-                }\n-                _ => cost += INSTR_COST,\n-            }\n-\n-            if !is_drop {\n-                for succ in term.successors() {\n-                    work_list.push(succ);\n-                }\n+            } else {\n+                work_list.extend(term.successors())\n             }\n-\n-            first_block = false;\n         }\n \n         // Count up the cost of local variables and temps, if we know the size\n         // use that, otherwise we use a moderately-large dummy cost.\n-\n-        let ptr_size = tcx.data_layout.pointer_size.bytes();\n-\n         for v in callee_body.vars_and_temps_iter() {\n-            let ty = callsite.callee.subst_mir(self.tcx, &callee_body.local_decls[v].ty);\n-            // Cost of the var is the size in machine-words, if we know\n-            // it.\n-            if let Some(size) = type_size_of(tcx, self.param_env, ty) {\n-                cost += ((size + ptr_size - 1) / ptr_size) as usize;\n-            } else {\n-                cost += UNKNOWN_SIZE_COST;\n-            }\n+            checker.visit_local_decl(v, &callee_body.local_decls[v]);\n         }\n \n+        let cost = checker.cost;\n         if let InlineAttr::Always = callee_attrs.inline {\n             debug!(\"INLINING {:?} because inline(always) [cost={}]\", callsite, cost);\n             Ok(())\n@@ -790,6 +728,98 @@ fn type_size_of<'tcx>(\n     tcx.layout_of(param_env.and(ty)).ok().map(|layout| layout.size.bytes())\n }\n \n+/// Verify that the callee body is compatible with the caller.\n+///\n+/// This visitor mostly computes the inlining cost,\n+/// but also needs to verify that types match because of normalization failure.\n+struct CostChecker<'b, 'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ParamEnv<'tcx>,\n+    cost: usize,\n+    callee_body: &'b Body<'tcx>,\n+    instance: ty::Instance<'tcx>,\n+}\n+\n+impl<'tcx> Visitor<'tcx> for CostChecker<'_, 'tcx> {\n+    fn visit_statement(&mut self, statement: &Statement<'tcx>, location: Location) {\n+        // Don't count StorageLive/StorageDead in the inlining cost.\n+        match statement.kind {\n+            StatementKind::StorageLive(_)\n+            | StatementKind::StorageDead(_)\n+            | StatementKind::Deinit(_)\n+            | StatementKind::Nop => {}\n+            _ => self.cost += INSTR_COST,\n+        }\n+\n+        self.super_statement(statement, location);\n+    }\n+\n+    fn visit_terminator(&mut self, terminator: &Terminator<'tcx>, location: Location) {\n+        let tcx = self.tcx;\n+        match terminator.kind {\n+            TerminatorKind::Drop { ref place, unwind, .. }\n+            | TerminatorKind::DropAndReplace { ref place, unwind, .. } => {\n+                // If the place doesn't actually need dropping, treat it like a regular goto.\n+                let ty = self.instance.subst_mir(tcx, &place.ty(self.callee_body, tcx).ty);\n+                if ty.needs_drop(tcx, self.param_env) {\n+                    self.cost += CALL_PENALTY;\n+                    if unwind.is_some() {\n+                        self.cost += LANDINGPAD_PENALTY;\n+                    }\n+                } else {\n+                    self.cost += INSTR_COST;\n+                }\n+            }\n+            TerminatorKind::Call { func: Operand::Constant(ref f), cleanup, .. } => {\n+                let fn_ty = self.instance.subst_mir(tcx, &f.literal.ty());\n+                self.cost += if let ty::FnDef(def_id, _) = *fn_ty.kind() && tcx.is_intrinsic(def_id) {\n+                    // Don't give intrinsics the extra penalty for calls\n+                    INSTR_COST\n+                } else {\n+                    CALL_PENALTY\n+                };\n+                if cleanup.is_some() {\n+                    self.cost += LANDINGPAD_PENALTY;\n+                }\n+            }\n+            TerminatorKind::Assert { cleanup, .. } => {\n+                self.cost += CALL_PENALTY;\n+                if cleanup.is_some() {\n+                    self.cost += LANDINGPAD_PENALTY;\n+                }\n+            }\n+            TerminatorKind::Resume => self.cost += RESUME_PENALTY,\n+            TerminatorKind::InlineAsm { cleanup, .. } => {\n+                self.cost += INSTR_COST;\n+                if cleanup.is_some() {\n+                    self.cost += LANDINGPAD_PENALTY;\n+                }\n+            }\n+            _ => self.cost += INSTR_COST,\n+        }\n+\n+        self.super_terminator(terminator, location);\n+    }\n+\n+    /// Count up the cost of local variables and temps, if we know the size\n+    /// use that, otherwise we use a moderately-large dummy cost.\n+    fn visit_local_decl(&mut self, local: Local, local_decl: &LocalDecl<'tcx>) {\n+        let tcx = self.tcx;\n+        let ptr_size = tcx.data_layout.pointer_size.bytes();\n+\n+        let ty = self.instance.subst_mir(tcx, &local_decl.ty);\n+        // Cost of the var is the size in machine-words, if we know\n+        // it.\n+        if let Some(size) = type_size_of(tcx, self.param_env, ty) {\n+            self.cost += ((size + ptr_size - 1) / ptr_size) as usize;\n+        } else {\n+            self.cost += UNKNOWN_SIZE_COST;\n+        }\n+\n+        self.super_local_decl(local, local_decl)\n+    }\n+}\n+\n /**\n  * Integrator.\n  *"}]}