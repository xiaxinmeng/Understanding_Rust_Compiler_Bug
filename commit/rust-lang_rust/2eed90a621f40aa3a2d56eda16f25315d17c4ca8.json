{"sha": "2eed90a621f40aa3a2d56eda16f25315d17c4ca8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlZWQ5MGE2MjFmNDBhYTNhMmQ1NmVkYTE2ZjI1MzE1ZDE3YzRjYTg=", "commit": {"author": {"name": "Paul Daniel Faria", "email": "Nashenas88@users.noreply.github.com", "date": "2019-10-23T17:46:23Z"}, "committer": {"name": "Paul Daniel Faria", "email": "Nashenas88@users.noreply.github.com", "date": "2019-12-02T13:30:30Z"}, "message": "Account for new maybe_sideeffect helper that requires predecessors", "tree": {"sha": "e64f332454dd6d845379982e3fe47aee5048bd77", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e64f332454dd6d845379982e3fe47aee5048bd77"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2eed90a621f40aa3a2d56eda16f25315d17c4ca8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2eed90a621f40aa3a2d56eda16f25315d17c4ca8", "html_url": "https://github.com/rust-lang/rust/commit/2eed90a621f40aa3a2d56eda16f25315d17c4ca8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2eed90a621f40aa3a2d56eda16f25315d17c4ca8/comments", "author": {"login": "Nashenas88", "id": 1673130, "node_id": "MDQ6VXNlcjE2NzMxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1673130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nashenas88", "html_url": "https://github.com/Nashenas88", "followers_url": "https://api.github.com/users/Nashenas88/followers", "following_url": "https://api.github.com/users/Nashenas88/following{/other_user}", "gists_url": "https://api.github.com/users/Nashenas88/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nashenas88/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nashenas88/subscriptions", "organizations_url": "https://api.github.com/users/Nashenas88/orgs", "repos_url": "https://api.github.com/users/Nashenas88/repos", "events_url": "https://api.github.com/users/Nashenas88/events{/privacy}", "received_events_url": "https://api.github.com/users/Nashenas88/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nashenas88", "id": 1673130, "node_id": "MDQ6VXNlcjE2NzMxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1673130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nashenas88", "html_url": "https://github.com/Nashenas88", "followers_url": "https://api.github.com/users/Nashenas88/followers", "following_url": "https://api.github.com/users/Nashenas88/following{/other_user}", "gists_url": "https://api.github.com/users/Nashenas88/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nashenas88/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nashenas88/subscriptions", "organizations_url": "https://api.github.com/users/Nashenas88/orgs", "repos_url": "https://api.github.com/users/Nashenas88/repos", "events_url": "https://api.github.com/users/Nashenas88/events{/privacy}", "received_events_url": "https://api.github.com/users/Nashenas88/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8c266a0fb4c83136cad45aaa0201594b9bd50db", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8c266a0fb4c83136cad45aaa0201594b9bd50db", "html_url": "https://github.com/rust-lang/rust/commit/c8c266a0fb4c83136cad45aaa0201594b9bd50db"}], "stats": {"total": 309, "additions": 176, "deletions": 133}, "files": [{"sha": "63d8eba971bb505bb28da63647ca263045d64437", "filename": "src/librustc/mir/cache.rs", "status": "modified", "additions": 115, "deletions": 50, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/2eed90a621f40aa3a2d56eda16f25315d17c4ca8/src%2Flibrustc%2Fmir%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eed90a621f40aa3a2d56eda16f25315d17c4ca8/src%2Flibrustc%2Fmir%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fcache.rs?ref=2eed90a621f40aa3a2d56eda16f25315d17c4ca8", "patch": "@@ -47,8 +47,7 @@ impl Cache {\n     }\n \n     #[inline]\n-    /// This will recompute the predecessors cache if it is not available\n-    pub fn predecessors(&mut self, body: &Body<'_>) -> &IndexVec<BasicBlock, Vec<BasicBlock>> {\n+    pub fn ensure_predecessors(&mut self, body: &Body<'_>) {\n         if self.predecessors.is_none() {\n             let mut result = IndexVec::from_elem(vec![], body.basic_blocks());\n             for (bb, data) in body.basic_blocks().iter_enumerated() {\n@@ -61,7 +60,12 @@ impl Cache {\n \n             self.predecessors = Some(result)\n         }\n+    }\n \n+    #[inline]\n+    /// This will recompute the predecessors cache if it is not available\n+    pub fn predecessors(&mut self, body: &Body<'_>) -> &IndexVec<BasicBlock, Vec<BasicBlock>> {\n+        self.ensure_predecessors(body);\n         self.predecessors.as_ref().unwrap()\n     }\n \n@@ -70,6 +74,11 @@ impl Cache {\n         &self.predecessors(body)[bb]\n     }\n \n+    #[inline]\n+    fn unwrap_predecessors_for(&self, bb: BasicBlock) -> &[BasicBlock] {\n+        &self.predecessors.as_ref().unwrap()[bb]\n+    }\n+\n     #[inline]\n     pub fn predecessor_locations<'a>(&'a mut self, loc: Location, body: &'a Body<'a>) -> impl Iterator<Item = Location> + 'a {\n         let if_zero_locations = if loc.statement_index == 0 {\n@@ -137,13 +146,17 @@ impl<'a, 'tcx> BodyCache<&'a Body<'tcx>> {\n     }\n \n     #[inline]\n-    pub fn basic_blocks(&self) -> &IndexVec<BasicBlock, BasicBlockData<'tcx>> {\n-        &self.body.basic_blocks\n+    pub fn read_only(mut self) -> ReadOnlyBodyCache<'a, 'tcx> {\n+        self.cache.ensure_predecessors(self.body);\n+        ReadOnlyBodyCache {\n+            cache: self.cache,\n+            body: self.body,\n+        }\n     }\n \n     #[inline]\n-    pub fn dominators(&mut self) -> Dominators<BasicBlock> {\n-        dominators(self)\n+    pub fn basic_blocks(&self) -> &IndexVec<BasicBlock, BasicBlockData<'tcx>> {\n+        &self.body.basic_blocks\n     }\n }\n \n@@ -164,50 +177,6 @@ impl<'a, 'tcx> Index<BasicBlock> for BodyCache<&'a Body<'tcx>> {\n     }\n }\n \n-impl<'a, 'tcx> graph::DirectedGraph for BodyCache<&'a Body<'tcx>> {\n-    type Node = BasicBlock;\n-}\n-\n-impl<'a, 'graph, 'tcx> graph::GraphPredecessors<'graph> for BodyCache<&'a Body<'tcx>> {\n-    type Item = BasicBlock;\n-    type Iter = IntoIter<BasicBlock>;\n-}\n-\n-impl<'a, 'tcx> graph::WithPredecessors for BodyCache<&'a Body<'tcx>> {\n-    fn predecessors(\n-        &mut self,\n-        node: Self::Node,\n-    ) -> <Self as GraphPredecessors<'_>>::Iter {\n-        self.predecessors_for(node).to_vec().into_iter()\n-    }\n-}\n-\n-impl<'a, 'tcx> graph::WithNumNodes for BodyCache<&'a Body<'tcx>> {\n-    fn num_nodes(&self) -> usize {\n-        self.body.num_nodes()\n-    }\n-}\n-\n-impl<'a, 'tcx> graph::WithStartNode for BodyCache<&'a Body<'tcx>> {\n-    fn start_node(&self) -> Self::Node {\n-        self.body.start_node()\n-    }\n-}\n-\n-impl<'a, 'tcx> graph::WithSuccessors for BodyCache<&'a Body<'tcx>> {\n-    fn successors(\n-        &self,\n-        node: Self::Node,\n-    ) -> <Self as GraphSuccessors<'_>>::Iter {\n-        self.body.successors(node)\n-    }\n-}\n-\n-impl<'a, 'b, 'tcx> graph::GraphSuccessors<'b> for BodyCache<&'a Body<'tcx>> {\n-    type Item = BasicBlock;\n-    type Iter = iter::Cloned<Successors<'b>>;\n-}\n-\n impl<'a, 'tcx> BodyCache<&'a mut Body<'tcx>> {\n     #[inline]\n     pub fn body(&self) -> &Body<'tcx> {\n@@ -259,3 +228,99 @@ impl<'a, 'tcx> IndexMut<BasicBlock> for BodyCache<&'a mut Body<'tcx>> {\n         &mut self.body.basic_blocks[index]\n     }\n }\n+\n+pub struct ReadOnlyBodyCache<'a, 'tcx> {\n+    cache: Cache,\n+    body: &'a Body<'tcx>,\n+}\n+\n+impl ReadOnlyBodyCache<'a, 'tcx> {\n+    #[inline]\n+    pub fn predecessors_for(&self, bb: BasicBlock) -> &[BasicBlock] {\n+        self.cache.unwrap_predecessors_for(bb)\n+    }\n+\n+    #[inline]\n+    pub fn body(&self) -> &'a Body<'tcx> {\n+        self.body\n+    }\n+\n+    #[inline]\n+    pub fn basic_blocks(&self) -> &IndexVec<BasicBlock, BasicBlockData<'tcx>> {\n+        &self.body.basic_blocks\n+    }\n+\n+    #[inline]\n+    pub fn dominators(&self) -> Dominators<BasicBlock> {\n+        dominators(self)\n+    }\n+\n+    pub fn to_owned(self) -> BodyCache<&'a Body<'tcx>> {\n+        BodyCache {\n+            cache: self.cache,\n+            body: self.body,\n+        }\n+    }\n+}\n+\n+impl graph::DirectedGraph for ReadOnlyBodyCache<'a, 'tcx> {\n+    type Node = BasicBlock;\n+}\n+\n+impl graph::GraphPredecessors<'graph> for ReadOnlyBodyCache<'a, 'tcx> {\n+    type Item = BasicBlock;\n+    type Iter = IntoIter<BasicBlock>;\n+}\n+\n+impl graph::WithPredecessors for ReadOnlyBodyCache<'a, 'tcx> {\n+    fn predecessors(\n+        &self,\n+        node: Self::Node,\n+    ) -> <Self as GraphPredecessors<'_>>::Iter {\n+        self.cache.unwrap_predecessors_for(node).to_vec().into_iter()\n+    }\n+}\n+\n+impl graph::WithNumNodes for ReadOnlyBodyCache<'a, 'tcx> {\n+    fn num_nodes(&self) -> usize {\n+        self.body.num_nodes()\n+    }\n+}\n+\n+impl graph::WithStartNode for ReadOnlyBodyCache<'a, 'tcx> {\n+    fn start_node(&self) -> Self::Node {\n+        self.body.start_node()\n+    }\n+}\n+\n+impl graph::WithSuccessors for ReadOnlyBodyCache<'a, 'tcx> {\n+    fn successors(\n+        &self,\n+        node: Self::Node,\n+    ) -> <Self as GraphSuccessors<'_>>::Iter {\n+        self.body.successors(node)\n+    }\n+}\n+\n+impl<'a, 'b, 'tcx> graph::GraphSuccessors<'b> for ReadOnlyBodyCache<'a, 'tcx> {\n+    type Item = BasicBlock;\n+    type Iter = iter::Cloned<Successors<'b>>;\n+}\n+\n+\n+impl Deref for ReadOnlyBodyCache<'a, 'tcx> {\n+    type Target = Body<'tcx>;\n+\n+    fn deref(&self) -> &Self::Target {\n+        self.body\n+    }\n+}\n+\n+impl Index<BasicBlock> for ReadOnlyBodyCache<'a, 'tcx> {\n+    type Output = BasicBlockData<'tcx>;\n+\n+    #[inline]\n+    fn index(&self, index: BasicBlock) -> &BasicBlockData<'tcx> {\n+        &self.body[index]\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "57d396ae933025dd19a0538b3ecd90a04016d347", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2eed90a621f40aa3a2d56eda16f25315d17c4ca8/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eed90a621f40aa3a2d56eda16f25315d17c4ca8/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=2eed90a621f40aa3a2d56eda16f25315d17c4ca8", "patch": "@@ -38,7 +38,7 @@ use syntax::symbol::Symbol;\n use syntax_pos::{Span, DUMMY_SP};\n \n pub use crate::mir::interpret::AssertMessage;\n-pub use crate::mir::cache::BodyCache;\n+pub use crate::mir::cache::{BodyCache, ReadOnlyBodyCache};\n \n pub mod cache;\n pub mod interpret;\n@@ -2600,7 +2600,7 @@ impl Location {\n     pub fn is_predecessor_of<'tcx>(\n         &self,\n         other: Location,\n-        mut body_cache: BodyCache<&'_ Body<'tcx>>\n+        body_cache: &ReadOnlyBodyCache<'_, 'tcx>\n     ) -> bool {\n         // If we are in the same block as the other location and are an earlier statement\n         // then we are a predecessor of `other`."}, {"sha": "7877466fbf6a66dcc6b65f5f1ae9554c827e5ceb", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2eed90a621f40aa3a2d56eda16f25315d17c4ca8/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eed90a621f40aa3a2d56eda16f25315d17c4ca8/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=2eed90a621f40aa3a2d56eda16f25315d17c4ca8", "patch": "@@ -65,6 +65,15 @@ use syntax_pos::Span;\n // variant argument) that does not require visiting, as in\n // `is_cleanup` above.\n \n+macro_rules! body_cache_type {\n+    (mut $a:lifetime, $tcx:lifetime) => {\n+        &mut BodyCache<& $a mut Body<$tcx>>\n+    };\n+    ($a:lifetime, $tcx:lifetime) => {\n+        &ReadOnlyBodyCache<$a, $tcx>\n+    };\n+}\n+\n macro_rules! make_mir_visitor {\n     ($visitor_trait_name:ident, $($mutability:ident)?) => {\n         pub trait $visitor_trait_name<'tcx> {\n@@ -73,7 +82,7 @@ macro_rules! make_mir_visitor {\n \n             fn visit_body(\n                 &mut self,\n-                body_cache: & $($mutability)? BodyCache<&'_ $($mutability)? Body<'tcx>>\n+                body_cache: body_cache_type!($($mutability)? '_, 'tcx)\n             ) {\n                 self.super_body(body_cache);\n             }\n@@ -245,7 +254,7 @@ macro_rules! make_mir_visitor {\n \n             fn super_body(\n                 &mut self,\n-                body_cache: & $($mutability)? BodyCache<&'_ $($mutability)? Body<'tcx>>\n+                body_cache: body_cache_type!($($mutability)? '_, 'tcx)\n             ) {\n                 macro_rules! body {\n                     (mut) => (body_cache.body_mut());"}, {"sha": "fff0117834101fd7da65a50e1c7bbd3c7e065a21", "filename": "src/librustc_codegen_ssa/mir/analyze.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2eed90a621f40aa3a2d56eda16f25315d17c4ca8/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eed90a621f40aa3a2d56eda16f25315d17c4ca8/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs?ref=2eed90a621f40aa3a2d56eda16f25315d17c4ca8", "patch": "@@ -4,7 +4,7 @@\n use rustc_index::bit_set::BitSet;\n use rustc_data_structures::graph::dominators::Dominators;\n use rustc_index::vec::{Idx, IndexVec};\n-use rustc::mir::{self, Body, BodyCache, Location, TerminatorKind};\n+use rustc::mir::{self, Location, TerminatorKind};\n use rustc::mir::visit::{\n     Visitor, PlaceContext, MutatingUseContext, NonMutatingUseContext, NonUseContext,\n };\n@@ -16,15 +16,14 @@ use syntax_pos::DUMMY_SP;\n use super::FunctionCx;\n use crate::traits::*;\n \n-pub fn non_ssa_locals<'a, 'b, 'c, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n-    fx: &FunctionCx<'a, 'b, 'tcx, Bx>,\n-    mir: &'c mut BodyCache<&'b Body<'tcx>>,\n+pub fn non_ssa_locals<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n+    fx: &FunctionCx<'a, 'b, 'tcx, Bx>\n ) -> BitSet<mir::Local> {\n-    let mut analyzer = LocalAnalyzer::new(fx, mir);\n+    let mut analyzer = LocalAnalyzer::new(fx);\n \n-    analyzer.visit_body(mir);\n+    analyzer.visit_body(fx.mir);\n \n-    for (local, decl) in mir.local_decls.iter_enumerated()\n+    for (local, decl) in fx.mir.local_decls.iter_enumerated()\n     {\n         // FIXME(eddyb): We should figure out how to use llvm.dbg.value instead\n         // of putting everything in allocas just so we can use llvm.dbg.declare.\n@@ -66,20 +65,20 @@ struct LocalAnalyzer<'mir, 'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> {\n     first_assignment: IndexVec<mir::Local, Location>,\n }\n \n-impl<'mir, 'a, 'b, 'c, 'tcx, Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'b, 'tcx, Bx> {\n-    fn new(fx: &'mir FunctionCx<'a, 'b, 'tcx, Bx>, mir: &'c mut BodyCache<&'b Body<'tcx>>) -> Self {\n+impl<'mir, 'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'b, 'tcx, Bx> {\n+    fn new(fx: &'mir FunctionCx<'a, 'b, 'tcx, Bx>) -> Self {\n         let invalid_location =\n-            mir::BasicBlock::new(mir.basic_blocks().len()).start_location();\n-        let dominators = mir.dominators();\n+            mir::BasicBlock::new(fx.mir.basic_blocks().len()).start_location();\n+        let dominators = fx.mir.dominators();\n         let mut analyzer = LocalAnalyzer {\n             fx,\n             dominators,\n-            non_ssa_locals: BitSet::new_empty(mir.local_decls.len()),\n-            first_assignment: IndexVec::from_elem(invalid_location, &mir.local_decls)\n+            non_ssa_locals: BitSet::new_empty(fx.mir.local_decls.len()),\n+            first_assignment: IndexVec::from_elem(invalid_location, &fx.mir.local_decls)\n         };\n \n         // Arguments get assigned to by means of the function being called\n-        for arg in mir.args_iter() {\n+        for arg in fx.mir.args_iter() {\n             analyzer.first_assignment[arg] = mir::START_BLOCK.start_location();\n         }\n \n@@ -131,7 +130,7 @@ impl<'mir, 'a, 'b, 'c, 'tcx, Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, '\n             };\n             if is_consume {\n                 let base_ty =\n-                    mir::Place::ty_from(place_ref.base, proj_base, self.fx.mir, cx.tcx());\n+                    mir::Place::ty_from(place_ref.base, proj_base, self.fx.mir.body(), cx.tcx());\n                 let base_ty = self.fx.monomorphize(&base_ty);\n \n                 // ZSTs don't require any actual memory access."}, {"sha": "e2cae0aa565166059921f504ad322b793f455b74", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/2eed90a621f40aa3a2d56eda16f25315d17c4ca8/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eed90a621f40aa3a2d56eda16f25315d17c4ca8/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=2eed90a621f40aa3a2d56eda16f25315d17c4ca8", "patch": "@@ -153,7 +153,7 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'a, 'tcx> {\n     // a loop.\n     fn maybe_sideeffect<'b, 'tcx2: 'b, Bx: BuilderMethods<'b, 'tcx2>>(\n         &self,\n-        mir: &'b mir::Body<'tcx>,\n+        mir: &mir::ReadOnlyBodyCache<'_, 'tcx>,\n         bx: &mut Bx,\n         targets: &[mir::BasicBlock],\n     ) {\n@@ -216,7 +216,7 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n             let lltrue = helper.llblock(self, targets[0]);\n             let llfalse = helper.llblock(self, targets[1]);\n             if switch_ty == bx.tcx().types.bool {\n-                helper.maybe_sideeffect(self.mir, &mut bx, targets.as_slice());\n+                helper.maybe_sideeffect(&self.mir, &mut bx, targets.as_slice());\n                 // Don't generate trivial icmps when switching on bool\n                 if let [0] = values[..] {\n                     bx.cond_br(discr.immediate(), llfalse, lltrue);\n@@ -230,11 +230,11 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n                 );\n                 let llval = bx.const_uint_big(switch_llty, values[0]);\n                 let cmp = bx.icmp(IntPredicate::IntEQ, discr.immediate(), llval);\n-                helper.maybe_sideeffect(self.mir, &mut bx, targets.as_slice());\n+                helper.maybe_sideeffect(&self.mir, &mut bx, targets.as_slice());\n                 bx.cond_br(cmp, lltrue, llfalse);\n             }\n         } else {\n-            helper.maybe_sideeffect(self.mir, &mut bx, targets.as_slice());\n+            helper.maybe_sideeffect(&self.mir, &mut bx, targets.as_slice());\n             let (otherwise, targets) = targets.split_last().unwrap();\n             bx.switch(\n                 discr.immediate(),\n@@ -324,13 +324,13 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n         target: mir::BasicBlock,\n         unwind: Option<mir::BasicBlock>,\n     ) {\n-        let ty = location.ty(self.mir, bx.tcx()).ty;\n+        let ty = location.ty(self.mir.body(), bx.tcx()).ty;\n         let ty = self.monomorphize(&ty);\n         let drop_fn = Instance::resolve_drop_in_place(bx.tcx(), ty);\n \n         if let ty::InstanceDef::DropGlue(_, None) = drop_fn.def {\n             // we don't actually need to drop anything.\n-            helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n+            helper.maybe_sideeffect(&self.mir, &mut bx, &[target]);\n             helper.funclet_br(self, &mut bx, target);\n             return\n         }\n@@ -361,7 +361,7 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n                  FnAbi::of_instance(&bx, drop_fn))\n             }\n         };\n-        helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n+        helper.maybe_sideeffect(&self.mir, &mut bx, &[target]);\n         helper.do_call(self, &mut bx, fn_ty, drop_fn, args,\n                        Some((ReturnDest::Nothing, target)),\n                        unwind);\n@@ -397,7 +397,7 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n \n         // Don't codegen the panic block if success if known.\n         if const_cond == Some(expected) {\n-            helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n+            helper.maybe_sideeffect(&self.mir, &mut bx, &[target]);\n             helper.funclet_br(self, &mut bx, target);\n             return;\n         }\n@@ -408,7 +408,7 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n         // Create the failure block and the conditional branch to it.\n         let lltarget = helper.llblock(self, target);\n         let panic_block = self.new_block(\"panic\");\n-        helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n+        helper.maybe_sideeffect(&self.mir, &mut bx, &[target]);\n         if expected {\n             bx.cond_br(cond, lltarget, panic_block.llbb());\n         } else {\n@@ -493,7 +493,7 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n             if let Some(destination_ref) = destination.as_ref() {\n                 let &(ref dest, target) = destination_ref;\n                 self.codegen_transmute(&mut bx, &args[0], dest);\n-                helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n+                helper.maybe_sideeffect(&self.mir, &mut bx, &[target]);\n                 helper.funclet_br(self, &mut bx, target);\n             } else {\n                 // If we are trying to transmute to an uninhabited type,\n@@ -510,7 +510,7 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n \n         let extra_args = &args[sig.inputs().len()..];\n         let extra_args = extra_args.iter().map(|op_arg| {\n-            let op_ty = op_arg.ty(self.mir, bx.tcx());\n+            let op_ty = op_arg.ty(self.mir.body(), bx.tcx());\n             self.monomorphize(&op_ty)\n         }).collect::<Vec<_>>();\n \n@@ -521,7 +521,7 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n             Some(ty::InstanceDef::DropGlue(_, None)) => {\n                 // Empty drop glue; a no-op.\n                 let &(_, target) = destination.as_ref().unwrap();\n-                helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n+                helper.maybe_sideeffect(&self.mir, &mut bx, &[target]);\n                 helper.funclet_br(self, &mut bx, target);\n                 return;\n             }\n@@ -553,7 +553,7 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n                 let llfn = bx.get_fn_addr(instance);\n \n                 if let Some((_, target)) = destination.as_ref() {\n-                    helper.maybe_sideeffect(self.mir, &mut bx, &[*target]);\n+                    helper.maybe_sideeffect(&self.mir, &mut bx, &[*target]);\n                 }\n                 // Codegen the actual panic invoke/call.\n                 helper.do_call(\n@@ -568,7 +568,7 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n             } else {\n                 // a NOP\n                 let target = destination.as_ref().unwrap().1;\n-                helper.maybe_sideeffect(mir, &mut bx, &[target]);\n+                helper.maybe_sideeffect(&self.mir, &mut bx, &[target]);\n                 helper.funclet_br(self, &mut bx, destination.as_ref().unwrap().1)\n             }\n             return;\n@@ -682,7 +682,7 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n             }\n \n             if let Some((_, target)) = *destination {\n-                helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n+                helper.maybe_sideeffect(&self.mir, &mut bx, &[target]);\n                 helper.funclet_br(self, &mut bx, target);\n             } else {\n                 bx.unreachable();\n@@ -776,7 +776,7 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n         };\n \n         if let Some((_, target)) = destination.as_ref() {\n-            helper.maybe_sideeffect(self.mir, &mut bx, &[*target]);\n+            helper.maybe_sideeffect(&self.mir, &mut bx, &[*target]);\n         }\n         helper.do_call(self, &mut bx, fn_ty, fn_ptr, &llargs,\n                        destination.as_ref().map(|&(_, target)| (ret_dest, target)),\n@@ -827,7 +827,7 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n             }\n \n             mir::TerminatorKind::Goto { target } => {\n-                helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n+                helper.maybe_sideeffect(&self.mir, &mut bx, &[target]);\n                 helper.funclet_br(self, &mut bx, target);\n             }\n "}, {"sha": "a58b13ce102d27ee924f6d454ab8784d6e8e7f2c", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2eed90a621f40aa3a2d56eda16f25315d17c4ca8/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eed90a621f40aa3a2d56eda16f25315d17c4ca8/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=2eed90a621f40aa3a2d56eda16f25315d17c4ca8", "patch": "@@ -21,7 +21,7 @@ use self::operand::{OperandRef, OperandValue};\n pub struct FunctionCx<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> {\n     instance: Instance<'tcx>,\n \n-    mir: &'b mir::Body<'tcx>,\n+    mir: &'b mir::ReadOnlyBodyCache<'a, 'tcx>,\n \n     debug_context: Option<FunctionDebugContext<Bx::DIScope>>,\n \n@@ -156,10 +156,11 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         }).collect();\n \n     let (landing_pads, funclets) = create_funclets(&mir, &mut bx, &cleanup_kinds, &block_bxs);\n-\n+    let mir_body = mir.body();\n+    let readonly_mir = mir.read_only();\n     let mut fx = FunctionCx {\n         instance,\n-        mir: mir.body(),\n+        mir: &readonly_mir,\n         llfn,\n         fn_abi,\n         cx,\n@@ -174,14 +175,14 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         per_local_var_debug_info: debuginfo::per_local_var_debug_info(cx.tcx(), mir),\n     };\n \n-    let memory_locals = analyze::non_ssa_locals(&fx, &mut mir);\n+    let memory_locals = analyze::non_ssa_locals(&fx);\n \n     // Allocate variable and temp allocas\n     fx.locals = {\n         let args = arg_local_refs(&mut bx, &fx, &memory_locals);\n \n         let mut allocate_local = |local| {\n-            let decl = &mir.local_decls[local];\n+            let decl = &mir_body.local_decls[local];\n             let layout = bx.layout_of(fx.monomorphize(&decl.ty));\n             assert!(!layout.ty.has_erasable_regions());\n \n@@ -207,7 +208,7 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         let retptr = allocate_local(mir::RETURN_PLACE);\n         iter::once(retptr)\n             .chain(args.into_iter())\n-            .chain(mir.vars_and_temps_iter().map(allocate_local))\n+            .chain(mir_body.vars_and_temps_iter().map(allocate_local))\n             .collect()\n     };\n \n@@ -226,8 +227,8 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         debug_context.source_locations_enabled = true;\n     }\n \n-    let rpo = traversal::reverse_postorder(&mir);\n-    let mut visited = BitSet::new_empty(mir.basic_blocks().len());\n+    let rpo = traversal::reverse_postorder(&mir_body);\n+    let mut visited = BitSet::new_empty(mir_body.basic_blocks().len());\n \n     // Codegen the body of each block using reverse postorder\n     for (bb, _) in rpo {\n@@ -237,7 +238,7 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n \n     // Remove blocks that haven't been visited, or have no\n     // predecessors.\n-    for bb in mir.basic_blocks().indices() {\n+    for bb in mir_body.basic_blocks().indices() {\n         // Unreachable block\n         if !visited.contains(bb.index()) {\n             debug!(\"codegen_mir: block {:?} was not visited\", bb);"}, {"sha": "34f2b56adee49049d3a6e56fbb92308df5669971", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2eed90a621f40aa3a2d56eda16f25315d17c4ca8/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eed90a621f40aa3a2d56eda16f25315d17c4ca8/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=2eed90a621f40aa3a2d56eda16f25315d17c4ca8", "patch": "@@ -591,7 +591,7 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n \n     pub fn monomorphized_place_ty(&self, place_ref: &mir::PlaceRef<'_, 'tcx>) -> Ty<'tcx> {\n         let tcx = self.cx.tcx();\n-        let place_ty = mir::Place::ty_from(place_ref.base, place_ref.projection, self.mir, tcx);\n+        let place_ty = mir::Place::ty_from(place_ref.base, place_ref.projection, self.mir.body(), tcx);\n         self.monomorphize(&place_ty.ty)\n     }\n }"}, {"sha": "19554156b2277adfb968defbf414922df4e35d59", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2eed90a621f40aa3a2d56eda16f25315d17c4ca8/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eed90a621f40aa3a2d56eda16f25315d17c4ca8/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=2eed90a621f40aa3a2d56eda16f25315d17c4ca8", "patch": "@@ -460,7 +460,7 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n             }\n \n             mir::Rvalue::Discriminant(ref place) => {\n-                let discr_ty = rvalue.ty(self.mir, bx.tcx());\n+                let discr_ty = rvalue.ty(self.mir.body(), bx.tcx());\n                 let discr =  self.codegen_place(&mut bx, &place.as_ref())\n                     .codegen_get_discr(&mut bx, discr_ty);\n                 (bx, OperandRef {\n@@ -513,7 +513,7 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n             mir::Rvalue::Aggregate(..) => {\n                 // According to `rvalue_creates_operand`, only ZST\n                 // aggregate rvalues are allowed to be operands.\n-                let ty = rvalue.ty(self.mir, self.cx.tcx());\n+                let ty = rvalue.ty(self.mir.body(), self.cx.tcx());\n                 let operand = OperandRef::new_zst(\n                     &mut bx,\n                     self.cx.layout_of(self.monomorphize(&ty)),\n@@ -714,7 +714,7 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n                 true,\n             mir::Rvalue::Repeat(..) |\n             mir::Rvalue::Aggregate(..) => {\n-                let ty = rvalue.ty(self.mir, self.cx.tcx());\n+                let ty = rvalue.ty(self.mir.body(), self.cx.tcx());\n                 let ty = self.monomorphize(&ty);\n                 self.cx.spanned_layout_of(ty, span).is_zst()\n             }"}, {"sha": "37335799d19af87ae5d46b1e469a41bc0aa9a0e6", "filename": "src/librustc_data_structures/graph/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2eed90a621f40aa3a2d56eda16f25315d17c4ca8/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eed90a621f40aa3a2d56eda16f25315d17c4ca8/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs?ref=2eed90a621f40aa3a2d56eda16f25315d17c4ca8", "patch": "@@ -50,7 +50,7 @@ where\n     Self: for<'graph> GraphPredecessors<'graph, Item = <Self as DirectedGraph>::Node>,\n {\n     fn predecessors(\n-        &mut self,\n+        &self,\n         node: Self::Node,\n     ) -> <Self as GraphPredecessors<'_>>::Iter;\n }"}, {"sha": "eab217692d0494ab3ec680e00395adb994a4b37d", "filename": "src/librustc_data_structures/graph/reference.rs", "status": "modified", "additions": 2, "deletions": 33, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/2eed90a621f40aa3a2d56eda16f25315d17c4ca8/src%2Flibrustc_data_structures%2Fgraph%2Freference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eed90a621f40aa3a2d56eda16f25315d17c4ca8/src%2Flibrustc_data_structures%2Fgraph%2Freference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Freference.rs?ref=2eed90a621f40aa3a2d56eda16f25315d17c4ca8", "patch": "@@ -4,46 +4,25 @@ impl<'graph, G: DirectedGraph> DirectedGraph for &'graph G {\n     type Node = G::Node;\n }\n \n-impl<'graph, G: DirectedGraph> DirectedGraph for &'graph mut G {\n-    type Node = G::Node;\n-}\n-\n impl<'graph, G: WithNumNodes> WithNumNodes for &'graph G {\n     fn num_nodes(&self) -> usize {\n         (**self).num_nodes()\n     }\n }\n-impl<'graph, G: WithNumNodes> WithNumNodes for &'graph mut G {\n-    fn num_nodes(&self) -> usize {\n-        (**self).num_nodes()\n-    }\n-}\n \n impl<'graph, G: WithStartNode> WithStartNode for &'graph G {\n     fn start_node(&self) -> Self::Node {\n         (**self).start_node()\n     }\n }\n \n-impl<'graph, G: WithStartNode> WithStartNode for &'graph mut G {\n-    fn start_node(&self) -> Self::Node {\n-        (**self).start_node()\n-    }\n-}\n-\n impl<'graph, G: WithSuccessors> WithSuccessors for &'graph G {\n     fn successors(&self, node: Self::Node) -> <Self as GraphSuccessors<'_>>::Iter {\n         (**self).successors(node)\n     }\n }\n-impl<'graph, G: WithSuccessors> WithSuccessors for &'graph mut G {\n-    fn successors(&self, node: Self::Node) -> <Self as GraphSuccessors<'_>>::Iter {\n-        (**self).successors(node)\n-    }\n-}\n-\n-impl<'graph, G: WithPredecessors> WithPredecessors for &'graph mut G {\n-    fn predecessors(&mut self,\n+impl<'graph, G: WithPredecessors> WithPredecessors for &'graph G {\n+    fn predecessors(&self,\n                     node: Self::Node)\n                     -> <Self as GraphPredecessors<'_>>::Iter {\n         (**self).predecessors(node)\n@@ -55,17 +34,7 @@ impl<'iter, 'graph, G: WithPredecessors> GraphPredecessors<'iter> for &'graph G\n     type Iter = <G as GraphPredecessors<'iter>>::Iter;\n }\n \n-impl<'iter, 'graph, G: WithPredecessors> GraphPredecessors<'iter> for &'graph mut G {\n-    type Item = G::Node;\n-    type Iter = <G as GraphPredecessors<'iter>>::Iter;\n-}\n-\n impl<'iter, 'graph, G: WithSuccessors> GraphSuccessors<'iter> for &'graph G {\n     type Item = G::Node;\n     type Iter = <G as GraphSuccessors<'iter>>::Iter;\n }\n-\n-impl<'iter, 'graph, G: WithSuccessors> GraphSuccessors<'iter> for &'graph mut G {\n-    type Item = G::Node;\n-    type Iter = <G as GraphSuccessors<'iter>>::Iter;\n-}"}]}