{"sha": "d4b934bdce53107a0270f97985bc3152c638183e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0YjkzNGJkY2U1MzEwN2EwMjcwZjk3OTg1YmMzMTUyYzYzODE4M2U=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-04-26T13:53:29Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-04-29T22:41:06Z"}, "message": "core: add some inlining hints to methods/fns in rand.", "tree": {"sha": "5ee902576e471d12f4546ed086cdf43a03596d98", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5ee902576e471d12f4546ed086cdf43a03596d98"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d4b934bdce53107a0270f97985bc3152c638183e", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d4b934bdce53107a0270f97985bc3152c638183e", "html_url": "https://github.com/rust-lang/rust/commit/d4b934bdce53107a0270f97985bc3152c638183e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d4b934bdce53107a0270f97985bc3152c638183e/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "30266a788f8399790024f0ffb7618cdd2c50935b", "url": "https://api.github.com/repos/rust-lang/rust/commits/30266a788f8399790024f0ffb7618cdd2c50935b", "html_url": "https://github.com/rust-lang/rust/commit/30266a788f8399790024f0ffb7618cdd2c50935b"}], "stats": {"total": 33, "additions": 32, "deletions": 1}, "files": [{"sha": "07e7defb1b5203c0fb2347921d285f6efe9e7a78", "filename": "src/libcore/rand.rs", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d4b934bdce53107a0270f97985bc3152c638183e/src%2Flibcore%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4b934bdce53107a0270f97985bc3152c638183e/src%2Flibcore%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand.rs?ref=d4b934bdce53107a0270f97985bc3152c638183e", "patch": "@@ -53,6 +53,7 @@ pub trait Rand {\n }\n \n impl Rand for int {\n+    #[inline]\n     fn rand<R: Rng>(rng: &R) -> int {\n         if int::bits == 32 {\n             rng.next() as int\n@@ -63,30 +64,35 @@ impl Rand for int {\n }\n \n impl Rand for i8 {\n+    #[inline]\n     fn rand<R: Rng>(rng: &R) -> i8 {\n         rng.next() as i8\n     }\n }\n \n impl Rand for i16 {\n+    #[inline]\n     fn rand<R: Rng>(rng: &R) -> i16 {\n         rng.next() as i16\n     }\n }\n \n impl Rand for i32 {\n+    #[inline]\n     fn rand<R: Rng>(rng: &R) -> i32 {\n         rng.next() as i32\n     }\n }\n \n impl Rand for i64 {\n+    #[inline]\n     fn rand<R: Rng>(rng: &R) -> i64 {\n         (rng.next() as i64 << 32) | rng.next() as i64\n     }\n }\n \n impl Rand for uint {\n+    #[inline]\n     fn rand<R: Rng>(rng: &R) -> uint {\n         if uint::bits == 32 {\n             rng.next() as uint\n@@ -97,43 +103,50 @@ impl Rand for uint {\n }\n \n impl Rand for u8 {\n+    #[inline]\n     fn rand<R: Rng>(rng: &R) -> u8 {\n         rng.next() as u8\n     }\n }\n \n impl Rand for u16 {\n+    #[inline]\n     fn rand<R: Rng>(rng: &R) -> u16 {\n         rng.next() as u16\n     }\n }\n \n impl Rand for u32 {\n+    #[inline]\n     fn rand<R: Rng>(rng: &R) -> u32 {\n         rng.next()\n     }\n }\n \n impl Rand for u64 {\n+    #[inline]\n     fn rand<R: Rng>(rng: &R) -> u64 {\n         (rng.next() as u64 << 32) | rng.next() as u64\n     }\n }\n \n impl Rand for float {\n+    #[inline]\n     fn rand<R: Rng>(rng: &R) -> float {\n         rng.gen::<f64>() as float\n     }\n }\n \n impl Rand for f32 {\n+    #[inline]\n     fn rand<R: Rng>(rng: &R) -> f32 {\n         rng.gen::<f64>() as f32\n     }\n }\n \n static scale : f64 = (u32::max_value as f64) + 1.0f64;\n impl Rand for f64 {\n+    #[inline]\n     fn rand<R: Rng>(rng: &R) -> f64 {\n         let u1 = rng.next() as f64;\n         let u2 = rng.next() as f64;\n@@ -144,12 +157,14 @@ impl Rand for f64 {\n }\n \n impl Rand for char {\n+    #[inline]\n     fn rand<R: Rng>(rng: &R) -> char {\n         rng.next() as char\n     }\n }\n \n impl Rand for bool {\n+    #[inline]\n     fn rand<R: Rng>(rng: &R) -> bool {\n         rng.next() & 1u32 == 1u32\n     }\n@@ -163,6 +178,7 @@ macro_rules! tuple_impl {\n             $( $tyvar : Rand ),*\n             > Rand for ( $( $tyvar ),* , ) {\n \n+            #[inline]\n             fn rand<R: Rng>(_rng: &R) -> ( $( $tyvar ),* , ) {\n                 (\n                     // use the $tyvar's to get the appropriate number of\n@@ -177,7 +193,10 @@ macro_rules! tuple_impl {\n     }\n }\n \n-impl Rand for () { fn rand<R: Rng>(_: &R) -> () { () } }\n+impl Rand for () {\n+    #[inline]\n+    fn rand<R: Rng>(_: &R) -> () { () }\n+}\n tuple_impl!{A}\n tuple_impl!{A, B}\n tuple_impl!{A, B, C}\n@@ -190,6 +209,7 @@ tuple_impl!{A, B, C, D, E, F, G, H, I}\n tuple_impl!{A, B, C, D, E, F, G, H, I, J}\n \n impl<T:Rand> Rand for Option<T> {\n+    #[inline]\n     fn rand<R: Rng>(rng: &R) -> Option<T> {\n         if rng.gen() {\n             Some(rng.gen())\n@@ -200,10 +220,12 @@ impl<T:Rand> Rand for Option<T> {\n }\n \n impl<T: Rand> Rand for ~T {\n+    #[inline]\n     fn rand<R: Rng>(rng: &R) -> ~T { ~rng.gen() }\n }\n \n impl<T: Rand> Rand for @T {\n+    #[inline]\n     fn rand<R: Rng>(rng: &R) -> @T { @rng.gen() }\n }\n \n@@ -413,6 +435,7 @@ pub trait RngUtil {\n /// Extension methods for random number generators\n impl<R: Rng> RngUtil for R {\n     /// Return a random value for a Rand type\n+    #[inline(always)]\n     fn gen<T: Rand>(&self) -> T {\n         Rand::rand(self)\n     }\n@@ -675,6 +698,7 @@ pub impl IsaacRng {\n     }\n \n     /// Refills the output buffer (`self.rsl`)\n+    #[inline]\n     priv fn isaac(&self) {\n         self.c += 1;\n         // abbreviations\n@@ -731,6 +755,9 @@ impl Rng for IsaacRng {\n     }\n }\n \n+/// An [Xorshift random number\n+/// generator](http://en.wikipedia.org/wiki/Xorshift). Not suitable for\n+/// cryptographic purposes.\n pub struct XorShiftRng {\n     priv mut x: u32,\n     priv mut y: u32,\n@@ -739,6 +766,7 @@ pub struct XorShiftRng {\n }\n \n impl Rng for XorShiftRng {\n+    #[inline]\n     pub fn next(&self) -> u32 {\n         let x = self.x;\n         let t = x ^ (x << 11);\n@@ -788,6 +816,7 @@ fn tls_rng_state(_v: @IsaacRng) {}\n  * seeded by the system. Intended to be used in method chaining style, ie\n  * `task_rng().gen::<int>()`.\n  */\n+#[inline]\n pub fn task_rng() -> @IsaacRng {\n     let r : Option<@IsaacRng>;\n     unsafe {\n@@ -807,13 +836,15 @@ pub fn task_rng() -> @IsaacRng {\n \n // Allow direct chaining with `task_rng`\n impl<R: Rng> Rng for @R {\n+    #[inline(always)]\n     fn next(&self) -> u32 { (**self).next() }\n }\n \n /**\n  * Returns a random value of a Rand type, using the task's random number\n  * generator.\n  */\n+#[inline]\n pub fn random<T: Rand>() -> T {\n     task_rng().gen()\n }"}]}