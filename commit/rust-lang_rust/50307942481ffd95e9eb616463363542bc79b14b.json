{"sha": "50307942481ffd95e9eb616463363542bc79b14b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwMzA3OTQyNDgxZmZkOTVlOWViNjE2NDYzMzYzNTQyYmM3OWIxNGI=", "commit": {"author": {"name": "Axary", "email": "bastian_kauschke@hotmail.de", "date": "2018-11-11T09:41:49Z"}, "committer": {"name": "Axary", "email": "bastian_kauschke@hotmail.de", "date": "2018-11-11T09:41:49Z"}, "message": "Merge branch 'master' of https://github.com/rust-lang/rust", "tree": {"sha": "4088a496090b024effdae0ed3beb24791225be46", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4088a496090b024effdae0ed3beb24791225be46"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/50307942481ffd95e9eb616463363542bc79b14b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/50307942481ffd95e9eb616463363542bc79b14b", "html_url": "https://github.com/rust-lang/rust/commit/50307942481ffd95e9eb616463363542bc79b14b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/50307942481ffd95e9eb616463363542bc79b14b/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "852ff1fc7d74a7668441e0f354f8c477c95b676d", "url": "https://api.github.com/repos/rust-lang/rust/commits/852ff1fc7d74a7668441e0f354f8c477c95b676d", "html_url": "https://github.com/rust-lang/rust/commit/852ff1fc7d74a7668441e0f354f8c477c95b676d"}, {"sha": "b76ee83254ec0398da554f25c2168d917ba60f1c", "url": "https://api.github.com/repos/rust-lang/rust/commits/b76ee83254ec0398da554f25c2168d917ba60f1c", "html_url": "https://github.com/rust-lang/rust/commit/b76ee83254ec0398da554f25c2168d917ba60f1c"}], "stats": {"total": 2376, "additions": 1483, "deletions": 893}, "files": [{"sha": "2ac51263cb5ca05644dcd816dad2923192b3264f", "filename": "src/Cargo.lock", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -197,7 +197,8 @@ dependencies = [\n  \"crates-io 0.21.0\",\n  \"crossbeam-utils 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"crypto-hash 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"curl 0.4.18 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"curl 0.4.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"curl-sys 0.4.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"env_logger 0.5.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"failure 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"filetime 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -230,7 +231,7 @@ dependencies = [\n  \"serde_ignored 0.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.31 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"shell-escape 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"tar 0.4.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"tar 0.4.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"tempfile 3.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"termcolor 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"toml 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -474,7 +475,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n name = \"crates-io\"\n version = \"0.21.0\"\n dependencies = [\n- \"curl 0.4.18 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"curl 0.4.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"failure 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde 1.0.75 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_derive 1.0.75 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -561,10 +562,10 @@ dependencies = [\n \n [[package]]\n name = \"curl\"\n-version = \"0.4.18\"\n+version = \"0.4.19\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"curl-sys 0.4.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"curl-sys 0.4.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.43 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"openssl-probe 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -576,7 +577,7 @@ dependencies = [\n \n [[package]]\n name = \"curl-sys\"\n-version = \"0.4.13\"\n+version = \"0.4.15\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"cc 1.0.25 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -848,7 +849,7 @@ name = \"git2-curl\"\n version = \"0.8.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"curl 0.4.18 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"curl 0.4.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"git2 0.7.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"url 1.7.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -966,7 +967,7 @@ dependencies = [\n  \"flate2 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rayon 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"tar 0.4.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"tar 0.4.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"walkdir 2.2.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"xz2 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1088,7 +1089,7 @@ version = \"0.7.10\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"cc 1.0.25 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"curl-sys 0.4.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"curl-sys 0.4.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.43 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libssh2-sys 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libz-sys 1.0.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -2095,6 +2096,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_cratesio_shim 0.0.0\",\n+ \"smallvec 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -2838,7 +2840,7 @@ dependencies = [\n \n [[package]]\n name = \"tar\"\n-version = \"0.4.16\"\n+version = \"0.4.19\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"filetime 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -3210,8 +3212,8 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum crossbeam-utils 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2760899e32a1d58d5abb31129f8fae5de75220bc2176e77ff7c627ae45c918d9\"\n \"checksum crossbeam-utils 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"677d453a17e8bd2b913fa38e8b9cf04bcdbb5be790aa294f2389661d72036015\"\n \"checksum crypto-hash 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"09de9ee0fc255ace04c7fa0763c9395a945c37c8292bb554f8d48361d1dcf1b4\"\n-\"checksum curl 0.4.18 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a9e5285b49b44401518c947d3b808d14d99a538a6c9ffb3ec0205c11f9fc4389\"\n-\"checksum curl-sys 0.4.13 (registry+https://github.com/rust-lang/crates.io-index)\" = \"08459503c415173da1ce6b41036a37b8bfdd86af46d45abb9964d4c61fe670ef\"\n+\"checksum curl 0.4.19 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c7c9d851c825e0c033979d4516c9173bc19a78a96eb4d6ae51d4045440eafa16\"\n+\"checksum curl-sys 0.4.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"721c204978be2143fab0a84b708c49d79d1f6100b8785610f456043a90708870\"\n \"checksum datafrog 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"16d724bf4ffe77cdceeecd461009b5f8d9e23c5d645d68bedb4586bf43e7e142\"\n \"checksum derive-new 0.5.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ceed73957c449214f8440eec8ad7fa282b67dc9eacbb24a3085b15d60397a17a\"\n \"checksum derive_more 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"46c7f14685a20f5dd08e7f754f2ea8cc064d8f4214ae21116c106a2768ba7b9b\"\n@@ -3390,7 +3392,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum syn 0.14.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"261ae9ecaa397c42b960649561949d69311f08eeaea86a65696e6e46517cf741\"\n \"checksum synom 0.11.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a393066ed9010ebaed60b9eafa373d4b1baac186dd7e008555b0f702b51945b6\"\n \"checksum synstructure 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"85bb9b7550d063ea184027c9b8c20ac167cd36d3e06b3a40bceb9d746dc1a7b7\"\n-\"checksum tar 0.4.16 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e8f41ca4a5689f06998f0247fcb60da6c760f1950cc9df2a10d71575ad0b062a\"\n+\"checksum tar 0.4.19 (registry+https://github.com/rust-lang/crates.io-index)\" = \"69e16840a1e0a1f1a880b739ef1cc6a4b85496c99b8aa786ccffce6e0c15624c\"\n \"checksum tempfile 3.0.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c4b103c6d08d323b92ff42c8ce62abcd83ca8efa7fd5bf7927efefec75f58c76\"\n \"checksum tendril 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9de21546595a0873061940d994bbbc5c35f024ae4fd61ec5c5b159115684f508\"\n \"checksum term 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5e6b677dd1e8214ea1ef4297f85dbcbed8e8cdddb561040cc998ca2551c37561\""}, {"sha": "bb52d7990ff5772fdc27c821ee3c730896af9630", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -672,14 +672,16 @@ impl<T: ?Sized> Rc<T> {\n         // Previously, layout was calculated on the expression\n         // `&*(ptr as *const RcBox<T>)`, but this created a misaligned\n         // reference (see #54908).\n-        let (layout, _) = Layout::new::<RcBox<()>>()\n-            .extend(Layout::for_value(&*ptr)).unwrap();\n+        let layout = Layout::new::<RcBox<()>>()\n+            .extend(Layout::for_value(&*ptr)).unwrap().0\n+            .pad_to_align().unwrap();\n \n         let mem = Global.alloc(layout)\n             .unwrap_or_else(|_| handle_alloc_error(layout));\n \n         // Initialize the RcBox\n         let inner = set_data_ptr(ptr as *mut T, mem.as_ptr() as *mut u8) as *mut RcBox<T>;\n+        debug_assert_eq!(Layout::for_value(&*inner), layout);\n \n         ptr::write(&mut (*inner).strong, Cell::new(1));\n         ptr::write(&mut (*inner).weak, Cell::new(1));"}, {"sha": "b63b3684964bb64038366cf6d12365614a99c2a9", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -575,14 +575,16 @@ impl<T: ?Sized> Arc<T> {\n         // Previously, layout was calculated on the expression\n         // `&*(ptr as *const ArcInner<T>)`, but this created a misaligned\n         // reference (see #54908).\n-        let (layout, _) = Layout::new::<ArcInner<()>>()\n-            .extend(Layout::for_value(&*ptr)).unwrap();\n+        let layout = Layout::new::<ArcInner<()>>()\n+            .extend(Layout::for_value(&*ptr)).unwrap().0\n+            .pad_to_align().unwrap();\n \n         let mem = Global.alloc(layout)\n             .unwrap_or_else(|_| handle_alloc_error(layout));\n \n         // Initialize the ArcInner\n         let inner = set_data_ptr(ptr as *mut T, mem.as_ptr() as *mut u8) as *mut ArcInner<T>;\n+        debug_assert_eq!(Layout::for_value(&*inner), layout);\n \n         ptr::write(&mut (*inner).strong, atomic::AtomicUsize::new(1));\n         ptr::write(&mut (*inner).weak, atomic::AtomicUsize::new(1));"}, {"sha": "58639808faedbfc5c3e28fe2e73ad1b0d8cb6838", "filename": "src/libcore/alloc.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibcore%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibcore%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -218,6 +218,23 @@ impl Layout {\n         len_rounded_up.wrapping_sub(len)\n     }\n \n+    /// Creates a layout by rounding the size of this layout up to a multiple\n+    /// of the layout's alignment.\n+    ///\n+    /// Returns `Err` if the padded size would overflow.\n+    ///\n+    /// This is equivalent to adding the result of `padding_needed_for`\n+    /// to the layout's current size.\n+    #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n+    #[inline]\n+    pub fn pad_to_align(&self) -> Result<Layout, LayoutErr> {\n+        let pad = self.padding_needed_for(self.align());\n+        let new_size = self.size().checked_add(pad)\n+            .ok_or(LayoutErr { private: () })?;\n+\n+        Layout::from_size_align(new_size, self.align())\n+    }\n+\n     /// Creates a layout describing the record for `n` instances of\n     /// `self`, with a suitable amount of padding between each to\n     /// ensure that each instance is given its requested size and\n@@ -506,7 +523,7 @@ pub unsafe trait GlobalAlloc {\n         ptr\n     }\n \n-    /// Shink or grow a block of memory to the given `new_size`.\n+    /// Shrink or grow a block of memory to the given `new_size`.\n     /// The block is described by the given `ptr` pointer and `layout`.\n     ///\n     /// If this returns a non-null pointer, then ownership of the memory block\n@@ -757,7 +774,7 @@ pub unsafe trait Alloc {\n     // realloc. alloc_excess, realloc_excess\n \n     /// Returns a pointer suitable for holding data described by\n-    /// a new layout with `layout`\u2019s alginment and a size given\n+    /// a new layout with `layout`\u2019s alignment and a size given\n     /// by `new_size`. To\n     /// accomplish this, this may extend or shrink the allocation\n     /// referenced by `ptr` to fit the new layout."}, {"sha": "0c870f9e404a26ca59147ea840bb30760bb16a67", "filename": "src/libcore/future/future.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibcore%2Ffuture%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibcore%2Ffuture%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Ffuture.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -17,7 +17,7 @@ use ops;\n use pin::Pin;\n use task::{Poll, LocalWaker};\n \n-/// A future represents an asychronous computation.\n+/// A future represents an asynchronous computation.\n ///\n /// A future is a value that may not have finished computing yet. This kind of\n /// \"asynchronous value\" makes it possible for a thread to continue doing useful"}, {"sha": "7ed6e4a8f51eb1ea2e3913c7b0cf4d5f5daff44e", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -1465,6 +1465,20 @@ extern \"rust-intrinsic\" {\n     /// y < 0 or y >= N, where N is the width of T in bits.\n     pub fn unchecked_shr<T>(x: T, y: T) -> T;\n \n+    /// Performs rotate left.\n+    /// The stabilized versions of this intrinsic are available on the integer\n+    /// primitives via the `rotate_left` method. For example,\n+    /// [`std::u32::rotate_left`](../../std/primitive.u32.html#method.rotate_left)\n+    #[cfg(not(stage0))]\n+    pub fn rotate_left<T>(x: T, y: T) -> T;\n+\n+    /// Performs rotate right.\n+    /// The stabilized versions of this intrinsic are available on the integer\n+    /// primitives via the `rotate_right` method. For example,\n+    /// [`std::u32::rotate_right`](../../std/primitive.u32.html#method.rotate_right)\n+    #[cfg(not(stage0))]\n+    pub fn rotate_right<T>(x: T, y: T) -> T;\n+\n     /// Returns (a + b) mod 2<sup>N</sup>, where N is the width of T in bits.\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `wrapping_add` method. For example,"}, {"sha": "c69d4441121ce9d9f6ad72e6403bec7e2929be4a", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -228,7 +228,7 @@ mod nonzero;\n mod tuple;\n mod unit;\n \n-// Pull in the the `coresimd` crate directly into libcore. This is where all the\n+// Pull in the `coresimd` crate directly into libcore. This is where all the\n // architecture-specific (and vendor-specific) intrinsics are defined. AKA\n // things like SIMD and such. Note that the actual source for all this lies in a\n // different repository, rust-lang-nursery/stdsimd. That's why the setup here is"}, {"sha": "c008b78e4509292810c8416d293b573bf15773fd", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -350,9 +350,8 @@ macro_rules! try {\n /// assert_eq!(v, b\"s = \\\"abc 123\\\"\");\n /// ```\n ///\n-/// Note: This macro can be used in `no_std` setups as well\n-/// In a `no_std` setup you are responsible for the\n-/// implementation details of the components.\n+/// Note: This macro can be used in `no_std` setups as well.\n+/// In a `no_std` setup you are responsible for the implementation details of the components.\n ///\n /// ```no_run\n /// # extern crate core;\n@@ -440,7 +439,7 @@ macro_rules! writeln {\n ///\n /// If the determination that the code is unreachable proves incorrect, the\n /// program immediately terminates with a [`panic!`].  The function [`unreachable_unchecked`],\n-/// which belongs to the [`std::hint`] module, informs the compilier to\n+/// which belongs to the [`std::hint`] module, informs the compiler to\n /// optimize the code out of the release version entirely.\n ///\n /// [`panic!`]:  ../std/macro.panic.html"}, {"sha": "8c4ff02aa140f65afec7d23c05edfee71287d46f", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -202,7 +202,7 @@ pub fn forget<T>(t: T) {\n ///\n /// ## Size of Enums\n ///\n-/// Enums that carry no data other than the descriminant have the same size as C enums\n+/// Enums that carry no data other than the discriminant have the same size as C enums\n /// on the platform they are compiled for.\n ///\n /// ## Size of Unions\n@@ -1081,7 +1081,7 @@ impl<T> MaybeUninit<T> {\n     ///\n     /// # Unsafety\n     ///\n-    /// It is up to the caller to guarantee that the the `MaybeUninit` really is in an initialized\n+    /// It is up to the caller to guarantee that the `MaybeUninit` really is in an initialized\n     /// state, otherwise this will immediately cause undefined behavior.\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n     pub unsafe fn into_inner(self) -> T {\n@@ -1092,7 +1092,7 @@ impl<T> MaybeUninit<T> {\n     ///\n     /// # Unsafety\n     ///\n-    /// It is up to the caller to guarantee that the the `MaybeUninit` really is in an initialized\n+    /// It is up to the caller to guarantee that the `MaybeUninit` really is in an initialized\n     /// state, otherwise this will immediately cause undefined behavior.\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n     pub unsafe fn get_ref(&self) -> &T {\n@@ -1103,7 +1103,7 @@ impl<T> MaybeUninit<T> {\n     ///\n     /// # Unsafety\n     ///\n-    /// It is up to the caller to guarantee that the the `MaybeUninit` really is in an initialized\n+    /// It is up to the caller to guarantee that the `MaybeUninit` really is in an initialized\n     /// state, otherwise this will immediately cause undefined behavior.\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n     pub unsafe fn get_mut(&mut self) -> &mut T {"}, {"sha": "30b7b4546841268750052647cabb30bec85a7ee2", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -2152,6 +2152,7 @@ Basic usage:\n \", $Feature, \"assert_eq!(\", stringify!($SelfT), \"::min_value(), 0);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_promotable]\n             #[inline]\n             pub const fn min_value() -> Self { 0 }\n         }\n@@ -2168,6 +2169,7 @@ Basic usage:\n stringify!($MaxV), \");\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_promotable]\n             #[inline]\n             pub const fn max_value() -> Self { !0 }\n         }\n@@ -2301,7 +2303,12 @@ assert_eq!(n.rotate_left(\", $rot, \"), m);\n             #[rustc_const_unstable(feature = \"const_int_rotate\")]\n             #[inline]\n             pub const fn rotate_left(self, n: u32) -> Self {\n-                (self << (n % $BITS)) | (self >> (($BITS - (n % $BITS)) % $BITS))\n+                #[cfg(not(stage0))] {\n+                    unsafe { intrinsics::rotate_left(self, n as $SelfT) }\n+                }\n+                #[cfg(stage0)] {\n+                    (self << (n % $BITS)) | (self >> (($BITS - (n % $BITS)) % $BITS))\n+                }\n             }\n         }\n \n@@ -2326,7 +2333,12 @@ assert_eq!(n.rotate_right(\", $rot, \"), m);\n             #[rustc_const_unstable(feature = \"const_int_rotate\")]\n             #[inline]\n             pub const fn rotate_right(self, n: u32) -> Self {\n-                (self >> (n % $BITS)) | (self << (($BITS - (n % $BITS)) % $BITS))\n+                #[cfg(not(stage0))] {\n+                    unsafe { intrinsics::rotate_right(self, n as $SelfT) }\n+                }\n+                #[cfg(stage0)] {\n+                    (self >> (n % $BITS)) | (self << (($BITS - (n % $BITS)) % $BITS))\n+                }\n             }\n         }\n "}, {"sha": "308dd9c79fa374391e1e222d379725c3c968f27d", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -3,7 +3,7 @@\n //! It is sometimes useful to have objects that are guaranteed to not move,\n //! in the sense that their placement in memory does not change, and can thus be relied upon.\n //!\n-//! A prime example of such a scenario would be building self-referencial structs,\n+//! A prime example of such a scenario would be building self-referential structs,\n //! since moving an object with pointers to itself will invalidate them,\n //! which could cause undefined behavior.\n //!\n@@ -39,7 +39,7 @@\n //! use std::marker::Pinned;\n //! use std::ptr::NonNull;\n //!\n-//! // This is a self referencial struct since the slice field points to the data field.\n+//! // This is a self-referential struct since the slice field points to the data field.\n //! // We cannot inform the compiler about that with a normal reference,\n //! // since this pattern cannot be described with the usual borrowing rules.\n //! // Instead we use a raw pointer, though one which is known to not be null,"}, {"sha": "827e297c84d1f427918508b885a71395a50884f9", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -120,7 +120,7 @@ pub use intrinsics::write_bytes;\n ///\n /// Additionally, if `T` is not [`Copy`], using the pointed-to value after\n /// calling `drop_in_place` can cause undefined behavior. Note that `*to_drop =\n-/// foo` counts as a use because it will cause the the value to be dropped\n+/// foo` counts as a use because it will cause the value to be dropped\n /// again. [`write`] can be used to overwrite data without causing it to be\n /// dropped.\n ///\n@@ -371,7 +371,7 @@ pub(crate) unsafe fn swap_nonoverlapping_one<T>(x: *mut T, y: *mut T) {\n #[inline]\n unsafe fn swap_nonoverlapping_bytes(x: *mut u8, y: *mut u8, len: usize) {\n     // The approach here is to utilize simd to swap x & y efficiently. Testing reveals\n-    // that swapping either 32 bytes or 64 bytes at a time is most efficient for intel\n+    // that swapping either 32 bytes or 64 bytes at a time is most efficient for Intel\n     // Haswell E processors. LLVM is more able to optimize if we give a struct a\n     // #[repr(simd)], even if we don't actually use this struct directly.\n     //\n@@ -1005,7 +1005,7 @@ impl<T: ?Sized> *const T {\n     /// # Null-unchecked version\n     ///\n     /// If you are sure the pointer can never be null and are looking for some kind of\n-    /// `as_ref_unchecked` that returns the `&T` instead of `Option<&T>, know that you can\n+    /// `as_ref_unchecked` that returns the `&T` instead of `Option<&T>`, know that you can\n     /// dereference the pointer directly.\n     ///\n     /// ```\n@@ -1625,7 +1625,7 @@ impl<T: ?Sized> *mut T {\n     /// # Null-unchecked version\n     ///\n     /// If you are sure the pointer can never be null and are looking for some kind of\n-    /// `as_ref_unchecked` that returns the `&T` instead of `Option<&T>, know that you can\n+    /// `as_ref_unchecked` that returns the `&T` instead of `Option<&T>`, know that you can\n     /// dereference the pointer directly.\n     ///\n     /// ```"}, {"sha": "96590c1fc72d400c8724e663dd39598da5fad024", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -2134,7 +2134,7 @@ static X: u32 = 42;\n \n \n register_diagnostics! {\n-//  E0006 // merged with E0005\n+//  E0006, // merged with E0005\n //  E0101, // replaced with E0282\n //  E0102, // replaced with E0282\n //  E0134,\n@@ -2183,9 +2183,7 @@ register_diagnostics! {\n     E0657, // `impl Trait` can only capture lifetimes bound at the fn level\n     E0687, // in-band lifetimes cannot be used in `fn`/`Fn` syntax\n     E0688, // in-band lifetimes cannot be mixed with explicit lifetime binders\n-\n     E0697, // closures cannot be static\n-\n     E0707, // multiple elided lifetimes used in arguments of `async fn`\n     E0708, // `async` non-`move` closures with arguments are not currently supported\n     E0709, // multiple different lifetimes used in arguments of `async fn`"}, {"sha": "f57e3ff913b38dd407a7b856fde7093c2281edc4", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -506,9 +506,9 @@ pub enum TraitBoundModifier {\n }\n \n /// The AST represents all type param bounds as types.\n-/// typeck::collect::compute_bounds matches these against\n-/// the \"special\" built-in traits (see middle::lang_items) and\n-/// detects Copy, Send and Sync.\n+/// `typeck::collect::compute_bounds` matches these against\n+/// the \"special\" built-in traits (see `middle::lang_items`) and\n+/// detects `Copy`, `Send` and `Sync`.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub enum GenericBound {\n     Trait(PolyTraitRef, TraitBoundModifier),"}, {"sha": "cc73dd63816aa466b4b75c1eaab89f59e65c120f", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -366,7 +366,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         let mut types = vec![concrete_ty];\n         let bound_region = |r| self.sub_regions(infer::CallReturn(span), least_region, r);\n         while let Some(ty) = types.pop() {\n-            let mut components = self.tcx.outlives_components(ty);\n+            let mut components = smallvec![];\n+            self.tcx.push_outlives_components(ty, &mut components);\n             while let Some(component) = components.pop() {\n                 match component {\n                     Component::Region(r) => {"}, {"sha": "f2825887f36e2d28dae70de54776647af151f6ee", "filename": "src/librustc/infer/outlives/obligations.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n //! Code that handles \"type-outlives\" constraints like `T: 'a`. This\n-//! is based on the `outlives_components` function defined on the tcx,\n+//! is based on the `push_outlives_components` function defined on the tcx,\n //! but it adds a bit of heuristics on top, in particular to deal with\n //! associated types and projections.\n //!\n@@ -307,31 +307,32 @@ where\n \n         assert!(!ty.has_escaping_bound_vars());\n \n-        let components = self.tcx.outlives_components(ty);\n-        self.components_must_outlive(origin, components, region);\n+        let mut components = smallvec![];\n+        self.tcx.push_outlives_components(ty, &mut components);\n+        self.components_must_outlive(origin, &components, region);\n     }\n \n     fn components_must_outlive(\n         &mut self,\n         origin: infer::SubregionOrigin<'tcx>,\n-        components: Vec<Component<'tcx>>,\n+        components: &[Component<'tcx>],\n         region: ty::Region<'tcx>,\n     ) {\n-        for component in components {\n+        for component in components.iter() {\n             let origin = origin.clone();\n             match component {\n                 Component::Region(region1) => {\n                     self.delegate\n                         .push_sub_region_constraint(origin, region, region1);\n                 }\n                 Component::Param(param_ty) => {\n-                    self.param_ty_must_outlive(origin, region, param_ty);\n+                    self.param_ty_must_outlive(origin, region, *param_ty);\n                 }\n                 Component::Projection(projection_ty) => {\n-                    self.projection_must_outlive(origin, region, projection_ty);\n+                    self.projection_must_outlive(origin, region, *projection_ty);\n                 }\n                 Component::EscapingProjection(subcomponents) => {\n-                    self.components_must_outlive(origin, subcomponents, region);\n+                    self.components_must_outlive(origin, &subcomponents, region);\n                 }\n                 Component::UnresolvedInferenceVariable(v) => {\n                     // ignore this, we presume it will yield an error"}, {"sha": "a7a79dd2e6560e6113407cfdb3c1fef2dc9f5971", "filename": "src/librustc/infer/outlives/verify.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -155,7 +155,8 @@ impl<'cx, 'gcx, 'tcx> VerifyBoundCx<'cx, 'gcx, 'tcx> {\n             .map(|subty| self.type_bound(subty))\n             .collect::<Vec<_>>();\n \n-        let mut regions = ty.regions();\n+        let mut regions = smallvec![];\n+        ty.push_regions(&mut regions);\n         regions.retain(|r| !r.is_late_bound()); // ignore late-bound regions\n         bounds.push(VerifyBound::AllBounds(\n             regions"}, {"sha": "01d87bdbf63374ff4b38e86f077bd8444c38fdfd", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -300,12 +300,6 @@ declare_lint! {\n     \"detects labels that are never used\"\n }\n \n-declare_lint! {\n-    pub DUPLICATE_ASSOCIATED_TYPE_BINDINGS,\n-    Warn,\n-    \"warns about duplicate associated type bindings in generics\"\n-}\n-\n declare_lint! {\n     pub DUPLICATE_MACRO_EXPORTS,\n     Deny,\n@@ -418,7 +412,6 @@ impl LintPass for HardwiredLints {\n             ABSOLUTE_PATHS_NOT_STARTING_WITH_CRATE,\n             UNSTABLE_NAME_COLLISIONS,\n             IRREFUTABLE_LET_PATTERNS,\n-            DUPLICATE_ASSOCIATED_TYPE_BINDINGS,\n             DUPLICATE_MACRO_EXPORTS,\n             INTRA_DOC_LINK_RESOLUTION_FAILURE,\n             MISSING_DOC_CODE_EXAMPLES,"}, {"sha": "f773f46b6f58cd0d3b98c6065ab2e6b54372db7e", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -80,19 +80,21 @@ impl<'a, 'gcx, 'tcx> PlaceTy<'tcx> {\n                          elem: &PlaceElem<'tcx>)\n                          -> PlaceTy<'tcx>\n     {\n-        self.projection_ty_core(tcx, elem, |_, _, ty| ty)\n+        self.projection_ty_core(tcx, elem, |_, _, ty| -> Result<Ty<'tcx>, ()> { Ok(ty) })\n+            .unwrap()\n     }\n \n     /// `place_ty.projection_ty_core(tcx, elem, |...| { ... })`\n     /// projects `place_ty` onto `elem`, returning the appropriate\n     /// `Ty` or downcast variant corresponding to that projection.\n     /// The `handle_field` callback must map a `Field` to its `Ty`,\n     /// (which should be trivial when `T` = `Ty`).\n-    pub fn projection_ty_core<V, T>(self,\n-                                    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                    elem: &ProjectionElem<'tcx, V, T>,\n-                                    mut handle_field: impl FnMut(&Self, &Field, &T) -> Ty<'tcx>)\n-                                    -> PlaceTy<'tcx>\n+    pub fn projection_ty_core<V, T, E>(\n+        self,\n+        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        elem: &ProjectionElem<'tcx, V, T>,\n+        mut handle_field: impl FnMut(&Self, &Field, &T) -> Result<Ty<'tcx>, E>)\n+        -> Result<PlaceTy<'tcx>, E>\n     where\n         V: ::std::fmt::Debug, T: ::std::fmt::Debug\n     {\n@@ -142,10 +144,11 @@ impl<'a, 'gcx, 'tcx> PlaceTy<'tcx> {\n                         bug!(\"cannot downcast non-ADT type: `{:?}`\", self)\n                     }\n                 },\n-            ProjectionElem::Field(ref f, ref fty) => PlaceTy::Ty { ty: handle_field(&self, f, fty) }\n+            ProjectionElem::Field(ref f, ref fty) =>\n+                PlaceTy::Ty { ty: handle_field(&self, f, fty)? },\n         };\n         debug!(\"projection_ty self: {:?} elem: {:?} yields: {:?}\", self, elem, answer);\n-        answer\n+        Ok(answer)\n     }\n }\n "}, {"sha": "efd7e8b610efc787290e7b977c9e81b95f507951", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -963,6 +963,10 @@ impl Session {\n         self.opts.debugging_opts.teach && self.diagnostic().must_teach(code)\n     }\n \n+    pub fn rust_2015(&self) -> bool {\n+        self.opts.edition == Edition::Edition2015\n+    }\n+\n     /// Are we allowed to use features from the Rust 2018 edition?\n     pub fn rust_2018(&self) -> bool {\n         self.opts.edition >= Edition::Edition2018"}, {"sha": "33b689c60a1188dad35d27597bbe23a67b77ce53", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -50,11 +50,8 @@ pub use self::select::{EvaluationResult, IntercrateAmbiguityCause, OverflowError\n pub use self::specialize::{OverlapError, specialization_graph, translate_substs};\n pub use self::specialize::find_associated_item;\n pub use self::engine::{TraitEngine, TraitEngineExt};\n-pub use self::util::elaborate_predicates;\n-pub use self::util::supertraits;\n-pub use self::util::Supertraits;\n-pub use self::util::supertrait_def_ids;\n-pub use self::util::SupertraitDefIds;\n+pub use self::util::{elaborate_predicates, elaborate_trait_ref, elaborate_trait_refs};\n+pub use self::util::{supertraits, supertrait_def_ids, Supertraits, SupertraitDefIds};\n pub use self::util::transitive_bounds;\n \n #[allow(dead_code)]"}, {"sha": "b59bd0e2388737085ad0cf6d4925c1556f78a943", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -885,7 +885,7 @@ fn project_type<'cx, 'gcx, 'tcx>(\n     let recursion_limit = *selcx.tcx().sess.recursion_limit.get();\n     if obligation.recursion_depth >= recursion_limit {\n         debug!(\"project: overflow!\");\n-        selcx.infcx().report_overflow_error(&obligation, true);\n+        return Err(ProjectionTyError::TraitSelectionError(SelectionError::Overflow));\n     }\n \n     let obligation_trait_ref = &obligation.predicate.trait_ref(selcx.tcx());"}, {"sha": "3a882506b41d6520e90921c0267f3752f75705b4", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -200,8 +200,10 @@ impl<'cx, 'gcx, 'tcx> Elaborator<'cx, 'gcx, 'tcx> {\n                 }\n \n                 let visited = &mut self.visited;\n+                let mut components = smallvec![];\n+                tcx.push_outlives_components(ty_max, &mut components);\n                 self.stack.extend(\n-                    tcx.outlives_components(ty_max)\n+                    components\n                        .into_iter()\n                        .filter_map(|component| match component {\n                            Component::Region(r) => if r.is_late_bound() {\n@@ -333,7 +335,7 @@ impl<I> FilterToTraits<I> {\n     }\n }\n \n-impl<'tcx,I:Iterator<Item = ty::Predicate<'tcx>>> Iterator for FilterToTraits<I> {\n+impl<'tcx, I: Iterator<Item = ty::Predicate<'tcx>>> Iterator for FilterToTraits<I> {\n     type Item = ty::PolyTraitRef<'tcx>;\n \n     fn next(&mut self) -> Option<ty::PolyTraitRef<'tcx>> {"}, {"sha": "82095a2f5b01de7cc6031f5e068ee7db5e8c4395", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -17,7 +17,7 @@ use session::Session;\n use session::config::{BorrowckMode, OutputFilenames};\n use session::config::CrateType;\n use middle;\n-use hir::{TraitCandidate, HirId, ItemLocalId, Node};\n+use hir::{TraitCandidate, HirId, ItemKind, ItemLocalId, Node};\n use hir::def::{Def, Export};\n use hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE};\n use hir::map as hir_map;\n@@ -1602,6 +1602,20 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         &self,\n         scope_def_id: DefId,\n     ) -> Option<Ty<'tcx>> {\n+        // HACK: `type_of_def_id()` will fail on these (#55796), so return None\n+        let node_id = self.hir.as_local_node_id(scope_def_id).unwrap();\n+        match self.hir.get(node_id) {\n+            Node::Item(item) => {\n+                match item.node {\n+                    ItemKind::Fn(..) => { /* type_of_def_id() will work */ }\n+                    _ => {\n+                        return None;\n+                    }\n+                }\n+            }\n+            _ => { /* type_of_def_id() will work or panic */ }\n+        }\n+\n         let ret_ty = self.type_of(scope_def_id);\n         match ret_ty.sty {\n             ty::FnDef(_, _) => {"}, {"sha": "ef9b3e3efab275f3421c3ea5eb9bcede113efa92", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 50, "deletions": 48, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -294,7 +294,7 @@ impl Visibility {\n         }\n     }\n \n-    /// Returns true if an item with this visibility is accessible from the given block.\n+    /// Returns `true` if an item with this visibility is accessible from the given block.\n     pub fn is_accessible_from<T: DefIdTree>(self, module: DefId, tree: T) -> bool {\n         let restriction = match self {\n             // Public items are visible everywhere.\n@@ -309,7 +309,7 @@ impl Visibility {\n         tree.is_descendant_of(module, restriction)\n     }\n \n-    /// Returns true if this visibility is at least as accessible as the given visibility\n+    /// Returns `true` if this visibility is at least as accessible as the given visibility\n     pub fn is_at_least<T: DefIdTree>(self, vis: Visibility, tree: T) -> bool {\n         let vis_restriction = match vis {\n             Visibility::Public => return self == Visibility::Public,\n@@ -320,7 +320,7 @@ impl Visibility {\n         self.is_accessible_from(vis_restriction, tree)\n     }\n \n-    // Returns true if this item is visible anywhere in the local crate.\n+    // Returns `true` if this item is visible anywhere in the local crate.\n     pub fn is_visible_locally(self) -> bool {\n         match self {\n             Visibility::Public => true,\n@@ -451,7 +451,7 @@ bitflags! {\n         // FIXME: Rename this to the actual property since it's used for generators too\n         const HAS_TY_CLOSURE     = 1 << 9;\n \n-        // true if there are \"names\" of types and regions and so forth\n+        // `true` if there are \"names\" of types and regions and so forth\n         // that are local to a particular fn\n         const HAS_FREE_LOCAL_NAMES    = 1 << 10;\n \n@@ -544,14 +544,14 @@ impl<'tcx> TyS<'tcx> {\n     pub fn is_primitive_ty(&self) -> bool {\n         match self.sty {\n             TyKind::Bool |\n-                TyKind::Char |\n-                TyKind::Int(_) |\n-                TyKind::Uint(_) |\n-                TyKind::Float(_) |\n-                TyKind::Infer(InferTy::IntVar(_)) |\n-                TyKind::Infer(InferTy::FloatVar(_)) |\n-                TyKind::Infer(InferTy::FreshIntTy(_)) |\n-                TyKind::Infer(InferTy::FreshFloatTy(_)) => true,\n+            TyKind::Char |\n+            TyKind::Int(_) |\n+            TyKind::Uint(_) |\n+            TyKind::Float(_) |\n+            TyKind::Infer(InferTy::IntVar(_)) |\n+            TyKind::Infer(InferTy::FloatVar(_)) |\n+            TyKind::Infer(InferTy::FreshIntTy(_)) |\n+            TyKind::Infer(InferTy::FreshFloatTy(_)) => true,\n             TyKind::Ref(_, x, _) => x.is_primitive_ty(),\n             _ => false,\n         }\n@@ -953,7 +953,7 @@ impl<'a, 'gcx, 'tcx> Generics {\n                 _ => bug!(\"expected lifetime parameter, but found another generic parameter\")\n             }\n         } else {\n-            tcx.generics_of(self.parent.expect(\"parent_count>0 but no parent?\"))\n+            tcx.generics_of(self.parent.expect(\"parent_count > 0 but no parent?\"))\n                .region_param(param, tcx)\n         }\n     }\n@@ -970,7 +970,7 @@ impl<'a, 'gcx, 'tcx> Generics {\n                 _ => bug!(\"expected type parameter, but found another generic parameter\")\n             }\n         } else {\n-            tcx.generics_of(self.parent.expect(\"parent_count>0 but no parent?\"))\n+            tcx.generics_of(self.parent.expect(\"parent_count > 0 but no parent?\"))\n                .type_param(param, tcx)\n         }\n     }\n@@ -993,6 +993,7 @@ impl<'a, 'gcx, 'tcx> GenericPredicates<'tcx> {\n         self.instantiate_into(tcx, &mut instantiated, substs);\n         instantiated\n     }\n+\n     pub fn instantiate_own(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, substs: &Substs<'tcx>)\n                            -> InstantiatedPredicates<'tcx> {\n         InstantiatedPredicates {\n@@ -1041,15 +1042,15 @@ impl<'a, 'gcx, 'tcx> GenericPredicates<'tcx> {\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub enum Predicate<'tcx> {\n-    /// Corresponds to `where Foo : Bar<A,B,C>`. `Foo` here would be\n+    /// Corresponds to `where Foo: Bar<A,B,C>`. `Foo` here would be\n     /// the `Self` type of the trait reference and `A`, `B`, and `C`\n     /// would be the type parameters.\n     Trait(PolyTraitPredicate<'tcx>),\n \n-    /// where `'a : 'b`\n+    /// where `'a: 'b`\n     RegionOutlives(PolyRegionOutlivesPredicate<'tcx>),\n \n-    /// where `T : 'a`\n+    /// where `T: 'a`\n     TypeOutlives(PolyTypeOutlivesPredicate<'tcx>),\n \n     /// where `<T as TraitRef>::Name == X`, approximately.\n@@ -1062,7 +1063,7 @@ pub enum Predicate<'tcx> {\n     /// trait must be object-safe\n     ObjectSafe(DefId),\n \n-    /// No direct syntax. May be thought of as `where T : FnFoo<...>`\n+    /// No direct syntax. May be thought of as `where T: FnFoo<...>`\n     /// for some substitutions `...` and `T` being a closure type.\n     /// Satisfied (or refuted) once we know the closure's kind.\n     ClosureKind(DefId, ClosureSubsts<'tcx>, ClosureKind),\n@@ -1111,11 +1112,11 @@ impl<'a, 'gcx, 'tcx> Predicate<'tcx> {\n         //\n         // Let's start with an easy case. Consider two traits:\n         //\n-        //     trait Foo<'a> : Bar<'a,'a> { }\n+        //     trait Foo<'a>: Bar<'a,'a> { }\n         //     trait Bar<'b,'c> { }\n         //\n-        // Now, if we have a trait reference `for<'x> T : Foo<'x>`, then\n-        // we can deduce that `for<'x> T : Bar<'x,'x>`. Basically, if we\n+        // Now, if we have a trait reference `for<'x> T: Foo<'x>`, then\n+        // we can deduce that `for<'x> T: Bar<'x,'x>`. Basically, if we\n         // knew that `Foo<'x>` (for any 'x) then we also know that\n         // `Bar<'x,'x>` (for any 'x). This more-or-less falls out from\n         // normal substitution.\n@@ -1128,21 +1129,21 @@ impl<'a, 'gcx, 'tcx> Predicate<'tcx> {\n         //\n         // Another example to be careful of is this:\n         //\n-        //     trait Foo1<'a> : for<'b> Bar1<'a,'b> { }\n+        //     trait Foo1<'a>: for<'b> Bar1<'a,'b> { }\n         //     trait Bar1<'b,'c> { }\n         //\n-        // Here, if we have `for<'x> T : Foo1<'x>`, then what do we know?\n-        // The answer is that we know `for<'x,'b> T : Bar1<'x,'b>`. The\n+        // Here, if we have `for<'x> T: Foo1<'x>`, then what do we know?\n+        // The answer is that we know `for<'x,'b> T: Bar1<'x,'b>`. The\n         // reason is similar to the previous example: any impl of\n-        // `T:Foo1<'x>` must show that `for<'b> T : Bar1<'x, 'b>`.  So\n+        // `T:Foo1<'x>` must show that `for<'b> T: Bar1<'x, 'b>`.  So\n         // basically we would want to collapse the bound lifetimes from\n         // the input (`trait_ref`) and the supertraits.\n         //\n         // To achieve this in practice is fairly straightforward. Let's\n         // consider the more complicated scenario:\n         //\n-        // - We start out with `for<'x> T : Foo1<'x>`. In this case, `'x`\n-        //   has a De Bruijn index of 1. We want to produce `for<'x,'b> T : Bar1<'x,'b>`,\n+        // - We start out with `for<'x> T: Foo1<'x>`. In this case, `'x`\n+        //   has a De Bruijn index of 1. We want to produce `for<'x,'b> T: Bar1<'x,'b>`,\n         //   where both `'x` and `'b` would have a DB index of 1.\n         //   The substitution from the input trait-ref is therefore going to be\n         //   `'a => 'x` (where `'x` has a DB index of 1).\n@@ -1194,6 +1195,7 @@ impl<'a, 'gcx, 'tcx> Predicate<'tcx> {\n pub struct TraitPredicate<'tcx> {\n     pub trait_ref: TraitRef<'tcx>\n }\n+\n pub type PolyTraitPredicate<'tcx> = ty::Binder<TraitPredicate<'tcx>>;\n \n impl<'tcx> TraitPredicate<'tcx> {\n@@ -1218,7 +1220,7 @@ impl<'tcx> PolyTraitPredicate<'tcx> {\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n-pub struct OutlivesPredicate<A,B>(pub A, pub B); // `A : B`\n+pub struct OutlivesPredicate<A,B>(pub A, pub B); // `A: B`\n pub type PolyOutlivesPredicate<A,B> = ty::Binder<OutlivesPredicate<A,B>>;\n pub type RegionOutlivesPredicate<'tcx> = OutlivesPredicate<ty::Region<'tcx>,\n                                                            ty::Region<'tcx>>;\n@@ -1238,11 +1240,11 @@ pub type PolySubtypePredicate<'tcx> = ty::Binder<SubtypePredicate<'tcx>>;\n /// This kind of predicate has no *direct* correspondent in the\n /// syntax, but it roughly corresponds to the syntactic forms:\n ///\n-/// 1. `T : TraitRef<..., Item=Type>`\n+/// 1. `T: TraitRef<..., Item=Type>`\n /// 2. `<T as TraitRef<...>>::Item == Type` (NYI)\n ///\n /// In particular, form #1 is \"desugared\" to the combination of a\n-/// normal trait predicate (`T : TraitRef<...>`) and one of these\n+/// normal trait predicate (`T: TraitRef<...>`) and one of these\n /// predicates. Form #2 is a broader form in that it also permits\n /// equality between arbitrary types. Processing an instance of\n /// Form #2 eventually yields one of these `ProjectionPredicate`\n@@ -1256,14 +1258,14 @@ pub struct ProjectionPredicate<'tcx> {\n pub type PolyProjectionPredicate<'tcx> = Binder<ProjectionPredicate<'tcx>>;\n \n impl<'tcx> PolyProjectionPredicate<'tcx> {\n-    /// Returns the def-id of the associated item being projected.\n+    /// Returns the `DefId` of the associated item being projected.\n     pub fn item_def_id(&self) -> DefId {\n         self.skip_binder().projection_ty.item_def_id\n     }\n \n     pub fn to_poly_trait_ref(&self, tcx: TyCtxt<'_, '_, '_>) -> PolyTraitRef<'tcx> {\n-        // Note: unlike with TraitRef::to_poly_trait_ref(),\n-        // self.0.trait_ref is permitted to have escaping regions.\n+        // Note: unlike with `TraitRef::to_poly_trait_ref()`,\n+        // `self.0.trait_ref` is permitted to have escaping regions.\n         // This is because here `self` has a `Binder` and so does our\n         // return value, so we are preserving the number of binding\n         // levels.\n@@ -1274,12 +1276,12 @@ impl<'tcx> PolyProjectionPredicate<'tcx> {\n         self.map_bound(|predicate| predicate.ty)\n     }\n \n-    /// The DefId of the TraitItem for the associated type.\n+    /// The `DefId` of the `TraitItem` for the associated type.\n     ///\n-    /// Note that this is not the DefId of the TraitRef containing this\n-    /// associated type, which is in tcx.associated_item(projection_def_id()).container.\n+    /// Note that this is not the `DefId` of the `TraitRef` containing this\n+    /// associated type, which is in `tcx.associated_item(projection_def_id()).container`.\n     pub fn projection_def_id(&self) -> DefId {\n-        // ok to skip binder since trait def-id does not care about regions\n+        // okay to skip binder since trait def-id does not care about regions\n         self.skip_binder().projection_ty.item_def_id\n     }\n }\n@@ -1515,14 +1517,14 @@ impl UniverseIndex {\n         UniverseIndex::from_u32(self.private.checked_add(1).unwrap())\n     }\n \n-    /// True if `self` can name a name from `other` -- in other words,\n+    /// Returns `true` if `self` can name a name from `other` -- in other words,\n     /// if the set of names in `self` is a superset of those in\n     /// `other` (`self >= other`).\n     pub fn can_name(self, other: UniverseIndex) -> bool {\n         self.private >= other.private\n     }\n \n-    /// True if `self` cannot name some names from `other` -- in other\n+    /// Returns `true` if `self` cannot name some names from `other` -- in other\n     /// words, if the set of names in `self` is a strict subset of\n     /// those in `other` (`self < other`).\n     pub fn cannot_name(self, other: UniverseIndex) -> bool {\n@@ -1574,7 +1576,7 @@ impl<'tcx> ParamEnv<'tcx> {\n     /// are revealed. This is suitable for monomorphized, post-typeck\n     /// environments like codegen or doing optimizations.\n     ///\n-    /// NB. If you want to have predicates in scope, use `ParamEnv::new`,\n+    /// N.B. If you want to have predicates in scope, use `ParamEnv::new`,\n     /// or invoke `param_env.with_reveal_all()`.\n     pub fn reveal_all() -> Self {\n         Self::new(List::empty(), Reveal::All)\n@@ -1979,14 +1981,14 @@ impl ReprOptions {\n         self.int.unwrap_or(attr::SignedInt(ast::IntTy::Isize))\n     }\n \n-    /// Returns true if this `#[repr()]` should inhabit \"smart enum\n+    /// Returns `true` if this `#[repr()]` should inhabit \"smart enum\n     /// layout\" optimizations, such as representing `Foo<&T>` as a\n     /// single pointer.\n     pub fn inhibit_enum_layout_opt(&self) -> bool {\n         self.c() || self.int.is_some()\n     }\n \n-    /// Returns true if this `#[repr()]` should inhibit struct field reordering\n+    /// Returns `true` if this `#[repr()]` should inhibit struct field reordering\n     /// optimizations, such as with repr(C) or repr(packed(1)).\n     pub fn inhibit_struct_field_reordering_opt(&self) -> bool {\n         !(self.flags & ReprFlags::IS_UNOPTIMISABLE).is_empty() || (self.pack == 1)\n@@ -2089,7 +2091,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         self.flags.intersects(AdtFlags::IS_FUNDAMENTAL)\n     }\n \n-    /// Returns true if this is PhantomData<T>.\n+    /// Returns `true` if this is PhantomData<T>.\n     #[inline]\n     pub fn is_phantom_data(&self) -> bool {\n         self.flags.intersects(AdtFlags::IS_PHANTOM_DATA)\n@@ -2105,7 +2107,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         self.flags.intersects(AdtFlags::IS_RC)\n     }\n \n-    /// Returns true if this is Box<T>.\n+    /// Returns `true` if this is Box<T>.\n     #[inline]\n     pub fn is_box(&self) -> bool {\n         self.flags.intersects(AdtFlags::IS_BOX)\n@@ -2422,7 +2424,7 @@ impl<'a, 'tcx> ClosureKind {\n         }\n     }\n \n-    /// True if this a type that impls this closure kind\n+    /// Returns `true` if this a type that impls this closure kind\n     /// must also implement `other`.\n     pub fn extends(self, other: ty::ClosureKind) -> bool {\n         match (self, other) {\n@@ -2475,7 +2477,7 @@ impl<'tcx> TyS<'tcx> {\n     ///\n     /// Note: prefer `ty.walk()` where possible.\n     pub fn maybe_walk<F>(&'tcx self, mut f: F)\n-        where F : FnMut(Ty<'tcx>) -> bool\n+        where F: FnMut(Ty<'tcx>) -> bool\n     {\n         let mut walker = self.walk();\n         while let Some(ty) = walker.next() {\n@@ -2678,7 +2680,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             as Box<dyn Iterator<Item = AssociatedItem> + 'a>\n     }\n \n-    /// Returns true if the impls are the same polarity and the trait either\n+    /// Returns `true` if the impls are the same polarity and the trait either\n     /// has no items or is annotated #[marker] and prevents item overrides.\n     pub fn impls_are_allowed_to_overlap(self, def_id1: DefId, def_id2: DefId) -> bool {\n         if self.features().overlapping_marker_traits {\n@@ -2802,7 +2804,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         attr::contains_name(&self.get_attrs(did), attr)\n     }\n \n-    /// Returns true if this is an `auto trait`.\n+    /// Returns `true` if this is an `auto trait`.\n     pub fn trait_is_auto(self, trait_def_id: DefId) -> bool {\n         self.trait_def(trait_def_id).has_auto_impl\n     }"}, {"sha": "7fac88a3d78f1855b97371e8dd793adf88572625", "filename": "src/librustc/ty/outlives.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Foutlives.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -12,6 +12,7 @@\n // refers to rules defined in RFC 1214 (`OutlivesFooBar`), so see that\n // RFC for reference.\n \n+use smallvec::SmallVec;\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n \n #[derive(Debug)]\n@@ -55,17 +56,15 @@ pub enum Component<'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    /// Returns all the things that must outlive `'a` for the condition\n+    /// Push onto `out` all the things that must outlive `'a` for the condition\n     /// `ty0: 'a` to hold. Note that `ty0` must be a **fully resolved type**.\n-    pub fn outlives_components(&self, ty0: Ty<'tcx>)\n-                               -> Vec<Component<'tcx>> {\n-        let mut components = vec![];\n-        self.compute_components(ty0, &mut components);\n-        debug!(\"components({:?}) = {:?}\", ty0, components);\n-        components\n+    pub fn push_outlives_components(&self, ty0: Ty<'tcx>,\n+                                    out: &mut SmallVec<[Component<'tcx>; 4]>) {\n+        self.compute_components(ty0, out);\n+        debug!(\"components({:?}) = {:?}\", ty0, out);\n     }\n \n-    fn compute_components(&self, ty: Ty<'tcx>, out: &mut Vec<Component<'tcx>>) {\n+    fn compute_components(&self, ty: Ty<'tcx>, out: &mut SmallVec<[Component<'tcx>; 4]>) {\n         // Descend through the types, looking for the various \"base\"\n         // components and collecting them into `out`. This is not written\n         // with `collect()` because of the need to sometimes skip subtrees\n@@ -164,7 +163,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 // list is maintained explicitly, because bound regions\n                 // themselves can be readily identified.\n \n-                push_region_constraints(out, ty.regions());\n+                push_region_constraints(ty, out);\n                 for subty in ty.walk_shallow() {\n                     self.compute_components(subty, out);\n                 }\n@@ -173,15 +172,17 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn capture_components(&self, ty: Ty<'tcx>) -> Vec<Component<'tcx>> {\n-        let mut temp = vec![];\n-        push_region_constraints(&mut temp, ty.regions());\n+        let mut temp = smallvec![];\n+        push_region_constraints(ty, &mut temp);\n         for subty in ty.walk_shallow() {\n             self.compute_components(subty, &mut temp);\n         }\n-        temp\n+        temp.into_iter().collect()\n     }\n }\n \n-fn push_region_constraints<'tcx>(out: &mut Vec<Component<'tcx>>, regions: Vec<ty::Region<'tcx>>) {\n+fn push_region_constraints<'tcx>(ty: Ty<'tcx>, out: &mut SmallVec<[Component<'tcx>; 4]>) {\n+    let mut regions = smallvec![];\n+    ty.push_regions(&mut regions);\n     out.extend(regions.iter().filter(|&r| !r.is_late_bound()).map(|r| Component::Region(r)));\n }"}, {"sha": "a4130bf15cb8272f2bd726ae061b5f758a03a042", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 21, "deletions": 23, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -22,6 +22,7 @@ use ty::{List, TyS, ParamEnvAnd, ParamEnv};\n use util::captures::Captures;\n use mir::interpret::{Scalar, Pointer};\n \n+use smallvec::SmallVec;\n use std::iter;\n use std::cmp::Ordering;\n use rustc_target::spec::abi;\n@@ -627,7 +628,7 @@ impl<'tcx> Binder<&'tcx List<ExistentialPredicate<'tcx>>> {\n /// A complete reference to a trait. These take numerous guises in syntax,\n /// but perhaps the most recognizable form is in a where clause:\n ///\n-///     T : Foo<U>\n+///     T: Foo<U>\n ///\n /// This would be represented by a trait-reference where the def-id is the\n /// def-id for the trait `Foo` and the substs define `T` as parameter 0,\n@@ -637,8 +638,8 @@ impl<'tcx> Binder<&'tcx List<ExistentialPredicate<'tcx>>> {\n /// that case the `Self` parameter is absent from the substitutions.\n ///\n /// Note that a `TraitRef` introduces a level of region binding, to\n-/// account for higher-ranked trait bounds like `T : for<'a> Foo<&'a\n-/// U>` or higher-ranked object types.\n+/// account for higher-ranked trait bounds like `T: for<'a> Foo<&'a U>`\n+/// or higher-ranked object types.\n #[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct TraitRef<'tcx> {\n     pub def_id: DefId,\n@@ -663,7 +664,7 @@ impl<'tcx> TraitRef<'tcx> {\n         self.substs.type_at(0)\n     }\n \n-    pub fn input_types<'a>(&'a self) -> impl DoubleEndedIterator<Item=Ty<'tcx>> + 'a {\n+    pub fn input_types<'a>(&'a self) -> impl DoubleEndedIterator<Item = Ty<'tcx>> + 'a {\n         // Select only the \"input types\" from a trait-reference. For\n         // now this is all the types that appear in the\n         // trait-reference, but it should eventually exclude\n@@ -886,16 +887,16 @@ pub struct ProjectionTy<'tcx> {\n     /// The parameters of the associated item.\n     pub substs: &'tcx Substs<'tcx>,\n \n-    /// The DefId of the TraitItem for the associated type N.\n+    /// The `DefId` of the `TraitItem` for the associated type `N`.\n     ///\n-    /// Note that this is not the DefId of the TraitRef containing this\n-    /// associated type, which is in tcx.associated_item(item_def_id).container.\n+    /// Note that this is not the `DefId` of the `TraitRef` containing this\n+    /// associated type, which is in `tcx.associated_item(item_def_id).container`.\n     pub item_def_id: DefId,\n }\n \n impl<'a, 'tcx> ProjectionTy<'tcx> {\n-    /// Construct a ProjectionTy by searching the trait from trait_ref for the\n-    /// associated item named item_name.\n+    /// Construct a `ProjectionTy` by searching the trait from `trait_ref` for the\n+    /// associated item named `item_name`.\n     pub fn from_ref_and_name(\n         tcx: TyCtxt<'_, '_, '_>, trait_ref: ty::TraitRef<'tcx>, item_name: Ident\n     ) -> ProjectionTy<'tcx> {\n@@ -1846,28 +1847,27 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n-    /// Returns the regions directly referenced from this type (but\n-    /// not types reachable from this type via `walk_tys`). This\n-    /// ignores late-bound regions binders.\n-    pub fn regions(&self) -> Vec<ty::Region<'tcx>> {\n+    /// Push onto `out` the regions directly referenced from this type (but not\n+    /// types reachable from this type via `walk_tys`). This ignores late-bound\n+    /// regions binders.\n+    pub fn push_regions(&self, out: &mut SmallVec<[ty::Region<'tcx>; 4]>) {\n         match self.sty {\n             Ref(region, _, _) => {\n-                vec![region]\n+                out.push(region);\n             }\n             Dynamic(ref obj, region) => {\n-                let mut v = vec![region];\n-                v.extend(obj.principal().skip_binder().substs.regions());\n-                v\n+                out.push(region);\n+                out.extend(obj.principal().skip_binder().substs.regions());\n             }\n             Adt(_, substs) | Opaque(_, substs) => {\n-                substs.regions().collect()\n+                out.extend(substs.regions())\n             }\n             Closure(_, ClosureSubsts { ref substs }) |\n             Generator(_, GeneratorSubsts { ref substs }, _) => {\n-                substs.regions().collect()\n+                out.extend(substs.regions())\n             }\n             Projection(ref data) | UnnormalizedProjection(ref data) => {\n-                data.substs.regions().collect()\n+                out.extend(data.substs.regions())\n             }\n             FnDef(..) |\n             FnPtr(_) |\n@@ -1887,9 +1887,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n             Param(_) |\n             Bound(..) |\n             Infer(_) |\n-            Error => {\n-                vec![]\n-            }\n+            Error => {}\n         }\n     }\n "}, {"sha": "b28e7c9fb199be7daaacce299e889784c7375078", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -27,7 +27,7 @@ use std::marker::PhantomData;\n use std::mem;\n use std::num::NonZeroUsize;\n \n-/// An entity in the Rust typesystem, which can be one of\n+/// An entity in the Rust type system, which can be one of\n /// several kinds (only types and lifetimes for now).\n /// To reduce memory usage, a `Kind` is a interned pointer,\n /// with the lowest 2 bits being reserved for a tag to\n@@ -171,17 +171,17 @@ impl<'tcx> Decodable for Kind<'tcx> {\n pub type Substs<'tcx> = List<Kind<'tcx>>;\n \n impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n-    /// Creates a Substs that maps each generic parameter to itself.\n+    /// Creates a `Substs` that maps each generic parameter to itself.\n     pub fn identity_for_item(tcx: TyCtxt<'a, 'gcx, 'tcx>, def_id: DefId)\n                              -> &'tcx Substs<'tcx> {\n         Substs::for_item(tcx, def_id, |param, _| {\n             tcx.mk_param_from_def(param)\n         })\n     }\n \n-    /// Creates a Substs for generic parameter definitions,\n+    /// Creates a `Substs` for generic parameter definitions,\n     /// by calling closures to obtain each kind.\n-    /// The closures get to observe the Substs as they're\n+    /// The closures get to observe the `Substs` as they're\n     /// being built, which can be used to correctly\n     /// substitute defaults of generic parameters.\n     pub fn for_item<F>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n@@ -242,7 +242,7 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n     }\n \n     #[inline]\n-    pub fn types(&'a self) -> impl DoubleEndedIterator<Item=Ty<'tcx>> + 'a {\n+    pub fn types(&'a self) -> impl DoubleEndedIterator<Item = Ty<'tcx>> + 'a {\n         self.iter().filter_map(|k| {\n             if let UnpackedKind::Type(ty) = k.unpack() {\n                 Some(ty)\n@@ -253,7 +253,7 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n     }\n \n     #[inline]\n-    pub fn regions(&'a self) -> impl DoubleEndedIterator<Item=ty::Region<'tcx>> + 'a {\n+    pub fn regions(&'a self) -> impl DoubleEndedIterator<Item = ty::Region<'tcx>> + 'a {\n         self.iter().filter_map(|k| {\n             if let UnpackedKind::Lifetime(lt) = k.unpack() {\n                 Some(lt)\n@@ -332,7 +332,7 @@ impl<'tcx> serialize::UseSpecializedDecodable for &'tcx Substs<'tcx> {}\n // `foo`. Or use `foo.subst_spanned(tcx, substs, Some(span))` when\n // there is more information available (for better errors).\n \n-pub trait Subst<'tcx> : Sized {\n+pub trait Subst<'tcx>: Sized {\n     fn subst<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                        substs: &[Kind<'tcx>]) -> Self {\n         self.subst_spanned(tcx, substs, None)"}, {"sha": "a8a5da90c7a6bb41418cb0b5cf20447eca1fff38", "filename": "src/librustc_apfloat/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_apfloat%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_apfloat%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2FCargo.toml?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -10,3 +10,4 @@ path = \"lib.rs\"\n [dependencies]\n bitflags = \"1.0\"\n rustc_cratesio_shim = { path = \"../librustc_cratesio_shim\" }\n+smallvec = { version = \"0.6.5\", features = [\"union\"] }"}, {"sha": "4f405858e350ce8269b9fba6dfe8512f2f6474ed", "filename": "src/librustc_apfloat/ieee.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_apfloat%2Fieee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_apfloat%2Fieee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Fieee.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -11,6 +11,7 @@\n use {Category, ExpInt, IEK_INF, IEK_NAN, IEK_ZERO};\n use {Float, FloatConvert, ParseError, Round, Status, StatusAnd};\n \n+use smallvec::{SmallVec, smallvec};\n use std::cmp::{self, Ordering};\n use std::convert::TryFrom;\n use std::fmt::{self, Write};\n@@ -1962,7 +1963,7 @@ impl<S: Semantics> IeeeFloat<S> {\n         // to hold the full significand, and an extra limb required by\n         // tcMultiplyPart.\n         let max_limbs = limbs_for_bits(1 + 196 * significand_digits / 59);\n-        let mut dec_sig = Vec::with_capacity(max_limbs);\n+        let mut dec_sig: SmallVec<[Limb; 1]> = SmallVec::with_capacity(max_limbs);\n \n         // Convert to binary efficiently - we do almost all multiplication\n         // in a Limb. When this would overflow do we do a single\n@@ -2021,11 +2022,11 @@ impl<S: Semantics> IeeeFloat<S> {\n \n             const FIRST_EIGHT_POWERS: [Limb; 8] = [1, 5, 25, 125, 625, 3125, 15625, 78125];\n \n-            let mut p5_scratch = vec![];\n-            let mut p5 = vec![FIRST_EIGHT_POWERS[4]];\n+            let mut p5_scratch = smallvec![];\n+            let mut p5: SmallVec<[Limb; 1]> = smallvec![FIRST_EIGHT_POWERS[4]];\n \n-            let mut r_scratch = vec![];\n-            let mut r = vec![FIRST_EIGHT_POWERS[power & 7]];\n+            let mut r_scratch = smallvec![];\n+            let mut r: SmallVec<[Limb; 1]> = smallvec![FIRST_EIGHT_POWERS[power & 7]];\n             power >>= 3;\n \n             while power > 0 {\n@@ -2064,7 +2065,7 @@ impl<S: Semantics> IeeeFloat<S> {\n             let calc_precision = (LIMB_BITS << attempt) - 1;\n             attempt += 1;\n \n-            let calc_normal_from_limbs = |sig: &mut Vec<Limb>,\n+            let calc_normal_from_limbs = |sig: &mut SmallVec<[Limb; 1]>,\n                                           limbs: &[Limb]|\n              -> StatusAnd<ExpInt> {\n                 sig.resize(limbs_for_bits(calc_precision), 0);"}, {"sha": "69c9f385409e4a268a1c0d17a39233e64c39bdbf", "filename": "src/librustc_apfloat/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_apfloat%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_apfloat%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Flib.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -53,6 +53,7 @@ extern crate rustc_cratesio_shim;\n \n #[macro_use]\n extern crate bitflags;\n+extern crate smallvec;\n \n use std::cmp::Ordering;\n use std::fmt;"}, {"sha": "03b0b04d4014694f5571b97745f9cffd48504ef3", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -19,7 +19,7 @@ use type_::Type;\n use type_of::{LayoutLlvmExt, PointerKind};\n use value::Value;\n \n-use rustc_target::abi::{LayoutOf, Size, TyLayout, Abi as LayoutAbi};\n+use rustc_target::abi::{HasDataLayout, LayoutOf, Size, TyLayout, Abi as LayoutAbi};\n use rustc::ty::{self, Ty};\n use rustc::ty::layout;\n \n@@ -277,6 +277,7 @@ pub trait FnTypeExt<'tcx> {\n                       cx: &CodegenCx<'ll, 'tcx>,\n                       abi: Abi);\n     fn llvm_type(&self, cx: &CodegenCx<'ll, 'tcx>) -> &'ll Type;\n+    fn ptr_to_llvm_type(&self, cx: &CodegenCx<'ll, 'tcx>) -> &'ll Type;\n     fn llvm_cconv(&self) -> llvm::CallConv;\n     fn apply_attrs_llfn(&self, llfn: &'ll Value);\n     fn apply_attrs_callsite(&self, bx: &Builder<'a, 'll, 'tcx>, callsite: &'ll Value);\n@@ -658,6 +659,13 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n         }\n     }\n \n+    fn ptr_to_llvm_type(&self, cx: &CodegenCx<'ll, 'tcx>) -> &'ll Type {\n+        unsafe {\n+            llvm::LLVMPointerType(self.llvm_type(cx),\n+                                  cx.data_layout().instruction_address_space as c_uint)\n+        }\n+    }\n+\n     fn llvm_cconv(&self) -> llvm::CallConv {\n         match self.conv {\n             Conv::C => llvm::CCallConv,"}, {"sha": "54245a36017ab9e5631040292287495957d49730", "filename": "src/librustc_codegen_llvm/back/archive.rs", "status": "modified", "additions": 14, "deletions": 19, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_codegen_llvm%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_codegen_llvm%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Farchive.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -83,15 +83,16 @@ impl<'a> ArchiveBuilder<'a> {\n         if self.src_archive().is_none() {\n             return Vec::new()\n         }\n+\n         let archive = self.src_archive.as_ref().unwrap().as_ref().unwrap();\n-        let ret = archive.iter()\n-                         .filter_map(|child| child.ok())\n-                         .filter(is_relevant_child)\n-                         .filter_map(|child| child.name())\n-                         .filter(|name| !self.removals.iter().any(|x| x == name))\n-                         .map(|name| name.to_string())\n-                         .collect();\n-        return ret;\n+\n+        archive.iter()\n+               .filter_map(|child| child.ok())\n+               .filter(is_relevant_child)\n+               .filter_map(|child| child.name())\n+               .filter(|name| !self.removals.iter().any(|x| x == name))\n+               .map(|name| name.to_owned())\n+               .collect()\n     }\n \n     fn src_archive(&mut self) -> Option<&ArchiveRO> {\n@@ -171,7 +172,7 @@ impl<'a> ArchiveBuilder<'a> {\n         let name = file.file_name().unwrap().to_str().unwrap();\n         self.additions.push(Addition::File {\n             path: file.to_path_buf(),\n-            name_in_archive: name.to_string(),\n+            name_in_archive: name.to_owned(),\n         });\n     }\n \n@@ -184,13 +185,8 @@ impl<'a> ArchiveBuilder<'a> {\n     /// Combine the provided files, rlibs, and native libraries into a single\n     /// `Archive`.\n     pub fn build(&mut self) {\n-        let kind = match self.llvm_archive_kind() {\n-            Ok(kind) => kind,\n-            Err(kind) => {\n-                self.config.sess.fatal(&format!(\"Don't know how to build archive of type: {}\",\n-                                                kind));\n-            }\n-        };\n+        let kind = self.llvm_archive_kind().unwrap_or_else(|kind|\n+            self.config.sess.fatal(&format!(\"Don't know how to build archive of type: {}\", kind)));\n \n         if let Err(e) = self.build_with_llvm(kind) {\n             self.config.sess.fatal(&format!(\"failed to build archive: {}\", e));\n@@ -281,10 +277,9 @@ impl<'a> ArchiveBuilder<'a> {\n             let ret = if r.into_result().is_err() {\n                 let err = llvm::LLVMRustGetLastError();\n                 let msg = if err.is_null() {\n-                    \"failed to write archive\".to_string()\n+                    \"failed to write archive\".into()\n                 } else {\n                     String::from_utf8_lossy(CStr::from_ptr(err).to_bytes())\n-                            .into_owned()\n                 };\n                 Err(io::Error::new(io::ErrorKind::Other, msg))\n             } else {\n@@ -293,7 +288,7 @@ impl<'a> ArchiveBuilder<'a> {\n             for member in members {\n                 llvm::LLVMRustArchiveMemberFree(member);\n             }\n-            return ret\n+            ret\n         }\n     }\n }"}, {"sha": "0b264de18c124b4f19567053dccfe96506a8f980", "filename": "src/librustc_codegen_llvm/back/bytecode.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_codegen_llvm%2Fback%2Fbytecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_codegen_llvm%2Fback%2Fbytecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fbytecode.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -42,7 +42,7 @@ use flate2::write::DeflateEncoder;\n \n // This is the \"magic number\" expected at the beginning of a LLVM bytecode\n // object in an rlib.\n-pub const RLIB_BYTECODE_OBJECT_MAGIC: &'static [u8] = b\"RUST_OBJECT\";\n+pub const RLIB_BYTECODE_OBJECT_MAGIC: &[u8] = b\"RUST_OBJECT\";\n \n // The version number this compiler will write to bytecode objects in rlibs\n pub const RLIB_BYTECODE_OBJECT_VERSION: u8 = 2;\n@@ -106,39 +106,39 @@ pub struct DecodedBytecode<'a> {\n }\n \n impl<'a> DecodedBytecode<'a> {\n-    pub fn new(data: &'a [u8]) -> Result<DecodedBytecode<'a>, String> {\n+    pub fn new(data: &'a [u8]) -> Result<DecodedBytecode<'a>, &'static str> {\n         if !data.starts_with(RLIB_BYTECODE_OBJECT_MAGIC) {\n-            return Err(\"magic bytecode prefix not found\".to_string())\n+            return Err(\"magic bytecode prefix not found\")\n         }\n         let data = &data[RLIB_BYTECODE_OBJECT_MAGIC.len()..];\n         if !data.starts_with(&[RLIB_BYTECODE_OBJECT_VERSION, 0, 0, 0]) {\n-            return Err(\"wrong version prefix found in bytecode\".to_string())\n+            return Err(\"wrong version prefix found in bytecode\")\n         }\n         let data = &data[4..];\n         if data.len() < 4 {\n-            return Err(\"bytecode corrupted\".to_string())\n+            return Err(\"bytecode corrupted\")\n         }\n         let identifier_len = unsafe {\n             u32::from_le(ptr::read_unaligned(data.as_ptr() as *const u32)) as usize\n         };\n         let data = &data[4..];\n         if data.len() < identifier_len {\n-            return Err(\"bytecode corrupted\".to_string())\n+            return Err(\"bytecode corrupted\")\n         }\n         let identifier = match str::from_utf8(&data[..identifier_len]) {\n             Ok(s) => s,\n-            Err(_) => return Err(\"bytecode corrupted\".to_string())\n+            Err(_) => return Err(\"bytecode corrupted\")\n         };\n         let data = &data[identifier_len..];\n         if data.len() < 8 {\n-            return Err(\"bytecode corrupted\".to_string())\n+            return Err(\"bytecode corrupted\")\n         }\n         let bytecode_len = unsafe {\n             u64::from_le(ptr::read_unaligned(data.as_ptr() as *const u64)) as usize\n         };\n         let data = &data[8..];\n         if data.len() < bytecode_len {\n-            return Err(\"bytecode corrupted\".to_string())\n+            return Err(\"bytecode corrupted\")\n         }\n         let encoded_bytecode = &data[..bytecode_len];\n "}, {"sha": "111637b6aa967800090441756dced4a984e29572", "filename": "src/librustc_codegen_llvm/back/link.rs", "status": "modified", "additions": 20, "deletions": 32, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -47,8 +47,8 @@ use std::str;\n use syntax::attr;\n \n pub use rustc_codegen_utils::link::{find_crate_name, filename_for_input, default_output_for_target,\n-                                  invalid_output_for_target, out_filename, check_file_is_writeable,\n-                                  filename_for_metadata};\n+                                    invalid_output_for_target, filename_for_metadata,\n+                                    out_filename, check_file_is_writeable};\n \n // The third parameter is for env vars, used on windows to set up the\n // path for MSVC to find its DLLs, and gcc to find its bundled\n@@ -107,13 +107,10 @@ pub fn get_linker(sess: &Session, linker: &Path, flavor: LinkerFlavor) -> (PathB\n }\n \n pub fn remove(sess: &Session, path: &Path) {\n-    match fs::remove_file(path) {\n-        Ok(..) => {}\n-        Err(e) => {\n-            sess.err(&format!(\"failed to remove {}: {}\",\n-                             path.display(),\n-                             e));\n-        }\n+    if let Err(e) = fs::remove_file(path) {\n+        sess.err(&format!(\"failed to remove {}: {}\",\n+                          path.display(),\n+                          e));\n     }\n }\n \n@@ -147,9 +144,7 @@ pub(crate) fn link_binary(sess: &Session,\n \n     // Remove the temporary object file and metadata if we aren't saving temps\n     if !sess.opts.cg.save_temps {\n-        if sess.opts.output_types.should_codegen() &&\n-            !preserve_objects_for_their_debuginfo(sess)\n-        {\n+        if sess.opts.output_types.should_codegen() && !preserve_objects_for_their_debuginfo(sess) {\n             for obj in codegen_results.modules.iter().filter_map(|m| m.object.as_ref()) {\n                 remove(sess, obj);\n             }\n@@ -186,7 +181,7 @@ fn preserve_objects_for_their_debuginfo(sess: &Session) -> bool {\n     // the objects as they're losslessly contained inside the archives.\n     let output_linked = sess.crate_types.borrow()\n         .iter()\n-        .any(|x| *x != config::CrateType::Rlib && *x != config::CrateType::Staticlib);\n+        .any(|&x| x != config::CrateType::Rlib && x != config::CrateType::Staticlib);\n     if !output_linked {\n         return false\n     }\n@@ -270,7 +265,7 @@ pub(crate) fn ignored_for_lto(sess: &Session, info: &CrateInfo, cnum: CrateNum)\n     // crates providing these functions don't participate in LTO (e.g.\n     // no_builtins or compiler builtins crates).\n     !sess.target.target.options.no_builtins &&\n-        (info.is_no_builtins.contains(&cnum) || info.compiler_builtins == Some(cnum))\n+        (info.compiler_builtins == Some(cnum) || info.is_no_builtins.contains(&cnum))\n }\n \n fn link_binary_output(sess: &Session,\n@@ -291,24 +286,19 @@ fn link_binary_output(sess: &Session,\n         // final destination, with a `fs::rename` call. In order for the rename to\n         // always succeed, the temporary file needs to be on the same filesystem,\n         // which is why we create it inside the output directory specifically.\n-        let metadata_tmpdir = match TempFileBuilder::new()\n+        let metadata_tmpdir = TempFileBuilder::new()\n             .prefix(\"rmeta\")\n             .tempdir_in(out_filename.parent().unwrap())\n-        {\n-            Ok(tmpdir) => tmpdir,\n-            Err(err) => sess.fatal(&format!(\"couldn't create a temp dir: {}\", err)),\n-        };\n+            .unwrap_or_else(|err| sess.fatal(&format!(\"couldn't create a temp dir: {}\", err)));\n         let metadata = emit_metadata(sess, codegen_results, &metadata_tmpdir);\n         if let Err(e) = fs::rename(metadata, &out_filename) {\n             sess.fatal(&format!(\"failed to write {}: {}\", out_filename.display(), e));\n         }\n         out_filenames.push(out_filename);\n     }\n \n-    let tmpdir = match TempFileBuilder::new().prefix(\"rustc\").tempdir() {\n-        Ok(tmpdir) => tmpdir,\n-        Err(err) => sess.fatal(&format!(\"couldn't create a temp dir: {}\", err)),\n-    };\n+    let tmpdir = TempFileBuilder::new().prefix(\"rustc\").tempdir().unwrap_or_else(|err|\n+        sess.fatal(&format!(\"couldn't create a temp dir: {}\", err)));\n \n     if outputs.outputs.should_codegen() {\n         let out_filename = out_filename(sess, crate_type, outputs, crate_name);\n@@ -342,7 +332,8 @@ fn archive_search_paths(sess: &Session) -> Vec<PathBuf> {\n     sess.target_filesearch(PathKind::Native).for_each_lib_search_path(|path, _| {\n         search.push(path.to_path_buf());\n     });\n-    return search;\n+\n+    search\n }\n \n fn archive_config<'a>(sess: &'a Session,\n@@ -814,8 +805,8 @@ fn link_natively(sess: &Session,\n                     .unwrap_or_else(|_| {\n                         let mut x = \"Non-UTF-8 output: \".to_string();\n                         x.extend(s.iter()\n-                                 .flat_map(|&b| ascii::escape_default(b))\n-                                 .map(|b| char::from_u32(b as u32).unwrap()));\n+                                  .flat_map(|&b| ascii::escape_default(b))\n+                                  .map(char::from));\n                         x\n                     })\n             }\n@@ -870,9 +861,8 @@ fn link_natively(sess: &Session,\n         sess.opts.debuginfo != DebugInfo::None &&\n         !preserve_objects_for_their_debuginfo(sess)\n     {\n-        match Command::new(\"dsymutil\").arg(out_filename).output() {\n-            Ok(..) => {}\n-            Err(e) => sess.fatal(&format!(\"failed to run dsymutil: {}\", e)),\n+        if let Err(e) = Command::new(\"dsymutil\").arg(out_filename).output() {\n+            sess.fatal(&format!(\"failed to run dsymutil: {}\", e))\n         }\n     }\n \n@@ -1012,8 +1002,7 @@ fn exec_linker(sess: &Session, cmd: &mut Command, out_filename: &Path, tmpdir: &\n                 // ensure the line is interpreted as one whole argument.\n                 for c in self.arg.chars() {\n                     match c {\n-                        '\\\\' |\n-                        ' ' => write!(f, \"\\\\{}\", c)?,\n+                        '\\\\' | ' ' => write!(f, \"\\\\{}\", c)?,\n                         c => write!(f, \"{}\", c)?,\n                     }\n                 }\n@@ -1426,7 +1415,6 @@ fn add_upstream_rust_crates(cmd: &mut dyn Linker,\n         for f in archive.src_files() {\n             if f.ends_with(RLIB_BYTECODE_EXTENSION) || f == METADATA_FILENAME {\n                 archive.remove_file(&f);\n-                continue\n             }\n         }\n "}, {"sha": "76faffa25216af79e9aad8667ab8e97d3deaee80", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 19, "deletions": 26, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -205,11 +205,11 @@ pub(crate) fn run(cgcx: &CodegenContext,\n         Lto::Fat => {\n             assert!(cached_modules.is_empty());\n             let opt_jobs = fat_lto(cgcx,\n-                                  &diag_handler,\n-                                  modules,\n-                                  upstream_modules,\n-                                  &symbol_white_list,\n-                                  timeline);\n+                                   &diag_handler,\n+                                   modules,\n+                                   upstream_modules,\n+                                   &symbol_white_list,\n+                                   timeline);\n             opt_jobs.map(|opt_jobs| (opt_jobs, vec![]))\n         }\n         Lto::Thin |\n@@ -296,7 +296,7 @@ fn fat_lto(cgcx: &CodegenContext,\n                 let data = bc_decoded.data();\n                 linker.add(&data).map_err(|()| {\n                     let msg = format!(\"failed to load bc of {:?}\", name);\n-                    write::llvm_err(&diag_handler, msg)\n+                    write::llvm_err(&diag_handler, &msg)\n                 })\n             })?;\n             timeline.record(&format!(\"link {:?}\", name));\n@@ -310,8 +310,8 @@ fn fat_lto(cgcx: &CodegenContext,\n         unsafe {\n             let ptr = symbol_white_list.as_ptr();\n             llvm::LLVMRustRunRestrictionPass(llmod,\n-                                            ptr as *const *const libc::c_char,\n-                                            symbol_white_list.len() as libc::size_t);\n+                                             ptr as *const *const libc::c_char,\n+                                             symbol_white_list.len() as libc::size_t);\n             cgcx.save_temp_bitcode(&module, \"lto.after-restriction\");\n         }\n \n@@ -490,7 +490,7 @@ fn thin_lto(cgcx: &CodegenContext,\n             symbol_white_list.as_ptr(),\n             symbol_white_list.len() as u32,\n         ).ok_or_else(|| {\n-            write::llvm_err(&diag_handler, \"failed to prepare thin LTO context\".to_string())\n+            write::llvm_err(&diag_handler, \"failed to prepare thin LTO context\")\n         })?;\n \n         info!(\"thin LTO data created\");\n@@ -617,8 +617,7 @@ fn run_pass_manager(cgcx: &CodegenContext,\n             llvm::LLVMRustAddPass(pm, pass.unwrap());\n         }\n \n-        time_ext(cgcx.time_passes, None, \"LTO passes\", ||\n-             llvm::LLVMRunPassManager(pm, llmod));\n+        time_ext(cgcx.time_passes, None, \"LTO passes\", || llvm::LLVMRunPassManager(pm, llmod));\n \n         llvm::LLVMDisposePassManager(pm);\n     }\n@@ -747,7 +746,7 @@ impl ThinModule {\n     {\n         let diag_handler = cgcx.create_diag_handler();\n         let tm = (cgcx.tm_factory)().map_err(|e| {\n-            write::llvm_err(&diag_handler, e)\n+            write::llvm_err(&diag_handler, &e)\n         })?;\n \n         // Right now the implementation we've got only works over serialized\n@@ -762,7 +761,7 @@ impl ThinModule {\n             self.data().len(),\n             self.shared.module_names[self.idx].as_ptr(),\n         ).ok_or_else(|| {\n-            let msg = \"failed to parse bitcode for thin LTO module\".to_string();\n+            let msg = \"failed to parse bitcode for thin LTO module\";\n             write::llvm_err(&diag_handler, msg)\n         })? as *const _;\n         let module = ModuleCodegen {\n@@ -786,7 +785,7 @@ impl ThinModule {\n             let mut cu2 = ptr::null_mut();\n             llvm::LLVMRustThinLTOGetDICompileUnit(llmod, &mut cu1, &mut cu2);\n             if !cu2.is_null() {\n-                let msg = \"multiple source DICompileUnits found\".to_string();\n+                let msg = \"multiple source DICompileUnits found\";\n                 return Err(write::llvm_err(&diag_handler, msg))\n             }\n \n@@ -807,25 +806,25 @@ impl ThinModule {\n             // You can find some more comments about these functions in the LLVM\n             // bindings we've got (currently `PassWrapper.cpp`)\n             if !llvm::LLVMRustPrepareThinLTORename(self.shared.data.0, llmod) {\n-                let msg = \"failed to prepare thin LTO module\".to_string();\n+                let msg = \"failed to prepare thin LTO module\";\n                 return Err(write::llvm_err(&diag_handler, msg))\n             }\n             cgcx.save_temp_bitcode(&module, \"thin-lto-after-rename\");\n             timeline.record(\"rename\");\n             if !llvm::LLVMRustPrepareThinLTOResolveWeak(self.shared.data.0, llmod) {\n-                let msg = \"failed to prepare thin LTO module\".to_string();\n+                let msg = \"failed to prepare thin LTO module\";\n                 return Err(write::llvm_err(&diag_handler, msg))\n             }\n             cgcx.save_temp_bitcode(&module, \"thin-lto-after-resolve\");\n             timeline.record(\"resolve\");\n             if !llvm::LLVMRustPrepareThinLTOInternalize(self.shared.data.0, llmod) {\n-                let msg = \"failed to prepare thin LTO module\".to_string();\n+                let msg = \"failed to prepare thin LTO module\";\n                 return Err(write::llvm_err(&diag_handler, msg))\n             }\n             cgcx.save_temp_bitcode(&module, \"thin-lto-after-internalize\");\n             timeline.record(\"internalize\");\n             if !llvm::LLVMRustPrepareThinLTOImport(self.shared.data.0, llmod) {\n-                let msg = \"failed to prepare thin LTO module\".to_string();\n+                let msg = \"failed to prepare thin LTO module\";\n                 return Err(write::llvm_err(&diag_handler, msg))\n             }\n             cgcx.save_temp_bitcode(&module, \"thin-lto-after-import\");\n@@ -920,12 +919,6 @@ impl ThinLTOImports {\n }\n \n fn module_name_to_str(c_str: &CStr) -> &str {\n-    match c_str.to_str() {\n-        Ok(s) => s,\n-        Err(e) => {\n-            bug!(\"Encountered non-utf8 LLVM module name `{}`: {}\",\n-                c_str.to_string_lossy(),\n-                e)\n-        }\n-    }\n+    c_str.to_str().unwrap_or_else(|e|\n+        bug!(\"Encountered non-utf8 LLVM module name `{}`: {}\", c_str.to_string_lossy(), e))\n }"}, {"sha": "ee4a9b30a1a8542224ed72a67ad9318ae60d5f4a", "filename": "src/librustc_codegen_llvm/back/rpath.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_codegen_llvm%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_codegen_llvm%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Frpath.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -42,7 +42,7 @@ pub fn get_rpath_flags(config: &mut RPathConfig) -> Vec<String> {\n \n     // Use DT_RUNPATH instead of DT_RPATH if available\n     if config.linker_is_gnu {\n-        flags.push(\"-Wl,--enable-new-dtags\".to_string());\n+        flags.push(\"-Wl,--enable-new-dtags\".to_owned());\n     }\n \n     flags\n@@ -59,7 +59,8 @@ fn rpaths_to_flags(rpaths: &[String]) -> Vec<String> {\n             ret.push(format!(\"-Wl,-rpath,{}\", &(*rpath)));\n         }\n     }\n-    return ret;\n+\n+    ret\n }\n \n fn get_rpaths(config: &mut RPathConfig, libs: &[PathBuf]) -> Vec<String> {\n@@ -92,7 +93,8 @@ fn get_rpaths(config: &mut RPathConfig, libs: &[PathBuf]) -> Vec<String> {\n \n     // Remove duplicates\n     let rpaths = minimize_rpaths(&rpaths);\n-    return rpaths;\n+\n+    rpaths\n }\n \n fn get_rpaths_relative_to_output(config: &mut RPathConfig,\n@@ -117,8 +119,7 @@ fn get_rpath_relative_to_output(config: &mut RPathConfig, lib: &Path) -> String\n     let relative = path_relative_from(&lib, &output).unwrap_or_else(||\n         panic!(\"couldn't create relative path from {:?} to {:?}\", output, lib));\n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    format!(\"{}/{}\", prefix,\n-            relative.to_str().expect(\"non-utf8 component in path\"))\n+    format!(\"{}/{}\", prefix, relative.to_str().expect(\"non-utf8 component in path\"))\n }\n \n // This routine is adapted from the *old* Path's `path_relative_from`\n@@ -168,7 +169,7 @@ fn get_install_prefix_rpath(config: &mut RPathConfig) -> String {\n     let path = (config.get_install_prefix_lib_path)();\n     let path = env::current_dir().unwrap().join(&path);\n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    path.to_str().expect(\"non-utf8 component in rpath\").to_string()\n+    path.to_str().expect(\"non-utf8 component in rpath\").to_owned()\n }\n \n fn minimize_rpaths(rpaths: &[String]) -> Vec<String> {"}, {"sha": "7101255173cafd08d5bd88aecb4237b57dbc8530", "filename": "src/librustc_codegen_llvm/back/wasm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_codegen_llvm%2Fback%2Fwasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_codegen_llvm%2Fback%2Fwasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwasm.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -42,7 +42,7 @@ const WASM_EXTERNAL_KIND_GLOBAL: u8 = 3;\n /// https://github.com/llvm-mirror/llvm/commit/0f32e1365, although support still\n /// needs to be added, tracked at https://bugs.llvm.org/show_bug.cgi?id=37168\n pub fn rewrite_imports(path: &Path, import_map: &FxHashMap<String, String>) {\n-    if import_map.len() == 0 {\n+    if import_map.is_empty() {\n         return\n     }\n \n@@ -127,7 +127,7 @@ impl<'a> Iterator for WasmSections<'a> {\n     type Item = (u8, &'a [u8]);\n \n     fn next(&mut self) -> Option<(u8, &'a [u8])> {\n-        if self.0.data.len() == 0 {\n+        if self.0.data.is_empty() {\n             return None\n         }\n "}, {"sha": "8973852caa86b351d594d5ae1e730198ade33fe6", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 39, "deletions": 45, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -64,7 +64,7 @@ use std::time::Instant;\n use std::thread;\n use libc::{c_uint, c_void, c_char, size_t};\n \n-pub const RELOC_MODEL_ARGS : [(&'static str, llvm::RelocMode); 7] = [\n+pub const RELOC_MODEL_ARGS : [(&str, llvm::RelocMode); 7] = [\n     (\"pic\", llvm::RelocMode::PIC),\n     (\"static\", llvm::RelocMode::Static),\n     (\"default\", llvm::RelocMode::Default),\n@@ -81,7 +81,7 @@ pub const CODE_GEN_MODEL_ARGS: &[(&str, llvm::CodeModel)] = &[\n     (\"large\", llvm::CodeModel::Large),\n ];\n \n-pub const TLS_MODEL_ARGS : [(&'static str, llvm::ThreadLocalMode); 4] = [\n+pub const TLS_MODEL_ARGS : [(&str, llvm::ThreadLocalMode); 4] = [\n     (\"global-dynamic\", llvm::ThreadLocalMode::GeneralDynamic),\n     (\"local-dynamic\", llvm::ThreadLocalMode::LocalDynamic),\n     (\"initial-exec\", llvm::ThreadLocalMode::InitialExec),\n@@ -90,7 +90,7 @@ pub const TLS_MODEL_ARGS : [(&'static str, llvm::ThreadLocalMode); 4] = [\n \n const PRE_THIN_LTO_BC_EXT: &str = \"pre-thin-lto.bc\";\n \n-pub fn llvm_err(handler: &errors::Handler, msg: String) -> FatalError {\n+pub fn llvm_err(handler: &errors::Handler, msg: &str) -> FatalError {\n     match llvm::last_error() {\n         Some(err) => handler.fatal(&format!(\"{}: {}\", msg, err)),\n         None => handler.fatal(&msg),\n@@ -106,11 +106,10 @@ pub fn write_output_file(\n         file_type: llvm::FileType) -> Result<(), FatalError> {\n     unsafe {\n         let output_c = path2cstr(output);\n-        let result = llvm::LLVMRustWriteOutputFile(\n-                target, pm, m, output_c.as_ptr(), file_type);\n+        let result = llvm::LLVMRustWriteOutputFile(target, pm, m, output_c.as_ptr(), file_type);\n         if result.into_result().is_err() {\n             let msg = format!(\"could not write output to {}\", output.display());\n-            Err(llvm_err(handler, msg))\n+            Err(llvm_err(handler, &msg))\n         } else {\n             Ok(())\n         }\n@@ -140,7 +139,7 @@ pub fn create_target_machine(\n     find_features: bool,\n ) -> &'static mut llvm::TargetMachine {\n     target_machine_factory(sess, find_features)().unwrap_or_else(|err| {\n-        llvm_err(sess.diagnostic(), err).raise()\n+        llvm_err(sess.diagnostic(), &err).raise()\n     })\n }\n \n@@ -456,7 +455,7 @@ impl<'a> Drop for DiagnosticHandlers<'a> {\n unsafe extern \"C\" fn report_inline_asm<'a, 'b>(cgcx: &'a CodegenContext,\n                                                msg: &'b str,\n                                                cookie: c_uint) {\n-    cgcx.diag_emitter.inline_asm_error(cookie as u32, msg.to_string());\n+    cgcx.diag_emitter.inline_asm_error(cookie as u32, msg.to_owned());\n }\n \n unsafe extern \"C\" fn inline_asm_handler(diag: &SMDiagnostic,\n@@ -590,8 +589,7 @@ unsafe fn optimize(cgcx: &CodegenContext,\n \n             for pass in &config.passes {\n                 if !addpass(pass) {\n-                    diag_handler.warn(&format!(\"unknown pass `{}`, ignoring\",\n-                                            pass));\n+                    diag_handler.warn(&format!(\"unknown pass `{}`, ignoring\", pass));\n                 }\n                 if pass == \"name-anon-globals\" {\n                     have_name_anon_globals_pass = true;\n@@ -601,8 +599,8 @@ unsafe fn optimize(cgcx: &CodegenContext,\n             for pass in &cgcx.plugin_passes {\n                 if !addpass(pass) {\n                     diag_handler.err(&format!(\"a plugin asked for LLVM pass \\\n-                                            `{}` but LLVM does not \\\n-                                            recognize it\", pass));\n+                                               `{}` but LLVM does not \\\n+                                               recognize it\", pass));\n                 }\n                 if pass == \"name-anon-globals\" {\n                     have_name_anon_globals_pass = true;\n@@ -613,12 +611,12 @@ unsafe fn optimize(cgcx: &CodegenContext,\n                 // As described above, this will probably cause an error in LLVM\n                 if config.no_prepopulate_passes {\n                     diag_handler.err(\"The current compilation is going to use thin LTO buffers \\\n-                                     without running LLVM's NameAnonGlobals pass. \\\n-                                     This will likely cause errors in LLVM. Consider adding \\\n-                                     -C passes=name-anon-globals to the compiler command line.\");\n+                                      without running LLVM's NameAnonGlobals pass. \\\n+                                      This will likely cause errors in LLVM. Consider adding \\\n+                                      -C passes=name-anon-globals to the compiler command line.\");\n                 } else {\n                     bug!(\"We are using thin LTO buffers without running the NameAnonGlobals pass. \\\n-                         This will likely cause errors in LLVM and should never happen.\");\n+                          This will likely cause errors in LLVM and should never happen.\");\n                 }\n             }\n         }\n@@ -704,9 +702,9 @@ unsafe fn codegen(cgcx: &CodegenContext,\n         // escape the closure itself, and the manager should only be\n         // used once.\n         unsafe fn with_codegen<'ll, F, R>(tm: &'ll llvm::TargetMachine,\n-                                    llmod: &'ll llvm::Module,\n-                                    no_builtins: bool,\n-                                    f: F) -> R\n+                                          llmod: &'ll llvm::Module,\n+                                          no_builtins: bool,\n+                                          f: F) -> R\n             where F: FnOnce(&'ll mut PassManager<'ll>) -> R,\n         {\n             let cpm = llvm::LLVMCreatePassManager();\n@@ -818,15 +816,15 @@ unsafe fn codegen(cgcx: &CodegenContext,\n                 };\n                 with_codegen(tm, llmod, config.no_builtins, |cpm| {\n                     write_output_file(diag_handler, tm, cpm, llmod, &path,\n-                                    llvm::FileType::AssemblyFile)\n+                                      llvm::FileType::AssemblyFile)\n                 })?;\n                 timeline.record(\"asm\");\n             }\n \n             if write_obj {\n                 with_codegen(tm, llmod, config.no_builtins, |cpm| {\n                     write_output_file(diag_handler, tm, cpm, llmod, &obj_out,\n-                                    llvm::FileType::ObjectFile)\n+                                      llvm::FileType::ObjectFile)\n                 })?;\n                 timeline.record(\"obj\");\n             } else if asm_to_obj {\n@@ -947,11 +945,11 @@ fn need_pre_thin_lto_bitcode_for_incr_comp(sess: &Session) -> bool {\n }\n \n pub fn start_async_codegen(tcx: TyCtxt,\n-                               time_graph: Option<TimeGraph>,\n-                               metadata: EncodedMetadata,\n-                               coordinator_receive: Receiver<Box<dyn Any + Send>>,\n-                               total_cgus: usize)\n-                               -> OngoingCodegen {\n+                           time_graph: Option<TimeGraph>,\n+                           metadata: EncodedMetadata,\n+                           coordinator_receive: Receiver<Box<dyn Any + Send>>,\n+                           total_cgus: usize)\n+                           -> OngoingCodegen {\n     let sess = tcx.sess;\n     let crate_name = tcx.crate_name(LOCAL_CRATE);\n     let crate_hash = tcx.crate_hash(LOCAL_CRATE);\n@@ -1116,7 +1114,8 @@ fn copy_all_cgu_workproducts_to_incr_comp_cache_dir(\n         }\n \n         if let Some((id, product)) =\n-                copy_cgu_workproducts_to_incr_comp_cache_dir(sess, &module.name, &files) {\n+            copy_cgu_workproducts_to_incr_comp_cache_dir(sess, &module.name, &files)\n+        {\n             work_products.insert(id, product);\n         }\n     }\n@@ -1441,15 +1440,12 @@ fn execute_copy_from_cache_work_item(cgcx: &CodegenContext,\n                module.name,\n                source_file,\n                obj_out.display());\n-        match link_or_copy(&source_file, &obj_out) {\n-            Ok(_) => { }\n-            Err(err) => {\n-                let diag_handler = cgcx.create_diag_handler();\n-                diag_handler.err(&format!(\"unable to copy {} to {}: {}\",\n-                                          source_file.display(),\n-                                          obj_out.display(),\n-                                          err));\n-            }\n+        if let Err(err) = link_or_copy(&source_file, &obj_out) {\n+            let diag_handler = cgcx.create_diag_handler();\n+            diag_handler.err(&format!(\"unable to copy {} to {}: {}\",\n+                                      source_file.display(),\n+                                      obj_out.display(),\n+                                      err));\n         }\n     }\n \n@@ -1584,10 +1580,8 @@ fn start_executing_work(tcx: TyCtxt,\n \n         let (name, mut cmd) = get_linker(sess, &linker, flavor);\n         cmd.args(&sess.target.target.options.asm_args);\n-        Some(Arc::new(AssemblerCommand {\n-            name,\n-            cmd,\n-        }))\n+\n+        Some(Arc::new(AssemblerCommand { name, cmd }))\n     } else {\n         None\n     };\n@@ -2186,9 +2180,9 @@ pub fn run_assembler(cgcx: &CodegenContext, handler: &Handler, assembly: &Path,\n                 handler.struct_err(&format!(\"linking with `{}` failed: {}\",\n                                             pname.display(),\n                                             prog.status))\n-                    .note(&format!(\"{:?}\", &cmd))\n-                    .note(str::from_utf8(&note[..]).unwrap())\n-                    .emit();\n+                       .note(&format!(\"{:?}\", &cmd))\n+                       .note(str::from_utf8(&note[..]).unwrap())\n+                       .emit();\n                 handler.abort_if_errors();\n             }\n         },\n@@ -2450,8 +2444,8 @@ impl OngoingCodegen {\n     }\n \n     pub(crate) fn submit_pre_codegened_module_to_llvm(&self,\n-                                                       tcx: TyCtxt,\n-                                                       module: ModuleCodegen) {\n+                                                      tcx: TyCtxt,\n+                                                      module: ModuleCodegen) {\n         self.wait_for_signal_to_codegen_item();\n         self.check_for_errors(tcx.sess);\n "}, {"sha": "81d615b5ad70a3505ba53819730a29fa6d1227f6", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -720,6 +720,18 @@ fn declare_intrinsic(cx: &CodegenCx<'ll, '_>, key: &str) -> Option<&'ll Value> {\n     ifn!(\"llvm.bitreverse.i64\", fn(t_i64) -> t_i64);\n     ifn!(\"llvm.bitreverse.i128\", fn(t_i128) -> t_i128);\n \n+    ifn!(\"llvm.fshl.i8\", fn(t_i8, t_i8, t_i8) -> t_i8);\n+    ifn!(\"llvm.fshl.i16\", fn(t_i16, t_i16, t_i16) -> t_i16);\n+    ifn!(\"llvm.fshl.i32\", fn(t_i32, t_i32, t_i32) -> t_i32);\n+    ifn!(\"llvm.fshl.i64\", fn(t_i64, t_i64, t_i64) -> t_i64);\n+    ifn!(\"llvm.fshl.i128\", fn(t_i128, t_i128, t_i128) -> t_i128);\n+\n+    ifn!(\"llvm.fshr.i8\", fn(t_i8, t_i8, t_i8) -> t_i8);\n+    ifn!(\"llvm.fshr.i16\", fn(t_i16, t_i16, t_i16) -> t_i16);\n+    ifn!(\"llvm.fshr.i32\", fn(t_i32, t_i32, t_i32) -> t_i32);\n+    ifn!(\"llvm.fshr.i64\", fn(t_i64, t_i64, t_i64) -> t_i64);\n+    ifn!(\"llvm.fshr.i128\", fn(t_i128, t_i128, t_i128) -> t_i128);\n+\n     ifn!(\"llvm.sadd.with.overflow.i8\", fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n     ifn!(\"llvm.sadd.with.overflow.i16\", fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n     ifn!(\"llvm.sadd.with.overflow.i32\", fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});"}, {"sha": "00f06645930c25209560492b8421f7f042bcdfb2", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -23,6 +23,7 @@ use value::Value;\n use llvm;\n use llvm::debuginfo::{DIType, DIFile, DIScope, DIDescriptor,\n                       DICompositeType, DILexicalBlock, DIFlags};\n+use llvm_util;\n \n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc::hir::CodegenFnAttrFlags;\n@@ -1169,9 +1170,8 @@ fn prepare_union_metadata(\n fn use_enum_fallback(cx: &CodegenCx) -> bool {\n     // On MSVC we have to use the fallback mode, because LLVM doesn't\n     // lower variant parts to PDB.\n-    return cx.sess().target.target.options.is_like_msvc || unsafe {\n-        llvm::LLVMRustVersionMajor() < 7\n-    };\n+    return cx.sess().target.target.options.is_like_msvc\n+        || llvm_util::get_major_version() < 7;\n }\n \n // Describes the members of an enum value: An enum is described as a union of"}, {"sha": "a5f90149f4ac47293715041893956d31d8c5bae2", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -13,6 +13,7 @@\n use attributes;\n use intrinsics::{self, Intrinsic};\n use llvm::{self, TypeKind};\n+use llvm_util;\n use abi::{Abi, FnType, LlvmType, PassMode};\n use mir::place::PlaceRef;\n use mir::operand::{OperandRef, OperandValue};\n@@ -284,7 +285,8 @@ pub fn codegen_intrinsic_call(\n         \"ctlz\" | \"ctlz_nonzero\" | \"cttz\" | \"cttz_nonzero\" | \"ctpop\" | \"bswap\" |\n         \"bitreverse\" | \"add_with_overflow\" | \"sub_with_overflow\" |\n         \"mul_with_overflow\" | \"overflowing_add\" | \"overflowing_sub\" | \"overflowing_mul\" |\n-        \"unchecked_div\" | \"unchecked_rem\" | \"unchecked_shl\" | \"unchecked_shr\" | \"exact_div\" => {\n+        \"unchecked_div\" | \"unchecked_rem\" | \"unchecked_shl\" | \"unchecked_shr\" | \"exact_div\" |\n+        \"rotate_left\" | \"rotate_right\" => {\n             let ty = arg_tys[0];\n             match int_type_width_signed(ty, cx) {\n                 Some((width, signed)) =>\n@@ -363,6 +365,27 @@ pub fn codegen_intrinsic_call(\n                             } else {\n                                 bx.lshr(args[0].immediate(), args[1].immediate())\n                             },\n+                        \"rotate_left\" | \"rotate_right\" => {\n+                            let is_left = name == \"rotate_left\";\n+                            let val = args[0].immediate();\n+                            let raw_shift = args[1].immediate();\n+                            if llvm_util::get_major_version() >= 7 {\n+                                // rotate = funnel shift with first two args the same\n+                                let llvm_name = &format!(\"llvm.fsh{}.i{}\",\n+                                                         if is_left { 'l' } else { 'r' }, width);\n+                                let llfn = cx.get_intrinsic(llvm_name);\n+                                bx.call(llfn, &[val, val, raw_shift], None)\n+                            } else {\n+                                // rotate_left: (X << (S % BW)) | (X >> ((BW - S) % BW))\n+                                // rotate_right: (X << ((BW - S) % BW)) | (X >> (S % BW))\n+                                let width = C_uint(Type::ix(cx, width), width);\n+                                let shift = bx.urem(raw_shift, width);\n+                                let inv_shift = bx.urem(bx.sub(width, raw_shift), width);\n+                                let shift1 = bx.shl(val, if is_left { shift } else { inv_shift });\n+                                let shift2 = bx.lshr(val, if !is_left { shift } else { inv_shift });\n+                                bx.or(shift1, shift2)\n+                            }\n+                        },\n                         _ => bug!(),\n                     },\n                 None => {"}, {"sha": "eaa599e0cd0fa67f8382eda55fe7575f9aadf9ad", "filename": "src/librustc_codegen_llvm/llvm_util.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -257,6 +257,10 @@ pub fn print_version() {\n     }\n }\n \n+pub fn get_major_version() -> u32 {\n+    unsafe { llvm::LLVMRustVersionMajor() }\n+}\n+\n pub fn print_passes() {\n     // Can be called without initializing LLVM\n     unsafe { llvm::LLVMRustPrintPasses(); }"}, {"sha": "0dc5a4ddde82c538bc820518cff99dfb18b3f5cd", "filename": "src/librustc_codegen_llvm/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_codegen_llvm%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_codegen_llvm%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmeth.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -39,7 +39,7 @@ impl<'a, 'tcx> VirtualIndex {\n         // Load the data pointer from the object.\n         debug!(\"get_fn({:?}, {:?})\", llvtable, self);\n \n-        let llvtable = bx.pointercast(llvtable, fn_ty.llvm_type(bx.cx).ptr_to().ptr_to());\n+        let llvtable = bx.pointercast(llvtable, fn_ty.ptr_to_llvm_type(bx.cx).ptr_to());\n         let ptr_align = bx.tcx().data_layout.pointer_align;\n         let ptr = bx.load(bx.inbounds_gep(llvtable, &[C_usize(bx.cx, self.0)]), ptr_align);\n         bx.nonnull_metadata(ptr);"}, {"sha": "e5b25ea068b3b7fd463c7fabc7afd987a7cd3a0b", "filename": "src/librustc_codegen_llvm/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -12,6 +12,7 @@ use common::{C_i32, C_null};\n use libc::c_uint;\n use llvm::{self, BasicBlock};\n use llvm::debuginfo::DIScope;\n+use llvm_util;\n use rustc::ty::{self, Ty, TypeFoldable, UpvarSubsts};\n use rustc::ty::layout::{LayoutOf, TyLayout};\n use rustc::mir::{self, Mir};\n@@ -612,7 +613,7 @@ fn arg_local_refs(\n             // doesn't actually strip the offset when splitting the closure\n             // environment into its components so it ends up out of bounds.\n             // (cuviper) It seems to be fine without the alloca on LLVM 6 and later.\n-            let env_alloca = !env_ref && unsafe { llvm::LLVMRustVersionMajor() < 6 };\n+            let env_alloca = !env_ref && llvm_util::get_major_version() < 6;\n             let env_ptr = if env_alloca {\n                 let scratch = PlaceRef::alloca(bx,\n                     bx.cx.layout_of(tcx.mk_mut_ptr(arg.layout.ty)),"}, {"sha": "6fb78fe4aa5a4124c590b755153451f3a4fab0c0", "filename": "src/librustc_codegen_llvm/type_.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -234,6 +234,8 @@ impl Type {\n     }\n \n     pub fn ptr_to(&self) -> &Type {\n+        assert_ne!(self.kind(), TypeKind::Function,\n+                   \"don't call ptr_to on function types, use ptr_to_llvm_type on FnType instead\");\n         unsafe {\n             llvm::LLVMPointerType(self, 0)\n         }"}, {"sha": "fea02edf7be01b70748d68f73f53285515b6e5d2", "filename": "src/librustc_codegen_llvm/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_of.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -265,7 +265,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n                         ty::ParamEnv::reveal_all(),\n                         &sig,\n                     );\n-                    FnType::new(cx, sig, &[]).llvm_type(cx).ptr_to()\n+                    FnType::new(cx, sig, &[]).ptr_to_llvm_type(cx)\n                 }\n                 _ => self.scalar_llvm_type_at(cx, scalar, Size::ZERO)\n             };"}, {"sha": "ae1d77f1521893f84a705b94c03ae89b880a76b0", "filename": "src/librustc_codegen_utils/linker.rs", "status": "modified", "additions": 18, "deletions": 30, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_codegen_utils%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_codegen_utils%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Flinker.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -224,9 +224,9 @@ impl<'a> GccLinker<'a> {\n }\n \n impl<'a> Linker for GccLinker<'a> {\n-    fn link_dylib(&mut self, lib: &str) { self.hint_dynamic(); self.cmd.arg(format!(\"-l{}\",lib)); }\n+    fn link_dylib(&mut self, lib: &str) { self.hint_dynamic(); self.cmd.arg(format!(\"-l{}\", lib)); }\n     fn link_staticlib(&mut self, lib: &str) {\n-        self.hint_static(); self.cmd.arg(format!(\"-l{}\",lib));\n+        self.hint_static(); self.cmd.arg(format!(\"-l{}\", lib));\n     }\n     fn link_rlib(&mut self, lib: &Path) { self.hint_static(); self.cmd.arg(lib); }\n     fn include_path(&mut self, path: &Path) { self.cmd.arg(\"-L\").arg(path); }\n@@ -243,7 +243,7 @@ impl<'a> Linker for GccLinker<'a> {\n \n     fn link_rust_dylib(&mut self, lib: &str, _path: &Path) {\n         self.hint_dynamic();\n-        self.cmd.arg(format!(\"-l{}\",lib));\n+        self.cmd.arg(format!(\"-l{}\", lib));\n     }\n \n     fn link_framework(&mut self, framework: &str) {\n@@ -261,7 +261,7 @@ impl<'a> Linker for GccLinker<'a> {\n         self.hint_static();\n         let target = &self.sess.target.target;\n         if !target.options.is_like_osx {\n-            self.linker_arg(\"--whole-archive\").cmd.arg(format!(\"-l{}\",lib));\n+            self.linker_arg(\"--whole-archive\").cmd.arg(format!(\"-l{}\", lib));\n             self.linker_arg(\"--no-whole-archive\");\n         } else {\n             // -force_load is the macOS equivalent of --whole-archive, but it\n@@ -343,17 +343,13 @@ impl<'a> Linker for GccLinker<'a> {\n     }\n \n     fn debuginfo(&mut self) {\n-        match self.sess.opts.debuginfo {\n-            DebugInfo::None => {\n-                // If we are building without debuginfo enabled and we were called with\n-                // `-Zstrip-debuginfo-if-disabled=yes`, tell the linker to strip any debuginfo\n-                // found when linking to get rid of symbols from libstd.\n-                match self.sess.opts.debugging_opts.strip_debuginfo_if_disabled {\n-                    Some(true) => { self.linker_arg(\"-S\"); },\n-                    _ => {},\n-                }\n-            },\n-            _ => {},\n+        if let DebugInfo::None = self.sess.opts.debuginfo {\n+            // If we are building without debuginfo enabled and we were called with\n+            // `-Zstrip-debuginfo-if-disabled=yes`, tell the linker to strip any debuginfo\n+            // found when linking to get rid of symbols from libstd.\n+            if let Some(true) = self.sess.opts.debugging_opts.strip_debuginfo_if_disabled {\n+                self.linker_arg(\"-S\");\n+            }\n         };\n     }\n \n@@ -373,8 +369,7 @@ impl<'a> Linker for GccLinker<'a> {\n             // purely to support rustbuild right now, we should get a more\n             // principled solution at some point to force the compiler to pass\n             // the right `-Wl,-install_name` with an `@rpath` in it.\n-            if self.sess.opts.cg.rpath ||\n-               self.sess.opts.debugging_opts.osx_rpath_install_name {\n+            if self.sess.opts.cg.rpath || self.sess.opts.debugging_opts.osx_rpath_install_name {\n                 self.linker_arg(\"-install_name\");\n                 let mut v = OsString::from(\"@rpath/\");\n                 v.push(out_filename.file_name().unwrap());\n@@ -461,9 +456,8 @@ impl<'a> Linker for GccLinker<'a> {\n \n     fn finalize(&mut self) -> Command {\n         self.hint_dynamic(); // Reset to default before returning the composed command line.\n-        let mut cmd = Command::new(\"\");\n-        ::std::mem::swap(&mut cmd, &mut self.cmd);\n-        cmd\n+\n+        ::std::mem::replace(&mut self.cmd, Command::new(\"\"))\n     }\n \n     fn group_start(&mut self) {\n@@ -715,9 +709,7 @@ impl<'a> Linker for MsvcLinker<'a> {\n     }\n \n     fn finalize(&mut self) -> Command {\n-        let mut cmd = Command::new(\"\");\n-        ::std::mem::swap(&mut cmd, &mut self.cmd);\n-        cmd\n+        ::std::mem::replace(&mut self.cmd, Command::new(\"\"))\n     }\n \n     // MSVC doesn't need group indicators\n@@ -865,7 +857,7 @@ impl<'a> Linker for EmLinker<'a> {\n             let res = encoder.emit_seq(symbols.len(), |encoder| {\n                 for (i, sym) in symbols.iter().enumerate() {\n                     encoder.emit_seq_elt(i, |encoder| {\n-                        encoder.emit_str(&(\"_\".to_string() + sym))\n+                        encoder.emit_str(&(\"_\".to_owned() + sym))\n                     })?;\n                 }\n                 Ok(())\n@@ -885,9 +877,7 @@ impl<'a> Linker for EmLinker<'a> {\n     }\n \n     fn finalize(&mut self) -> Command {\n-        let mut cmd = Command::new(\"\");\n-        ::std::mem::swap(&mut cmd, &mut self.cmd);\n-        cmd\n+        ::std::mem::replace(&mut self.cmd, Command::new(\"\"))\n     }\n \n     // Appears not necessary on Emscripten\n@@ -1085,9 +1075,7 @@ impl<'a> Linker for WasmLd<'a> {\n         // indicative of bugs, let's prevent them.\n         self.cmd.arg(\"--fatal-warnings\");\n \n-        let mut cmd = Command::new(\"\");\n-        ::std::mem::swap(&mut cmd, &mut self.cmd);\n-        cmd\n+        ::std::mem::replace(&mut self.cmd, Command::new(\"\"))\n     }\n \n     // Not needed for now with LLD"}, {"sha": "dff7e518630e4d23628aea3f6db9000caf04a35a", "filename": "src/librustc_codegen_utils/symbol_export.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_codegen_utils%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_codegen_utils%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_export.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -47,11 +47,10 @@ fn crate_export_threshold(crate_type: config::CrateType) -> SymbolExportLevel {\n     }\n }\n \n-pub fn crates_export_threshold(crate_types: &[config::CrateType])\n-                                      -> SymbolExportLevel {\n-    if crate_types.iter().any(|&crate_type| {\n-        crate_export_threshold(crate_type) == SymbolExportLevel::Rust\n-    }) {\n+pub fn crates_export_threshold(crate_types: &[config::CrateType]) -> SymbolExportLevel {\n+    if crate_types.iter().any(|&crate_type|\n+        crate_export_threshold(crate_type) == SymbolExportLevel::Rust)\n+    {\n         SymbolExportLevel::Rust\n     } else {\n         SymbolExportLevel::C\n@@ -359,7 +358,7 @@ fn is_unreachable_local_definition_provider(tcx: TyCtxt, def_id: DefId) -> bool\n         !tcx.reachable_set(LOCAL_CRATE).0.contains(&node_id)\n     } else {\n         bug!(\"is_unreachable_local_definition called with non-local DefId: {:?}\",\n-              def_id)\n+             def_id)\n     }\n }\n "}, {"sha": "8c0e9bd11a173da5813c13157f8244af22204632", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -317,11 +317,6 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n             reference: \"issue #51443 <https://github.com/rust-lang/rust/issues/51443>\",\n             edition: None,\n         },\n-        FutureIncompatibleInfo {\n-            id: LintId::of(DUPLICATE_ASSOCIATED_TYPE_BINDINGS),\n-            reference: \"issue #50589 <https://github.com/rust-lang/rust/issues/50589>\",\n-            edition: None,\n-        },\n         FutureIncompatibleInfo {\n             id: LintId::of(PROC_MACRO_DERIVE_RESOLUTION_FALLBACK),\n             reference: \"issue #50504 <https://github.com/rust-lang/rust/issues/50504>\","}, {"sha": "a32fb0503a814e6ba74f7e65f3134091de8eded8", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -687,22 +687,24 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         let mir_node_id = tcx.hir.as_local_node_id(mir_def_id).expect(\"non-local mir\");\n \n-        let (return_span, mir_description) =\n-            if let hir::ExprKind::Closure(_, _, _, span, gen_move) =\n-                tcx.hir.expect_expr(mir_node_id).node\n-            {\n-                (\n-                    tcx.sess.source_map().end_point(span),\n-                    if gen_move.is_some() {\n-                        \" of generator\"\n-                    } else {\n-                        \" of closure\"\n-                    },\n-                )\n-            } else {\n-                // unreachable?\n-                (mir.span, \"\")\n-            };\n+        let (return_span, mir_description) = match tcx.hir.get(mir_node_id) {\n+            hir::Node::Expr(hir::Expr {\n+                node: hir::ExprKind::Closure(_, _, _, span, gen_move),\n+                ..\n+            }) => (\n+                tcx.sess.source_map().end_point(*span),\n+                if gen_move.is_some() {\n+                    \" of generator\"\n+                } else {\n+                    \" of closure\"\n+                },\n+            ),\n+            hir::Node::ImplItem(hir::ImplItem {\n+                node: hir::ImplItemKind::Method(method_sig, _),\n+                ..\n+            }) => (method_sig.decl.output.span(), \"\"),\n+            _ => (mir.span, \"\"),\n+        };\n \n         Some(RegionName {\n             // This counter value will already have been used, so this function will increment it"}, {"sha": "a057f2f45c0105e8090de91b4e049d2f4a466523", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 27, "deletions": 8, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -1021,20 +1021,39 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 let v1 = ty::Contravariant.xform(v);\n \n                 let tcx = self.infcx.tcx;\n-                let mut projected_ty = PlaceTy::from_ty(ty);\n+                let ty = self.normalize(ty, locations);\n+\n+                // We need to follow any provided projetions into the type.\n+                //\n+                // if we hit a ty var as we descend, then just skip the\n+                // attempt to relate the mir local with any type.\n+                #[derive(Debug)] struct HitTyVar;\n+                let mut curr_projected_ty: Result<PlaceTy, HitTyVar>;\n+\n+                curr_projected_ty = Ok(PlaceTy::from_ty(ty));\n                 for proj in &user_ty.projs {\n-                    projected_ty = projected_ty.projection_ty_core(\n+                    let projected_ty = if let Ok(projected_ty) = curr_projected_ty {\n+                        projected_ty\n+                    } else {\n+                        break;\n+                    };\n+                    curr_projected_ty = projected_ty.projection_ty_core(\n                         tcx, proj, |this, field, &()| {\n-                            let ty = this.field_ty(tcx, field);\n-                            self.normalize(ty, locations)\n+                            if this.to_ty(tcx).is_ty_var() {\n+                                Err(HitTyVar)\n+                            } else {\n+                                let ty = this.field_ty(tcx, field);\n+                                Ok(self.normalize(ty, locations))\n+                            }\n                         });\n                 }\n                 debug!(\"user_ty base: {:?} freshened: {:?} projs: {:?} yields: {:?}\",\n-                       user_ty.base, ty, user_ty.projs, projected_ty);\n+                       user_ty.base, ty, user_ty.projs, curr_projected_ty);\n \n-                let ty = projected_ty.to_ty(tcx);\n-\n-                self.relate_types(ty, v1, a, locations, category)?;\n+                if let Ok(projected_ty) = curr_projected_ty {\n+                    let ty = projected_ty.to_ty(tcx);\n+                    self.relate_types(ty, v1, a, locations, category)?;\n+                }\n             }\n             UserTypeAnnotation::TypeOf(def_id, canonical_substs) => {\n                 let ("}, {"sha": "3eb3d7600fd31600819df3ff5efda1c006131fa0", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -150,6 +150,24 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                 }\n                 self.write_scalar(val, dest)?;\n             }\n+            \"rotate_left\" | \"rotate_right\" => {\n+                // rotate_left: (X << (S % BW)) | (X >> ((BW - S) % BW))\n+                // rotate_right: (X << ((BW - S) % BW)) | (X >> (S % BW))\n+                let layout = self.layout_of(substs.type_at(0))?;\n+                let val_bits = self.read_scalar(args[0])?.to_bits(layout.size)?;\n+                let raw_shift_bits = self.read_scalar(args[1])?.to_bits(layout.size)?;\n+                let width_bits = layout.size.bits() as u128;\n+                let shift_bits = raw_shift_bits % width_bits;\n+                let inv_shift_bits = (width_bits - raw_shift_bits) % width_bits;\n+                let result_bits = if intrinsic_name == \"rotate_left\" {\n+                    (val_bits << shift_bits) | (val_bits >> inv_shift_bits)\n+                } else {\n+                    (val_bits >> shift_bits) | (val_bits << inv_shift_bits)\n+                };\n+                let truncated_bits = self.truncate(result_bits, layout);\n+                let result = Scalar::from_uint(truncated_bits, layout.size);\n+                self.write_scalar(result, dest)?;\n+            }\n             \"transmute\" => {\n                 self.copy_op_transmute(args[0], dest)?;\n             }"}, {"sha": "98311444e28718d3b24aef07a04d92ba9a221e22", "filename": "src/librustc_mir/transform/cleanup_post_borrowck.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -37,6 +37,7 @@ use rustc::mir::{BasicBlock, FakeReadCause, Local, Location, Mir, Place};\n use rustc::mir::{Rvalue, Statement, StatementKind};\n use rustc::mir::visit::{MutVisitor, Visitor, TyContext};\n use rustc::ty::{Ty, RegionKind, TyCtxt};\n+use smallvec::smallvec;\n use transform::{MirPass, MirSource};\n \n pub struct CleanEndRegions;\n@@ -80,7 +81,11 @@ impl<'tcx> Visitor<'tcx> for GatherBorrowedRegions {\n \n     fn visit_ty(&mut self, ty: &Ty<'tcx>, _: TyContext) {\n         // Gather regions that occur in types\n-        for re in ty.walk().flat_map(|t| t.regions()) {\n+        let mut regions = smallvec![];\n+        for t in ty.walk() {\n+            t.push_regions(&mut regions);\n+        }\n+        for re in regions {\n             match *re {\n                 RegionKind::ReScope(ce) => { self.seen_regions.insert(ce); }\n                 _ => {},"}, {"sha": "885d70dc4304dee3e3cd02c3118df7555aab58b6", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -591,8 +591,8 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for ConstPropagator<'b, 'a, 'tcx> {\n         if let TerminatorKind::Assert { expected, msg, cond, .. } = kind {\n             if let Some(value) = self.eval_operand(cond, source_info) {\n                 trace!(\"assertion on {:?} should be {:?}\", value, expected);\n-                let expected = Immediate::Scalar(Scalar::from_bool(*expected).into());\n-                if expected != value.0.to_immediate() {\n+                let expected = ScalarMaybeUndef::from(Scalar::from_bool(*expected));\n+                if expected != self.ecx.read_scalar(value.0).unwrap() {\n                     // poison all places this operand references so that further code\n                     // doesn't use the invalid value\n                     match cond {\n@@ -628,20 +628,20 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for ConstPropagator<'b, 'a, 'tcx> {\n                             let len = self\n                                 .eval_operand(len, source_info)\n                                 .expect(\"len must be const\");\n-                            let len = match len.0.to_immediate() {\n-                                Immediate::Scalar(ScalarMaybeUndef::Scalar(Scalar::Bits {\n+                            let len = match self.ecx.read_scalar(len.0) {\n+                                Ok(ScalarMaybeUndef::Scalar(Scalar::Bits {\n                                     bits, ..\n                                 })) => bits,\n-                                _ => bug!(\"const len not primitive: {:?}\", len),\n+                                other => bug!(\"const len not primitive: {:?}\", other),\n                             };\n                             let index = self\n                                 .eval_operand(index, source_info)\n                                 .expect(\"index must be const\");\n-                            let index = match index.0.to_immediate() {\n-                                Immediate::Scalar(ScalarMaybeUndef::Scalar(Scalar::Bits {\n+                            let index = match self.ecx.read_scalar(index.0) {\n+                                Ok(ScalarMaybeUndef::Scalar(Scalar::Bits {\n                                     bits, ..\n                                 })) => bits,\n-                                _ => bug!(\"const index not primitive: {:?}\", index),\n+                                other => bug!(\"const index not primitive: {:?}\", other),\n                             };\n                             format!(\n                                 \"index out of bounds: \\"}, {"sha": "1cce0de5152fda7bd649b1b92c80235f9a2958d6", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 49, "deletions": 45, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -19,7 +19,7 @@ use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n \n use rustc::mir::*;\n use rustc::mir::visit::*;\n-use rustc::ty::{self, Instance, InstanceDef, Ty, TyCtxt};\n+use rustc::ty::{self, Instance, InstanceDef, ParamEnv, Ty, TyCtxt};\n use rustc::ty::subst::{Subst,Substs};\n \n use std::collections::VecDeque;\n@@ -85,39 +85,16 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n         // Only do inlining into fn bodies.\n         let id = self.tcx.hir.as_local_node_id(self.source.def_id).unwrap();\n         let body_owner_kind = self.tcx.hir.body_owner_kind(id);\n+\n         if let (hir::BodyOwnerKind::Fn, None) = (body_owner_kind, self.source.promoted) {\n \n             for (bb, bb_data) in caller_mir.basic_blocks().iter_enumerated() {\n-                // Don't inline calls that are in cleanup blocks.\n-                if bb_data.is_cleanup { continue; }\n-\n-                // Only consider direct calls to functions\n-                let terminator = bb_data.terminator();\n-                if let TerminatorKind::Call {\n-                    func: ref op, .. } = terminator.kind {\n-                        if let ty::FnDef(callee_def_id, substs) = op.ty(caller_mir, self.tcx).sty {\n-                            if let Some(instance) = Instance::resolve(self.tcx,\n-                                                                      param_env,\n-                                                                      callee_def_id,\n-                                                                      substs) {\n-                                let is_virtual =\n-                                    if let InstanceDef::Virtual(..) = instance.def {\n-                                        true\n-                                    } else {\n-                                        false\n-                                    };\n-\n-                                if !is_virtual {\n-                                    callsites.push_back(CallSite {\n-                                        callee: instance.def_id(),\n-                                        substs: instance.substs,\n-                                        bb,\n-                                        location: terminator.source_info\n-                                    });\n-                                }\n-                            }\n-                        }\n-                    }\n+                if let Some(callsite) = self.get_valid_function_call(bb,\n+                                                                     bb_data,\n+                                                                     caller_mir,\n+                                                                     param_env) {\n+                    callsites.push_back(callsite);\n+                }\n             }\n         } else {\n             return;\n@@ -163,20 +140,13 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n \n                 // Add callsites from inlined function\n                 for (bb, bb_data) in caller_mir.basic_blocks().iter_enumerated().skip(start) {\n-                    // Only consider direct calls to functions\n-                    let terminator = bb_data.terminator();\n-                    if let TerminatorKind::Call {\n-                        func: Operand::Constant(ref f), .. } = terminator.kind {\n-                        if let ty::FnDef(callee_def_id, substs) = f.ty.sty {\n-                            // Don't inline the same function multiple times.\n-                            if callsite.callee != callee_def_id {\n-                                callsites.push_back(CallSite {\n-                                    callee: callee_def_id,\n-                                    substs,\n-                                    bb,\n-                                    location: terminator.source_info\n-                                });\n-                            }\n+                    if let Some(new_callsite) = self.get_valid_function_call(bb,\n+                                                                             bb_data,\n+                                                                             caller_mir,\n+                                                                             param_env) {\n+                        // Don't inline the same function multiple times.\n+                        if callsite.callee != new_callsite.callee {\n+                            callsites.push_back(new_callsite);\n                         }\n                     }\n                 }\n@@ -198,6 +168,40 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n         }\n     }\n \n+    fn get_valid_function_call(&self,\n+                               bb: BasicBlock,\n+                               bb_data: &BasicBlockData<'tcx>,\n+                               caller_mir: &Mir<'tcx>,\n+                               param_env: ParamEnv<'tcx>,\n+    ) -> Option<CallSite<'tcx>> {\n+        // Don't inline calls that are in cleanup blocks.\n+        if bb_data.is_cleanup { return None; }\n+\n+        // Only consider direct calls to functions\n+        let terminator = bb_data.terminator();\n+        if let TerminatorKind::Call { func: ref op, .. } = terminator.kind {\n+            if let ty::FnDef(callee_def_id, substs) = op.ty(caller_mir, self.tcx).sty {\n+                let instance = Instance::resolve(self.tcx,\n+                                                 param_env,\n+                                                 callee_def_id,\n+                                                 substs)?;\n+\n+                if let InstanceDef::Virtual(..) = instance.def {\n+                    return None;\n+                }\n+\n+                return Some(CallSite {\n+                    callee: instance.def_id(),\n+                    substs: instance.substs,\n+                    bb,\n+                    location: terminator.source_info\n+                });\n+            }\n+        }\n+\n+        None\n+    }\n+\n     fn consider_optimizing(&self,\n                            callsite: CallSite<'tcx>,\n                            callee_mir: &Mir<'tcx>)"}, {"sha": "03497be03087b4fbafa495ca41cf9279cf694949", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -869,6 +869,8 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                             | \"overflowing_mul\"\n                             | \"unchecked_shl\"\n                             | \"unchecked_shr\"\n+                            | \"rotate_left\"\n+                            | \"rotate_right\"\n                             | \"add_with_overflow\"\n                             | \"sub_with_overflow\"\n                             | \"mul_with_overflow\""}, {"sha": "db5b516e7b23b4c3fe5441a8876098b5e51177d7", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -663,10 +663,13 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     binding.map(|binding| (binding, Flags::MODULE, Flags::empty()))\n                 }\n                 WhereToResolve::MacroUsePrelude => {\n-                    match self.macro_use_prelude.get(&ident.name).cloned() {\n-                        Some(binding) => Ok((binding, Flags::PRELUDE, Flags::empty())),\n-                        None => Err(Determinacy::Determined),\n+                    let mut result = Err(Determinacy::Determined);\n+                    if use_prelude || self.session.rust_2015() {\n+                        if let Some(binding) = self.macro_use_prelude.get(&ident.name).cloned() {\n+                            result = Ok((binding, Flags::PRELUDE, Flags::empty()));\n+                        }\n                     }\n+                    result\n                 }\n                 WhereToResolve::BuiltinMacros => {\n                     match self.builtin_macros.get(&ident.name).cloned() {\n@@ -685,7 +688,8 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     }\n                 }\n                 WhereToResolve::LegacyPluginHelpers => {\n-                    if self.session.plugin_attributes.borrow().iter()\n+                    if (use_prelude || self.session.rust_2015()) &&\n+                       self.session.plugin_attributes.borrow().iter()\n                                                      .any(|(name, _)| ident.name == &**name) {\n                         let binding = (Def::NonMacroAttr(NonMacroAttrKind::LegacyPluginHelper),\n                                        ty::Visibility::Public, ident.span, Mark::root())"}, {"sha": "15f61a033447fffacc782b2b4bc011f71a1d65ce", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -35,7 +35,8 @@ pub struct TargetDataLayout {\n     pub aggregate_align: Align,\n \n     /// Alignments for vector types.\n-    pub vector_align: Vec<(Size, Align)>\n+    pub vector_align: Vec<(Size, Align)>,\n+    pub instruction_address_space: u32,\n }\n \n impl Default for TargetDataLayout {\n@@ -57,13 +58,22 @@ impl Default for TargetDataLayout {\n             vector_align: vec![\n                 (Size::from_bits(64), Align::from_bits(64, 64).unwrap()),\n                 (Size::from_bits(128), Align::from_bits(128, 128).unwrap())\n-            ]\n+            ],\n+            instruction_address_space: 0,\n         }\n     }\n }\n \n impl TargetDataLayout {\n     pub fn parse(target: &Target) -> Result<TargetDataLayout, String> {\n+        // Parse an address space index from a string.\n+        let parse_address_space = |s: &str, cause: &str| {\n+            s.parse::<u32>().map_err(|err| {\n+                format!(\"invalid address space `{}` for `{}` in \\\"data-layout\\\": {}\",\n+                        s, cause, err)\n+            })\n+        };\n+\n         // Parse a bit count from a string.\n         let parse_bits = |s: &str, kind: &str, cause: &str| {\n             s.parse::<u64>().map_err(|err| {\n@@ -96,6 +106,9 @@ impl TargetDataLayout {\n             match spec.split(':').collect::<Vec<_>>()[..] {\n                 [\"e\"] => dl.endian = Endian::Little,\n                 [\"E\"] => dl.endian = Endian::Big,\n+                [p] if p.starts_with(\"P\") => {\n+                    dl.instruction_address_space = parse_address_space(&p[1..], \"P\")?\n+                }\n                 [\"a\", ref a..] => dl.aggregate_align = align(a, \"a\")?,\n                 [\"f32\", ref a..] => dl.f32_align = align(a, \"f32\")?,\n                 [\"f64\", ref a..] => dl.f64_align = align(a, \"f64\")?,"}, {"sha": "2c80f3b4b3b02c68da0f9670601f9f8191ae5c9b", "filename": "src/librustc_target/spec/wasm32_unknown_emscripten.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_target%2Fspec%2Fwasm32_unknown_emscripten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_target%2Fspec%2Fwasm32_unknown_emscripten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fwasm32_unknown_emscripten.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -11,12 +11,18 @@\n use super::{LinkArgs, LinkerFlavor, Target, TargetOptions};\n \n pub fn target() -> Result<Target, String> {\n+    // FIXME(nikic) BINARYEN_TRAP_MODE=clamp is needed to avoid trapping in our\n+    // -Zsaturating-float-casts implementation. This can be dropped if/when\n+    // we have native fpto[su]i.sat intrinsics, or the implementation otherwise\n+    // stops relying on non-trapping fpto[su]i.\n     let mut post_link_args = LinkArgs::new();\n     post_link_args.insert(LinkerFlavor::Em,\n                           vec![\"-s\".to_string(),\n                                \"BINARYEN=1\".to_string(),\n                                \"-s\".to_string(),\n-                               \"ERROR_ON_UNDEFINED_SYMBOLS=1\".to_string()]);\n+                               \"ERROR_ON_UNDEFINED_SYMBOLS=1\".to_string(),\n+                               \"-s\".to_string(),\n+                               \"BINARYEN_TRAP_MODE='clamp'\".to_string()]);\n \n     let opts = TargetOptions {\n         dynamic_linking: false,"}, {"sha": "7514c2c18e7ca8f77aec0fbe7fcd15be28e12c8a", "filename": "src/librustc_traits/implied_outlives_bounds.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -20,6 +20,7 @@ use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::outlives::Component;\n use rustc::ty::query::Providers;\n use rustc::ty::wf;\n+use smallvec::{SmallVec, smallvec};\n use syntax::ast::DUMMY_NODE_ID;\n use syntax::source_map::DUMMY_SP;\n use rustc::traits::FulfillmentContext;\n@@ -133,7 +134,8 @@ fn compute_implied_outlives_bounds<'tcx>(\n                     None => vec![],\n                     Some(ty::OutlivesPredicate(ty_a, r_b)) => {\n                         let ty_a = infcx.resolve_type_vars_if_possible(&ty_a);\n-                        let components = tcx.outlives_components(ty_a);\n+                        let mut components = smallvec![];\n+                        tcx.push_outlives_components(ty_a, &mut components);\n                         implied_bounds_from_components(r_b, components)\n                     }\n                 },\n@@ -155,7 +157,7 @@ fn compute_implied_outlives_bounds<'tcx>(\n /// those relationships.\n fn implied_bounds_from_components(\n     sub_region: ty::Region<'tcx>,\n-    sup_components: Vec<Component<'tcx>>,\n+    sup_components: SmallVec<[Component<'tcx>; 4]>,\n ) -> Vec<OutlivesBound<'tcx>> {\n     sup_components\n         .into_iter()"}, {"sha": "e635bc9efc45c0572326d00d87d6776d014aae6d", "filename": "src/librustc_traits/type_op.rs", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_traits%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_traits%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Ftype_op.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -151,17 +151,35 @@ impl AscribeUserTypeCx<'me, 'gcx, 'tcx> {\n         debug!(\"relate_type_and_user_type: ty of def-id is {:?}\", ty);\n         let ty = self.normalize(ty);\n \n-        let mut projected_ty = PlaceTy::from_ty(ty);\n+        // We need to follow any provided projetions into the type.\n+        //\n+        // if we hit a ty var as we descend, then just skip the\n+        // attempt to relate the mir local with any type.\n+\n+        struct HitTyVar;\n+        let mut curr_projected_ty: Result<PlaceTy, HitTyVar>;\n+        curr_projected_ty = Ok(PlaceTy::from_ty(ty));\n         for proj in projs {\n-            projected_ty = projected_ty.projection_ty_core(\n+            let projected_ty = if let Ok(projected_ty) = curr_projected_ty {\n+                projected_ty\n+            } else {\n+                break;\n+            };\n+            curr_projected_ty = projected_ty.projection_ty_core(\n                 tcx, proj, |this, field, &()| {\n-                    let ty = this.field_ty(tcx, field);\n-                    self.normalize(ty)\n+                    if this.to_ty(tcx).is_ty_var() {\n+                        Err(HitTyVar)\n+                    } else {\n+                        let ty = this.field_ty(tcx, field);\n+                        Ok(self.normalize(ty))\n+                    }\n                 });\n         }\n-        let ty = projected_ty.to_ty(tcx);\n \n-        self.relate(mir_ty, variance, ty)?;\n+        if let Ok(projected_ty) = curr_projected_ty {\n+            let ty = projected_ty.to_ty(tcx);\n+            self.relate(mir_ty, variance, ty)?;\n+        }\n \n         if let Some(UserSelfTy {\n             impl_def_id,"}, {"sha": "572e79407a10be41586bc8b9d38d5aeb33de66a6", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 57, "deletions": 51, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -37,7 +37,7 @@ use std::iter;\n use syntax::ast;\n use syntax::ptr::P;\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n-use syntax_pos::{Span, MultiSpan};\n+use syntax_pos::{DUMMY_SP, Span, MultiSpan};\n \n pub trait AstConv<'gcx, 'tcx> {\n     fn tcx<'a>(&'a self) -> TyCtxt<'a, 'gcx, 'tcx>;\n@@ -451,7 +451,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         }\n \n         // We manually build up the substitution, rather than using convenience\n-        // methods in subst.rs so that we can iterate over the arguments and\n+        // methods in `subst.rs` so that we can iterate over the arguments and\n         // parameters in lock-step linearly, rather than trying to match each pair.\n         let mut substs: SmallVec<[Kind<'tcx>; 8]> = SmallVec::with_capacity(count);\n \n@@ -469,7 +469,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                 }\n             }\n \n-            // (Unless it's been handled in `parent_substs`) `Self` is handled first.\n+            // `Self` is handled first, unless it's been handled in `parent_substs`.\n             if has_self {\n                 if let Some(&param) = params.peek() {\n                     if param.index == 0 {\n@@ -698,7 +698,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                                         trait_ref.path.segments.last().unwrap())\n     }\n \n-    /// Get the DefId of the given trait ref. It _must_ actually be a trait.\n+    /// Get the `DefId` of the given trait ref. It _must_ actually be a trait.\n     fn trait_def_id(&self, trait_ref: &hir::TraitRef) -> DefId {\n         let path = &trait_ref.path;\n         match path.def {\n@@ -711,7 +711,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         }\n     }\n \n-    /// The given `trait_ref` must actually be trait.\n+    /// The given trait ref must actually be a trait.\n     pub(super) fn instantiate_poly_trait_ref_inner(&self,\n         trait_ref: &hir::TraitRef,\n         self_ty: Ty<'tcx>,\n@@ -738,7 +738,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n             let predicate: Result<_, ErrorReported> =\n                 self.ast_type_binding_to_poly_projection_predicate(\n                     trait_ref.ref_id, poly_trait_ref, binding, speculative, &mut dup_bindings);\n-            // ok to ignore Err because ErrorReported (see above)\n+            // okay to ignore Err because of ErrorReported (see above)\n             Some((predicate.ok()?, binding.span))\n         }));\n \n@@ -831,15 +831,15 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         let tcx = self.tcx();\n \n         if !speculative {\n-            // Given something like `U : SomeTrait<T=X>`, we want to produce a\n+            // Given something like `U: SomeTrait<T = X>`, we want to produce a\n             // predicate like `<U as SomeTrait>::T = X`. This is somewhat\n             // subtle in the event that `T` is defined in a supertrait of\n             // `SomeTrait`, because in that case we need to upcast.\n             //\n             // That is, consider this case:\n             //\n             // ```\n-            // trait SubTrait : SuperTrait<int> { }\n+            // trait SubTrait: SuperTrait<int> { }\n             // trait SuperTrait<A> { type T; }\n             //\n             // ... B : SubTrait<T=foo> ...\n@@ -908,16 +908,14 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         if !speculative {\n             dup_bindings.entry(assoc_ty.def_id)\n                 .and_modify(|prev_span| {\n-                    let mut err = self.tcx().struct_span_lint_node(\n-                        ::rustc::lint::builtin::DUPLICATE_ASSOCIATED_TYPE_BINDINGS,\n-                        ref_id,\n-                        binding.span,\n-                        &format!(\"associated type binding `{}` specified more than once\",\n-                                 binding.item_name)\n-                    );\n-                    err.span_label(binding.span, \"used more than once\");\n-                    err.span_label(*prev_span, format!(\"first use of `{}`\", binding.item_name));\n-                    err.emit();\n+                    struct_span_err!(self.tcx().sess, binding.span, E0719,\n+                                     \"the value of the associated type `{}` (from the trait `{}`) \\\n+                                      is already specified\",\n+                                     binding.item_name,\n+                                     tcx.item_path_str(assoc_ty.container.id()))\n+                        .span_label(binding.span, \"re-bound here\")\n+                        .span_label(*prev_span, format!(\"`{}` bound here first\", binding.item_name))\n+                        .emit();\n                 })\n                 .or_insert(binding.span);\n         }\n@@ -969,7 +967,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n             return tcx.types.err;\n         }\n \n-        let mut projection_bounds = vec![];\n+        let mut projection_bounds = Vec::new();\n         let dummy_self = tcx.mk_ty(TRAIT_OBJECT_DUMMY_SELF);\n         let principal = self.instantiate_poly_trait_ref(&trait_bounds[0],\n                                                         dummy_self,\n@@ -994,23 +992,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                 .emit();\n         }\n \n-        // Erase the dummy_self (TRAIT_OBJECT_DUMMY_SELF) used above.\n-        let existential_principal = principal.map_bound(|trait_ref| {\n-            self.trait_ref_to_existential(trait_ref)\n-        });\n-        let existential_projections = projection_bounds.iter().map(|(bound, _)| {\n-            bound.map_bound(|b| {\n-                let trait_ref = self.trait_ref_to_existential(b.projection_ty.trait_ref(tcx));\n-                ty::ExistentialProjection {\n-                    ty: b.ty,\n-                    item_def_id: b.projection_ty.item_def_id,\n-                    substs: trait_ref.substs,\n-                }\n-            })\n-        });\n-\n         // Check that there are no gross object safety violations;\n-        // most importantly, that the supertraits don't contain Self,\n+        // most importantly, that the supertraits don't contain `Self`,\n         // to avoid ICEs.\n         let object_safety_violations =\n             tcx.global_tcx().astconv_object_safety_violations(principal.def_id());\n@@ -1021,13 +1004,22 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n             return tcx.types.err;\n         }\n \n-        // Use a BTreeSet to keep output in a more consistent order.\n+        // Use a `BTreeSet` to keep output in a more consistent order.\n         let mut associated_types = BTreeSet::default();\n \n-        for tr in traits::supertraits(tcx, principal) {\n-            associated_types.extend(tcx.associated_items(tr.def_id())\n-                .filter(|item| item.kind == ty::AssociatedKind::Type)\n-                .map(|item| item.def_id));\n+        for tr in traits::elaborate_trait_ref(tcx, principal) {\n+            match tr {\n+                ty::Predicate::Trait(pred) => {\n+                    associated_types.extend(tcx.associated_items(pred.def_id())\n+                                    .filter(|item| item.kind == ty::AssociatedKind::Type)\n+                                    .map(|item| item.def_id));\n+                }\n+                ty::Predicate::Projection(pred) => {\n+                    // Include projections defined on supertraits.\n+                    projection_bounds.push((pred, DUMMY_SP))\n+                }\n+                _ => ()\n+            }\n         }\n \n         for (projection_bound, _) in &projection_bounds {\n@@ -1046,11 +1038,26 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                 .emit();\n         }\n \n+        // Erase the `dummy_self` (`TRAIT_OBJECT_DUMMY_SELF`) used above.\n+        let existential_principal = principal.map_bound(|trait_ref| {\n+            self.trait_ref_to_existential(trait_ref)\n+        });\n+        let existential_projections = projection_bounds.iter().map(|(bound, _)| {\n+            bound.map_bound(|b| {\n+                let trait_ref = self.trait_ref_to_existential(b.projection_ty.trait_ref(tcx));\n+                ty::ExistentialProjection {\n+                    ty: b.ty,\n+                    item_def_id: b.projection_ty.item_def_id,\n+                    substs: trait_ref.substs,\n+                }\n+            })\n+        });\n+\n         // Dedup auto traits so that `dyn Trait + Send + Send` is the same as `dyn Trait + Send`.\n         auto_traits.sort();\n         auto_traits.dedup();\n \n-        // skip_binder is okay, because the predicates are re-bound.\n+        // Calling `skip_binder` is okay, because the predicates are re-bound.\n         let mut v =\n             iter::once(ty::ExistentialPredicate::Trait(*existential_principal.skip_binder()))\n             .chain(auto_traits.into_iter().map(ty::ExistentialPredicate::AutoTrait))\n@@ -1128,8 +1135,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                                       span)\n     }\n \n-\n-    // Checks that bounds contains exactly one element and reports appropriate\n+    // Checks that `bounds` contains exactly one element and reports appropriate\n     // errors otherwise.\n     fn one_bound_for_assoc_type<I>(&self,\n                                    mut bounds: I,\n@@ -1186,11 +1192,11 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n     }\n \n     // Create a type from a path to an associated type.\n-    // For a path A::B::C::D, ty and ty_path_def are the type and def for A::B::C\n-    // and item_segment is the path segment for D. We return a type and a def for\n+    // For a path `A::B::C::D`, `ty` and `ty_path_def` are the type and def for `A::B::C`\n+    // and item_segment is the path segment for `D`. We return a type and a def for\n     // the whole path.\n-    // Will fail except for T::A and Self::A; i.e., if ty/ty_path_def are not a type\n-    // parameter or Self.\n+    // Will fail except for `T::A` and `Self::A`; i.e., if `ty`/`ty_path_def` are not a type\n+    // parameter or `Self`.\n     pub fn associated_path_def_to_ty(&self,\n                                      ref_id: ast::NodeId,\n                                      span: Span,\n@@ -1210,7 +1216,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         // item is declared.\n         let bound = match (&ty.sty, ty_path_def) {\n             (_, Def::SelfTy(Some(_), Some(impl_def_id))) => {\n-                // `Self` in an impl of a trait - we have a concrete self type and a\n+                // `Self` in an impl of a trait - we have a concrete `self` type and a\n                 // trait reference.\n                 let trait_ref = match tcx.impl_trait_ref(impl_def_id) {\n                     Some(trait_ref) => trait_ref,\n@@ -1361,7 +1367,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         let span = path.span;\n         match path.def {\n             Def::Existential(did) => {\n-                // check for desugared impl trait\n+                // Check for desugared impl trait.\n                 assert!(ty::is_impl_trait_defn(tcx, did).is_none());\n                 let item_segment = path.segments.split_last().unwrap();\n                 self.prohibit_generics(item_segment.1);\n@@ -1398,15 +1404,15 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                 tcx.mk_ty_param(index, tcx.hir.name(node_id).as_interned_str())\n             }\n             Def::SelfTy(_, Some(def_id)) => {\n-                // Self in impl (we know the concrete type).\n+                // `Self` in impl (we know the concrete type)\n \n                 assert_eq!(opt_self_ty, None);\n                 self.prohibit_generics(&path.segments);\n \n                 tcx.at(span).type_of(def_id)\n             }\n             Def::SelfTy(Some(_), None) => {\n-                // Self in trait.\n+                // `Self` in trait\n                 assert_eq!(opt_self_ty, None);\n                 self.prohibit_generics(&path.segments);\n                 tcx.mk_self_type()"}, {"sha": "a477df6ae2d568e4d296876c7a9fd0c91a442612", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -626,9 +626,9 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n         let discrim_diverges = self.diverges.get();\n         self.diverges.set(Diverges::Maybe);\n \n-        // Typecheck the patterns first, so that we get types for all the\n-        // bindings.\n-        let all_arm_pats_diverge = arms.iter().map(|arm| {\n+        // rust-lang/rust#55810: Typecheck patterns first (via eager\n+        // collection into `Vec`), so we get types for all bindings.\n+        let all_arm_pats_diverge: Vec<_> = arms.iter().map(|arm| {\n             let mut all_pats_diverge = Diverges::WarnedAlways;\n             for p in &arm.pats {\n                 self.diverges.set(Diverges::Maybe);\n@@ -644,7 +644,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n                 Diverges::Maybe => Diverges::Maybe,\n                 Diverges::Always | Diverges::WarnedAlways => Diverges::WarnedAlways,\n             }\n-        });\n+        }).collect();\n \n         // Now typecheck the blocks.\n         //"}, {"sha": "84967aaf72f5797cf034129985d507d607760554", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -292,7 +292,8 @@ pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n             \"unchecked_div\" | \"unchecked_rem\" | \"exact_div\" =>\n                 (1, vec![param(0), param(0)], param(0)),\n-            \"unchecked_shl\" | \"unchecked_shr\" =>\n+            \"unchecked_shl\" | \"unchecked_shr\" |\n+            \"rotate_left\" | \"rotate_right\" =>\n                 (1, vec![param(0), param(0)], param(0)),\n \n             \"overflowing_add\" | \"overflowing_sub\" | \"overflowing_mul\" =>"}, {"sha": "8574443190d7c7a2d6a70f8737e3b1b7565de272", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -28,9 +28,9 @@ use errors::{DiagnosticBuilder, DiagnosticId};\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir;\n \n-/// Helper type of a temporary returned by .for_item(...).\n+/// Helper type of a temporary returned by `.for_item(...)`.\n /// Necessary because we can't write the following bound:\n-/// F: for<'b, 'tcx> where 'gcx: 'tcx FnOnce(FnCtxt<'b, 'gcx, 'tcx>).\n+/// `F: for<'b, 'tcx> where 'gcx: 'tcx FnOnce(FnCtxt<'b, 'gcx, 'tcx>)`.\n struct CheckWfFcxBuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     inherited: super::InheritedBuilder<'a, 'gcx, 'tcx>,\n     id: ast::NodeId,\n@@ -186,6 +186,8 @@ fn check_associated_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                    item_id: ast::NodeId,\n                                    span: Span,\n                                    sig_if_method: Option<&hir::MethodSig>) {\n+    debug!(\"check_associated_item: {:?}\", item_id);\n+\n     let code = ObligationCauseCode::MiscObligation;\n     for_id(tcx, item_id, span).with_fcx(|fcx, tcx| {\n         let item = fcx.tcx.associated_item(fcx.tcx.hir.local_def_id(item_id));\n@@ -311,6 +313,8 @@ fn check_type_defn<'a, 'tcx, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n fn check_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item: &hir::Item) {\n+    debug!(\"check_trait: {:?}\", item.id);\n+\n     let trait_def_id = tcx.hir.local_def_id(item.id);\n \n     let trait_def = tcx.trait_def(trait_def_id);\n@@ -1012,7 +1016,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n \n             None => {\n-                // Inherent impl: take implied bounds from the self type.\n+                // Inherent impl: take implied bounds from the `self` type.\n                 let self_ty = self.tcx.type_of(impl_def_id);\n                 let self_ty = self.normalize_associated_types_in(span, &self_ty);\n                 vec![self_ty]"}, {"sha": "d5f5cbb562e78514581bea80c91fc6e1237add51", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -1978,18 +1978,18 @@ pub enum SizedByDefault {\n     No,\n }\n \n-/// Translate the AST's notion of ty param bounds (which are an enum consisting of a newtyped Ty or\n-/// a region) to ty's notion of ty param bounds, which can either be user-defined traits, or the\n-/// built-in trait (formerly known as kind): Send.\n+/// Translate the AST's notion of ty param bounds (which are an enum consisting of a newtyped `Ty`\n+/// or a region) to ty's notion of ty param bounds, which can either be user-defined traits, or the\n+/// built-in trait `Send`.\n pub fn compute_bounds<'gcx: 'tcx, 'tcx>(\n     astconv: &dyn AstConv<'gcx, 'tcx>,\n     param_ty: Ty<'tcx>,\n     ast_bounds: &[hir::GenericBound],\n     sized_by_default: SizedByDefault,\n     span: Span,\n ) -> Bounds<'tcx> {\n-    let mut region_bounds = vec![];\n-    let mut trait_bounds = vec![];\n+    let mut region_bounds = Vec::new();\n+    let mut trait_bounds = Vec::new();\n \n     for ast_bound in ast_bounds {\n         match *ast_bound {\n@@ -1999,7 +1999,7 @@ pub fn compute_bounds<'gcx: 'tcx, 'tcx>(\n         }\n     }\n \n-    let mut projection_bounds = vec![];\n+    let mut projection_bounds = Vec::new();\n \n     let mut trait_bounds: Vec<_> = trait_bounds.iter().map(|&bound| {\n         (astconv.instantiate_poly_trait_ref(bound, param_ty, &mut projection_bounds), bound.span)"}, {"sha": "a985c3e9fdf449bfc8b57664c867ef065d1025f6", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -4909,4 +4909,5 @@ register_diagnostics! {\n     E0641, // cannot cast to/from a pointer with an unknown kind\n     E0645, // trait aliases not finished\n     E0698, // type inside generator must be known in this context\n+    E0719, // duplicate values for associated type binding\n }"}, {"sha": "6ed59837eb49a2c23a709491a25918c5e49d4c03", "filename": "src/librustc_typeck/outlives/utils.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_typeck%2Foutlives%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustc_typeck%2Foutlives%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Futils.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -11,6 +11,7 @@\n use rustc::ty::outlives::Component;\n use rustc::ty::subst::{Kind, UnpackedKind};\n use rustc::ty::{self, Region, RegionKind, Ty, TyCtxt};\n+use smallvec::smallvec;\n use std::collections::BTreeSet;\n \n /// Tracks the `T: 'a` or `'a: 'a` predicates that we have inferred\n@@ -40,7 +41,9 @@ pub fn insert_outlives_predicate<'tcx>(\n             //\n             // Or if within `struct Foo<U>` you had `T = Vec<U>`, then\n             // we would want to add `U: 'outlived_region`\n-            for component in tcx.outlives_components(ty) {\n+            let mut components = smallvec![];\n+            tcx.push_outlives_components(ty, &mut components);\n+            for component in components {\n                 match component {\n                     Component::Region(r) => {\n                         // This would arise from something like:"}, {"sha": "7dafe67485a6e92d86f2972fb34571a874a8aeec", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -29,6 +29,7 @@ use core::new_handler;\n use externalfiles::ExternalHtml;\n use html;\n use html::markdown::IdMap;\n+use html::static_files;\n use opts;\n use passes::{self, DefaultPassOption};\n use theme;\n@@ -261,7 +262,7 @@ impl Options {\n \n         let to_check = matches.opt_strs(\"theme-checker\");\n         if !to_check.is_empty() {\n-            let paths = theme::load_css_paths(include_bytes!(\"html/static/themes/light.css\"));\n+            let paths = theme::load_css_paths(static_files::themes::LIGHT.as_bytes());\n             let mut errors = 0;\n \n             println!(\"rustdoc: [theme-checker] Starting tests!\");\n@@ -338,7 +339,7 @@ impl Options {\n \n         let mut themes = Vec::new();\n         if matches.opt_present(\"themes\") {\n-            let paths = theme::load_css_paths(include_bytes!(\"html/static/themes/light.css\"));\n+            let paths = theme::load_css_paths(static_files::themes::LIGHT.as_bytes());\n \n             for (theme_file, theme_s) in matches.opt_strs(\"themes\")\n                                                 .iter()"}, {"sha": "f560350d5105d6298de6fada8d39894894cd1ca0", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -76,7 +76,7 @@ use html::format::{VisSpace, Method, UnsafetySpace, MutableSpace};\n use html::format::fmt_impl_for_trait_page;\n use html::item_type::ItemType;\n use html::markdown::{self, Markdown, MarkdownHtml, MarkdownSummaryLine, ErrorCodes, IdMap};\n-use html::{highlight, layout};\n+use html::{highlight, layout, static_files};\n \n use minifier;\n \n@@ -767,10 +767,10 @@ fn write_shared(\n     // overwrite them anyway to make sure that they're fresh and up-to-date.\n \n     write_minify(cx.dst.join(&format!(\"rustdoc{}.css\", cx.shared.resource_suffix)),\n-                 include_str!(\"static/rustdoc.css\"),\n+                 static_files::RUSTDOC_CSS,\n                  options.enable_minification)?;\n     write_minify(cx.dst.join(&format!(\"settings{}.css\", cx.shared.resource_suffix)),\n-                 include_str!(\"static/settings.css\"),\n+                 static_files::SETTINGS_CSS,\n                  options.enable_minification)?;\n \n     // To avoid \"light.css\" to be overwritten, we'll first run over the received themes and only\n@@ -790,15 +790,15 @@ fn write_shared(\n     }\n \n     write(cx.dst.join(&format!(\"brush{}.svg\", cx.shared.resource_suffix)),\n-          include_bytes!(\"static/brush.svg\"))?;\n+          static_files::BRUSH_SVG)?;\n     write(cx.dst.join(&format!(\"wheel{}.svg\", cx.shared.resource_suffix)),\n-          include_bytes!(\"static/wheel.svg\"))?;\n+          static_files::WHEEL_SVG)?;\n     write_minify(cx.dst.join(&format!(\"light{}.css\", cx.shared.resource_suffix)),\n-                 include_str!(\"static/themes/light.css\"),\n+                 static_files::themes::LIGHT,\n                  options.enable_minification)?;\n     themes.insert(\"light\".to_owned());\n     write_minify(cx.dst.join(&format!(\"dark{}.css\", cx.shared.resource_suffix)),\n-                 include_str!(\"static/themes/dark.css\"),\n+                 static_files::themes::DARK,\n                  options.enable_minification)?;\n     themes.insert(\"dark\".to_owned());\n \n@@ -854,16 +854,16 @@ themePicker.onblur = handleThemeButtonsBlur;\n     )?;\n \n     write_minify(cx.dst.join(&format!(\"main{}.js\", cx.shared.resource_suffix)),\n-                 include_str!(\"static/main.js\"),\n+                 static_files::MAIN_JS,\n                  options.enable_minification)?;\n     write_minify(cx.dst.join(&format!(\"settings{}.js\", cx.shared.resource_suffix)),\n-                 include_str!(\"static/settings.js\"),\n+                 static_files::SETTINGS_JS,\n                  options.enable_minification)?;\n \n     {\n         let mut data = format!(\"var resourcesSuffix = \\\"{}\\\";\\n\",\n                                cx.shared.resource_suffix);\n-        data.push_str(include_str!(\"static/storage.js\"));\n+        data.push_str(static_files::STORAGE_JS);\n         write_minify(cx.dst.join(&format!(\"storage{}.js\", cx.shared.resource_suffix)),\n                      &data,\n                      options.enable_minification)?;\n@@ -882,36 +882,36 @@ themePicker.onblur = handleThemeButtonsBlur;\n         }\n     }\n     write_minify(cx.dst.join(&format!(\"normalize{}.css\", cx.shared.resource_suffix)),\n-                 include_str!(\"static/normalize.css\"),\n+                 static_files::NORMALIZE_CSS,\n                  options.enable_minification)?;\n     write(cx.dst.join(\"FiraSans-Regular.woff\"),\n-          include_bytes!(\"static/FiraSans-Regular.woff\"))?;\n+          static_files::fira_sans::REGULAR)?;\n     write(cx.dst.join(\"FiraSans-Medium.woff\"),\n-          include_bytes!(\"static/FiraSans-Medium.woff\"))?;\n+          static_files::fira_sans::MEDIUM)?;\n     write(cx.dst.join(\"FiraSans-LICENSE.txt\"),\n-          include_bytes!(\"static/FiraSans-LICENSE.txt\"))?;\n+          static_files::fira_sans::LICENSE)?;\n     write(cx.dst.join(\"Heuristica-Italic.woff\"),\n-          include_bytes!(\"static/Heuristica-Italic.woff\"))?;\n+          static_files::heuristica::ITALIC)?;\n     write(cx.dst.join(\"Heuristica-LICENSE.txt\"),\n-          include_bytes!(\"static/Heuristica-LICENSE.txt\"))?;\n+          static_files::heuristica::LICENSE)?;\n     write(cx.dst.join(\"SourceSerifPro-Regular.woff\"),\n-          include_bytes!(\"static/SourceSerifPro-Regular.woff\"))?;\n+          static_files::source_serif_pro::REGULAR)?;\n     write(cx.dst.join(\"SourceSerifPro-Bold.woff\"),\n-          include_bytes!(\"static/SourceSerifPro-Bold.woff\"))?;\n+          static_files::source_serif_pro::BOLD)?;\n     write(cx.dst.join(\"SourceSerifPro-LICENSE.txt\"),\n-          include_bytes!(\"static/SourceSerifPro-LICENSE.txt\"))?;\n+          static_files::source_serif_pro::LICENSE)?;\n     write(cx.dst.join(\"SourceCodePro-Regular.woff\"),\n-          include_bytes!(\"static/SourceCodePro-Regular.woff\"))?;\n+          static_files::source_code_pro::REGULAR)?;\n     write(cx.dst.join(\"SourceCodePro-Semibold.woff\"),\n-          include_bytes!(\"static/SourceCodePro-Semibold.woff\"))?;\n+          static_files::source_code_pro::SEMIBOLD)?;\n     write(cx.dst.join(\"SourceCodePro-LICENSE.txt\"),\n-          include_bytes!(\"static/SourceCodePro-LICENSE.txt\"))?;\n+          static_files::source_code_pro::LICENSE)?;\n     write(cx.dst.join(\"LICENSE-MIT.txt\"),\n-          include_bytes!(\"static/LICENSE-MIT.txt\"))?;\n+          static_files::LICENSE_MIT)?;\n     write(cx.dst.join(\"LICENSE-APACHE.txt\"),\n-          include_bytes!(\"static/LICENSE-APACHE.txt\"))?;\n+          static_files::LICENSE_APACHE)?;\n     write(cx.dst.join(\"COPYRIGHT.txt\"),\n-          include_bytes!(\"static/COPYRIGHT.txt\"))?;\n+          static_files::COPYRIGHT)?;\n \n     fn collect(path: &Path, krate: &str, key: &str) -> io::Result<(Vec<String>, Vec<String>)> {\n         let mut ret = Vec::new();"}, {"sha": "3baa082bd0e6936203c966e2c67994a7548723f0", "filename": "src/librustdoc/html/static_files.rs", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustdoc%2Fhtml%2Fstatic_files.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustdoc%2Fhtml%2Fstatic_files.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic_files.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -0,0 +1,111 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Static files bundled with documentation output.\n+//!\n+//! All the static files are included here for centralized access in case anything other than the\n+//! HTML rendering code (say, the theme checker) needs to access one of these files.\n+//!\n+//! Note about types: CSS and JavaScript files are included as `&'static str` to allow for the\n+//! minifier to run on them. All other files are included as `&'static [u8]` so they can be\n+//! directly written to a `Write` handle.\n+\n+/// The file contents of the main `rustdoc.css` file, responsible for the core layout of the page.\n+pub static RUSTDOC_CSS: &'static str = include_str!(\"static/rustdoc.css\");\n+\n+/// The file contents of `settings.css`, responsible for the items on the settings page.\n+pub static SETTINGS_CSS: &'static str = include_str!(\"static/settings.css\");\n+\n+/// The file contents of `normalize.css`, included to even out standard elements between browser\n+/// implementations.\n+pub static NORMALIZE_CSS: &'static str = include_str!(\"static/normalize.css\");\n+\n+/// The file contents of `main.js`, which contains the core JavaScript used on documentation pages,\n+/// including search behavior and docblock folding, among others.\n+pub static MAIN_JS: &'static str = include_str!(\"static/main.js\");\n+\n+/// The file contents of `settings.js`, which contains the JavaScript used to handle the settings\n+/// page.\n+pub static SETTINGS_JS: &'static str = include_str!(\"static/settings.js\");\n+\n+/// The file contents of `storage.js`, which contains functionality related to browser Local\n+/// Storage, used to store documentation settings.\n+pub static STORAGE_JS: &'static str = include_str!(\"static/storage.js\");\n+\n+/// The file contents of `brush.svg`, the icon used for the theme-switch button.\n+pub static BRUSH_SVG: &'static [u8] = include_bytes!(\"static/brush.svg\");\n+\n+/// The file contents of `wheel.svg`, the icon used for the settings button.\n+pub static WHEEL_SVG: &'static [u8] = include_bytes!(\"static/wheel.svg\");\n+\n+/// The contents of `COPYRIGHT.txt`, the license listing for files distributed with documentation\n+/// output.\n+pub static COPYRIGHT: &'static [u8] = include_bytes!(\"static/COPYRIGHT.txt\");\n+\n+/// The contents of `LICENSE-APACHE.txt`, the text of the Apache License, version 2.0.\n+pub static LICENSE_APACHE: &'static [u8] = include_bytes!(\"static/LICENSE-APACHE.txt\");\n+\n+/// The contents of `LICENSE-MIT.txt`, the text of the MIT License.\n+pub static LICENSE_MIT: &'static [u8] = include_bytes!(\"static/LICENSE-MIT.txt\");\n+\n+/// The built-in themes given to every documentation site.\n+pub mod themes {\n+    /// The \"light\" theme, selected by default when no setting is available. Used as the basis for\n+    /// the `--theme-checker` functionality.\n+    pub static LIGHT: &'static str = include_str!(\"static/themes/light.css\");\n+\n+    /// The \"dark\" theme.\n+    pub static DARK: &'static str = include_str!(\"static/themes/dark.css\");\n+}\n+\n+/// Files related to the Fira Sans font.\n+pub mod fira_sans {\n+    /// The file `FiraSans-Regular.woff`, the Regular variant of the Fira Sans font.\n+    pub static REGULAR: &'static [u8] = include_bytes!(\"static/FiraSans-Regular.woff\");\n+\n+    /// The file `FiraSans-Medium.woff`, the Medium variant of the Fira Sans font.\n+    pub static MEDIUM: &'static [u8] = include_bytes!(\"static/FiraSans-Medium.woff\");\n+\n+    /// The file `FiraSans-LICENSE.txt`, the license text for the Fira Sans font.\n+    pub static LICENSE: &'static [u8] = include_bytes!(\"static/FiraSans-LICENSE.txt\");\n+}\n+\n+/// Files related to the Heuristica font.\n+pub mod heuristica {\n+    /// The file `Heuristica-Italic.woff`, the Italic variant of the Heuristica font.\n+    pub static ITALIC: &'static [u8] = include_bytes!(\"static/Heuristica-Italic.woff\");\n+\n+    /// The file `Heuristica-LICENSE.txt`, the license text for the Heuristica font.\n+    pub static LICENSE: &'static [u8] = include_bytes!(\"static/Heuristica-LICENSE.txt\");\n+}\n+\n+/// Files related to the Source Serif Pro font.\n+pub mod source_serif_pro {\n+    /// The file `SourceSerifPro-Regular.woff`, the Regular variant of the Source Serif Pro font.\n+    pub static REGULAR: &'static [u8] = include_bytes!(\"static/SourceSerifPro-Regular.woff\");\n+\n+    /// The file `SourceSerifPro-Bold.woff`, the Bold variant of the Source Serif Pro font.\n+    pub static BOLD: &'static [u8] = include_bytes!(\"static/SourceSerifPro-Bold.woff\");\n+\n+    /// The file `SourceSerifPro-LICENSE.txt`, the license text for the Source Serif Pro font.\n+    pub static LICENSE: &'static [u8] = include_bytes!(\"static/SourceSerifPro-LICENSE.txt\");\n+}\n+\n+/// Files related to the Source Code Pro font.\n+pub mod source_code_pro {\n+    /// The file `SourceCodePro-Regular.woff`, the Regular variant of the Source Code Pro font.\n+    pub static REGULAR: &'static [u8] = include_bytes!(\"static/SourceCodePro-Regular.woff\");\n+\n+    /// The file `SourceCodePro-Semibold.woff`, the Semibold variant of the Source Code Pro font.\n+    pub static SEMIBOLD: &'static [u8] = include_bytes!(\"static/SourceCodePro-Semibold.woff\");\n+\n+    /// The file `SourceCodePro-LICENSE.txt`, the license text of the Source Code Pro font.\n+    pub static LICENSE: &'static [u8] = include_bytes!(\"static/SourceCodePro-LICENSE.txt\");\n+}"}, {"sha": "4b043b26d8650d6a6149062d13cd202979e48000", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -78,6 +78,7 @@ pub mod html {\n     crate mod layout;\n     pub mod markdown;\n     crate mod render;\n+    crate mod static_files;\n     crate mod toc;\n }\n mod markdown;"}, {"sha": "87ffe0f15e45461032f31da6de9159016b7795c6", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -1178,7 +1178,7 @@ impl CStr {\n     ///\n     /// If the contents of the `CStr` are valid UTF-8 data, this\n     /// function will return a [`Cow`]`::`[`Borrowed`]`(`[`&str`]`)`\n-    /// with the the corresponding [`&str`] slice. Otherwise, it will\n+    /// with the corresponding [`&str`] slice. Otherwise, it will\n     /// replace any invalid UTF-8 sequences with\n     /// [`U+FFFD REPLACEMENT CHARACTER`][U+FFFD] and return a\n     /// [`Cow`]`::`[`Owned`]`(`[`String`]`)` with the result."}, {"sha": "0829593505d69e5b8060132d992b922f33d29da4", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -495,7 +495,7 @@ mod memchr;\n // compiler\n pub mod rt;\n \n-// Pull in the the `stdsimd` crate directly into libstd. This is the same as\n+// Pull in the `stdsimd` crate directly into libstd. This is the same as\n // libcore's arch/simd modules where the source of truth here is in a different\n // repository, but we pull things in here manually to get it into libstd.\n //"}, {"sha": "aa756f4a2337058da474c8484529e98fee5a653a", "filename": "src/test/mir-opt/inline-trait-method_2.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fmir-opt%2Finline-trait-method_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fmir-opt%2Finline-trait-method_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline-trait-method_2.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -0,0 +1,36 @@\n+// compile-flags: -Z span_free_formats -Z mir-opt-level=3\n+\n+#[inline]\n+fn test(x: &dyn X) -> bool {\n+    x.y()\n+}\n+\n+fn test2(x: &dyn X) -> bool {\n+    test(x)\n+}\n+\n+trait X {\n+    fn y(&self) -> bool {\n+        false\n+    }\n+}\n+\n+impl X for () {\n+    fn y(&self) -> bool {\n+        true\n+    }\n+}\n+\n+fn main() {\n+    println!(\"Should be true: {}\", test2(&()));\n+}\n+\n+// END RUST SOURCE\n+// START rustc.test2.Inline.after.mir\n+// ...\n+// bb0: {\n+// ...\n+//     _0 = const X::y(move _2) -> bb1;\n+// }\n+// ...\n+// END rustc.test2.Inline.after.mir"}, {"sha": "e69c0af2be768dfa4c51c41117eb44894ef04f66", "filename": "src/test/run-pass/associated-types/associated-types-from-supertrait.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-from-supertrait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-from-supertrait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-from-supertrait.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Foo: Iterator<Item = i32> {}\n+trait Bar: Foo {}\n+\n+fn main() {\n+    let _: &dyn Bar;\n+}"}, {"sha": "cce8bb84837f3b2fde9928063a557647e3a82013", "filename": "src/test/run-pass/issues/issue-24010.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Frun-pass%2Fissues%2Fissue-24010.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Frun-pass%2Fissues%2Fissue-24010.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-24010.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Foo: Fn(i32) -> i32 + Send {}\n+\n+impl<T: ?Sized + Fn(i32) -> i32 + Send> Foo for T {}\n+\n+fn wants_foo(f: Box<Foo>) -> i32 {\n+    f(42)\n+}\n+\n+fn main() {\n+    let f = Box::new(|x| x);\n+    assert_eq!(wants_foo(f), 42);\n+}"}, {"sha": "adac28eeb1292d40797fc1f322aba3b1fdb7e030", "filename": "src/test/run-pass/traits/trait-alias-object.rs", "status": "renamed", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-alias-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-alias-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-alias-object.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -21,7 +21,6 @@ pub fn main() {\n     let b = Box::new(456) as Box<dyn Foo>;\n     assert!(*b == 456);\n \n-    // FIXME(alexreg): associated type should be gotten from trait alias definition\n-    // let c: &dyn I32Iterator = &vec![123].into_iter();\n-    // assert_eq!(c.next(), Some(123));\n+    let c: &mut dyn I32Iterator = &mut vec![123].into_iter();\n+    assert_eq!(c.next(), Some(123));\n }", "previous_filename": "src/test/run-pass/traits/trait-alias-object-type.rs"}, {"sha": "8d91561b7d64feb218d1a0ff9d71c2834a3573ec", "filename": "src/test/ui/associated-types/associated-types-overridden-binding-2.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding-2.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(trait_alias)]\n+\n+trait I32Iterator = Iterator<Item = i32>;\n+\n+fn main() {\n+    let _: &I32Iterator<Item = u32> = &vec![42].into_iter();\n+}"}, {"sha": "536cd945083a60cb8b6f77919a45ea6da7175b0c", "filename": "src/test/ui/associated-types/associated-types-overridden-binding-2.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding-2.stderr?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -0,0 +1,13 @@\n+error[E0271]: type mismatch resolving `<std::vec::IntoIter<u32> as std::iter::Iterator>::Item == i32`\n+  --> $DIR/associated-types-overridden-binding-2.rs:16:39\n+   |\n+LL |     let _: &I32Iterator<Item = u32> = &vec![42].into_iter();\n+   |                                       ^^^^^^^^^^^^^^^^^^^^^ expected u32, found i32\n+   |\n+   = note: expected type `u32`\n+              found type `i32`\n+   = note: required for the cast to the object type `dyn I32Iterator<Item=u32, Item=i32>`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0271`."}, {"sha": "ed2211ecffd2bff8fba1f529674d4eda3138e3ce", "filename": "src/test/ui/associated-types/associated-types-overridden-binding.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(trait_alias)]\n+\n+trait Foo: Iterator<Item = i32> {}\n+trait Bar: Foo<Item = u32> {}\n+\n+trait I32Iterator = Iterator<Item = i32>;\n+trait U32Iterator = I32Iterator<Item = u32>;\n+\n+fn main() {\n+    let _: &I32Iterator<Item = u32>;\n+}"}, {"sha": "216aa097db9fb7c44f0af2ea27b691c859415ec6", "filename": "src/test/ui/associated-types/associated-types-overridden-binding.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding.stderr?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -0,0 +1,15 @@\n+error[E0284]: type annotations required: cannot resolve `<Self as std::iter::Iterator>::Item == i32`\n+  --> $DIR/associated-types-overridden-binding.rs:14:1\n+   |\n+LL | trait Bar: Foo<Item = u32> {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: required by `Foo`\n+  --> $DIR/associated-types-overridden-binding.rs:13:1\n+   |\n+LL | trait Foo: Iterator<Item = i32> {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0284`."}, {"sha": "95b26a5724a412da7024ec1f88ecd1a4f59ce61f", "filename": "src/test/ui/borrowck/borrowck-box-insensitivity.ast.stderr", "status": "renamed", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-box-insensitivity.ast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-box-insensitivity.ast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-box-insensitivity.ast.stderr?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -3,8 +3,8 @@ error[E0382]: use of moved value: `a`\n    |\n LL |     let _x = a.x;\n    |         -- value moved here\n-LL |     //~^ value moved here\n-LL |     let _y = a.y; //~ ERROR use of moved\n+LL |     //[ast]~^ value moved here\n+LL |     let _y = a.y; //[ast]~ ERROR use of moved\n    |         ^^ value used here after move\n    |\n    = note: move occurs because `a.x` has type `std::boxed::Box<isize>`, which does not implement the `Copy` trait\n@@ -14,8 +14,8 @@ error[E0382]: use of moved value: `a`\n    |\n LL |     let _x = a.x;\n    |         -- value moved here\n-LL |     //~^ value moved here\n-LL |     let _y = a.y; //~ ERROR use of moved\n+LL |     //[ast]~^ value moved here\n+LL |     let _y = a.y; //[ast]~ ERROR use of moved\n    |         ^^ value used here after move\n    |\n    = note: move occurs because `a.x` has type `std::boxed::Box<isize>`, which does not implement the `Copy` trait\n@@ -25,8 +25,8 @@ error[E0382]: use of moved value: `a`\n    |\n LL |     let _x = a.x;\n    |         -- value moved here\n-LL |     //~^ value moved here\n-LL |     let _y = &a.y; //~ ERROR use of moved\n+LL |     //[ast]~^ value moved here\n+LL |     let _y = &a.y; //[ast]~ ERROR use of moved\n    |               ^^^ value used here after move\n    |\n    = note: move occurs because `a.x` has type `std::boxed::Box<isize>`, which does not implement the `Copy` trait\n@@ -44,7 +44,7 @@ error[E0503]: cannot use `a.y` because it was mutably borrowed\n    |\n LL |     let _x = &mut a.x;\n    |                   --- borrow of `a.x` occurs here\n-LL |     let _y = a.y; //~ ERROR cannot use\n+LL |     let _y = a.y; //[ast]~ ERROR cannot use\n    |         ^^ use of borrowed `a.x`\n \n error[E0505]: cannot move out of `a.y` because it is borrowed\n@@ -60,9 +60,9 @@ error[E0502]: cannot borrow `a` (via `a.y`) as immutable because `a` is also bor\n    |\n LL |     let _x = &mut a.x;\n    |                   --- mutable borrow occurs here (via `a.x`)\n-LL |     let _y = &a.y; //~ ERROR cannot borrow\n+LL |     let _y = &a.y; //[ast]~ ERROR cannot borrow\n    |               ^^^ immutable borrow occurs here (via `a.y`)\n-LL |     //~^ immutable borrow occurs here (via `a.y`)\n+...\n LL | }\n    | - mutable borrow ends here\n \n@@ -71,9 +71,9 @@ error[E0502]: cannot borrow `a` (via `a.y`) as mutable because `a` is also borro\n    |\n LL |     let _x = &a.x;\n    |               --- immutable borrow occurs here (via `a.x`)\n-LL |     let _y = &mut a.y; //~ ERROR cannot borrow\n+LL |     let _y = &mut a.y; //[ast]~ ERROR cannot borrow\n    |                   ^^^ mutable borrow occurs here (via `a.y`)\n-LL |     //~^ mutable borrow occurs here (via `a.y`)\n+...\n LL | }\n    | - immutable borrow ends here\n \n@@ -82,8 +82,8 @@ error[E0382]: use of collaterally moved value: `a.y`\n    |\n LL |     let _x = a.x.x;\n    |         -- value moved here\n-LL |     //~^ value moved here\n-LL |     let _y = a.y; //~ ERROR use of collaterally moved\n+LL |     //[ast]~^ value moved here\n+LL |     let _y = a.y; //[ast]~ ERROR use of collaterally moved\n    |         ^^ value used here after move\n    |\n    = note: move occurs because `a.x.x` has type `std::boxed::Box<isize>`, which does not implement the `Copy` trait\n@@ -93,8 +93,8 @@ error[E0382]: use of collaterally moved value: `a.y`\n    |\n LL |     let _x = a.x.x;\n    |         -- value moved here\n-LL |     //~^ value moved here\n-LL |     let _y = a.y; //~ ERROR use of collaterally moved\n+LL |     //[ast]~^ value moved here\n+LL |     let _y = a.y; //[ast]~ ERROR use of collaterally moved\n    |         ^^ value used here after move\n    |\n    = note: move occurs because `a.x.x` has type `std::boxed::Box<isize>`, which does not implement the `Copy` trait\n@@ -104,8 +104,8 @@ error[E0382]: use of collaterally moved value: `a.y`\n    |\n LL |     let _x = a.x.x;\n    |         -- value moved here\n-LL |     //~^ value moved here\n-LL |     let _y = &a.y; //~ ERROR use of collaterally moved\n+LL |     //[ast]~^ value moved here\n+LL |     let _y = &a.y; //[ast]~ ERROR use of collaterally moved\n    |               ^^^ value used here after move\n    |\n    = note: move occurs because `a.x.x` has type `std::boxed::Box<isize>`, which does not implement the `Copy` trait\n@@ -115,7 +115,7 @@ error[E0505]: cannot move out of `a.y` because it is borrowed\n    |\n LL |     let _x = &a.x.x;\n    |               ----- borrow of `a.x.x` occurs here\n-LL |     //~^ borrow of `a.x.x` occurs here\n+LL |     //[ast]~^ borrow of `a.x.x` occurs here\n LL |     let _y = a.y;\n    |         ^^ move out of `a.y` occurs here\n \n@@ -124,7 +124,7 @@ error[E0503]: cannot use `a.y` because it was mutably borrowed\n    |\n LL |     let _x = &mut a.x.x;\n    |                   ----- borrow of `a.x.x` occurs here\n-LL |     let _y = a.y; //~ ERROR cannot use\n+LL |     let _y = a.y; //[ast]~ ERROR cannot use\n    |         ^^ use of borrowed `a.x.x`\n \n error[E0505]: cannot move out of `a.y` because it is borrowed\n@@ -140,10 +140,10 @@ error[E0502]: cannot borrow `a.y` as immutable because `a.x.x` is also borrowed\n    |\n LL |     let _x = &mut a.x.x;\n    |                   ----- mutable borrow occurs here\n-LL |     //~^ mutable borrow occurs here\n-LL |     let _y = &a.y; //~ ERROR cannot borrow\n+LL |     //[ast]~^ mutable borrow occurs here\n+LL |     let _y = &a.y; //[ast]~ ERROR cannot borrow\n    |               ^^^ immutable borrow occurs here\n-LL |     //~^ immutable borrow occurs here\n+...\n LL | }\n    | - mutable borrow ends here\n \n@@ -152,10 +152,10 @@ error[E0502]: cannot borrow `a.y` as mutable because `a.x.x` is also borrowed as\n    |\n LL |     let _x = &a.x.x;\n    |               ----- immutable borrow occurs here\n-LL |     //~^ immutable borrow occurs here\n-LL |     let _y = &mut a.y; //~ ERROR cannot borrow\n+LL |     //[ast]~^ immutable borrow occurs here\n+LL |     let _y = &mut a.y; //[ast]~ ERROR cannot borrow\n    |                   ^^^ mutable borrow occurs here\n-LL |     //~^ mutable borrow occurs here\n+...\n LL | }\n    | - immutable borrow ends here\n ", "previous_filename": "src/test/ui/borrowck/borrowck-box-insensitivity.stderr"}, {"sha": "171e992e8a628e7aa1b072991509860f9f293e51", "filename": "src/test/ui/borrowck/borrowck-box-insensitivity.mir.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-box-insensitivity.mir.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-box-insensitivity.mir.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-box-insensitivity.mir.stderr?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -0,0 +1,14 @@\n+error: compilation successful\n+  --> $DIR/borrowck-box-insensitivity.rs:160:1\n+   |\n+LL | / fn main() { //[mir]~ ERROR compilation successful\n+LL | |     copy_after_move();\n+LL | |     move_after_move();\n+LL | |     borrow_after_move();\n+...  |\n+LL | |     mut_borrow_after_borrow_nested();\n+LL | | }\n+   | |_^\n+\n+error: aborting due to previous error\n+"}, {"sha": "2af97a9fc1d58718ed3e92eefa80f0549adbe68e", "filename": "src/test/ui/borrowck/borrowck-box-insensitivity.rs", "status": "modified", "additions": 64, "deletions": 61, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-box-insensitivity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-box-insensitivity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-box-insensitivity.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -1,13 +1,13 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n+// This test is an artifact of the old policy that `Box<T>` should not\n+// be treated specially by the AST-borrowck.\n //\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n+// NLL goes back to treating `Box<T>` specially (namely, knowing that\n+// it uniquely owns the data it holds). See rust-lang/rfcs#130.\n \n+// revisions: ast mir\n+//[ast] compile-flags: -Z borrowck=ast\n+//[mir] compile-flags: -Z borrowck=mir\n+// ignore-compare-mode-nll\n #![feature(box_syntax, rustc_attrs)]\n \n struct A {\n@@ -33,131 +33,131 @@ struct D {\n fn copy_after_move() {\n     let a: Box<_> = box A { x: box 0, y: 1 };\n     let _x = a.x;\n-    //~^ value moved here\n-    let _y = a.y; //~ ERROR use of moved\n-    //~^ move occurs because `a.x` has type `std::boxed::Box<isize>`\n-    //~| value used here after move\n+    //[ast]~^ value moved here\n+    let _y = a.y; //[ast]~ ERROR use of moved\n+    //[ast]~^ move occurs because `a.x` has type `std::boxed::Box<isize>`\n+    //[ast]~| value used here after move\n }\n \n fn move_after_move() {\n     let a: Box<_> = box B { x: box 0, y: box 1 };\n     let _x = a.x;\n-    //~^ value moved here\n-    let _y = a.y; //~ ERROR use of moved\n-    //~^ move occurs because `a.x` has type `std::boxed::Box<isize>`\n-    //~| value used here after move\n+    //[ast]~^ value moved here\n+    let _y = a.y; //[ast]~ ERROR use of moved\n+    //[ast]~^ move occurs because `a.x` has type `std::boxed::Box<isize>`\n+    //[ast]~| value used here after move\n }\n \n fn borrow_after_move() {\n     let a: Box<_> = box A { x: box 0, y: 1 };\n     let _x = a.x;\n-    //~^ value moved here\n-    let _y = &a.y; //~ ERROR use of moved\n-    //~^ move occurs because `a.x` has type `std::boxed::Box<isize>`\n-    //~| value used here after move\n+    //[ast]~^ value moved here\n+    let _y = &a.y; //[ast]~ ERROR use of moved\n+    //[ast]~^ move occurs because `a.x` has type `std::boxed::Box<isize>`\n+    //[ast]~| value used here after move\n }\n \n fn move_after_borrow() {\n     let a: Box<_> = box B { x: box 0, y: box 1 };\n     let _x = &a.x;\n     let _y = a.y;\n-    //~^ ERROR cannot move\n-    //~| move out of\n+    //[ast]~^ ERROR cannot move\n+    //[ast]~| move out of\n+    use_imm(_x);\n }\n-\n fn copy_after_mut_borrow() {\n     let mut a: Box<_> = box A { x: box 0, y: 1 };\n     let _x = &mut a.x;\n-    let _y = a.y; //~ ERROR cannot use\n+    let _y = a.y; //[ast]~ ERROR cannot use\n+    use_mut(_x);\n }\n-\n fn move_after_mut_borrow() {\n     let mut a: Box<_> = box B { x: box 0, y: box 1 };\n     let _x = &mut a.x;\n     let _y = a.y;\n-    //~^ ERROR cannot move\n-    //~| move out of\n+    //[ast]~^ ERROR cannot move\n+    //[ast]~| move out of\n+    use_mut(_x);\n }\n-\n fn borrow_after_mut_borrow() {\n     let mut a: Box<_> = box A { x: box 0, y: 1 };\n     let _x = &mut a.x;\n-    let _y = &a.y; //~ ERROR cannot borrow\n-    //~^ immutable borrow occurs here (via `a.y`)\n+    let _y = &a.y; //[ast]~ ERROR cannot borrow\n+    //[ast]~^ immutable borrow occurs here (via `a.y`)\n+    use_mut(_x);\n }\n-\n fn mut_borrow_after_borrow() {\n     let mut a: Box<_> = box A { x: box 0, y: 1 };\n     let _x = &a.x;\n-    let _y = &mut a.y; //~ ERROR cannot borrow\n-    //~^ mutable borrow occurs here (via `a.y`)\n+    let _y = &mut a.y; //[ast]~ ERROR cannot borrow\n+    //[ast]~^ mutable borrow occurs here (via `a.y`)\n+    use_imm(_x);\n }\n-\n fn copy_after_move_nested() {\n     let a: Box<_> = box C { x: box A { x: box 0, y: 1 }, y: 2 };\n     let _x = a.x.x;\n-    //~^ value moved here\n-    let _y = a.y; //~ ERROR use of collaterally moved\n-    //~| value used here after move\n+    //[ast]~^ value moved here\n+    let _y = a.y; //[ast]~ ERROR use of collaterally moved\n+    //[ast]~| value used here after move\n }\n \n fn move_after_move_nested() {\n     let a: Box<_> = box D { x: box A { x: box 0, y: 1 }, y: box 2 };\n     let _x = a.x.x;\n-    //~^ value moved here\n-    let _y = a.y; //~ ERROR use of collaterally moved\n-    //~| value used here after move\n+    //[ast]~^ value moved here\n+    let _y = a.y; //[ast]~ ERROR use of collaterally moved\n+    //[ast]~| value used here after move\n }\n \n fn borrow_after_move_nested() {\n     let a: Box<_> = box C { x: box A { x: box 0, y: 1 }, y: 2 };\n     let _x = a.x.x;\n-    //~^ value moved here\n-    let _y = &a.y; //~ ERROR use of collaterally moved\n-    //~| value used here after move\n+    //[ast]~^ value moved here\n+    let _y = &a.y; //[ast]~ ERROR use of collaterally moved\n+    //[ast]~| value used here after move\n }\n \n fn move_after_borrow_nested() {\n     let a: Box<_> = box D { x: box A { x: box 0, y: 1 }, y: box 2 };\n     let _x = &a.x.x;\n-    //~^ borrow of `a.x.x` occurs here\n+    //[ast]~^ borrow of `a.x.x` occurs here\n     let _y = a.y;\n-    //~^ ERROR cannot move\n-    //~| move out of\n+    //[ast]~^ ERROR cannot move\n+    //[ast]~| move out of\n+    use_imm(_x);\n }\n-\n fn copy_after_mut_borrow_nested() {\n     let mut a: Box<_> = box C { x: box A { x: box 0, y: 1 }, y: 2 };\n     let _x = &mut a.x.x;\n-    let _y = a.y; //~ ERROR cannot use\n+    let _y = a.y; //[ast]~ ERROR cannot use\n+    use_mut(_x);\n }\n-\n fn move_after_mut_borrow_nested() {\n     let mut a: Box<_> = box D { x: box A { x: box 0, y: 1 }, y: box 2 };\n     let _x = &mut a.x.x;\n     let _y = a.y;\n-    //~^ ERROR cannot move\n-    //~| move out of\n+    //[ast]~^ ERROR cannot move\n+    //[ast]~| move out of\n+    use_mut(_x);\n }\n-\n fn borrow_after_mut_borrow_nested() {\n     let mut a: Box<_> = box C { x: box A { x: box 0, y: 1 }, y: 2 };\n     let _x = &mut a.x.x;\n-    //~^ mutable borrow occurs here\n-    let _y = &a.y; //~ ERROR cannot borrow\n-    //~^ immutable borrow occurs here\n+    //[ast]~^ mutable borrow occurs here\n+    let _y = &a.y; //[ast]~ ERROR cannot borrow\n+    //[ast]~^ immutable borrow occurs here\n+    use_mut(_x);\n }\n-\n fn mut_borrow_after_borrow_nested() {\n     let mut a: Box<_> = box C { x: box A { x: box 0, y: 1 }, y: 2 };\n     let _x = &a.x.x;\n-    //~^ immutable borrow occurs here\n-    let _y = &mut a.y; //~ ERROR cannot borrow\n-    //~^ mutable borrow occurs here\n+    //[ast]~^ immutable borrow occurs here\n+    let _y = &mut a.y; //[ast]~ ERROR cannot borrow\n+    //[ast]~^ mutable borrow occurs here\n+    use_imm(_x);\n }\n-\n #[rustc_error]\n-fn main() {\n+fn main() { //[mir]~ ERROR compilation successful\n     copy_after_move();\n     move_after_move();\n     borrow_after_move();\n@@ -180,3 +180,6 @@ fn main() {\n     borrow_after_mut_borrow_nested();\n     mut_borrow_after_borrow_nested();\n }\n+\n+fn use_mut<T>(_: &mut T) { }\n+fn use_imm<T>(_: &T) { }"}, {"sha": "6d91fd3508a867916bded4c64ee5bc22d4caee84", "filename": "src/test/ui/borrowck/issue-55552-ascribe-wildcard-to-structured-pattern.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fui%2Fborrowck%2Fissue-55552-ascribe-wildcard-to-structured-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fui%2Fborrowck%2Fissue-55552-ascribe-wildcard-to-structured-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-55552-ascribe-wildcard-to-structured-pattern.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -0,0 +1,31 @@\n+// compile-pass\n+\n+// rust-lang/rust#55552: The strategy pnkfelix landed in PR #55274\n+// (for ensuring that NLL respects user-provided lifetime annotations)\n+// did not handle the case where the ascribed type has some expliit\n+// wildcards (`_`) mixed in, and it caused an internal compiler error\n+// (ICE).\n+//\n+// This test is just checking that we do not ICE when such things\n+// occur.\n+\n+struct X;\n+struct Y;\n+struct Z;\n+\n+struct Pair { x: X, y: Y }\n+\n+pub fn join<A, B, RA, RB>(oper_a: A, oper_b: B) -> (RA, RB)\n+where A: FnOnce() -> RA + Send,\n+      B: FnOnce() -> RB + Send,\n+      RA: Send,\n+      RB: Send\n+{\n+    (oper_a(), oper_b())\n+}\n+\n+fn main() {\n+    let ((_x, _y), _z): (_, Z) = join(|| (X, Y), || Z);\n+\n+    let (Pair { x: _x, y: _y }, Z): (_, Z) = join(|| Pair { x: X, y: Y }, || Z);\n+}"}, {"sha": "f6bbcc60e4e6456fc388d5fdb34baeb20ab14197", "filename": "src/test/ui/consts/auxiliary/promotable_const_fn_lib.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fui%2Fconsts%2Fauxiliary%2Fpromotable_const_fn_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fui%2Fconsts%2Fauxiliary%2Fpromotable_const_fn_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fauxiliary%2Fpromotable_const_fn_lib.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Crate that exports a const fn. Used for testing cross-crate.\n+\n+#![feature(staged_api, rustc_attrs)]\n+#![stable(since=\"1.0.0\", feature = \"mep\")]\n+\n+#![crate_type=\"rlib\"]\n+\n+#[rustc_promotable]\n+#[stable(since=\"1.0.0\", feature = \"mep\")]\n+#[inline]\n+pub const fn foo() -> usize { 22 }\n+\n+#[stable(since=\"1.0.0\", feature = \"mep\")]\n+pub struct Foo(usize);\n+\n+impl Foo {\n+    #[stable(since=\"1.0.0\", feature = \"mep\")]\n+    #[inline]\n+    #[rustc_promotable]\n+    pub const fn foo() -> usize { 22 }\n+}"}, {"sha": "13309f978b6729733584a2ea1dd170e77a8a2338", "filename": "src/test/ui/consts/const-prop-ice.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fui%2Fconsts%2Fconst-prop-ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fui%2Fconsts%2Fconst-prop-ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-prop-ice.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -0,0 +1,3 @@\n+fn main() {\n+    [0; 3][3u64 as usize]; //~ ERROR the len is 3 but the index is 3\n+}"}, {"sha": "749ef952b5ddbee40f4bf382809dd21241788aac", "filename": "src/test/ui/consts/const-prop-ice.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fui%2Fconsts%2Fconst-prop-ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fui%2Fconsts%2Fconst-prop-ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-prop-ice.stderr?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -0,0 +1,10 @@\n+error: index out of bounds: the len is 3 but the index is 3\n+  --> $DIR/const-prop-ice.rs:2:5\n+   |\n+LL |     [0; 3][3u64 as usize]; //~ ERROR the len is 3 but the index is 3\n+   |     ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: #[deny(const_err)] on by default\n+\n+error: aborting due to previous error\n+"}, {"sha": "e5fd79f11676e76f456263be064f26e2a60e96b1", "filename": "src/test/ui/consts/const-prop-ice2.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fui%2Fconsts%2Fconst-prop-ice2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fui%2Fconsts%2Fconst-prop-ice2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-prop-ice2.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -0,0 +1,5 @@\n+fn main() {\n+    enum Enum { One=1 }\n+    let xs=[0;1 as usize];\n+    println!(\"{}\", xs[Enum::One as usize]); //~ ERROR the len is 1 but the index is 1\n+}"}, {"sha": "4febd0ee1e3911a3b16ad2f6f7f2b164fe9c5cce", "filename": "src/test/ui/consts/const-prop-ice2.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fui%2Fconsts%2Fconst-prop-ice2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fui%2Fconsts%2Fconst-prop-ice2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-prop-ice2.stderr?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -0,0 +1,10 @@\n+error: index out of bounds: the len is 1 but the index is 1\n+  --> $DIR/const-prop-ice2.rs:4:20\n+   |\n+LL |     println!(\"{}\", xs[Enum::One as usize]); //~ ERROR the len is 1 but the index is 1\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: #[deny(const_err)] on by default\n+\n+error: aborting due to previous error\n+"}, {"sha": "045322de3470820ed61789bd5ddcf5d038d93b4d", "filename": "src/test/ui/consts/promote_fn_calls.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fui%2Fconsts%2Fpromote_fn_calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fui%2Fconsts%2Fpromote_fn_calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fpromote_fn_calls.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -0,0 +1,13 @@\n+// compile-pass\n+// aux-build:promotable_const_fn_lib.rs\n+\n+#![feature(nll)]\n+\n+extern crate promotable_const_fn_lib;\n+\n+use promotable_const_fn_lib::{foo, Foo};\n+\n+fn main() {\n+    let x: &'static usize = &foo();\n+    let x: &'static usize = &Foo::foo();\n+}"}, {"sha": "0350708d673d7d52a9558f76aaf806f6d6ea6a72", "filename": "src/test/ui/consts/promote_fn_calls_std.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fui%2Fconsts%2Fpromote_fn_calls_std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fui%2Fconsts%2Fpromote_fn_calls_std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fpromote_fn_calls_std.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -0,0 +1,30 @@\n+// compile-pass\n+\n+#![feature(nll)]\n+\n+fn main() {\n+    let x: &'static u8 = &u8::max_value();\n+    let x: &'static u16 = &u16::max_value();\n+    let x: &'static u32 = &u32::max_value();\n+    let x: &'static u64 = &u64::max_value();\n+    let x: &'static u128 = &u128::max_value();\n+    let x: &'static usize = &usize::max_value();\n+    let x: &'static u8 = &u8::min_value();\n+    let x: &'static u16 = &u16::min_value();\n+    let x: &'static u32 = &u32::min_value();\n+    let x: &'static u64 = &u64::min_value();\n+    let x: &'static u128 = &u128::min_value();\n+    let x: &'static usize = &usize::min_value();\n+    let x: &'static i8 = &i8::max_value();\n+    let x: &'static i16 = &i16::max_value();\n+    let x: &'static i32 = &i32::max_value();\n+    let x: &'static i64 = &i64::max_value();\n+    let x: &'static i128 = &i128::max_value();\n+    let x: &'static isize = &isize::max_value();\n+    let x: &'static i8 = &i8::min_value();\n+    let x: &'static i16 = &i16::min_value();\n+    let x: &'static i32 = &i32::min_value();\n+    let x: &'static i64 = &i64::min_value();\n+    let x: &'static i128 = &i128::min_value();\n+    let x: &'static isize = &isize::min_value();\n+}"}, {"sha": "c35c7e10f5a38500ab26cff4ab0cc8854964f397", "filename": "src/test/ui/error-codes/E0191.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fui%2Ferror-codes%2FE0191.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fui%2Ferror-codes%2FE0191.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0191.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -14,5 +14,4 @@ trait Trait {\n \n type Foo = Trait; //~ ERROR E0191\n \n-fn main() {\n-}\n+fn main() {}"}, {"sha": "c7bfa85093f2da7147a162af5bdbe627a9c5c32f", "filename": "src/test/ui/error-codes/E0719.rs", "status": "renamed", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fui%2Ferror-codes%2FE0719.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fui%2Ferror-codes%2FE0719.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0719.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -8,16 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-pass\n-\n-use std::iter::Iterator;\n+trait Foo: Iterator<Item = i32, Item = i32> {}\n \n type Unit = ();\n \n-fn test() ->  Box<Iterator<Item = (), Item = Unit>> {\n+fn test() -> Box<Iterator<Item = (), Item = Unit>> {\n     Box::new(None.into_iter())\n }\n \n fn main() {\n+    let _: &Iterator<Item = i32, Item = i32>;\n     test();\n }", "previous_filename": "src/test/ui/lint/issue-50589-multiple-associated-types.rs"}, {"sha": "3a908fceced6028cd4612ee7b1753115350cb04d", "filename": "src/test/ui/error-codes/E0719.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fui%2Ferror-codes%2FE0719.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fui%2Ferror-codes%2FE0719.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0719.stderr?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -0,0 +1,19 @@\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/E0719.rs:11:33\n+   |\n+LL | trait Foo: Iterator<Item = i32, Item = i32> {}\n+   |                     ----------  ^^^^^^^^^^ re-bound here\n+   |                     |\n+   |                     `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/E0719.rs:15:38\n+   |\n+LL | fn test() -> Box<Iterator<Item = (), Item = Unit>> {\n+   |                           ---------  ^^^^^^^^^^^ re-bound here\n+   |                           |\n+   |                           `Item` bound here first\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0719`."}, {"sha": "3ad7435fecf29790d20ea7d1b500432b6b48f817", "filename": "src/test/ui/hygiene/no_implicit_prelude-2018.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fui%2Fhygiene%2Fno_implicit_prelude-2018.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fui%2Fhygiene%2Fno_implicit_prelude-2018.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fno_implicit_prelude-2018.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -0,0 +1,11 @@\n+// edition:2018\n+\n+#[no_implicit_prelude]\n+mod bar {\n+    fn f() {\n+        ::std::print!(\"\"); // OK\n+        print!(); //~ ERROR cannot find macro `print!` in this scope\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "370fc9784ad4da3357ec5bf7722d94ef2d4b8d86", "filename": "src/test/ui/hygiene/no_implicit_prelude-2018.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fui%2Fhygiene%2Fno_implicit_prelude-2018.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fui%2Fhygiene%2Fno_implicit_prelude-2018.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fno_implicit_prelude-2018.stderr?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -0,0 +1,10 @@\n+error: cannot find macro `print!` in this scope\n+  --> $DIR/no_implicit_prelude-2018.rs:7:9\n+   |\n+LL |         print!(); //~ ERROR cannot find macro `print!` in this scope\n+   |         ^^^^^\n+   |\n+   = help: have you added the `#[macro_use]` on the module/import?\n+\n+error: aborting due to previous error\n+"}, {"sha": "5b6041945abea76a2f9d57e39d0b591a66ab9798", "filename": "src/test/ui/hygiene/no_implicit_prelude.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fui%2Fhygiene%2Fno_implicit_prelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fui%2Fhygiene%2Fno_implicit_prelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fno_implicit_prelude.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -21,7 +21,10 @@ mod bar {\n         Vec::new(); //~ ERROR failed to resolve\n         ().clone() //~ ERROR no method named `clone` found\n     }\n-    fn f() { ::foo::m!(); }\n+    fn f() {\n+        ::foo::m!();\n+        println!(); // OK on 2015 edition (at least for now)\n+    }\n }\n \n fn main() {}"}, {"sha": "7b79807e4d7ff5df6ffa42a3e4a12a3ec698367d", "filename": "src/test/ui/issue-51947.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/852ff1fc7d74a7668441e0f354f8c477c95b676d/src%2Ftest%2Fui%2Fissue-51947.rs", "raw_url": "https://github.com/rust-lang/rust/raw/852ff1fc7d74a7668441e0f354f8c477c95b676d/src%2Ftest%2Fui%2Fissue-51947.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-51947.rs?ref=852ff1fc7d74a7668441e0f354f8c477c95b676d", "patch": "@@ -1,17 +0,0 @@\n-// compile-pass\n-\n-#![crate_type = \"lib\"]\n-#![feature(linkage)]\n-\n-// MergeFunctions will merge these via an anonymous internal\n-// backing function, which must be named if ThinLTO buffers are used\n-\n-#[linkage = \"weak\"]\n-pub fn fn1(a: u32, b: u32, c: u32) -> u32 {\n-    a + b + c\n-}\n-\n-#[linkage = \"weak\"]\n-pub fn fn2(a: u32, b: u32, c: u32) -> u32 {\n-    a + b + c\n-}"}, {"sha": "9620f89338620c3bd715c9066d90e65d812c88f4", "filename": "src/test/ui/issues/issue-23122-2.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fui%2Fissues%2Fissue-23122-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fui%2Fissues%2Fissue-23122-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-23122-2.stderr?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -1,10 +1,11 @@\n-error[E0275]: overflow evaluating the requirement `<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<T as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next`\n+error[E0275]: overflow evaluating the requirement `<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<T as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next: std::marker::Sized`\n   --> $DIR/issue-23122-2.rs:17:15\n    |\n LL | impl<T: Next> Next for GetNext<T> {\n    |               ^^^^\n    |\n    = help: consider adding a `#![recursion_limit=\"128\"]` attribute to your crate\n+   = note: required because of the requirements on the impl of `Next` for `GetNext<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<T as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next>`\n \n error: aborting due to previous error\n "}, {"sha": "3e0c3c002f64962cb97c905a8f8e1faa239c30d7", "filename": "src/test/ui/issues/issue-51947.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fui%2Fissues%2Fissue-51947.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fui%2Fissues%2Fissue-51947.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-51947.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-pass\n+\n+#![crate_type = \"lib\"]\n+#![feature(linkage)]\n+\n+// MergeFunctions will merge these via an anonymous internal\n+// backing function, which must be named if ThinLTO buffers are used\n+\n+#[linkage = \"weak\"]\n+pub fn fn1(a: u32, b: u32, c: u32) -> u32 {\n+    a + b + c\n+}\n+\n+#[linkage = \"weak\"]\n+pub fn fn2(a: u32, b: u32, c: u32) -> u32 {\n+    a + b + c\n+}"}, {"sha": "b48d4a9c022f42dbe1aadab24058278dd2aef4a9", "filename": "src/test/ui/issues/issue-55796.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fui%2Fissues%2Fissue-55796.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fui%2Fissues%2Fissue-55796.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-55796.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -0,0 +1,22 @@\n+pub trait EdgeTrait<N> {\n+    fn target(&self) -> N;\n+}\n+\n+pub trait Graph<'a> {\n+    type Node;\n+    type Edge: EdgeTrait<Self::Node>;\n+    type NodesIter: Iterator<Item = Self::Node> + 'a;\n+    type EdgesIter: Iterator<Item = Self::Edge> + 'a;\n+\n+    fn nodes(&'a self) -> Self::NodesIter;\n+    fn out_edges(&'a self, u: &Self::Node) -> Self::EdgesIter;\n+    fn in_edges(&'a self, u: &Self::Node) -> Self::EdgesIter;\n+\n+    fn out_neighbors(&'a self, u: &Self::Node) -> Box<Iterator<Item = Self::Node>> {\n+        Box::new(self.out_edges(u).map(|e| e.target()))\n+    }\n+\n+    fn in_neighbors(&'a self, u: &Self::Node) -> Box<Iterator<Item = Self::Node>> {\n+        Box::new(self.in_edges(u).map(|e| e.target()))\n+    }\n+}"}, {"sha": "60ce8293a5ceb4e4ee54219687464b9351c6413c", "filename": "src/test/ui/issues/issue-55796.stderr", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fui%2Fissues%2Fissue-55796.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fui%2Fissues%2Fissue-55796.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-55796.stderr?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -0,0 +1,50 @@\n+error[E0601]: `main` function not found in crate `issue_55796`\n+   |\n+   = note: consider adding a `main` function to `$DIR/issue-55796.rs`\n+\n+error[E0495]: cannot infer an appropriate lifetime due to conflicting requirements\n+  --> $DIR/issue-55796.rs:16:9\n+   |\n+LL |         Box::new(self.out_edges(u).map(|e| e.target()))\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: first, the lifetime cannot outlive the lifetime 'a as defined on the trait at 5:17...\n+  --> $DIR/issue-55796.rs:5:17\n+   |\n+LL | pub trait Graph<'a> {\n+   |                 ^^\n+note: ...so that the type `std::iter::Map<<Self as Graph<'a>>::EdgesIter, [closure@$DIR/issue-55796.rs:16:40: 16:54]>` will meet its required lifetime bounds\n+  --> $DIR/issue-55796.rs:16:9\n+   |\n+LL |         Box::new(self.out_edges(u).map(|e| e.target()))\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: but, the lifetime must be valid for the static lifetime...\n+   = note: ...so that the expression is assignable:\n+           expected std::boxed::Box<(dyn std::iter::Iterator<Item=<Self as Graph<'a>>::Node> + 'static)>\n+              found std::boxed::Box<dyn std::iter::Iterator<Item=<Self as Graph<'a>>::Node>>\n+\n+error[E0495]: cannot infer an appropriate lifetime due to conflicting requirements\n+  --> $DIR/issue-55796.rs:20:9\n+   |\n+LL |         Box::new(self.in_edges(u).map(|e| e.target()))\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: first, the lifetime cannot outlive the lifetime 'a as defined on the trait at 5:17...\n+  --> $DIR/issue-55796.rs:5:17\n+   |\n+LL | pub trait Graph<'a> {\n+   |                 ^^\n+note: ...so that the type `std::iter::Map<<Self as Graph<'a>>::EdgesIter, [closure@$DIR/issue-55796.rs:20:39: 20:53]>` will meet its required lifetime bounds\n+  --> $DIR/issue-55796.rs:20:9\n+   |\n+LL |         Box::new(self.in_edges(u).map(|e| e.target()))\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: but, the lifetime must be valid for the static lifetime...\n+   = note: ...so that the expression is assignable:\n+           expected std::boxed::Box<(dyn std::iter::Iterator<Item=<Self as Graph<'a>>::Node> + 'static)>\n+              found std::boxed::Box<dyn std::iter::Iterator<Item=<Self as Graph<'a>>::Node>>\n+\n+error: aborting due to 3 previous errors\n+\n+Some errors occurred: E0495, E0601.\n+For more information about an error, try `rustc --explain E0495`."}, {"sha": "7f0a1ee1f3307b2a4f3f226d88f715a50af84def", "filename": "src/test/ui/lint/issue-50589-multiple-associated-types.stderr", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/852ff1fc7d74a7668441e0f354f8c477c95b676d/src%2Ftest%2Fui%2Flint%2Fissue-50589-multiple-associated-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/852ff1fc7d74a7668441e0f354f8c477c95b676d/src%2Ftest%2Fui%2Flint%2Fissue-50589-multiple-associated-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fissue-50589-multiple-associated-types.stderr?ref=852ff1fc7d74a7668441e0f354f8c477c95b676d", "patch": "@@ -1,23 +0,0 @@\n-warning: associated type binding `Item` specified more than once\n-  --> $DIR/issue-50589-multiple-associated-types.rs:17:39\n-   |\n-LL | fn test() ->  Box<Iterator<Item = (), Item = Unit>> {\n-   |                            ---------  ^^^^^^^^^^^ used more than once\n-   |                            |\n-   |                            first use of `Item`\n-   |\n-   = note: #[warn(duplicate_associated_type_bindings)] on by default\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #50589 <https://github.com/rust-lang/rust/issues/50589>\n-\n-warning: associated type binding `Item` specified more than once\n-  --> $DIR/issue-50589-multiple-associated-types.rs:17:39\n-   |\n-LL | fn test() ->  Box<Iterator<Item = (), Item = Unit>> {\n-   |                            ---------  ^^^^^^^^^^^ used more than once\n-   |                            |\n-   |                            first use of `Item`\n-   |\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #50589 <https://github.com/rust-lang/rust/issues/50589>\n-"}, {"sha": "40f68c6782781f0b01163c4c1db385d167e5a7e6", "filename": "src/test/ui/lint/lint-unused-mut-variables.nll.stderr", "status": "removed", "additions": 0, "deletions": 150, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/852ff1fc7d74a7668441e0f354f8c477c95b676d/src%2Ftest%2Fui%2Flint%2Flint-unused-mut-variables.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/852ff1fc7d74a7668441e0f354f8c477c95b676d/src%2Ftest%2Fui%2Flint%2Flint-unused-mut-variables.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-unused-mut-variables.nll.stderr?ref=852ff1fc7d74a7668441e0f354f8c477c95b676d", "patch": "@@ -1,150 +0,0 @@\n-error: variable does not need to be mutable\n-  --> $DIR/lint-unused-mut-variables.rs:59:14\n-   |\n-LL |     let x = |mut y: isize| 10; //[lexical]~ ERROR: variable does not need to be mutable\n-   |              ----^\n-   |              |\n-   |              help: remove this `mut`\n-   |\n-note: lint level defined here\n-  --> $DIR/lint-unused-mut-variables.rs:19:9\n-   |\n-LL | #![deny(unused_mut)]\n-   |         ^^^^^^^^^^\n-\n-error: variable does not need to be mutable\n-  --> $DIR/lint-unused-mut-variables.rs:24:9\n-   |\n-LL |     let mut a = 3; //[lexical]~ ERROR: variable does not need to be mutable\n-   |         ----^\n-   |         |\n-   |         help: remove this `mut`\n-\n-error: variable does not need to be mutable\n-  --> $DIR/lint-unused-mut-variables.rs:26:9\n-   |\n-LL |     let mut a = 2; //[lexical]~ ERROR: variable does not need to be mutable\n-   |         ----^\n-   |         |\n-   |         help: remove this `mut`\n-\n-error: variable does not need to be mutable\n-  --> $DIR/lint-unused-mut-variables.rs:28:9\n-   |\n-LL |     let mut b = 3; //[lexical]~ ERROR: variable does not need to be mutable\n-   |         ----^\n-   |         |\n-   |         help: remove this `mut`\n-\n-error: variable does not need to be mutable\n-  --> $DIR/lint-unused-mut-variables.rs:30:9\n-   |\n-LL |     let mut a = vec![3]; //[lexical]~ ERROR: variable does not need to be mutable\n-   |         ----^\n-   |         |\n-   |         help: remove this `mut`\n-\n-error: variable does not need to be mutable\n-  --> $DIR/lint-unused-mut-variables.rs:32:10\n-   |\n-LL |     let (mut a, b) = (1, 2); //[lexical]~ ERROR: variable does not need to be mutable\n-   |          ----^\n-   |          |\n-   |          help: remove this `mut`\n-\n-error: variable does not need to be mutable\n-  --> $DIR/lint-unused-mut-variables.rs:34:9\n-   |\n-LL |     let mut a; //[lexical]~ ERROR: variable does not need to be mutable\n-   |         ----^\n-   |         |\n-   |         help: remove this `mut`\n-\n-error: variable does not need to be mutable\n-  --> $DIR/lint-unused-mut-variables.rs:38:9\n-   |\n-LL |     let mut b; //[lexical]~ ERROR: variable does not need to be mutable\n-   |         ----^\n-   |         |\n-   |         help: remove this `mut`\n-\n-error: variable does not need to be mutable\n-  --> $DIR/lint-unused-mut-variables.rs:47:9\n-   |\n-LL |         mut x => {} //[lexical]~ ERROR: variable does not need to be mutable\n-   |         ----^\n-   |         |\n-   |         help: remove this `mut`\n-\n-error: variable does not need to be mutable\n-  --> $DIR/lint-unused-mut-variables.rs:51:8\n-   |\n-LL |       (mut x, 1) | //[lexical]~ ERROR: variable does not need to be mutable\n-   |        ----^\n-   |        |\n-   |        help: remove this `mut`\n-\n-error: variable does not need to be mutable\n-  --> $DIR/lint-unused-mut-variables.rs:64:9\n-   |\n-LL |     let mut a = &mut 5; //[lexical]~ ERROR: variable does not need to be mutable\n-   |         ----^\n-   |         |\n-   |         help: remove this `mut`\n-\n-error: variable does not need to be mutable\n-  --> $DIR/lint-unused-mut-variables.rs:69:9\n-   |\n-LL |     let mut b = (&mut a,); //[lexical]~ ERROR: variable does not need to be mutable\n-   |         ----^\n-   |         |\n-   |         help: remove this `mut`\n-\n-error: variable does not need to be mutable\n-  --> $DIR/lint-unused-mut-variables.rs:72:9\n-   |\n-LL |     let mut x = &mut 1; //[lexical]~ ERROR: variable does not need to be mutable\n-   |         ----^\n-   |         |\n-   |         help: remove this `mut`\n-\n-error: variable does not need to be mutable\n-  --> $DIR/lint-unused-mut-variables.rs:84:9\n-   |\n-LL |     let mut v : &mut Vec<()> = &mut vec![]; //[lexical]~ ERROR: variable does not need to be mutable\n-   |         ----^\n-   |         |\n-   |         help: remove this `mut`\n-\n-error: variable does not need to be mutable\n-  --> $DIR/lint-unused-mut-variables.rs:61:13\n-   |\n-LL |     fn what(mut foo: isize) {} //[lexical]~ ERROR: variable does not need to be mutable\n-   |             ----^^^\n-   |             |\n-   |             help: remove this `mut`\n-\n-error: variable does not need to be mutable\n-  --> $DIR/lint-unused-mut-variables.rs:79:20\n-   |\n-LL |     fn mut_ref_arg(mut arg : &mut [u8]) -> &mut [u8] {\n-   |                    ----^^^\n-   |                    |\n-   |                    help: remove this `mut`\n-\n-error: variable does not need to be mutable\n-  --> $DIR/lint-unused-mut-variables.rs:143:9\n-   |\n-LL |     let mut b = vec![2]; //[lexical]~ ERROR: variable does not need to be mutable\n-   |         ----^\n-   |         |\n-   |         help: remove this `mut`\n-   |\n-note: lint level defined here\n-  --> $DIR/lint-unused-mut-variables.rs:139:8\n-   |\n-LL | #[deny(unused_mut)]\n-   |        ^^^^^^^^^^\n-\n-error: aborting due to 17 previous errors\n-"}, {"sha": "a2005ba9f72e02db8b82d3d3736c3d6756d9d9a2", "filename": "src/test/ui/lint/lint-unused-mut-variables.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fui%2Flint%2Flint-unused-mut-variables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fui%2Flint%2Flint-unused-mut-variables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-unused-mut-variables.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// revisions: lexical nll\n-#![cfg_attr(nll, feature(nll))]\n+\n+\n \n // Exercise the unused_mut attribute in some positive and negative cases\n \n@@ -21,68 +21,68 @@\n \n fn main() {\n     // negative cases\n-    let mut a = 3; //[lexical]~ ERROR: variable does not need to be mutable\n-                   //[nll]~^ ERROR: variable does not need to be mutable\n-    let mut a = 2; //[lexical]~ ERROR: variable does not need to be mutable\n-                   //[nll]~^ ERROR: variable does not need to be mutable\n-    let mut b = 3; //[lexical]~ ERROR: variable does not need to be mutable\n-                   //[nll]~^ ERROR: variable does not need to be mutable\n-    let mut a = vec![3]; //[lexical]~ ERROR: variable does not need to be mutable\n-                         //[nll]~^ ERROR: variable does not need to be mutable\n-    let (mut a, b) = (1, 2); //[lexical]~ ERROR: variable does not need to be mutable\n-                             //[nll]~^ ERROR: variable does not need to be mutable\n-    let mut a; //[lexical]~ ERROR: variable does not need to be mutable\n-               //[nll]~^ ERROR: variable does not need to be mutable\n+    let mut a = 3; //~ ERROR: variable does not need to be mutable\n+\n+    let mut a = 2; //~ ERROR: variable does not need to be mutable\n+\n+    let mut b = 3; //~ ERROR: variable does not need to be mutable\n+\n+    let mut a = vec![3]; //~ ERROR: variable does not need to be mutable\n+\n+    let (mut a, b) = (1, 2); //~ ERROR: variable does not need to be mutable\n+\n+    let mut a; //~ ERROR: variable does not need to be mutable\n+\n     a = 3;\n \n-    let mut b; //[lexical]~ ERROR: variable does not need to be mutable\n-               //[nll]~^ ERROR: variable does not need to be mutable\n+    let mut b; //~ ERROR: variable does not need to be mutable\n+\n     if true {\n         b = 3;\n     } else {\n         b = 4;\n     }\n \n     match 30 {\n-        mut x => {} //[lexical]~ ERROR: variable does not need to be mutable\n-                    //[nll]~^ ERROR: variable does not need to be mutable\n+        mut x => {} //~ ERROR: variable does not need to be mutable\n+\n     }\n     match (30, 2) {\n-      (mut x, 1) | //[lexical]~ ERROR: variable does not need to be mutable\n-                   //[nll]~^ ERROR: variable does not need to be mutable\n+      (mut x, 1) | //~ ERROR: variable does not need to be mutable\n+\n       (mut x, 2) |\n       (mut x, 3) => {\n       }\n       _ => {}\n     }\n \n-    let x = |mut y: isize| 10; //[lexical]~ ERROR: variable does not need to be mutable\n-                               //[nll]~^ ERROR: variable does not need to be mutable\n-    fn what(mut foo: isize) {} //[lexical]~ ERROR: variable does not need to be mutable\n-                               //[nll]~^ ERROR: variable does not need to be mutable\n+    let x = |mut y: isize| 10; //~ ERROR: variable does not need to be mutable\n+\n+    fn what(mut foo: isize) {} //~ ERROR: variable does not need to be mutable\n+\n+\n+    let mut a = &mut 5; //~ ERROR: variable does not need to be mutable\n \n-    let mut a = &mut 5; //[lexical]~ ERROR: variable does not need to be mutable\n-                        //[nll]~^ ERROR: variable does not need to be mutable\n     *a = 4;\n \n     let mut a = 5;\n-    let mut b = (&mut a,); //[lexical]~ ERROR: variable does not need to be mutable\n-    *b.0 = 4;              //[nll]~^ ERROR: variable does not need to be mutable\n+    let mut b = (&mut a,); //~ ERROR: variable does not need to be mutable\n+    *b.0 = 4;\n+\n+    let mut x = &mut 1; //~ ERROR: variable does not need to be mutable\n \n-    let mut x = &mut 1; //[lexical]~ ERROR: variable does not need to be mutable\n-                        //[nll]~^ ERROR: variable does not need to be mutable\n     let mut f = || {\n       *x += 1;\n     };\n     f();\n \n     fn mut_ref_arg(mut arg : &mut [u8]) -> &mut [u8] {\n-        &mut arg[..] //[lexical]~^ ERROR: variable does not need to be mutable\n-                     //[nll]~^^ ERROR: variable does not need to be mutable\n+        &mut arg[..] //~^ ERROR: variable does not need to be mutable\n+\n     }\n \n-    let mut v : &mut Vec<()> = &mut vec![]; //[lexical]~ ERROR: variable does not need to be mutable\n-                                            //[nll]~^ ERROR: variable does not need to be mutable\n+    let mut v : &mut Vec<()> = &mut vec![]; //~ ERROR: variable does not need to be mutable\n+\n     v.push(());\n \n     // positive cases\n@@ -140,6 +140,6 @@ fn foo(mut a: isize) {\n fn bar() {\n     #[allow(unused_mut)]\n     let mut a = 3;\n-    let mut b = vec![2]; //[lexical]~ ERROR: variable does not need to be mutable\n-                         //[nll]~^ ERROR: variable does not need to be mutable\n+    let mut b = vec![2]; //~ ERROR: variable does not need to be mutable\n+\n }"}, {"sha": "60e8400c42870980a52cefe5a4f0bd430270661f", "filename": "src/test/ui/lint/lint-unused-mut-variables.stderr", "status": "renamed", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fui%2Flint%2Flint-unused-mut-variables.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fui%2Flint%2Flint-unused-mut-variables.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-unused-mut-variables.stderr?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -1,7 +1,7 @@\n error: variable does not need to be mutable\n   --> $DIR/lint-unused-mut-variables.rs:59:14\n    |\n-LL |     let x = |mut y: isize| 10; //[lexical]~ ERROR: variable does not need to be mutable\n+LL |     let x = |mut y: isize| 10; //~ ERROR: variable does not need to be mutable\n    |              ----^\n    |              |\n    |              help: remove this `mut`\n@@ -15,111 +15,111 @@ LL | #![deny(unused_mut)]\n error: variable does not need to be mutable\n   --> $DIR/lint-unused-mut-variables.rs:24:9\n    |\n-LL |     let mut a = 3; //[lexical]~ ERROR: variable does not need to be mutable\n+LL |     let mut a = 3; //~ ERROR: variable does not need to be mutable\n    |         ----^\n    |         |\n    |         help: remove this `mut`\n \n error: variable does not need to be mutable\n   --> $DIR/lint-unused-mut-variables.rs:26:9\n    |\n-LL |     let mut a = 2; //[lexical]~ ERROR: variable does not need to be mutable\n+LL |     let mut a = 2; //~ ERROR: variable does not need to be mutable\n    |         ----^\n    |         |\n    |         help: remove this `mut`\n \n error: variable does not need to be mutable\n   --> $DIR/lint-unused-mut-variables.rs:28:9\n    |\n-LL |     let mut b = 3; //[lexical]~ ERROR: variable does not need to be mutable\n+LL |     let mut b = 3; //~ ERROR: variable does not need to be mutable\n    |         ----^\n    |         |\n    |         help: remove this `mut`\n \n error: variable does not need to be mutable\n   --> $DIR/lint-unused-mut-variables.rs:30:9\n    |\n-LL |     let mut a = vec![3]; //[lexical]~ ERROR: variable does not need to be mutable\n+LL |     let mut a = vec![3]; //~ ERROR: variable does not need to be mutable\n    |         ----^\n    |         |\n    |         help: remove this `mut`\n \n error: variable does not need to be mutable\n   --> $DIR/lint-unused-mut-variables.rs:32:10\n    |\n-LL |     let (mut a, b) = (1, 2); //[lexical]~ ERROR: variable does not need to be mutable\n+LL |     let (mut a, b) = (1, 2); //~ ERROR: variable does not need to be mutable\n    |          ----^\n    |          |\n    |          help: remove this `mut`\n \n error: variable does not need to be mutable\n   --> $DIR/lint-unused-mut-variables.rs:34:9\n    |\n-LL |     let mut a; //[lexical]~ ERROR: variable does not need to be mutable\n+LL |     let mut a; //~ ERROR: variable does not need to be mutable\n    |         ----^\n    |         |\n    |         help: remove this `mut`\n \n error: variable does not need to be mutable\n   --> $DIR/lint-unused-mut-variables.rs:38:9\n    |\n-LL |     let mut b; //[lexical]~ ERROR: variable does not need to be mutable\n+LL |     let mut b; //~ ERROR: variable does not need to be mutable\n    |         ----^\n    |         |\n    |         help: remove this `mut`\n \n error: variable does not need to be mutable\n   --> $DIR/lint-unused-mut-variables.rs:47:9\n    |\n-LL |         mut x => {} //[lexical]~ ERROR: variable does not need to be mutable\n+LL |         mut x => {} //~ ERROR: variable does not need to be mutable\n    |         ----^\n    |         |\n    |         help: remove this `mut`\n \n error: variable does not need to be mutable\n   --> $DIR/lint-unused-mut-variables.rs:51:8\n    |\n-LL |       (mut x, 1) | //[lexical]~ ERROR: variable does not need to be mutable\n+LL |       (mut x, 1) | //~ ERROR: variable does not need to be mutable\n    |        ----^\n    |        |\n    |        help: remove this `mut`\n \n error: variable does not need to be mutable\n   --> $DIR/lint-unused-mut-variables.rs:64:9\n    |\n-LL |     let mut a = &mut 5; //[lexical]~ ERROR: variable does not need to be mutable\n+LL |     let mut a = &mut 5; //~ ERROR: variable does not need to be mutable\n    |         ----^\n    |         |\n    |         help: remove this `mut`\n \n error: variable does not need to be mutable\n   --> $DIR/lint-unused-mut-variables.rs:69:9\n    |\n-LL |     let mut b = (&mut a,); //[lexical]~ ERROR: variable does not need to be mutable\n+LL |     let mut b = (&mut a,); //~ ERROR: variable does not need to be mutable\n    |         ----^\n    |         |\n    |         help: remove this `mut`\n \n error: variable does not need to be mutable\n   --> $DIR/lint-unused-mut-variables.rs:72:9\n    |\n-LL |     let mut x = &mut 1; //[lexical]~ ERROR: variable does not need to be mutable\n+LL |     let mut x = &mut 1; //~ ERROR: variable does not need to be mutable\n    |         ----^\n    |         |\n    |         help: remove this `mut`\n \n error: variable does not need to be mutable\n   --> $DIR/lint-unused-mut-variables.rs:84:9\n    |\n-LL |     let mut v : &mut Vec<()> = &mut vec![]; //[lexical]~ ERROR: variable does not need to be mutable\n+LL |     let mut v : &mut Vec<()> = &mut vec![]; //~ ERROR: variable does not need to be mutable\n    |         ----^\n    |         |\n    |         help: remove this `mut`\n \n error: variable does not need to be mutable\n   --> $DIR/lint-unused-mut-variables.rs:61:13\n    |\n-LL |     fn what(mut foo: isize) {} //[lexical]~ ERROR: variable does not need to be mutable\n+LL |     fn what(mut foo: isize) {} //~ ERROR: variable does not need to be mutable\n    |             ----^^^\n    |             |\n    |             help: remove this `mut`\n@@ -135,7 +135,7 @@ LL |     fn mut_ref_arg(mut arg : &mut [u8]) -> &mut [u8] {\n error: variable does not need to be mutable\n   --> $DIR/lint-unused-mut-variables.rs:143:9\n    |\n-LL |     let mut b = vec![2]; //[lexical]~ ERROR: variable does not need to be mutable\n+LL |     let mut b = vec![2]; //~ ERROR: variable does not need to be mutable\n    |         ----^\n    |         |\n    |         help: remove this `mut`", "previous_filename": "src/test/ui/lint/lint-unused-mut-variables.lexical.stderr"}, {"sha": "452fc88d1ecdd07083f7b2f63c5d187b1e02b681", "filename": "src/test/ui/nll/issue-55394.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fui%2Fnll%2Fissue-55394.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fui%2Fnll%2Fissue-55394.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-55394.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(nll)]\n+\n+struct Bar;\n+\n+struct Foo<'s> {\n+    bar: &'s mut Bar,\n+}\n+\n+impl Foo<'_> {\n+    fn new(bar: &mut Bar) -> Self {\n+        Foo { bar }\n+    }\n+}\n+\n+fn main() { }"}, {"sha": "284d7afa6fd23cc38056422be695d5ec9a35daea", "filename": "src/test/ui/nll/issue-55394.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fui%2Fnll%2Fissue-55394.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fui%2Fnll%2Fissue-55394.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-55394.stderr?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -0,0 +1,12 @@\n+error: unsatisfied lifetime constraints\n+  --> $DIR/issue-55394.rs:21:9\n+   |\n+LL |     fn new(bar: &mut Bar) -> Self {\n+   |                 -            ---- return type is Foo<'2>\n+   |                 |\n+   |                 let's call the lifetime of this reference `'1`\n+LL |         Foo { bar }\n+   |         ^^^^^^^^^^^ returning this value requires that `'1` must outlive `'2`\n+\n+error: aborting due to previous error\n+"}, {"sha": "3adcd8436d8a1c2c9075aaf5b7bbfe67552660da", "filename": "src/test/ui/traits/trait-alias-object.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-object.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "previous_filename": "src/test/ui/traits/trait-alias-objects.rs"}, {"sha": "6b7b322a53d9e86ec530d55da1ef9a887bbd02ff", "filename": "src/test/ui/traits/trait-alias-object.stderr", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-object.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-object.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-object.stderr?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -1,13 +1,13 @@\n error[E0038]: the trait `EqAlias` cannot be made into an object\n-  --> $DIR/trait-alias-objects.rs:17:13\n+  --> $DIR/trait-alias-object.rs:17:13\n    |\n LL |     let _: &dyn EqAlias = &123;\n    |             ^^^^^^^^^^^ the trait `EqAlias` cannot be made into an object\n    |\n    = note: the trait cannot use `Self` as a type parameter in the supertraits or where-clauses\n \n error[E0191]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) must be specified\n-  --> $DIR/trait-alias-objects.rs:18:13\n+  --> $DIR/trait-alias-object.rs:18:13\n    |\n LL |     let _: &dyn IteratorAlias = &vec![123].into_iter();\n    |             ^^^^^^^^^^^^^^^^^ missing associated type `Item` value", "previous_filename": "src/test/ui/traits/trait-alias-objects.stderr"}, {"sha": "9eed80ad886e0c876a3d14e08031382e7404dec3", "filename": "src/test/ui/typeck/issue-55810-must-typeck-match-pats-before-guards.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fui%2Ftypeck%2Fissue-55810-must-typeck-match-pats-before-guards.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftest%2Fui%2Ftypeck%2Fissue-55810-must-typeck-match-pats-before-guards.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-55810-must-typeck-match-pats-before-guards.rs?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -0,0 +1,23 @@\n+// compile-pass\n+\n+// rust-lang/rust#55810: types for a binding in a match arm can be\n+// inferred from arms that come later in the match.\n+\n+struct S;\n+\n+impl S {\n+    fn method(&self) -> bool {\n+        unimplemented!()\n+    }\n+}\n+\n+fn get<T>() -> T {\n+    unimplemented!()\n+}\n+\n+fn main() {\n+    match get() {\n+        x if x.method() => {}\n+        &S => {}\n+    }\n+}"}, {"sha": "241fac0e3933063fa48a1a01f5d577e40af12e4d", "filename": "src/tools/cargo", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcargo?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -1 +1 @@\n-Subproject commit 1fa30882067703202d13ad0bd53d630bc2c1de66\n+Subproject commit 241fac0e3933063fa48a1a01f5d577e40af12e4d"}, {"sha": "f2b08f8e0bbdd4bd840e6ba53c440602036d2717", "filename": "src/tools/rustc-workspace-hack/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftools%2Frustc-workspace-hack%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/50307942481ffd95e9eb616463363542bc79b14b/src%2Ftools%2Frustc-workspace-hack%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustc-workspace-hack%2FCargo.toml?ref=50307942481ffd95e9eb616463363542bc79b14b", "patch": "@@ -59,4 +59,4 @@ openssl = { version = \"0.10.12\", optional = true }\n \n \n [features]\n-all-static = ['openssl/vendored', 'curl-sys/static-curl']\n+all-static = ['openssl/vendored', 'curl-sys/static-curl', 'curl-sys/force-system-lib-on-osx']"}]}