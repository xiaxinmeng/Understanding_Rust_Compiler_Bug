{"sha": "7f1dfcab679a1c8248b16e34902a578c2f7bf5e2", "node_id": "C_kwDOAAsO6NoAKDdmMWRmY2FiNjc5YTFjODI0OGIxNmUzNDkwMmE1NzhjMmY3YmY1ZTI", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-07-04T23:04:41Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-07-08T23:02:50Z"}, "message": "Avoid transposes in deriving code.\n\nThe deriving code has some complex parts involving iterations over\nselflike args and also fields within structs and enum variants.\n\nThe return types for a few functions demonstrate this:\n\n- `TraitDef::create_{struct_pattern,enum_variant_pattern}` returns a\n  `(P<ast::Pat>, Vec<(Span, Option<Ident>, P<Expr>)>)`\n- `TraitDef::create_struct_field_accesses` returns a `Vec<(Span,\n  Option<Ident>, P<Expr>)>`.\n\nThis results in per-field data stored within per-selflike-arg data, with\nlots of repetition within the per-field data elements. This then has to\nbe \"transposed\" in two places (`expand_struct_method_body` and\n`expand_enum_method_body`) into per-self-like-arg data stored within\nper-field data. It's all quite clumsy and confusing.\n\nThis commit rearranges things greatly. Data is obtained in the needed\nform up-front, avoiding the need for transposition. Also, various\nfunctions are split, removed, and added, to make things clearer and\navoid tuple return values.\n\nThe diff is hard to read, which reflects the messiness of the original\ncode -- there wasn't an easy way to break these changes into small\npieces. (Sorry!) It's a net reduction of 35 lines and a readability\nimprovement. The generated code is unchanged.", "tree": {"sha": "80851c2d1732e81d49c66e29e80994c46caaca21", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/80851c2d1732e81d49c66e29e80994c46caaca21"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f1dfcab679a1c8248b16e34902a578c2f7bf5e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f1dfcab679a1c8248b16e34902a578c2f7bf5e2", "html_url": "https://github.com/rust-lang/rust/commit/7f1dfcab679a1c8248b16e34902a578c2f7bf5e2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f1dfcab679a1c8248b16e34902a578c2f7bf5e2/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "27571da5fae9ee5f4eb34582a91ba06ad0a2ab13", "url": "https://api.github.com/repos/rust-lang/rust/commits/27571da5fae9ee5f4eb34582a91ba06ad0a2ab13", "html_url": "https://github.com/rust-lang/rust/commit/27571da5fae9ee5f4eb34582a91ba06ad0a2ab13"}], "stats": {"total": 401, "additions": 183, "deletions": 218}, "files": [{"sha": "47ba6f50175593d3e7d4c6bd3eb0eb0347dcdb7f", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 183, "deletions": 218, "changes": 401, "blob_url": "https://github.com/rust-lang/rust/blob/7f1dfcab679a1c8248b16e34902a578c2f7bf5e2/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f1dfcab679a1c8248b16e34902a578c2f7bf5e2/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=7f1dfcab679a1c8248b16e34902a578c2f7bf5e2", "patch": "@@ -1047,67 +1047,40 @@ impl<'a> MethodDef<'a> {\n         use_temporaries: bool,\n         is_packed: bool,\n     ) -> BlockOrExpr {\n-        let mut raw_fields = Vec::new(); // Vec<[fields of self], [fields of next Self arg], [etc]>\n         let span = trait_.span;\n-        let mut patterns = Vec::new();\n-\n-        for (i, selflike_arg) in selflike_args.iter().enumerate() {\n-            let ident_exprs = if !is_packed {\n-                trait_.create_struct_field_accesses(cx, selflike_arg, struct_def)\n-            } else {\n-                // Get the pattern for the let-destructuring.\n-                //\n-                // We could use `type_ident` instead of `Self`, but in the case of a type parameter\n-                // shadowing the struct name, that causes a second, unnecessary E0578 error. #97343\n-                let struct_path = cx.path(span, vec![Ident::new(kw::SelfUpper, type_ident.span)]);\n-                let (pat, ident_exprs) = trait_.create_struct_pattern(\n-                    cx,\n-                    struct_path,\n-                    struct_def,\n-                    &format!(\"__self_{}\", i),\n-                    ast::Mutability::Not,\n-                    use_temporaries,\n-                );\n-                patterns.push(pat);\n-                ident_exprs\n-            };\n-            raw_fields.push(ident_exprs);\n-        }\n-\n-        // transpose raw_fields\n-        let fields = if !raw_fields.is_empty() {\n-            let mut raw_fields = raw_fields.into_iter().map(|v| v.into_iter());\n-            let first_field = raw_fields.next().unwrap();\n-            let mut nonself_fields: Vec<vec::IntoIter<_>> = raw_fields.collect();\n-            first_field\n-                .map(|(span, opt_id, expr)| FieldInfo {\n-                    span: span.with_ctxt(trait_.span.ctxt()),\n-                    name: opt_id,\n-                    self_expr: expr,\n-                    other_selflike_exprs: nonself_fields\n-                        .iter_mut()\n-                        .map(|l| {\n-                            let (_, _, ex) = l.next().unwrap();\n-                            ex\n-                        })\n-                        .collect(),\n-                })\n-                .collect()\n-        } else {\n-            cx.span_bug(span, \"no `self` parameter for method in generic `derive`\")\n+        assert!(selflike_args.len() == 1 || selflike_args.len() == 2);\n+\n+        let mk_body = |cx, selflike_fields| {\n+            self.call_substructure_method(\n+                cx,\n+                trait_,\n+                type_ident,\n+                nonselflike_args,\n+                &Struct(struct_def, selflike_fields),\n+            )\n         };\n \n-        let mut body = self.call_substructure_method(\n-            cx,\n-            trait_,\n-            type_ident,\n-            nonselflike_args,\n-            &Struct(struct_def, fields),\n-        );\n-\n         if !is_packed {\n-            body\n+            let selflike_fields =\n+                trait_.create_struct_field_access_fields(cx, selflike_args, struct_def);\n+            mk_body(cx, selflike_fields)\n         } else {\n+            let prefixes: Vec<_> =\n+                (0..selflike_args.len()).map(|i| format!(\"__self_{}\", i)).collect();\n+            let selflike_fields =\n+                trait_.create_struct_pattern_fields(cx, struct_def, &prefixes, use_temporaries);\n+            let mut body = mk_body(cx, selflike_fields);\n+\n+            let struct_path = cx.path(span, vec![Ident::new(kw::SelfUpper, type_ident.span)]);\n+            let patterns = trait_.create_struct_patterns(\n+                cx,\n+                struct_path,\n+                struct_def,\n+                &prefixes,\n+                ast::Mutability::Not,\n+                use_temporaries,\n+            );\n+\n             // Do the let-destructuring.\n             let mut stmts: Vec<_> = iter::zip(selflike_args, patterns)\n                 .map(|(selflike_arg_expr, pat)| {\n@@ -1193,7 +1166,7 @@ impl<'a> MethodDef<'a> {\n         let span = trait_.span;\n         let variants = &enum_def.variants;\n \n-        let selflike_arg_names = iter::once(\"__self\".to_string())\n+        let prefixes = iter::once(\"__self\".to_string())\n             .chain(\n                 selflike_args\n                     .iter()\n@@ -1206,7 +1179,7 @@ impl<'a> MethodDef<'a> {\n         // The `vi_idents` will be bound, solely in the catch-all, to\n         // a series of let statements mapping each selflike_arg to an int\n         // value corresponding to its discriminant.\n-        let vi_idents = selflike_arg_names\n+        let vi_idents = prefixes\n             .iter()\n             .map(|name| {\n                 let vi_suffix = format!(\"{}_vi\", name);\n@@ -1226,36 +1199,37 @@ impl<'a> MethodDef<'a> {\n         // (Variant2, Variant2, ...) => Body2\n         // ...\n         // where each tuple has length = selflike_args.len()\n+\n         let mut match_arms: Vec<ast::Arm> = variants\n             .iter()\n             .enumerate()\n             .filter(|&(_, v)| !(self.unify_fieldless_variants && v.data.fields().is_empty()))\n             .map(|(index, variant)| {\n-                let mk_selflike_pat = |cx: &mut ExtCtxt<'_>, selflike_arg_name: &str| {\n-                    let (p, idents) = trait_.create_enum_variant_pattern(\n-                        cx,\n-                        type_ident,\n-                        variant,\n-                        selflike_arg_name,\n-                        ast::Mutability::Not,\n-                    );\n-                    (cx.pat(span, PatKind::Ref(p, ast::Mutability::Not)), idents)\n-                };\n-\n                 // A single arm has form (&VariantK, &VariantK, ...) => BodyK\n                 // (see \"Final wrinkle\" note below for why.)\n-                let mut subpats = Vec::with_capacity(selflike_arg_names.len());\n-                let mut selflike_pats_idents = Vec::with_capacity(selflike_arg_names.len() - 1);\n-                let first_selflike_pat_idents = {\n-                    let (p, idents) = mk_selflike_pat(cx, &selflike_arg_names[0]);\n-                    subpats.push(p);\n-                    idents\n-                };\n-                for selflike_arg_name in &selflike_arg_names[1..] {\n-                    let (p, idents) = mk_selflike_pat(cx, &selflike_arg_name);\n-                    subpats.push(p);\n-                    selflike_pats_idents.push(idents);\n-                }\n+\n+                let use_temporaries = false; // enums can't be repr(packed)\n+                let fields = trait_.create_struct_pattern_fields(\n+                    cx,\n+                    &variant.data,\n+                    &prefixes,\n+                    use_temporaries,\n+                );\n+\n+                let sp = variant.span.with_ctxt(trait_.span.ctxt());\n+                let variant_path = cx.path(sp, vec![type_ident, variant.ident]);\n+                let mut subpats: Vec<_> = trait_\n+                    .create_struct_patterns(\n+                        cx,\n+                        variant_path,\n+                        &variant.data,\n+                        &prefixes,\n+                        ast::Mutability::Not,\n+                        use_temporaries,\n+                    )\n+                    .into_iter()\n+                    .map(|p| cx.pat(span, PatKind::Ref(p, ast::Mutability::Not)))\n+                    .collect();\n \n                 // Here is the pat = `(&VariantK, &VariantK, ...)`\n                 let single_pat = if subpats.len() == 1 {\n@@ -1267,54 +1241,12 @@ impl<'a> MethodDef<'a> {\n                 // For the BodyK, we need to delegate to our caller,\n                 // passing it an EnumMatching to indicate which case\n                 // we are in.\n-\n-                // All of the Self args have the same variant in these\n-                // cases. So we transpose the info in selflike_pats_idents\n-                // to gather the getter expressions together, in the\n-                // form that EnumMatching expects.\n-\n-                // The transposition is driven by walking across the\n-                // arg fields of the variant for the first selflike pat.\n-                let field_tuples = first_selflike_pat_idents\n-                    .into_iter()\n-                    .enumerate()\n-                    // For each arg field of self, pull out its getter expr ...\n-                    .map(|(field_index, (span, opt_ident, self_getter_expr))| {\n-                        // ... but FieldInfo also wants getter expr\n-                        // for matching other arguments of Self type;\n-                        // so walk across the *other* selflike_pats_idents\n-                        // and pull out getter for same field in each\n-                        // of them (using `field_index` tracked above).\n-                        // That is the heart of the transposition.\n-                        let other_selflike_exprs = selflike_pats_idents\n-                            .iter()\n-                            .map(|fields| {\n-                                let (_, _opt_ident, ref other_getter_expr) = fields[field_index];\n-\n-                                // All Self args have same variant, so\n-                                // opt_idents are the same.  (Assert\n-                                // here to make it self-evident that\n-                                // it is okay to ignore `_opt_ident`.)\n-                                assert!(opt_ident == _opt_ident);\n-\n-                                other_getter_expr.clone()\n-                            })\n-                            .collect::<Vec<P<Expr>>>();\n-\n-                        FieldInfo {\n-                            span,\n-                            name: opt_ident,\n-                            self_expr: self_getter_expr,\n-                            other_selflike_exprs,\n-                        }\n-                    })\n-                    .collect::<Vec<FieldInfo>>();\n-\n+                //\n                 // Now, for some given VariantK, we have built up\n                 // expressions for referencing every field of every\n                 // Self arg, assuming all are instances of VariantK.\n                 // Build up code associated with such a case.\n-                let substructure = EnumMatching(index, variants.len(), variant, field_tuples);\n+                let substructure = EnumMatching(index, variants.len(), variant, fields);\n                 let arm_expr = self\n                     .call_substructure_method(\n                         cx,\n@@ -1566,119 +1498,152 @@ impl<'a> TraitDef<'a> {\n         }\n     }\n \n-    fn create_subpatterns(\n+    fn create_struct_patterns(\n         &self,\n         cx: &mut ExtCtxt<'_>,\n-        field_paths: Vec<Ident>,\n+        struct_path: ast::Path,\n+        struct_def: &'a VariantData,\n+        prefixes: &[String],\n         mutbl: ast::Mutability,\n         use_temporaries: bool,\n     ) -> Vec<P<ast::Pat>> {\n-        field_paths\n+        prefixes\n             .iter()\n-            .map(|path| {\n-                let binding_mode = if use_temporaries {\n-                    ast::BindingMode::ByValue(ast::Mutability::Not)\n-                } else {\n-                    ast::BindingMode::ByRef(mutbl)\n-                };\n-                cx.pat(path.span, PatKind::Ident(binding_mode, *path, None))\n+            .map(|prefix| {\n+                let pieces: Vec<_> = struct_def\n+                    .fields()\n+                    .iter()\n+                    .enumerate()\n+                    .map(|(i, struct_field)| {\n+                        let sp = struct_field.span.with_ctxt(self.span.ctxt());\n+                        let binding_mode = if use_temporaries {\n+                            ast::BindingMode::ByValue(ast::Mutability::Not)\n+                        } else {\n+                            ast::BindingMode::ByRef(mutbl)\n+                        };\n+                        let ident = self.mk_pattern_ident(prefix, i);\n+                        let path = ident.with_span_pos(sp);\n+                        (\n+                            sp,\n+                            struct_field.ident,\n+                            cx.pat(path.span, PatKind::Ident(binding_mode, path, None)),\n+                        )\n+                    })\n+                    .collect();\n+\n+                let struct_path = struct_path.clone();\n+                match *struct_def {\n+                    VariantData::Struct(..) => {\n+                        let field_pats = pieces\n+                            .into_iter()\n+                            .map(|(sp, ident, pat)| {\n+                                if ident.is_none() {\n+                                    cx.span_bug(\n+                                        sp,\n+                                        \"a braced struct with unnamed fields in `derive`\",\n+                                    );\n+                                }\n+                                ast::PatField {\n+                                    ident: ident.unwrap(),\n+                                    is_shorthand: false,\n+                                    attrs: ast::AttrVec::new(),\n+                                    id: ast::DUMMY_NODE_ID,\n+                                    span: pat.span.with_ctxt(self.span.ctxt()),\n+                                    pat,\n+                                    is_placeholder: false,\n+                                }\n+                            })\n+                            .collect();\n+                        cx.pat_struct(self.span, struct_path, field_pats)\n+                    }\n+                    VariantData::Tuple(..) => {\n+                        let subpats = pieces.into_iter().map(|(_, _, subpat)| subpat).collect();\n+                        cx.pat_tuple_struct(self.span, struct_path, subpats)\n+                    }\n+                    VariantData::Unit(..) => cx.pat_path(self.span, struct_path),\n+                }\n             })\n             .collect()\n     }\n \n-    fn create_struct_pattern(\n-        &self,\n-        cx: &mut ExtCtxt<'_>,\n-        struct_path: ast::Path,\n-        struct_def: &'a VariantData,\n-        prefix: &str,\n-        mutbl: ast::Mutability,\n-        use_temporaries: bool,\n-    ) -> (P<ast::Pat>, Vec<(Span, Option<Ident>, P<Expr>)>) {\n-        let mut paths = Vec::new();\n-        let mut ident_exprs = Vec::new();\n-        for (i, struct_field) in struct_def.fields().iter().enumerate() {\n-            let sp = struct_field.span.with_ctxt(self.span.ctxt());\n-            let ident = Ident::from_str_and_span(&format!(\"{}_{}\", prefix, i), self.span);\n-            paths.push(ident.with_span_pos(sp));\n-            let val = cx.expr_path(cx.path_ident(sp, ident));\n-            let val = if use_temporaries { val } else { cx.expr_deref(sp, val) };\n-            ident_exprs.push((sp, struct_field.ident, val));\n-        }\n-\n-        let subpats = self.create_subpatterns(cx, paths, mutbl, use_temporaries);\n-        let pattern = match *struct_def {\n-            VariantData::Struct(..) => {\n-                let field_pats = iter::zip(subpats, &ident_exprs)\n-                    .map(|(pat, &(sp, ident, ..))| {\n-                        if ident.is_none() {\n-                            cx.span_bug(sp, \"a braced struct with unnamed fields in `derive`\");\n-                        }\n-                        ast::PatField {\n-                            ident: ident.unwrap(),\n-                            is_shorthand: false,\n-                            attrs: ast::AttrVec::new(),\n-                            id: ast::DUMMY_NODE_ID,\n-                            span: pat.span.with_ctxt(self.span.ctxt()),\n-                            pat,\n-                            is_placeholder: false,\n-                        }\n-                    })\n-                    .collect();\n-                cx.pat_struct(self.span, struct_path, field_pats)\n-            }\n-            VariantData::Tuple(..) => cx.pat_tuple_struct(self.span, struct_path, subpats),\n-            VariantData::Unit(..) => cx.pat_path(self.span, struct_path),\n-        };\n+    fn create_fields<F>(&self, struct_def: &'a VariantData, mk_exprs: F) -> Vec<FieldInfo>\n+    where\n+        F: Fn(usize, &ast::FieldDef, Span) -> Vec<P<ast::Expr>>,\n+    {\n+        struct_def\n+            .fields()\n+            .iter()\n+            .enumerate()\n+            .map(|(i, struct_field)| {\n+                // For this field, get an expr for each selflike_arg. E.g. for\n+                // `PartialEq::eq`, one for each of `&self` and `other`.\n+                let sp = struct_field.span.with_ctxt(self.span.ctxt());\n+                let mut exprs: Vec<_> = mk_exprs(i, struct_field, sp);\n+                let self_expr = exprs.remove(0);\n+                let other_selflike_exprs = exprs;\n+                FieldInfo {\n+                    span: sp.with_ctxt(self.span.ctxt()),\n+                    name: struct_field.ident,\n+                    self_expr,\n+                    other_selflike_exprs,\n+                }\n+            })\n+            .collect()\n+    }\n \n-        (pattern, ident_exprs)\n+    fn mk_pattern_ident(&self, prefix: &str, i: usize) -> Ident {\n+        Ident::from_str_and_span(&format!(\"{}_{}\", prefix, i), self.span)\n     }\n \n-    fn create_struct_field_accesses(\n+    fn create_struct_pattern_fields(\n         &self,\n         cx: &mut ExtCtxt<'_>,\n-        mut selflike_arg: &P<Expr>,\n         struct_def: &'a VariantData,\n-    ) -> Vec<(Span, Option<Ident>, P<Expr>)> {\n-        let mut ident_exprs = Vec::new();\n-        for (i, struct_field) in struct_def.fields().iter().enumerate() {\n-            let sp = struct_field.span.with_ctxt(self.span.ctxt());\n-\n-            // We don't the need the deref, if there is one.\n-            if let ast::ExprKind::Unary(ast::UnOp::Deref, inner) = &selflike_arg.kind {\n-                selflike_arg = inner;\n-            }\n-\n-            // Note: we must use `struct_field.span` rather than `span` in the\n-            // `unwrap_or_else` case otherwise the hygiene is wrong and we get\n-            // \"field `0` of struct `Point` is private\" errors on tuple\n-            // structs.\n-            let val = cx.expr(\n-                sp,\n-                ast::ExprKind::Field(\n-                    selflike_arg.clone(),\n-                    struct_field.ident.unwrap_or_else(|| {\n-                        Ident::from_str_and_span(&i.to_string(), struct_field.span)\n-                    }),\n-                ),\n-            );\n-            ident_exprs.push((sp, struct_field.ident, val));\n-        }\n-        ident_exprs\n+        prefixes: &[String],\n+        use_temporaries: bool,\n+    ) -> Vec<FieldInfo> {\n+        self.create_fields(struct_def, |i, _struct_field, sp| {\n+            prefixes\n+                .iter()\n+                .map(|prefix| {\n+                    let ident = self.mk_pattern_ident(prefix, i);\n+                    let expr = cx.expr_path(cx.path_ident(sp, ident));\n+                    if use_temporaries { expr } else { cx.expr_deref(sp, expr) }\n+                })\n+                .collect()\n+        })\n     }\n \n-    fn create_enum_variant_pattern(\n+    fn create_struct_field_access_fields(\n         &self,\n         cx: &mut ExtCtxt<'_>,\n-        enum_ident: Ident,\n-        variant: &'a ast::Variant,\n-        prefix: &str,\n-        mutbl: ast::Mutability,\n-    ) -> (P<ast::Pat>, Vec<(Span, Option<Ident>, P<Expr>)>) {\n-        let sp = variant.span.with_ctxt(self.span.ctxt());\n-        let variant_path = cx.path(sp, vec![enum_ident, variant.ident]);\n-        let use_temporaries = false; // enums can't be repr(packed)\n-        self.create_struct_pattern(cx, variant_path, &variant.data, prefix, mutbl, use_temporaries)\n+        selflike_args: &[P<Expr>],\n+        struct_def: &'a VariantData,\n+    ) -> Vec<FieldInfo> {\n+        self.create_fields(struct_def, |i, struct_field, sp| {\n+            selflike_args\n+                .iter()\n+                .map(|mut selflike_arg| {\n+                    // We don't the need the deref, if there is one.\n+                    if let ast::ExprKind::Unary(ast::UnOp::Deref, inner) = &selflike_arg.kind {\n+                        selflike_arg = inner;\n+                    }\n+                    // Note: we must use `struct_field.span` rather than `span` in the\n+                    // `unwrap_or_else` case otherwise the hygiene is wrong and we get\n+                    // \"field `0` of struct `Point` is private\" errors on tuple\n+                    // structs.\n+                    cx.expr(\n+                        sp,\n+                        ast::ExprKind::Field(\n+                            selflike_arg.clone(),\n+                            struct_field.ident.unwrap_or_else(|| {\n+                                Ident::from_str_and_span(&i.to_string(), struct_field.span)\n+                            }),\n+                        ),\n+                    )\n+                })\n+                .collect()\n+        })\n     }\n }\n "}]}