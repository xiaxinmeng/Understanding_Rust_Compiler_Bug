{"sha": "381205b7473765c9e34162bc7e350d67f603d579", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4MTIwNWI3NDczNzY1YzllMzQxNjJiYzdlMzUwZDY3ZjYwM2Q1Nzk=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-09-28T19:07:33Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-09-28T19:46:29Z"}, "message": "Revert \"Revert \"Implement pattern ranges for all numeric types.\"\"\n\nThis reverts commit a034f87146e60e1db2327c6f6807c47406a1bb0b.\n\nConflicts:\n\n\tsrc/comp/middle/check_alt.rs\n\tsrc/comp/middle/trans_alt.rs\n\tsrc/comp/syntax/ast.rs\n\tsrc/comp/syntax/ast_util.rs\n\tsrc/comp/syntax/fold.rs\n\tsrc/comp/syntax/print/pprust.rs\n\nConflicts:\n\n\tsrc/comp/middle/trans_alt.rs", "tree": {"sha": "f58090e3d25f5e00d72972fbd0528e91b3c2b82f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f58090e3d25f5e00d72972fbd0528e91b3c2b82f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/381205b7473765c9e34162bc7e350d67f603d579", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/381205b7473765c9e34162bc7e350d67f603d579", "html_url": "https://github.com/rust-lang/rust/commit/381205b7473765c9e34162bc7e350d67f603d579", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/381205b7473765c9e34162bc7e350d67f603d579/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5fac684af87e2e9064bb561340a7fa7aadcb21ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/5fac684af87e2e9064bb561340a7fa7aadcb21ff", "html_url": "https://github.com/rust-lang/rust/commit/5fac684af87e2e9064bb561340a7fa7aadcb21ff"}], "stats": {"total": 481, "additions": 455, "deletions": 26}, "files": [{"sha": "03a060a57fd57235e67b5b6035fd4484523d4a3a", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/381205b7473765c9e34162bc7e350d67f603d579/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/381205b7473765c9e34162bc7e350d67f603d579/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=381205b7473765c9e34162bc7e350d67f603d579", "patch": "@@ -642,7 +642,7 @@ fn pattern_roots(tcx: ty::ctxt, mut: option::t<unsafe_ty>, pat: @ast::pat)\n     fn walk(tcx: ty::ctxt, mut: option::t<unsafe_ty>, pat: @ast::pat,\n             &set: [pattern_root]) {\n         alt pat.node {\n-          ast::pat_wild. | ast::pat_lit(_) {}\n+          ast::pat_wild. | ast::pat_lit(_) | ast::pat_range(_, _) {}\n           ast::pat_bind(nm) {\n             set += [{id: pat.id, name: nm, mut: mut, span: pat.span}];\n           }"}, {"sha": "236b040335886882c9d6ac698bd47e2e5e8787af", "filename": "src/comp/middle/check_alt.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/381205b7473765c9e34162bc7e350d67f603d579/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/381205b7473765c9e34162bc7e350d67f603d579/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs?ref=381205b7473765c9e34162bc7e350d67f603d579", "patch": "@@ -62,12 +62,15 @@ fn pattern_supersedes(tcx: ty::ctxt, a: @pat, b: @pat) -> bool {\n         ret true;\n     }\n \n-\n     alt a.node {\n       pat_wild. | pat_bind(_) { ret true; }\n       pat_lit(la) {\n         alt b.node {\n           pat_lit(lb) { ret util::common::lit_eq(la, lb); }\n+          pat_range(beginb, endb) {\n+            ret util::common::lit_type_eq(la, beginb) &&\n+                util::common::lit_in_range(la, beginb, endb);\n+          }\n           _ { ret false; }\n         }\n       }\n@@ -104,6 +107,19 @@ fn pattern_supersedes(tcx: ty::ctxt, a: @pat, b: @pat) -> bool {\n           _ { ret pattern_supersedes(tcx, suba, b); }\n         }\n       }\n+      pat_range(begina, enda) {\n+        alt b.node {\n+          pat_lit(lb) {\n+            ret util::common::lit_type_eq(lb, begina) &&\n+                util::common::lit_in_range(lb, begina, enda);\n+          }\n+          pat_range(beginb, endb) {\n+            ret util::common::lit_type_eq(begina, beginb) &&\n+                util::common::lit_ranges_overlap(begina, enda, beginb, endb);\n+          }\n+          _ { ret false; }\n+        }\n+      }\n     }\n }\n "}, {"sha": "175b8b9ec9b8f7aba378cc9d549b16687d912228", "filename": "src/comp/middle/trans_alt.rs", "status": "modified", "additions": 82, "deletions": 21, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/381205b7473765c9e34162bc7e350d67f603d579/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/381205b7473765c9e34162bc7e350d67f603d579/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs?ref=381205b7473765c9e34162bc7e350d67f603d579", "patch": "@@ -1,4 +1,4 @@\n-import std::{str, vec, option};\n+import std::{str, vec, option, int};\n import option::{some, none};\n import std::map::hashmap;\n \n@@ -16,22 +16,34 @@ import util::common::lit_eq;\n \n import trans_common::*;\n \n-// An option identifying a branch (either a literal or a tag variant)\n+// An option identifying a branch (either a literal, a tag variant or a range)\n tag opt {\n     lit(@ast::lit);\n     var(/* variant id */uint, /* variant dids */{tg: def_id, var: def_id});\n+    range(@ast::lit, @ast::lit);\n }\n fn opt_eq(a: opt, b: opt) -> bool {\n     alt a {\n       lit(la) {\n-        ret alt b { lit(lb) { lit_eq(la, lb) } var(_, _) { false } };\n+        ret alt b { lit(lb) { lit_eq(la, lb) } _ { false } };\n       }\n       var(ida, _) {\n-        ret alt b { lit(_) { false } var(idb, _) { ida == idb } };\n+        ret alt b { var(idb, _) { ida == idb } _ { false } };\n+      }\n+      range(la1, la2) {\n+        ret alt b {\n+          range(lb1, lb2) { lit_eq(la1, lb1) && lit_eq(la2, lb2) }\n+          _ { false }\n+        };\n       }\n     }\n }\n-fn trans_opt(bcx: @block_ctxt, o: opt) -> result {\n+\n+tag opt_result {\n+    single_result(result);\n+    range_result(result, result);\n+}\n+fn trans_opt(bcx: @block_ctxt, o: opt) -> opt_result {\n     alt o {\n       lit(l) {\n         alt l.node {\n@@ -40,14 +52,22 @@ fn trans_opt(bcx: @block_ctxt, o: opt) -> result {\n             let {bcx, val: dst} = trans::alloc_ty(bcx, strty);\n             bcx = trans_vec::trans_str(bcx, s, trans::save_in(dst));\n             add_clean_temp(bcx, dst, strty);\n-            ret rslt(bcx, dst);\n+            ret single_result(rslt(bcx, dst));\n           }\n           _ {\n-            ret rslt(bcx, trans::trans_crate_lit(bcx_ccx(bcx), *l));\n+            ret single_result(\n+                rslt(bcx, trans::trans_crate_lit(bcx_ccx(bcx), *l)));\n           }\n         }\n       }\n-      var(id, _) { ret rslt(bcx, C_int(id as int)); }\n+      var(id, _) { ret single_result(rslt(bcx, C_int(id as int))); }\n+      range(l1, l2) {\n+        let cell1 = trans::empty_dest_cell();\n+        let cell2 = trans::empty_dest_cell();\n+        let bcx = trans::trans_lit(bcx, *l1, trans::by_val(cell1));\n+        let bcx = trans::trans_lit(bcx, *l2, trans::by_val(cell2));\n+        ret range_result(rslt(bcx, *cell1), rslt(bcx, *cell2));\n+      }\n     }\n }\n \n@@ -137,6 +157,9 @@ fn enter_opt(ccx: @crate_ctxt, m: match, opt: opt, col: uint, tag_size: uint,\n           ast::pat_lit(l) {\n             ret if opt_eq(lit(l), opt) { some([]) } else { none };\n           }\n+          ast::pat_range(l1, l2) {\n+            ret if opt_eq(range(l1, l2), opt) { some([]) } else { none };\n+          }\n           _ { ret some(vec::init_elt(dummy, size)); }\n         }\n     }\n@@ -210,6 +233,9 @@ fn get_options(ccx: @crate_ctxt, m: match, col: uint) -> [opt] {\n     for br: match_branch in m {\n         alt br.pats[col].node {\n           ast::pat_lit(l) { add_to_set(found, lit(l)); }\n+          ast::pat_range(l1, l2) {\n+            add_to_set(found, range(l1, l2));\n+          }\n           ast::pat_tag(_, _) {\n             add_to_set(found, variant_opt(ccx, br.pats[col].id));\n           }\n@@ -296,7 +322,9 @@ fn pick_col(m: match) -> uint {\n         let i = 0u;\n         for p: @ast::pat in br.pats {\n             alt p.node {\n-              ast::pat_lit(_) | ast::pat_tag(_, _) { scores[i] += 1u; }\n+              ast::pat_lit(_) | ast::pat_tag(_, _) | ast::pat_range(_, _) {\n+                scores[i] += 1u;\n+              }\n               _ { }\n             }\n             i += 1u;\n@@ -450,6 +478,16 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n               _ { test_val = Load(bcx, val); switch }\n             };\n           }\n+          range(_, _) {\n+            test_val = Load(bcx, val);\n+            kind = compare;\n+          }\n+        }\n+    }\n+    for o: opt in opts {\n+        alt o {\n+          range(_, _) { kind = compare; break; }\n+          _ { }\n         }\n     }\n     let else_cx =\n@@ -473,22 +511,44 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n         alt kind {\n           single. { Br(bcx, opt_cx.llbb); }\n           switch. {\n-            let r = trans_opt(bcx, opt);\n-            bcx = r.bcx;\n-            AddCase(sw, r.val, opt_cx.llbb);\n+            let res = trans_opt(bcx, opt);\n+            alt res {\n+              single_result(r) {\n+                llvm::LLVMAddCase(sw, r.val, opt_cx.llbb);\n+                bcx = r.bcx;\n+              }\n+            }\n           }\n           compare. {\n             let compare_cx = new_scope_block_ctxt(bcx, \"compare_scope\");\n             Br(bcx, compare_cx.llbb);\n             bcx = compare_cx;\n-            let r = trans_opt(bcx, opt);\n-            bcx = r.bcx;\n             let t = ty::node_id_to_type(ccx.tcx, pat_id);\n-            let eq =\n-                trans::trans_compare(bcx, ast::eq, test_val, t, r.val, t);\n-            let cleanup_cx = trans::trans_block_cleanups(eq.bcx, compare_cx);\n-            bcx = new_sub_block_ctxt(bcx, \"compare_next\");\n-            CondBr(cleanup_cx, eq.val, opt_cx.llbb, bcx.llbb);\n+            let res = trans_opt(bcx, opt);\n+            alt res {\n+              single_result(r) {\n+                bcx = r.bcx;\n+                let eq =\n+                    trans::trans_compare(bcx, ast::eq, test_val, t, r.val, t);\n+                let cleanup_cx = trans::trans_block_cleanups(\n+                    eq.bcx, compare_cx);\n+                bcx = new_sub_block_ctxt(bcx, \"compare_next\");\n+                CondBr(cleanup_cx, eq.val, opt_cx.llbb, bcx.llbb);\n+              }\n+              range_result(rbegin, rend) {\n+                bcx = rend.bcx;\n+                let ge = trans::trans_compare(bcx, ast::ge, test_val, t,\n+                                              rbegin.val, t);\n+                let le = trans::trans_compare(ge.bcx, ast::le, test_val, t,\n+                                              rend.val, t);\n+                let in_range = rslt(le.bcx, And(le.bcx, ge.val, le.val));\n+                /*let*/ bcx = in_range.bcx; //XXX uncomment for assertion\n+                let cleanup_cx =\n+                    trans::trans_block_cleanups(bcx, compare_cx);\n+                bcx = new_sub_block_ctxt(bcx, \"compare_next\");\n+                CondBr(cleanup_cx, in_range.val, opt_cx.llbb, bcx.llbb);\n+              }\n+            }\n           }\n           _ { }\n         }\n@@ -501,7 +561,7 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n             unpacked = args.vals;\n             opt_cx = args.bcx;\n           }\n-          lit(_) { }\n+          lit(_) | range(_, _) { }\n         }\n         compile_submatch(opt_cx, enter_opt(ccx, m, opt, col, size, val),\n                          unpacked + vals_left, f, exits);\n@@ -673,12 +733,13 @@ fn bind_irrefutable_pat(bcx: @block_ctxt, pat: @ast::pat, val: ValueRef,\n         let val = Load(bcx, val);\n         bcx = bind_irrefutable_pat(bcx, inner, val, table, true);\n       }\n-      ast::pat_wild. | ast::pat_lit(_) { }\n+      ast::pat_wild. | ast::pat_lit(_) | ast::pat_range(_, _) { }\n     }\n     ret bcx;\n }\n \n // Local Variables:\n+// mode: rust\n // fill-column: 78;\n // indent-tabs-mode: nil\n // c-basic-offset: 4"}, {"sha": "bdf8b91c8ff70f3afaad04c0f867821b44620766", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/381205b7473765c9e34162bc7e350d67f603d579/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/381205b7473765c9e34162bc7e350d67f603d579/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=381205b7473765c9e34162bc7e350d67f603d579", "patch": "@@ -1266,6 +1266,44 @@ fn check_lit(ccx: @crate_ctxt, lit: @ast::lit) -> ty::t {\n     }\n }\n \n+fn lit_as_uint(l: @ast::lit) -> uint {\n+    alt l.node {\n+      ast::lit_uint(u) { u }\n+      ast::lit_char(c) { c as uint }\n+    }\n+}\n+fn lit_as_int(l: @ast::lit) -> int {\n+    alt l.node {\n+      ast::lit_int(i) | ast::lit_mach_int(_, i) { i }\n+    }\n+}\n+fn lit_as_float(l: @ast::lit) -> str {\n+    alt l.node {\n+      ast::lit_float(f) | ast::lit_mach_float(_, f) { f }\n+    }\n+}\n+\n+fn valid_range_bounds(l1: @ast::lit, l2: @ast::lit) -> bool {\n+    alt l1.node {\n+      ast::lit_float(s1) | ast::lit_mach_float(_, s1) {\n+        let s2 = lit_as_float(l2);\n+        let f1 = util::common::str_to_float(s1);\n+        let f2 = util::common::str_to_float(s2);\n+        ret *util::common::min(f1, f2) == f1\n+      }\n+      ast::lit_uint(_) | ast::lit_char(_) {\n+        let u1 = lit_as_uint(l1);\n+        let u2 = lit_as_uint(l2);\n+        ret *util::common::min(u1, u2) == u1\n+      }\n+      _ {\n+        let i1 = lit_as_int(l1);\n+        let i2 = lit_as_int(l2);\n+        ret *util::common::min(i1, i2) == i1\n+      }\n+    }\n+}\n+\n // Pattern checking is top-down rather than bottom-up so that bindings get\n // their types immediately.\n fn check_pat(fcx: @fn_ctxt, map: ast_util::pat_id_map, pat: @ast::pat,\n@@ -1277,6 +1315,23 @@ fn check_pat(fcx: @fn_ctxt, map: ast_util::pat_id_map, pat: @ast::pat,\n         typ = demand::simple(fcx, pat.span, expected, typ);\n         write::ty_only_fixup(fcx, pat.id, typ);\n       }\n+      ast::pat_range(begin, end) {\n+        if !util::common::lit_is_numeric(begin) ||\n+           !util::common::lit_is_numeric(end) {\n+            fcx.ccx.tcx.sess.span_err(pat.span,\n+                                      \"non-numeric type used in range\");\n+        } else if !valid_range_bounds(begin, end) {\n+            fcx.ccx.tcx.sess.span_err(begin.span,\n+                                      \"lower range bound must be less \\\n+                                       than upper\");\n+        }\n+        let typ1 = check_lit(fcx.ccx, begin);\n+        typ1 = demand::simple(fcx, pat.span, expected, typ1);\n+        write::ty_only_fixup(fcx, pat.id, typ1);\n+        let typ2 = check_lit(fcx.ccx, end);\n+        typ2 = demand::simple(fcx, pat.span, typ1, typ2);\n+        write::ty_only_fixup(fcx, pat.id, typ2);\n+      }\n       ast::pat_bind(name) {\n         let vid = lookup_local(fcx, pat.span, pat.id);\n         let typ = ty::mk_var(fcx.ccx.tcx, vid);"}, {"sha": "6dced2bf32a6ed9d1f20d080c6af2c2c0406b445", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/381205b7473765c9e34162bc7e350d67f603d579/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/381205b7473765c9e34162bc7e350d67f603d579/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=381205b7473765c9e34162bc7e350d67f603d579", "patch": "@@ -93,6 +93,7 @@ tag pat_ {\n     pat_tup([@pat]);\n     pat_box(@pat);\n     pat_uniq(@pat);\n+    pat_range(@lit, @lit);\n }\n \n tag mutability { mut; imm; maybe_mut; }"}, {"sha": "c4d0272b95fa10d5e800971b54aacf51770b647b", "filename": "src/comp/syntax/ast_util.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/381205b7473765c9e34162bc7e350d67f603d579/src%2Fcomp%2Fsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/381205b7473765c9e34162bc7e350d67f603d579/src%2Fcomp%2Fsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast_util.rs?ref=381205b7473765c9e34162bc7e350d67f603d579", "patch": "@@ -70,7 +70,7 @@ iter pat_bindings(pat: @pat) -> @pat {\n       }\n       pat_box(sub) { for each b in pat_bindings(sub) { put b; } }\n       pat_uniq(sub) { for each b in pat_bindings(sub) { put b; } }\n-      pat_wild. | pat_lit(_) { }\n+      pat_wild. | pat_lit(_) | pat_range(_, _) { }\n     }\n }\n \n@@ -230,3 +230,4 @@ fn ret_by_ref(style: ret_style) -> bool {\n // buffer-file-coding-system: utf-8-unix\n // compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n // End:\n+"}, {"sha": "bf8504f3c1aa52283385f984790020061bafcd3a", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/381205b7473765c9e34162bc7e350d67f603d579/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/381205b7473765c9e34162bc7e350d67f603d579/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=381205b7473765c9e34162bc7e350d67f603d579", "patch": "@@ -292,6 +292,7 @@ fn noop_fold_pat(p: pat_, fld: ast_fold) -> pat_ {\n           pat_tup(elts) { pat_tup(vec::map(fld.fold_pat, elts)) }\n           pat_box(inner) { pat_box(fld.fold_pat(inner)) }\n           pat_uniq(inner) { pat_uniq(fld.fold_pat(inner)) }\n+          pat_range(_, _) { p }\n         };\n }\n "}, {"sha": "b2a89a43ec53d4f9f48ed147ed4fbf33a85285f1", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/381205b7473765c9e34162bc7e350d67f603d579/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/381205b7473765c9e34162bc7e350d67f603d579/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=381205b7473765c9e34162bc7e350d67f603d579", "patch": "@@ -1494,8 +1494,14 @@ fn parse_pat(p: parser) -> @ast::pat {\n       tok {\n         if !is_ident(tok) || is_word(p, \"true\") || is_word(p, \"false\") {\n             let lit = parse_lit(p);\n-            hi = lit.span.hi;\n-            pat = ast::pat_lit(@lit);\n+            if eat_word(p, \"to\") {\n+                let end = parse_lit(p);\n+                hi = end.span.hi;\n+                pat = ast::pat_range(@lit, @end);\n+            } else {\n+                hi = lit.span.hi;\n+                pat = ast::pat_lit(@lit);\n+            }\n         } else if is_plain_ident(p) &&\n                       alt p.look_ahead(1u) {\n                         token::DOT. | token::LPAREN. | token::LBRACKET. {"}, {"sha": "458af7e9b12ee12bf9242b4863b182cac63cbfb3", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/381205b7473765c9e34162bc7e350d67f603d579/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/381205b7473765c9e34162bc7e350d67f603d579/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=381205b7473765c9e34162bc7e350d67f603d579", "patch": "@@ -1114,6 +1114,12 @@ fn print_pat(s: ps, pat: @ast::pat) {\n       }\n       ast::pat_box(inner) { word(s.s, \"@\"); print_pat(s, inner); }\n       ast::pat_uniq(inner) { word(s.s, \"~\"); print_pat(s, inner); }\n+      ast::pat_range(begin, end) {\n+        print_literal(s, begin);\n+        space(s.s);\n+        word_space(s, \"to\");\n+        print_literal(s, end);\n+      }\n     }\n     s.ann.post(ann_node);\n }"}, {"sha": "6966cafbe048caecb519b353a8da68dcc852d288", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/381205b7473765c9e34162bc7e350d67f603d579/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/381205b7473765c9e34162bc7e350d67f603d579/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=381205b7473765c9e34162bc7e350d67f603d579", "patch": "@@ -84,6 +84,162 @@ fn local_rhs_span(l: @ast::local, def: span) -> span {\n     alt l.node.init { some(i) { ret i.expr.span; } _ { ret def; } }\n }\n \n+fn lit_is_numeric(l: @ast::lit) -> bool {\n+    alt l.node {\n+      ast::lit_int(_) | ast::lit_char(_) | ast::lit_uint(_) |\n+      ast::lit_mach_int(_, _) | ast::lit_float(_) | ast::lit_mach_float(_,_) {\n+        true\n+      }\n+      _ { false }\n+    }\n+}\n+\n+fn lit_type_eq(l: @ast::lit, m: @ast::lit) -> bool {\n+    alt l.node {\n+      ast::lit_str(_) {\n+        alt m.node { ast::lit_str(_) { true } _ { false } }\n+      }\n+      ast::lit_char(_) {\n+        alt m.node { ast::lit_char(_) { true } _ { false } }\n+      }\n+      ast::lit_int(_) {\n+        alt m.node { ast::lit_int(_) { true } _ { false } }\n+      }\n+      ast::lit_uint(_) {\n+        alt m.node { ast::lit_uint(_) { true } _ { false } }\n+      }\n+      ast::lit_mach_int(_, _) {\n+        alt m.node { ast::lit_mach_int(_, _) { true } _ { false } }\n+      }\n+      ast::lit_float(_) {\n+        alt m.node { ast::lit_float(_) { true } _ { false } }\n+      }\n+      ast::lit_mach_float(_, _) {\n+        alt m.node { ast::lit_mach_float(_, _) { true } _ { false } }\n+      }\n+      ast::lit_nil. {\n+        alt m.node { ast::lit_nil. { true } _ { false } }\n+      }\n+      ast::lit_bool(_) {\n+        alt m.node { ast::lit_bool(_) { true } _ { false } }\n+      }\n+    }\n+}\n+\n+fn lit_in_range(l: @ast::lit, m1: @ast::lit, m2: @ast::lit) -> bool {\n+    alt lits_to_range(m1, m2) {\n+      irange(i1, i2) {\n+        alt l.node {\n+          ast::lit_int(i3) | ast::lit_mach_int(_, i3) {\n+            i3 >= *min(i1, i2) && i3 <= *max(i1, i2)\n+          }\n+          _ { fail }\n+        }\n+      }\n+      urange(u1, u2) {\n+        alt l.node {\n+          ast::lit_uint(u3) {\n+            u3 >= *min(u1, u2) && u3 <= *max(u1, u2)\n+          }\n+          _ { fail }\n+        }\n+      }\n+      crange(c1, c2) {\n+        alt l.node {\n+          ast::lit_char(c3) {\n+            (c3 as uint) >= *min(c1 as uint, c2 as uint) &&\n+            (c3 as uint) <= *max(c1 as uint, c2 as uint)\n+          }\n+          _ { fail }\n+        }\n+      }\n+      frange(f1, f2) {\n+        alt l.node {\n+          ast::lit_float(f3) | ast::lit_mach_float(_, f3) {\n+            str_to_float(f3) >= *min(f1, f2) &&\n+            str_to_float(f3) <= *max(f1, f2)\n+          }\n+          _ { fail }\n+        }\n+      }\n+    }\n+}\n+\n+fn min<@T>(x: T, y: T) -> @T {\n+    ret @(if x > y { y } else { x });\n+}\n+\n+fn max<@T>(x: T, y: T) -> @T {\n+    ret @(if x > y { x } else { y });\n+}\n+\n+fn ranges_overlap<@T>(a1: T, a2: T, b1: T, b2: T) -> bool {\n+    let min1 = *min(a1, a2);\n+    let max1 = *max(a1, a2);\n+    let min2 = *min(b1, b2);\n+    let max2 = *max(b1, b2);\n+    ret (min1 >= min2 && max1 <= max2) || (min1 <= min2 && max1 >= min2) ||\n+        (min1 >= min2 && min1 <= max2) || (max1 >= min2 && max1 <= max2);\n+}\n+\n+fn lit_ranges_overlap(a1: @ast::lit, a2: @ast::lit,\n+                      b1: @ast::lit, b2: @ast::lit) -> bool {\n+    alt lits_to_range(a1, a2) {\n+      irange(i1, i2) {\n+        alt lits_to_range(b1, b2) {\n+          irange(i3, i4) { ranges_overlap(i1, i2, i3, i4) }\n+          _ { fail }\n+        }\n+      }\n+      urange(u1, u2) {\n+        alt lits_to_range(b1, b2) {\n+          urange(u3, u4) { ranges_overlap(u1, u2, u3, u4) }\n+          _ { fail }\n+        }\n+      }\n+      crange(c1, c2) {\n+        alt lits_to_range(b1, b2) {\n+          crange(c3, c4) { ranges_overlap(c1, c2, c3, c4) }\n+          _ { fail }\n+        }\n+      }\n+      frange(f1, f2) {\n+        alt lits_to_range(b1, b2) {\n+          frange(f3, f4) { ranges_overlap(f1, f2, f3, f4) }\n+          _ { fail }\n+        }\n+      }\n+    }\n+}\n+\n+tag range {\n+    irange(int, int);\n+    urange(uint, uint);\n+    crange(char, char);\n+    frange(float, float);\n+}\n+\n+fn lits_to_range(l: @ast::lit, r: @ast::lit) -> range {\n+    alt l.node {\n+      ast::lit_int(i1) | ast::lit_mach_int(_, i1) {\n+        alt r.node { ast::lit_int(i2) { irange(i1, i2) } _ { fail } }\n+      }\n+      ast::lit_uint(u1) {\n+        alt r.node { ast::lit_uint(u2) { urange(u1, u2) } _ { fail } }\n+      }\n+      ast::lit_char(c1) {\n+        alt r.node { ast::lit_char(c2) { crange(c1, c2) } _ { fail } }\n+      }\n+      ast::lit_float(f1) | ast::lit_mach_float(_, f1) {\n+        alt r.node { ast::lit_float(f2) | ast::lit_mach_float(_, f2) {\n+          frange(str_to_float(f1), str_to_float(f2))\n+        }\n+        _ { fail } }\n+      }\n+      _ { fail }\n+    }\n+}\n+\n fn lit_eq(l: @ast::lit, m: @ast::lit) -> bool {\n     alt l.node {\n       ast::lit_str(s) {\n@@ -156,6 +312,22 @@ fn float_to_str(num: float, digits: uint) -> str {\n     ret accum;\n }\n \n+fn str_to_float(num: str) -> float {\n+    let digits = str::split(num, '.' as u8);\n+    let total = int::from_str(digits[0]) as float;\n+\n+    fn dec_val(c: char) -> int { ret (c as int) - ('0' as int); }\n+\n+    let right = digits[1];\n+    let len = str::char_len(digits[1]);\n+    let i = 1u;\n+    while (i < len) {\n+        total += dec_val(str::pop_char(right)) as float /\n+                 (int::pow(10, i) as float);\n+        i += 1u;\n+    }\n+    ret total;\n+}\n \n //\n // Local Variables:"}, {"sha": "0a6e69ceadc7e3ad32280c057e61fdf08b1e711f", "filename": "src/lib/int.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/381205b7473765c9e34162bc7e350d67f603d579/src%2Flib%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/381205b7473765c9e34162bc7e350d67f603d579/src%2Flib%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fint.rs?ref=381205b7473765c9e34162bc7e350d67f603d579", "patch": "@@ -41,6 +41,29 @@ iter range(lo: int, hi: int) -> int {\n     while lo_ < hi { put lo_; lo_ += 1; }\n }\n \n+fn parse_buf(buf: [u8], radix: uint) -> int {\n+    if vec::len::<u8>(buf) == 0u {\n+        log_err \"parse_buf(): buf is empty\";\n+        fail;\n+    }\n+    let i = vec::len::<u8>(buf) - 1u;\n+    let power = 1;\n+    if buf[0] == ('-' as u8) {\n+        power = -1;\n+        i -= 1u;\n+    }\n+    let n = 0;\n+    while true {\n+        n += (buf[i] - ('0' as u8) as int) * power;\n+        power *= radix as int;\n+        if i == 0u { ret n; }\n+        i -= 1u;\n+    }\n+    fail;\n+}\n+\n+fn from_str(s: str) -> int { parse_buf(str::bytes(s), 10u) }\n+\n fn to_str(n: int, radix: uint) -> str {\n     assert (0u < radix && radix <= 16u);\n     ret if n < 0 {"}, {"sha": "51883e8f8ddbafe01c042d3b0843398392c733f5", "filename": "src/test/compile-fail/alt-range-fail-dominate.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/381205b7473765c9e34162bc7e350d67f603d579/src%2Ftest%2Fcompile-fail%2Falt-range-fail-dominate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/381205b7473765c9e34162bc7e350d67f603d579/src%2Ftest%2Fcompile-fail%2Falt-range-fail-dominate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Falt-range-fail-dominate.rs?ref=381205b7473765c9e34162bc7e350d67f603d579", "patch": "@@ -0,0 +1,38 @@\n+//error-pattern: unreachable\n+//error-pattern: unreachable\n+//error-pattern: unreachable\n+//error-pattern: unreachable\n+//error-pattern: unreachable\n+//error-pattern: unreachable\n+\n+fn main() {\n+    alt 5u {\n+      1u to 10u { }\n+      5u to 6u { }\n+    };\n+\n+    alt 5u {\n+      4u to 6u { }\n+      3u to 5u { }\n+    };\n+\n+    alt 5u {\n+      4u to 6u { }\n+      5u to 7u { }\n+    };\n+\n+    alt 'c' {\n+      'A' to 'z' {}\n+      'a' to 'z' {}\n+    };\n+\n+    alt 1.0 {\n+      -5.0 to 5.0 {}\n+      0.0 to 6.5 {}\n+    };\n+\n+    alt 1.0 {\n+      0.02 {}\n+      0.01 to 6.5 {}\n+    };\n+}\n\\ No newline at end of file"}, {"sha": "0a9acdcd4b98b63b86352d4ecdd8b95abe8ead36", "filename": "src/test/compile-fail/alt-range-fail.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/381205b7473765c9e34162bc7e350d67f603d579/src%2Ftest%2Fcompile-fail%2Falt-range-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/381205b7473765c9e34162bc7e350d67f603d579/src%2Ftest%2Fcompile-fail%2Falt-range-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Falt-range-fail.rs?ref=381205b7473765c9e34162bc7e350d67f603d579", "patch": "@@ -0,0 +1,19 @@\n+//error-pattern: lower range bound\n+//error-pattern: non-numeric\n+//error-pattern: mismatched types\n+\n+fn main() {\n+    alt 5u {\n+      6u to 1u { }\n+      _ { }\n+    };\n+\n+    alt \"wow\" {\n+      \"wow\" to \"woow\" { }\n+    };\n+\n+    alt 5u {\n+      'c' to 100u { }\n+      _ { }\n+    };\n+}\n\\ No newline at end of file"}, {"sha": "1cd29cb35177bb978e94fb0f8a649ecd6115881c", "filename": "src/test/run-pass/alt-range.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/381205b7473765c9e34162bc7e350d67f603d579/src%2Ftest%2Frun-pass%2Falt-range.rs", "raw_url": "https://github.com/rust-lang/rust/raw/381205b7473765c9e34162bc7e350d67f603d579/src%2Ftest%2Frun-pass%2Falt-range.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-range.rs?ref=381205b7473765c9e34162bc7e350d67f603d579", "patch": "@@ -0,0 +1,30 @@\n+fn main() {\n+    alt 5u {\n+      1u to 5u {}\n+      _ { fail \"should match range\"; }\n+    }\n+    alt 5u {\n+      6u to 7u { fail \"shouldn't match range\"; }\n+      _ {}\n+    }\n+    alt 5u {\n+      1u { fail \"should match non-first range\"; }\n+      2u to 6u {}\n+    }\n+    alt 'c' {\n+      'a' to 'z' {}\n+      _ { fail \"should suppport char ranges\"; }\n+    }\n+    alt -3 {\n+      -7 to 5 {}\n+      _ { fail \"should match signed range\"; }\n+    }\n+    alt 3.0 {\n+      1.0 to 5.0 {}\n+      _ { fail \"should match float range\"; }\n+    }\n+    alt -1.5 {\n+      -3.6 to 3.6 {}\n+      _ { fail \"should match negative float range\"; }\n+    }\n+}"}]}