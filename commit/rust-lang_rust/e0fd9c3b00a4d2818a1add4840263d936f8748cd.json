{"sha": "e0fd9c3b00a4d2818a1add4840263d936f8748cd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwZmQ5YzNiMDBhNGQyODE4YTFhZGQ0ODQwMjYzZDkzNmY4NzQ4Y2Q=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2016-01-25T13:17:31Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2016-01-25T13:17:31Z"}, "message": "remove implicator\n\nit is pre-RFC1214 junk", "tree": {"sha": "d3c694c5a3a451a6983d0e332c8b48bb7bebb79d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d3c694c5a3a451a6983d0e332c8b48bb7bebb79d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e0fd9c3b00a4d2818a1add4840263d936f8748cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e0fd9c3b00a4d2818a1add4840263d936f8748cd", "html_url": "https://github.com/rust-lang/rust/commit/e0fd9c3b00a4d2818a1add4840263d936f8748cd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e0fd9c3b00a4d2818a1add4840263d936f8748cd/comments", "author": null, "committer": null, "parents": [{"sha": "0486e12ad0661adcfdbd926dea17d7edfda419c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/0486e12ad0661adcfdbd926dea17d7edfda419c1", "html_url": "https://github.com/rust-lang/rust/commit/0486e12ad0661adcfdbd926dea17d7edfda419c1"}], "stats": {"total": 504, "additions": 1, "deletions": 503}, "files": [{"sha": "4f6c1305f768357bca6220070d29f8e22b4822c2", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e0fd9c3b00a4d2818a1add4840263d936f8748cd/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0fd9c3b00a4d2818a1add4840263d936f8748cd/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=e0fd9c3b00a4d2818a1add4840263d936f8748cd", "patch": "@@ -108,7 +108,6 @@ pub mod middle {\n     pub mod free_region;\n     pub mod intrinsicck;\n     pub mod infer;\n-    pub mod implicator;\n     pub mod lang_items;\n     pub mod liveness;\n     pub mod mem_categorization;"}, {"sha": "d25084bbdffb5e5794cc0840f0c4cf9d7b4750e9", "filename": "src/librustc/middle/implicator.rs", "status": "removed", "additions": 0, "deletions": 454, "changes": 454, "blob_url": "https://github.com/rust-lang/rust/blob/0486e12ad0661adcfdbd926dea17d7edfda419c1/src%2Flibrustc%2Fmiddle%2Fimplicator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0486e12ad0661adcfdbd926dea17d7edfda419c1/src%2Flibrustc%2Fmiddle%2Fimplicator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fimplicator.rs?ref=0486e12ad0661adcfdbd926dea17d7edfda419c1", "patch": "@@ -1,454 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// #![warn(deprecated_mode)]\n-\n-use middle::def_id::DefId;\n-use middle::infer::{InferCtxt, GenericKind};\n-use middle::subst::Substs;\n-use middle::traits;\n-use middle::ty::{self, ToPredicate, Ty};\n-use middle::ty::fold::{TypeFoldable, TypeFolder};\n-\n-use syntax::ast;\n-use syntax::codemap::Span;\n-\n-use util::common::ErrorReported;\n-use util::nodemap::FnvHashSet;\n-\n-// Helper functions related to manipulating region types.\n-\n-#[derive(Debug)]\n-pub enum Implication<'tcx> {\n-    RegionSubRegion(Option<Ty<'tcx>>, ty::Region, ty::Region),\n-    RegionSubGeneric(Option<Ty<'tcx>>, ty::Region, GenericKind<'tcx>),\n-    Predicate(DefId, ty::Predicate<'tcx>),\n-}\n-\n-struct Implicator<'a, 'tcx: 'a> {\n-    infcx: &'a InferCtxt<'a,'tcx>,\n-    body_id: ast::NodeId,\n-    stack: Vec<(ty::Region, Option<Ty<'tcx>>)>,\n-    span: Span,\n-    out: Vec<Implication<'tcx>>,\n-    visited: FnvHashSet<Ty<'tcx>>,\n-}\n-\n-/// This routine computes the well-formedness constraints that must hold for the type `ty` to\n-/// appear in a context with lifetime `outer_region`\n-pub fn implications<'a,'tcx>(\n-    infcx: &'a InferCtxt<'a,'tcx>,\n-    body_id: ast::NodeId,\n-    ty: Ty<'tcx>,\n-    outer_region: ty::Region,\n-    span: Span)\n-    -> Vec<Implication<'tcx>>\n-{\n-    debug!(\"implications(body_id={}, ty={:?}, outer_region={:?})\",\n-           body_id,\n-           ty,\n-           outer_region);\n-\n-    let mut stack = Vec::new();\n-    stack.push((outer_region, None));\n-    let mut wf = Implicator { infcx: infcx,\n-                              body_id: body_id,\n-                              span: span,\n-                              stack: stack,\n-                              out: Vec::new(),\n-                              visited: FnvHashSet() };\n-    wf.accumulate_from_ty(ty);\n-    debug!(\"implications: out={:?}\", wf.out);\n-    wf.out\n-}\n-\n-impl<'a, 'tcx> Implicator<'a, 'tcx> {\n-    fn tcx(&self) -> &'a ty::ctxt<'tcx> {\n-        self.infcx.tcx\n-    }\n-\n-    fn accumulate_from_ty(&mut self, ty: Ty<'tcx>) {\n-        debug!(\"accumulate_from_ty(ty={:?})\",\n-               ty);\n-\n-        // When expanding out associated types, we can visit a cyclic\n-        // set of types. Issue #23003.\n-        if !self.visited.insert(ty) {\n-            return;\n-        }\n-\n-        match ty.sty {\n-            ty::TyBool |\n-            ty::TyChar |\n-            ty::TyInt(..) |\n-            ty::TyUint(..) |\n-            ty::TyFloat(..) |\n-            ty::TyBareFn(..) |\n-            ty::TyError |\n-            ty::TyStr => {\n-                // No borrowed content reachable here.\n-            }\n-\n-            ty::TyClosure(_, ref substs) => {\n-                // FIXME(#27086). We do not accumulate from substs, since they\n-                // don't represent reachable data. This means that, in\n-                // practice, some of the lifetime parameters might not\n-                // be in scope when the body runs, so long as there is\n-                // no reachable data with that lifetime. For better or\n-                // worse, this is consistent with fn types, however,\n-                // which can also encapsulate data in this fashion\n-                // (though it's somewhat harder, and typically\n-                // requires virtual dispatch).\n-                //\n-                // Note that changing this (in a naive way, at least)\n-                // causes regressions for what appears to be perfectly\n-                // reasonable code like this:\n-                //\n-                // ```\n-                // fn foo<'a>(p: &Data<'a>) {\n-                //    bar(|q: &mut Parser| q.read_addr())\n-                // }\n-                // fn bar(p: Box<FnMut(&mut Parser)+'static>) {\n-                // }\n-                // ```\n-                //\n-                // Note that `p` (and `'a`) are not used in the\n-                // closure at all, but to meet the requirement that\n-                // the closure type `C: 'static` (so it can be coerced\n-                // to the object type), we get the requirement that\n-                // `'a: 'static` since `'a` appears in the closure\n-                // type `C`.\n-                //\n-                // A smarter fix might \"prune\" unused `func_substs` --\n-                // this would avoid breaking simple examples like\n-                // this, but would still break others (which might\n-                // indeed be invalid, depending on your POV). Pruning\n-                // would be a subtle process, since we have to see\n-                // what func/type parameters are used and unused,\n-                // taking into consideration UFCS and so forth.\n-\n-                for &upvar_ty in &substs.upvar_tys {\n-                    self.accumulate_from_ty(upvar_ty);\n-                }\n-            }\n-\n-            ty::TyTrait(ref t) => {\n-                let required_region_bounds =\n-                    object_region_bounds(self.tcx(), &t.principal, t.bounds.builtin_bounds);\n-                self.accumulate_from_object_ty(ty, t.bounds.region_bound, required_region_bounds)\n-            }\n-\n-            ty::TyEnum(def, substs) |\n-            ty::TyStruct(def, substs) => {\n-                let item_scheme = def.type_scheme(self.tcx());\n-                self.accumulate_from_adt(ty, def.did, &item_scheme.generics, substs)\n-            }\n-\n-            ty::TyArray(t, _) |\n-            ty::TySlice(t) |\n-            ty::TyRawPtr(ty::TypeAndMut { ty: t, .. }) |\n-            ty::TyBox(t) => {\n-                self.accumulate_from_ty(t)\n-            }\n-\n-            ty::TyRef(r_b, mt) => {\n-                self.accumulate_from_rptr(ty, *r_b, mt.ty);\n-            }\n-\n-            ty::TyParam(p) => {\n-                self.push_param_constraint_from_top(p);\n-            }\n-\n-            ty::TyProjection(ref data) => {\n-                // `<T as TraitRef<..>>::Name`\n-\n-                self.push_projection_constraint_from_top(data);\n-            }\n-\n-            ty::TyTuple(ref tuptys) => {\n-                for &tupty in tuptys {\n-                    self.accumulate_from_ty(tupty);\n-                }\n-            }\n-\n-            ty::TyInfer(_) => {\n-                // This should not happen, BUT:\n-                //\n-                //   Currently we uncover region relationships on\n-                //   entering the fn check. We should do this after\n-                //   the fn check, then we can call this case a bug().\n-            }\n-        }\n-    }\n-\n-    fn accumulate_from_rptr(&mut self,\n-                            ty: Ty<'tcx>,\n-                            r_b: ty::Region,\n-                            ty_b: Ty<'tcx>) {\n-        // We are walking down a type like this, and current\n-        // position is indicated by caret:\n-        //\n-        //     &'a &'b ty_b\n-        //         ^\n-        //\n-        // At this point, top of stack will be `'a`. We must\n-        // require that `'a <= 'b`.\n-\n-        self.push_region_constraint_from_top(r_b);\n-\n-        // Now we push `'b` onto the stack, because it must\n-        // constrain any borrowed content we find within `T`.\n-\n-        self.stack.push((r_b, Some(ty)));\n-        self.accumulate_from_ty(ty_b);\n-        self.stack.pop().unwrap();\n-    }\n-\n-    /// Pushes a constraint that `r_b` must outlive the top region on the stack.\n-    fn push_region_constraint_from_top(&mut self,\n-                                       r_b: ty::Region) {\n-\n-        // Indicates that we have found borrowed content with a lifetime\n-        // of at least `r_b`. This adds a constraint that `r_b` must\n-        // outlive the region `r_a` on top of the stack.\n-        //\n-        // As an example, imagine walking a type like:\n-        //\n-        //     &'a &'b T\n-        //         ^\n-        //\n-        // when we hit the inner pointer (indicated by caret), `'a` will\n-        // be on top of stack and `'b` will be the lifetime of the content\n-        // we just found. So we add constraint that `'a <= 'b`.\n-\n-        let &(r_a, opt_ty) = self.stack.last().unwrap();\n-        self.push_sub_region_constraint(opt_ty, r_a, r_b);\n-    }\n-\n-    /// Pushes a constraint that `r_a <= r_b`, due to `opt_ty`\n-    fn push_sub_region_constraint(&mut self,\n-                                  opt_ty: Option<Ty<'tcx>>,\n-                                  r_a: ty::Region,\n-                                  r_b: ty::Region) {\n-        self.out.push(Implication::RegionSubRegion(opt_ty, r_a, r_b));\n-    }\n-\n-    /// Pushes a constraint that `param_ty` must outlive the top region on the stack.\n-    fn push_param_constraint_from_top(&mut self,\n-                                      param_ty: ty::ParamTy) {\n-        let &(region, opt_ty) = self.stack.last().unwrap();\n-        self.push_param_constraint(region, opt_ty, param_ty);\n-    }\n-\n-    /// Pushes a constraint that `projection_ty` must outlive the top region on the stack.\n-    fn push_projection_constraint_from_top(&mut self,\n-                                           projection_ty: &ty::ProjectionTy<'tcx>) {\n-        let &(region, opt_ty) = self.stack.last().unwrap();\n-        self.out.push(Implication::RegionSubGeneric(\n-            opt_ty, region, GenericKind::Projection(projection_ty.clone())));\n-    }\n-\n-    /// Pushes a constraint that `region <= param_ty`, due to `opt_ty`\n-    fn push_param_constraint(&mut self,\n-                             region: ty::Region,\n-                             opt_ty: Option<Ty<'tcx>>,\n-                             param_ty: ty::ParamTy) {\n-        self.out.push(Implication::RegionSubGeneric(\n-            opt_ty, region, GenericKind::Param(param_ty)));\n-    }\n-\n-    fn accumulate_from_adt(&mut self,\n-                           ty: Ty<'tcx>,\n-                           def_id: DefId,\n-                           _generics: &ty::Generics<'tcx>,\n-                           substs: &Substs<'tcx>)\n-    {\n-        let predicates =\n-            self.tcx().lookup_predicates(def_id).instantiate(self.tcx(), substs);\n-        let predicates = match self.fully_normalize(&predicates) {\n-            Ok(predicates) => predicates,\n-            Err(ErrorReported) => { return; }\n-        };\n-\n-        for predicate in predicates.predicates.as_slice() {\n-            match *predicate {\n-                ty::Predicate::Trait(..) => { }\n-                ty::Predicate::Equate(..) => { }\n-                ty::Predicate::Projection(..) => { }\n-                ty::Predicate::RegionOutlives(ref data) => {\n-                    match self.tcx().no_late_bound_regions(data) {\n-                        None => { }\n-                        Some(ty::OutlivesPredicate(r_a, r_b)) => {\n-                            self.push_sub_region_constraint(Some(ty), r_b, r_a);\n-                        }\n-                    }\n-                }\n-                ty::Predicate::TypeOutlives(ref data) => {\n-                    match self.tcx().no_late_bound_regions(data) {\n-                        None => { }\n-                        Some(ty::OutlivesPredicate(ty_a, r_b)) => {\n-                            self.stack.push((r_b, Some(ty)));\n-                            self.accumulate_from_ty(ty_a);\n-                            self.stack.pop().unwrap();\n-                        }\n-                    }\n-                }\n-                ty::Predicate::ObjectSafe(_) |\n-                ty::Predicate::WellFormed(_) => {\n-                }\n-            }\n-        }\n-\n-        let obligations = predicates.predicates\n-                                    .into_iter()\n-                                    .map(|pred| Implication::Predicate(def_id, pred));\n-        self.out.extend(obligations);\n-\n-        let variances = self.tcx().item_variances(def_id);\n-        self.accumulate_from_substs(substs, Some(&variances));\n-    }\n-\n-    fn accumulate_from_substs(&mut self,\n-                              substs: &Substs<'tcx>,\n-                              variances: Option<&ty::ItemVariances>)\n-    {\n-        let mut tmp_variances = None;\n-        let variances = variances.unwrap_or_else(|| {\n-            tmp_variances = Some(ty::ItemVariances {\n-                types: substs.types.map(|_| ty::Variance::Invariant),\n-                regions: substs.regions().map(|_| ty::Variance::Invariant),\n-            });\n-            tmp_variances.as_ref().unwrap()\n-        });\n-\n-        for (&region, &variance) in substs.regions().iter().zip(&variances.regions) {\n-            match variance {\n-                ty::Contravariant | ty::Invariant => {\n-                    // If any data with this lifetime is reachable\n-                    // within, it must be at least contravariant.\n-                    self.push_region_constraint_from_top(region)\n-                }\n-                ty::Covariant | ty::Bivariant => { }\n-            }\n-        }\n-\n-        for (&ty, &variance) in substs.types.iter().zip(&variances.types) {\n-            match variance {\n-                ty::Covariant | ty::Invariant => {\n-                    // If any data of this type is reachable within,\n-                    // it must be at least covariant.\n-                    self.accumulate_from_ty(ty);\n-                }\n-                ty::Contravariant | ty::Bivariant => { }\n-            }\n-        }\n-    }\n-\n-    fn accumulate_from_object_ty(&mut self,\n-                                 ty: Ty<'tcx>,\n-                                 region_bound: ty::Region,\n-                                 required_region_bounds: Vec<ty::Region>)\n-    {\n-        // Imagine a type like this:\n-        //\n-        //     trait Foo { }\n-        //     trait Bar<'c> : 'c { }\n-        //\n-        //     &'b (Foo+'c+Bar<'d>)\n-        //         ^\n-        //\n-        // In this case, the following relationships must hold:\n-        //\n-        //     'b <= 'c\n-        //     'd <= 'c\n-        //\n-        // The first conditions is due to the normal region pointer\n-        // rules, which say that a reference cannot outlive its\n-        // referent.\n-        //\n-        // The final condition may be a bit surprising. In particular,\n-        // you may expect that it would have been `'c <= 'd`, since\n-        // usually lifetimes of outer things are conservative\n-        // approximations for inner things. However, it works somewhat\n-        // differently with trait objects: here the idea is that if the\n-        // user specifies a region bound (`'c`, in this case) it is the\n-        // \"master bound\" that *implies* that bounds from other traits are\n-        // all met. (Remember that *all bounds* in a type like\n-        // `Foo+Bar+Zed` must be met, not just one, hence if we write\n-        // `Foo<'x>+Bar<'y>`, we know that the type outlives *both* 'x and\n-        // 'y.)\n-        //\n-        // Note: in fact we only permit builtin traits, not `Bar<'d>`, I\n-        // am looking forward to the future here.\n-\n-        // The content of this object type must outlive\n-        // `bounds.region_bound`:\n-        let r_c = region_bound;\n-        self.push_region_constraint_from_top(r_c);\n-\n-        // And then, in turn, to be well-formed, the\n-        // `region_bound` that user specified must imply the\n-        // region bounds required from all of the trait types:\n-        for &r_d in &required_region_bounds {\n-            // Each of these is an instance of the `'c <= 'b`\n-            // constraint above\n-            self.out.push(Implication::RegionSubRegion(Some(ty), r_d, r_c));\n-        }\n-    }\n-\n-    fn fully_normalize<T>(&self, value: &T) -> Result<T,ErrorReported>\n-        where T : TypeFoldable<'tcx>\n-    {\n-        let value =\n-            traits::fully_normalize(self.infcx,\n-                                    traits::ObligationCause::misc(self.span, self.body_id),\n-                                    value);\n-        match value {\n-            Ok(value) => Ok(value),\n-            Err(errors) => {\n-                // I don't like reporting these errors here, but I\n-                // don't know where else to report them just now. And\n-                // I don't really expect errors to arise here\n-                // frequently. I guess the best option would be to\n-                // propagate them out.\n-                traits::report_fulfillment_errors(self.infcx, &errors);\n-                Err(ErrorReported)\n-            }\n-        }\n-    }\n-}\n-\n-/// Given an object type like `SomeTrait+Send`, computes the lifetime\n-/// bounds that must hold on the elided self type. These are derived\n-/// from the declarations of `SomeTrait`, `Send`, and friends -- if\n-/// they declare `trait SomeTrait : 'static`, for example, then\n-/// `'static` would appear in the list. The hard work is done by\n-/// `ty::required_region_bounds`, see that for more information.\n-pub fn object_region_bounds<'tcx>(\n-    tcx: &ty::ctxt<'tcx>,\n-    principal: &ty::PolyTraitRef<'tcx>,\n-    others: ty::BuiltinBounds)\n-    -> Vec<ty::Region>\n-{\n-    // Since we don't actually *know* the self type for an object,\n-    // this \"open(err)\" serves as a kind of dummy standin -- basically\n-    // a skolemized type.\n-    let open_ty = tcx.mk_infer(ty::FreshTy(0));\n-\n-    // Note that we preserve the overall binding levels here.\n-    assert!(!open_ty.has_escaping_regions());\n-    let substs = tcx.mk_substs(principal.0.substs.with_self_ty(open_ty));\n-    let trait_refs = vec!(ty::Binder(ty::TraitRef::new(principal.0.def_id, substs)));\n-\n-    let mut predicates = others.to_predicates(tcx, open_ty);\n-    predicates.extend(trait_refs.iter().map(|t| t.to_predicate()));\n-\n-    tcx.required_region_bounds(open_ty, predicates)\n-}"}, {"sha": "56b02412c31b2f1c65fb703206e7647868333713", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 48, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/e0fd9c3b00a4d2818a1add4840263d936f8748cd/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0fd9c3b00a4d2818a1add4840263d936f8748cd/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=e0fd9c3b00a4d2818a1add4840263d936f8748cd", "patch": "@@ -86,7 +86,6 @@ use astconv::AstConv;\n use check::dropck;\n use check::FnCtxt;\n use middle::free_region::FreeRegionMap;\n-use middle::implicator::{self, Implication};\n use middle::mem_categorization as mc;\n use middle::mem_categorization::Categorization;\n use middle::region::{self, CodeExtent};\n@@ -365,60 +364,14 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n                    r_o, r_o.cause);\n             let sup_type = self.resolve_type(r_o.sup_type);\n             let origin = self.code_to_origin(r_o.cause.span, sup_type, &r_o.cause.code);\n-\n-            if r_o.sub_region != ty::ReEmpty {\n-                type_must_outlive(self, origin, sup_type, r_o.sub_region);\n-            } else {\n-                self.visit_old_school_wf(node_id, sup_type, origin);\n-            }\n+            type_must_outlive(self, origin, sup_type, r_o.sub_region);\n         }\n \n         // Processing the region obligations should not cause the list to grow further:\n         assert_eq!(region_obligations.len(),\n                    self.fcx.inh.infcx.fulfillment_cx.borrow().region_obligations(node_id).len());\n     }\n \n-    fn visit_old_school_wf(&mut self,\n-                           body_id: ast::NodeId,\n-                           ty: Ty<'tcx>,\n-                           origin: infer::SubregionOrigin<'tcx>) {\n-        // As a weird kind of hack, we use a region of empty as a signal\n-        // to mean \"old-school WF rules\". The only reason the old-school\n-        // WF rules are not encoded using WF is that this leads to errors,\n-        // and we want to phase those in gradually.\n-\n-        // FIXME(#27579) remove this weird special case once we phase in new WF rules completely\n-        let implications = implicator::implications(self.infcx(),\n-                                                    body_id,\n-                                                    ty,\n-                                                    ty::ReEmpty,\n-                                                    origin.span());\n-        let origin_for_ty = |ty: Option<Ty<'tcx>>| match ty {\n-            None => origin.clone(),\n-            Some(ty) => infer::ReferenceOutlivesReferent(ty, origin.span()),\n-        };\n-        for implication in implications {\n-            match implication {\n-                Implication::RegionSubRegion(ty, r1, r2) => {\n-                    self.fcx.mk_subr(origin_for_ty(ty), r1, r2);\n-                }\n-                Implication::RegionSubGeneric(ty, r1, GenericKind::Param(param_ty)) => {\n-                    param_ty_must_outlive(self, origin_for_ty(ty), r1, param_ty);\n-                }\n-                Implication::RegionSubGeneric(ty, r1, GenericKind::Projection(proj_ty)) => {\n-                    projection_must_outlive(self, origin_for_ty(ty), r1, proj_ty);\n-                }\n-                Implication::Predicate(def_id, predicate) => {\n-                    let cause = traits::ObligationCause::new(origin.span(),\n-                                                             body_id,\n-                                                             traits::ItemObligation(def_id));\n-                    let obligation = traits::Obligation::new(cause, predicate);\n-                    self.fcx.register_predicate(obligation);\n-                }\n-            }\n-        }\n-    }\n-\n     fn code_to_origin(&self,\n                       span: Span,\n                       sup_type: Ty<'tcx>,"}]}