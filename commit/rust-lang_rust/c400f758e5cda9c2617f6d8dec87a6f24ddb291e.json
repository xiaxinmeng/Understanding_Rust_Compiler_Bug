{"sha": "c400f758e5cda9c2617f6d8dec87a6f24ddb291e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0MDBmNzU4ZTVjZGE5YzI2MTdmNmQ4ZGVjODdhNmYyNGRkYjI5MWU=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-04-29T08:00:22Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-05-10T09:45:43Z"}, "message": "Miri interning: replace ICEs by proper errors, make intern_shallow type signature more precise", "tree": {"sha": "6add93098e1176bd551ceac2d73193d83b639000", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6add93098e1176bd551ceac2d73193d83b639000"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c400f758e5cda9c2617f6d8dec87a6f24ddb291e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c400f758e5cda9c2617f6d8dec87a6f24ddb291e", "html_url": "https://github.com/rust-lang/rust/commit/c400f758e5cda9c2617f6d8dec87a6f24ddb291e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c400f758e5cda9c2617f6d8dec87a6f24ddb291e/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b3269536d0a883caa0904cf6589aa1310ff70b5e", "url": "https://api.github.com/repos/rust-lang/rust/commits/b3269536d0a883caa0904cf6589aa1310ff70b5e", "html_url": "https://github.com/rust-lang/rust/commit/b3269536d0a883caa0904cf6589aa1310ff70b5e"}], "stats": {"total": 561, "additions": 274, "deletions": 287}, "files": [{"sha": "eba4dd336ade2d1bb110f7a1db0044b9caf65239", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c400f758e5cda9c2617f6d8dec87a6f24ddb291e/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c400f758e5cda9c2617f6d8dec87a6f24ddb291e/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=c400f758e5cda9c2617f6d8dec87a6f24ddb291e", "patch": "@@ -871,6 +871,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // Our result will later be validated anyway, and there seems no good reason\n         // to have to fail early here.  This is also more consistent with\n         // `Memory::get_static_alloc` which has to use `const_eval_raw` to avoid cycles.\n+        // FIXME: We can hit delay_span_bug if this is an invalid const, interning finds\n+        // that problem, but we never run validation to show an error. Can we ensure\n+        // this does not happen?\n         let val = self.tcx.const_eval_raw(param_env.and(gid))?;\n         self.raw_const_to_mplace(val)\n     }"}, {"sha": "c9661c92d2e2762e2c403864bf37b8752f339bc7", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 144, "deletions": 119, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/c400f758e5cda9c2617f6d8dec87a6f24ddb291e/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c400f758e5cda9c2617f6d8dec87a6f24ddb291e/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=c400f758e5cda9c2617f6d8dec87a6f24ddb291e", "patch": "@@ -8,7 +8,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n use rustc_middle::mir::interpret::{ErrorHandled, InterpResult};\n-use rustc_middle::ty::{self, Ty};\n+use rustc_middle::ty::{self, query::TyCtxtAt, Ty};\n \n use rustc_ast::ast::Mutability;\n \n@@ -29,43 +29,44 @@ struct InternVisitor<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>> {\n     /// The ectx from which we intern.\n     ecx: &'rt mut InterpCx<'mir, 'tcx, M>,\n     /// Previously encountered safe references.\n-    ref_tracking: &'rt mut RefTracking<(MPlaceTy<'tcx>, Mutability, InternMode)>,\n+    ref_tracking: &'rt mut RefTracking<(MPlaceTy<'tcx>, InternMode)>,\n     /// A list of all encountered allocations. After type-based interning, we traverse this list to\n     /// also intern allocations that are only referenced by a raw pointer or inside a union.\n     leftover_allocations: &'rt mut FxHashSet<AllocId>,\n-    /// The root node of the value that we're looking at. This field is never mutated and only used\n+    /// The root kind of the value that we're looking at. This field is never mutated and only used\n     /// for sanity assertions that will ICE when `const_qualif` screws up.\n     mode: InternMode,\n-    /// This field stores the mutability of the value *currently* being checked.\n-    /// When encountering a mutable reference, we determine the pointee mutability\n-    /// taking into account the mutability of the context: `& &mut i32` is entirely immutable,\n-    /// despite the nested mutable reference!\n-    /// The field gets updated when an `UnsafeCell` is encountered.\n-    mutability: Mutability,\n+    /// This field stores whether we are *currently* inside an `UnsafeCell`. This can affect\n+    /// the intern mode of references we encounter.\n+    inside_unsafe_cell: bool,\n \n     /// This flag is to avoid triggering UnsafeCells are not allowed behind references in constants\n     /// for promoteds.\n     /// It's a copy of `mir::Body`'s ignore_interior_mut_in_const_validation field\n-    ignore_interior_mut_in_const_validation: bool,\n+    ignore_interior_mut_in_const: bool,\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Hash, Eq)]\n enum InternMode {\n-    /// Mutable references must in fact be immutable due to their surrounding immutability in a\n-    /// `static`. In a `static mut` we start out as mutable and thus can also contain further `&mut`\n-    /// that will actually be treated as mutable.\n-    Static,\n-    /// UnsafeCell is OK in the value of a constant: `const FOO = Cell::new(0)` creates\n-    /// a new cell every time it is used.\n+    /// A static and its current mutability.  Below shared references inside a `static mut`,\n+    /// this is *immutable*, and below mutable references inside an `UnsafeCell`, this\n+    /// is *mutable*.\n+    Static(hir::Mutability),\n+    /// The \"base value\" of a const, which can have `UnsafeCell` (as in `const FOO: Cell<i32>`),\n+    /// but that interior mutability is simply ignored.\n     ConstBase,\n-    /// `UnsafeCell` ICEs.\n-    Const,\n+    /// The \"inner values\" of a const with references, where `UnsafeCell` is an error.\n+    ConstInner,\n }\n \n /// Signalling data structure to ensure we don't recurse\n /// into the memory of other constants or statics\n struct IsStaticOrFn;\n \n+fn mutable_memory_in_const(tcx: TyCtxtAt<'_>, kind: &str) {\n+    tcx.sess.span_err(tcx.span, &format!(\"mutable memory ({}) is not allowed in constant\", kind));\n+}\n+\n /// Intern an allocation without looking at its children.\n /// `mode` is the mode of the environment where we found this pointer.\n /// `mutablity` is the mutability of the place to be interned; even if that says\n@@ -75,12 +76,11 @@ struct IsStaticOrFn;\n fn intern_shallow<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>>(\n     ecx: &'rt mut InterpCx<'mir, 'tcx, M>,\n     leftover_allocations: &'rt mut FxHashSet<AllocId>,\n-    mode: InternMode,\n     alloc_id: AllocId,\n-    mutability: Mutability,\n+    mode: InternMode,\n     ty: Option<Ty<'tcx>>,\n ) -> InterpResult<'tcx, Option<IsStaticOrFn>> {\n-    trace!(\"InternVisitor::intern {:?} with {:?}\", alloc_id, mutability,);\n+    trace!(\"intern_shallow {:?} with {:?}\", alloc_id, mode);\n     // remove allocation\n     let tcx = ecx.tcx;\n     let (kind, mut alloc) = match ecx.memory.alloc_map.remove(&alloc_id) {\n@@ -89,8 +89,9 @@ fn intern_shallow<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>>(\n             // Pointer not found in local memory map. It is either a pointer to the global\n             // map, or dangling.\n             // If the pointer is dangling (neither in local nor global memory), we leave it\n-            // to validation to error. The `delay_span_bug` ensures that we don't forget such\n-            // a check in validation.\n+            // to validation to error -- it has the much better error messages, pointing out where\n+            // in the value the dangling reference lies.\n+            // The `delay_span_bug` ensures that we don't forget such a check in validation.\n             if tcx.get_global_alloc(alloc_id).is_none() {\n                 tcx.sess.delay_span_bug(ecx.tcx.span, \"tried to intern dangling pointer\");\n             }\n@@ -107,28 +108,28 @@ fn intern_shallow<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>>(\n     // Set allocation mutability as appropriate. This is used by LLVM to put things into\n     // read-only memory, and also by Miri when evaluating other globals that\n     // access this one.\n-    if mode == InternMode::Static {\n-        // When `ty` is `None`, we assume no interior mutability.\n+    if let InternMode::Static(mutability) = mode {\n+        // For this, we need to take into account `UnsafeCell`. When `ty` is `None`, we assume\n+        // no interior mutability.\n         let frozen = ty.map_or(true, |ty| ty.is_freeze(ecx.tcx.tcx, ecx.param_env, ecx.tcx.span));\n         // For statics, allocation mutability is the combination of the place mutability and\n         // the type mutability.\n         // The entire allocation needs to be mutable if it contains an `UnsafeCell` anywhere.\n-        if mutability == Mutability::Not && frozen {\n+        let immutable = mutability == Mutability::Not && frozen;\n+        if immutable {\n             alloc.mutability = Mutability::Not;\n         } else {\n             // Just making sure we are not \"upgrading\" an immutable allocation to mutable.\n             assert_eq!(alloc.mutability, Mutability::Mut);\n         }\n     } else {\n-        // We *could* be non-frozen at `ConstBase`, for constants like `Cell::new(0)`.\n-        // But we still intern that as immutable as the memory cannot be changed once the\n-        // initial value was computed.\n-        // Constants are never mutable.\n-        assert_eq!(\n-            mutability,\n-            Mutability::Not,\n-            \"Something went very wrong: mutability requested for a constant\"\n-        );\n+        // No matter what, *constants are never mutable*. Mutating them is UB.\n+        // See const_eval::machine::MemoryExtra::can_access_statics for why\n+        // immutability is so important.\n+\n+        // There are no sensible checks we can do here; grep for `mutable_memory_in_const` to\n+        // find the checks we are doing elsewhere to avoid even getting here for memory\n+        // that \"wants\" to be mutable.\n         alloc.mutability = Mutability::Not;\n     };\n     // link the alloc id to the actual allocation\n@@ -142,10 +143,16 @@ impl<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>> InternVisitor<'rt, 'mir\n     fn intern_shallow(\n         &mut self,\n         alloc_id: AllocId,\n-        mutability: Mutability,\n+        mode: InternMode,\n         ty: Option<Ty<'tcx>>,\n     ) -> InterpResult<'tcx, Option<IsStaticOrFn>> {\n-        intern_shallow(self.ecx, self.leftover_allocations, self.mode, alloc_id, mutability, ty)\n+        intern_shallow(\n+            self.ecx,\n+            self.leftover_allocations,\n+            alloc_id,\n+            mode,\n+            ty,\n+        )\n     }\n }\n \n@@ -166,22 +173,22 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir\n     ) -> InterpResult<'tcx> {\n         if let Some(def) = mplace.layout.ty.ty_adt_def() {\n             if Some(def.did) == self.ecx.tcx.lang_items().unsafe_cell_type() {\n+                if self.mode == InternMode::ConstInner && !self.ignore_interior_mut_in_const {\n+                    // We do not actually make this memory mutable.  But in case the user\n+                    // *expected* it to be mutable, make sure we error.  This is just a\n+                    // sanity check to prevent users from accidentally exploiting the UB\n+                    // they caused.  It also helps us to find cases where const-checking\n+                    // failed to prevent an `UnsafeCell` (but as `ignore_interior_mut_in_const`\n+                    // shows that part is not airtight).\n+                    mutable_memory_in_const(self.ecx.tcx, \"`UnsafeCell`\");\n+                }\n                 // We are crossing over an `UnsafeCell`, we can mutate again. This means that\n                 // References we encounter inside here are interned as pointing to mutable\n                 // allocations.\n-                let old = std::mem::replace(&mut self.mutability, Mutability::Mut);\n-                if !self.ignore_interior_mut_in_const_validation {\n-                    assert_ne!(\n-                        self.mode,\n-                        InternMode::Const,\n-                        \"UnsafeCells are not allowed behind references in constants. This should \\\n-                        have been prevented statically by const qualification. If this were \\\n-                        allowed one would be able to change a constant at one use site and other \\\n-                        use sites could observe that mutation.\",\n-                    );\n-                }\n+                // Remember the `old` value to handle nested `UnsafeCell`.\n+                let old = std::mem::replace(&mut self.inside_unsafe_cell, true);\n                 let walked = self.walk_aggregate(mplace, fields);\n-                self.mutability = old;\n+                self.inside_unsafe_cell = old;\n                 return walked;\n             }\n         }\n@@ -191,78 +198,93 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir\n     fn visit_value(&mut self, mplace: MPlaceTy<'tcx>) -> InterpResult<'tcx> {\n         // Handle Reference types, as these are the only relocations supported by const eval.\n         // Raw pointers (and boxes) are handled by the `leftover_relocations` logic.\n+        let tcx = self.ecx.tcx;\n         let ty = mplace.layout.ty;\n-        if let ty::Ref(_, referenced_ty, mutability) = ty.kind {\n+        if let ty::Ref(_, referenced_ty, ref_mutability) = ty.kind {\n             let value = self.ecx.read_immediate(mplace.into())?;\n             let mplace = self.ecx.ref_to_mplace(value)?;\n+            assert_eq!(mplace.layout.ty, referenced_ty);\n             // Handle trait object vtables.\n             if let ty::Dynamic(..) =\n-                self.ecx.tcx.struct_tail_erasing_lifetimes(referenced_ty, self.ecx.param_env).kind\n+                tcx.struct_tail_erasing_lifetimes(referenced_ty, self.ecx.param_env).kind\n             {\n-                // Validation has already errored on an invalid vtable pointer so we can safely not\n-                // do anything if this is not a real pointer.\n+                // Validation will error (with a better message) on an invalid vtable pointer\n+                // so we can safely not do anything if this is not a real pointer.\n                 if let Scalar::Ptr(vtable) = mplace.meta.unwrap_meta() {\n-                    // Explicitly choose `Immutable` here, since vtables are immutable, even\n+                    // Explicitly choose const mode here, since vtables are immutable, even\n                     // if the reference of the fat pointer is mutable.\n-                    self.intern_shallow(vtable.alloc_id, Mutability::Not, None)?;\n+                    self.intern_shallow(vtable.alloc_id, InternMode::ConstInner, None)?;\n                 } else {\n-                    self.ecx().tcx.sess.delay_span_bug(\n-                        rustc_span::DUMMY_SP,\n+                    // Let validation show the error message, but make sure it *does* error.\n+                    tcx.sess.delay_span_bug(\n+                        tcx.span,\n                         \"vtables pointers cannot be integer pointers\",\n                     );\n                 }\n             }\n             // Check if we have encountered this pointer+layout combination before.\n             // Only recurse for allocation-backed pointers.\n             if let Scalar::Ptr(ptr) = mplace.ptr {\n-                // We do not have any `frozen` logic here, because it's essentially equivalent to\n-                // the mutability except for the outermost item. Only `UnsafeCell` can \"unfreeze\",\n-                // and we check that in `visit_aggregate`.\n-                // This is not an inherent limitation, but one that we know to be true, because\n-                // const qualification enforces it. We can lift it in the future.\n-                match (self.mode, mutability) {\n-                    // immutable references are fine everywhere\n-                    (_, hir::Mutability::Not) => {}\n-                    // all is \"good and well\" in the unsoundness of `static mut`\n+                // Compute the mode with which we intern this.\n+                let ref_mode = match self.mode {\n+                    InternMode::Static(mutbl) => {\n+                        // In statics, merge outer mutability with reference mutability and\n+                        // take into account whether we are in an `UnsafeCell`.\n \n-                    // mutable references are ok in `static`. Either they are treated as immutable\n-                    // because they are behind an immutable one, or they are behind an `UnsafeCell`\n-                    // and thus ok.\n-                    (InternMode::Static, hir::Mutability::Mut) => {}\n-                    // we statically prevent `&mut T` via `const_qualif` and double check this here\n-                    (InternMode::ConstBase | InternMode::Const, hir::Mutability::Mut) => {\n-                        match referenced_ty.kind {\n-                            ty::Array(_, n)\n-                                if n.eval_usize(self.ecx.tcx.tcx, self.ecx.param_env) == 0 => {}\n-                            ty::Slice(_)\n-                                if mplace.meta.unwrap_meta().to_machine_usize(self.ecx)? == 0 => {}\n-                            _ => bug!(\"const qualif failed to prevent mutable references\"),\n+                        // The only way a mutable reference actually works as a mutable reference is\n+                        // by being in a `static mut` directly or behind another mutable reference.\n+                        // If there's an immutable reference or we are inside a `static`, then our\n+                        // mutable reference is equivalent to an immutable one. As an example:\n+                        // `&&mut Foo` is semantically equivalent to `&&Foo`\n+                        match ref_mutability {\n+                            _ if self.inside_unsafe_cell => {\n+                                // Inside an `UnsafeCell` is like inside a `static mut`, the \"outer\"\n+                                // mutability does not matter.\n+                                InternMode::Static(ref_mutability)\n+                            }\n+                            Mutability::Not => {\n+                                // A shared reference, things become immutable.\n+                                // We do *not* consier `freeze` here -- that is done more precisely\n+                                // when traversing the referenced data (by tracking `UnsafeCell`).\n+                                InternMode::Static(Mutability::Not)\n+                            }\n+                            Mutability::Mut => {\n+                                // Mutable reference.\n+                                InternMode::Static(mutbl)\n+                            }\n                         }\n                     }\n-                }\n-                // Compute the mutability with which we'll start visiting the allocation. This is\n-                // what gets changed when we encounter an `UnsafeCell`.\n-                //\n-                // The only way a mutable reference actually works as a mutable reference is\n-                // by being in a `static mut` directly or behind another mutable reference.\n-                // If there's an immutable reference or we are inside a static, then our\n-                // mutable reference is equivalent to an immutable one. As an example:\n-                // `&&mut Foo` is semantically equivalent to `&&Foo`\n-                let mutability = self.mutability.and(mutability);\n-                // Recursing behind references changes the intern mode for constants in order to\n-                // cause assertions to trigger if we encounter any `UnsafeCell`s.\n-                let mode = match self.mode {\n-                    InternMode::ConstBase => InternMode::Const,\n-                    other => other,\n+                    InternMode::ConstBase | InternMode::ConstInner => {\n+                        // Ignore `UnsafeCell`, everything is immutable.  Do some sanity checking\n+                        // for mutable references that we encounter -- they must all be ZST.\n+                        // This helps to prevent users from accidentally exploiting UB that they\n+                        // caused (by somehow getting a mutable reference in a `const`).\n+                        if ref_mutability == Mutability::Mut {\n+                            match referenced_ty.kind {\n+                                ty::Array(_, n)\n+                                    if n.eval_usize(tcx.tcx, self.ecx.param_env) == 0 => {}\n+                                ty::Slice(_)\n+                                    if mplace.meta.unwrap_meta().to_machine_usize(self.ecx)? == 0 => {}\n+                                _ => mutable_memory_in_const(tcx, \"`&mut`\"),\n+                            }\n+                        } else {\n+                            // A shared reference. We cannot check `freeze` here due to references\n+                            // like `&dyn Trait` that are actually immutable.  We do check for\n+                            // concrete `UnsafeCell` when traversing the pointee though (if it is\n+                            // a new allocation, not yet interned).\n+                        }\n+                        // Go on with the \"inner\" rules.\n+                        InternMode::ConstInner\n+                    }\n                 };\n-                match self.intern_shallow(ptr.alloc_id, mutability, Some(mplace.layout.ty))? {\n+                match self.intern_shallow(ptr.alloc_id, ref_mode, Some(referenced_ty))? {\n                     // No need to recurse, these are interned already and statics may have\n                     // cycles, so we don't want to recurse there\n                     Some(IsStaticOrFn) => {}\n                     // intern everything referenced by this value. The mutability is taken from the\n                     // reference. It is checked above that mutable references only happen in\n                     // `static mut`\n-                    None => self.ref_tracking.track((mplace, mutability, mode), || ()),\n+                    None => self.ref_tracking.track((mplace, ref_mode), || ()),\n                 }\n             }\n             Ok(())\n@@ -273,6 +295,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir\n     }\n }\n \n+#[derive(Copy, Clone, Debug, PartialEq, Hash, Eq)]\n pub enum InternKind {\n     /// The `mutability` of the static, ignoring the type which may have interior mutability.\n     Static(hir::Mutability),\n@@ -285,48 +308,48 @@ pub fn intern_const_alloc_recursive<M: CompileTimeMachine<'mir, 'tcx>>(\n     ecx: &mut InterpCx<'mir, 'tcx, M>,\n     intern_kind: InternKind,\n     ret: MPlaceTy<'tcx>,\n-    ignore_interior_mut_in_const_validation: bool,\n+    ignore_interior_mut_in_const: bool,\n ) -> InterpResult<'tcx>\n where\n     'tcx: 'mir,\n {\n     let tcx = ecx.tcx;\n-    let (base_mutability, base_intern_mode) = match intern_kind {\n-        // `static mut` doesn't care about interior mutability, it's mutable anyway\n-        InternKind::Static(mutbl) => (mutbl, InternMode::Static),\n+    let base_intern_mode = match intern_kind {\n+        InternKind::Static(mutbl) => InternMode::Static(mutbl),\n         // FIXME: what about array lengths, array initializers?\n-        InternKind::Constant | InternKind::ConstProp => (Mutability::Not, InternMode::ConstBase),\n-        InternKind::Promoted => (Mutability::Not, InternMode::ConstBase),\n+        InternKind::Constant | InternKind::ConstProp | InternKind::Promoted =>\n+            InternMode::ConstBase,\n     };\n \n     // Type based interning.\n-    // `ref_tracking` tracks typed references we have seen and still need to crawl for\n+    // `ref_tracking` tracks typed references we have already interned and still need to crawl for\n     // more typed information inside them.\n     // `leftover_allocations` collects *all* allocations we see, because some might not\n     // be available in a typed way. They get interned at the end.\n-    let mut ref_tracking = RefTracking::new((ret, base_mutability, base_intern_mode));\n+    let mut ref_tracking = RefTracking::empty();\n     let leftover_allocations = &mut FxHashSet::default();\n \n     // start with the outermost allocation\n     intern_shallow(\n         ecx,\n         leftover_allocations,\n-        base_intern_mode,\n         // The outermost allocation must exist, because we allocated it with\n         // `Memory::allocate`.\n         ret.ptr.assert_ptr().alloc_id,\n-        base_mutability,\n+        base_intern_mode,\n         Some(ret.layout.ty),\n     )?;\n \n-    while let Some(((mplace, mutability, mode), _)) = ref_tracking.todo.pop() {\n+    ref_tracking.track((ret, base_intern_mode), || ());\n+\n+    while let Some(((mplace, mode), _)) = ref_tracking.todo.pop() {\n         let interned = InternVisitor {\n             ref_tracking: &mut ref_tracking,\n             ecx,\n             mode,\n             leftover_allocations,\n-            mutability,\n-            ignore_interior_mut_in_const_validation,\n+            ignore_interior_mut_in_const,\n+            inside_unsafe_cell: false,\n         }\n         .visit_value(mplace);\n         if let Err(error) = interned {\n@@ -366,26 +389,28 @@ where\n                 InternKind::Static(_) => {}\n                 // Raw pointers in promoteds may only point to immutable things so we mark\n                 // everything as immutable.\n-                // It is UB to mutate through a raw pointer obtained via an immutable reference.\n+                // It is UB to mutate through a raw pointer obtained via an immutable reference:\n                 // Since all references and pointers inside a promoted must by their very definition\n                 // be created from an immutable reference (and promotion also excludes interior\n                 // mutability), mutating through them would be UB.\n                 // There's no way we can check whether the user is using raw pointers correctly,\n                 // so all we can do is mark this as immutable here.\n                 InternKind::Promoted => {\n+                    // See const_eval::machine::MemoryExtra::can_access_statics for why\n+                    // immutability is so important.\n                     alloc.mutability = Mutability::Not;\n                 }\n                 InternKind::Constant | InternKind::ConstProp => {\n-                    // If it's a constant, it *must* be immutable.\n-                    // We cannot have mutable memory inside a constant.\n-                    // We use `delay_span_bug` here, because this can be reached in the presence\n-                    // of fancy transmutes.\n-                    if alloc.mutability == Mutability::Mut {\n-                        // For better errors later, mark the allocation as immutable\n-                        // (on top of the delayed ICE).\n-                        alloc.mutability = Mutability::Not;\n-                        ecx.tcx.sess.delay_span_bug(ecx.tcx.span, \"mutable allocation in constant\");\n-                    }\n+                    // If it's a constant, we should not have any \"leftovers\" as everything\n+                    // is tracked by const-checking.\n+                    // FIXME: downgrade this to a warning? It rejects some legitimate consts,\n+                    // such as `const CONST_RAW: *const Vec<i32> = &Vec::new() as *const _;`.\n+                    ecx.tcx.sess.span_err(\n+                        ecx.tcx.span,\n+                        \"untyped pointers are not allowed in constant\",\n+                    );\n+                    // For better errors later, mark the allocation as immutable.\n+                    alloc.mutability = Mutability::Not;\n                 }\n             }\n             let alloc = tcx.intern_const_alloc(alloc);"}, {"sha": "f8aa652827381c32d29b9394c1443394c641972b", "filename": "src/test/ui/consts/miri_unleashed/mutable_const.rs", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b3269536d0a883caa0904cf6589aa1310ff70b5e/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3269536d0a883caa0904cf6589aa1310ff70b5e/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const.rs?ref=b3269536d0a883caa0904cf6589aa1310ff70b5e", "patch": "@@ -1,25 +0,0 @@\n-// compile-flags: -Zunleash-the-miri-inside-of-you\n-// normalize-stderr-test \"alloc[0-9]+\" -> \"allocN\"\n-\n-#![deny(const_err)] // The `allow` variant is tested by `mutable_const2`.\n-//~^ NOTE lint level\n-// Here we check that even though `MUTABLE_BEHIND_RAW` is created from a mutable\n-// allocation, we intern that allocation as *immutable* and reject writes to it.\n-// We avoid the `delay_span_bug` ICE by having compilation fail via the `deny` above.\n-\n-use std::cell::UnsafeCell;\n-\n-// make sure we do not just intern this as mutable\n-const MUTABLE_BEHIND_RAW: *mut i32 = &UnsafeCell::new(42) as *const _ as *mut _;\n-\n-const MUTATING_BEHIND_RAW: () = { //~ NOTE\n-    // Test that `MUTABLE_BEHIND_RAW` is actually immutable, by doing this at const time.\n-    unsafe {\n-        *MUTABLE_BEHIND_RAW = 99 //~ ERROR any use of this value will cause an error\n-        //~^ NOTE: which is read-only\n-        // FIXME would be good to match more of the error message here, but looks like we\n-        // normalize *after* checking the annoations here.\n-    }\n-};\n-\n-fn main() {}"}, {"sha": "4772baf9d9a019a7bb254dd4256816c165430f39", "filename": "src/test/ui/consts/miri_unleashed/mutable_const.stderr", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/b3269536d0a883caa0904cf6589aa1310ff70b5e/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b3269536d0a883caa0904cf6589aa1310ff70b5e/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const.stderr?ref=b3269536d0a883caa0904cf6589aa1310ff70b5e", "patch": "@@ -1,39 +0,0 @@\n-error: any use of this value will cause an error\n-  --> $DIR/mutable_const.rs:18:9\n-   |\n-LL | / const MUTATING_BEHIND_RAW: () = {\n-LL | |     // Test that `MUTABLE_BEHIND_RAW` is actually immutable, by doing this at const time.\n-LL | |     unsafe {\n-LL | |         *MUTABLE_BEHIND_RAW = 99\n-   | |         ^^^^^^^^^^^^^^^^^^^^^^^^ writing to allocN which is read-only\n-...  |\n-LL | |     }\n-LL | | };\n-   | |__-\n-   |\n-note: the lint level is defined here\n-  --> $DIR/mutable_const.rs:4:9\n-   |\n-LL | #![deny(const_err)] // The `allow` variant is tested by `mutable_const2`.\n-   |         ^^^^^^^^^\n-\n-warning: skipping const checks\n-   |\n-help: skipping check that does not even have a feature gate\n-  --> $DIR/mutable_const.rs:13:38\n-   |\n-LL | const MUTABLE_BEHIND_RAW: *mut i32 = &UnsafeCell::new(42) as *const _ as *mut _;\n-   |                                      ^^^^^^^^^^^^^^^^^^^^\n-help: skipping check for `const_raw_ptr_deref` feature\n-  --> $DIR/mutable_const.rs:18:9\n-   |\n-LL |         *MUTABLE_BEHIND_RAW = 99\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^\n-help: skipping check for `const_mut_refs` feature\n-  --> $DIR/mutable_const.rs:18:9\n-   |\n-LL |         *MUTABLE_BEHIND_RAW = 99\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to previous error; 1 warning emitted\n-"}, {"sha": "867091af7ba762335a31e9f7a2ee2b9070b191a1", "filename": "src/test/ui/consts/miri_unleashed/mutable_const2.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b3269536d0a883caa0904cf6589aa1310ff70b5e/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3269536d0a883caa0904cf6589aa1310ff70b5e/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const2.rs?ref=b3269536d0a883caa0904cf6589aa1310ff70b5e", "patch": "@@ -1,16 +0,0 @@\n-// compile-flags: -Zunleash-the-miri-inside-of-you\n-// failure-status: 101\n-// rustc-env:RUST_BACKTRACE=0\n-// normalize-stderr-test \"note: rustc 1.* running on .*\" -> \"note: rustc VERSION running on TARGET\"\n-// normalize-stderr-test \"note: compiler flags: .*\" -> \"note: compiler flags: FLAGS\"\n-// normalize-stderr-test \"interpret/intern.rs:[0-9]+:[0-9]+\" -> \"interpret/intern.rs:LL:CC\"\n-\n-#![allow(const_err)]\n-\n-use std::cell::UnsafeCell;\n-\n-// make sure we do not just intern this as mutable\n-const MUTABLE_BEHIND_RAW: *mut i32 = &UnsafeCell::new(42) as *const _ as *mut _;\n-//~^ ERROR: mutable allocation in constant\n-\n-fn main() {}"}, {"sha": "98a1c8bdd8967d881efd94a8800947cda3251b0d", "filename": "src/test/ui/consts/miri_unleashed/mutable_const2.stderr", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b3269536d0a883caa0904cf6589aa1310ff70b5e/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b3269536d0a883caa0904cf6589aa1310ff70b5e/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const2.stderr?ref=b3269536d0a883caa0904cf6589aa1310ff70b5e", "patch": "@@ -1,29 +0,0 @@\n-warning: skipping const checks\n-   |\n-help: skipping check that does not even have a feature gate\n-  --> $DIR/mutable_const2.rs:13:38\n-   |\n-LL | const MUTABLE_BEHIND_RAW: *mut i32 = &UnsafeCell::new(42) as *const _ as *mut _;\n-   |                                      ^^^^^^^^^^^^^^^^^^^^\n-\n-warning: 1 warning emitted\n-\n-error: internal compiler error: mutable allocation in constant\n-  --> $DIR/mutable_const2.rs:13:1\n-   |\n-LL | const MUTABLE_BEHIND_RAW: *mut i32 = &UnsafeCell::new(42) as *const _ as *mut _;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-thread 'rustc' panicked at 'no errors encountered even though `delay_span_bug` issued', src/librustc_errors/lib.rs:366:17\n-note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n-\n-error: internal compiler error: unexpected panic\n-\n-note: the compiler unexpectedly panicked. this is a bug.\n-\n-note: we would appreciate a bug report: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports\n-\n-note: rustc VERSION running on TARGET\n-\n-note: compiler flags: FLAGS\n-"}, {"sha": "ca927ef4a518b0226ffff0ad9efe4db2ae3122bc", "filename": "src/test/ui/consts/miri_unleashed/mutable_references.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c400f758e5cda9c2617f6d8dec87a6f24ddb291e/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c400f758e5cda9c2617f6d8dec87a6f24ddb291e/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references.rs?ref=c400f758e5cda9c2617f6d8dec87a6f24ddb291e", "patch": "@@ -17,12 +17,11 @@ struct Foo<T>(T);\n // this is fine for the same reason as `BAR`.\n static BOO: &mut Foo<()> = &mut Foo(());\n \n+// interior mutability is fine\n struct Meh {\n     x: &'static UnsafeCell<i32>,\n }\n-\n unsafe impl Sync for Meh {}\n-\n static MEH: Meh = Meh {\n     x: &UnsafeCell::new(42),\n };"}, {"sha": "7109ffd8b61d783b1c770ad0ce172cb55e03ac79", "filename": "src/test/ui/consts/miri_unleashed/mutable_references.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c400f758e5cda9c2617f6d8dec87a6f24ddb291e/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c400f758e5cda9c2617f6d8dec87a6f24ddb291e/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references.stderr?ref=c400f758e5cda9c2617f6d8dec87a6f24ddb291e", "patch": "@@ -1,5 +1,5 @@\n error[E0594]: cannot assign to `*OH_YES`, as `OH_YES` is an immutable static item\n-  --> $DIR/mutable_references.rs:37:5\n+  --> $DIR/mutable_references.rs:36:5\n    |\n LL |     *OH_YES = 99;\n    |     ^^^^^^^^^^^^ cannot assign\n@@ -22,12 +22,12 @@ help: skipping check for `const_mut_refs` feature\n LL | static BOO: &mut Foo<()> = &mut Foo(());\n    |                            ^^^^^^^^^^^^\n help: skipping check that does not even have a feature gate\n-  --> $DIR/mutable_references.rs:27:8\n+  --> $DIR/mutable_references.rs:26:8\n    |\n LL |     x: &UnsafeCell::new(42),\n    |        ^^^^^^^^^^^^^^^^^^^^\n help: skipping check for `const_mut_refs` feature\n-  --> $DIR/mutable_references.rs:31:27\n+  --> $DIR/mutable_references.rs:30:27\n    |\n LL | static OH_YES: &mut i32 = &mut 42;\n    |                           ^^^^^^^"}, {"sha": "5014a601390d2db602025aabcd40f0e4e92dd392", "filename": "src/test/ui/consts/miri_unleashed/mutable_references_err.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/c400f758e5cda9c2617f6d8dec87a6f24ddb291e/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c400f758e5cda9c2617f6d8dec87a6f24ddb291e/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_err.rs?ref=c400f758e5cda9c2617f6d8dec87a6f24ddb291e", "patch": "@@ -0,0 +1,37 @@\n+// compile-flags: -Zunleash-the-miri-inside-of-you\n+\n+#![allow(const_err)]\n+\n+use std::cell::UnsafeCell;\n+\n+// this test ICEs to ensure that our mutability story is sound\n+\n+struct Meh {\n+    x: &'static UnsafeCell<i32>,\n+}\n+unsafe impl Sync for Meh {}\n+\n+// the following will never be ok! no interior mut behind consts, because\n+// all allocs interned here will be marked immutable.\n+const MUH: Meh = Meh { //~ ERROR: mutable memory (`UnsafeCell`) is not allowed in constant\n+    x: &UnsafeCell::new(42),\n+};\n+\n+struct Synced {\n+    x: UnsafeCell<i32>,\n+}\n+unsafe impl Sync for Synced {}\n+\n+// Make sure we also catch this behind a type-erased `dyn Trait` reference.\n+const SNEAKY: &dyn Sync = &Synced { x: UnsafeCell::new(42) };\n+//~^ ERROR: mutable memory (`UnsafeCell`) is not allowed in constant\n+\n+// Make sure we also catch mutable references.\n+const BLUNT: &mut i32 = &mut 42;\n+//~^ ERROR: mutable memory (`&mut`) is not allowed in constant\n+\n+fn main() {\n+    unsafe {\n+        *MUH.x.get() = 99;\n+    }\n+}"}, {"sha": "45e7d5a2cc3b3e03bb93d0054c27d2e7a41c499d", "filename": "src/test/ui/consts/miri_unleashed/mutable_references_err.stderr", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c400f758e5cda9c2617f6d8dec87a6f24ddb291e/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_err.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c400f758e5cda9c2617f6d8dec87a6f24ddb291e/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_err.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_err.stderr?ref=c400f758e5cda9c2617f6d8dec87a6f24ddb291e", "patch": "@@ -0,0 +1,40 @@\n+error: mutable memory (`UnsafeCell`) is not allowed in constant\n+  --> $DIR/mutable_references_err.rs:16:1\n+   |\n+LL | / const MUH: Meh = Meh {\n+LL | |     x: &UnsafeCell::new(42),\n+LL | | };\n+   | |__^\n+\n+error: mutable memory (`UnsafeCell`) is not allowed in constant\n+  --> $DIR/mutable_references_err.rs:26:1\n+   |\n+LL | const SNEAKY: &dyn Sync = &Synced { x: UnsafeCell::new(42) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: mutable memory (`&mut`) is not allowed in constant\n+  --> $DIR/mutable_references_err.rs:30:1\n+   |\n+LL | const BLUNT: &mut i32 = &mut 42;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+warning: skipping const checks\n+   |\n+help: skipping check that does not even have a feature gate\n+  --> $DIR/mutable_references_err.rs:17:8\n+   |\n+LL |     x: &UnsafeCell::new(42),\n+   |        ^^^^^^^^^^^^^^^^^^^^\n+help: skipping check that does not even have a feature gate\n+  --> $DIR/mutable_references_err.rs:26:27\n+   |\n+LL | const SNEAKY: &dyn Sync = &Synced { x: UnsafeCell::new(42) };\n+   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: skipping check for `const_mut_refs` feature\n+  --> $DIR/mutable_references_err.rs:30:25\n+   |\n+LL | const BLUNT: &mut i32 = &mut 42;\n+   |                         ^^^^^^^\n+\n+error: aborting due to 3 previous errors; 1 warning emitted\n+"}, {"sha": "7388aad2a9e53c05b90bb5910f40f3ff1a7aa732", "filename": "src/test/ui/consts/miri_unleashed/mutable_references_ice.rs", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b3269536d0a883caa0904cf6589aa1310ff70b5e/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3269536d0a883caa0904cf6589aa1310ff70b5e/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_ice.rs?ref=b3269536d0a883caa0904cf6589aa1310ff70b5e", "patch": "@@ -1,29 +0,0 @@\n-// compile-flags: -Zunleash-the-miri-inside-of-you\n-// failure-status: 101\n-// rustc-env:RUST_BACKTRACE=0\n-// normalize-stderr-test \"note: rustc 1.* running on .*\" -> \"note: rustc VERSION running on TARGET\"\n-// normalize-stderr-test \"note: compiler flags: .*\" -> \"note: compiler flags: FLAGS\"\n-// normalize-stderr-test \"interpret/intern.rs:[0-9]+:[0-9]+\" -> \"interpret/intern.rs:LL:CC\"\n-\n-#![allow(const_err)]\n-\n-use std::cell::UnsafeCell;\n-\n-// this test ICEs to ensure that our mutability story is sound\n-\n-struct Meh {\n-    x: &'static UnsafeCell<i32>,\n-}\n-\n-unsafe impl Sync for Meh {}\n-\n-// the following will never be ok!\n-const MUH: Meh = Meh {\n-    x: &UnsafeCell::new(42),\n-};\n-\n-fn main() {\n-    unsafe {\n-        *MUH.x.get() = 99;\n-    }\n-}"}, {"sha": "7ddf77af4d3af645a272acd7b0fff0cb82aa296a", "filename": "src/test/ui/consts/miri_unleashed/mutable_references_ice.stderr", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b3269536d0a883caa0904cf6589aa1310ff70b5e/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b3269536d0a883caa0904cf6589aa1310ff70b5e/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_ice.stderr?ref=b3269536d0a883caa0904cf6589aa1310ff70b5e", "patch": "@@ -1,25 +0,0 @@\n-thread 'rustc' panicked at 'assertion failed: `(left != right)`\n-  left: `Const`,\n- right: `Const`: UnsafeCells are not allowed behind references in constants. This should have been prevented statically by const qualification. If this were allowed one would be able to change a constant at one use site and other use sites could observe that mutation.', src/librustc_mir/interpret/intern.rs:LL:CC\n-note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n-\n-error: internal compiler error: unexpected panic\n-\n-note: the compiler unexpectedly panicked. this is a bug.\n-\n-note: we would appreciate a bug report: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports\n-\n-note: rustc VERSION running on TARGET\n-\n-note: compiler flags: FLAGS\n-\n-warning: skipping const checks\n-   |\n-help: skipping check that does not even have a feature gate\n-  --> $DIR/mutable_references_ice.rs:22:8\n-   |\n-LL |     x: &UnsafeCell::new(42),\n-   |        ^^^^^^^^^^^^^^^^^^^^\n-\n-warning: 1 warning emitted\n-"}, {"sha": "3d200e231733b7bd8f480c45149848f05fbfdc67", "filename": "src/test/ui/consts/miri_unleashed/raw_mutable_const.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c400f758e5cda9c2617f6d8dec87a6f24ddb291e/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fraw_mutable_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c400f758e5cda9c2617f6d8dec87a6f24ddb291e/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fraw_mutable_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fraw_mutable_const.rs?ref=c400f758e5cda9c2617f6d8dec87a6f24ddb291e", "patch": "@@ -0,0 +1,12 @@\n+// compile-flags: -Zunleash-the-miri-inside-of-you\n+\n+#![feature(const_raw_ptr_deref)]\n+#![feature(const_mut_refs)]\n+#![allow(const_err)]\n+\n+use std::cell::UnsafeCell;\n+\n+const MUTABLE_BEHIND_RAW: *mut i32 = &UnsafeCell::new(42) as *const _ as *mut _;\n+//~^ ERROR: untyped pointers are not allowed in constant\n+\n+fn main() {}"}, {"sha": "c6dbf086ec0e97e1384d6b20754254a832c76241", "filename": "src/test/ui/consts/miri_unleashed/raw_mutable_const.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c400f758e5cda9c2617f6d8dec87a6f24ddb291e/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fraw_mutable_const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c400f758e5cda9c2617f6d8dec87a6f24ddb291e/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fraw_mutable_const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fraw_mutable_const.stderr?ref=c400f758e5cda9c2617f6d8dec87a6f24ddb291e", "patch": "@@ -0,0 +1,16 @@\n+error: untyped pointers are not allowed in constant\n+  --> $DIR/raw_mutable_const.rs:9:1\n+   |\n+LL | const MUTABLE_BEHIND_RAW: *mut i32 = &UnsafeCell::new(42) as *const _ as *mut _;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+warning: skipping const checks\n+   |\n+help: skipping check that does not even have a feature gate\n+  --> $DIR/raw_mutable_const.rs:9:38\n+   |\n+LL | const MUTABLE_BEHIND_RAW: *mut i32 = &UnsafeCell::new(42) as *const _ as *mut _;\n+   |                                      ^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error; 1 warning emitted\n+"}, {"sha": "00fad046b557d337f6d6540d93f627feb3c2ce57", "filename": "src/test/ui/consts/raw-ptr-const.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c400f758e5cda9c2617f6d8dec87a6f24ddb291e/src%2Ftest%2Fui%2Fconsts%2Fraw-ptr-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c400f758e5cda9c2617f6d8dec87a6f24ddb291e/src%2Ftest%2Fui%2Fconsts%2Fraw-ptr-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fraw-ptr-const.rs?ref=c400f758e5cda9c2617f6d8dec87a6f24ddb291e", "patch": "@@ -0,0 +1,10 @@\n+#![allow(const_err)] // make sure we hit the `delay_span_bug`\n+\n+// This is a regression test for a `delay_span_bug` during interning when a constant\n+// evaluates to a (non-dangling) raw pointer.  For now this errors; potentially it\n+// could also be allowed.\n+\n+const CONST_RAW: *const Vec<i32> = &Vec::new() as *const _;\n+//~^ ERROR untyped pointers are not allowed in constant\n+\n+fn main() {}"}, {"sha": "974b1c3ff45b55c891d2af81e1d7007f39051846", "filename": "src/test/ui/consts/raw-ptr-const.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c400f758e5cda9c2617f6d8dec87a6f24ddb291e/src%2Ftest%2Fui%2Fconsts%2Fraw-ptr-const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c400f758e5cda9c2617f6d8dec87a6f24ddb291e/src%2Ftest%2Fui%2Fconsts%2Fraw-ptr-const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fraw-ptr-const.stderr?ref=c400f758e5cda9c2617f6d8dec87a6f24ddb291e", "patch": "@@ -0,0 +1,8 @@\n+error: untyped pointers are not allowed in constant\n+  --> $DIR/raw-ptr-const.rs:7:1\n+   |\n+LL | const CONST_RAW: *const Vec<i32> = &Vec::new() as *const _;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}]}