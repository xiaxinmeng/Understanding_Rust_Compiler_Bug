{"sha": "4c76bfdc1f460692d378803b478f02dc45b7e049", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjNzZiZmRjMWY0NjA2OTJkMzc4ODAzYjQ3OGYwMmRjNDViN2UwNDk=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-01T02:09:30Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-01T02:09:52Z"}, "message": "stdlib: Add an interior vector version of sort and a test case", "tree": {"sha": "09fc3d314eacaa5abb27a3195ac1f33987887aee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/09fc3d314eacaa5abb27a3195ac1f33987887aee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4c76bfdc1f460692d378803b478f02dc45b7e049", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4c76bfdc1f460692d378803b478f02dc45b7e049", "html_url": "https://github.com/rust-lang/rust/commit/4c76bfdc1f460692d378803b478f02dc45b7e049", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4c76bfdc1f460692d378803b478f02dc45b7e049/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b773f8d22b7e132aa9dd59090b939bc612ac8d83", "url": "https://api.github.com/repos/rust-lang/rust/commits/b773f8d22b7e132aa9dd59090b939bc612ac8d83", "html_url": "https://github.com/rust-lang/rust/commit/b773f8d22b7e132aa9dd59090b939bc612ac8d83"}], "stats": {"total": 164, "additions": 164, "deletions": 0}, "files": [{"sha": "4845c9ed25a2d81fc4a3abe6f36755aca8b2aec3", "filename": "src/lib/sort.rs", "status": "modified", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/4c76bfdc1f460692d378803b478f02dc45b7e049/src%2Flib%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c76bfdc1f460692d378803b478f02dc45b7e049/src%2Flib%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsort.rs?ref=4c76bfdc1f460692d378803b478f02dc45b7e049", "patch": "@@ -1,6 +1,9 @@\n \n import vec::len;\n import vec::slice;\n+import ilen = ivec::len;\n+import islice = ivec::slice;\n+export ivector;\n export lteq;\n export merge_sort;\n export quick_sort;\n@@ -130,6 +133,139 @@ fn quick_sort3[T](lteq[T] compare_func_lt, lteq[T] compare_func_eq,\n     qsort3[T](compare_func_lt, compare_func_eq, arr, 0,\n               (vec::len[T](arr) as int) - 1);\n }\n+\n+mod ivector {\n+    export merge_sort;\n+    export quick_sort;\n+    export quick_sort3;\n+\n+    type lteq[T] = fn(&T, &T) -> bool;\n+\n+    fn merge_sort[T](lteq[T] le, &T[] v) -> T[] {\n+        fn merge[T](lteq[T] le, &T[] a, &T[] b) -> T[] {\n+            let T[] rs = ~[];\n+            let uint a_len = ilen[T](a);\n+            let uint a_ix = 0u;\n+            let uint b_len = ilen[T](b);\n+            let uint b_ix = 0u;\n+            while (a_ix < a_len && b_ix < b_len) {\n+                if (le(a.(a_ix), b.(b_ix))) {\n+                    rs += ~[a.(a_ix)];\n+                    a_ix += 1u;\n+                } else { rs += ~[b.(b_ix)]; b_ix += 1u; }\n+            }\n+            rs += islice[T](a, a_ix, a_len);\n+            rs += islice[T](b, b_ix, b_len);\n+            ret rs;\n+        }\n+        let uint v_len = ilen[T](v);\n+        if (v_len <= 1u) { ret v; }\n+        let uint mid = v_len / 2u;\n+        let T[] a = islice[T](v, 0u, mid);\n+        let T[] b = islice[T](v, mid, v_len);\n+        ret merge[T](le, merge_sort[T](le, a), merge_sort[T](le, b));\n+    }\n+\n+    fn swap[T](&T[mutable] arr, uint x, uint y) {\n+        auto a = arr.(x);\n+        arr.(x) = arr.(y);\n+        arr.(y) = a;\n+    }\n+\n+    fn part[T](lteq[T] compare_func, &T[mutable] arr, uint left, uint right,\n+               uint pivot) -> uint {\n+        auto pivot_value = arr.(pivot);\n+        swap[T](arr, pivot, right);\n+        let uint storage_index = left;\n+        let uint i = left;\n+        while (i < right) {\n+            if (compare_func({ arr.(i) }, pivot_value)) {\n+                swap[T](arr, i, storage_index);\n+                storage_index += 1u;\n+            }\n+            i += 1u;\n+        }\n+        swap[T](arr, storage_index, right);\n+        ret storage_index;\n+    }\n+\n+    fn qsort[T](lteq[T] compare_func, &T[mutable] arr, uint left,\n+                uint right) {\n+        if (right > left) {\n+            auto pivot = (left + right) / 2u;\n+            auto new_pivot = part[T](compare_func, arr, left, right, pivot);\n+            if (new_pivot == 0u) { ret; }\n+            qsort[T](compare_func, arr, left, new_pivot - 1u);\n+            qsort[T](compare_func, arr, new_pivot + 1u, right);\n+        }\n+    }\n+\n+    fn quick_sort[T](lteq[T] compare_func, &T[mutable] arr) {\n+        if (ilen[T](arr) == 0u) { ret; }\n+        qsort[T](compare_func, arr, 0u, ilen[T](arr) - 1u);\n+    }\n+\n+\n+    // Based on algorithm presented by Sedgewick and Bentley here:\n+    // http://www.cs.princeton.edu/~rs/talks/QuicksortIsOptimal.pdf\n+    // According to these slides this is the algorithm of choice for\n+    // 'randomly ordered keys, abstract compare' & 'small number of key values'\n+    fn qsort3[T](lteq[T] compare_func_lt, lteq[T] compare_func_eq,\n+                 &T[mutable] arr, int left, int right) {\n+        if (right <= left) { ret; }\n+        let T v = arr.(right);\n+        let int i = left - 1;\n+        let int j = right;\n+        let int p = i;\n+        let int q = j;\n+        while (true) {\n+            i += 1;\n+            while (compare_func_lt({ arr.(i) }, v)) { i += 1; }\n+            j -= 1;\n+            while (compare_func_lt(v, { arr.(j) })) {\n+                if (j == left) { break; }\n+                j -= 1;\n+            }\n+            if (i >= j) { break; }\n+            swap[T](arr, i as uint, j as uint);\n+            if (compare_func_eq({ arr.(i) }, v)) {\n+                p += 1;\n+                swap[T](arr, p as uint, i as uint);\n+            }\n+            if (compare_func_eq(v, { arr.(j) })) {\n+                q -= 1;\n+                swap[T](arr, j as uint, q as uint);\n+            }\n+        }\n+        swap[T](arr, i as uint, right as uint);\n+        j = i - 1;\n+        i += 1;\n+        let int k = left;\n+        while (k < p) {\n+            swap[T](arr, k as uint, j as uint);\n+            k += 1;\n+            j -= 1;\n+            if (k == ilen[T](arr) as int) { break; }\n+        }\n+        k = right - 1;\n+        while (k > q) {\n+            swap[T](arr, i as uint, k as uint);\n+            k -= 1;\n+            i += 1;\n+            if (k == 0) { break; }\n+        }\n+        qsort3[T](compare_func_lt, compare_func_eq, arr, left, j);\n+        qsort3[T](compare_func_lt, compare_func_eq, arr, i, right);\n+    }\n+\n+    fn quick_sort3[T](lteq[T] compare_func_lt, lteq[T] compare_func_eq,\n+                      &T[mutable] arr) {\n+        if (ilen[T](arr) == 0u) { ret; }\n+        qsort3[T](compare_func_lt, compare_func_eq, arr, 0,\n+                  (ilen[T](arr) as int) - 1);\n+    }\n+}\n+\n // Local Variables:\n // mode: rust;\n // fill-column: 78;"}, {"sha": "6b957c8a4ab6fd2967bf04a00e88be9002ca9db9", "filename": "src/test/run-pass/lib-sort-ivec.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4c76bfdc1f460692d378803b478f02dc45b7e049/src%2Ftest%2Frun-pass%2Flib-sort-ivec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c76bfdc1f460692d378803b478f02dc45b7e049/src%2Ftest%2Frun-pass%2Flib-sort-ivec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-sort-ivec.rs?ref=4c76bfdc1f460692d378803b478f02dc45b7e049", "patch": "@@ -0,0 +1,28 @@\n+// xfail-stage0\n+\n+use std;\n+\n+fn check_sort(&int[] v1, &int[] v2) {\n+    auto len = std::ivec::len[int](v1);\n+    fn lteq(&int a, &int b) -> bool { ret a <= b; }\n+    auto f = lteq;\n+    auto v3 = std::sort::ivector::merge_sort[int](f, v1);\n+    auto i = 0u;\n+    while (i < len) { log v3.(i); assert (v3.(i) == v2.(i)); i += 1u; }\n+}\n+\n+fn main() {\n+    {\n+        auto v1 = ~[3, 7, 4, 5, 2, 9, 5, 8];\n+        auto v2 = ~[2, 3, 4, 5, 5, 7, 8, 9];\n+        check_sort(v1, v2);\n+    }\n+    { auto v1 = ~[1, 1, 1]; auto v2 = ~[1, 1, 1]; check_sort(v1, v2); }\n+    { let int[] v1 = ~[]; let int[] v2 = ~[]; check_sort(v1, v2); }\n+    { auto v1 = ~[9]; auto v2 = ~[9]; check_sort(v1, v2); }\n+    {\n+        auto v1 = ~[9, 3, 3, 3, 9];\n+        auto v2 = ~[3, 3, 3, 9, 9];\n+        check_sort(v1, v2);\n+    }\n+}"}]}