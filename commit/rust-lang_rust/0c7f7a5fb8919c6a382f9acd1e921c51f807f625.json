{"sha": "0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjN2Y3YTVmYjg5MTljNmEzODJmOWFjZDFlOTIxYzUxZjgwN2Y2MjU=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-01-04T04:43:24Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-01-06T23:02:52Z"}, "message": "fallout", "tree": {"sha": "74a8f54870574e503df68fd62d799552c8664cf8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/74a8f54870574e503df68fd62d799552c8664cf8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "comment_count": 4, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "html_url": "https://github.com/rust-lang/rust/commit/0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "791f5456859845a4a1814eca45aa900fc62d4e44", "url": "https://api.github.com/repos/rust-lang/rust/commits/791f5456859845a4a1814eca45aa900fc62d4e44", "html_url": "https://github.com/rust-lang/rust/commit/791f5456859845a4a1814eca45aa900fc62d4e44"}], "stats": {"total": 921, "additions": 498, "deletions": 423}, "files": [{"sha": "afcdcf6439c26d6391ccfc4bf4f3cbb917834467", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -539,18 +539,17 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n             script_str.push_str(\"set print pretty off\\n\");\n \n             // Add the pretty printer directory to GDB's source-file search path\n-            script_str.push_str(format!(\"directory {}\\n\", rust_pp_module_abs_path)[]);\n+            script_str.push_str(&format!(\"directory {}\\n\", rust_pp_module_abs_path)[]);\n \n             // Load the target executable\n-            script_str.push_str(format!(\"file {}\\n\",\n-                                        exe_file.as_str().unwrap().replace(\"\\\\\", \"\\\\\\\\\"))\n-                                    .as_slice());\n+            script_str.push_str(&format!(\"file {}\\n\",\n+                                         exe_file.as_str().unwrap().replace(\"\\\\\", \"\\\\\\\\\"))[]);\n \n             // Add line breakpoints\n             for line in breakpoint_lines.iter() {\n-                script_str.push_str(format!(\"break '{}':{}\\n\",\n-                                            testfile.filename_display(),\n-                                            *line)[]);\n+                script_str.push_str(&format!(\"break '{}':{}\\n\",\n+                                             testfile.filename_display(),\n+                                             *line)[]);\n             }\n \n             script_str.push_str(cmds.as_slice());\n@@ -676,7 +675,7 @@ fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testfile: &Path)\n                                                .unwrap()\n                                                .to_string();\n \n-    script_str.push_str(format!(\"command script import {}\\n\", rust_pp_module_abs_path.index(&FullRange))[]);\n+    script_str.push_str(&format!(\"command script import {}\\n\", &rust_pp_module_abs_path[])[]);\n     script_str.push_str(\"type summary add --no-value \");\n     script_str.push_str(\"--python-function lldb_rust_formatters.print_val \");\n     script_str.push_str(\"-x \\\".*\\\" --category Rust\\n\");"}, {"sha": "98e9d6c16b8231d4196d8fa0254dbeeea1210745", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -525,7 +525,7 @@ impl<T> RingBuf<T> {\n     ///     *num = *num - 2;\n     /// }\n     /// let b: &[_] = &[&mut 3, &mut 1, &mut 2];\n-    /// assert_eq!(buf.iter_mut().collect::<Vec<&mut int>>()[], b);\n+    /// assert_eq!(&buf.iter_mut().collect::<Vec<&mut int>>()[], b);\n     /// ```\n     #[stable]\n     pub fn iter_mut<'a>(&'a mut self) -> IterMut<'a, T> {"}, {"sha": "e57574fdbcee36a0ea98d22f438392aaa64fc745", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -1393,15 +1393,20 @@ fn merge_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Order\n \n #[cfg(test)]\n mod tests {\n-    use prelude::{Some, None, range, Vec, ToString, Clone, Greater, Less, Equal};\n-    use prelude::{SliceExt, Iterator, IteratorExt};\n-    use prelude::AsSlice;\n-    use prelude::{RandomAccessIterator, Ord, SliceConcatExt};\n+    use core::cmp::Ordering::{Greater, Less, Equal};\n+    use core::prelude::{Some, None, range, Clone};\n+    use core::prelude::{Iterator, IteratorExt};\n+    use core::prelude::{AsSlice};\n+    use core::prelude::{Ord, FullRange};\n     use core::default::Default;\n     use core::mem;\n+    use core::ops::Index;\n+    use std::iter::RandomAccessIterator;\n     use std::rand::{Rng, thread_rng};\n     use std::rc::Rc;\n-    use super::ElementSwaps;\n+    use string::ToString;\n+    use vec::Vec;\n+    use super::{ElementSwaps, SliceConcatExt, SliceExt};\n \n     fn square(n: uint) -> uint { n * n }\n "}, {"sha": "aacb6d90d6fe483001e3ccf32e5193041f0046d3", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -60,7 +60,7 @@ use core::char::CharExt;\n use core::clone::Clone;\n use core::iter::AdditiveIterator;\n use core::iter::{range, Iterator, IteratorExt};\n-use core::ops::{self, llRange, Index};\n+use core::ops::{FullRange, Index};\n use core::option::Option::{self, Some, None};\n use core::slice::AsSlice;\n use core::str as core_str;\n@@ -408,7 +408,7 @@ Section: Trait implementations\n \n /// Any string that can be represented as a slice.\n #[stable]\n-pub trait StrExt: Index<FullRange, str> {\n+pub trait StrExt: Index<FullRange, Output = str> {\n     /// Escapes each char in `s` with `char::escape_default`.\n     #[unstable = \"return type may change to be an iterator\"]\n     fn escape_default(&self) -> String {\n@@ -1339,12 +1339,6 @@ pub trait StrExt: Index<FullRange, str> {\n     fn trim_left(&self) -> &str {\n         UnicodeStr::trim_left(self.index(&FullRange))\n     }\n-\n-    /// Returns a string with trailing whitespace removed.\n-    #[stable]\n-    fn trim_right(&self) -> &str {\n-        UnicodeStr::trim_right(self.index(&FullRange))\n-    }\n }\n \n #[stable]\n@@ -2133,7 +2127,7 @@ mod tests {\n         let mut bytes = [0u8; 4];\n         for c in range(0u32, 0x110000).filter_map(|c| ::core::char::from_u32(c)) {\n             let len = c.encode_utf8(&mut bytes).unwrap_or(0);\n-            let s = ::core::str::from_utf8(bytes.index(&(0..len))).unwrap();\n+            let s = ::core::str::from_utf8(&bytes[..len]).unwrap();\n             if Some(c) != s.chars().next() {\n                 panic!(\"character {:x}={} does not decode correctly\", c as u32, c);\n             }\n@@ -2145,7 +2139,7 @@ mod tests {\n         let mut bytes = [0u8; 4];\n         for c in range(0u32, 0x110000).filter_map(|c| ::core::char::from_u32(c)) {\n             let len = c.encode_utf8(&mut bytes).unwrap_or(0);\n-            let s = ::core::str::from_utf8(bytes.index(&(0..len))).unwrap();\n+            let s = ::core::str::from_utf8(&bytes[..len]).unwrap();\n             if Some(c) != s.chars().rev().next() {\n                 panic!(\"character {:x}={} does not decode correctly\", c as u32, c);\n             }"}, {"sha": "20bc08416dc78b0b218222c0371bda82e3c03949", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -22,7 +22,7 @@ use core::fmt;\n use core::hash;\n use core::iter::FromIterator;\n use core::mem;\n-use core::ops::{self, Deref, Add};\n+use core::ops::{self, Deref, Add, Index};\n use core::ptr;\n use core::raw::Slice as RawSlice;\n use unicode::str as unicode_str;\n@@ -818,28 +818,29 @@ impl<'a> Add<&'a str> for String {\n     }\n }\n \n-impl ops::Index<ops::Range<uint>, str> for String {\n+impl ops::Index<ops::Range<uint>> for String {\n+    type Output = str;\n     #[inline]\n     fn index(&self, index: &ops::Range<uint>) -> &str {\n         &self.index(&FullRange)[*index]\n     }\n }\n-\n-impl ops::Index<ops::RangeTo<uint>, str> for String {\n+impl ops::Index<ops::RangeTo<uint>> for String {\n+    type Output = str;\n     #[inline]\n     fn index(&self, index: &ops::RangeTo<uint>) -> &str {\n         &self.index(&FullRange)[*index]\n     }\n }\n-\n-impl ops::Index<ops::RangeFrom<uint>, str> for String {\n+impl ops::Index<ops::RangeFrom<uint>> for String {\n+    type Output = str;\n     #[inline]\n     fn index(&self, index: &ops::RangeFrom<uint>) -> &str {\n         &self.index(&FullRange)[*index]\n     }\n }\n-\n-impl ops::Index<ops::FullRange, str> for String {\n+impl ops::Index<ops::FullRange> for String {\n+    type Output = str;\n     #[inline]\n     fn index(&self, _index: &ops::FullRange) -> &str {\n         unsafe { mem::transmute(self.vec.as_slice()) }\n@@ -949,6 +950,7 @@ mod tests {\n     use str::Utf8Error;\n     use core::iter::repeat;\n     use super::{as_string, CowString};\n+    use core::ops::FullRange;\n \n     #[test]\n     fn test_as_string() {\n@@ -1230,10 +1232,10 @@ mod tests {\n     #[test]\n     fn test_slicing() {\n         let s = \"foobar\".to_string();\n-        assert_eq!(\"foobar\", s.index(&FullRange));\n-        assert_eq!(\"foo\", s.index(&(0..3)));\n-        assert_eq!(\"bar\", s.index(&(3..)));\n-        assert_eq!(\"oob\", s.index(&(1..4)));\n+        assert_eq!(\"foobar\", &s[]);\n+        assert_eq!(\"foo\", &s[..3]);\n+        assert_eq!(\"bar\", &s[3..]);\n+        assert_eq!(\"oob\", &s[1..4]);\n     }\n \n     #[test]"}, {"sha": "1cfbbdf6cb8ffedd3b3e58a5e8ee824a4c4702ce", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 27, "deletions": 22, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -1209,62 +1209,66 @@ impl<T> IndexMut<uint> for Vec<T> {\n     }\n }\n \n-impl<T> ops::Index<ops::Range<uint>, [T]> for Vec<T> {\n+\n+impl<T> ops::Index<ops::Range<uint>> for Vec<T> {\n+    type Output = [T];\n     #[inline]\n     fn index(&self, index: &ops::Range<uint>) -> &[T] {\n         self.as_slice().index(index)\n     }\n }\n-\n-impl<T> ops::Index<ops::RangeTo<uint>, [T]> for Vec<T> {\n+impl<T> ops::Index<ops::RangeTo<uint>> for Vec<T> {\n+    type Output = [T];\n     #[inline]\n     fn index(&self, index: &ops::RangeTo<uint>) -> &[T] {\n         self.as_slice().index(index)\n     }\n }\n-\n-impl<T> ops::Index<ops::RangeFrom<uint>, [T]> for Vec<T> {\n+impl<T> ops::Index<ops::RangeFrom<uint>> for Vec<T> {\n+    type Output = [T];\n     #[inline]\n     fn index(&self, index: &ops::RangeFrom<uint>) -> &[T] {\n         self.as_slice().index(index)\n     }\n }\n-\n-impl<T> ops::Index<ops::FullRange, [T]> for Vec<T> {\n+impl<T> ops::Index<ops::FullRange> for Vec<T> {\n+    type Output = [T];\n     #[inline]\n     fn index(&self, _index: &ops::FullRange) -> &[T] {\n         self.as_slice()\n     }\n }\n \n-impl<T> ops::IndexMut<ops::Range<uint>, [T]> for Vec<T> {\n+impl<T> ops::IndexMut<ops::Range<uint>> for Vec<T> {\n+    type Output = [T];\n     #[inline]\n     fn index_mut(&mut self, index: &ops::Range<uint>) -> &mut [T] {\n         self.as_mut_slice().index_mut(index)\n     }\n }\n-\n-impl<T> ops::IndexMut<ops::RangeTo<uint>, [T]> for Vec<T> {\n+impl<T> ops::IndexMut<ops::RangeTo<uint>> for Vec<T> {\n+    type Output = [T];\n     #[inline]\n     fn index_mut(&mut self, index: &ops::RangeTo<uint>) -> &mut [T] {\n         self.as_mut_slice().index_mut(index)\n     }\n }\n-\n-impl<T> ops::IndexMut<ops::RangeFrom<uint>, [T]> for Vec<T> {\n+impl<T> ops::IndexMut<ops::RangeFrom<uint>> for Vec<T> {\n+    type Output = [T];\n     #[inline]\n     fn index_mut(&mut self, index: &ops::RangeFrom<uint>) -> &mut [T] {\n         self.as_mut_slice().index_mut(index)\n     }\n }\n-\n-impl<T> ops::IndexMut<ops::FullRange, [T]> for Vec<T> {\n+impl<T> ops::IndexMut<ops::FullRange> for Vec<T> {\n+    type Output = [T];\n     #[inline]\n     fn index_mut(&mut self, _index: &ops::FullRange) -> &mut [T] {\n         self.as_mut_slice()\n     }\n }\n \n+\n #[stable]\n impl<T> ops::Deref for Vec<T> {\n     type Target = [T];\n@@ -1795,6 +1799,7 @@ mod tests {\n     use prelude::*;\n     use core::mem::size_of;\n     use core::iter::repeat;\n+    use core::ops::FullRange;\n     use test::Bencher;\n     use super::as_vec;\n \n@@ -1932,15 +1937,15 @@ mod tests {\n             let (left, right) = values.split_at_mut(2);\n             {\n                 let left: &[_] = left;\n-                assert!(left[0..left.len()] == [1, 2][]);\n+                assert!(&left[..left.len()] == &[1, 2][]);\n             }\n             for p in left.iter_mut() {\n                 *p += 1;\n             }\n \n             {\n                 let right: &[_] = right;\n-                assert!(right[0..right.len()] == [3, 4, 5][]);\n+                assert!(&right[..right.len()] == &[3, 4, 5][]);\n             }\n             for p in right.iter_mut() {\n                 *p += 2;\n@@ -2111,35 +2116,35 @@ mod tests {\n     #[should_fail]\n     fn test_slice_out_of_bounds_1() {\n         let x: Vec<int> = vec![1, 2, 3, 4, 5];\n-        x[-1..];\n+        &x[(-1)..];\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_slice_out_of_bounds_2() {\n         let x: Vec<int> = vec![1, 2, 3, 4, 5];\n-        x.index(&(0..6));\n+        &x[..6];\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_slice_out_of_bounds_3() {\n         let x: Vec<int> = vec![1, 2, 3, 4, 5];\n-        x[-1..4];\n+        &x[(-1)..4];\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_slice_out_of_bounds_4() {\n         let x: Vec<int> = vec![1, 2, 3, 4, 5];\n-        x.index(&(1..6));\n+        &x[1..6];\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_slice_out_of_bounds_5() {\n         let x: Vec<int> = vec![1, 2, 3, 4, 5];\n-        x.index(&(3..2));\n+        &x[3..2];\n     }\n \n     #[test]\n@@ -2385,7 +2390,7 @@ mod tests {\n         b.bytes = src_len as u64;\n \n         b.iter(|| {\n-            let dst = src.clone().as_slice().to_vec();\n+            let dst = src.clone()[].to_vec();\n             assert_eq!(dst.len(), src_len);\n             assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n         });"}, {"sha": "a4b32f2b6a2cdf29461af3b176daeb237376346e", "filename": "src/libcore/array.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -57,9 +57,13 @@ macro_rules! array_impls {\n                 Rhs: Deref<Target=[B]>,\n             {\n                 #[inline(always)]\n-                fn eq(&self, other: &Rhs) -> bool { PartialEq::eq(self.index(&FullRange), &**other) }\n+                fn eq(&self, other: &Rhs) -> bool {\n+                    PartialEq::eq(self.index(&FullRange), &**other)\n+                }\n                 #[inline(always)]\n-                fn ne(&self, other: &Rhs) -> bool { PartialEq::ne(self.index(&FullRange), &**other) }\n+                fn ne(&self, other: &Rhs) -> bool {\n+                    PartialEq::ne(self.index(&FullRange), &**other)\n+                }\n             }\n \n             #[stable]\n@@ -68,9 +72,13 @@ macro_rules! array_impls {\n                 Lhs: Deref<Target=[A]>\n             {\n                 #[inline(always)]\n-                fn eq(&self, other: &[B; $N]) -> bool { PartialEq::eq(&**self, other.index(&FullRange)) }\n+                fn eq(&self, other: &[B; $N]) -> bool {\n+                    PartialEq::eq(&**self, other.index(&FullRange))\n+                }\n                 #[inline(always)]\n-                fn ne(&self, other: &[B; $N]) -> bool { PartialEq::ne(&**self, other.index(&FullRange)) }\n+                fn ne(&self, other: &[B; $N]) -> bool {\n+                    PartialEq::ne(&**self, other.index(&FullRange))\n+                }\n             }\n \n             #[stable]"}, {"sha": "76c2671cfd033a7a5519439c27de100f115ba102", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -521,7 +521,7 @@ impl<'a> Formatter<'a> {\n \n         let mut fill = [0u8; 4];\n         let len = self.fill.encode_utf8(&mut fill).unwrap_or(0);\n-        let fill = unsafe { str::from_utf8_unchecked(fill[..len]) };\n+        let fill = unsafe { str::from_utf8_unchecked(fill.index(&(..len))) };\n \n         for _ in range(0, pre_pad) {\n             try!(self.buf.write_str(fill));"}, {"sha": "8ab927f701a1ecd84b3f5c25ad3b6339516ca309", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 49, "deletions": 55, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -551,9 +551,10 @@ impl<T> ops::IndexMut<uint> for [T] {\n     }\n }\n \n-impl<T> ops::Index<ops::Range<uint>, [T]> for [T] {\n+impl<T> ops::Index<ops::Range<uint>> for [T] {\n+    type Output = [T];\n     #[inline]\n-    fn index(&self, &index: &ops::Range<uint>) -> &[T] {\n+    fn index(&self, index: &ops::Range<uint>) -> &[T] {\n         assert!(index.start <= index.end);\n         assert!(index.end <= self.len());\n         unsafe {\n@@ -564,31 +565,32 @@ impl<T> ops::Index<ops::Range<uint>, [T]> for [T] {\n         }\n     }\n }\n-\n-impl<T> ops::Index<ops::RangeTo<uint>, [T]> for [T] {\n+impl<T> ops::Index<ops::RangeTo<uint>> for [T] {\n+    type Output = [T];\n     #[inline]\n-    fn index(&self, &index: &ops::RangeTo<uint>) -> &[T] {\n+    fn index(&self, index: &ops::RangeTo<uint>) -> &[T] {\n         self.index(&ops::Range{ start: 0, end: index.end })\n     }\n }\n-\n-impl<T> ops::Index<ops::RangeFrom<uint>, [T]> for [T] {\n+impl<T> ops::Index<ops::RangeFrom<uint>> for [T] {\n+    type Output = [T];\n     #[inline]\n-    fn index(&self, &index: &ops::RangeFrom<uint>) -> &[T] {\n+    fn index(&self, index: &ops::RangeFrom<uint>) -> &[T] {\n         self.index(&ops::Range{ start: index.start, end: self.len() })\n     }\n }\n-\n-impl<T> ops::Index<ops::FullRange, [T]> for [T] {\n+impl<T> ops::Index<ops::FullRange> for [T] {\n+    type Output = [T];\n     #[inline]\n-    fn index(&self, &index: &ops::FullRange) -> &[T] {\n+    fn index(&self, _index: &ops::FullRange) -> &[T] {\n         self\n     }\n }\n \n-impl<T> ops::IndexMut<ops::Range<uint>, [T]> for [T] {\n+impl<T> ops::IndexMut<ops::Range<uint>> for [T] {\n+    type Output = [T];\n     #[inline]\n-    fn index_mut(&mut self, &index: &ops::Range<uint>) -> &mut [T] {\n+    fn index_mut(&mut self, index: &ops::Range<uint>) -> &mut [T] {\n         assert!(index.start <= index.end);\n         assert!(index.end <= self.len());\n         unsafe {\n@@ -599,43 +601,29 @@ impl<T> ops::IndexMut<ops::Range<uint>, [T]> for [T] {\n         }\n     }\n }\n-\n-impl<T> ops::IndexMut<ops::RangeTo<uint>, [T]> for [T] {\n+impl<T> ops::IndexMut<ops::RangeTo<uint>> for [T] {\n+    type Output = [T];\n     #[inline]\n-    fn index_mut(&mut self, &index: &ops::RangeTo<uint>) -> &mut [T] {\n+    fn index_mut(&mut self, index: &ops::RangeTo<uint>) -> &mut [T] {\n         self.index_mut(&ops::Range{ start: 0, end: index.end })\n     }\n }\n-\n-impl<T> ops::IndexMut<ops::RangeFrom<uint>, [T]> for [T] {\n+impl<T> ops::IndexMut<ops::RangeFrom<uint>> for [T] {\n+    type Output = [T];\n     #[inline]\n-    fn index_mut(&mut self, &index: &ops::RangeFrom<uint>) -> &mut [T] {\n+    fn index_mut(&mut self, index: &ops::RangeFrom<uint>) -> &mut [T] {\n         let len = self.len();\n         self.index_mut(&ops::Range{ start: index.start, end: len })\n     }\n }\n-\n-impl<T> ops::IndexMut<ops::FullRange, [T]> for [T] {\n+impl<T> ops::IndexMut<ops::FullRange> for [T] {\n+    type Output = [T];\n     #[inline]\n-    fn index_mut(&mut self, &index: &ops::FullRange) -> &mut [T] {\n+    fn index_mut(&mut self, _index: &ops::FullRange) -> &mut [T] {\n         self\n     }\n }\n \n-impl<T> ops::Index<ops::Range<uint>, [T]> for [T] {\n-    #[inline]\n-    fn index(&self, index: &ops::Range<uint>) -> &[T] {\n-        assert!(index.start <= index.end);\n-        assert!(index.end <= self.len());\n-        unsafe {\n-            transmute(RawSlice {\n-                    data: self.as_ptr().offset(index.start as int),\n-                    len: index.end - index.start\n-                })\n-        }\n-    }\n-}\n-\n \n ////////////////////////////////////////////////////////////////////////////////\n // Common traits\n@@ -767,38 +755,41 @@ pub struct Iter<'a, T: 'a> {\n }\n \n #[experimental]\n-impl<'a, T> ops::Index<ops::Range<uint>, [T]> for Iter<'a, T> {\n+impl<'a, T> ops::Index<ops::Range<uint>> for Iter<'a, T> {\n+    type Output = [T];\n     #[inline]\n     fn index(&self, index: &ops::Range<uint>) -> &[T] {\n         self.as_slice().index(index)\n     }\n }\n \n #[experimental]\n-impl<'a, T> ops::Index<ops::RangeTo<uint>, [T]> for Iter<'a, T> {\n+impl<'a, T> ops::Index<ops::RangeTo<uint>> for Iter<'a, T> {\n+    type Output = [T];\n     #[inline]\n     fn index(&self, index: &ops::RangeTo<uint>) -> &[T] {\n         self.as_slice().index(index)\n     }\n }\n \n #[experimental]\n-impl<'a, T> ops::Index<ops::RangeFrom<uint>, [T]> for Iter<'a, T> {\n+impl<'a, T> ops::Index<ops::RangeFrom<uint>> for Iter<'a, T> {\n+    type Output = [T];\n     #[inline]\n     fn index(&self, index: &ops::RangeFrom<uint>) -> &[T] {\n         self.as_slice().index(index)\n     }\n }\n \n #[experimental]\n-impl<'a, T> ops::Index<ops::FullRange, [T]> for Iter<'a, T> {\n+impl<'a, T> ops::Index<ops::FullRange> for Iter<'a, T> {\n+    type Output = [T];\n     #[inline]\n     fn index(&self, _index: &ops::FullRange) -> &[T] {\n         self.as_slice()\n     }\n }\n \n-\n impl<'a, T> Iter<'a, T> {\n     /// View the underlying data as a subslice of the original data.\n     ///\n@@ -855,64 +846,67 @@ pub struct IterMut<'a, T: 'a> {\n     marker: marker::ContravariantLifetime<'a>,\n }\n \n+\n #[experimental]\n-impl<'a, T> ops::Index<ops::Range<uint>, [T]> for IterMut<'a, T> {\n+impl<'a, T> ops::Index<ops::Range<uint>> for IterMut<'a, T> {\n+    type Output = [T];\n     #[inline]\n     fn index(&self, index: &ops::Range<uint>) -> &[T] {\n         self.index(&ops::FullRange).index(index)\n     }\n }\n-\n #[experimental]\n-impl<'a, T> ops::Index<ops::RangeTo<uint>, [T]> for IterMut<'a, T> {\n+impl<'a, T> ops::Index<ops::RangeTo<uint>> for IterMut<'a, T> {\n+    type Output = [T];\n     #[inline]\n     fn index(&self, index: &ops::RangeTo<uint>) -> &[T] {\n         self.index(&ops::FullRange).index(index)\n     }\n }\n-\n #[experimental]\n-impl<'a, T> ops::Index<ops::RangeFrom<uint>, [T]> for IterMut<'a, T> {\n+impl<'a, T> ops::Index<ops::RangeFrom<uint>> for IterMut<'a, T> {\n+    type Output = [T];\n     #[inline]\n     fn index(&self, index: &ops::RangeFrom<uint>) -> &[T] {\n         self.index(&ops::FullRange).index(index)\n     }\n }\n-\n #[experimental]\n-impl<'a, T> ops::Index<ops::FullRange, [T]> for IterMut<'a, T> {\n+impl<'a, T> ops::Index<ops::FullRange> for IterMut<'a, T> {\n+    type Output = [T];\n     #[inline]\n     fn index(&self, _index: &ops::FullRange) -> &[T] {\n         make_slice!(T -> &[T]: self.ptr, self.end)\n     }\n }\n \n #[experimental]\n-impl<'a, T> ops::IndexMut<ops::Range<uint>, [T]> for IterMut<'a, T> {\n+impl<'a, T> ops::IndexMut<ops::Range<uint>> for IterMut<'a, T> {\n+    type Output = [T];\n     #[inline]\n     fn index_mut(&mut self, index: &ops::Range<uint>) -> &mut [T] {\n         self.index_mut(&ops::FullRange).index_mut(index)\n     }\n }\n-\n #[experimental]\n-impl<'a, T> ops::IndexMut<ops::RangeTo<uint>, [T]> for IterMut<'a, T> {\n+impl<'a, T> ops::IndexMut<ops::RangeTo<uint>> for IterMut<'a, T> {\n+    type Output = [T];\n     #[inline]\n     fn index_mut(&mut self, index: &ops::RangeTo<uint>) -> &mut [T] {\n         self.index_mut(&ops::FullRange).index_mut(index)\n     }\n }\n-\n #[experimental]\n-impl<'a, T> ops::IndexMut<ops::RangeFrom<uint>, [T]> for IterMut<'a, T> {\n+impl<'a, T> ops::IndexMut<ops::RangeFrom<uint>> for IterMut<'a, T> {\n+    type Output = [T];\n     #[inline]\n     fn index_mut(&mut self, index: &ops::RangeFrom<uint>) -> &mut [T] {\n         self.index_mut(&ops::FullRange).index_mut(index)\n     }\n }\n-\n #[experimental]\n-impl<'a, T> ops::IndexMut<ops::FullRange, [T]> for IterMut<'a, T> {\n+impl<'a, T> ops::IndexMut<ops::FullRange> for IterMut<'a, T> {\n+    type Output = [T];\n     #[inline]\n     fn index_mut(&mut self, _index: &ops::FullRange) -> &mut [T] {\n         make_slice!(T -> &mut [T]: self.ptr, self.end)"}, {"sha": "bc995a2af72993ee9e8a92647c01c7b7a2f83a3d", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -1119,28 +1119,29 @@ mod traits {\n         }\n     }\n \n-    impl ops::Index<ops::Range<uint>, str> for str {\n+    impl ops::Index<ops::Range<uint>> for str {\n+        type Output = str;\n         #[inline]\n         fn index(&self, index: &ops::Range<uint>) -> &str {\n             self.slice(index.start, index.end)\n         }\n     }\n-\n-    impl ops::Index<ops::RangeTo<uint>, str> for str {\n+    impl ops::Index<ops::RangeTo<uint>> for str {\n+        type Output = str;\n         #[inline]\n         fn index(&self, index: &ops::RangeTo<uint>) -> &str {\n             self.slice_to(index.end)\n         }\n     }\n-\n-    impl ops::Index<ops::RangeFrom<uint>, str> for str {\n+    impl ops::Index<ops::RangeFrom<uint>> for str {\n+        type Output = str;\n         #[inline]\n         fn index(&self, index: &ops::RangeFrom<uint>) -> &str {\n             self.slice_from(index.start)\n         }\n     }\n-\n-    impl ops::Index<ops::FullRange, str> for str {\n+    impl ops::Index<ops::FullRange> for str {\n+        type Output = str;\n         #[inline]\n         fn index(&self, _index: &ops::FullRange) -> &str {\n             self"}, {"sha": "61266a926494458f62bfffdbac6b964cbcffac83", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -14,7 +14,6 @@ use core::iter::MinMaxResult::*;\n use core::num::SignedInt;\n use core::uint;\n use core::cmp;\n-use core::ops::Slice;\n \n use test::Bencher;\n \n@@ -230,7 +229,7 @@ fn test_inspect() {\n                .collect::<Vec<uint>>();\n \n     assert_eq!(n, xs.len());\n-    assert_eq!(xs.index(&FullRange), ys.index(&FullRange));\n+    assert_eq!(&xs[], &ys[]);\n }\n \n #[test]\n@@ -281,47 +280,47 @@ fn test_iterator_nth() {\n fn test_iterator_last() {\n     let v: &[_] = &[0i, 1, 2, 3, 4];\n     assert_eq!(v.iter().last().unwrap(), &4);\n-    assert_eq!(v.index(&(0..1)).iter().last().unwrap(), &0);\n+    assert_eq!(v[..1].iter().last().unwrap(), &0);\n }\n \n #[test]\n fn test_iterator_len() {\n     let v: &[_] = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-    assert_eq!(v.index(&(0..4)).iter().count(), 4);\n-    assert_eq!(v.index(&(0..10)).iter().count(), 10);\n-    assert_eq!(v.index(&(0..0)).iter().count(), 0);\n+    assert_eq!(v[..4].iter().count(), 4);\n+    assert_eq!(v[..10].iter().count(), 10);\n+    assert_eq!(v[0..0].iter().count(), 0);\n }\n \n #[test]\n fn test_iterator_sum() {\n     let v: &[_] = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-    assert_eq!(v.index(&(0..4)).iter().map(|&x| x).sum(), 6);\n+    assert_eq!(v[..4].iter().map(|&x| x).sum(), 6);\n     assert_eq!(v.iter().map(|&x| x).sum(), 55);\n-    assert_eq!(v.index(&(0..0)).iter().map(|&x| x).sum(), 0);\n+    assert_eq!(v[0..0].iter().map(|&x| x).sum(), 0);\n }\n \n #[test]\n fn test_iterator_product() {\n     let v: &[_] = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-    assert_eq!(v.index(&(0..4)).iter().map(|&x| x).product(), 0);\n-    assert_eq!(v.index(&(1..5)).iter().map(|&x| x).product(), 24);\n-    assert_eq!(v.index(&(0..0)).iter().map(|&x| x).product(), 1);\n+    assert_eq!(v[0..4].iter().map(|&x| x).product(), 0);\n+    assert_eq!(v[1..5].iter().map(|&x| x).product(), 24);\n+    assert_eq!(v[0..0].iter().map(|&x| x).product(), 1);\n }\n \n #[test]\n fn test_iterator_max() {\n     let v: &[_] = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-    assert_eq!(v.index(&(0..4)).iter().map(|&x| x).max(), Some(3));\n+    assert_eq!(v[0..4].iter().map(|&x| x).max(), Some(3));\n     assert_eq!(v.iter().map(|&x| x).max(), Some(10));\n-    assert_eq!(v.index(&(0..0)).iter().map(|&x| x).max(), None);\n+    assert_eq!(v[0..0].iter().map(|&x| x).max(), None);\n }\n \n #[test]\n fn test_iterator_min() {\n     let v: &[_] = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-    assert_eq!(v.index(&(0..4)).iter().map(|&x| x).min(), Some(0));\n+    assert_eq!(v[0..4].iter().map(|&x| x).min(), Some(0));\n     assert_eq!(v.iter().map(|&x| x).min(), Some(0));\n-    assert_eq!(v.index(&(0..0)).iter().map(|&x| x).min(), None);\n+    assert_eq!(v[0..0].iter().map(|&x| x).min(), None);\n }\n \n #[test]\n@@ -374,7 +373,7 @@ fn test_all() {\n     assert!(v.iter().all(|&x| x < 10));\n     assert!(!v.iter().all(|&x| x % 2 == 0));\n     assert!(!v.iter().all(|&x| x > 100));\n-    assert!(v.slice_or_fail(&0, &0).iter().all(|_| panic!()));\n+    assert!(v[0..0].iter().all(|_| panic!()));\n }\n \n #[test]\n@@ -383,7 +382,7 @@ fn test_any() {\n     assert!(v.iter().any(|&x| x < 10));\n     assert!(v.iter().any(|&x| x % 2 == 0));\n     assert!(!v.iter().any(|&x| x > 100));\n-    assert!(!v.slice_or_fail(&0, &0).iter().any(|_| panic!()));\n+    assert!(!v[0..0].iter().any(|_| panic!()));\n }\n \n #[test]\n@@ -586,7 +585,7 @@ fn check_randacc_iter<A, T>(a: T, len: uint) where\n fn test_double_ended_flat_map() {\n     let u = [0u,1];\n     let v = [5u,6,7,8];\n-    let mut it = u.iter().flat_map(|x| v[*x..v.len()].iter());\n+    let mut it = u.iter().flat_map(|x| v[(*x)..v.len()].iter());\n     assert_eq!(it.next_back().unwrap(), &8);\n     assert_eq!(it.next().unwrap(),      &5);\n     assert_eq!(it.next_back().unwrap(), &7);"}, {"sha": "b714b6a4e417dfb1bdfde88a2741fb6d122177d9", "filename": "src/libcoretest/slice.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibcoretest%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibcoretest%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fslice.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -43,35 +43,35 @@ fn iterator_to_slice() {\n \n             {\n                 let mut iter = data.iter();\n-                assert_eq!(iter.index(&FullRange), other_data.index(&FullRange));\n+                assert_eq!(&iter[], &other_data[]);\n \n                 iter.next();\n-                assert_eq!(iter.index(&FullRange), other_data.index(&(1..)));\n+                assert_eq!(&iter[], &other_data[1..]);\n \n                 iter.next_back();\n-                assert_eq!(iter.index(&FullRange), other_data.index(&(1..2)));\n+                assert_eq!(&iter[], &other_data[1..2]);\n \n                 let s = iter.as_slice();\n                 iter.next();\n-                assert_eq!(s, other_data.index(&(1..2)));\n+                assert_eq!(s, &other_data[1..2]);\n             }\n             {\n                 let mut iter = data.iter_mut();\n                 assert_eq!(iter.index(&FullRange), other_data.index(&FullRange));\n                 // mutability:\n-                assert!(iter[mut] == other_data);\n+                assert!(&mut iter[] == other_data);\n \n                 iter.next();\n                 assert_eq!(iter.index(&FullRange), other_data.index(&(1..)));\n-                assert!(iter[mut] == other_data[mut 1..]);\n+                assert!(&mut iter[] == &mut other_data[1..]);\n \n                 iter.next_back();\n \n                 assert_eq!(iter.index(&FullRange), other_data.index(&(1..2)));\n-                assert!(iter[mut] == other_data[mut 1..2]);\n+                assert!(&mut iter[] == &mut other_data[1..2]);\n \n                 let s = iter.into_slice();\n-                assert!(s == other_data[mut 1..2]);\n+                assert!(s == &mut other_data[1..2]);\n             }\n         }}\n     }"}, {"sha": "dd9e5e5a038a77549ca5aa877bceec7590593ba5", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -1413,7 +1413,7 @@ mod tests {\n         assert!(matches_single.opts_present(&[\"e\".to_string(), \"encrypt\".to_string()]));\n         assert!(!matches_single.opts_present(&[\"encrypt\".to_string()]));\n         assert!(!matches_single.opts_present(&[\"thing\".to_string()]));\n-        assert!(!matches_single.opts_present(&.index(&FullRange)));\n+        assert!(!matches_single.opts_present(&[]));\n \n         assert_eq!(matches_single.opts_str(&[\"e\".to_string()]).unwrap(), \"foo\");\n         assert_eq!(matches_single.opts_str(&[\"e\".to_string(), \"encrypt\".to_string()]).unwrap(),\n@@ -1434,7 +1434,7 @@ mod tests {\n         assert!(matches_both.opts_present(&[\"e\".to_string(), \"encrypt\".to_string()]));\n         assert!(!matches_both.opts_present(&[\"f\".to_string()]));\n         assert!(!matches_both.opts_present(&[\"thing\".to_string()]));\n-        assert!(!matches_both.opts_present(&.index(&FullRange)));\n+        assert!(!matches_both.opts_present(&[]));\n \n         assert_eq!(matches_both.opts_str(&[\"e\".to_string()]).unwrap(), \"foo\");\n         assert_eq!(matches_both.opts_str(&[\"encrypt\".to_string()]).unwrap(), \"foo\");"}, {"sha": "2fdba8a6c4f960358a1c064d4d6ec7561cdb06ef", "filename": "src/librand/distributions/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fmod.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -24,7 +24,7 @@ use core::num::{Float, Int};\n \n use {Rng, Rand};\n \n-pub use self::range::Range as RandRange;\n+pub use self::range::Range;\n pub use self::gamma::{Gamma, ChiSquared, FisherF, StudentT};\n pub use self::normal::{Normal, LogNormal};\n pub use self::exponential::Exp;\n@@ -104,7 +104,7 @@ pub struct Weighted<T> {\n /// ```\n pub struct WeightedChoice<'a, T:'a> {\n     items: &'a mut [Weighted<T>],\n-    weight_range: RandRange<uint>\n+    weight_range: Range<uint>\n }\n \n impl<'a, T: Clone> WeightedChoice<'a, T> {\n@@ -138,7 +138,7 @@ impl<'a, T: Clone> WeightedChoice<'a, T> {\n             items: items,\n             // we're likely to be generating numbers in this range\n             // relatively often, so might as well cache it\n-            weight_range: RandRange::new(0, running_total)\n+            weight_range: Range::new(0, running_total)\n         }\n     }\n }"}, {"sha": "1002d9693ba691e3778abe1a1c0cf068f4cc9ac0", "filename": "src/librand/distributions/range.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrand%2Fdistributions%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrand%2Fdistributions%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Frange.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -166,7 +166,7 @@ mod tests {\n     use std::num::Int;\n     use std::prelude::v1::*;\n     use distributions::{Sample, IndependentSample};\n-    use super::Range;\n+    use super::Range as Range;\n \n     #[should_fail]\n     #[test]"}, {"sha": "aeecd69e205ff2b1e618246f4bc4e3ed345ad9e1", "filename": "src/librand/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -58,7 +58,7 @@ use core::prelude::*;\n pub use isaac::{IsaacRng, Isaac64Rng};\n pub use chacha::ChaChaRng;\n \n-use distributions::{RandRange, IndependentSample};\n+use distributions::{Range, IndependentSample};\n use distributions::range::SampleRange;\n \n #[cfg(test)]\n@@ -247,7 +247,7 @@ pub trait Rng : Sized {\n     /// ```\n     fn gen_range<T: PartialOrd + SampleRange>(&mut self, low: T, high: T) -> T {\n         assert!(low < high, \"Rng.gen_range called with low >= high\");\n-        RandRange::new(low, high).ind_sample(self)\n+        Range::new(low, high).ind_sample(self)\n     }\n \n     /// Return a bool with a 1 in n chance of true\n@@ -290,8 +290,8 @@ pub trait Rng : Sized {\n     /// let choices = [1i, 2, 4, 8, 16, 32];\n     /// let mut rng = thread_rng();\n     /// println!(\"{}\", rng.choose(&choices));\n-    /// # // replace with slicing syntax when it's stable!\n-    /// assert_eq!(rng.choose(choices.index(&(0..0))), None);\n+    /// # // uncomment when slicing syntax is stable\n+    /// //assert_eq!(rng.choose(choices.index(&(0..0))), None);\n     /// ```\n     fn choose<'a, T>(&mut self, values: &'a [T]) -> Option<&'a T> {\n         if values.is_empty() {"}, {"sha": "7508f4c50a2c313ff373fee34e22901c9565e005", "filename": "src/libregex/test/matches.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibregex%2Ftest%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibregex%2Ftest%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Ftest%2Fmatches.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -121,7 +121,7 @@ mat!{match_basic_110, r\"a[b-d]\", r\"aac\", Some((1, 3))}\n mat!{match_basic_111, r\"a[-b]\", r\"a-\", Some((0, 2))}\n mat!{match_basic_112, r\"a[b-]\", r\"a-\", Some((0, 2))}\n mat!{match_basic_113, r\"a]\", r\"a]\", Some((0, 2))}\n-mat!{match_basic_114, r\"a.index(&FullRange)]b\", r\"a]b\", Some((0, 3))}\n+mat!{match_basic_114, r\"a[]]b\", r\"a]b\", Some((0, 3))}\n mat!{match_basic_115, r\"a[^bc]d\", r\"aed\", Some((0, 3))}\n mat!{match_basic_116, r\"a[^-b]c\", r\"adc\", Some((0, 3))}\n mat!{match_basic_117, r\"a[^]b]c\", r\"adc\", Some((0, 3))}"}, {"sha": "4f38370d7a150898380c586debcd89cd97785fc7", "filename": "src/libregex/test/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibregex%2Ftest%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibregex%2Ftest%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Ftest%2Ftests.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -159,7 +159,7 @@ macro_rules! mat {\n             // actual capture groups to match test set.\n             let mut sgot = got.as_slice();\n             if sgot.len() > expected.len() {\n-                sgot = sgot[0..expected.len()]\n+                sgot = &sgot[..expected.len()]\n             }\n             if expected != sgot {\n                 panic!(\"For RE '{}' against '{}', expected '{}' but got '{}'\","}, {"sha": "51998bdbcf299dda29f9bcf011b4c3b051af0d67", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -499,7 +499,7 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n                                 None => {\n                                     self.span_lint(builtin::UNKNOWN_LINTS, span,\n                                                format!(\"unknown `{}` attribute: `{}`\",\n-                                                       level.as_str(), lint_name).index(&FullRange));\n+                                                       level.as_str(), lint_name).as_slice());\n                                     continue;\n                                 }\n                             }\n@@ -791,7 +791,7 @@ pub fn check_crate(tcx: &ty::ctxt,\n         for &(lint, span, ref msg) in v.iter() {\n             tcx.sess.span_bug(span,\n                               format!(\"unprocessed lint {} at {}: {}\",\n-                                      lint.as_str(), tcx.map.node_to_string(*id), *msg).index(&FullRange))\n+                                      lint.as_str(), tcx.map.node_to_string(*id), *msg).as_slice())\n         }\n     }\n "}, {"sha": "8961c3e728ca507b3dfd5604c73ef2e264838f72", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -209,7 +209,7 @@ impl<'a> CrateReader<'a> {\n                 let name = match *path_opt {\n                     Some((ref path_str, _)) => {\n                         let name = path_str.get().to_string();\n-                        validate_crate_name(Some(self.sess), name[],\n+                        validate_crate_name(Some(self.sess), name.index(&FullRange),\n                                             Some(i.span));\n                         name\n                     }\n@@ -276,7 +276,7 @@ impl<'a> CrateReader<'a> {\n                                     } else {\n                                         self.sess.span_err(m.span,\n                                             format!(\"unknown kind: `{}`\",\n-                                                    k)[]);\n+                                                    k).index(&FullRange));\n                                         cstore::NativeUnknown\n                                     }\n                                 }\n@@ -330,7 +330,7 @@ impl<'a> CrateReader<'a> {\n             match self.sess.opts.externs.get(name) {\n                 Some(locs) => {\n                     let found = locs.iter().any(|l| {\n-                        let l = fs::realpath(&Path::new(l[])).ok();\n+                        let l = fs::realpath(&Path::new(l.index(&FullRange))).ok();\n                         l == source.dylib || l == source.rlib\n                     });\n                     if found {\n@@ -409,7 +409,7 @@ impl<'a> CrateReader<'a> {\n                     crate_name: name,\n                     hash: hash.map(|a| &*a),\n                     filesearch: self.sess.target_filesearch(kind),\n-                    triple: self.sess.opts.target_triple[],\n+                    triple: self.sess.opts.target_triple.index(&FullRange),\n                     root: root,\n                     rejected_via_hash: vec!(),\n                     rejected_via_triple: vec!(),"}, {"sha": "b19501229aa0b08958d945296a7273fbc7047e85", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -1826,10 +1826,10 @@ fn encode_macro_defs(rbml_w: &mut Encoder,\n         rbml_w.start_tag(tag_macro_def);\n \n         encode_name(rbml_w, def.ident.name);\n-        encode_attributes(rbml_w, def.attrs[]);\n+        encode_attributes(rbml_w, def.attrs.index(&FullRange));\n \n         rbml_w.start_tag(tag_macro_def_body);\n-        rbml_w.wr_str(pprust::tts_to_string(def.body[])[]);\n+        rbml_w.wr_str(pprust::tts_to_string(def.body.index(&FullRange)).index(&FullRange));\n         rbml_w.end_tag();\n \n         rbml_w.end_tag();"}, {"sha": "4106d216bf9a2b50121bb2ec492076caad361dc1", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -624,7 +624,8 @@ impl<'a> Context<'a> {\n                     return true\n                 } else {\n                     let (ref prefix, ref suffix) = dylibname;\n-                    if file.starts_with(prefix.index(&FullRange)) && file.ends_with(suffix.index(&FullRange)) {\n+                    if file.starts_with(prefix.index(&FullRange)) &&\n+                       file.ends_with(suffix.index(&FullRange)) {\n                         return true\n                     }\n                 }"}, {"sha": "8b9a0d89b380c90547d0f304d07cf854e726d562", "filename": "src/librustc/middle/cfg/graphviz.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -85,7 +85,9 @@ impl<'a, 'ast> dot::Labeller<'a, Node<'a>, Edge<'a>> for LabelledCFG<'a, 'ast> {\n             let s = self.ast_map.node_to_string(node_id);\n             // left-aligns the lines\n             let s = replace_newline_with_backslash_l(s);\n-            label.push_str(format!(\"exiting scope_{} {}\", i, s.index(&FullRange)).index(&FullRange));\n+            label.push_str(format!(\"exiting scope_{} {}\",\n+                                   i,\n+                                   s.index(&FullRange)).index(&FullRange));\n         }\n         dot::LabelText::EscStr(label.into_cow())\n     }"}, {"sha": "ac53bdbefcf10a4e2d63c37efa7f4a4a9ae83474", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -165,6 +165,7 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &ast::Expr) {\n         ast::ExprParen(..) |\n         ast::ExprField(..) |\n         ast::ExprTupField(..) |\n+        ast::ExprIndex(..) |\n         ast::ExprTup(..) |\n         ast::ExprRepeat(..) |\n         ast::ExprStruct(..) => {}"}, {"sha": "1f89121488ea18efc54da7330ce7671b86a2334a", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -1158,7 +1158,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                                 let msg = format!(\"Pattern has unexpected type: {} and type {}\",\n                                                   def,\n                                                   cmt_pat.ty.repr(tcx));\n-                                tcx.sess.span_bug(pat.span, msg[])\n+                                tcx.sess.span_bug(pat.span, msg.as_slice())\n                             }\n                         }\n "}, {"sha": "81d4d66a88eb9785fa00b2de375c3d7af4f2dc44", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -495,7 +495,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                                                         ret_ty), 1, true)\n                 }\n                 None => {\n-                    self.cat_index(expr, self.cat_expr(&**base))\n+                    self.cat_index(expr, try!(self.cat_expr(&**base)))\n                 }\n             }\n           }\n@@ -1497,7 +1497,7 @@ impl<'tcx> Repr<'tcx> for InteriorKind {\n                 token::get_name(fld).get().to_string()\n             }\n             InteriorField(PositionalField(i)) => format!(\"#{}\", i),\n-            InteriorElement(_) => \".index(&FullRange)\".to_string(),\n+            InteriorElement(_) => \"[]\".to_string(),\n         }\n     }\n }"}, {"sha": "3638d98ae8800169f7100486e61f2003f554562e", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -378,7 +378,7 @@ pub fn type_known_to_meet_builtin_bound<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n                 span,\n                 format!(\"overflow evaluating whether `{}` is `{}`\",\n                         ty.user_string(infcx.tcx),\n-                        bound.user_string(infcx.tcx))[]);\n+                        bound.user_string(infcx.tcx)).as_slice());\n             suggest_new_overflow_limit(infcx.tcx, span);\n             false\n         }"}, {"sha": "17792ef78ab5351405c0473f5a7159a31b322019", "filename": "src/librustc/middle/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -178,7 +178,7 @@ fn object_safety_violations_for_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n     // The `Self` type is erased, so it should not appear in list of\n     // arguments or return type apart from the receiver.\n     let ref sig = method.fty.sig;\n-    for &input_ty in sig.0.inputs[1..].iter() {\n+    for &input_ty in sig.0.inputs.index(&(1..)).iter() {\n         if contains_illegal_self_type_reference(tcx, trait_def_id, input_ty) {\n             return Some(MethodViolationCode::ReferencesSelf);\n         }"}, {"sha": "67a8508e60dd1760486520a98ea378607cbf5fa8", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -490,7 +490,7 @@ fn assemble_candidates_from_object_type<'cx,'tcx>(\n             selcx.tcx().sess.span_bug(\n                 obligation.cause.span,\n                 format!(\"assemble_candidates_from_object_type called with non-object: {}\",\n-                        object_ty.repr(selcx.tcx()))[]);\n+                        object_ty.repr(selcx.tcx())).as_slice());\n         }\n     };\n     let projection_bounds = data.projection_bounds_with_self_ty(selcx.tcx(), object_ty);"}, {"sha": "e24fe46b34db76d3c902490bf9f1f379a30ba736", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -3654,7 +3654,8 @@ pub fn is_instantiable<'tcx>(cx: &ctxt<'tcx>, r_ty: Ty<'tcx>) -> bool {\n             ty_unboxed_closure(..) => {\n                 // this check is run on type definitions, so we don't expect to see\n                 // inference by-products or unboxed closure types\n-                cx.sess.bug(format!(\"requires check invoked on inapplicable type: {}\", ty)[])\n+                cx.sess.bug(format!(\"requires check invoked on inapplicable type: {}\",\n+                                    ty).as_slice())\n             }\n \n             ty_tup(ref ts) => {\n@@ -3747,7 +3748,8 @@ pub fn is_type_representable<'tcx>(cx: &ctxt<'tcx>, sp: Span, ty: Ty<'tcx>)\n             ty_unboxed_closure(..) => {\n                 // this check is run on type definitions, so we don't expect to see\n                 // unboxed closure types\n-                cx.sess.bug(format!(\"requires check invoked on inapplicable type: {}\", ty)[])\n+                cx.sess.bug(format!(\"requires check invoked on inapplicable type: {}\",\n+                                    ty).as_slice())\n             }\n             _ => Representable,\n         }"}, {"sha": "d3f8c8284e0dc38eb1eadbeac3d8a04afdeb770f", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -639,7 +639,7 @@ pub fn build_target_config(opts: &Options, sp: &SpanHandler) -> Config {\n     let target = match Target::search(opts.target_triple.index(&FullRange)) {\n         Ok(t) => t,\n         Err(e) => {\n-            sp.handler().fatal((format!(\"Error loading target specification: {}\", e)).index(&FullRange));\n+            sp.handler().fatal((format!(\"Error loading target specification: {}\", e)).as_slice());\n     }\n     };\n \n@@ -1027,7 +1027,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n                 s => {\n                     early_error(format!(\"unknown library kind `{}`, expected \\\n                                          one of dylib, framework, or static\",\n-                                        s)[]);\n+                                        s).as_slice());\n                 }\n             };\n             return (name.to_string(), kind)"}, {"sha": "02bb6aa4b0d3840f2dcbdc2e55016d5581866dc3", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -247,7 +247,9 @@ impl Target {\n             } );\n             ($key_name:ident, bool) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                obj.find(name.index(&FullRange)).map(|o| o.as_boolean().map(|s| base.options.$key_name = s));\n+                obj.find(name.index(&FullRange))\n+                    .map(|o| o.as_boolean()\n+                         .map(|s| base.options.$key_name = s));\n             } );\n             ($key_name:ident, list) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");"}, {"sha": "2100d5a9bc307cec26d3283c165b59b68b626291", "filename": "src/librustc_borrowck/borrowck/doc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustc_borrowck%2Fborrowck%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustc_borrowck%2Fborrowck%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fdoc.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -138,7 +138,7 @@\n //! - `FREEZE` means that the `LV` cannot be borrowed immutably;\n //!\n //! Finally, it is never possible to move from an lvalue that appears in a\n-//! restriction. This implies that the \"empty restriction\" `(LV, .index(&FullRange))`,\n+//! restriction. This implies that the \"empty restriction\" `(LV, [])`,\n //! which contains an empty set of actions, still has a purpose---it\n //! prevents moves from `LV`. I chose not to make `MOVE` a fourth kind of\n //! action because that would imply that sometimes moves are permitted\n@@ -476,7 +476,7 @@\n //! ```text\n //! &mut LV =>   RESTRICTIONS(LV, LT, MUTATE|CLAIM|FREEZE)\n //! &LV =>       RESTRICTIONS(LV, LT, MUTATE|CLAIM)\n-//! &const LV => RESTRICTIONS(LV, LT, .index(&FullRange))\n+//! &const LV => RESTRICTIONS(LV, LT, [])\n //! ```\n //!\n //! The reasoning here is that a mutable borrow must be the only writer,\n@@ -542,7 +542,7 @@\n //! restricting `MUTATE` and `CLAIM` actions:\n //!\n //! ```text\n-//! RESTRICTIONS(*LV, LT, ACTIONS) = .index(&FullRange)                    // R-Deref-Imm-Borrowed\n+//! RESTRICTIONS(*LV, LT, ACTIONS) = []                    // R-Deref-Imm-Borrowed\n //!   TYPE(LV) = &LT' Ty\n //!   LT <= LT'                                            // (1)\n //!   ACTIONS subset of [MUTATE, CLAIM]\n@@ -660,7 +660,7 @@\n //! necessary to add any restrictions at all to the final result.\n //!\n //! ```text\n-//!     RESTRICTIONS(*LV, LT, .index(&FullRange)) = .index(&FullRange)                         // R-Deref-Freeze-Borrowed\n+//!     RESTRICTIONS(*LV, LT, []) = []                // R-Deref-Freeze-Borrowed\n //!       TYPE(LV) = &const Ty\n //! ```\n //!"}, {"sha": "75dee49623498e122c8b1a207c6916a3a888e03e", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -804,7 +804,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             mc::AliasableClosure(id) => {\n                 self.tcx.sess.span_err(span,\n                                        format!(\"{} in a captured outer \\\n-                                               variable in an `Fn` closure\", prefix).index(&FullRange));\n+                                               variable in an `Fn` closure\", prefix).as_slice());\n                 span_help!(self.tcx.sess, self.tcx.map.span(id),\n                            \"consider changing this closure to take self by mutable reference\");\n             }"}, {"sha": "debbf2767ac9511333710f07eab68c884c4f7039", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -3763,13 +3763,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             self.resolve_error(path.span,\n                                 format!(\"`{}` is not an enum variant, struct or const\",\n                                     token::get_ident(\n-                                        path.segments.last().unwrap().identifier)).index(&FullRange));\n+                                        path.segments.last().unwrap().identifier)).as_slice());\n                         }\n                         None => {\n                             self.resolve_error(path.span,\n                                 format!(\"unresolved enum variant, struct or const `{}`\",\n                                     token::get_ident(\n-                                        path.segments.last().unwrap().identifier)).index(&FullRange));\n+                                        path.segments.last().unwrap().identifier)).as_slice());\n                         }\n                     }\n "}, {"sha": "aff5f00e64eb73cf1c481fc670f88ebcb6f0e4be", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -608,7 +608,7 @@ fn link_rlib<'a>(sess: &'a Session,\n                 // extension to it. This is to work around a bug in LLDB that\n                 // would cause it to crash if the name of a file in an archive\n                 // was exactly 16 bytes.\n-                let bc_filename = obj_filename.with_extension(format!(\"{}.bc\", i).index(&FullRange));\n+                let bc_filename = obj_filename.with_extension(format!(\"{}.bc\", i).as_slice());\n                 let bc_deflated_filename = obj_filename.with_extension(\n                     format!(\"{}.bytecode.deflate\", i).index(&FullRange));\n \n@@ -1083,8 +1083,8 @@ fn add_local_native_libraries(cmd: &mut Command, sess: &Session) {\n             // -force_load is the OSX equivalent of --whole-archive, but it\n             // involves passing the full path to the library to link.\n             let lib = archive::find_library(l.index(&FullRange),\n-                                            sess.target.target.options.staticlib_prefix.index(&FullRange),\n-                                            sess.target.target.options.staticlib_suffix.index(&FullRange),\n+                                            sess.target.target.options.staticlib_prefix.as_slice(),\n+                                            sess.target.target.options.staticlib_suffix.as_slice(),\n                                             search_path.index(&FullRange),\n                                             &sess.diagnostic().handler);\n             let mut v = b\"-Wl,-force_load,\".to_vec();"}, {"sha": "ecf2e9ed7242557360ad7b3d6c8c465b28e90dc5", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -64,7 +64,7 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n         debug!(\"reading {}\", file);\n         for i in iter::count(0u, 1) {\n             let bc_encoded = time(sess.time_passes(),\n-                                  format!(\"check for {}.{}.bytecode.deflate\", name, i).index(&FullRange),\n+                                  format!(\"check for {}.{}.bytecode.deflate\", name, i).as_slice(),\n                                   (),\n                                   |_| {\n                                       archive.read(format!(\"{}.{}.bytecode.deflate\","}, {"sha": "56d7fb096627c595bd86aba4127918e4604fdb3e", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -381,8 +381,8 @@ unsafe extern \"C\" fn diagnostic_handler(info: DiagnosticInfoRef, user: *mut c_vo\n                 cgcx.handler.note(format!(\"optimization {} for {} at {}: {}\",\n                                           opt.kind.describe(),\n                                           pass_name,\n-                                          if loc.is_empty() { \"[unknown]\" } else { loc.index(&FullRange) },\n-                                          llvm::twine_to_string(opt.message)).index(&FullRange));\n+                                          if loc.is_empty() { \"[unknown]\" } else { loc.as_slice() },\n+                                          llvm::twine_to_string(opt.message)).as_slice());\n             }\n         }\n "}, {"sha": "4ac9f1c7c930f8ef49c7bfc1c07d0a506c6c7f9c", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -292,7 +292,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                 Some(def_id) => {\n                                     result.push_str(\" as \");\n                                     result.push_str(\n-                                        ty::item_path_str(&self.analysis.ty_cx, def_id).index(&FullRange));\n+                                        ty::item_path_str(&self.analysis.ty_cx, def_id).as_slice());\n                                 },\n                                 None => {}\n                             }\n@@ -636,7 +636,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                         item.id);\n \n                     for field in struct_def.fields.iter() {\n-                        self.process_struct_field_def(field, qualname.index(&FullRange), variant.node.id);\n+                        self.process_struct_field_def(field, qualname.as_slice(), variant.node.id);\n                         self.visit_ty(&*field.node.ty);\n                     }\n                 }\n@@ -774,7 +774,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         let def_map = self.analysis.ty_cx.def_map.borrow();\n         if !def_map.contains_key(&id) {\n             self.sess.span_bug(span,\n-                               format!(\"def_map has no key for {} in visit_expr\", id).index(&FullRange));\n+                               format!(\"def_map has no key for {} in visit_expr\", id).as_slice());\n         }\n         let def = &(*def_map)[id];\n         let sub_span = self.span.span_for_last_ident(span);\n@@ -1065,7 +1065,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                                      value.index(&FullRange));\n \n                 self.visit_ty(&**ty);\n-                self.process_generic_params(ty_params, item.span, qualname.index(&FullRange), item.id);\n+                self.process_generic_params(ty_params, item.span, qualname.as_slice(), item.id);\n             },\n             ast::ItemMac(_) => (),\n             _ => visit::walk_item(self, item),\n@@ -1418,7 +1418,8 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n             let def_map = self.analysis.ty_cx.def_map.borrow();\n             if !def_map.contains_key(&id) {\n                 self.sess.span_bug(p.span,\n-                                   format!(\"def_map has no key for {} in visit_arm\", id).index(&FullRange));\n+                                   format!(\"def_map has no key for {} in visit_arm\",\n+                                           id).index(&FullRange));\n             }\n             let def = &(*def_map)[id];\n             match *def {"}, {"sha": "bb0fb387002083ffc19ec1ea511a60f59972bf78", "filename": "src/librustc_trans/save/recorder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Frecorder.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -237,7 +237,7 @@ impl<'a> FmtStrs<'a> {\n         if !needs_span {\n             self.span.sess.span_bug(span,\n                                     format!(\"Called record_with_span for '{}' \\\n-                                             which does not require a span\", label).index(&FullRange));\n+                                             which does not require a span\", label).as_slice());\n         }\n \n         let values_str = match self.make_values_str(label, fields, values, span) {"}, {"sha": "438cfe0b6c710b644dbd9a41b032b7ab4c4e0490", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -1037,8 +1037,8 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                         field_vals.len())\n             );\n             let mut vals = field_vals;\n-            vals.push_all(vals_left.index(&FullRange));\n-            compile_submatch(bcx, pats.index(&FullRange), vals.index(&FullRange), chk, has_genuine_default);\n+            vals.push_all(vals_left.as_slice());\n+            compile_submatch(bcx, pats.as_slice(), vals.as_slice(), chk, has_genuine_default);\n             return;\n         }\n         _ => ()"}, {"sha": "458c1fa923ecbd09c0e606cf0334955525e5608a", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -2239,7 +2239,7 @@ pub fn update_linkage(ccx: &CrateContext,\n     if let Some(id) = id {\n         let item = ccx.tcx().map.get(id);\n         if let ast_map::NodeItem(i) = item {\n-            if let Some(name) = attr::first_attr_value_str_by_name(i.attrs.index(&FullRange), \"linkage\") {\n+            if let Some(name) = attr::first_attr_value_str_by_name(i.attrs.as_slice(), \"linkage\") {\n                 if let Some(linkage) = llvm_linkage_by_name(name.get()) {\n                     llvm::SetLinkage(llval, linkage);\n                 } else {\n@@ -2597,7 +2597,11 @@ pub fn register_fn_llvmty(ccx: &CrateContext,\n                           llfty: Type) -> ValueRef {\n     debug!(\"register_fn_llvmty id={} sym={}\", node_id, sym);\n \n-    let llfn = decl_fn(ccx, sym.index(&FullRange), cc, llfty, ty::FnConverging(ty::mk_nil(ccx.tcx())));\n+    let llfn = decl_fn(ccx,\n+                       sym.index(&FullRange),\n+                       cc,\n+                       llfty,\n+                       ty::FnConverging(ty::mk_nil(ccx.tcx())));\n     finish_register_fn(ccx, sp, sym, node_id, llfn);\n     llfn\n }"}, {"sha": "44890407d08699066da345888e462f1e43e357c1", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -414,7 +414,7 @@ impl<'tcx> TypeMap<'tcx> {\n                         unique_type_id.push_str(format!(\"[{}]\", len).index(&FullRange));\n                     }\n                     None => {\n-                        unique_type_id.push_str(\".index(&FullRange)\");\n+                        unique_type_id.push_str(\"[]\");\n                     }\n                 };\n "}, {"sha": "da19fc52c8c36a60ff7cf96b835d32c4cd6e0a9b", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -1369,13 +1369,13 @@ fn trans_struct<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let tcx = bcx.tcx();\n     with_field_tys(tcx, ty, Some(expr_id), |discr, field_tys| {\n-        let mut need_base: Vec<_> = repeat(true).take(field_tys.len()).collect();\n+        let mut need_base: Vec<bool> = repeat(true).take(field_tys.len()).collect();\n \n         let numbered_fields = fields.iter().map(|field| {\n             let opt_pos =\n                 field_tys.iter().position(|field_ty|\n                                           field_ty.name == field.ident.node.name);\n-            match opt_pos {\n+            let result = match opt_pos {\n                 Some(i) => {\n                     need_base[i] = false;\n                     (i, &*field.expr)\n@@ -1384,14 +1384,15 @@ fn trans_struct<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     tcx.sess.span_bug(field.span,\n                                       \"Couldn't find field in struct type\")\n                 }\n-            }\n+            };\n+            result\n         }).collect::<Vec<_>>();\n         let optbase = match base {\n             Some(base_expr) => {\n                 let mut leftovers = Vec::new();\n                 for (i, b) in need_base.iter().enumerate() {\n                     if *b {\n-                        leftovers.push((i, field_tys[i].mt.ty))\n+                        leftovers.push((i, field_tys[i].mt.ty));\n                     }\n                 }\n                 Some(StructBaseInfo {expr: base_expr,\n@@ -1408,7 +1409,7 @@ fn trans_struct<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         trans_adt(bcx,\n                   ty,\n                   discr,\n-                  numbered_fields.index(&FullRange),\n+                  numbered_fields.as_slice(),\n                   optbase,\n                   dest,\n                   Some(NodeInfo { id: expr_id, span: expr_span }))"}, {"sha": "c8112e03707f24eb638db1e229c057d4898020e4", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -748,7 +748,7 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         debug!(\"calling llrustfn = {}, t = {}\",\n                ccx.tn().val_to_string(llrustfn), t.repr(ccx.tcx()));\n         let attributes = base::get_fn_llvm_attributes(ccx, t);\n-        let llrust_ret_val = builder.call(llrustfn, llrust_args.index(&FullRange), Some(attributes));\n+        let llrust_ret_val = builder.call(llrustfn, llrust_args.as_slice(), Some(attributes));\n \n         // Get the return value where the foreign fn expects it.\n         let llforeign_ret_ty = match tys.fn_ty.ret_ty.cast {\n@@ -869,7 +869,7 @@ fn foreign_types_for_fn_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n            ty.repr(ccx.tcx()),\n            ccx.tn().types_to_str(llsig.llarg_tys.index(&FullRange)),\n            ccx.tn().type_to_string(llsig.llret_ty),\n-           ccx.tn().types_to_str(fn_ty.arg_tys.iter().map(|t| t.ty).collect::<Vec<_>>().index(&FullRange)),\n+           ccx.tn().types_to_str(fn_ty.arg_tys.iter().map(|t| t.ty).collect::<Vec<_>>().as_slice()),\n            ccx.tn().type_to_string(fn_ty.ret_ty.ty),\n            llsig.ret_def);\n "}, {"sha": "a2b1c32f0a5020332e9b08b8a2c07936ca07035b", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -556,7 +556,8 @@ pub fn instantiate_trait_ref<'tcx>(\n         _ => {\n             this.tcx().sess.span_fatal(\n                 ast_trait_ref.path.span,\n-                format!(\"`{}` is not a trait\", ast_trait_ref.path.user_string(this.tcx())).index(&FullRange));\n+                format!(\"`{}` is not a trait\",\n+                        ast_trait_ref.path.user_string(this.tcx())).index(&FullRange));\n         }\n     }\n }\n@@ -1069,8 +1070,12 @@ pub fn ast_ty_to_ty<'tcx>(\n             ast::TyObjectSum(ref ty, ref bounds) => {\n                 match ast_ty_to_trait_ref(this, rscope, &**ty, bounds.index(&FullRange)) {\n                     Ok((trait_ref, projection_bounds)) => {\n-                        trait_ref_to_object_type(this, rscope, ast_ty.span,\n-                                                 trait_ref, projection_bounds, bounds.index(&FullRange))\n+                        trait_ref_to_object_type(this,\n+                                                 rscope,\n+                                                 ast_ty.span,\n+                                                 trait_ref,\n+                                                 projection_bounds,\n+                                                 bounds.index(&FullRange))\n                     }\n                     Err(ErrorReported) => {\n                         this.tcx().types.err"}, {"sha": "dff216ac2935f99ff386fb77b2cca799adbc5385", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -195,7 +195,7 @@ fn confirm_builtin_call<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n     let arg_exprs: Vec<_> = arg_exprs.iter().collect(); // for some weird reason we take &[&P<...>].\n     check_argument_types(fcx,\n                          call_expr.span,\n-                         fn_sig.inputs[],\n+                         fn_sig.inputs.as_slice(),\n                          arg_exprs.as_slice(),\n                          AutorefArgs::No,\n                          fn_sig.variadic,"}, {"sha": "652540bde70a956aa74a092268650cb699eef8fe", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -563,7 +563,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                                 &**base_expr,\n                                 Some(&ty::AdjustDerefRef(base_adjustment.clone())));\n                         let index_expr_ty = self.fcx.expr_ty(&**index_expr);\n-                        \n+\n                         let result = check::try_index_step(\n                             self.fcx,\n                             MethodCall::expr(expr.id),\n@@ -640,7 +640,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                     self.span,\n                     format!(\"cannot upcast `{}` to `{}`\",\n                             source_trait_ref.repr(self.tcx()),\n-                            target_trait_def_id.repr(self.tcx()))[]);\n+                            target_trait_def_id.repr(self.tcx())).as_slice());\n             }\n         }\n     }"}, {"sha": "eb85654e68ec1540c238b067750f7379532c0323", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -3976,7 +3976,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n           callee::check_call(fcx, expr, &**callee, args.as_slice());\n       }\n       ast::ExprMethodCall(ident, ref tps, ref args) => {\n-        check_method_call(fcx, expr, ident, args.index(&FullRange), tps.index(&FullRange), lvalue_pref);\n+        check_method_call(fcx, expr, ident, args.as_slice(), tps.as_slice(), lvalue_pref);\n         let arg_tys = args.iter().map(|a| fcx.expr_ty(&**a));\n         let  args_err = arg_tys.fold(false,\n              |rest_err, a| {"}, {"sha": "7d52418a9db4fc9385232d2b4b6aba113bb43373", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -1318,7 +1318,7 @@ fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n     let param_ty = ty::ParamTy::new(space, index, param.ident.name);\n     let bounds = compute_bounds(ccx,\n                                 param_ty.to_ty(ccx.tcx),\n-                                param.bounds.index(&FullRange,\n+                                param.bounds.index(&FullRange),\n                                 SizedByDefault::Yes,\n                                 param.span);\n     let default = match param.default {"}, {"sha": "abc669729fe803645b1151dbf144736bfd1f6ceb", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -97,7 +97,7 @@ impl fmt::Show for clean::Generics {\n                 if i > 0 {\n                     try!(f.write_str(\", \"))\n                 }\n-                try!(f.write_str(tp.name[]));\n+                try!(f.write_str(tp.name.as_slice()));\n \n                 if tp.bounds.len() > 0 {\n                     try!(write!(f, \": {}\", TyParamBounds(tp.bounds.as_slice())));\n@@ -337,7 +337,7 @@ fn path<F, G>(w: &mut fmt::Formatter,\n         // This is a documented path, link to it!\n         Some((ref fqp, shortty)) if abs_root.is_some() => {\n             let mut url = String::from_str(abs_root.unwrap().as_slice());\n-            let to_link = fqp[..fqp.len() - 1];\n+            let to_link = &fqp[..(fqp.len() - 1)];\n             for component in to_link.iter() {\n                 url.push_str(component.as_slice());\n                 url.push_str(\"/\");\n@@ -433,7 +433,7 @@ impl fmt::Show for clean::Type {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             clean::TyParamBinder(id) => {\n-                f.write_str(cache().typarams[ast_util::local_def(id)][])\n+                f.write_str(cache().typarams[ast_util::local_def(id)].as_slice())\n             }\n             clean::Generic(ref name) => {\n                 f.write_str(name.as_slice())"}, {"sha": "a01fcd399521ad3d76a22d461b6b829b66d1bcf8", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -404,7 +404,7 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> io::IoResult<String>\n                     search_index.push(IndexItem {\n                         ty: shortty(item),\n                         name: item.name.clone().unwrap(),\n-                        path: fqp[..fqp.len() - 1].connect(\"::\"),\n+                        path: fqp[..(fqp.len() - 1)].connect(\"::\"),\n                         desc: shorter(item.doc_value()).to_string(),\n                         parent: Some(did),\n                     });\n@@ -559,7 +559,7 @@ fn write_shared(cx: &Context,\n         };\n \n         let mut mydst = dst.clone();\n-        for part in remote_path[..remote_path.len() - 1].iter() {\n+        for part in remote_path[..(remote_path.len() - 1)].iter() {\n             mydst.push(part.as_slice());\n             try!(mkdir(&mydst));\n         }\n@@ -842,7 +842,7 @@ impl DocFolder for Cache {\n                 clean::StructFieldItem(..) |\n                 clean::VariantItem(..) => {\n                     ((Some(*self.parent_stack.last().unwrap()),\n-                      Some(self.stack[..self.stack.len() - 1])),\n+                      Some(&self.stack[..(self.stack.len() - 1)])),\n                      false)\n                 }\n                 clean::MethodItem(..) => {\n@@ -853,13 +853,13 @@ impl DocFolder for Cache {\n                         let did = *last;\n                         let path = match self.paths.get(&did) {\n                             Some(&(_, ItemType::Trait)) =>\n-                                Some(self.stack[..self.stack.len() - 1]),\n+                                Some(&self.stack[..(self.stack.len() - 1)]),\n                             // The current stack not necessarily has correlation for\n                             // where the type was defined. On the other hand,\n                             // `paths` always has the right information if present.\n                             Some(&(ref fqp, ItemType::Struct)) |\n                             Some(&(ref fqp, ItemType::Enum)) =>\n-                                Some(fqp[..fqp.len() - 1]),\n+                                Some(&fqp[..(fqp.len() - 1)]),\n                             Some(..) => Some(self.stack.as_slice()),\n                             None => None\n                         };\n@@ -1185,7 +1185,7 @@ impl Context {\n                                            .collect::<String>();\n                 match cache().paths.get(&it.def_id) {\n                     Some(&(ref names, _)) => {\n-                        for name in names[..names.len() - 1].iter() {\n+                        for name in (&names[..(names.len() - 1)]).iter() {\n                             url.push_str(name.as_slice());\n                             url.push_str(\"/\");\n                         }\n@@ -2267,7 +2267,7 @@ fn item_macro(w: &mut fmt::Formatter, it: &clean::Item,\n               t: &clean::Macro) -> fmt::Result {\n     try!(w.write_str(highlight::highlight(t.source.as_slice(),\n                                           Some(\"macro\"),\n-                                          None)[]));\n+                                          None).as_slice()));\n     document(w, it)\n }\n "}, {"sha": "c520b6f4723c02bcf01a5bdce8e77ce18ce0275a", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 39, "deletions": 18, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -1124,15 +1124,15 @@ impl Json {\n     }\n }\n \n-impl<'a> ops::Index<&'a str>  for Json {\n+impl<'a> Index<&'a str>  for Json {\n     type Output = Json;\n \n     fn index(&self, idx: & &str) -> &Json {\n         self.find(*idx).unwrap()\n     }\n }\n \n-impl ops::Index<uint> for Json {\n+impl Index<uint> for Json {\n     type Output = Json;\n \n     fn index<'a>(&'a self, idx: &uint) -> &'a Json {\n@@ -1186,7 +1186,8 @@ pub struct Stack {\n }\n \n /// StackElements compose a Stack.\n-/// For example, StackElement::Key(\"foo\"), StackElement::Key(\"bar\"), StackElement::Index(3) and StackElement::Key(\"x\") are the\n+/// For example, StackElement::Key(\"foo\"), StackElement::Key(\"bar\"),\n+/// StackElement::Index(3) and StackElement::Key(\"x\") are the\n /// StackElements compositing the stack that represents foo.bar[3].x\n #[derive(PartialEq, Clone, Show)]\n pub enum StackElement<'l> {\n@@ -2505,12 +2506,12 @@ mod tests {\n     use super::ParserError::*;\n     use super::DecoderError::*;\n     use super::JsonEvent::*;\n-    use super::StackElement::*;\n     use super::{Json, from_str, DecodeResult, DecoderError, JsonEvent, Parser,\n                 StackElement, Stack, Decoder};\n-    use std::{i64, u64, f32, f64};\n+    use std::{i64, u64, f32, f64, io};\n     use std::collections::BTreeMap;\n     use std::num::Float;\n+    use std::ops::Index;\n     use std::string;\n \n     #[derive(RustcDecodable, Eq, PartialEq, Show)]\n@@ -3487,9 +3488,12 @@ mod tests {\n                     (U64Value(5),         vec![StackElement::Key(\"array\"), StackElement::Index(5)]),\n                   (ArrayEnd,              vec![StackElement::Key(\"array\")]),\n                   (ArrayStart,            vec![StackElement::Key(\"idents\")]),\n-                    (NullValue,           vec![StackElement::Key(\"idents\"), StackElement::Index(0)]),\n-                    (BooleanValue(true),  vec![StackElement::Key(\"idents\"), StackElement::Index(1)]),\n-                    (BooleanValue(false), vec![StackElement::Key(\"idents\"), StackElement::Index(2)]),\n+                    (NullValue,           vec![StackElement::Key(\"idents\"),\n+                                               StackElement::Index(0)]),\n+                    (BooleanValue(true),  vec![StackElement::Key(\"idents\"),\n+                                               StackElement::Index(1)]),\n+                    (BooleanValue(false), vec![StackElement::Key(\"idents\"),\n+                                               StackElement::Index(2)]),\n                   (ArrayEnd,              vec![StackElement::Key(\"idents\")]),\n                 (ObjectEnd,               vec![]),\n             ]\n@@ -3567,13 +3571,24 @@ mod tests {\n                 (ObjectStart,                   vec![]),\n                   (F64Value(1.0),               vec![StackElement::Key(\"a\")]),\n                   (ArrayStart,                  vec![StackElement::Key(\"b\")]),\n-                    (BooleanValue(true),        vec![StackElement::Key(\"b\"), StackElement::Index(0)]),\n-                    (StringValue(\"foo\\nbar\".to_string()),  vec![StackElement::Key(\"b\"), StackElement::Index(1)]),\n-                    (ObjectStart,               vec![StackElement::Key(\"b\"), StackElement::Index(2)]),\n-                      (ObjectStart,             vec![StackElement::Key(\"b\"), StackElement::Index(2), StackElement::Key(\"c\")]),\n-                        (NullValue,             vec![StackElement::Key(\"b\"), StackElement::Index(2), StackElement::Key(\"c\"), StackElement::Key(\"d\")]),\n-                      (ObjectEnd,               vec![StackElement::Key(\"b\"), StackElement::Index(2), StackElement::Key(\"c\")]),\n-                    (ObjectEnd,                 vec![StackElement::Key(\"b\"), StackElement::Index(2)]),\n+                    (BooleanValue(true),        vec![StackElement::Key(\"b\"),\n+                                                     StackElement::Index(0)]),\n+                    (StringValue(\"foo\\nbar\".to_string()),  vec![StackElement::Key(\"b\"),\n+                                                                StackElement::Index(1)]),\n+                    (ObjectStart,               vec![StackElement::Key(\"b\"),\n+                                                     StackElement::Index(2)]),\n+                      (ObjectStart,             vec![StackElement::Key(\"b\"),\n+                                                     StackElement::Index(2),\n+                                                     StackElement::Key(\"c\")]),\n+                        (NullValue,             vec![StackElement::Key(\"b\"),\n+                                                     StackElement::Index(2),\n+                                                     StackElement::Key(\"c\"),\n+                                                     StackElement::Key(\"d\")]),\n+                      (ObjectEnd,               vec![StackElement::Key(\"b\"),\n+                                                     StackElement::Index(2),\n+                                                     StackElement::Key(\"c\")]),\n+                    (ObjectEnd,                 vec![StackElement::Key(\"b\"),\n+                                                     StackElement::Index(2)]),\n                   (ArrayEnd,                    vec![StackElement::Key(\"b\")]),\n                 (ObjectEnd,                     vec![]),\n             ]\n@@ -3716,13 +3731,19 @@ mod tests {\n         stack.push_key(\"bar\".to_string());\n \n         assert!(stack.len() == 3);\n-        assert!(stack.is_equal_to(&[StackElement::Index(1), StackElement::Key(\"foo\"), StackElement::Key(\"bar\")]));\n+        assert!(stack.is_equal_to(&[StackElement::Index(1),\n+                                    StackElement::Key(\"foo\"),\n+                                    StackElement::Key(\"bar\")]));\n         assert!(stack.starts_with(&[StackElement::Index(1)]));\n         assert!(stack.starts_with(&[StackElement::Index(1), StackElement::Key(\"foo\")]));\n-        assert!(stack.starts_with(&[StackElement::Index(1), StackElement::Key(\"foo\"), StackElement::Key(\"bar\")]));\n+        assert!(stack.starts_with(&[StackElement::Index(1),\n+                                    StackElement::Key(\"foo\"),\n+                                    StackElement::Key(\"bar\")]));\n         assert!(stack.ends_with(&[StackElement::Key(\"bar\")]));\n         assert!(stack.ends_with(&[StackElement::Key(\"foo\"), StackElement::Key(\"bar\")]));\n-        assert!(stack.ends_with(&[StackElement::Index(1), StackElement::Key(\"foo\"), StackElement::Key(\"bar\")]));\n+        assert!(stack.ends_with(&[StackElement::Index(1),\n+                                  StackElement::Key(\"foo\"),\n+                                  StackElement::Key(\"bar\")]));\n         assert!(!stack.last_is_index());\n         assert!(stack.get(0) == StackElement::Index(1));\n         assert!(stack.get(1) == StackElement::Key(\"foo\"));"}, {"sha": "1c2855f67452973fe95f2d3e2625050dbb19c119", "filename": "src/libserialize/json_stage0.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibserialize%2Fjson_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibserialize%2Fjson_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson_stage0.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -211,6 +211,7 @@ use std::string;\n use std::ops;\n use unicode::str as unicode_str;\n use unicode::str::Utf16Item;\n+use std::ops::Index as IndexOp;\n \n use Encodable;\n \n@@ -386,7 +387,7 @@ fn escape_str(wr: &mut fmt::Writer, v: &str) -> fmt::Result {\n         };\n \n         if start < i {\n-            try!(wr.write_str(v[start..i]));\n+            try!(wr.write_str(v.index(&(start..i))));\n         }\n \n         try!(wr.write_str(escaped));\n@@ -395,7 +396,7 @@ fn escape_str(wr: &mut fmt::Writer, v: &str) -> fmt::Result {\n     }\n \n     if start != v.len() {\n-        try!(wr.write_str(v[start..]));\n+        try!(wr.write_str(v.index(&(start..))));\n     }\n \n     wr.write_str(\"\\\"\")\n@@ -404,7 +405,7 @@ fn escape_str(wr: &mut fmt::Writer, v: &str) -> fmt::Result {\n fn escape_char(writer: &mut fmt::Writer, v: char) -> fmt::Result {\n     let mut buf = [0; 4];\n     let n = v.encode_utf8(&mut buf).unwrap();\n-    let buf = unsafe { str::from_utf8_unchecked(buf[0..n]) };\n+    let buf = unsafe { str::from_utf8_unchecked(buf.index(&(0..n))) };\n     escape_str(writer, buf)\n }\n \n@@ -417,7 +418,7 @@ fn spaces(wr: &mut fmt::Writer, mut n: uint) -> fmt::Result {\n     }\n \n     if n > 0 {\n-        wr.write_str(BUF[..n])\n+        wr.write_str(BUF.index(&(..n)))\n     } else {\n         Ok(())\n     }\n@@ -624,7 +625,7 @@ impl<'a> ::Encoder<fmt::Error> for Encoder<'a> {\n             let mut check_encoder = Encoder::new(&mut buf);\n             try!(f(transmute(&mut check_encoder)));\n         }\n-        let out = str::from_utf8(buf[]).unwrap();\n+        let out = str::from_utf8(buf.index(&FullRange)).unwrap();\n         let needs_wrapping = out.char_at(0) != '\"' && out.char_at_reverse(out.len()) != '\"';\n         if needs_wrapping { try!(write!(self.writer, \"\\\"\")); }\n         try!(f(self));\n@@ -893,7 +894,7 @@ impl<'a> ::Encoder<fmt::Error> for PrettyEncoder<'a> {\n             let mut check_encoder = PrettyEncoder::new(&mut buf);\n             try!(f(transmute(&mut check_encoder)));\n         }\n-        let out = str::from_utf8(buf[]).unwrap();\n+        let out = str::from_utf8(buf.index(&FullRange)).unwrap();\n         let needs_wrapping = out.char_at(0) != '\"' && out.char_at_reverse(out.len()) != '\"';\n         if needs_wrapping { try!(write!(self.writer, \"\\\"\")); }\n         try!(f(self));\n@@ -1026,7 +1027,7 @@ impl Json {\n     /// Returns None otherwise.\n     pub fn as_string<'a>(&'a self) -> Option<&'a str> {\n         match *self {\n-            Json::String(ref s) => Some(s[]),\n+            Json::String(ref s) => Some(s.index(&FullRange)),\n             _ => None\n         }\n     }\n@@ -1220,7 +1221,8 @@ impl Stack {\n             InternalIndex(i) => Index(i),\n             InternalKey(start, size) => {\n                 Key(str::from_utf8(\n-                    self.str_buffer[start as uint .. start as uint + size as uint]).unwrap())\n+                    self.str_buffer.index(\n+                        &((start as uint) .. (start as uint + size as uint)))).unwrap())\n             }\n         }\n     }\n@@ -1262,7 +1264,7 @@ impl Stack {\n             Some(&InternalIndex(i)) => Some(Index(i)),\n             Some(&InternalKey(start, size)) => {\n                 Some(Key(str::from_utf8(\n-                    self.str_buffer[start as uint .. (start+size) as uint]\n+                    self.str_buffer.index(&(start as uint) .. ((start+size) as uint))\n                 ).unwrap()))\n             }\n         }\n@@ -2139,7 +2141,7 @@ impl ::Decoder<DecoderError> for Decoder {\n                 return Err(ExpectedError(\"String or Object\".to_string(), format!(\"{}\", json)))\n             }\n         };\n-        let idx = match names.iter().position(|n| *n == name[]) {\n+        let idx = match names.iter().position(|n| *n == name.index(&FullRange)) {\n             Some(idx) => idx,\n             None => return Err(UnknownVariantError(name))\n         };\n@@ -3352,7 +3354,7 @@ mod tests {\n         hm.insert(1, true);\n         let mut mem_buf = Vec::new();\n         write!(&mut mem_buf, \"{}\", super::as_pretty_json(&hm)).unwrap();\n-        let json_str = from_utf8(mem_buf[]).unwrap();\n+        let json_str = from_utf8(&mem_buf.index(&FullRange)).unwrap();\n         match from_str(json_str) {\n             Err(_) => panic!(\"Unable to parse json_str: {}\", json_str),\n             _ => {} // it parsed and we are good to go\n@@ -3368,7 +3370,7 @@ mod tests {\n         hm.insert(1, true);\n         let mut mem_buf = Vec::new();\n         write!(&mut mem_buf, \"{}\", super::as_pretty_json(&hm)).unwrap();\n-        let json_str = from_utf8(mem_buf[]).unwrap();\n+        let json_str = from_utf8(&mem_buf.index(&FullRange)).unwrap();\n         match from_str(json_str) {\n             Err(_) => panic!(\"Unable to parse json_str: {}\", json_str),\n             _ => {} // it parsed and we are good to go\n@@ -3408,7 +3410,7 @@ mod tests {\n             write!(&mut writer, \"{}\",\n                    super::as_pretty_json(&json).indent(i)).unwrap();\n \n-            let printed = from_utf8(writer[]).unwrap();\n+            let printed = from_utf8(&writer.index(&FullRange)).unwrap();\n \n             // Check for indents at each line\n             let lines: Vec<&str> = printed.lines().collect();"}, {"sha": "87ff5922c1a7edec4e2df2ddc5ccfdc15136e0d1", "filename": "src/libserialize/serialize_stage0.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibserialize%2Fserialize_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibserialize%2Fserialize_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize_stage0.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -14,6 +14,7 @@\n Core encoding and decoding interfaces.\n */\n \n+use std::ops::FullRange;\n use std::path;\n use std::rc::Rc;\n use std::cell::{Cell, RefCell};\n@@ -308,7 +309,7 @@ impl<E, S:Encoder<E>> Encodable<S, E> for str {\n \n impl<E, S:Encoder<E>> Encodable<S, E> for String {\n     fn encode(&self, s: &mut S) -> Result<(), E> {\n-        s.emit_str(self[])\n+        s.emit_str(self.index(&FullRange))\n     }\n }\n "}, {"sha": "c54a5ffa665f63bb96e69a018d27b3e3b8bc0170", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -472,49 +472,45 @@ mod test {\n \n         writer.write(&[0, 1]).unwrap();\n         let b: &[_] = &[];\n-        assert_eq!(writer.get_ref()[], b);\n+        assert_eq!(&writer.get_ref()[], b);\n \n         writer.write(&[2]).unwrap();\n         let b: &[_] = &[0, 1];\n-        assert_eq!(writer.get_ref()[], b);\n+        assert_eq!(&writer.get_ref()[], b);\n \n         writer.write(&[3]).unwrap();\n-        assert_eq!(writer.get_ref()[], b);\n+        assert_eq!(&writer.get_ref()[], b);\n \n         writer.flush().unwrap();\n         let a: &[_] = &[0, 1, 2, 3];\n-        assert_eq!(a, writer.get_ref()[]);\n+        assert_eq!(a, &writer.get_ref()[]);\n \n         writer.write(&[4]).unwrap();\n         writer.write(&[5]).unwrap();\n-        assert_eq!(a, writer.get_ref()[]);\n+        assert_eq!(a, &writer.get_ref()[]);\n \n         writer.write(&[6]).unwrap();\n         let a: &[_] = &[0, 1, 2, 3, 4, 5];\n-        assert_eq!(a,\n-                   writer.get_ref()[]);\n+        assert_eq!(a, &writer.get_ref()[]);\n \n         writer.write(&[7, 8]).unwrap();\n         let a: &[_] = &[0, 1, 2, 3, 4, 5, 6];\n-        assert_eq!(a,\n-                   writer.get_ref()[]);\n+        assert_eq!(a, &writer.get_ref()[]);\n \n         writer.write(&[9, 10, 11]).unwrap();\n         let a: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];\n-        assert_eq!(a,\n-                   writer.get_ref()[]);\n+        assert_eq!(a, &writer.get_ref()[]);\n \n         writer.flush().unwrap();\n-        assert_eq!(a,\n-                   writer.get_ref()[]);\n+        assert_eq!(a, &writer.get_ref()[]);\n     }\n \n     #[test]\n     fn test_buffered_writer_inner_flushes() {\n         let mut w = BufferedWriter::with_capacity(3, Vec::new());\n         w.write(&[0, 1]).unwrap();\n         let a: &[_] = &[];\n-        assert_eq!(a, w.get_ref()[]);\n+        assert_eq!(a, &w.get_ref()[]);\n         let w = w.into_inner();\n         let a: &[_] = &[0, 1];\n         assert_eq!(a, w.index(&FullRange));\n@@ -559,21 +555,21 @@ mod test {\n         let mut writer = LineBufferedWriter::new(Vec::new());\n         writer.write(&[0]).unwrap();\n         let b: &[_] = &[];\n-        assert_eq!(writer.get_ref()[], b);\n+        assert_eq!(&writer.get_ref()[], b);\n         writer.write(&[1]).unwrap();\n-        assert_eq!(writer.get_ref()[], b);\n+        assert_eq!(&writer.get_ref()[], b);\n         writer.flush().unwrap();\n         let b: &[_] = &[0, 1];\n-        assert_eq!(writer.get_ref()[], b);\n+        assert_eq!(&writer.get_ref()[], b);\n         writer.write(&[0, b'\\n', 1, b'\\n', 2]).unwrap();\n         let b: &[_] = &[0, 1, 0, b'\\n', 1, b'\\n'];\n-        assert_eq!(writer.get_ref()[], b);\n+        assert_eq!(&writer.get_ref()[], b);\n         writer.flush().unwrap();\n         let b: &[_] = &[0, 1, 0, b'\\n', 1, b'\\n', 2];\n-        assert_eq!(writer.get_ref()[], b);\n+        assert_eq!(&writer.get_ref()[], b);\n         writer.write(&[3, b'\\n']).unwrap();\n         let b: &[_] = &[0, 1, 0, b'\\n', 1, b'\\n', 2, 3, b'\\n'];\n-        assert_eq!(writer.get_ref()[], b);\n+        assert_eq!(&writer.get_ref()[], b);\n     }\n \n     #[test]"}, {"sha": "9e6af86925b8a2e802dd43baf47e50a7aed8d421", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -13,7 +13,7 @@\n //! Readers and Writers for in-memory buffers\n \n use cmp::min;\n-use prelude::Index;\n+use prelude::v1::Index;\n use option::Option::None;\n use result::Result::{Err, Ok};\n use io;\n@@ -391,9 +391,9 @@ impl<'a> Buffer for BufReader<'a> {\n #[cfg(test)]\n mod test {\n     extern crate \"test\" as test_crate;\n-    use prelude::v1::*;\n-\n-    use io::{SeekSet, SeekCur, SeekEnd};\n+    use io::{SeekSet, SeekCur, SeekEnd, Reader, Writer, Seek};\n+    use prelude::v1::{Ok, Err, range,  Vec, Buffer,  AsSlice, SliceExt};\n+    use prelude::v1::{IteratorExt, Index};\n     use io;\n     use iter::repeat;\n     use self::test_crate::Bencher;"}, {"sha": "5f77ab38d74533f065ee7de519ef7af733e26d92", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -752,12 +752,12 @@ impl Drop for Process {\n \n #[cfg(test)]\n mod tests {\n-    use prelude::v1::*;\n-\n+    use io::{Truncate, Write, TimedOut, timer, process, FileNotFound};\n+    use prelude::v1::{Ok, Err, range, drop, Some, None, Vec};\n+    use prelude::v1::{Path, String, Reader, Writer, Clone};\n+    use prelude::v1::{SliceExt, Str, StrExt, AsSlice, ToString, GenericPath};\n     use io::fs::PathExtensions;\n-    use io::process;\n     use io::timer::*;\n-    use io::{Truncate, Write, TimedOut, timer, FileNotFound};\n     use rt::running_on_valgrind;\n     use str;\n     use super::{CreatePipe};"}, {"sha": "87188c0d4a25ccb2a29580e5f0e43736e7a18ef1", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -68,7 +68,7 @@ use fmt;\n use iter::IteratorExt;\n use option::Option;\n use option::Option::{None, Some};\n-use prelude::{FullRange, Index};\n+use prelude::v1::{FullRange, Index};\n use str;\n use str::StrExt;\n use string::{String, CowString};"}, {"sha": "97545bc202278ec700306bf295e60332000da3d7", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -24,7 +24,7 @@ use iter::{AdditiveIterator, Extend};\n use iter::{Iterator, IteratorExt, Map, repeat};\n use mem;\n use option::Option::{self, Some, None};\n-use prelude::{FullRange, Index};\n+use prelude::v1::{FullRange, Index};\n use slice::{SliceExt, SliceConcatExt};\n use str::{SplitTerminator, FromStr, StrExt};\n use string::{String, ToString};\n@@ -337,8 +337,12 @@ impl GenericPath for Path {\n         Some(match self.sepidx_or_prefix_len() {\n             None if \"..\" == self.repr => self.repr.index(&FullRange),\n             None => \".\",\n-            Some((_,idxa,end)) if self.repr.index(&(idxa..end)) == \"..\" => self.repr.index(&FullRange),\n-            Some((idxb,_,end)) if self.repr.index(&(idxb..end)) == \"\\\\\" => self.repr.index(&FullRange),\n+            Some((_,idxa,end)) if self.repr.index(&(idxa..end)) == \"..\" => {\n+                self.repr.index(&FullRange)\n+            }\n+            Some((idxb,_,end)) if self.repr.index(&(idxb..end)) == \"\\\\\" => {\n+                self.repr.index(&FullRange)\n+            }\n             Some((0,idxa,_)) => self.repr.index(&(0..idxa)),\n             Some((idxb,idxa,_)) => {\n                 match self.prefix {"}, {"sha": "d0dcf77002ff4101997eaedcff36a85aae98c319", "filename": "src/libstd/prelude/v1.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibstd%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibstd%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude%2Fv1.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -14,7 +14,8 @@\n \n // Reexported core operators\n #[stable] #[doc(no_inline)] pub use kinds::{Copy, Send, Sized, Sync};\n-#[stable] #[doc(no_inline)] pub use ops::{Drop, Fn, FnMut, FnOnce};\n+#[stable] #[doc(no_inline)] pub use ops::{Drop, Fn, FnMut, FnOnce, FullRange};\n+#[unstable] #[doc(no_inline)] pub use ops::{Index, IndexMut};\n \n // Reexported functions\n #[stable] #[doc(no_inline)] pub use mem::drop;"}, {"sha": "eb76f13afe72167112570df8e31c92acf0574674", "filename": "src/libstd/sys/windows/backtrace.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -23,6 +23,7 @@\n \n use dynamic_lib::DynamicLibrary;\n use ffi;\n+use core::ops::Index;\n use intrinsics;\n use io::{IoResult, Writer};\n use libc;\n@@ -361,7 +362,7 @@ pub fn write(w: &mut Writer) -> IoResult<()> {\n             let bytes = unsafe { ffi::c_str_to_bytes(&ptr) };\n             match str::from_utf8(bytes) {\n                 Ok(s) => try!(demangle(w, s)),\n-                Err(..) => try!(w.write(bytes[..bytes.len()-1])),\n+                Err(..) => try!(w.write(bytes.index(&(..(bytes.len()-1))))),\n             }\n         }\n         try!(w.write(&['\\n' as u8]));"}, {"sha": "da3744d83f52eb7fbf13c0845e7bc4b05ddc174e", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -206,7 +206,7 @@ impl<D: Decoder<E>, E> Decodable<D, E> for Ident {\n #[cfg(not(stage0))]\n impl Decodable for Ident {\n     fn decode<D: Decoder>(d: &mut D) -> Result<Ident, D::Error> {\n-        Ok(str_to_ident(try!(d.read_str())[]))\n+        Ok(str_to_ident(try!(d.read_str()).index(&FullRange)))\n     }\n }\n "}, {"sha": "68bbde35ae61560d39c977fe84d3f9d5184a8b55", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -332,7 +332,7 @@ pub fn cfg_matches(diagnostic: &SpanHandler, cfgs: &[P<MetaItem>], cfg: &ast::Me\n             !cfg_matches(diagnostic, cfgs, &*mis[0])\n         }\n         ast::MetaList(ref pred, _) => {\n-            diagnostic.span_err(cfg.span, format!(\"invalid predicate `{}`\", pred).index(&FullRange));\n+            diagnostic.span_err(cfg.span, format!(\"invalid predicate `{}`\", pred).as_slice());\n             false\n         },\n         ast::MetaWord(_) | ast::MetaNameValue(..) => contains(cfgs, cfg),"}, {"sha": "440bdff14716990075840f353e002808a454596b", "filename": "src/libsyntax/ext/deriving/bounds.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -29,12 +29,13 @@ pub fn expand_deriving_bound<F>(cx: &mut ExtCtxt,\n                 \"Send\" | \"Sync\" => {\n                     return cx.span_err(span,\n                                        format!(\"{} is an unsafe trait and it \\\n-                                               should be implemented explicitly\", *tname).index(&FullRange))\n+                                                should be implemented explicitly\",\n+                                               *tname).as_slice())\n                 }\n                 ref tname => {\n                     cx.span_bug(span,\n                                 format!(\"expected built-in trait name but \\\n-                                         found {}\", *tname).index(&FullRange))\n+                                         found {}\", *tname).as_slice())\n                 }\n             }\n         },"}, {"sha": "581c60bdeb9436a910fd7cc32e720014db95782d", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -386,7 +386,7 @@ pub fn parse(sess: &ParseSess,\n                             new_ei.idx += 1u;\n                             //we specifically matched zero repeats.\n                             for idx in range(ei.match_cur, ei.match_cur + seq.num_captures) {\n-                                (&mut new_ei.matches[idx]).push(Rc::new(MatchedSeq(Vec::new(), sp)));\n+                                (&mut new_ei.matches[idx]).push(Rc::new(MatchedSeq(vec![], sp)));\n                             }\n \n                             cur_eis.push(new_ei);"}, {"sha": "2c36a02d44fe38feafee9fedd2f6c395526119c8", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -278,7 +278,7 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n                     _ => {}\n                 }\n \n-                if attr::contains_name(i.attrs[],\n+                if attr::contains_name(i.attrs.as_slice(),\n                                        \"unsafe_destructor\") {\n                     self.gate_feature(\"unsafe_destructor\",\n                                       i.span,\n@@ -287,7 +287,7 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n                                        removed in the future\");\n                 }\n \n-                if attr::contains_name(i.attrs[],\n+                if attr::contains_name(i.attrs.index(&FullRange),\n                                        \"old_orphan_check\") {\n                     self.gate_feature(\n                         \"old_orphan_check\",\n@@ -309,7 +309,8 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n                                and not portable across platforms\")\n         }\n \n-        let links_to_llvm = match attr::first_attr_value_str_by_name(i.attrs[], \"link_name\") {\n+        let links_to_llvm = match attr::first_attr_value_str_by_name(i.attrs.as_slice(),\n+                                                                     \"link_name\") {\n             Some(val) => val.get().starts_with(\"llvm.\"),\n             _ => false\n         };"}, {"sha": "d4650a4bb0395d79f012f619e32a9dfff49cb68c", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -1167,10 +1167,10 @@ mod test {\n \n         for &src in srcs.iter() {\n             let spans = get_spans_of_pat_idents(src);\n-            let Span{lo:lo,hi:hi,..} = spans[0];\n-            assert!(\"self\" == src[lo.to_uint()..hi.to_uint()],\n+            let Span{ lo, hi, .. } = spans[0];\n+            assert!(\"self\" == &src[lo.to_uint()..hi.to_uint()],\n                     \"\\\"{}\\\" != \\\"self\\\". src=\\\"{}\\\"\",\n-                    src[lo.to_uint()..hi.to_uint()], src)\n+                    &src[lo.to_uint()..hi.to_uint()], src)\n         }\n     }\n "}, {"sha": "0ecd098951f8d11339c32dd4eedc49a1455af680", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 27, "deletions": 11, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -1726,7 +1726,7 @@ impl<'a> Parser<'a> {\n \n                     token::Str_(s) => {\n                         (true,\n-                         LitStr(token::intern_and_get_ident(parse::str_lit(s.as_str()).index(&FullRange)),\n+                         LitStr(token::intern_and_get_ident(parse::str_lit(s.as_str()).as_slice()),\n                                 ast::CookedStr))\n                     }\n                     token::StrRaw(s, n) => {\n@@ -2538,16 +2538,26 @@ impl<'a> Parser<'a> {\n               token::OpenDelim(token::Bracket) => {\n                 let bracket_pos = self.span.lo;\n                 self.bump();\n-                if self.eat(&token::CloseDelim(token::Bracket)) {\n+\n+                let mut found_dotdot = false;\n+                if self.token == token::DotDot &&\n+                   self.look_ahead(1, |t| t == &token::CloseDelim(token::Bracket)) {\n+                    // Using expr[..], which is a mistake, should be expr[]\n+                    self.bump();\n+                    self.bump();\n+                    found_dotdot = true;\n+                }\n+\n+                if found_dotdot || self.eat(&token::CloseDelim(token::Bracket)) {\n                     // No expression, expand to a FullRange\n-                    let ix = {\n-                        hi = self.last_span.hi;\n-                        let range = ExprStruct(ident_to_path(mk_sp(lo, hi),\n-                                                             token::special_idents::FullRange),\n-                                               vec![],\n-                                               None);\n-                        self.mk_expr(bracket_pos, hi, range)\n-                    };\n+                    // FIXME(#20516) It would be better to use a lang item or\n+                    // something for FullRange.\n+                    hi = self.last_span.hi;\n+                    let range = ExprStruct(ident_to_path(mk_sp(lo, hi),\n+                                                         token::special_idents::FullRange),\n+                                           vec![],\n+                                           None);\n+                    let ix = self.mk_expr(bracket_pos, hi, range);\n                     let index = self.mk_index(e, ix);\n                     e = self.mk_expr(lo, hi, index)\n                 } else {\n@@ -2557,6 +2567,12 @@ impl<'a> Parser<'a> {\n                     let index = self.mk_index(e, ix);\n                     e = self.mk_expr(lo, hi, index)\n                 }\n+\n+                if found_dotdot {\n+                    self.span_err(e.span, \"incorrect slicing expression: `[..]`\");\n+                    self.span_note(e.span,\n+                                   \"use `&expr[]` to construct a slice of the whole of expr\");\n+                }\n               }\n \n               // A range expression, either `expr..expr` or `expr..`.\n@@ -4881,7 +4897,7 @@ impl<'a> Parser<'a> {\n             let token_str = self.this_token_to_string();\n             self.fatal(format!(\"expected `where`, or `{}` after struct \\\n                                 name, found `{}`\", \"{\",\n-                                token_str)[]);\n+                                token_str).index(&FullRange));\n         }\n \n         fields"}, {"sha": "f70ce54bb1c0a8228c33c9bcf25af55287321e2d", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -689,8 +689,7 @@ impl<D:Decoder<E>, E> Decodable<D, E> for InternedString {\n #[cfg(not(stage0))]\n impl Decodable for InternedString {\n     fn decode<D: Decoder>(d: &mut D) -> Result<InternedString, D::Error> {\n-        Ok(get_name(get_ident_interner().intern(\n-                    try!(d.read_str())[])))\n+        Ok(get_name(get_ident_interner().intern(try!(d.read_str()).index(&FullRange))))\n     }\n }\n \n@@ -704,7 +703,7 @@ impl<S:Encoder<E>, E> Encodable<S, E> for InternedString {\n #[cfg(not(stage0))]\n impl Encodable for InternedString {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_str(self.string[])\n+        s.emit_str(self.string.index(&FullRange))\n     }\n }\n "}, {"sha": "87dcc9e70f46184491034f334fd9a9374cb72cb8", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 26, "deletions": 27, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -1537,35 +1537,34 @@ impl<'a> State<'a> {\n \n             ast::ExprStruct(ref path, ref fields, ref wth) => {\n                 try!(self.print_path(path, true));\n-                if fields.is_empty() && wth.is_none() {\n-                    return;\n-                }\n-                try!(word(&mut self.s, \"{\"));\n-                try!(self.commasep_cmnt(\n-                    Consistent,\n-                    fields.index(&FullRange),\n-                    |s, field| {\n-                        try!(s.ibox(indent_unit));\n-                        try!(s.print_ident(field.ident.node));\n-                        try!(s.word_space(\":\"));\n-                        try!(s.print_expr(&*field.expr));\n-                        s.end()\n-                    },\n-                    |f| f.span));\n-                match *wth {\n-                    Some(ref expr) => {\n-                        try!(self.ibox(indent_unit));\n-                        if !fields.is_empty() {\n-                            try!(word(&mut self.s, \",\"));\n-                            try!(space(&mut self.s));\n+                if !(fields.is_empty() && wth.is_none()) {\n+                    try!(word(&mut self.s, \"{\"));\n+                    try!(self.commasep_cmnt(\n+                        Consistent,\n+                        fields.index(&FullRange),\n+                        |s, field| {\n+                            try!(s.ibox(indent_unit));\n+                            try!(s.print_ident(field.ident.node));\n+                            try!(s.word_space(\":\"));\n+                            try!(s.print_expr(&*field.expr));\n+                            s.end()\n+                        },\n+                        |f| f.span));\n+                    match *wth {\n+                        Some(ref expr) => {\n+                            try!(self.ibox(indent_unit));\n+                            if !fields.is_empty() {\n+                                try!(word(&mut self.s, \",\"));\n+                                try!(space(&mut self.s));\n+                            }\n+                            try!(word(&mut self.s, \"..\"));\n+                            try!(self.print_expr(&**expr));\n+                            try!(self.end());\n                         }\n-                        try!(word(&mut self.s, \"..\"));\n-                        try!(self.print_expr(&**expr));\n-                        try!(self.end());\n+                        _ => try!(word(&mut self.s, \",\")),\n                     }\n-                    _ => try!(word(&mut self.s, \",\")),\n+                    try!(word(&mut self.s, \"}\"));\n                 }\n-                try!(word(&mut self.s, \"}\"));\n             }\n             ast::ExprTup(ref exprs) => {\n                 try!(self.popen());\n@@ -2781,7 +2780,7 @@ impl<'a> State<'a> {\n                              format!(\"-{}\", istr).index(&FullRange))\n                     }\n                     ast::UnsignedIntLit(ut) => {\n-                        word(&mut self.s, ast_util::uint_ty_to_string(ut, Some(i)).index(&FullRange))\n+                        word(&mut self.s, ast_util::uint_ty_to_string(ut, Some(i)).as_slice())\n                     }\n                     ast::UnsuffixedIntLit(ast::Plus) => {\n                         word(&mut self.s, format!(\"{}\", i).index(&FullRange))"}, {"sha": "8ce365f765d851d5eeddb3e73f41b6bbd922ed4a", "filename": "src/test/bench/shootout-fannkuch-redux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -105,7 +105,7 @@ impl Perm {\n             let d = idx / self.fact[i] as i32;\n             self.cnt[i] = d;\n             idx %= self.fact[i] as i32;\n-            for (place, val) in pp.iter_mut().zip(self.perm.p[..i+1].iter()) {\n+            for (place, val) in pp.iter_mut().zip(self.perm.p[..(i+1)].iter()) {\n                 *place = (*val) as u8\n             }\n "}, {"sha": "29994f45d3af27b3726903ce8658756e49b638a7", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -99,7 +99,7 @@ fn make_fasta<W: Writer, I: Iterator<Item=u8>>(\n         }\n         n -= nb;\n         line[nb] = '\\n' as u8;\n-        try!(wr.write(line[..nb+1]));\n+        try!(wr.write(&line[..(nb+1)]));\n     }\n     Ok(())\n }"}, {"sha": "39c839ba114033da244ef9f882beee9e9a1656b7", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -101,11 +101,11 @@ fn windows_with_carry<F>(bb: &[u8], nn: uint, mut it: F) -> Vec<u8> where\n \n    let len = bb.len();\n    while ii < len - (nn - 1u) {\n-      it(bb[ii..ii+nn]);\n+      it(&bb[ii..(ii+nn)]);\n       ii += 1u;\n    }\n \n-   return bb[len - (nn - 1u)..len].to_vec();\n+   return bb[(len - (nn - 1u))..len].to_vec();\n }\n \n fn make_sequence_processor(sz: uint,"}, {"sha": "efb7a5253ed3df8b3160d21ca1b2503349baa04c", "filename": "src/test/compile-fail/borrowck-loan-vec-content.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-vec-content.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-vec-content.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-vec-content.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -17,12 +17,12 @@ fn takes_imm_elt<F>(_v: &int, f: F) where F: FnOnce() {\n }\n \n fn has_mut_vec_and_does_not_try_to_change_it() {\n-    let mut v = vec!(1, 2, 3);\n+    let mut v: Vec<int> = vec!(1, 2, 3);\n     takes_imm_elt(&v[0], || {})\n }\n \n fn has_mut_vec_but_tries_to_change_it() {\n-    let mut v = vec!(1, 2, 3);\n+    let mut v: Vec<int> = vec!(1, 2, 3);\n     takes_imm_elt(\n         &v[0],\n         || { //~ ERROR cannot borrow `v` as mutable"}, {"sha": "e5edb2358f8e15b29415ff0fa41af6055bf92aa3", "filename": "src/test/compile-fail/indexing-requires-a-uint.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Ftest%2Fcompile-fail%2Findexing-requires-a-uint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Ftest%2Fcompile-fail%2Findexing-requires-a-uint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Findexing-requires-a-uint.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -13,7 +13,8 @@\n \n fn main() {\n     fn bar<T>(_: T) {}\n-    [0][0u8]; //~ ERROR: mismatched types\n+    [0][0u8]; //~ ERROR: the trait `core::ops::Index<u8>` is not implemented\n+    //~^ ERROR: the trait `core::ops::Index<u8>` is not implemented\n \n     [0][0]; // should infer to be a uint\n "}, {"sha": "bbceb00abd39d3e728da025dbc134b1b218fe863", "filename": "src/test/compile-fail/integral-indexing.rs", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Ftest%2Fcompile-fail%2Fintegral-indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Ftest%2Fcompile-fail%2Fintegral-indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fintegral-indexing.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -11,16 +11,24 @@\n pub fn main() {\n     let v: Vec<int> = vec!(0, 1, 2, 3, 4, 5);\n     let s: String = \"abcdef\".to_string();\n-    assert_eq!(v.as_slice()[3u], 3);\n-    assert_eq!(v.as_slice()[3u8], 3); //~ ERROR: mismatched types\n-    assert_eq!(v.as_slice()[3i8], 3); //~ ERROR: mismatched types\n-    assert_eq!(v.as_slice()[3u32], 3); //~ ERROR: mismatched types\n-    assert_eq!(v.as_slice()[3i32], 3); //~ ERROR: mismatched types\n-    println!(\"{}\", v.as_slice()[3u8]); //~ ERROR: mismatched types\n-    assert_eq!(s.as_bytes()[3u], 'd' as u8);\n-    assert_eq!(s.as_bytes()[3u8], 'd' as u8); //~ ERROR: mismatched types\n-    assert_eq!(s.as_bytes()[3i8], 'd' as u8); //~ ERROR: mismatched types\n-    assert_eq!(s.as_bytes()[3u32], 'd' as u8); //~ ERROR: mismatched types\n-    assert_eq!(s.as_bytes()[3i32], 'd' as u8); //~ ERROR: mismatched types\n-    println!(\"{}\", s.as_bytes()[3u8]); //~ ERROR: mismatched types\n+    v.as_slice()[3u];\n+    v.as_slice()[3];\n+    v.as_slice()[3u8];  //~ERROR the trait `core::ops::Index<u8>` is not implemented\n+    //~^ ERROR the trait `core::ops::Index<u8>` is not implemented\n+    v.as_slice()[3i8];  //~ERROR the trait `core::ops::Index<i8>` is not implemented\n+    //~^ ERROR the trait `core::ops::Index<i8>` is not implemented\n+    v.as_slice()[3u32]; //~ERROR the trait `core::ops::Index<u32>` is not implemented\n+    //~^ ERROR the trait `core::ops::Index<u32>` is not implemented\n+    v.as_slice()[3i32]; //~ERROR the trait `core::ops::Index<i32>` is not implemented\n+    //~^ ERROR the trait `core::ops::Index<i32>` is not implemented\n+    s.as_bytes()[3u];\n+    s.as_bytes()[3];\n+    s.as_bytes()[3u8];  //~ERROR the trait `core::ops::Index<u8>` is not implemented\n+    //~^ERROR the trait `core::ops::Index<u8>` is not implemented\n+    s.as_bytes()[3i8];  //~ERROR the trait `core::ops::Index<i8>` is not implemented\n+    //~^ERROR the trait `core::ops::Index<i8>` is not implemented\n+    s.as_bytes()[3u32]; //~ERROR the trait `core::ops::Index<u32>` is not implemented\n+    //~^ERROR the trait `core::ops::Index<u32>` is not implemented\n+    s.as_bytes()[3i32]; //~ERROR the trait `core::ops::Index<i32>` is not implemented\n+    //~^ERROR the trait `core::ops::Index<i32>` is not implemented\n }"}, {"sha": "327f50ee059f961bdb917a0b2ecda6b8c259dccc", "filename": "src/test/compile-fail/issue-16709.rs", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/791f5456859845a4a1814eca45aa900fc62d4e44/src%2Ftest%2Fcompile-fail%2Fissue-16709.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791f5456859845a4a1814eca45aa900fc62d4e44/src%2Ftest%2Fcompile-fail%2Fissue-16709.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-16709.rs?ref=791f5456859845a4a1814eca45aa900fc62d4e44", "patch": "@@ -1,25 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::ptr;\n-use std::raw;\n-\n-trait Slice {}\n-\n-fn main() {\n-  unsafe {\n-    let nil: *const u8 = ptr::null();\n-    let slice: raw::Slice<u8> =\n-      Slice { //~ ERROR use of trait `Slice` as a struct constructor [E0159]\n-        data: nil,\n-        len:  0,\n-      };\n-  }\n-}"}, {"sha": "a03693b5fada086f4a26d6644cf12cfcea3cc26c", "filename": "src/test/compile-fail/slice-2.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Ftest%2Fcompile-fail%2Fslice-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Ftest%2Fcompile-fail%2Fslice-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fslice-2.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -16,8 +16,8 @@ struct Foo;\n \n fn main() {\n     let x = Foo;\n-    &x[]; //~ ERROR cannot take a slice of a value with type `Foo`\n-    &x[Foo..]; //~ ERROR cannot take a slice of a value with type `Foo`\n-    &x[0..Foo]; //~ ERROR cannot take a slice of a value with type `Foo`\n-    &x[Foo..Foo]; //~ ERROR cannot take a slice of a value with type `Foo`\n+    &x[]; //~ ERROR cannot index a value of type `Foo`\n+    &x[Foo..]; //~ ERROR cannot index a value of type `Foo`\n+    &x[..Foo]; //~ ERROR cannot index a value of type `Foo`\n+    &x[Foo..Foo]; //~ ERROR cannot index a value of type `Foo`\n }"}, {"sha": "1dedb0cf888e56ff5cce65856f57094e7725465c", "filename": "src/test/compile-fail/slice-mut-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Ftest%2Fcompile-fail%2Fslice-mut-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Ftest%2Fcompile-fail%2Fslice-mut-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fslice-mut-2.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -16,5 +16,5 @@ fn main() {\n     let x: &[int] = &[1, 2, 3, 4, 5];\n     // Can't mutably slice an immutable slice\n     let slice: &mut [int] = &mut [0, 1];\n-    &mut x[2..4] = slice; //~ ERROR cannot borrow\n+    let _ = &mut x[2..4]; //~ERROR cannot borrow immutable dereference of `&`-pointer `*x` as mutabl\n }"}, {"sha": "f0f525a553576e7de57f9e66d2b46fa6f95b582c", "filename": "src/test/compile-fail/slice-mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Ftest%2Fcompile-fail%2Fslice-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Ftest%2Fcompile-fail%2Fslice-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fslice-mut.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -15,5 +15,5 @@\n fn main() {\n     let x: &[int] = &[1, 2, 3, 4, 5];\n     // Immutable slices are not mutable.\n-    let y: &mut[_] = &x[2..4]; //~ ERROR cannot borrow immutable dereference of `&`-pointer as mutabl\n+    let y: &mut[_] = &x[2..4]; //~ ERROR cannot borrow immutable dereference of `&`-pointer as mutab\n }"}, {"sha": "ddd2a4eeedf76f4f6b5107bcd8ed5f27a2737e2e", "filename": "src/test/compile-fail/str-idx.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Ftest%2Fcompile-fail%2Fstr-idx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Ftest%2Fcompile-fail%2Fstr-idx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstr-idx.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -10,5 +10,6 @@\n \n pub fn main() {\n     let s: &str = \"hello\";\n-    let c: u8 = s[4]; //~ ERROR cannot index a value of type `&str`\n+    let c: u8 = s[4]; //~ ERROR the trait `core::ops::Index<_>` is not implemented\n+    //~^ ERROR the trait `core::ops::Index<_>` is not implemented\n }"}, {"sha": "8acda1750069257f80cb09360568b269d451f7c2", "filename": "src/test/run-pass/issue-17503.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Ftest%2Frun-pass%2Fissue-17503.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Ftest%2Frun-pass%2Fissue-17503.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-17503.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -15,7 +15,7 @@ fn main() {\n     let ss: &&[int] = &s;\n     let sss: &&&[int] = &ss;\n \n-    println!(\"{}\", s.index(&(0..3)));\n-    println!(\"{}\", ss.index(&(3..)));\n-    println!(\"{}\", sss.index(&(2..4)));\n+    println!(\"{}\", &s[0..3]);\n+    println!(\"{}\", &ss[3..]);\n+    println!(\"{}\", &sss[2..4]);\n }"}, {"sha": "5ed9729c1425861cf9ed4a4530ef5932c1e59fe7", "filename": "src/test/run-pass/issue-3888-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Ftest%2Frun-pass%2Fissue-3888-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Ftest%2Frun-pass%2Fissue-3888-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3888-2.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -11,7 +11,7 @@\n #![feature(slicing_syntax)]\n \n fn vec_peek<'r, T>(v: &'r [T]) -> &'r [T] {\n-    v.index(&(1..5))\n+    &v[1..5]\n }\n \n pub fn main() {}"}, {"sha": "2581069d29b05c0b399b53530d579b987aeab2f3", "filename": "src/test/run-pass/issue-4464.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Ftest%2Frun-pass%2Fissue-4464.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Ftest%2Frun-pass%2Fissue-4464.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4464.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -10,6 +10,6 @@\n \n #![feature(slicing_syntax)]\n \n-fn broken(v: &[u8], i: uint, j: uint) -> &[u8] { v.index(&(i..j)) }\n+fn broken(v: &[u8], i: uint, j: uint) -> &[u8] { &v[i..j] }\n \n pub fn main() {}"}, {"sha": "0c19286921a99656c7c6b1eeaa6593cbae875d87", "filename": "src/test/run-pass/issue-8898.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Ftest%2Frun-pass%2Fissue-8898.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Ftest%2Frun-pass%2Fissue-8898.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-8898.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -18,7 +18,7 @@ pub fn main() {\n     let abc = [1i, 2, 3];\n     let tf = [true, false];\n     let x  = [(), ()];\n-    let slice = x.index(&(0..1));\n+    let slice = &x[0..1];\n \n     assert_repr_eq(&abc[], \"[1, 2, 3]\".to_string());\n     assert_repr_eq(&tf[], \"[true, false]\".to_string());"}, {"sha": "ebe6e974c26cf70ac598a329a2dd94d574bf94c6", "filename": "src/test/run-pass/slice-panic-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Ftest%2Frun-pass%2Fslice-panic-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Ftest%2Frun-pass%2Fslice-panic-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fslice-panic-1.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Test that is a slicing expr.index(&(..)) fails, the correct cleanups happen.\n+// Test that if a slicing expr[..] fails, the correct cleanups happen.\n \n #![feature(slicing_syntax)]\n \n@@ -24,7 +24,7 @@ impl Drop for Foo {\n \n fn foo() {\n     let x: &[_] = &[Foo, Foo];\n-    x.index(&(3..4));\n+    &x[3..4];\n }\n \n fn main() {"}, {"sha": "6bbd1ac7b2d9f0e658a9521a8d7bdd693c3b6e99", "filename": "src/test/run-pass/slice-panic-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Ftest%2Frun-pass%2Fslice-panic-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Ftest%2Frun-pass%2Fslice-panic-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fslice-panic-2.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Test that is a slicing expr.index(&(..)) fails, the correct cleanups happen.\n+// Test that if a slicing expr[..] fails, the correct cleanups happen.\n \n #![feature(slicing_syntax)]\n \n@@ -28,7 +28,7 @@ fn bar() -> uint {\n \n fn foo() {\n     let x: &[_] = &[Foo, Foo];\n-    x[3..bar()];\n+    &x[3..bar()];\n }\n \n fn main() {"}, {"sha": "fca7daeb07d6f8c992508d8225ccfd91c08d942e", "filename": "src/test/run-pass/slice.rs", "status": "modified", "additions": 33, "deletions": 11, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Ftest%2Frun-pass%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7f7a5fb8919c6a382f9acd1e921c51f807f625/src%2Ftest%2Frun-pass%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fslice.rs?ref=0c7f7a5fb8919c6a382f9acd1e921c51f807f625", "patch": "@@ -11,6 +11,7 @@\n // Test slicing sugar.\n \n #![feature(slicing_syntax)]\n+#![feature(associated_types)]\n \n extern crate core;\n use core::ops::{Index, Range, RangeTo, RangeFrom, FullRange};\n@@ -19,49 +20,70 @@ static mut COUNT: uint = 0;\n \n struct Foo;\n \n-impl Slice<Foo, Foo> for Foo {\n-    fn as_slice_<'a>(&'a self) -> &'a Foo {\n+impl Index<Range<Foo>> for Foo {\n+    type Output = Foo;\n+    fn index(&self, index: &Range<Foo>) -> &Foo {\n         unsafe { COUNT += 1; }\n         self\n     }\n-    fn slice_from_or_fail<'a>(&'a self, _from: &Foo) -> &'a Foo {\n+}\n+impl Index<RangeTo<Foo>> for Foo {\n+    type Output = Foo;\n+    fn index(&self, index: &RangeTo<Foo>) -> &Foo {\n         unsafe { COUNT += 1; }\n         self\n     }\n-    fn slice_to_or_fail<'a>(&'a self, _to: &Foo) -> &'a Foo {\n+}\n+impl Index<RangeFrom<Foo>> for Foo {\n+    type Output = Foo;\n+    fn index(&self, index: &RangeFrom<Foo>) -> &Foo {\n         unsafe { COUNT += 1; }\n         self\n     }\n-    fn slice_or_fail<'a>(&'a self, _from: &Foo, _to: &Foo) -> &'a Foo {\n+}\n+impl Index<FullRange> for Foo {\n+    type Output = Foo;\n+    fn index(&self, _index: &FullRange) -> &Foo {\n         unsafe { COUNT += 1; }\n         self\n     }\n }\n \n-impl SliceMut<Foo, Foo> for Foo {\n-    fn as_mut_slice_<'a>(&'a mut self) -> &'a mut Foo {\n+impl IndexMut<Range<Foo>> for Foo {\n+    type Output = Foo;\n+    fn index_mut(&mut self, index: &Range<Foo>) -> &mut Foo {\n         unsafe { COUNT += 1; }\n         self\n     }\n-    fn slice_from_or_fail_mut<'a>(&'a mut self, _from: &Foo) -> &'a mut Foo {\n+}\n+impl IndexMut<RangeTo<Foo>> for Foo {\n+    type Output = Foo;\n+    fn index_mut(&mut self, index: &RangeTo<Foo>) -> &mut Foo {\n         unsafe { COUNT += 1; }\n         self\n     }\n-    fn slice_to_or_fail_mut<'a>(&'a mut self, _to: &Foo) -> &'a mut Foo {\n+}\n+impl IndexMut<RangeFrom<Foo>> for Foo {\n+    type Output = Foo;\n+    fn index_mut(&mut self, index: &RangeFrom<Foo>) -> &mut Foo {\n         unsafe { COUNT += 1; }\n         self\n     }\n-    fn slice_or_fail_mut<'a>(&'a mut self, _from: &Foo, _to: &Foo) -> &'a mut Foo {\n+}\n+impl IndexMut<FullRange> for Foo {\n+    type Output = Foo;\n+    fn index_mut(&mut self, _index: &FullRange) -> &mut Foo {\n         unsafe { COUNT += 1; }\n         self\n     }\n }\n \n+\n fn main() {\n     let mut x = Foo;\n     &x[];\n     &x[Foo..];\n-    &x[0..Foo];\n+    &x[..Foo];\n     &x[Foo..Foo];\n     &mut x[];\n     &mut x[Foo..];"}]}