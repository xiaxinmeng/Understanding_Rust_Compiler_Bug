{"sha": "7b0113b3d588fdc1f95eca1286fb2f6881abe65a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiMDExM2IzZDU4OGZkYzFmOTVlY2ExMjg2ZmIyZjY4ODFhYmU2NWE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-07-01T10:30:17Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-07-01T10:30:17Z"}, "message": "Move parser specific tests utils to parser tests", "tree": {"sha": "9304d504567e48cee870644701f8305c418e77ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9304d504567e48cee870644701f8305c418e77ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7b0113b3d588fdc1f95eca1286fb2f6881abe65a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7b0113b3d588fdc1f95eca1286fb2f6881abe65a", "html_url": "https://github.com/rust-lang/rust/commit/7b0113b3d588fdc1f95eca1286fb2f6881abe65a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7b0113b3d588fdc1f95eca1286fb2f6881abe65a/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a9db3d53a0997010f8d3f9c9b14636bef3754f8b", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9db3d53a0997010f8d3f9c9b14636bef3754f8b", "html_url": "https://github.com/rust-lang/rust/commit/a9db3d53a0997010f8d3f9c9b14636bef3754f8b"}], "stats": {"total": 206, "additions": 104, "deletions": 102}, "files": [{"sha": "f14f23628a027dfbb35df296d4e85a28e178c635", "filename": "crates/ra_syntax/src/tests.rs", "status": "modified", "additions": 99, "deletions": 1, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/7b0113b3d588fdc1f95eca1286fb2f6881abe65a/crates%2Fra_syntax%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0113b3d588fdc1f95eca1286fb2f6881abe65a/crates%2Fra_syntax%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Ftests.rs?ref=7b0113b3d588fdc1f95eca1286fb2f6881abe65a", "patch": "@@ -1,9 +1,11 @@\n use std::{\n+    env,\n     fmt::Write,\n+    fs,\n     path::{Component, Path, PathBuf},\n };\n \n-use test_utils::{collect_rust_files, dir_tests, project_dir, read_text};\n+use test_utils::{assert_eq_text, project_dir};\n \n use crate::{fuzz, tokenize, SourceFile, SyntaxError, TextRange, TextSize, Token};\n \n@@ -200,3 +202,99 @@ where\n         }\n     });\n }\n+\n+/// Calls callback `f` with input code and file paths for each `.rs` file in `test_data_dir`\n+/// subdirectories defined by `paths`.\n+///\n+/// If the content of the matching output file differs from the output of `f()`\n+/// the test will fail.\n+///\n+/// If there is no matching output file it will be created and filled with the\n+/// output of `f()`, but the test will fail.\n+fn dir_tests<F>(test_data_dir: &Path, paths: &[&str], outfile_extension: &str, f: F)\n+where\n+    F: Fn(&str, &Path) -> String,\n+{\n+    for (path, input_code) in collect_rust_files(test_data_dir, paths) {\n+        let actual = f(&input_code, &path);\n+        let path = path.with_extension(outfile_extension);\n+        if !path.exists() {\n+            println!(\"\\nfile: {}\", path.display());\n+            println!(\"No .txt file with expected result, creating...\\n\");\n+            println!(\"{}\\n{}\", input_code, actual);\n+            fs::write(&path, &actual).unwrap();\n+            panic!(\"No expected result\");\n+        }\n+        let expected = read_text(&path);\n+        assert_equal_text(&expected, &actual, &path);\n+    }\n+}\n+\n+/// Collects all `.rs` files from `dir` subdirectories defined by `paths`.\n+fn collect_rust_files(root_dir: &Path, paths: &[&str]) -> Vec<(PathBuf, String)> {\n+    paths\n+        .iter()\n+        .flat_map(|path| {\n+            let path = root_dir.to_owned().join(path);\n+            rust_files_in_dir(&path).into_iter()\n+        })\n+        .map(|path| {\n+            let text = read_text(&path);\n+            (path, text)\n+        })\n+        .collect()\n+}\n+\n+/// Collects paths to all `.rs` files from `dir` in a sorted `Vec<PathBuf>`.\n+fn rust_files_in_dir(dir: &Path) -> Vec<PathBuf> {\n+    let mut acc = Vec::new();\n+    for file in fs::read_dir(&dir).unwrap() {\n+        let file = file.unwrap();\n+        let path = file.path();\n+        if path.extension().unwrap_or_default() == \"rs\" {\n+            acc.push(path);\n+        }\n+    }\n+    acc.sort();\n+    acc\n+}\n+\n+/// Asserts that `expected` and `actual` strings are equal. If they differ only\n+/// in trailing or leading whitespace the test won't fail and\n+/// the contents of `actual` will be written to the file located at `path`.\n+fn assert_equal_text(expected: &str, actual: &str, path: &Path) {\n+    if expected == actual {\n+        return;\n+    }\n+    let dir = project_dir();\n+    let pretty_path = path.strip_prefix(&dir).unwrap_or_else(|_| path);\n+    if expected.trim() == actual.trim() {\n+        println!(\"whitespace difference, rewriting\");\n+        println!(\"file: {}\\n\", pretty_path.display());\n+        fs::write(path, actual).unwrap();\n+        return;\n+    }\n+    if env::var(\"UPDATE_EXPECTATIONS\").is_ok() {\n+        println!(\"rewriting {}\", pretty_path.display());\n+        fs::write(path, actual).unwrap();\n+        return;\n+    }\n+    assert_eq_text!(expected, actual, \"file: {}\", pretty_path.display());\n+}\n+\n+/// Read file and normalize newlines.\n+///\n+/// `rustc` seems to always normalize `\\r\\n` newlines to `\\n`:\n+///\n+/// ```\n+/// let s = \"\n+/// \";\n+/// assert_eq!(s.as_bytes(), &[10]);\n+/// ```\n+///\n+/// so this should always be correct.\n+fn read_text(path: &Path) -> String {\n+    fs::read_to_string(path)\n+        .unwrap_or_else(|_| panic!(\"File at {:?} should be valid\", path))\n+        .replace(\"\\r\\n\", \"\\n\")\n+}"}, {"sha": "fba5f42810d6baccb3b8fc835d77419ed0dbbdc6", "filename": "crates/test_utils/src/lib.rs", "status": "modified", "additions": 5, "deletions": 101, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/7b0113b3d588fdc1f95eca1286fb2f6881abe65a/crates%2Ftest_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0113b3d588fdc1f95eca1286fb2f6881abe65a/crates%2Ftest_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Flib.rs?ref=7b0113b3d588fdc1f95eca1286fb2f6881abe65a", "patch": "@@ -13,7 +13,7 @@ mod fixture;\n use std::{\n     convert::{TryFrom, TryInto},\n     env, fs,\n-    path::{Path, PathBuf},\n+    path::PathBuf,\n };\n \n use serde_json::Value;\n@@ -299,85 +299,6 @@ pub fn find_mismatch<'a>(expected: &'a Value, actual: &'a Value) -> Option<(&'a\n     }\n }\n \n-/// Calls callback `f` with input code and file paths for each `.rs` file in `test_data_dir`\n-/// subdirectories defined by `paths`.\n-///\n-/// If the content of the matching output file differs from the output of `f()`\n-/// the test will fail.\n-///\n-/// If there is no matching output file it will be created and filled with the\n-/// output of `f()`, but the test will fail.\n-pub fn dir_tests<F>(test_data_dir: &Path, paths: &[&str], outfile_extension: &str, f: F)\n-where\n-    F: Fn(&str, &Path) -> String,\n-{\n-    for (path, input_code) in collect_rust_files(test_data_dir, paths) {\n-        let actual = f(&input_code, &path);\n-        let path = path.with_extension(outfile_extension);\n-        if !path.exists() {\n-            println!(\"\\nfile: {}\", path.display());\n-            println!(\"No .txt file with expected result, creating...\\n\");\n-            println!(\"{}\\n{}\", input_code, actual);\n-            fs::write(&path, &actual).unwrap();\n-            panic!(\"No expected result\");\n-        }\n-        let expected = read_text(&path);\n-        assert_equal_text(&expected, &actual, &path);\n-    }\n-}\n-\n-/// Collects all `.rs` files from `dir` subdirectories defined by `paths`.\n-pub fn collect_rust_files(root_dir: &Path, paths: &[&str]) -> Vec<(PathBuf, String)> {\n-    paths\n-        .iter()\n-        .flat_map(|path| {\n-            let path = root_dir.to_owned().join(path);\n-            rust_files_in_dir(&path).into_iter()\n-        })\n-        .map(|path| {\n-            let text = read_text(&path);\n-            (path, text)\n-        })\n-        .collect()\n-}\n-\n-/// Collects paths to all `.rs` files from `dir` in a sorted `Vec<PathBuf>`.\n-fn rust_files_in_dir(dir: &Path) -> Vec<PathBuf> {\n-    let mut acc = Vec::new();\n-    for file in fs::read_dir(&dir).unwrap() {\n-        let file = file.unwrap();\n-        let path = file.path();\n-        if path.extension().unwrap_or_default() == \"rs\" {\n-            acc.push(path);\n-        }\n-    }\n-    acc.sort();\n-    acc\n-}\n-\n-/// Returns the path to the root directory of `rust-analyzer` project.\n-pub fn project_dir() -> PathBuf {\n-    let dir = env!(\"CARGO_MANIFEST_DIR\");\n-    PathBuf::from(dir).parent().unwrap().parent().unwrap().to_owned()\n-}\n-\n-/// Read file and normalize newlines.\n-///\n-/// `rustc` seems to always normalize `\\r\\n` newlines to `\\n`:\n-///\n-/// ```\n-/// let s = \"\n-/// \";\n-/// assert_eq!(s.as_bytes(), &[10]);\n-/// ```\n-///\n-/// so this should always be correct.\n-pub fn read_text(path: &Path) -> String {\n-    fs::read_to_string(path)\n-        .unwrap_or_else(|_| panic!(\"File at {:?} should be valid\", path))\n-        .replace(\"\\r\\n\", \"\\n\")\n-}\n-\n /// Returns `false` if slow tests should not run, otherwise returns `true` and\n /// also creates a file at `./target/.slow_tests_cookie` which serves as a flag\n /// that slow tests did run.\n@@ -392,25 +313,8 @@ pub fn skip_slow_tests() -> bool {\n     should_skip\n }\n \n-/// Asserts that `expected` and `actual` strings are equal. If they differ only\n-/// in trailing or leading whitespace the test won't fail and\n-/// the contents of `actual` will be written to the file located at `path`.\n-fn assert_equal_text(expected: &str, actual: &str, path: &Path) {\n-    if expected == actual {\n-        return;\n-    }\n-    let dir = project_dir();\n-    let pretty_path = path.strip_prefix(&dir).unwrap_or_else(|_| path);\n-    if expected.trim() == actual.trim() {\n-        println!(\"whitespace difference, rewriting\");\n-        println!(\"file: {}\\n\", pretty_path.display());\n-        fs::write(path, actual).unwrap();\n-        return;\n-    }\n-    if env::var(\"UPDATE_EXPECTATIONS\").is_ok() {\n-        println!(\"rewriting {}\", pretty_path.display());\n-        fs::write(path, actual).unwrap();\n-        return;\n-    }\n-    assert_eq_text!(expected, actual, \"file: {}\", pretty_path.display());\n+/// Returns the path to the root directory of `rust-analyzer` project.\n+pub fn project_dir() -> PathBuf {\n+    let dir = env!(\"CARGO_MANIFEST_DIR\");\n+    PathBuf::from(dir).parent().unwrap().parent().unwrap().to_owned()\n }"}]}