{"sha": "a45f69f27dce51b1124f2262c819da1f6221bdf6", "node_id": "C_kwDOAAsO6NoAKGE0NWY2OWYyN2RjZTUxYjExMjRmMjI2MmM4MTlkYTFmNjIyMWJkZjY", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-08-21T14:54:07Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-08-21T14:54:07Z"}, "message": "Rollup merge of #100822 - WaffleLapkin:no_offset_question_mark, r=scottmcm\n\nReplace most uses of `pointer::offset` with `add` and `sub`\n\nAs PR title says, it replaces `pointer::offset` in compiler and standard library with `pointer::add` and `pointer::sub`. This generally makes code cleaner, easier to grasp and removes (or, well, hides) integer casts.\n\nThis is generally trivially correct, `.offset(-constant)` is just `.sub(constant)`, `.offset(usized as isize)` is just `.add(usized)`, etc. However in some cases we need to be careful with signs of things.\n\nr? ````@scottmcm````\n\n_split off from #100746_", "tree": {"sha": "b88bba1bcb832134a3563db7d4102e040df7cdea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b88bba1bcb832134a3563db7d4102e040df7cdea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a45f69f27dce51b1124f2262c819da1f6221bdf6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjAkcPCRBK7hj4Ov3rIwAACB8IACwpc+bcwFJBB/UMethVW8Q1\nOxVspQPU4aghkopOianVrLpO0nLRtWa4pGrjEVdtnS2lZ/jI5AWsWw0WU+IC8Y9I\nUkYO31mgiEK2vZmg+MfzPHIjH6OTeahpt/S+AVVkTS4jcX5OJqg6mugXozPSTKcY\nGZtFOcUHKWC7rY5dvNhHeWX4Rv33ZYoWa3Vtb8/6d+VK0WbfsAzAQ6CfJS9YXuNq\nmdsO+VltR0uecfR2WSZI8m+h+JyaNwXudmtVSIyVEvlbzWMRWX5iCvGHqGWf9VQ1\nEBQF98b1wIiXJmo9X2w4Qk0nUebHDEFnTfiRtsYGa+tY7Q22D7+S9TwZoGU4xKg=\n=sCqi\n-----END PGP SIGNATURE-----\n", "payload": "tree b88bba1bcb832134a3563db7d4102e040df7cdea\nparent fd403f5d1780388a89fc70a3dd8bdac3c0e606c1\nparent e4720e1cf26b6a9804615f79dc6ff1a006399cf1\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1661093647 +0200\ncommitter GitHub <noreply@github.com> 1661093647 +0200\n\nRollup merge of #100822 - WaffleLapkin:no_offset_question_mark, r=scottmcm\n\nReplace most uses of `pointer::offset` with `add` and `sub`\n\nAs PR title says, it replaces `pointer::offset` in compiler and standard library with `pointer::add` and `pointer::sub`. This generally makes code cleaner, easier to grasp and removes (or, well, hides) integer casts.\n\nThis is generally trivially correct, `.offset(-constant)` is just `.sub(constant)`, `.offset(usized as isize)` is just `.add(usized)`, etc. However in some cases we need to be careful with signs of things.\n\nr? ````@scottmcm````\n\n_split off from #100746_\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a45f69f27dce51b1124f2262c819da1f6221bdf6", "html_url": "https://github.com/rust-lang/rust/commit/a45f69f27dce51b1124f2262c819da1f6221bdf6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a45f69f27dce51b1124f2262c819da1f6221bdf6/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fd403f5d1780388a89fc70a3dd8bdac3c0e606c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd403f5d1780388a89fc70a3dd8bdac3c0e606c1", "html_url": "https://github.com/rust-lang/rust/commit/fd403f5d1780388a89fc70a3dd8bdac3c0e606c1"}, {"sha": "e4720e1cf26b6a9804615f79dc6ff1a006399cf1", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4720e1cf26b6a9804615f79dc6ff1a006399cf1", "html_url": "https://github.com/rust-lang/rust/commit/e4720e1cf26b6a9804615f79dc6ff1a006399cf1"}], "stats": {"total": 114, "additions": 57, "deletions": 57}, "files": [{"sha": "d2f8ef8eaae7dbc3904c4cd8cb03fa2df4195a4e", "filename": "compiler/rustc_arena/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a45f69f27dce51b1124f2262c819da1f6221bdf6/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45f69f27dce51b1124f2262c819da1f6221bdf6/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_arena%2Fsrc%2Flib.rs?ref=a45f69f27dce51b1124f2262c819da1f6221bdf6", "patch": "@@ -219,7 +219,7 @@ impl<T> TypedArena<T> {\n             } else {\n                 let ptr = self.ptr.get();\n                 // Advance the pointer.\n-                self.ptr.set(self.ptr.get().offset(1));\n+                self.ptr.set(self.ptr.get().add(1));\n                 // Write into uninitialized memory.\n                 ptr::write(ptr, object);\n                 &mut *ptr"}, {"sha": "50261c193973932d85be96140e1359129e8e6641", "filename": "compiler/rustc_codegen_cranelift/example/alloc_system.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a45f69f27dce51b1124f2262c819da1f6221bdf6/compiler%2Frustc_codegen_cranelift%2Fexample%2Falloc_system.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45f69f27dce51b1124f2262c819da1f6221bdf6/compiler%2Frustc_codegen_cranelift%2Fexample%2Falloc_system.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Falloc_system.rs?ref=a45f69f27dce51b1124f2262c819da1f6221bdf6", "patch": "@@ -94,7 +94,7 @@ mod platform {\n     struct Header(*mut u8);\n     const HEAP_ZERO_MEMORY: DWORD = 0x00000008;\n     unsafe fn get_header<'a>(ptr: *mut u8) -> &'a mut Header {\n-        &mut *(ptr as *mut Header).offset(-1)\n+        &mut *(ptr as *mut Header).sub(1)\n     }\n     unsafe fn align_ptr(ptr: *mut u8, align: usize) -> *mut u8 {\n         let aligned = ptr.add(align - (ptr as usize & (align - 1)));"}, {"sha": "89661918d05a5d14e90359c267beb57f356dab98", "filename": "compiler/rustc_codegen_gcc/example/alloc_system.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a45f69f27dce51b1124f2262c819da1f6221bdf6/compiler%2Frustc_codegen_gcc%2Fexample%2Falloc_system.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45f69f27dce51b1124f2262c819da1f6221bdf6/compiler%2Frustc_codegen_gcc%2Fexample%2Falloc_system.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fexample%2Falloc_system.rs?ref=a45f69f27dce51b1124f2262c819da1f6221bdf6", "patch": "@@ -156,7 +156,7 @@ mod platform {\n     struct Header(*mut u8);\n     const HEAP_ZERO_MEMORY: DWORD = 0x00000008;\n     unsafe fn get_header<'a>(ptr: *mut u8) -> &'a mut Header {\n-        &mut *(ptr as *mut Header).offset(-1)\n+        &mut *(ptr as *mut Header).sub(1)\n     }\n     unsafe fn align_ptr(ptr: *mut u8, align: usize) -> *mut u8 {\n         let aligned = ptr.add(align - (ptr as usize & (align - 1)));"}, {"sha": "9bd5550038fc605a24cd9aa510b668f46f4cf6ea", "filename": "compiler/rustc_serialize/src/serialize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a45f69f27dce51b1124f2262c819da1f6221bdf6/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45f69f27dce51b1124f2262c819da1f6221bdf6/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs?ref=a45f69f27dce51b1124f2262c819da1f6221bdf6", "patch": "@@ -273,7 +273,7 @@ impl<D: Decoder, T: Decodable<D>> Decodable<D> for Vec<T> {\n         unsafe {\n             let ptr: *mut T = vec.as_mut_ptr();\n             for i in 0..len {\n-                std::ptr::write(ptr.offset(i as isize), Decodable::decode(d));\n+                std::ptr::write(ptr.add(i), Decodable::decode(d));\n             }\n             vec.set_len(len);\n         }"}, {"sha": "b2f0194599b287057f41023545a244749eaf232f", "filename": "library/alloc/src/alloc/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a45f69f27dce51b1124f2262c819da1f6221bdf6/library%2Falloc%2Fsrc%2Falloc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45f69f27dce51b1124f2262c819da1f6221bdf6/library%2Falloc%2Fsrc%2Falloc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Falloc%2Ftests.rs?ref=a45f69f27dce51b1124f2262c819da1f6221bdf6", "patch": "@@ -15,7 +15,7 @@ fn allocate_zeroed() {\n         let end = i.add(layout.size());\n         while i < end {\n             assert_eq!(*i, 0);\n-            i = i.offset(1);\n+            i = i.add(1);\n         }\n         Global.deallocate(ptr.as_non_null_ptr(), layout);\n     }"}, {"sha": "57ab74e01590bd1dabd52d96b93ab29f49da94ee", "filename": "library/alloc/src/collections/vec_deque/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a45f69f27dce51b1124f2262c819da1f6221bdf6/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45f69f27dce51b1124f2262c819da1f6221bdf6/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs?ref=a45f69f27dce51b1124f2262c819da1f6221bdf6", "patch": "@@ -2447,8 +2447,8 @@ impl<T, A: Allocator> VecDeque<T, A> {\n                     let mut right_offset = 0;\n                     for i in left_edge..right_edge {\n                         right_offset = (i - left_edge) % (cap - right_edge);\n-                        let src: isize = (right_edge + right_offset) as isize;\n-                        ptr::swap(buf.add(i), buf.offset(src));\n+                        let src = right_edge + right_offset;\n+                        ptr::swap(buf.add(i), buf.add(src));\n                     }\n                     let n_ops = right_edge - left_edge;\n                     left_edge += n_ops;"}, {"sha": "5733124ec7565ecc22170cdaf74b9ab379998f07", "filename": "library/alloc/src/slice.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a45f69f27dce51b1124f2262c819da1f6221bdf6/library%2Falloc%2Fsrc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45f69f27dce51b1124f2262c819da1f6221bdf6/library%2Falloc%2Fsrc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fslice.rs?ref=a45f69f27dce51b1124f2262c819da1f6221bdf6", "patch": "@@ -1024,7 +1024,7 @@ where\n             // Consume the greater side.\n             // If equal, prefer the right run to maintain stability.\n             unsafe {\n-                let to_copy = if is_less(&*right.offset(-1), &*left.offset(-1)) {\n+                let to_copy = if is_less(&*right.sub(1), &*left.sub(1)) {\n                     decrement_and_get(left)\n                 } else {\n                     decrement_and_get(right)\n@@ -1038,12 +1038,12 @@ where\n \n     unsafe fn get_and_increment<T>(ptr: &mut *mut T) -> *mut T {\n         let old = *ptr;\n-        *ptr = unsafe { ptr.offset(1) };\n+        *ptr = unsafe { ptr.add(1) };\n         old\n     }\n \n     unsafe fn decrement_and_get<T>(ptr: &mut *mut T) -> *mut T {\n-        *ptr = unsafe { ptr.offset(-1) };\n+        *ptr = unsafe { ptr.sub(1) };\n         *ptr\n     }\n "}, {"sha": "b211421b20270f3787646651dd99025ca21903fc", "filename": "library/alloc/src/vec/in_place_collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a45f69f27dce51b1124f2262c819da1f6221bdf6/library%2Falloc%2Fsrc%2Fvec%2Fin_place_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45f69f27dce51b1124f2262c819da1f6221bdf6/library%2Falloc%2Fsrc%2Fvec%2Fin_place_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fin_place_collect.rs?ref=a45f69f27dce51b1124f2262c819da1f6221bdf6", "patch": "@@ -267,7 +267,7 @@ where\n             // one slot in the underlying storage will have been freed up and we can immediately\n             // write back the result.\n             unsafe {\n-                let dst = dst_buf.offset(i as isize);\n+                let dst = dst_buf.add(i);\n                 debug_assert!(dst as *const _ <= end, \"InPlaceIterable contract violation\");\n                 ptr::write(dst, self.__iterator_get_unchecked(i));\n                 // Since this executes user code which can panic we have to bump the pointer"}, {"sha": "e02ad391a595fae24192ab21931d64e38f47e00c", "filename": "library/alloc/src/vec/into_iter.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a45f69f27dce51b1124f2262c819da1f6221bdf6/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45f69f27dce51b1124f2262c819da1f6221bdf6/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs?ref=a45f69f27dce51b1124f2262c819da1f6221bdf6", "patch": "@@ -160,7 +160,7 @@ impl<T, A: Allocator> Iterator for IntoIter<T, A> {\n             Some(unsafe { mem::zeroed() })\n         } else {\n             let old = self.ptr;\n-            self.ptr = unsafe { self.ptr.offset(1) };\n+            self.ptr = unsafe { self.ptr.add(1) };\n \n             Some(unsafe { ptr::read(old) })\n         }\n@@ -272,7 +272,7 @@ impl<T, A: Allocator> DoubleEndedIterator for IntoIter<T, A> {\n             // Make up a value of this ZST.\n             Some(unsafe { mem::zeroed() })\n         } else {\n-            self.end = unsafe { self.end.offset(-1) };\n+            self.end = unsafe { self.end.sub(1) };\n \n             Some(unsafe { ptr::read(self.end) })\n         }\n@@ -288,7 +288,7 @@ impl<T, A: Allocator> DoubleEndedIterator for IntoIter<T, A> {\n             }\n         } else {\n             // SAFETY: same as for advance_by()\n-            self.end = unsafe { self.end.offset(step_size.wrapping_neg() as isize) };\n+            self.end = unsafe { self.end.sub(step_size) };\n         }\n         let to_drop = ptr::slice_from_raw_parts_mut(self.end as *mut T, step_size);\n         // SAFETY: same as for advance_by()"}, {"sha": "cea943602f77024afd0a10ce5d84c1c369f25a0b", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a45f69f27dce51b1124f2262c819da1f6221bdf6/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45f69f27dce51b1124f2262c819da1f6221bdf6/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=a45f69f27dce51b1124f2262c819da1f6221bdf6", "patch": "@@ -1393,7 +1393,7 @@ impl<T, A: Allocator> Vec<T, A> {\n                 if index < len {\n                     // Shift everything over to make space. (Duplicating the\n                     // `index`th element into two consecutive places.)\n-                    ptr::copy(p, p.offset(1), len - index);\n+                    ptr::copy(p, p.add(1), len - index);\n                 } else if index == len {\n                     // No elements need shifting.\n                 } else {\n@@ -1455,7 +1455,7 @@ impl<T, A: Allocator> Vec<T, A> {\n                 ret = ptr::read(ptr);\n \n                 // Shift everything down to fill in that spot.\n-                ptr::copy(ptr.offset(1), ptr, len - index - 1);\n+                ptr::copy(ptr.add(1), ptr, len - index - 1);\n             }\n             self.set_len(len - 1);\n             ret\n@@ -2408,7 +2408,7 @@ impl<T, A: Allocator> Vec<T, A> {\n             // Write all elements except the last one\n             for _ in 1..n {\n                 ptr::write(ptr, value.next());\n-                ptr = ptr.offset(1);\n+                ptr = ptr.add(1);\n                 // Increment the length in every step in case next() panics\n                 local_len.increment_len(1);\n             }"}, {"sha": "1ea9c827afd70702f1254b843d6ed2e3b48e472a", "filename": "library/alloc/src/vec/spec_extend.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a45f69f27dce51b1124f2262c819da1f6221bdf6/library%2Falloc%2Fsrc%2Fvec%2Fspec_extend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45f69f27dce51b1124f2262c819da1f6221bdf6/library%2Falloc%2Fsrc%2Fvec%2Fspec_extend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fspec_extend.rs?ref=a45f69f27dce51b1124f2262c819da1f6221bdf6", "patch": "@@ -39,7 +39,7 @@ where\n                 let mut local_len = SetLenOnDrop::new(&mut self.len);\n                 iterator.for_each(move |element| {\n                     ptr::write(ptr, element);\n-                    ptr = ptr.offset(1);\n+                    ptr = ptr.add(1);\n                     // Since the loop executes user code which can panic we have to bump the pointer\n                     // after each step.\n                     // NB can't overflow since we would have had to alloc the address space"}, {"sha": "e30329aa1cb6c78e46c8952eae1f839763ec8df4", "filename": "library/alloc/tests/str.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a45f69f27dce51b1124f2262c819da1f6221bdf6/library%2Falloc%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45f69f27dce51b1124f2262c819da1f6221bdf6/library%2Falloc%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fstr.rs?ref=a45f69f27dce51b1124f2262c819da1f6221bdf6", "patch": "@@ -1010,11 +1010,11 @@ fn test_as_bytes_fail() {\n fn test_as_ptr() {\n     let buf = \"hello\".as_ptr();\n     unsafe {\n-        assert_eq!(*buf.offset(0), b'h');\n-        assert_eq!(*buf.offset(1), b'e');\n-        assert_eq!(*buf.offset(2), b'l');\n-        assert_eq!(*buf.offset(3), b'l');\n-        assert_eq!(*buf.offset(4), b'o');\n+        assert_eq!(*buf.add(0), b'h');\n+        assert_eq!(*buf.add(1), b'e');\n+        assert_eq!(*buf.add(2), b'l');\n+        assert_eq!(*buf.add(3), b'l');\n+        assert_eq!(*buf.add(4), b'o');\n     }\n }\n "}, {"sha": "ea6a70c2f4e741db18b951125b257e2200c75f4e", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a45f69f27dce51b1124f2262c819da1f6221bdf6/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45f69f27dce51b1124f2262c819da1f6221bdf6/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=a45f69f27dce51b1124f2262c819da1f6221bdf6", "patch": "@@ -2924,7 +2924,7 @@ impl<T> [T] {\n                 let prev_ptr_write = ptr.add(next_write - 1);\n                 if !same_bucket(&mut *ptr_read, &mut *prev_ptr_write) {\n                     if next_read != next_write {\n-                        let ptr_write = prev_ptr_write.offset(1);\n+                        let ptr_write = prev_ptr_write.add(1);\n                         mem::swap(&mut *ptr_read, &mut *ptr_write);\n                     }\n                     next_write += 1;"}, {"sha": "8b025da2a46ed02968b037e1fc122147500eefa0", "filename": "library/core/src/slice/sort.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a45f69f27dce51b1124f2262c819da1f6221bdf6/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45f69f27dce51b1124f2262c819da1f6221bdf6/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs?ref=a45f69f27dce51b1124f2262c819da1f6221bdf6", "patch": "@@ -326,8 +326,8 @@ where\n                 unsafe {\n                     // Branchless comparison.\n                     *end_l = i as u8;\n-                    end_l = end_l.offset(!is_less(&*elem, pivot) as isize);\n-                    elem = elem.offset(1);\n+                    end_l = end_l.add(!is_less(&*elem, pivot) as usize);\n+                    elem = elem.add(1);\n                 }\n             }\n         }\n@@ -352,9 +352,9 @@ where\n                 //        Plus, `block_r` was asserted to be less than `BLOCK` and `elem` will therefore at most be pointing to the beginning of the slice.\n                 unsafe {\n                     // Branchless comparison.\n-                    elem = elem.offset(-1);\n+                    elem = elem.sub(1);\n                     *end_r = i as u8;\n-                    end_r = end_r.offset(is_less(&*elem, pivot) as isize);\n+                    end_r = end_r.add(is_less(&*elem, pivot) as usize);\n                 }\n             }\n         }\n@@ -365,12 +365,12 @@ where\n         if count > 0 {\n             macro_rules! left {\n                 () => {\n-                    l.offset(*start_l as isize)\n+                    l.add(*start_l as usize)\n                 };\n             }\n             macro_rules! right {\n                 () => {\n-                    r.offset(-(*start_r as isize) - 1)\n+                    r.sub((*start_r as usize) + 1)\n                 };\n             }\n \n@@ -398,16 +398,16 @@ where\n                 ptr::copy_nonoverlapping(right!(), left!(), 1);\n \n                 for _ in 1..count {\n-                    start_l = start_l.offset(1);\n+                    start_l = start_l.add(1);\n                     ptr::copy_nonoverlapping(left!(), right!(), 1);\n-                    start_r = start_r.offset(1);\n+                    start_r = start_r.add(1);\n                     ptr::copy_nonoverlapping(right!(), left!(), 1);\n                 }\n \n                 ptr::copy_nonoverlapping(&tmp, right!(), 1);\n                 mem::forget(tmp);\n-                start_l = start_l.offset(1);\n-                start_r = start_r.offset(1);\n+                start_l = start_l.add(1);\n+                start_r = start_r.add(1);\n             }\n         }\n \n@@ -420,15 +420,15 @@ where\n             // safe. Otherwise, the debug assertions in the `is_done` case guarantee that\n             // `width(l, r) == block_l + block_r`, namely, that the block sizes have been adjusted to account\n             // for the smaller number of remaining elements.\n-            l = unsafe { l.offset(block_l as isize) };\n+            l = unsafe { l.add(block_l) };\n         }\n \n         if start_r == end_r {\n             // All out-of-order elements in the right block were moved. Move to the previous block.\n \n             // SAFETY: Same argument as [block-width-guarantee]. Either this is a full block `2*BLOCK`-wide,\n             // or `block_r` has been adjusted for the last handful of elements.\n-            r = unsafe { r.offset(-(block_r as isize)) };\n+            r = unsafe { r.sub(block_r) };\n         }\n \n         if is_done {\n@@ -457,9 +457,9 @@ where\n             //  - `offsets_l` contains valid offsets into `v` collected during the partitioning of\n             //    the last block, so the `l.offset` calls are valid.\n             unsafe {\n-                end_l = end_l.offset(-1);\n-                ptr::swap(l.offset(*end_l as isize), r.offset(-1));\n-                r = r.offset(-1);\n+                end_l = end_l.sub(1);\n+                ptr::swap(l.add(*end_l as usize), r.sub(1));\n+                r = r.sub(1);\n             }\n         }\n         width(v.as_mut_ptr(), r)\n@@ -470,9 +470,9 @@ where\n         while start_r < end_r {\n             // SAFETY: See the reasoning in [remaining-elements-safety].\n             unsafe {\n-                end_r = end_r.offset(-1);\n-                ptr::swap(l, r.offset(-(*end_r as isize) - 1));\n-                l = l.offset(1);\n+                end_r = end_r.sub(1);\n+                ptr::swap(l, r.sub((*end_r as usize) + 1));\n+                l = l.add(1);\n             }\n         }\n         width(v.as_mut_ptr(), l)"}, {"sha": "2acef432f2063a7978d7163f60e80a0b8f4d4460", "filename": "library/core/src/str/validations.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a45f69f27dce51b1124f2262c819da1f6221bdf6/library%2Fcore%2Fsrc%2Fstr%2Fvalidations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45f69f27dce51b1124f2262c819da1f6221bdf6/library%2Fcore%2Fsrc%2Fstr%2Fvalidations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fvalidations.rs?ref=a45f69f27dce51b1124f2262c819da1f6221bdf6", "patch": "@@ -216,12 +216,12 @@ pub(super) const fn run_utf8_validation(v: &[u8]) -> Result<(), Utf8Error> {\n                     // SAFETY: since `align - index` and `ascii_block_size` are\n                     // multiples of `usize_bytes`, `block = ptr.add(index)` is\n                     // always aligned with a `usize` so it's safe to dereference\n-                    // both `block` and `block.offset(1)`.\n+                    // both `block` and `block.add(1)`.\n                     unsafe {\n                         let block = ptr.add(index) as *const usize;\n                         // break if there is a nonascii byte\n                         let zu = contains_nonascii(*block);\n-                        let zv = contains_nonascii(*block.offset(1));\n+                        let zv = contains_nonascii(*block.add(1));\n                         if zu || zv {\n                             break;\n                         }"}, {"sha": "0fd824f8a458da3f19d77899e6aea18bd282f96f", "filename": "library/panic_abort/src/android.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a45f69f27dce51b1124f2262c819da1f6221bdf6/library%2Fpanic_abort%2Fsrc%2Fandroid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45f69f27dce51b1124f2262c819da1f6221bdf6/library%2Fpanic_abort%2Fsrc%2Fandroid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fpanic_abort%2Fsrc%2Fandroid.rs?ref=a45f69f27dce51b1124f2262c819da1f6221bdf6", "patch": "@@ -42,7 +42,7 @@ pub(crate) unsafe fn android_set_abort_message(payload: *mut &mut dyn BoxMeUp) {\n         return; // allocation failure\n     }\n     copy_nonoverlapping(msg.as_ptr(), buf as *mut u8, msg.len());\n-    buf.offset(msg.len() as isize).write(0);\n+    buf.add(msg.len()).write(0);\n \n     let func = transmute::<usize, SetAbortMessageType>(func_addr);\n     func(buf);"}, {"sha": "9aa966b5063b1a0f91492db0deac919a026a2f28", "filename": "library/panic_unwind/src/dwarf/eh.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a45f69f27dce51b1124f2262c819da1f6221bdf6/library%2Fpanic_unwind%2Fsrc%2Fdwarf%2Feh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45f69f27dce51b1124f2262c819da1f6221bdf6/library%2Fpanic_unwind%2Fsrc%2Fdwarf%2Feh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fpanic_unwind%2Fsrc%2Fdwarf%2Feh.rs?ref=a45f69f27dce51b1124f2262c819da1f6221bdf6", "patch": "@@ -75,7 +75,7 @@ pub unsafe fn find_eh_action(lsda: *const u8, context: &EHContext<'_>) -> Result\n \n     let call_site_encoding = reader.read::<u8>();\n     let call_site_table_length = reader.read_uleb128();\n-    let action_table = reader.ptr.offset(call_site_table_length as isize);\n+    let action_table = reader.ptr.add(call_site_table_length as usize);\n     let ip = context.ip;\n \n     if !USING_SJLJ_EXCEPTIONS {"}, {"sha": "bb313c7597b6c87991a6da351698de7543e1a437", "filename": "library/std/src/os/unix/net/addr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a45f69f27dce51b1124f2262c819da1f6221bdf6/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45f69f27dce51b1124f2262c819da1f6221bdf6/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Faddr.rs?ref=a45f69f27dce51b1124f2262c819da1f6221bdf6", "patch": "@@ -329,7 +329,7 @@ impl SocketAddr {\n \n             crate::ptr::copy_nonoverlapping(\n                 namespace.as_ptr(),\n-                addr.sun_path.as_mut_ptr().offset(1) as *mut u8,\n+                addr.sun_path.as_mut_ptr().add(1) as *mut u8,\n                 namespace.len(),\n             );\n             let len = (sun_path_offset(&addr) + 1 + namespace.len()) as libc::socklen_t;"}, {"sha": "58b8eb215d73cc97fe29f4342d050ac5ffc5d8e8", "filename": "library/std/src/sys/sgx/abi/usercalls/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a45f69f27dce51b1124f2262c819da1f6221bdf6/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45f69f27dce51b1124f2262c819da1f6221bdf6/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Ftests.rs?ref=a45f69f27dce51b1124f2262c819da1f6221bdf6", "patch": "@@ -17,12 +17,12 @@ fn test_copy_to_userspace_function() {\n             dst.copy_from_enclave(&[0u8; 100]);\n \n             // Copy src[0..size] to dst + offset\n-            unsafe { copy_to_userspace(src.as_ptr(), dst.as_mut_ptr().offset(offset), size) };\n+            unsafe { copy_to_userspace(src.as_ptr(), dst.as_mut_ptr().add(offset), size) };\n \n             // Verify copy\n             for byte in 0..size {\n                 unsafe {\n-                    assert_eq!(*dst.as_ptr().offset(offset + byte as isize), src[byte as usize]);\n+                    assert_eq!(*dst.as_ptr().add(offset + byte), src[byte as usize]);\n                 }\n             }\n         }"}, {"sha": "fe00c08aa6a9ae19c15d7035bd65624587a6fed6", "filename": "library/std/src/sys/windows/alloc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a45f69f27dce51b1124f2262c819da1f6221bdf6/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45f69f27dce51b1124f2262c819da1f6221bdf6/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Falloc.rs?ref=a45f69f27dce51b1124f2262c819da1f6221bdf6", "patch": "@@ -168,7 +168,7 @@ unsafe fn allocate(layout: Layout, zeroed: bool) -> *mut u8 {\n         // SAFETY: Because the size and alignment of a header is <= `MIN_ALIGN` and `aligned`\n         // is aligned to at least `MIN_ALIGN` and has at least `MIN_ALIGN` bytes of padding before\n         // it, it is safe to write a header directly before it.\n-        unsafe { ptr::write((aligned as *mut Header).offset(-1), Header(ptr)) };\n+        unsafe { ptr::write((aligned as *mut Header).sub(1), Header(ptr)) };\n \n         // SAFETY: The returned pointer does not point to the to the start of an allocated block,\n         // but there is a header readable directly before it containing the location of the start\n@@ -213,7 +213,7 @@ unsafe impl GlobalAlloc for System {\n \n                 // SAFETY: Because of the contract of `System`, `ptr` is guaranteed to be non-null\n                 // and have a header readable directly before it.\n-                unsafe { ptr::read((ptr as *mut Header).offset(-1)).0 }\n+                unsafe { ptr::read((ptr as *mut Header).sub(1)).0 }\n             }\n         };\n "}, {"sha": "1361b9c90c021879e2cc097ae5437fcf47278dc5", "filename": "library/std/src/sys/windows/fs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a45f69f27dce51b1124f2262c819da1f6221bdf6/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45f69f27dce51b1124f2262c819da1f6221bdf6/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs?ref=a45f69f27dce51b1124f2262c819da1f6221bdf6", "patch": "@@ -512,7 +512,7 @@ impl File {\n                     ));\n                 }\n             };\n-            let subst_ptr = path_buffer.offset(subst_off as isize);\n+            let subst_ptr = path_buffer.add(subst_off.into());\n             let mut subst = slice::from_raw_parts(subst_ptr, subst_len as usize);\n             // Absolute paths start with an NT internal namespace prefix `\\??\\`\n             // We should not let it leak through.\n@@ -1345,10 +1345,10 @@ fn symlink_junction_inner(original: &Path, junction: &Path) -> io::Result<()> {\n         let v = br\"\\??\\\";\n         let v = v.iter().map(|x| *x as u16);\n         for c in v.chain(original.as_os_str().encode_wide()) {\n-            *buf.offset(i) = c;\n+            *buf.add(i) = c;\n             i += 1;\n         }\n-        *buf.offset(i) = 0;\n+        *buf.add(i) = 0;\n         i += 1;\n         (*db).ReparseTag = c::IO_REPARSE_TAG_MOUNT_POINT;\n         (*db).ReparseTargetMaximumLength = (i * 2) as c::WORD;"}, {"sha": "352337ba322371d77b89aedc5d1a7cc756351f0d", "filename": "library/std/src/sys/windows/os.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a45f69f27dce51b1124f2262c819da1f6221bdf6/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45f69f27dce51b1124f2262c819da1f6221bdf6/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fos.rs?ref=a45f69f27dce51b1124f2262c819da1f6221bdf6", "patch": "@@ -99,11 +99,11 @@ impl Iterator for Env {\n                 }\n                 let p = self.cur as *const u16;\n                 let mut len = 0;\n-                while *p.offset(len) != 0 {\n+                while *p.add(len) != 0 {\n                     len += 1;\n                 }\n-                let s = slice::from_raw_parts(p, len as usize);\n-                self.cur = self.cur.offset(len + 1);\n+                let s = slice::from_raw_parts(p, len);\n+                self.cur = self.cur.add(len + 1);\n \n                 // Windows allows environment variables to start with an equals\n                 // symbol (in any other position, this is the separator between"}]}