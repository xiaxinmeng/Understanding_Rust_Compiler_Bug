{"sha": "2f100e04af6085a286caf6c4416733723bedac49", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmMTAwZTA0YWY2MDg1YTI4NmNhZjZjNDQxNjczMzcyM2JlZGFjNDk=", "commit": {"author": {"name": "flip1995", "email": "hello@philkrones.com", "date": "2019-04-07T17:40:46Z"}, "committer": {"name": "flip1995", "email": "hello@philkrones.com", "date": "2019-04-17T10:51:57Z"}, "message": "Remove uplifted functions {get,match}_def_path from Clippy", "tree": {"sha": "a7d42e20dc3593400951ac2fad36538448edeadc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a7d42e20dc3593400951ac2fad36538448edeadc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f100e04af6085a286caf6c4416733723bedac49", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEZxoS6lESXlRGMHWcaTCGhp1QZjcFAly3BU0ACgkQaTCGhp1Q\nZjcOAA//RO3DMj3CQ2P/RkCxdWWVdRUDl4EuR5MaMxyRte/azAdcCBtfqzjMZOCB\nJUqOi7VLAhuARmYnEoZMZbH1hgPJ3quf2T1kk6KTpgYXr4/YqYGGmhFp0o9SSpGu\nr+3ptBMLxKJbD9K+n/NkvBezZiqvtewx83pQPu7mU9cGg4HgZk/0qpQqDaSb4Bfu\noMtX2dyZWtcwMbkrrJaSsPIj9o40rA2SbdGx9lj60ahTUOGDpup3XRR00vKB78y9\nVXB2Y/AW6PvRXUZyXrH9bBkCcYxxTGuTX/LZKysf/0rd3ublceyZmOrUCvBXwNF0\n8djTJTRWPujnDFVfhxDPR+Iu/jU8m6cFmx69+It6hNkJaU4995WCkB1UErcf19oq\nFgOc5moVO+Uc4LLtGpd9pVZGwWXiSbYRYw7NuSr5eSkocu4kf+/kof4YS57bwCuV\nkwC6D+CRoOLm124rUFROTCSVF6AvvX40f7j6Ch8fYGjipF6AfUaHF8diOBBVOiae\nh6Rmg2eVD3hpcRFukZQgsc+j1zjXsoC8ESqiumcNXUjVNVr1beTswlxasIucFprS\nD4UaaKiaxCn/sPsGMUhN4ZJ8+2z2Q+buEEfRugualGvZjzG9vABTG8yP9507uovW\nlntw9hruyMy6FYuizpYAa5m9duSYBHHVPOCkyiFLCxEpaU6joOI=\n=LjyW\n-----END PGP SIGNATURE-----", "payload": "tree a7d42e20dc3593400951ac2fad36538448edeadc\nparent 27d62cf603235a80f0caa8f99b72778701549b87\nauthor flip1995 <hello@philkrones.com> 1554658846 +0200\ncommitter flip1995 <hello@philkrones.com> 1555498317 +0200\n\nRemove uplifted functions {get,match}_def_path from Clippy\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f100e04af6085a286caf6c4416733723bedac49", "html_url": "https://github.com/rust-lang/rust/commit/2f100e04af6085a286caf6c4416733723bedac49", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f100e04af6085a286caf6c4416733723bedac49/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "27d62cf603235a80f0caa8f99b72778701549b87", "url": "https://api.github.com/repos/rust-lang/rust/commits/27d62cf603235a80f0caa8f99b72778701549b87", "html_url": "https://github.com/rust-lang/rust/commit/27d62cf603235a80f0caa8f99b72778701549b87"}], "stats": {"total": 133, "additions": 1, "deletions": 132}, "files": [{"sha": "58de90a4b74be3c989629c3b14bcb1edd722e60b", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 1, "deletions": 132, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/2f100e04af6085a286caf6c4416733723bedac49/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f100e04af6085a286caf6c4416733723bedac49/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=2f100e04af6085a286caf6c4416733723bedac49", "patch": "@@ -24,10 +24,8 @@ use if_chain::if_chain;\n use matches::matches;\n use rustc::hir;\n use rustc::hir::def::Def;\n-use rustc::hir::def_id::CrateNum;\n use rustc::hir::def_id::{DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc::hir::intravisit::{NestedVisitorMap, Visitor};\n-use rustc::hir::map::{DefPathData, DisambiguatedDefPathData};\n use rustc::hir::Node;\n use rustc::hir::*;\n use rustc::lint::{LateContext, Level, Lint, LintContext};\n@@ -43,7 +41,7 @@ use rustc_errors::Applicability;\n use syntax::ast::{self, LitKind};\n use syntax::attr;\n use syntax::source_map::{Span, DUMMY_SP};\n-use syntax::symbol::{keywords, LocalInternedString, Symbol};\n+use syntax::symbol::{keywords, Symbol};\n \n use crate::reexport::*;\n \n@@ -95,135 +93,6 @@ pub fn in_macro(span: Span) -> bool {\n     span.ctxt().outer().expn_info().is_some()\n }\n \n-/// Used to store the absolute path to a type.\n-///\n-/// See `match_def_path` for usage.\n-pub struct AbsolutePathPrinter<'a, 'tcx> {\n-    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-}\n-\n-use rustc::ty::print::Printer;\n-\n-#[allow(clippy::diverging_sub_expression)]\n-impl<'tcx> Printer<'tcx, 'tcx> for AbsolutePathPrinter<'_, 'tcx> {\n-    type Error = !;\n-\n-    type Path = Vec<LocalInternedString>;\n-    type Region = ();\n-    type Type = ();\n-    type DynExistential = ();\n-\n-    fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n-        self.tcx\n-    }\n-\n-    fn print_region(self, _region: ty::Region<'_>) -> Result<Self::Region, Self::Error> {\n-        Ok(())\n-    }\n-\n-    fn print_type(self, _ty: Ty<'tcx>) -> Result<Self::Type, Self::Error> {\n-        Ok(())\n-    }\n-\n-    fn print_dyn_existential(\n-        self,\n-        _predicates: &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n-    ) -> Result<Self::DynExistential, Self::Error> {\n-        Ok(())\n-    }\n-\n-    fn path_crate(self, cnum: CrateNum) -> Result<Self::Path, Self::Error> {\n-        Ok(vec![self.tcx.original_crate_name(cnum).as_str()])\n-    }\n-\n-    fn path_qualified(\n-        self,\n-        self_ty: Ty<'tcx>,\n-        trait_ref: Option<ty::TraitRef<'tcx>>,\n-    ) -> Result<Self::Path, Self::Error> {\n-        if trait_ref.is_none() {\n-            if let ty::Adt(def, substs) = self_ty.sty {\n-                return self.print_def_path(def.did, substs);\n-            }\n-        }\n-\n-        // This shouldn't ever be needed, but just in case:\n-        Ok(vec![match trait_ref {\n-            Some(trait_ref) => Symbol::intern(&format!(\"{:?}\", trait_ref)).as_str(),\n-            None => Symbol::intern(&format!(\"<{}>\", self_ty)).as_str(),\n-        }])\n-    }\n-\n-    fn path_append_impl(\n-        self,\n-        print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n-        _disambiguated_data: &DisambiguatedDefPathData,\n-        self_ty: Ty<'tcx>,\n-        trait_ref: Option<ty::TraitRef<'tcx>>,\n-    ) -> Result<Self::Path, Self::Error> {\n-        let mut path = print_prefix(self)?;\n-\n-        // This shouldn't ever be needed, but just in case:\n-        path.push(match trait_ref {\n-            Some(trait_ref) => Symbol::intern(&format!(\"<impl {} for {}>\", trait_ref, self_ty)).as_str(),\n-            None => Symbol::intern(&format!(\"<impl {}>\", self_ty)).as_str(),\n-        });\n-\n-        Ok(path)\n-    }\n-\n-    fn path_append(\n-        self,\n-        print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n-        disambiguated_data: &DisambiguatedDefPathData,\n-    ) -> Result<Self::Path, Self::Error> {\n-        let mut path = print_prefix(self)?;\n-\n-        // Skip `::{{constructor}}` on tuple/unit structs.\n-        if let DefPathData::Ctor = disambiguated_data.data {\n-            return Ok(path);\n-        }\n-\n-        path.push(disambiguated_data.data.as_interned_str().as_str());\n-        Ok(path)\n-    }\n-\n-    fn path_generic_args(\n-        self,\n-        print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n-        _args: &[Kind<'tcx>],\n-    ) -> Result<Self::Path, Self::Error> {\n-        print_prefix(self)\n-    }\n-}\n-\n-/// Checks if a `DefId`'s path matches the given absolute type path usage.\n-///\n-/// # Examples\n-/// ```rust,ignore\n-/// match_def_path(cx.tcx, id, &[\"core\", \"option\", \"Option\"])\n-/// ```\n-///\n-/// See also the `paths` module.\n-pub fn match_def_path<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId, path: &[&str]) -> bool {\n-    let names = get_def_path(tcx, def_id);\n-\n-    names.len() == path.len() && names.into_iter().zip(path.iter()).all(|(a, &b)| *a == *b)\n-}\n-\n-/// Gets the absolute path of `def_id` as a vector of `&str`.\n-///\n-/// # Examples\n-/// ```rust,ignore\n-/// let def_path = get_def_path(tcx, def_id);\n-/// if let &[\"core\", \"option\", \"Option\"] = &def_path[..] {\n-///     // The given `def_id` is that of an `Option` type\n-/// };\n-/// ```\n-pub fn get_def_path<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Vec<LocalInternedString> {\n-    AbsolutePathPrinter { tcx }.print_def_path(def_id, &[]).unwrap()\n-}\n-\n /// Checks if type is struct, enum or union type with the given def path.\n pub fn match_type(cx: &LateContext<'_, '_>, ty: Ty<'_>, path: &[&str]) -> bool {\n     match ty.sty {"}]}