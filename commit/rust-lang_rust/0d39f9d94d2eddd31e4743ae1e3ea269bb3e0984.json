{"sha": "0d39f9d94d2eddd31e4743ae1e3ea269bb3e0984", "node_id": "C_kwDOAAsO6NoAKDBkMzlmOWQ5NGQyZWRkZDMxZTQ3NDNhZTFlM2VhMjY5YmIzZTA5ODQ", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-02-12T19:46:51Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-02-14T20:26:04Z"}, "message": "Do not fetch HIR to monomorphize impls.", "tree": {"sha": "17651395530c8c0b510b258abd17dd9172f2ae44", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/17651395530c8c0b510b258abd17dd9172f2ae44"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0d39f9d94d2eddd31e4743ae1e3ea269bb3e0984", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0d39f9d94d2eddd31e4743ae1e3ea269bb3e0984", "html_url": "https://github.com/rust-lang/rust/commit/0d39f9d94d2eddd31e4743ae1e3ea269bb3e0984", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0d39f9d94d2eddd31e4743ae1e3ea269bb3e0984/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "facecf6e1b96f3dc1c2a3f1bcfb56caa018e78cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/facecf6e1b96f3dc1c2a3f1bcfb56caa018e78cf", "html_url": "https://github.com/rust-lang/rust/commit/facecf6e1b96f3dc1c2a3f1bcfb56caa018e78cf"}], "stats": {"total": 114, "additions": 42, "deletions": 72}, "files": [{"sha": "dd7ee220d7311a52f5d214685b80689d637843a6", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 42, "deletions": 72, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/0d39f9d94d2eddd31e4743ae1e3ea269bb3e0984/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d39f9d94d2eddd31e4743ae1e3ea269bb3e0984/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=0d39f9d94d2eddd31e4743ae1e3ea269bb3e0984", "patch": "@@ -1191,28 +1191,14 @@ impl<'v> RootCollector<'_, 'v> {\n     fn process_item(&mut self, id: hir::ItemId) {\n         match self.tcx.def_kind(id.owner_id) {\n             DefKind::Enum | DefKind::Struct | DefKind::Union => {\n-                let item = self.tcx.hir().item(id);\n-                match item.kind {\n-                    hir::ItemKind::Enum(_, ref generics)\n-                    | hir::ItemKind::Struct(_, ref generics)\n-                    | hir::ItemKind::Union(_, ref generics) => {\n-                        if generics.params.is_empty() {\n-                            if self.mode == MonoItemCollectionMode::Eager {\n-                                debug!(\n-                                    \"RootCollector: ADT drop-glue for {}\",\n-                                    self.tcx.def_path_str(item.owner_id.to_def_id())\n-                                );\n-\n-                                let ty = Instance::new(\n-                                    item.owner_id.to_def_id(),\n-                                    InternalSubsts::empty(),\n-                                )\n-                                .ty(self.tcx, ty::ParamEnv::reveal_all());\n-                                visit_drop_use(self.tcx, ty, true, DUMMY_SP, self.output);\n-                            }\n-                        }\n-                    }\n-                    _ => bug!(),\n+                if self.tcx.generics_of(id.owner_id).count() == 0\n+                    && self.mode == MonoItemCollectionMode::Eager\n+                {\n+                    debug!(\"RootCollector: ADT drop-glue for `{id:?}`\",);\n+\n+                    let ty =\n+                        self.tcx.bound_type_of(id.owner_id.to_def_id()).no_bound_vars().unwrap();\n+                    visit_drop_use(self.tcx, ty, true, DUMMY_SP, self.output);\n                 }\n             }\n             DefKind::GlobalAsm => {\n@@ -1240,8 +1226,7 @@ impl<'v> RootCollector<'_, 'v> {\n             }\n             DefKind::Impl { .. } => {\n                 if self.mode == MonoItemCollectionMode::Eager {\n-                    let item = self.tcx.hir().item(id);\n-                    create_mono_items_for_default_impls(self.tcx, item, self.output);\n+                    create_mono_items_for_default_impls(self.tcx, id, self.output);\n                 }\n             }\n             DefKind::Fn => {\n@@ -1326,66 +1311,51 @@ fn item_requires_monomorphization(tcx: TyCtxt<'_>, def_id: LocalDefId) -> bool {\n     generics.requires_monomorphization(tcx)\n }\n \n+#[instrument(level = \"debug\", skip(tcx, output))]\n fn create_mono_items_for_default_impls<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    item: &'tcx hir::Item<'tcx>,\n+    item: hir::ItemId,\n     output: &mut MonoItems<'tcx>,\n ) {\n-    match item.kind {\n-        hir::ItemKind::Impl(ref impl_) => {\n-            if matches!(impl_.polarity, hir::ImplPolarity::Negative(_)) {\n-                return;\n-            }\n+    let polarity = tcx.impl_polarity(item.owner_id);\n+    if matches!(polarity, ty::ImplPolarity::Negative) {\n+        return;\n+    }\n \n-            for param in impl_.generics.params {\n-                match param.kind {\n-                    hir::GenericParamKind::Lifetime { .. } => {}\n-                    hir::GenericParamKind::Type { .. } | hir::GenericParamKind::Const { .. } => {\n-                        return;\n-                    }\n-                }\n-            }\n+    if tcx.generics_of(item.owner_id).own_requires_monomorphization() {\n+        return;\n+    }\n \n-            debug!(\n-                \"create_mono_items_for_default_impls(item={})\",\n-                tcx.def_path_str(item.owner_id.to_def_id())\n-            );\n+    let Some(trait_ref) = tcx.impl_trait_ref(item.owner_id) else {\n+        return;\n+    };\n \n-            if let Some(trait_ref) = tcx.impl_trait_ref(item.owner_id) {\n-                let trait_ref = trait_ref.subst_identity();\n+    let trait_ref = trait_ref.subst_identity();\n \n-                let param_env = ty::ParamEnv::reveal_all();\n-                let trait_ref = tcx.normalize_erasing_regions(param_env, trait_ref);\n-                let overridden_methods = tcx.impl_item_implementor_ids(item.owner_id);\n-                for method in tcx.provided_trait_methods(trait_ref.def_id) {\n-                    if overridden_methods.contains_key(&method.def_id) {\n-                        continue;\n-                    }\n+    let param_env = ty::ParamEnv::reveal_all();\n+    let trait_ref = tcx.normalize_erasing_regions(param_env, trait_ref);\n+    let overridden_methods = tcx.impl_item_implementor_ids(item.owner_id);\n+    for method in tcx.provided_trait_methods(trait_ref.def_id) {\n+        if overridden_methods.contains_key(&method.def_id) {\n+            continue;\n+        }\n \n-                    if tcx.generics_of(method.def_id).own_requires_monomorphization() {\n-                        continue;\n-                    }\n+        if tcx.generics_of(method.def_id).own_requires_monomorphization() {\n+            continue;\n+        }\n \n-                    let substs =\n-                        InternalSubsts::for_item(tcx, method.def_id, |param, _| match param.kind {\n-                            GenericParamDefKind::Lifetime => tcx.lifetimes.re_erased.into(),\n-                            GenericParamDefKind::Type { .. }\n-                            | GenericParamDefKind::Const { .. } => {\n-                                trait_ref.substs[param.index as usize]\n-                            }\n-                        });\n-                    let instance =\n-                        ty::Instance::expect_resolve(tcx, param_env, method.def_id, substs);\n-\n-                    let mono_item = create_fn_mono_item(tcx, instance, DUMMY_SP);\n-                    if mono_item.node.is_instantiable(tcx) && should_codegen_locally(tcx, &instance)\n-                    {\n-                        output.push(mono_item);\n-                    }\n-                }\n+        let substs = InternalSubsts::for_item(tcx, method.def_id, |param, _| match param.kind {\n+            GenericParamDefKind::Lifetime => tcx.lifetimes.re_erased.into(),\n+            GenericParamDefKind::Type { .. } | GenericParamDefKind::Const { .. } => {\n+                trait_ref.substs[param.index as usize]\n             }\n+        });\n+        let instance = ty::Instance::expect_resolve(tcx, param_env, method.def_id, substs);\n+\n+        let mono_item = create_fn_mono_item(tcx, instance, DUMMY_SP);\n+        if mono_item.node.is_instantiable(tcx) && should_codegen_locally(tcx, &instance) {\n+            output.push(mono_item);\n         }\n-        _ => bug!(),\n     }\n }\n "}]}