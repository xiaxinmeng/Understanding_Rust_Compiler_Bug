{"sha": "ccbf754e351da26f48c76f228831cd12c064053d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjYmY3NTRlMzUxZGEyNmY0OGM3NmYyMjg4MzFjZDEyYzA2NDA1M2Q=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2019-03-16T06:56:16Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-03-16T06:56:16Z"}, "message": "Rollup merge of #58901 - ebarnard:just-copying, r=sfackler\n\nChange `std::fs::copy` to use `copyfile` on MacOS and iOS\n\n`copyfile` on MacOS is similar to `CopyFileEx` on Windows. It supports copying resource forks, extended attributes, and file ACLs, none of which are copied by the current generic unix implementation.\n\nThe API is available from MacOS 10.7 and iOS 4.3 (and possibly earlier but I haven't checked).\n\nCloses #58895.", "tree": {"sha": "17a2096d45c3af4702ff89d27cb54cf93f938883", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/17a2096d45c3af4702ff89d27cb54cf93f938883"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ccbf754e351da26f48c76f228831cd12c064053d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcjJ4QCRBK7hj4Ov3rIwAAdHIIADcMMOyFNxjMvd69rkTv9KlH\ncwxLchyXTh5hhNgnxhEqLsM3du3eVugH78hQ01W4T2XPRnB7pMGvCODnZQmXPont\n5JDIdPqETOqPBHQjy/DbMwqEw7v1Vp5DfguJdvMVBApTb48UlGbt7lGt2leQR5cw\nKQtkPR3ODtbbbb26w18jDi42WDdbXW36V0MkcSIVmgZtIW5g/pAKhMZoiYujkTi/\nnRCHWtpz03iKhokj+wYXgXNkbumPf8GNp0AHrQ/N1WecaXXphdbrDn2R0+/AR28a\nc8JKeHgLTlhIxB13Fv9ql3EX7ta9P42wI5Jf/MyDRkC18pRVZoOAbFWXQGrVOjk=\n=v27s\n-----END PGP SIGNATURE-----\n", "payload": "tree 17a2096d45c3af4702ff89d27cb54cf93f938883\nparent d869a7b16f87f806bfb2a746adf527f7d8b0d9f2\nparent 124ab2a4d87f2d10b88d668e35286af4c00ec12b\nauthor kennytm <kennytm@gmail.com> 1552719376 +0800\ncommitter GitHub <noreply@github.com> 1552719376 +0800\n\nRollup merge of #58901 - ebarnard:just-copying, r=sfackler\n\nChange `std::fs::copy` to use `copyfile` on MacOS and iOS\n\n`copyfile` on MacOS is similar to `CopyFileEx` on Windows. It supports copying resource forks, extended attributes, and file ACLs, none of which are copied by the current generic unix implementation.\n\nThe API is available from MacOS 10.7 and iOS 4.3 (and possibly earlier but I haven't checked).\n\nCloses #58895.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ccbf754e351da26f48c76f228831cd12c064053d", "html_url": "https://github.com/rust-lang/rust/commit/ccbf754e351da26f48c76f228831cd12c064053d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ccbf754e351da26f48c76f228831cd12c064053d/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d869a7b16f87f806bfb2a746adf527f7d8b0d9f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/d869a7b16f87f806bfb2a746adf527f7d8b0d9f2", "html_url": "https://github.com/rust-lang/rust/commit/d869a7b16f87f806bfb2a746adf527f7d8b0d9f2"}, {"sha": "124ab2a4d87f2d10b88d668e35286af4c00ec12b", "url": "https://api.github.com/repos/rust-lang/rust/commits/124ab2a4d87f2d10b88d668e35286af4c00ec12b", "html_url": "https://github.com/rust-lang/rust/commit/124ab2a4d87f2d10b88d668e35286af4c00ec12b"}], "stats": {"total": 110, "additions": 108, "deletions": 2}, "files": [{"sha": "a03f55424a9cd84f9a0a04ae344b7ad1ad685366", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ccbf754e351da26f48c76f228831cd12c064053d/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccbf754e351da26f48c76f228831cd12c064053d/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=ccbf754e351da26f48c76f228831cd12c064053d", "patch": "@@ -1581,7 +1581,8 @@ pub fn rename<P: AsRef<Path>, Q: AsRef<Path>>(from: P, to: Q) -> io::Result<()>\n /// `O_CLOEXEC` is set for returned file descriptors.\n /// On Windows, this function currently corresponds to `CopyFileEx`. Alternate\n /// NTFS streams are copied but only the size of the main stream is returned by\n-/// this function.\n+/// this function. On MacOS, this function corresponds to `copyfile` with\n+/// `COPYFILE_ALL`.\n /// Note that, this [may change in the future][changes].\n ///\n /// [changes]: ../io/index.html#platform-specific-behavior\n@@ -2836,6 +2837,26 @@ mod tests {\n         assert_eq!(check!(out_path.metadata()).len(), copied_len);\n     }\n \n+    #[test]\n+    fn copy_file_follows_dst_symlink() {\n+        let tmp = tmpdir();\n+        if !got_symlink_permission(&tmp) { return };\n+\n+        let in_path = tmp.join(\"in.txt\");\n+        let out_path = tmp.join(\"out.txt\");\n+        let out_path_symlink = tmp.join(\"out_symlink.txt\");\n+\n+        check!(fs::write(&in_path, \"foo\"));\n+        check!(fs::write(&out_path, \"bar\"));\n+        check!(symlink_file(&out_path, &out_path_symlink));\n+\n+        check!(fs::copy(&in_path, &out_path_symlink));\n+\n+        assert!(check!(out_path_symlink.symlink_metadata()).file_type().is_symlink());\n+        assert_eq!(check!(fs::read(&out_path_symlink)), b\"foo\".to_vec());\n+        assert_eq!(check!(fs::read(&out_path)), b\"foo\".to_vec());\n+    }\n+\n     #[test]\n     fn symlinks_work() {\n         let tmpdir = tmpdir();"}, {"sha": "7ff098bc9e1237fd288beb1c2ecfa4a7cb8d9ea3", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 86, "deletions": 1, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/ccbf754e351da26f48c76f228831cd12c064053d/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccbf754e351da26f48c76f228831cd12c064053d/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=ccbf754e351da26f48c76f228831cd12c064053d", "patch": "@@ -827,7 +827,10 @@ pub fn canonicalize(p: &Path) -> io::Result<PathBuf> {\n     Ok(PathBuf::from(OsString::from_vec(buf)))\n }\n \n-#[cfg(not(any(target_os = \"linux\", target_os = \"android\")))]\n+#[cfg(not(any(target_os = \"linux\",\n+              target_os = \"android\",\n+              target_os = \"macos\",\n+              target_os = \"ios\")))]\n pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n     use crate::fs::File;\n     if !from.is_file() {\n@@ -937,3 +940,85 @@ pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n     writer.set_permissions(perm)?;\n     Ok(written)\n }\n+\n+#[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n+pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n+    const COPYFILE_ACL: u32 = 1 << 0;\n+    const COPYFILE_STAT: u32 = 1 << 1;\n+    const COPYFILE_XATTR: u32 = 1 << 2;\n+    const COPYFILE_DATA: u32 = 1 << 3;\n+\n+    const COPYFILE_SECURITY: u32 = COPYFILE_STAT | COPYFILE_ACL;\n+    const COPYFILE_METADATA: u32 = COPYFILE_SECURITY | COPYFILE_XATTR;\n+    const COPYFILE_ALL: u32 = COPYFILE_METADATA | COPYFILE_DATA;\n+\n+    const COPYFILE_STATE_COPIED: u32 = 8;\n+\n+    #[allow(non_camel_case_types)]\n+    type copyfile_state_t = *mut libc::c_void;\n+    #[allow(non_camel_case_types)]\n+    type copyfile_flags_t = u32;\n+\n+    extern \"C\" {\n+        fn copyfile(\n+            from: *const libc::c_char,\n+            to: *const libc::c_char,\n+            state: copyfile_state_t,\n+            flags: copyfile_flags_t,\n+        ) -> libc::c_int;\n+        fn copyfile_state_alloc() -> copyfile_state_t;\n+        fn copyfile_state_free(state: copyfile_state_t) -> libc::c_int;\n+        fn copyfile_state_get(\n+            state: copyfile_state_t,\n+            flag: u32,\n+            dst: *mut libc::c_void,\n+        ) -> libc::c_int;\n+    }\n+\n+    struct FreeOnDrop(copyfile_state_t);\n+    impl Drop for FreeOnDrop {\n+        fn drop(&mut self) {\n+            // The code below ensures that `FreeOnDrop` is never a null pointer\n+            unsafe {\n+                // `copyfile_state_free` returns -1 if the `to` or `from` files\n+                // cannot be closed. However, this is not considerd this an\n+                // error.\n+                copyfile_state_free(self.0);\n+            }\n+        }\n+    }\n+\n+    if !from.is_file() {\n+        return Err(Error::new(ErrorKind::InvalidInput,\n+                              \"the source path is not an existing regular file\"))\n+    }\n+\n+    // We ensure that `FreeOnDrop` never contains a null pointer so it is\n+    // always safe to call `copyfile_state_free`\n+    let state = unsafe {\n+        let state = copyfile_state_alloc();\n+        if state.is_null() {\n+            return Err(crate::io::Error::last_os_error());\n+        }\n+        FreeOnDrop(state)\n+    };\n+\n+    cvt(unsafe {\n+        copyfile(\n+            cstr(from)?.as_ptr(),\n+            cstr(to)?.as_ptr(),\n+            state.0,\n+            COPYFILE_ALL,\n+        )\n+    })?;\n+\n+    let mut bytes_copied: libc::off_t = 0;\n+    cvt(unsafe {\n+        copyfile_state_get(\n+            state.0,\n+            COPYFILE_STATE_COPIED,\n+            &mut bytes_copied as *mut libc::off_t as *mut libc::c_void,\n+        )\n+    })?;\n+    Ok(bytes_copied as u64)\n+}"}]}