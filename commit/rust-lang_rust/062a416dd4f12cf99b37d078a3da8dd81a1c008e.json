{"sha": "062a416dd4f12cf99b37d078a3da8dd81a1c008e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2MmE0MTZkZDRmMTJjZjk5YjM3ZDA3OGEzZGE4ZGQ4MWExYzAwOGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-06T16:01:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-06T16:01:25Z"}, "message": "Auto merge of #52010 - toidiu:ak-crossCrateOutlives, r=nikomatsakis\n\nFix: infer outlives requirements across crates\n\nFixes https://github.com/rust-lang/rust/issues/51858", "tree": {"sha": "628c1f3af52ed2cb499d149534259f2f74e93882", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/628c1f3af52ed2cb499d149534259f2f74e93882"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/062a416dd4f12cf99b37d078a3da8dd81a1c008e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/062a416dd4f12cf99b37d078a3da8dd81a1c008e", "html_url": "https://github.com/rust-lang/rust/commit/062a416dd4f12cf99b37d078a3da8dd81a1c008e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/062a416dd4f12cf99b37d078a3da8dd81a1c008e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "50302821c4f63f487783762c1b45b412c2574334", "url": "https://api.github.com/repos/rust-lang/rust/commits/50302821c4f63f487783762c1b45b412c2574334", "html_url": "https://github.com/rust-lang/rust/commit/50302821c4f63f487783762c1b45b412c2574334"}, {"sha": "3f616cb8c1831948a40beca8fb117e920df5a7a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f616cb8c1831948a40beca8fb117e920df5a7a8", "html_url": "https://github.com/rust-lang/rust/commit/3f616cb8c1831948a40beca8fb117e920df5a7a8"}], "stats": {"total": 234, "additions": 130, "deletions": 104}, "files": [{"sha": "a7ecfc269f35badcdc81d4474c1a210945a69f39", "filename": "src/librustc_typeck/outlives/explicit.rs", "status": "modified", "additions": 48, "deletions": 59, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/062a416dd4f12cf99b37d078a3da8dd81a1c008e/src%2Flibrustc_typeck%2Foutlives%2Fexplicit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/062a416dd4f12cf99b37d078a3da8dd81a1c008e/src%2Flibrustc_typeck%2Foutlives%2Fexplicit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fexplicit.rs?ref=062a416dd4f12cf99b37d078a3da8dd81a1c008e", "patch": "@@ -8,77 +8,66 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc::hir;\n-use rustc::hir::def_id::{CrateNum, DefId};\n-use rustc::hir::itemlikevisit::ItemLikeVisitor;\n-use rustc::ty::{self, TyCtxt};\n+use rustc::hir::def_id::DefId;\n+use rustc::ty::{self, OutlivesPredicate, TyCtxt};\n use util::nodemap::FxHashMap;\n \n use super::utils::*;\n \n-pub fn explicit_predicates<'tcx>(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n-    crate_num: CrateNum,\n-) -> FxHashMap<DefId, RequiredPredicates<'tcx>> {\n-    let mut predicates = FxHashMap::default();\n-\n-    // iterate over the entire crate\n-    tcx.hir.krate().visit_all_item_likes(&mut ExplicitVisitor {\n-        tcx: tcx,\n-        explicit_predicates: &mut predicates,\n-        crate_num: crate_num,\n-    });\n-\n-    predicates\n+#[derive(Debug)]\n+pub struct ExplicitPredicatesMap<'tcx> {\n+    map: FxHashMap<DefId, RequiredPredicates<'tcx>>,\n }\n \n-pub struct ExplicitVisitor<'cx, 'tcx: 'cx> {\n-    tcx: TyCtxt<'cx, 'tcx, 'tcx>,\n-    explicit_predicates: &'cx mut FxHashMap<DefId, RequiredPredicates<'tcx>>,\n-    crate_num: CrateNum,\n-}\n+impl<'tcx> ExplicitPredicatesMap<'tcx> {\n+    pub fn new() -> ExplicitPredicatesMap<'tcx> {\n+        ExplicitPredicatesMap {\n+            map: FxHashMap::default(),\n+        }\n+    }\n \n-impl<'cx, 'tcx> ItemLikeVisitor<'tcx> for ExplicitVisitor<'cx, 'tcx> {\n-    fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        let def_id = DefId {\n-            krate: self.crate_num,\n-            index: item.hir_id.owner,\n-        };\n+    pub fn explicit_predicates_of(\n+        &mut self,\n+        tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+        def_id: DefId,\n+    ) -> &RequiredPredicates<'tcx> {\n+        self.map.entry(def_id).or_insert_with(|| {\n+            let predicates = if def_id.is_local() {\n+                tcx.explicit_predicates_of(def_id).predicates\n+            } else {\n+                tcx.predicates_of(def_id).predicates\n+            };\n+            let mut required_predicates = RequiredPredicates::default();\n \n-        let mut required_predicates = RequiredPredicates::default();\n-        let local_explicit_predicate = self.tcx.explicit_predicates_of(def_id).predicates;\n+            // process predicates and convert to `RequiredPredicates` entry, see below\n+            for pred in predicates.into_iter() {\n+                match pred {\n+                    ty::Predicate::TypeOutlives(predicate) => {\n+                        let OutlivesPredicate(ref ty, ref reg) = predicate.skip_binder();\n+                        insert_outlives_predicate(tcx, (*ty).into(), reg, &mut required_predicates)\n+                    }\n \n-        for pred in local_explicit_predicate.into_iter() {\n-            match pred {\n-                ty::Predicate::TypeOutlives(predicate) => {\n-                    let ty::OutlivesPredicate(ref ty, ref reg) = predicate.skip_binder();\n-                    insert_outlives_predicate(self.tcx, (*ty).into(), reg, &mut required_predicates)\n-                }\n+                    ty::Predicate::RegionOutlives(predicate) => {\n+                        let OutlivesPredicate(ref reg1, ref reg2) = predicate.skip_binder();\n+                        insert_outlives_predicate(\n+                            tcx,\n+                            (*reg1).into(),\n+                            reg2,\n+                            &mut required_predicates,\n+                        )\n+                    }\n \n-                ty::Predicate::RegionOutlives(predicate) => {\n-                    let ty::OutlivesPredicate(ref reg1, ref reg2) = predicate.skip_binder();\n-                    insert_outlives_predicate(\n-                        self.tcx,\n-                        (*reg1).into(),\n-                        reg2,\n-                        &mut required_predicates,\n-                    )\n+                    ty::Predicate::Trait(..)\n+                    | ty::Predicate::Projection(..)\n+                    | ty::Predicate::WellFormed(..)\n+                    | ty::Predicate::ObjectSafe(..)\n+                    | ty::Predicate::ClosureKind(..)\n+                    | ty::Predicate::Subtype(..)\n+                    | ty::Predicate::ConstEvaluatable(..) => (),\n                 }\n-\n-                ty::Predicate::Trait(..)\n-                | ty::Predicate::Projection(..)\n-                | ty::Predicate::WellFormed(..)\n-                | ty::Predicate::ObjectSafe(..)\n-                | ty::Predicate::ClosureKind(..)\n-                | ty::Predicate::Subtype(..)\n-                | ty::Predicate::ConstEvaluatable(..) => (),\n             }\n-        }\n \n-        self.explicit_predicates.insert(def_id, required_predicates);\n+            required_predicates\n+        })\n     }\n-\n-    fn visit_trait_item(&mut self, _trait_item: &'tcx hir::TraitItem) {}\n-\n-    fn visit_impl_item(&mut self, _impl_item: &'tcx hir::ImplItem) {}\n }"}, {"sha": "a015122d62e74a17902062f7506b22d02003267d", "filename": "src/librustc_typeck/outlives/implicit_infer.rs", "status": "modified", "additions": 45, "deletions": 43, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/062a416dd4f12cf99b37d078a3da8dd81a1c008e/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/062a416dd4f12cf99b37d078a3da8dd81a1c008e/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs?ref=062a416dd4f12cf99b37d078a3da8dd81a1c008e", "patch": "@@ -15,6 +15,7 @@ use rustc::ty::subst::{Kind, Subst, UnpackedKind};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::util::nodemap::FxHashMap;\n \n+use super::explicit::ExplicitPredicatesMap;\n use super::utils::*;\n \n /// Infer predicates for the items in the crate.\n@@ -24,7 +25,7 @@ use super::utils::*;\n ///     now be filled with inferred predicates.\n pub fn infer_predicates<'tcx>(\n     tcx: TyCtxt<'_, 'tcx, 'tcx>,\n-    explicit_map: &FxHashMap<DefId, RequiredPredicates<'tcx>>,\n+    explicit_map: &mut ExplicitPredicatesMap<'tcx>,\n ) -> FxHashMap<DefId, RequiredPredicates<'tcx>> {\n     debug!(\"infer_predicates\");\n \n@@ -55,7 +56,7 @@ pub struct InferVisitor<'cx, 'tcx: 'cx> {\n     tcx: TyCtxt<'cx, 'tcx, 'tcx>,\n     global_inferred_outlives: &'cx mut FxHashMap<DefId, RequiredPredicates<'tcx>>,\n     predicates_added: &'cx mut bool,\n-    explicit_map: &'cx FxHashMap<DefId, RequiredPredicates<'tcx>>,\n+    explicit_map: &'cx mut ExplicitPredicatesMap<'tcx>,\n }\n \n impl<'cx, 'tcx> ItemLikeVisitor<'tcx> for InferVisitor<'cx, 'tcx> {\n@@ -93,7 +94,7 @@ impl<'cx, 'tcx> ItemLikeVisitor<'tcx> for InferVisitor<'cx, 'tcx> {\n                         field_ty,\n                         self.global_inferred_outlives,\n                         &mut item_required_predicates,\n-                        self.explicit_map,\n+                        &mut self.explicit_map,\n                     );\n                 }\n             }\n@@ -129,7 +130,7 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n     field_ty: Ty<'tcx>,\n     global_inferred_outlives: &FxHashMap<DefId, RequiredPredicates<'tcx>>,\n     required_predicates: &mut RequiredPredicates<'tcx>,\n-    explicit_map: &FxHashMap<DefId, RequiredPredicates<'tcx>>,\n+    explicit_map: &mut ExplicitPredicatesMap<'tcx>,\n ) {\n     for ty in field_ty.walk() {\n         match ty.sty {\n@@ -257,53 +258,54 @@ pub fn check_explicit_predicates<'tcx>(\n     def_id: &DefId,\n     substs: &[Kind<'tcx>],\n     required_predicates: &mut RequiredPredicates<'tcx>,\n-    explicit_map: &FxHashMap<DefId, RequiredPredicates<'tcx>>,\n+    explicit_map: &mut ExplicitPredicatesMap<'tcx>,\n     ignore_self_ty: bool,\n ) {\n     debug!(\"def_id = {:?}\", &def_id);\n     debug!(\"substs = {:?}\", &substs);\n     debug!(\"explicit_map =  {:?}\", explicit_map);\n     debug!(\"required_predicates = {:?}\", required_predicates);\n-    if let Some(explicit_predicates) = explicit_map.get(def_id) {\n-        for outlives_predicate in explicit_predicates.iter() {\n-            debug!(\"outlives_predicate = {:?}\", &outlives_predicate);\n+    let explicit_predicates = explicit_map.explicit_predicates_of(tcx, *def_id);\n \n-            // Careful: If we are inferring the effects of a `dyn Trait<..>`\n-            // type, then when we look up the predicates for `Trait`,\n-            // we may find some that reference `Self`. e.g., perhaps the\n-            // definition of `Trait` was:\n-            //\n-            // ```\n-            // trait Trait<'a, T> where Self: 'a  { .. }\n-            // ```\n-            //\n-            // we want to ignore such predicates here, because\n-            // there is no type parameter for them to affect. Consider\n-            // a struct containing `dyn Trait`:\n-            //\n-            // ```\n-            // struct MyStruct<'x, X> { field: Box<dyn Trait<'x, X>> }\n-            // ```\n-            //\n-            // The `where Self: 'a` predicate refers to the *existential, hidden type*\n-            // that is represented by the `dyn Trait`, not to the `X` type parameter\n-            // (or any other generic parameter) declared on `MyStruct`.\n-            //\n-            // Note that we do this check for self **before** applying `substs`. In the\n-            // case that `substs` come from a `dyn Trait` type, our caller will have\n-            // included `Self = dyn Trait<'x, X>` as the value for `Self`. If we were\n-            // to apply the substs, and not filter this predicate, we might then falsely\n-            // conclude that e.g. `X: 'x` was a reasonable inferred requirement.\n-            if let UnpackedKind::Type(ty) = outlives_predicate.0.unpack() {\n-                if ty.is_self() && ignore_self_ty {\n-                    debug!(\"skipping self ty = {:?}\", &ty);\n-                    continue;\n-                }\n-            }\n+    for outlives_predicate in explicit_predicates.iter() {\n+        debug!(\"outlives_predicate = {:?}\", &outlives_predicate);\n \n-            let predicate = outlives_predicate.subst(tcx, substs);\n-            debug!(\"predicate = {:?}\", &predicate);\n-            insert_outlives_predicate(tcx, predicate.0.into(), predicate.1, required_predicates);\n+        // Careful: If we are inferring the effects of a `dyn Trait<..>`\n+        // type, then when we look up the predicates for `Trait`,\n+        // we may find some that reference `Self`. e.g., perhaps the\n+        // definition of `Trait` was:\n+        //\n+        // ```\n+        // trait Trait<'a, T> where Self: 'a  { .. }\n+        // ```\n+        //\n+        // we want to ignore such predicates here, because\n+        // there is no type parameter for them to affect. Consider\n+        // a struct containing `dyn Trait`:\n+        //\n+        // ```\n+        // struct MyStruct<'x, X> { field: Box<dyn Trait<'x, X>> }\n+        // ```\n+        //\n+        // The `where Self: 'a` predicate refers to the *existential, hidden type*\n+        // that is represented by the `dyn Trait`, not to the `X` type parameter\n+        // (or any other generic parameter) declared on `MyStruct`.\n+        //\n+        // Note that we do this check for self **before** applying `substs`. In the\n+        // case that `substs` come from a `dyn Trait` type, our caller will have\n+        // included `Self = dyn Trait<'x, X>` as the value for `Self`. If we were\n+        // to apply the substs, and not filter this predicate, we might then falsely\n+        // conclude that e.g. `X: 'x` was a reasonable inferred requirement.\n+        if let UnpackedKind::Type(ty) = outlives_predicate.0.unpack() {\n+            if ty.is_self() && ignore_self_ty {\n+                debug!(\"skipping self ty = {:?}\", &ty);\n+                continue;\n+            }\n         }\n+\n+        let predicate = outlives_predicate.subst(tcx, substs);\n+        debug!(\"predicate = {:?}\", &predicate);\n+        insert_outlives_predicate(tcx, predicate.0.into(), predicate.1, required_predicates);\n     }\n+    // }\n }"}, {"sha": "9c483924992d48384858c5f31a70011b9f78420f", "filename": "src/librustc_typeck/outlives/mod.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/062a416dd4f12cf99b37d078a3da8dd81a1c008e/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/062a416dd4f12cf99b37d078a3da8dd81a1c008e/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs?ref=062a416dd4f12cf99b37d078a3da8dd81a1c008e", "patch": "@@ -84,6 +84,8 @@ fn inferred_outlives_crate<'tcx>(\n     tcx: TyCtxt<'_, 'tcx, 'tcx>,\n     crate_num: CrateNum,\n ) -> Lrc<CratePredicatesMap<'tcx>> {\n+    assert_eq!(crate_num, LOCAL_CRATE);\n+\n     // Compute a map from each struct/enum/union S to the **explicit**\n     // outlives predicates (`T: 'a`, `'a: 'b`) that the user wrote.\n     // Typically there won't be many of these, except in older code where\n@@ -92,8 +94,9 @@ fn inferred_outlives_crate<'tcx>(\n     // for the type.\n \n     // Compute the inferred predicates\n-    let exp = explicit::explicit_predicates(tcx, crate_num);\n-    let global_inferred_outlives = implicit_infer::infer_predicates(tcx, &exp);\n+    let mut exp_map = explicit::ExplicitPredicatesMap::new();\n+\n+    let global_inferred_outlives = implicit_infer::infer_predicates(tcx, &mut exp_map);\n \n     // Convert the inferred predicates into the \"collected\" form the\n     // global data structure expects."}, {"sha": "016739978834b0c9558a94374073ba311f0c8aef", "filename": "src/test/ui/rfc-2093-infer-outlives/cross-crate.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/062a416dd4f12cf99b37d078a3da8dd81a1c008e/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fcross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/062a416dd4f12cf99b37d078a3da8dd81a1c008e/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fcross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fcross-crate.rs?ref=062a416dd4f12cf99b37d078a3da8dd81a1c008e", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs)]\n+#![feature(infer_outlives_requirements)]\n+\n+#[rustc_outlives]\n+struct Foo<'a, T> { //~ ERROR 15:1: 17:2: rustc_outlives\n+    bar: std::slice::IterMut<'a, T>\n+}\n+\n+fn main() {}\n+"}, {"sha": "a90643ae8916be2a7d27772495ef7555af2064aa", "filename": "src/test/ui/rfc-2093-infer-outlives/cross-crate.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/062a416dd4f12cf99b37d078a3da8dd81a1c008e/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fcross-crate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/062a416dd4f12cf99b37d078a3da8dd81a1c008e/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fcross-crate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fcross-crate.stderr?ref=062a416dd4f12cf99b37d078a3da8dd81a1c008e", "patch": "@@ -0,0 +1,12 @@\n+error: rustc_outlives\n+  --> $DIR/cross-crate.rs:15:1\n+   |\n+LL | / struct Foo<'a, T> { //~ ERROR 15:1: 17:2: rustc_outlives\n+LL | |     bar: std::slice::IterMut<'a, T>\n+LL | | }\n+   | |_^\n+   |\n+   = note: T : 'a\n+\n+error: aborting due to previous error\n+"}]}