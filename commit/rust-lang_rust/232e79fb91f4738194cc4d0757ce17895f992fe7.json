{"sha": "232e79fb91f4738194cc4d0757ce17895f992fe7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIzMmU3OWZiOTFmNDczODE5NGNjNGQwNzU3Y2UxNzg5NWY5OTJmZTc=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-04-01T20:22:09Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-04-01T20:22:09Z"}, "message": "rollup merge of #23568: steveklabnik/closure_docs\n\n[rendered](https://github.com/steveklabnik/rust/blob/closure_docs/src/doc/trpl/closures.md)\n\nr? @nikomatsakis", "tree": {"sha": "82ecdda939056b2785bed63fe56ae3963576ada8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/82ecdda939056b2785bed63fe56ae3963576ada8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/232e79fb91f4738194cc4d0757ce17895f992fe7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/232e79fb91f4738194cc4d0757ce17895f992fe7", "html_url": "https://github.com/rust-lang/rust/commit/232e79fb91f4738194cc4d0757ce17895f992fe7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/232e79fb91f4738194cc4d0757ce17895f992fe7/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec6c2c3fc57170719d7bcfbdc40536c73b550824", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec6c2c3fc57170719d7bcfbdc40536c73b550824", "html_url": "https://github.com/rust-lang/rust/commit/ec6c2c3fc57170719d7bcfbdc40536c73b550824"}, {"sha": "eac94fa097934e9329c65a3471949b228b098d1d", "url": "https://api.github.com/repos/rust-lang/rust/commits/eac94fa097934e9329c65a3471949b228b098d1d", "html_url": "https://github.com/rust-lang/rust/commit/eac94fa097934e9329c65a3471949b228b098d1d"}], "stats": {"total": 538, "additions": 401, "deletions": 137}, "files": [{"sha": "01b8163ffd372b89c75843e419dcc9bc968546e8", "filename": "src/doc/trpl/closures.md", "status": "modified", "additions": 401, "deletions": 137, "changes": 538, "blob_url": "https://github.com/rust-lang/rust/blob/232e79fb91f4738194cc4d0757ce17895f992fe7/src%2Fdoc%2Ftrpl%2Fclosures.md", "raw_url": "https://github.com/rust-lang/rust/raw/232e79fb91f4738194cc4d0757ce17895f992fe7/src%2Fdoc%2Ftrpl%2Fclosures.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fclosures.md?ref=232e79fb91f4738194cc4d0757ce17895f992fe7", "patch": "@@ -1,214 +1,478 @@\n % Closures\n \n-So far, we've made lots of functions in Rust, but we've given them all names.\n-Rust also allows us to create anonymous functions. Rust's anonymous\n-functions are called *closures*. By themselves, closures aren't all that\n-interesting, but when you combine them with functions that take closures as\n-arguments, really powerful things are possible.\n+Rust not only has named functions, but anonymous functions as well. Anonymous\n+functions that have an associated environment are called 'closures', because they\n+close over an environment. Rust has a really great implementation of them, as\n+we'll see.\n \n-Let's make a closure:\n+# Syntax\n \n-```{rust}\n-let add_one = |x| { 1 + x };\n+Closures look like this:\n \n-println!(\"The sum of 5 plus 1 is {}.\", add_one(5));\n+```rust\n+let plus_one = |x: i32| x + 1;\n+\n+assert_eq!(2, plus_one(1));\n+```\n+\n+We create a binding, `plus_one`, and assign it to a closure. The closure's\n+arguments go between the pipes (`|`), and the body is an expression, in this\n+case, `x + 1`. Remember that `{ }` is an expression, so we can have multi-line\n+closures too:\n+\n+```rust\n+let plus_two = |x| {\n+    let mut result: i32 = x;\n+\n+    result += 1;\n+    result += 1;\n+\n+    result\n+};\n+\n+assert_eq!(4, plus_two(2));\n+```\n+\n+You'll notice a few things about closures that are a bit different than regular\n+functions defined with `fn`. The first of which is that we did not need to\n+annotate the types of arguments the closure takes or the values it returns. We\n+can:\n+\n+```rust\n+let plus_one = |x: i32| -> i32 { x + 1 };\n+\n+assert_eq!(2, plus_one(1));\n+```\n+\n+But we don't have to. Why is this? Basically, it was chosen for ergonomic reasons.\n+While specifying the full type for named functions is helpful with things like\n+documentation and type inference, the types of closures are rarely documented\n+since they\u2019re anonymous, and they don\u2019t cause the kinds of error-at-a-distance\n+that inferring named function types can.\n+\n+The second is that the syntax is similar, but a bit different. I've added spaces\n+here to make them look a little closer:\n+\n+```rust\n+fn  plus_one_v1 (  x: i32 ) -> i32 { x + 1 }\n+let plus_one_v2 = |x: i32 | -> i32 { x + 1 };\n+let plus_one_v3 = |x: i32 |          x + 1  ;\n ```\n \n-We create a closure using the `|...| { ... }` syntax, and then we create a\n-binding so we can use it later. Note that we call the function using the\n-binding name and two parentheses, just like we would for a named function.\n+Small differences, but they're similar in ways.\n \n-Let's compare syntax. The two are pretty close:\n+# Closures and their environment\n \n-```{rust}\n-let add_one = |x: i32| -> i32 { 1 + x };\n-fn  add_one   (x: i32) -> i32 { 1 + x }\n+Closures are called such because they 'close over their environment.' It\n+looks like this:\n+\n+```rust\n+let num = 5;\n+let plus_num = |x: i32| x + num;\n+\n+assert_eq!(10, plus_num(5));\n ```\n \n-As you may have noticed, closures infer their argument and return types, so you\n-don't need to declare one. This is different from named functions, which\n-default to returning unit (`()`).\n+This closure, `plus_num`, refers to a `let` binding in its scope: `num`. More\n+specifically, it borrows the binding. If we do something that would conflict\n+with that binding, we get an error. Like this one:\n+\n+```rust,ignore\n+let mut num = 5;\n+let plus_num = |x: i32| x + num;\n \n-There's one big difference between a closure and named functions, and it's in\n-the name: a closure \"closes over its environment.\" What does that mean? It means\n-this:\n+let y = &mut num;\n+```\n \n-```{rust}\n+Which errors with:\n+\n+```text\n+error: cannot borrow `num` as mutable because it is also borrowed as immutable\n+    let y = &mut num;\n+                 ^~~\n+note: previous borrow of `num` occurs here due to use in closure; the immutable\n+  borrow prevents subsequent moves or mutable borrows of `num` until the borrow\n+  ends\n+    let plus_num = |x| x + num;\n+                   ^~~~~~~~~~~\n+note: previous borrow ends here\n fn main() {\n-    let x: i32 = 5;\n+    let mut num = 5;\n+    let plus_num = |x| x + num;\n+    \n+    let y = &mut num;\n+}\n+^\n+```\n+\n+A verbose yet helpful error message! As it says, we can't take a mutable borrow\n+on `num` because the closure is already borrowing it. If we let the closure go\n+out of scope, we can:\n+\n+```rust\n+let mut num = 5;\n+{\n+    let plus_num = |x: i32| x + num;\n+\n+} // plus_num goes out of scope, borrow of num ends\n \n-    let printer = || { println!(\"x is: {}\", x); };\n+let y = &mut num;\n+```\n+\n+If your closure requires it, however, Rust will take ownership and move\n+the environment instead:\n+\n+```rust,ignore\n+let nums = vec![1, 2, 3];\n+\n+let takes_nums = || nums;\n+\n+println!(\"{:?}\", nums);\n+```\n+\n+This gives us:\n+\n+```text\n+note: `nums` moved into closure environment here because it has type\n+  `[closure(()) -> collections::vec::Vec<i32>]`, which is non-copyable\n+let takes_nums = || nums;\n+                    ^~~~~~~\n+```\n+\n+`Vec<T>` has ownership over its contents, and therefore, when we refer to it\n+in our closure, we have to take ownership of `nums`. It's the same as if we'd\n+passed `nums` to a function that took ownership of it.\n+\n+## `move` closures\n+\n+We can force our closure to take ownership of its environment with the `move`\n+keyword:\n \n-    printer(); // prints \"x is: 5\"\n+```rust\n+let num = 5;\n+\n+let owns_num = move |x: i32| x + num;\n+```\n+\n+Now, even though the keyword is `move`, the variables follow normal move semantics.\n+In this case, `5` implements `Copy`, and so `owns_num` takes ownership of a copy\n+of `num`. So what's the difference?\n+\n+```rust\n+let mut num = 5;\n+\n+{ \n+    let mut add_num = |x: i32| num += x;\n+\n+    add_num(5);\n }\n+\n+assert_eq!(10, num);\n ```\n \n-The `||` syntax means this is an anonymous closure that takes no arguments.\n-Without it, we'd just have a block of code in `{}`s.\n+So in this case, our closure took a mutable reference to `num`, and then when\n+we called `add_num`, it mutated the underlying value, as we'd expect. We also\n+needed to declare `add_num` as `mut` too, because we\u2019re mutating its\n+environment.\n \n-In other words, a closure has access to variables in the scope where it's\n-defined. The closure borrows any variables it uses, so this will error:\n+We also had to declare `add_num` as mut, since we will be modifying its\n+environment.\n \n-```{rust,ignore}\n-fn main() {\n-    let mut x: i32 = 5;\n+If we change to a `move` closure, it's different:\n+\n+```rust\n+let mut num = 5;\n \n-    let printer = || { println!(\"x is: {}\", x); };\n+{ \n+    let mut add_num = move |x: i32| num += x;\n \n-    x = 6; // error: cannot assign to `x` because it is borrowed\n+    add_num(5);\n }\n+\n+assert_eq!(5, num);\n ```\n \n-## Moving closures\n+We only get `5`. Rather than taking a mutable borrow out on our `num`, we took\n+ownership of a copy.\n+\n+Another way to think about `move` closures: they give a closure its own stack\n+frame.  Without `move`, a closure may be tied to the stack frame that created\n+it, while a `move` closure is self-contained. This means that you cannot\n+generally return a non-`move` closure from a function, for example.\n+\n+But before we talk about taking and returning closures, we should talk some more\n+about the way that closures are implemented. As a systems language, Rust gives\n+you tons of control over what your code does, and closures are no different.\n \n-Rust has a second type of closure, called a *moving closure*. Moving\n-closures are indicated using the `move` keyword (e.g., `move || x *\n-x`). The difference between a moving closure and an ordinary closure\n-is that a moving closure always takes ownership of all variables that\n-it uses. Ordinary closures, in contrast, just create a reference into\n-the enclosing stack frame. Moving closures are most useful with Rust's\n-concurrency features, and so we'll just leave it at this for\n-now. We'll talk about them more in the \"Concurrency\" chapter of the book.\n+# Closure implementation\n \n-## Accepting closures as arguments\n+Rust's implementation of closures is a bit different than other languages. They\n+are effectively syntax sugar for traits. You'll want to make sure to have read\n+the [traits chapter][traits] before this one, as well as the chapter on [static\n+and dynamic dispatch][dispatch], which talks about trait objects.\n \n-Closures are most useful as an argument to another function. Here's an example:\n+[traits]: traits.html\n+[dispatch]: static-and-dynamic-dispatch.html\n \n-```{rust}\n-fn twice<F: Fn(i32) -> i32>(x: i32, f: F) -> i32 {\n-    f(x) + f(x)\n+Got all that? Good.\n+\n+The key to understanding how closures work under the hood is something a bit\n+strange: Using `()` to call a function, like `foo()`, is an overloadable\n+operator. From this, everything else clicks into place. In Rust, we use the\n+trait system to overload operators. Calling functions is no different. We have\n+three separate traits to overload with:\n+\n+```rust\n+# mod foo {\n+pub trait Fn<Args> : FnMut<Args> {\n+    extern \"rust-call\" fn call(&self, args: Args) -> Self::Output;\n }\n \n-fn main() {\n-    let square = |x: i32| { x * x };\n+pub trait FnMut<Args> : FnOnce<Args> {\n+    extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n+}\n+\n+pub trait FnOnce<Args> {\n+    type Output;\n \n-    twice(5, square); // evaluates to 50\n+    extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n }\n+# }\n ```\n \n-Let's break the example down, starting with `main`:\n+You'll notice a few differences between these traits, but a big one is `self`:\n+`Fn` takes `&self`, `FnMut` takes `&mut self`, and `FnOnce` takes `self`. This\n+covers all three kinds of `self` via the usual method call syntax. But we've\n+split them up into three traits, rather than having a single one. This gives us\n+a large amount of control over what kind of closures we can take.\n \n-```{rust}\n-let square = |x: i32| { x * x };\n-```\n+The `|| {}` syntax for closures is sugar for these three traits. Rust will\n+generate a struct for the environment, `impl` the appropriate trait, and then\n+use it.\n+\n+# Taking closures as arguments\n+\n+Now that we know that closures are traits, we already know how to accept and\n+return closures: just like any other trait!\n+\n+This also means that we can choose static vs dynamic dispatch as well. First,\n+let's write a function which takes something callable, calls it, and returns\n+the result:\n+\n+```rust\n+fn call_with_one<F>(some_closure: F) -> i32\n+    where F : Fn(i32) -> i32 {\n+\n+    some_closure(1)\n+}\n \n-We've seen this before. We make a closure that takes an integer, and returns\n-its square.\n+let answer = call_with_one(|x| x + 2);\n \n-```{rust}\n-# fn twice<F: Fn(i32) -> i32>(x: i32, f: F) -> i32 { f(x) + f(x) }\n-# let square = |x: i32| { x * x };\n-twice(5, square); // evaluates to 50\n+assert_eq!(3, answer);\n ```\n \n-This line is more interesting. Here, we call our function, `twice`, and we pass\n-it two arguments: an integer, `5`, and our closure, `square`. This is just like\n-passing any other two variable bindings to a function, but if you've never\n-worked with closures before, it can seem a little complex. Just think: \"I'm\n-passing two variables: one is an i32, and one is a function.\"\n+We pass our closure, `|x| x + 2`, to `call_with_one`. It just does what it\n+suggests: it calls the closure, giving it `1` as an argument.\n \n-Next, let's look at how `twice` is defined:\n+Let's examine the signature of `call_with_one` in more depth:\n \n-```{rust,ignore}\n-fn twice<F: Fn(i32) -> i32>(x: i32, f: F) -> i32 {\n+```rust\n+fn call_with_one<F>(some_closure: F) -> i32\n+#    where F : Fn(i32) -> i32 {\n+#    some_closure(1) }\n ```\n \n-`twice` takes two arguments, `x` and `f`. That's why we called it with two\n-arguments. `x` is an `i32`, we've done that a ton of times. `f` is a function,\n-though, and that function takes an `i32` and returns an `i32`. This is\n-what the requirement `Fn(i32) -> i32` for the type parameter `F` says.\n-Now `F` represents *any* function that takes an `i32` and returns an `i32`.\n+We take one parameter, and it has the type `F`. We also return a `i32`. This part\n+isn't interesting. The next part is:\n \n-This is the most complicated function signature we've seen yet! Give it a read\n-a few times until you can see how it works. It takes a teeny bit of practice, and\n-then it's easy. The good news is that this kind of passing a closure around\n-can be very efficient. With all the type information available at compile-time\n-the compiler can do wonders.\n+```rust\n+# fn call_with_one<F>(some_closure: F) -> i32\n+    where F : Fn(i32) -> i32 {\n+#   some_closure(1) }\n+```\n+\n+Because `Fn` is a trait, we can bound our generic with it. In this case, our closure\n+takes a `i32` as an argument and returns an `i32`, and so the generic bound we use\n+is `Fn(i32) -> i32`.\n \n-Finally, `twice` returns an `i32` as well.\n+There's one other key point here: because we're bounding a generic with a\n+trait, this will get monomorphized, and therefore, we'll be doing static\n+dispatch into the closure. That's pretty neat. In many langauges, closures are\n+inherently heap allocated, and will always involve dynamic dispatch. In Rust,\n+we can stack allocate our closure environment, and statically dispatch the\n+call. This happens quite often with iterators and their adapters, which often\n+take closures as arguments.\n \n-Okay, let's look at the body of `twice`:\n+Of course, if we want dynamic dispatch, we can get that too. A trait object\n+handles this case, as usual:\n \n-```{rust}\n-fn twice<F: Fn(i32) -> i32>(x: i32, f: F) -> i32 {\n-  f(x) + f(x)\n+```rust\n+fn call_with_one(some_closure: &Fn(i32) -> i32) -> i32 {\n+    some_closure(1)\n }\n+\n+let answer = call_with_one(&|x| x + 2);\n+\n+assert_eq!(3, answer);\n ```\n \n-Since our closure is named `f`, we can call it just like we called our closures\n-before, and we pass in our `x` argument to each one, hence the name `twice`.\n+Now we take a trait object, a `&Fn`. And we have to make a reference\n+to our closure when we pass it to `call_with_one`, so we use `&||`.\n \n-If you do the math, `(5 * 5) + (5 * 5) == 50`, so that's the output we get.\n+# Returning closures\n \n-Play around with this concept until you're comfortable with it. Rust's standard\n-library uses lots of closures where appropriate, so you'll be using\n-this technique a lot.\n+It\u2019s very common for functional-style code to return closures in various\n+situations. If you try to return a closure, you may run into an error. At\n+first, it may seem strange, but we'll figure it out. Here's how you'd probably\n+try to return a closure from a function:\n \n-If we didn't want to give `square` a name, we could just define it inline.\n-This example is the same as the previous one:\n+```rust,ignore\n+fn factory() -> (Fn(i32) -> Vec<i32>) {\n+    let vec = vec![1, 2, 3];\n \n-```{rust}\n-fn twice<F: Fn(i32) -> i32>(x: i32, f: F) -> i32 {\n-    f(x) + f(x)\n+    |n| vec.push(n)\n }\n \n-fn main() {\n-    twice(5, |x: i32| { x * x }); // evaluates to 50\n-}\n+let f = factory();\n+\n+let answer = f(4);\n+assert_eq!(vec![1, 2, 3, 4], answer);\n ```\n \n-A named function's name can be used wherever you'd use a closure. Another\n-way of writing the previous example:\n+This gives us these long, related errors:\n+\n+```text\n+error: the trait `core::marker::Sized` is not implemented for the type\n+`core::ops::Fn(i32) -> collections::vec::Vec<i32>` [E0277]\n+f = factory();\n+^\n+note: `core::ops::Fn(i32) -> collections::vec::Vec<i32>` does not have a\n+constant size known at compile-time\n+f = factory();\n+^\n+error: the trait `core::marker::Sized` is not implemented for the type\n+`core::ops::Fn(i32) -> collections::vec::Vec<i32>` [E0277]\n+factory() -> (Fn(i32) -> Vec<i32>) {\n+             ^~~~~~~~~~~~~~~~~~~~~\n+note: `core::ops::Fn(i32) -> collections::vec::Vec<i32>` does not have a constant size known at compile-time\n+fa ctory() -> (Fn(i32) -> Vec<i32>) {\n+              ^~~~~~~~~~~~~~~~~~~~~\n \n-```{rust}\n-fn twice<F: Fn(i32) -> i32>(x: i32, f: F) -> i32 {\n-    f(x) + f(x)\n-}\n+```\n \n-fn square(x: i32) -> i32 { x * x }\n+In order to return something from a function, Rust needs to know what\n+size the return type is. But since `Fn` is a trait, it could be various\n+things of various sizes: many different types can implement `Fn`. An easy\n+way to give something a size is to take a reference to it, as references\n+have a known size. So we'd write this:\n \n-fn main() {\n-    twice(5, square); // evaluates to 50\n+```rust,ignore\n+fn factory() -> &(Fn(i32) -> Vec<i32>) {\n+    let vec = vec![1, 2, 3];\n+\n+    |n| vec.push(n)\n }\n+\n+let f = factory();\n+\n+let answer = f(4);\n+assert_eq!(vec![1, 2, 3, 4], answer);\n+```\n+\n+But we get another error:\n+\n+```text\n+error: missing lifetime specifier [E0106]\n+fn factory() -> &(Fn(i32) -> i32) {\n+                ^~~~~~~~~~~~~~~~~\n ```\n \n-Doing this is not particularly common, but it's useful every once in a while.\n+Right. Because we have a reference, we need to give it a lifetime. But\n+our `factory()` function takes no arguments, so elision doesn't kick in\n+here. What lifetime can we choose? `'static`:\n \n-Before we move on, let us look at a function that accepts two closures.\n+```rust,ignore\n+fn factory() -> &'static (Fn(i32) -> i32) {\n+    let num = 5;\n \n-```{rust}\n-fn compose<F, G>(x: i32, f: F, g: G) -> i32\n-    where F: Fn(i32) -> i32, G: Fn(i32) -> i32 {\n-    g(f(x))\n+    |x| x + num\n }\n \n-fn main() {\n-    compose(5,\n-            |n: i32| { n + 42 },\n-            |n: i32| { n * 2 }); // evaluates to 94\n+let f = factory();\n+\n+let answer = f(1);\n+assert_eq!(6, answer);\n+```\n+\n+But we get another error:\n+\n+```text\n+error: mismatched types:\n+ expected `&'static core::ops::Fn(i32) -> i32`,\n+    found `[closure <anon>:7:9: 7:20]`\n+(expected &-ptr,\n+    found closure) [E0308]\n+         |x| x + num\n+         ^~~~~~~~~~~\n+\n+```\n+\n+This error is letting us know that we don't have a `&'static Fn(i32) -> i32`,\n+we have a `[closure <anon>:7:9: 7:20]`. Wait, what?\n+\n+Because each closure generates its own environment `struct` and implementation\n+of `Fn` and friends, these types are anonymous. They exist just solely for\n+this closure. So Rust shows them as `closure <anon>`, rather than some\n+autogenerated name.\n+\n+But why doesn't our closure implement `&'static Fn`? Well, as we discussed before,\n+closures borrow their environment. And in this case, our environment is based\n+on a stack-allocated `5`, the `num` variable binding. So the borrow has a lifetime\n+of the stack frame. So if we returned this closure, the function call would be\n+over, the stack frame would go away, and our closure is capturing an environment\n+of garbage memory!\n+\n+So what to do? This _almost_ works:\n+\n+```rust,ignore\n+fn factory() -> Box<Fn(i32) -> i32> {\n+    let num = 5;\n+\n+    Box::new(|x| x + num)\n }\n+# fn main() {\n+let f = factory();\n+\n+let answer = f(1);\n+assert_eq!(6, answer);\n+# }\n ```\n \n-You might ask yourself: why do we need to introduce two type\n-parameters `F` and `G` here?  Evidently, both `f` and `g` have the\n-same signature: `Fn(i32) -> i32`.\n+We use a trait object, by `Box`ing up the `Fn`. There's just one last problem:\n \n-That is because in Rust each closure has its own unique type.\n-So, not only do closures with different signatures have different types,\n-but different closures with the *same* signature have *different*\n-types, as well!\n+```text\n+error: `num` does not live long enough\n+Box::new(|x| x + num)\n+         ^~~~~~~~~~~\n+```\n+\n+We still have a reference to the parent stack frame. With one last fix, we can\n+make this work:\n \n-You can think of it this way: the behavior of a closure is part of its\n-type.  Therefore, using a single type parameter for both closures\n-will accept the first of them, rejecting the second. The distinct\n-type of the second closure does not allow it to be represented by the\n-same type parameter as that of the first.  We acknowledge this, and\n-use two different type parameters `F` and `G`.\n+```rust\n+fn factory() -> Box<Fn(i32) -> i32> {\n+    let num = 5;\n \n-This also introduces the `where` clause, which lets us describe type\n-parameters in a more flexible manner.\n+    Box::new(move |x| x + num)\n+}\n+# fn main() {\n+let f = factory();\n+\n+let answer = f(1);\n+assert_eq!(6, answer);\n+# }\n+```\n \n-That's all you need to get the hang of closures! Closures are a little bit\n-strange at first, but once you're used to them, you'll miss them\n-in other languages. Passing functions to other functions is\n-incredibly powerful, as you will see in the following chapter about iterators.\n+By making the inner closure a `move Fn`, we create a new stack frame for our\n+closure. By `Box`ing it up, we've given it a known size, and allowing it to\n+escape our stack frame."}]}