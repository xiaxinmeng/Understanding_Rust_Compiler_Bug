{"sha": "dde41869ce2ef1d66e753fc8b4efc7d917c77875", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkZTQxODY5Y2UyZWYxZDY2ZTc1M2ZjOGI0ZWZjN2Q5MTdjNzc4NzU=", "commit": {"author": {"name": "Haitao Li", "email": "lihaitao@gmail.com", "date": "2012-01-16T10:21:01Z"}, "committer": {"name": "Haitao Li", "email": "lihaitao@gmail.com", "date": "2012-01-18T18:10:36Z"}, "message": "Use ctypes in native function declarations", "tree": {"sha": "ee9ea278fa981a8188a7d4cdb11201df10a81478", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee9ea278fa981a8188a7d4cdb11201df10a81478"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dde41869ce2ef1d66e753fc8b4efc7d917c77875", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dde41869ce2ef1d66e753fc8b4efc7d917c77875", "html_url": "https://github.com/rust-lang/rust/commit/dde41869ce2ef1d66e753fc8b4efc7d917c77875", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dde41869ce2ef1d66e753fc8b4efc7d917c77875/comments", "author": {"login": "lht", "id": 19508, "node_id": "MDQ6VXNlcjE5NTA4", "avatar_url": "https://avatars.githubusercontent.com/u/19508?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lht", "html_url": "https://github.com/lht", "followers_url": "https://api.github.com/users/lht/followers", "following_url": "https://api.github.com/users/lht/following{/other_user}", "gists_url": "https://api.github.com/users/lht/gists{/gist_id}", "starred_url": "https://api.github.com/users/lht/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lht/subscriptions", "organizations_url": "https://api.github.com/users/lht/orgs", "repos_url": "https://api.github.com/users/lht/repos", "events_url": "https://api.github.com/users/lht/events{/privacy}", "received_events_url": "https://api.github.com/users/lht/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lht", "id": 19508, "node_id": "MDQ6VXNlcjE5NTA4", "avatar_url": "https://avatars.githubusercontent.com/u/19508?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lht", "html_url": "https://github.com/lht", "followers_url": "https://api.github.com/users/lht/followers", "following_url": "https://api.github.com/users/lht/following{/other_user}", "gists_url": "https://api.github.com/users/lht/gists{/gist_id}", "starred_url": "https://api.github.com/users/lht/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lht/subscriptions", "organizations_url": "https://api.github.com/users/lht/orgs", "repos_url": "https://api.github.com/users/lht/repos", "events_url": "https://api.github.com/users/lht/events{/privacy}", "received_events_url": "https://api.github.com/users/lht/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f03eb96f39dd616d8213cadf337b9d0b0984a687", "url": "https://api.github.com/repos/rust-lang/rust/commits/f03eb96f39dd616d8213cadf337b9d0b0984a687", "html_url": "https://github.com/rust-lang/rust/commit/f03eb96f39dd616d8213cadf337b9d0b0984a687"}], "stats": {"total": 475, "additions": 252, "deletions": 223}, "files": [{"sha": "fa038f4a5a34776557203958e1a9f95c121cf9ab", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/dde41869ce2ef1d66e753fc8b4efc7d917c77875/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde41869ce2ef1d66e753fc8b4efc7d917c77875/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=dde41869ce2ef1d66e753fc8b4efc7d917c77875", "patch": "@@ -1,4 +1,4 @@\n-\n+import core::ctypes::{c_int, c_uint};\n import driver::session;\n import session::session;\n import lib::llvm::llvm;\n@@ -170,24 +170,25 @@ mod write {\n             llvm::LLVMAddTargetData(td.lltd, fpm.llpm);\n \n             let FPMB = llvm::LLVMPassManagerBuilderCreate();\n-            llvm::LLVMPassManagerBuilderSetOptLevel(FPMB, 2u);\n+            llvm::LLVMPassManagerBuilderSetOptLevel(FPMB, 2u32);\n             llvm::LLVMPassManagerBuilderPopulateFunctionPassManager(FPMB,\n                                                                     fpm.llpm);\n             llvm::LLVMPassManagerBuilderDispose(FPMB);\n \n             llvm::LLVMRunPassManager(fpm.llpm, llmod);\n-            let threshold: uint = 225u;\n-            if opts.optimize == 3u { threshold = 275u; }\n+            let threshold = 225u as c_uint;\n+            if opts.optimize == 3u { threshold = 275u as c_uint; }\n \n             let MPMB = llvm::LLVMPassManagerBuilderCreate();\n-            llvm::LLVMPassManagerBuilderSetOptLevel(MPMB, opts.optimize);\n+            llvm::LLVMPassManagerBuilderSetOptLevel(MPMB,\n+                                                    opts.optimize as u32);\n             llvm::LLVMPassManagerBuilderSetSizeLevel(MPMB, 0);\n             llvm::LLVMPassManagerBuilderSetDisableUnitAtATime(MPMB, False);\n             llvm::LLVMPassManagerBuilderSetDisableUnrollLoops(MPMB, False);\n             llvm::LLVMPassManagerBuilderSetDisableSimplifyLibCalls(MPMB,\n                                                                    False);\n \n-            if threshold != 0u {\n+            if threshold != 0u32 {\n                 llvm::LLVMPassManagerBuilderUseInlinerWithThreshold\n                     (MPMB, threshold);\n             }\n@@ -198,12 +199,12 @@ mod write {\n         }\n         if opts.verify { llvm::LLVMAddVerifierPass(pm.llpm); }\n         if is_object_or_assembly_or_exe(opts.output_type) {\n-            let LLVMAssemblyFile: int = 0;\n-            let LLVMObjectFile: int = 1;\n-            let LLVMOptNone: int = 0; // -O0\n-            let LLVMOptLess: int = 1; // -O1\n-            let LLVMOptDefault: int = 2; // -O2, -Os\n-            let LLVMOptAggressive: int = 3; // -O3\n+            let LLVMAssemblyFile  = 0 as c_int;\n+            let LLVMObjectFile    = 1 as c_int;\n+            let LLVMOptNone       = 0 as c_int; // -O0\n+            let LLVMOptLess       = 1 as c_int; // -O1\n+            let LLVMOptDefault    = 2 as c_int; // -O2, -Os\n+            let LLVMOptAggressive = 3 as c_int; // -O3\n \n             let CodeGenOptLevel;\n             alt opts.optimize {"}, {"sha": "a164ba1e10880e7ea533ba31c4424bf40d2dca92", "filename": "src/comp/lib/llvm.rs", "status": "modified", "additions": 114, "deletions": 105, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/dde41869ce2ef1d66e753fc8b4efc7d917c77875/src%2Fcomp%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde41869ce2ef1d66e753fc8b4efc7d917c77875/src%2Fcomp%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Flib%2Fllvm.rs?ref=dde41869ce2ef1d66e753fc8b4efc7d917c77875", "patch": "@@ -4,9 +4,8 @@ import str::sbuf;\n import llvm::{TypeRef, MemoryBufferRef,\n               PassManagerRef, TargetDataRef,\n               ObjectFileRef, SectionIteratorRef};\n+import ctypes::{c_int, c_uint, unsigned, longlong, ulonglong};\n \n-type ULongLong = u64;\n-type LongLong = i64;\n type Long = i32;\n type Bool = int;\n \n@@ -141,9 +140,9 @@ native mod llvm {\n     fn LLVMContextCreate() -> ContextRef;\n     fn LLVMGetGlobalContext() -> ContextRef;\n     fn LLVMContextDispose(C: ContextRef);\n-    fn LLVMGetMDKindIDInContext(C: ContextRef, Name: sbuf, SLen: uint) ->\n-       uint;\n-    fn LLVMGetMDKindID(Name: sbuf, SLen: uint) -> uint;\n+    fn LLVMGetMDKindIDInContext(C: ContextRef, Name: sbuf, SLen: unsigned) ->\n+       unsigned;\n+    fn LLVMGetMDKindID(Name: sbuf, SLen: unsigned) -> unsigned;\n \n     /* Create and destroy modules. */\n     fn LLVMModuleCreateWithNameInContext(ModuleID: sbuf, C: ContextRef) ->\n@@ -170,7 +169,7 @@ native mod llvm {\n     // we directly inspect the values, and casting from\n     // a native doesn't work yet (only *to* a native).\n \n-    fn LLVMGetTypeKind(Ty: TypeRef) -> int;\n+    fn LLVMGetTypeKind(Ty: TypeRef) -> c_int;\n \n     /** See llvm::LLVMType::getContext. */\n     fn LLVMGetTypeContext(Ty: TypeRef) -> ContextRef;\n@@ -181,15 +180,15 @@ native mod llvm {\n     fn LLVMInt16TypeInContext(C: ContextRef) -> TypeRef;\n     fn LLVMInt32TypeInContext(C: ContextRef) -> TypeRef;\n     fn LLVMInt64TypeInContext(C: ContextRef) -> TypeRef;\n-    fn LLVMIntTypeInContext(C: ContextRef, NumBits: uint) -> TypeRef;\n+    fn LLVMIntTypeInContext(C: ContextRef, NumBits: unsigned) -> TypeRef;\n \n     fn LLVMInt1Type() -> TypeRef;\n     fn LLVMInt8Type() -> TypeRef;\n     fn LLVMInt16Type() -> TypeRef;\n     fn LLVMInt32Type() -> TypeRef;\n     fn LLVMInt64Type() -> TypeRef;\n-    fn LLVMIntType(NumBits: uint) -> TypeRef;\n-    fn LLVMGetIntTypeWidth(IntegerTy: TypeRef) -> uint;\n+    fn LLVMIntType(NumBits: unsigned) -> TypeRef;\n+    fn LLVMGetIntTypeWidth(IntegerTy: TypeRef) -> unsigned;\n \n     /* Operations on real types */\n     fn LLVMFloatTypeInContext(C: ContextRef) -> TypeRef;\n@@ -206,30 +205,34 @@ native mod llvm {\n \n     /* Operations on function types */\n     fn LLVMFunctionType(ReturnType: TypeRef, ParamTypes: *TypeRef,\n-                        ParamCount: uint, IsVarArg: Bool) -> TypeRef;\n+                        ParamCount: unsigned, IsVarArg: Bool) -> TypeRef;\n     fn LLVMIsFunctionVarArg(FunctionTy: TypeRef) -> Bool;\n     fn LLVMGetReturnType(FunctionTy: TypeRef) -> TypeRef;\n-    fn LLVMCountParamTypes(FunctionTy: TypeRef) -> uint;\n+    fn LLVMCountParamTypes(FunctionTy: TypeRef) -> unsigned;\n     fn LLVMGetParamTypes(FunctionTy: TypeRef, Dest: *TypeRef);\n \n     /* Operations on struct types */\n     fn LLVMStructTypeInContext(C: ContextRef, ElementTypes: *TypeRef,\n-                               ElementCount: uint, Packed: Bool) -> TypeRef;\n-    fn LLVMStructType(ElementTypes: *TypeRef, ElementCount: uint,\n+                               ElementCount: unsigned,\n+                               Packed: Bool) -> TypeRef;\n+    fn LLVMStructType(ElementTypes: *TypeRef, ElementCount: unsigned,\n                       Packed: Bool) -> TypeRef;\n-    fn LLVMCountStructElementTypes(StructTy: TypeRef) -> uint;\n+    fn LLVMCountStructElementTypes(StructTy: TypeRef) -> unsigned;\n     fn LLVMGetStructElementTypes(StructTy: TypeRef, Dest: *TypeRef);\n     fn LLVMIsPackedStruct(StructTy: TypeRef) -> Bool;\n \n     /* Operations on array, pointer, and vector types (sequence types) */\n-    fn LLVMArrayType(ElementType: TypeRef, ElementCount: uint) -> TypeRef;\n-    fn LLVMPointerType(ElementType: TypeRef, AddressSpace: uint) -> TypeRef;\n-    fn LLVMVectorType(ElementType: TypeRef, ElementCount: uint) -> TypeRef;\n+    fn LLVMArrayType(ElementType: TypeRef,\n+                     ElementCount: unsigned) -> TypeRef;\n+    fn LLVMPointerType(ElementType: TypeRef,\n+                       AddressSpace: unsigned) -> TypeRef;\n+    fn LLVMVectorType(ElementType: TypeRef,\n+                      ElementCount: unsigned) -> TypeRef;\n \n     fn LLVMGetElementType(Ty: TypeRef) -> TypeRef;\n-    fn LLVMGetArrayLength(ArrayTy: TypeRef) -> uint;\n-    fn LLVMGetPointerAddressSpace(PointerTy: TypeRef) -> uint;\n-    fn LLVMGetVectorSize(VectorTy: TypeRef) -> uint;\n+    fn LLVMGetArrayLength(ArrayTy: TypeRef) -> unsigned;\n+    fn LLVMGetPointerAddressSpace(PointerTy: TypeRef) -> unsigned;\n+    fn LLVMGetVectorSize(VectorTy: TypeRef) -> unsigned;\n \n     /* Operations on other types */\n     fn LLVMVoidTypeInContext(C: ContextRef) -> TypeRef;\n@@ -246,9 +249,9 @@ native mod llvm {\n     fn LLVMSetValueName(Val: ValueRef, Name: sbuf);\n     fn LLVMDumpValue(Val: ValueRef);\n     fn LLVMReplaceAllUsesWith(OldVal: ValueRef, NewVal: ValueRef);\n-    fn LLVMHasMetadata(Val: ValueRef) -> int;\n-    fn LLVMGetMetadata(Val: ValueRef, KindID: uint) -> ValueRef;\n-    fn LLVMSetMetadata(Val: ValueRef, KindID: uint, Node: ValueRef);\n+    fn LLVMHasMetadata(Val: ValueRef) -> c_int;\n+    fn LLVMGetMetadata(Val: ValueRef, KindID: unsigned) -> ValueRef;\n+    fn LLVMSetMetadata(Val: ValueRef, KindID: unsigned, Node: ValueRef);\n \n     /* Operations on Uses */\n     fn LLVMGetFirstUse(Val: ValueRef) -> UseRef;\n@@ -257,8 +260,8 @@ native mod llvm {\n     fn LLVMGetUsedValue(U: UseRef) -> ValueRef;\n \n     /* Operations on Users */\n-    fn LLVMGetOperand(Val: ValueRef, Index: uint) -> ValueRef;\n-    fn LLVMSetOperand(Val: ValueRef, Index: uint, Op: ValueRef);\n+    fn LLVMGetOperand(Val: ValueRef, Index: unsigned) -> ValueRef;\n+    fn LLVMSetOperand(Val: ValueRef, Index: unsigned, Op: ValueRef);\n \n     /* Operations on constants of any type */\n     fn LLVMConstNull(Ty: TypeRef) -> ValueRef;\n@@ -272,45 +275,46 @@ native mod llvm {\n     fn LLVMConstPointerNull(Ty: TypeRef) -> ValueRef;\n \n     /* Operations on metadata */\n-    fn LLVMMDStringInContext(C: ContextRef, Str: sbuf, SLen: uint) ->\n+    fn LLVMMDStringInContext(C: ContextRef, Str: sbuf, SLen: unsigned) ->\n        ValueRef;\n-    fn LLVMMDString(Str: sbuf, SLen: uint) -> ValueRef;\n-    fn LLVMMDNodeInContext(C: ContextRef, Vals: *ValueRef, Count: uint) ->\n+    fn LLVMMDString(Str: sbuf, SLen: unsigned) -> ValueRef;\n+    fn LLVMMDNodeInContext(C: ContextRef, Vals: *ValueRef, Count: unsigned) ->\n        ValueRef;\n-    fn LLVMMDNode(Vals: *ValueRef, Count: uint) -> ValueRef;\n+    fn LLVMMDNode(Vals: *ValueRef, Count: unsigned) -> ValueRef;\n     fn LLVMAddNamedMetadataOperand(M: ModuleRef, Str: sbuf,\n                                    Val: ValueRef);\n \n     /* Operations on scalar constants */\n-    fn LLVMConstInt(IntTy: TypeRef, N: ULongLong, SignExtend: Bool) ->\n+    fn LLVMConstInt(IntTy: TypeRef, N: ulonglong, SignExtend: Bool) ->\n        ValueRef;\n     // FIXME: radix is actually u8, but our native layer can't handle this\n     // yet.  lucky for us we're little-endian. Small miracles.\n-    fn LLVMConstIntOfString(IntTy: TypeRef, Text: sbuf, Radix: int) ->\n+    fn LLVMConstIntOfString(IntTy: TypeRef, Text: sbuf, Radix: c_int) ->\n        ValueRef;\n-    fn LLVMConstIntOfStringAndSize(IntTy: TypeRef, Text: sbuf, SLen: uint,\n+    fn LLVMConstIntOfStringAndSize(IntTy: TypeRef, Text: sbuf, SLen: unsigned,\n                                    Radix: u8) -> ValueRef;\n     fn LLVMConstReal(RealTy: TypeRef, N: f64) -> ValueRef;\n     fn LLVMConstRealOfString(RealTy: TypeRef, Text: sbuf) -> ValueRef;\n-    fn LLVMConstRealOfStringAndSize(RealTy: TypeRef, Text: sbuf, SLen: uint)\n-       -> ValueRef;\n-    fn LLVMConstIntGetZExtValue(ConstantVal: ValueRef) -> ULongLong;\n-    fn LLVMConstIntGetSExtValue(ConstantVal: ValueRef) -> LongLong;\n+    fn LLVMConstRealOfStringAndSize(RealTy: TypeRef, Text: sbuf,\n+                                    SLen: unsigned) -> ValueRef;\n+    fn LLVMConstIntGetZExtValue(ConstantVal: ValueRef) -> ulonglong;\n+    fn LLVMConstIntGetSExtValue(ConstantVal: ValueRef) -> longlong;\n \n \n     /* Operations on composite constants */\n-    fn LLVMConstStringInContext(C: ContextRef, Str: sbuf, Length: uint,\n+    fn LLVMConstStringInContext(C: ContextRef, Str: sbuf, Length: unsigned,\n                                 DontNullTerminate: Bool) -> ValueRef;\n     fn LLVMConstStructInContext(C: ContextRef, ConstantVals: *ValueRef,\n-                                Count: uint, Packed: Bool) -> ValueRef;\n+                                Count: unsigned, Packed: Bool) -> ValueRef;\n \n-    fn LLVMConstString(Str: sbuf, Length: uint, DontNullTerminate: Bool) ->\n-       ValueRef;\n+    fn LLVMConstString(Str: sbuf, Length: unsigned,\n+                       DontNullTerminate: Bool) -> ValueRef;\n     fn LLVMConstArray(ElementTy: TypeRef, ConstantVals: *ValueRef,\n-                      Length: uint) -> ValueRef;\n-    fn LLVMConstStruct(ConstantVals: *ValueRef, Count: uint, Packed: Bool) ->\n-       ValueRef;\n-    fn LLVMConstVector(ScalarConstantVals: *ValueRef, Size: uint) -> ValueRef;\n+                      Length: unsigned) -> ValueRef;\n+    fn LLVMConstStruct(ConstantVals: *ValueRef,\n+                       Count: unsigned, Packed: Bool) -> ValueRef;\n+    fn LLVMConstVector(ScalarConstantVals: *ValueRef,\n+                       Size: unsigned) -> ValueRef;\n \n     /* Constant expressions */\n     fn LLVMAlignOf(Ty: TypeRef) -> ValueRef;\n@@ -364,9 +368,9 @@ native mod llvm {\n     fn LLVMConstAShr(LHSConstant: ValueRef, RHSConstant: ValueRef) ->\n        ValueRef;\n     fn LLVMConstGEP(ConstantVal: ValueRef, ConstantIndices: *uint,\n-                    NumIndices: uint) -> ValueRef;\n+                    NumIndices: unsigned) -> ValueRef;\n     fn LLVMConstInBoundsGEP(ConstantVal: ValueRef, ConstantIndices: *uint,\n-                            NumIndices: uint) -> ValueRef;\n+                            NumIndices: unsigned) -> ValueRef;\n     fn LLVMConstTrunc(ConstantVal: ValueRef, ToType: TypeRef) -> ValueRef;\n     fn LLVMConstSExt(ConstantVal: ValueRef, ToType: TypeRef) -> ValueRef;\n     fn LLVMConstZExt(ConstantVal: ValueRef, ToType: TypeRef) -> ValueRef;\n@@ -401,10 +405,10 @@ native mod llvm {\n                               VectorBConstant: ValueRef,\n                               MaskConstant: ValueRef) -> ValueRef;\n     fn LLVMConstExtractValue(AggConstant: ValueRef, IdxList: *uint,\n-                             NumIdx: uint) -> ValueRef;\n+                             NumIdx: unsigned) -> ValueRef;\n     fn LLVMConstInsertValue(AggConstant: ValueRef,\n                             ElementValueConstant: ValueRef, IdxList: *uint,\n-                            NumIdx: uint) -> ValueRef;\n+                            NumIdx: unsigned) -> ValueRef;\n     fn LLVMConstInlineAsm(Ty: TypeRef, AsmString: sbuf, Constraints: sbuf,\n                           HasSideEffects: Bool, IsAlignStack: Bool) ->\n        ValueRef;\n@@ -421,14 +425,14 @@ native mod llvm {\n     fn LLVMSetSection(Global: ValueRef, Section: sbuf);\n     fn LLVMGetVisibility(Global: ValueRef) -> Visibility;\n     fn LLVMSetVisibility(Global: ValueRef, Viz: Visibility);\n-    fn LLVMGetAlignment(Global: ValueRef) -> uint;\n-    fn LLVMSetAlignment(Global: ValueRef, Bytes: uint);\n+    fn LLVMGetAlignment(Global: ValueRef) -> unsigned;\n+    fn LLVMSetAlignment(Global: ValueRef, Bytes: unsigned);\n \n \n     /* Operations on global variables */\n     fn LLVMAddGlobal(M: ModuleRef, Ty: TypeRef, Name: sbuf) -> ValueRef;\n     fn LLVMAddGlobalInAddressSpace(M: ModuleRef, Ty: TypeRef, Name: sbuf,\n-                                   AddressSpace: uint) -> ValueRef;\n+                                   AddressSpace: unsigned) -> ValueRef;\n     fn LLVMGetNamedGlobal(M: ModuleRef, Name: sbuf) -> ValueRef;\n     fn LLVMGetFirstGlobal(M: ModuleRef) -> ValueRef;\n     fn LLVMGetLastGlobal(M: ModuleRef) -> ValueRef;\n@@ -457,19 +461,19 @@ native mod llvm {\n     fn LLVMDeleteFunction(Fn: ValueRef);\n     fn LLVMGetOrInsertFunction(M: ModuleRef, Name: sbuf, FunctionTy: TypeRef)\n        -> ValueRef;\n-    fn LLVMGetIntrinsicID(Fn: ValueRef) -> uint;\n-    fn LLVMGetFunctionCallConv(Fn: ValueRef) -> uint;\n-    fn LLVMSetFunctionCallConv(Fn: ValueRef, CC: uint);\n+    fn LLVMGetIntrinsicID(Fn: ValueRef) -> unsigned;\n+    fn LLVMGetFunctionCallConv(Fn: ValueRef) -> unsigned;\n+    fn LLVMSetFunctionCallConv(Fn: ValueRef, CC: unsigned);\n     fn LLVMGetGC(Fn: ValueRef) -> sbuf;\n     fn LLVMSetGC(Fn: ValueRef, Name: sbuf);\n-    fn LLVMAddFunctionAttr(Fn: ValueRef, PA: Attribute, HighPA: uint);\n+    fn LLVMAddFunctionAttr(Fn: ValueRef, PA: Attribute, HighPA: unsigned);\n     fn LLVMGetFunctionAttr(Fn: ValueRef) -> Attribute;\n-    fn LLVMRemoveFunctionAttr(Fn: ValueRef, PA: Attribute, HighPA: uint);\n+    fn LLVMRemoveFunctionAttr(Fn: ValueRef, PA: Attribute, HighPA: unsigned);\n \n     /* Operations on parameters */\n-    fn LLVMCountParams(Fn: ValueRef) -> uint;\n+    fn LLVMCountParams(Fn: ValueRef) -> unsigned;\n     fn LLVMGetParams(Fn: ValueRef, Params: *ValueRef);\n-    fn LLVMGetParam(Fn: ValueRef, Index: uint) -> ValueRef;\n+    fn LLVMGetParam(Fn: ValueRef, Index: unsigned) -> ValueRef;\n     fn LLVMGetParamParent(Inst: ValueRef) -> ValueRef;\n     fn LLVMGetFirstParam(Fn: ValueRef) -> ValueRef;\n     fn LLVMGetLastParam(Fn: ValueRef) -> ValueRef;\n@@ -478,14 +482,14 @@ native mod llvm {\n     fn LLVMAddAttribute(Arg: ValueRef, PA: Attribute);\n     fn LLVMRemoveAttribute(Arg: ValueRef, PA: Attribute);\n     fn LLVMGetAttribute(Arg: ValueRef) -> Attribute;\n-    fn LLVMSetParamAlignment(Arg: ValueRef, align: uint);\n+    fn LLVMSetParamAlignment(Arg: ValueRef, align: unsigned);\n \n     /* Operations on basic blocks */\n     fn LLVMBasicBlockAsValue(BB: BasicBlockRef) -> ValueRef;\n     fn LLVMValueIsBasicBlock(Val: ValueRef) -> Bool;\n     fn LLVMValueAsBasicBlock(Val: ValueRef) -> BasicBlockRef;\n     fn LLVMGetBasicBlockParent(BB: BasicBlockRef) -> ValueRef;\n-    fn LLVMCountBasicBlocks(Fn: ValueRef) -> uint;\n+    fn LLVMCountBasicBlocks(Fn: ValueRef) -> unsigned;\n     fn LLVMGetBasicBlocks(Fn: ValueRef, BasicBlocks: *ValueRef);\n     fn LLVMGetFirstBasicBlock(Fn: ValueRef) -> BasicBlockRef;\n     fn LLVMGetLastBasicBlock(Fn: ValueRef) -> BasicBlockRef;\n@@ -511,22 +515,25 @@ native mod llvm {\n     fn LLVMGetPreviousInstruction(Inst: ValueRef) -> ValueRef;\n \n     /* Operations on call sites */\n-    fn LLVMSetInstructionCallConv(Instr: ValueRef, CC: uint);\n-    fn LLVMGetInstructionCallConv(Instr: ValueRef) -> uint;\n-    fn LLVMAddInstrAttribute(Instr: ValueRef, index: uint, IA: Attribute);\n-    fn LLVMRemoveInstrAttribute(Instr: ValueRef, index: uint, IA: Attribute);\n-    fn LLVMSetInstrParamAlignment(Instr: ValueRef, index: uint, align: uint);\n+    fn LLVMSetInstructionCallConv(Instr: ValueRef, CC: unsigned);\n+    fn LLVMGetInstructionCallConv(Instr: ValueRef) -> unsigned;\n+    fn LLVMAddInstrAttribute(Instr: ValueRef, index: unsigned, IA: Attribute);\n+    fn LLVMRemoveInstrAttribute(Instr: ValueRef, index: unsigned,\n+                                IA: Attribute);\n+    fn LLVMSetInstrParamAlignment(Instr: ValueRef, index: unsigned,\n+                                  align: unsigned);\n \n     /* Operations on call instructions (only) */\n     fn LLVMIsTailCall(CallInst: ValueRef) -> Bool;\n     fn LLVMSetTailCall(CallInst: ValueRef, IsTailCall: Bool);\n \n     /* Operations on phi nodes */\n     fn LLVMAddIncoming(PhiNode: ValueRef, IncomingValues: *ValueRef,\n-                       IncomingBlocks: *BasicBlockRef, Count: uint);\n-    fn LLVMCountIncoming(PhiNode: ValueRef) -> uint;\n-    fn LLVMGetIncomingValue(PhiNode: ValueRef, Index: uint) -> ValueRef;\n-    fn LLVMGetIncomingBlock(PhiNode: ValueRef, Index: uint) -> BasicBlockRef;\n+                       IncomingBlocks: *BasicBlockRef, Count: unsigned);\n+    fn LLVMCountIncoming(PhiNode: ValueRef) -> unsigned;\n+    fn LLVMGetIncomingValue(PhiNode: ValueRef, Index: unsigned) -> ValueRef;\n+    fn LLVMGetIncomingBlock(PhiNode: ValueRef,\n+                            Index: unsigned) -> BasicBlockRef;\n \n     /* Instruction builders */\n     fn LLVMCreateBuilderInContext(C: ContextRef) -> BuilderRef;\n@@ -550,20 +557,20 @@ native mod llvm {\n     /* Terminators */\n     fn LLVMBuildRetVoid(B: BuilderRef) -> ValueRef;\n     fn LLVMBuildRet(B: BuilderRef, V: ValueRef) -> ValueRef;\n-    fn LLVMBuildAggregateRet(B: BuilderRef, RetVals: *ValueRef, N: uint) ->\n-       ValueRef;\n+    fn LLVMBuildAggregateRet(B: BuilderRef, RetVals: *ValueRef,\n+                             N: unsigned) -> ValueRef;\n     fn LLVMBuildBr(B: BuilderRef, Dest: BasicBlockRef) -> ValueRef;\n     fn LLVMBuildCondBr(B: BuilderRef, If: ValueRef, Then: BasicBlockRef,\n                        Else: BasicBlockRef) -> ValueRef;\n     fn LLVMBuildSwitch(B: BuilderRef, V: ValueRef, Else: BasicBlockRef,\n-                       NumCases: uint) -> ValueRef;\n-    fn LLVMBuildIndirectBr(B: BuilderRef, Addr: ValueRef, NumDests: uint) ->\n-       ValueRef;\n+                       NumCases: unsigned) -> ValueRef;\n+    fn LLVMBuildIndirectBr(B: BuilderRef, Addr: ValueRef,\n+                           NumDests: unsigned) -> ValueRef;\n     fn LLVMBuildInvoke(B: BuilderRef, Fn: ValueRef, Args: *ValueRef,\n-                       NumArgs: uint, Then: BasicBlockRef,\n+                       NumArgs: unsigned, Then: BasicBlockRef,\n                        Catch: BasicBlockRef, Name: sbuf) -> ValueRef;\n     fn LLVMBuildLandingPad(B: BuilderRef, Ty: TypeRef, PersFn: ValueRef,\n-                           NumClauses: uint, Name: sbuf) -> ValueRef;\n+                           NumClauses: unsigned, Name: sbuf) -> ValueRef;\n     fn LLVMBuildResume(B: BuilderRef, Exn: ValueRef) -> ValueRef;\n     fn LLVMBuildUnreachable(B: BuilderRef) -> ValueRef;\n \n@@ -651,11 +658,12 @@ native mod llvm {\n     fn LLVMBuildStore(B: BuilderRef, Val: ValueRef, Ptr: ValueRef) ->\n        ValueRef;\n     fn LLVMBuildGEP(B: BuilderRef, Pointer: ValueRef, Indices: *ValueRef,\n-                    NumIndices: uint, Name: sbuf) -> ValueRef;\n+                    NumIndices: unsigned, Name: sbuf) -> ValueRef;\n     fn LLVMBuildInBoundsGEP(B: BuilderRef, Pointer: ValueRef,\n-                            Indices: *ValueRef, NumIndices: uint, Name: sbuf)\n+                            Indices: *ValueRef, NumIndices: unsigned,\n+                            Name: sbuf)\n        -> ValueRef;\n-    fn LLVMBuildStructGEP(B: BuilderRef, Pointer: ValueRef, Idx: uint,\n+    fn LLVMBuildStructGEP(B: BuilderRef, Pointer: ValueRef, Idx: unsigned,\n                           Name: sbuf) -> ValueRef;\n     fn LLVMBuildGlobalString(B: BuilderRef, Str: sbuf, Name: sbuf) ->\n        ValueRef;\n@@ -703,15 +711,15 @@ native mod llvm {\n                        Name: sbuf) -> ValueRef;\n \n     /* Comparisons */\n-    fn LLVMBuildICmp(B: BuilderRef, Op: uint, LHS: ValueRef, RHS: ValueRef,\n-                     Name: sbuf) -> ValueRef;\n-    fn LLVMBuildFCmp(B: BuilderRef, Op: uint, LHS: ValueRef, RHS: ValueRef,\n-                     Name: sbuf) -> ValueRef;\n+    fn LLVMBuildICmp(B: BuilderRef, Op: unsigned, LHS: ValueRef,\n+                     RHS: ValueRef, Name: sbuf) -> ValueRef;\n+    fn LLVMBuildFCmp(B: BuilderRef, Op: unsigned, LHS: ValueRef,\n+                     RHS: ValueRef, Name: sbuf) -> ValueRef;\n \n     /* Miscellaneous instructions */\n     fn LLVMBuildPhi(B: BuilderRef, Ty: TypeRef, Name: sbuf) -> ValueRef;\n     fn LLVMBuildCall(B: BuilderRef, Fn: ValueRef, Args: *ValueRef,\n-                     NumArgs: uint, Name: sbuf) -> ValueRef;\n+                     NumArgs: unsigned, Name: sbuf) -> ValueRef;\n     fn LLVMBuildSelect(B: BuilderRef, If: ValueRef, Then: ValueRef,\n                        Else: ValueRef, Name: sbuf) -> ValueRef;\n     fn LLVMBuildVAArg(B: BuilderRef, list: ValueRef, Ty: TypeRef, Name: sbuf)\n@@ -723,10 +731,10 @@ native mod llvm {\n        -> ValueRef;\n     fn LLVMBuildShuffleVector(B: BuilderRef, V1: ValueRef, V2: ValueRef,\n                               Mask: ValueRef, Name: sbuf) -> ValueRef;\n-    fn LLVMBuildExtractValue(B: BuilderRef, AggVal: ValueRef, Index: uint,\n+    fn LLVMBuildExtractValue(B: BuilderRef, AggVal: ValueRef, Index: unsigned,\n                              Name: sbuf) -> ValueRef;\n     fn LLVMBuildInsertValue(B: BuilderRef, AggVal: ValueRef, EltVal: ValueRef,\n-                            Index: uint, Name: sbuf) -> ValueRef;\n+                            Index: unsigned, Name: sbuf) -> ValueRef;\n \n     fn LLVMBuildIsNull(B: BuilderRef, Val: ValueRef, Name: sbuf) -> ValueRef;\n     fn LLVMBuildIsNotNull(B: BuilderRef, Val: ValueRef, Name: sbuf) ->\n@@ -738,17 +746,18 @@ native mod llvm {\n     fn LLVMIsATerminatorInst(Inst: ValueRef) -> ValueRef;\n \n     /** Writes a module to the specified path. Returns 0 on success. */\n-    fn LLVMWriteBitcodeToFile(M: ModuleRef, Path: sbuf) -> int;\n+    fn LLVMWriteBitcodeToFile(M: ModuleRef, Path: sbuf) -> c_int;\n \n     /** Creates target data from a target layout string. */\n     fn LLVMCreateTargetData(StringRep: sbuf) -> TargetDataRef;\n     /** Adds the target data to the given pass manager. The pass manager\n         references the target data only weakly. */\n     fn LLVMAddTargetData(TD: TargetDataRef, PM: PassManagerRef);\n     /** Returns the size of a type. FIXME: rv is actually a ULongLong! */\n-    fn LLVMStoreSizeOfType(TD: TargetDataRef, Ty: TypeRef) -> uint;\n+    fn LLVMStoreSizeOfType(TD: TargetDataRef, Ty: TypeRef) -> unsigned;\n     /** Returns the alignment of a type. */\n-    fn LLVMPreferredAlignmentOfType(TD: TargetDataRef, Ty: TypeRef) -> uint;\n+    fn LLVMPreferredAlignmentOfType(TD: TargetDataRef,\n+                                    Ty: TypeRef) -> unsigned;\n     /** Disposes target data. */\n     fn LLVMDisposeTargetData(TD: TargetDataRef);\n \n@@ -801,7 +810,7 @@ native mod llvm {\n     fn LLVMPassManagerBuilderCreate() -> PassManagerBuilderRef;\n     fn LLVMPassManagerBuilderDispose(PMB: PassManagerBuilderRef);\n     fn LLVMPassManagerBuilderSetOptLevel(PMB: PassManagerBuilderRef,\n-                                         OptimizationLevel: uint);\n+                                         OptimizationLevel: unsigned);\n     fn LLVMPassManagerBuilderSetSizeLevel(PMB: PassManagerBuilderRef,\n                                           Value: Bool);\n     fn LLVMPassManagerBuilderSetDisableUnitAtATime(PMB: PassManagerBuilderRef,\n@@ -811,7 +820,7 @@ native mod llvm {\n     fn LLVMPassManagerBuilderSetDisableSimplifyLibCalls\n         (PMB: PassManagerBuilderRef, Value: Bool);\n     fn LLVMPassManagerBuilderUseInlinerWithThreshold\n-        (PMB: PassManagerBuilderRef, threshold: uint);\n+        (PMB: PassManagerBuilderRef, threshold: unsigned);\n     fn LLVMPassManagerBuilderPopulateModulePassManager\n         (PMB: PassManagerBuilderRef, PM: PassManagerRef);\n \n@@ -844,9 +853,8 @@ native mod llvm {\n     fn LLVMMoveToNextSection(SI: SectionIteratorRef);\n     /** Returns the current section name. */\n     fn LLVMGetSectionName(SI: SectionIteratorRef) -> sbuf;\n-    /** Returns the current section size.\n-        FIXME: The return value is actually a uint64_t! */\n-    fn LLVMGetSectionSize(SI: SectionIteratorRef) -> uint;\n+    /** Returns the current section size. */\n+    fn LLVMGetSectionSize(SI: SectionIteratorRef) -> ulonglong;\n     /** Returns the current section contents as a string buffer. */\n     fn LLVMGetSectionContents(SI: SectionIteratorRef) -> sbuf;\n \n@@ -857,7 +865,7 @@ native mod llvm {\n \n     /* FIXME: The FileType is an enum.*/\n     fn LLVMRustWriteOutputFile(PM: PassManagerRef, M: ModuleRef, Triple: sbuf,\n-                               Output: sbuf, FileType: int, OptLevel: int,\n+                               Output: sbuf, FileType: c_int, OptLevel: c_int,\n                                EnableSegmentedStacks: bool);\n \n     /** Returns a string describing the last error caused by an LLVMRust*\n@@ -871,7 +879,7 @@ native mod llvm {\n     fn LLVMRustParseAssemblyFile(Filename: sbuf) -> ModuleRef;\n \n     /** FiXME: Hacky adaptor for lack of ULongLong in FFI: */\n-    fn LLVMRustConstInt(IntTy: TypeRef, N_hi: uint, N_lo: uint,\n+    fn LLVMRustConstInt(IntTy: TypeRef, N_hi: unsigned, N_lo: unsigned,\n                         SignExtend: Bool) -> ValueRef;\n \n     fn LLVMRustAddPrintModulePass(PM: PassManagerRef, M: ModuleRef,\n@@ -886,10 +894,10 @@ native mod llvm {\n     fn LLVMStructCreateNamed(C: ContextRef, Name: sbuf) -> TypeRef;\n \n     fn LLVMStructSetBody(StructTy: TypeRef, ElementTypes: *TypeRef,\n-                         ElementCount: uint, Packed: Bool);\n+                         ElementCount: unsigned, Packed: Bool);\n \n-    fn LLVMConstNamedStruct(S: TypeRef, ConstantVals: *ValueRef, Count: uint)\n-       -> ValueRef;\n+    fn LLVMConstNamedStruct(S: TypeRef, ConstantVals: *ValueRef,\n+                            Count: unsigned) -> ValueRef;\n \n     /** Links LLVM modules together. `Src` is destroyed by this call and\n         must never be referenced again. */\n@@ -934,7 +942,7 @@ fn type_to_str_inner(names: type_names, outer0: [TypeRef], ty: TypeRef) ->\n \n     let outer = outer0 + [ty];\n \n-    let kind: int = llvm::LLVMGetTypeKind(ty);\n+    let kind: int = llvm::LLVMGetTypeKind(ty) as int;\n \n     fn tys_str(names: type_names, outer: [TypeRef], tys: [TypeRef]) -> str {\n         let s: str = \"\";\n@@ -963,7 +971,7 @@ fn type_to_str_inner(names: type_names, outer0: [TypeRef], ty: TypeRef) ->\n       9 {\n         let s = \"fn(\";\n         let out_ty: TypeRef = llvm::LLVMGetReturnType(ty);\n-        let n_args: uint = llvm::LLVMCountParamTypes(ty);\n+        let n_args = llvm::LLVMCountParamTypes(ty) as uint;\n         let args: [TypeRef] = vec::init_elt::<TypeRef>(0 as TypeRef, n_args);\n         unsafe {\n             llvm::LLVMGetParamTypes(ty, vec::to_ptr(args));\n@@ -975,7 +983,7 @@ fn type_to_str_inner(names: type_names, outer0: [TypeRef], ty: TypeRef) ->\n       }\n       10 {\n         let s: str = \"{\";\n-        let n_elts: uint = llvm::LLVMCountStructElementTypes(ty);\n+        let n_elts = llvm::LLVMCountStructElementTypes(ty) as uint;\n         let elts: [TypeRef] = vec::init_elt::<TypeRef>(0 as TypeRef, n_elts);\n         unsafe {\n             llvm::LLVMGetStructElementTypes(ty, vec::to_ptr(elts));\n@@ -987,7 +995,7 @@ fn type_to_str_inner(names: type_names, outer0: [TypeRef], ty: TypeRef) ->\n       11 {\n         let el_ty = llvm::LLVMGetElementType(ty);\n         ret \"[\" + type_to_str_inner(names, outer, el_ty) + \" x \" +\n-            uint::str(llvm::LLVMGetArrayLength(ty)) + \"]\";\n+            uint::str(llvm::LLVMGetArrayLength(ty) as uint) + \"]\";\n       }\n       12 {\n         let i: uint = 0u;\n@@ -1009,7 +1017,7 @@ fn type_to_str_inner(names: type_names, outer0: [TypeRef], ty: TypeRef) ->\n }\n \n fn float_width(llt: TypeRef) -> uint {\n-    ret alt llvm::LLVMGetTypeKind(llt) {\n+    ret alt llvm::LLVMGetTypeKind(llt) as int {\n           1 { 32u }\n           2 { 64u }\n           3 { 80u }\n@@ -1019,7 +1027,8 @@ fn float_width(llt: TypeRef) -> uint {\n }\n \n fn fn_ty_param_tys(fn_ty: TypeRef) -> [TypeRef] unsafe {\n-    let args = vec::init_elt(0 as TypeRef, llvm::LLVMCountParamTypes(fn_ty));\n+    let args = vec::init_elt(0 as TypeRef,\n+                             llvm::LLVMCountParamTypes(fn_ty) as uint);\n     llvm::LLVMGetParamTypes(fn_ty, vec::to_ptr(args));\n     ret args;\n }"}, {"sha": "fd87b54a0a60116e9ee266a27716e3e9ba443690", "filename": "src/comp/metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dde41869ce2ef1d66e753fc8b4efc7d917c77875/src%2Fcomp%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde41869ce2ef1d66e753fc8b4efc7d917c77875/src%2Fcomp%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcreader.rs?ref=dde41869ce2ef1d66e753fc8b4efc7d917c77875", "patch": "@@ -221,7 +221,7 @@ fn get_metadata_section(sess: session::session,\n         let name = unsafe { str::from_cstr(name_buf) };\n         if str::eq(name, sess.targ_cfg.target_strs.meta_sect_name) {\n             let cbuf = llvm::LLVMGetSectionContents(si.llsi);\n-            let csz = llvm::LLVMGetSectionSize(si.llsi);\n+            let csz = llvm::LLVMGetSectionSize(si.llsi) as uint;\n             unsafe {\n                 let cvbuf: *u8 = unsafe::reinterpret_cast(cbuf);\n                 ret option::some::<@[u8]>(@vec::unsafe::from_buf(cvbuf, csz));"}, {"sha": "821858465c362d154f098a2fe12f4360382453a0", "filename": "src/comp/middle/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dde41869ce2ef1d66e753fc8b4efc7d917c77875/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde41869ce2ef1d66e753fc8b4efc7d917c77875/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs?ref=dde41869ce2ef1d66e753fc8b4efc7d917c77875", "patch": "@@ -46,7 +46,7 @@ const DW_ATE_unsigned_char: int = 0x08;\n \n fn llstr(s: str) -> ValueRef {\n     str::as_buf(s, {|sbuf|\n-        llvm::LLVMMDString(sbuf, str::byte_len(s))\n+        llvm::LLVMMDString(sbuf, str::byte_len(s) as u32)\n     })\n }\n fn lltag(lltag: int) -> ValueRef {\n@@ -63,7 +63,7 @@ fn lli1(bval: bool) -> ValueRef {\n }\n fn llmdnode(elems: [ValueRef]) -> ValueRef unsafe {\n     llvm::LLVMMDNode(vec::unsafe::to_ptr(elems),\n-                     vec::len(elems))\n+                     vec::len(elems) as u32)\n }\n fn llunused() -> ValueRef {\n     lli32(0x0)"}, {"sha": "b6a34a6177ba4c04885a358e7a5337aa9ed76ff8", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 33, "deletions": 28, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/dde41869ce2ef1d66e753fc8b4efc7d917c77875/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde41869ce2ef1d66e753fc8b4efc7d917c77875/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=dde41869ce2ef1d66e753fc8b4efc7d917c77875", "patch": "@@ -13,6 +13,7 @@\n //     but many TypeRefs correspond to one ty::t; for instance, tup(int, int,\n //     int) and rec(x=int, y=int, z=int) will have the same TypeRef.\n \n+import core::ctypes::c_uint;\n import std::{map, time};\n import std::map::hashmap;\n import std::map::{new_int_hash, new_str_hash};\n@@ -292,11 +293,12 @@ fn log_fn_time(ccx: @crate_ctxt, name: str, start: time::timeval,\n }\n \n \n-fn decl_fn(llmod: ModuleRef, name: str, cc: uint, llty: TypeRef) -> ValueRef {\n+fn decl_fn(llmod: ModuleRef, name: str, cc: uint, llty: TypeRef) ->\n+    ValueRef {\n     let llfn: ValueRef =\n         str::as_buf(name, {|buf|\n             llvm::LLVMGetOrInsertFunction(llmod, buf, llty) });\n-    llvm::LLVMSetFunctionCallConv(llfn, cc);\n+    llvm::LLVMSetFunctionCallConv(llfn, cc as c_uint);\n     ret llfn;\n }\n \n@@ -339,7 +341,8 @@ fn get_simple_extern_fn(cx: @block_ctxt,\n     let inputs = vec::init_elt::<TypeRef>(ccx.int_type, n_args as uint);\n     let output = ccx.int_type;\n     let t = T_fn(inputs, output);\n-    ret get_extern_fn(externs, llmod, name, lib::llvm::LLVMCCallConv, t);\n+    ret get_extern_fn(externs, llmod, name,\n+                      lib::llvm::LLVMCCallConv, t);\n }\n \n fn trans_native_call(cx: @block_ctxt, externs: hashmap<str, ValueRef>,\n@@ -390,12 +393,12 @@ fn align_to(cx: @block_ctxt, off: ValueRef, align: ValueRef) -> ValueRef {\n \n // Returns the real size of the given type for the current target.\n fn llsize_of_real(cx: @crate_ctxt, t: TypeRef) -> uint {\n-    ret llvm::LLVMStoreSizeOfType(cx.td.lltd, t);\n+    ret llvm::LLVMStoreSizeOfType(cx.td.lltd, t) as uint;\n }\n \n // Returns the real alignment of the given type for the current target.\n fn llalign_of_real(cx: @crate_ctxt, t: TypeRef) -> uint {\n-    ret llvm::LLVMPreferredAlignmentOfType(cx.td.lltd, t);\n+    ret llvm::LLVMPreferredAlignmentOfType(cx.td.lltd, t) as uint;\n }\n \n fn llsize_of(cx: @crate_ctxt, t: TypeRef) -> ValueRef {\n@@ -1070,7 +1073,7 @@ fn set_no_inline(f: ValueRef) {\n     llvm::LLVMAddFunctionAttr(f,\n                               lib::llvm::LLVMNoInlineAttribute as\n                                   lib::llvm::llvm::Attribute,\n-                              0u);\n+                              0u32);\n }\n \n // Tell LLVM to emit the information necessary to unwind the stack for the\n@@ -1079,19 +1082,19 @@ fn set_uwtable(f: ValueRef) {\n     llvm::LLVMAddFunctionAttr(f,\n                               lib::llvm::LLVMUWTableAttribute as\n                                   lib::llvm::llvm::Attribute,\n-                              0u);\n+                              0u32);\n }\n \n fn set_always_inline(f: ValueRef) {\n     llvm::LLVMAddFunctionAttr(f,\n                               lib::llvm::LLVMAlwaysInlineAttribute as\n                                   lib::llvm::llvm::Attribute,\n-                              0u);\n+                              0u32);\n }\n \n fn set_custom_stack_growth_fn(f: ValueRef) {\n     // TODO: Remove this hack to work around the lack of u64 in the FFI.\n-    llvm::LLVMAddFunctionAttr(f, 0 as lib::llvm::llvm::Attribute, 1u);\n+    llvm::LLVMAddFunctionAttr(f, 0 as lib::llvm::llvm::Attribute, 1u32);\n }\n \n fn set_glue_inlining(cx: @local_ctxt, f: ValueRef, t: ty::t) {\n@@ -1178,7 +1181,7 @@ fn make_generic_glue_inner(cx: @local_ctxt, sp: span, t: ty::t,\n         } else { T_ptr(T_i8()) };\n \n     let ty_param_count = vec::len::<uint>(ty_params);\n-    let lltyparams = llvm::LLVMGetParam(llfn, 2u);\n+    let lltyparams = llvm::LLVMGetParam(llfn, 2u32);\n     let load_env_bcx = new_raw_block_ctxt(fcx, fcx.llloadenv);\n     let lltydescs = [mutable];\n     let p = 0u;\n@@ -1193,7 +1196,7 @@ fn make_generic_glue_inner(cx: @local_ctxt, sp: span, t: ty::t,\n \n     let bcx = new_top_block_ctxt(fcx);\n     let lltop = bcx.llbb;\n-    let llrawptr0 = llvm::LLVMGetParam(llfn, 3u);\n+    let llrawptr0 = llvm::LLVMGetParam(llfn, 3u32);\n     let llval0 = BitCast(bcx, llrawptr0, llty);\n     helper(bcx, llval0, t);\n     finish_fn(fcx, lltop);\n@@ -4300,8 +4303,8 @@ fn new_fn_ctxt_w_id(cx: @local_ctxt, sp: span, llfndecl: ValueRef,\n     -> @fn_ctxt {\n     let llbbs = mk_standard_basic_blocks(llfndecl);\n     ret @{llfn: llfndecl,\n-          llenv: llvm::LLVMGetParam(llfndecl, 1u),\n-          llretptr: llvm::LLVMGetParam(llfndecl, 0u),\n+          llenv: llvm::LLVMGetParam(llfndecl, 1u32),\n+          llretptr: llvm::LLVMGetParam(llfndecl, 0u32),\n           mutable llstaticallocas: llbbs.sa,\n           mutable llloadenv: llbbs.ca,\n           mutable llderivedtydescs_first: llbbs.dt,\n@@ -4344,7 +4347,7 @@ fn create_llargs_for_fn_args(cx: @fn_ctxt, ty_self: self_arg,\n     // Skip the implicit arguments 0, and 1.  TODO: Pull out 2u and define\n     // it as a constant, since we're using it in several places in trans this\n     // way.\n-    let arg_n = 2u;\n+    let arg_n = 2u32;\n     alt ty_self {\n       impl_self(tt) {\n         cx.llself = some({v: cx.llenv, t: tt});\n@@ -4353,12 +4356,12 @@ fn create_llargs_for_fn_args(cx: @fn_ctxt, ty_self: self_arg,\n     }\n     for tp in ty_params {\n         let lltydesc = llvm::LLVMGetParam(cx.llfn, arg_n), dicts = none;\n-        arg_n += 1u;\n+        arg_n += 1u32;\n         for bound in *fcx_tcx(cx).ty_param_bounds.get(tp.id) {\n             alt bound {\n               ty::bound_iface(_) {\n                 let dict = llvm::LLVMGetParam(cx.llfn, arg_n);\n-                arg_n += 1u;\n+                arg_n += 1u32;\n                 dicts = some(alt dicts {\n                     none. { [dict] }\n                     some(ds) { ds + [dict] }\n@@ -4379,7 +4382,7 @@ fn create_llargs_for_fn_args(cx: @fn_ctxt, ty_self: self_arg,\n         // copy_args_to_allocas will overwrite the table entry with local_imm\n         // before it's actually used.\n         cx.llargs.insert(arg.id, local_mem(llarg));\n-        arg_n += 1u;\n+        arg_n += 1u32;\n     }\n }\n \n@@ -4798,7 +4801,7 @@ fn trans_native_mod(lcx: @local_ctxt, native_mod: ast::native_mod,\n         let fcx = new_fn_ctxt(lcx, span, llshimfn);\n         let bcx = new_top_block_ctxt(fcx);\n         let lltop = bcx.llbb;\n-        let llargbundle = llvm::LLVMGetParam(llshimfn, 0u);\n+        let llargbundle = llvm::LLVMGetParam(llshimfn, 0u32);\n         let i = 0u, n = vec::len(tys.arg_tys);\n         let llargvals = [];\n         while i < n {\n@@ -4808,7 +4811,8 @@ fn trans_native_mod(lcx: @local_ctxt, native_mod: ast::native_mod,\n         }\n \n         // Create the call itself and store the return value:\n-        let llretval = CallWithConv(bcx, llbasefn, llargvals, cc); // r\n+        let llretval = CallWithConv(bcx, llbasefn,\n+                                    llargvals, cc as c_uint); // r\n         if tys.ret_def {\n             // R** llretptr = &args->r;\n             let llretptr = GEPi(bcx, llargbundle, [0, n as int]);\n@@ -4842,11 +4846,12 @@ fn trans_native_mod(lcx: @local_ctxt, native_mod: ast::native_mod,\n         let i = 0u, n = vec::len(tys.arg_tys);\n         let implicit_args = 2u + num_tps; // ret + env\n         while i < n {\n-            let llargval = llvm::LLVMGetParam(llwrapfn, i + implicit_args);\n+            let llargval = llvm::LLVMGetParam(llwrapfn,\n+                                              (i + implicit_args) as c_uint);\n             store_inbounds(bcx, llargval, llargbundle, [0, i as int]);\n             i += 1u;\n         }\n-        let llretptr = llvm::LLVMGetParam(llwrapfn, 0u);\n+        let llretptr = llvm::LLVMGetParam(llwrapfn, 0u32);\n         store_inbounds(bcx, llretptr, llargbundle, [0, n as int]);\n \n         // Create call itself.\n@@ -4859,7 +4864,7 @@ fn trans_native_mod(lcx: @local_ctxt, native_mod: ast::native_mod,\n     }\n \n     let ccx = lcx_ccx(lcx);\n-    let cc: uint = lib::llvm::LLVMCCallConv;\n+    let cc = lib::llvm::LLVMCCallConv;\n     alt abi {\n       ast::native_abi_rust_intrinsic. { ret; }\n       ast::native_abi_cdecl. { cc = lib::llvm::LLVMCCallConv; }\n@@ -5031,10 +5036,10 @@ fn create_main_wrapper(ccx: @crate_ctxt, sp: span, main_llfn: ValueRef,\n         let bcx = new_top_block_ctxt(fcx);\n         let lltop = bcx.llbb;\n \n-        let lloutputarg = llvm::LLVMGetParam(llfdecl, 0u);\n-        let llenvarg = llvm::LLVMGetParam(llfdecl, 1u);\n+        let lloutputarg = llvm::LLVMGetParam(llfdecl, 0u32);\n+        let llenvarg = llvm::LLVMGetParam(llfdecl, 1u32);\n         let args = [lloutputarg, llenvarg];\n-        if takes_argv { args += [llvm::LLVMGetParam(llfdecl, 2u)]; }\n+        if takes_argv { args += [llvm::LLVMGetParam(llfdecl, 2u32)]; }\n         Call(bcx, main_llfn, args);\n         build_return(bcx);\n \n@@ -5065,11 +5070,11 @@ fn create_main_wrapper(ccx: @crate_ctxt, sp: span, main_llfn: ValueRef,\n         let start = str::as_buf(\"rust_start\", {|buf|\n             llvm::LLVMAddGlobal(ccx.llmod, start_ty, buf)\n         });\n-        let args = [rust_main, llvm::LLVMGetParam(llfn, 0u),\n-                    llvm::LLVMGetParam(llfn, 1u), crate_map];\n+        let args = [rust_main, llvm::LLVMGetParam(llfn, 0u32),\n+                    llvm::LLVMGetParam(llfn, 1u32), crate_map];\n         let result = unsafe {\n             llvm::LLVMBuildCall(bld, start, vec::to_ptr(args),\n-                                vec::len(args), noname())\n+                                vec::len(args) as c_uint, noname())\n         };\n         llvm::LLVMBuildRet(bld, result);\n     }"}, {"sha": "8fa703c8f8862380236fae7ebf74403b9e0ed3bc", "filename": "src/comp/middle/trans_build.rs", "status": "modified", "additions": 33, "deletions": 26, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/dde41869ce2ef1d66e753fc8b4efc7d917c77875/src%2Fcomp%2Fmiddle%2Ftrans_build.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde41869ce2ef1d66e753fc8b4efc7d917c77875/src%2Fcomp%2Fmiddle%2Ftrans_build.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_build.rs?ref=dde41869ce2ef1d66e753fc8b4efc7d917c77875", "patch": "@@ -1,4 +1,5 @@\n import core::{vec, str};\n+import core::ctypes::c_uint;\n import str::sbuf;\n import lib::llvm::llvm;\n import syntax::codemap;\n@@ -42,7 +43,7 @@ fn AggregateRet(cx: @block_ctxt, RetVals: [ValueRef]) {\n     cx.terminated = true;\n     unsafe {\n         llvm::LLVMBuildAggregateRet(B(cx), vec::to_ptr(RetVals),\n-                                    vec::len(RetVals));\n+                                    vec::len(RetVals) as c_uint);\n     }\n }\n \n@@ -66,7 +67,7 @@ fn Switch(cx: @block_ctxt, V: ValueRef, Else: BasicBlockRef, NumCases: uint)\n     if cx.unreachable { ret _Undef(V); }\n     assert !cx.terminated;\n     cx.terminated = true;\n-    ret llvm::LLVMBuildSwitch(B(cx), V, Else, NumCases);\n+    ret llvm::LLVMBuildSwitch(B(cx), V, Else, NumCases as c_uint);\n }\n \n fn AddCase(S: ValueRef, OnVal: ValueRef, Dest: BasicBlockRef) {\n@@ -78,7 +79,7 @@ fn IndirectBr(cx: @block_ctxt, Addr: ValueRef, NumDests: uint) {\n     if cx.unreachable { ret; }\n     assert (!cx.terminated);\n     cx.terminated = true;\n-    llvm::LLVMBuildIndirectBr(B(cx), Addr, NumDests);\n+    llvm::LLVMBuildIndirectBr(B(cx), Addr, NumDests as c_uint);\n }\n \n // This is a really awful way to get a zero-length c-string, but better (and a\n@@ -95,7 +96,7 @@ fn Invoke(cx: @block_ctxt, Fn: ValueRef, Args: [ValueRef],\n     cx.terminated = true;\n     unsafe {\n         llvm::LLVMBuildInvoke(B(cx), Fn, vec::to_ptr(Args),\n-                              vec::len(Args), Then, Catch,\n+                              vec::len(Args) as c_uint, Then, Catch,\n                               noname());\n     }\n }\n@@ -107,8 +108,10 @@ fn FastInvoke(cx: @block_ctxt, Fn: ValueRef, Args: [ValueRef],\n     cx.terminated = true;\n     unsafe {\n         let v = llvm::LLVMBuildInvoke(B(cx), Fn, vec::to_ptr(Args),\n-                                      vec::len(Args), Then, Catch, noname());\n-        llvm::LLVMSetInstructionCallConv(v, lib::llvm::LLVMFastCallConv);\n+                                      vec::len(Args) as c_uint,\n+                                      Then, Catch, noname());\n+        llvm::LLVMSetInstructionCallConv(\n+            v, lib::llvm::LLVMFastCallConv as c_uint);\n     }\n }\n \n@@ -308,7 +311,7 @@ fn Load(cx: @block_ctxt, PointerVal: ValueRef) -> ValueRef {\n     let ccx = cx.fcx.lcx.ccx;\n     if cx.unreachable {\n         let ty = val_ty(PointerVal);\n-        let eltty = if llvm::LLVMGetTypeKind(ty) == 11 {\n+        let eltty = if llvm::LLVMGetTypeKind(ty) == 11i32 {\n             llvm::LLVMGetElementType(ty) } else { ccx.int_type };\n         ret llvm::LLVMGetUndef(eltty);\n     }\n@@ -324,7 +327,7 @@ fn GEP(cx: @block_ctxt, Pointer: ValueRef, Indices: [ValueRef]) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(T_nil())); }\n     unsafe {\n         ret llvm::LLVMBuildGEP(B(cx), Pointer, vec::to_ptr(Indices),\n-                               vec::len(Indices), noname());\n+                               vec::len(Indices) as c_uint, noname());\n     }\n }\n \n@@ -342,13 +345,14 @@ fn InBoundsGEP(cx: @block_ctxt, Pointer: ValueRef, Indices: [ValueRef]) ->\n     unsafe {\n         ret llvm::LLVMBuildInBoundsGEP(B(cx), Pointer,\n                                        vec::to_ptr(Indices),\n-                                       vec::len(Indices), noname());\n+                                       vec::len(Indices) as c_uint,\n+                                       noname());\n     }\n }\n \n fn StructGEP(cx: @block_ctxt, Pointer: ValueRef, Idx: uint) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(T_nil())); }\n-    ret llvm::LLVMBuildStructGEP(B(cx), Pointer, Idx, noname());\n+    ret llvm::LLVMBuildStructGEP(B(cx), Pointer, Idx as c_uint, noname());\n }\n \n fn GlobalString(cx: @block_ctxt, _Str: sbuf) -> ValueRef {\n@@ -465,12 +469,12 @@ fn FPCast(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n /* Comparisons */\n fn ICmp(cx: @block_ctxt, Op: uint, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_i1()); }\n-    ret llvm::LLVMBuildICmp(B(cx), Op, LHS, RHS, noname());\n+    ret llvm::LLVMBuildICmp(B(cx), Op as c_uint, LHS, RHS, noname());\n }\n \n fn FCmp(cx: @block_ctxt, Op: uint, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_i1()); }\n-    ret llvm::LLVMBuildFCmp(B(cx), Op, LHS, RHS, noname());\n+    ret llvm::LLVMBuildFCmp(B(cx), Op as c_uint, LHS, RHS, noname());\n }\n \n /* Miscellaneous instructions */\n@@ -486,7 +490,7 @@ fn Phi(cx: @block_ctxt, Ty: TypeRef, vals: [ValueRef], bbs: [BasicBlockRef])\n     let phi = EmptyPhi(cx, Ty);\n     unsafe {\n         llvm::LLVMAddIncoming(phi, vec::to_ptr(vals), vec::to_ptr(bbs),\n-                              vec::len(vals));\n+                              vec::len(vals) as c_uint);\n         ret phi;\n     }\n }\n@@ -496,14 +500,14 @@ fn AddIncomingToPhi(phi: ValueRef, val: ValueRef, bb: BasicBlockRef) {\n     unsafe {\n         let valptr = unsafe::reinterpret_cast(ptr::addr_of(val));\n         let bbptr = unsafe::reinterpret_cast(ptr::addr_of(bb));\n-        llvm::LLVMAddIncoming(phi, valptr, bbptr, 1u);\n+        llvm::LLVMAddIncoming(phi, valptr, bbptr, 1u32);\n     }\n }\n \n fn _UndefReturn(cx: @block_ctxt, Fn: ValueRef) -> ValueRef {\n     let ccx = cx.fcx.lcx.ccx;\n     let ty = val_ty(Fn);\n-    let retty = if llvm::LLVMGetTypeKind(ty) == 8 {\n+    let retty = if llvm::LLVMGetTypeKind(ty) == 8i32 {\n         llvm::LLVMGetReturnType(ty) } else { ccx.int_type };\n     ret llvm::LLVMGetUndef(retty);\n }\n@@ -535,26 +539,27 @@ fn Call(cx: @block_ctxt, Fn: ValueRef, Args: [ValueRef]) -> ValueRef {\n     if cx.unreachable { ret _UndefReturn(cx, Fn); }\n     unsafe {\n         ret llvm::LLVMBuildCall(B(cx), Fn, vec::to_ptr(Args),\n-                                vec::len(Args), noname());\n+                                vec::len(Args) as c_uint, noname());\n     }\n }\n \n fn FastCall(cx: @block_ctxt, Fn: ValueRef, Args: [ValueRef]) -> ValueRef {\n     if cx.unreachable { ret _UndefReturn(cx, Fn); }\n     unsafe {\n         let v = llvm::LLVMBuildCall(B(cx), Fn, vec::to_ptr(Args),\n-                                    vec::len(Args), noname());\n-        llvm::LLVMSetInstructionCallConv(v, lib::llvm::LLVMFastCallConv);\n+                                    vec::len(Args) as c_uint, noname());\n+        llvm::LLVMSetInstructionCallConv(\n+            v, lib::llvm::LLVMFastCallConv as c_uint);\n         ret v;\n     }\n }\n \n-fn CallWithConv(cx: @block_ctxt, Fn: ValueRef, Args: [ValueRef], Conv: uint)\n-   -> ValueRef {\n+fn CallWithConv(cx: @block_ctxt, Fn: ValueRef, Args: [ValueRef],\n+                Conv: c_uint) -> ValueRef {\n     if cx.unreachable { ret _UndefReturn(cx, Fn); }\n     unsafe {\n         let v = llvm::LLVMBuildCall(B(cx), Fn, vec::to_ptr(Args),\n-                                    vec::len(Args), noname());\n+                                    vec::len(Args) as c_uint, noname());\n         llvm::LLVMSetInstructionCallConv(v, Conv);\n         ret v;\n     }\n@@ -591,13 +596,14 @@ fn ShuffleVector(cx: @block_ctxt, V1: ValueRef, V2: ValueRef,\n \n fn ExtractValue(cx: @block_ctxt, AggVal: ValueRef, Index: uint) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_nil()); }\n-    ret llvm::LLVMBuildExtractValue(B(cx), AggVal, Index, noname());\n+    ret llvm::LLVMBuildExtractValue(B(cx), AggVal, Index as c_uint, noname());\n }\n \n fn InsertValue(cx: @block_ctxt, AggVal: ValueRef, EltVal: ValueRef,\n                Index: uint) {\n     if cx.unreachable { ret; }\n-    llvm::LLVMBuildInsertValue(B(cx), AggVal, EltVal, Index, noname());\n+    llvm::LLVMBuildInsertValue(B(cx), AggVal, EltVal, Index as c_uint,\n+                               noname());\n }\n \n fn IsNull(cx: @block_ctxt, Val: ValueRef) -> ValueRef {\n@@ -628,15 +634,16 @@ fn Trap(cx: @block_ctxt) {\n     assert (T as int != 0);\n     let Args: [ValueRef] = [];\n     unsafe {\n-        llvm::LLVMBuildCall(b, T, vec::to_ptr(Args), vec::len(Args),\n-                            noname());\n+        llvm::LLVMBuildCall(b, T, vec::to_ptr(Args),\n+                            vec::len(Args) as c_uint, noname());\n     }\n }\n \n fn LandingPad(cx: @block_ctxt, Ty: TypeRef, PersFn: ValueRef,\n               NumClauses: uint) -> ValueRef {\n     assert !cx.terminated && !cx.unreachable;\n-    ret llvm::LLVMBuildLandingPad(B(cx), Ty, PersFn, NumClauses, noname());\n+    ret llvm::LLVMBuildLandingPad(B(cx), Ty, PersFn,\n+                                  NumClauses as c_uint, noname());\n }\n \n fn SetCleanup(_cx: @block_ctxt, LandingPad: ValueRef) {"}, {"sha": "61f7aec999798fde1403ff4bfdeb3219223aa9d1", "filename": "src/comp/middle/trans_closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dde41869ce2ef1d66e753fc8b4efc7d917c77875/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde41869ce2ef1d66e753fc8b4efc7d917c77875/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs?ref=dde41869ce2ef1d66e753fc8b4efc7d917c77875", "patch": "@@ -918,7 +918,7 @@ fn trans_bind_thunk(cx: @local_ctxt,\n         fcx.lltyparams += [{desc: dsc, dicts: dicts}];\n     }\n \n-    let a: uint = 2u; // retptr, env come first\n+    let a: u32 = 2u32; // retptr, env come first\n     let b: int = starting_idx;\n     let outgoing_arg_index: uint = 0u;\n     let llout_arg_tys: [TypeRef] =\n@@ -960,7 +960,7 @@ fn trans_bind_thunk(cx: @local_ctxt,\n                 arg = PointerCast(bcx, arg, llout_arg_ty);\n             }\n             llargs += [arg];\n-            a += 1u;\n+            a += 1u32;\n           }\n         }\n         outgoing_arg_index += 1u;"}, {"sha": "835f8cc5c5e861a272b4c2d721d8202dbf65e30d", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 26, "deletions": 22, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/dde41869ce2ef1d66e753fc8b4efc7d917c77875/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde41869ce2ef1d66e753fc8b4efc7d917c77875/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=dde41869ce2ef1d66e753fc8b4efc7d917c77875", "patch": "@@ -4,6 +4,7 @@\n */\n \n import core::{int, vec, str, uint, option, unsafe};\n+import core::ctypes::unsigned;\n import vec::to_ptr;\n import std::map::hashmap;\n import option::some;\n@@ -410,7 +411,7 @@ fn val_str(tn: type_names, v: ValueRef) -> str { ret ty_str(tn, val_ty(v)); }\n \n // Returns the nth element of the given LLVM structure type.\n fn struct_elt(llstructty: TypeRef, n: uint) -> TypeRef unsafe {\n-    let elt_count = llvm::LLVMCountStructElementTypes(llstructty);\n+    let elt_count = llvm::LLVMCountStructElementTypes(llstructty) as uint;\n     assert (n < elt_count);\n     let elt_tys = vec::init_elt(T_nil(), elt_count);\n     llvm::LLVMGetStructElementTypes(llstructty, to_ptr(elt_tys));\n@@ -533,17 +534,20 @@ fn T_size_t(targ_cfg: @session::config) -> TypeRef {\n \n fn T_fn(inputs: [TypeRef], output: TypeRef) -> TypeRef unsafe {\n     ret llvm::LLVMFunctionType(output, to_ptr(inputs),\n-                               vec::len::<TypeRef>(inputs), False);\n+                               vec::len::<TypeRef>(inputs) as unsigned,\n+                               False);\n }\n \n fn T_fn_pair(cx: @crate_ctxt, tfn: TypeRef) -> TypeRef {\n     ret T_struct([T_ptr(tfn), T_opaque_cbox_ptr(cx)]);\n }\n \n-fn T_ptr(t: TypeRef) -> TypeRef { ret llvm::LLVMPointerType(t, 0u); }\n+fn T_ptr(t: TypeRef) -> TypeRef {\n+    ret llvm::LLVMPointerType(t, 0u as unsigned);\n+}\n \n fn T_struct(elts: [TypeRef]) -> TypeRef unsafe {\n-    ret llvm::LLVMStructType(to_ptr(elts), vec::len(elts), False);\n+    ret llvm::LLVMStructType(to_ptr(elts), vec::len(elts) as unsigned, False);\n }\n \n fn T_named_struct(name: str) -> TypeRef {\n@@ -552,7 +556,8 @@ fn T_named_struct(name: str) -> TypeRef {\n }\n \n fn set_struct_body(t: TypeRef, elts: [TypeRef]) unsafe {\n-    llvm::LLVMStructSetBody(t, to_ptr(elts), vec::len(elts), False);\n+    llvm::LLVMStructSetBody(t, to_ptr(elts),\n+                            vec::len(elts) as unsigned, False);\n }\n \n fn T_empty_struct() -> TypeRef { ret T_struct([]); }\n@@ -634,7 +639,9 @@ fn T_tydesc(targ_cfg: @session::config) -> TypeRef {\n     ret tydesc;\n }\n \n-fn T_array(t: TypeRef, n: uint) -> TypeRef { ret llvm::LLVMArrayType(t, n); }\n+fn T_array(t: TypeRef, n: uint) -> TypeRef {\n+    ret llvm::LLVMArrayType(t, n as unsigned);\n+}\n \n // Interior vector.\n //\n@@ -739,8 +746,8 @@ fn T_opaque_chan_ptr() -> TypeRef { ret T_ptr(T_i8()); }\n fn C_null(t: TypeRef) -> ValueRef { ret llvm::LLVMConstNull(t); }\n \n fn C_integral(t: TypeRef, u: u64, sign_extend: Bool) -> ValueRef {\n-    let u_hi = (u >> 32u64) as uint;\n-    let u_lo = u as uint;\n+    let u_hi = (u >> 32u64) as unsigned;\n+    let u_lo = u as unsigned;\n     ret llvm::LLVMRustConstInt(t, u_hi, u_lo, sign_extend);\n }\n \n@@ -782,11 +789,9 @@ fn C_u8(i: uint) -> ValueRef { ret C_integral(T_i8(), i as u64, False); }\n // This is a 'c-like' raw string, which differs from\n // our boxed-and-length-annotated strings.\n fn C_cstr(cx: @crate_ctxt, s: str) -> ValueRef {\n-    let sc =\n-        str::as_buf(s,\n-                    {|buf|\n-                        llvm::LLVMConstString(buf, str::byte_len(s), False)\n-                    });\n+    let sc = str::as_buf(s) {|buf|\n+        llvm::LLVMConstString(buf, str::byte_len(s) as unsigned, False)\n+    };\n     let g =\n         str::as_buf(cx.names(\"str\"),\n                     {|buf| llvm::LLVMAddGlobal(cx.llmod, val_ty(sc), buf) });\n@@ -798,39 +803,38 @@ fn C_cstr(cx: @crate_ctxt, s: str) -> ValueRef {\n \n // Returns a Plain Old LLVM String:\n fn C_postr(s: str) -> ValueRef {\n-    ret str::as_buf(s,\n-                    {|buf|\n-                        llvm::LLVMConstString(buf, str::byte_len(s), False)\n-                    });\n+    ret str::as_buf(s) {|buf|\n+        llvm::LLVMConstString(buf, str::byte_len(s) as unsigned, False)\n+    };\n }\n \n fn C_zero_byte_arr(size: uint) -> ValueRef unsafe {\n     let i = 0u;\n     let elts: [ValueRef] = [];\n     while i < size { elts += [C_u8(0u)]; i += 1u; }\n     ret llvm::LLVMConstArray(T_i8(), vec::to_ptr(elts),\n-                             vec::len(elts));\n+                             vec::len(elts) as unsigned);\n }\n \n fn C_struct(elts: [ValueRef]) -> ValueRef unsafe {\n-    ret llvm::LLVMConstStruct(vec::to_ptr(elts), vec::len(elts),\n+    ret llvm::LLVMConstStruct(vec::to_ptr(elts), vec::len(elts) as unsigned,\n                               False);\n }\n \n fn C_named_struct(T: TypeRef, elts: [ValueRef]) -> ValueRef unsafe {\n     ret llvm::LLVMConstNamedStruct(T, vec::to_ptr(elts),\n-                                   vec::len(elts));\n+                                   vec::len(elts) as unsigned);\n }\n \n fn C_array(ty: TypeRef, elts: [ValueRef]) -> ValueRef unsafe {\n     ret llvm::LLVMConstArray(ty, vec::to_ptr(elts),\n-                             vec::len(elts));\n+                             vec::len(elts) as unsigned);\n }\n \n fn C_bytes(bytes: [u8]) -> ValueRef unsafe {\n     ret llvm::LLVMConstString(\n         unsafe::reinterpret_cast(vec::to_ptr(bytes)),\n-        vec::len(bytes), False);\n+        vec::len(bytes) as unsigned, False);\n }\n \n fn C_shape(ccx: @crate_ctxt, bytes: [u8]) -> ValueRef {"}, {"sha": "f23f4a47353487dabee93da4233f5843863df60b", "filename": "src/comp/middle/trans_impl.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/dde41869ce2ef1d66e753fc8b4efc7d917c77875/src%2Fcomp%2Fmiddle%2Ftrans_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde41869ce2ef1d66e753fc8b4efc7d917c77875/src%2Fcomp%2Fmiddle%2Ftrans_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_impl.rs?ref=dde41869ce2ef1d66e753fc8b4efc7d917c77875", "patch": "@@ -138,7 +138,7 @@ fn trans_iface_callee(bcx: @block_ctxt, fld_expr: @ast::expr,\n fn llfn_arg_tys(ft: TypeRef) -> {inputs: [TypeRef], output: TypeRef} {\n     let out_ty = llvm::LLVMGetReturnType(ft);\n     let n_args = llvm::LLVMCountParamTypes(ft);\n-    let args = vec::init_elt(0 as TypeRef, n_args);\n+    let args = vec::init_elt(0 as TypeRef, n_args as uint);\n     unsafe { llvm::LLVMGetParamTypes(ft, vec::to_ptr(args)); }\n     {inputs: args, output: out_ty}\n }\n@@ -191,19 +191,20 @@ fn trans_impl_wrapper(ccx: @crate_ctxt, pt: [ast::ident],\n         vec::slice(real_args, 2u + vec::len(extra_ptrs), vec::len(real_args));\n     let llfn_ty = T_fn(wrap_args, real_ret);\n     trans_wrapper(ccx, pt, llfn_ty, {|llfn, bcx|\n-        let dict = PointerCast(bcx, LLVMGetParam(llfn, 0u), env_ty);\n+        let dict = PointerCast(bcx, LLVMGetParam(llfn, 0u32), env_ty);\n         // retptr, self\n-        let args = [LLVMGetParam(llfn, 1u), LLVMGetParam(llfn, 2u)], i = 0u;\n+        let args = [LLVMGetParam(llfn, 1u32), LLVMGetParam(llfn, 2u32)];\n+        let i = 0u;\n         // saved tydescs/dicts\n         while i < n_extra_ptrs {\n             i += 1u;\n             args += [load_inbounds(bcx, dict, [0, i as int])];\n         }\n         // the rest of the parameters\n-        let i = 3u, params_total = llvm::LLVMCountParamTypes(llfn_ty);\n+        let i = 3u32, params_total = llvm::LLVMCountParamTypes(llfn_ty);\n         while i < params_total {\n             args += [LLVMGetParam(llfn, i)];\n-            i += 1u;\n+            i += 1u32;\n         }\n         Call(bcx, real_fn, args);\n         bcx\n@@ -231,7 +232,7 @@ fn trans_iface_wrapper(ccx: @crate_ctxt, pt: [ast::ident], m: ty::method,\n                        n: uint) -> ValueRef {\n     let {llty: llfty, _} = wrapper_fn_ty(ccx, T_ptr(T_i8()), m);\n     trans_wrapper(ccx, pt, llfty, {|llfn, bcx|\n-        let self = Load(bcx, PointerCast(bcx, LLVMGetParam(llfn, 2u),\n+        let self = Load(bcx, PointerCast(bcx, LLVMGetParam(llfn, 2u32),\n                                          T_ptr(T_opaque_iface_ptr(ccx))));\n         let boxed = GEPi(bcx, self, [0, abi::box_rc_field_body]);\n         let dict = Load(bcx, PointerCast(bcx, GEPi(bcx, boxed, [0, 1]),\n@@ -242,12 +243,12 @@ fn trans_iface_wrapper(ccx: @crate_ctxt, pt: [ast::ident], m: ty::method,\n         // FIXME[impl] This doesn't account for more-than-ptr-sized alignment\n         let inner_self = GEPi(bcx, boxed, [0, 2]);\n         let args = [PointerCast(bcx, dict, T_ptr(T_i8())),\n-                    LLVMGetParam(llfn, 1u),\n+                    LLVMGetParam(llfn, 1u32),\n                     PointerCast(bcx, inner_self, T_opaque_cbox_ptr(ccx))];\n-        let i = 3u, total = llvm::LLVMCountParamTypes(llfty);\n+        let i = 3u32, total = llvm::LLVMCountParamTypes(llfty);\n         while i < total {\n             args += [LLVMGetParam(llfn, i)];\n-            i += 1u;\n+            i += 1u32;\n         }\n         Call(bcx, mptr, args);\n         bcx"}, {"sha": "98d49083f9daf747d84ec16c3a9442b56208583e", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dde41869ce2ef1d66e753fc8b4efc7d917c77875/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde41869ce2ef1d66e753fc8b4efc7d917c77875/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=dde41869ce2ef1d66e753fc8b4efc7d917c77875", "patch": "@@ -33,7 +33,7 @@ native mod rustrt {\n                             target_task: task::task, target_port: port_id,\n                             data: T) -> ctypes::uintptr_t;\n \n-    fn new_port(unit_sz: uint) -> *rust_port;\n+    fn new_port(unit_sz: ctypes::size_t) -> *rust_port;\n     fn del_port(po: *rust_port);\n     fn rust_port_detach(po: *rust_port);\n     fn get_port_id(po: *rust_port) -> port_id;"}, {"sha": "a7eb33daeaf3267084c6defc1db331b394a0723e", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dde41869ce2ef1d66e753fc8b4efc7d917c77875/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde41869ce2ef1d66e753fc8b4efc7d917c77875/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=dde41869ce2ef1d66e753fc8b4efc7d917c77875", "patch": "@@ -6,7 +6,7 @@ Unsafe pointer utility functions\n #[abi = \"rust-intrinsic\"]\n native mod rusti {\n     fn addr_of<T>(val: T) -> *T;\n-    fn ptr_offset<T>(ptr: *T, count: uint) -> *T;\n+    fn ptr_offset<T>(ptr: *T, count: ctypes::uintptr_t) -> *T;\n }\n \n /*"}, {"sha": "2d516fbeea396a4e830fc1e117319faab478a057", "filename": "src/libcore/sys.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dde41869ce2ef1d66e753fc8b4efc7d917c77875/src%2Flibcore%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde41869ce2ef1d66e753fc8b4efc7d917c77875/src%2Flibcore%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsys.rs?ref=dde41869ce2ef1d66e753fc8b4efc7d917c77875", "patch": "@@ -16,12 +16,12 @@ native mod rustrt {\n     // available outside this crate. Otherwise it's\n     // visible-in-crate, but not re-exported.\n     fn last_os_error() -> str;\n-    fn refcount<T>(t: @T) -> uint;\n+    fn refcount<T>(t: @T) -> ctypes::intptr_t;\n     fn do_gc();\n     fn unsupervise();\n     fn shape_log_str<T>(t: *sys::type_desc, data: T) -> str;\n-    fn rust_set_exit_status(code: int);\n-    fn set_min_stack(size: uint);\n+    fn rust_set_exit_status(code: ctypes::intptr_t);\n+    fn set_min_stack(size: ctypes::uintptr_t);\n }\n \n #[abi = \"rust-intrinsic\"]\n@@ -103,7 +103,7 @@ fn log_str<T>(t: T) -> str {\n             with the default failure status.\"\n )]\n fn set_exit_status(code: int) {\n-    rustrt::rust_set_exit_status(code);\n+    rustrt::rust_set_exit_status(code as ctypes::intptr_t);\n }\n \n // FIXME: #1495 - This shouldn't exist"}, {"sha": "cd6fb1a4ae11e49f0f6d57ced82c6509952f17f4", "filename": "src/libcore/task.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dde41869ce2ef1d66e753fc8b4efc7d917c77875/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde41869ce2ef1d66e753fc8b4efc7d917c77875/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=dde41869ce2ef1d66e753fc8b4efc7d917c77875", "patch": "@@ -55,7 +55,7 @@ export try;\n #[abi = \"rust-intrinsic\"]\n native mod rusti {\n     // these must run on the Rust stack so that they can swap stacks etc:\n-    fn task_sleep(task: *rust_task, time_in_us: uint, &killed: bool);\n+    fn task_sleep(task: *rust_task, time_in_us: c::size_t, &killed: bool);\n }\n \n type rust_closure = {"}, {"sha": "33ff630e708b170d2dea29fce0c2e7e8b0fa4de9", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dde41869ce2ef1d66e753fc8b4efc7d917c77875/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde41869ce2ef1d66e753fc8b4efc7d917c77875/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=dde41869ce2ef1d66e753fc8b4efc7d917c77875", "patch": "@@ -8,17 +8,17 @@ import ptr::addr_of;\n \n #[abi = \"rust-intrinsic\"]\n native mod rusti {\n-    fn vec_len<T>(&&v: [const T]) -> uint;\n+    fn vec_len<T>(&&v: [const T]) -> ctypes::size_t;\n }\n \n #[abi = \"cdecl\"]\n native mod rustrt {\n     fn vec_reserve_shared<T>(t: *sys::type_desc,\n                              &v: [const T],\n-                             n: uint);\n+                             n: ctypes::size_t);\n     fn vec_from_buf_shared<T>(t: *sys::type_desc,\n                               ptr: *T,\n-                              count: uint) -> [T];\n+                              count: ctypes::size_t) -> [T];\n }\n \n /*"}, {"sha": "e1f82fedda0625ab19d389c4d8735e78398117eb", "filename": "src/libstd/dbg.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dde41869ce2ef1d66e753fc8b4efc7d917c77875/src%2Flibstd%2Fdbg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde41869ce2ef1d66e753fc8b4efc7d917c77875/src%2Flibstd%2Fdbg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdbg.rs?ref=dde41869ce2ef1d66e753fc8b4efc7d917c77875", "patch": "@@ -14,7 +14,8 @@ native mod rustrt {\n     fn debug_opaque<T>(td: *sys::type_desc, x: T);\n     fn debug_box<T>(td: *sys::type_desc, x: @T);\n     fn debug_tag<T>(td: *sys::type_desc, x: T);\n-    fn debug_obj<T>(td: *sys::type_desc, x: T, nmethods: uint, nbytes: uint);\n+    fn debug_obj<T>(td: *sys::type_desc, x: T,\n+                    nmethods: ctypes::size_t, nbytes: ctypes::size_t);\n     fn debug_fn<T>(td: *sys::type_desc, x: T);\n     fn debug_ptrcast<T, U>(td: *sys::type_desc, x: @T) -> @U;\n }"}, {"sha": "fe06e2a89aa6f3019845f000e4c7823cffd5b404", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dde41869ce2ef1d66e753fc8b4efc7d917c77875/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde41869ce2ef1d66e753fc8b4efc7d917c77875/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=dde41869ce2ef1d66e753fc8b4efc7d917c77875", "patch": "@@ -13,8 +13,8 @@ import os_fs;\n \n #[abi = \"cdecl\"]\n native mod rustrt {\n-    fn rust_path_is_dir(path: str::sbuf) -> int;\n-    fn rust_path_exists(path: str::sbuf) -> int;\n+    fn rust_path_is_dir(path: str::sbuf) -> ctypes::c_int;\n+    fn rust_path_exists(path: str::sbuf) -> ctypes::c_int;\n }\n \n /*\n@@ -120,7 +120,7 @@ Function: path_is_dir\n Indicates whether a path represents a directory.\n */\n fn path_is_dir(p: path) -> bool {\n-    ret str::as_buf(p, {|buf| rustrt::rust_path_is_dir(buf) != 0 });\n+    ret str::as_buf(p, {|buf| rustrt::rust_path_is_dir(buf) != 0i32 });\n }\n \n /*\n@@ -129,7 +129,7 @@ Function: path_exists\n Indicates whether a path exists.\n */\n fn path_exists(p: path) -> bool {\n-    ret str::as_buf(p, {|buf| rustrt::rust_path_exists(buf) != 0 });\n+    ret str::as_buf(p, {|buf| rustrt::rust_path_exists(buf) != 0i32 });\n }\n \n /*"}, {"sha": "3d58a71f95040b10b1e0165dc9e46275148b1ec1", "filename": "src/libstd/test.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dde41869ce2ef1d66e753fc8b4efc7d917c77875/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde41869ce2ef1d66e753fc8b4efc7d917c77875/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=dde41869ce2ef1d66e753fc8b4efc7d917c77875", "patch": "@@ -5,6 +5,7 @@\n \n import result::{ok, err};\n import io::writer_util;\n+import core::ctypes;\n \n export test_name;\n export test_fn;\n@@ -28,7 +29,7 @@ export joinable;\n \n #[abi = \"cdecl\"]\n native mod rustrt {\n-    fn sched_threads() -> uint;\n+    fn sched_threads() -> ctypes::size_t;\n }\n \n // The name of a test. By convention this follows the rules for rust"}]}