{"sha": "38c2363c459b481f40392f78b4db843172961fd4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4YzIzNjNjNDU5YjQ4MWY0MDM5MmY3OGI0ZGI4NDMxNzI5NjFmZDQ=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-15T23:21:55Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-16T17:29:09Z"}, "message": "Replace std::ufind with std::ufindivec. Remove std::ufindivec", "tree": {"sha": "cc81bdaafa3e505094464173022bc051ac16c2a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cc81bdaafa3e505094464173022bc051ac16c2a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/38c2363c459b481f40392f78b4db843172961fd4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/38c2363c459b481f40392f78b4db843172961fd4", "html_url": "https://github.com/rust-lang/rust/commit/38c2363c459b481f40392f78b4db843172961fd4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/38c2363c459b481f40392f78b4db843172961fd4/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "df402a5029a1e37d8fbf7f5a18d32efaf9ef751b", "url": "https://api.github.com/repos/rust-lang/rust/commits/df402a5029a1e37d8fbf7f5a18d32efaf9ef751b", "html_url": "https://github.com/rust-lang/rust/commit/df402a5029a1e37d8fbf7f5a18d32efaf9ef751b"}], "stats": {"total": 105, "additions": 26, "deletions": 79}, "files": [{"sha": "9468b76d7a4bfa7a8417cb8c26456e62f65e6f78", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/38c2363c459b481f40392f78b4db843172961fd4/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38c2363c459b481f40392f78b4db843172961fd4/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=38c2363c459b481f40392f78b4db843172961fd4", "patch": "@@ -3,7 +3,7 @@ import std::ivec;\n import std::str;\n import std::uint;\n import std::box;\n-import std::ufindivec;\n+import std::ufind;\n import std::map;\n import std::map::hashmap;\n import std::option;\n@@ -2130,24 +2130,24 @@ mod unify {\n \n     }\n     type var_bindings =\n-        {sets: ufindivec::ufind, types: smallintmap::smallintmap[t]};\n+        {sets: ufind::ufind, types: smallintmap::smallintmap[t]};\n \n     type ctxt = {vb: @var_bindings, tcx: ty_ctxt};\n \n     fn mk_var_bindings() -> @var_bindings {\n-        ret @{sets: ufindivec::make(), types: smallintmap::mk[t]()};\n+        ret @{sets: ufind::make(), types: smallintmap::mk[t]()};\n     }\n \n     // Unifies two sets.\n     fn union(cx: &@ctxt, set_a: uint, set_b: uint) -> union_result {\n-        ufindivec::grow(cx.vb.sets, uint::max(set_a, set_b) + 1u);\n-        let root_a = ufindivec::find(cx.vb.sets, set_a);\n-        let root_b = ufindivec::find(cx.vb.sets, set_b);\n+        ufind::grow(cx.vb.sets, uint::max(set_a, set_b) + 1u);\n+        let root_a = ufind::find(cx.vb.sets, set_a);\n+        let root_b = ufind::find(cx.vb.sets, set_b);\n \n         let replace_type =\n             bind fn (cx: &@ctxt, t: t, set_a: uint, set_b: uint) {\n-                     ufindivec::union(cx.vb.sets, set_a, set_b);\n-                     let root_c: uint = ufindivec::find(cx.vb.sets, set_a);\n+                     ufind::union(cx.vb.sets, set_a, set_b);\n+                     let root_c: uint = ufind::find(cx.vb.sets, set_a);\n                      smallintmap::insert[t](cx.vb.types, root_c, t);\n                  }(_, _, set_a, set_b);\n \n@@ -2156,7 +2156,7 @@ mod unify {\n           none. {\n             alt smallintmap::find(cx.vb.types, root_b) {\n               none. {\n-                ufindivec::union(cx.vb.sets, set_a, set_b);\n+                ufind::union(cx.vb.sets, set_a, set_b);\n                 ret unres_ok;\n               }\n               some(t_b) { replace_type(cx, t_b); ret unres_ok; }\n@@ -2176,8 +2176,8 @@ mod unify {\n         }\n     }\n     fn record_var_binding(cx: &@ctxt, key: int, typ: t) -> result {\n-        ufindivec::grow(cx.vb.sets, (key as uint) + 1u);\n-        let root = ufindivec::find(cx.vb.sets, key as uint);\n+        ufind::grow(cx.vb.sets, (key as uint) + 1u);\n+        let root = ufind::find(cx.vb.sets, key as uint);\n         let result_type = typ;\n         alt smallintmap::find[t](cx.vb.types, root) {\n           some(old_type) {\n@@ -2410,10 +2410,10 @@ mod unify {\n        fixup_result {\n         alt struct(tcx, typ) {\n           ty_var(vid) {\n-            if vid as uint >= ufindivec::set_count(vb.sets) {\n+            if vid as uint >= ufind::set_count(vb.sets) {\n                 ret fix_err(vid);\n             }\n-            let root_id = ufindivec::find(vb.sets, vid as uint);\n+            let root_id = ufind::find(vb.sets, vid as uint);\n             alt smallintmap::find[t](vb.types, root_id) {\n               none. { ret fix_err(vid); }\n               some(rt) { ret fix_ok(rt); }\n@@ -2825,11 +2825,11 @@ mod unify {\n     }\n     fn dump_var_bindings(tcx: ty_ctxt, vb: @var_bindings) {\n         let i = 0u;\n-        while i < ivec::len[ufindivec::node](vb.sets.nodes) {\n+        while i < ivec::len[ufind::node](vb.sets.nodes) {\n             let sets = \"\";\n             let j = 0u;\n             while j < ivec::len[option::t[uint]](vb.sets.nodes) {\n-                if ufindivec::find(vb.sets, j) == i {\n+                if ufind::find(vb.sets, j) == i {\n                     sets += #fmt(\" %u\", j);\n                 }\n                 j += 1u;\n@@ -2854,11 +2854,11 @@ mod unify {\n                       unresolved: @mutable option::t[int], vid: int) -> t {\n             // Should really return a fixup_result instead of a t, but fold_ty\n             // doesn't allow returning anything but a t.\n-            if vid as uint >= ufindivec::set_count(vb.sets) {\n+            if vid as uint >= ufind::set_count(vb.sets) {\n                 *unresolved = some(vid);\n                 ret ty::mk_var(tcx, vid);\n             }\n-            let root_id = ufindivec::find(vb.sets, vid as uint);\n+            let root_id = ufind::find(vb.sets, vid as uint);\n             alt smallintmap::find[t](vb.types, root_id) {\n               none. { *unresolved = some(vid); ret ty::mk_var(tcx, vid); }\n               some(rt) {\n@@ -2884,8 +2884,8 @@ mod unify {\n     fn resolve_type_var(tcx: &ty_ctxt, sp: &option::t[span],\n                         vb: &@var_bindings, vid: int) ->\n        fixup_result {\n-        if vid as uint >= ufindivec::set_count(vb.sets) { ret fix_err(vid); }\n-        let root_id = ufindivec::find(vb.sets, vid as uint);\n+        if vid as uint >= ufind::set_count(vb.sets) { ret fix_err(vid); }\n+        let root_id = ufind::find(vb.sets, vid as uint);\n         alt smallintmap::find[t](vb.types, root_id) {\n           none. { ret fix_err(vid); }\n           some(rt) { ret fixup_vars(tcx, sp, vb, rt); }"}, {"sha": "5b89694c63fbf81a001b1145fabc5844d5b3d7a0", "filename": "src/lib/std.rc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/38c2363c459b481f40392f78b4db843172961fd4/src%2Flib%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/38c2363c459b481f40392f78b4db843172961fd4/src%2Flib%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fstd.rc?ref=38c2363c459b481f40392f78b4db843172961fd4", "patch": "@@ -83,7 +83,6 @@ mod sort;\n mod sha1;\n mod ebml;\n mod ufind;\n-mod ufindivec;\n mod extfmt;\n mod box;\n mod getopts;"}, {"sha": "79a2811653acbe101b4eef92c8cf64b63dbefa95", "filename": "src/lib/ufind.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/38c2363c459b481f40392f78b4db843172961fd4/src%2Flib%2Fufind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38c2363c459b481f40392f78b4db843172961fd4/src%2Flib%2Fufind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fufind.rs?ref=38c2363c459b481f40392f78b4db843172961fd4", "patch": "@@ -8,13 +8,13 @@ import option::some;\n // than the node itself.\n type node = option::t[uint];\n \n-type ufind = {nodes: @mutable [mutable node]};\n+type ufind = {mutable nodes: [mutable node]};\n \n-fn make() -> ufind { ret {nodes: @mutable ~[mutable]}; }\n+fn make() -> ufind { ret {mutable nodes: ~[mutable]}; }\n \n fn make_set(ufnd: &ufind) -> uint {\n-    let idx = ivec::len(*ufnd.nodes);\n-    *ufnd.nodes += ~[mutable none[uint]];\n+    let idx = ivec::len(ufnd.nodes);\n+    ufnd.nodes += ~[mutable none[uint]];\n     ret idx;\n }\n \n@@ -40,13 +40,13 @@ fn union(ufnd: &ufind, m: uint, n: uint) {\n     } else if (m_root > n_root) { ufnd.nodes.(m_root) = some[uint](n_root); }\n }\n \n-fn set_count(ufnd: &ufind) -> uint { ret ivec::len[node](*ufnd.nodes); }\n+fn set_count(ufnd: &ufind) -> uint { ret ivec::len[node](ufnd.nodes); }\n \n \n // Removes all sets with IDs greater than or equal to the given value.\n fn prune(ufnd: &ufind, n: uint) {\n     // TODO: Use \"slice\" once we get rid of \"mutable?\"\n \n-    let len = ivec::len[node](*ufnd.nodes);\n-    while len != n { ivec::pop[node](*ufnd.nodes); len -= 1u; }\n+    let len = ivec::len[node](ufnd.nodes);\n+    while len != n { ivec::pop[node](ufnd.nodes); len -= 1u; }\n }"}, {"sha": "79a2811653acbe101b4eef92c8cf64b63dbefa95", "filename": "src/lib/ufindivec.rs", "status": "removed", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/df402a5029a1e37d8fbf7f5a18d32efaf9ef751b/src%2Flib%2Fufindivec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df402a5029a1e37d8fbf7f5a18d32efaf9ef751b/src%2Flib%2Fufindivec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fufindivec.rs?ref=df402a5029a1e37d8fbf7f5a18d32efaf9ef751b", "patch": "@@ -1,52 +0,0 @@\n-\n-import option::none;\n-import option::some;\n-\n-\n-// A very naive implementation of union-find with unsigned integer nodes.\n-// Maintains the invariant that the root of a node is always equal to or less\n-// than the node itself.\n-type node = option::t[uint];\n-\n-type ufind = {mutable nodes: [mutable node]};\n-\n-fn make() -> ufind { ret {mutable nodes: ~[mutable]}; }\n-\n-fn make_set(ufnd: &ufind) -> uint {\n-    let idx = ivec::len(ufnd.nodes);\n-    ufnd.nodes += ~[mutable none[uint]];\n-    ret idx;\n-}\n-\n-\n-/// Creates sets as necessary to ensure that least `n` sets are present in the\n-/// data structure.\n-fn grow(ufnd: &ufind, n: uint) {\n-    while set_count(ufnd) < n { make_set(ufnd); }\n-}\n-\n-fn find(ufnd: &ufind, n: uint) -> uint {\n-    alt ufnd.nodes.(n) {\n-      none. { ret n; }\n-      some(m) { let m_ = m; be find(ufnd, m_); }\n-    }\n-}\n-\n-fn union(ufnd: &ufind, m: uint, n: uint) {\n-    let m_root = find(ufnd, m);\n-    let n_root = find(ufnd, n);\n-    if m_root < n_root {\n-        ufnd.nodes.(n_root) = some[uint](m_root);\n-    } else if (m_root > n_root) { ufnd.nodes.(m_root) = some[uint](n_root); }\n-}\n-\n-fn set_count(ufnd: &ufind) -> uint { ret ivec::len[node](ufnd.nodes); }\n-\n-\n-// Removes all sets with IDs greater than or equal to the given value.\n-fn prune(ufnd: &ufind, n: uint) {\n-    // TODO: Use \"slice\" once we get rid of \"mutable?\"\n-\n-    let len = ivec::len[node](ufnd.nodes);\n-    while len != n { ivec::pop[node](ufnd.nodes); len -= 1u; }\n-}"}]}