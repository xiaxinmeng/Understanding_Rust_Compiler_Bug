{"sha": "2a274e720fe8046d8db154ca2661701a519a0033", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhMjc0ZTcyMGZlODA0NmQ4ZGIxNTRjYTI2NjE3MDFhNTE5YTAwMzM=", "commit": {"author": {"name": "QuietMisdreavus", "email": "bryan@icesoldier.me", "date": "2016-09-26T21:02:21Z"}, "committer": {"name": "QuietMisdreavus", "email": "bryan@icesoldier.me", "date": "2016-09-26T21:02:21Z"}, "message": "rustdoc: format struct methods like rustfmt\n\n* ignore signatures 80 characters or shorter\n* otherwise, put arguments and return arrow on their own line, indented\n  to the opening parenthesis\n\nin doing this, most of a plain-text output has been written for rustdoc,\naccessible through \"alternate\" Display printing: \"{:#}\"", "tree": {"sha": "46c8e99e5a2463c517e29862c3df78727b9e05f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/46c8e99e5a2463c517e29862c3df78727b9e05f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2a274e720fe8046d8db154ca2661701a519a0033", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2a274e720fe8046d8db154ca2661701a519a0033", "html_url": "https://github.com/rust-lang/rust/commit/2a274e720fe8046d8db154ca2661701a519a0033", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2a274e720fe8046d8db154ca2661701a519a0033/comments", "author": null, "committer": null, "parents": [{"sha": "fccfc5392aa36a788abf329cb8c251241adc28d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/fccfc5392aa36a788abf329cb8c251241adc28d0", "html_url": "https://github.com/rust-lang/rust/commit/fccfc5392aa36a788abf329cb8c251241adc28d0"}], "stats": {"total": 420, "additions": 320, "deletions": 100}, "files": [{"sha": "84057fddf5a23ed7d588c5fdf273b26088f3134d", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 304, "deletions": 99, "changes": 403, "blob_url": "https://github.com/rust-lang/rust/blob/2a274e720fe8046d8db154ca2661701a519a0033/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a274e720fe8046d8db154ca2661701a519a0033/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=2a274e720fe8046d8db154ca2661701a519a0033", "patch": "@@ -42,7 +42,7 @@ pub struct UnsafetySpace(pub hir::Unsafety);\n #[derive(Copy, Clone)]\n pub struct ConstnessSpace(pub hir::Constness);\n /// Wrapper struct for properly emitting a method declaration.\n-pub struct Method<'a>(pub &'a clean::FnDecl);\n+pub struct Method<'a>(pub &'a clean::FnDecl, pub &'a str);\n /// Similar to VisSpace, but used for mutability\n #[derive(Copy, Clone)]\n pub struct MutableSpace(pub clean::Mutability);\n@@ -84,7 +84,7 @@ impl<'a, T: fmt::Display> fmt::Display for CommaSep<'a, T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         for (i, item) in self.0.iter().enumerate() {\n             if i != 0 { write!(f, \", \")?; }\n-            write!(f, \"{}\", item)?;\n+            fmt::Display::fmt(item, f)?;\n         }\n         Ok(())\n     }\n@@ -97,7 +97,7 @@ impl<'a> fmt::Display for TyParamBounds<'a> {\n             if i > 0 {\n                 f.write_str(\" + \")?;\n             }\n-            write!(f, \"{}\", *bound)?;\n+            fmt::Display::fmt(bound, f)?;\n         }\n         Ok(())\n     }\n@@ -106,35 +106,51 @@ impl<'a> fmt::Display for TyParamBounds<'a> {\n impl fmt::Display for clean::Generics {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         if self.lifetimes.is_empty() && self.type_params.is_empty() { return Ok(()) }\n-        f.write_str(\"&lt;\")?;\n+        if f.alternate() {\n+            f.write_str(\"<\")?;\n+        } else {\n+            f.write_str(\"&lt;\")?;\n+        }\n \n         for (i, life) in self.lifetimes.iter().enumerate() {\n             if i > 0 {\n-                f.write_str(\",&nbsp;\")?;\n+                f.write_str(\", \")?;\n             }\n             write!(f, \"{}\", *life)?;\n         }\n \n         if !self.type_params.is_empty() {\n             if !self.lifetimes.is_empty() {\n-                f.write_str(\",&nbsp;\")?;\n+                f.write_str(\", \")?;\n             }\n             for (i, tp) in self.type_params.iter().enumerate() {\n                 if i > 0 {\n-                    f.write_str(\",&nbsp;\")?\n+                    f.write_str(\", \")?\n                 }\n                 f.write_str(&tp.name)?;\n \n                 if !tp.bounds.is_empty() {\n-                    write!(f, \":&nbsp;{}\", TyParamBounds(&tp.bounds))?;\n+                    if f.alternate() {\n+                        write!(f, \": {:#}\", TyParamBounds(&tp.bounds))?;\n+                    } else {\n+                        write!(f, \":&nbsp;{}\", TyParamBounds(&tp.bounds))?;\n+                    }\n                 }\n \n                 if let Some(ref ty) = tp.default {\n-                    write!(f, \"&nbsp;=&nbsp;{}\", ty)?;\n+                    if f.alternate() {\n+                        write!(f, \" = {:#}\", ty)?;\n+                    } else {\n+                        write!(f, \"&nbsp;=&nbsp;{}\", ty)?;\n+                    }\n                 };\n             }\n         }\n-        f.write_str(\"&gt;\")?;\n+        if f.alternate() {\n+            f.write_str(\">\")?;\n+        } else {\n+            f.write_str(\"&gt;\")?;\n+        }\n         Ok(())\n     }\n }\n@@ -145,15 +161,23 @@ impl<'a> fmt::Display for WhereClause<'a> {\n         if gens.where_predicates.is_empty() {\n             return Ok(());\n         }\n-        f.write_str(\" <span class='where'>where \")?;\n+        if f.alternate() {\n+            f.write_str(\" \")?;\n+        } else {\n+            f.write_str(\" <span class='where'>where \")?;\n+        }\n         for (i, pred) in gens.where_predicates.iter().enumerate() {\n             if i > 0 {\n                 f.write_str(\", \")?;\n             }\n             match pred {\n                 &clean::WherePredicate::BoundPredicate { ref ty, ref bounds } => {\n                     let bounds = bounds;\n-                    write!(f, \"{}: {}\", ty, TyParamBounds(bounds))?;\n+                    if f.alternate() {\n+                        write!(f, \"{:#}: {:#}\", ty, TyParamBounds(bounds))?;\n+                    } else {\n+                        write!(f, \"{}: {}\", ty, TyParamBounds(bounds))?;\n+                    }\n                 }\n                 &clean::WherePredicate::RegionPredicate { ref lifetime,\n                                                           ref bounds } => {\n@@ -167,11 +191,17 @@ impl<'a> fmt::Display for WhereClause<'a> {\n                     }\n                 }\n                 &clean::WherePredicate::EqPredicate { ref lhs, ref rhs } => {\n-                    write!(f, \"{} == {}\", lhs, rhs)?;\n+                    if f.alternate() {\n+                        write!(f, \"{:#} == {:#}\", lhs, rhs)?;\n+                    } else {\n+                        write!(f, \"{} == {}\", lhs, rhs)?;\n+                    }\n                 }\n             }\n         }\n-        f.write_str(\"</span>\")?;\n+        if !f.alternate() {\n+            f.write_str(\"</span>\")?;\n+        }\n         Ok(())\n     }\n }\n@@ -186,16 +216,28 @@ impl fmt::Display for clean::Lifetime {\n impl fmt::Display for clean::PolyTrait {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         if !self.lifetimes.is_empty() {\n-            f.write_str(\"for&lt;\")?;\n+            if f.alternate() {\n+                f.write_str(\"for<\")?;\n+            } else {\n+                f.write_str(\"for&lt;\")?;\n+            }\n             for (i, lt) in self.lifetimes.iter().enumerate() {\n                 if i > 0 {\n                     f.write_str(\", \")?;\n                 }\n                 write!(f, \"{}\", lt)?;\n             }\n-            f.write_str(\"&gt; \")?;\n+            if f.alternate() {\n+                f.write_str(\"> \")?;\n+            } else {\n+                f.write_str(\"&gt; \")?;\n+            }\n+        }\n+        if f.alternate() {\n+            write!(f, \"{:#}\", self.trait_)\n+        } else {\n+            write!(f, \"{}\", self.trait_)\n         }\n-        write!(f, \"{}\", self.trait_)\n     }\n }\n \n@@ -210,7 +252,11 @@ impl fmt::Display for clean::TyParamBound {\n                     hir::TraitBoundModifier::None => \"\",\n                     hir::TraitBoundModifier::Maybe => \"?\",\n                 };\n-                write!(f, \"{}{}\", modifier_str, *ty)\n+                if f.alternate() {\n+                    write!(f, \"{}{:#}\", modifier_str, *ty)\n+                } else {\n+                    write!(f, \"{}{}\", modifier_str, *ty)\n+                }\n             }\n         }\n     }\n@@ -223,30 +269,46 @@ impl fmt::Display for clean::PathParameters {\n                 ref lifetimes, ref types, ref bindings\n             } => {\n                 if !lifetimes.is_empty() || !types.is_empty() || !bindings.is_empty() {\n-                    f.write_str(\"&lt;\")?;\n+                    if f.alternate() {\n+                        f.write_str(\"<\")?;\n+                    } else {\n+                        f.write_str(\"&lt;\")?;\n+                    }\n                     let mut comma = false;\n                     for lifetime in lifetimes {\n                         if comma {\n-                            f.write_str(\",&nbsp;\")?;\n+                            f.write_str(\", \")?;\n                         }\n                         comma = true;\n                         write!(f, \"{}\", *lifetime)?;\n                     }\n                     for ty in types {\n                         if comma {\n-                            f.write_str(\",&nbsp;\")?;\n+                            f.write_str(\", \")?;\n                         }\n                         comma = true;\n-                        write!(f, \"{}\", *ty)?;\n+                        if f.alternate() {\n+                            write!(f, \"{:#}\", *ty)?;\n+                        } else {\n+                            write!(f, \"{}\", *ty)?;\n+                        }\n                     }\n                     for binding in bindings {\n                         if comma {\n-                            f.write_str(\",&nbsp;\")?;\n+                            f.write_str(\", \")?;\n                         }\n                         comma = true;\n-                        write!(f, \"{}\", *binding)?;\n+                        if f.alternate() {\n+                            write!(f, \"{:#}\", *binding)?;\n+                        } else {\n+                            write!(f, \"{}\", *binding)?;\n+                        }\n+                    }\n+                    if f.alternate() {\n+                        f.write_str(\">\")?;\n+                    } else {\n+                        f.write_str(\"&gt;\")?;\n                     }\n-                    f.write_str(\"&gt;\")?;\n                 }\n             }\n             clean::PathParameters::Parenthesized { ref inputs, ref output } => {\n@@ -257,12 +319,19 @@ impl fmt::Display for clean::PathParameters {\n                         f.write_str(\", \")?;\n                     }\n                     comma = true;\n-                    write!(f, \"{}\", *ty)?;\n+                    if f.alternate() {\n+                        write!(f, \"{:#}\", *ty)?;\n+                    } else {\n+                        write!(f, \"{}\", *ty)?;\n+                    }\n                 }\n                 f.write_str(\")\")?;\n                 if let Some(ref ty) = *output {\n-                    f.write_str(\" -&gt; \")?;\n-                    write!(f, \"{}\", ty)?;\n+                    if f.alternate() {\n+                        write!(f, \" -> {:#}\", ty)?;\n+                    } else {\n+                        write!(f, \" -&gt; {}\", ty)?;\n+                    }\n                 }\n             }\n         }\n@@ -273,7 +342,11 @@ impl fmt::Display for clean::PathParameters {\n impl fmt::Display for clean::PathSegment {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.write_str(&self.name)?;\n-        write!(f, \"{}\", self.params)\n+        if f.alternate() {\n+            write!(f, \"{:#}\", self.params)\n+        } else {\n+            write!(f, \"{}\", self.params)\n+        }\n     }\n }\n \n@@ -287,7 +360,11 @@ impl fmt::Display for clean::Path {\n             if i > 0 {\n                 f.write_str(\"::\")?\n             }\n-            write!(f, \"{}\", seg)?;\n+            if f.alternate() {\n+                write!(f, \"{:#}\", seg)?;\n+            } else {\n+                write!(f, \"{}\", seg)?;\n+            }\n         }\n         Ok(())\n     }\n@@ -349,7 +426,7 @@ fn resolved_path(w: &mut fmt::Formatter, did: DefId, path: &clean::Path,\n         match rel_root {\n             Some(mut root) => {\n                 for seg in &path.segments[..amt] {\n-                    if \"super\" == seg.name || \"self\" == seg.name {\n+                    if \"super\" == seg.name || \"self\" == seg.name || w.alternate() {\n                         write!(w, \"{}::\", seg.name)?;\n                     } else {\n                         root.push_str(&seg.name);\n@@ -368,7 +445,11 @@ fn resolved_path(w: &mut fmt::Formatter, did: DefId, path: &clean::Path,\n             }\n         }\n     }\n-    write!(w, \"{}{}\", HRef::new(did, &last.name), last.params)?;\n+    if w.alternate() {\n+        write!(w, \"{:#}{:#}\", HRef::new(did, &last.name), last.params)?;\n+    } else {\n+        write!(w, \"{}{}\", HRef::new(did, &last.name), last.params)?;\n+    }\n     Ok(())\n }\n \n@@ -377,33 +458,35 @@ fn primitive_link(f: &mut fmt::Formatter,\n                   name: &str) -> fmt::Result {\n     let m = cache();\n     let mut needs_termination = false;\n-    match m.primitive_locations.get(&prim) {\n-        Some(&LOCAL_CRATE) => {\n-            let len = CURRENT_LOCATION_KEY.with(|s| s.borrow().len());\n-            let len = if len == 0 {0} else {len - 1};\n-            write!(f, \"<a class='primitive' href='{}primitive.{}.html'>\",\n-                   repeat(\"../\").take(len).collect::<String>(),\n-                   prim.to_url_str())?;\n-            needs_termination = true;\n-        }\n-        Some(&cnum) => {\n-            let loc = match m.extern_locations[&cnum] {\n-                (ref cname, render::Remote(ref s)) => Some((cname, s.to_string())),\n-                (ref cname, render::Local) => {\n-                    let len = CURRENT_LOCATION_KEY.with(|s| s.borrow().len());\n-                    Some((cname, repeat(\"../\").take(len).collect::<String>()))\n-                }\n-                (_, render::Unknown) => None,\n-            };\n-            if let Some((cname, root)) = loc {\n-                write!(f, \"<a class='primitive' href='{}{}/primitive.{}.html'>\",\n-                       root,\n-                       cname,\n+    if !f.alternate() {\n+        match m.primitive_locations.get(&prim) {\n+            Some(&LOCAL_CRATE) => {\n+                let len = CURRENT_LOCATION_KEY.with(|s| s.borrow().len());\n+                let len = if len == 0 {0} else {len - 1};\n+                write!(f, \"<a class='primitive' href='{}primitive.{}.html'>\",\n+                       repeat(\"../\").take(len).collect::<String>(),\n                        prim.to_url_str())?;\n                 needs_termination = true;\n             }\n+            Some(&cnum) => {\n+                let loc = match m.extern_locations[&cnum] {\n+                    (ref cname, render::Remote(ref s)) => Some((cname, s.to_string())),\n+                    (ref cname, render::Local) => {\n+                        let len = CURRENT_LOCATION_KEY.with(|s| s.borrow().len());\n+                        Some((cname, repeat(\"../\").take(len).collect::<String>()))\n+                    }\n+                    (_, render::Unknown) => None,\n+                };\n+                if let Some((cname, root)) = loc {\n+                    write!(f, \"<a class='primitive' href='{}{}/primitive.{}.html'>\",\n+                           root,\n+                           cname,\n+                           prim.to_url_str())?;\n+                    needs_termination = true;\n+                }\n+            }\n+            None => {}\n         }\n-        None => {}\n     }\n     write!(f, \"{}\", name)?;\n     if needs_termination {\n@@ -419,7 +502,7 @@ fn tybounds(w: &mut fmt::Formatter,\n         Some(ref params) => {\n             for param in params {\n                 write!(w, \" + \")?;\n-                write!(w, \"{}\", *param)?;\n+                fmt::Display::fmt(param, w)?;\n             }\n             Ok(())\n         }\n@@ -436,10 +519,12 @@ impl<'a> HRef<'a> {\n impl<'a> fmt::Display for HRef<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match href(self.did) {\n-            Some((url, shortty, fqp)) => {\n+            Some((url, shortty, fqp)) => if !f.alternate() {\n                 write!(f, \"<a class='{}' href='{}' title='{}'>{}</a>\",\n                        shortty, url, fqp.join(\"::\"), self.text)\n-            }\n+            } else {\n+                write!(f, \"{}\", self.text)\n+            },\n             _ => write!(f, \"{}\", self.text),\n         }\n     }\n@@ -459,49 +544,68 @@ impl fmt::Display for clean::Type {\n             clean::Infer => write!(f, \"_\"),\n             clean::Primitive(prim) => primitive_link(f, prim, prim.to_string()),\n             clean::BareFunction(ref decl) => {\n-                write!(f, \"{}{}fn{}{}\",\n-                       UnsafetySpace(decl.unsafety),\n-                       AbiSpace(decl.abi),\n-                       decl.generics,\n-                       decl.decl)\n+                if f.alternate() {\n+                    write!(f, \"{}{}fn{:#}{:#}\",\n+                           UnsafetySpace(decl.unsafety),\n+                           AbiSpace(decl.abi),\n+                           decl.generics,\n+                           decl.decl)\n+                } else {\n+                    write!(f, \"{}{}fn{}{}\",\n+                           UnsafetySpace(decl.unsafety),\n+                           AbiSpace(decl.abi),\n+                           decl.generics,\n+                           decl.decl)\n+                }\n             }\n             clean::Tuple(ref typs) => {\n                 match &typs[..] {\n                     &[] => primitive_link(f, PrimitiveType::Tuple, \"()\"),\n                     &[ref one] => {\n                         primitive_link(f, PrimitiveType::Tuple, \"(\")?;\n-                        write!(f, \"{},\", one)?;\n+                        //carry f.alternate() into this display w/o branching manually\n+                        fmt::Display::fmt(one, f)?;\n                         primitive_link(f, PrimitiveType::Tuple, \")\")\n                     }\n                     many => {\n                         primitive_link(f, PrimitiveType::Tuple, \"(\")?;\n-                        write!(f, \"{}\", CommaSep(&many))?;\n+                        fmt::Display::fmt(&CommaSep(&many), f)?;\n                         primitive_link(f, PrimitiveType::Tuple, \")\")\n                     }\n                 }\n             }\n             clean::Vector(ref t) => {\n                 primitive_link(f, PrimitiveType::Slice, &format!(\"[\"))?;\n-                write!(f, \"{}\", t)?;\n+                fmt::Display::fmt(t, f)?;\n                 primitive_link(f, PrimitiveType::Slice, &format!(\"]\"))\n             }\n             clean::FixedVector(ref t, ref s) => {\n                 primitive_link(f, PrimitiveType::Array, \"[\")?;\n-                write!(f, \"{}\", t)?;\n-                primitive_link(f, PrimitiveType::Array,\n-                               &format!(\"; {}]\", Escape(s)))\n+                fmt::Display::fmt(t, f)?;\n+                if f.alternate() {\n+                    primitive_link(f, PrimitiveType::Array,\n+                                   &format!(\"; {}]\", s))\n+                } else {\n+                    primitive_link(f, PrimitiveType::Array,\n+                                   &format!(\"; {}]\", Escape(s)))\n+                }\n             }\n             clean::Never => f.write_str(\"!\"),\n             clean::RawPointer(m, ref t) => {\n                 match **t {\n                     clean::Generic(_) | clean::ResolvedPath {is_generic: true, ..} => {\n-                        primitive_link(f, clean::PrimitiveType::RawPointer,\n-                                       &format!(\"*{}{}\", RawMutableSpace(m), t))\n+                        if f.alternate() {\n+                            primitive_link(f, clean::PrimitiveType::RawPointer,\n+                                           &format!(\"*{}{:#}\", RawMutableSpace(m), t))\n+                        } else {\n+                            primitive_link(f, clean::PrimitiveType::RawPointer,\n+                                           &format!(\"*{}{}\", RawMutableSpace(m), t))\n+                        }\n                     }\n                     _ => {\n                         primitive_link(f, clean::PrimitiveType::RawPointer,\n                                        &format!(\"*{}\", RawMutableSpace(m)))?;\n-                        write!(f, \"{}\", t)\n+                        fmt::Display::fmt(t, f)\n                     }\n                 }\n             }\n@@ -515,18 +619,31 @@ impl fmt::Display for clean::Type {\n                     clean::Vector(ref bt) => { // BorrowedRef{ ... Vector(T) } is &[T]\n                         match **bt {\n                             clean::Generic(_) =>\n-                                primitive_link(f, PrimitiveType::Slice,\n-                                    &format!(\"&amp;{}{}[{}]\", lt, m, **bt)),\n+                                if f.alternate() {\n+                                    primitive_link(f, PrimitiveType::Slice,\n+                                        &format!(\"&amp;{}{}[{:#}]\", lt, m, **bt))\n+                                } else {\n+                                    primitive_link(f, PrimitiveType::Slice,\n+                                        &format!(\"&amp;{}{}[{}]\", lt, m, **bt))\n+                                },\n                             _ => {\n                                 primitive_link(f, PrimitiveType::Slice,\n                                                &format!(\"&amp;{}{}[\", lt, m))?;\n-                                write!(f, \"{}\", **bt)?;\n+                                if f.alternate() {\n+                                    write!(f, \"{:#}\", **bt)?;\n+                                } else {\n+                                    write!(f, \"{}\", **bt)?;\n+                                }\n                                 primitive_link(f, PrimitiveType::Slice, \"]\")\n                             }\n                         }\n                     }\n                     _ => {\n-                        write!(f, \"&amp;{}{}{}\", lt, m, **ty)\n+                        if f.alternate() {\n+                            write!(f, \"&amp;{}{}{:#}\", lt, m, **ty)\n+                        } else {\n+                            write!(f, \"&amp;{}{}{}\", lt, m, **ty)\n+                        }\n                     }\n                 }\n             }\n@@ -535,7 +652,11 @@ impl fmt::Display for clean::Type {\n                     if i != 0 {\n                         write!(f, \" + \")?;\n                     }\n-                    write!(f, \"{}\", *bound)?;\n+                    if f.alternate() {\n+                        write!(f, \"{:#}\", *bound)?;\n+                    } else {\n+                        write!(f, \"{}\", *bound)?;\n+                    }\n                 }\n                 Ok(())\n             }\n@@ -545,7 +666,11 @@ impl fmt::Display for clean::Type {\n                     if i != 0 {\n                         write!(f, \" + \")?;\n                     }\n-                    write!(f, \"{}\", *bound)?;\n+                    if f.alternate() {\n+                        write!(f, \"{:#}\", *bound)?;\n+                    } else {\n+                        write!(f, \"{}\", *bound)?;\n+                    }\n                 }\n                 Ok(())\n             }\n@@ -564,7 +689,11 @@ impl fmt::Display for clean::Type {\n                 ref self_type,\n                 trait_: box clean::ResolvedPath { did, ref typarams, .. },\n             } => {\n-                write!(f, \"{}::\", self_type)?;\n+                if f.alternate() {\n+                    write!(f, \"{:#}::\", self_type)?;\n+                } else {\n+                    write!(f, \"{}::\", self_type)?;\n+                }\n                 let path = clean::Path::singleton(name.clone());\n                 resolved_path(f, did, &path, false)?;\n \n@@ -573,7 +702,11 @@ impl fmt::Display for clean::Type {\n                 Ok(())\n             }\n             clean::QPath { ref name, ref self_type, ref trait_ } => {\n-                write!(f, \"&lt;{} as {}&gt;::{}\", self_type, trait_, name)\n+                if f.alternate() {\n+                    write!(f, \"<{:#} as {:#}>::{}\", self_type, trait_, name)\n+                } else {\n+                    write!(f, \"&lt;{} as {}&gt;::{}\", self_type, trait_, name)\n+                }\n             }\n             clean::Unique(..) => {\n                 panic!(\"should have been cleaned\")\n@@ -583,24 +716,30 @@ impl fmt::Display for clean::Type {\n }\n \n fn fmt_impl(i: &clean::Impl, f: &mut fmt::Formatter, link_trait: bool) -> fmt::Result {\n-    write!(f, \"impl{} \", i.generics)?;\n+    if f.alternate() {\n+        write!(f, \"impl{:#} \", i.generics)?;\n+    } else {\n+        write!(f, \"impl{} \", i.generics)?;\n+    }\n     if let Some(ref ty) = i.trait_ {\n         write!(f, \"{}\",\n                if i.polarity == Some(clean::ImplPolarity::Negative) { \"!\" } else { \"\" })?;\n         if link_trait {\n-            write!(f, \"{}\", *ty)?;\n+            fmt::Display::fmt(ty, f)?;\n         } else {\n             match *ty {\n                 clean::ResolvedPath{ typarams: None, ref path, is_generic: false, .. } => {\n                     let last = path.segments.last().unwrap();\n-                    write!(f, \"{}{}\", last.name, last.params)?;\n+                    fmt::Display::fmt(&last.name, f)?;\n+                    fmt::Display::fmt(&last.params, f)?;\n                 }\n                 _ => unreachable!(),\n             }\n         }\n         write!(f, \" for \")?;\n     }\n-    write!(f, \"{}{}\", i.for_, WhereClause(&i.generics))?;\n+    fmt::Display::fmt(&i.for_, f)?;\n+    fmt::Display::fmt(&WhereClause(&i.generics), f)?;\n     Ok(())\n }\n \n@@ -622,7 +761,11 @@ impl fmt::Display for clean::Arguments {\n             if !input.name.is_empty() {\n                 write!(f, \"{}: \", input.name)?;\n             }\n-            write!(f, \"{}\", input.type_)?;\n+            if f.alternate() {\n+                write!(f, \"{:#}\", input.type_)?;\n+            } else {\n+                write!(f, \"{}\", input.type_)?;\n+            }\n             if i + 1 < self.values.len() { write!(f, \",\")?; }\n         }\n         if !self.values.is_empty() {\n@@ -636,6 +779,7 @@ impl fmt::Display for clean::FunctionRetTy {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             clean::Return(clean::Tuple(ref tys)) if tys.is_empty() => Ok(()),\n+            clean::Return(ref ty) if f.alternate() => write!(f, \" -> {:#}\", ty),\n             clean::Return(ref ty) => write!(f, \" -&gt; {}\", ty),\n             clean::DefaultReturn => Ok(()),\n         }\n@@ -645,44 +789,100 @@ impl fmt::Display for clean::FunctionRetTy {\n impl fmt::Display for clean::FnDecl {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         if self.variadic {\n-            write!(f, \"({args}, ...){arrow}\", args = self.inputs, arrow = self.output)\n+            if f.alternate() {\n+                write!(f, \"({args:#}, ...){arrow:#}\", args = self.inputs, arrow = self.output)\n+            } else {\n+                write!(f, \"({args}, ...){arrow}\", args = self.inputs, arrow = self.output)\n+            }\n         } else {\n-            write!(f, \"({args}){arrow}\", args = self.inputs, arrow = self.output)\n+            if f.alternate() {\n+                write!(f, \"({args:#}){arrow:#}\", args = self.inputs, arrow = self.output)\n+            } else {\n+                write!(f, \"({args}){arrow}\", args = self.inputs, arrow = self.output)\n+            }\n         }\n     }\n }\n \n impl<'a> fmt::Display for Method<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let decl = self.0;\n+        let indent = self.1;\n+        let amp = if f.alternate() { \"&\" } else { \"&amp;\" };\n         let mut args = String::new();\n+        let mut args_plain = String::new();\n         for (i, input) in decl.inputs.values.iter().enumerate() {\n             if let Some(selfty) = input.to_self() {\n                 match selfty {\n-                    clean::SelfValue => args.push_str(\"self\"),\n+                    clean::SelfValue => {\n+                        args.push_str(\"self\");\n+                        args_plain.push_str(\"self\");\n+                    }\n                     clean::SelfBorrowed(Some(ref lt), mtbl) => {\n-                        args.push_str(&format!(\"&amp;{} {}self\", *lt, MutableSpace(mtbl)));\n+                        let arg = format!(\"{}{} {}self\", amp, *lt, MutableSpace(mtbl));\n+                        args.push_str(&arg);\n+                        args_plain.push_str(&arg);\n                     }\n                     clean::SelfBorrowed(None, mtbl) => {\n-                        args.push_str(&format!(\"&amp;{}self\", MutableSpace(mtbl)));\n+                        let arg = format!(\"{}{}self\", amp, MutableSpace(mtbl));\n+                        args.push_str(&arg);\n+                        args_plain.push_str(&arg);\n                     }\n                     clean::SelfExplicit(ref typ) => {\n-                        args.push_str(&format!(\"self: {}\", *typ));\n+                        if f.alternate() {\n+                            args.push_str(&format!(\"self: {:#}\", *typ));\n+                        } else {\n+                            args.push_str(&format!(\"self: {}\", *typ));\n+                        }\n+                        args_plain.push_str(&format!(\"self: {:#}\", *typ));\n                     }\n                 }\n             } else {\n-                args.push_str(\"\\n    \");\n+                if i > 0 {\n+                    args.push_str(\"\\n \");\n+                    args_plain.push_str(\"\\n \");\n+                }\n                 if !input.name.is_empty() {\n                     args.push_str(&format!(\"{}: \", input.name));\n+                    args_plain.push_str(&format!(\"{}: \", input.name));\n                 }\n-                args.push_str(&format!(\"{}\", input.type_));\n+                if f.alternate() {\n+                    args.push_str(&format!(\"{:#}\", input.type_));\n+                } else {\n+                    args.push_str(&format!(\"{}\", input.type_));\n+                }\n+                args_plain.push_str(&format!(\"{:#}\", input.type_));\n+            }\n+            if i + 1 < decl.inputs.values.len() {\n+                args.push_str(\",\");\n+                args_plain.push_str(\",\");\n             }\n-            if i + 1 < decl.inputs.values.len() { args.push_str(\",\"); }\n         }\n-        if let Some(None) = decl.inputs.values.iter().last().map(|val| val.to_self()) {\n-            args.push_str(\"\\n\");\n+\n+        let arrow_plain = format!(\"{:#}\", decl.output);\n+        let arrow = if f.alternate() {\n+            format!(\"{:#}\", decl.output)\n+        } else {\n+            format!(\"{}\", decl.output)\n+        };\n+\n+        let mut output: String;\n+        let plain: String;\n+        if arrow.is_empty() {\n+            output = format!(\"({})\", args);\n+            plain = format!(\"({})\", args_plain);\n+        } else {\n+            output = format!(\"({args})\\n{arrow}\", args = args, arrow = arrow);\n+            plain = format!(\"({args})\\n{arrow}\", args = args_plain, arrow = arrow_plain);\n+        }\n+\n+        if plain.replace(\"\\n\", \"\").len() > 80 {\n+            let pad = format!(\"\\n{}\", indent);\n+            output = output.replace(\"\\n\", &pad);\n+        } else {\n+            output = output.replace(\"\\n\", \"\");\n         }\n-        write!(f, \"({args}){arrow}\", args = args, arrow = decl.output)\n+        write!(f, \"{}\", output)\n     }\n }\n \n@@ -776,7 +976,11 @@ impl fmt::Display for clean::ViewListIdent {\n \n impl fmt::Display for clean::TypeBinding {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}={}\", self.name, self.ty)\n+        if f.alternate() {\n+            write!(f, \"{}={:#}\", self.name, self.ty)\n+        } else {\n+            write!(f, \"{}={}\", self.name, self.ty)\n+        }\n     }\n }\n \n@@ -800,10 +1004,11 @@ impl fmt::Display for RawMutableSpace {\n \n impl fmt::Display for AbiSpace {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let quot = if f.alternate() { \"\\\"\" } else { \"&quot;\" };\n         match self.0 {\n             Abi::Rust => Ok(()),\n             Abi::C => write!(f, \"extern \"),\n-            abi => write!(f, \"extern &quot;{}&quot; \", abi.name()),\n+            abi => write!(f, \"extern {0}{1}{0} \", quot, abi.name()),\n         }\n     }\n }"}, {"sha": "20eda9f14804634cd90991c017789cd77ae38c42", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2a274e720fe8046d8db154ca2661701a519a0033/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a274e720fe8046d8db154ca2661701a519a0033/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=2a274e720fe8046d8db154ca2661701a519a0033", "patch": "@@ -1975,6 +1975,14 @@ fn item_function(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n         UnstableFeatures::Allow => f.constness,\n         _ => hir::Constness::NotConst\n     };\n+    let prefix = format!(\"{vis}{constness}{unsafety}{abi:#}fn {name}{generics:#}\",\n+                         vis = VisSpace(&it.visibility),\n+                         constness = ConstnessSpace(vis_constness),\n+                         unsafety = UnsafetySpace(f.unsafety),\n+                         abi = AbiSpace(f.abi),\n+                         name = it.name.as_ref().unwrap(),\n+                         generics = f.generics)?;\n+    let indent = repeat(\"&nbsp;\").take(prefix.len()).collect::<String>();\n     write!(w, \"<pre class='rust fn'>{vis}{constness}{unsafety}{abi}fn \\\n                {name}{generics}{decl}{where_clause}</pre>\",\n            vis = VisSpace(&it.visibility),\n@@ -2254,6 +2262,13 @@ fn render_assoc_item(w: &mut fmt::Formatter,\n             UnstableFeatures::Allow => constness,\n             _ => hir::Constness::NotConst\n         };\n+        let prefix = format!(\"{}{}{:#}fn {}{:#}\",\n+                             ConstnessSpace(vis_constness),\n+                             UnsafetySpace(unsafety),\n+                             AbiSpace(abi),\n+                             name,\n+                             *g);\n+        let indent = repeat(\"&nbsp;\").take(prefix.len()).collect::<String>();\n         write!(w, \"{}{}{}fn <a href='{href}' class='fnname'>{name}</a>\\\n                    {generics}{decl}{where_clause}\",\n                ConstnessSpace(vis_constness),\n@@ -2262,7 +2277,7 @@ fn render_assoc_item(w: &mut fmt::Formatter,\n                href = href,\n                name = name,\n                generics = *g,\n-               decl = Method(d),\n+               decl = Method(d, &indent),\n                where_clause = WhereClause(g))\n     }\n     match item.inner {"}]}