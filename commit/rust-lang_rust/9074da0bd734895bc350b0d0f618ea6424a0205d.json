{"sha": "9074da0bd734895bc350b0d0f618ea6424a0205d", "node_id": "C_kwDOAAsO6NoAKDkwNzRkYTBiZDczNDg5NWJjMzUwYjBkMGY2MThlYTY0MjRhMDIwNWQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-09T17:15:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-09T17:15:23Z"}, "message": "Auto merge of #10359 - mladedav:dm/private/is-empty, r=llogiq\n\nInclude async functions in the len_without_is_empty\n\nfixes #7232\n\nChanges done to the functionality:\n\nAllowing different error types for the functions was disallowed. So the following was linted before but is not after this change\n```\nimpl Foo {\n    pub len(&self) -> Result<usize, Error1> { todo!(); }\n    pub is_empty(&self) -> Result<bool, Error2> { todo!(); }\n}\n```\n\n---\n\nchangelog: Enhancement: [`len_without_is_empty`]: Now also detects `async` functions\n[#10359](https://github.com/rust-lang/rust-clippy/pull/10359)\n<!-- changelog_checked -->", "tree": {"sha": "6bdadc45b81f06075f4d0f3253bff53f73c3b224", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6bdadc45b81f06075f4d0f3253bff53f73c3b224"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9074da0bd734895bc350b0d0f618ea6424a0205d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9074da0bd734895bc350b0d0f618ea6424a0205d", "html_url": "https://github.com/rust-lang/rust/commit/9074da0bd734895bc350b0d0f618ea6424a0205d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9074da0bd734895bc350b0d0f618ea6424a0205d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a45f71265cc8781c35ca9aa60f6e284d4d121996", "url": "https://api.github.com/repos/rust-lang/rust/commits/a45f71265cc8781c35ca9aa60f6e284d4d121996", "html_url": "https://github.com/rust-lang/rust/commit/a45f71265cc8781c35ca9aa60f6e284d4d121996"}, {"sha": "536905278ff2a4fb057193e3592f7f5dc64eb2d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/536905278ff2a4fb057193e3592f7f5dc64eb2d7", "html_url": "https://github.com/rust-lang/rust/commit/536905278ff2a4fb057193e3592f7f5dc64eb2d7"}], "stats": {"total": 222, "additions": 202, "deletions": 20}, "files": [{"sha": "0805b4b19796ed50c7cdb1499ed221644c58caef", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 91, "deletions": 19, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/9074da0bd734895bc350b0d0f618ea6424a0205d/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9074da0bd734895bc350b0d0f618ea6424a0205d/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=9074da0bd734895bc350b0d0f618ea6424a0205d", "patch": "@@ -6,8 +6,9 @@ use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n use rustc_hir::def_id::DefIdSet;\n use rustc_hir::{\n-    def_id::DefId, AssocItemKind, BinOpKind, Expr, ExprKind, FnRetTy, ImplItem, ImplItemKind, ImplicitSelfKind, Item,\n-    ItemKind, Mutability, Node, TraitItemRef, TyKind,\n+    def::Res, def_id::DefId, lang_items::LangItem, AssocItemKind, BinOpKind, Expr, ExprKind, FnRetTy, GenericArg,\n+    GenericBound, ImplItem, ImplItemKind, ImplicitSelfKind, Item, ItemKind, Mutability, Node, PathSegment, PrimTy,\n+    QPath, TraitItemRef, TyKind, TypeBindingKind,\n };\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::{self, AssocKind, FnSig, Ty};\n@@ -250,33 +251,98 @@ fn check_trait_items(cx: &LateContext<'_>, visited_trait: &Item<'_>, trait_items\n }\n \n #[derive(Debug, Clone, Copy)]\n-enum LenOutput<'tcx> {\n+enum LenOutput {\n     Integral,\n     Option(DefId),\n-    Result(DefId, Ty<'tcx>),\n+    Result(DefId),\n }\n-fn parse_len_output<'tcx>(cx: &LateContext<'_>, sig: FnSig<'tcx>) -> Option<LenOutput<'tcx>> {\n+\n+fn extract_future_output<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<&'tcx PathSegment<'tcx>> {\n+    if let ty::Alias(_, alias_ty) = ty.kind() &&\n+        let Some(Node::Item(item)) = cx.tcx.hir().get_if_local(alias_ty.def_id) &&\n+        let Item { kind: ItemKind::OpaqueTy(opaque), .. } = item &&\n+        opaque.bounds.len() == 1 &&\n+        let GenericBound::LangItemTrait(LangItem::Future, _, _, generic_args) = &opaque.bounds[0] &&\n+        generic_args.bindings.len() == 1 &&\n+        let TypeBindingKind::Equality {\n+            term: rustc_hir::Term::Ty(rustc_hir::Ty {kind: TyKind::Path(QPath::Resolved(_, path)), .. }),\n+        } = &generic_args.bindings[0].kind &&\n+        path.segments.len() == 1 {\n+            return Some(&path.segments[0]);\n+        }\n+\n+    None\n+}\n+\n+fn is_first_generic_integral<'tcx>(segment: &'tcx PathSegment<'tcx>) -> bool {\n+    if let Some(generic_args) = segment.args {\n+        if generic_args.args.is_empty() {\n+            return false;\n+        }\n+        let arg = &generic_args.args[0];\n+        if let GenericArg::Type(rustc_hir::Ty {\n+            kind: TyKind::Path(QPath::Resolved(_, path)),\n+            ..\n+        }) = arg\n+        {\n+            let segments = &path.segments;\n+            let segment = &segments[0];\n+            let res = &segment.res;\n+            if matches!(res, Res::PrimTy(PrimTy::Uint(_))) || matches!(res, Res::PrimTy(PrimTy::Int(_))) {\n+                return true;\n+            }\n+        }\n+    }\n+\n+    false\n+}\n+\n+fn parse_len_output<'tcx>(cx: &LateContext<'tcx>, sig: FnSig<'tcx>) -> Option<LenOutput> {\n+    if let Some(segment) = extract_future_output(cx, sig.output()) {\n+        let res = segment.res;\n+\n+        if matches!(res, Res::PrimTy(PrimTy::Uint(_))) || matches!(res, Res::PrimTy(PrimTy::Int(_))) {\n+            return Some(LenOutput::Integral);\n+        }\n+\n+        if let Res::Def(_, def_id) = res {\n+            if cx.tcx.is_diagnostic_item(sym::Option, def_id) && is_first_generic_integral(segment) {\n+                return Some(LenOutput::Option(def_id));\n+            } else if cx.tcx.is_diagnostic_item(sym::Result, def_id) && is_first_generic_integral(segment) {\n+                return Some(LenOutput::Result(def_id));\n+            }\n+        }\n+\n+        return None;\n+    }\n+\n     match *sig.output().kind() {\n         ty::Int(_) | ty::Uint(_) => Some(LenOutput::Integral),\n         ty::Adt(adt, subs) if cx.tcx.is_diagnostic_item(sym::Option, adt.did()) => {\n             subs.type_at(0).is_integral().then(|| LenOutput::Option(adt.did()))\n         },\n-        ty::Adt(adt, subs) if cx.tcx.is_diagnostic_item(sym::Result, adt.did()) => subs\n-            .type_at(0)\n-            .is_integral()\n-            .then(|| LenOutput::Result(adt.did(), subs.type_at(1))),\n+        ty::Adt(adt, subs) if cx.tcx.is_diagnostic_item(sym::Result, adt.did()) => {\n+            subs.type_at(0).is_integral().then(|| LenOutput::Result(adt.did()))\n+        },\n         _ => None,\n     }\n }\n \n-impl<'tcx> LenOutput<'tcx> {\n-    fn matches_is_empty_output(self, ty: Ty<'tcx>) -> bool {\n+impl LenOutput {\n+    fn matches_is_empty_output<'tcx>(self, cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n+        if let Some(segment) = extract_future_output(cx, ty) {\n+            return match (self, segment.res) {\n+                (_, Res::PrimTy(PrimTy::Bool)) => true,\n+                (Self::Option(_), Res::Def(_, def_id)) if cx.tcx.is_diagnostic_item(sym::Option, def_id) => true,\n+                (Self::Result(_), Res::Def(_, def_id)) if cx.tcx.is_diagnostic_item(sym::Result, def_id) => true,\n+                _ => false,\n+            };\n+        }\n+\n         match (self, ty.kind()) {\n             (_, &ty::Bool) => true,\n             (Self::Option(id), &ty::Adt(adt, subs)) if id == adt.did() => subs.type_at(0).is_bool(),\n-            (Self::Result(id, err_ty), &ty::Adt(adt, subs)) if id == adt.did() => {\n-                subs.type_at(0).is_bool() && subs.type_at(1) == err_ty\n-            },\n+            (Self::Result(id), &ty::Adt(adt, subs)) if id == adt.did() => subs.type_at(0).is_bool(),\n             _ => false,\n         }\n     }\n@@ -300,9 +366,14 @@ impl<'tcx> LenOutput<'tcx> {\n }\n \n /// Checks if the given signature matches the expectations for `is_empty`\n-fn check_is_empty_sig<'tcx>(sig: FnSig<'tcx>, self_kind: ImplicitSelfKind, len_output: LenOutput<'tcx>) -> bool {\n+fn check_is_empty_sig<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    sig: FnSig<'tcx>,\n+    self_kind: ImplicitSelfKind,\n+    len_output: LenOutput,\n+) -> bool {\n     match &**sig.inputs_and_output {\n-        [arg, res] if len_output.matches_is_empty_output(*res) => {\n+        [arg, res] if len_output.matches_is_empty_output(cx, *res) => {\n             matches!(\n                 (arg.kind(), self_kind),\n                 (ty::Ref(_, _, Mutability::Not), ImplicitSelfKind::ImmRef)\n@@ -314,11 +385,11 @@ fn check_is_empty_sig<'tcx>(sig: FnSig<'tcx>, self_kind: ImplicitSelfKind, len_o\n }\n \n /// Checks if the given type has an `is_empty` method with the appropriate signature.\n-fn check_for_is_empty<'tcx>(\n-    cx: &LateContext<'tcx>,\n+fn check_for_is_empty(\n+    cx: &LateContext<'_>,\n     span: Span,\n     self_kind: ImplicitSelfKind,\n-    output: LenOutput<'tcx>,\n+    output: LenOutput,\n     impl_ty: DefId,\n     item_name: Symbol,\n     item_kind: &str,\n@@ -351,6 +422,7 @@ fn check_for_is_empty<'tcx>(\n         Some(is_empty)\n             if !(is_empty.fn_has_self_parameter\n                 && check_is_empty_sig(\n+                    cx,\n                     cx.tcx.fn_sig(is_empty.def_id).subst_identity().skip_binder(),\n                     self_kind,\n                     output,"}, {"sha": "52aabefaed20a0488a0677e7228f674d285bac12", "filename": "tests/ui/len_without_is_empty.rs", "status": "modified", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/9074da0bd734895bc350b0d0f618ea6424a0205d/tests%2Fui%2Flen_without_is_empty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9074da0bd734895bc350b0d0f618ea6424a0205d/tests%2Fui%2Flen_without_is_empty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flen_without_is_empty.rs?ref=9074da0bd734895bc350b0d0f618ea6424a0205d", "patch": "@@ -282,6 +282,87 @@ impl AsyncLen {\n     }\n }\n \n+// issue #7232\n+pub struct AsyncLenWithoutIsEmpty;\n+impl AsyncLenWithoutIsEmpty {\n+    pub async fn async_task(&self) -> bool {\n+        true\n+    }\n+\n+    pub async fn len(&self) -> usize {\n+        usize::from(!self.async_task().await)\n+    }\n+}\n+\n+// issue #7232\n+pub struct AsyncOptionLenWithoutIsEmpty;\n+impl AsyncOptionLenWithoutIsEmpty {\n+    async fn async_task(&self) -> bool {\n+        true\n+    }\n+\n+    pub async fn len(&self) -> Option<usize> {\n+        None\n+    }\n+}\n+\n+// issue #7232\n+pub struct AsyncOptionLenNonIntegral;\n+impl AsyncOptionLenNonIntegral {\n+    // don't lint\n+    pub async fn len(&self) -> Option<String> {\n+        None\n+    }\n+}\n+\n+// issue #7232\n+pub struct AsyncResultLenWithoutIsEmpty;\n+impl AsyncResultLenWithoutIsEmpty {\n+    async fn async_task(&self) -> bool {\n+        true\n+    }\n+\n+    pub async fn len(&self) -> Result<usize, ()> {\n+        Err(())\n+    }\n+}\n+\n+// issue #7232\n+pub struct AsyncOptionLen;\n+impl AsyncOptionLen {\n+    async fn async_task(&self) -> bool {\n+        true\n+    }\n+\n+    pub async fn len(&self) -> Result<usize, ()> {\n+        Err(())\n+    }\n+\n+    pub async fn is_empty(&self) -> bool {\n+        true\n+    }\n+}\n+\n+pub struct AsyncLenSyncIsEmpty;\n+impl AsyncLenSyncIsEmpty {\n+    pub async fn len(&self) -> u32 {\n+        0\n+    }\n+\n+    pub fn is_empty(&self) -> bool {\n+        true\n+    }\n+}\n+\n+// issue #9520\n+pub struct NonStandardLen;\n+impl NonStandardLen {\n+    // don't lint\n+    pub fn len(&self, something: usize) -> usize {\n+        something\n+    }\n+}\n+\n // issue #9520\n pub struct NonStandardLenAndIsEmptySignature;\n impl NonStandardLenAndIsEmptySignature {\n@@ -328,4 +409,15 @@ impl NonStandardSignatureWithGenerics {\n     }\n }\n \n+pub struct DifferingErrors;\n+impl DifferingErrors {\n+    pub fn len(&self) -> Result<usize, u8> {\n+        Ok(0)\n+    }\n+\n+    pub fn is_empty(&self) -> Result<bool, u16> {\n+        Ok(true)\n+    }\n+}\n+\n fn main() {}"}, {"sha": "1bce1734b81afd69c4768facb76465f453e1ef70", "filename": "tests/ui/len_without_is_empty.stderr", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9074da0bd734895bc350b0d0f618ea6424a0205d/tests%2Fui%2Flen_without_is_empty.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9074da0bd734895bc350b0d0f618ea6424a0205d/tests%2Fui%2Flen_without_is_empty.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flen_without_is_empty.stderr?ref=9074da0bd734895bc350b0d0f618ea6424a0205d", "patch": "@@ -119,5 +119,23 @@ LL |     pub fn len(&self) -> Result<usize, ()> {\n    |\n    = help: use a custom `Error` type instead\n \n-error: aborting due to 12 previous errors\n+error: struct `AsyncLenWithoutIsEmpty` has a public `len` method, but no `is_empty` method\n+  --> $DIR/len_without_is_empty.rs:292:5\n+   |\n+LL |     pub async fn len(&self) -> usize {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: struct `AsyncOptionLenWithoutIsEmpty` has a public `len` method, but no `is_empty` method\n+  --> $DIR/len_without_is_empty.rs:304:5\n+   |\n+LL |     pub async fn len(&self) -> Option<usize> {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: struct `AsyncResultLenWithoutIsEmpty` has a public `len` method, but no `is_empty` method\n+  --> $DIR/len_without_is_empty.rs:325:5\n+   |\n+LL |     pub async fn len(&self) -> Result<usize, ()> {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 15 previous errors\n "}]}