{"sha": "eda3fa9eb5e0b2eb3cee55a6cc0a23a207b56059", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkYTNmYTllYjVlMGIyZWIzY2VlNTVhNmNjMGEyM2EyMDdiNTYwNTk=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2019-12-25T00:09:47Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2019-12-26T11:11:11Z"}, "message": "Move `eval_body_using_ecx` to the only module it is used in", "tree": {"sha": "182e1dff74f2dd7087e239646fffc02eba87f3e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/182e1dff74f2dd7087e239646fffc02eba87f3e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eda3fa9eb5e0b2eb3cee55a6cc0a23a207b56059", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eda3fa9eb5e0b2eb3cee55a6cc0a23a207b56059", "html_url": "https://github.com/rust-lang/rust/commit/eda3fa9eb5e0b2eb3cee55a6cc0a23a207b56059", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eda3fa9eb5e0b2eb3cee55a6cc0a23a207b56059/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a82458e70296eb55f9c7af7a9c892f8b5477684", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a82458e70296eb55f9c7af7a9c892f8b5477684", "html_url": "https://github.com/rust-lang/rust/commit/9a82458e70296eb55f9c7af7a9c892f8b5477684"}], "stats": {"total": 103, "additions": 53, "deletions": 50}, "files": [{"sha": "aefc8a3ff0ffcf194fa3bc841a38d47a304c952b", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 3, "deletions": 48, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/eda3fa9eb5e0b2eb3cee55a6cc0a23a207b56059/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda3fa9eb5e0b2eb3cee55a6cc0a23a207b56059/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=eda3fa9eb5e0b2eb3cee55a6cc0a23a207b56059", "patch": "@@ -6,18 +6,16 @@ use std::fmt;\n use std::hash::Hash;\n \n use rustc::mir;\n-use rustc::mir::interpret::ScalarMaybeUndef;\n-use rustc::ty::layout::{self, LayoutOf, VariantIdx};\n-use rustc::ty::{self, subst::Subst, TyCtxt};\n+use rustc::ty::layout::{self, VariantIdx};\n+use rustc::ty::{self, TyCtxt};\n \n use syntax::{\n     source_map::{Span, DUMMY_SP},\n     symbol::Symbol,\n };\n \n use crate::interpret::{\n-    intern_const_alloc_recursive, Allocation, ConstValue, GlobalId, ImmTy, Immediate, InterpCx,\n-    InterpResult, MPlaceTy, MemoryKind, OpTy, Scalar, StackPopCleanup,\n+    intern_const_alloc_recursive, Allocation, ConstValue, ImmTy, Immediate, InterpCx, OpTy, Scalar,\n };\n \n mod error;\n@@ -121,49 +119,6 @@ fn op_to_const<'tcx>(\n     ecx.tcx.mk_const(ty::Const { val: ty::ConstKind::Value(val), ty: op.layout.ty })\n }\n \n-// Returns a pointer to where the result lives\n-fn eval_body_using_ecx<'mir, 'tcx>(\n-    ecx: &mut CompileTimeEvalContext<'mir, 'tcx>,\n-    cid: GlobalId<'tcx>,\n-    body: &'mir mir::Body<'tcx>,\n-) -> InterpResult<'tcx, MPlaceTy<'tcx>> {\n-    debug!(\"eval_body_using_ecx: {:?}, {:?}\", cid, ecx.param_env);\n-    let tcx = ecx.tcx.tcx;\n-    let layout = ecx.layout_of(body.return_ty().subst(tcx, cid.instance.substs))?;\n-    assert!(!layout.is_unsized());\n-    let ret = ecx.allocate(layout, MemoryKind::Stack);\n-\n-    let name = ty::tls::with(|tcx| tcx.def_path_str(cid.instance.def_id()));\n-    let prom = cid.promoted.map_or(String::new(), |p| format!(\"::promoted[{:?}]\", p));\n-    trace!(\"eval_body_using_ecx: pushing stack frame for global: {}{}\", name, prom);\n-\n-    // Assert all args (if any) are zero-sized types; `eval_body_using_ecx` doesn't\n-    // make sense if the body is expecting nontrivial arguments.\n-    // (The alternative would be to use `eval_fn_call` with an args slice.)\n-    for arg in body.args_iter() {\n-        let decl = body.local_decls.get(arg).expect(\"arg missing from local_decls\");\n-        let layout = ecx.layout_of(decl.ty.subst(tcx, cid.instance.substs))?;\n-        assert!(layout.is_zst())\n-    }\n-\n-    ecx.push_stack_frame(\n-        cid.instance,\n-        body.span,\n-        body,\n-        Some(ret.into()),\n-        StackPopCleanup::None { cleanup: false },\n-    )?;\n-\n-    // The main interpreter loop.\n-    ecx.run()?;\n-\n-    // Intern the result\n-    intern_const_alloc_recursive(ecx, tcx.static_mutability(cid.instance.def_id()), ret)?;\n-\n-    debug!(\"eval_body_using_ecx done: {:?}\", *ret);\n-    Ok(ret)\n-}\n-\n /// Extracts a field of a (variant of a) const.\n // this function uses `unwrap` copiously, because an already validated constant must have valid\n // fields and can thus never fail outside of compiler bugs"}, {"sha": "1ab8377c4b9383149d28e19f68352d4d4353fade", "filename": "src/librustc_mir/const_eval/query.rs", "status": "modified", "additions": 50, "deletions": 2, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/eda3fa9eb5e0b2eb3cee55a6cc0a23a207b56059/src%2Flibrustc_mir%2Fconst_eval%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda3fa9eb5e0b2eb3cee55a6cc0a23a207b56059/src%2Flibrustc_mir%2Fconst_eval%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Fquery.rs?ref=eda3fa9eb5e0b2eb3cee55a6cc0a23a207b56059", "patch": "@@ -1,13 +1,18 @@\n use crate::interpret::eval_nullary_intrinsic;\n use rustc::hir::def::DefKind;\n+use rustc::mir;\n use rustc::mir::interpret::{ConstEvalErr, ErrorHandled};\n use rustc::traits::Reveal;\n+use rustc::ty::{self, layout::LayoutOf, subst::Subst, TyCtxt};\n use rustc::ty::{self, TyCtxt};\n \n-use crate::interpret::{ConstValue, GlobalId, InterpCx, RawConst, RefTracking};\n+use crate::interpret::{\n+    intern_const_alloc_recursive, ConstValue, GlobalId, InterpCx, InterpResult, MPlaceTy,\n+    MemoryKind, RawConst, RefTracking, StackPopCleanup,\n+};\n \n use super::{\n-    error_to_const_error, eval_body_using_ecx, mk_eval_cx, op_to_const, CompileTimeInterpreter,\n+    error_to_const_error, mk_eval_cx, op_to_const, CompileTimeEvalContext, CompileTimeInterpreter,\n };\n \n pub fn note_on_undefined_behavior_error() -> &'static str {\n@@ -214,3 +219,46 @@ pub fn const_eval_raw_provider<'tcx>(\n             }\n         })\n }\n+\n+// Returns a pointer to where the result lives\n+fn eval_body_using_ecx<'mir, 'tcx>(\n+    ecx: &mut CompileTimeEvalContext<'mir, 'tcx>,\n+    cid: GlobalId<'tcx>,\n+    body: &'mir mir::Body<'tcx>,\n+) -> InterpResult<'tcx, MPlaceTy<'tcx>> {\n+    debug!(\"eval_body_using_ecx: {:?}, {:?}\", cid, ecx.param_env);\n+    let tcx = ecx.tcx.tcx;\n+    let layout = ecx.layout_of(body.return_ty().subst(tcx, cid.instance.substs))?;\n+    assert!(!layout.is_unsized());\n+    let ret = ecx.allocate(layout, MemoryKind::Stack);\n+\n+    let name = ty::tls::with(|tcx| tcx.def_path_str(cid.instance.def_id()));\n+    let prom = cid.promoted.map_or(String::new(), |p| format!(\"::promoted[{:?}]\", p));\n+    trace!(\"eval_body_using_ecx: pushing stack frame for global: {}{}\", name, prom);\n+\n+    // Assert all args (if any) are zero-sized types; `eval_body_using_ecx` doesn't\n+    // make sense if the body is expecting nontrivial arguments.\n+    // (The alternative would be to use `eval_fn_call` with an args slice.)\n+    for arg in body.args_iter() {\n+        let decl = body.local_decls.get(arg).expect(\"arg missing from local_decls\");\n+        let layout = ecx.layout_of(decl.ty.subst(tcx, cid.instance.substs))?;\n+        assert!(layout.is_zst())\n+    }\n+\n+    ecx.push_stack_frame(\n+        cid.instance,\n+        body.span,\n+        body,\n+        Some(ret.into()),\n+        StackPopCleanup::None { cleanup: false },\n+    )?;\n+\n+    // The main interpreter loop.\n+    ecx.run()?;\n+\n+    // Intern the result\n+    intern_const_alloc_recursive(ecx, tcx.static_mutability(cid.instance.def_id()), ret)?;\n+\n+    debug!(\"eval_body_using_ecx done: {:?}\", *ret);\n+    Ok(ret)\n+}"}]}