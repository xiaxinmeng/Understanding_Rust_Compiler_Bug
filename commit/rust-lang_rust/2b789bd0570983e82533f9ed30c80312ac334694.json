{"sha": "2b789bd0570983e82533f9ed30c80312ac334694", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiNzg5YmQwNTcwOTgzZTgyNTMzZjllZDMwYzgwMzEyYWMzMzQ2OTQ=", "commit": {"author": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2018-06-13T22:32:30Z"}, "committer": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2018-06-18T19:41:24Z"}, "message": "Rename OOM to allocation error\n\nThe acronym is not descriptive unless one has seen it before.\n\n* Rename the `oom` function to `handle_alloc_error`. It was **stabilized in 1.28**, so if we do this at all we need to land it this cycle.\n* Rename `set_oom_hook` to `set_alloc_error_hook`\n* Rename `take_oom_hook` to `take_alloc_error_hook`\n\nBikeshed: `alloc` v.s. `allocator`, `error` v.s. `failure`", "tree": {"sha": "a1bc074ebb134737b1b670927bb9b4105bdd8f61", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a1bc074ebb134737b1b670927bb9b4105bdd8f61"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2b789bd0570983e82533f9ed30c80312ac334694", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2b789bd0570983e82533f9ed30c80312ac334694", "html_url": "https://github.com/rust-lang/rust/commit/2b789bd0570983e82533f9ed30c80312ac334694", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2b789bd0570983e82533f9ed30c80312ac334694/comments", "author": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b36917b33104dc0af4d26d53899b7cd064a40b22", "url": "https://api.github.com/repos/rust-lang/rust/commits/b36917b33104dc0af4d26d53899b7cd064a40b22", "html_url": "https://github.com/rust-lang/rust/commit/b36917b33104dc0af4d26d53899b7cd064a40b22"}], "stats": {"total": 136, "additions": 72, "deletions": 64}, "files": [{"sha": "84bd275df347c9c73b376c37e900ff3212be6900", "filename": "src/liballoc/alloc.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2b789bd0570983e82533f9ed30c80312ac334694/src%2Fliballoc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b789bd0570983e82533f9ed30c80312ac334694/src%2Fliballoc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc.rs?ref=2b789bd0570983e82533f9ed30c80312ac334694", "patch": "@@ -158,7 +158,7 @@ unsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 {\n         if !ptr.is_null() {\n             ptr\n         } else {\n-            oom(layout)\n+            handle_alloc_error(layout)\n         }\n     }\n }\n@@ -184,13 +184,13 @@ pub(crate) unsafe fn box_free<T: ?Sized>(ptr: Unique<T>) {\n ///\n /// The default behavior of this function is to print a message to standard error\n /// and abort the process.\n-/// It can be replaced with [`set_oom_hook`] and [`take_oom_hook`].\n+/// It can be replaced with [`set_alloc_error_hook`] and [`take_alloc_error_hook`].\n ///\n-/// [`set_oom_hook`]: ../../std/alloc/fn.set_oom_hook.html\n-/// [`take_oom_hook`]: ../../std/alloc/fn.take_oom_hook.html\n+/// [`set_alloc_error_hook`]: ../../std/alloc/fn.set_alloc_error_hook.html\n+/// [`take_alloc_error_hook`]: ../../std/alloc/fn.take_alloc_error_hook.html\n #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n #[rustc_allocator_nounwind]\n-pub fn oom(layout: Layout) -> ! {\n+pub fn handle_alloc_error(layout: Layout) -> ! {\n     #[allow(improper_ctypes)]\n     extern \"Rust\" {\n         #[lang = \"oom\"]\n@@ -204,14 +204,14 @@ mod tests {\n     extern crate test;\n     use self::test::Bencher;\n     use boxed::Box;\n-    use alloc::{Global, Alloc, Layout, oom};\n+    use alloc::{Global, Alloc, Layout, handle_alloc_error};\n \n     #[test]\n     fn allocate_zeroed() {\n         unsafe {\n             let layout = Layout::from_size_align(1024, 1).unwrap();\n             let ptr = Global.alloc_zeroed(layout.clone())\n-                .unwrap_or_else(|_| oom(layout));\n+                .unwrap_or_else(|_| handle_alloc_error(layout));\n \n             let mut i = ptr.cast::<u8>().as_ptr();\n             let end = i.offset(layout.size() as isize);"}, {"sha": "0fbd1408f644f9e3f2da1e0e709ec8509d182738", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2b789bd0570983e82533f9ed30c80312ac334694/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b789bd0570983e82533f9ed30c80312ac334694/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=2b789bd0570983e82533f9ed30c80312ac334694", "patch": "@@ -32,7 +32,7 @@ use core::hash::{Hash, Hasher};\n use core::{isize, usize};\n use core::convert::From;\n \n-use alloc::{Global, Alloc, Layout, box_free, oom};\n+use alloc::{Global, Alloc, Layout, box_free, handle_alloc_error};\n use boxed::Box;\n use string::String;\n use vec::Vec;\n@@ -554,7 +554,7 @@ impl<T: ?Sized> Arc<T> {\n         let layout = Layout::for_value(&*fake_ptr);\n \n         let mem = Global.alloc(layout)\n-            .unwrap_or_else(|_| oom(layout));\n+            .unwrap_or_else(|_| handle_alloc_error(layout));\n \n         // Initialize the real ArcInner\n         let inner = set_data_ptr(ptr as *mut T, mem.as_ptr() as *mut u8) as *mut ArcInner<T>;"}, {"sha": "2369ce648fda56ee64d5b92a097d9d7be7c25748", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2b789bd0570983e82533f9ed30c80312ac334694/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b789bd0570983e82533f9ed30c80312ac334694/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=2b789bd0570983e82533f9ed30c80312ac334694", "patch": "@@ -14,7 +14,7 @@ use core::ops::Drop;\n use core::ptr::{self, NonNull, Unique};\n use core::slice;\n \n-use alloc::{Alloc, Layout, Global, oom};\n+use alloc::{Alloc, Layout, Global, handle_alloc_error};\n use alloc::CollectionAllocErr;\n use alloc::CollectionAllocErr::*;\n use boxed::Box;\n@@ -104,7 +104,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n                 };\n                 match result {\n                     Ok(ptr) => ptr.cast(),\n-                    Err(_) => oom(layout),\n+                    Err(_) => handle_alloc_error(layout),\n                 }\n             };\n \n@@ -319,7 +319,9 @@ impl<T, A: Alloc> RawVec<T, A> {\n                                                  new_size);\n                     match ptr_res {\n                         Ok(ptr) => (new_cap, ptr.cast().into()),\n-                        Err(_) => oom(Layout::from_size_align_unchecked(new_size, cur.align())),\n+                        Err(_) => handle_alloc_error(\n+                            Layout::from_size_align_unchecked(new_size, cur.align())\n+                        ),\n                     }\n                 }\n                 None => {\n@@ -328,7 +330,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n                     let new_cap = if elem_size > (!0) / 8 { 1 } else { 4 };\n                     match self.a.alloc_array::<T>(new_cap) {\n                         Ok(ptr) => (new_cap, ptr.into()),\n-                        Err(_) => oom(Layout::array::<T>(new_cap).unwrap()),\n+                        Err(_) => handle_alloc_error(Layout::array::<T>(new_cap).unwrap()),\n                     }\n                 }\n             };\n@@ -611,7 +613,9 @@ impl<T, A: Alloc> RawVec<T, A> {\n                                      old_layout,\n                                      new_size) {\n                     Ok(p) => self.ptr = p.cast().into(),\n-                    Err(_) => oom(Layout::from_size_align_unchecked(new_size, align)),\n+                    Err(_) => handle_alloc_error(\n+                        Layout::from_size_align_unchecked(new_size, align)\n+                    ),\n                 }\n             }\n             self.cap = amount;\n@@ -673,7 +677,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n             };\n \n             match (&res, fallibility) {\n-                (Err(AllocErr), Infallible) => oom(new_layout),\n+                (Err(AllocErr), Infallible) => handle_alloc_error(new_layout),\n                 _ => {}\n             }\n "}, {"sha": "32d624e8fbc7942f32660a2275a4ba8ec72ef43c", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2b789bd0570983e82533f9ed30c80312ac334694/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b789bd0570983e82533f9ed30c80312ac334694/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=2b789bd0570983e82533f9ed30c80312ac334694", "patch": "@@ -259,7 +259,7 @@ use core::ops::CoerceUnsized;\n use core::ptr::{self, NonNull};\n use core::convert::From;\n \n-use alloc::{Global, Alloc, Layout, box_free, oom};\n+use alloc::{Global, Alloc, Layout, box_free, handle_alloc_error};\n use string::String;\n use vec::Vec;\n \n@@ -662,7 +662,7 @@ impl<T: ?Sized> Rc<T> {\n         let layout = Layout::for_value(&*fake_ptr);\n \n         let mem = Global.alloc(layout)\n-            .unwrap_or_else(|_| oom(layout));\n+            .unwrap_or_else(|_| handle_alloc_error(layout));\n \n         // Initialize the real RcBox\n         let inner = set_data_ptr(ptr as *mut T, mem.as_ptr() as *mut u8) as *mut RcBox<T>;"}, {"sha": "0c074582281d6414617a30050bd82d5a20290160", "filename": "src/libcore/alloc.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/2b789bd0570983e82533f9ed30c80312ac334694/src%2Flibcore%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b789bd0570983e82533f9ed30c80312ac334694/src%2Flibcore%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc.rs?ref=2b789bd0570983e82533f9ed30c80312ac334694", "patch": "@@ -492,10 +492,10 @@ pub unsafe trait GlobalAlloc {\n     /// library that aborts on memory exhaustion.)\n     ///\n     /// Clients wishing to abort computation in response to an\n-    /// allocation error are encouraged to call the [`oom`] function,\n+    /// allocation error are encouraged to call the [`handle_alloc_error`] function,\n     /// rather than directly invoking `panic!` or similar.\n     ///\n-    /// [`oom`]: ../../alloc/alloc/fn.oom.html\n+    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n     #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n     unsafe fn alloc(&self, layout: Layout) -> *mut u8;\n \n@@ -529,10 +529,10 @@ pub unsafe trait GlobalAlloc {\n     /// just as in `alloc`.\n     ///\n     /// Clients wishing to abort computation in response to an\n-    /// allocation error are encouraged to call the [`oom`] function,\n+    /// allocation error are encouraged to call the [`handle_alloc_error`] function,\n     /// rather than directly invoking `panic!` or similar.\n     ///\n-    /// [`oom`]: ../../alloc/alloc/fn.oom.html\n+    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n     #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n     unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n         let size = layout.size();\n@@ -589,10 +589,10 @@ pub unsafe trait GlobalAlloc {\n     /// library that aborts on memory exhaustion.)\n     ///\n     /// Clients wishing to abort computation in response to a\n-    /// reallocation error are encouraged to call the [`oom`] function,\n+    /// reallocation error are encouraged to call the [`handle_alloc_error`] function,\n     /// rather than directly invoking `panic!` or similar.\n     ///\n-    /// [`oom`]: ../../alloc/alloc/fn.oom.html\n+    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n     #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n     unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n         let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n@@ -733,10 +733,10 @@ pub unsafe trait Alloc {\n     /// library that aborts on memory exhaustion.)\n     ///\n     /// Clients wishing to abort computation in response to an\n-    /// allocation error are encouraged to call the [`oom`] function,\n+    /// allocation error are encouraged to call the [`handle_alloc_error`] function,\n     /// rather than directly invoking `panic!` or similar.\n     ///\n-    /// [`oom`]: ../../alloc/alloc/fn.oom.html\n+    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n     unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr>;\n \n     /// Deallocate the memory referenced by `ptr`.\n@@ -843,10 +843,10 @@ pub unsafe trait Alloc {\n     /// library that aborts on memory exhaustion.)\n     ///\n     /// Clients wishing to abort computation in response to a\n-    /// reallocation error are encouraged to call the [`oom`] function,\n+    /// reallocation error are encouraged to call the [`handle_alloc_error`] function,\n     /// rather than directly invoking `panic!` or similar.\n     ///\n-    /// [`oom`]: ../../alloc/alloc/fn.oom.html\n+    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n     unsafe fn realloc(&mut self,\n                       ptr: NonNull<u8>,\n                       layout: Layout,\n@@ -889,10 +889,10 @@ pub unsafe trait Alloc {\n     /// constraints, just as in `alloc`.\n     ///\n     /// Clients wishing to abort computation in response to an\n-    /// allocation error are encouraged to call the [`oom`] function,\n+    /// allocation error are encouraged to call the [`handle_alloc_error`] function,\n     /// rather than directly invoking `panic!` or similar.\n     ///\n-    /// [`oom`]: ../../alloc/alloc/fn.oom.html\n+    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n     unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n         let size = layout.size();\n         let p = self.alloc(layout);\n@@ -917,10 +917,10 @@ pub unsafe trait Alloc {\n     /// constraints, just as in `alloc`.\n     ///\n     /// Clients wishing to abort computation in response to an\n-    /// allocation error are encouraged to call the [`oom`] function,\n+    /// allocation error are encouraged to call the [`handle_alloc_error`] function,\n     /// rather than directly invoking `panic!` or similar.\n     ///\n-    /// [`oom`]: ../../alloc/alloc/fn.oom.html\n+    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n     unsafe fn alloc_excess(&mut self, layout: Layout) -> Result<Excess, AllocErr> {\n         let usable_size = self.usable_size(&layout);\n         self.alloc(layout).map(|p| Excess(p, usable_size.1))\n@@ -941,10 +941,10 @@ pub unsafe trait Alloc {\n     /// constraints, just as in `realloc`.\n     ///\n     /// Clients wishing to abort computation in response to a\n-    /// reallocation error are encouraged to call the [`oom`] function,\n+    /// reallocation error are encouraged to call the [`handle_alloc_error`] function,\n     /// rather than directly invoking `panic!` or similar.\n     ///\n-    /// [`oom`]: ../../alloc/alloc/fn.oom.html\n+    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n     unsafe fn realloc_excess(&mut self,\n                              ptr: NonNull<u8>,\n                              layout: Layout,\n@@ -986,7 +986,7 @@ pub unsafe trait Alloc {\n     /// unable to assert that the memory block referenced by `ptr`\n     /// could fit `layout`.\n     ///\n-    /// Note that one cannot pass `CannotReallocInPlace` to the `oom`\n+    /// Note that one cannot pass `CannotReallocInPlace` to the `handle_alloc_error`\n     /// function; clients are expected either to be able to recover from\n     /// `grow_in_place` failures without aborting, or to fall back on\n     /// another reallocation method before resorting to an abort.\n@@ -1041,7 +1041,7 @@ pub unsafe trait Alloc {\n     /// unable to assert that the memory block referenced by `ptr`\n     /// could fit `layout`.\n     ///\n-    /// Note that one cannot pass `CannotReallocInPlace` to the `oom`\n+    /// Note that one cannot pass `CannotReallocInPlace` to the `handle_alloc_error`\n     /// function; clients are expected either to be able to recover from\n     /// `shrink_in_place` failures without aborting, or to fall back\n     /// on another reallocation method before resorting to an abort.\n@@ -1090,10 +1090,10 @@ pub unsafe trait Alloc {\n     /// will *not* yield undefined behavior.\n     ///\n     /// Clients wishing to abort computation in response to an\n-    /// allocation error are encouraged to call the [`oom`] function,\n+    /// allocation error are encouraged to call the [`handle_alloc_error`] function,\n     /// rather than directly invoking `panic!` or similar.\n     ///\n-    /// [`oom`]: ../../alloc/alloc/fn.oom.html\n+    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n     fn alloc_one<T>(&mut self) -> Result<NonNull<T>, AllocErr>\n         where Self: Sized\n     {\n@@ -1159,10 +1159,10 @@ pub unsafe trait Alloc {\n     /// Always returns `Err` on arithmetic overflow.\n     ///\n     /// Clients wishing to abort computation in response to an\n-    /// allocation error are encouraged to call the [`oom`] function,\n+    /// allocation error are encouraged to call the [`handle_alloc_error`] function,\n     /// rather than directly invoking `panic!` or similar.\n     ///\n-    /// [`oom`]: ../../alloc/alloc/fn.oom.html\n+    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n     fn alloc_array<T>(&mut self, n: usize) -> Result<NonNull<T>, AllocErr>\n         where Self: Sized\n     {\n@@ -1206,10 +1206,10 @@ pub unsafe trait Alloc {\n     /// Always returns `Err` on arithmetic overflow.\n     ///\n     /// Clients wishing to abort computation in response to a\n-    /// reallocation error are encouraged to call the [`oom`] function,\n+    /// reallocation error are encouraged to call the [`handle_alloc_error`] function,\n     /// rather than directly invoking `panic!` or similar.\n     ///\n-    /// [`oom`]: ../../alloc/alloc/fn.oom.html\n+    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n     unsafe fn realloc_array<T>(&mut self,\n                                ptr: NonNull<T>,\n                                n_old: usize,"}, {"sha": "f28e91e19b73c834dd999c6b93177923295f8248", "filename": "src/libstd/alloc.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2b789bd0570983e82533f9ed30c80312ac334694/src%2Flibstd%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b789bd0570983e82533f9ed30c80312ac334694/src%2Flibstd%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Falloc.rs?ref=2b789bd0570983e82533f9ed30c80312ac334694", "patch": "@@ -88,38 +88,38 @@ pub use alloc_system::System;\n \n static HOOK: AtomicPtr<()> = AtomicPtr::new(ptr::null_mut());\n \n-/// Registers a custom OOM hook, replacing any that was previously registered.\n+/// Registers a custom allocation error hook, replacing any that was previously registered.\n ///\n-/// The OOM hook is invoked when an infallible memory allocation fails, before\n+/// The allocation error hook is invoked when an infallible memory allocation fails, before\n /// the runtime aborts. The default hook prints a message to standard error,\n-/// but this behavior can be customized with the [`set_oom_hook`] and\n-/// [`take_oom_hook`] functions.\n+/// but this behavior can be customized with the [`set_alloc_error_hook`] and\n+/// [`take_alloc_error_hook`] functions.\n ///\n /// The hook is provided with a `Layout` struct which contains information\n /// about the allocation that failed.\n ///\n-/// The OOM hook is a global resource.\n-#[unstable(feature = \"oom_hook\", issue = \"51245\")]\n-pub fn set_oom_hook(hook: fn(Layout)) {\n+/// The allocation error hook is a global resource.\n+#[unstable(feature = \"alloc_error_hook\", issue = \"51245\")]\n+pub fn set_alloc_error_hook(hook: fn(Layout)) {\n     HOOK.store(hook as *mut (), Ordering::SeqCst);\n }\n \n-/// Unregisters the current OOM hook, returning it.\n+/// Unregisters the current allocation error hook, returning it.\n ///\n-/// *See also the function [`set_oom_hook`].*\n+/// *See also the function [`set_alloc_error_hook`].*\n ///\n /// If no custom hook is registered, the default hook will be returned.\n-#[unstable(feature = \"oom_hook\", issue = \"51245\")]\n-pub fn take_oom_hook() -> fn(Layout) {\n+#[unstable(feature = \"alloc_error_hook\", issue = \"51245\")]\n+pub fn take_alloc_error_hook() -> fn(Layout) {\n     let hook = HOOK.swap(ptr::null_mut(), Ordering::SeqCst);\n     if hook.is_null() {\n-        default_oom_hook\n+        default_alloc_error_hook\n     } else {\n         unsafe { mem::transmute(hook) }\n     }\n }\n \n-fn default_oom_hook(layout: Layout) {\n+fn default_alloc_error_hook(layout: Layout) {\n     dumb_print(format_args!(\"memory allocation of {} bytes failed\", layout.size()));\n }\n \n@@ -130,7 +130,7 @@ fn default_oom_hook(layout: Layout) {\n pub extern fn rust_oom(layout: Layout) -> ! {\n     let hook = HOOK.load(Ordering::SeqCst);\n     let hook: fn(Layout) = if hook.is_null() {\n-        default_oom_hook\n+        default_alloc_error_hook\n     } else {\n         unsafe { mem::transmute(hook) }\n     };"}, {"sha": "d14b754ddb6614831466307656733a8ae5110b0a", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2b789bd0570983e82533f9ed30c80312ac334694/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b789bd0570983e82533f9ed30c80312ac334694/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=2b789bd0570983e82533f9ed30c80312ac334694", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use alloc::{Global, Alloc, Layout, LayoutErr, CollectionAllocErr, oom};\n+use alloc::{Global, Alloc, Layout, LayoutErr, CollectionAllocErr, handle_alloc_error};\n use hash::{BuildHasher, Hash, Hasher};\n use marker;\n use mem::{size_of, needs_drop};\n@@ -699,7 +699,7 @@ impl<K, V> RawTable<K, V> {\n         // point into it.\n         let (layout, _) = calculate_layout::<K, V>(capacity)?;\n         let buffer = Global.alloc(layout).map_err(|e| match fallibility {\n-            Infallible => oom(layout),\n+            Infallible => handle_alloc_error(layout),\n             Fallible => e,\n         })?;\n "}, {"sha": "f15b013c07ba497a02278a7fa3c1d55788841732", "filename": "src/test/run-pass/allocator-alloc-one.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2b789bd0570983e82533f9ed30c80312ac334694/src%2Ftest%2Frun-pass%2Fallocator-alloc-one.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b789bd0570983e82533f9ed30c80312ac334694/src%2Ftest%2Frun-pass%2Fallocator-alloc-one.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fallocator-alloc-one.rs?ref=2b789bd0570983e82533f9ed30c80312ac334694", "patch": "@@ -10,11 +10,13 @@\n \n #![feature(allocator_api, nonnull)]\n \n-use std::alloc::{Alloc, Global, Layout, oom};\n+use std::alloc::{Alloc, Global, Layout, handle_alloc_error};\n \n fn main() {\n     unsafe {\n-        let ptr = Global.alloc_one::<i32>().unwrap_or_else(|_| oom(Layout::new::<i32>()));\n+        let ptr = Global.alloc_one::<i32>().unwrap_or_else(|_| {\n+            handle_alloc_error(Layout::new::<i32>())\n+        });\n         *ptr.as_ptr() = 4;\n         assert_eq!(*ptr.as_ptr(), 4);\n         Global.dealloc_one(ptr);"}, {"sha": "3b4b458bb0477508081a4d36cb0f1e157812ef81", "filename": "src/test/run-pass/realloc-16687.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2b789bd0570983e82533f9ed30c80312ac334694/src%2Ftest%2Frun-pass%2Frealloc-16687.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b789bd0570983e82533f9ed30c80312ac334694/src%2Ftest%2Frun-pass%2Frealloc-16687.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frealloc-16687.rs?ref=2b789bd0570983e82533f9ed30c80312ac334694", "patch": "@@ -15,7 +15,7 @@\n \n #![feature(heap_api, allocator_api)]\n \n-use std::alloc::{Global, Alloc, Layout, oom};\n+use std::alloc::{Global, Alloc, Layout, handle_alloc_error};\n use std::ptr::{self, NonNull};\n \n fn main() {\n@@ -50,7 +50,7 @@ unsafe fn test_triangle() -> bool {\n             println!(\"allocate({:?})\", layout);\n         }\n \n-        let ret = Global.alloc(layout).unwrap_or_else(|_| oom(layout));\n+        let ret = Global.alloc(layout).unwrap_or_else(|_| handle_alloc_error(layout));\n \n         if PRINT {\n             println!(\"allocate({:?}) = {:?}\", layout, ret);\n@@ -73,7 +73,9 @@ unsafe fn test_triangle() -> bool {\n         }\n \n         let ret = Global.realloc(NonNull::new_unchecked(ptr), old, new.size())\n-            .unwrap_or_else(|_| oom(Layout::from_size_align_unchecked(new.size(), old.align())));\n+            .unwrap_or_else(|_| handle_alloc_error(\n+                Layout::from_size_align_unchecked(new.size(), old.align())\n+            ));\n \n         if PRINT {\n             println!(\"reallocate({:?}, old={:?}, new={:?}) = {:?}\","}, {"sha": "b58e837f3bdcf27359f8d21a336b0cde0119cafd", "filename": "src/test/run-pass/regions-mock-codegen.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2b789bd0570983e82533f9ed30c80312ac334694/src%2Ftest%2Frun-pass%2Fregions-mock-codegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b789bd0570983e82533f9ed30c80312ac334694/src%2Ftest%2Frun-pass%2Fregions-mock-codegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-mock-codegen.rs?ref=2b789bd0570983e82533f9ed30c80312ac334694", "patch": "@@ -12,7 +12,7 @@\n \n #![feature(allocator_api)]\n \n-use std::alloc::{Alloc, Global, Layout, oom};\n+use std::alloc::{Alloc, Global, Layout, handle_alloc_error};\n use std::ptr::NonNull;\n \n struct arena(());\n@@ -33,7 +33,7 @@ struct Ccx {\n fn alloc<'a>(_bcx : &'a arena) -> &'a Bcx<'a> {\n     unsafe {\n         let layout = Layout::new::<Bcx>();\n-        let ptr = Global.alloc(layout).unwrap_or_else(|_| oom(layout));\n+        let ptr = Global.alloc(layout).unwrap_or_else(|_| handle_alloc_error(layout));\n         &*(ptr.as_ptr() as *const _)\n     }\n }"}]}