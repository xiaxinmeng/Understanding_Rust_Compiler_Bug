{"sha": "9956e81c19c2f5bbc273d75b49f2e031d80d0e4e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5NTZlODFjMTljMmY1YmJjMjczZDc1YjQ5ZjJlMDMxZDgwZDBlNGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-05-07T22:59:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-05-07T22:59:30Z"}, "message": "Auto merge of #41729 - ubsan:master, r=nrc\n\nDelete features which are easily removed, in libsyntax", "tree": {"sha": "310745f2077404dbd30a486775066bf145284b1e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/310745f2077404dbd30a486775066bf145284b1e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9956e81c19c2f5bbc273d75b49f2e031d80d0e4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9956e81c19c2f5bbc273d75b49f2e031d80d0e4e", "html_url": "https://github.com/rust-lang/rust/commit/9956e81c19c2f5bbc273d75b49f2e031d80d0e4e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9956e81c19c2f5bbc273d75b49f2e031d80d0e4e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d985625b3c04c8a9b083da712fbc951b38093a58", "url": "https://api.github.com/repos/rust-lang/rust/commits/d985625b3c04c8a9b083da712fbc951b38093a58", "html_url": "https://github.com/rust-lang/rust/commit/d985625b3c04c8a9b083da712fbc951b38093a58"}, {"sha": "0be875827fe64412f6c0eedc8f775f57137e7c55", "url": "https://api.github.com/repos/rust-lang/rust/commits/0be875827fe64412f6c0eedc8f775f57137e7c55", "html_url": "https://github.com/rust-lang/rust/commit/0be875827fe64412f6c0eedc8f775f57137e7c55"}], "stats": {"total": 61, "additions": 30, "deletions": 31}, "files": [{"sha": "0b21ec986502109c1b62b4288b57f9d9da488fcf", "filename": "src/Cargo.lock", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9956e81c19c2f5bbc273d75b49f2e031d80d0e4e/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/9956e81c19c2f5bbc273d75b49f2e031d80d0e4e/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=9956e81c19c2f5bbc273d75b49f2e031d80d0e4e", "patch": "@@ -860,8 +860,8 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n name = \"syntax\"\n version = \"0.0.0\"\n dependencies = [\n+ \"bitflags 0.8.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc_bitflags 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n  \"serialize 0.0.0\","}, {"sha": "82e7cfa0032ce5ed9221e12b4f9610857260ab92", "filename": "src/libsyntax/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9956e81c19c2f5bbc273d75b49f2e031d80d0e4e/src%2Flibsyntax%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9956e81c19c2f5bbc273d75b49f2e031d80d0e4e/src%2Flibsyntax%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2FCargo.toml?ref=9956e81c19c2f5bbc273d75b49f2e031d80d0e4e", "patch": "@@ -11,7 +11,7 @@ crate-type = [\"dylib\"]\n [dependencies]\n serialize = { path = \"../libserialize\" }\n log = \"0.3\"\n-rustc_bitflags = { path = \"../librustc_bitflags\" }\n+bitflags = \"0.8\"\n syntax_pos = { path = \"../libsyntax_pos\" }\n rustc_errors = { path = \"../librustc_errors\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }"}, {"sha": "89c67b88cbde6dccaa7c0006cefc9152aac9a747", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9956e81c19c2f5bbc273d75b49f2e031d80d0e4e/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9956e81c19c2f5bbc273d75b49f2e031d80d0e4e/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=9956e81c19c2f5bbc273d75b49f2e031d80d0e4e", "patch": "@@ -24,20 +24,15 @@\n        test(attr(deny(warnings))))]\n #![deny(warnings)]\n \n-#![feature(associated_consts)]\n-#![feature(const_fn)]\n-#![feature(optin_builtin_traits)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n-#![feature(str_escape)]\n #![feature(unicode)]\n #![feature(rustc_diagnostic_macros)]\n-#![feature(specialization)]\n #![feature(i128_type)]\n \n extern crate serialize;\n #[macro_use] extern crate log;\n-#[macro_use] #[no_link] extern crate rustc_bitflags;\n+#[macro_use] extern crate bitflags;\n extern crate std_unicode;\n pub extern crate rustc_errors as errors;\n extern crate syntax_pos;"}, {"sha": "fe3ca1cf2305c0341ae3fb50db3616cb0e581c1b", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9956e81c19c2f5bbc273d75b49f2e031d80d0e4e/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9956e81c19c2f5bbc273d75b49f2e031d80d0e4e/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=9956e81c19c2f5bbc273d75b49f2e031d80d0e4e", "patch": "@@ -261,10 +261,14 @@ pub fn char_lit(lit: &str) -> (char, isize) {\n     }\n }\n \n+pub fn escape_default(s: &str) -> String {\n+    s.chars().map(char::escape_default).flat_map(|x| x).collect()\n+}\n+\n /// Parse a string representing a string literal into its final form. Does\n /// unescaping.\n pub fn str_lit(lit: &str) -> String {\n-    debug!(\"parse_str_lit: given {}\", lit.escape_default());\n+    debug!(\"parse_str_lit: given {}\", escape_default(lit));\n     let mut res = String::with_capacity(lit.len());\n \n     // FIXME #8372: This could be a for-loop if it didn't borrow the iterator\n@@ -339,7 +343,7 @@ pub fn str_lit(lit: &str) -> String {\n /// Parse a string representing a raw string literal into its final form. The\n /// only operation this does is convert embedded CRLF into a single LF.\n pub fn raw_str_lit(lit: &str) -> String {\n-    debug!(\"raw_str_lit: given {}\", lit.escape_default());\n+    debug!(\"raw_str_lit: given {}\", escape_default(lit));\n     let mut res = String::with_capacity(lit.len());\n \n     // FIXME #8372: This could be a for-loop if it didn't borrow the iterator"}, {"sha": "c09ddb4d1c9e039a9cc98654183867fe6667cef1", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/9956e81c19c2f5bbc273d75b49f2e031d80d0e4e/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9956e81c19c2f5bbc273d75b49f2e031d80d0e4e/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=9956e81c19c2f5bbc273d75b49f2e031d80d0e4e", "patch": "@@ -64,7 +64,7 @@ use std::path::{self, Path, PathBuf};\n use std::slice;\n \n bitflags! {\n-    flags Restrictions: u8 {\n+    pub flags Restrictions: u8 {\n         const RESTRICTION_STMT_EXPR         = 1 << 0,\n         const RESTRICTION_NO_STRUCT_LITERAL = 1 << 1,\n     }\n@@ -2291,7 +2291,7 @@ impl<'a> Parser<'a> {\n                     let e = if self.token.can_begin_expr()\n                                && !(self.token == token::OpenDelim(token::Brace)\n                                     && self.restrictions.contains(\n-                                           Restrictions::RESTRICTION_NO_STRUCT_LITERAL)) {\n+                                           RESTRICTION_NO_STRUCT_LITERAL)) {\n                         Some(self.parse_expr()?)\n                     } else {\n                         None\n@@ -2318,7 +2318,7 @@ impl<'a> Parser<'a> {\n                         // This is a struct literal, unless we're prohibited\n                         // from parsing struct literals here.\n                         let prohibited = self.restrictions.contains(\n-                            Restrictions::RESTRICTION_NO_STRUCT_LITERAL\n+                            RESTRICTION_NO_STRUCT_LITERAL\n                         );\n                         if !prohibited {\n                             return self.parse_struct_expr(lo, pth, attrs);\n@@ -2735,7 +2735,7 @@ impl<'a> Parser<'a> {\n             token::Ident(..) if self.token.is_keyword(keywords::In) => {\n                 self.bump();\n                 let place = self.parse_expr_res(\n-                    Restrictions::RESTRICTION_NO_STRUCT_LITERAL,\n+                    RESTRICTION_NO_STRUCT_LITERAL,\n                     None,\n                 )?;\n                 let blk = self.parse_block()?;\n@@ -2798,7 +2798,7 @@ impl<'a> Parser<'a> {\n \n             let cur_op_span = self.span;\n             let restrictions = if op.is_assign_like() {\n-                self.restrictions & Restrictions::RESTRICTION_NO_STRUCT_LITERAL\n+                self.restrictions & RESTRICTION_NO_STRUCT_LITERAL\n             } else {\n                 self.restrictions\n             };\n@@ -2848,21 +2848,21 @@ impl<'a> Parser<'a> {\n \n             let rhs = match op.fixity() {\n                 Fixity::Right => self.with_res(\n-                    restrictions - Restrictions::RESTRICTION_STMT_EXPR,\n+                    restrictions - RESTRICTION_STMT_EXPR,\n                     |this| {\n                         this.parse_assoc_expr_with(op.precedence(),\n                             LhsExpr::NotYetParsed)\n                 }),\n                 Fixity::Left => self.with_res(\n-                    restrictions - Restrictions::RESTRICTION_STMT_EXPR,\n+                    restrictions - RESTRICTION_STMT_EXPR,\n                     |this| {\n                         this.parse_assoc_expr_with(op.precedence() + 1,\n                             LhsExpr::NotYetParsed)\n                 }),\n                 // We currently have no non-associative operators that are not handled above by\n                 // the special cases. The code is here only for future convenience.\n                 Fixity::None => self.with_res(\n-                    restrictions - Restrictions::RESTRICTION_STMT_EXPR,\n+                    restrictions - RESTRICTION_STMT_EXPR,\n                     |this| {\n                         this.parse_assoc_expr_with(op.precedence() + 1,\n                             LhsExpr::NotYetParsed)\n@@ -2972,7 +2972,7 @@ impl<'a> Parser<'a> {\n         if self.token.can_begin_expr() {\n             // parse `for i in 1.. { }` as infinite loop, not as `for i in (1..{})`.\n             if self.token == token::OpenDelim(token::Brace) {\n-                return !self.restrictions.contains(Restrictions::RESTRICTION_NO_STRUCT_LITERAL);\n+                return !self.restrictions.contains(RESTRICTION_NO_STRUCT_LITERAL);\n             }\n             true\n         } else {\n@@ -2986,7 +2986,7 @@ impl<'a> Parser<'a> {\n             return self.parse_if_let_expr(attrs);\n         }\n         let lo = self.prev_span;\n-        let cond = self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL, None)?;\n+        let cond = self.parse_expr_res(RESTRICTION_NO_STRUCT_LITERAL, None)?;\n         let thn = self.parse_block()?;\n         let mut els: Option<P<Expr>> = None;\n         let mut hi = thn.span;\n@@ -3005,7 +3005,7 @@ impl<'a> Parser<'a> {\n         self.expect_keyword(keywords::Let)?;\n         let pat = self.parse_pat()?;\n         self.expect(&token::Eq)?;\n-        let expr = self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL, None)?;\n+        let expr = self.parse_expr_res(RESTRICTION_NO_STRUCT_LITERAL, None)?;\n         let thn = self.parse_block()?;\n         let (hi, els) = if self.eat_keyword(keywords::Else) {\n             let expr = self.parse_else_expr()?;\n@@ -3059,7 +3059,7 @@ impl<'a> Parser<'a> {\n \n         let pat = self.parse_pat()?;\n         self.expect_keyword(keywords::In)?;\n-        let expr = self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL, None)?;\n+        let expr = self.parse_expr_res(RESTRICTION_NO_STRUCT_LITERAL, None)?;\n         let (iattrs, loop_block) = self.parse_inner_attrs_and_block()?;\n         attrs.extend(iattrs);\n \n@@ -3074,7 +3074,7 @@ impl<'a> Parser<'a> {\n         if self.token.is_keyword(keywords::Let) {\n             return self.parse_while_let_expr(opt_ident, span_lo, attrs);\n         }\n-        let cond = self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL, None)?;\n+        let cond = self.parse_expr_res(RESTRICTION_NO_STRUCT_LITERAL, None)?;\n         let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n         attrs.extend(iattrs);\n         let span = span_lo.to(body.span);\n@@ -3088,7 +3088,7 @@ impl<'a> Parser<'a> {\n         self.expect_keyword(keywords::Let)?;\n         let pat = self.parse_pat()?;\n         self.expect(&token::Eq)?;\n-        let expr = self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL, None)?;\n+        let expr = self.parse_expr_res(RESTRICTION_NO_STRUCT_LITERAL, None)?;\n         let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n         attrs.extend(iattrs);\n         let span = span_lo.to(body.span);\n@@ -3118,7 +3118,7 @@ impl<'a> Parser<'a> {\n     fn parse_match_expr(&mut self, mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n         let match_span = self.prev_span;\n         let lo = self.prev_span;\n-        let discriminant = self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL,\n+        let discriminant = self.parse_expr_res(RESTRICTION_NO_STRUCT_LITERAL,\n                                                None)?;\n         if let Err(mut e) = self.expect(&token::OpenDelim(token::Brace)) {\n             if self.token == token::Token::Semi {\n@@ -3159,7 +3159,7 @@ impl<'a> Parser<'a> {\n             guard = Some(self.parse_expr()?);\n         }\n         self.expect(&token::FatArrow)?;\n-        let expr = self.parse_expr_res(Restrictions::RESTRICTION_STMT_EXPR, None)?;\n+        let expr = self.parse_expr_res(RESTRICTION_STMT_EXPR, None)?;\n \n         let require_comma =\n             !classify::expr_is_simple_block(&expr)\n@@ -3740,7 +3740,7 @@ impl<'a> Parser<'a> {\n         self.look_ahead(2, |t| *t == token::OpenDelim(token::Brace)) &&\n \n         // prevent `while catch {} {}`, `if catch {} {} else {}`, etc.\n-        !self.restrictions.contains(Restrictions::RESTRICTION_NO_STRUCT_LITERAL)\n+        !self.restrictions.contains(RESTRICTION_NO_STRUCT_LITERAL)\n     }\n \n     fn is_union_item(&self) -> bool {\n@@ -3812,7 +3812,7 @@ impl<'a> Parser<'a> {\n                     self.mk_expr(lo.to(hi), ExprKind::Path(None, pth), ThinVec::new())\n                 };\n \n-                let expr = self.with_res(Restrictions::RESTRICTION_STMT_EXPR, |this| {\n+                let expr = self.with_res(RESTRICTION_STMT_EXPR, |this| {\n                     let expr = this.parse_dot_or_call_expr_with(expr, lo, attrs.into())?;\n                     this.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(expr))\n                 })?;\n@@ -3952,7 +3952,7 @@ impl<'a> Parser<'a> {\n \n                     // Remainder are line-expr stmts.\n                     let e = self.parse_expr_res(\n-                        Restrictions::RESTRICTION_STMT_EXPR, Some(attrs.into()))?;\n+                        RESTRICTION_STMT_EXPR, Some(attrs.into()))?;\n                     Stmt {\n                         id: ast::DUMMY_NODE_ID,\n                         span: lo.to(e.span),\n@@ -3965,7 +3965,7 @@ impl<'a> Parser<'a> {\n \n     /// Is this expression a successfully-parsed statement?\n     fn expr_is_complete(&mut self, e: &Expr) -> bool {\n-        self.restrictions.contains(Restrictions::RESTRICTION_STMT_EXPR) &&\n+        self.restrictions.contains(RESTRICTION_STMT_EXPR) &&\n             !classify::expr_requires_semi_to_be_stmt(e)\n     }\n "}, {"sha": "0c7e8fda83766cbdbc8f4f0df87c1e42b5f9c523", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9956e81c19c2f5bbc273d75b49f2e031d80d0e4e/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9956e81c19c2f5bbc273d75b49f2e031d80d0e4e/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=9956e81c19c2f5bbc273d75b49f2e031d80d0e4e", "patch": "@@ -677,7 +677,7 @@ pub trait PrintState<'a> {\n                     style: ast::StrStyle) -> io::Result<()> {\n         let st = match style {\n             ast::StrStyle::Cooked => {\n-                (format!(\"\\\"{}\\\"\", st.escape_default()))\n+                (format!(\"\\\"{}\\\"\", parse::escape_default(st)))\n             }\n             ast::StrStyle::Raw(n) => {\n                 (format!(\"r{delim}\\\"{string}\\\"{delim}\","}]}