{"sha": "df483e82e7bcac0f36eff91145d5ac1c019f5078", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmNDgzZTgyZTdiY2FjMGYzNmVmZjkxMTQ1ZDVhYzFjMDE5ZjUwNzg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-12T21:34:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-12T21:34:34Z"}, "message": "auto merge of #7084 : pnkfelix/rust/fsk-visitor-refactoring, r=pnkfelix\n\nThis step 1 in my plan for issue #7081: Refactor visit.rs with a `@Visitor` trait.", "tree": {"sha": "4366604128a94110e69081407cb6c891c53ecc1c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4366604128a94110e69081407cb6c891c53ecc1c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df483e82e7bcac0f36eff91145d5ac1c019f5078", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df483e82e7bcac0f36eff91145d5ac1c019f5078", "html_url": "https://github.com/rust-lang/rust/commit/df483e82e7bcac0f36eff91145d5ac1c019f5078", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df483e82e7bcac0f36eff91145d5ac1c019f5078/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "78cddc83a44f04c7252435c9d6fff01b43cb44b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/78cddc83a44f04c7252435c9d6fff01b43cb44b3", "html_url": "https://github.com/rust-lang/rust/commit/78cddc83a44f04c7252435c9d6fff01b43cb44b3"}, {"sha": "009a2fdc5e185cf3cfce978c963cadd001aee8ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/009a2fdc5e185cf3cfce978c963cadd001aee8ed", "html_url": "https://github.com/rust-lang/rust/commit/009a2fdc5e185cf3cfce978c963cadd001aee8ed"}], "stats": {"total": 1540, "additions": 765, "deletions": 775}, "files": [{"sha": "d043ee27fb1d8e7228ba88c9a5415eb24f1717db", "filename": "src/libfuzzer/fuzzer.rc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibfuzzer%2Ffuzzer.rc", "raw_url": "https://github.com/rust-lang/rust/raw/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibfuzzer%2Ffuzzer.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Ffuzzer.rc?ref=df483e82e7bcac0f36eff91145d5ac1c019f5078", "patch": "@@ -176,7 +176,7 @@ pub fn steal(crate: @ast::crate, tm: test_mode) -> StolenStuff {\n         visit_ty: |a| stash_ty_if(safe_to_steal_ty, tys, a, tm),\n         .. *visit::default_simple_visitor()\n     });\n-    visit::visit_crate(crate, (), v);\n+    visit::visit_crate(crate, ((), v));\n     StolenStuff {\n         exprs: (*exprs).clone(),\n         tys: (*tys).clone(),\n@@ -539,7 +539,7 @@ pub fn has_raw_pointers(c: @ast::crate) -> bool {\n         visit::mk_simple_visitor(@visit::SimpleVisitor {\n             visit_ty: |a| visit_ty(has_rp, a),\n             .. *visit::default_simple_visitor()});\n-    visit::visit_crate(c, (), v);\n+    visit::visit_crate(c, ((), v));\n     return *has_rp;\n }\n "}, {"sha": "e05684d51e27581f3aff43fece2e23b00edbd8a6", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=df483e82e7bcac0f36eff91145d5ac1c019f5078", "patch": "@@ -52,7 +52,7 @@ pub fn read_crates(diag: @span_handler,\n             visit_item: |a| visit_item(e, a),\n             .. *visit::default_simple_visitor()});\n     visit_crate(e, crate);\n-    visit::visit_crate(crate, (), v);\n+    visit::visit_crate(crate, ((), v));\n     dump_crates(e.crate_cache);\n     warn_if_multiple_versions(e, diag, e.crate_cache);\n }"}, {"sha": "0c6c1065dba0afab54a9b786d65a32c50ada12e8", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=df483e82e7bcac0f36eff91145d5ac1c019f5078", "patch": "@@ -1120,12 +1120,12 @@ fn encode_info_for_items(ecx: @EncodeContext,\n     encode_info_for_mod(ecx, ebml_w, &crate.node.module,\n                         crate_node_id, [],\n                         syntax::parse::token::special_idents::invalid);\n-    visit::visit_crate(crate, (), visit::mk_vt(@visit::Visitor {\n-        visit_expr: |_e, _cx, _v| { },\n+    visit::visit_crate(crate, ((), visit::mk_vt(@visit::Visitor {\n+        visit_expr: |_e, (_cx, _v)| { },\n         visit_item: {\n             let ebml_w = copy *ebml_w;\n-            |i, cx, v| {\n-                visit::visit_item(i, cx, v);\n+            |i, (cx, v)| {\n+                visit::visit_item(i, (cx, v));\n                 match ecx.tcx.items.get_copy(&i.id) {\n                     ast_map::node_item(_, pt) => {\n                         let mut ebml_w = copy ebml_w;\n@@ -1137,8 +1137,8 @@ fn encode_info_for_items(ecx: @EncodeContext,\n         },\n         visit_foreign_item: {\n             let ebml_w = copy *ebml_w;\n-            |ni, cx, v| {\n-                visit::visit_foreign_item(ni, cx, v);\n+            |ni, (cx, v)| {\n+                visit::visit_foreign_item(ni, (cx, v));\n                 match ecx.tcx.items.get_copy(&ni.id) {\n                     ast_map::node_foreign_item(_, abi, _, pt) => {\n                         let mut ebml_w = copy ebml_w;\n@@ -1155,7 +1155,7 @@ fn encode_info_for_items(ecx: @EncodeContext,\n             }\n         },\n         ..*visit::default_visitor()\n-    }));\n+    })));\n     ebml_w.end_tag();\n     return /*bad*/copy *index;\n }"}, {"sha": "dfbef30f896d6a371b7033e6f5e3c11805b0ff54", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=df483e82e7bcac0f36eff91145d5ac1c019f5078", "patch": "@@ -62,7 +62,7 @@ pub fn check_loans(bccx: @BorrowckCtxt,\n                                            visit_pat: check_loans_in_pat,\n                                            visit_fn: check_loans_in_fn,\n                                            .. *visit::default_visitor()});\n-    (vt.visit_block)(body, clcx, vt);\n+    (vt.visit_block)(body, (clcx, vt));\n }\n \n enum MoveError {\n@@ -614,8 +614,8 @@ fn check_loans_in_fn<'a>(fk: &visit::fn_kind,\n                          body: &ast::blk,\n                          sp: span,\n                          id: ast::node_id,\n-                         this: @mut CheckLoanCtxt<'a>,\n-                         visitor: visit::vt<@mut CheckLoanCtxt<'a>>) {\n+                         (this, visitor): (@mut CheckLoanCtxt<'a>,\n+                                           visit::vt<@mut CheckLoanCtxt<'a>>)) {\n     match *fk {\n         visit::fk_item_fn(*) |\n         visit::fk_method(*) => {\n@@ -629,7 +629,7 @@ fn check_loans_in_fn<'a>(fk: &visit::fn_kind,\n         }\n     }\n \n-    visit::visit_fn(fk, decl, body, sp, id, this, visitor);\n+    visit::visit_fn(fk, decl, body, sp, id, (this, visitor));\n \n     fn check_captured_variables(this: @mut CheckLoanCtxt,\n                                 closure_id: ast::node_id,\n@@ -677,15 +677,15 @@ fn check_loans_in_fn<'a>(fk: &visit::fn_kind,\n }\n \n fn check_loans_in_local<'a>(local: @ast::local,\n-                            this: @mut CheckLoanCtxt<'a>,\n-                            vt: visit::vt<@mut CheckLoanCtxt<'a>>) {\n-    visit::visit_local(local, this, vt);\n+                            (this, vt): (@mut CheckLoanCtxt<'a>,\n+                                         visit::vt<@mut CheckLoanCtxt<'a>>)) {\n+    visit::visit_local(local, (this, vt));\n }\n \n fn check_loans_in_expr<'a>(expr: @ast::expr,\n-                           this: @mut CheckLoanCtxt<'a>,\n-                           vt: visit::vt<@mut CheckLoanCtxt<'a>>) {\n-    visit::visit_expr(expr, this, vt);\n+                           (this, vt): (@mut CheckLoanCtxt<'a>,\n+                                        visit::vt<@mut CheckLoanCtxt<'a>>)) {\n+    visit::visit_expr(expr, (this, vt));\n \n     debug!(\"check_loans_in_expr(expr=%s)\",\n            expr.repr(this.tcx()));\n@@ -740,8 +740,8 @@ fn check_loans_in_expr<'a>(expr: @ast::expr,\n }\n \n fn check_loans_in_pat<'a>(pat: @ast::pat,\n-                          this: @mut CheckLoanCtxt<'a>,\n-                          vt: visit::vt<@mut CheckLoanCtxt<'a>>)\n+                          (this, vt): (@mut CheckLoanCtxt<'a>,\n+                                       visit::vt<@mut CheckLoanCtxt<'a>>))\n {\n     this.check_for_conflicting_loans(pat.id);\n \n@@ -756,13 +756,13 @@ fn check_loans_in_pat<'a>(pat: @ast::pat,\n     // rewalk the patterns and rebuild the pattern\n     // categorizations.\n \n-    visit::visit_pat(pat, this, vt);\n+    visit::visit_pat(pat, (this, vt));\n }\n \n fn check_loans_in_block<'a>(blk: &ast::blk,\n-                            this: @mut CheckLoanCtxt<'a>,\n-                            vt: visit::vt<@mut CheckLoanCtxt<'a>>)\n+                            (this, vt): (@mut CheckLoanCtxt<'a>,\n+                                         visit::vt<@mut CheckLoanCtxt<'a>>))\n {\n-    visit::visit_block(blk, this, vt);\n+    visit::visit_block(blk, (this, vt));\n     this.check_for_conflicting_loans(blk.node.id);\n }"}, {"sha": "b88d4365014473ae0b0e46b1d23f08142ab9ee38", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=df483e82e7bcac0f36eff91145d5ac1c019f5078", "patch": "@@ -92,28 +92,28 @@ pub fn gather_loans(bccx: @BorrowckCtxt,\n                                           visit_pat: add_pat_to_id_range,\n                                           visit_local: gather_loans_in_local,\n                                           .. *visit::default_visitor()});\n-    (v.visit_block)(body, glcx, v);\n+    (v.visit_block)(body, (glcx, v));\n     return (glcx.id_range, glcx.all_loans, glcx.move_data);\n }\n \n fn add_pat_to_id_range(p: @ast::pat,\n-                       this: @mut GatherLoanCtxt,\n-                       v: visit::vt<@mut GatherLoanCtxt>) {\n+                       (this, v): (@mut GatherLoanCtxt,\n+                                   visit::vt<@mut GatherLoanCtxt>)) {\n     // NB: This visitor function just adds the pat ids into the id\n     // range. We gather loans that occur in patterns using the\n     // `gather_pat()` method below. Eventually these two should be\n     // brought together.\n     this.id_range.add(p.id);\n-    visit::visit_pat(p, this, v);\n+    visit::visit_pat(p, (this, v));\n }\n \n fn gather_loans_in_fn(fk: &visit::fn_kind,\n                       decl: &ast::fn_decl,\n                       body: &ast::blk,\n                       sp: span,\n                       id: ast::node_id,\n-                      this: @mut GatherLoanCtxt,\n-                      v: visit::vt<@mut GatherLoanCtxt>) {\n+                      (this, v): (@mut GatherLoanCtxt,\n+                                  visit::vt<@mut GatherLoanCtxt>)) {\n     match fk {\n         // Do not visit items here, the outer loop in borrowck/mod\n         // will visit them for us in turn.\n@@ -124,22 +124,22 @@ fn gather_loans_in_fn(fk: &visit::fn_kind,\n         // Visit closures as part of the containing item.\n         &visit::fk_anon(*) | &visit::fk_fn_block(*) => {\n             this.push_repeating_id(body.node.id);\n-            visit::visit_fn(fk, decl, body, sp, id, this, v);\n+            visit::visit_fn(fk, decl, body, sp, id, (this, v));\n             this.pop_repeating_id(body.node.id);\n         }\n     }\n }\n \n fn gather_loans_in_block(blk: &ast::blk,\n-                         this: @mut GatherLoanCtxt,\n-                         vt: visit::vt<@mut GatherLoanCtxt>) {\n+                         (this, vt): (@mut GatherLoanCtxt,\n+                                      visit::vt<@mut GatherLoanCtxt>)) {\n     this.id_range.add(blk.node.id);\n-    visit::visit_block(blk, this, vt);\n+    visit::visit_block(blk, (this, vt));\n }\n \n fn gather_loans_in_local(local: @ast::local,\n-                         this: @mut GatherLoanCtxt,\n-                         vt: visit::vt<@mut GatherLoanCtxt>) {\n+                         (this, vt): (@mut GatherLoanCtxt,\n+                                      visit::vt<@mut GatherLoanCtxt>)) {\n     if local.node.init.is_none() {\n         // Variable declarations without initializers are considered \"moves\":\n         let tcx = this.bccx.tcx;\n@@ -163,12 +163,12 @@ fn gather_loans_in_local(local: @ast::local,\n         }\n     }\n \n-    visit::visit_local(local, this, vt);\n+    visit::visit_local(local, (this, vt));\n }\n \n fn gather_loans_in_expr(ex: @ast::expr,\n-                        this: @mut GatherLoanCtxt,\n-                        vt: visit::vt<@mut GatherLoanCtxt>) {\n+                        (this, vt): (@mut GatherLoanCtxt,\n+                                     visit::vt<@mut GatherLoanCtxt>)) {\n     let bccx = this.bccx;\n     let tcx = bccx.tcx;\n \n@@ -208,7 +208,7 @@ fn gather_loans_in_expr(ex: @ast::expr,\n         // for the lifetime `scope_r` of the resulting ptr:\n         let scope_r = ty_region(tcx, ex.span, ty::expr_ty(tcx, ex));\n         this.guarantee_valid(ex.id, ex.span, base_cmt, mutbl, scope_r);\n-        visit::visit_expr(ex, this, vt);\n+        visit::visit_expr(ex, (this, vt));\n       }\n \n       ast::expr_assign(l, _) | ast::expr_assign_op(_, _, l, _) => {\n@@ -225,7 +225,7 @@ fn gather_loans_in_expr(ex: @ast::expr,\n                   // with moves etc, just ignore.\n               }\n           }\n-          visit::visit_expr(ex, this, vt);\n+          visit::visit_expr(ex, (this, vt));\n       }\n \n       ast::expr_match(ex_v, ref arms) => {\n@@ -235,7 +235,7 @@ fn gather_loans_in_expr(ex: @ast::expr,\n                 this.gather_pat(cmt, *pat, arm.body.node.id, ex.id);\n             }\n         }\n-        visit::visit_expr(ex, this, vt);\n+        visit::visit_expr(ex, (this, vt));\n       }\n \n       ast::expr_index(_, _, arg) |\n@@ -249,36 +249,36 @@ fn gather_loans_in_expr(ex: @ast::expr,\n           let scope_r = ty::re_scope(ex.id);\n           let arg_cmt = this.bccx.cat_expr(arg);\n           this.guarantee_valid(arg.id, arg.span, arg_cmt, m_imm, scope_r);\n-          visit::visit_expr(ex, this, vt);\n+          visit::visit_expr(ex, (this, vt));\n       }\n \n       // see explanation attached to the `root_ub` field:\n       ast::expr_while(cond, ref body) => {\n           // during the condition, can only root for the condition\n           this.push_repeating_id(cond.id);\n-          (vt.visit_expr)(cond, this, vt);\n+          (vt.visit_expr)(cond, (this, vt));\n           this.pop_repeating_id(cond.id);\n \n           // during body, can only root for the body\n           this.push_repeating_id(body.node.id);\n-          (vt.visit_block)(body, this, vt);\n+          (vt.visit_block)(body, (this, vt));\n           this.pop_repeating_id(body.node.id);\n       }\n \n       // see explanation attached to the `root_ub` field:\n       ast::expr_loop(ref body, _) => {\n           this.push_repeating_id(body.node.id);\n-          visit::visit_expr(ex, this, vt);\n+          visit::visit_expr(ex, (this, vt));\n           this.pop_repeating_id(body.node.id);\n       }\n \n       ast::expr_fn_block(*) => {\n           gather_moves::gather_captures(this.bccx, this.move_data, ex);\n-          visit::visit_expr(ex, this, vt);\n+          visit::visit_expr(ex, (this, vt));\n       }\n \n       _ => {\n-        visit::visit_expr(ex, this, vt);\n+        visit::visit_expr(ex, (this, vt));\n       }\n     }\n }\n@@ -702,13 +702,13 @@ impl GatherLoanCtxt {\n // Setting up info that preserve needs.\n // This is just the most convenient place to do it.\n fn add_stmt_to_map(stmt: @ast::stmt,\n-                   this: @mut GatherLoanCtxt,\n-                   vt: visit::vt<@mut GatherLoanCtxt>) {\n+                   (this, vt): (@mut GatherLoanCtxt,\n+                                visit::vt<@mut GatherLoanCtxt>)) {\n     match stmt.node {\n         ast::stmt_expr(_, id) | ast::stmt_semi(_, id) => {\n             this.bccx.stmt_map.insert(id);\n         }\n         _ => ()\n     }\n-    visit::visit_stmt(stmt, this, vt);\n+    visit::visit_stmt(stmt, (this, vt));\n }"}, {"sha": "982751ee5a56aba215ba21b4f839d0f7a153f50f", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=df483e82e7bcac0f36eff91145d5ac1c019f5078", "patch": "@@ -81,7 +81,7 @@ pub fn check_crate(\n \n     let v = visit::mk_vt(@visit::Visitor {visit_fn: borrowck_fn,\n                                           ..*visit::default_visitor()});\n-    visit::visit_crate(crate, bccx, v);\n+    visit::visit_crate(crate, (bccx, v));\n \n     if tcx.sess.borrowck_stats() {\n         io::println(\"--- borrowck stats ---\");\n@@ -111,8 +111,8 @@ fn borrowck_fn(fk: &visit::fn_kind,\n                body: &ast::blk,\n                sp: span,\n                id: ast::node_id,\n-               this: @BorrowckCtxt,\n-               v: visit::vt<@BorrowckCtxt>) {\n+               (this, v): (@BorrowckCtxt,\n+                           visit::vt<@BorrowckCtxt>)) {\n     match fk {\n         &visit::fk_anon(*) |\n         &visit::fk_fn_block(*) => {\n@@ -149,7 +149,7 @@ fn borrowck_fn(fk: &visit::fn_kind,\n         }\n     }\n \n-    visit::visit_fn(fk, decl, body, sp, id, this, v);\n+    visit::visit_fn(fk, decl, body, sp, id, (this, v));\n }\n \n // ----------------------------------------------------------------------"}, {"sha": "85e2fe370762ca22506e16ea420747edb507e2e5", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=df483e82e7bcac0f36eff91145d5ac1c019f5078", "patch": "@@ -27,39 +27,39 @@ pub fn check_crate(sess: Session,\n                    def_map: resolve::DefMap,\n                    method_map: typeck::method_map,\n                    tcx: ty::ctxt) {\n-    visit::visit_crate(crate, false, visit::mk_vt(@visit::Visitor {\n-        visit_item: |a,b,c| check_item(sess, ast_map, def_map, a, b, c),\n+    visit::visit_crate(crate, (false, visit::mk_vt(@visit::Visitor {\n+        visit_item: |a,b| check_item(sess, ast_map, def_map, a, b),\n         visit_pat: check_pat,\n-        visit_expr: |a,b,c|\n-            check_expr(sess, def_map, method_map, tcx, a, b, c),\n+        visit_expr: |a,b|\n+            check_expr(sess, def_map, method_map, tcx, a, b),\n         .. *visit::default_visitor()\n-    }));\n+    })));\n     sess.abort_if_errors();\n }\n \n pub fn check_item(sess: Session,\n                   ast_map: ast_map::map,\n                   def_map: resolve::DefMap,\n                   it: @item,\n-                  _is_const: bool,\n-                  v: visit::vt<bool>) {\n+                  (_is_const, v): (bool,\n+                                   visit::vt<bool>)) {\n     match it.node {\n       item_const(_, ex) => {\n-        (v.visit_expr)(ex, true, v);\n+        (v.visit_expr)(ex, (true, v));\n         check_item_recursion(sess, ast_map, def_map, it);\n       }\n       item_enum(ref enum_definition, _) => {\n         for (*enum_definition).variants.each |var| {\n             for var.node.disr_expr.iter().advance |ex| {\n-                (v.visit_expr)(*ex, true, v);\n+                (v.visit_expr)(*ex, (true, v));\n             }\n         }\n       }\n-      _ => visit::visit_item(it, false, v)\n+      _ => visit::visit_item(it, (false, v))\n     }\n }\n \n-pub fn check_pat(p: @pat, _is_const: bool, v: visit::vt<bool>) {\n+pub fn check_pat(p: @pat, (_is_const, v): (bool, visit::vt<bool>)) {\n     fn is_str(e: @expr) -> bool {\n         match e.node {\n             expr_vstore(\n@@ -74,12 +74,12 @@ pub fn check_pat(p: @pat, _is_const: bool, v: visit::vt<bool>) {\n     }\n     match p.node {\n       // Let through plain ~-string literals here\n-      pat_lit(a) => if !is_str(a) { (v.visit_expr)(a, true, v); },\n+      pat_lit(a) => if !is_str(a) { (v.visit_expr)(a, (true, v)); },\n       pat_range(a, b) => {\n-        if !is_str(a) { (v.visit_expr)(a, true, v); }\n-        if !is_str(b) { (v.visit_expr)(b, true, v); }\n+        if !is_str(a) { (v.visit_expr)(a, (true, v)); }\n+        if !is_str(b) { (v.visit_expr)(b, (true, v)); }\n       }\n-      _ => visit::visit_pat(p, false, v)\n+      _ => visit::visit_pat(p, (false, v))\n     }\n }\n \n@@ -88,8 +88,8 @@ pub fn check_expr(sess: Session,\n                   method_map: typeck::method_map,\n                   tcx: ty::ctxt,\n                   e: @expr,\n-                  is_const: bool,\n-                  v: visit::vt<bool>) {\n+                  (is_const, v): (bool,\n+                                  visit::vt<bool>)) {\n     if is_const {\n         match e.node {\n           expr_unary(_, deref, _) => { }\n@@ -155,7 +155,7 @@ pub fn check_expr(sess: Session,\n             }\n           }\n           expr_paren(e) => { check_expr(sess, def_map, method_map,\n-                                         tcx, e, is_const, v); }\n+                                         tcx, e, (is_const, v)); }\n           expr_vstore(_, expr_vstore_slice) |\n           expr_vec(_, m_imm) |\n           expr_addr_of(m_imm, _) |\n@@ -193,7 +193,7 @@ pub fn check_expr(sess: Session,\n       }\n       _ => ()\n     }\n-    visit::visit_expr(e, is_const, v);\n+    visit::visit_expr(e, (is_const, v));\n }\n \n // Make sure a const item doesn't recursively refer to itself\n@@ -223,26 +223,26 @@ pub fn check_item_recursion(sess: Session,\n         visit_expr: visit_expr,\n         .. *visit::default_visitor()\n     });\n-    (visitor.visit_item)(it, env, visitor);\n+    (visitor.visit_item)(it, (env, visitor));\n \n-    fn visit_item(it: @item, env: env, v: visit::vt<env>) {\n+    fn visit_item(it: @item, (env, v): (env, visit::vt<env>)) {\n         if env.idstack.contains(&(it.id)) {\n             env.sess.span_fatal(env.root_it.span, \"recursive constant\");\n         }\n         env.idstack.push(it.id);\n-        visit::visit_item(it, env, v);\n+        visit::visit_item(it, (env, v));\n         env.idstack.pop();\n     }\n \n-    fn visit_expr(e: @expr, env: env, v: visit::vt<env>) {\n+    fn visit_expr(e: @expr, (env, v): (env, visit::vt<env>)) {\n         match e.node {\n           expr_path(*) => {\n             match env.def_map.find(&e.id) {\n               Some(&def_const(def_id)) => {\n                 if ast_util::is_local(def_id) {\n                   match env.ast_map.get_copy(&def_id.node) {\n                     ast_map::node_item(it, _) => {\n-                      (v.visit_item)(it, env, v);\n+                      (v.visit_item)(it, (env, v));\n                     }\n                     _ => fail!(\"const not bound to an item\")\n                   }\n@@ -253,6 +253,6 @@ pub fn check_item_recursion(sess: Session,\n           }\n           _ => ()\n         }\n-        visit::visit_expr(e, env, v);\n+        visit::visit_expr(e, (env, v));\n     }\n }"}, {"sha": "2ed7b7adecc1ac0881b5b743427da50eea40a39c", "filename": "src/librustc/middle/check_loop.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs?ref=df483e82e7bcac0f36eff91145d5ac1c019f5078", "patch": "@@ -21,36 +21,36 @@ pub struct Context {\n \n pub fn check_crate(tcx: ty::ctxt, crate: @crate) {\n     visit::visit_crate(crate,\n-                       Context { in_loop: false, can_ret: true },\n+                       (Context { in_loop: false, can_ret: true },\n                        visit::mk_vt(@visit::Visitor {\n-        visit_item: |i, _cx, v| {\n-            visit::visit_item(i, Context {\n+        visit_item: |i, (_cx, v)| {\n+            visit::visit_item(i, (Context {\n                                     in_loop: false,\n                                     can_ret: true\n-                                 }, v);\n+                                 }, v));\n         },\n-        visit_expr: |e: @expr, cx: Context, v: visit::vt<Context>| {\n+        visit_expr: |e: @expr, (cx, v): (Context, visit::vt<Context>)| {\n             match e.node {\n               expr_while(e, ref b) => {\n-                (v.visit_expr)(e, cx, v);\n-                (v.visit_block)(b, Context { in_loop: true,.. cx }, v);\n+                (v.visit_expr)(e, (cx, v));\n+                (v.visit_block)(b, (Context { in_loop: true,.. cx }, v));\n               }\n               expr_loop(ref b, _) => {\n-                (v.visit_block)(b, Context { in_loop: true,.. cx }, v);\n+                (v.visit_block)(b, (Context { in_loop: true,.. cx }, v));\n               }\n               expr_fn_block(_, ref b) => {\n-                (v.visit_block)(b, Context {\n+                (v.visit_block)(b, (Context {\n                                          in_loop: false,\n                                          can_ret: false\n-                                      }, v);\n+                                      }, v));\n               }\n               expr_loop_body(@expr {node: expr_fn_block(_, ref b), _}) => {\n                 let sigil = ty::ty_closure_sigil(ty::expr_ty(tcx, e));\n                 let blk = (sigil == BorrowedSigil);\n-                (v.visit_block)(b, Context {\n+                (v.visit_block)(b, (Context {\n                                          in_loop: true,\n                                          can_ret: blk\n-                                     }, v);\n+                                     }, v));\n               }\n               expr_break(_) => {\n                 if !cx.in_loop {\n@@ -66,11 +66,11 @@ pub fn check_crate(tcx: ty::ctxt, crate: @crate) {\n                 if !cx.can_ret {\n                     tcx.sess.span_err(e.span, \"`return` in block function\");\n                 }\n-                visit::visit_expr_opt(oe, cx, v);\n+                visit::visit_expr_opt(oe, (cx, v));\n               }\n-              _ => visit::visit_expr(e, cx, v)\n+              _ => visit::visit_expr(e, (cx, v))\n             }\n         },\n         .. *visit::default_visitor()\n-    }));\n+    })));\n }"}, {"sha": "d32882a2f49558356cdf71863a567fde027bb969", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=df483e82e7bcac0f36eff91145d5ac1c019f5078", "patch": "@@ -41,13 +41,13 @@ pub fn check_crate(tcx: ty::ctxt,\n     let cx = @MatchCheckCtxt {tcx: tcx,\n                               method_map: method_map,\n                               moves_map: moves_map};\n-    visit::visit_crate(crate, (), visit::mk_vt(@visit::Visitor {\n-        visit_expr: |a,b,c| check_expr(cx, a, b, c),\n-        visit_local: |a,b,c| check_local(cx, a, b, c),\n-        visit_fn: |kind, decl, body, sp, id, e, v|\n-            check_fn(cx, kind, decl, body, sp, id, e, v),\n+    visit::visit_crate(crate, ((), visit::mk_vt(@visit::Visitor {\n+        visit_expr: |a,b| check_expr(cx, a, b),\n+        visit_local: |a,b| check_local(cx, a, b),\n+        visit_fn: |kind, decl, body, sp, id, (e, v)|\n+            check_fn(cx, kind, decl, body, sp, id, (e, v)),\n         .. *visit::default_visitor::<()>()\n-    }));\n+    })));\n     tcx.sess.abort_if_errors();\n }\n \n@@ -59,8 +59,8 @@ pub fn expr_is_non_moving_lvalue(cx: @MatchCheckCtxt, expr: @expr) -> bool {\n     !cx.moves_map.contains(&expr.id)\n }\n \n-pub fn check_expr(cx: @MatchCheckCtxt, ex: @expr, s: (), v: visit::vt<()>) {\n-    visit::visit_expr(ex, s, v);\n+pub fn check_expr(cx: @MatchCheckCtxt, ex: @expr, (s, v): ((), visit::vt<()>)) {\n+    visit::visit_expr(ex, (s, v));\n     match ex.node {\n       expr_match(scrut, ref arms) => {\n         // First, check legality of move bindings.\n@@ -751,9 +751,9 @@ pub fn default(cx: @MatchCheckCtxt, r: &[@pat]) -> Option<~[@pat]> {\n \n pub fn check_local(cx: @MatchCheckCtxt,\n                    loc: @local,\n-                   s: (),\n-                   v: visit::vt<()>) {\n-    visit::visit_local(loc, s, v);\n+                   (s, v): ((),\n+                            visit::vt<()>)) {\n+    visit::visit_local(loc, (s, v));\n     if is_refutable(cx, loc.node.pat) {\n         cx.tcx.sess.span_err(loc.node.pat.span,\n                              \"refutable pattern in local binding\");\n@@ -773,9 +773,9 @@ pub fn check_fn(cx: @MatchCheckCtxt,\n                 body: &blk,\n                 sp: span,\n                 id: node_id,\n-                s: (),\n-                v: visit::vt<()>) {\n-    visit::visit_fn(kind, decl, body, sp, id, s, v);\n+                (s, v): ((),\n+                         visit::vt<()>)) {\n+    visit::visit_fn(kind, decl, body, sp, id, (s, v));\n     for decl.inputs.each |input| {\n         if is_refutable(cx, input.pat) {\n             cx.tcx.sess.span_err(input.pat.span,"}, {"sha": "a24faf91021e29063efa84399bedca8652acb9f4", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=df483e82e7bcac0f36eff91145d5ac1c019f5078", "patch": "@@ -224,7 +224,7 @@ pub fn process_crate(crate: @ast::crate,\n         visit_expr_post: |e| { classify(e, tcx); },\n         .. *visit::default_simple_visitor()\n     });\n-    visit::visit_crate(crate, (), v);\n+    visit::visit_crate(crate, ((), v));\n     tcx.sess.abort_if_errors();\n }\n "}, {"sha": "0d817a5c629dc8e0230e68da36c108574dc5fc85", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=df483e82e7bcac0f36eff91145d5ac1c019f5078", "patch": "@@ -72,7 +72,7 @@ pub fn check_crate(tcx: ty::ctxt,\n     };\n \n     let visitor = visit::mk_vt(@visit::Visitor {\n-        visit_fn: |fn_kind, fn_decl, block, span, node_id, _, visitor| {\n+        visit_fn: |fn_kind, fn_decl, block, span, node_id, (_, visitor)| {\n             let (is_item_fn, is_unsafe_fn) = match *fn_kind {\n                 fk_item_fn(_, _, purity, _) => (true, purity == unsafe_fn),\n                 fk_method(_, _, method) => (true, method.purity == unsafe_fn),\n@@ -91,25 +91,25 @@ pub fn check_crate(tcx: ty::ctxt,\n                             block,\n                             span,\n                             node_id,\n-                            (),\n-                            visitor);\n+                            ((),\n+                             visitor));\n \n             context.unsafe_context = old_unsafe_context\n         },\n \n-        visit_block: |block, _, visitor| {\n+        visit_block: |block, (_, visitor)| {\n             let old_unsafe_context = context.unsafe_context;\n             if block.node.rules == unsafe_blk &&\n                     context.unsafe_context == SafeContext {\n                 context.unsafe_context = UnsafeBlock(block.node.id)\n             }\n \n-            visit::visit_block(block, (), visitor);\n+            visit::visit_block(block, ((), visitor));\n \n             context.unsafe_context = old_unsafe_context\n         },\n \n-        visit_expr: |expr, _, visitor| {\n+        visit_expr: |expr, (_, visitor)| {\n             match expr.node {\n                 expr_method_call(callee_id, _, _, _, _, _) => {\n                     let base_type = ty::node_id_to_type(tcx, callee_id);\n@@ -146,12 +146,12 @@ pub fn check_crate(tcx: ty::ctxt,\n                 _ => {}\n             }\n \n-            visit::visit_expr(expr, (), visitor)\n+            visit::visit_expr(expr, ((), visitor))\n         },\n \n         .. *visit::default_visitor()\n     });\n \n-    visit::visit_crate(crate, (), visitor)\n+    visit::visit_crate(crate, ((), visitor))\n }\n "}, {"sha": "a93aea983fbfec5c946ab8338cfa34433a1ac2a0", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=df483e82e7bcac0f36eff91145d5ac1c019f5078", "patch": "@@ -59,10 +59,10 @@ pub fn find_entry_point(session: Session, crate: @crate, ast_map: ast_map::map)\n         non_main_fns: ~[],\n     };\n \n-    visit_crate(crate, ctxt, mk_vt(@Visitor {\n-        visit_item: |item, ctxt, visitor| find_item(item, ctxt, visitor),\n+    visit_crate(crate, (ctxt, mk_vt(@Visitor {\n+        visit_item: |item, (ctxt, visitor)| find_item(item, ctxt, visitor),\n         .. *default_visitor()\n-    }));\n+    })));\n \n     configure_main(ctxt);\n }\n@@ -114,7 +114,7 @@ fn find_item(item: @item, ctxt: @mut EntryContext, visitor: EntryVisitor) {\n         _ => ()\n     }\n \n-    visit_item(item, ctxt, visitor);\n+    visit_item(item, (ctxt, visitor));\n }\n \n fn configure_main(ctxt: @mut EntryContext) {"}, {"sha": "e18143042b0eeab414b2b540a2fb3af1814bebcd", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=df483e82e7bcac0f36eff91145d5ac1c019f5078", "patch": "@@ -40,12 +40,12 @@ fn collect_freevars(def_map: resolve::DefMap, blk: &ast::blk)\n     let seen = @mut HashMap::new();\n     let refs = @mut ~[];\n \n-    fn ignore_item(_i: @ast::item, _depth: int, _v: visit::vt<int>) { }\n+    fn ignore_item(_i: @ast::item, (_depth, _v): (int, visit::vt<int>)) { }\n \n-    let walk_expr: @fn(expr: @ast::expr, depth: int, v: visit::vt<int>) =\n-        |expr, depth, v| {\n+    let walk_expr: @fn(expr: @ast::expr, (int, visit::vt<int>)) =\n+        |expr, (depth, v)| {\n             match expr.node {\n-              ast::expr_fn_block(*) => visit::visit_expr(expr, depth + 1, v),\n+              ast::expr_fn_block(*) => visit::visit_expr(expr, (depth + 1, v)),\n               ast::expr_path(*) | ast::expr_self => {\n                   let mut i = 0;\n                   match def_map.find(&expr.id) {\n@@ -72,14 +72,14 @@ fn collect_freevars(def_map: resolve::DefMap, blk: &ast::blk)\n                     }\n                   }\n               }\n-              _ => visit::visit_expr(expr, depth, v)\n+              _ => visit::visit_expr(expr, (depth, v))\n             }\n         };\n \n     let v = visit::mk_vt(@visit::Visitor {visit_item: ignore_item,\n                                           visit_expr: walk_expr,\n                                           .. *visit::default_visitor()});\n-    (v.visit_block)(blk, 1, v);\n+    (v.visit_block)(blk, (1, v));\n     return @/*bad*/copy *refs;\n }\n \n@@ -105,7 +105,7 @@ pub fn annotate_freevars(def_map: resolve::DefMap, crate: @ast::crate) ->\n         visit::mk_simple_visitor(@visit::SimpleVisitor {\n             visit_fn: walk_fn,\n             .. *visit::default_simple_visitor()});\n-    visit::visit_crate(crate, (), visitor);\n+    visit::visit_crate(crate, ((), visitor));\n \n     return freevars;\n }"}, {"sha": "a4cac540a7e787025888c067846fde5a358733b3", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=df483e82e7bcac0f36eff91145d5ac1c019f5078", "patch": "@@ -78,7 +78,7 @@ pub fn check_crate(tcx: ty::ctxt,\n         visit_block: check_block,\n         .. *visit::default_visitor()\n     });\n-    visit::visit_crate(crate, ctx, visit);\n+    visit::visit_crate(crate, (ctx, visit));\n     tcx.sess.abort_if_errors();\n }\n \n@@ -114,11 +114,11 @@ fn check_struct_safe_for_destructor(cx: Context,\n     }\n }\n \n-fn check_block(block: &blk, cx: Context, visitor: visit::vt<Context>) {\n-    visit::visit_block(block, cx, visitor);\n+fn check_block(block: &blk, (cx, visitor): (Context, visit::vt<Context>)) {\n+    visit::visit_block(block, (cx, visitor));\n }\n \n-fn check_item(item: @item, cx: Context, visitor: visit::vt<Context>) {\n+fn check_item(item: @item, (cx, visitor): (Context, visit::vt<Context>)) {\n     // If this is a destructor, check kinds.\n     if !attrs_contains_name(item.attrs, \"unsafe_destructor\") {\n         match item.node {\n@@ -157,7 +157,7 @@ fn check_item(item: @item, cx: Context, visitor: visit::vt<Context>) {\n     }\n \n     let cx = Context { current_item: item.id, ..cx };\n-    visit::visit_item(item, cx, visitor);\n+    visit::visit_item(item, (cx, visitor));\n }\n \n // Yields the appropriate function to check the kind of closed over\n@@ -224,8 +224,8 @@ fn check_fn(\n     body: &blk,\n     sp: span,\n     fn_id: node_id,\n-    cx: Context,\n-    v: visit::vt<Context>) {\n+    (cx, v): (Context,\n+              visit::vt<Context>)) {\n \n     // Check kinds on free variables:\n     do with_appropriate_checker(cx, fn_id) |chk| {\n@@ -234,10 +234,10 @@ fn check_fn(\n         }\n     }\n \n-    visit::visit_fn(fk, decl, body, sp, fn_id, cx, v);\n+    visit::visit_fn(fk, decl, body, sp, fn_id, (cx, v));\n }\n \n-pub fn check_expr(e: @expr, cx: Context, v: visit::vt<Context>) {\n+pub fn check_expr(e: @expr, (cx, v): (Context, visit::vt<Context>)) {\n     debug!(\"kind::check_expr(%s)\", expr_to_str(e, cx.tcx.sess.intr()));\n \n     // Handle any kind bounds on type parameters\n@@ -303,10 +303,10 @@ pub fn check_expr(e: @expr, cx: Context, v: visit::vt<Context>) {\n         }\n         _ => {}\n     }\n-    visit::visit_expr(e, cx, v);\n+    visit::visit_expr(e, (cx, v));\n }\n \n-fn check_ty(aty: @Ty, cx: Context, v: visit::vt<Context>) {\n+fn check_ty(aty: @Ty, (cx, v): (Context, visit::vt<Context>)) {\n     match aty.node {\n       ty_path(_, id) => {\n           let r = cx.tcx.node_type_substs.find(&id);\n@@ -321,7 +321,7 @@ fn check_ty(aty: @Ty, cx: Context, v: visit::vt<Context>) {\n       }\n       _ => {}\n     }\n-    visit::visit_ty(aty, cx, v);\n+    visit::visit_ty(aty, (cx, v));\n }\n \n pub fn check_bounds(cx: Context,"}, {"sha": "dc5f86ea0defb15752a868968da0524bbdc1c6ee", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=df483e82e7bcac0f36eff91145d5ac1c019f5078", "patch": "@@ -389,7 +389,7 @@ impl LanguageItemCollector {\n \n     pub fn collect_local_language_items(&mut self) {\n         let this: *mut LanguageItemCollector = &mut *self;\n-        visit_crate(self.crate, (), mk_simple_visitor(@SimpleVisitor {\n+        visit_crate(self.crate, ((), mk_simple_visitor(@SimpleVisitor {\n             visit_item: |item| {\n                 for item.attrs.each |attribute| {\n                     unsafe {\n@@ -401,7 +401,7 @@ impl LanguageItemCollector {\n                 }\n             },\n             .. *default_simple_visitor()\n-        }));\n+        })));\n     }\n \n     pub fn collect_external_language_items(&mut self) {"}, {"sha": "bb6a623128854f417f6130e0f01fa11c8ae73c8e", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=df483e82e7bcac0f36eff91145d5ac1c019f5078", "patch": "@@ -474,12 +474,12 @@ impl Context {\n         match n {\n             Item(it) => {\n                 for self.visitors.each |&(orig, stopping)| {\n-                    (orig.visit_item)(it, self, stopping);\n+                    (orig.visit_item)(it, (self, stopping));\n                 }\n             }\n             Crate(c) => {\n                 for self.visitors.each |&(_, stopping)| {\n-                    visit::visit_crate(c, self, stopping);\n+                    visit::visit_crate(c, (self, stopping));\n                 }\n             }\n             // Can't use visit::visit_method_helper because the\n@@ -489,7 +489,7 @@ impl Context {\n                 let fk = visit::fk_method(copy m.ident, &m.generics, m);\n                 for self.visitors.each |&(orig, stopping)| {\n                     (orig.visit_fn)(&fk, &m.decl, &m.body, m.span, m.id,\n-                                    self, stopping);\n+                                    (self, stopping));\n                 }\n             }\n         }\n@@ -535,23 +535,23 @@ pub fn each_lint(sess: session::Session,\n // lint visitor.\n fn item_stopping_visitor<E: Copy>(outer: visit::vt<E>) -> visit::vt<E> {\n     visit::mk_vt(@visit::Visitor {\n-        visit_item: |_i, _e, _v| { },\n-        visit_fn: |fk, fd, b, s, id, e, v| {\n+        visit_item: |_i, (_e, _v)| { },\n+        visit_fn: |fk, fd, b, s, id, (e, v)| {\n             match *fk {\n                 visit::fk_method(*) => {}\n-                _ => (outer.visit_fn)(fk, fd, b, s, id, e, v)\n+                _ => (outer.visit_fn)(fk, fd, b, s, id, (e, v))\n             }\n         },\n     .. **(ty_stopping_visitor(outer))})\n }\n \n fn ty_stopping_visitor<E>(v: visit::vt<E>) -> visit::vt<E> {\n-    visit::mk_vt(@visit::Visitor {visit_ty: |_t, _e, _v| { },.. **v})\n+    visit::mk_vt(@visit::Visitor {visit_ty: |_t, (_e, _v)| { },.. **v})\n }\n \n fn lint_while_true() -> visit::vt<@mut Context> {\n     visit::mk_vt(@visit::Visitor {\n-        visit_expr: |e, cx: @mut Context, vt| {\n+        visit_expr: |e, (cx, vt): (@mut Context, visit::vt<@mut Context>)| {\n             match e.node {\n                 ast::expr_while(cond, _) => {\n                     match cond.node {\n@@ -567,7 +567,7 @@ fn lint_while_true() -> visit::vt<@mut Context> {\n                 }\n                 _ => ()\n             }\n-            visit::visit_expr(e, cx, vt);\n+            visit::visit_expr(e, (cx, vt));\n         },\n         .. *visit::default_visitor()\n     })\n@@ -673,7 +673,7 @@ fn lint_type_limits() -> visit::vt<@mut Context> {\n     }\n \n     visit::mk_vt(@visit::Visitor {\n-        visit_expr: |e, cx: @mut Context, vt| {\n+        visit_expr: |e, (cx, vt): (@mut Context, visit::vt<@mut Context>)| {\n             match e.node {\n                 ast::expr_binary(_, ref binop, @ref l, @ref r) => {\n                     if is_comparison(*binop)\n@@ -684,7 +684,7 @@ fn lint_type_limits() -> visit::vt<@mut Context> {\n                 }\n                 _ => ()\n             }\n-            visit::visit_expr(e, cx, vt);\n+            visit::visit_expr(e, (cx, vt));\n         },\n \n         .. *visit::default_visitor()\n@@ -809,18 +809,18 @@ fn check_item_heap(cx: &Context, it: @ast::item) {\n \n fn lint_heap() -> visit::vt<@mut Context> {\n     visit::mk_vt(@visit::Visitor {\n-        visit_expr: |e, cx: @mut Context, vt| {\n+        visit_expr: |e, (cx, vt): (@mut Context, visit::vt<@mut Context>)| {\n             let ty = ty::expr_ty(cx.tcx, e);\n             check_type(cx, e.span, ty);\n-            visit::visit_expr(e, cx, vt);\n+            visit::visit_expr(e, (cx, vt));\n         },\n         .. *visit::default_visitor()\n     })\n }\n \n fn lint_path_statement() -> visit::vt<@mut Context> {\n     visit::mk_vt(@visit::Visitor {\n-        visit_stmt: |s, cx: @mut Context, vt| {\n+        visit_stmt: |s, (cx, vt): (@mut Context, visit::vt<@mut Context>)| {\n             match s.node {\n                 ast::stmt_semi(\n                     @ast::expr { node: ast::expr_path(_), _ },\n@@ -831,7 +831,7 @@ fn lint_path_statement() -> visit::vt<@mut Context> {\n                 }\n                 _ => ()\n             }\n-            visit::visit_stmt(s, cx, vt);\n+            visit::visit_stmt(s, (cx, vt));\n         },\n         .. *visit::default_visitor()\n     })\n@@ -871,7 +871,7 @@ fn check_item_non_camel_case_types(cx: &Context, it: @ast::item) {\n \n fn lint_unused_unsafe() -> visit::vt<@mut Context> {\n     visit::mk_vt(@visit::Visitor {\n-        visit_expr: |e, cx: @mut Context, vt| {\n+        visit_expr: |e, (cx, vt): (@mut Context, visit::vt<@mut Context>)| {\n             match e.node {\n                 ast::expr_block(ref blk) if blk.node.rules == ast::unsafe_blk => {\n                     if !cx.tcx.used_unsafe.contains(&blk.node.id) {\n@@ -881,7 +881,7 @@ fn lint_unused_unsafe() -> visit::vt<@mut Context> {\n                 }\n                 _ => ()\n             }\n-            visit::visit_expr(e, cx, vt);\n+            visit::visit_expr(e, (cx, vt));\n         },\n         .. *visit::default_visitor()\n     })\n@@ -914,30 +914,30 @@ fn lint_unused_mut() -> visit::vt<@mut Context> {\n     }\n \n     visit::mk_vt(@visit::Visitor {\n-        visit_local: |l, cx: @mut Context, vt| {\n+        visit_local: |l, (cx, vt): (@mut Context, visit::vt<@mut Context>)| {\n             if l.node.is_mutbl {\n                 check_pat(cx, l.node.pat);\n             }\n-            visit::visit_local(l, cx, vt);\n+            visit::visit_local(l, (cx, vt));\n         },\n-        visit_fn: |a, fd, b, c, d, cx, vt| {\n+        visit_fn: |a, fd, b, c, d, (cx, vt)| {\n             visit_fn_decl(cx, fd);\n-            visit::visit_fn(a, fd, b, c, d, cx, vt);\n+            visit::visit_fn(a, fd, b, c, d, (cx, vt));\n         },\n-        visit_ty_method: |tm, cx, vt| {\n+        visit_ty_method: |tm, (cx, vt)| {\n             visit_fn_decl(cx, &tm.decl);\n-            visit::visit_ty_method(tm, cx, vt);\n+            visit::visit_ty_method(tm, (cx, vt));\n         },\n-        visit_struct_method: |sm, cx, vt| {\n+        visit_struct_method: |sm, (cx, vt)| {\n             visit_fn_decl(cx, &sm.decl);\n-            visit::visit_struct_method(sm, cx, vt);\n+            visit::visit_struct_method(sm, (cx, vt));\n         },\n-        visit_trait_method: |tm, cx, vt| {\n+        visit_trait_method: |tm, (cx, vt)| {\n             match *tm {\n                 ast::required(ref tm) => visit_fn_decl(cx, &tm.decl),\n                 ast::provided(m) => visit_fn_decl(cx, &m.decl)\n             }\n-            visit::visit_trait_method(tm, cx, vt);\n+            visit::visit_trait_method(tm, (cx, vt));\n         },\n         .. *visit::default_visitor()\n     })\n@@ -987,9 +987,9 @@ fn lint_unnecessary_allocations() -> visit::vt<@mut Context> {\n     }\n \n     visit::mk_vt(@visit::Visitor {\n-        visit_expr: |e, cx: @mut Context, vt| {\n+        visit_expr: |e, (cx, vt): (@mut Context, visit::vt<@mut Context>)| {\n             check(cx, e);\n-            visit::visit_expr(e, cx, vt);\n+            visit::visit_expr(e, (cx, vt));\n         },\n         .. *visit::default_visitor()\n     })\n@@ -1011,23 +1011,23 @@ fn lint_missing_doc() -> visit::vt<@mut Context> {\n     }\n \n     visit::mk_vt(@visit::Visitor {\n-        visit_struct_method: |m, cx, vt| {\n+        visit_struct_method: |m, (cx, vt)| {\n             if m.vis == ast::public {\n                 check_attrs(cx, m.attrs, m.span,\n                             \"missing documentation for a method\");\n             }\n-            visit::visit_struct_method(m, cx, vt);\n+            visit::visit_struct_method(m, (cx, vt));\n         },\n \n-        visit_ty_method: |m, cx, vt| {\n+        visit_ty_method: |m, (cx, vt)| {\n             // All ty_method objects are linted about because they're part of a\n             // trait (no visibility)\n             check_attrs(cx, m.attrs, m.span,\n                         \"missing documentation for a method\");\n-            visit::visit_ty_method(m, cx, vt);\n+            visit::visit_ty_method(m, (cx, vt));\n         },\n \n-        visit_fn: |fk, d, b, sp, id, cx, vt| {\n+        visit_fn: |fk, d, b, sp, id, (cx, vt)| {\n             // Only warn about explicitly public methods. Soon implicit\n             // public-ness will hopefully be going away.\n             match *fk {\n@@ -1042,10 +1042,10 @@ fn lint_missing_doc() -> visit::vt<@mut Context> {\n \n                 _ => {}\n             }\n-            visit::visit_fn(fk, d, b, sp, id, cx, vt);\n+            visit::visit_fn(fk, d, b, sp, id, (cx, vt));\n         },\n \n-        visit_item: |it, cx, vt| {\n+        visit_item: |it, (cx, vt)| {\n             match it.node {\n                 // Go ahead and match the fields here instead of using\n                 // visit_struct_field while we have access to the enclosing\n@@ -1077,7 +1077,7 @@ fn lint_missing_doc() -> visit::vt<@mut Context> {\n                 _ => {}\n             };\n \n-            visit::visit_item(it, cx, vt);\n+            visit::visit_item(it, (cx, vt));\n         },\n \n         .. *visit::default_visitor()\n@@ -1120,8 +1120,8 @@ pub fn check_crate(tcx: ty::ctxt, crate: @ast::crate) {\n     do cx.with_lint_attrs(crate.node.attrs) {\n         cx.process(Crate(crate));\n \n-        visit::visit_crate(crate, cx, visit::mk_vt(@visit::Visitor {\n-            visit_item: |it, cx: @mut Context, vt| {\n+        visit::visit_crate(crate, (cx, visit::mk_vt(@visit::Visitor {\n+            visit_item: |it, (cx, vt): (@mut Context, visit::vt<@mut Context>)| {\n                 do cx.with_lint_attrs(it.attrs) {\n                     match it.node {\n                         ast::item_impl(_, Some(*), _, _) => {\n@@ -1135,25 +1135,25 @@ pub fn check_crate(tcx: ty::ctxt, crate: @ast::crate) {\n                     check_item_heap(cx, it);\n \n                     cx.process(Item(it));\n-                    visit::visit_item(it, cx, vt);\n+                    visit::visit_item(it, (cx, vt));\n                     cx.in_trait_impl = false;\n                 }\n             },\n-            visit_fn: |fk, decl, body, span, id, cx, vt| {\n+            visit_fn: |fk, decl, body, span, id, (cx, vt)| {\n                 match *fk {\n                     visit::fk_method(_, _, m) => {\n                         do cx.with_lint_attrs(m.attrs) {\n                             cx.process(Method(m));\n-                            visit::visit_fn(fk, decl, body, span, id, cx, vt);\n+                            visit::visit_fn(fk, decl, body, span, id, (cx, vt));\n                         }\n                     }\n                     _ => {\n-                        visit::visit_fn(fk, decl, body, span, id, cx, vt);\n+                        visit::visit_fn(fk, decl, body, span, id, (cx, vt));\n                     }\n                 }\n             },\n             .. *visit::default_visitor()\n-        }));\n+        })));\n     }\n \n     // If we missed any lints added to the session, then there's a bug somewhere"}, {"sha": "b79eee9e7cafce9531854dc96294da4bd1ac6fed", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=df483e82e7bcac0f36eff91145d5ac1c019f5078", "patch": "@@ -163,7 +163,7 @@ pub fn check_crate(tcx: ty::ctxt,\n     let initial_maps = @mut IrMaps(tcx,\n                                    method_map,\n                                    capture_map);\n-    visit::visit_crate(crate, initial_maps, visitor);\n+    visit::visit_crate(crate, (initial_maps, visitor));\n     tcx.sess.abort_if_errors();\n }\n \n@@ -342,8 +342,8 @@ fn visit_fn(fk: &visit::fn_kind,\n             body: &blk,\n             sp: span,\n             id: node_id,\n-            this: @mut IrMaps,\n-            v: vt<@mut IrMaps>) {\n+            (this, v): (@mut IrMaps,\n+                        vt<@mut IrMaps>)) {\n     debug!(\"visit_fn: id=%d\", id);\n     let _i = ::util::common::indenter();\n \n@@ -381,7 +381,7 @@ fn visit_fn(fk: &visit::fn_kind,\n \n     // gather up the various local variables, significant expressions,\n     // and so forth:\n-    visit::visit_fn(fk, decl, body, sp, id, fn_maps, v);\n+    visit::visit_fn(fk, decl, body, sp, id, (fn_maps, v));\n \n     // Special nodes and variables:\n     // - exit_ln represents the end of the fn, either by return or fail\n@@ -405,12 +405,12 @@ fn visit_fn(fk: &visit::fn_kind,\n         visit_arm: check_arm,\n         .. *visit::default_visitor()\n     });\n-    (check_vt.visit_block)(body, lsets, check_vt);\n+    (check_vt.visit_block)(body, (lsets, check_vt));\n     lsets.check_ret(id, sp, fk, entry_ln);\n     lsets.warn_about_unused_args(decl, entry_ln);\n }\n \n-fn visit_local(local: @local, this: @mut IrMaps, vt: vt<@mut IrMaps>) {\n+fn visit_local(local: @local, (this, vt): (@mut IrMaps, vt<@mut IrMaps>)) {\n     let def_map = this.tcx.def_map;\n     do pat_util::pat_bindings(def_map, local.node.pat) |_bm, p_id, sp, path| {\n         debug!(\"adding local variable %d\", p_id);\n@@ -427,10 +427,10 @@ fn visit_local(local: @local, this: @mut IrMaps, vt: vt<@mut IrMaps>) {\n           kind: kind\n         }));\n     }\n-    visit::visit_local(local, this, vt);\n+    visit::visit_local(local, (this, vt));\n }\n \n-fn visit_arm(arm: &arm, this: @mut IrMaps, vt: vt<@mut IrMaps>) {\n+fn visit_arm(arm: &arm, (this, vt): (@mut IrMaps, vt<@mut IrMaps>)) {\n     let def_map = this.tcx.def_map;\n     for arm.pats.each |pat| {\n         do pat_util::pat_bindings(def_map, *pat) |bm, p_id, sp, path| {\n@@ -446,10 +446,10 @@ fn visit_arm(arm: &arm, this: @mut IrMaps, vt: vt<@mut IrMaps>) {\n             }));\n         }\n     }\n-    visit::visit_arm(arm, this, vt);\n+    visit::visit_arm(arm, (this, vt));\n }\n \n-fn visit_expr(expr: @expr, this: @mut IrMaps, vt: vt<@mut IrMaps>) {\n+fn visit_expr(expr: @expr, (this, vt): (@mut IrMaps, vt<@mut IrMaps>)) {\n     match expr.node {\n       // live nodes required for uses or definitions of variables:\n       expr_path(_) | expr_self => {\n@@ -458,7 +458,7 @@ fn visit_expr(expr: @expr, this: @mut IrMaps, vt: vt<@mut IrMaps>) {\n         if moves::moved_variable_node_id_from_def(def).is_some() {\n             this.add_live_node_for_node(expr.id, ExprNode(expr.span));\n         }\n-        visit::visit_expr(expr, this, vt);\n+        visit::visit_expr(expr, (this, vt));\n       }\n       expr_fn_block(*) => {\n         // Interesting control flow (for loops can contain labeled\n@@ -491,17 +491,17 @@ fn visit_expr(expr: @expr, this: @mut IrMaps, vt: vt<@mut IrMaps>) {\n         }\n         this.set_captures(expr.id, call_caps);\n \n-        visit::visit_expr(expr, this, vt);\n+        visit::visit_expr(expr, (this, vt));\n       }\n \n       // live nodes required for interesting control flow:\n       expr_if(*) | expr_match(*) | expr_while(*) | expr_loop(*) => {\n         this.add_live_node_for_node(expr.id, ExprNode(expr.span));\n-        visit::visit_expr(expr, this, vt);\n+        visit::visit_expr(expr, (this, vt));\n       }\n       expr_binary(_, op, _, _) if ast_util::lazy_binop(op) => {\n         this.add_live_node_for_node(expr.id, ExprNode(expr.span));\n-        visit::visit_expr(expr, this, vt);\n+        visit::visit_expr(expr, (this, vt));\n       }\n \n       // otherwise, live nodes are not required:\n@@ -513,7 +513,7 @@ fn visit_expr(expr: @expr, this: @mut IrMaps, vt: vt<@mut IrMaps>) {\n       expr_assign(*) | expr_assign_op(*) | expr_mac(*) |\n       expr_struct(*) | expr_repeat(*) | expr_paren(*) |\n       expr_inline_asm(*) => {\n-          visit::visit_expr(expr, this, vt);\n+          visit::visit_expr(expr, (this, vt));\n       }\n     }\n }\n@@ -1406,7 +1406,7 @@ impl Liveness {\n // _______________________________________________________________________\n // Checking for error conditions\n \n-fn check_local(local: @local, this: @Liveness, vt: vt<@Liveness>) {\n+fn check_local(local: @local, (this, vt): (@Liveness, vt<@Liveness>)) {\n     match local.node.init {\n       Some(_) => {\n         this.warn_about_unused_or_dead_vars_in_pat(local.node.pat);\n@@ -1432,34 +1432,34 @@ fn check_local(local: @local, this: @Liveness, vt: vt<@Liveness>) {\n       }\n     }\n \n-    visit::visit_local(local, this, vt);\n+    visit::visit_local(local, (this, vt));\n }\n \n-fn check_arm(arm: &arm, this: @Liveness, vt: vt<@Liveness>) {\n+fn check_arm(arm: &arm, (this, vt): (@Liveness, vt<@Liveness>)) {\n     do this.arm_pats_bindings(arm.pats) |ln, var, sp, id| {\n         this.warn_about_unused(sp, id, ln, var);\n     }\n-    visit::visit_arm(arm, this, vt);\n+    visit::visit_arm(arm, (this, vt));\n }\n \n-fn check_expr(expr: @expr, this: @Liveness, vt: vt<@Liveness>) {\n+fn check_expr(expr: @expr, (this, vt): (@Liveness, vt<@Liveness>)) {\n     match expr.node {\n       expr_assign(l, r) => {\n         this.check_lvalue(l, vt);\n-        (vt.visit_expr)(r, this, vt);\n+        (vt.visit_expr)(r, (this, vt));\n \n-        visit::visit_expr(expr, this, vt);\n+        visit::visit_expr(expr, (this, vt));\n       }\n \n       expr_assign_op(_, _, l, _) => {\n         this.check_lvalue(l, vt);\n \n-        visit::visit_expr(expr, this, vt);\n+        visit::visit_expr(expr, (this, vt));\n       }\n \n       expr_inline_asm(ref ia) => {\n         for ia.inputs.each |&(_, in)| {\n-          (vt.visit_expr)(in, this, vt);\n+          (vt.visit_expr)(in, (this, vt));\n         }\n \n         // Output operands must be lvalues\n@@ -1470,10 +1470,10 @@ fn check_expr(expr: @expr, this: @Liveness, vt: vt<@Liveness>) {\n             }\n             _ => {}\n           }\n-          (vt.visit_expr)(out, this, vt);\n+          (vt.visit_expr)(out, (this, vt));\n         }\n \n-        visit::visit_expr(expr, this, vt);\n+        visit::visit_expr(expr, (this, vt));\n       }\n \n       // no correctness conditions related to liveness\n@@ -1485,14 +1485,14 @@ fn check_expr(expr: @expr, this: @Liveness, vt: vt<@Liveness>) {\n       expr_again(*) | expr_lit(_) | expr_block(*) |\n       expr_mac(*) | expr_addr_of(*) | expr_struct(*) | expr_repeat(*) |\n       expr_paren(*) | expr_fn_block(*) | expr_path(*) | expr_self(*) => {\n-        visit::visit_expr(expr, this, vt);\n+        visit::visit_expr(expr, (this, vt));\n       }\n     }\n }\n \n fn check_fn(_fk: &visit::fn_kind, _decl: &fn_decl,\n             _body: &blk, _sp: span, _id: node_id,\n-            _self: @Liveness, _v: vt<@Liveness>) {\n+            (_self, _v): (@Liveness, vt<@Liveness>)) {\n     // do not check contents of nested fns\n }\n \n@@ -1556,7 +1556,7 @@ impl Liveness {\n           _ => {\n             // For other kinds of lvalues, no checks are required,\n             // and any embedded expressions are actually rvalues\n-            visit::visit_expr(expr, self, vt);\n+            visit::visit_expr(expr, (self, vt));\n           }\n        }\n     }"}, {"sha": "5c1ab038940eedb3f5e2f12122b96ee41e63df21", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=df483e82e7bcac0f36eff91145d5ac1c019f5078", "patch": "@@ -206,7 +206,7 @@ pub fn compute_moves(tcx: ty::ctxt,\n             moved_variables_set: @mut HashSet::new()\n         }\n     };\n-    visit::visit_crate(crate, visit_cx, visitor);\n+    visit::visit_crate(crate, (visit_cx, visitor));\n     return visit_cx.move_maps;\n }\n \n@@ -225,8 +225,8 @@ pub fn moved_variable_node_id_from_def(def: def) -> Option<node_id> {\n // Expressions\n \n fn compute_modes_for_expr(expr: @expr,\n-                          cx: VisitContext,\n-                          v: vt<VisitContext>)\n+                          (cx, v): (VisitContext,\n+                                    vt<VisitContext>))\n {\n     cx.consume_expr(expr, v);\n }\n@@ -265,7 +265,7 @@ impl VisitContext {\n         debug!(\"consume_block(blk.id=%?)\", blk.node.id);\n \n         for blk.node.stmts.each |stmt| {\n-            (visitor.visit_stmt)(*stmt, *self, visitor);\n+            (visitor.visit_stmt)(*stmt, (*self, visitor));\n         }\n \n         for blk.node.expr.iter().advance |tail_expr| {"}, {"sha": "11f9cc2bed124370232ab98eb0a014c4433666f2", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=df483e82e7bcac0f36eff91145d5ac1c019f5078", "patch": "@@ -38,8 +38,8 @@ use syntax::codemap::span;\n use syntax::parse::token;\n use syntax::visit;\n \n-pub fn check_crate(tcx: ty::ctxt,\n-                   method_map: &method_map,\n+pub fn check_crate<'mm>(tcx: ty::ctxt,\n+                   method_map: &'mm method_map,\n                    crate: @ast::crate) {\n     let privileged_items = @mut ~[];\n \n@@ -357,24 +357,24 @@ pub fn check_crate(tcx: ty::ctxt,\n     };\n \n     let visitor = visit::mk_vt(@visit::Visitor {\n-        visit_mod: |the_module, span, node_id, method_map, visitor| {\n+        visit_mod: |the_module, span, node_id, (method_map, visitor)| {\n             let n_added = add_privileged_items(the_module.items);\n \n-            visit::visit_mod(the_module, span, node_id, method_map, visitor);\n+            visit::visit_mod(the_module, span, node_id, (method_map, visitor));\n \n             for n_added.times {\n                 ignore(privileged_items.pop());\n             }\n         },\n-        visit_item: |item, method_map, visitor| {\n+        visit_item: |item, (method_map, visitor)| {\n             // Do not check privacy inside items with the resolve_unexported\n             // attribute. This is used for the test runner.\n             if !attr::contains_name(attr::attr_metas(/*bad*/copy item.attrs),\n                                     \"!resolve_unexported\") {\n-                visit::visit_item(item, method_map, visitor);\n+                visit::visit_item(item, (method_map, visitor));\n             }\n         },\n-        visit_block: |block, method_map, visitor| {\n+        visit_block: |block, (method_map, visitor)| {\n             // Gather up all the privileged items.\n             let mut n_added = 0;\n             for block.node.stmts.each |stmt| {\n@@ -391,13 +391,13 @@ pub fn check_crate(tcx: ty::ctxt,\n                 }\n             }\n \n-            visit::visit_block(block, method_map, visitor);\n+            visit::visit_block(block, (method_map, visitor));\n \n             for n_added.times {\n                 ignore(privileged_items.pop());\n             }\n         },\n-        visit_expr: |expr, method_map: &method_map, visitor| {\n+        visit_expr: |expr, (method_map, visitor): (&'mm method_map, visit::vt<&'mm method_map>)| {\n             match expr.node {\n                 expr_field(base, ident, _) => {\n                     // Method calls are now a special syntactic form,\n@@ -506,9 +506,9 @@ pub fn check_crate(tcx: ty::ctxt,\n                 _ => {}\n             }\n \n-            visit::visit_expr(expr, method_map, visitor);\n+            visit::visit_expr(expr, (method_map, visitor));\n         },\n-        visit_pat: |pattern, method_map, visitor| {\n+        visit_pat: |pattern, (method_map, visitor)| {\n             match pattern.node {\n                 pat_struct(_, ref fields, _) => {\n                     match ty::get(ty::pat_ty(tcx, pattern)).sty {\n@@ -558,9 +558,9 @@ pub fn check_crate(tcx: ty::ctxt,\n                 _ => {}\n             }\n \n-            visit::visit_pat(pattern, method_map, visitor);\n+            visit::visit_pat(pattern, (method_map, visitor));\n         },\n         .. *visit::default_visitor()\n     });\n-    visit::visit_crate(crate, method_map, visitor);\n+    visit::visit_crate(crate, (method_map, visitor));\n }"}, {"sha": "e514e504fe1bfb9b596bc19ec25bf635bda44181", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=df483e82e7bcac0f36eff91145d5ac1c019f5078", "patch": "@@ -335,43 +335,43 @@ pub fn parent_to_expr(cx: Context, child_id: ast::node_id, sp: span) {\n     }\n }\n \n-pub fn resolve_block(blk: &ast::blk, cx: Context, visitor: visit::vt<Context>) {\n+pub fn resolve_block(blk: &ast::blk, (cx, visitor): (Context, visit::vt<Context>)) {\n     // Record the parent of this block.\n     parent_to_expr(cx, blk.node.id, blk.span);\n \n     // Descend.\n     let new_cx = Context {var_parent: Some(blk.node.id),\n                           parent: Some(blk.node.id),\n                           ..cx};\n-    visit::visit_block(blk, new_cx, visitor);\n+    visit::visit_block(blk, (new_cx, visitor));\n }\n \n-pub fn resolve_arm(arm: &ast::arm, cx: Context, visitor: visit::vt<Context>) {\n-    visit::visit_arm(arm, cx, visitor);\n+pub fn resolve_arm(arm: &ast::arm, (cx, visitor): (Context, visit::vt<Context>)) {\n+    visit::visit_arm(arm, (cx, visitor));\n }\n \n-pub fn resolve_pat(pat: @ast::pat, cx: Context, visitor: visit::vt<Context>) {\n+pub fn resolve_pat(pat: @ast::pat, (cx, visitor): (Context, visit::vt<Context>)) {\n     assert_eq!(cx.var_parent, cx.parent);\n     parent_to_expr(cx, pat.id, pat.span);\n-    visit::visit_pat(pat, cx, visitor);\n+    visit::visit_pat(pat, (cx, visitor));\n }\n \n-pub fn resolve_stmt(stmt: @ast::stmt, cx: Context, visitor: visit::vt<Context>) {\n+pub fn resolve_stmt(stmt: @ast::stmt, (cx, visitor): (Context, visit::vt<Context>)) {\n     match stmt.node {\n         ast::stmt_decl(*) => {\n-            visit::visit_stmt(stmt, cx, visitor);\n+            visit::visit_stmt(stmt, (cx, visitor));\n         }\n         ast::stmt_expr(_, stmt_id) |\n         ast::stmt_semi(_, stmt_id) => {\n             parent_to_expr(cx, stmt_id, stmt.span);\n             let expr_cx = Context {parent: Some(stmt_id), ..cx};\n-            visit::visit_stmt(stmt, expr_cx, visitor);\n+            visit::visit_stmt(stmt, (expr_cx, visitor));\n         }\n         ast::stmt_mac(*) => cx.sess.bug(\"unexpanded macro\")\n     }\n }\n \n-pub fn resolve_expr(expr: @ast::expr, cx: Context, visitor: visit::vt<Context>) {\n+pub fn resolve_expr(expr: @ast::expr, (cx, visitor): (Context, visit::vt<Context>)) {\n     parent_to_expr(cx, expr.id, expr.span);\n \n     let mut new_cx = cx;\n@@ -407,30 +407,30 @@ pub fn resolve_expr(expr: @ast::expr, cx: Context, visitor: visit::vt<Context>)\n     };\n \n \n-    visit::visit_expr(expr, new_cx, visitor);\n+    visit::visit_expr(expr, (new_cx, visitor));\n }\n \n pub fn resolve_local(local: @ast::local,\n-                     cx: Context,\n-                     visitor: visit::vt<Context>) {\n+                     (cx, visitor) : (Context,\n+                                      visit::vt<Context>)) {\n     assert_eq!(cx.var_parent, cx.parent);\n     parent_to_expr(cx, local.node.id, local.span);\n-    visit::visit_local(local, cx, visitor);\n+    visit::visit_local(local, (cx, visitor));\n }\n \n-pub fn resolve_item(item: @ast::item, cx: Context, visitor: visit::vt<Context>) {\n+pub fn resolve_item(item: @ast::item, (cx, visitor): (Context, visit::vt<Context>)) {\n     // Items create a new outer block scope as far as we're concerned.\n     let new_cx = Context {var_parent: None, parent: None, ..cx};\n-    visit::visit_item(item, new_cx, visitor);\n+    visit::visit_item(item, (new_cx, visitor));\n }\n \n pub fn resolve_fn(fk: &visit::fn_kind,\n                   decl: &ast::fn_decl,\n                   body: &ast::blk,\n                   sp: span,\n                   id: ast::node_id,\n-                  cx: Context,\n-                  visitor: visit::vt<Context>) {\n+                  (cx, visitor): (Context,\n+                                  visit::vt<Context>)) {\n     debug!(\"region::resolve_fn(id=%?, \\\n                                span=%?, \\\n                                body.node.id=%?, \\\n@@ -450,7 +450,7 @@ pub fn resolve_fn(fk: &visit::fn_kind,\n         }\n         _ => {}\n     }\n-    visit::visit_fn_decl(decl, decl_cx, visitor);\n+    visit::visit_fn_decl(decl, (decl_cx, visitor));\n \n     // The body of the fn itself is either a root scope (top-level fn)\n     // or it continues with the inherited scope (closures).\n@@ -464,7 +464,7 @@ pub fn resolve_fn(fk: &visit::fn_kind,\n             cx\n         }\n     };\n-    (visitor.visit_block)(body, body_cx, visitor);\n+    (visitor.visit_block)(body, (body_cx, visitor));\n }\n \n pub fn resolve_crate(sess: Session,\n@@ -492,7 +492,7 @@ pub fn resolve_crate(sess: Session,\n         visit_local: resolve_local,\n         .. *visit::default_visitor()\n     });\n-    visit::visit_crate(crate, cx, visitor);\n+    visit::visit_crate(crate, (cx, visitor));\n     return region_maps;\n }\n \n@@ -717,10 +717,10 @@ impl DetermineRpCtxt {\n }\n \n pub fn determine_rp_in_item(item: @ast::item,\n-                            cx: @mut DetermineRpCtxt,\n-                            visitor: visit::vt<@mut DetermineRpCtxt>) {\n+                            (cx, visitor): (@mut DetermineRpCtxt,\n+                                            visit::vt<@mut DetermineRpCtxt>)) {\n     do cx.with(item.id, true) {\n-        visit::visit_item(item, cx, visitor);\n+        visit::visit_item(item, (cx, visitor));\n     }\n }\n \n@@ -729,32 +729,32 @@ pub fn determine_rp_in_fn(fk: &visit::fn_kind,\n                           body: &ast::blk,\n                           _: span,\n                           _: ast::node_id,\n-                          cx: @mut DetermineRpCtxt,\n-                          visitor: visit::vt<@mut DetermineRpCtxt>) {\n+                          (cx, visitor): (@mut DetermineRpCtxt,\n+                                          visit::vt<@mut DetermineRpCtxt>)) {\n     do cx.with(cx.item_id, false) {\n         do cx.with_ambient_variance(rv_contravariant) {\n             for decl.inputs.each |a| {\n-                (visitor.visit_ty)(a.ty, cx, visitor);\n+                (visitor.visit_ty)(a.ty, (cx, visitor));\n             }\n         }\n-        (visitor.visit_ty)(decl.output, cx, visitor);\n+        (visitor.visit_ty)(decl.output, (cx, visitor));\n         let generics = visit::generics_of_fn(fk);\n-        (visitor.visit_generics)(&generics, cx, visitor);\n-        (visitor.visit_block)(body, cx, visitor);\n+        (visitor.visit_generics)(&generics, (cx, visitor));\n+        (visitor.visit_block)(body, (cx, visitor));\n     }\n }\n \n pub fn determine_rp_in_ty_method(ty_m: &ast::ty_method,\n-                                 cx: @mut DetermineRpCtxt,\n-                                 visitor: visit::vt<@mut DetermineRpCtxt>) {\n+                                 (cx, visitor): (@mut DetermineRpCtxt,\n+                                                 visit::vt<@mut DetermineRpCtxt>)) {\n     do cx.with(cx.item_id, false) {\n-        visit::visit_ty_method(ty_m, cx, visitor);\n+        visit::visit_ty_method(ty_m, (cx, visitor));\n     }\n }\n \n pub fn determine_rp_in_ty(ty: @ast::Ty,\n-                          cx: @mut DetermineRpCtxt,\n-                          visitor: visit::vt<@mut DetermineRpCtxt>) {\n+                          (cx, visitor): (@mut DetermineRpCtxt,\n+                                          visit::vt<@mut DetermineRpCtxt>)) {\n     // we are only interested in types that will require an item to\n     // be region-parameterized.  if cx.item_id is zero, then this type\n     // is not a member of a type defn nor is it a constitutent of an\n@@ -838,14 +838,14 @@ pub fn determine_rp_in_ty(ty: @ast::Ty,\n     match ty.node {\n       ast::ty_box(mt) | ast::ty_uniq(mt) | ast::ty_vec(mt) |\n       ast::ty_rptr(_, mt) | ast::ty_ptr(mt) => {\n-        visit_mt(mt, cx, visitor);\n+        visit_mt(mt, (cx, visitor));\n       }\n \n       ast::ty_path(path, _) => {\n         // type parameters are---for now, anyway---always invariant\n         do cx.with_ambient_variance(rv_invariant) {\n             for path.types.each |tp| {\n-                (visitor.visit_ty)(*tp, cx, visitor);\n+                (visitor.visit_ty)(*tp, (cx, visitor));\n             }\n         }\n       }\n@@ -858,37 +858,37 @@ pub fn determine_rp_in_ty(ty: @ast::Ty,\n             // parameters are contravariant\n             do cx.with_ambient_variance(rv_contravariant) {\n                 for decl.inputs.each |a| {\n-                    (visitor.visit_ty)(a.ty, cx, visitor);\n+                    (visitor.visit_ty)(a.ty, (cx, visitor));\n                 }\n             }\n-            (visitor.visit_ty)(decl.output, cx, visitor);\n+            (visitor.visit_ty)(decl.output, (cx, visitor));\n         }\n       }\n \n       _ => {\n-        visit::visit_ty(ty, cx, visitor);\n+        visit::visit_ty(ty, (cx, visitor));\n       }\n     }\n \n     fn visit_mt(mt: ast::mt,\n-                cx: @mut DetermineRpCtxt,\n-                visitor: visit::vt<@mut DetermineRpCtxt>) {\n+                (cx, visitor): (@mut DetermineRpCtxt,\n+                                visit::vt<@mut DetermineRpCtxt>)) {\n         // mutability is invariant\n         if mt.mutbl == ast::m_mutbl {\n             do cx.with_ambient_variance(rv_invariant) {\n-                (visitor.visit_ty)(mt.ty, cx, visitor);\n+                (visitor.visit_ty)(mt.ty, (cx, visitor));\n             }\n         } else {\n-            (visitor.visit_ty)(mt.ty, cx, visitor);\n+            (visitor.visit_ty)(mt.ty, (cx, visitor));\n         }\n     }\n }\n \n pub fn determine_rp_in_struct_field(\n         cm: @ast::struct_field,\n-        cx: @mut DetermineRpCtxt,\n-        visitor: visit::vt<@mut DetermineRpCtxt>) {\n-    visit::visit_struct_field(cm, cx, visitor);\n+        (cx, visitor): (@mut DetermineRpCtxt,\n+                        visit::vt<@mut DetermineRpCtxt>)) {\n+    visit::visit_struct_field(cm, (cx, visitor));\n }\n \n pub fn determine_rp_in_crate(sess: Session,\n@@ -917,7 +917,7 @@ pub fn determine_rp_in_crate(sess: Session,\n         visit_struct_field: determine_rp_in_struct_field,\n         .. *visit::default_visitor()\n     });\n-    visit::visit_crate(crate, cx, visitor);\n+    visit::visit_crate(crate, (cx, visitor));\n \n     // Propagate indirect dependencies\n     //"}, {"sha": "73ac82ea54901bd20d99e03c64f45bae2de63191", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 64, "deletions": 61, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=df483e82e7bcac0f36eff91145d5ac1c019f5078", "patch": "@@ -905,27 +905,27 @@ impl Resolver {\n     pub fn build_reduced_graph(@mut self) {\n         let initial_parent =\n             ModuleReducedGraphParent(self.graph_root.get_module());\n-        visit_crate(self.crate, initial_parent, mk_vt(@Visitor {\n-            visit_item: |item, context, visitor|\n-                self.build_reduced_graph_for_item(item, context, visitor),\n+        visit_crate(self.crate, (initial_parent, mk_vt(@Visitor {\n+            visit_item: |item, (context, visitor)|\n+                self.build_reduced_graph_for_item(item, (context, visitor)),\n \n-            visit_foreign_item: |foreign_item, context, visitor|\n+            visit_foreign_item: |foreign_item, (context, visitor)|\n                 self.build_reduced_graph_for_foreign_item(foreign_item,\n-                                                             context,\n-                                                             visitor),\n+                                                             (context,\n+                                                              visitor)),\n \n-            visit_view_item: |view_item, context, visitor|\n+            visit_view_item: |view_item, (context, visitor)|\n                 self.build_reduced_graph_for_view_item(view_item,\n-                                                          context,\n-                                                          visitor),\n+                                                          (context,\n+                                                           visitor)),\n \n-            visit_block: |block, context, visitor|\n+            visit_block: |block, (context, visitor)|\n                 self.build_reduced_graph_for_block(block,\n-                                                      context,\n-                                                      visitor),\n+                                                      (context,\n+                                                       visitor)),\n \n             .. *default_visitor()\n-        }));\n+        })));\n     }\n \n     /// Returns the current module tracked by the reduced graph parent.\n@@ -1094,8 +1094,8 @@ impl Resolver {\n     /// Constructs the reduced graph for one item.\n     pub fn build_reduced_graph_for_item(@mut self,\n                                         item: @item,\n-                                        parent: ReducedGraphParent,\n-                                        visitor: vt<ReducedGraphParent>) {\n+                                        (parent, visitor): (ReducedGraphParent,\n+                                                            vt<ReducedGraphParent>)) {\n         let ident = item.ident;\n         let sp = item.span;\n         let privacy = visibility_to_privacy(item.vis);\n@@ -1116,7 +1116,7 @@ impl Resolver {\n                 let new_parent =\n                     ModuleReducedGraphParent(name_bindings.get_module());\n \n-                visit_mod(module_, sp, item.id, new_parent, visitor);\n+                visit_mod(module_, sp, item.id, (new_parent, visitor));\n             }\n \n             item_foreign_mod(ref fm) => {\n@@ -1143,7 +1143,7 @@ impl Resolver {\n                     anonymous => parent\n                 };\n \n-                visit_item(item, new_parent, visitor);\n+                visit_item(item, (new_parent, visitor));\n             }\n \n             // These items live in the value namespace.\n@@ -1160,7 +1160,7 @@ impl Resolver {\n \n                 let def = def_fn(local_def(item.id), purity);\n                 name_bindings.define_value(privacy, def, sp);\n-                visit_item(item, new_parent, visitor);\n+                visit_item(item, (new_parent, visitor));\n             }\n \n             // These items live in the type namespace.\n@@ -1180,13 +1180,13 @@ impl Resolver {\n                     (privacy, def_ty(local_def(item.id)), sp);\n \n                 for (*enum_definition).variants.each |variant| {\n-                    self.build_reduced_graph_for_variant(variant,\n+                    self.build_reduced_graph_for_variant(\n+                        variant,\n                         local_def(item.id),\n                         // inherited => privacy of the enum item\n                         variant_visibility_to_privacy(variant.node.vis,\n                                                       privacy == Public),\n-                        new_parent,\n-                        visitor);\n+                        (new_parent, visitor));\n                 }\n             }\n \n@@ -1213,7 +1213,7 @@ impl Resolver {\n                 // Record the def ID of this struct.\n                 self.structs.insert(local_def(item.id));\n \n-                visit_item(item, new_parent, visitor);\n+                visit_item(item, (new_parent, visitor));\n             }\n \n             item_impl(_, trait_ref_opt, ty, ref methods) => {\n@@ -1307,7 +1307,7 @@ impl Resolver {\n                     _ => {}\n                 }\n \n-                visit_item(item, parent, visitor);\n+                visit_item(item, (parent, visitor));\n             }\n \n             item_trait(_, _, ref methods) => {\n@@ -1397,7 +1397,7 @@ impl Resolver {\n                 }\n \n                 name_bindings.define_type(privacy, def_trait(def_id), sp);\n-                visit_item(item, new_parent, visitor);\n+                visit_item(item, (new_parent, visitor));\n             }\n \n             item_mac(*) => {\n@@ -1412,8 +1412,9 @@ impl Resolver {\n                                            variant: &variant,\n                                            item_id: def_id,\n                                            parent_privacy: Privacy,\n-                                           parent: ReducedGraphParent,\n-                                           _visitor: vt<ReducedGraphParent>) {\n+                                           (parent, _visitor):\n+                                           (ReducedGraphParent,\n+                                            vt<ReducedGraphParent>)) {\n         let ident = variant.node.name;\n         let (child, _) = self.add_child(ident, parent, ForbidDuplicateValues,\n                                         variant.span);\n@@ -1446,8 +1447,9 @@ impl Resolver {\n     /// of imports and use directives.\n     pub fn build_reduced_graph_for_view_item(@mut self,\n                                              view_item: @view_item,\n-                                             parent: ReducedGraphParent,\n-                                             _: vt<ReducedGraphParent>) {\n+                                             (parent, _):\n+                                             (ReducedGraphParent,\n+                                              vt<ReducedGraphParent>)) {\n         let privacy = visibility_to_privacy(view_item.vis);\n         match view_item.node {\n             view_item_use(ref view_paths) => {\n@@ -1542,9 +1544,9 @@ impl Resolver {\n     /// Constructs the reduced graph for one foreign item.\n     pub fn build_reduced_graph_for_foreign_item(@mut self,\n                                                 foreign_item: @foreign_item,\n-                                                parent: ReducedGraphParent,\n-                                                visitor:\n-                                                vt<ReducedGraphParent>) {\n+                                                (parent, visitor):\n+                                                (ReducedGraphParent,\n+                                                 vt<ReducedGraphParent>)) {\n         let name = foreign_item.ident;\n         let (name_bindings, new_parent) =\n             self.add_child(name, parent, ForbidDuplicateValues,\n@@ -1559,22 +1561,23 @@ impl Resolver {\n                     HasTypeParameters(\n                         generics, foreign_item.id, 0, NormalRibKind))\n                 {\n-                    visit_foreign_item(foreign_item, new_parent, visitor);\n+                    visit_foreign_item(foreign_item, (new_parent, visitor));\n                 }\n             }\n             foreign_item_const(*) => {\n                 let def = def_const(local_def(foreign_item.id));\n                 name_bindings.define_value(Public, def, foreign_item.span);\n \n-                visit_foreign_item(foreign_item, new_parent, visitor);\n+                visit_foreign_item(foreign_item, (new_parent, visitor));\n             }\n         }\n     }\n \n     pub fn build_reduced_graph_for_block(@mut self,\n                                          block: &blk,\n-                                         parent: ReducedGraphParent,\n-                                         visitor: vt<ReducedGraphParent>) {\n+                                         (parent, visitor):\n+                                         (ReducedGraphParent,\n+                                          vt<ReducedGraphParent>)) {\n         let new_parent;\n         if self.block_needs_anonymous_module(block) {\n             let block_id = block.node.id;\n@@ -1594,7 +1597,7 @@ impl Resolver {\n             new_parent = parent;\n         }\n \n-        visit_block(block, new_parent, visitor);\n+        visit_block(block, (new_parent, visitor));\n     }\n \n     pub fn handle_external_def(@mut self,\n@@ -3481,21 +3484,21 @@ impl Resolver {\n     pub fn resolve_crate(@mut self) {\n         debug!(\"(resolving crate) starting\");\n \n-        visit_crate(self.crate, (), mk_vt(@Visitor {\n-            visit_item: |item, _context, visitor|\n+        visit_crate(self.crate, ((), mk_vt(@Visitor {\n+            visit_item: |item, (_context, visitor)|\n                 self.resolve_item(item, visitor),\n-            visit_arm: |arm, _context, visitor|\n+            visit_arm: |arm, (_context, visitor)|\n                 self.resolve_arm(arm, visitor),\n-            visit_block: |block, _context, visitor|\n+            visit_block: |block, (_context, visitor)|\n                 self.resolve_block(block, visitor),\n-            visit_expr: |expr, _context, visitor|\n+            visit_expr: |expr, (_context, visitor)|\n                 self.resolve_expr(expr, visitor),\n-            visit_local: |local, _context, visitor|\n+            visit_local: |local, (_context, visitor)|\n                 self.resolve_local(local, visitor),\n-            visit_ty: |ty, _context, visitor|\n+            visit_ty: |ty, (_context, visitor)|\n                 self.resolve_type(ty, visitor),\n             .. *default_visitor()\n-        }));\n+        })));\n     }\n \n     pub fn resolve_item(@mut self, item: @item, visitor: ResolveVisitor) {\n@@ -3531,7 +3534,7 @@ impl Resolver {\n                 do self.with_type_parameter_rib(\n                     HasTypeParameters(\n                         generics, item.id, 0, NormalRibKind)) {\n-                    visit_item(item, (), visitor);\n+                    visit_item(item, ((), visitor));\n                 }\n             }\n \n@@ -3541,7 +3544,7 @@ impl Resolver {\n                                            NormalRibKind))\n                         || {\n \n-                    visit_item(item, (), visitor);\n+                    visit_item(item, ((), visitor));\n                 }\n             }\n \n@@ -3657,12 +3660,12 @@ impl Resolver {\n                                     HasTypeParameters(\n                                         generics, foreign_item.id, 0,\n                                         NormalRibKind),\n-                                    || visit_foreign_item(*foreign_item, (),\n-                                                          visitor));\n+                                    || visit_foreign_item(*foreign_item,\n+                                                          ((), visitor)));\n                             }\n                             foreign_item_const(_) => {\n-                                visit_foreign_item(*foreign_item, (),\n-                                                   visitor);\n+                                visit_foreign_item(*foreign_item,\n+                                                   ((), visitor));\n                             }\n                         }\n                     }\n@@ -3684,7 +3687,7 @@ impl Resolver {\n \n             item_const(*) => {\n                 self.with_constant_rib(|| {\n-                    visit_item(item, (), visitor);\n+                    visit_item(item, ((), visitor));\n                 });\n             }\n \n@@ -3993,7 +3996,7 @@ impl Resolver {\n                           visitor: ResolveVisitor) {\n         // Write the implementations in scope into the module metadata.\n         debug!(\"(resolving module) resolving module ID %d\", id);\n-        visit_mod(module_, span, id, (), visitor);\n+        visit_mod(module_, span, id, ((), visitor));\n     }\n \n     pub fn resolve_local(@mut self, local: @local, visitor: ResolveVisitor) {\n@@ -4080,7 +4083,7 @@ impl Resolver {\n         // pat_idents are variants\n         self.check_consistent_bindings(arm);\n \n-        visit_expr_opt(arm.guard, (), visitor);\n+        visit_expr_opt(arm.guard, ((), visitor));\n         self.resolve_block(&arm.body, visitor);\n \n         self.value_ribs.pop();\n@@ -4102,7 +4105,7 @@ impl Resolver {\n         }\n \n         // Descend into the block.\n-        visit_block(block, (), visitor);\n+        visit_block(block, ((), visitor));\n \n         // Move back up.\n         self.current_module = orig_module;\n@@ -4181,12 +4184,12 @@ impl Resolver {\n                 for c.bounds.each |bound| {\n                     self.resolve_type_parameter_bound(bound, visitor);\n                 }\n-                visit_ty(ty, (), visitor);\n+                visit_ty(ty, ((), visitor));\n             }\n \n             _ => {\n                 // Just resolve embedded types.\n-                visit_ty(ty, (), visitor);\n+                visit_ty(ty, ((), visitor));\n             }\n         }\n     }\n@@ -4949,7 +4952,7 @@ impl Resolver {\n                     }\n                 }\n \n-                visit_expr(expr, (), visitor);\n+                visit_expr(expr, ((), visitor));\n             }\n \n             expr_fn_block(ref fn_decl, ref block) => {\n@@ -4981,7 +4984,7 @@ impl Resolver {\n                     }\n                 }\n \n-                visit_expr(expr, (), visitor);\n+                visit_expr(expr, ((), visitor));\n             }\n \n             expr_loop(_, Some(label)) => {\n@@ -4993,7 +4996,7 @@ impl Resolver {\n                         rib.bindings.insert(label, def_like);\n                     }\n \n-                    visit_expr(expr, (), visitor);\n+                    visit_expr(expr, ((), visitor));\n                 }\n             }\n \n@@ -5029,7 +5032,7 @@ impl Resolver {\n             }\n \n             _ => {\n-                visit_expr(expr, (), visitor);\n+                visit_expr(expr, ((), visitor));\n             }\n         }\n     }\n@@ -5266,7 +5269,7 @@ impl Resolver {\n             visit_view_item: |vi| self.check_for_item_unused_imports(vi),\n             .. *default_simple_visitor()\n         });\n-        visit_crate(self.crate, (), vt);\n+        visit_crate(self.crate, ((), vt));\n     }\n \n     pub fn check_for_item_unused_imports(&mut self, vi: @view_item) {"}, {"sha": "1a6029917895ac2f09d9466355ccf2dc654832f4", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=df483e82e7bcac0f36eff91145d5ac1c019f5078", "patch": "@@ -2629,11 +2629,11 @@ pub fn trans_constant(ccx: @CrateContext, it: @ast::item) {\n \n pub fn trans_constants(ccx: @CrateContext, crate: &ast::crate) {\n     visit::visit_crate(\n-        crate, (),\n+        crate, ((),\n         visit::mk_simple_visitor(@visit::SimpleVisitor {\n             visit_item: |a| trans_constant(ccx, a),\n             ..*visit::default_simple_visitor()\n-        }));\n+        })));\n }\n \n pub fn vp2i(cx: block, v: ValueRef) -> ValueRef {"}, {"sha": "42e31cb2e0024889d7110cc4a6ba9c65dd06e51d", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=df483e82e7bcac0f36eff91145d5ac1c019f5078", "patch": "@@ -434,18 +434,18 @@ pub fn trans_lang_call_with_type_params(bcx: block,\n \n pub fn body_contains_ret(body: &ast::blk) -> bool {\n     let cx = @mut false;\n-    visit::visit_block(body, cx, visit::mk_vt(@visit::Visitor {\n-        visit_item: |_i, _cx, _v| { },\n-        visit_expr: |e: @ast::expr, cx: @mut bool, v| {\n+    visit::visit_block(body, (cx, visit::mk_vt(@visit::Visitor {\n+        visit_item: |_i, (_cx, _v)| { },\n+        visit_expr: |e: @ast::expr, (cx, v): (@mut bool, visit::vt<@mut bool>)| {\n             if !*cx {\n                 match e.node {\n                   ast::expr_ret(_) => *cx = true,\n-                  _ => visit::visit_expr(e, cx, v),\n+                  _ => visit::visit_expr(e, (cx, v)),\n                 }\n             }\n         },\n         ..*visit::default_visitor()\n-    }));\n+    })));\n     *cx\n }\n "}, {"sha": "d30409ffb919fed15df23fab12ed424c229c7002", "filename": "src/librustc/middle/trans/reachable.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=df483e82e7bcac0f36eff91145d5ac1c019f5078", "patch": "@@ -143,17 +143,17 @@ fn traverse_public_item(cx: @mut ctx, item: @item) {\n         }\n       }\n       item_ty(t, _) => {\n-        traverse_ty(t, cx,\n-                    visit::mk_vt(@visit::Visitor {visit_ty: traverse_ty,\n-                                                  ..*visit::default_visitor()}))\n+        traverse_ty(t, (cx,\n+                        visit::mk_vt(@visit::Visitor {visit_ty: traverse_ty,\n+                                                      ..*visit::default_visitor()})))\n       }\n       item_const(*) |\n       item_enum(*) | item_trait(*) => (),\n       item_mac(*) => fail!(\"item macros unimplemented\")\n     }\n }\n \n-fn traverse_ty<'a>(ty: @Ty, cx: @mut ctx<'a>, v: visit::vt<@mut ctx<'a>>) {\n+fn traverse_ty<'a>(ty: @Ty, (cx, v): (@mut ctx<'a>, visit::vt<@mut ctx<'a>>)) {\n     {\n         let cx = &mut *cx; // FIXME(#6269) reborrow @mut to &mut\n         if cx.rmap.contains(&ty.id) { return; }\n@@ -170,16 +170,16 @@ fn traverse_ty<'a>(ty: @Ty, cx: @mut ctx<'a>, v: visit::vt<@mut ctx<'a>>) {\n           None    => { /* do nothing -- but should we fail here? */ }\n         }\n         for p.types.each |t| {\n-            (v.visit_ty)(*t, cx, v);\n+            (v.visit_ty)(*t, (cx, v));\n         }\n       }\n-      _ => visit::visit_ty(ty, cx, v)\n+      _ => visit::visit_ty(ty, (cx, v))\n     }\n }\n \n fn traverse_inline_body(cx: @mut ctx, body: &blk) {\n-    fn traverse_expr<'a>(e: @expr, cx: @mut ctx<'a>,\n-                         v: visit::vt<@mut ctx<'a>>) {\n+    fn traverse_expr<'a>(e: @expr, (cx, v): (@mut ctx<'a>,\n+                                             visit::vt<@mut ctx<'a>>)) {\n         match e.node {\n           expr_path(_) => {\n             match cx.tcx.def_map.find(&e.id) {\n@@ -210,31 +210,31 @@ fn traverse_inline_body(cx: @mut ctx, body: &blk) {\n           }\n           _ => ()\n         }\n-        visit::visit_expr(e, cx, v);\n+        visit::visit_expr(e, (cx, v));\n     }\n     // Don't ignore nested items: for example if a generic fn contains a\n     // generic impl (as in deque::create), we need to monomorphize the\n     // impl as well\n-    fn traverse_item(i: @item, cx: @mut ctx, _v: visit::vt<@mut ctx>) {\n+    fn traverse_item(i: @item, (cx, _v): (@mut ctx, visit::vt<@mut ctx>)) {\n       traverse_public_item(cx, i);\n     }\n-    visit::visit_block(body, cx, visit::mk_vt(@visit::Visitor {\n+    visit::visit_block(body, (cx, visit::mk_vt(@visit::Visitor {\n         visit_expr: traverse_expr,\n         visit_item: traverse_item,\n          ..*visit::default_visitor()\n-    }));\n+    })));\n }\n \n fn traverse_all_resources_and_impls(cx: @mut ctx, crate_mod: &_mod) {\n     visit::visit_mod(\n         crate_mod,\n         codemap::dummy_sp(),\n         0,\n-        cx,\n+        (cx,\n         visit::mk_vt(@visit::Visitor {\n-            visit_expr: |_e, _cx, _v| { },\n-            visit_item: |i, cx, v| {\n-                visit::visit_item(i, cx, v);\n+            visit_expr: |_e, (_cx, _v)| { },\n+            visit_item: |i, (cx, v)| {\n+                visit::visit_item(i, (cx, v));\n                 match i.node {\n                     item_impl(*) => {\n                         traverse_public_item(cx, i);\n@@ -243,5 +243,5 @@ fn traverse_all_resources_and_impls(cx: @mut ctx, crate_mod: &_mod) {\n                 }\n             },\n             ..*visit::default_visitor()\n-        }));\n+        })));\n }"}, {"sha": "b2b11d544c1b7d394e025a0a5bdbc19c272e91eb", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=df483e82e7bcac0f36eff91145d5ac1c019f5078", "patch": "@@ -382,26 +382,26 @@ pub fn mark_for_expr(cx: Context, e: @expr) {\n \n pub fn handle_body(cx: Context, body: &blk) {\n     let v = visit::mk_vt(@visit::Visitor {\n-        visit_expr: |e, cx, v| {\n-            visit::visit_expr(e, cx, v);\n+        visit_expr: |e, (cx, v)| {\n+            visit::visit_expr(e, (cx, v));\n             mark_for_expr(cx, e);\n         },\n-        visit_local: |l, cx, v| {\n-            visit::visit_local(l, cx, v);\n+        visit_local: |l, (cx, v)| {\n+            visit::visit_local(l, (cx, v));\n             node_type_needs(cx, use_repr, l.node.id);\n         },\n-        visit_pat: |p, cx, v| {\n-            visit::visit_pat(p, cx, v);\n+        visit_pat: |p, (cx, v)| {\n+            visit::visit_pat(p, (cx, v));\n             node_type_needs(cx, use_repr, p.id);\n         },\n-        visit_block: |b, cx, v| {\n-            visit::visit_block(b, cx, v);\n+        visit_block: |b, (cx, v)| {\n+            visit::visit_block(b, (cx, v));\n             for b.node.expr.iter().advance |e| {\n                 node_type_needs(cx, use_repr, e.id);\n             }\n         },\n-        visit_item: |_i, _cx, _v| { },\n+        visit_item: |_i, (_cx, _v)| { },\n         ..*visit::default_visitor()\n     });\n-    (v.visit_block)(body, cx, v);\n+    (v.visit_block)(body, (cx, v));\n }"}, {"sha": "18bc30c7fb31a9a5e0459a172dd4d59ae21367cd", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=df483e82e7bcac0f36eff91145d5ac1c019f5078", "patch": "@@ -290,7 +290,7 @@ pub fn check_item_types(ccx: @mut CrateCtxt, crate: @ast::crate) {\n         visit_item: |a| check_item(ccx, a),\n         .. *visit::default_simple_visitor()\n     });\n-    visit::visit_crate(crate, (), visit);\n+    visit::visit_crate(crate, ((), visit));\n }\n \n pub fn check_bare_fn(ccx: @mut CrateCtxt,\n@@ -469,8 +469,8 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n         }\n \n         // Add explicitly-declared locals.\n-        let visit_local: @fn(@ast::local, e: (), visit::vt<()>) =\n-                |local, e, v| {\n+        let visit_local: @fn(@ast::local, ((), visit::vt<()>)) =\n+                |local, (e, v)| {\n             let o_ty = match local.node.ty.node {\n               ast::ty_infer => None,\n               _ => Some(fcx.to_ty(local.node.ty))\n@@ -480,11 +480,11 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n                    fcx.pat_to_str(local.node.pat),\n                    fcx.infcx().ty_to_str(\n                        fcx.inh.locals.get_copy(&local.node.id)));\n-            visit::visit_local(local, e, v);\n+            visit::visit_local(local, (e, v));\n         };\n \n         // Add pattern bindings.\n-        let visit_pat: @fn(@ast::pat, e: (), visit::vt<()>) = |p, e, v| {\n+        let visit_pat: @fn(@ast::pat, ((), visit::vt<()>)) = |p, (e, v)| {\n             match p.node {\n               ast::pat_ident(_, path, _)\n                   if pat_util::pat_is_binding(fcx.ccx.tcx.def_map, p) => {\n@@ -496,24 +496,24 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n               }\n               _ => {}\n             }\n-            visit::visit_pat(p, e, v);\n+            visit::visit_pat(p, (e, v));\n         };\n \n-        let visit_block: @fn(&ast::blk, e: (), visit::vt<()>) = |b, e, v| {\n+        let visit_block: @fn(&ast::blk, ((), visit::vt<()>)) = |b, (e, v)| {\n             // non-obvious: the `blk` variable maps to region lb, so\n             // we have to keep this up-to-date.  This\n             // is... unfortunate.  It'd be nice to not need this.\n             do fcx.with_region_lb(b.node.id) {\n-                visit::visit_block(b, e, v);\n+                visit::visit_block(b, (e, v));\n             }\n         };\n \n         // Don't descend into fns and items\n         fn visit_fn(_fk: &visit::fn_kind, _decl: &ast::fn_decl,\n                     _body: &ast::blk, _sp: span,\n-                    _id: ast::node_id, _t: (), _v: visit::vt<()>) {\n+                    _id: ast::node_id, (_t,_v): ((), visit::vt<()>)) {\n         }\n-        fn visit_item(_i: @ast::item, _e: (), _v: visit::vt<()>) { }\n+        fn visit_item(_i: @ast::item, (_e,_v): ((), visit::vt<()>)) { }\n \n         let visit = visit::mk_vt(\n             @visit::Visitor {visit_local: visit_local,\n@@ -523,7 +523,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n                              visit_block: visit_block,\n                              ..*visit::default_visitor()});\n \n-        (visit.visit_block)(body, (), visit);\n+        (visit.visit_block)(body, ((), visit));\n     }\n }\n "}, {"sha": "63a13789194cb275df7a4fd625fcd4a5190fd610", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=df483e82e7bcac0f36eff91145d5ac1c019f5078", "patch": "@@ -140,7 +140,7 @@ pub fn regionck_expr(fcx: @mut FnCtxt, e: @ast::expr) {\n     if fcx.err_count_since_creation() == 0 {\n         // regionck assumes typeck succeeded\n         let v = regionck_visitor();\n-        (v.visit_expr)(e, rcx, v);\n+        (v.visit_expr)(e, (rcx, v));\n     }\n     fcx.infcx().resolve_regions();\n }\n@@ -150,7 +150,7 @@ pub fn regionck_fn(fcx: @mut FnCtxt, blk: &ast::blk) {\n     if fcx.err_count_since_creation() == 0 {\n         // regionck assumes typeck succeeded\n         let v = regionck_visitor();\n-        (v.visit_block)(blk, rcx, v);\n+        (v.visit_block)(blk, (rcx, v));\n     }\n     fcx.infcx().resolve_regions();\n }\n@@ -174,28 +174,28 @@ fn regionck_visitor() -> rvt {\n                                   .. *visit::default_visitor()})\n }\n \n-fn visit_item(_item: @ast::item, _rcx: @mut Rcx, _v: rvt) {\n+fn visit_item(_item: @ast::item, (_rcx, _v): (@mut Rcx, rvt)) {\n     // Ignore items\n }\n \n-fn visit_block(b: &ast::blk, rcx: @mut Rcx, v: rvt) {\n+fn visit_block(b: &ast::blk, (rcx, v): (@mut Rcx, rvt)) {\n     rcx.fcx.tcx().region_maps.record_cleanup_scope(b.node.id);\n-    visit::visit_block(b, rcx, v);\n+    visit::visit_block(b, (rcx, v));\n }\n \n-fn visit_arm(arm: &ast::arm, rcx: @mut Rcx, v: rvt) {\n+fn visit_arm(arm: &ast::arm, (rcx, v): (@mut Rcx, rvt)) {\n     // see above\n     for arm.pats.each |&p| {\n         constrain_bindings_in_pat(p, rcx);\n     }\n \n-    visit::visit_arm(arm, rcx, v);\n+    visit::visit_arm(arm, (rcx, v));\n }\n \n-fn visit_local(l: @ast::local, rcx: @mut Rcx, v: rvt) {\n+fn visit_local(l: @ast::local, (rcx, v): (@mut Rcx, rvt)) {\n     // see above\n     constrain_bindings_in_pat(l.node.pat, rcx);\n-    visit::visit_local(l, rcx, v);\n+    visit::visit_local(l, (rcx, v));\n }\n \n fn constrain_bindings_in_pat(pat: @ast::pat, rcx: @mut Rcx) {\n@@ -230,7 +230,7 @@ fn constrain_bindings_in_pat(pat: @ast::pat, rcx: @mut Rcx) {\n     }\n }\n \n-fn visit_expr(expr: @ast::expr, rcx: @mut Rcx, v: rvt) {\n+fn visit_expr(expr: @ast::expr, (rcx, v): (@mut Rcx, rvt)) {\n     debug!(\"regionck::visit_expr(e=%s)\", rcx.fcx.expr_to_str(expr));\n \n     let has_method_map = rcx.fcx.inh.method_map.contains_key(&expr.id);\n@@ -404,7 +404,7 @@ fn visit_expr(expr: @ast::expr, rcx: @mut Rcx, v: rvt) {\n         _ => ()\n     }\n \n-    visit::visit_expr(expr, rcx, v);\n+    visit::visit_expr(expr, (rcx, v));\n }\n \n fn constrain_callee(rcx: @mut Rcx,"}, {"sha": "adcf17a5f3d8e578bc8775758e0373716931cead", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=df483e82e7bcac0f36eff91145d5ac1c019f5078", "patch": "@@ -651,18 +651,18 @@ pub fn early_resolve_expr(ex: @ast::expr,\n }\n \n fn resolve_expr(ex: @ast::expr,\n-                fcx: @mut FnCtxt,\n-                v: visit::vt<@mut FnCtxt>) {\n+                (fcx, v): (@mut FnCtxt,\n+                           visit::vt<@mut FnCtxt>)) {\n     early_resolve_expr(ex, fcx, false);\n-    visit::visit_expr(ex, fcx, v);\n+    visit::visit_expr(ex, (fcx, v));\n }\n \n // Detect points where a trait-bounded type parameter is\n // instantiated, resolve the impls for the parameters.\n pub fn resolve_in_block(fcx: @mut FnCtxt, bl: &ast::blk) {\n-    visit::visit_block(bl, fcx, visit::mk_vt(@visit::Visitor {\n+    visit::visit_block(bl, (fcx, visit::mk_vt(@visit::Visitor {\n         visit_expr: resolve_expr,\n-        visit_item: |_,_,_| {},\n+        visit_item: |_,_| {},\n         .. *visit::default_visitor()\n-    }));\n+    })));\n }"}, {"sha": "8127322b836205b2ec8a0df5ce4064da6fcec1f9", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=df483e82e7bcac0f36eff91145d5ac1c019f5078", "patch": "@@ -210,13 +210,13 @@ struct WbCtxt {\n \n type wb_vt = visit::vt<@mut WbCtxt>;\n \n-fn visit_stmt(s: @ast::stmt, wbcx: @mut WbCtxt, v: wb_vt) {\n+fn visit_stmt(s: @ast::stmt, (wbcx, v): (@mut WbCtxt, wb_vt)) {\n     if !wbcx.success { return; }\n     resolve_type_vars_for_node(wbcx, s.span, ty::stmt_node_id(s));\n-    visit::visit_stmt(s, wbcx, v);\n+    visit::visit_stmt(s, (wbcx, v));\n }\n \n-fn visit_expr(e: @ast::expr, wbcx: @mut WbCtxt, v: wb_vt) {\n+fn visit_expr(e: @ast::expr, (wbcx, v): (@mut WbCtxt, wb_vt)) {\n     if !wbcx.success {\n         return;\n     }\n@@ -261,19 +261,19 @@ fn visit_expr(e: @ast::expr, wbcx: @mut WbCtxt, v: wb_vt) {\n         _ => ()\n     }\n \n-    visit::visit_expr(e, wbcx, v);\n+    visit::visit_expr(e, (wbcx, v));\n }\n \n-fn visit_block(b: &ast::blk, wbcx: @mut WbCtxt, v: wb_vt) {\n+fn visit_block(b: &ast::blk, (wbcx, v): (@mut WbCtxt, wb_vt)) {\n     if !wbcx.success {\n         return;\n     }\n \n     resolve_type_vars_for_node(wbcx, b.span, b.node.id);\n-    visit::visit_block(b, wbcx, v);\n+    visit::visit_block(b, (wbcx, v));\n }\n \n-fn visit_pat(p: @ast::pat, wbcx: @mut WbCtxt, v: wb_vt) {\n+fn visit_pat(p: @ast::pat, (wbcx, v): (@mut WbCtxt, wb_vt)) {\n     if !wbcx.success {\n         return;\n     }\n@@ -284,10 +284,10 @@ fn visit_pat(p: @ast::pat, wbcx: @mut WbCtxt, v: wb_vt) {\n            wbcx.fcx.infcx().ty_to_str(\n                ty::node_id_to_type(wbcx.fcx.ccx.tcx,\n                                    p.id)));\n-    visit::visit_pat(p, wbcx, v);\n+    visit::visit_pat(p, (wbcx, v));\n }\n \n-fn visit_local(l: @ast::local, wbcx: @mut WbCtxt, v: wb_vt) {\n+fn visit_local(l: @ast::local, (wbcx, v): (@mut WbCtxt, wb_vt)) {\n     if !wbcx.success { return; }\n     let var_ty = wbcx.fcx.local_ty(l.span, l.node.id);\n     match resolve_type(wbcx.fcx.infcx(), var_ty, resolve_all | force_all) {\n@@ -307,9 +307,9 @@ fn visit_local(l: @ast::local, wbcx: @mut WbCtxt, v: wb_vt) {\n             wbcx.success = false;\n         }\n     }\n-    visit::visit_local(l, wbcx, v);\n+    visit::visit_local(l, (wbcx, v));\n }\n-fn visit_item(_item: @ast::item, _wbcx: @mut WbCtxt, _v: wb_vt) {\n+fn visit_item(_item: @ast::item, (_wbcx, _v): (@mut WbCtxt, wb_vt)) {\n     // Ignore items\n }\n \n@@ -326,7 +326,7 @@ fn mk_visitor() -> visit::vt<@mut WbCtxt> {\n pub fn resolve_type_vars_in_expr(fcx: @mut FnCtxt, e: @ast::expr) -> bool {\n     let wbcx = @mut WbCtxt { fcx: fcx, success: true };\n     let visit = mk_visitor();\n-    (visit.visit_expr)(e, wbcx, visit);\n+    (visit.visit_expr)(e, (wbcx, visit));\n     return wbcx.success;\n }\n \n@@ -336,7 +336,7 @@ pub fn resolve_type_vars_in_fn(fcx: @mut FnCtxt,\n                                self_info: Option<SelfInfo>) -> bool {\n     let wbcx = @mut WbCtxt { fcx: fcx, success: true };\n     let visit = mk_visitor();\n-    (visit.visit_block)(blk, wbcx, visit);\n+    (visit.visit_block)(blk, (wbcx, visit));\n     for self_info.iter().advance |self_info| {\n         resolve_type_vars_for_node(wbcx,\n                                    self_info.span,"}, {"sha": "3de51629741e1156deff467a6a578f71df63bcb5", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=df483e82e7bcac0f36eff91145d5ac1c019f5078", "patch": "@@ -204,7 +204,7 @@ impl CoherenceChecker {\n         // Check implementations and traits. This populates the tables\n         // containing the inherent methods and extension methods. It also\n         // builds up the trait inheritance table.\n-        visit_crate(crate, (), mk_simple_visitor(@SimpleVisitor {\n+        visit_crate(crate, ((), mk_simple_visitor(@SimpleVisitor {\n             visit_item: |item| {\n //                debug!(\"(checking coherence) item '%s'\",\n //                       self.crate_context.tcx.sess.str_of(item.ident));\n@@ -220,7 +220,7 @@ impl CoherenceChecker {\n                 };\n             },\n             .. *default_simple_visitor()\n-        }));\n+        })));\n \n         // Check that there are no overlapping trait instances\n         self.check_implementation_coherence();\n@@ -659,12 +659,12 @@ impl CoherenceChecker {\n \n     // Privileged scope checking\n     pub fn check_privileged_scopes(self, crate: @crate) {\n-        visit_crate(crate, (), mk_vt(@Visitor {\n-            visit_item: |item, _context, visitor| {\n+        visit_crate(crate, ((), mk_vt(@Visitor {\n+            visit_item: |item, (_context, visitor)| {\n                 match item.node {\n                     item_mod(ref module_) => {\n                         // Then visit the module items.\n-                        visit_mod(module_, item.span, item.id, (), visitor);\n+                        visit_mod(module_, item.span, item.id, ((), visitor));\n                     }\n                     item_impl(_, None, ast_ty, _) => {\n                         if !self.ast_type_is_defined_in_local_crate(ast_ty) {\n@@ -697,15 +697,15 @@ impl CoherenceChecker {\n                             }\n                         }\n \n-                        visit_item(item, (), visitor);\n+                        visit_item(item, ((), visitor));\n                     }\n                     _ => {\n-                        visit_item(item, (), visitor);\n+                        visit_item(item, ((), visitor));\n                     }\n                 }\n             },\n             .. *default_visitor()\n-        }));\n+        })));\n     }\n \n     pub fn trait_ref_to_trait_def_id(&self, trait_ref: @trait_ref) -> def_id {"}, {"sha": "1a3b284556b0c0ac4e7d0409ffcbe543186e55cb", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=df483e82e7bcac0f36eff91145d5ac1c019f5078", "patch": "@@ -113,12 +113,12 @@ pub fn collect_item_types(ccx: @mut CrateCtxt, crate: @ast::crate) {\n     }\n \n     visit::visit_crate(\n-        crate, (),\n+        crate, ((),\n         visit::mk_simple_visitor(@visit::SimpleVisitor {\n             visit_item: |a| convert(ccx, a),\n             visit_foreign_item: |a|convert_foreign(ccx, a),\n             .. *visit::default_simple_visitor()\n-        }));\n+        })));\n }\n \n impl CrateCtxt {"}, {"sha": "0839c2b963b4e00ad7f499483e7499b870f0dae5", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=df483e82e7bcac0f36eff91145d5ac1c019f5078", "patch": "@@ -66,21 +66,21 @@ pub fn field_exprs(fields: ~[ast::field]) -> ~[@ast::expr] {\n pub fn loop_query(b: &ast::blk, p: @fn(&ast::expr_) -> bool) -> bool {\n     let rs = @mut false;\n     let visit_expr: @fn(@ast::expr,\n-                        flag: @mut bool,\n-                        v: visit::vt<@mut bool>) = |e, flag, v| {\n+                        (@mut bool,\n+                         visit::vt<@mut bool>)) = |e, (flag, v)| {\n         *flag |= p(&e.node);\n         match e.node {\n           // Skip inner loops, since a break in the inner loop isn't a\n           // break inside the outer loop\n           ast::expr_loop(*) | ast::expr_while(*)\n           | ast::expr_loop_body(*) => {}\n-          _ => visit::visit_expr(e, flag, v)\n+          _ => visit::visit_expr(e, (flag, v))\n         }\n     };\n     let v = visit::mk_vt(@visit::Visitor {\n         visit_expr: visit_expr,\n         .. *visit::default_visitor()});\n-    visit::visit_block(b, rs, v);\n+    visit::visit_block(b, (rs, v));\n     return *rs;\n }\n \n@@ -89,15 +89,15 @@ pub fn loop_query(b: &ast::blk, p: @fn(&ast::expr_) -> bool) -> bool {\n pub fn block_query(b: &ast::blk, p: @fn(@ast::expr) -> bool) -> bool {\n     let rs = @mut false;\n     let visit_expr: @fn(@ast::expr,\n-                        flag: @mut bool,\n-                        v: visit::vt<@mut bool>) = |e, flag, v| {\n+                        (@mut bool,\n+                         visit::vt<@mut bool>)) = |e, (flag, v)| {\n         *flag |= p(e);\n-        visit::visit_expr(e, flag, v)\n+        visit::visit_expr(e, (flag, v))\n     };\n     let v = visit::mk_vt(@visit::Visitor{\n         visit_expr: visit_expr,\n         .. *visit::default_visitor()});\n-    visit::visit_block(b, rs, v);\n+    visit::visit_block(b, (rs, v));\n     return *rs;\n }\n "}, {"sha": "430567e3e2f7b7665b59a6f56e803baef130c097", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=df483e82e7bcac0f36eff91145d5ac1c019f5078", "patch": "@@ -133,7 +133,7 @@ pub fn map_crate(diag: @span_handler, c: @crate) -> map {\n         path: ~[],\n         diag: diag,\n     };\n-    visit::visit_crate(c, cx, mk_ast_map_visitor());\n+    visit::visit_crate(c, (cx, mk_ast_map_visitor()));\n     cx.map\n }\n \n@@ -183,21 +183,21 @@ pub fn map_fn(\n     body: &blk,\n     sp: codemap::span,\n     id: node_id,\n-    cx: @mut Ctx,\n-    v: visit::vt<@mut Ctx>\n+    (cx,v): (@mut Ctx,\n+             visit::vt<@mut Ctx>)\n ) {\n     for decl.inputs.each |a| {\n         cx.map.insert(a.id, node_arg);\n     }\n-    visit::visit_fn(fk, decl, body, sp, id, cx, v);\n+    visit::visit_fn(fk, decl, body, sp, id, (cx, v));\n }\n \n-pub fn map_block(b: &blk, cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n+pub fn map_block(b: &blk, (cx,v): (@mut Ctx, visit::vt<@mut Ctx>)) {\n     cx.map.insert(b.node.id, node_block(/* FIXME (#2543) */ copy *b));\n-    visit::visit_block(b, cx, v);\n+    visit::visit_block(b, (cx, v));\n }\n \n-pub fn map_pat(pat: @pat, cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n+pub fn map_pat(pat: @pat, (cx,v): (@mut Ctx, visit::vt<@mut Ctx>)) {\n     match pat.node {\n         pat_ident(_, path, _) => {\n             // Note: this is at least *potentially* a pattern...\n@@ -206,7 +206,7 @@ pub fn map_pat(pat: @pat, cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n         _ => ()\n     }\n \n-    visit::visit_pat(pat, cx, v);\n+    visit::visit_pat(pat, (cx, v));\n }\n \n pub fn map_method(impl_did: def_id, impl_path: @path,\n@@ -215,7 +215,7 @@ pub fn map_method(impl_did: def_id, impl_path: @path,\n     cx.map.insert(m.self_id, node_local(special_idents::self_));\n }\n \n-pub fn map_item(i: @item, cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n+pub fn map_item(i: @item, (cx, v): (@mut Ctx, visit::vt<@mut Ctx>)) {\n     let item_path = @/* FIXME (#2543) */ copy cx.path;\n     cx.map.insert(i.id, node_item(i, item_path));\n     match i.node {\n@@ -262,8 +262,8 @@ pub fn map_item(i: @item, cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n                 struct_def,\n                 node_item(i, item_path),\n                 i.ident,\n-                cx,\n-                v\n+                (cx,\n+                 v)\n             );\n         }\n         item_trait(_, ref traits, ref methods) => {\n@@ -288,16 +288,16 @@ pub fn map_item(i: @item, cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n         }\n         _ => cx.path.push(path_name(i.ident))\n     }\n-    visit::visit_item(i, cx, v);\n+    visit::visit_item(i, (cx, v));\n     cx.path.pop();\n }\n \n pub fn map_struct_def(\n     struct_def: @ast::struct_def,\n     parent_node: ast_node,\n     ident: ast::ident,\n-    cx: @mut Ctx,\n-    _v: visit::vt<@mut Ctx>\n+    (cx, _v): (@mut Ctx,\n+               visit::vt<@mut Ctx>)\n ) {\n     let p = extend(cx, ident);\n     // If this is a tuple-like struct, register the constructor.\n@@ -315,7 +315,7 @@ pub fn map_struct_def(\n     }\n }\n \n-pub fn map_expr(ex: @expr, cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n+pub fn map_expr(ex: @expr, (cx,v): (@mut Ctx, visit::vt<@mut Ctx>)) {\n     cx.map.insert(ex.id, node_expr(ex));\n     // Expressions which are or might be calls:\n     {\n@@ -324,12 +324,12 @@ pub fn map_expr(ex: @expr, cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n             cx.map.insert(*callee_id, node_callee_scope(ex));\n         }\n     }\n-    visit::visit_expr(ex, cx, v);\n+    visit::visit_expr(ex, (cx, v));\n }\n \n-pub fn map_stmt(stmt: @stmt, cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n+pub fn map_stmt(stmt: @stmt, (cx,v): (@mut Ctx, visit::vt<@mut Ctx>)) {\n     cx.map.insert(stmt_id(stmt), node_stmt(stmt));\n-    visit::visit_stmt(stmt, cx, v);\n+    visit::visit_stmt(stmt, (cx, v));\n }\n \n pub fn node_id_to_str(map: map, id: node_id, itr: @ident_interner) -> ~str {"}, {"sha": "904f35bce5a61287428918fecb27e71dc954d594", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=df483e82e7bcac0f36eff91145d5ac1c019f5078", "patch": "@@ -323,9 +323,9 @@ impl inlined_item_utils for inlined_item {\n \n     fn accept<E: Copy>(&self, e: E, v: visit::vt<E>) {\n         match *self {\n-            ii_item(i) => (v.visit_item)(i, e, v),\n-            ii_foreign(i) => (v.visit_foreign_item)(i, e, v),\n-            ii_method(_, m) => visit::visit_method_helper(m, e, v),\n+            ii_item(i) => (v.visit_item)(i, (e, v)),\n+            ii_foreign(i) => (v.visit_foreign_item)(i, (e, v)),\n+            ii_method(_, m) => visit::visit_method_helper(m, (e, v)),\n         }\n     }\n }\n@@ -403,12 +403,12 @@ pub fn id_visitor<T: Copy>(vfn: @fn(node_id, T)) -> visit::vt<T> {\n         }\n     };\n     visit::mk_vt(@visit::Visitor {\n-        visit_mod: |m, sp, id, t, vt| {\n+        visit_mod: |m, sp, id, (t, vt)| {\n             vfn(id, t);\n-            visit::visit_mod(m, sp, id, t, vt);\n+            visit::visit_mod(m, sp, id, (t, vt));\n         },\n \n-        visit_view_item: |vi, t, vt| {\n+        visit_view_item: |vi, (t, vt)| {\n             match vi.node {\n               view_item_extern_mod(_, _, id) => vfn(id, t),\n               view_item_use(ref vps) => {\n@@ -426,66 +426,66 @@ pub fn id_visitor<T: Copy>(vfn: @fn(node_id, T)) -> visit::vt<T> {\n                   }\n               }\n             }\n-            visit::visit_view_item(vi, t, vt);\n+            visit::visit_view_item(vi, (t, vt));\n         },\n \n-        visit_foreign_item: |ni, t, vt| {\n+        visit_foreign_item: |ni, (t, vt)| {\n             vfn(ni.id, t);\n-            visit::visit_foreign_item(ni, t, vt);\n+            visit::visit_foreign_item(ni, (t, vt));\n         },\n \n-        visit_item: |i, t, vt| {\n+        visit_item: |i, (t, vt)| {\n             vfn(i.id, t);\n             match i.node {\n               item_enum(ref enum_definition, _) =>\n                 for (*enum_definition).variants.each |v| { vfn(v.node.id, t); },\n               _ => ()\n             }\n-            visit::visit_item(i, t, vt);\n+            visit::visit_item(i, (t, vt));\n         },\n \n-        visit_local: |l, t, vt| {\n+        visit_local: |l, (t, vt)| {\n             vfn(l.node.id, t);\n-            visit::visit_local(l, t, vt);\n+            visit::visit_local(l, (t, vt));\n         },\n-        visit_block: |b, t, vt| {\n+        visit_block: |b, (t, vt)| {\n             vfn(b.node.id, t);\n-            visit::visit_block(b, t, vt);\n+            visit::visit_block(b, (t, vt));\n         },\n-        visit_stmt: |s, t, vt| {\n+        visit_stmt: |s, (t, vt)| {\n             vfn(ast_util::stmt_id(s), t);\n-            visit::visit_stmt(s, t, vt);\n+            visit::visit_stmt(s, (t, vt));\n         },\n-        visit_pat: |p, t, vt| {\n+        visit_pat: |p, (t, vt)| {\n             vfn(p.id, t);\n-            visit::visit_pat(p, t, vt);\n+            visit::visit_pat(p, (t, vt));\n         },\n \n-        visit_expr: |e, t, vt| {\n+        visit_expr: |e, (t, vt)| {\n             {\n                 let r = e.get_callee_id();\n                 for r.iter().advance |callee_id| {\n                     vfn(*callee_id, t);\n                 }\n             }\n             vfn(e.id, t);\n-            visit::visit_expr(e, t, vt);\n+            visit::visit_expr(e, (t, vt));\n         },\n \n-        visit_ty: |ty, t, vt| {\n+        visit_ty: |ty, (t, vt)| {\n             match ty.node {\n               ty_path(_, id) => vfn(id, t),\n               _ => { /* fall through */ }\n             }\n-            visit::visit_ty(ty, t, vt);\n+            visit::visit_ty(ty, (t, vt));\n         },\n \n-        visit_generics: |generics, t, vt| {\n+        visit_generics: |generics, (t, vt)| {\n             visit_generics(generics, t);\n-            visit::visit_generics(generics, t, vt);\n+            visit::visit_generics(generics, (t, vt));\n         },\n \n-        visit_fn: |fk, d, a, b, id, t, vt| {\n+        visit_fn: |fk, d, a, b, id, (t, vt)| {\n             vfn(id, t);\n \n             match *fk {\n@@ -504,12 +504,12 @@ pub fn id_visitor<T: Copy>(vfn: @fn(node_id, T)) -> visit::vt<T> {\n             for d.inputs.each |arg| {\n                 vfn(arg.id, t)\n             }\n-            visit::visit_fn(fk, d, a, b, id, t, vt);\n+            visit::visit_fn(fk, d, a, b, id, (t, vt));\n         },\n \n-        visit_struct_field: |f, t, vt| {\n+        visit_struct_field: |f, (t, vt)| {\n             vfn(f.node.id, t);\n-            visit::visit_struct_field(f, t, vt);\n+            visit::visit_struct_field(f, (t, vt));\n         },\n \n         .. *visit::default_visitor()\n@@ -577,7 +577,7 @@ impl EachViewItem for ast::crate {\n         let vtor: visit::vt<()> = visit::mk_simple_visitor(@visit::SimpleVisitor {\n             visit_view_item: |vi| { *broke = f(vi); }, ..*visit::default_simple_visitor()\n         });\n-        visit::visit_crate(self, (), vtor);\n+        visit::visit_crate(self, ((), vtor));\n         true\n     }\n }"}, {"sha": "fe751d279d2649e098a18ffdeb40f7efd7d28228", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=df483e82e7bcac0f36eff91145d5ac1c019f5078", "patch": "@@ -372,7 +372,8 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n pub fn new_name_finder() -> @Visitor<@mut ~[ast::ident]> {\n     let default_visitor = visit::default_visitor();\n     @Visitor{\n-        visit_pat : |p:@ast::pat,ident_accum:@mut ~[ast::ident],v:visit::vt<@mut ~[ast::ident]>| {\n+        visit_pat : |p:@ast::pat,\n+                     (ident_accum, v): (@mut ~[ast::ident], visit::vt<@mut ~[ast::ident]>)| {\n             match *p {\n                 // we found a pat_ident!\n                 ast::pat{id:_, node: ast::pat_ident(_,path,ref inner), span:_} => {\n@@ -385,11 +386,11 @@ pub fn new_name_finder() -> @Visitor<@mut ~[ast::ident]> {\n                     }\n                     // visit optional subpattern of pat_ident:\n                     for inner.iter().advance |subpat: &@ast::pat| {\n-                        (v.visit_pat)(*subpat, ident_accum, v)\n+                        (v.visit_pat)(*subpat, (ident_accum, v))\n                     }\n                 }\n                 // use the default traversal for non-pat_idents\n-                _ => visit::visit_pat(p,ident_accum,v)\n+                _ => visit::visit_pat(p,(ident_accum,v))\n             }\n         },\n         .. *default_visitor\n@@ -889,7 +890,7 @@ mod test {\n         let pat = string_to_pat(@~\"(a,Foo{x:c @ (b,9),y:Bar(4,d)})\");\n         let pat_idents = new_name_finder();\n         let idents = @mut ~[];\n-        ((*pat_idents).visit_pat)(pat,idents, mk_vt(pat_idents));\n+        ((*pat_idents).visit_pat)(pat, (idents, mk_vt(pat_idents)));\n         assert_eq!(idents,@mut strs_to_idents(~[\"a\",\"c\",\"b\",\"d\"]));\n     }\n }"}, {"sha": "7eee2ab95ef0ce962c3906e12ca78bf0c3238b83", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 272, "deletions": 286, "changes": 558, "blob_url": "https://github.com/rust-lang/rust/blob/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df483e82e7bcac0f36eff91145d5ac1c019f5078/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=df483e82e7bcac0f36eff91145d5ac1c019f5078", "patch": "@@ -74,85 +74,84 @@ pub fn generics_of_fn(fk: &fn_kind) -> Generics {\n }\n \n pub struct Visitor<E> {\n-    visit_mod: @fn(&_mod, span, node_id, E, vt<E>),\n-    visit_view_item: @fn(@view_item, E, vt<E>),\n-    visit_foreign_item: @fn(@foreign_item, E, vt<E>),\n-    visit_item: @fn(@item, E, vt<E>),\n-    visit_local: @fn(@local, E, vt<E>),\n-    visit_block: @fn(&blk, E, vt<E>),\n-    visit_stmt: @fn(@stmt, E, vt<E>),\n-    visit_arm: @fn(&arm, E, vt<E>),\n-    visit_pat: @fn(@pat, E, vt<E>),\n-    visit_decl: @fn(@decl, E, vt<E>),\n-    visit_expr: @fn(@expr, E, vt<E>),\n-    visit_expr_post: @fn(@expr, E, vt<E>),\n-    visit_ty: @fn(@Ty, E, vt<E>),\n-    visit_generics: @fn(&Generics, E, vt<E>),\n-    visit_fn: @fn(&fn_kind, &fn_decl, &blk, span, node_id, E, vt<E>),\n-    visit_ty_method: @fn(&ty_method, E, vt<E>),\n-    visit_trait_method: @fn(&trait_method, E, vt<E>),\n-    visit_struct_def: @fn(@struct_def, ident, &Generics, node_id, E, vt<E>),\n-    visit_struct_field: @fn(@struct_field, E, vt<E>),\n-    visit_struct_method: @fn(@method, E, vt<E>)\n+    visit_mod: @fn(&_mod, span, node_id, (E, vt<E>)),\n+    visit_view_item: @fn(@view_item, (E, vt<E>)),\n+    visit_foreign_item: @fn(@foreign_item, (E, vt<E>)),\n+    visit_item: @fn(@item, (E, vt<E>)),\n+    visit_local: @fn(@local, (E, vt<E>)),\n+    visit_block: @fn(&blk, (E, vt<E>)),\n+    visit_stmt: @fn(@stmt, (E, vt<E>)),\n+    visit_arm: @fn(&arm, (E, vt<E>)),\n+    visit_pat: @fn(@pat, (E, vt<E>)),\n+    visit_decl: @fn(@decl, (E, vt<E>)),\n+    visit_expr: @fn(@expr, (E, vt<E>)),\n+    visit_expr_post: @fn(@expr, (E, vt<E>)),\n+    visit_ty: @fn(@Ty, (E, vt<E>)),\n+    visit_generics: @fn(&Generics, (E, vt<E>)),\n+    visit_fn: @fn(&fn_kind, &fn_decl, &blk, span, node_id, (E, vt<E>)),\n+    visit_ty_method: @fn(&ty_method, (E, vt<E>)),\n+    visit_trait_method: @fn(&trait_method, (E, vt<E>)),\n+    visit_struct_def: @fn(@struct_def, ident, &Generics, node_id, (E, vt<E>)),\n+    visit_struct_field: @fn(@struct_field, (E, vt<E>)),\n+    visit_struct_method: @fn(@method, (E, vt<E>))\n }\n \n pub type visitor<E> = @Visitor<E>;\n \n pub fn default_visitor<E: Copy>() -> visitor<E> {\n     return @Visitor {\n-        visit_mod: |a,b,c,d,e|visit_mod::<E>(a, b, c, d, e),\n-        visit_view_item: |a,b,c|visit_view_item::<E>(a, b, c),\n-        visit_foreign_item: |a,b,c|visit_foreign_item::<E>(a, b, c),\n-        visit_item: |a,b,c|visit_item::<E>(a, b, c),\n-        visit_local: |a,b,c|visit_local::<E>(a, b, c),\n-        visit_block: |a,b,c|visit_block::<E>(a, b, c),\n-        visit_stmt: |a,b,c|visit_stmt::<E>(a, b, c),\n-        visit_arm: |a,b,c|visit_arm::<E>(a, b, c),\n-        visit_pat: |a,b,c|visit_pat::<E>(a, b, c),\n-        visit_decl: |a,b,c|visit_decl::<E>(a, b, c),\n-        visit_expr: |a,b,c|visit_expr::<E>(a, b, c),\n-        visit_expr_post: |_a,_b,_c| (),\n-        visit_ty: |a,b,c|skip_ty::<E>(a, b, c),\n-        visit_generics: |a,b,c|visit_generics::<E>(a, b, c),\n-        visit_fn: |a,b,c,d,e,f,g|visit_fn::<E>(a, b, c, d, e, f, g),\n-        visit_ty_method: |a,b,c|visit_ty_method::<E>(a, b, c),\n-        visit_trait_method: |a,b,c|visit_trait_method::<E>(a, b, c),\n-        visit_struct_def: |a,b,c,d,e,f|visit_struct_def::<E>(a, b, c,\n-                                                             d, e, f),\n-        visit_struct_field: |a,b,c|visit_struct_field::<E>(a, b, c),\n-        visit_struct_method: |a,b,c|visit_struct_method::<E>(a, b, c)\n+        visit_mod: |a,b,c,d|visit_mod::<E>(a, b, c, d),\n+        visit_view_item: |a,b|visit_view_item::<E>(a, b),\n+        visit_foreign_item: |a,b|visit_foreign_item::<E>(a, b),\n+        visit_item: |a,b|visit_item::<E>(a, b),\n+        visit_local: |a,b|visit_local::<E>(a, b),\n+        visit_block: |a,b|visit_block::<E>(a, b),\n+        visit_stmt: |a,b|visit_stmt::<E>(a, b),\n+        visit_arm: |a,b|visit_arm::<E>(a, b),\n+        visit_pat: |a,b|visit_pat::<E>(a, b),\n+        visit_decl: |a,b|visit_decl::<E>(a, b),\n+        visit_expr: |a,b|visit_expr::<E>(a, b),\n+        visit_expr_post: |_a,_b| (),\n+        visit_ty: |a,b|skip_ty::<E>(a, b),\n+        visit_generics: |a,b|visit_generics::<E>(a, b),\n+        visit_fn: |a,b,c,d,e,f|visit_fn::<E>(a, b, c, d, e, f),\n+        visit_ty_method: |a,b|visit_ty_method::<E>(a, b),\n+        visit_trait_method: |a,b|visit_trait_method::<E>(a, b),\n+        visit_struct_def: |a,b,c,d,e|visit_struct_def::<E>(a, b, c, d, e),\n+        visit_struct_field: |a,b|visit_struct_field::<E>(a, b),\n+        visit_struct_method: |a,b|visit_struct_method::<E>(a, b)\n     };\n }\n \n-pub fn visit_crate<E: Copy>(c: &crate, e: E, v: vt<E>) {\n-    (v.visit_mod)(&c.node.module, c.span, crate_node_id, e, v);\n+pub fn visit_crate<E: Copy>(c: &crate, (e, v): (E, vt<E>)) {\n+    (v.visit_mod)(&c.node.module, c.span, crate_node_id, (e, v));\n }\n \n-pub fn visit_mod<E: Copy>(m: &_mod, _sp: span, _id: node_id, e: E, v: vt<E>) {\n-    for m.view_items.each |vi| { (v.visit_view_item)(*vi, e, v); }\n-    for m.items.each |i| { (v.visit_item)(*i, e, v); }\n+pub fn visit_mod<E: Copy>(m: &_mod, _sp: span, _id: node_id, (e, v): (E, vt<E>)) {\n+    for m.view_items.each |vi| { (v.visit_view_item)(*vi, (e, v)); }\n+    for m.items.each |i| { (v.visit_item)(*i, (e, v)); }\n }\n \n-pub fn visit_view_item<E>(_vi: @view_item, _e: E, _v: vt<E>) { }\n+pub fn visit_view_item<E>(_vi: @view_item, (_e, _v): (E, vt<E>)) { }\n \n-pub fn visit_local<E: Copy>(loc: @local, e: E, v: vt<E>) {\n-    (v.visit_pat)(loc.node.pat, e, v);\n-    (v.visit_ty)(loc.node.ty, e, v);\n+pub fn visit_local<E: Copy>(loc: @local, (e, v): (E, vt<E>)) {\n+    (v.visit_pat)(loc.node.pat, (e, v));\n+    (v.visit_ty)(loc.node.ty, (e, v));\n     match loc.node.init {\n       None => (),\n-      Some(ex) => (v.visit_expr)(ex, e, v)\n+      Some(ex) => (v.visit_expr)(ex, (e, v))\n     }\n }\n \n-fn visit_trait_ref<E: Copy>(tref: @ast::trait_ref, e: E, v: vt<E>) {\n-    visit_path(tref.path, e, v);\n+fn visit_trait_ref<E: Copy>(tref: @ast::trait_ref, (e, v): (E, vt<E>)) {\n+    visit_path(tref.path, (e, v));\n }\n \n-pub fn visit_item<E: Copy>(i: @item, e: E, v: vt<E>) {\n+pub fn visit_item<E: Copy>(i: @item, (e, v): (E, vt<E>)) {\n     match i.node {\n         item_const(t, ex) => {\n-            (v.visit_ty)(t, e, v);\n-            (v.visit_expr)(ex, e, v);\n+            (v.visit_ty)(t, (e, v));\n+            (v.visit_expr)(ex, (e, v));\n         }\n         item_fn(ref decl, purity, abi, ref generics, ref body) => {\n             (v.visit_fn)(\n@@ -166,193 +165,191 @@ pub fn visit_item<E: Copy>(i: @item, e: E, v: vt<E>) {\n                 body,\n                 i.span,\n                 i.id,\n-                e,\n-                v\n+                (e,\n+                 v)\n             );\n         }\n-        item_mod(ref m) => (v.visit_mod)(m, i.span, i.id, e, v),\n+        item_mod(ref m) => (v.visit_mod)(m, i.span, i.id, (e, v)),\n         item_foreign_mod(ref nm) => {\n-            for nm.view_items.each |vi| { (v.visit_view_item)(*vi, e, v); }\n-            for nm.items.each |ni| { (v.visit_foreign_item)(*ni, e, v); }\n+            for nm.view_items.each |vi| { (v.visit_view_item)(*vi, (e, v)); }\n+            for nm.items.each |ni| { (v.visit_foreign_item)(*ni, (e, v)); }\n         }\n         item_ty(t, ref tps) => {\n-            (v.visit_ty)(t, e, v);\n-            (v.visit_generics)(tps, e, v);\n+            (v.visit_ty)(t, (e, v));\n+            (v.visit_generics)(tps, (e, v));\n         }\n         item_enum(ref enum_definition, ref tps) => {\n-            (v.visit_generics)(tps, e, v);\n+            (v.visit_generics)(tps, (e, v));\n             visit_enum_def(\n                 enum_definition,\n                 tps,\n-                e,\n-                v\n+                (e, v)\n             );\n         }\n         item_impl(ref tps, ref traits, ty, ref methods) => {\n-            (v.visit_generics)(tps, e, v);\n+            (v.visit_generics)(tps, (e, v));\n             for traits.iter().advance |&p| {\n-                visit_trait_ref(p, e, v);\n+                visit_trait_ref(p, (e, v));\n             }\n-            (v.visit_ty)(ty, e, v);\n+            (v.visit_ty)(ty, (e, v));\n             for methods.each |m| {\n-                visit_method_helper(*m, e, v)\n+                visit_method_helper(*m, (e, v))\n             }\n         }\n         item_struct(struct_def, ref generics) => {\n-            (v.visit_generics)(generics, e, v);\n-            (v.visit_struct_def)(struct_def, i.ident, generics, i.id, e, v);\n+            (v.visit_generics)(generics, (e, v));\n+            (v.visit_struct_def)(struct_def, i.ident, generics, i.id, (e, v));\n         }\n         item_trait(ref generics, ref traits, ref methods) => {\n-            (v.visit_generics)(generics, e, v);\n-            for traits.each |p| { visit_path(p.path, e, v); }\n+            (v.visit_generics)(generics, (e, v));\n+            for traits.each |p| { visit_path(p.path, (e, v)); }\n             for methods.each |m| {\n-                (v.visit_trait_method)(m, e, v);\n+                (v.visit_trait_method)(m, (e, v));\n             }\n         }\n-        item_mac(ref m) => visit_mac(m, e, v)\n+        item_mac(ref m) => visit_mac(m, (e, v))\n     }\n }\n \n pub fn visit_enum_def<E: Copy>(enum_definition: &ast::enum_def,\n                                tps: &Generics,\n-                               e: E,\n-                               v: vt<E>) {\n+                               (e, v): (E, vt<E>)) {\n     for enum_definition.variants.each |vr| {\n         match vr.node.kind {\n             tuple_variant_kind(ref variant_args) => {\n-                for variant_args.each |va| { (v.visit_ty)(va.ty, e, v); }\n+                for variant_args.each |va| { (v.visit_ty)(va.ty, (e, v)); }\n             }\n             struct_variant_kind(struct_def) => {\n                 (v.visit_struct_def)(struct_def, vr.node.name, tps,\n-                                   vr.node.id, e, v);\n+                                   vr.node.id, (e, v));\n             }\n         }\n         // Visit the disr expr if it exists\n-        for vr.node.disr_expr.iter().advance |ex| { (v.visit_expr)(*ex, e, v) }\n+        for vr.node.disr_expr.iter().advance |ex| { (v.visit_expr)(*ex, (e, v)) }\n     }\n }\n \n-pub fn skip_ty<E>(_t: @Ty, _e: E, _v: vt<E>) {}\n+pub fn skip_ty<E>(_t: @Ty, (_e,_v): (E, vt<E>)) {}\n \n-pub fn visit_ty<E: Copy>(t: @Ty, e: E, v: vt<E>) {\n+pub fn visit_ty<E: Copy>(t: @Ty, (e, v): (E, vt<E>)) {\n     match t.node {\n         ty_box(mt) | ty_uniq(mt) |\n         ty_vec(mt) | ty_ptr(mt) | ty_rptr(_, mt) => {\n-            (v.visit_ty)(mt.ty, e, v);\n+            (v.visit_ty)(mt.ty, (e, v));\n         },\n         ty_tup(ref ts) => {\n             for ts.each |tt| {\n-                (v.visit_ty)(*tt, e, v);\n+                (v.visit_ty)(*tt, (e, v));\n             }\n         },\n         ty_closure(ref f) => {\n-            for f.decl.inputs.each |a| { (v.visit_ty)(a.ty, e, v); }\n-            (v.visit_ty)(f.decl.output, e, v);\n+            for f.decl.inputs.each |a| { (v.visit_ty)(a.ty, (e, v)); }\n+            (v.visit_ty)(f.decl.output, (e, v));\n         },\n         ty_bare_fn(ref f) => {\n-            for f.decl.inputs.each |a| { (v.visit_ty)(a.ty, e, v); }\n-            (v.visit_ty)(f.decl.output, e, v);\n+            for f.decl.inputs.each |a| { (v.visit_ty)(a.ty, (e, v)); }\n+            (v.visit_ty)(f.decl.output, (e, v));\n         },\n-        ty_path(p, _) => visit_path(p, e, v),\n+        ty_path(p, _) => visit_path(p, (e, v)),\n         ty_fixed_length_vec(ref mt, ex) => {\n-            (v.visit_ty)(mt.ty, e, v);\n-            (v.visit_expr)(ex, e, v);\n+            (v.visit_ty)(mt.ty, (e, v));\n+            (v.visit_expr)(ex, (e, v));\n         },\n         ty_nil | ty_bot | ty_mac(_) | ty_infer => ()\n     }\n }\n \n-pub fn visit_path<E: Copy>(p: @Path, e: E, v: vt<E>) {\n-    for p.types.each |tp| { (v.visit_ty)(*tp, e, v); }\n+pub fn visit_path<E: Copy>(p: @Path, (e, v): (E, vt<E>)) {\n+    for p.types.each |tp| { (v.visit_ty)(*tp, (e, v)); }\n }\n \n-pub fn visit_pat<E: Copy>(p: @pat, e: E, v: vt<E>) {\n+pub fn visit_pat<E: Copy>(p: @pat, (e, v): (E, vt<E>)) {\n     match p.node {\n         pat_enum(path, ref children) => {\n-            visit_path(path, e, v);\n+            visit_path(path, (e, v));\n             for children.iter().advance |children| {\n-                for children.iter().advance |child| { (v.visit_pat)(*child, e, v); }\n+                for children.iter().advance |child| { (v.visit_pat)(*child, (e, v)); }\n             }\n         }\n         pat_struct(path, ref fields, _) => {\n-            visit_path(path, e, v);\n+            visit_path(path, (e, v));\n             for fields.each |f| {\n-                (v.visit_pat)(f.pat, e, v);\n+                (v.visit_pat)(f.pat, (e, v));\n             }\n         }\n         pat_tup(ref elts) => {\n             for elts.each |elt| {\n-                (v.visit_pat)(*elt, e, v)\n+                (v.visit_pat)(*elt, (e, v))\n             }\n         },\n         pat_box(inner) | pat_uniq(inner) | pat_region(inner) => {\n-            (v.visit_pat)(inner, e, v)\n+            (v.visit_pat)(inner, (e, v))\n         },\n         pat_ident(_, path, ref inner) => {\n-            visit_path(path, e, v);\n-            for inner.iter().advance |subpat| { (v.visit_pat)(*subpat, e, v) }\n+            visit_path(path, (e, v));\n+            for inner.iter().advance |subpat| { (v.visit_pat)(*subpat, (e, v)) }\n         }\n-        pat_lit(ex) => (v.visit_expr)(ex, e, v),\n+        pat_lit(ex) => (v.visit_expr)(ex, (e, v)),\n         pat_range(e1, e2) => {\n-            (v.visit_expr)(e1, e, v);\n-            (v.visit_expr)(e2, e, v);\n+            (v.visit_expr)(e1, (e, v));\n+            (v.visit_expr)(e2, (e, v));\n         }\n         pat_wild => (),\n         pat_vec(ref before, ref slice, ref after) => {\n             for before.each |elt| {\n-                (v.visit_pat)(*elt, e, v);\n+                (v.visit_pat)(*elt, (e, v));\n             }\n             for slice.iter().advance |elt| {\n-                (v.visit_pat)(*elt, e, v);\n+                (v.visit_pat)(*elt, (e, v));\n             }\n             for after.each |tail| {\n-                (v.visit_pat)(*tail, e, v);\n+                (v.visit_pat)(*tail, (e, v));\n             }\n         }\n     }\n }\n \n-pub fn visit_foreign_item<E: Copy>(ni: @foreign_item, e: E, v: vt<E>) {\n+pub fn visit_foreign_item<E: Copy>(ni: @foreign_item, (e, v): (E, vt<E>)) {\n     match ni.node {\n         foreign_item_fn(ref fd, _, ref generics) => {\n-            visit_fn_decl(fd, e, v);\n-            (v.visit_generics)(generics, e, v);\n+            visit_fn_decl(fd, (e, v));\n+            (v.visit_generics)(generics, (e, v));\n         }\n         foreign_item_const(t) => {\n-            (v.visit_ty)(t, e, v);\n+            (v.visit_ty)(t, (e, v));\n         }\n     }\n }\n \n pub fn visit_ty_param_bounds<E: Copy>(bounds: @OptVec<TyParamBound>,\n-                                      e: E, v: vt<E>) {\n+                                      (e, v): (E, vt<E>)) {\n     for bounds.each |bound| {\n         match *bound {\n-            TraitTyParamBound(ty) => visit_trait_ref(ty, e, v),\n+            TraitTyParamBound(ty) => visit_trait_ref(ty, (e, v)),\n             RegionTyParamBound => {}\n         }\n     }\n }\n \n-pub fn visit_generics<E: Copy>(generics: &Generics, e: E, v: vt<E>) {\n+pub fn visit_generics<E: Copy>(generics: &Generics, (e, v): (E, vt<E>)) {\n     for generics.ty_params.each |tp| {\n-        visit_ty_param_bounds(tp.bounds, e, v);\n+        visit_ty_param_bounds(tp.bounds, (e, v));\n     }\n }\n \n-pub fn visit_fn_decl<E: Copy>(fd: &fn_decl, e: E, v: vt<E>) {\n+pub fn visit_fn_decl<E: Copy>(fd: &fn_decl, (e, v): (E, vt<E>)) {\n     for fd.inputs.each |a| {\n-        (v.visit_pat)(a.pat, e, v);\n-        (v.visit_ty)(a.ty, e, v);\n+        (v.visit_pat)(a.pat, (e, v));\n+        (v.visit_ty)(a.ty, (e, v));\n     }\n-    (v.visit_ty)(fd.output, e, v);\n+    (v.visit_ty)(fd.output, (e, v));\n }\n \n // Note: there is no visit_method() method in the visitor, instead override\n // visit_fn() and check for fk_method().  I named this visit_method_helper()\n // because it is not a default impl of any method, though I doubt that really\n // clarifies anything. - Niko\n-pub fn visit_method_helper<E: Copy>(m: &method, e: E, v: vt<E>) {\n+pub fn visit_method_helper<E: Copy>(m: &method, (e, v): (E, vt<E>)) {\n     (v.visit_fn)(\n         &fk_method(\n             /* FIXME (#2543) */ copy m.ident,\n@@ -363,29 +360,28 @@ pub fn visit_method_helper<E: Copy>(m: &method, e: E, v: vt<E>) {\n         &m.body,\n         m.span,\n         m.id,\n-        e,\n-        v\n+        (e, v)\n     );\n }\n \n pub fn visit_fn<E: Copy>(fk: &fn_kind, decl: &fn_decl, body: &blk, _sp: span,\n-                         _id: node_id, e: E, v: vt<E>) {\n-    visit_fn_decl(decl, e, v);\n+                         _id: node_id, (e, v): (E, vt<E>)) {\n+    visit_fn_decl(decl, (e, v));\n     let generics = generics_of_fn(fk);\n-    (v.visit_generics)(&generics, e, v);\n-    (v.visit_block)(body, e, v);\n+    (v.visit_generics)(&generics, (e, v));\n+    (v.visit_block)(body, (e, v));\n }\n \n-pub fn visit_ty_method<E: Copy>(m: &ty_method, e: E, v: vt<E>) {\n-    for m.decl.inputs.each |a| { (v.visit_ty)(a.ty, e, v); }\n-    (v.visit_generics)(&m.generics, e, v);\n-    (v.visit_ty)(m.decl.output, e, v);\n+pub fn visit_ty_method<E: Copy>(m: &ty_method, (e, v): (E, vt<E>)) {\n+    for m.decl.inputs.each |a| { (v.visit_ty)(a.ty, (e, v)); }\n+    (v.visit_generics)(&m.generics, (e, v));\n+    (v.visit_ty)(m.decl.output, (e, v));\n }\n \n-pub fn visit_trait_method<E: Copy>(m: &trait_method, e: E, v: vt<E>) {\n+pub fn visit_trait_method<E: Copy>(m: &trait_method, (e, v): (E, vt<E>)) {\n     match *m {\n-      required(ref ty_m) => (v.visit_ty_method)(ty_m, e, v),\n-      provided(m) => visit_method_helper(m, e, v)\n+      required(ref ty_m) => (v.visit_ty_method)(ty_m, (e, v)),\n+      provided(m) => visit_method_helper(m, (e, v))\n     }\n }\n \n@@ -394,109 +390,108 @@ pub fn visit_struct_def<E: Copy>(\n     _nm: ast::ident,\n     _generics: &Generics,\n     _id: node_id,\n-    e: E,\n-    v: vt<E>\n+    (e, v): (E, vt<E>)\n ) {\n     for sd.fields.each |f| {\n-        (v.visit_struct_field)(*f, e, v);\n+        (v.visit_struct_field)(*f, (e, v));\n     }\n }\n \n-pub fn visit_struct_field<E: Copy>(sf: @struct_field, e: E, v: vt<E>) {\n-    (v.visit_ty)(sf.node.ty, e, v);\n+pub fn visit_struct_field<E: Copy>(sf: @struct_field, (e, v): (E, vt<E>)) {\n+    (v.visit_ty)(sf.node.ty, (e, v));\n }\n \n-pub fn visit_struct_method<E: Copy>(m: @method, e: E, v: vt<E>) {\n-    visit_method_helper(m, e, v);\n+pub fn visit_struct_method<E: Copy>(m: @method, (e, v): (E, vt<E>)) {\n+    visit_method_helper(m, (e, v));\n }\n \n-pub fn visit_block<E: Copy>(b: &blk, e: E, v: vt<E>) {\n+pub fn visit_block<E: Copy>(b: &blk, (e, v): (E, vt<E>)) {\n     for b.node.view_items.each |vi| {\n-        (v.visit_view_item)(*vi, e, v);\n+        (v.visit_view_item)(*vi, (e, v));\n     }\n     for b.node.stmts.each |s| {\n-        (v.visit_stmt)(*s, e, v);\n+        (v.visit_stmt)(*s, (e, v));\n     }\n-    visit_expr_opt(b.node.expr, e, v);\n+    visit_expr_opt(b.node.expr, (e, v));\n }\n \n-pub fn visit_stmt<E>(s: @stmt, e: E, v: vt<E>) {\n+pub fn visit_stmt<E>(s: @stmt, (e, v): (E, vt<E>)) {\n     match s.node {\n-      stmt_decl(d, _) => (v.visit_decl)(d, e, v),\n-      stmt_expr(ex, _) => (v.visit_expr)(ex, e, v),\n-      stmt_semi(ex, _) => (v.visit_expr)(ex, e, v),\n-      stmt_mac(ref mac, _) => visit_mac(mac, e, v)\n+      stmt_decl(d, _) => (v.visit_decl)(d, (e, v)),\n+      stmt_expr(ex, _) => (v.visit_expr)(ex, (e, v)),\n+      stmt_semi(ex, _) => (v.visit_expr)(ex, (e, v)),\n+      stmt_mac(ref mac, _) => visit_mac(mac, (e, v))\n     }\n }\n \n-pub fn visit_decl<E: Copy>(d: @decl, e: E, v: vt<E>) {\n+pub fn visit_decl<E: Copy>(d: @decl, (e, v): (E, vt<E>)) {\n     match d.node {\n-        decl_local(ref loc) => (v.visit_local)(*loc, e, v),\n-        decl_item(it) => (v.visit_item)(it, e, v)\n+        decl_local(ref loc) => (v.visit_local)(*loc, (e, v)),\n+        decl_item(it) => (v.visit_item)(it, (e, v))\n     }\n }\n \n-pub fn visit_expr_opt<E>(eo: Option<@expr>, e: E, v: vt<E>) {\n-    match eo { None => (), Some(ex) => (v.visit_expr)(ex, e, v) }\n+pub fn visit_expr_opt<E>(eo: Option<@expr>, (e, v): (E, vt<E>)) {\n+    match eo { None => (), Some(ex) => (v.visit_expr)(ex, (e, v)) }\n }\n \n-pub fn visit_exprs<E: Copy>(exprs: &[@expr], e: E, v: vt<E>) {\n-    for exprs.each |ex| { (v.visit_expr)(*ex, e, v); }\n+pub fn visit_exprs<E: Copy>(exprs: &[@expr], (e, v): (E, vt<E>)) {\n+    for exprs.each |ex| { (v.visit_expr)(*ex, (e, v)); }\n }\n \n-pub fn visit_mac<E>(_m: &mac, _e: E, _v: vt<E>) {\n+pub fn visit_mac<E>(_m: &mac, (_e, _v): (E, vt<E>)) {\n     /* no user-serviceable parts inside */\n }\n \n-pub fn visit_expr<E: Copy>(ex: @expr, e: E, v: vt<E>) {\n+pub fn visit_expr<E: Copy>(ex: @expr, (e, v): (E, vt<E>)) {\n     match ex.node {\n-        expr_vstore(x, _) => (v.visit_expr)(x, e, v),\n-        expr_vec(ref es, _) => visit_exprs(*es, e, v),\n+        expr_vstore(x, _) => (v.visit_expr)(x, (e, v)),\n+        expr_vec(ref es, _) => visit_exprs(*es, (e, v)),\n         expr_repeat(element, count, _) => {\n-            (v.visit_expr)(element, e, v);\n-            (v.visit_expr)(count, e, v);\n+            (v.visit_expr)(element, (e, v));\n+            (v.visit_expr)(count, (e, v));\n         }\n         expr_struct(p, ref flds, base) => {\n-            visit_path(p, e, v);\n-            for flds.each |f| { (v.visit_expr)(f.node.expr, e, v); }\n-            visit_expr_opt(base, e, v);\n+            visit_path(p, (e, v));\n+            for flds.each |f| { (v.visit_expr)(f.node.expr, (e, v)); }\n+            visit_expr_opt(base, (e, v));\n         }\n         expr_tup(ref elts) => {\n-            for elts.each |el| { (v.visit_expr)(*el, e, v) }\n+            for elts.each |el| { (v.visit_expr)(*el, (e, v)) }\n         }\n         expr_call(callee, ref args, _) => {\n-            visit_exprs(*args, e, v);\n-            (v.visit_expr)(callee, e, v);\n+            visit_exprs(*args, (e, v));\n+            (v.visit_expr)(callee, (e, v));\n         }\n         expr_method_call(_, callee, _, ref tys, ref args, _) => {\n-            visit_exprs(*args, e, v);\n-            for tys.each |tp| { (v.visit_ty)(*tp, e, v); }\n-            (v.visit_expr)(callee, e, v);\n+            visit_exprs(*args, (e, v));\n+            for tys.each |tp| { (v.visit_ty)(*tp, (e, v)); }\n+            (v.visit_expr)(callee, (e, v));\n         }\n         expr_binary(_, _, a, b) => {\n-            (v.visit_expr)(a, e, v);\n-            (v.visit_expr)(b, e, v);\n+            (v.visit_expr)(a, (e, v));\n+            (v.visit_expr)(b, (e, v));\n         }\n         expr_addr_of(_, x) | expr_unary(_, _, x) |\n-        expr_loop_body(x) | expr_do_body(x) => (v.visit_expr)(x, e, v),\n+        expr_loop_body(x) | expr_do_body(x) => (v.visit_expr)(x, (e, v)),\n         expr_lit(_) => (),\n         expr_cast(x, t) => {\n-            (v.visit_expr)(x, e, v);\n-            (v.visit_ty)(t, e, v);\n+            (v.visit_expr)(x, (e, v));\n+            (v.visit_ty)(t, (e, v));\n         }\n         expr_if(x, ref b, eo) => {\n-            (v.visit_expr)(x, e, v);\n-            (v.visit_block)(b, e, v);\n-            visit_expr_opt(eo, e, v);\n+            (v.visit_expr)(x, (e, v));\n+            (v.visit_block)(b, (e, v));\n+            visit_expr_opt(eo, (e, v));\n         }\n         expr_while(x, ref b) => {\n-            (v.visit_expr)(x, e, v);\n-            (v.visit_block)(b, e, v);\n+            (v.visit_expr)(x, (e, v));\n+            (v.visit_block)(b, (e, v));\n         }\n-        expr_loop(ref b, _) => (v.visit_block)(b, e, v),\n+        expr_loop(ref b, _) => (v.visit_block)(b, (e, v)),\n         expr_match(x, ref arms) => {\n-            (v.visit_expr)(x, e, v);\n-            for arms.each |a| { (v.visit_arm)(a, e, v); }\n+            (v.visit_expr)(x, (e, v));\n+            for arms.each |a| { (v.visit_arm)(a, (e, v)); }\n         }\n         expr_fn_block(ref decl, ref body) => {\n             (v.visit_fn)(\n@@ -505,55 +500,54 @@ pub fn visit_expr<E: Copy>(ex: @expr, e: E, v: vt<E>) {\n                 body,\n                 ex.span,\n                 ex.id,\n-                e,\n-                v\n+                (e, v)\n             );\n         }\n-        expr_block(ref b) => (v.visit_block)(b, e, v),\n+        expr_block(ref b) => (v.visit_block)(b, (e, v)),\n         expr_assign(a, b) => {\n-            (v.visit_expr)(b, e, v);\n-            (v.visit_expr)(a, e, v);\n+            (v.visit_expr)(b, (e, v));\n+            (v.visit_expr)(a, (e, v));\n         }\n-        expr_copy(a) => (v.visit_expr)(a, e, v),\n+        expr_copy(a) => (v.visit_expr)(a, (e, v)),\n         expr_assign_op(_, _, a, b) => {\n-            (v.visit_expr)(b, e, v);\n-            (v.visit_expr)(a, e, v);\n+            (v.visit_expr)(b, (e, v));\n+            (v.visit_expr)(a, (e, v));\n         }\n         expr_field(x, _, ref tys) => {\n-            (v.visit_expr)(x, e, v);\n-            for tys.each |tp| { (v.visit_ty)(*tp, e, v); }\n+            (v.visit_expr)(x, (e, v));\n+            for tys.each |tp| { (v.visit_ty)(*tp, (e, v)); }\n         }\n         expr_index(_, a, b) => {\n-            (v.visit_expr)(a, e, v);\n-            (v.visit_expr)(b, e, v);\n+            (v.visit_expr)(a, (e, v));\n+            (v.visit_expr)(b, (e, v));\n         }\n-        expr_path(p) => visit_path(p, e, v),\n+        expr_path(p) => visit_path(p, (e, v)),\n         expr_self => (),\n         expr_break(_) => (),\n         expr_again(_) => (),\n-        expr_ret(eo) => visit_expr_opt(eo, e, v),\n+        expr_ret(eo) => visit_expr_opt(eo, (e, v)),\n         expr_log(lv, x) => {\n-            (v.visit_expr)(lv, e, v);\n-            (v.visit_expr)(x, e, v);\n+            (v.visit_expr)(lv, (e, v));\n+            (v.visit_expr)(x, (e, v));\n         }\n-        expr_mac(ref mac) => visit_mac(mac, e, v),\n-        expr_paren(x) => (v.visit_expr)(x, e, v),\n+        expr_mac(ref mac) => visit_mac(mac, (e, v)),\n+        expr_paren(x) => (v.visit_expr)(x, (e, v)),\n         expr_inline_asm(ref a) => {\n             for a.inputs.each |&(_, in)| {\n-                (v.visit_expr)(in, e, v);\n+                (v.visit_expr)(in, (e, v));\n             }\n             for a.outputs.each |&(_, out)| {\n-                (v.visit_expr)(out, e, v);\n+                (v.visit_expr)(out, (e, v));\n             }\n         }\n     }\n-    (v.visit_expr_post)(ex, e, v);\n+    (v.visit_expr_post)(ex, (e, v));\n }\n \n-pub fn visit_arm<E: Copy>(a: &arm, e: E, v: vt<E>) {\n-    for a.pats.iter().advance |p| { (v.visit_pat)(*p, e, v); }\n-    visit_expr_opt(a.guard, e, v);\n-    (v.visit_block)(&a.body, e, v);\n+pub fn visit_arm<E: Copy>(a: &arm, (e, v): (E, vt<E>)) {\n+    for a.pats.iter().advance |p| { (v.visit_pat)(*p, (e, v)); }\n+    visit_expr_opt(a.guard, (e, v));\n+    (v.visit_block)(&a.body, (e, v));\n }\n \n // Simpler, non-context passing interface. Always walks the whole tree, simply\n@@ -617,91 +611,86 @@ pub fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n         m: &_mod,\n         sp: span,\n         id: node_id,\n-        e: (),\n-        v: vt<()>\n+        (e, v): ((), vt<()>)\n     ) {\n         f(m, sp, id);\n-        visit_mod(m, sp, id, e, v);\n+        visit_mod(m, sp, id, (e, v));\n     }\n-    fn v_view_item(f: @fn(@view_item), vi: @view_item, e: (), v: vt<()>) {\n+    fn v_view_item(f: @fn(@view_item), vi: @view_item, (e, v): ((), vt<()>)) {\n         f(vi);\n-        visit_view_item(vi, e, v);\n+        visit_view_item(vi, (e, v));\n     }\n-    fn v_foreign_item(f: @fn(@foreign_item), ni: @foreign_item, e: (),\n-                      v: vt<()>) {\n+    fn v_foreign_item(f: @fn(@foreign_item), ni: @foreign_item, (e, v): ((), vt<()>)) {\n         f(ni);\n-        visit_foreign_item(ni, e, v);\n+        visit_foreign_item(ni, (e, v));\n     }\n-    fn v_item(f: @fn(@item), i: @item, e: (), v: vt<()>) {\n+    fn v_item(f: @fn(@item), i: @item, (e, v): ((), vt<()>)) {\n         f(i);\n-        visit_item(i, e, v);\n+        visit_item(i, (e, v));\n     }\n-    fn v_local(f: @fn(@local), l: @local, e: (), v: vt<()>) {\n+    fn v_local(f: @fn(@local), l: @local, (e, v): ((), vt<()>)) {\n         f(l);\n-        visit_local(l, e, v);\n+        visit_local(l, (e, v));\n     }\n-    fn v_block(f: @fn(&ast::blk), bl: &ast::blk, e: (), v: vt<()>) {\n+    fn v_block(f: @fn(&ast::blk), bl: &ast::blk, (e, v): ((), vt<()>)) {\n         f(bl);\n-        visit_block(bl, e, v);\n+        visit_block(bl, (e, v));\n     }\n-    fn v_stmt(f: @fn(@stmt), st: @stmt, e: (), v: vt<()>) {\n+    fn v_stmt(f: @fn(@stmt), st: @stmt, (e, v): ((), vt<()>)) {\n         f(st);\n-        visit_stmt(st, e, v);\n+        visit_stmt(st, (e, v));\n     }\n-    fn v_arm(f: @fn(&arm), a: &arm, e: (), v: vt<()>) {\n+    fn v_arm(f: @fn(&arm), a: &arm, (e, v): ((), vt<()>)) {\n         f(a);\n-        visit_arm(a, e, v);\n+        visit_arm(a, (e, v));\n     }\n-    fn v_pat(f: @fn(@pat), p: @pat, e: (), v: vt<()>) {\n+    fn v_pat(f: @fn(@pat), p: @pat, (e, v): ((), vt<()>)) {\n         f(p);\n-        visit_pat(p, e, v);\n+        visit_pat(p, (e, v));\n     }\n-    fn v_decl(f: @fn(@decl), d: @decl, e: (), v: vt<()>) {\n+    fn v_decl(f: @fn(@decl), d: @decl, (e, v): ((), vt<()>)) {\n         f(d);\n-        visit_decl(d, e, v);\n+        visit_decl(d, (e, v));\n     }\n-    fn v_expr(f: @fn(@expr), ex: @expr, e: (), v: vt<()>) {\n+    fn v_expr(f: @fn(@expr), ex: @expr, (e, v): ((), vt<()>)) {\n         f(ex);\n-        visit_expr(ex, e, v);\n+        visit_expr(ex, (e, v));\n     }\n-    fn v_expr_post(f: @fn(@expr), ex: @expr, _e: (), _v: vt<()>) {\n+    fn v_expr_post(f: @fn(@expr), ex: @expr, (_e, _v): ((), vt<()>)) {\n         f(ex);\n     }\n-    fn v_ty(f: @fn(@Ty), ty: @Ty, e: (), v: vt<()>) {\n+    fn v_ty(f: @fn(@Ty), ty: @Ty, (e, v): ((), vt<()>)) {\n         f(ty);\n-        visit_ty(ty, e, v);\n+        visit_ty(ty, (e, v));\n     }\n-    fn v_ty_method(f: @fn(&ty_method), ty: &ty_method, e: (), v: vt<()>) {\n+    fn v_ty_method(f: @fn(&ty_method), ty: &ty_method, (e, v): ((), vt<()>)) {\n         f(ty);\n-        visit_ty_method(ty, e, v);\n+        visit_ty_method(ty, (e, v));\n     }\n     fn v_trait_method(f: @fn(&trait_method),\n                       m: &trait_method,\n-                      e: (),\n-                      v: vt<()>) {\n+                      (e, v): ((), vt<()>)) {\n         f(m);\n-        visit_trait_method(m, e, v);\n+        visit_trait_method(m, (e, v));\n     }\n     fn v_struct_def(\n         f: @fn(@struct_def, ident, &Generics, node_id),\n         sd: @struct_def,\n         nm: ident,\n         generics: &Generics,\n         id: node_id,\n-        e: (),\n-        v: vt<()>\n+        (e, v): ((), vt<()>)\n     ) {\n         f(sd, nm, generics, id);\n-        visit_struct_def(sd, nm, generics, id, e, v);\n+        visit_struct_def(sd, nm, generics, id, (e, v));\n     }\n     fn v_generics(\n         f: @fn(&Generics),\n         ps: &Generics,\n-        e: (),\n-        v: vt<()>\n+        (e, v): ((), vt<()>)\n     ) {\n         f(ps);\n-        visit_generics(ps, e, v);\n+        visit_generics(ps, (e, v));\n     }\n     fn v_fn(\n         f: @fn(&fn_kind, &fn_decl, &blk, span, node_id),\n@@ -710,52 +699,49 @@ pub fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n         body: &blk,\n         sp: span,\n         id: node_id,\n-        e: (),\n-        v: vt<()>\n+        (e, v): ((), vt<()>)\n     ) {\n         f(fk, decl, body, sp, id);\n-        visit_fn(fk, decl, body, sp, id, e, v);\n+        visit_fn(fk, decl, body, sp, id, (e, v));\n     }\n-    let visit_ty: @fn(@Ty, x: (), vt<()>) =\n-        |a,b,c| v_ty(v.visit_ty, a, b, c);\n-    fn v_struct_field(f: @fn(@struct_field), sf: @struct_field, e: (),\n-                      v: vt<()>) {\n+    let visit_ty: @fn(@Ty, ((), vt<()>)) =\n+        |a,b| v_ty(v.visit_ty, a, b);\n+    fn v_struct_field(f: @fn(@struct_field), sf: @struct_field, (e, v): ((), vt<()>)) {\n         f(sf);\n-        visit_struct_field(sf, e, v);\n+        visit_struct_field(sf, (e, v));\n     }\n-    fn v_struct_method(f: @fn(@method), m: @method, e: (), v: vt<()>) {\n+    fn v_struct_method(f: @fn(@method), m: @method, (e, v): ((), vt<()>)) {\n         f(m);\n-        visit_struct_method(m, e, v);\n+        visit_struct_method(m, (e, v));\n     }\n     return mk_vt(@Visitor {\n-        visit_mod: |a,b,c,d,e|v_mod(v.visit_mod, a, b, c, d, e),\n-        visit_view_item: |a,b,c| v_view_item(v.visit_view_item, a, b, c),\n+        visit_mod: |a,b,c,d|v_mod(v.visit_mod, a, b, c, d),\n+        visit_view_item: |a,b| v_view_item(v.visit_view_item, a, b),\n         visit_foreign_item:\n-            |a,b,c|v_foreign_item(v.visit_foreign_item, a, b, c),\n-        visit_item: |a,b,c|v_item(v.visit_item, a, b, c),\n-        visit_local: |a,b,c|v_local(v.visit_local, a, b, c),\n-        visit_block: |a,b,c|v_block(v.visit_block, a, b, c),\n-        visit_stmt: |a,b,c|v_stmt(v.visit_stmt, a, b, c),\n-        visit_arm: |a,b,c|v_arm(v.visit_arm, a, b, c),\n-        visit_pat: |a,b,c|v_pat(v.visit_pat, a, b, c),\n-        visit_decl: |a,b,c|v_decl(v.visit_decl, a, b, c),\n-        visit_expr: |a,b,c|v_expr(v.visit_expr, a, b, c),\n-        visit_expr_post: |a,b,c| v_expr_post(v.visit_expr_post,\n-                                             a, b, c),\n+            |a,b|v_foreign_item(v.visit_foreign_item, a, b),\n+        visit_item: |a,b|v_item(v.visit_item, a, b),\n+        visit_local: |a,b|v_local(v.visit_local, a, b),\n+        visit_block: |a,b|v_block(v.visit_block, a, b),\n+        visit_stmt: |a,b|v_stmt(v.visit_stmt, a, b),\n+        visit_arm: |a,b|v_arm(v.visit_arm, a, b),\n+        visit_pat: |a,b|v_pat(v.visit_pat, a, b),\n+        visit_decl: |a,b|v_decl(v.visit_decl, a, b),\n+        visit_expr: |a,b|v_expr(v.visit_expr, a, b),\n+        visit_expr_post: |a,b| v_expr_post(v.visit_expr_post, a, b),\n         visit_ty: visit_ty,\n-        visit_generics: |a,b,c|\n-            v_generics(v.visit_generics, a, b, c),\n-        visit_fn: |a,b,c,d,e,f,g|\n-            v_fn(v.visit_fn, a, b, c, d, e, f, g),\n-        visit_ty_method: |a,b,c|\n-            v_ty_method(v.visit_ty_method, a, b, c),\n-        visit_trait_method: |a,b,c|\n-            v_trait_method(v.visit_trait_method, a, b, c),\n-        visit_struct_def: |a,b,c,d,e,f|\n-            v_struct_def(v.visit_struct_def, a, b, c, d, e, f),\n-        visit_struct_field: |a,b,c|\n-            v_struct_field(v.visit_struct_field, a, b, c),\n-        visit_struct_method: |a,b,c|\n-            v_struct_method(v.visit_struct_method, a, b, c)\n+        visit_generics: |a,b|\n+            v_generics(v.visit_generics, a, b),\n+        visit_fn: |a,b,c,d,e,f|\n+            v_fn(v.visit_fn, a, b, c, d, e, f),\n+        visit_ty_method: |a,b|\n+            v_ty_method(v.visit_ty_method, a, b),\n+        visit_trait_method: |a,b|\n+            v_trait_method(v.visit_trait_method, a, b),\n+        visit_struct_def: |a,b,c,d,e|\n+            v_struct_def(v.visit_struct_def, a, b, c, d, e),\n+        visit_struct_field: |a,b|\n+            v_struct_field(v.visit_struct_field, a, b),\n+        visit_struct_method: |a,b|\n+            v_struct_method(v.visit_struct_method, a, b)\n     });\n }"}]}