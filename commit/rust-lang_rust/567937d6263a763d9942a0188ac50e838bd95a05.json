{"sha": "567937d6263a763d9942a0188ac50e838bd95a05", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2NzkzN2Q2MjYzYTc2M2Q5OTQyYTAxODhhYzUwZTgzOGJkOTVhMDU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-09T00:13:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-09T00:13:19Z"}, "message": "Auto merge of #32126 - steveklabnik:rollup, r=steveklabnik\n\nRollup of 7 pull requests\n\n- Successful merges: #31772, #32083, #32084, #32092, #32099, #32103, #32115\n- Failed merges:", "tree": {"sha": "58bfe9fd4730d587aad8ff35a719fec97c8d0e2e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/58bfe9fd4730d587aad8ff35a719fec97c8d0e2e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/567937d6263a763d9942a0188ac50e838bd95a05", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/567937d6263a763d9942a0188ac50e838bd95a05", "html_url": "https://github.com/rust-lang/rust/commit/567937d6263a763d9942a0188ac50e838bd95a05", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/567937d6263a763d9942a0188ac50e838bd95a05/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eabfc160f87ccc0b296f49af7fe688506580c473", "url": "https://api.github.com/repos/rust-lang/rust/commits/eabfc160f87ccc0b296f49af7fe688506580c473", "html_url": "https://github.com/rust-lang/rust/commit/eabfc160f87ccc0b296f49af7fe688506580c473"}, {"sha": "33fe4d10fc2e81ef4d2f601e9982cc9dbe5615a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/33fe4d10fc2e81ef4d2f601e9982cc9dbe5615a5", "html_url": "https://github.com/rust-lang/rust/commit/33fe4d10fc2e81ef4d2f601e9982cc9dbe5615a5"}], "stats": {"total": 147, "additions": 105, "deletions": 42}, "files": [{"sha": "7f7f7d4c8ebdb87f37cfb0c8059fee086098e1e8", "filename": "src/doc/book/ownership.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/567937d6263a763d9942a0188ac50e838bd95a05/src%2Fdoc%2Fbook%2Fownership.md", "raw_url": "https://github.com/rust-lang/rust/raw/567937d6263a763d9942a0188ac50e838bd95a05/src%2Fdoc%2Fbook%2Fownership.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fownership.md?ref=567937d6263a763d9942a0188ac50e838bd95a05", "patch": "@@ -51,7 +51,7 @@ fn foo() {\n }\n ```\n \n-When `v` comes into scope, a new [vector] is created on [the stack][stack],\n+When `v` comes into scope, a new [vector][vectors] is created on [the stack][stack],\n and it allocates space on [the heap][heap] for its elements. When `v` goes out\n of scope at the end of `foo()`, Rust will clean up everything related to the\n vector, even the heap-allocated memory. This happens deterministically, at the"}, {"sha": "7be5cc442dd5f912ae441d4e7370fc9aa3cb009b", "filename": "src/doc/book/references-and-borrowing.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/567937d6263a763d9942a0188ac50e838bd95a05/src%2Fdoc%2Fbook%2Freferences-and-borrowing.md", "raw_url": "https://github.com/rust-lang/rust/raw/567937d6263a763d9942a0188ac50e838bd95a05/src%2Fdoc%2Fbook%2Freferences-and-borrowing.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Freferences-and-borrowing.md?ref=567937d6263a763d9942a0188ac50e838bd95a05", "patch": "@@ -23,7 +23,7 @@ Before we get to the details, two important notes about the ownership system.\n Rust has a focus on safety and speed. It accomplishes these goals through many\n \u2018zero-cost abstractions\u2019, which means that in Rust, abstractions cost as little\n as possible in order to make them work. The ownership system is a prime example\n-of a zero cost abstraction. All of the analysis we\u2019ll talk about in this guide\n+of a zero-cost abstraction. All of the analysis we\u2019ll talk about in this guide\n is _done at compile time_. You do not pay any run-time cost for any of these\n features.\n "}, {"sha": "3e889f51f542d2d7541933d62771d05942c3e6c6", "filename": "src/doc/book/syntax-index.md", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/567937d6263a763d9942a0188ac50e838bd95a05/src%2Fdoc%2Fbook%2Fsyntax-index.md", "raw_url": "https://github.com/rust-lang/rust/raw/567937d6263a763d9942a0188ac50e838bd95a05/src%2Fdoc%2Fbook%2Fsyntax-index.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fsyntax-index.md?ref=567937d6263a763d9942a0188ac50e838bd95a05", "patch": "@@ -43,23 +43,23 @@\n * `!` (`!expr`): bitwise or logical complement.  Overloadable (`Not`).\n * `!=` (`var != expr`): nonequality comparison.  Overloadable (`PartialEq`).\n * `%` (`expr % expr`): arithmetic remainder.  Overloadable (`Rem`).\n-* `%=` (`var %= expr`): arithmetic remainder & assignment.\n+* `%=` (`var %= expr`): arithmetic remainder & assignment. Overloadable (`RemAssign`).\n * `&` (`expr & expr`): bitwise and.  Overloadable (`BitAnd`).\n * `&` (`&expr`): borrow.  See [References and Borrowing].\n * `&` (`&type`, `&mut type`, `&'a type`, `&'a mut type`): borrowed pointer type.  See [References and Borrowing].\n-* `&=` (`var &= expr`): bitwise and & assignment.\n+* `&=` (`var &= expr`): bitwise and & assignment. Overloadable (`BitAndAssign`).\n * `&&` (`expr && expr`): logical and.\n * `*` (`expr * expr`): arithmetic multiplication.  Overloadable (`Mul`).\n * `*` (`*expr`): dereference.\n * `*` (`*const type`, `*mut type`): raw pointer.  See [Raw Pointers].\n-* `*=` (`var *= expr`): arithmetic multiplication & assignment.\n+* `*=` (`var *= expr`): arithmetic multiplication & assignment. Overloadable (`MulAssign`).\n * `+` (`expr + expr`): arithmetic addition.  Overloadable (`Add`).\n * `+` (`trait + trait`, `'a + trait`): compound type constraint.  See [Traits (Multiple Trait Bounds)].\n-* `+=` (`var += expr`): arithmetic addition & assignment.\n+* `+=` (`var += expr`): arithmetic addition & assignment. Overloadable (`AddAssign`).\n * `,`: argument and element separator.  See [Attributes], [Functions], [Structs], [Generics], [Match], [Closures], [Crates and Modules (Importing Modules with `use`)].\n * `-` (`expr - expr`): arithmetic subtraction.  Overloadable (`Sub`).\n * `-` (`- expr`): arithmetic negation.  Overloadable (`Neg`).\n-* `-=` (`var -= expr`): arithmetic subtraction & assignment.\n+* `-=` (`var -= expr`): arithmetic subtraction & assignment. Overloadable (`SubAssign`).\n * `->` (`fn(\u2026) -> type`, `|\u2026| -> type`): function and closure return type.  See [Functions], [Closures].\n * `-> !` (`fn(\u2026) -> !`, `|\u2026| -> !`): diverging function or closure. See [Diverging Functions].\n * `.` (`expr.ident`): member access.  See [Structs], [Method Syntax].\n@@ -69,14 +69,14 @@\n * `...` (`...expr`, `expr...expr`) *in an expression*: inclusive range expression. See [Iterators].\n * `...` (`expr...expr`) *in a pattern*: inclusive range pattern.  See [Patterns (Ranges)].\n * `/` (`expr / expr`): arithmetic division.  Overloadable (`Div`).\n-* `/=` (`var /= expr`): arithmetic division & assignment.\n+* `/=` (`var /= expr`): arithmetic division & assignment. Overloadable (`DivAssign`).\n * `:` (`pat: type`, `ident: type`): constraints.  See [Variable Bindings], [Functions], [Structs], [Traits].\n * `:` (`ident: expr`): struct field initializer.  See [Structs].\n * `:` (`'a: loop {\u2026}`): loop label.  See [Loops (Loops Labels)].\n * `;`: statement and item terminator.\n * `;` (`[\u2026; len]`): part of fixed-size array syntax.  See [Primitive Types (Arrays)].\n * `<<` (`expr << expr`): left-shift.  Overloadable (`Shl`).\n-* `<<=` (`var <<= expr`): left-shift & assignment.\n+* `<<=` (`var <<= expr`): left-shift & assignment. Overloadable (`ShlAssign`).\n * `<` (`expr < expr`): less-than comparison.  Overloadable (`PartialOrd`).\n * `<=` (`var <= expr`): less-than or equal-to comparison.  Overloadable (`PartialOrd`).\n * `=` (`var = expr`, `ident = type`): assignment/equivalence.  See [Variable Bindings], [`type` Aliases], generic parameter defaults.\n@@ -85,14 +85,14 @@\n * `>` (`expr > expr`): greater-than comparison.  Overloadable (`PartialOrd`).\n * `>=` (`var >= expr`): greater-than or equal-to comparison.  Overloadable (`PartialOrd`).\n * `>>` (`expr >> expr`): right-shift.  Overloadable (`Shr`).\n-* `>>=` (`var >>= expr`): right-shift & assignment.\n+* `>>=` (`var >>= expr`): right-shift & assignment. Overloadable (`ShrAssign`).\n * `@` (`ident @ pat`): pattern binding.  See [Patterns (Bindings)].\n * `^` (`expr ^ expr`): bitwise exclusive or.  Overloadable (`BitXor`).\n-* `^=` (`var ^= expr`): bitwise exclusive or & assignment.\n+* `^=` (`var ^= expr`): bitwise exclusive or & assignment. Overloadable (`BitXorAssign`).\n * `|` (`expr | expr`): bitwise or.  Overloadable (`BitOr`).\n * `|` (`pat | pat`): pattern alternatives.  See [Patterns (Multiple patterns)].\n * `|` (`|\u2026| expr`): closures.  See [Closures].\n-* `|=` (`var |= expr`): bitwise or & assignment.\n+* `|=` (`var |= expr`): bitwise or & assignment. Overloadable (`BitOrAssign`).\n * `||` (`expr || expr`): logical or.\n * `_`: \"ignored\" pattern binding.  See [Patterns (Ignoring bindings)].\n "}, {"sha": "8e655ee22e302f279b674d34662520e956229684", "filename": "src/doc/reference.md", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/567937d6263a763d9942a0188ac50e838bd95a05/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/567937d6263a763d9942a0188ac50e838bd95a05/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=567937d6263a763d9942a0188ac50e838bd95a05", "patch": "@@ -1118,6 +1118,16 @@ type Point = (u8, u8);\n let p: Point = (41, 68);\n ```\n \n+Currently a type alias to an enum type cannot be used to qualify the\n+constructors:\n+\n+```\n+enum E { A }\n+type F = E;\n+let _: F = E::A;  // OK\n+// let _: F = F::A;  // Doesn't work\n+```\n+\n ### Structs\n \n A _struct_ is a nominal [struct type](#struct-types) defined with the\n@@ -1195,18 +1205,24 @@ a = Animal::Cat { name: \"Spotty\".to_string(), weight: 2.7 };\n In this example, `Cat` is a _struct-like enum variant_,\n whereas `Dog` is simply called an enum variant.\n \n-Enums have a discriminant. You can assign them explicitly:\n+Each enum value has a _discriminant_ which is an integer associated to it. You\n+can specify it explicitly:\n \n ```\n enum Foo {\n     Bar = 123,\n }\n ```\n \n-If a discriminant isn't assigned, they start at zero, and add one for each\n+The right hand side of the specification is interpreted as an `isize` value,\n+but the compiler is allowed to use a smaller type in the actual memory layout.\n+The [`repr` attribute](#ffi-attributes) can be added in order to change\n+the type of the right hand side and specify the memory layout.\n+\n+If a discriminant isn't specified, they start at zero, and add one for each\n variant, in order.\n \n-You can cast an enum to get this value:\n+You can cast an enum to get its discriminant:\n \n ```\n # enum Foo { Bar = 123 }"}, {"sha": "435c9f0e9f4c38148dace07b3ac1a06a6cd85e10", "filename": "src/libcollections/fmt.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/567937d6263a763d9942a0188ac50e838bd95a05/src%2Flibcollections%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/567937d6263a763d9942a0188ac50e838bd95a05/src%2Flibcollections%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ffmt.rs?ref=567937d6263a763d9942a0188ac50e838bd95a05", "patch": "@@ -429,20 +429,20 @@\n //! For example, these:\n //!\n //! ```\n-//! // Hello {arg 0 (x)} is {arg 1 (0.01} with precision specified inline (5)}\n+//! // Hello {arg 0 (x)} is {arg 1 (0.01) with precision specified inline (5)}\n //! println!(\"Hello {0} is {1:.5}\", \"x\", 0.01);\n //!\n-//! // Hello {arg 1 (x)} is {arg 2 (0.01} with precision specified in arg 0 (5)}\n+//! // Hello {arg 1 (x)} is {arg 2 (0.01) with precision specified in arg 0 (5)}\n //! println!(\"Hello {1} is {2:.0$}\", 5, \"x\", 0.01);\n //!\n-//! // Hello {arg 0 (x)} is {arg 2 (0.01} with precision specified in arg 1 (5)}\n+//! // Hello {arg 0 (x)} is {arg 2 (0.01) with precision specified in arg 1 (5)}\n //! println!(\"Hello {0} is {2:.1$}\", \"x\", 5, 0.01);\n //!\n-//! // Hello {next arg (x)} is {second of next two args (0.01} with precision\n+//! // Hello {next arg (x)} is {second of next two args (0.01) with precision\n //! //                          specified in first of next two args (5)}\n //! println!(\"Hello {} is {:.*}\",    \"x\", 5, 0.01);\n //!\n-//! // Hello {next arg (x)} is {arg 2 (0.01} with precision\n+//! // Hello {next arg (x)} is {arg 2 (0.01) with precision\n //! //                          specified in its predecessor (5)}\n //! println!(\"Hello {} is {2:.*}\",   \"x\", 5, 0.01);\n //! ```"}, {"sha": "f5abdf65a5b4f525d1e8930286a59adf1f6ce8e6", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 51, "deletions": 13, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/567937d6263a763d9942a0188ac50e838bd95a05/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/567937d6263a763d9942a0188ac50e838bd95a05/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=567937d6263a763d9942a0188ac50e838bd95a05", "patch": "@@ -1311,13 +1311,19 @@ mod traits {\n         }\n     }\n \n+    /// Implements substring slicing with syntax `&self[begin .. end]`.\n+    ///\n     /// Returns a slice of the given string from the byte range\n     /// [`begin`..`end`).\n     ///\n     /// This operation is `O(1)`.\n     ///\n-    /// Panics when `begin` and `end` do not point to valid characters\n-    /// or point beyond the last character of the string.\n+    /// # Panics\n+    ///\n+    /// Panics if `begin` or `end` does not point to the starting\n+    /// byte offset of a character (as defined by `is_char_boundary`).\n+    /// Requires that `begin <= end` and `end <= len` where `len` is the\n+    /// length of the string.\n     ///\n     /// # Examples\n     ///\n@@ -1353,8 +1359,20 @@ mod traits {\n         }\n     }\n \n+    /// Implements mutable substring slicing with syntax\n+    /// `&mut self[begin .. end]`.\n+    ///\n     /// Returns a mutable slice of the given string from the byte range\n     /// [`begin`..`end`).\n+    ///\n+    /// This operation is `O(1)`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `begin` or `end` does not point to the starting\n+    /// byte offset of a character (as defined by `is_char_boundary`).\n+    /// Requires that `begin <= end` and `end <= len` where `len` is the\n+    /// length of the string.\n     #[stable(feature = \"derefmut_for_string\", since = \"1.2.0\")]\n     impl ops::IndexMut<ops::Range<usize>> for str {\n         #[inline]\n@@ -1370,13 +1388,12 @@ mod traits {\n         }\n     }\n \n-    /// Returns a slice of the string from the beginning to byte\n-    /// `end`.\n+    /// Implements substring slicing with syntax `&self[.. end]`.\n     ///\n-    /// Equivalent to `self[0 .. end]`.\n+    /// Returns a slice of the string from the beginning to byte offset\n+    /// `end`.\n     ///\n-    /// Panics when `end` does not point to a valid character, or is\n-    /// out of bounds.\n+    /// Equivalent to `&self[0 .. end]`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl ops::Index<ops::RangeTo<usize>> for str {\n         type Output = str;\n@@ -1392,8 +1409,12 @@ mod traits {\n         }\n     }\n \n-    /// Returns a mutable slice of the string from the beginning to byte\n+    /// Implements mutable substring slicing with syntax `&mut self[.. end]`.\n+    ///\n+    /// Returns a mutable slice of the string from the beginning to byte offset\n     /// `end`.\n+    ///\n+    /// Equivalent to `&mut self[0 .. end]`.\n     #[stable(feature = \"derefmut_for_string\", since = \"1.2.0\")]\n     impl ops::IndexMut<ops::RangeTo<usize>> for str {\n         #[inline]\n@@ -1407,12 +1428,12 @@ mod traits {\n         }\n     }\n \n-    /// Returns a slice of the string from `begin` to its end.\n+    /// Implements substring slicing with syntax `&self[begin ..]`.\n     ///\n-    /// Equivalent to `self[begin .. self.len()]`.\n+    /// Returns a slice of the string from byte offset `begin`\n+    /// to the end of the string.\n     ///\n-    /// Panics when `begin` does not point to a valid character, or is\n-    /// out of bounds.\n+    /// Equivalent to `&self[begin .. len]`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl ops::Index<ops::RangeFrom<usize>> for str {\n         type Output = str;\n@@ -1428,7 +1449,12 @@ mod traits {\n         }\n     }\n \n-    /// Returns a slice of the string from `begin` to its end.\n+    /// Implements mutable substring slicing with syntax `&mut self[begin ..]`.\n+    ///\n+    /// Returns a mutable slice of the string from byte offset `begin`\n+    /// to the end of the string.\n+    ///\n+    /// Equivalent to `&mut self[begin .. len]`.\n     #[stable(feature = \"derefmut_for_string\", since = \"1.2.0\")]\n     impl ops::IndexMut<ops::RangeFrom<usize>> for str {\n         #[inline]\n@@ -1443,6 +1469,12 @@ mod traits {\n         }\n     }\n \n+    /// Implements substring slicing with syntax `&self[..]`.\n+    ///\n+    /// Returns a slice of the whole string. This operation can\n+    /// never panic.\n+    ///\n+    /// Equivalent to `&self[0 .. len]`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl ops::Index<ops::RangeFull> for str {\n         type Output = str;\n@@ -1453,6 +1485,12 @@ mod traits {\n         }\n     }\n \n+    /// Implements mutable substring slicing with syntax `&mut self[..]`.\n+    ///\n+    /// Returns a mutable slice of the whole string. This operation can\n+    /// never panic.\n+    ///\n+    /// Equivalent to `&mut self[0 .. len]`.\n     #[stable(feature = \"derefmut_for_string\", since = \"1.2.0\")]\n     impl ops::IndexMut<ops::RangeFull> for str {\n         #[inline]"}, {"sha": "cfe76206b02903bf65a8e7974ae539a0fdeaa150", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/567937d6263a763d9942a0188ac50e838bd95a05/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/567937d6263a763d9942a0188ac50e838bd95a05/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=567937d6263a763d9942a0188ac50e838bd95a05", "patch": "@@ -1133,15 +1133,16 @@ enum Bad {\n }\n ```\n \n-Here `X` will have already been assigned the discriminant 0 by the time `Y` is\n+Here `X` will have already been specified the discriminant 0 by the time `Y` is\n encountered, so a conflict occurs.\n \"##,\n \n E0082: r##\"\n-The default type for enum discriminants is `isize`, but it can be adjusted by\n-adding the `repr` attribute to the enum declaration. This error indicates that\n-an integer literal given as a discriminant is not a member of the discriminant\n-type. For example:\n+When you specify enum discriminants with `=`, the compiler expects `isize`\n+values by default. Or you can add the `repr` attibute to the enum declaration\n+for an explicit choice of the discriminant type. In either cases, the\n+discriminant values must fall within a valid range for the expected type;\n+otherwise this error is raised. For example:\n \n ```compile_fail\n #[repr(u8)]\n@@ -1152,11 +1153,19 @@ enum Thing {\n ```\n \n Here, 1024 lies outside the valid range for `u8`, so the discriminant for `A` is\n-invalid. You may want to change representation types to fix this, or else change\n-invalid discriminant values so that they fit within the existing type.\n+invalid. Here is another, more subtle example which depends on target word size:\n \n-Note also that without a representation manually defined, the compiler will\n-optimize by using the smallest integer type possible.\n+```compile_fail\n+enum DependsOnPointerSize {\n+    A = 1 << 32\n+}\n+```\n+\n+Here, `1 << 32` is interpreted as an `isize` value. So it is invalid for 32 bit\n+target (`target_pointer_width = \"32\"`) but valid for 64 bit target.\n+\n+You may want to change representation types to fix this, or else change invalid\n+discriminant values so that they fit within the existing type.\n \"##,\n \n E0084: r##\""}]}