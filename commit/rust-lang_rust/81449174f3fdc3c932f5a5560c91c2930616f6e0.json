{"sha": "81449174f3fdc3c932f5a5560c91c2930616f6e0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxNDQ5MTc0ZjNmZGMzYzkzMmY1YTU1NjBjOTFjMjkzMDYxNmY2ZTA=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-10-30T09:50:39Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-10-31T16:41:40Z"}, "message": "make the dataflow / mir-borrowck types carry a `'tcx` lifetime\n\nAlso, factor out `do_mir_borrowck`, which is the code that actually\nperforms the MIR borrowck from within the scope of an inference context.\n\nThis change should be a pure refactoring.", "tree": {"sha": "15a741fd80e2f83595b7a89606d1b9a33cbc11a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/15a741fd80e2f83595b7a89606d1b9a33cbc11a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/81449174f3fdc3c932f5a5560c91c2930616f6e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/81449174f3fdc3c932f5a5560c91c2930616f6e0", "html_url": "https://github.com/rust-lang/rust/commit/81449174f3fdc3c932f5a5560c91c2930616f6e0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/81449174f3fdc3c932f5a5560c91c2930616f6e0/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "82b287a8c890100678563112e49f7b0533b09c5d", "url": "https://api.github.com/repos/rust-lang/rust/commits/82b287a8c890100678563112e49f7b0533b09c5d", "html_url": "https://github.com/rust-lang/rust/commit/82b287a8c890100678563112e49f7b0533b09c5d"}], "stats": {"total": 412, "additions": 211, "deletions": 201}, "files": [{"sha": "5ff7bcc3c16d5f6f88680fe8b28a585dd359eb03", "filename": "src/librustc_mir/borrow_check.rs", "status": "modified", "additions": 114, "deletions": 104, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/81449174f3fdc3c932f5a5560c91c2930616f6e0/src%2Flibrustc_mir%2Fborrow_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81449174f3fdc3c932f5a5560c91c2930616f6e0/src%2Flibrustc_mir%2Fborrow_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check.rs?ref=81449174f3fdc3c932f5a5560c91c2930616f6e0", "patch": "@@ -46,93 +46,103 @@ pub fn provide(providers: &mut Providers) {\n }\n \n fn mir_borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n-    let mir = tcx.mir_validated(def_id);\n+    let input_mir = tcx.mir_validated(def_id);\n     let src = MirSource::from_local_def_id(tcx, def_id);\n     debug!(\"run query mir_borrowck: {}\", tcx.node_path_str(src.item_id()));\n \n-    let mir: &Mir<'tcx> = &mir.borrow();\n     if !tcx.has_attr(def_id, \"rustc_mir_borrowck\") && !tcx.sess.opts.debugging_opts.borrowck_mir {\n         return;\n     }\n \n-    let id = src.item_id();\n+    tcx.infer_ctxt().enter(|infcx| {\n+        let input_mir: &Mir = &input_mir.borrow();\n+        do_mir_borrowck(&infcx, input_mir, def_id, src);\n+    });\n+    debug!(\"mir_borrowck done\");\n+}\n+\n+fn do_mir_borrowck<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                   mir: &Mir<'gcx>,\n+                                   def_id: DefId,\n+                                   src: MirSource)\n+{\n+    let tcx = infcx.tcx;\n     let attributes = tcx.get_attrs(def_id);\n     let param_env = tcx.param_env(def_id);\n-    tcx.infer_ctxt().enter(|_infcx| {\n-\n-        let move_data = match MoveData::gather_moves(mir, tcx, param_env) {\n-            Ok(move_data) => move_data,\n-            Err((move_data, move_errors)) => {\n-                for move_error in move_errors {\n-                    let (span, kind): (Span, IllegalMoveOriginKind) = match move_error {\n-                        MoveError::UnionMove { .. } =>\n-                            unimplemented!(\"dont know how to report union move errors yet.\"),\n-                        MoveError::IllegalMove { cannot_move_out_of: o } => (o.span, o.kind),\n-                    };\n-                    let origin = Origin::Mir;\n-                    let mut err = match kind {\n-                        IllegalMoveOriginKind::Static =>\n-                            tcx.cannot_move_out_of(span, \"static item\", origin),\n-                        IllegalMoveOriginKind::BorrowedContent =>\n-                            tcx.cannot_move_out_of(span, \"borrowed_content\", origin),\n-                        IllegalMoveOriginKind::InteriorOfTypeWithDestructor { container_ty: ty } =>\n-                            tcx.cannot_move_out_of_interior_of_drop(span, ty, origin),\n-                        IllegalMoveOriginKind::InteriorOfSlice { elem_ty: ty, is_index } =>\n-                            tcx.cannot_move_out_of_interior_noncopy(span, ty, is_index, origin),\n-                        IllegalMoveOriginKind::InteriorOfArray { elem_ty: ty, is_index } =>\n-                            tcx.cannot_move_out_of_interior_noncopy(span, ty, is_index, origin),\n-                    };\n-                    err.emit();\n-                }\n-                move_data\n+\n+    let id = src.item_id();\n+\n+    let move_data: MoveData<'tcx> = match MoveData::gather_moves(mir, tcx, param_env) {\n+        Ok(move_data) => move_data,\n+        Err((move_data, move_errors)) => {\n+            for move_error in move_errors {\n+                let (span, kind): (Span, IllegalMoveOriginKind) = match move_error {\n+                    MoveError::UnionMove { .. } =>\n+                        unimplemented!(\"dont know how to report union move errors yet.\"),\n+                    MoveError::IllegalMove { cannot_move_out_of: o } => (o.span, o.kind),\n+                };\n+                let origin = Origin::Mir;\n+                let mut err = match kind {\n+                    IllegalMoveOriginKind::Static =>\n+                        tcx.cannot_move_out_of(span, \"static item\", origin),\n+                    IllegalMoveOriginKind::BorrowedContent =>\n+                        tcx.cannot_move_out_of(span, \"borrowed_content\", origin),\n+                    IllegalMoveOriginKind::InteriorOfTypeWithDestructor { container_ty: ty } =>\n+                        tcx.cannot_move_out_of_interior_of_drop(span, ty, origin),\n+                    IllegalMoveOriginKind::InteriorOfSlice { elem_ty: ty, is_index } =>\n+                        tcx.cannot_move_out_of_interior_noncopy(span, ty, is_index, origin),\n+                    IllegalMoveOriginKind::InteriorOfArray { elem_ty: ty, is_index } =>\n+                        tcx.cannot_move_out_of_interior_noncopy(span, ty, is_index, origin),\n+                };\n+                err.emit();\n             }\n-        };\n-        let mdpe = MoveDataParamEnv { move_data: move_data, param_env: param_env };\n-        let dead_unwinds = IdxSetBuf::new_empty(mir.basic_blocks().len());\n-        let flow_borrows = do_dataflow(tcx, mir, id, &attributes, &dead_unwinds,\n-                                       Borrows::new(tcx, mir),\n-                                       |bd, i| bd.location(i));\n-        let flow_inits = do_dataflow(tcx, mir, id, &attributes, &dead_unwinds,\n-                                     MaybeInitializedLvals::new(tcx, mir, &mdpe),\n-                                     |bd, i| &bd.move_data().move_paths[i]);\n-        let flow_uninits = do_dataflow(tcx, mir, id, &attributes, &dead_unwinds,\n-                                       MaybeUninitializedLvals::new(tcx, mir, &mdpe),\n-                                       |bd, i| &bd.move_data().move_paths[i]);\n-\n-        let mut mbcx = MirBorrowckCtxt {\n-            tcx: tcx,\n-            mir: mir,\n-            node_id: id,\n-            move_data: &mdpe.move_data,\n-            param_env: param_env,\n-            fake_infer_ctxt: &_infcx,\n-        };\n+            move_data\n+        }\n+    };\n \n-        let mut state = InProgress::new(flow_borrows,\n-                                        flow_inits,\n-                                        flow_uninits);\n+    let mdpe = MoveDataParamEnv { move_data: move_data, param_env: param_env };\n+    let dead_unwinds = IdxSetBuf::new_empty(mir.basic_blocks().len());\n+    let flow_borrows = do_dataflow(tcx, mir, id, &attributes, &dead_unwinds,\n+                                   Borrows::new(tcx, mir),\n+                                   |bd, i| bd.location(i));\n+    let flow_inits = do_dataflow(tcx, mir, id, &attributes, &dead_unwinds,\n+                                 MaybeInitializedLvals::new(tcx, mir, &mdpe),\n+                                 |bd, i| &bd.move_data().move_paths[i]);\n+    let flow_uninits = do_dataflow(tcx, mir, id, &attributes, &dead_unwinds,\n+                                   MaybeUninitializedLvals::new(tcx, mir, &mdpe),\n+                                   |bd, i| &bd.move_data().move_paths[i]);\n+\n+    let mut mbcx = MirBorrowckCtxt {\n+        tcx: tcx,\n+        mir: mir,\n+        node_id: id,\n+        move_data: &mdpe.move_data,\n+        param_env: param_env,\n+        fake_infer_ctxt: &infcx,\n+    };\n \n-        mbcx.analyze_results(&mut state); // entry point for DataflowResultsConsumer\n-    });\n+    let mut state = InProgress::new(flow_borrows,\n+                                    flow_inits,\n+                                    flow_uninits);\n \n-    debug!(\"mir_borrowck done\");\n+    mbcx.analyze_results(&mut state); // entry point for DataflowResultsConsumer\n }\n \n #[allow(dead_code)]\n pub struct MirBorrowckCtxt<'c, 'b, 'a: 'b+'c, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'gcx>,\n-    mir: &'b Mir<'gcx>,\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    mir: &'b Mir<'tcx>,\n     node_id: ast::NodeId,\n-    move_data: &'b MoveData<'gcx>,\n+    move_data: &'b MoveData<'tcx>,\n     param_env: ParamEnv<'tcx>,\n     fake_infer_ctxt: &'c InferCtxt<'c, 'gcx, 'tcx>,\n }\n \n // (forced to be `pub` due to its use as an associated type below.)\n-pub struct InProgress<'b, 'tcx: 'b> {\n-    borrows: FlowInProgress<Borrows<'b, 'tcx>>,\n-    inits: FlowInProgress<MaybeInitializedLvals<'b, 'tcx>>,\n-    uninits: FlowInProgress<MaybeUninitializedLvals<'b, 'tcx>>,\n+pub struct InProgress<'b, 'gcx: 'tcx, 'tcx: 'b> {\n+    borrows: FlowInProgress<Borrows<'b, 'gcx, 'tcx>>,\n+    inits: FlowInProgress<MaybeInitializedLvals<'b, 'gcx, 'tcx>>,\n+    uninits: FlowInProgress<MaybeUninitializedLvals<'b, 'gcx, 'tcx>>,\n }\n \n struct FlowInProgress<BD> where BD: BitDenotation {\n@@ -147,12 +157,12 @@ struct FlowInProgress<BD> where BD: BitDenotation {\n // 2. loans made in overlapping scopes do not conflict\n // 3. assignments do not affect things loaned out as immutable\n // 4. moves do not affect things loaned out in any way\n-impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> DataflowResultsConsumer<'b, 'gcx>\n+impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> DataflowResultsConsumer<'b, 'tcx>\n     for MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n {\n-    type FlowState = InProgress<'b, 'gcx>;\n+    type FlowState = InProgress<'b, 'gcx, 'tcx>;\n \n-    fn mir(&self) -> &'b Mir<'gcx> { self.mir }\n+    fn mir(&self) -> &'b Mir<'tcx> { self.mir }\n \n     fn reset_to_entry_of(&mut self, bb: BasicBlock, flow_state: &mut Self::FlowState) {\n         flow_state.each_flow(|b| b.reset_to_entry_of(bb),\n@@ -193,7 +203,7 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> DataflowResultsConsumer<'b, 'gcx>\n \n     fn visit_statement_entry(&mut self,\n                              location: Location,\n-                             stmt: &Statement<'gcx>,\n+                             stmt: &Statement<'tcx>,\n                              flow_state: &Self::FlowState) {\n         let summary = flow_state.summary();\n         debug!(\"MirBorrowckCtxt::process_statement({:?}, {:?}): {}\", location, stmt, summary);\n@@ -261,7 +271,7 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> DataflowResultsConsumer<'b, 'gcx>\n \n     fn visit_terminator_entry(&mut self,\n                               location: Location,\n-                              term: &Terminator<'gcx>,\n+                              term: &Terminator<'tcx>,\n                               flow_state: &Self::FlowState) {\n         let loc = location;\n         let summary = flow_state.summary();\n@@ -405,9 +415,9 @@ enum WriteKind {\n impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n     fn access_lvalue(&mut self,\n                      context: Context,\n-                     lvalue_span: (&Lvalue<'gcx>, Span),\n+                     lvalue_span: (&Lvalue<'tcx>, Span),\n                      kind: (ShallowOrDeep, ReadOrWrite),\n-                     flow_state: &InProgress<'b, 'gcx>) {\n+                     flow_state: &InProgress<'b, 'gcx, 'tcx>) {\n         // FIXME: also need to check permissions (e.g. reject mut\n         // borrow of immutable ref, moves through non-`Box`-ref)\n         let (sd, rw) = kind;\n@@ -460,10 +470,10 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n \n     fn mutate_lvalue(&mut self,\n                      context: Context,\n-                     lvalue_span: (&Lvalue<'gcx>, Span),\n+                     lvalue_span: (&Lvalue<'tcx>, Span),\n                      kind: ShallowOrDeep,\n                      mode: MutateMode,\n-                     flow_state: &InProgress<'b, 'gcx>) {\n+                     flow_state: &InProgress<'b, 'gcx, 'tcx>) {\n         // Write of P[i] or *P, or WriteAndRead of any P, requires P init'd.\n         match mode {\n             MutateMode::WriteAndRead => {\n@@ -482,9 +492,9 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n \n     fn consume_rvalue(&mut self,\n                       context: Context,\n-                      (rvalue, span): (&Rvalue<'gcx>, Span),\n+                      (rvalue, span): (&Rvalue<'tcx>, Span),\n                       _location: Location,\n-                      flow_state: &InProgress<'b, 'gcx>) {\n+                      flow_state: &InProgress<'b, 'gcx, 'tcx>) {\n         match *rvalue {\n             Rvalue::Ref(_/*rgn*/, bk, ref lvalue) => {\n                 let access_kind = match bk {\n@@ -540,8 +550,8 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n     fn consume_operand(&mut self,\n                        context: Context,\n                        consume_via_drop: ConsumeKind,\n-                       (operand, span): (&Operand<'gcx>, Span),\n-                       flow_state: &InProgress<'b, 'gcx>) {\n+                       (operand, span): (&Operand<'tcx>, Span),\n+                       flow_state: &InProgress<'b, 'gcx, 'tcx>) {\n         match *operand {\n             Operand::Consume(ref lvalue) => {\n                 self.consume_lvalue(context, consume_via_drop, (lvalue, span), flow_state)\n@@ -553,8 +563,8 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n     fn consume_lvalue(&mut self,\n                       context: Context,\n                       consume_via_drop: ConsumeKind,\n-                      lvalue_span: (&Lvalue<'gcx>, Span),\n-                      flow_state: &InProgress<'b, 'gcx>) {\n+                      lvalue_span: (&Lvalue<'tcx>, Span),\n+                      flow_state: &InProgress<'b, 'gcx, 'tcx>) {\n         let lvalue = lvalue_span.0;\n         let ty = lvalue.ty(self.mir, self.tcx).to_ty(self.tcx);\n         let moves_by_default =\n@@ -584,8 +594,8 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n     fn check_if_reassignment_to_immutable_state(&mut self,\n                                                 context: Context,\n-                                                (lvalue, span): (&Lvalue<'gcx>, Span),\n-                                                flow_state: &InProgress<'b, 'gcx>) {\n+                                                (lvalue, span): (&Lvalue<'tcx>, Span),\n+                                                flow_state: &InProgress<'b, 'gcx, 'tcx>) {\n         let move_data = self.move_data;\n \n         // determine if this path has a non-mut owner (and thus needs checking).\n@@ -635,8 +645,8 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n     fn check_if_path_is_moved(&mut self,\n                               context: Context,\n                               desired_action: &str,\n-                              lvalue_span: (&Lvalue<'gcx>, Span),\n-                              flow_state: &InProgress<'b, 'gcx>) {\n+                              lvalue_span: (&Lvalue<'tcx>, Span),\n+                              flow_state: &InProgress<'b, 'gcx, 'tcx>) {\n         // FIXME: analogous code in check_loans first maps `lvalue` to\n         // its base_path ... but is that what we want here?\n         let lvalue = self.base_path(lvalue_span.0);\n@@ -725,7 +735,7 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n     /// An Err result includes a tag indicated why the search failed.\n     /// Currenly this can only occur if the lvalue is built off of a\n     /// static variable, as we do not track those in the MoveData.\n-    fn move_path_closest_to(&mut self, lvalue: &Lvalue<'gcx>)\n+    fn move_path_closest_to(&mut self, lvalue: &Lvalue<'tcx>)\n                             -> Result<MovePathIndex, NoMovePathFound>\n     {\n         let mut last_prefix = lvalue;\n@@ -743,7 +753,7 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n     }\n \n     fn move_path_for_lvalue(&mut self,\n-                            lvalue: &Lvalue<'gcx>)\n+                            lvalue: &Lvalue<'tcx>)\n                             -> Option<MovePathIndex>\n     {\n         // If returns None, then there is no move path corresponding\n@@ -758,8 +768,8 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n \n     fn check_if_assigned_path_is_moved(&mut self,\n                                        context: Context,\n-                                       (lvalue, span): (&Lvalue<'gcx>, Span),\n-                                       flow_state: &InProgress<'b, 'gcx>) {\n+                                       (lvalue, span): (&Lvalue<'tcx>, Span),\n+                                       flow_state: &InProgress<'b, 'gcx, 'tcx>) {\n         // recur down lvalue; dispatch to check_if_path_is_moved when necessary\n         let mut lvalue = lvalue;\n         loop {\n@@ -827,10 +837,10 @@ enum NoMovePathFound {\n impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n     fn each_borrow_involving_path<F>(&mut self,\n                                      _context: Context,\n-                                     access_lvalue: (ShallowOrDeep, &Lvalue<'gcx>),\n-                                     flow_state: &InProgress<'b, 'gcx>,\n+                                     access_lvalue: (ShallowOrDeep, &Lvalue<'tcx>),\n+                                     flow_state: &InProgress<'b, 'gcx, 'tcx>,\n                                      mut op: F)\n-        where F: FnMut(&mut Self, BorrowIndex, &BorrowData<'gcx>, &Lvalue) -> Control\n+        where F: FnMut(&mut Self, BorrowIndex, &BorrowData<'tcx>, &Lvalue) -> Control\n     {\n         let (access, lvalue) = access_lvalue;\n \n@@ -928,9 +938,9 @@ mod prefixes {\n     }\n \n \n-    pub(super) struct Prefixes<'c, 'tcx: 'c> {\n+    pub(super) struct Prefixes<'c, 'gcx: 'tcx, 'tcx: 'c> {\n         mir: &'c Mir<'tcx>,\n-        tcx: TyCtxt<'c, 'tcx, 'tcx>,\n+        tcx: TyCtxt<'c, 'gcx, 'tcx>,\n         kind: PrefixSet,\n         next: Option<&'c Lvalue<'tcx>>,\n     }\n@@ -951,15 +961,15 @@ mod prefixes {\n         /// (inclusive) from longest to smallest, potentially\n         /// terminating the iteration early based on `kind`.\n         pub(super) fn prefixes<'d>(&self,\n-                                   lvalue: &'d Lvalue<'gcx>,\n+                                   lvalue: &'d Lvalue<'tcx>,\n                                    kind: PrefixSet)\n-                                   -> Prefixes<'d, 'gcx> where 'b: 'd\n+                                   -> Prefixes<'d, 'gcx, 'tcx> where 'b: 'd\n         {\n             Prefixes { next: Some(lvalue), kind, mir: self.mir, tcx: self.tcx }\n         }\n     }\n \n-    impl<'c, 'tcx> Iterator for Prefixes<'c, 'tcx> {\n+    impl<'c, 'gcx, 'tcx> Iterator for Prefixes<'c, 'gcx, 'tcx> {\n         type Item = &'c Lvalue<'tcx>;\n         fn next(&mut self) -> Option<Self::Item> {\n             let mut cursor = match self.next {\n@@ -1315,7 +1325,7 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n     // moves out of a Box. They should be removed when/if we stop\n     // treating Box specially (e.g. when/if DerefMove is added...)\n \n-    fn base_path<'d>(&self, lvalue: &'d Lvalue<'gcx>) -> &'d Lvalue<'gcx> {\n+    fn base_path<'d>(&self, lvalue: &'d Lvalue<'tcx>) -> &'d Lvalue<'tcx> {\n         //! Returns the base of the leftmost (deepest) dereference of an\n         //! Box in `lvalue`. If there is no dereference of an Box\n         //! in `lvalue`, then it just returns `lvalue` itself.\n@@ -1364,10 +1374,10 @@ impl ContextKind {\n     fn new(self, loc: Location) -> Context { Context { kind: self, loc: loc } }\n }\n \n-impl<'b, 'tcx: 'b> InProgress<'b, 'tcx> {\n-    pub(super) fn new(borrows: DataflowResults<Borrows<'b, 'tcx>>,\n-                      inits: DataflowResults<MaybeInitializedLvals<'b, 'tcx>>,\n-                      uninits: DataflowResults<MaybeUninitializedLvals<'b, 'tcx>>)\n+impl<'b, 'gcx, 'tcx> InProgress<'b, 'gcx, 'tcx> {\n+    pub(super) fn new(borrows: DataflowResults<Borrows<'b, 'gcx, 'tcx>>,\n+                      inits: DataflowResults<MaybeInitializedLvals<'b, 'gcx, 'tcx>>,\n+                      uninits: DataflowResults<MaybeUninitializedLvals<'b, 'gcx, 'tcx>>)\n                       -> Self {\n         InProgress {\n             borrows: FlowInProgress::new(borrows),\n@@ -1380,9 +1390,9 @@ impl<'b, 'tcx: 'b> InProgress<'b, 'tcx> {\n                              mut xform_borrows: XB,\n                              mut xform_inits: XI,\n                              mut xform_uninits: XU) where\n-        XB: FnMut(&mut FlowInProgress<Borrows<'b, 'tcx>>),\n-        XI: FnMut(&mut FlowInProgress<MaybeInitializedLvals<'b, 'tcx>>),\n-        XU: FnMut(&mut FlowInProgress<MaybeUninitializedLvals<'b, 'tcx>>),\n+        XB: FnMut(&mut FlowInProgress<Borrows<'b, 'gcx, 'tcx>>),\n+        XI: FnMut(&mut FlowInProgress<MaybeInitializedLvals<'b, 'gcx, 'tcx>>),\n+        XU: FnMut(&mut FlowInProgress<MaybeUninitializedLvals<'b, 'gcx, 'tcx>>),\n     {\n         xform_borrows(&mut self.borrows);\n         xform_inits(&mut self.inits);\n@@ -1438,7 +1448,7 @@ impl<'b, 'tcx: 'b> InProgress<'b, 'tcx> {\n     }\n }\n \n-impl<'b, 'tcx> FlowInProgress<MaybeUninitializedLvals<'b, 'tcx>> {\n+impl<'b, 'gcx, 'tcx> FlowInProgress<MaybeUninitializedLvals<'b, 'gcx, 'tcx>> {\n     fn has_any_child_of(&self, mpi: MovePathIndex) -> Option<MovePathIndex> {\n         let move_data = self.base_results.operator().move_data();\n "}, {"sha": "e35bd34c40bd0ce6a1b3012dfcb4be2c3aef16da", "filename": "src/librustc_mir/dataflow/drop_flag_effects.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/81449174f3fdc3c932f5a5560c91c2930616f6e0/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81449174f3fdc3c932f5a5560c91c2930616f6e0/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs?ref=81449174f3fdc3c932f5a5560c91c2930616f6e0", "patch": "@@ -58,9 +58,9 @@ pub fn move_path_children_matching<'tcx, F>(move_data: &MoveData<'tcx>,\n /// is no need to maintain separate drop flags to track such state.\n ///\n /// FIXME: we have to do something for moving slice patterns.\n-fn lvalue_contents_drop_state_cannot_differ<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                                      mir: &Mir<'tcx>,\n-                                                      lv: &mir::Lvalue<'tcx>) -> bool {\n+fn lvalue_contents_drop_state_cannot_differ<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                                            mir: &Mir<'tcx>,\n+                                                            lv: &mir::Lvalue<'tcx>) -> bool {\n     let ty = lv.ty(mir, tcx).to_ty(tcx);\n     match ty.sty {\n         ty::TyArray(..) | ty::TySlice(..) | ty::TyRef(..) | ty::TyRawPtr(..) => {\n@@ -79,8 +79,8 @@ fn lvalue_contents_drop_state_cannot_differ<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx\n     }\n }\n \n-pub(crate) fn on_lookup_result_bits<'a, 'tcx, F>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub(crate) fn on_lookup_result_bits<'a, 'gcx, 'tcx, F>(\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     mir: &Mir<'tcx>,\n     move_data: &MoveData<'tcx>,\n     lookup_result: LookupResult,\n@@ -97,16 +97,16 @@ pub(crate) fn on_lookup_result_bits<'a, 'tcx, F>(\n     }\n }\n \n-pub(crate) fn on_all_children_bits<'a, 'tcx, F>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub(crate) fn on_all_children_bits<'a, 'gcx, 'tcx, F>(\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     mir: &Mir<'tcx>,\n     move_data: &MoveData<'tcx>,\n     move_path_index: MovePathIndex,\n     mut each_child: F)\n     where F: FnMut(MovePathIndex)\n {\n-    fn is_terminal_path<'a, 'tcx>(\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    fn is_terminal_path<'a, 'gcx, 'tcx>(\n+        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         mir: &Mir<'tcx>,\n         move_data: &MoveData<'tcx>,\n         path: MovePathIndex) -> bool\n@@ -115,8 +115,8 @@ pub(crate) fn on_all_children_bits<'a, 'tcx, F>(\n             tcx, mir, &move_data.move_paths[path].lvalue)\n     }\n \n-    fn on_all_children_bits<'a, 'tcx, F>(\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    fn on_all_children_bits<'a, 'gcx, 'tcx, F>(\n+        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         mir: &Mir<'tcx>,\n         move_data: &MoveData<'tcx>,\n         move_path_index: MovePathIndex,\n@@ -138,10 +138,10 @@ pub(crate) fn on_all_children_bits<'a, 'tcx, F>(\n     on_all_children_bits(tcx, mir, move_data, move_path_index, &mut each_child);\n }\n \n-pub(crate) fn on_all_drop_children_bits<'a, 'tcx, F>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub(crate) fn on_all_drop_children_bits<'a, 'gcx, 'tcx, F>(\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     mir: &Mir<'tcx>,\n-    ctxt: &MoveDataParamEnv<'tcx>,\n+    ctxt: &MoveDataParamEnv<'gcx, 'tcx>,\n     path: MovePathIndex,\n     mut each_child: F)\n     where F: FnMut(MovePathIndex)\n@@ -161,10 +161,10 @@ pub(crate) fn on_all_drop_children_bits<'a, 'tcx, F>(\n     })\n }\n \n-pub(crate) fn drop_flag_effects_for_function_entry<'a, 'tcx, F>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub(crate) fn drop_flag_effects_for_function_entry<'a, 'gcx, 'tcx, F>(\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     mir: &Mir<'tcx>,\n-    ctxt: &MoveDataParamEnv<'tcx>,\n+    ctxt: &MoveDataParamEnv<'gcx, 'tcx>,\n     mut callback: F)\n     where F: FnMut(MovePathIndex, DropFlagState)\n {\n@@ -178,10 +178,10 @@ pub(crate) fn drop_flag_effects_for_function_entry<'a, 'tcx, F>(\n     }\n }\n \n-pub(crate) fn drop_flag_effects_for_location<'a, 'tcx, F>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub(crate) fn drop_flag_effects_for_location<'a, 'gcx, 'tcx, F>(\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     mir: &Mir<'tcx>,\n-    ctxt: &MoveDataParamEnv<'tcx>,\n+    ctxt: &MoveDataParamEnv<'gcx, 'tcx>,\n     loc: Location,\n     mut callback: F)\n     where F: FnMut(MovePathIndex, DropFlagState)"}, {"sha": "8079f64bf5db3795bb601f8ab3ac624ddd662183", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/81449174f3fdc3c932f5a5560c91c2930616f6e0/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81449174f3fdc3c932f5a5560c91c2930616f6e0/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=81449174f3fdc3c932f5a5560c91c2930616f6e0", "patch": "@@ -29,8 +29,8 @@ use std::fmt;\n // `Borrows` maps each dataflow bit to an `Rvalue::Ref`, which can be\n // uniquely identified in the MIR by the `Location` of the assigment\n // statement in which it appears on the right hand side.\n-pub struct Borrows<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub struct Borrows<'a, 'gcx: 'tcx, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     mir: &'a Mir<'tcx>,\n     borrows: IndexVec<BorrowIndex, BorrowData<'tcx>>,\n     location_map: FxHashMap<Location, BorrowIndex>,\n@@ -63,8 +63,8 @@ impl<'tcx> fmt::Display for BorrowData<'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Borrows<'a, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, mir: &'a Mir<'tcx>) -> Self {\n+impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>, mir: &'a Mir<'tcx>) -> Self {\n         let mut visitor = GatherBorrows { idx_vec: IndexVec::new(),\n                                           location_map: FxHashMap(),\n                                           region_map: FxHashMap(),\n@@ -126,7 +126,7 @@ impl<'a, 'tcx> Borrows<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> BitDenotation for Borrows<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n     type Idx = BorrowIndex;\n     fn name() -> &'static str { \"borrows\" }\n     fn bits_per_block(&self) -> usize {\n@@ -191,14 +191,14 @@ impl<'a, 'tcx> BitDenotation for Borrows<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> BitwiseOperator for Borrows<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> BitwiseOperator for Borrows<'a, 'gcx, 'tcx> {\n     #[inline]\n     fn join(&self, pred1: usize, pred2: usize) -> usize {\n         pred1 | pred2 // union effects of preds when computing borrows\n     }\n }\n \n-impl<'a, 'tcx> DataflowOperator for Borrows<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> DataflowOperator for Borrows<'a, 'gcx, 'tcx> {\n     #[inline]\n     fn bottom_value() -> bool {\n         false // bottom = no Rvalue::Refs are active by default"}, {"sha": "af99706be811d21770f975921ebc29affe62337e", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/81449174f3fdc3c932f5a5560c91c2930616f6e0/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81449174f3fdc3c932f5a5560c91c2930616f6e0/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=81449174f3fdc3c932f5a5560c91c2930616f6e0", "patch": "@@ -69,23 +69,23 @@ pub(super) mod borrows;\n /// Similarly, at a given `drop` statement, the set-intersection\n /// between this data and `MaybeUninitializedLvals` yields the set of\n /// l-values that would require a dynamic drop-flag at that statement.\n-pub struct MaybeInitializedLvals<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub struct MaybeInitializedLvals<'a, 'gcx: 'tcx, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     mir: &'a Mir<'tcx>,\n-    mdpe: &'a MoveDataParamEnv<'tcx>,\n+    mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>,\n }\n \n-impl<'a, 'tcx: 'a> MaybeInitializedLvals<'a, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+impl<'a, 'gcx: 'tcx, 'tcx> MaybeInitializedLvals<'a, 'gcx, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                mir: &'a Mir<'tcx>,\n-               mdpe: &'a MoveDataParamEnv<'tcx>)\n+               mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>)\n                -> Self\n     {\n         MaybeInitializedLvals { tcx: tcx, mir: mir, mdpe: mdpe }\n     }\n }\n \n-impl<'a, 'tcx: 'a> HasMoveData<'tcx> for MaybeInitializedLvals<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> HasMoveData<'tcx> for MaybeInitializedLvals<'a, 'gcx, 'tcx> {\n     fn move_data(&self) -> &MoveData<'tcx> { &self.mdpe.move_data }\n }\n \n@@ -124,23 +124,23 @@ impl<'a, 'tcx: 'a> HasMoveData<'tcx> for MaybeInitializedLvals<'a, 'tcx> {\n /// Similarly, at a given `drop` statement, the set-intersection\n /// between this data and `MaybeInitializedLvals` yields the set of\n /// l-values that would require a dynamic drop-flag at that statement.\n-pub struct MaybeUninitializedLvals<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub struct MaybeUninitializedLvals<'a, 'gcx: 'tcx, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     mir: &'a Mir<'tcx>,\n-    mdpe: &'a MoveDataParamEnv<'tcx>,\n+    mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>,\n }\n \n-impl<'a, 'tcx: 'a> MaybeUninitializedLvals<'a, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+impl<'a, 'gcx, 'tcx> MaybeUninitializedLvals<'a, 'gcx, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                mir: &'a Mir<'tcx>,\n-               mdpe: &'a MoveDataParamEnv<'tcx>)\n+               mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>)\n                -> Self\n     {\n         MaybeUninitializedLvals { tcx: tcx, mir: mir, mdpe: mdpe }\n     }\n }\n \n-impl<'a, 'tcx: 'a> HasMoveData<'tcx> for MaybeUninitializedLvals<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> HasMoveData<'tcx> for MaybeUninitializedLvals<'a, 'gcx, 'tcx> {\n     fn move_data(&self) -> &MoveData<'tcx> { &self.mdpe.move_data }\n }\n \n@@ -185,27 +185,27 @@ impl<'a, 'tcx: 'a> HasMoveData<'tcx> for MaybeUninitializedLvals<'a, 'tcx> {\n /// Similarly, at a given `drop` statement, the set-difference between\n /// this data and `MaybeInitializedLvals` yields the set of l-values\n /// that would require a dynamic drop-flag at that statement.\n-pub struct DefinitelyInitializedLvals<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub struct DefinitelyInitializedLvals<'a, 'gcx: 'tcx, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     mir: &'a Mir<'tcx>,\n-    mdpe: &'a MoveDataParamEnv<'tcx>,\n+    mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>,\n }\n \n-impl<'a, 'tcx: 'a> DefinitelyInitializedLvals<'a, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+impl<'a, 'gcx, 'tcx: 'a> DefinitelyInitializedLvals<'a, 'gcx, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                mir: &'a Mir<'tcx>,\n-               mdpe: &'a MoveDataParamEnv<'tcx>)\n+               mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>)\n                -> Self\n     {\n         DefinitelyInitializedLvals { tcx: tcx, mir: mir, mdpe: mdpe }\n     }\n }\n \n-impl<'a, 'tcx: 'a> HasMoveData<'tcx> for DefinitelyInitializedLvals<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx: 'a> HasMoveData<'tcx> for DefinitelyInitializedLvals<'a, 'gcx, 'tcx> {\n     fn move_data(&self) -> &MoveData<'tcx> { &self.mdpe.move_data }\n }\n \n-impl<'a, 'tcx> MaybeInitializedLvals<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> MaybeInitializedLvals<'a, 'gcx, 'tcx> {\n     fn update_bits(sets: &mut BlockSets<MovePathIndex>, path: MovePathIndex,\n                    state: DropFlagState)\n     {\n@@ -216,7 +216,7 @@ impl<'a, 'tcx> MaybeInitializedLvals<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> MaybeUninitializedLvals<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> MaybeUninitializedLvals<'a, 'gcx, 'tcx> {\n     fn update_bits(sets: &mut BlockSets<MovePathIndex>, path: MovePathIndex,\n                    state: DropFlagState)\n     {\n@@ -227,7 +227,7 @@ impl<'a, 'tcx> MaybeUninitializedLvals<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> DefinitelyInitializedLvals<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> DefinitelyInitializedLvals<'a, 'gcx, 'tcx> {\n     fn update_bits(sets: &mut BlockSets<MovePathIndex>, path: MovePathIndex,\n                    state: DropFlagState)\n     {\n@@ -238,7 +238,7 @@ impl<'a, 'tcx> DefinitelyInitializedLvals<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> BitDenotation for MaybeInitializedLvals<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> BitDenotation for MaybeInitializedLvals<'a, 'gcx, 'tcx> {\n     type Idx = MovePathIndex;\n     fn name() -> &'static str { \"maybe_init\" }\n     fn bits_per_block(&self) -> usize {\n@@ -290,7 +290,7 @@ impl<'a, 'tcx> BitDenotation for MaybeInitializedLvals<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> BitDenotation for MaybeUninitializedLvals<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> BitDenotation for MaybeUninitializedLvals<'a, 'gcx, 'tcx> {\n     type Idx = MovePathIndex;\n     fn name() -> &'static str { \"maybe_uninit\" }\n     fn bits_per_block(&self) -> usize {\n@@ -345,7 +345,7 @@ impl<'a, 'tcx> BitDenotation for MaybeUninitializedLvals<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> BitDenotation for DefinitelyInitializedLvals<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> BitDenotation for DefinitelyInitializedLvals<'a, 'gcx, 'tcx> {\n     type Idx = MovePathIndex;\n     fn name() -> &'static str { \"definite_init\" }\n     fn bits_per_block(&self) -> usize {\n@@ -399,21 +399,21 @@ impl<'a, 'tcx> BitDenotation for DefinitelyInitializedLvals<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> BitwiseOperator for MaybeInitializedLvals<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> BitwiseOperator for MaybeInitializedLvals<'a, 'gcx, 'tcx> {\n     #[inline]\n     fn join(&self, pred1: usize, pred2: usize) -> usize {\n         pred1 | pred2 // \"maybe\" means we union effects of both preds\n     }\n }\n \n-impl<'a, 'tcx> BitwiseOperator for MaybeUninitializedLvals<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> BitwiseOperator for MaybeUninitializedLvals<'a, 'gcx, 'tcx> {\n     #[inline]\n     fn join(&self, pred1: usize, pred2: usize) -> usize {\n         pred1 | pred2 // \"maybe\" means we union effects of both preds\n     }\n }\n \n-impl<'a, 'tcx> BitwiseOperator for DefinitelyInitializedLvals<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> BitwiseOperator for DefinitelyInitializedLvals<'a, 'gcx, 'tcx> {\n     #[inline]\n     fn join(&self, pred1: usize, pred2: usize) -> usize {\n         pred1 & pred2 // \"definitely\" means we intersect effects of both preds\n@@ -430,21 +430,21 @@ impl<'a, 'tcx> BitwiseOperator for DefinitelyInitializedLvals<'a, 'tcx> {\n // propagating, or you start at all-ones and then use Intersect as\n // your merge when propagating.\n \n-impl<'a, 'tcx> DataflowOperator for MaybeInitializedLvals<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> DataflowOperator for MaybeInitializedLvals<'a, 'gcx, 'tcx> {\n     #[inline]\n     fn bottom_value() -> bool {\n         false // bottom = uninitialized\n     }\n }\n \n-impl<'a, 'tcx> DataflowOperator for MaybeUninitializedLvals<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> DataflowOperator for MaybeUninitializedLvals<'a, 'gcx, 'tcx> {\n     #[inline]\n     fn bottom_value() -> bool {\n         false // bottom = initialized (start_block_effect counters this at outset)\n     }\n }\n \n-impl<'a, 'tcx> DataflowOperator for DefinitelyInitializedLvals<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> DataflowOperator for DefinitelyInitializedLvals<'a, 'gcx, 'tcx> {\n     #[inline]\n     fn bottom_value() -> bool {\n         true // bottom = initialized (start_block_effect counters this at outset)"}, {"sha": "d27a4e7e9d9c3fe98070d89f86977d19c2982680", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/81449174f3fdc3c932f5a5560c91c2930616f6e0/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81449174f3fdc3c932f5a5560c91c2930616f6e0/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=81449174f3fdc3c932f5a5560c91c2930616f6e0", "patch": "@@ -91,19 +91,19 @@ pub(crate) fn has_rustc_mir_with(attrs: &[ast::Attribute], name: &str) -> Option\n     return None;\n }\n \n-pub struct MoveDataParamEnv<'tcx> {\n+pub struct MoveDataParamEnv<'gcx, 'tcx> {\n     pub(crate) move_data: MoveData<'tcx>,\n-    pub(crate) param_env: ty::ParamEnv<'tcx>,\n+    pub(crate) param_env: ty::ParamEnv<'gcx>,\n }\n \n-pub(crate) fn do_dataflow<'a, 'tcx, BD, P>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                mir: &Mir<'tcx>,\n-                                node_id: ast::NodeId,\n-                                attributes: &[ast::Attribute],\n-                                dead_unwinds: &IdxSet<BasicBlock>,\n-                                bd: BD,\n-                                p: P)\n-                                -> DataflowResults<BD>\n+pub(crate) fn do_dataflow<'a, 'gcx, 'tcx, BD, P>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                                 mir: &Mir<'tcx>,\n+                                                 node_id: ast::NodeId,\n+                                                 attributes: &[ast::Attribute],\n+                                                 dead_unwinds: &IdxSet<BasicBlock>,\n+                                                 bd: BD,\n+                                                 p: P)\n+                                                 -> DataflowResults<BD>\n     where BD: BitDenotation,\n           P: Fn(&BD, BD::Idx) -> &fmt::Debug\n {\n@@ -612,9 +612,9 @@ pub trait BitDenotation: DataflowOperator {\n                              dest_lval: &mir::Lvalue);\n }\n \n-impl<'a, 'tcx: 'a, D> DataflowAnalysis<'a, 'tcx, D> where D: BitDenotation\n+impl<'a, 'gcx, 'tcx: 'a, D> DataflowAnalysis<'a, 'tcx, D> where D: BitDenotation\n {\n-    pub fn new(_tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    pub fn new(_tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                mir: &'a Mir<'tcx>,\n                dead_unwinds: &'a IdxSet<mir::BasicBlock>,\n                denotation: D) -> Self {"}, {"sha": "8f473d035ee1df128f32e39ca72246248d94adf4", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/81449174f3fdc3c932f5a5560c91c2930616f6e0/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81449174f3fdc3c932f5a5560c91c2930616f6e0/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=81449174f3fdc3c932f5a5560c91c2930616f6e0", "patch": "@@ -25,18 +25,18 @@ use super::{LocationMap, MoveData, MovePath, MovePathLookup, MovePathIndex, Move\n use super::{MoveError};\n use super::IllegalMoveOriginKind::*;\n \n-struct MoveDataBuilder<'a, 'tcx: 'a> {\n+struct MoveDataBuilder<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     mir: &'a Mir<'tcx>,\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    param_env: ty::ParamEnv<'gcx>,\n     data: MoveData<'tcx>,\n     errors: Vec<MoveError<'tcx>>,\n }\n \n-impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> MoveDataBuilder<'a, 'gcx, 'tcx> {\n     fn new(mir: &'a Mir<'tcx>,\n-           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-           param_env: ty::ParamEnv<'tcx>)\n+           tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+           param_env: ty::ParamEnv<'gcx>)\n            -> Self {\n         let mut move_paths = IndexVec::new();\n         let mut path_map = IndexVec::new();\n@@ -86,7 +86,7 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n     }\n }\n \n-impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n+impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n     /// This creates a MovePath for a given lvalue, returning an `MovePathError`\n     /// if that lvalue can't be moved from.\n     ///\n@@ -175,7 +175,7 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> MoveDataBuilder<'a, 'gcx, 'tcx> {\n     fn finalize(self) -> Result<MoveData<'tcx>, (MoveData<'tcx>, Vec<MoveError<'tcx>>)> {\n         debug!(\"{}\", {\n             debug!(\"moves for {:?}:\", self.mir.span);\n@@ -197,11 +197,11 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n     }\n }\n \n-pub(super) fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>,\n-                                     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                     param_env: ty::ParamEnv<'tcx>)\n-                                     -> Result<MoveData<'tcx>,\n-                                               (MoveData<'tcx>, Vec<MoveError<'tcx>>)> {\n+pub(super) fn gather_moves<'a, 'gcx, 'tcx>(mir: &Mir<'tcx>,\n+                                           tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                           param_env: ty::ParamEnv<'gcx>)\n+                                           -> Result<MoveData<'tcx>,\n+                                                     (MoveData<'tcx>, Vec<MoveError<'tcx>>)> {\n     let mut builder = MoveDataBuilder::new(mir, tcx, param_env);\n \n     for (bb, block) in mir.basic_blocks().iter_enumerated() {\n@@ -220,7 +220,7 @@ pub(super) fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>,\n     builder.finalize()\n }\n \n-impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> MoveDataBuilder<'a, 'gcx, 'tcx> {\n     fn gather_statement(&mut self, loc: Location, stmt: &Statement<'tcx>) {\n         debug!(\"gather_statement({:?}, {:?})\", loc, stmt);\n         (Gatherer { builder: self, loc }).gather_statement(stmt);\n@@ -232,12 +232,12 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n     }\n }\n \n-struct Gatherer<'b, 'a: 'b, 'tcx: 'a> {\n-    builder: &'b mut MoveDataBuilder<'a, 'tcx>,\n+struct Gatherer<'b, 'a: 'b, 'gcx: 'tcx, 'tcx: 'a> {\n+    builder: &'b mut MoveDataBuilder<'a, 'gcx, 'tcx>,\n     loc: Location,\n }\n \n-impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n+impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n     fn gather_statement(&mut self, stmt: &Statement<'tcx>) {\n         match stmt.kind {\n             StatementKind::Assign(ref lval, ref rval) => {"}, {"sha": "5bfecd01aaa822c809175a865355d2fa56628daf", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/81449174f3fdc3c932f5a5560c91c2930616f6e0/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81449174f3fdc3c932f5a5560c91c2930616f6e0/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=81449174f3fdc3c932f5a5560c91c2930616f6e0", "patch": "@@ -256,10 +256,10 @@ impl<'tcx> MoveError<'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> MoveData<'tcx> {\n+impl<'a, 'gcx, 'tcx> MoveData<'tcx> {\n     pub fn gather_moves(mir: &Mir<'tcx>,\n-                        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                        param_env: ty::ParamEnv<'tcx>)\n+                        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                        param_env: ty::ParamEnv<'gcx>)\n                         -> Result<Self, (Self, Vec<MoveError<'tcx>>)> {\n         builder::gather_moves(mir, tcx, param_env)\n     }"}, {"sha": "94da1f31a96b2a3a50f866141bd29d9dbc4d026f", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/81449174f3fdc3c932f5a5560c91c2930616f6e0/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81449174f3fdc3c932f5a5560c91c2930616f6e0/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=81449174f3fdc3c932f5a5560c91c2930616f6e0", "patch": "@@ -83,7 +83,7 @@ fn find_dead_unwinds<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     mir: &Mir<'tcx>,\n     id: ast::NodeId,\n-    env: &MoveDataParamEnv<'tcx>)\n+    env: &MoveDataParamEnv<'tcx, 'tcx>)\n     -> IdxSetBuf<BasicBlock>\n {\n     debug!(\"find_dead_unwinds({:?})\", mir.span);\n@@ -146,7 +146,7 @@ impl InitializationData {\n     fn apply_location<'a,'tcx>(&mut self,\n                                tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                mir: &Mir<'tcx>,\n-                               env: &MoveDataParamEnv<'tcx>,\n+                               env: &MoveDataParamEnv<'tcx, 'tcx>,\n                                loc: Location)\n     {\n         drop_flag_effects_for_location(tcx, mir, env, loc, |path, df| {\n@@ -280,9 +280,9 @@ impl<'a, 'b, 'tcx> DropElaborator<'a, 'tcx> for Elaborator<'a, 'b, 'tcx> {\n struct ElaborateDropsCtxt<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     mir: &'a Mir<'tcx>,\n-    env: &'a MoveDataParamEnv<'tcx>,\n-    flow_inits: DataflowResults<MaybeInitializedLvals<'a, 'tcx>>,\n-    flow_uninits:  DataflowResults<MaybeUninitializedLvals<'a, 'tcx>>,\n+    env: &'a MoveDataParamEnv<'tcx, 'tcx>,\n+    flow_inits: DataflowResults<MaybeInitializedLvals<'a, 'tcx, 'tcx>>,\n+    flow_uninits:  DataflowResults<MaybeUninitializedLvals<'a, 'tcx, 'tcx>>,\n     drop_flags: FxHashMap<MovePathIndex, Local>,\n     patch: MirPatch<'tcx>,\n }"}]}