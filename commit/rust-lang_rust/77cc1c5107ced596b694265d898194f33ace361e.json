{"sha": "77cc1c5107ced596b694265d898194f33ace361e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3Y2MxYzUxMDdjZWQ1OTZiNjk0MjY1ZDg5ODE5NGYzM2FjZTM2MWU=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-12-11T23:18:13Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2014-01-09T20:53:44Z"}, "message": "add a strong/weak reference counted pointer type", "tree": {"sha": "be0e26525a609de862ad4dddb59ed37c8a50aa48", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/be0e26525a609de862ad4dddb59ed37c8a50aa48"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/77cc1c5107ced596b694265d898194f33ace361e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/77cc1c5107ced596b694265d898194f33ace361e", "html_url": "https://github.com/rust-lang/rust/commit/77cc1c5107ced596b694265d898194f33ace361e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/77cc1c5107ced596b694265d898194f33ace361e/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b36a948831f7375b725f26ebec1df88687fdfeab", "url": "https://api.github.com/repos/rust-lang/rust/commits/b36a948831f7375b725f26ebec1df88687fdfeab", "html_url": "https://github.com/rust-lang/rust/commit/b36a948831f7375b725f26ebec1df88687fdfeab"}], "stats": {"total": 191, "additions": 191, "deletions": 0}, "files": [{"sha": "eebf17c3e61226cd226a05c015106411e7ba3036", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/77cc1c5107ced596b694265d898194f33ace361e/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77cc1c5107ced596b694265d898194f33ace361e/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=77cc1c5107ced596b694265d898194f33ace361e", "patch": "@@ -121,6 +121,7 @@ pub mod owned;\n pub mod managed;\n pub mod borrow;\n pub mod rc;\n+pub mod weak;\n pub mod gc;\n \n "}, {"sha": "54176a1dc434f19fdf752e37bf23df579c6e0985", "filename": "src/libstd/weak.rs", "status": "added", "additions": 190, "deletions": 0, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/77cc1c5107ced596b694265d898194f33ace361e/src%2Flibstd%2Fweak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77cc1c5107ced596b694265d898194f33ace361e/src%2Flibstd%2Fweak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fweak.rs?ref=77cc1c5107ced596b694265d898194f33ace361e", "patch": "@@ -0,0 +1,190 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*! Task-local reference counted boxes with weak pointer support\n+\n+The `Strong` type is an extension of `std::rc::Rc` with a `downgrade` method returning a `Weak`\n+pointer type. Ownership of the contained value is shared amongst the `Strong` pointers, and the\n+value will be destroyed as soon as the last one is gone. A `Weak` pointer can be upgraded to a\n+`Strong` pointer, but will return `None` if the value has already been freed. It can be used to\n+avoid creating reference cycles.\n+\n+For example, a tree with parent pointers can be represented by putting the nodes behind `Strong`\n+pointers, and then storing the parent pointers as `Weak` pointers.\n+\n+*/\n+\n+use cast::transmute;\n+use ops::Drop;\n+use cmp::{Eq, Ord};\n+use clone::{Clone, DeepClone};\n+use rt::global_heap::exchange_free;\n+use ptr::read_ptr;\n+use option::{Option, Some, None};\n+\n+struct RcBox<T> {\n+    value: T,\n+    strong: uint,\n+    weak: uint\n+}\n+\n+/// Immutable reference counted pointer type\n+#[unsafe_no_drop_flag]\n+#[no_send]\n+pub struct Strong<T> {\n+    priv ptr: *mut RcBox<T>\n+}\n+\n+impl<T> Strong<T> {\n+    /// Construct a new reference-counted box\n+    pub fn new(value: T) -> Strong<T> {\n+        unsafe {\n+            Strong { ptr: transmute(~RcBox { value: value, strong: 1, weak: 0 }) }\n+        }\n+    }\n+}\n+\n+impl<T> Strong<T> {\n+    /// Borrow the value contained in the reference-counted box\n+    #[inline(always)]\n+    pub fn borrow<'a>(&'a self) -> &'a T {\n+        unsafe { &(*self.ptr).value }\n+    }\n+\n+    /// Downgrade the reference-counted pointer to a weak reference\n+    pub fn downgrade(&self) -> Weak<T> {\n+        unsafe {\n+            (*self.ptr).weak += 1;\n+            Weak { ptr: self.ptr }\n+        }\n+    }\n+}\n+\n+#[unsafe_destructor]\n+impl<T> Drop for Strong<T> {\n+    fn drop(&mut self) {\n+        unsafe {\n+            if self.ptr != 0 as *mut RcBox<T> {\n+                (*self.ptr).strong -= 1;\n+                if (*self.ptr).strong == 0 {\n+                    read_ptr(self.borrow()); // destroy the contained object\n+                    if (*self.ptr).weak == 0 {\n+                        exchange_free(self.ptr as *mut u8 as *i8)\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<T> Clone for Strong<T> {\n+    #[inline]\n+    fn clone(&self) -> Strong<T> {\n+        unsafe {\n+            (*self.ptr).strong += 1;\n+            Strong { ptr: self.ptr }\n+        }\n+    }\n+}\n+\n+impl<T: DeepClone> DeepClone for Strong<T> {\n+    #[inline]\n+    fn deep_clone(&self) -> Strong<T> {\n+        Strong::new(self.borrow().deep_clone())\n+    }\n+}\n+\n+impl<T: Eq> Eq for Strong<T> {\n+    #[inline(always)]\n+    fn eq(&self, other: &Strong<T>) -> bool { *self.borrow() == *other.borrow() }\n+\n+    #[inline(always)]\n+    fn ne(&self, other: &Strong<T>) -> bool { *self.borrow() != *other.borrow() }\n+}\n+\n+impl<T: Ord> Ord for Strong<T> {\n+    #[inline(always)]\n+    fn lt(&self, other: &Strong<T>) -> bool { *self.borrow() < *other.borrow() }\n+\n+    #[inline(always)]\n+    fn le(&self, other: &Strong<T>) -> bool { *self.borrow() <= *other.borrow() }\n+\n+    #[inline(always)]\n+    fn gt(&self, other: &Strong<T>) -> bool { *self.borrow() > *other.borrow() }\n+\n+    #[inline(always)]\n+    fn ge(&self, other: &Strong<T>) -> bool { *self.borrow() >= *other.borrow() }\n+}\n+\n+/// Weak reference to a reference-counted box\n+#[unsafe_no_drop_flag]\n+#[no_send]\n+pub struct Weak<T> {\n+    priv ptr: *mut RcBox<T>\n+}\n+\n+impl<T> Weak<T> {\n+    /// Upgrade a weak reference to a strong reference\n+    pub fn upgrade(&self) -> Option<Strong<T>> {\n+        unsafe {\n+            if (*self.ptr).strong == 0 {\n+                None\n+            } else {\n+                (*self.ptr).strong += 1;\n+                Some(Strong { ptr: self.ptr })\n+            }\n+        }\n+    }\n+}\n+\n+#[unsafe_destructor]\n+impl<T> Drop for Weak<T> {\n+    fn drop(&mut self) {\n+        unsafe {\n+            if self.ptr != 0 as *mut RcBox<T> {\n+                (*self.ptr).weak -= 1;\n+                if (*self.ptr).weak == 0 && (*self.ptr).strong == 0 {\n+                    exchange_free(self.ptr as *mut u8 as *i8)\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<T> Clone for Weak<T> {\n+    #[inline]\n+    fn clone(&self) -> Weak<T> {\n+        unsafe {\n+            (*self.ptr).weak += 1;\n+            Weak { ptr: self.ptr }\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use prelude::drop;\n+\n+    #[test]\n+    fn test_live() {\n+        let x = Strong::new(5);\n+        let y = x.downgrade();\n+        assert!(y.upgrade().is_some());\n+    }\n+\n+    #[test]\n+    fn test_dead() {\n+        let x = Strong::new(5);\n+        let y = x.downgrade();\n+        drop(x);\n+        assert!(y.upgrade().is_none());\n+    }\n+}"}]}