{"sha": "d17d2dd48e7f6baabfdeeef567b79013caec1a01", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxN2QyZGQ0OGU3ZjZiYWFiZmRlZWVmNTY3Yjc5MDEzY2FlYzFhMDE=", "commit": {"author": {"name": "Bj\u00f6rn Steinbrink", "email": "bsteinbr@gmail.com", "date": "2015-07-29T11:53:59Z"}, "committer": {"name": "Bj\u00f6rn Steinbrink", "email": "bsteinbr@gmail.com", "date": "2015-08-12T05:42:31Z"}, "message": "Workaround ODR violations in enum debuginfo\n\nWhen using a generic enum type that was defined in an external crate,\nour debuginfo currently claims that the concrete type (e.g. Option<i32>)\nwas defined in the current crate, where it was first used.\n\nThis means that if there are multiple crates that all use, for example,\nOption<i32> values, they'll have conflicting debuginfo, each crate\nclaiming to have defined that type. This doesn't cause problems in\nregular builds, but with LTO enabled, LLVM complains because it tries to\nmerge the debuginfo for those types and sees the ODR violations.\n\nSince I couldn't find a way to get the file info for the external crate\nthat actually defined the enum, I'm working around the issue by using\n\"<unknown>\" as the file for enum types. We'll want to re-visit and fix\nthis later, but this at least this fixes the ICE. And with the file\nbeing unknown instead of wrong, the debuginfo isn't really worse than\nbefore either.\n\nFixes #26447", "tree": {"sha": "ee8355b28cc3d2ca152ddaf193e09f21b748d74c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee8355b28cc3d2ca152ddaf193e09f21b748d74c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d17d2dd48e7f6baabfdeeef567b79013caec1a01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d17d2dd48e7f6baabfdeeef567b79013caec1a01", "html_url": "https://github.com/rust-lang/rust/commit/d17d2dd48e7f6baabfdeeef567b79013caec1a01", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d17d2dd48e7f6baabfdeeef567b79013caec1a01/comments", "author": {"login": "dotdash", "id": 230962, "node_id": "MDQ6VXNlcjIzMDk2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dotdash", "html_url": "https://github.com/dotdash", "followers_url": "https://api.github.com/users/dotdash/followers", "following_url": "https://api.github.com/users/dotdash/following{/other_user}", "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}", "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions", "organizations_url": "https://api.github.com/users/dotdash/orgs", "repos_url": "https://api.github.com/users/dotdash/repos", "events_url": "https://api.github.com/users/dotdash/events{/privacy}", "received_events_url": "https://api.github.com/users/dotdash/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dotdash", "id": 230962, "node_id": "MDQ6VXNlcjIzMDk2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dotdash", "html_url": "https://github.com/dotdash", "followers_url": "https://api.github.com/users/dotdash/followers", "following_url": "https://api.github.com/users/dotdash/following{/other_user}", "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}", "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions", "organizations_url": "https://api.github.com/users/dotdash/orgs", "repos_url": "https://api.github.com/users/dotdash/repos", "events_url": "https://api.github.com/users/dotdash/events{/privacy}", "received_events_url": "https://api.github.com/users/dotdash/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "58b0aa5e420643d454cf141263652a8bcb6a35f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/58b0aa5e420643d454cf141263652a8bcb6a35f1", "html_url": "https://github.com/rust-lang/rust/commit/58b0aa5e420643d454cf141263652a8bcb6a35f1"}], "stats": {"total": 60, "additions": 38, "deletions": 22}, "files": [{"sha": "63b3f6b5eb10458fc4d74fc94ea698345a17f00d", "filename": "src/librustc_trans/trans/debuginfo/metadata.rs", "status": "modified", "additions": 38, "deletions": 22, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/d17d2dd48e7f6baabfdeeef567b79013caec1a01/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d17d2dd48e7f6baabfdeeef567b79013caec1a01/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs?ref=d17d2dd48e7f6baabfdeeef567b79013caec1a01", "patch": "@@ -63,8 +63,8 @@ pub const UNKNOWN_LINE_NUMBER: c_uint = 0;\n pub const UNKNOWN_COLUMN_NUMBER: c_uint = 0;\n \n // ptr::null() doesn't work :(\n-const UNKNOWN_FILE_METADATA: DIFile = (0 as DIFile);\n-const UNKNOWN_SCOPE_METADATA: DIScope = (0 as DIScope);\n+const NO_FILE_METADATA: DIFile = (0 as DIFile);\n+const NO_SCOPE_METADATA: DIScope = (0 as DIScope);\n \n const FLAGS_NONE: c_uint = 0;\n \n@@ -566,7 +566,7 @@ fn vec_slice_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                            &slice_type_name[..],\n                                            unique_type_id,\n                                            &member_descriptions,\n-                                           UNKNOWN_SCOPE_METADATA,\n+                                           NO_SCOPE_METADATA,\n                                            file_metadata,\n                                            span);\n     return MetadataCreationResult::new(metadata, false);\n@@ -611,7 +611,7 @@ fn subroutine_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         unsafe {\n             llvm::LLVMDIBuilderCreateSubroutineType(\n                 DIB(cx),\n-                UNKNOWN_FILE_METADATA,\n+                NO_FILE_METADATA,\n                 create_DIArray(DIB(cx), &signature_metadata[..]))\n         },\n         false);\n@@ -655,7 +655,7 @@ fn trait_pointer_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                             unique_type_id,\n                             &[],\n                             containing_scope,\n-                            UNKNOWN_FILE_METADATA,\n+                            NO_FILE_METADATA,\n                             codemap::DUMMY_SP)\n }\n \n@@ -851,13 +851,6 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n }\n \n pub fn file_metadata(cx: &CrateContext, full_path: &str) -> DIFile {\n-    match debug_context(cx).created_files.borrow().get(full_path) {\n-        Some(file_metadata) => return *file_metadata,\n-        None => ()\n-    }\n-\n-    debug!(\"file_metadata: {}\", full_path);\n-\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     let work_dir = cx.sess().working_dir.to_str().unwrap();\n     let file_name =\n@@ -867,6 +860,24 @@ pub fn file_metadata(cx: &CrateContext, full_path: &str) -> DIFile {\n             full_path\n         };\n \n+    file_metadata_(cx, full_path, file_name, &work_dir)\n+}\n+\n+pub fn unknown_file_metadata(cx: &CrateContext) -> DIFile {\n+    // Regular filenames should not be empty, so we abuse an empty name as the\n+    // key for the special unknown file metadata\n+    file_metadata_(cx, \"\", \"<unknown>\", \"\")\n+\n+}\n+\n+fn file_metadata_(cx: &CrateContext, key: &str, file_name: &str, work_dir: &str) -> DIFile {\n+    match debug_context(cx).created_files.borrow().get(key) {\n+        Some(file_metadata) => return *file_metadata,\n+        None => ()\n+    }\n+\n+    debug!(\"file_metadata: file_name: {}, work_dir: {}\", file_name, work_dir);\n+\n     let file_name = CString::new(file_name).unwrap();\n     let work_dir = CString::new(work_dir).unwrap();\n     let file_metadata = unsafe {\n@@ -875,8 +886,8 @@ pub fn file_metadata(cx: &CrateContext, full_path: &str) -> DIFile {\n     };\n \n     let mut created_files = debug_context(cx).created_files.borrow_mut();\n-    created_files.insert(full_path.to_string(), file_metadata);\n-    return file_metadata;\n+    created_files.insert(key.to_string(), file_metadata);\n+    file_metadata\n }\n \n /// Finds the scope metadata node for the given AST node.\n@@ -1227,7 +1238,7 @@ fn prepare_tuple_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                            tuple_llvm_type,\n                            &tuple_name[..],\n                            unique_type_id,\n-                           UNKNOWN_SCOPE_METADATA),\n+                           NO_SCOPE_METADATA),\n         tuple_llvm_type,\n         TupleMDF(TupleMemberDescriptionFactory {\n             component_types: component_types.to_vec(),\n@@ -1570,9 +1581,14 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                    -> RecursiveTypeDescription<'tcx> {\n     let enum_name = compute_debuginfo_type_name(cx, enum_type, false);\n \n-    let (containing_scope, definition_span) = get_namespace_and_span_for_item(cx, enum_def_id);\n-    let loc = span_start(cx, definition_span);\n-    let file_metadata = file_metadata(cx, &loc.file.name);\n+    let (containing_scope, _) = get_namespace_and_span_for_item(cx, enum_def_id);\n+    // FIXME: This should emit actual file metadata for the enum, but we\n+    // currently can't get the necessary information when it comes to types\n+    // imported from other crates. Formerly we violated the ODR when performing\n+    // LTO because we emitted debuginfo for the same type with varying file\n+    // metadata, so as a workaround we pretend that the type comes from\n+    // <unknown>\n+    let file_metadata = unknown_file_metadata(cx);\n \n     let variants = &enum_type.ty_adt_def().unwrap().variants;\n \n@@ -1613,7 +1629,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                         DIB(cx),\n                         containing_scope,\n                         name.as_ptr(),\n-                        UNKNOWN_FILE_METADATA,\n+                        NO_FILE_METADATA,\n                         UNKNOWN_LINE_NUMBER,\n                         bytes_to_bits(discriminant_size),\n                         bytes_to_bits(discriminant_align),\n@@ -1765,7 +1781,7 @@ fn set_members_of_composite_type(cx: &CrateContext,\n                     DIB(cx),\n                     composite_type_metadata,\n                     member_name.as_ptr(),\n-                    UNKNOWN_FILE_METADATA,\n+                    NO_FILE_METADATA,\n                     UNKNOWN_LINE_NUMBER,\n                     bytes_to_bits(member_size),\n                     bytes_to_bits(member_align),\n@@ -1808,7 +1824,7 @@ fn create_struct_stub(cx: &CrateContext,\n             DIB(cx),\n             containing_scope,\n             name.as_ptr(),\n-            UNKNOWN_FILE_METADATA,\n+            NO_FILE_METADATA,\n             UNKNOWN_LINE_NUMBER,\n             bytes_to_bits(struct_size),\n             bytes_to_bits(struct_align),\n@@ -1869,7 +1885,7 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n         let loc = span_start(cx, span);\n         (file_metadata(cx, &loc.file.name), loc.line as c_uint)\n     } else {\n-        (UNKNOWN_FILE_METADATA, UNKNOWN_LINE_NUMBER)\n+        (NO_FILE_METADATA, UNKNOWN_LINE_NUMBER)\n     };\n \n     let is_local_to_unit = is_node_local_to_unit(cx, node_id);"}]}