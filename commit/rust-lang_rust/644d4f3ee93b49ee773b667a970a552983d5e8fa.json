{"sha": "644d4f3ee93b49ee773b667a970a552983d5e8fa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0NGQ0ZjNlZTkzYjQ5ZWU3NzNiNjY3YTk3MGE1NTI5ODNkNWU4ZmE=", "commit": {"author": {"name": "Wesley Wiser", "email": "wwiser@gmail.com", "date": "2019-09-06T11:48:52Z"}, "committer": {"name": "Wesley Wiser", "email": "wwiser@gmail.com", "date": "2019-09-28T00:11:12Z"}, "message": "[const-prop] Replace most `UnaryOp` handling with use of `InterpCx`", "tree": {"sha": "6e11b6c375f2cc9d917be63413b802357f1d2077", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6e11b6c375f2cc9d917be63413b802357f1d2077"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/644d4f3ee93b49ee773b667a970a552983d5e8fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/644d4f3ee93b49ee773b667a970a552983d5e8fa", "html_url": "https://github.com/rust-lang/rust/commit/644d4f3ee93b49ee773b667a970a552983d5e8fa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/644d4f3ee93b49ee773b667a970a552983d5e8fa/comments", "author": {"login": "wesleywiser", "id": 831192, "node_id": "MDQ6VXNlcjgzMTE5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/831192?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wesleywiser", "html_url": "https://github.com/wesleywiser", "followers_url": "https://api.github.com/users/wesleywiser/followers", "following_url": "https://api.github.com/users/wesleywiser/following{/other_user}", "gists_url": "https://api.github.com/users/wesleywiser/gists{/gist_id}", "starred_url": "https://api.github.com/users/wesleywiser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wesleywiser/subscriptions", "organizations_url": "https://api.github.com/users/wesleywiser/orgs", "repos_url": "https://api.github.com/users/wesleywiser/repos", "events_url": "https://api.github.com/users/wesleywiser/events{/privacy}", "received_events_url": "https://api.github.com/users/wesleywiser/received_events", "type": "User", "site_admin": false}, "committer": {"login": "wesleywiser", "id": 831192, "node_id": "MDQ6VXNlcjgzMTE5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/831192?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wesleywiser", "html_url": "https://github.com/wesleywiser", "followers_url": "https://api.github.com/users/wesleywiser/followers", "following_url": "https://api.github.com/users/wesleywiser/following{/other_user}", "gists_url": "https://api.github.com/users/wesleywiser/gists{/gist_id}", "starred_url": "https://api.github.com/users/wesleywiser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wesleywiser/subscriptions", "organizations_url": "https://api.github.com/users/wesleywiser/orgs", "repos_url": "https://api.github.com/users/wesleywiser/repos", "events_url": "https://api.github.com/users/wesleywiser/events{/privacy}", "received_events_url": "https://api.github.com/users/wesleywiser/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c219bb34bead8b603da164dfcbb7c808ae70384", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c219bb34bead8b603da164dfcbb7c808ae70384", "html_url": "https://github.com/rust-lang/rust/commit/1c219bb34bead8b603da164dfcbb7c808ae70384"}], "stats": {"total": 45, "additions": 17, "deletions": 28}, "files": [{"sha": "f172071a8fb9ce5cf182990e2109d4deaeb6a981", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 17, "deletions": 28, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/644d4f3ee93b49ee773b667a970a552983d5e8fa/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/644d4f3ee93b49ee773b667a970a552983d5e8fa/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=644d4f3ee93b49ee773b667a970a552983d5e8fa", "patch": "@@ -325,39 +325,28 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             },\n \n             Rvalue::UnaryOp(op, ref arg) => {\n-                let def_id = if self.tcx.is_closure(self.source.def_id()) {\n-                    self.tcx.closure_base_def_id(self.source.def_id())\n-                } else {\n-                    self.source.def_id()\n-                };\n-                let generics = self.tcx.generics_of(def_id);\n-                if generics.requires_monomorphization(self.tcx) {\n-                    // FIXME: can't handle code with generics\n-                    return None;\n-                }\n+                let overflow_check = self.tcx.sess.overflow_checks();\n \n-                let arg = self.eval_operand(arg, source_info)?;\n-                let oflo_check = self.tcx.sess.overflow_checks();\n-                let val = self.use_ecx(source_info, |this| {\n-                    let prim = this.ecx.read_immediate(arg)?;\n-                    match op {\n-                        UnOp::Neg => {\n-                            // We check overflow in debug mode already\n-                            // so should only check in release mode.\n-                            if !oflo_check\n-                            && prim.layout.ty.is_signed()\n-                            && prim.to_bits()? == (1 << (prim.layout.size.bits() - 1)) {\n+                self.use_ecx(source_info, |this| {\n+                    // We check overflow in debug mode already\n+                    // so should only check in release mode.\n+                    if op == UnOp::Neg && !overflow_check {\n+                        let ty = arg.ty(&this.local_decls, this.tcx);\n+\n+                        if ty.is_integral() {\n+                            let arg = this.ecx.eval_operand(arg, None)?;\n+                            let prim = this.ecx.read_immediate(arg)?;\n+                            // Need to do overflow check here: For actual CTFE, MIR\n+                            // generation emits code that does this before calling the op.\n+                            if prim.to_bits()? == (1 << (prim.layout.size.bits() - 1)) {\n                                 throw_panic!(OverflowNeg)\n                             }\n                         }\n-                        UnOp::Not => {\n-                            // Cannot overflow\n-                        }\n                     }\n-                    // Now run the actual operation.\n-                    this.ecx.unary_op(op, prim)\n-                })?;\n-                Some(val.into())\n+\n+                    this.ecx.eval_rvalue_into_place(rvalue, place)?;\n+                    this.ecx.eval_place_to_op(place, Some(place_layout))\n+                })\n             }\n             Rvalue::CheckedBinaryOp(op, ref left, ref right) |\n             Rvalue::BinaryOp(op, ref left, ref right) => {"}]}