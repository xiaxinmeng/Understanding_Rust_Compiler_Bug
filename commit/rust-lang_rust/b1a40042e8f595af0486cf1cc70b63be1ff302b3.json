{"sha": "b1a40042e8f595af0486cf1cc70b63be1ff302b3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxYTQwMDQyZThmNTk1YWYwNDg2Y2YxY2M3MGI2M2JlMWZmMzAyYjM=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-08-22T11:23:50Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-08-22T19:55:11Z"}, "message": "Handle impl/dyn Trait in method resolution\n\nWhen we have one of these, the `Trait` doesn't need to be in scope to call its\nmethods. So we need to consider this when looking for method\ncandidates. (Actually I think the same is true when we have a bound `T:\nsome::Trait`, but we don't handle that yet).\n\nAt the same time, since Chalk doesn't handle these types yet, add a small hack\nto skip Chalk in method resolution and just consider `impl Trait: Trait` always\ntrue. This is enough to e.g. get completions for `impl Trait`, but since we\ndon't do any unification we won't infer the return type of e.g. `impl\nInto<i64>::into()`.", "tree": {"sha": "c3f58127c4a330275d2dd635bb5fb11ca7957ddc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c3f58127c4a330275d2dd635bb5fb11ca7957ddc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b1a40042e8f595af0486cf1cc70b63be1ff302b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b1a40042e8f595af0486cf1cc70b63be1ff302b3", "html_url": "https://github.com/rust-lang/rust/commit/b1a40042e8f595af0486cf1cc70b63be1ff302b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b1a40042e8f595af0486cf1cc70b63be1ff302b3/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "16a7d8cc850002b427fdc8d21ccde81caaed7902", "url": "https://api.github.com/repos/rust-lang/rust/commits/16a7d8cc850002b427fdc8d21ccde81caaed7902", "html_url": "https://github.com/rust-lang/rust/commit/16a7d8cc850002b427fdc8d21ccde81caaed7902"}], "stats": {"total": 111, "additions": 79, "deletions": 32}, "files": [{"sha": "b54c80318522f0caf6efbdbf855b88e3eea07b32", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b1a40042e8f595af0486cf1cc70b63be1ff302b3/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1a40042e8f595af0486cf1cc70b63be1ff302b3/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=b1a40042e8f595af0486cf1cc70b63be1ff302b3", "patch": "@@ -583,6 +583,19 @@ impl Ty {\n             ty => ty,\n         })\n     }\n+\n+    /// If this is an `impl Trait` or `dyn Trait`, returns that trait.\n+    pub fn inherent_trait(&self) -> Option<Trait> {\n+        match self {\n+            Ty::Dyn(predicates) | Ty::Opaque(predicates) => {\n+                predicates.iter().find_map(|pred| match pred {\n+                    GenericPredicate::Implemented(tr) => Some(tr.trait_),\n+                    _ => None,\n+                })\n+            }\n+            _ => None,\n+        }\n+    }\n }\n \n impl HirDisplay for &Ty {"}, {"sha": "9873a0440bcdcd07f7dbc28f778fc6856a9e7cb7", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b1a40042e8f595af0486cf1cc70b63be1ff302b3/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1a40042e8f595af0486cf1cc70b63be1ff302b3/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=b1a40042e8f595af0486cf1cc70b63be1ff302b3", "patch": "@@ -211,12 +211,19 @@ fn iterate_trait_method_candidates<T>(\n     let krate = resolver.krate()?;\n     // FIXME: maybe put the trait_env behind a query (need to figure out good input parameters for that)\n     let env = lower::trait_env(db, resolver);\n-    'traits: for t in resolver.traits_in_scope(db) {\n+    // if ty is `impl Trait` or `dyn Trait`, the trait doesn't need to be in scope\n+    let traits = ty.value.inherent_trait().into_iter().chain(resolver.traits_in_scope(db));\n+    'traits: for t in traits {\n         let data = t.trait_data(db);\n+\n+        // FIXME this is a bit of a hack, since Chalk should say the same thing\n+        // anyway, but currently Chalk doesn't implement `dyn/impl Trait` yet\n+        let inherently_implemented = ty.value.inherent_trait() == Some(t);\n+\n         // we'll be lazy about checking whether the type implements the\n         // trait, but if we find out it doesn't, we'll skip the rest of the\n         // iteration\n-        let mut known_implemented = false;\n+        let mut known_implemented = inherently_implemented;\n         for item in data.items() {\n             if let TraitItem::Function(m) = *item {\n                 let data = m.data(db);\n@@ -271,6 +278,11 @@ pub(crate) fn implements_trait(\n     krate: Crate,\n     trait_: Trait,\n ) -> bool {\n+    if ty.value.inherent_trait() == Some(trait_) {\n+        // FIXME this is a bit of a hack, since Chalk should say the same thing\n+        // anyway, but currently Chalk doesn't implement `dyn/impl Trait` yet\n+        return true;\n+    }\n     let env = lower::trait_env(db, resolver);\n     let goal = generic_implements_goal(db, env.clone(), trait_, ty.clone());\n     let solution = db.trait_solve(krate, goal);"}, {"sha": "41cea9564fb62b35bbe753ac698e74978270e760", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 52, "deletions": 30, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/b1a40042e8f595af0486cf1cc70b63be1ff302b3/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1a40042e8f595af0486cf1cc70b63be1ff302b3/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=b1a40042e8f595af0486cf1cc70b63be1ff302b3", "patch": "@@ -3279,6 +3279,7 @@ fn impl_trait() {\n         infer(r#\"\n trait Trait<T> {\n     fn foo(&self) -> T;\n+    fn foo2(&self) -> i64;\n }\n fn bar() -> impl Trait<u64> {}\n \n@@ -3289,26 +3290,36 @@ fn test(x: impl Trait<u64>, y: &impl Trait<u64>) {\n     x.foo();\n     y.foo();\n     z.foo();\n+    x.foo2();\n+    y.foo2();\n+    z.foo2();\n }\n \"#),\n         @r###\"\n    \u22ee\n    \u22ee[30; 34) 'self': &Self\n-   \u22ee[72; 74) '{}': ()\n-   \u22ee[84; 85) 'x': impl Trait<u64>\n-   \u22ee[104; 105) 'y': &impl Trait<u64>\n-   \u22ee[125; 200) '{     ...o(); }': ()\n-   \u22ee[131; 132) 'x': impl Trait<u64>\n-   \u22ee[138; 139) 'y': &impl Trait<u64>\n-   \u22ee[149; 150) 'z': impl Trait<u64>\n-   \u22ee[153; 156) 'bar': fn bar() -> impl Trait<u64>\n-   \u22ee[153; 158) 'bar()': impl Trait<u64>\n-   \u22ee[164; 165) 'x': impl Trait<u64>\n-   \u22ee[164; 171) 'x.foo()': {unknown}\n-   \u22ee[177; 178) 'y': &impl Trait<u64>\n-   \u22ee[177; 184) 'y.foo()': {unknown}\n-   \u22ee[190; 191) 'z': impl Trait<u64>\n-   \u22ee[190; 197) 'z.foo()': {unknown}\n+   \u22ee[55; 59) 'self': &Self\n+   \u22ee[99; 101) '{}': ()\n+   \u22ee[111; 112) 'x': impl Trait<u64>\n+   \u22ee[131; 132) 'y': &impl Trait<u64>\n+   \u22ee[152; 269) '{     ...2(); }': ()\n+   \u22ee[158; 159) 'x': impl Trait<u64>\n+   \u22ee[165; 166) 'y': &impl Trait<u64>\n+   \u22ee[176; 177) 'z': impl Trait<u64>\n+   \u22ee[180; 183) 'bar': fn bar() -> impl Trait<u64>\n+   \u22ee[180; 185) 'bar()': impl Trait<u64>\n+   \u22ee[191; 192) 'x': impl Trait<u64>\n+   \u22ee[191; 198) 'x.foo()': {unknown}\n+   \u22ee[204; 205) 'y': &impl Trait<u64>\n+   \u22ee[204; 211) 'y.foo()': {unknown}\n+   \u22ee[217; 218) 'z': impl Trait<u64>\n+   \u22ee[217; 224) 'z.foo()': {unknown}\n+   \u22ee[230; 231) 'x': impl Trait<u64>\n+   \u22ee[230; 238) 'x.foo2()': i64\n+   \u22ee[244; 245) 'y': &impl Trait<u64>\n+   \u22ee[244; 252) 'y.foo2()': i64\n+   \u22ee[258; 259) 'z': impl Trait<u64>\n+   \u22ee[258; 266) 'z.foo2()': i64\n     \"###\n     );\n }\n@@ -3319,6 +3330,7 @@ fn dyn_trait() {\n         infer(r#\"\n trait Trait<T> {\n     fn foo(&self) -> T;\n+    fn foo2(&self) -> i64;\n }\n fn bar() -> dyn Trait<u64> {}\n \n@@ -3329,26 +3341,36 @@ fn test(x: dyn Trait<u64>, y: &dyn Trait<u64>) {\n     x.foo();\n     y.foo();\n     z.foo();\n+    x.foo2();\n+    y.foo2();\n+    z.foo2();\n }\n \"#),\n         @r###\"\n    \u22ee\n    \u22ee[30; 34) 'self': &Self\n-   \u22ee[71; 73) '{}': ()\n-   \u22ee[83; 84) 'x': dyn Trait<u64>\n-   \u22ee[102; 103) 'y': &dyn Trait<u64>\n-   \u22ee[122; 197) '{     ...o(); }': ()\n-   \u22ee[128; 129) 'x': dyn Trait<u64>\n-   \u22ee[135; 136) 'y': &dyn Trait<u64>\n-   \u22ee[146; 147) 'z': dyn Trait<u64>\n-   \u22ee[150; 153) 'bar': fn bar() -> dyn Trait<u64>\n-   \u22ee[150; 155) 'bar()': dyn Trait<u64>\n-   \u22ee[161; 162) 'x': dyn Trait<u64>\n-   \u22ee[161; 168) 'x.foo()': {unknown}\n-   \u22ee[174; 175) 'y': &dyn Trait<u64>\n-   \u22ee[174; 181) 'y.foo()': {unknown}\n-   \u22ee[187; 188) 'z': dyn Trait<u64>\n-   \u22ee[187; 194) 'z.foo()': {unknown}\n+   \u22ee[55; 59) 'self': &Self\n+   \u22ee[98; 100) '{}': ()\n+   \u22ee[110; 111) 'x': dyn Trait<u64>\n+   \u22ee[129; 130) 'y': &dyn Trait<u64>\n+   \u22ee[149; 266) '{     ...2(); }': ()\n+   \u22ee[155; 156) 'x': dyn Trait<u64>\n+   \u22ee[162; 163) 'y': &dyn Trait<u64>\n+   \u22ee[173; 174) 'z': dyn Trait<u64>\n+   \u22ee[177; 180) 'bar': fn bar() -> dyn Trait<u64>\n+   \u22ee[177; 182) 'bar()': dyn Trait<u64>\n+   \u22ee[188; 189) 'x': dyn Trait<u64>\n+   \u22ee[188; 195) 'x.foo()': {unknown}\n+   \u22ee[201; 202) 'y': &dyn Trait<u64>\n+   \u22ee[201; 208) 'y.foo()': {unknown}\n+   \u22ee[214; 215) 'z': dyn Trait<u64>\n+   \u22ee[214; 221) 'z.foo()': {unknown}\n+   \u22ee[227; 228) 'x': dyn Trait<u64>\n+   \u22ee[227; 235) 'x.foo2()': i64\n+   \u22ee[241; 242) 'y': &dyn Trait<u64>\n+   \u22ee[241; 249) 'y.foo2()': i64\n+   \u22ee[255; 256) 'z': dyn Trait<u64>\n+   \u22ee[255; 263) 'z.foo2()': i64\n     \"###\n     );\n }"}]}