{"sha": "1aa749469bfc57ae023be6fbb1141b806bcb3d62", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhYTc0OTQ2OWJmYzU3YWUwMjNiZTZmYmIxMTQxYjgwNmJjYjNkNjI=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-05-24T12:30:21Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-08-16T19:09:05Z"}, "message": "Introduce signed_bias method\n\nThe epitome of simplicity!", "tree": {"sha": "4d3a89c41dd5679d22ef3dbffd5fa76930c36453", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d3a89c41dd5679d22ef3dbffd5fa76930c36453"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1aa749469bfc57ae023be6fbb1141b806bcb3d62", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1aa749469bfc57ae023be6fbb1141b806bcb3d62", "html_url": "https://github.com/rust-lang/rust/commit/1aa749469bfc57ae023be6fbb1141b806bcb3d62", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1aa749469bfc57ae023be6fbb1141b806bcb3d62/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "72cc4bd33b0d1b975173f4032581040fa354b724", "url": "https://api.github.com/repos/rust-lang/rust/commits/72cc4bd33b0d1b975173f4032581040fa354b724", "html_url": "https://github.com/rust-lang/rust/commit/72cc4bd33b0d1b975173f4032581040fa354b724"}], "stats": {"total": 66, "additions": 21, "deletions": 45}, "files": [{"sha": "0d56f345d8eafeee0fd9c8c9e208baacc48e12e0", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 21, "deletions": 45, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/1aa749469bfc57ae023be6fbb1141b806bcb3d62/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aa749469bfc57ae023be6fbb1141b806bcb3d62/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=1aa749469bfc57ae023be6fbb1141b806bcb3d62", "patch": "@@ -21,11 +21,13 @@ use super::{PatternFoldable, PatternFolder, compare_const_vals};\n use rustc::hir::def_id::DefId;\n use rustc::hir::RangeEnd;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n+use rustc::ty::layout::{Integer, IntegerExt};\n \n use rustc::mir::Field;\n use rustc::mir::interpret::ConstValue;\n use rustc::util::common::ErrorReported;\n \n+use syntax::attr::{SignedInt, UnsignedInt};\n use syntax_pos::{Span, DUMMY_SP};\n \n use arena::TypedArena;\n@@ -469,21 +471,19 @@ fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                 ConstantRange(endpoint('\\u{E000}'), endpoint('\\u{10FFFF}'), RangeEnd::Included),\n             ]\n         }\n-        ty::TyInt(_) if exhaustive_integer_patterns => {\n+        ty::TyInt(ity) if exhaustive_integer_patterns => {\n             // FIXME(49937): refactor these bit manipulations into interpret.\n-            let bits = cx.tcx.layout_of(ty::ParamEnv::reveal_all().and(pcx.ty))\n-                             .unwrap().size.bits() as u128;\n+            let bits = Integer::from_attr(cx.tcx, SignedInt(ity)).size().bits() as u128;\n             let min = 1u128 << (bits - 1);\n             let max = (1u128 << (bits - 1)) - 1;\n             value_constructors = true;\n             vec![ConstantRange(ty::Const::from_bits(cx.tcx, min as u128, pcx.ty),\n                                ty::Const::from_bits(cx.tcx, max as u128, pcx.ty),\n                                RangeEnd::Included)]\n         }\n-        ty::TyUint(_) if exhaustive_integer_patterns => {\n+        ty::TyUint(uty) if exhaustive_integer_patterns => {\n             // FIXME(49937): refactor these bit manipulations into interpret.\n-            let bits = cx.tcx.layout_of(ty::ParamEnv::reveal_all().and(pcx.ty))\n-                             .unwrap().size.bits() as u128;\n+            let bits = Integer::from_attr(cx.tcx, UnsignedInt(uty)).size().bits() as u128;\n             let max = !0u128 >> (128 - bits);\n             value_constructors = true;\n             vec![ConstantRange(ty::Const::from_bits(cx.tcx, 0, pcx.ty),\n@@ -627,7 +627,8 @@ impl<'tcx> IntRange<'tcx> {\n                     if let Some(hi) = hi.assert_bits(ty) {\n                         // Perform a shift if the underlying types are signed,\n                         // which makes the interval arithmetic simpler.\n-                        let (lo, hi) = Self::encode(tcx, ty, (lo, hi));\n+                        let bias = IntRange::signed_bias(tcx, ty);\n+                        let (lo, hi) = (lo ^ bias, hi ^ bias);\n                         // Make sure the interval is well-formed.\n                         return if lo > hi || lo == hi && *end == RangeEnd::Excluded {\n                             None\n@@ -642,8 +643,9 @@ impl<'tcx> IntRange<'tcx> {\n             ConstantValue(val) => {\n                 let ty = val.ty;\n                 if let Some(val) = val.assert_bits(ty) {\n-                    let (lo, hi) = Self::encode(tcx, ty, (val, val));\n-                    Some(IntRange { range: lo..=hi, ty })\n+                    let bias = IntRange::signed_bias(tcx, ty);\n+                    let val = val ^ bias;\n+                    Some(IntRange { range: val..=val, ty })\n                 } else {\n                     None\n                 }\n@@ -654,46 +656,16 @@ impl<'tcx> IntRange<'tcx> {\n         }\n     }\n \n-    fn encode(tcx: TyCtxt<'_, 'tcx, 'tcx>,\n-              ty: Ty<'tcx>,\n-              (lo, hi): (u128, u128))\n-              -> (u128, u128) {\n+    fn signed_bias(tcx: TyCtxt<'_, 'tcx, 'tcx>, ty: Ty<'tcx>) -> u128 {\n         match ty.sty {\n-            ty::TyInt(_) => {\n-                // FIXME(49937): refactor these bit manipulations into interpret.\n-                let bits = tcx.layout_of(ty::ParamEnv::reveal_all().and(ty))\n-                              .unwrap().size.bits() as u128;\n-                let min = 1u128 << (bits - 1);\n-                let mask = !0u128 >> (128 - bits);\n-                let offset = |x: u128| x.wrapping_sub(min) & mask;\n-                (offset(lo), offset(hi))\n+            ty::TyInt(ity) => {\n+                let bits = Integer::from_attr(tcx, SignedInt(ity)).size().bits() as u128;\n+                1u128 << (bits - 1)\n             }\n-            _ => (lo, hi)\n+            _ => 0\n         }\n     }\n \n-    fn decode(tcx: TyCtxt<'_, 'tcx, 'tcx>,\n-              ty: Ty<'tcx>,\n-              range: RangeInclusive<u128>)\n-              -> Constructor<'tcx> {\n-        let (lo, hi) = range.into_inner();\n-        let (lo, hi) = match ty.sty {\n-            ty::TyInt(_) => {\n-                // FIXME(49937): refactor these bit manipulations into interpret.\n-                let bits = tcx.layout_of(ty::ParamEnv::reveal_all().and(ty))\n-                              .unwrap().size.bits() as u128;\n-                let min = 1u128 << (bits - 1);\n-                let mask = !0u128 >> (128 - bits);\n-                let offset = |x: u128| x.wrapping_add(min) & mask;\n-                (offset(lo), offset(hi))\n-            }\n-            _ => (lo, hi)\n-        };\n-        ConstantRange(ty::Const::from_bits(tcx, lo, ty),\n-                      ty::Const::from_bits(tcx, hi, ty),\n-                      RangeEnd::Included)\n-    }\n-\n     fn into_inner(self) -> (u128, u128) {\n         self.range.into_inner()\n     }\n@@ -733,7 +705,11 @@ fn ranges_subtract_pattern<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n         }\n         // Convert the remaining ranges from pairs to inclusive `ConstantRange`s.\n         remaining_ranges.into_iter().map(|r| {\n-            IntRange::decode(cx.tcx, ty, r)\n+            let (lo, hi) = r.into_inner();\n+            let bias = IntRange::signed_bias(cx.tcx, ty);\n+            ConstantRange(ty::Const::from_bits(cx.tcx, lo ^ bias, ty),\n+                          ty::Const::from_bits(cx.tcx, hi ^ bias, ty),\n+                          RangeEnd::Included)\n         }).collect()\n     } else {\n         ranges"}]}