{"sha": "57d1ed819b9e32a8e915ced9b5e130c299a46bca", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3ZDFlZDgxOWI5ZTMyYThlOTE1Y2VkOWI1ZTEzMGMyOTlhNDZiY2E=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-08T08:11:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-08T08:11:07Z"}, "message": "auto merge of #10303 : niftynif/rust/master, r=catamorphism\n\nr? @catamorphism\r\nFirst contribution; contains struct definitions and some useful traits.  Can possibly be improved by removing the dependence on the Clone trait.  This is intended to be the beginning of a long-term project.", "tree": {"sha": "5bfcc7ef7acdc5bd51662aa44bed426fef915758", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5bfcc7ef7acdc5bd51662aa44bed426fef915758"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/57d1ed819b9e32a8e915ced9b5e130c299a46bca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/57d1ed819b9e32a8e915ced9b5e130c299a46bca", "html_url": "https://github.com/rust-lang/rust/commit/57d1ed819b9e32a8e915ced9b5e130c299a46bca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/57d1ed819b9e32a8e915ced9b5e130c299a46bca/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "acbcb9ed2e24137040a4c0a4f87034e943036ecb", "url": "https://api.github.com/repos/rust-lang/rust/commits/acbcb9ed2e24137040a4c0a4f87034e943036ecb", "html_url": "https://github.com/rust-lang/rust/commit/acbcb9ed2e24137040a4c0a4f87034e943036ecb"}, {"sha": "2f1b4335cbb2673996c5331b2a69b209e2e673cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f1b4335cbb2673996c5331b2a69b209e2e673cd", "html_url": "https://github.com/rust-lang/rust/commit/2f1b4335cbb2673996c5331b2a69b209e2e673cd"}], "stats": {"total": 450, "additions": 450, "deletions": 0}, "files": [{"sha": "d650769d70f8ec040fcae68c92f1e8853b94f8a8", "filename": "src/libextra/btree.rs", "status": "added", "additions": 449, "deletions": 0, "changes": 449, "blob_url": "https://github.com/rust-lang/rust/blob/57d1ed819b9e32a8e915ced9b5e130c299a46bca/src%2Flibextra%2Fbtree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57d1ed819b9e32a8e915ced9b5e130c299a46bca/src%2Flibextra%2Fbtree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbtree.rs?ref=57d1ed819b9e32a8e915ced9b5e130c299a46bca", "patch": "@@ -0,0 +1,449 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+//\n+// btree.rs\n+//\n+\n+//! Starting implementation of a btree for rust.\n+//! Structure inspired by github user davidhalperin's gist.\n+\n+\n+use std::util::replace;\n+\n+\n+///A B-tree contains a root node (which contains a vector of elements),\n+///a length (the height of the tree), and lower and upper bounds on the\n+///number of elements that a given node can contain.\n+#[allow(missing_doc)]\n+pub struct BTree<K, V>{\n+    root: Node<K, V>,\n+    len: uint,\n+    lower_bound: uint,\n+    upper_bound: uint\n+}\n+\n+//We would probably want to remove the dependence on the Clone trait in the future.\n+//It is here as a crutch to ensure values can be passed around through the tree's nodes\n+//especially during insertions and deletions.\n+//Using the swap or replace methods is one option for replacing dependence on Clone, or\n+//changing the way in which the BTree is stored could also potentially work.\n+impl<K: Clone + TotalOrd, V: Clone> BTree<K, V>{\n+\n+    ///Returns new BTree with root node (leaf) and user-supplied lower bound\n+    fn new(k: K, v: V, lb: uint) -> BTree<K, V>{\n+        BTree{\n+            root: Node::new_leaf(~[LeafElt::new(k, v)]),\n+            len: 1,\n+            lower_bound: lb,\n+            upper_bound: 2 * lb\n+        }\n+    }\n+\n+    ///Helper function for clone: returns new BTree with supplied root node,\n+    ///length, and lower bound.  For use when the length is known already.\n+    fn new_with_node_len(n: Node<K, V>, length: uint, lb: uint) -> BTree<K, V>{\n+        BTree{\n+            root: n,\n+            len: length,\n+            lower_bound: lb,\n+            upper_bound: 2 * lb\n+        }\n+    }\n+\n+    ///Implements the Clone trait for the BTree.\n+    ///Uses a helper function/constructor to produce a new BTree.\n+    fn clone(&self) -> BTree<K, V>{\n+        return BTree::new_with_node_len(self.root.clone(), self.len, self.lower_bound);\n+    }\n+\n+    ///Returns the value of a given key, which may not exist in the tree.\n+    ///Calls the root node's get method.\n+    fn get(self, k: K) -> Option<V>{\n+        return self.root.get(k);\n+    }\n+\n+    ///Checks to see if the key already exists in the tree, and if it is not,\n+    ///the key-value pair is added to the tree by calling add on the root node.\n+    fn add(self, k: K, v: V) -> bool{\n+        let is_get = &self.clone().get(k.clone());\n+        if is_get.is_some(){ return false; }\n+        else{\n+            replace(&mut self.root.clone(),self.root.add(k.clone(), v));\n+            return true;\n+        }\n+\n+    }\n+\n+\n+\n+}\n+\n+impl<K: ToStr + TotalOrd, V: ToStr> ToStr for BTree<K, V>{\n+    ///Returns a string representation of the BTree\n+    fn to_str(&self) -> ~str{\n+        let ret = self.root.to_str();\n+        ret\n+    }\n+}\n+\n+\n+//Node types\n+//A node is either a LeafNode or a BranchNode, which contain either a Leaf or a Branch.\n+//Branches contain BranchElts, which contain a left child (another node) and a key-value\n+//pair.  Branches also contain the rightmost child of the elements in the array.\n+//Leaves contain LeafElts, which do not have children.\n+enum Node<K, V>{\n+    LeafNode(Leaf<K, V>),\n+    BranchNode(Branch<K, V>)\n+}\n+\n+\n+//Node functions/methods\n+impl<K: Clone + TotalOrd, V: Clone> Node<K, V>{\n+\n+    ///Differentiates between leaf and branch nodes.\n+    fn is_leaf(&self) -> bool{\n+        match self{\n+            &LeafNode(*) => true,\n+            &BranchNode(*) => false\n+        }\n+    }\n+\n+    ///Creates a new leaf node given a vector of elements.\n+    fn new_leaf(vec: ~[LeafElt<K, V>]) -> Node<K,V>{\n+        LeafNode(Leaf::new(vec))\n+    }\n+\n+    ///Creates a new branch node given a vector of an elements and a pointer to a rightmost child.\n+    fn new_branch(vec: ~[BranchElt<K, V>], right: ~Node<K, V>) -> Node<K, V>{\n+        BranchNode(Branch::new(vec, right))\n+    }\n+\n+\n+    ///Returns the corresponding value to the provided key.\n+    ///get() is called in different ways on a branch or a leaf.\n+    fn get(&self, k: K) -> Option<V>{\n+        match *self{\n+            LeafNode(ref leaf) => return leaf.get(k),\n+            BranchNode(ref branch) => return branch.get(k)\n+        }\n+    }\n+\n+    ///A placeholder for add\n+    ///Currently returns a leaf node with a single value (the added one)\n+    fn add(self, k: K, v: V) -> Node<K, V>{\n+        return Node::new_leaf(~[LeafElt::new(k, v)]);\n+    }\n+}\n+\n+//Again, this might not be necessary in the future.\n+impl<K: Clone + TotalOrd, V: Clone> Clone for Node<K, V>{\n+\n+    ///Returns a new node based on whether or not it is a branch or a leaf.\n+    fn clone(&self) -> Node<K, V>{\n+        match *self{\n+            LeafNode(ref leaf) => return Node::new_leaf(leaf.elts.clone()),\n+            BranchNode(ref branch) => return Node::new_branch(branch.elts.clone(),\n+                                                              branch.rightmost_child.clone())\n+        }\n+    }\n+}\n+\n+//The following impl is unfinished.  Old iterations of code are left in for\n+//future reference when implementing this trait (commented-out).\n+impl<K: Clone + TotalOrd, V: Clone> TotalOrd for Node<K, V>{\n+\n+    ///Placeholder for an implementation of TotalOrd for Nodes.\n+    #[allow(unused_variable)]\n+    fn cmp(&self, other: &Node<K, V>) -> Ordering{\n+        //Requires a match statement--defer these procs to branch and leaf.\n+        /* if self.elts[0].less_than(other.elts[0]) { return Less}\n+        if self.elts[0].greater_than(other.elts[0]) {return Greater}\n+            else {return Equal}\n+         */\n+        return Equal;\n+    }\n+}\n+\n+//The following impl is unfinished.  Old iterations of code are left in for\n+//future reference when implementing this trait (commented-out).\n+impl<K: Clone + TotalOrd, V: Clone> TotalEq for Node<K, V>{\n+\n+    ///Placeholder for an implementation of TotalEq for Nodes.\n+    #[allow(unused_variable)]\n+    fn equals(&self, other: &Node<K, V>) -> bool{\n+        /* put in a match and defer this stuff to branch and leaf\n+\n+        let mut shorter = 0;\n+        if self.elts.len() <= other.elts.len(){\n+        shorter = self.elts.len();\n+    }\n+            else{\n+        shorter = other.elts.len();\n+    }\n+        let mut i = 0;\n+        while i < shorter{\n+        if !self.elts[i].has_key(other.elts[i].key){\n+        return false;\n+    }\n+        i +=1;\n+    }\n+        return true;\n+         */\n+        return true;\n+    }\n+}\n+\n+\n+impl<K: ToStr + TotalOrd, V: ToStr> ToStr for Node<K, V>{\n+    ///Returns a string representation of a Node.\n+    ///The Branch's to_str() is not implemented yet.\n+    fn to_str(&self) -> ~str{\n+        match *self{\n+            LeafNode(ref leaf) => leaf.to_str(),\n+            BranchNode(*) => ~\"\"\n+        }\n+    }\n+}\n+\n+\n+//A leaf is a vector with elements that contain no children.  A leaf also\n+//does not contain a rightmost child.\n+struct Leaf<K, V>{\n+    elts: ~[LeafElt<K, V>]\n+}\n+\n+//Vector of values with children, plus a rightmost child (greater than all)\n+struct Branch<K, V>{\n+    elts: ~[BranchElt<K,V>],\n+    rightmost_child: ~Node<K, V>\n+}\n+\n+\n+impl<K: Clone + TotalOrd, V: Clone> Leaf<K, V>{\n+\n+    ///Creates a new Leaf from a vector of LeafElts.\n+    fn new(vec: ~[LeafElt<K, V>]) -> Leaf<K, V>{\n+        Leaf{\n+            elts: vec\n+        }\n+    }\n+\n+    ///Returns the corresponding value to the supplied key.\n+    fn get(&self, k: K) -> Option<V>{\n+        for s in self.elts.iter(){\n+            let order = s.key.cmp(&k);\n+            match order{\n+                Equal => return Some(s.value.clone()),\n+                _ => {}\n+            }\n+        }\n+        return None;\n+    }\n+\n+    ///Placeholder for add method in progress.\n+    ///Currently returns a new Leaf containing a single LeafElt.\n+    fn add(&self, k: K, v: V) -> Node<K, V>{\n+        return Node::new_leaf(~[LeafElt::new(k, v)]);\n+    }\n+\n+}\n+\n+impl<K: ToStr + TotalOrd, V: ToStr> ToStr for Leaf<K, V>{\n+\n+    ///Returns a string representation of a Leaf.\n+    fn to_str(&self) -> ~str{\n+        let mut ret = ~\"\";\n+        for s in self.elts.iter(){\n+            ret = ret + \" // \" + s.to_str();\n+        }\n+        ret\n+    }\n+\n+}\n+\n+\n+impl<K: Clone + TotalOrd, V: Clone> Branch<K, V>{\n+\n+    ///Creates a new Branch from a vector of BranchElts and a rightmost child (a node).\n+    fn new(vec: ~[BranchElt<K, V>], right: ~Node<K, V>) -> Branch<K, V>{\n+        Branch{\n+            elts: vec,\n+            rightmost_child: right\n+        }\n+    }\n+\n+    ///Returns the corresponding value to the supplied key.\n+    ///If the key is not there, find the child that might hold it.\n+    fn get(&self, k: K) -> Option<V>{\n+        for s in self.elts.iter(){\n+            let order = s.key.cmp(&k);\n+            match order{\n+                Less => return s.left.get(k),\n+                Equal => return Some(s.value.clone()),\n+                _ => {}\n+            }\n+        }\n+        return self.rightmost_child.get(k);\n+    }\n+\n+\n+    ///Placeholder for add method in progress\n+    fn add(&self, k: K, v: V) -> Node<K, V>{\n+        return Node::new_leaf(~[LeafElt::new(k, v)]);\n+    }\n+}\n+\n+//A LeafElt containts no left child, but a key-value pair.\n+struct LeafElt<K, V>{\n+    key: K,\n+    value: V\n+}\n+\n+//A BranchElt has a left child in addition to a key-value pair.\n+struct BranchElt<K, V>{\n+    left: Node<K, V>,\n+    key: K,\n+    value: V\n+}\n+\n+impl<K: Clone + TotalOrd, V> LeafElt<K, V>{\n+\n+    ///Creates a new LeafElt from a supplied key-value pair.\n+    fn new(k: K, v: V) -> LeafElt<K, V>{\n+        LeafElt{\n+            key: k,\n+            value: v\n+        }\n+    }\n+\n+    ///Compares another LeafElt against itself and determines whether\n+    ///the original LeafElt's key is less than the other one's key.\n+    fn less_than(&self, other: LeafElt<K, V>) -> bool{\n+        let order = self.key.cmp(&other.key);\n+        match order{\n+            Less => true,\n+            _ => false\n+        }\n+    }\n+\n+    ///Compares another LeafElt against itself and determines whether\n+    ///the original LeafElt's key is greater than the other one's key.\n+    fn greater_than(&self, other: LeafElt<K, V>) -> bool{\n+        let order = self.key.cmp(&other.key);\n+        match order{\n+            Greater => true,\n+            _ => false\n+        }\n+    }\n+\n+    ///Takes a key and determines whether its own key and the supplied key\n+    ///are the same.\n+    fn has_key(&self, other: K) -> bool{\n+        let order = self.key.cmp(&other);\n+        match order{\n+            Equal => true,\n+            _ => false\n+        }\n+    }\n+\n+}\n+\n+//This may be eliminated in the future to perserve efficiency by adjusting the way\n+//the BTree as a whole is stored in memory.\n+impl<K: Clone + TotalOrd, V: Clone> Clone for LeafElt<K, V>{\n+\n+    ///Returns a new LeafElt by cloning the key and value.\n+    fn clone(&self) -> LeafElt<K, V>{\n+        return LeafElt::new(self.key.clone(), self.value.clone());\n+    }\n+}\n+\n+impl<K: ToStr + TotalOrd, V: ToStr> ToStr for LeafElt<K, V>{\n+\n+    ///Returns a string representation of a LeafElt.\n+    fn to_str(&self) -> ~str{\n+        return \"Key: \" + self.key.to_str() + \", value: \"+ self.value.to_str() + \"; \";\n+    }\n+\n+}\n+\n+impl<K: Clone + TotalOrd, V: Clone> BranchElt<K, V>{\n+\n+    ///Creates a new BranchElt from a supplied key, value, and left child.\n+    fn new(k: K, v: V, n: Node<K, V>) -> BranchElt<K, V>{\n+        BranchElt{\n+            left: n,\n+            key: k,\n+            value: v\n+        }\n+    }\n+\n+    ///Placeholder for add method in progress.\n+    ///Overall implementation will determine the actual return value of this method.\n+    fn add(&self, k: K, v: V) -> LeafElt<K, V>{\n+        return LeafElt::new(k, v);\n+    }\n+}\n+\n+impl<K: Clone + TotalOrd, V: Clone> Clone for BranchElt<K, V>{\n+\n+    ///Returns a new BranchElt by cloning the key, value, and left child.\n+    fn clone(&self) -> BranchElt<K, V>{\n+        return BranchElt::new(self.key.clone(), self.value.clone(), self.left.clone());\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test_btree{\n+\n+    use super::*;\n+\n+    ///Tests the functionality of the add methods (which are unfinished).\n+    #[test]\n+    fn add_test(){\n+        let b = BTree::new(1, ~\"abc\", 2);\n+        let is_add = b.add(2, ~\"xyz\");\n+        assert!(is_add);\n+    }\n+\n+    ///Tests the functionality of the get method.\n+    #[test]\n+    fn get_test(){\n+        let b = BTree::new(1, ~\"abc\", 2);\n+        let val = b.get(1);\n+        assert_eq!(val, Some(~\"abc\"));\n+    }\n+\n+    ///Tests the LeafElt's less_than() method.\n+    #[test]\n+    fn leaf_lt(){\n+        let l1 = LeafElt::new(1, ~\"abc\");\n+        let l2 = LeafElt::new(2, ~\"xyz\");\n+        assert!(l1.less_than(l2));\n+    }\n+\n+\n+    ///Tests the LeafElt's greater_than() method.\n+    #[test]\n+    fn leaf_gt(){\n+        let l1 = LeafElt::new(1, ~\"abc\");\n+        let l2 = LeafElt::new(2, ~\"xyz\");\n+        assert!(l2.greater_than(l1));\n+    }\n+\n+    ///Tests the LeafElt's has_key() method.\n+    #[test]\n+    fn leaf_hk(){\n+        let l1 = LeafElt::new(1, ~\"abc\");\n+        assert!(l1.has_key(1));\n+    }\n+}\n+"}, {"sha": "8bb996172743ab21769ba9eb7f62435757a80938", "filename": "src/libextra/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/57d1ed819b9e32a8e915ced9b5e130c299a46bca/src%2Flibextra%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57d1ed819b9e32a8e915ced9b5e130c299a46bca/src%2Flibextra%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Flib.rs?ref=57d1ed819b9e32a8e915ced9b5e130c299a46bca", "patch": "@@ -67,6 +67,7 @@ pub mod sort;\n \n pub mod dlist;\n pub mod treemap;\n+pub mod btree;\n \n // And ... other stuff\n "}]}